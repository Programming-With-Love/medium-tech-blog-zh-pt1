<html>
<head>
<title>Notify RecyclerView On a Specific Item Update</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在特定项目更新时通知RecyclerView</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/notifying-recyclerview-on-a-specific-change-b36e6dc59e0f?source=collection_archive---------0-----------------------#2019-03-12">https://medium.com/google-developer-experts/notifying-recyclerview-on-a-specific-change-b36e6dc59e0f?source=collection_archive---------0-----------------------#2019-03-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="c8c1" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">偶尔当使用<a class="ae iw" href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView" rel="noopener ugc nofollow" target="_blank"> <em class="ix"> RecyclerView </em> </a>时，我们希望能够通知特定的更新。我们想知道条目在列表中的位置，以及它的更新(插入、删除、更改)。也许关于这次更新我们想传递更多的信息。例如，更改的原因、原始屏幕或发生日期。</h2></div><p id="0806" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">知道了具体的变化，我们就可以调用<code class="du ju jv jw jx b">notifyItemAdded()</code>，而不是<code class="du ju jv jw jx b">notifyItemSetChanged()</code>，后者会遍历整个列表。</p><p id="d970" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">老实说，使用<a class="ae iw" href="https://proandroiddev.com/clean-easy-new-how-to-architect-your-app-part-5-list-update-afac69da0b5e" rel="noopener ugc nofollow" target="_blank"> <em class="jy">分页库</em>或者仅仅是<em class="jy"> DiffUtil </em> </a>，通常都可以实现这个功能，而且性能也非常好。然而，在某些情况下，它仍然是我们想要保存的多余工作。</p><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es jz"><img src="../Images/0dbf80467451796c40f203da61b1a7d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8s-VzNIcca2gZ3JNLseODw.jpeg"/></div></div></figure><h2 id="330e" class="kl km hh bd kn ko kp kq kr ks kt ku kv jh kw kx ky jl kz la lb jp lc ld le lf bi translated">如何通知列表中的更改？</h2><p id="d395" class="pw-post-body-paragraph iy iz hh ja b jb lg ii jd je lh il jg jh li jj jk jl lj jn jo jp lk jr js jt ha bi translated"><a class="ae iw" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank"> <em class="jy"> LiveData </em> </a>是观察和通知UI变化的一个很棒的工具。它包装一个对象，每当这个对象改变时，<em class="jy"> LiveData </em>通知它所有的观察者新的值。但是，如果我们在LiveData中包装一个项目列表，并且列表中的一个项目发生了变化，那么列表对象本身保持不变。也就是说，如果我们还想让观察者得到条目变化的通知——我们需要这么小的技巧来解决这个问题。</p><p id="3b16" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">此外，如前所述，我们希望保留一些关于变更的信息，并将其传递给观察者。我们应该怎样做呢？</p><p id="0b21" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">为了解决这个问题，这里有一个我用过几次的食谱:</p><p id="eda1" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">这个具体的例子是建立在我所做的一个例子之上的。它允许用户选择在通话过程中要执行的操作(文本到语音、录音等..)并使用Nexmo Voice API来执行它们。我在另一篇文章中写了更多关于它的内容<a class="ae iw" href="https://proandroiddev.com/moshi-polymorphic-adapter-is-d25deebbd7c5" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="412c" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">很明显，这只是一个演示项目，但这个想法在不止一个复杂的应用程序中对我很有用。</p><h2 id="8f81" class="kl km hh bd kn ko kp kq kr ks kt ku kv jh kw kx ky jl kz la lb jp lc ld le lf bi translated">设置表示层</h2><p id="7fdd" class="pw-post-body-paragraph iy iz hh ja b jb lg ii jd je lh il jg jh li jj jk jl lj jn jo jp lk jr js jt ha bi translated"><a class="ae iw" href="https://proandroiddev.com/clean-easy-new-how-to-architect-your-app-part-1-e439668a523d" rel="noopener ugc nofollow" target="_blank">在之前的帖子系列</a>中，我分享了构建应用程序时我喜欢应用的架构，包括<em class="jy">表示层</em>、<em class="jy">域层</em>和<em class="jy">数据层</em>。</p><p id="b84b" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">我的<em class="jy">展现</em>层持有一个<em class="jy"> UIModel </em>，它扩展了<a class="ae iw" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank"> <em class="jy"> ViewModel </em> </a>。它的作用是以最简单的方式向<em class="jy">表示</em>提供它需要的数据，这样就有尽可能少的计算和逻辑。</p><p id="ed5b" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">在这种情况下，<em class="jy"> UiModel </em>保持:</p><ul class=""><li id="e574" class="ll lm hh ja b jb jc je jf jh ln jl lo jp lp jt lq lr ls lt bi translated">要拨打的电话号码</li><li id="078a" class="ll lm hh ja b jb lu je lv jh lw jl lx jp ly jt lq lr ls lt bi translated">打电话的电话号码</li><li id="e013" class="ll lm hh ja b jb lu je lv jh lw jl lx jp ly jt lq lr ls lt bi translated">要执行的操作列表</li></ul><p id="0289" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">每当动作列表中有变化时，我们希望通知观察者，在本例中，通知UI和<em class="jy"> RecyclerView适配器</em>。</p><p id="7035" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">这是我的用户界面模型:</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="73f1" class="kl km hh jx b fi md me l mf mg">class CallRequestUiModel : ViewModel() {<br/>    lateinit var toPhone: String<br/>    lateinit var fromPhone: String<br/><strong class="jx hi">    val actions = ListLiveData&lt;NccoAction&gt;()</strong><br/>}</span></pre><h2 id="491f" class="kl km hh bd kn ko kp kq kr ks kt ku kv jh kw kx ky jl kz la lb jp lc ld le lf bi translated">什么是<strong class="ak"> ListLiveData </strong>？</h2><p id="78f3" class="pw-post-body-paragraph iy iz hh ja b jb lg ii jd je lh il jg jh li jj jk jl lj jn jo jp lk jr js jt ha bi translated">如前所述，我们需要向<em class="jy"> LiveData </em>添加更多的信息和逻辑。所以，我延长了。</p><p id="0f7d" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">首先，它包装了一个类型为<strong class="ja hi"> <em class="jy"> ListHolder </em> </strong>的值，以保存我们需要的所有信息，而不仅仅是条目列表:</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="fb96" class="kl km hh jx b fi md me l mf mg">class ListLiveData&lt;T&gt; : LiveData&lt;<strong class="jx hi">ListHolder</strong>&lt;T&gt;&gt;() {</span><span id="e46e" class="kl km hh jx b fi mh me l mf mg">}</span></pre><p id="342a" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">在这种情况下，<strong class="ja hi"> ListHolder </strong>保存项目列表、已更改项目的索引以及更新的类型:</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="9363" class="kl km hh jx b fi md me l mf mg">data class <strong class="jx hi">ListHolder</strong>&lt;T&gt;(val list: MutableList&lt;T&gt; = <em class="jy">mutableListOf</em>()) {<br/>    var indexChanged: Int = -1<br/>    var updateType: <strong class="jx hi">UpdateType</strong>? = null<br/>}</span></pre><p id="d819" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><strong class="ja hi"> <em class="jy"> UpdateType </em> </strong>是我创建的一个枚举，它匹配RecyclerView可以做的更改，因此我们能够通知特定的更改:</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="399b" class="kl km hh jx b fi md me l mf mg">private enum class UpdateType {<br/>    INSERT, REMOVE, CHANGE<br/>}</span></pre><p id="9bbf" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">由于<strong class="ja hi"> UpdateType </strong>的工作将是确定我们要在适配器上调用哪个方法，我使用了很酷的Kotlin特性，它允许你<a class="ae iw" href="https://kotlinlang.org/docs/reference/enum-classes.html#implementing-interfaces-in-enum-classes" rel="noopener ugc nofollow" target="_blank">使用枚举</a>实现接口。</p><p id="cd58" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><strong class="ja hi">注</strong>:这是我喜欢Kotlin的一个特性。<strong class="ja hi">但是</strong>！确保不要滥用它。对我来说，重要的是不要混淆架构层。因为在这种情况下，ListHolder(它拥有UpdateType)和它所做的动作(通知适配器)都属于<em class="jy">表示层</em>我很乐意这样实现它。例如，如果一个属于UI的枚举将实现使用数据层的方法，我就不太推荐它。</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="bcfc" class="kl km hh jx b fi md me l mf mg">private enum class <strong class="jx hi">UpdateType</strong> {</span><span id="c73c" class="kl km hh jx b fi mh me l mf mg">   abstract fun <strong class="jx hi">notifyChange</strong>(<br/>        adapter: RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;,<br/>        indexChanged: Int<br/>    )</span><span id="10a3" class="kl km hh jx b fi mh me l mf mg">    <strong class="jx hi">INSERT</strong> {<br/>        override fun <strong class="jx hi">notifyChange</strong>(<br/>            adapter: RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;,<br/>            indexChanged: Int) = adapter.notifyItemInserted(indexChanged)<br/>    },<br/>   <br/>  <strong class="jx hi">REMOVE</strong> {<br/>        override fun <strong class="jx hi">notifyChange</strong>(<br/>            adapter: RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;,<br/>            indexChanged: Int) = adapter.notifyItemRemoved(indexChanged)<br/>    },</span><span id="2352" class="kl km hh jx b fi mh me l mf mg">    <strong class="jx hi">CHANGE</strong> {<br/>        override fun <strong class="jx hi">notifyChange</strong>(<br/>            adapter: RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;,<br/>            indexChanged: Int) = adapter.notifyItemChanged(indexChanged)<br/>    };<br/><br/>}</span></pre><p id="e650" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">这个枚举是私有的，有助于我上面提到的层的分离。这样，只有<strong class="ja hi">列表持有人</strong>(即已更改的项目)能够应用它:</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="5913" class="kl km hh jx b fi md me l mf mg">data class <strong class="jx hi">ListHolder</strong>&lt;T&gt;(val list: MutableList&lt;T&gt; = <em class="jy">mutableListOf</em>()) {<br/>    var indexChanged: Int = -1<br/>    private var updateType: UpdateType? = null<br/><br/>//...<br/><br/>    fun <strong class="jx hi">applyChange</strong>(adapter: RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;) {<br/><strong class="jx hi">        updateType?.notifyChange(adapter, indexChanged)<br/></strong>    }</span></pre><h2 id="36bb" class="kl km hh bd kn ko kp kq kr ks kt ku kv jh kw kx ky jl kz la lb jp lc ld le lf bi translated">通知观察者变化</h2><p id="4822" class="pw-post-body-paragraph iy iz hh ja b jb lg ii jd je lh il jg jh li jj jk jl lj jn jo jp lk jr js jt ha bi translated">在我的MainActivity.onCreate()中(这是我的<em class="jy">表示</em>层组件的起点)，我要求观察动作列表中的变化:</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="ae56" class="kl km hh jx b fi md me l mf mg">uiModel.actions.observe(this, this)</span></pre><p id="eced" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">举个简单的例子，我的<em class="jy"> MainActivity </em>也实现了<em class="jy"> Observer </em>，因此覆盖了<em class="jy"> onChanged() </em>。每当<em class="jy"> actions </em>中的一个项目更新时，我们只需要请求<em class="jy">LiveData</em>(<em class="jy">list holder</em>)的新值来应用适配器上的更改。值<em class="jy"> ListHolder，</em>已经知道被更新的确切项目，以及在适配器上应用什么:</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="6413" class="kl km hh jx b fi md me l mf mg">override fun <strong class="jx hi">onChanged</strong>(value: ListHolder&lt;NccoAction&gt;?) {<br/>    list.<em class="jy">adapter</em>?.<em class="jy">let </em><strong class="jx hi">{<br/>        </strong>value?.applyChange(<strong class="jx hi">it</strong>)<br/>    <strong class="jx hi">}<br/></strong>}</span></pre><h2 id="e5ef" class="kl km hh bd kn ko kp kq kr ks kt ku kv jh kw kx ky jl kz la lb jp lc ld le lf bi translated">更新一个项目看起来像什么？</h2><p id="695a" class="pw-post-body-paragraph iy iz hh ja b jb lg ii jd je lh il jg jh li jj jk jl lj jn jo jp lk jr js jt ha bi translated">UI可以调用<em class="jy"> addItem()、removeItemAt()或setItem()，</em>实际上是传递给<em class="jy"> ListLiveData </em>处理的:</p><p id="be82" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">例如，用户界面调用:</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="270a" class="kl km hh jx b fi md me l mf mg">fun <strong class="jx hi">addAction</strong>(action: NccoAction) {<br/>    uiModel.actions.addItem(action)<br/>}</span></pre><p id="3fa6" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><strong class="ja hi"> <em class="jy"> ListHolder </em> </strong>将执行更新的请求传递给<strong class="ja hi"> <em class="jy"> ListHolder </em> </strong>，然后通知观察者(此处为UI)更新。</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="a595" class="kl km hh jx b fi md me l mf mg">class ListLiveData&lt;T&gt; : LiveData&lt;ListHolder&lt;T&gt;&gt;() {<br/><br/>    //...<br/><br/>    fun addItem(item: T, position: Int = <em class="jy">value</em>?.size() ?: 0) {<br/>        <em class="jy">value</em>?.addItem(position, item)<br/>        <em class="jy">value </em>= <em class="jy">value<br/><br/>    </em>}<br/><br/>    fun removeItemAt(position: Int) {<br/>        <em class="jy">value</em>?.removeItemAt(position)<br/>        <em class="jy">value </em>= <em class="jy">value<br/>    </em>}<br/><br/><br/>    fun setItem(position: Int, item: T) {<br/>        <em class="jy">value</em>?.setItem(position, item)<br/>        <em class="jy">value </em>= <em class="jy">value<br/>    </em>}<br/><br/><br/>}</span></pre><h2 id="a121" class="kl km hh bd kn ko kp kq kr ks kt ku kv jh kw kx ky jl kz la lb jp lc ld le lf bi translated">为什么价值=价值？</h2><p id="2936" class="pw-post-body-paragraph iy iz hh ja b jb lg ii jd je lh il jg jh li jj jk jl lj jn jo jp lk jr js jt ha bi translated">可能有一种更优雅的方式来做到这一点🤷‍♀ ️如前所述，因为我不更新值本身(ListHolder对象)，而只更新它的内容，所以更新不会作为值的变化发送给观察者。<em class="jy"> LiveData </em>只有在<em class="jy"> setValue() </em>被调用时才会将变更发送给观察者。所以我通过使用具有相同值的setValue()来欺骗它😬</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="50f3" class="kl km hh jx b fi md me l mf mg">From source code of LiveData.java</span><span id="19bc" class="kl km hh jx b fi mh me l mf mg">@MainThread<br/>protected void setValue(T value) {<br/>    <em class="jy">assertMainThread</em>("setValue");<br/>    mVersion++;<br/>    mData = value;<br/>    dispatchingValue(null);<br/>}</span></pre><p id="d0cd" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">关于<em class="jy"> ListLiveData的另一个说明:</em></p><p id="3f46" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">为了方便起见，为了使它表现得更list一List，我实现了2个方法:</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="ab46" class="kl km hh jx b fi md me l mf mg">class ListLiveData&lt;T&gt; : LiveData&lt;ListHolder&lt;T&gt;&gt;() {<br/><br/>    val <strong class="jx hi">size</strong>: Int get() {<br/>            return <em class="jy">value</em>?.size() ?: -1<br/>    }</span><span id="8e5b" class="kl km hh jx b fi mh me l mf mg">    <strong class="jx hi">operator</strong> fun <strong class="jx hi">get(position: Int)</strong>: T? {<br/>        return <em class="jy">value</em>?.list?.get(position)<br/>    }<br/><br/>}</span></pre><p id="4162" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">例如，<code class="du ju jv jw jx b"><strong class="ja hi">size():</strong></code>用于<em class="jy"> Adapter.getItemCount() </em></p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="3e3c" class="kl km hh jx b fi md me l mf mg">override fun getItemCount(): Int {<br/>    return actions.size<br/>}</span></pre><p id="633e" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><code class="du ju jv jw jx b"><strong class="ja hi">operator fun get()</strong></code>是从列表中获取一个特定的项目，例如在<em class="jy">adapter . onbindviewholder():</em>上</p><pre class="ka kb kc kd fd lz jx ma mb aw mc bi"><span id="4e88" class="kl km hh jx b fi md me l mf mg">override fun onBindViewHolder(holder: NccoCompVH, index: Int) {<br/>    actions[index]?.<em class="jy">let </em><strong class="jx hi">{ </strong>holder.bind(<strong class="jx hi">it</strong>) <strong class="jx hi">}<br/></strong>}</span></pre><h1 id="6704" class="mi km hh bd kn mj mk ml kr mm mn mo kv in mp io ky iq mq ir lb it mr iu le ms bi translated">让我们看看整个流程</h1><figure class="ka kb kc kd fd ke er es paragraph-image"><div role="button" tabindex="0" class="kf kg di kh bf ki"><div class="er es mt"><img src="../Images/85f7dd50bf33dfc0664c5a246773c6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*afd3onTvWuxsqrDT8sP5Pw.gif"/></div></div></figure><ol class=""><li id="a9ec" class="ll lm hh ja b jb jc je jf jh ln jl lo jp lp jt mu lr ls lt bi translated"><em class="jy"> UI </em>要求<em class="jy"> ListLiveData </em>更新列表项→</li><li id="c920" class="ll lm hh ja b jb lu je lv jh lw jl lx jp ly jt mu lr ls lt bi translated"><em class="jy">列表直播数据</em>要求<em class="jy">列表持有者</em>保存更新信息→</li><li id="49e1" class="ll lm hh ja b jb lu je lv jh lw jl lx jp ly jt mu lr ls lt bi translated"><em class="jy"> ListLiveData </em>设置其值，并将更改发送给<em class="jy">观察器</em></li><li id="c23c" class="ll lm hh ja b jb lu je lv jh lw jl lx jp ly jt mu lr ls lt bi translated"><em class="jy">观察者</em> (UI) <em class="jy"> onChange() </em>用新值调用，该值在类型<em class="jy">列表框</em>上</li><li id="df21" class="ll lm hh ja b jb lu je lv jh lw jl lx jp ly jt mu lr ls lt bi translated"><em class="jy"> UI </em>要求新值<em class="jy">list holder</em>应用其保存的数据的更新</li><li id="9762" class="ll lm hh ja b jb lu je lv jh lw jl lx jp ly jt mu lr ls lt bi translated"><em class="jy"> UpdateType，</em>包含在<em class="jy"> ListHolder </em>中，通知适配器更新</li><li id="7cb2" class="ll lm hh ja b jb lu je lv jh lw jl lx jp ly jt mu lr ls lt bi translated">适配器应用特定的项目更新(你也可以传递更多的信息，做任何你想做的事情！)</li><li id="7afd" class="ll lm hh ja b jb lu je lv jh lw jl lx jp ly jt mu lr ls lt bi translated">大家都很开心！！</li></ol><h1 id="2541" class="mi km hh bd kn mj mk ml kr mm mn mo kv in mp io ky iq mq ir lb it mr iu le ms bi translated">就是这样！</h1><p id="2655" class="pw-post-body-paragraph iy iz hh ja b jb lg ii jd je lh il jg jh li jj jk jl lj jn jo jp lk jr js jt ha bi translated">就这些，希望有帮助:)</p><p id="5467" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">这里是Github上这个例子的代码</p><p id="68c8" class="pw-post-body-paragraph iy iz hh ja b jb jc ii jd je jf il jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">编码快乐！感谢您的阅读。<a class="ae iw" href="https://twitter.com/BrittBarak" rel="noopener ugc nofollow" target="_blank">此处(上<em class="jy">推特</em>其实)</a>提问🙌🙏😍✌</p></div></div>    
</body>
</html>