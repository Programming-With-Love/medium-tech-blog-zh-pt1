<html>
<head>
<title>Multiple back stacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多个后堆栈</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/multiple-back-stacks-b714d974f134?source=collection_archive---------0-----------------------#2021-06-07">https://medium.com/androiddevelopers/multiple-back-stacks-b714d974f134?source=collection_archive---------0-----------------------#2021-06-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f2832eae5247e9b8824b86463748948c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-lbc-YBJlZnxVFPvNMPAQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="bd93" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">深入探究这一特性的真正内涵</h2></div><p id="e731" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果“back stack”是一组屏幕，你可以通过系统的back按钮向后导航，“multiple back stacks”就是一堆这样的屏幕，对吗？嗯，这正是我们在<a class="ae kd" href="https://developer.android.com/jetpack/androidx/releases/navigation#2.4.0-alpha01" rel="noopener ugc nofollow" target="_blank">导航2.4.0-alpha01 </a>和<a class="ae kd" href="https://developer.android.com/jetpack/androidx/releases/fragment#1.4.0-alpha01" rel="noopener ugc nofollow" target="_blank">片段1.4.0-alpha01 </a>中添加的多back stack支持所做的！</p><h1 id="9762" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">系统后退按钮的乐趣</h1><p id="ccd4" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">无论你使用的是Android新的手势导航系统还是传统的导航栏，用户返回的能力是Android用户体验的一个关键部分，正确地做到这一点是让你的应用程序感觉像生态系统的一个自然部分的重要部分。</p><p id="32c8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在最简单的情况下，系统后退按钮只是完成您的活动。虽然在过去，您可能会试图覆盖活动的<code class="du lb lc ld le b">onBackPressed()</code>方法来定制这种行为，但现在是2021年，这完全没有必要。相反，在<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/androidx/activity/OnBackPressedDispatcher" rel="noopener ugc nofollow" target="_blank">OnBackPressedDispatcher</a></code>中有<a class="ae kd" href="https://developer.android.com/guide/navigation/navigation-custom-back" rel="noopener ugc nofollow" target="_blank">API用于定制向后导航</a>。这实际上是<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/androidx/fragment/app/FragmentManager" rel="noopener ugc nofollow" target="_blank">FragmentManager</a></code>和<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/kotlin/androidx/navigation/NavController" rel="noopener ugc nofollow" target="_blank">NavController</a></code>已经插入的同一个API。</p><p id="f1d5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这意味着当你使用片段或导航时，他们使用<code class="du lb lc ld le b">OnBackPressedDispatcher</code>来确保如果你使用他们的后台堆栈API，系统的后退按钮可以反转你推到后台堆栈上的每一个屏幕。</p><p id="d52b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">多个后堆栈不会改变这些基本原则。系统返回按钮仍然是一个单向命令——“返回”。这对多后台堆栈API的工作方式有着深远的影响。</p><h1 id="a94d" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">碎片中的多个背面堆栈</h1><p id="7512" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">从表面上来看，<a class="ae kd" href="https://developer.android.com/guide/fragments/fragmentmanager#multiple-back-stacks" rel="noopener ugc nofollow" target="_blank">对多后台栈</a>的支持看似简单，但需要解释一下什么是“片段后台栈”。<code class="du lb lc ld le b">FragmentManager</code>的后台堆栈不是由片段组成的，而是由片段事务组成的。特别是那些使用过<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/androidx/fragment/app/FragmentTransaction#addToBackStack(java.lang.String)" rel="noopener ugc nofollow" target="_blank">addToBackStack(String name)</a></code> API的。</p><p id="a042" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这意味着当你用<code class="du lb lc ld le b">addToBackStack()</code>来<code class="du lb lc ld le b">commit()</code>一个片段事务时，<code class="du lb lc ld le b">FragmentManager</code>将通过遍历和执行每个操作(T5)来执行事务。)，从而将每个片段移动到其预期的状态。然后将该事务作为其后台堆栈的一部分保存起来。</p><p id="9473" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当您调用<code class="du lb lc ld le b">popBackStack()</code>(直接调用或者通过<code class="du lb lc ld le b">FragmentManager</code>与系统返回按钮的集成调用)时，片段返回堆栈中最顶层的事务被反转——一个添加的片段被移除，一个隐藏的片段被显示，等等。这使<code class="du lb lc ld le b">FragmentManager</code>回到片段事务最初提交之前的状态。</p><blockquote class="lf lg lh"><p id="3125" class="jh ji li jj b jk jl it jm jn jo iw jp lj jr js jt lk jv jw jx ll jz ka kb kc ha bi translated"><strong class="jj ht">注意</strong>:我再怎么强调这一点也不为过，但是你绝对不应该用<code class="du lb lc ld le b">addToBackStack()</code>和不在同一个<code class="du lb lc ld le b">FragmentManager</code>中的事务来交错事务:你的后台堆栈上的事务并不知道非后台堆栈正在改变片段事务——当你提出一个更冒险的提议时，从那些事务下面交换东西会产生相反的结果。</p></blockquote><p id="ffdb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这意味着<code class="du lb lc ld le b">popBackStack()</code>是一个破坏性的操作:当事务被弹出时，任何添加的片段的状态都会被破坏。这意味着您将丢失视图状态，任何保存的实例状态，以及您附加到该片段的任何<code class="du lb lc ld le b">ViewModel</code>实例都将被清除。这是API和新的<code class="du lb lc ld le b">saveBackStack()</code>的主要区别。<code class="du lb lc ld le b">saveBackStack()</code>执行与弹出事务相同的反转，但是它确保视图状态、保存的实例状态和<code class="du lb lc ld le b">ViewModel</code>实例都被保存下来，不会被销毁。这就是<code class="du lb lc ld le b">restoreBackStack()</code> API如何在以后从保存的状态中重新创建那些事务及其片段，并有效地“重做”保存的所有内容。神奇！</p><p id="6c35" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">不过，这并不是在没有偿还大量技术债务的情况下实现的。</p><h1 id="ce04" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">分期偿还我们的技术债务</h1><p id="a158" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">虽然片段总是保存<a class="ae kd" href="https://developer.android.com/guide/fragments/saving-state#view" rel="noopener ugc nofollow" target="_blank">片段的视图状态</a>，但是只有当活动的<code class="du lb lc ld le b">onSaveInstanceState()</code>被调用时，片段的<code class="du lb lc ld le b">onSaveInstanceState()</code>才会被调用。为了确保在调用<code class="du lb lc ld le b">saveBackStack()</code>时保存实例状态，我们需要<strong class="jj ht">也在<a class="ae kd" href="https://developer.android.com/guide/fragments/lifecycle#states" rel="noopener ugc nofollow" target="_blank">片段生命周期转换</a>的正确点</strong>注入对<code class="du lb lc ld le b">onSaveInstanceState()</code>的调用。我们不能过早调用它(当它还在<code class="du lb lc ld le b">STARTED</code>的时候，你的片段不应该保存它的状态)，但是也不能太晚(你想在片段被销毁之前保存状态)。</p><p id="7246" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这个需求启动了一个过程来<a class="ae kd" href="https://issuetracker.google.com/139536619" rel="noopener ugc nofollow" target="_blank">修复</a> <code class="du lb lc ld le b"><a class="ae kd" href="https://issuetracker.google.com/139536619" rel="noopener ugc nofollow" target="_blank">FragmentManager</a></code> <a class="ae kd" href="https://issuetracker.google.com/139536619" rel="noopener ugc nofollow" target="_blank">如何移动到状态</a>，以确保有一个地方管理将片段移动到其预期状态，并处理重入行为和进入片段的所有状态转换。</p><p id="aaec" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">35个变更和6个月的片段重组，结果是<a class="ae kd" href="https://issuetracker.google.com/147749580" rel="noopener ugc nofollow" target="_blank">延迟的片段被严重破坏</a>，导致延迟的事务被留在中间——没有实际提交，也没有实际未提交。经过65次修改，又过了5个月，我们已经完全重写了<code class="du lb lc ld le b">FragmentManager</code>如何管理状态、延迟转换和动画的大部分内部内容。在我之前的博客文章中有更详细的介绍:</p><div class="hg hh ez fb hi lm"><a rel="noopener follow" target="_blank" href="/androiddevelopers/fragments-rebuilding-the-internals-61913f8bf48e"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd ht fi z dy lr ea eb ls ed ef hr bi translated">片段:重建内部</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">介绍:新的状态管理器</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">medium.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma ho lm"/></div></div></a></div><h1 id="1e19" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">碎片中期待什么</h1><p id="30f6" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">随着技术债务的偿还(和一个更可靠、更容易理解的<code class="du lb lc ld le b">FragmentManager</code>)，添加了<code class="du lb lc ld le b">saveBackStack()</code>和<code class="du lb lc ld le b">restoreBackStack()</code>的冰山一角API。</p><p id="06e0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你不使用这些新的API，什么都不会改变:单个<code class="du lb lc ld le b">FragmentManager</code>后台栈和以前一样工作。现有的<code class="du lb lc ld le b">addToBackStack()</code> API保持不变——您可以使用空的<code class="du lb lc ld le b">name</code>或任何您想要的<code class="du lb lc ld le b">name</code>。然而，当您开始查看多个back stacks时，这个<code class="du lb lc ld le b">name</code>就有了新的重要性:这个名称是您将在<code class="du lb lc ld le b">saveBackStack()</code>和<code class="du lb lc ld le b">restoreBackStack()</code>中使用的片段事务的惟一键。</p><p id="aed3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这在示例中可能更容易看到。假设您已经向活动添加了一个初始片段，然后完成了两个事务，每个事务都有一个<code class="du lb lc ld le b">replace</code>操作:</p><pre class="mb mc md me fd mf le mg mh aw mi bi"><span id="de20" class="mj kf hs le b fi mk ml l mm mn">// This is the initial fragment the user sees<br/>fragmentManager.commit {<br/>  setReorderingAllowed(true)<br/>  replace&lt;HomeFragment&gt;(R.id.fragment_container)<br/>}</span><span id="3119" class="mj kf hs le b fi mo ml l mm mn">// Later, in response to user actions, we’ve added two more<br/>// transactions to the back stack<br/>fragmentManager.commit {<br/>  setReorderingAllowed(true)<br/>  replace&lt;ProfileFragment&gt;(R.id.fragment_container)<br/>  addToBackStack(“profile”)<br/>}</span><span id="ae52" class="mj kf hs le b fi mo ml l mm mn">fragmentManager.commit {<br/>  setReorderingAllowed(true)<br/>  replace&lt;EditProfileFragment&gt;(R.id.fragment_container)<br/>  addToBackStack(“edit_profile”)<br/>}</span></pre><p id="6ecf" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这意味着我们的<code class="du lb lc ld le b">FragmentManager</code>看起来像:</p><figure class="mb mc md me fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mp"><img src="../Images/e02c183f71b46f8f60e95ece17c4af3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYX8n8VUsWPKxzRQTGx0zg.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx">FragmentManager state after three commits</figcaption></figure><p id="8a76" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">假设我们想换出我们的概要文件回栈，并换到通知片段。我们将调用<code class="du lb lc ld le b">saveBackStack()</code>,后跟一个新事务:</p><pre class="mb mc md me fd mf le mg mh aw mi bi"><span id="ebdc" class="mj kf hs le b fi mk ml l mm mn">fragmentManager.saveBackStack("profile")</span><span id="9673" class="mj kf hs le b fi mo ml l mm mn">fragmentManager.commit {<br/>  setReorderingAllowed(true)<br/>  replace&lt;NotificationsFragment&gt;(R.id.fragment_container)<br/>  addToBackStack("notifications")<br/>}</span></pre><p id="b9f1" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在我们添加了<code class="du lb lc ld le b">ProfileFragment</code>的交易和添加了<code class="du lb lc ld le b">EditProfileFragment</code>的交易已经保存在<code class="du lb lc ld le b">"profile"<br/></code>键下。那些片段已经完全保存了它们的状态，并且<code class="du lb lc ld le b">FragmentManager</code>正在保持它们的状态以及事务状态。重要的是:那些片段实例不再存在于内存或<code class="du lb lc ld le b">FragmentManager</code>中——它只是状态(以及以<code class="du lb lc ld le b">ViewModel</code>实例形式的任何非配置状态):</p><figure class="mb mc md me fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mp"><img src="../Images/a9b46183c6b4729e90107a89b16f7ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cG_ot3MkNMb--5BVvrIoCQ.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx">FragmentManager state after we’ve saved the profile back stack and added one more commit</figcaption></figure><p id="e621" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">交换回来非常简单:我们可以对我们的<code class="du lb lc ld le b">"notifications"</code>事务和<code class="du lb lc ld le b">restoreBackStack()</code>事务进行同样的<code class="du lb lc ld le b">saveBackStack()</code>操作:</p><pre class="mb mc md me fd mf le mg mh aw mi bi"><span id="60bb" class="mj kf hs le b fi mk ml l mm mn">fragmentManager.saveBackStack(“notifications”)</span><span id="55d8" class="mj kf hs le b fi mo ml l mm mn">fragmentManager.restoreBackStack(“profile”)</span></pre><p id="8c21" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这两个堆栈实际上交换了位置:</p><figure class="mb mc md me fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mp"><img src="../Images/512a8df03eacf88514945861b9b2fd38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xr1O7MJNWzWPO9uK88IdRA.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx">FragmentManager state after swapping the two stacks</figcaption></figure><p id="1d93" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这种维护单个活动后台堆栈并在其上交换事务的方式确保了<code class="du lb lc ld le b">FragmentManager</code>和系统的其余部分总是对点击系统后退按钮时实际应该发生的事情有一致的看法。事实上，这种逻辑完全没有改变:它仍然像以前一样从片段堆栈中弹出最后一个事务。</p><p id="42d9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这些API是有意最小化的，尽管它们有潜在的影响。这使得在这些构建块之上构建您自己的结构成为可能，同时避免任何保存片段视图状态、保存的实例状态和非配置状态的攻击。</p><p id="f382" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当然，如果你不想在这些API之上构建你自己的结构，你也可以使用我们提供的那个。</p><h1 id="6ade" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">通过导航将多个back stacks带到任何屏幕类型</h1><p id="f2d6" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated"><a class="ae kd" href="https://developer.android.com/guide/navigation/" rel="noopener ugc nofollow" target="_blank">导航组件</a>从一开始<strong class="jj ht">就被构建为一个通用运行时，它对视图、片段、可组合组件或者任何其他类型的屏幕或者你可能在活动中实现的‘目的地’一无所知。相反，<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/kotlin/androidx/navigation/NavHost" rel="noopener ugc nofollow" target="_blank">NavHost</a></code> <a class="ae kd" href="https://developer.android.com/reference/kotlin/androidx/navigation/NavHost" rel="noopener ugc nofollow" target="_blank">接口</a>的一个实现负责添加一个或多个<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/kotlin/androidx/navigation/Navigator" rel="noopener ugc nofollow" target="_blank">Navigator</a></code>实例，使<strong class="jj ht">知道如何与特定类型的目的地交互。</strong></strong></p><p id="228a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这意味着与片段交互的逻辑完全封装在<code class="du lb lc ld le b">navigation-fragment</code>工件及其<code class="du lb lc ld le b">FragmentNavigator</code>和<code class="du lb lc ld le b">DialogFragmentNavigator</code>中。类似地，与Composables交互的逻辑在完全独立的<code class="du lb lc ld le b">navigation-compose</code>工件及其<code class="du lb lc ld le b">ComposeNavigator</code>中。这种抽象意味着，如果你想单独用Composables来构建你的应用程序，当你使用导航组合时，你不会被迫加入任何对片段的依赖。</p><p id="8e49" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这种级别的分离意味着导航中实际上有两层到多个后台堆栈:</p><ul class=""><li id="2a58" class="mu mv hs jj b jk jl jn jo jq mw ju mx jy my kc mz na nb nc bi translated">保存组成<code class="du lb lc ld le b">NavController</code>后台堆栈的各个<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/kotlin/androidx/navigation/NavBackStackEntry" rel="noopener ugc nofollow" target="_blank">NavBackStackEntry</a></code>实例的状态。这是<code class="du lb lc ld le b">NavController</code>的责任。</li><li id="cca8" class="mu mv hs jj b jk nd jn ne jq nf ju ng jy nh kc mz na nb nc bi translated">保存与每个<code class="du lb lc ld le b">NavBackStackEntry</code>相关联的任何<code class="du lb lc ld le b">Navigator</code>特定状态(例如，与<code class="du lb lc ld le b">FragmentNavigator</code>目的地相关联的片段)。这是<code class="du lb lc ld le b">Navigator</code>的责任。</li></ul><p id="baae" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">特别注意<code class="du lb lc ld le b">Navigator</code>没有<strong class="jj ht">更新以支持保存其状态的情况。虽然底层的<code class="du lb lc ld le b">Navigator</code> API被完全重写以支持保存状态(您应该覆盖它的<code class="du lb lc ld le b">navigate()</code>和<code class="du lb lc ld le b">popBackStack()</code>API的新重载，而不是以前的版本)，但是即使<code class="du lb lc ld le b">Navigator</code>没有更新，<code class="du lb lc ld le b">NavController</code>也会保存<code class="du lb lc ld le b">NavBackStackEntry</code>状态(向后兼容性在Jetpack世界中是一件大事！).</strong></p><blockquote class="lf lg lh"><p id="5cd0" class="jh ji li jj b jk jl it jm jn jo iw jp lj jr js jt lk jv jw jx ll jz ka kb kc ha bi translated">PS:这个新的<code class="du lb lc ld le b">Navigator</code> API还通过附加一个充当迷你<code class="du lb lc ld le b">NavController</code>的<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/kotlin/androidx/navigation/testing/TestNavigatorState" rel="noopener ugc nofollow" target="_blank">TestNavigatorState</a></code>来使测试你自己的定制<code class="du lb lc ld le b">Navigator</code>更加容易。</p></blockquote><p id="ae7e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你只是在你的应用中使用导航，那么<code class="du lb lc ld le b">Navigator</code>层更多的是一个实现细节，而不是你需要直接交互的东西。简单地说，我们已经完成了将<code class="du lb lc ld le b">FragmentNavigator</code>和<code class="du lb lc ld le b">ComposeNavigator</code>转移到新的<code class="du lb lc ld le b">Navigator</code>API所需的工作，这样它们就可以正确地保存和恢复它们的状态；在那个层次上你不需要做任何工作。</p><h1 id="bd9c" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">在导航中启用多个后台堆栈</h1><p id="eb03" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">如果你正在使用<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/guide/navigation/navigation-ui" rel="noopener ugc nofollow" target="_blank">NavigationUI</a></code>，我们的一组固执己见的助手来连接你的<code class="du lb lc ld le b">NavController</code>到材质视图组件，你会发现默认情况下<strong class="jj ht">为菜单项</strong>，<code class="du lb lc ld le b">BottomNavigationView</code>(现在是<code class="du lb lc ld le b">NavigationRailView</code>！)，还有<code class="du lb lc ld le b">NavigationView</code>。这意味着使用<code class="du lb lc ld le b">navigation-fragment</code>和<code class="du lb lc ld le b">navigation-ui</code>的常见组合<em class="li">将只工作</em>。</p><p id="c602" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du lb lc ld le b">NavigationUI</code>API是有目的地构建在导航中可用的其他公共API之上的，确保您可以为您想要的定制组件精确地构建自己的版本。支持保存和恢复后台堆栈的API也不例外，导航XML中的<code class="du lb lc ld le b">NavOptions</code>、<code class="du lb lc ld le b">navOptions</code> Kotlin DSL以及<code class="du lb lc ld le b">popBackStack()</code>的重载中的新API允许您指定是希望pop操作保存状态，还是希望navigate操作恢复一些以前保存的状态。</p><p id="5881" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">例如，在Compose中，任何全局导航模式(无论是底部导航条、导航条、抽屉，还是你能想到的任何东西)都可以使用与我们展示的<a class="ae kd" href="https://developer.android.com/jetpack/compose/navigation#bottom-nav" rel="noopener ugc nofollow" target="_blank">集成底部导航</a>相同的技术，并用<code class="du lb lc ld le b">saveState</code>和<code class="du lb lc ld le b">restoreState</code>属性调用<code class="du lb lc ld le b">navigate()</code>:</p><pre class="mb mc md me fd mf le mg mh aw mi bi"><span id="9bd8" class="mj kf hs le b fi mk ml l mm mn">onClick = {<br/>  navController.navigate(screen.route) {<br/>    // Pop up to the start destination of the graph to<br/>    // avoid building up a large stack of destinations<br/>    // on the back stack as users select items<br/>    popUpTo(navController.graph.findStartDestination().id) {<br/>      saveState = true<br/>    }<br/><br/>    // Avoid multiple copies of the same destination when<br/>    // reselecting the same item<br/>    launchSingleTop = true</span><span id="d24c" class="mj kf hs le b fi mo ml l mm mn">    // Restore state when reselecting a previously selected item<br/>    restoreState = true<br/>  }<br/>}</span></pre><h1 id="1f26" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">保存您的状态，保存您的用户</h1><p id="09ed" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">对用户来说，最令人沮丧的事情之一就是丢失他们的状态。这就是为什么片段在<a class="ae kd" href="https://developer.android.com/guide/fragments/saving-state" rel="noopener ugc nofollow" target="_blank">保存状态</a>上有一整页的原因之一，也是为什么我很高兴更新每一层以支持多个后台堆栈的原因之一:</p><ul class=""><li id="1c8a" class="mu mv hs jj b jk jl jn jo jq mw ju mx jy my kc mz na nb nc bi translated">片段(即，根本不使用导航组件):这是通过使用<code class="du lb lc ld le b">saveBackStack</code>和<code class="du lb lc ld le b">restoreBackStack</code>的新<code class="du lb lc ld le b">FragmentManager</code>API进行的选择加入更改。</li><li id="ab0b" class="mu mv hs jj b jk nd jn ne jq nf ju ng jy nh kc mz na nb nc bi translated">核心导航运行时:为<code class="du lb lc ld le b">restoreState</code>和<code class="du lb lc ld le b">saveState</code>添加了新的<code class="du lb lc ld le b">NavOptions</code>方法，并添加了一个新的<code class="du lb lc ld le b">popBackStack()</code>重载，该重载也接受一个<code class="du lb lc ld le b">saveState</code>布尔值(默认为<code class="du lb lc ld le b">false</code>)。</li><li id="de96" class="mu mv hs jj b jk nd jn ne jq nf ju ng jy nh kc mz na nb nc bi translated">使用片段导航:现在<code class="du lb lc ld le b">FragmentNavigator</code>利用新的<code class="du lb lc ld le b">Navigator</code>API，通过使用导航运行时API将导航运行时API正确地翻译成片段API。</li><li id="514b" class="mu mv hs jj b jk nd jn ne jq nf ju ng jy nh kc mz na nb nc bi translated"><code class="du lb lc ld le b">NavigationUI</code>:现在<code class="du lb lc ld le b">onNavDestinationSelected()</code>、<code class="du lb lc ld le b">NavigationBarView.setupWithNavController()</code>、<code class="du lb lc ld le b">NavigationView.setupWithNavController()</code>默认使用新的<code class="du lb lc ld le b">restoreState</code>、<code class="du lb lc ld le b">saveState</code>、<code class="du lb lc ld le b">NavOptions</code>、T18弹出后栈。这意味着，在升级Navigation 2.4.0-alpha01或更高版本后，每个使用这些<code class="du lb lc ld le b"><strong class="jj ht">NavigationUI</strong></code><strong class="jj ht">API的应用程序都将获得多个后台堆栈，而不会有任何代码更改。</strong></li></ul><p id="5540" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你想看看更多使用这个API的例子，看看<code class="du lb lc ld le b">NavigationAdvancedSample</code>(新更新的，没有任何<code class="du lb lc ld le b">NavigationExtensions</code>代码需要支持多个后台堆栈):</p><div class="hg hh ez fb hi lm"><a href="https://github.com/android/architecture-components-samples/tree/master/NavigationAdvancedSample" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd ht fi z dy lr ea eb ls ed ef hr bi translated">Android/架构-组件-示例</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">本示例展示了遵循导航原则的底部导航视图的行为。固定开始…</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">github.com</p></div></div><div class="lv l"><div class="ni l lx ly lz lv ma ho lm"/></div></div></a></div><p id="4cc3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对于导航合成，考虑一下Tivi:</p><div class="hg hh ez fb hi lm"><a href="https://github.com/chrisbanes/tivi" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd ht fi z dy lr ea eb ls ed ef hr bi translated">chrisbanes/tivi</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">这不是官方的谷歌产品，Tivi是一个正在进行的跟踪Android应用程序的电视节目，它连接到…</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">github.com</p></div></div><div class="lv l"><div class="nj l lx ly lz lv ma ho lm"/></div></div></a></div><p id="fb66" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果您确实遇到了任何问题，请确保使用官方的问题跟踪器对<a class="ae kd" href="https://issuetracker.google.com/issues/new?component=460964" rel="noopener ugc nofollow" target="_blank">碎片</a>或<a class="ae kd" href="https://issuetracker.google.com/issues/new?component=409828" rel="noopener ugc nofollow" target="_blank">导航</a>进行bug归档，我们一定会查看的！</p></div></div>    
</body>
</html>