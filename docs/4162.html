<html>
<head>
<title>CSS: select first-of-class with the subsequent sibling combinator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSS:用后续的兄弟组合符选择第一类</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/css-select-first-of-class-with-the-subsequent-sibling-combinator-853aa541bda8?source=collection_archive---------1-----------------------#2018-03-18">https://medium.com/google-developer-experts/css-select-first-of-class-with-the-subsequent-sibling-combinator-853aa541bda8?source=collection_archive---------1-----------------------#2018-03-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1982963ecc68c3b0945d854fffa0e71d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wN01TOAbvRjQagKQq8kWEQ.png"/></div></div></figure><p id="096e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">web开发人员可以使用一大堆CSS选择器，但有时还是不够。我最近在构建我的网站的<a class="ae jn" href="https://philna.sh/speaking/" rel="noopener ugc nofollow" target="_blank">口语部分时发现了这一点，并想使用不存在的<code class="du jo jp jq jr b">:first-of-class</code>伪类来应用一些风格。</a></p><h1 id="d77c" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">问题是</h1><p id="f88f" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">伪类<code class="du jo jp jq jr b">:first-of-type</code>确实存在，但是有限。它是<code class="du jo jp jq jr b">:nth-of-type()</code>伪类的一个特例。从规格(强调我的):</p><blockquote class="kv kw kx"><p id="1c89" class="ip iq ky ir b is it iu iv iw ix iy iz kz jb jc jd la jf jg jh lb jj jk jl jm ha bi translated"><em class="hh">:n-of-type(An+B)伪类符号表示将由以下元素匹配的相同元素:n-child(| An+B | of S)，</em> <strong class="ir hi">，其中S是类型选择器</strong> <em class="hh">和匹配所讨论元素的名称空间前缀。</em></p></blockquote><p id="7f9f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">也就是说，当使用<code class="du jo jp jq jr b">:nth-of-type()</code>或<code class="du jo jp jq jr b">:first-of-type</code>时，选择器只能是类型选择器。也就是说，当使用<code class="du jo jp jq jr b">:first-of-type</code>时，您只能直接引用元素，比如<code class="du jo jp jq jr b">&lt;p&gt;</code>或<code class="du jo jp jq jr b">&lt;h1&gt;</code>。所以，如果你有下面的HTML:</p><pre class="lc ld le lf fd lg jr lh li aw lj bi"><span id="88d5" class="lk jt hh jr b fi ll lm l ln lo">&lt;div&gt;<br/>  &lt;p&gt;This is paragraph 1&lt;/p&gt;<br/>  &lt;p class="special"&gt;This is paragraph 2&lt;/p&gt;<br/>  &lt;p class="special"&gt;This is paragraph 3&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="6e1c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个CSS:</p><pre class="lc ld le lf fd lg jr lh li aw lj bi"><span id="8919" class="lk jt hh jr b fi ll lm l ln lo">div p { color: #333; }<br/>div p:first-of-type { color: red; }<br/>div p.special:first-of-type { color: green; }</span></pre><p id="2a70" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可能会认为第一段是红色的，第二段是绿色的。但是<code class="du jo jp jq jr b">div p.special</code>不是类型选择器，所以<code class="du jo jp jq jr b">:first-of-type</code>在这里不适用，没有什么是绿色的。</p><p id="13a4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这可以通过由<a class="ae jn" href="https://stackoverflow.com/questions/2717480/css-selector-for-first-element-with-class" rel="noopener ugc nofollow" target="_blank">陈家风</a>和<a class="ae jn" href="https://stackoverflow.com/questions/5287272/css-select-first-element-with-a-certain-class/5293095#5293095" rel="noopener ugc nofollow" target="_blank">利·韦鲁</a>创造的技术来解决，并在堆栈溢出上共享。我们可以使用<a class="ae jn" href="https://www.w3.org/TR/selectors/#general-sibling-combinators" rel="noopener ugc nofollow" target="_blank">后续或通用兄弟组合符</a>，而不是使用伪类。</p><p id="7b06" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">后续的兄弟组合符看起来像<code class="du jo jp jq jr b">A ~ B</code>，其中<code class="du jo jp jq jr b">A</code>和<code class="du jo jp jq jr b">B</code>是两个复合选择器(不仅仅是类型选择器)。它允许您选择<code class="du jo jp jq jr b">B</code>，其中<code class="du jo jp jq jr b">A</code>和<code class="du jo jp jq jr b">B</code>共享一个父级，并且<code class="du jo jp jq jr b">A</code>在文档中位于<code class="du jo jp jq jr b">B</code>之前。</p><p id="0154" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用下面的HTML，选择器<code class="du jo jp jq jr b">h2 ~ p</code>将选择第二个<code class="du jo jp jq jr b">&lt;p&gt;</code>，因为它跟在<code class="du jo jp jq jr b">&lt;h2&gt;</code>后面，而不是第一个<code class="du jo jp jq jr b">&lt;p&gt;</code>。</p><pre class="lc ld le lf fd lg jr lh li aw lj bi"><span id="0775" class="lk jt hh jr b fi ll lm l ln lo">&lt;div&gt;<br/>  &lt;h1&gt;Heading&lt;/h1&gt;<br/>  &lt;p&gt;Meta data&lt;/p&gt;<br/>  &lt;h2&gt;Subheading&lt;/h2&gt;<br/>  &lt;p&gt;Some article text&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="5c03" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用组合子模拟一个<code class="du jo jp jq jr b">:first-of-class</code>伪类的技巧是使用一个常规的选择器，用你想要的样式来设计类的所有元素。然后使用组合子关闭除第一个元素之外的所有元素。在我们最初的例子中，CSS现在看起来像这样:</p><pre class="lc ld le lf fd lg jr lh li aw lj bi"><span id="b2ac" class="lk jt hh jr b fi ll lm l ln lo">div p { color: #333; }<br/>div p:first-of-type { color: red; }<br/>div p.special { color: green; }<br/>div p.special ~ p.special { color: #333; }</span></pre><p id="9420" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在第一段是红色，第二段是绿色，最后一段是灰色。你可以在Codepen 上查看一个这样的例子。</p><h1 id="632c" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">CSS选择器级别4</h1><p id="dc81" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">在贴出这篇文章后，<a class="ae jn" href="https://twitter.com/simevidas" rel="noopener ugc nofollow" target="_blank">ime Vidas</a><a class="ae jn" href="https://twitter.com/simevidas/status/975394813863432192" rel="noopener ugc nofollow" target="_blank">在Twitter上指出</a>CSS的未来对这种风格的选择器更有希望。在CSS选择器级别4规范中，<code class="du jo jp jq jr b">:nth-child()</code>伪类采用了一个类似于<code class="du jo jp jq jr b">An+B [of S]?</code>的参数。<code class="du jo jp jq jr b">An+B</code>部分意味着您可以提供一个函数来计算<code class="du jo jp jq jr b">n</code>是什么，但是可选的<code class="du jo jp jq jr b">of S</code>意味着伪类将匹配与选择器匹配的第n个元素。</p><p id="617b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这意味着我们可以更新我们的例子来使用<code class="du jo jp jq jr b">:nth-child()</code>，而不是像上面那样使用两个规则。查看下面的CSS:</p><pre class="lc ld le lf fd lg jr lh li aw lj bi"><span id="dad6" class="lk jt hh jr b fi ll lm l ln lo">div p { color: #333; }<br/>div p:first-of-type { color: red; }<br/>div :nth-child(1 of p.special) { color: green; }</span></pre><p id="b80c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<code class="du jo jp jq jr b">:nth-child(1 of p.special)</code>意味着我们正在选择<code class="du jo jp jq jr b">&lt;div&gt;</code>的第一个子节点，它是一个具有“特殊”类的<code class="du jo jp jq jr b">&lt;p&gt;</code>。这正是我想要的。</p><p id="29f8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种技术的唯一缺点是？目前只能在Safari中使用。我已经更新了<a class="ae jn" href="https://codepen.io/philnash/pen/WzoNwG/" rel="noopener ugc nofollow" target="_blank"> Codepen，在Safari中查看一下，看看你所有的未来选择器梦想都实现了</a>。</p><h1 id="9127" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">CSS黑客仍然很有趣</h1><p id="27fe" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我断断续续写CSS已经十多年了，虽然CSS所有的现代布局功能意味着黑客攻击少了很多，但有时你需要想出一个创造性的解决方案来解决问题。我本可以用一个额外的类或者重新安排我的HTML来解决这个问题，但是当CSS可以为你做这件事的时候，你会感觉更满意。</p><p id="84c6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">感谢Daniel和Lea分享他们关于堆栈溢出的解决方案，特别感谢Daniel，他的<a class="ae jn" href="https://stackoverflow.com/questions/2717480/css-selector-for-first-element-with-class/8539107#8539107" rel="noopener ugc nofollow" target="_blank">回答对CSS选择器和伪类误解</a>进行了更详细的描述。</p><p id="239a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">也许有一天我们会看到一个<code class="du jo jp jq jr b">:first-of-class</code>伪类。有了最新版本的<code class="du jo jp jq jr b">:nth-child()</code>，也许我们甚至不需要<code class="du jo jp jq jr b">:first-of-class</code>，我们只是在等待浏览器的支持。与此同时，后续的兄弟组合子仍然是我们的朋友。</p></div><div class="ab cl lp lq go lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ha hb hc hd he"><p id="6385" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://philna.sh/blog/2018/03/18/css-first-of-class/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> CSS:用后续的兄弟组合子</em> </a> <em class="ky">选择一流最初发布于2018年3月18日</em><a class="ae jn" href="https://philna.sh/blog/2018/03/18/css-first-of-class/index.html" rel="noopener ugc nofollow" target="_blank"><em class="ky">philna . sh</em></a><em class="ky">。</em></p></div></div>    
</body>
</html>