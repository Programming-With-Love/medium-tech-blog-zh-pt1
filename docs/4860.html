<html>
<head>
<title>Effective Java in Kotlin, item 7: Eliminate obsolete object references</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的有效Java，第7项:消除过时的对象引用</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/effective-java-in-kotlin-item-7-eliminate-obsolete-object-references-9a197b6fb728?source=collection_archive---------1-----------------------#2018-08-08">https://blog.kotlin-academy.com/effective-java-in-kotlin-item-7-eliminate-obsolete-object-references-9a197b6fb728?source=collection_archive---------1-----------------------#2018-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/837993b83ac34210ed56468ff4c9947e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DDX9PlNkiwssztUaYUwhIg.png"/></div></div></figure><div class=""/><p id="8067" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用自动内存管理语言(如Java，垃圾收集器[GC]完成所有工作)的程序员很少考虑释放对象。它会导致内存泄漏，在某些情况下会导致<code class="fe kt ku kv kw b">OutOfMemoryError</code>。最重要的一条规则是不使用的对象应该被释放。让我们看一个来自<a class="ae kx" href="https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997" rel="noopener ugc nofollow" target="_blank">书</a>(移到Kotlin)的例子，它是一个堆栈实现:</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="588d" class="lg lh iy kw b gy li lj l lk ll"><strong class="kw iz">class </strong>Stack {<br/>    <strong class="kw iz">private var elements</strong>: Array&lt;Any?&gt; = <br/>        <em class="lm">arrayOfNulls</em>(<strong class="kw iz">DEFAULT_INITIAL_CAPACITY</strong>)<br/>    <strong class="kw iz">private var size </strong>= 0<br/><br/>    <strong class="kw iz">fun </strong>push(e: Any) {<br/>        ensureCapacity()<br/>        <strong class="kw iz">elements</strong>[<strong class="kw iz">size</strong>++] = e<br/>    }<br/><br/>    <strong class="kw iz">fun </strong>pop(): Any? {<br/>        <strong class="kw iz">if </strong>(<strong class="kw iz">size </strong>== 0)<br/>            <strong class="kw iz">throw </strong>EmptyStackException()<br/>        <strong class="kw iz">return elements</strong>[--<strong class="kw iz">size</strong>]<br/>    }<br/><br/>    <em class="lm">/**<br/>     * Ensure space for at least one more element, roughly<br/>     * doubling the capacity each time the array needs to grow.<br/>     */<br/>    </em><strong class="kw iz">private fun </strong>ensureCapacity() {<br/>        <strong class="kw iz">if </strong>(<strong class="kw iz">elements</strong>.<strong class="kw iz">size </strong>== <strong class="kw iz">size</strong>)<br/>            <strong class="kw iz">elements </strong>= Arrays.copyOf(<strong class="kw iz">elements</strong>, 2 * <strong class="kw iz">size </strong>+ 1)<br/>    }<br/><br/>    <strong class="kw iz">companion object </strong>{<br/>        <strong class="kw iz">private const val DEFAULT_INITIAL_CAPACITY </strong>= 16<br/>    }<br/>}</span></pre><p id="b8c6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你能发现这里的问题吗？花一分钟考虑一下。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi ln"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><p id="4c51" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题是，当我们弹出时，我们只是减少大小，但我们没有释放数组上的元素。假设堆栈上有1000个元素，我们一个接一个地弹出了几乎所有的元素，我们的大小现在等于1。我们应该只有一个元素，并且只能访问一个元素，但是我们的堆栈仍然保存1000个元素，并且不允许GC销毁它们。更多这样的问题，我们可能会有<code class="fe kt ku kv kw b">OutOfMemoryError</code>。怎么才能修好？解决方案很简单:</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="3315" class="lg lh iy kw b gy li lj l lk ll"><strong class="kw iz">fun </strong>pop(): Any? {<br/>    <strong class="kw iz">if </strong>(<strong class="kw iz">size </strong>== 0)<br/>        <strong class="kw iz">throw </strong>EmptyStackException()<br/>    <strong class="kw iz">val </strong>elem = <strong class="kw iz">elements</strong>[--<strong class="kw iz">size</strong>]<br/>    <strong class="kw iz">elements</strong>[<strong class="kw iz">size</strong>] = <strong class="kw iz">null<br/>    return </strong>elem<br/>}</span></pre><p id="2648" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个非常罕见的例子，也是一个巨大的错误，但是有一些日常用品我们可以从这条规则中获益。比方说，我们需要<code class="fe kt ku kv kw b">mutableLazy</code>财产委托。它应该像lazy一样工作，但也应该允许属性状态突变。我可以做如下实现:</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="f647" class="lg lh iy kw b gy li lj l lk ll"><strong class="kw iz">fun </strong>&lt;T&gt; mutableLazy(initializer: () -&gt; T): ReadWriteProperty&lt;Any?, T&gt; = MutableLazy(initializer)<br/><br/><strong class="kw iz">private class </strong>MutableLazy&lt;T&gt;(<br/>    <strong class="kw iz">val initializer</strong>: () -&gt; T<br/>) : ReadWriteProperty&lt;Any?, T&gt; {<br/><br/>    <strong class="kw iz">private var value</strong>: T? = <strong class="kw iz">null<br/>    private var initialized </strong>= <strong class="kw iz">false<br/><br/>    override fun </strong>getValue(<br/>        thisRef: Any?, <br/>        property: KProperty&lt;*&gt;<br/>    ): T {<br/>        <em class="lm">synchronized</em>(<strong class="kw iz">this</strong>) <strong class="kw iz">{<br/>            if </strong>(!<strong class="kw iz">initialized</strong>) {<br/>                <strong class="kw iz">value </strong>= <strong class="kw iz">initializer</strong>()<br/>                <strong class="kw iz">initialized </strong>= <strong class="kw iz">true<br/>            </strong>}<br/>            <strong class="kw iz">return value as </strong>T<br/>        <strong class="kw iz">}<br/>    </strong>}<br/><br/>    <strong class="kw iz">override fun </strong>setValue(<br/>        thisRef: Any?, <br/>        property: KProperty&lt;*&gt;, <br/>        value: T<br/>    ) {<br/>        <em class="lm">synchronized</em>(<strong class="kw iz">this</strong>) <strong class="kw iz">{<br/>            this</strong>.<strong class="kw iz">value </strong>= value<br/>            <strong class="kw iz">initialized </strong>= <strong class="kw iz">true<br/>        }<br/>    </strong>}<br/>}</span></pre><p id="f868" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用法:</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="3192" class="lg lh iy kw b gy li lj l lk ll"><strong class="kw iz">var </strong><em class="lm">game</em>: Game? <strong class="kw iz">by </strong><em class="lm">mutableLazy </em><strong class="kw iz">{ </strong>readGameFromSave() <strong class="kw iz">}<br/><br/>fun </strong>setUpActions() {<br/>    startNewGameButton.setOnClickListener <strong class="kw iz">{<br/>        </strong><em class="lm">game </em>= makeNewGame()<br/>        startGame()<br/>    <strong class="kw iz">}<br/>    </strong>resumeGameButton.setOnClickListener <strong class="kw iz">{<br/>        </strong>startGame()<br/>    <strong class="kw iz">}<br/></strong>}</span></pre><p id="8c61" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的<code class="fe kt ku kv kw b">mutableLazy</code>实现是正确的，但是它有一个缺陷:<code class="fe kt ku kv kw b">initializer</code>在使用后没有被删除。这意味着只要对实例<code class="fe kt ku kv kw b">MutableLazy</code>的引用存在，它就被持有，即使它不再有用。这就是如何改进<code class="fe kt ku kv kw b">MutableLazy</code>实现的方法:</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="4f3e" class="lg lh iy kw b gy li lj l lk ll"><strong class="kw iz">fun </strong>&lt;T&gt; mutableLazy(initializer: () -&gt; T): ReadWriteProperty&lt;Any?, T&gt; = MutableLazy(initializer)<br/><br/><strong class="kw iz">private class </strong>MutableLazy&lt;T&gt;(<br/>    <strong class="kw iz">var initializer</strong>: (() -&gt; T)?<br/>) : ReadWriteProperty&lt;Any?, T&gt; {<br/><br/>    <strong class="kw iz">private var value</strong>: T? = <strong class="kw iz">null<br/><br/>    override fun </strong>getValue(<br/>        thisRef: Any?, <br/>        property: KProperty&lt;*&gt;<br/>    ): T {<br/>        <em class="lm">synchronized</em>(<strong class="kw iz">this</strong>) <strong class="kw iz">{<br/>            val </strong>initializer = <strong class="kw iz">initializer<br/>            if </strong>(initializer != <strong class="kw iz">null</strong>) {<br/>                <strong class="kw iz">value </strong>= initializer()<br/>                <strong class="kw iz">this</strong>.<strong class="kw iz">initializer </strong>= <strong class="kw iz">null<br/>            </strong>}<br/>            <strong class="kw iz">return value as </strong>T<br/>        <strong class="kw iz">}<br/>    </strong>}<br/><br/>    <strong class="kw iz">override fun </strong>setValue(<br/>        thisRef: Any?, <br/>        property: KProperty&lt;*&gt;, <br/>        value: T<br/>    ) {<br/>        <em class="lm">synchronized</em>(<strong class="kw iz">this</strong>) <strong class="kw iz">{<br/>            this</strong>.<strong class="kw iz">value </strong>= value<br/>            <strong class="kw iz">this</strong>.<strong class="kw iz">initializer </strong>= <strong class="kw iz">null<br/>        }<br/>    </strong>}<br/>}</span></pre><p id="3211" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们将<code class="fe kt ku kv kw b">initializer</code>设置为<code class="fe kt ku kv kw b">null</code>时，之前的值可以被GC回收。</p><p id="5d29" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种优化有多重要？为很少使用的对象而烦恼并不重要。有一种说法，过早的优化是纯粹的罪恶之源。虽然将<code class="fe kt ku kv kw b">null</code>设置为未使用的对象很好，但这样做不会花费您太多成本。尤其是当它是一个函数类型(在Kotlin/JVM中经常是一个匿名类)或者是一个未知类(<code class="fe kt ku kv kw b">Any</code>或者泛型类型的时候。上面的例子是<code class="fe kt ku kv kw b">Stack</code>，它可能被用来装重物。).当我们使用通用工具，尤其是库时，我们应该关心更深层次的优化。例如，在Kotlin stdlib的lazy委托的所有3个实现中，我们可以看到初始化器在使用后被设置为<code class="fe kt ku kv kw b">null</code>:</p><pre class="ky kz la lb gt lc kw ld le aw lf bi"><span id="c9a8" class="lg lh iy kw b gy li lj l lk ll"><strong class="kw iz">private class </strong>SynchronizedLazyImpl&lt;<strong class="kw iz">out </strong>T&gt;(<br/>    initializer: () -&gt; T, lock: Any? = <strong class="kw iz">null<br/></strong>) : Lazy&lt;T&gt;, Serializable {</span><span id="fdb8" class="lg lh iy kw b gy lo lj l lk ll">    <strong class="kw iz">private var initializer</strong>: (() -&gt; T)? = initializer<br/>    <strong class="kw iz">private var _value</strong>: Any? = UNINITIALIZED_VALUE<em class="lm"><br/>    </em><strong class="kw iz">private val lock </strong>= lock ?: <strong class="kw iz">this<br/><br/>    override val value</strong>: T<br/>        <strong class="kw iz">get</strong>() {<br/>            <strong class="kw iz">val </strong>_v1 = <strong class="kw iz">_value<br/>            if </strong>(_v1 !== UNINITIALIZED_VALUE) {<br/>                @Suppress(<strong class="kw iz">"UNCHECKED_CAST"</strong>)<br/>                <strong class="kw iz">return </strong>_v1 <strong class="kw iz">as </strong>T<br/>            }<br/><br/>            <strong class="kw iz">return </strong><em class="lm">synchronized</em>(<strong class="kw iz">lock</strong>) <strong class="kw iz">{<br/>                val </strong>_v2 = <strong class="kw iz">_value<br/>                if </strong>(_v2 !== UNINITIALIZED_VALUE) {<br/>                    @Suppress(<strong class="kw iz">"UNCHECKED_CAST"</strong>) (_v2 <strong class="kw iz">as </strong>T)<br/>                } <strong class="kw iz">else </strong>{<br/>                    <strong class="kw iz">val </strong>typedValue = <strong class="kw iz">initializer</strong>!!()<br/>                    <strong class="kw iz">_value </strong>= typedValue<br/>                    <strong class="kw iz">initializer </strong>= <strong class="kw iz">null<br/>                    </strong>typedValue<br/>                }<br/>            <strong class="kw iz">}<br/>        </strong>}<br/><br/>    <strong class="kw iz">override fun </strong>isInitialized(): Boolean = <strong class="kw iz">_value </strong>!== UNINITIALIZED_VALUE<br/><br/>    <strong class="kw iz">override fun </strong>toString(): String = <strong class="kw iz">if </strong>(isInitialized()) <strong class="kw iz">value</strong>.<em class="lm">toString</em>() <strong class="kw iz">else "Lazy value not initialized yet."<br/><br/>    private fun </strong>writeReplace(): Any = InitializedLazyImpl(<strong class="kw iz">value</strong>)<br/>}</span></pre><p id="de0a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一般规则是:</p><blockquote class="lp"><p id="19fa" class="lq lr iy bd ls lt lu lv lw lx ly ks dk translated">当我们保持状态时，我们应该在头脑中一直有内存管理。但是，在改变实现之前，我们应该为我们的项目找到最佳的折衷方案，不仅要考虑内存和性能，还要考虑解决方案的可读性和可伸缩性。当我们做一个应用程序时，大多数情况下可读性更重要。当我们开发一个库时，通常性能和内存更重要。</p></blockquote><p id="574f" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">我们需要讨论一些常见的内存泄漏来源。首先，缓存保存着可能永远不会用到的对象。这是缓存背后的想法，但当我们遭受内存不足错误时，它不会帮助我们。解决方案是使用<a class="ae kx" href="https://www.google.com/search?q=weak+reference&amp;oq=weak+reference&amp;aqs=chrome..69i57j0l5.2684j0j1&amp;sourceid=chrome&amp;ie=UTF-8" rel="noopener ugc nofollow" target="_blank">弱引用</a>。如果需要内存，对象仍然可以被GC收集，但是它们通常会存在并被使用。</p><p id="5559" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个常见的问题是回调和侦听器的问题。开发人员经常注册它们，当不再需要时就不再注销它们。同样，解决方案是使用弱引用注册回调。</p><p id="eae1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最大的问题是，内存泄漏有时很难预测，直到应用程序崩溃时才会显现出来。这就是为什么我们应该使用特殊的工具来寻找它们。最基本的工具是堆分析器。我们也有一些帮助查找数据泄漏的库。例如，Android的一个流行库是LeakCanary，每当检测到内存泄漏时，它就会显示一个通知。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><a href="https://www.kt.academy/#workshops-offer"><div class="gh gi ln"><img src="../Images/018370a2476e1ce49e6d3299428b4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-f1laplrjQQAMlYKfLgHw.png"/></div></a></figure></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><h1 id="4dd9" class="ml lh iy bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">关于作者</h1><p id="a5e7" class="pw-post-body-paragraph jv jw iy jx b jy ni ka kb kc nj ke kf kg nk ki kj kk nl km kn ko nm kq kr ks ig bi translated"><a class="ae kx" href="http://marcinmoskala.com/" rel="noopener ugc nofollow" target="_blank">马尔金·莫斯卡兹拉</a>(<a class="ae kx" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank">@马尔金莫斯卡拉</a>)是一名培训师兼顾问，目前专注于给<strong class="jx iz">在Android和高级Kotlin工作坊</strong> ( <a class="ae kx" href="https://marcinmoskala.typeform.com/to/iwKnN9" rel="noopener ugc nofollow" target="_blank">填写表格</a>，我们可以谈谈你的需求)。他还是一名演讲者，撰写了关于kot Lin Android开发的文章和书籍。</p></div><div class="ab cl me mf hr mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ig ih ii ij ik"><p id="a4b1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你需要Kotlin工作室吗？访问<a class="ae kx" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank">我们的网站</a>看看我们能为您做些什么。</p><p id="5a0d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kx" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kx" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi ln"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>