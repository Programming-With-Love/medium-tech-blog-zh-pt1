<html>
<head>
<title>An Approach to Designing a Distributed, Fault-Tolerant, Horizontally Scalable Event Scheduler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种设计分布式、容错、可水平扩展的事件调度器的方法</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/an-approach-to-designing-distributed-fault-tolerant-horizontally-scalable-event-scheduler-278c9c380637?source=collection_archive---------0-----------------------#2016-11-23">https://medium.com/walmartglobaltech/an-approach-to-designing-distributed-fault-tolerant-horizontally-scalable-event-scheduler-278c9c380637?source=collection_archive---------0-----------------------#2016-11-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/657d7eb3cd63d196fe0cc20330c31f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JI5_Fm7d5jEvUcVdNZZxlQ.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Photo Credit <a class="ae hu" href="https://pixabay.com/en/pocket-watch-time-of-sand-1637396/" rel="noopener ugc nofollow" target="_blank">annca</a></figcaption></figure><div class=""/><div class=""><h2 id="73cf" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated"><strong class="ak">简介</strong></h2></div><p id="767f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">设计一个基于时间的事件调度器总是一个有趣的问题。大规模这样做更具挑战性。首先，让我们定义什么是基于时间的事件调度程序？</p><p id="7693" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">时基事件调度器是一个系统，服务可以使用它来调度需要在<em class="ki">未来</em>处理的请求。该服务在调度器中注册一个<em class="ki">事件</em>，并暂停当前请求的处理。</p><p id="8dbc" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">当规定的时间到达时，调度器通知请求服务，并且前者可以继续处理暂停的请求。这种系统在许多情况下都是有用的。下面列出了一些用例，但并不详尽</p><h2 id="9a4a" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">异步请求超时</h2><p id="9b50" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh ha bi translated">随着越来越多的系统转向基于消息的架构，如Kafka、JMS等。最常见的场景之一是使用消息传递层作为异步请求/响应总线。一个系统产生一个“<em class="ki">消息请求</em>给另一个系统，当后者返回响应时，它继续进行剩余的处理。在某些情况下，让打电话的人有“<strong class="jo hy">最终回应</strong>”是很重要的。可能是另一个系统有滞后，或关闭，或只是错过了返回响应。在具有无状态微服务范例的分布式环境中，很难跟踪这种<em class="ki">丢失的</em>请求。一种解决方案是安排一个“超时”事件，它可以在请求的规定SLA时触发。</p><p id="e538" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">当事件被触发时，可以检查请求的当前状态，如果响应丢失，则可以将请求标记为超时。</p><h2 id="8b37" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">系统重试次数</h2><p id="e509" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh ha bi translated">即使在通过同步通道(如HTTP)进行交互的系统中，服务器也有可能出现故障，无法满足请求。客户端可以选择重试，但是，如果重试间隔非常短，则不太可能有任何净正面效果。例如，如果是系统范围的中断，它可能会持续几秒钟以上。在这种情况下，可能需要进行更长时间的指数重试，因为请求数据可能不会保存在内存中。</p><p id="db8b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这些情况下，重试的有效负载可以发送到事件调度程序，并且可以根据客户端的重试策略在以后重试。</p><h2 id="a9f5" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">协调作业</h2><p id="20bc" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh ha bi translated">有时，在基于批处理的分布式系统中，数据流被分割并由多个集群作为微批处理进行处理。在失败的情况下，可能需要协调响应，以便可以为初始批次向客户端返回一致的响应。</p><p id="9950" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这种情况下，可以在批处理开始时安排协调事件，以便可以在批处理或SLA处理时间结束时协调数据。</p><h2 id="bdd5" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">与价格相关的触发器</h2><p id="a4c4" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh ha bi translated">在电子商务世界中，价格变化通常是为了使产品保持有竞争力的价格。触发这样的价格变化可能是一项巨大的人工工作，容易出错，并且可能不会在预期的时间精确发生。例如，在黑色星期五这样的假日高峰时段，即使价格变化有一分钟的滞后，也可能影响全年的销售。</p><p id="d8e9" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这种情况下，可以提前将价格变化设置为“促销”，这可以由活动调度程序在所需的时间触发，从而节省手动价格同步工作。</p><p id="ce5f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">所有上述提到的问题都是<a class="ae hu" href="https://www.walmart.com/" rel="noopener ugc nofollow" target="_blank">沃尔玛</a>在某个时候面临的，我们清楚地认识到，我们需要投资一个能够跟踪<em class="ki">暂停请求</em>的系统。由于沃尔玛的经营规模巨大，调度程序必须具有容错性和水平可伸缩性。</p><h2 id="f06e" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">现有选项</h2><p id="bcc7" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh ha bi translated">我们开始寻找各种现有的开源解决方案，比如Quartz。虽然Quartz是基于时间的调度的成熟解决方案，功能丰富，但我们的问题陈述有所不同</p><ul class=""><li id="f228" class="lj lk hx jo b jp jq js jt jv ll jz lm kd ln kh lo lp lq lr bi translated">我们的许多应用程序都使用<a class="ae hu" href="https://www.youtube.com/watch?v=KMHua4LUvQ0" rel="noopener ugc nofollow" target="_blank"> Cassandra </a>作为NoSql数据存储。随着时间的推移，我们在Cassandra及其细微差别方面积累了丰富的专业知识。Quartz似乎没有卡珊德拉的JobStore(或者至少我们找不到)</li><li id="e461" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">我们希望事件具有可调的一致性。对于一些事件，如系统重试等，可以将它们写入一个节点(LOCAL_ONE ),但对于其他事件，如升级触发器，则需要使用EACH_QUORUM，这样就不会丢失任何事件。</li><li id="02b0" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">横向扩展集群更加困难。我们需要扩展到每小时数百万个事件。</li></ul><p id="2a93" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们还研究了Quartz的基于Hazelcast的JobStore实现，但是延长的垃圾收集周期会导致内存中数据的错误。</p><h2 id="3a6b" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">介绍BigBen</h2><p id="ed01" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh ha bi translated">我们开始实施我们自己的解决方案，它被称为BigBen，灵感来自非常著名的<a class="ae hu" href="https://en.wikipedia.org/wiki/Big_Ben" rel="noopener ugc nofollow" target="_blank">伦敦钟楼</a>。BigBen提供了以下功能</p><ul class=""><li id="2457" class="lj lk hx jo b jp jq js jt jv ll jz lm kd ln kh lo lp lq lr bi translated">主从设计，这样主服务器可以决定在集群中分配负载的最佳策略</li><li id="16e2" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">极强的容错设计，这样，如果一个给定的主机发生故障，几乎可以立即选择另一个主机</li><li id="105f" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">对数据库中的事件数据进行统一分区，以便在Cassandra中没有胖分区方面的热点</li><li id="cbef" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">在集群上统一执行事件，以便所有节点共享<em class="ki">几乎</em>相等的负载</li><li id="9efd" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">维护检查点，以便跟踪未被触发或执行失败(误触发)的事件</li><li id="a13e" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">与HTTP和Kafka集成，作为事件的<em class="ki">默认</em>通道</li><li id="fcef" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">多租户。每个事件属于一个租户，每个租户可以定义如何存储(一致性保证)和/或处理事件的策略。</li></ul><h2 id="c8c4" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">设计和建筑</h2><p id="de3a" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh ha bi translated">BigBen基于“微批处理”架构。事件被一起存储在一个窗口中，这些存储桶作为分区存储在数据库中。</p><p id="956e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">当集群启动时，选择一个主服务器，它开始以定义的粒度扫描存储桶。支持的最小粒度是一分钟，这意味着主服务器将每分钟扫描一次事件。</p><h2 id="092a" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">事件摄入</h2><p id="8467" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh ha bi translated">由于不知道每分钟将调度多少个事件，因此基于存储桶宽度(在本例中为一分钟)对数据进行分区可能会导致数据库负载不均衡。因此，事件被分片<em class="ki">处理</em>，只有1000个(可配置值)事件存储在一个分片中。</p><p id="e62b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">例如，假设在上午10:00，收到了2030个事件，那么这些事件将被分配到三个分片。碎片1将包含1000个事件，碎片2将包含另外1000个事件，碎片3将包含30个事件。这样，系统保证每个分片不超过1000个事件。</p><p id="77ae" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">要知道一个给定的事件将被分配到哪个碎片，取决于该桶的事件总数。使用下面的公式计算该事件的碎片指数非常简单:</p><blockquote class="lx ly lz"><p id="bebf" class="jm jn ki jo b jp jq iy jr js jt jb ju ma jw jx jy mb ka kb kc mc ke kf kg kh ha bi translated">碎片索引=(总事件数/碎片大小)</p></blockquote><p id="b730" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">例如，当在2030个事件之后接收到下一个事件时，它将转到</p><blockquote class="lx ly lz"><p id="95a0" class="jm jn ki jo b jp jq iy jr js jt jb ju ma jw jx jy mb ka kb kc mc ke kf kg kh ha bi translated">2030/1000 =第二个索引(或第三个碎片)</p></blockquote><p id="7d80" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">对于快速查找，这需要维护每个存储桶的运行事件总数。BigBen使用嵌入式Hazelcast网格在分布式地图中维护这些计数，尽管其他解决方案如memcache、<a class="ae hu" href="https://t.co/CSDgqm6MP9" rel="noopener ugc nofollow" target="_blank"> Couchbase </a>等。其提供对原子计数的支持。地图数据每隔几秒钟就会与Cassandra同步一次。</p><p id="b902" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">下图捕获了事件接收流。可以通过HTTP或Kafka接收事件。无效事件被拒绝并立即返回(由<em class="ki">红色虚线</em>显示)。对于其他人，计算相应的桶(假设事件安排在上午10:21:55，那么桶是上午10:21:00)，计数递增，并计算碎片索引。该事件然后被存储在对应的分区中，该分区是桶和碎片索引的组合(例如10:21:00/1)</p><figure class="me mf mg mh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es md"><img src="../Images/e1babd64cb13e2a22dde6afafc1857eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmYyR8GT9TjPmrRorOBzLg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Fig 1 — Event Receive Flow</figcaption></figure><h2 id="3613" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">事件处理</h2><p id="02e3" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh ha bi translated">对于处理部分，在集群成员中选出一个主机。Zookeeper可以用于领导者/主人选举，但是由于BigBen已经使用了Hazelcast，我们使用了分布式锁特性来实现一个<em class="ki">集群单例。</em>然后，主机调度下一个时段并读取事件计数。知道了事件计数和碎片大小，它可以很容易地计算出总共有多少碎片。然后，主服务器创建(bucket，shard_index)对，并在集群成员之间平均分配它们<strong class="jo hy"/>，包括它自己。在不相等划分的情况下，主设备试图在自身上承担最小的负载。例如，对于上午10:21时段，假设有6000个事件和4个节点的集群，划分如下:</p><blockquote class="lx ly lz"><p id="b642" class="jm jn ki jo b jp jq iy jr js jt jb ju ma jw jx jy mb ka kb kc mc ke kf kg kh ha bi translated">distribution =&gt; (bucket，shard索引数组，node IP) =&gt; (10:21，[1，5]，node1)，(10:21，[2，6]，node2)，(10:21，[3]，node3)，(10:21，[4]，node4)</p></blockquote><p id="7e84" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">主服务器还检查是否有任何先前的存储桶已经失败，并对这些存储桶进行调度。完成存储桶后，该存储桶将被标记为已处理，并且状态将在检查点中更新。下图显示了处理阶段(<em class="ki">调度扫描仪是主</em>)</p><figure class="me mf mg mh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/2315a20b18feaaca9b99a78321bec2c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*euaHLOnw6G96SigfXxWhtA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Fig 2 — Event Processing Flow</figcaption></figure><p id="b8d7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">处理工作流程中的各种组件包括:</p><ul class=""><li id="214e" class="lj lk hx jo b jp jq js jt jv ll jz lm kd ln kh lo lp lq lr bi translated">存储桶管理器:在内存中维护加载的存储桶的快照</li><li id="45b0" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">Bucket Loader:以速率受限/节流的方式将以前的存储桶加载到内存中</li><li id="f756" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">检查点助手:每几秒钟同步一次检查点</li><li id="f960" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">状态同步:一旦完成，就同步存储桶的状态</li></ul><h2 id="b5c5" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">容错设计</h2><p id="9556" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh ha bi translated">与任何其他分布式系统一样，可能会有多个故障点。其中一些是:</p><ul class=""><li id="311a" class="lj lk hx jo b jp jq js jt jv ll jz lm kd ln kh lo lp lq lr bi translated">主设备变得不可用</li><li id="b4e5" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">事件处理失败</li><li id="b1c3" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">数据库关闭了</li></ul><p id="fbf9" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">BigBen使用不同的技术来处理故障。对于master的容错，我们在Hazelcast中使用了分布式锁。注意，这个锁<em class="ki">在节点的生命周期中从来没有释放过</em>。只有当节点关闭时，另一个成员才会尝试获取锁。这提供了非常健壮的容错能力，我们在混沌猴子测试中验证了这一点。下图显示了主故障切换场景</p><figure class="me mf mg mh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mj"><img src="../Images/19d71e16253239fe96ad4e0fda2eb167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KRjTGz1jrWpYl2tYznV8jg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Fig 3 — Master (Cluster Singleton) distributing tasks among slaves</figcaption></figure><figure class="me mf mg mh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mk"><img src="../Images/ba600317d8bbc0dc09770e128a4c11cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SHiYcpNCJcRsaAbFpXb3rw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Fig 4 — Master down, new slave promoted to master, and starts distributing tasks</figcaption></figure><p id="fca2" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在事件处理失败或数据库关闭的情况下，用这些失败的存储桶标记检查点。在每次新的存储桶扫描时，主服务器也会扫描检查点，以查看是否有任何先前的存储桶处于失败状态。如果找到，那么这些存储桶也会被调度。</p><p id="2b8a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">BigBen使用一个可配置的'<em class="ki">回看</em>'参数，该参数关于它必须走多远才能继续尝试失败的桶/事件。默认情况下，该值为1天。</p><h2 id="0a3a" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">绩效基准</h2><p id="205e" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh ha bi translated">我们使用以下参数对集群的性能进行了基准测试:</p><ul class=""><li id="2c8a" class="lj lk hx jo b jp jq js jt jv ll jz lm kd ln kh lo lp lq lr bi translated">4台机器，Cent OS 6+，8个内核，16 GB内存，最小堆2 GB，最大堆8 GB</li><li id="a0ee" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">事件有效负载大小:500字节</li><li id="4a16" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">Cassandra 6+6裸机集群</li><li id="4428" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">写入一致性:本地仲裁</li><li id="31aa" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">读取一致性:本地仲裁</li><li id="a927" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">摄入率:52秒内摄入100万个事件。=&gt; <strong class="jo hy">每小时7000万个事件</strong></li><li id="5315" class="lj lk hx jo b jp ls js lt jv lu jz lv kd lw kh lo lp lq lr bi translated">处理速度:60秒100万事件=&gt; <strong class="jo hy">每小时6000万事件</strong></li></ul><h2 id="bf24" class="kj kk hx bd kl km kn ko kp kq kr ks kt jv ku kv kw jz kx ky kz kd la lb lc ld bi translated">后续步骤</h2><p id="901a" class="pw-post-body-paragraph jm jn hx jo b jp le iy jr js lf jb ju jv lg jx jy jz lh kb kc kd li kf kg kh ha bi translated">我希望你发现这篇文章内容丰富。k̶e̶e̶p̶̶a̶n̶̶e̶y̶e̶̶o̶u̶t̶,̶̶a̶s̶̶w̶e̶̶w̶i̶l̶l̶̶b̶e̶̶o̶p̶e̶n̶s̶o̶u̶r̶c̶i̶n̶g̶̶b̶i̶g̶b̶e̶n̶̶v̶e̶r̶y̶̶s̶o̶o̶n̶.我们有开源的<a class="ae hu" href="https://github.com/walmartlabs/bigben" rel="noopener ugc nofollow" target="_blank">大本</a>。如果有任何问题，请告诉我们。感谢阅读！</p></div></div>    
</body>
</html>