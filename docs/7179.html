<html>
<head>
<title>The Bikeshop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自行车店</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/the-bikeshop-da7d52fc6317?source=collection_archive---------0-----------------------#2016-10-05">https://medium.com/square-corner-blog/the-bikeshop-da7d52fc6317?source=collection_archive---------0-----------------------#2016-10-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="c3b2" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">稳步迈向更干净的代码。</h2></div><blockquote class="iw"><p id="afe1" class="ix iy hh bd iz ja jb jc jd je jf jg dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jh" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="16d6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc jg ha bi translated">当我几周前加入Square的开发团队时，我被告知，作为入职的一部分，每个新成员都要使用我们的API制作一个示例应用程序。丰富的示例应用程序非常棒，因为它们不仅向开发人员展示了API是如何工作的，还激发了开发人员使用我们的工具可以做各种复杂事情的想法。制作这些示例应用程序让我们有机会获得API的第一手经验，感受与开发人员相同的痛点，并为团队提供关于产品的宝贵反馈。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/224f7fd6fe4bfb390a18c55c5d6c3de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yO-eugnHVfgNPOf6."/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Original designs for the bikeshop used for Register API promotion</figcaption></figure><p id="6876" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">我开发了一个名为Bikeshop的示例应用程序。我们的API宣传材料展示了一个名为Owen's Bikes的定制自行车商店的虚构销售点应用程序，我们决定将这些二维宣传图像融入生活，并构建一个真实的应用程序。</p><p id="8731" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">主屏幕上有一辆自行车，用户可以用许多硬件部件和附件对其进行定制。结账按钮触发<a class="ae jh" href="http://squ.re/1ON8phj" rel="noopener ugc nofollow" target="_blank"> Register Android SDK </a>，将顾客带入Square Register完成交易。交易完成后，结果由API发送回自行车商店，并用于显示“订单完成”页面。</p><p id="15e3" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">创建自行车店是一次宝贵的经历，原因有很多，包括开发速度非常快，然后不断迭代，直到代码可以开源。这个迭代是一个非常有趣的过程，因为它涉及到清理我的代码——谁不喜欢干净的代码呢？我和我知识渊博的新同事在设计和改进这个应用程序的过程中学到了一些东西，虽然它们是非常基本的概念，但我希望它们能帮助一些人寻找一个充满干净代码的Android应用程序。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ky"><img src="../Images/a27eabb22897631c9de75116a8da8a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UN_144j8CgCuja5fCgpa1w.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">Bikeshop screenshot in landscape</figcaption></figure><h2 id="34d5" class="kz la hh bd lb lc ld le lf lg lh li lj jr lk ll lm jv ln lo lp jz lq lr ls lt bi translated">抽象出复杂性</h2><p id="b6c2" class="pw-post-body-paragraph ji jj hh jk b jl lu ii jn jo lv il jq jr lw jt ju jv lx jx jy jz ly kb kc jg ha bi translated">我们设计的一个棘手的方面是两个显示列表的变化布局，分别标为“Bike”和“accessories”(在应用程序中标为“modifiers”和“Accessories”)。如截图所示，在纵向模式下有两个并排的列表，而在横向模式下它们是堆叠的。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lz"><img src="../Images/9e73e7cbaf3faf61c7b0abfe1ebae6db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T6POWMeHQxAs_NvAqnxMaQ.png"/></div></div></figure><p id="4317" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">我的第一个想法是创建两个独立的列表，然后将它们横向堆叠——但是看起来像一个列表但在两个地方滚动会造成糟糕的用户体验。考虑到这一点，我不得不创建两个纵向列表和一个横向列表。</p><p id="47d5" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">这个怎么设置？好吧，碎片出来是因为<a class="ma mb ge" href="https://medium.com/u/abe7df80fc76?source=post_page-----da7d52fc6317--------------------------------" rel="noopener" target="_blank">py⚔</a>T2】提倡反对它们。所以我决定对列表使用几个RecyclerViews。它们都将由一个适配器类填充，该类不知道它正在与哪种列表进行对话。在主活动中，我保留了三个RecyclerAdapters，并根据方向使用了其中的一个或两个。</p><p id="e401" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">听起来很简单，对吧？没错。下面是我设置视图和适配器的初始代码。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="6979" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">这用许多令人困惑的样板文件阻塞了主活动——对我们的开发人员来说不是一个好例子。</p><p id="d312" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">此外，每当活动与适配器对话时，必须再次检查方向，以确保使用了正确的适配器。更烦人的if/else分支是这样的:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="dd62" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">或者这个:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="17d6" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">开始解决这个问题的第一个变化是将与适配器对话的代码移到一个名为ItemManager的新类中。这里的目标是让主要活动承担尽可能少的责任，因为这是很好的实践:参见<a class="ae jh" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>。</p><p id="1b5e" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">下一步:ItemManager不需要知道设备是横向的还是纵向的来调用适配器上的方法。这需要一个接口，所以我们做了一个:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="e2f4" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">我们用两个类实现了这个接口，AdapterController。景观和适应控制器。肖像，以获得想要的行为。现在，当ItemManager想要获取注释、总计或适配器时，它可以调用适当的接口方法。当主活动创建静态AdapterController以传递给ItemManager时，只检查一次方向。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="1b52" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">不再需要我们一直在调用的isLandscape()方法，并且可以删除所有令人困惑的if/else语句。</p><h2 id="80cf" class="kz la hh bd lb lc ld le lf lg lh li lj jr lk ll lm jv ln lo lp jz lq lr ls lt bi translated">不变性FTW</h2><p id="7976" class="pw-post-body-paragraph ji jj hh jk b jl lu ii jn jo lv il jq jr lw jt ju jv lx jx jy jz ly kb kc jg ha bi translated">在应用程序中，我们从静态目录中加载修改器和附件。每个项目都有一个选项列表。例如，项目“框架尺寸”包含框架尺寸的选项，从“42厘米”到“62厘米”。选项集永远不会改变，但是用户可以改变他们选择的选项。最初这反映在我的项目模型类中:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="3998" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">…并且不断地使用getter方法。然而，经过一点回顾之后，我们注意到这个模型对象有一些可以改进的地方。首先，getters和setters是不必要的。我认为的最佳实践导致了应用程序中其他地方不必要的方法调用。第二，它看起来很像是一个不可变的对象。每次都从相同的目录中读取相同的项目，除了当前选择的选项之外，它们没有任何变化。这里的警告标志是，除了一个字段外，所有字段都是最终的。因此，我们决定将所选选项保存在ItemManager中，并让BikeItem类成为一个不可变的对象，表示目录中的一个项目，这是它最初的目的。</p><p id="c040" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">结果是这样的:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mc md l"/></div><figcaption class="kp kq et er es kr ks bd b be z dx">This is not technically immutable because we don’t copy the list of options, but the constructor is only ever used by Gson.</figcaption></figure><p id="c145" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">干净多了。</p><h2 id="bec7" class="kz la hh bd lb lc ld le lf lg lh li lj jr lk ll lm jv ln lo lp jz lq lr ls lt bi translated">避免重复字符串常量</h2><p id="dd72" class="pw-post-body-paragraph ji jj hh jk b jl lu ii jn jo lv il jq jr lw jt ju jv lx jx jy jz ly kb kc jg ha bi translated">这是另一个有趣的清理。当bikeshop从Register API接收到ChargeResult时，它从Intent中获取ORDER_NUMBER字符串，并在新的Intent中传递它，以启动TransactionSuccessActivity。然后，TransactionSuccessActivity从意图中提取ORDER_NUMBER字符串，并将其显示给用户。这种模式导致ORDER_NUMBER常量被定义在两个地方。难看。</p><p id="f9d8" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">因为显示订单号的是TransactionSuccessActivity，所以它应该负责字符串常量。所以我们把字符串从MainActivity中移除并放在那里。MainActivity仍然需要传递字符串，所以我们在TransactionSuccessActivity中创建了一个静态方法。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="954c" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">那么MainActivity只需用上下文和订单号值调用transactionsuccessactivity . start()，不需要知道字符串ORDER_NUMBER。这是一个非常简单的改变，它消除了重复，防止了将来的错误，并使MainActivity看起来更加整洁。</p><h2 id="b7ab" class="kz la hh bd lb lc ld le lf lg lh li lj jr lk ll lm jv ln lo lp jz lq lr ls lt bi translated">结论</h2><p id="b934" class="pw-post-body-paragraph ji jj hh jk b jl lu ii jn jo lv il jq jr lw jt ju jv lx jx jy jz ly kb kc jg ha bi translated">随着我们的迭代，这段代码的质量有了无数的改进。它们并不都很有趣，但它们确实帮助我接触了Android，同时了解了代码质量，这是一名优秀的工程师应该做的。当然，还有很多额外的清理潜力——更不用说要添加无数的功能了！允许用户为自行车的每一部分定制颜色，或者获取不同自行车部件的图像，以便当用户做出选择时，我们可以交换它们，这将增强应用程序的体验。但是尽管我很想继续改进Bikeshop，我们的API还有很多工作要做！</p><p id="38a1" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">你可以通过注册Android SDK在<a class="ae jh" href="http://squ.re/2dm1sNQ" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到Bikeshop示例应用程序，并且有构建应用程序的说明，所以你可以马上开始使用它。欢迎反馈和贡献。GitHub上还有一个APK可供下载，因此您无需Square开发人员帐户就可以使用该应用程序。</p><p id="2449" class="pw-post-body-paragraph ji jj hh jk b jl kt ii jn jo ku il jq jr kv jt ju jv kw jx jy jz kx kb kc jg ha bi translated">我们希望这只是我们的开发人员的许多成熟的示例应用程序的第一个。我们乐观地认为，有人可以利用自行车商店作为他们自己的可怕的销售点的出发点。让我们看看你能做什么！</p></div></div>    
</body>
</html>