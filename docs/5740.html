<html>
<head>
<title>Session persistence for applications running on WebLogic for OKE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在WebLogic for OKE上运行的应用程序的会话持久性</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/session-persistence-for-applications-running-on-weblogic-for-oke-5a3629c89900?source=collection_archive---------2-----------------------#2021-01-04">https://medium.com/oracledevs/session-persistence-for-applications-running-on-weblogic-for-oke-5a3629c89900?source=collection_archive---------2-----------------------#2021-01-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4293bb5741a5ace436b045987200e9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OdRsDLOdgm7wlSOhlnBdQg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo from <a class="ae it" href="https://www.pexels.com/photo/art-background-brick-brick-texture-272254/" rel="noopener ugc nofollow" target="_blank"><strong class="bd iu">Pexels</strong></a></figcaption></figure><p id="081a" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我最近越来越多地使用Oracle的云市场解决方案来部署运行在OCI的Kubernetes容器引擎(简称OKE)上的WebLogic域。如果您还没有听说过这个解决方案，它让您不必在Kubernetes上手动安装WebLogic以及更多！，查看这篇博客文章，了解很好的介绍和起点:<a class="ae it" href="https://blogs.oracle.com/weblogicserver/oracle-weblogic-server-for-oke-now-available-on-oracle-cloud-marketplace" rel="noopener ugc nofollow" target="_blank">Oracle WebLogic Server for OKE</a>。</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jt"><img src="../Images/c20ade5cb8029d1f2ec318f5749255ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yy0o_Uxqahd9cGnZu_hlcA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">WebLogic for OKE components reference architecture</figcaption></figure><p id="0dd8" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">很自然地，在我测试的某个时候，我部署了一个示例ADF应用程序，并在与应用程序交互时收到了这个熟悉的警告消息:</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jy"><img src="../Images/c6ed031949139f26785c7dc2fdb8c4ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-TAg1y2D3JHNPo_-RawgA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">ADF warning message linked with expired an session</figcaption></figure><p id="7851" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我记得这个恼人的弹出窗口通常是由于一个过期的会话。从技术上讲，浏览器发送的JSESSIONID cookie不再与WebLogic Server上的有效会话相关联，或者是未知的，单击“确定”按钮将强制重新加载页面。这将导致重定向到登录或SSO页面，或者在公共页面的情况下，使用新的JSESSIONID立即重新生成新的会话。但是在我的场景中却不是这样。</p><p id="6886" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">一点上下文:在我的Weblogic for OKE拓扑中，我有一个Kubernetes集群，它有两个与<em class="jz"> Weblogic节点池</em>(用于运行WebLogic相关pods的专用节点池)相关联的工作节点和四个运行WebLogic托管服务器pods。从WebLogic Server的角度来看，这是一个具有四个受管服务器的WebLogic群集。在前面，一个公共OCI负载平衡器将流量分发到我的Kubernetes集群，随后，一个预配置的NGINX入口控制器将应用程序流量路由到WebLogic托管服务器pod。因此，在我的例子中，最有可能的情况是，每次调用都是由不同的pod服务的，它不能识别由对等pod创建的会话cookie。这很有意义，因为我的示例ADF应用程序没有针对会话复制进行配置。</p><p id="df1e" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如何快速修复此问题？配置相关的Kubernetes入口资源以支持pod关联！我登录到<em class="jz">管理主机</em>(查看上面的参考组件架构)，因为它已经安装了所有CLI工具，并配置了Kubernetes集群。列出所有入口资源，我们可以看到三种不同的资源:</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="e9f1" class="kf kg hh kb b fi kh ki l kj kk">$ kubectl get ingress -A<br/>NAMESPACE NAME HOSTS ADDRESS PORTS AGE<br/>jenkins-ns jenkins-dashboard-ingress * 10.0.3.4 80 20d<br/>wlsoke07-domain-ns wls-admin-ingress * 10.0.3.4 80 20d<br/>wlsoke07-domain-ns wls-cluster-ingress * 193.133.3.17 80 20d</span></pre><p id="97a7" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><code class="du kl km kn kb b">wls-cluster-ingress</code>处理外部流量，我们可以看到它使用了不同的NGINX入口控制器实例:</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="a1d2" class="kf kg hh kb b fi kh ki l kj kk">$ kubectl get ingress -A -o custom-columns=NAME:.metadata.name,CLASS:.metadata.annotations."kubernetes\.io/ingress\.class"<br/>NAME                        CLASS<br/>jenkins-dashboard-ingress   nginx<br/>wls-admin-ingress           nginx<br/>wls-cluster-ingress         nginx-applications</span></pre><p id="f5f2" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">要设置会话持久性，我们需要向<code class="du kl km kn kb b">wls-cluster-ingress</code>入口添加至少两个注释:</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="0fbc" class="kf kg hh kb b fi kh ki l kj kk">nginx.ingress.kubernetes.io/affinity: cookie<br/>nginx.ingress.kubernetes.io/affinity-mode: persistent</span></pre><p id="e9d0" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">此外，我们还需要为默认路由映射一个主机名。在我的例子中，我正在设置主机<code class="du kl km kn kb b">wlsoke.com</code>(我还需要编辑我的本地<code class="du kl km kn kb b">/etc/hosts</code>文件，以将它映射到公共负载平衡器IP地址)。要编辑入口:</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="2c2b" class="kf kg hh kb b fi kh ki l kj kk">$ kubectl edit ingress wls-cluster-ingress -n wlsoke07-domain-ns</span></pre><p id="2deb" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">添加上述内容后。yaml文件应该如下所示:</p><figure class="ju jv jw jx fd ii"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="2dac" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">像在<code class="du kl km kn kb b">vi</code>或<code class="du kl km kn kb b">vim</code>等其他编辑器中一样保存文件会自动触发入口配置重新加载:</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="035f" class="kf kg hh kb b fi kh ki l kj kk">$ kubectl edit ingress wls-cluster-ingress -n wlsoke07-domain-ns<br/>ingress.extensions/wls-cluster-ingress edited</span></pre><p id="f8c6" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">现在列出入口资源，我们看到映射的主机:</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="8923" class="kf kg hh kb b fi kh ki l kj kk">$ kubectl get ingress -A<br/>NAMESPACE NAME HOSTS ADDRESS PORTS AGE<br/>jenkins-ns jenkins-dashboard-ingress * 10.0.3.4 80 20d<br/>wlsoke07-domain-ns wls-admin-ingress * 10.0.3.4 80 20d<br/>wlsoke07-domain-ns wls-cluster-ingress wlsoke 193.133.3.17 80 20d</span></pre><p id="973f" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">现在，示例ADF应用程序按预期运行:</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/b750c336d6ecc8fa535bbdd5478d824e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hpiiNp7vp1qsONDeM0_sFw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">ADF Calendar Component</figcaption></figure><p id="369b" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如果我们检查应用程序COOKIE，我们会看到一个名为INGRESSCOOKIE的新cookie。这是由NGINX入口控制器生成的，它确保会话与特定的WebLogic托管服务器pod保持一致。</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kr"><img src="../Images/7c595c059f37e94cc4da5322d5966707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LqWx2UF7Hfdqwf8dsmRDw.png"/></div></div></figure><p id="d036" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我要改变的另一件事是:通过增加外部入口控制器的副本数量，使架构真正实现高可用性:</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="32d2" class="kf kg hh kb b fi kh ki l kj kk">$ kubectl get deployments -A<br/>NAMESPACE NAME READY UP-TO-DATE AVAILABLE AGE<br/>ingress-nginx nginx-ingress-controller 1/1 1 1 20d<br/>ingress-nginx nginx-ingress-controller-external 1/1 1 1 20d<br/>jenkins-ns jenkins-deployment 1/1 1 1 20d<br/>kube-system coredns 4/4 4 4 20d<br/>kube-system kube-dns-autoscaler 1/1 1 1 20d<br/>wlsoke07-operator-ns weblogic-operator 1/1 1 1 20d</span></pre><p id="3d57" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">当然，在运行唯一的<code class="du kl km kn kb b">nginx-ingress-controller-external</code> pod的Kubernetes worker节点崩溃的情况下，另一个实例将在另一个worker节点上自动启动，但这可能意味着几秒钟的停机时间。如果我们将副本数量增加到始终有两个实例运行&amp;,就不会出现这种情况:</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="0a21" class="kf kg hh kb b fi kh ki l kj kk">$ kubectl scale --replicas=2 deployment/ninx-ingress-controller-external -n ingress-nginx<br/>deployment.apps/nginx-ingress-controller-external scaled</span><span id="0635" class="kf kg hh kb b fi ks ki l kj kk">$ kubectl get deployments -A<br/>NAMESPACE              NAME                                READY   UP-TO-DATE   AVAILABLE   AGE<br/>ingress-nginx          nginx-ingress-controller            1/1     1            1           20d<br/>ingress-nginx          nginx-ingress-controller-external   2/2     2            2           20d<br/>jenkins-ns             jenkins-deployment                  1/1     1            1           20d<br/>kube-system            coredns                             4/4     4            4           20d<br/>kube-system            kube-dns-autoscaler                 1/1     1            1           20d<br/>wlsoke07-operator-ns   weblogic-operator                   1/1     1            1           20d</span></pre><p id="b569" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">检查在不同工作节点上运行的两个实例(节点列):</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="8a73" class="kf kg hh kb b fi kh ki l kj kk">$ kubectl get pods -o wide -n ingress-nginx<br/>NAME                                                 READY   STATUS    RESTARTS   AGE     IP             NODE       NOMINATED NODE   READINESS GATES<br/>nginx-ingress-controller-84dbddc6dd-tzck6            1/1     Running   0          20d     10.244.0.131   10.0.4.3   &lt;none&gt;           &lt;none&gt;<br/>nginx-ingress-controller-external-85c7889d47-5hxm5   1/1     Running   0          25h     10.244.0.161   10.0.4.3   &lt;none&gt;           &lt;none&gt;<br/>nginx-ingress-controller-external-85c7889d47-gfvk6   1/1     Running   0          2m32s   10.244.2.12    10.0.4.8   &lt;none&gt;           &lt;none&gt;</span></pre><p id="f182" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如果只是为了好玩，我们取消任何NGINX外部入口控制器pods，ADF应用程序仍然可以访问，因此真正的高可用性:</p><pre class="ju jv jw jx fd ka kb kc kd aw ke bi"><span id="d08b" class="kf kg hh kb b fi kh ki l kj kk">$ kubectl delete pods nginx-ingress-controller-external-85c7889d47-gfvk6 — grace-period=0 — force -n ingress-nginx<br/>warning: Immediate deletion does not wait for confirmation that the running resource has been terminated. The resource may continue to run on the cluster indefinitely.<br/>pod “nginx-ingress-controller-external-85c7889d47-gfvk6” force deleted</span></pre></div></div>    
</body>
</html>