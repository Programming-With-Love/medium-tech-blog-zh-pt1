<html>
<head>
<title>Cloud Camera — Replicating a video stream</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">云摄像机——复制视频流</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/cloud-camera-replicating-a-video-stream-9ec6f9e81c79?source=collection_archive---------6-----------------------#2022-02-10">https://medium.com/oracledevs/cloud-camera-replicating-a-video-stream-9ec6f9e81c79?source=collection_archive---------6-----------------------#2022-02-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/40f36e8b755b0656c72c573e409bd520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwbMo-X71A_eMnrR3B-ZLw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><em class="it">Photo from </em><a class="ae iu" href="https://pixabay.com/photos/roads-split-fork-divided-dirt-320371/" rel="noopener ugc nofollow" target="_blank"><em class="it">https://pixabay.com/photos/roads-split-fork-divided-dirt-320371/</em></a></figcaption></figure><p id="87b5" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">对于那些第一次加入我的人，我写了一篇<a class="ae iu" rel="noopener" href="/oracledevs/cloud-camera-simulating-a-source-4e710299606a">文章</a>，分享了<a class="ae iu" rel="noopener" href="/oracledevs/cloud-camera-simulating-a-source-4e710299606a">如何模拟一个摄像机镜头</a>。这不是什么革命性的东西，但它是未来工作的基石之一。至少对于某些用例来说，这是另一个需要的关键功能。</p><h1 id="afd1" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">基本原理或缺乏基本原理</h1><p id="ed0d" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">为什么要复制一个视频流呢？对于某些用例，延迟视频馈送是可以接受的。这是非实时环境的理想选择，在非实时环境中，延迟不是真正的问题。例如，如果我把一个摄像头对准一个喂鸟器，我可能会想看看什么种类的鸟正在喂鸟器。我不在乎在喂食器那里看到它们，只是一个“视频日志”，我可以随时查看，看看谁访问了喂食器(包括任何邻居的猫，寻找免费的一餐)。对于这个用例来说，类似下面的内容可能是完全可以接受的:</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kw"><img src="../Images/b51ca94a6c68294dcf3f0aa78b07a8be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhipiS3F5ia5G5gGAtYuTg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Non-real-time use-case potential flow</figcaption></figure><p id="0bc8" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">显而易见的是，分析发生在之后<em class="lb">，一个流被保存到存储中，这意味着会有一些滞后(延迟)。观看视频流也是如此。这只有在</em>保存到存储器后<em class="lb">才有可能。是的，延迟观看。</em></p><p id="51c2" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">从线性的、高层次的角度来看，事情大致是这样的:</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/1c366f8852934115f38d5d061aa643e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ydxe8cYJvfXGaRwfx44sww.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Non-real-time use-case high-level flow</figcaption></figure><p id="b1f5" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">所有事情都是连续发生的(一个接一个)。对于上面的非实时用例来说，这是很棒的。别担心。也许我会每周查看一次活动(以及相关的保存视频)，寻找亮点和不足。</p><p id="4afa" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在其他情况下，视频事件反馈需要尽可能即时。最小化延迟是实时用例的关键驱动因素。让我们考虑一下安全摄像头的情况。也许我正在监视我的前门，并希望在送货时得到提醒，这样我就可以将包裹从我的前廊拿下来。我不希望一个包裹在外面放上几个小时，而是希望能迅速得到提示。我还需要能够在任何时间点看到摄像头馈送(不管是否检测到活动)。</p><p id="df5f" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">这是我们想要的:</p><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es ld"><img src="../Images/29932379234f55837cf339659fe26779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*b2uKqO6-ci6-pjQQWGrs6w.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Real-time use-case high-level flow</figcaption></figure><p id="7d7f" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">注意到并行活动的发生了吗？再见串行进程，你好并行化！我们需要观看服务看到的和录制服务保存的完全一样。任何类型的分析都应该查看视频流中完全相同的帧(时间点)。每个服务应该查看视频流的相同时间点。无需等待流被保存到存储设备后再进行查看，只需查看在该确切时间点保存的同一实时流即可！</p><h1 id="58a4" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">这听起来很容易</h1><p id="3599" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">是的，乍一看，这听起来超级简单。向它扔一个负载平衡器！哦，等等…不，那不行。负载平衡器将流量转移到多个进程中的一个进程。我们需要所有进程同时获得相同的数据。嗯…好吧，回到绘图板。</p><h1 id="aa36" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">连接与否，这是一个问题</h1><p id="9ea2" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">值得提醒您的是，UDP是所选的传输协议，因为它有几个可取的特性。参见本系列的<a class="ae iu" rel="noopener" href="/oracledevs/cloud-camera-simulating-a-source-4e710299606a">最后一篇文章</a>，了解为什么使用UDP而不是TCP的更多细节。</p><h1 id="e319" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">iptables来拯救？</h1><p id="5e14" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">原来iptables有克隆包的能力。这叫做<a class="ae iu" href="https://ipset.netfilter.org/iptables-extensions.man.html#lbDU" rel="noopener ugc nofollow" target="_blank">球座</a>。它还明确表示这是为本地目标… TEE似乎没有改变目的地IP地址。这意味着，除非您的目标(目的地)以混杂模式侦听(这通常需要一个定制的应用程序来拦截/处理数据包)，否则它们将被丢弃。这是因为它们将被寻址到一个没有分配给接收机器的网卡的IP地址。你可以在互联网上找到很多尝试使用iptables解决这类问题的例子(这里有一个例子<a class="ae iu" href="https://serverfault.com/questions/236503/need-to-duplicate-udp-packets-to-multiple-destinations-via-iptables" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="d010" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">作为一个潜在的解决方案，我们可以编写一个工具，以混杂模式监听并处理(接收、重定向到实时查看器等。)给我们的小包。如果我们采用这种类型的解决方案，几乎每个接收视频的服务都必须以这种方式编写。</p><p id="e673" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">iptables TEE的另一个挑战是它将发送到一个目的地。看到一些好玩的<a class="ae iu" href="https://www.cyberciti.biz/faq/how-to-use-iptables-with-multiple-source-destination-ips-addresses/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae iu" href="https://unix.stackexchange.com/questions/553832/where-does-the-packet-cloned-by-iptables-mod-tee-go-after-cloning" rel="noopener ugc nofollow" target="_blank">这里</a>(或者上面的链接)。嗯，这是个问题！可以肯定地说，iptables TEE对于这个包复制用例来说是<em class="lb">而不是</em>可行的解决方案。</p><h1 id="2e5e" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么有用？</h1><p id="64a6" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">首先，功劳归功劳:我没有想到这个解决方案。我只是在重复别人精心制作的东西。点击查看<a class="ae iu" href="https://unix.stackexchange.com/questions/553334/setting-up-udp-packets-to-two-different-destinations-using-iptables-and-prerouti" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b4a4" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在我的例子中，我想在端口8100接收一个UDP流，然后将它重新分发到端口8101和8102。下面是在OCI实例上执行的命令:</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="65dd" class="lj ju hh lf b fi lk ll l lm ln">$ socat -U - udp4-recv:8100 | tee &gt;(socat -u - udp4-datagram:127.0.0.1:8101) | socat -u - udp4-datagram:127.0.0.1:8102</span></pre><p id="536a" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">顺便提一下，在OCI服务器上运行两个VLC实例，一个监听udp/8101，另一个监听udp/8102(都在本地主机上)。两人都收到了视频！</p><h1 id="0881" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">回到实时用例</h1><p id="fbdc" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">让我们回到门廊监控摄像头。假设我们有三种服务:</p><ol class=""><li id="8be1" class="lo lp hh ix b iy iz jc jd jg lq jk lr jo ls js lt lu lv lw bi translated">录像机</li><li id="e43f" class="lo lp hh ix b iy lx jc ly jg lz jk ma jo mb js lt lu lv lw bi translated">视频分析器</li><li id="8154" class="lo lp hh ix b iy lx jc ly jg lz jk ma jo mb js lt lu lv lw bi translated">视频浏览器</li></ol><p id="6afb" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">服务#1将负责将视频流保存(保存)到存储位置。这可能是OCI对象存储、数据库、文件系统或其他位置。</p><p id="6115" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">服务#2可以实时查看视频馈送并寻找任何要记录的事件。它可能只是将事件记录到系统日志、数据库、发送电子邮件警报和/或其他内容。</p><p id="15d3" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">服务#3可以显示摄像机馈送的当前视图。这不是查看视频档案(已经保存的流)，而是查看当前的提要。</p><p id="6eaf" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">所有三个服务将在任何给定的时刻获得流的精确副本，这有助于减少解决方案的延迟。从另一个角度来看，通过复制流，我们能够提高响应能力。</p><h1 id="b298" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">TCP呢？</h1><p id="7c77" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">如果我们的用例要求使用TCP，这种简单的数据包复制就不起作用了。我们需要更复杂的东西，至少要处理TCP连接的管理。</p><h1 id="4acf" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">亲自尝试一下</h1><p id="1d87" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">我假设你有一个OCI账户。如果你没有，你真的应该<a class="ae iu" href="https://www.oracle.com/cloud/free/#always-free?source=:ex:tb:::::WWMK220126P00009&amp;SC=:ex:tb:::::WWMK220126P00009&amp;pcode=WWMK220126P00009" rel="noopener ugc nofollow" target="_blank">注册</a>一个。如果你想要一步一步的指导，请参见<a class="ae iu" rel="noopener" href="/oracledevs/create-an-oracle-always-free-cloud-account-bc6aa82c1397">该指南</a>，否则请继续完成<a class="ae iu" href="https://www.oracle.com/cloud/free/#always-free?source=:ex:tb:::::WWMK220126P00009&amp;SC=:ex:tb:::::WWMK220126P00009&amp;pcode=WWMK220126P00009" rel="noopener ugc nofollow" target="_blank"> OCI注册</a>流程。</p><p id="1670" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我是在<a class="ae iu" href="https://github.com/oracle-devrel/terraform-oci-cloud-camera" rel="noopener ugc nofollow" target="_blank"> OCI云相机预建环境</a>下构建的。如果您部署这个<a class="ae iu" href="https://github.com/oracle-devrel/terraform-oci-cloud-camera" rel="noopener ugc nofollow" target="_blank">解决方案</a>，使用通过这个例子创建的计算形状，您就可以在您自己的OCI租赁中遵循它！</p><p id="0c31" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">默认情况下不会安装socat，所以您需要安装它:</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="1a9d" class="lj ju hh lf b fi lk ll l lm ln">$ dnf install -y socat</span></pre><p id="3d5b" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">现在您可以尝试一下了:</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="c238" class="lj ju hh lf b fi lk ll l lm ln">$ socat -U - udp4-recv:8100 | tee &gt;(socat -u - udp4-datagram:127.0.0.1:8101) | socat -u - udp4-datagram:127.0.0.1:8102</span></pre><p id="a07f" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">要退出，请键入CTRL+C。这没问题，但让我们这样做，使它默认运行，并且更容易打开(和关闭)。</p><h1 id="fdd3" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">自动化这项工作</h1><p id="2a1c" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">我引用了这个伟大的<a class="ae iu" href="https://linuxconfig.org/how-to-write-a-simple-systemd-service" rel="noopener ugc nofollow" target="_blank"> how-to </a>来创建一个基本的systemd服务。其他一些有用的参考包括<a class="ae iu" href="https://www.shellhacks.com/systemd-service-file-example/" rel="noopener ugc nofollow" target="_blank">这个</a>、<a class="ae iu" href="https://linuxconfig.org/how-to-create-systemd-service-unit-in-linux" rel="noopener ugc nofollow" target="_blank">这个</a>、<a class="ae iu" href="https://www.how2shout.com/linux/how-to-create-a-systemd-service-unit-file-in-linux/" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae iu" href="https://www.howtogeek.com/67469/the-beginners-guide-to-shell-scripting-the-basics/" rel="noopener ugc nofollow" target="_blank">这个</a>(等等)。编辑新文件:</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="60b8" class="lj ju hh lf b fi lk ll l lm ln">$ sudo nano /usr/lib/systemd/system/udp_duplicator.service</span></pre><p id="1e1f" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">将以下内容放入其中:</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="3db6" class="lj ju hh lf b fi lk ll l lm ln">[Unit]<br/>Description=UDP packet duplicator<br/>After=network.target</span><span id="2301" class="lj ju hh lf b fi mc ll l lm ln">[Service]<br/>Type=simple<br/>ExecStart=bash -c "socat -U - udp4-recv:8100 | tee &gt;(socat -u - udp4-datagram:127.0.0.1:8101) | socat -u - udp4-datagra$<br/>Restart=on-failure</span><span id="faf2" class="lj ju hh lf b fi mc ll l lm ln">[Install]<br/>WantedBy=multi-user.target</span></pre><p id="415b" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">现在让它默认启动:</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="e57a" class="lj ju hh lf b fi lk ll l lm ln">$ sudo systemctl enable udp_duplicator.service</span></pre><p id="ff92" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如果你愿意，你可以用手点燃它:</p><pre class="kx ky kz la fd le lf lg lh aw li bi"><span id="6bf1" class="lj ju hh lf b fi lk ll l lm ln">$ sudo systemctl start udp_duplicator</span></pre><p id="2bd6" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">就是这样！要查看它的运行情况，您可以在OCI实例上启动VLC并打开udp://@:8101。流到UDP端口8100上的OCI计算实例公共IP，您应该会看到视频流！大概，在端口8102上做同样的事情。</p><p id="60ad" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">显然，按照这种设置方式，您需要为您想要使用的任何端口修改服务文件。它确实在我的环境中工作，并且产生了看起来可行的解决方案！</p><h1 id="433c" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="e94b" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">虽然这并不复杂，但并不像我最初预期的那样简单。因为使用了UDP，所以并没有想象中那么难。在这一点上，我们有一个解决方案，我们应该能够专注于即将到来的项目的其他方面。直到下一次，保持位流！</p></div></div>    
</body>
</html>