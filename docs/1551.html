<html>
<head>
<title>Applying Minification and Uglification to AWS Lambda Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对AWS Lambda函数应用缩小化和丑化</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/applying-minification-and-uglification-to-aws-lambda-functions-dbc7ad75241?source=collection_archive---------1-----------------------#2018-04-19">https://medium.com/capital-one-tech/applying-minification-and-uglification-to-aws-lambda-functions-dbc7ad75241?source=collection_archive---------1-----------------------#2018-04-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="20a3" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">最优化实验</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/a8cf327c6c8fc098ac4d6b9baf167780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8BQlfNSvqCNQJqw2JNKruA.png"/></div></div></figure><p id="4be1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">AWS Lambda——或功能即服务(FaaS)——无疑是IaaS生态系统中的游戏规则改变者。它允许后端开发者以有竞争力的价格和效率为他们所使用的东西付费。我在Capital One的团队使用一些Lambda函数来快速启动需要弹性和可用性的功能。尽管AWS Lambda已经针对速度进行了高度优化，但我是一个效率狂，所以每当我在做一些事情时，我总是问自己，“我们如何才能让这个<em class="ke">更加</em>高效？”因此，在过去的几个月里，我一直在尝试优化Lambda函数，看看我是否在最佳地使用它们。</p><p id="ec7d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在优化AWS Lambda函数时，要记住的一点是函数调用的短暂性。以传统的Express Node.js应用程序为例——一旦应用程序启动，它将一直在机器上运行，直到关闭。由于我们工作的应用和技术的性质，后端工程师经常忽略前端工程师更熟悉使用的一个常见程序:<em class="ke">缩小和丑化</em>。</p><p id="bbb2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这可能是优化我们的Lambda函数效率的答案吗？</p><h1 id="9b93" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">浅入AWS Lambda —冷启动与热启动</h1><p id="3852" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">如果您对AWS Lambda有初步的了解，您可能会对图表中显示的内容有所了解:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lc"><img src="../Images/f77976248a9d2db844115772da009407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8T3oB_mV2aL5x_v4mf9UIA.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx"><em class="lh">Note: I realize that AWS is not using Docker Hub and has a highly customized registry but you get the point.</em></figcaption></figure><p id="8649" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里我们有冷启动和暖启动。我们可以把冷启动想象成一个需要从docker Hub下载Docker镜像的EC2实例。我们可以把热启动看作是在EC2实例中已经下载了容器。<em class="ke">注意，这多少是正确的——从这个图中你不知道的是“容器”没有被重新初始化。<br/> </em> <br/>为了测试这个理论，让我们运行一个简单的节点应用程序:</p><pre class="ix iy iz ja fd li lj lk ll aw lm bi"><span id="b943" class="ln kg hh lj b fi lo lp l lq lr">var outer = Date.now();</span><span id="a8f2" class="ln kg hh lj b fi ls lp l lq lr">exports.handler = function(context, event, callback) {</span><span id="462e" class="ln kg hh lj b fi ls lp l lq lr">  var inner = Date.now();</span><span id="11ae" class="ln kg hh lj b fi ls lp l lq lr">  console.log(‘inner: ‘ + inner);</span><span id="0abe" class="ln kg hh lj b fi ls lp l lq lr">  console.log(‘outer: ‘ + outer);</span><span id="aad7" class="ln kg hh lj b fi ls lp l lq lr">}</span></pre><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="bfa3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是非常基本的——它在运行时获得两个变量并打印出来。<br/>理论上，两个变量应该相等(或接近相等)。</p><p id="7bfa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，让我们通过运行以下命令来运行这个应用程序的Docker版本:</p><pre class="ix iy iz ja fd li lj lk ll aw lm bi"><span id="5aed" class="ln kg hh lj b fi lo lp l lq lr">docker run lilnate22/test-lambda.</span></pre><p id="3b1c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们将看到，当您第一次运行这个命令时，它需要一些时间来执行，因为您需要从注册表中下载映像(冷启动)。我们还应该看到两个变量相等或接近相等的输出。</p><p id="6bfc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下次您运行<em class="ke">docker run lil Nate 22/test-lambda</em>时，它将接近即时(热启动)，因为它已经下载到您的机器上了。这是非常基本的东西。<em class="ke">但是当我们在AWS中做同样的事情会发生什么呢？</em> <br/> <br/>来试试吧！复制上面的代码，创建一个新的空白Nodejs 6.10 lambda函数。当您运行新创建的函数时，应该会花费稍长的时间(因为AWS必须“下载”)。在第一次初始化时，您会看到内部和外部计时几乎相等。<em class="ke">但是我们再做一次会怎么样呢？</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lc"><img src="../Images/68a5e8794ad0b8ae7ba10a805a059bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kUT2KWX3oOIvGVyoKvHp7g.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx">wait a minute….why are they different?</figcaption></figure><p id="908d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">提示在于这样一个事实，即<strong class="jk hi"> AWS只在热状态运行期间执行处理函数内部的代码。</strong>即<em class="ke">里面的任何东西exports.handler = function() </em>。那是什么意思？假设我们有一个Lambda函数，它获取每天的彩票号码:</p><p id="dd8c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae lv" href="https://gist.github.com/nfons/c54449e587cd6d970bb4acff24e44f4a" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nfons/c 54449 e 587 CD 6d 970 bb 4 acff 24 e 44 f 4a</a></p><p id="7945" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果我们像编写Docker应用程序一样编写Lambda函数，那么每次Lambda执行都会“获取”彩票号码。</p><p id="3254" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">相反，我们应该优化它，检查是否已经设置了一个依赖项，如果它是空的，只执行昂贵的获取。</p><p id="3de1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae lv" href="https://gist.github.com/nfons/91bca1483d912d6f1a27ad0f37554d4c" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nfons/91 BCA 1483d 912 D6 f1 a 27 ad 0 f 37554 d4c</a></p><p id="dced" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这样，在随后的调用中，我们就不必去做这个过程中昂贵的功能。</p><h1 id="d470" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">缩小+丑陋=速度+成本。</h1><p id="3645" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">缩小/丑化是客户端JavaScript开发的常见组件。前端工程师强调缩小提交给浏览器的CSS/HTML以帮助提高速度的重要性。但是当涉及到你的后端开发人员(服务开发人员)时，缩小化经常被忽略。</p><p id="0031" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">举个例子——如果你在谷歌上搜索“<a class="ae lv" href="https://stackoverflow.com/questions/12068971/does-it-make-sense-to-minify-code-used-in-nodejshttps:/www.quora.com/Is-it-advisable-or-even-possible-to-minify-node-js-code" rel="noopener ugc nofollow" target="_blank">Nodejs minimization</a></p><p id="dfe7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">大多数前端开发人员会感到困惑，并问“为什么？”这在考虑传统的Node.js服务运行时环境时是有意义的。在这些环境中，比如说，你运行一次Express.js rest应用程序，这个应用程序就会一直接受请求。不像客户端代码那样“短暂”,实际上没有必要通过网络将代码发送到浏览器。</p><h2 id="1597" class="ln kg hh bd kh lw lx ly kl lz ma mb kp jr mc md kr jv me mf kt jz mg mh kv mi bi translated">缩小</h2><p id="0fe2" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">缩小是一个常见的前端过程，它在不改变代码逻辑的情况下获取代码并删除所有不必要的字符。</p><p id="0f8d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">假设我们有这样一个代码块:</p><pre class="ix iy iz ja fd li lj lk ll aw lm bi"><span id="e076" class="ln kg hh lj b fi lo lp l lq lr"><strong class="lj hi"><em class="ke">[code]</em></strong></span><span id="3395" class="ln kg hh lj b fi ls lp l lq lr"><strong class="lj hi"><em class="ke">var longvariable = “myname”</em></strong></span><span id="30d8" class="ln kg hh lj b fi ls lp l lq lr"><strong class="lj hi"><em class="ke">var longArray = [1,2,3,4,5,6]</em></strong></span><span id="306e" class="ln kg hh lj b fi ls lp l lq lr"><strong class="lj hi"><em class="ke">//some comment about functionality perhaps?</em></strong></span><span id="14fe" class="ln kg hh lj b fi ls lp l lq lr"><strong class="lj hi"><em class="ke">for(var index = 0; index &lt; 6; index++){</em></strong></span><span id="fd71" class="ln kg hh lj b fi ls lp l lq lr"><strong class="lj hi"><em class="ke">console.log(longArray[index]);</em></strong></span><span id="ea05" class="ln kg hh lj b fi ls lp l lq lr"><strong class="lj hi"><em class="ke">}</em></strong></span><span id="1092" class="ln kg hh lj b fi ls lp l lq lr"><strong class="lj hi"><em class="ke">[/code]</em></strong></span></pre><p id="b727" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">缩小它将删除所有空格、制表符和注释，以输出代码块，如:</p><pre class="ix iy iz ja fd li lj lk ll aw lm bi"><span id="ab32" class="ln kg hh lj b fi lo lp l lq lr"><strong class="lj hi"><em class="ke">[code]</em></strong></span><span id="2b90" class="ln kg hh lj b fi ls lp l lq lr"><strong class="lj hi"><em class="ke">var index,longvariable=”myname”,longArray=[1,2,3,4,5,6] for(index=0;6&gt;index;index++)console.log(longArray[index])</em></strong></span><span id="049d" class="ln kg hh lj b fi ls lp l lq lr"><strong class="lj hi"><em class="ke">[/code]</em></strong></span></pre><p id="0daa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">就在我们的例子中，我们取了一个六行代码，并将其缩减为两行。如果我们将它与Webpack(一个捆绑器)结合起来，它将把多个相关文件压缩成一个文件，我们可以显著减少应用程序中的总行数。</p><h2 id="5114" class="ln kg hh bd kh lw lx ly kl lz ma mb kp jr mc md kr jv me mf kt jz mg mh kv mi bi translated">丑化</h2><p id="f3c6" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">丑化是使代码更加精简的一个额外过程。丑化将所有变量混淆/简化，因此我们的简化示例:</p><pre class="ix iy iz ja fd li lj lk ll aw lm bi"><span id="edb7" class="ln kg hh lj b fi lo lp l lq lr"><strong class="lj hi"><em class="ke">var index,longvariable=”myname”,longArray=[1,2,3,4,5,6] for(index=0;6&gt;index;index++)console.log(longArray[index])</em></strong></span></pre><p id="42a3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">看起来会像这样:</p><pre class="ix iy iz ja fd li lj lk ll aw lm bi"><span id="a713" class="ln kg hh lj b fi lo lp l lq lr"><strong class="lj hi"><em class="ke">for(var o=”myname”,a=[1,2,3,4,5,6],e=0;e&lt;6;e++)console.log(a[e]);</em></strong></span></pre><h1 id="0367" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">为什么要缩小+丑化？？</h1><p id="7eda" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">有几个原因让你想到为什么你会想要变小和变丑。从我做前端开发人员的时候起，我就知道缩小化/丑化的一大好处是它确保了客户端浏览器可以下载尽可能少的文件。将同样的原则应用于Lambda及其短暂的代码功能，我希望同样的好处可以应用于后端工作。</p><p id="f4b8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">但是要记住的另一件事是，AWS Lambda在每个包限制为50MB的区域中，对所有Lambda函数的限制为75GB。因此，即使我们的性能提升不是很大，也许我们可以消除达到75GB限制的麻烦。</p><p id="210f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我创建了一个示例应用程序来说明这一点。随意在这里克隆:【https://github.com/lilnate22/Lambda-Tester/】<a class="ae lv" href="https://github.com/lilnate22/Lambda-Tester/" rel="noopener ugc nofollow" target="_blank"/></p><p id="3a73" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">要运行:</p><pre class="ix iy iz ja fd li lj lk ll aw lm bi"><span id="bb23" class="ln kg hh lj b fi lo lp l lq lr">npm run build</span><span id="89bd" class="ln kg hh lj b fi ls lp l lq lr">zip -r package-raw.zip .</span><span id="4e97" class="ln kg hh lj b fi ls lp l lq lr">zip -r package-ugly.zip bundle.js</span></pre><p id="309b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您查看Zip文件的统计数据:</p><p id="9523" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="ke">原始:13.8MB对缩小:1MB。尺寸超过13倍！</em> </strong></p><h1 id="3d8a" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">例子</h1><p id="1296" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">但是现实世界的例子呢？</p><p id="6577" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在Capital One，我们处理来自不同供应商和合作伙伴的大量数据。在每季度的黑客马拉松中，我们创建了一个Lambda函数，它会自动解析这些数据，并根据适用的数据安全规则来剥离或屏蔽它们。</p><p id="33f6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们在热状态和冷状态下运行这个应用程序100次。虽然AWS没有告诉用户暖态有多长，但我们根据Lambda在容器中的工作方式做了一个安全的假设，即如果我们运行应用程序，在执行完成后，它应该立即处于暖态。如果我们创建100个lambda函数，并在名称后附加一个整数，我们可以执行每个函数一次来计算冷态平均值。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mj"><img src="../Images/80f91d05a34a37c2221705af0482d4ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*C_jpGOXz-BEgGx8SkLy9_Q.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx">Data points for Minified and raw entries (in ms):</figcaption></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lc"><img src="../Images/6cc7c9ae867933985e81cd31bfbdc19b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WfWOZAsqCQ8OrP4MLwWneA.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx">For a warm state execution, we see about a 40% reduction in execution time. <em class="lh">Note: we did see a higher memory footprint though.</em></figcaption></figure><p id="84cd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我预计冷状态执行会更快，但令我惊讶的是，我们只看到缩小和原始函数之间减少了大约30%。尽管冷状态RAW的值比minified的值(高:969，低:737)更加不稳定和不稳定(高:1667，低:903)。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lc"><img src="../Images/652cb9e445e2c4e4c722cc61b703f90d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1YvmLXRwlSieuputXamLg.png"/></div></div></figure><h1 id="121c" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">结果</h1><p id="f66e" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">现在我们已经展示了速度的提高，这对我们的黑客马拉松项目意味着什么？我们确实看到了内存使用量的上升(据AWS报道)。但据我所知，AWS并没有按Mb收费(只按max分配)。<br/> <br/>从成本的角度来看，如果我们外推这些值，我们会看到我们的黑客马拉松项目总共节省了大约20%</p><h1 id="3772" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">最后的想法</h1><p id="0861" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">AWS Lambda已经成为后端开发人员的游戏规则改变者。已经对速度进行了高度优化，通过从前端开发中借用缩小和丑化的概念，我们可以帮助进一步推动我们的功能。</p><p id="4c63" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">作为一个效率狂，我在黑客马拉松项目和个人实验中使用过这种策略，发现它很有前途。这可能是进一步优化Lambda函数效率的答案吗？也许吧。以这种方式使用缩小和丑化的结果可能因应用和项目而异。在优化您自己的AWS Lambda函数时，请仔细权衡您的选择。</p></div><div class="ab cl mk ml go mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ha hb hc hd he"><p id="8a99" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>