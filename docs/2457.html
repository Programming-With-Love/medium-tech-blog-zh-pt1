<html>
<head>
<title>Consuming SQS Message using Golang in EKS (Elastic Kubernetes Service) from AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用来自AWS的Golang(弹性Kubernetes服务)消费SQS消息</h1>
<blockquote>原文：<a href="https://medium.easyread.co/consuming-sqs-message-using-golang-in-eks-elastic-kubernetes-service-from-aws-cf0b30ca0e01?source=collection_archive---------2-----------------------#2020-03-09">https://medium.easyread.co/consuming-sqs-message-using-golang-in-eks-elastic-kubernetes-service-from-aws-cf0b30ca0e01?source=collection_archive---------2-----------------------#2020-03-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8451" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">当我们试图用EKS的Golang(弹性Kubernetes服务)来传达SQS信息时，我们所做的和学到的事情</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/18bb100a500dcfd665afa37853f8c0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IsERlXqHqtY1myaG"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@davideragusa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">davide ragusa</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1fb5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">几天前，我在戈朗研究SQS。相当棘手，但对我来说足够的压力。因为我坚持了5天，只是为了让我的消费者在EKS工作得更好。</p><p id="eeb4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">给一些上下文，<strong class="kv io"> SQS </strong>代表简单队列服务。它是由AWS提供的消息队列服务。关于它的更多细节，你可以在AWS 的<a class="ae ks" href="https://aws.amazon.com/en/sqs/" rel="noopener ugc nofollow" target="_blank"> SQS的官方页面上看到。</a></p><p id="57e6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">简而言之，假设我有一个需要使用大量来自SQS的消息的应用程序。</p><p id="919b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">简单地说，我们可以使用AWS SDK Go来消费SQS消息。但是流程和我用Google Pubsub体验过的完全不一样。在GCP，他们已经准备了一个完整的SDK，它已经有了一个功能，可以长期使用/传输来自Google Pubsub的消息。在AWS中，尤其是SQS，我们需要进行一个长循环并调用REST来提取排队的消息。</p><p id="7007" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我们所做的基本上就是复制这篇很棒的文章“<a class="ae ks" href="https://medium.com/@questhenkart/sqs-consumer-design-achieving-high-scalability-while-managing-concurrency-in-go-d5a8504ea754" rel="noopener"> SQS消费者设计:在Go </a>中管理并发性的同时实现高可伸缩性”。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="22ab" class="lu lv in lq b gy lw lx l ly lz">func (c *consumer) Consume() {<br/> for w := 1; w &lt;= c.workerPool; w++ {<br/>  go c.worker(w)<br/> }<br/>}func (c *consumer) worker(id int) {<br/> for {<br/>  output, err := retrieveSQSMessages(c.QueueURL, maxMessages)<br/>  if err != nil {<br/>   continue<br/>  }  var wg sync.WaitGroup<br/>  for _, message := range output.Messages {<br/>   wg.Add(1)<br/>   go func(m *message) {<br/>     defer wg.Done()<br/>     if err := h(m); err != nil {<br/>       //log error<br/>       continue<br/>     }<br/>     c.delete(m) //MESSAGE CONSUMED<br/>   }(newMessage(m))<br/>   <br/>   wg.Wait()<br/>  }<br/> }<br/>}</span></pre><p id="3615" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">是的，我只是复制他的代码。因为它看起来已经很好了。使用工人模式。那么为什么不正确使用它呢？</p></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><p id="b023" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">TLDR；但是现在，我有两个问题</strong></p><ul class=""><li id="8407" class="mh mi in kv b kw kx kz la lc mj lg mk lk ml lo mm mn mo mp bi translated">链凭证问题</li><li id="179a" class="mh mi in kv b kw mq kz mr lc ms lg mt lk mu lo mm mn mo mp bi translated">使用来自SQS的消息时出现超时错误</li></ul></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h1 id="98f5" class="mv lv in bd mw mx my mz na nb nc nd ne jt nf ju ng jw nh jx ni jz nj ka nk nl bi translated">问题陈述</h1><h2 id="4167" class="lu lv in bd mw nm nn dn na no np dp ne lc nq nr ng lg ns nt ni lk nu nv nk nw bi translated">链凭据</h2><p id="1c3b" class="pw-post-body-paragraph kt ku in kv b kw nx jo ky kz ny jr lb lc nz le lf lg oa li lj lk ob lm ln lo ig bi translated">我们的问题不在于工人或其他东西。它从我们跟随SDK介绍开始。</p><p id="c72b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以问题是，默认的SDK有一个连续的认证顺序。如果您转到此页面，“为Go 配置AWS SDK”，您会发现关于链凭证顺序的信息。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oc"><img src="../Images/d2ca6af2288cb5dbeb7a1cd4f2159044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KD0CBURrYmTZOPF6l8zE6g.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Chain Credentials AWS</figcaption></figure><p id="d538" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从文档中，我们可以了解到SDK将首先寻找ENV键。如果不存在，那么它将查找共享凭证文件。如果凭证文件也不存在，它将查看EC2上的IAM角色，依此类推。</p><p id="db02" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，这里的问题是，在我们的用例中，由于SDK的默认配置将首先加载ENV变量，如果不存在，那么它将查看共享凭证文件，这可能类似于<code class="fe od oe of lq b"><strong class="kv io">AWS_WEB_IDENTITY_TOKEN_FILE</strong></code>。对于本地工作区，它将在AWS config中查找凭证文件，该文件位于<code class="fe od oe of lq b"><strong class="kv io">~/.aws/credentials</strong></code> (Mac/Linux) ( <em class="og">有关更多信息，您可以在这里阅读</em> <a class="ae ks" href="https://aws.amazon.com/id/blogs/security/a-new-and-standardized-way-to-manage-credentials-in-the-aws-sdks/" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="e772" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这对我们来说是个问题。因为该项目将不仅用于我们，但可能会在不同的团队的其他工程师。我们担心的是，其他工程师在他们的本地有一个配置好的AWS配置，它位于<code class="fe od oe of lq b"><strong class="kv io">~/.aws/credentials</strong></code>。我们假设他们有机会在本地运行应用程序，但是使用在<code class="fe od oe of lq b"><strong class="kv io">~/.aws/credentials</strong></code>中配置的生产访问凭证。</p><p id="e36f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，我们真正想要的是:</p><ul class=""><li id="55ca" class="mh mi in kv b kw kx kz la lc mj lg mk lk ml lo mm mn mo mp bi translated">本地开发，我们使用ENV变量</li><li id="ee51" class="mh mi in kv b kw mq kz mr lc ms lg mt lk mu lo mm mn mo mp bi translated">在筹备和生产中，我们使用IAM角色。</li><li id="9ce1" class="mh mi in kv b kw mq kz mr lc ms lg mt lk mu lo mm mn mo mp bi translated">首先避免使用共享凭证文件，以避免其他工程师意外使用生产访问凭证文件。</li></ul><p id="5a43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">首次尝试解决方案<br/> </strong>我们的第一个解决方案是，如果IAM角色存在，我们将首先检测它，然后确定。如果不存在，那么我们的应用程序将查找ENV键<code class="fe od oe of lq b"><strong class="kv io">AWS_ACCESS_KEY_ID</strong></code>和<code class="fe od oe of lq b"><strong class="kv io">AWS_SECRET_ACCESS_KEY</strong></code>。</p><p id="3e1c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我们定制了我们的链凭证，如下所示</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="c318" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您看到上面的函数，尤其是<code class="fe od oe of lq b"><strong class="kv io">credProviders</strong></code>，我们指定凭证链接提供者的顺序，首先，它将查找实例IAM角色，然后查找ENV提供者。因此，我们基本上取消了使用共享凭证文件的身份验证。因此，只要工程师在他们的PC中有一个配置好的AWS凭证密钥(位于<code class="fe od oe of lq b"><strong class="kv io">~/.aws/credentials</strong></code>中),它仍然是安全的，因为SDK将只寻找IAM角色和ENV密钥。</p><p id="597c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">问题<br/> </strong>在做了一个自定义链凭证后，我们发现了另一个问题。它可以在EC2实例中运行良好，但不能在我们的EKS中运行。简而言之，我们的链凭证只在EC2实例级别上起作用。对于EKS的情况，如果我们只允许IAM在节点级别上的角色，它就可以工作。</p><p id="ae57" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">出于安全考虑，对于EKS，我们希望在服务帐户级别或在pods级别使用IAM角色，而不是在节点级别，正如我们在此处的示例“<a class="ae ks" href="https://aws.amazon.com/id/blogs/opensource/introducing-fine-grained-iam-roles-service-accounts/" rel="noopener ugc nofollow" target="_blank">为服务帐户</a>引入细粒度IAM角色”中所看到的那样。</p><p id="3593" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以很明显，我们的定制链凭证对EKS并不适用。所以我们需要改变链式方法。</p><p id="d00d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">最终解决方案<br/> </strong>为了解决这个问题，我们和我们的基础工程师坐在一起。讨论和调试应用程序。花了一整天的时间，经过多次尝试，我们最终决定在我们的应用程序中合理地定制解决方案。</p><p id="238b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">事实证明，要使它在EKS工作，我们必须启用共享凭证文件。这是因为在EKS我们将使用<code class="fe od oe of lq b"><strong class="kv io">AWS_WEB_IDENTITY_TOKEN_FILE</strong></code>，基于这篇<a class="ae ks" href="https://aws.amazon.com/id/blogs/opensource/introducing-fine-grained-iam-roles-service-accounts/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="37ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，要使用web身份令牌文件，我们必须使用文件来启用凭证。这是我们首先要避免的，但是为了在EKS中工作得更好，我们决定使用共享凭证文件来启用chain auth。</p><p id="51a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是为了避免工程师的本地共享凭证文件<code class="fe od oe of lq b"><strong class="kv io">~/.aws/credentials</strong></code>被意外使用，我们决定在应用程序中对其进行逻辑处理(用代码静态编写)。</p><p id="a891" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们使用一个环境变量<code class="fe od oe of lq b"><strong class="kv io">APP_ENV</strong></code>来检查环境是否是本地的。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="c066" class="lu lv in lq b gy lw lx l ly lz">// IsLocal will return true if the APP_ENV is not listed in those<br/>// three condition</span><span id="ce23" class="lu lv in lq b gy oj lx l ly lz">func IsLocal() bool {<br/>  envLevel := MustHaveEnv("APP_ENV")<br/>  return envLevel != "production" &amp;&amp; <br/>         envLevel != "staging" &amp;&amp;   <br/>         envLevel != "integration"<br/>}</span></pre><p id="0d75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以不管<code class="fe od oe of lq b"><strong class="kv io">APP_ENV</strong></code> <strong class="kv io">的</strong>值是多少，如果它不是<code class="fe od oe of lq b"><strong class="kv io">production</strong></code>或<code class="fe od oe of lq b"><strong class="kv io">staging</strong></code>或<code class="fe od oe of lq b"><strong class="kv io">integration</strong></code>我们假设它是局部的。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="eec1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，如果环境不是本地的(<code class="fe od oe of lq b"><strong class="kv io">if !IsLocal()</strong></code>)，我们使用共享的配置文件。如果是在本地，我们使用ENV键，这是必需的，这样我们可以避免在工程师的本地工作空间中意外使用生产访问凭证<code class="fe od oe of lq b"><strong class="kv io">~/.aws/credentials</strong></code>。</p><p id="8047" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这样，我们终于安全地解决了SDK的凭证问题。我们将强制工程师在本地使用ENV键(使用<a class="ae ks" href="https://github.com/localstack/localstack" rel="noopener ugc nofollow" target="_blank"> localstack </a>)。并将在试运行和生产中使用共享凭据文件</p><h2 id="3d8a" class="lu lv in bd mw nm nn dn na no np dp ne lc nq nr ng lg ns nt ni lk nu nv nk nw bi translated">使用定制的HTTP客户端</h2><p id="e483" class="pw-post-body-paragraph kt ku in kv b kw nx jo ky kz ny jr lb lc nz le lf lg oa li lj lk ob lm ln lo ig bi translated">另一个问题是，当我们试图吸收SQS的信息时。但是在讲述细节之前，为了给出一些背景，在AWS SDK文档页面中，我们找到了这篇文章，“<a class="ae ks" href="https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/custom-http.html" rel="noopener ugc nofollow" target="_blank">创建自定义HTTP客户端</a>”。在那个页面上，我们找到了如何定制我们的HTTP客户端。</p><div class="kd ke kf kg gt ab cb"><figure class="ok kh ol om on oo op paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/46f1fd93560f50372a353fd2526e2f44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*cYb5jx4Rn-n4BmYbiy4x6Q.png"/></div></figure><figure class="ok kh oq om on oo op paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><img src="../Images/99aaf4cedc6711bf34a46dd852ead089.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*GBmavELtV-yL2iLWr-YtHQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk or di os ot">Custom HTTP Client on AWS SDK</figcaption></figure></div><p id="ab63" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么，我们就按照这些步骤。我们定制了我们的HTTP客户端。我们设置超时、最大空闲连接等。然后，我们在本地运行(感谢<a class="ae ks" href="https://github.com/localstack/localstack" rel="noopener ugc nofollow" target="_blank"> localstack </a>)。我们在本地测试，一切正常。完美的工作。</p><p id="c284" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，当我们试图在EKS部署它时。在部署到EKS后，我们遇到了很多错误。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="242c" class="lu lv in lq b gy lw lx l ly lz">time="2020-02-06T07:23:02Z" level=error msg="there was an error reading messages from SQS RequestError: send request failed\ncaused by: Post <a class="ae ks" href="https://sqs.ap-southeast-2.amazonaws.com/" rel="noopener ugc nofollow" target="_blank">https://sqs.ap-southeast-2.amazonaws.com/</a>: net/http: request canceled (Client.Timeout exceeded while awaiting headers)"<br/>time="2020-02-06T07:23:02Z" level=error msg="there was an error reading messages from SQS RequestError: send request failed\ncaused by: Post <a class="ae ks" href="https://sqs.ap-southeast-2.amazonaws.com/" rel="noopener ugc nofollow" target="_blank">https://sqs.ap-southeast-2.amazonaws.com/</a>: net/http: request canceled (Client.Timeout exceeded while awaiting headers)"</span></pre><p id="0e69" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">实际上这并不是一个大问题，但是它会增加我们的日志存储，因为这将实时运行，因为我们使用HTTP调用从SQS长期运行拉消息。解决这个问题，我花了两天时间！！！我的两天就这样毁了。WTF！</p><p id="6e3f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">最终解决方案<br/> </strong>我很沮丧，没有人理解为什么这个问题会发生在我的团队里。然后，我决定在Gopher的slack组里问问。</p><p id="4465" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢<a class="ae ks" href="https://app.slack.com/team/UJMFVPR8F" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">安德烈埃里克森</strong> </a> <strong class="kv io"> </strong>和<a class="ae ks" href="https://app.slack.com/team/U46RP390W" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">扎克Easey </strong> </a> <strong class="kv io"> </strong>等人在Slack Gopher<a class="ae ks" href="https://gophers.slack.com/archives/C029RQSEE/p1580979593499800" rel="noopener ugc nofollow" target="_blank">https://gophers . Slack . com/archives/c 029 rqsee/p 1580979593499800</a>。他们帮我解决这里的问题。</p><p id="5168" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">总而言之，这是因为我们启用了长轮询，但是在启用了长轮询和连接的情况下，我们还定制了HTTP客户端。</p><p id="3354" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，解决方案是，对于长轮询消耗来自SQS的消息，我们不应该定制我们的HTTP客户端，我们使用默认的。因为，如果我们定制HTTP客户端(如超时等)，它将与长轮询连接时间竞争，这将导致<code class="fe od oe of lq b"><strong class="kv io">request canceled (Client.Timeout exceeded while awaiting headers)</strong></code>错误频繁发生。</p><p id="f324" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是相当棘手的，因为据我所知，为了避免糟糕的超时和用户体验，我通常会定制我的HTTP客户端。但是在这种情况下，对于SQS，由于我们启用了长轮询调用，正确的解决方案是只使用没有超时设置的默认HTTP客户端。</p></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h1 id="d18f" class="mv lv in bd mw mx my mz na nb nc nd ne jt nf ju ng jw nh jx ni jz nj ka nk nl bi translated">结论</h1><p id="c187" class="pw-post-body-paragraph kt ku in kv b kw nx jo ky kz ny jr lb lc nz le lf lg oa li lj lk ob lm ln lo ig bi translated">在EKS将SQS与围棋相结合时，整个项目的收获是:</p><ul class=""><li id="7b20" class="mh mi in kv b kw kx kz la lc mj lg mk lk ml lo mm mn mo mp bi translated">我们手动处理AWS SDK的定制链凭证，以避免意外使用本地工作区engineers，<code class="fe od oe of lq b"><strong class="kv io">~/.aws/credentials</strong></code>中的生产访问凭证文件。</li><li id="d588" class="mh mi in kv b kw mq kz mr lc ms lg mt lk mu lo mm mn mo mp bi translated">为了在pods级别上启用IAM角色，我们需要允许SDK使用共享的凭证文件，这是相当棘手的，因为我们在本地工作区上禁用了它。</li><li id="424b" class="mh mi in kv b kw mq kz mr lc ms lg mt lk mu lo mm mn mo mp bi translated">我们使用额外的ENV键，如<code class="fe od oe of lq b"><strong class="kv io">APP_ENV</strong></code>，在代码中逻辑地处理链凭证。</li><li id="92ed" class="mh mi in kv b kw mq kz mr lc ms lg mt lk mu lo mm mn mo mp bi translated">如果您启用长轮询连接来消费SQS消息，我们必须使用默认的HTTP客户端，不要自定义它的超时，否则您将面临很多超时错误。</li></ul></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ou oi l"/></div></figure></div></div>    
</body>
</html>