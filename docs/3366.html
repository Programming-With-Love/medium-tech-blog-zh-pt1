<html>
<head>
<title>iOS App Launch time analysis and optimizations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS应用启动时间分析和优化</h1>
<blockquote>原文：<a href="https://medium.com/globant/ios-app-launch-time-analysis-and-optimization-a219ee81447c?source=collection_archive---------0-----------------------#2017-08-27">https://medium.com/globant/ios-app-launch-time-analysis-and-optimization-a219ee81447c?source=collection_archive---------0-----------------------#2017-08-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/fdb85bba1a31d86a660c66ed0ac6149e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOtFeO2p_WSenEhVFyhMig.png"/></div></div></figure><p id="4bbd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">任何产品的第一印象对其长期成功都是至关重要的。拆箱体验必须是最好的，如果手机等有形产品如此，移动应用程序也是如此，而移动应用程序是这些物理设备的核心和灵魂。</p><p id="beda" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当用户从AppStore下载应用程序时，他所关心的是:只需在主屏幕上点击应用程序图标，并尽快体验该应用程序提供的一切。</p><p id="5db0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">也就是说，不管应用程序的<strong class="ir hi">【Launch】</strong>屏幕看起来有多花哨，也许是通过漂亮的动画，或者仅仅是从启动屏幕到闪屏，最后到欢迎/主屏幕的过渡。</p><p id="3846" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗯，所有这些听起来都很明显，但在引擎盖下，应用程序开发人员在未经用户同意的情况下，将他们的错误隐藏在启动屏幕后面。如果你是一个开发者，你一定已经意识到，我在说什么。你看，这样做你会破坏用户对你的应用程序的第一印象。更不用说这些应用程序的用户可能会对这些应用程序评价很差和/或完全放弃它们。</p><p id="0e33" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">那么你应该怎么做呢？</em></p><h2 id="399e" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated"><em class="kj">第一:</em></h2><p id="3e90" class="pw-post-body-paragraph ip iq hh ir b is kk iu iv iw kl iy iz ja km jc jd je kn jg jh ji ko jk jl jm ha bi translated">让我们分析一下问题陈述，首先我们需要了解应用发布的类型:</p><ol class=""><li id="9b4d" class="kp kq hh ir b is it iw ix ja kr je ks ji kt jm ku kv kw kx bi translated"><strong class="ir hi">冷启动:</strong>这仅仅意味着App进程不存在于系统(OS)内核缓冲区缓存中。假设应用程序是第一次启动，或者设备已经重新启动并且内核缓存被清空。这是应用程序启动的最坏情况，因此应该在应用程序启动优化分析中加以考虑。这意味着每次你想测量你的应用程序启动重启设备。</li><li id="3eaa" class="kp kq hh ir b is ky iw kz ja la je lb ji lc jm ku kv kw kx bi translated"><strong class="ir hi">热启动:</strong>这是一种应用程序进程和数据存在于系统内存中的启动类型，系统所做的只是将内存中现有的应用程序实例应用到前台。为了模拟这种情况，可以直接关闭应用程序，然后重新启动。</li><li id="626c" class="kp kq hh ir b is ky iw kz ja la je lb ji lc jm ku kv kw kx bi translated"><strong class="ir hi">热启动:</strong>此启动意味着应用程序不会被终止，但可能会被后台处理或暂停，并且应用程序会被调用并带到前台。</li></ol><p id="e2ad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这三种类型的启动在iOS和Android平台上都很常见。然而，Android的第三种启动类型被称为<em class="jn">不冷不热的启动</em>，它介于冷启动和热启动类型之间。在Android中，这种类型的启动意味着应用程序进程可能存在于内存中，但是活动的实例必须从头开始重新创建。或者，如果流程和活动都不存在于系统内存中，但是<a class="ae ld" href="https://developer.android.com/guide/components/activities/tasks-and-back-stack.html" rel="noopener ugc nofollow" target="_blank">任务</a>的重新创建可以从<em class="jn"> savedInstanceState </em>包中受益，该包是活动的<code class="du le lf lg lh b">onCreate()</code> <em class="jn"> </em>方法的参数。</p><h2 id="0722" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated"><em class="kj">第二:</em></h2><p id="900f" class="pw-post-body-paragraph ip iq hh ir b is kk iu iv iw kl iy iz ja km jc jd je kn jg jh ji ko jk jl jm ha bi translated">让我们分析一下应用发布时间的类型，看看我们能做些什么来改善它。</p><p id="a189" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">回到iOS世界；应用启动时间可以分为两部分:</p><ol class=""><li id="d4ef" class="kp kq hh ir b is it iw ix ja kr je ks ji kt jm ku kv kw kx bi translated"><strong class="ir hi"> pre- </strong> <code class="du le lf lg lh b"><strong class="ir hi">main()</strong></code>时间:返回<code class="du le lf lg lh b">UIApplicationMain</code> <em class="jn"> </em>之前的时间。或者简单的说，当你的应用程序的<code class="du le lf lg lh b">main()</code> <em class="jn"> </em>方法被调用，你得到了OS对App的控制权。到目前为止，你一定已经意识到了，因为这段时间不在你的控制范围内，所以很难管理。然而，dyld有一个内置的度量(一个环境变量:<code class="du le lf lg lh b">DYLD_PRINT_STATISTICS</code>)来分析这一点。如下图所示。</li></ol><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es li"><img src="../Images/c8884f226883d6646f4d85e7cb0fa162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AH8yomKPFruKezlLnTC9DA.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Environment variable setting on Xcode to calculate pre-main time of the App</figcaption></figure><p id="1cdd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您一定已经注意到，构建配置应该设置为<code class="du le lf lg lh b">Release</code>用于计算，因为这是应用程序将在AppStore上发布的配置。此外，总是建议在iPhone上做这个练习，而不是在模拟器上。一旦配置完成，应用程序运行，您将会在控制台上看到<code class="du le lf lg lh b">main()</code>之前的详细计时信息，如下所示:</p><pre class="lj lk ll lm fd lr lh ls lt aw lu bi"><span id="773e" class="jo jp hh lh b fi lv lw l lx ly">Total pre-main time: 1.4 seconds (100.0%)<br/>      dylib loading time: 1.1 seconds (77.4%)<br/>      rebase/binding time: 242.40 milliseconds (16.6%)<br/>      ObjC setup time:  33.04 milliseconds (2.2%)<br/>      initializer time:  53.47 milliseconds (3.6%)<br/>      slowest intializers :<br/>      libSystem.B.dylib :  10.72 milliseconds (0.7%)</span></pre><p id="8af6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些数据给你一个抽象的概念，你的应用程序中可能有什么导致它启动缓慢。要深入了解这些类型，我推荐观看WWDC 2016关于优化应用启动时间的演讲。</p><p id="6024" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如在演讲中提到的，你的应用程序启动时间慢的主要原因可能是使用了多个动态框架。虽然苹果建议只使用6个，但实际上，随着你的应用包含越来越多的功能，你往往会有多个框架。此外，因为您必须已经在您的应用程序中使用了Swift。每个应用程序都必须附带Swift标准库。</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div class="er es lz"><img src="../Images/b6614c2cdf6d264cc1f9274f966148b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*qZgSsmdRtq8eC5JQy2pE2g.png"/></div><figcaption class="ln lo et er es lp lq bd b be z dx">Swift dylib(s) shipped with each iOS App using Swift</figcaption></figure><p id="60cb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好吧，我相信这些库肯定已经被苹果优化了，但是它们仍然存在。然而，在我们完成Swift的<a class="ae ld" href="https://swift.org/blog/abi-stability-and-apple/" rel="noopener ugc nofollow" target="_blank"> ABI稳定性</a>之前，这不是你能控制的。<a class="ae ld" href="https://developer.apple.com/documentation/xcode_release_notes/xcode_10_2_beta_2_release_notes/swift_5_release_notes_for_xcode_10_2_beta_2" rel="noopener ugc nofollow" target="_blank">从Xcode 10.2和iOS 12.2开始</a>应用程序将不再附带Swift标准库。这将使变薄的IPA尺寸减少<strong class="ir hi"> ~9MB </strong>。也就是说，你应该考虑做的第一件也是最重要的事情是:检查所有的依赖关系，如果可能的话，在不打破应用程序逻辑界限的情况下，尽可能多的合并它们。第二步是将依赖关系转换为<code class="du le lf lg lh b">Static Frameworks</code>而不是<code class="du le lf lg lh b">Dynamic Frameworks</code></p><p id="c8f4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du le lf lg lh b">Xcode 9</code>之前，不可能将Swift框架作为静态框架发布，但幸运的是，<code class="du le lf lg lh b">Xcode 9 beta 4</code>之后有了<a class="ae ld" href="https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md" rel="noopener ugc nofollow" target="_blank"> ABI源代码兼容性</a>，这让您可以灵活地将Swift框架作为静态框架发布。您只需将框架目标的构建设置更改为:</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/3e3901372247a7063804586a84b1c64d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3HLijLYURd4LJbiI8GTPoQ.png"/></div></div></figure><p id="9025" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，这适用于纯Swift框架以及同时包含Swift和Objective-C的框架。</p><p id="a4b7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，需要注意的是，如果您使用Objective-C/Hybrid框架作为静态框架，并向消费者应用程序公开Objective-C类或<a class="ae ld" href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" rel="noopener ugc nofollow" target="_blank">类别</a>，您应该确保在框架和消费者应用程序的<em class="jn">构建设置</em>下设置<code class="du le lf lg lh b">OTHER_LDFLAGS = “-ObjC”</code>。下面的截图描述了一个例子:</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/1cee56615d938b02e6aa97b1be4ae83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GZrcsRK3IWA-D7BvBmvz4Q.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Build Setting to load all the members of static archive libraries that implement an Objective-C class or category.</figcaption></figure><p id="f570" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">仅仅通过合并框架并将它们转换成静态框架，您就会看到应用程序在<code class="du le lf lg lh b">main()</code>发布之前和之后的巨大差异。下面显示了一个简单的示例，其中包含4个框架依赖项:</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/02121f6a1ee4bb25411b21d0e1ab8f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ea7WO2B449pywp9FMm2GtA.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx">Dynamic vs Static Frameworks impact on pre-<code class="du le lf lg lh b">main()</code> time</figcaption></figure><p id="2c36" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然这应该有助于你赢得与应用的pre-T1启动时间相关的战斗的<code class="du le lf lg lh b">90%</code>,其余的与编码最佳实践相关，如WWDC演讲中所述:<a class="ae ld" href="https://developer.apple.com/videos/play/wwdc2016/406/" rel="noopener ugc nofollow" target="_blank">优化应用启动时间</a></p><p id="4dd7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">静态框架不仅改善了应用程序的加载时间，而且也有利于应用程序的整体<a class="ae ld" rel="noopener" href="/@avijeet.dutta13/ios-app-size-analysis-76206a18a666">大小。</a></p><p id="f7e6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着<strong class="ir hi"> iOS 13，</strong> dyld3也将包含在iOS应用中，这是一个很大的改进，因为这将使iOS应用的启动速度加快<strong class="ir hi"> 2x </strong>。这是一个来自WWDC 2019的非常好的<a class="ae ld" href="https://developer.apple.com/videos/play/wwdc2019/423/" rel="noopener ugc nofollow" target="_blank">视频</a>，它更详细地解释了所有的优化。</p><p id="6f74" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">继续下一个…</p><p id="7b46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.<strong class="ir hi">后</strong> <code class="du le lf lg lh b"><strong class="ir hi">main()</strong></code>时间:这个因素是你作为一个开发者会完全控制的。因此，这是非常确定的，易于理解和管理。这从你的<code class="du le lf lg lh b">AppDelegate</code>的<code class="du le lf lg lh b"><a class="ae ld" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623032-application" rel="noopener ugc nofollow" target="_blank">application:willFinishLaunchingWithOptions:</a></code>和<code class="du le lf lg lh b"><a class="ae ld" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application" rel="noopener ugc nofollow" target="_blank">application:didFinishLaunchingWithOptions</a></code>开始，一直到你的用户可以看到你的应用程序的“欢迎/回家”屏幕时的<code class="du le lf lg lh b">viewDidLoad</code>和<code class="du le lf lg lh b">viewWillAppear</code>方法。</p><p id="0352" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不用说，如果您已经有了AppDelegates和初始ViewController的层次结构，那么您将需要在上述方法组合的所有级别上测量时间。您总是想把所有的全局初始化代码放在上面提到的AppDelegate的生命周期方法中；大多在<code class="du le lf lg lh b"><a class="ae ld" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application" rel="noopener ugc nofollow" target="_blank">application:didFinishLaunchingWithOptions</a></code>法。但是你必须意识到这样做会增加你的应用程序启动时间。</p><p id="8a1b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在应用程序发布期间，应该进行彻底的分析，尽可能做最少的工作。特别是在这种情况下，我建议在AppDelegate的<code class="du le lf lg lh b"><a class="ae ld" href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622921-application" rel="noopener ugc nofollow" target="_blank">application:didFinishLaunchingWithOptions</a></code>方法中使用三种不同的策略:</p><ol class=""><li id="e462" class="kp kq hh ir b is it iw ix ja kr je ks ji kt jm ku kv kw kx bi translated">首次运行循环:这是你的应用在第一个<code class="du le lf lg lh b">CFRunloop</code>周期中必须配置的。理想情况下，这应该是最少的总工作<code class="du le lf lg lh b">~10%</code>，你想在应用程序启动期间做。</li><li id="7afd" class="kp kq hh ir b is ky iw kz ja la je lb ji lc jm ku kv kw kx bi translated">第二次运行循环:这只是主队列上的一个调度异步，但是可以推迟到第二个<code class="du le lf lg lh b">CFRunLoop</code>周期。这也应该尽可能少。和</li><li id="f4a5" class="kp kq hh ir b is ky iw kz ja la je lb ji lc jm ku kv kw kx bi translated">后台操作:这是全局队列上的调度异步，线程优先级为:<code class="du le lf lg lh b">DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>理想情况下，这是您的最佳选择。尽可能推迟一些不重要的应用程序发布工作。诸如注册到Analytics、配置在应用启动时不立即需要的组件等操作。这肯定会给你带来更好的收益。</li></ol><h2 id="eaf4" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">最后:</h2><p id="43e1" class="pw-post-body-paragraph ip iq hh ir b is kk iu iv iw kl iy iz ja km jc jd je kn jg jh ji ko jk jl jm ha bi translated">简单的方程式是:</p><pre class="lj lk ll lm fd lr lh ls lt aw lu bi"><span id="b798" class="jo jp hh lh b fi lv lw l lx ly">pre-<!-- -->main() time<!-- --> + post-<!-- -->main() time = Total time of App Launch</span></pre><p id="3a30" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">也就是说，为了给用户提供更好的体验，从而最大限度地保留你的产品，你应该在你的应用程序的每个版本中严格检查上述所有策略。</p></div></div>    
</body>
</html>