<html>
<head>
<title>Forecast Anomalies in Refrigeration with PySpark &amp; Sensor-data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用PySpark和传感器数据预测制冷异常</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/forecast-anomalies-in-refrigeration-with-pyspark-sensor-data-195f23ae24e2?source=collection_archive---------0-----------------------#2021-08-04">https://medium.com/walmartglobaltech/forecast-anomalies-in-refrigeration-with-pyspark-sensor-data-195f23ae24e2?source=collection_archive---------0-----------------------#2021-08-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="ed4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">简介</em> </strong></p><p id="b5b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">沃尔玛的足迹遍布美国，每年销售价值数十亿美元的易腐商品。大多数易腐烂的货物都储存在冰箱里以保持新鲜和长久。为了满足客户需求和改善客户体验，制冷系统通过远程设置配置或物理维护进行调节，减少食物浪费、高温问题、机械故障等。</p><p id="50b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个问题是从规模和多样性的角度来看的。大约有50万种不同类型的制冷系统，例如多层冰柜、步入式冰柜、棺材冰柜等。每一个都包含不同类型的食物(如肉类、熟食、冷冻食品、冰淇淋等。)并因此在不同的温度设置下运行。为了避免故障，这种规模的维护需要人力，而且非常耗时。现在，由于闪存尚未上市，所以我们需要找出解决大量并发问题的最佳方法。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7892de9675e78bfb4c99c9dd57430da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wBcMQ_Zv3rwP-7Nt.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Photo Credit: <a class="ae jt" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="d346" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇博客中，我将谈谈我们为解决这个问题而建立的框架。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><p id="0e74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">遥测传感器信息</em> </strong></p><p id="1964" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">制冷系统有四个重要部件:压缩机、冷凝器风扇、蒸发器风扇和膨胀阀。不严格地说，他们一起试图将压力保持在一个合理的水平，以便将温度保持在内(记住，PV = nRT)。在沃尔玛，我们每隔10分钟收集一次所有这些组件的传感器数据(如压力、风扇转速、温度),以及系统是否处于除霜状态、压缩机是否锁定等指标。我们还捕捉外部空气温度，因为它会影响冷凝器风扇速度，进而影响温度。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kb"><img src="../Images/e044f37c82e21f22fffb6f0b36b1f33c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SUJshpGrcwHlb2UT.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Refrigeration Cycle — Four components</figcaption></figure><p id="f73e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当温度高于默认设置时，除霜非常重要，以清除系统中的多冰。如果不解冻，冬天的风将会产生大量可怕的不新鲜食物。与除霜相关的特性，例如最高除霜温度、达到最高温度所需的时间以及回到正常温度所需的时间，所有这些都会影响系统的整体健康状况。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><p id="6992" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">目标</em> </strong></p><p id="5615" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">目标是最大限度地减少故障数量，并提出可能的解决方案以节省时间。因此，我们利用这一遥测信息来<em class="jc">预测</em>温度异常，这将有助于确定问题的优先顺序，并且是主动的而不是被动的。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><p id="210b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">数据准备</em> </strong></p><p id="6d39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用了过去两年的遥测信息，并从10分钟开始每小时汇总一次。原因是，数据越细，噪音就越大。此外，像每个传感器信息一样，这些数据容易丢失和错误的传感器值。因此，通过每小时一次的汇总，我们试图将这些数据的插补次数减到最少。由于我们希望预测温度异常，因此，将温度建模为我在遥测传感器信息部分提到的功能的函数，并预测未来72小时的温度。</p><p id="91ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">挑战在于，除了室外气温，我们没有任何特征的未来值。我们使用了第三方供应商对未来72小时气温的预测，非常准确。现在，单变量预测或仅以气温为特征的预测可能是一种选择，但这样一来，我们将失去压力或风扇速度等变化的信息。因此，对于预测，我们使用最后96小时数据的滞后，并保留每6小时的滚动平均值作为特征值。例如，如果我想预测6月1日上午12点的天气，我将使用5月28日下午7点到5月29日上午12点的平均值来预测某个特定的特性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kc"><img src="../Images/119d7b2b5cfd0822376b6e8f7261f053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CZfw5f0jYyV0zidm.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Feature calculation at forecast point</figcaption></figure></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><p id="9961" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">造型</em> </strong></p><p id="174b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们试验了不同的建模技术，从ARIMAX开始，然后是贝叶斯结构时间序列(BSTS)和Prophet。这些算法的细节可以在这里找到:<a class="ae jt" href="https://robjhyndman.com/hyndsight/arimax/" rel="noopener ugc nofollow" target="_blank"> ARIMAX </a>，<a class="ae jt" href="https://www.unofficialgoogledatascience.com/2017/07/fitting-bayesian-structural-time-series.html" rel="noopener ugc nofollow" target="_blank"> BSTS </a>，<a class="ae jt" href="https://facebook.github.io/prophet/docs/quick_start.html" rel="noopener ugc nofollow" target="_blank">先知</a>。嵌入代码片段是为了便于执行。</p><p id="8751" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kd ke kf kg b">Pseudo code for ARIMAX &amp; BSTS in <strong class="ig hi"><em class="jc">R</em></strong>:</code></p><pre class="je jf jg jh fd kh kg ki kj aw kk bi"><span id="4b48" class="kl km hh kg b fi kn ko l kp kq">library(dplyr)<br/>library(forecast)<br/>library(bsts) </span><span id="24d4" class="kl km hh kg b fi kr ko l kp kq"># df : dataframe consisting 'ds'(timestamp), 'y' and other exogenous variables<br/># future_df : dataframe consisting lagged feature variables for forecast </span><span id="de13" class="kl km hh kg b fi kr ko l kp kq">############# ARIMAX ############</span><span id="e149" class="kl km hh kg b fi kr ko l kp kq"># Create ts object<br/>train.ts &lt;- ts(df$y, frequency = 24)  </span><span id="3a87" class="kl km hh kg b fi kr ko l kp kq"># Fit &amp; Forecast<br/>fit &lt;- try(auto.arima(train.ts, <br/>                      xreg = as.matrix(df[, 3:ncol(df)]), seasonal=TRUE), silent = TRUE) </span><span id="8e4d" class="kl km hh kg b fi kr ko l kp kq">if(inherits(fit, "try-error")){  <br/>  print('Fit Failed')<br/>}else{  <br/>  # Forecast the model  <br/>  fc &lt;- forecast(fit, <br/>                 xreg = future_df %&gt;% as.matrix(), h = nrow(future_df))  <br/>  y_hat &lt;- fc$mean # forecasted value<br/>} </span><span id="73b3" class="kl km hh kg b fi kr ko l kp kq">############# BSTS ############### </span><span id="3744" class="kl km hh kg b fi kr ko l kp kq"># ss: state space<br/>ss &lt;- AddLocalLinearTrend(list(), df$y)<br/>ss &lt;- AddSeasonal(ss, df$y, nseasons = 24) </span><span id="1f38" class="kl km hh kg b fi kr ko l kp kq"># Fit Model<br/>setseed &lt;- 2021<br/>model_fit &lt;- bsts(y~., <br/>                  state.specification = ss, <br/>                  niter = 5000, <br/>                  data = df[, 3:ncol(df)], <br/>                  seed = setseed) #, expected.model.size = 5)</span><span id="9649" class="kl km hh kg b fi kr ko l kp kq">burn_fit &lt;- SuggestBurn(0.1, model_fit) </span><span id="d0ea" class="kl km hh kg b fi kr ko l kp kq">fc_bsts &lt;- bsts::predict.bsts(model_fit, <br/>                              horizon = nrow(future_df), <br/>                              newdata = future_df, <br/>                              seed = setseed, <br/>                              burn = burn_fit, quantiles = c(.05, .95))<br/>future_df$bsts_yhat &lt;- fc_bsts$mean</span></pre><p id="abf1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">先知是<em class="jc">被选中的人</em>。字面意思！！但如果你不相信先知，看看下一节背后的逻辑。</p><p id="d916" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">插补和<em class="jc">多重共线性</em>检查的初步步骤已经完成。对于我们正在处理的每小时数据，我们已经结合了每日和每周的季节性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ks"><img src="../Images/bc11863bbc638ef60001db0a0d778513.png" data-original-src="https://miro.medium.com/v2/resize:fit:120/0*NorVIVaflmaPsHwm"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/afd221b19490449b517cb69fd4b375c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z5mDevOjHdy0vDdi.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Trend &amp; Seasonality</figcaption></figure><p id="217b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个制冷系统都有一个基于其类型和食物含量的预定义的有利温度范围。假设，</p><p id="cb81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc"> d1:与有利温度带的预报差异，d2:与近期平均温度的差异</em></p><p id="fbca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果最近的气温在范围之内，我们就用<em class="jc"> d1、</em>来衡量预测，但如果它们已经超出范围，就用<em class="jc"> d2 </em>来衡量。当除霜关闭时，基于这些差异，预测被标记为异常(无论如何除霜打开意味着高温！).除霜时间或多或少保持不变，因此在产生异常时这些时间点被排除在外。</p><p id="ef21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据这些差异的大小和超出范围的持续时间(以小时为单位),对异常进行优先排序。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><p id="b053" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">型号选择</em> </strong></p><p id="1bdd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们选择了一个具有良好数据质量的制冷系统样本来评估不同的算法。ARIMAX、BSTS和Prophet对MAPE的平均预测分别约为4-6%、2.5-4%和3.5-5%。通常我们使用精度指标来选择模型，但这里我们也需要考虑其他重要因素。</p><p id="2e48" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，准确性与执行时间同样重要，因为我们每天要处理大约3600家商店中大约50万个系统的预测。由于BSTS依赖于<em class="jc"> MCMC采样</em>，所以运行时间比其他方法要长得多，但准确性几乎没有提高。因此，我们放弃了BSTS！</p><p id="efe6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一个重要方面是能够提供异常的<em class="jc">原因</em>，而不仅仅是预测。在任何模型的情况下，我们都会得到基于<em class="jc"> p值</em>的重要变量列表，但它依赖于整个训练数据，并不关注最近的变化。</p><p id="a2c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Prophet有一个称为<em class="jc">变点</em>检测的特性，即它允许趋势随着时间的推移改变方向。Prophet通过首先指定速率允许变化的大量<em class="jc">潜在变化点</em>来检测变化点。然后，它在速率变化的幅度上放置一个稀疏的先验(相当于L1正则化)，这实质上意味着Prophet有大量速率可能变化的<em class="jc">可能</em>位置，但将使用尽可能少的位置。更多详情<a class="ae jt" href="https://facebook.github.io/prophet/docs/trend_changepoints.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/c54e4ce48162bb4ab4c53396f9acbeab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e-rIsrtEjh6qmXdk.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Light Blue:Actual, Dark Blue:Predicted, Black:Trend, Red:Favorable Temperature Band</figcaption></figure><p id="f332" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上图中<em class="jc">垂直</em>黑线为温度变化点。这很有用，因为它有助于通知温度模式的任何突然变化。默认情况下，Prophet指定了25个潜在的变化点，这些点均匀地位于时间序列的前80%。这些超参数可以通过<em class="jc"> n_changepoints </em>和<em class="jc"> changepoint_range进行更改。</em></p><p id="42a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kd ke kf kg b">Pseudo code for model change-point in <strong class="ig hi"><em class="jc">Python</em></strong>:</code></p><pre class="je jf jg jh fd kh kg ki kj aw kk bi"><span id="798d" class="kl km hh kg b fi kn ko l kp kq">from fbprophet import Prophet<br/> <br/># df : dataframe consisting 'ds'(timestamp), 'y' and other exogenous variables<br/># future_df : dataframe consisting lagged feature variables for forecast<br/># features : list of features to be included in the model after multi-collinearity checks </span><span id="043c" class="kl km hh kg b fi kr ko l kp kq"># create an expression instead of including each regressor separately </span><span id="7ebf" class="kl km hh kg b fi kr ko l kp kq">all_fea = [str(".add_regressor('") + str(features[i]) + str("')") for i in range(0, len(features))]<br/>all_fea = ''.join(all_fea) </span><span id="bd55" class="kl km hh kg b fi kr ko l kp kq"># No need to put seasonalities separately. <br/># Prophet detects the frequency of the data itself<br/># If the frequency is less than daily, then it includes daily &amp; weekly seasonality automatically </span><span id="cb43" class="kl km hh kg b fi kr ko l kp kq">exp = str("Prophet(changepoint_prior_scale = 0.05, changepoint_range=0.8)") + all_fea + str(".fit(df)")  </span><span id="952c" class="kl km hh kg b fi kr ko l kp kq"># Fit &amp; Predict</span><span id="7d9b" class="kl km hh kg b fi kr ko l kp kq">model_prophet = eval(exp)<br/>fcst_all = model_prophet.predict(future_df) # It will contain yhat, trend, seasonalities</span></pre><p id="6935" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用了相同的特征来检测潜在的特征，该特征可能是这种突然变化的<em class="jc">原因</em>。因此，每一个特性将分别通过Prophet模型并搜索最近的变化点。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/69394eb86081e89735523c1b7ced5133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7WwiF_A2nKNbNJRG.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Plot of one of the feature variables — Blue:Actual, Maroon:Trend</figcaption></figure><p id="bd6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">只要温度模式有任何变化，我们就会在2-3天内寻找特征变量的变化，并提供它们作为潜在的原因。因为这种内在的神圣属性，我们选择了先知而不是ARIMAX。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><p id="bfdf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">验证</em> </strong></p><p id="ba1a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于大约85%的系统，验证集上的模型预测准确度<em class="jc">高于</em> <em class="jc"> 90%。但是，要了解模型诊断异常的能力，预测的准确性是不够的。因此，我们通过对已经记录的故障问题进行回溯测试来验证异常检测性能。对于回溯测试，我们使用<em class="jc"> recall </em>来了解模型可以捕获多少实际问题！</em></p><p id="d118" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">平均而言，如果最近的历史温度<em class="jc">在带内，则67%的时间异常被准确预测，如果最近的历史温度</em>在带外，则84%的时间异常被准确预测。后者更高，因为系统在有利温度带之外运行时变得更容易异常。</p><p id="2372" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">中小企业也验证了产生的异常现象。这是必需的，因为并非所有异常都被记录为故障问题。有些是小问题，可以通过远程配置更改来解决。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><p id="5c89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">缩放&amp;部署</em> </strong></p><p id="9d59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">集合时间到了！！已经建立了一个自动化框架，通过批处理每天生成异常。使用<em class="jc"> PandasUDF </em>并通过<em class="jc"> PySpark </em>进行并行化(参见<a class="ae jt" href="https://databricks.com/blog/2020/01/27/time-series-forecasting-prophet-spark.html" rel="noopener ugc nofollow" target="_blank">此处</a>)。从数据提取到模型存储，Azure Cloud得到了充分利用。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/e9344b09cb141be92c84ac62c0360bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q13r7tWGMlAKnI9T.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Architecture Diagram</figcaption></figure><p id="c1ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">前端应用已经部署到沃尔玛云原生平台(WCNP)。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><p id="638a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">结论</em> </strong></p><p id="c5a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">异常的预测和优先排序大大简化了维护流程。但是在提高维护过程本身的有效性方面，仍然有很大的空间。我们正在探索通过识别<em class="jc">机械层面</em>异常的根本原因并推荐正确的措施来解决这些问题，从而最大限度地缩短每个问题的解决时间并防止问题再次出现。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><p id="cbcd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">参考文献</em> </strong></p><p id="7ef2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里有一些关于详细的Prophet方程和PySpark缩放的参考资料。</p><div class="ku kv ez fb kw kx"><a rel="noopener follow" target="_blank" href="/future-vision/the-math-of-prophet-46864fa9c55a"><div class="ky ab dw"><div class="kz ab la cl cj lb"><h2 class="bd hi fi z dy lc ea eb ld ed ef hg bi translated">先知的数学</h2><div class="le l"><h3 class="bd b fi z dy lc ea eb ld ed ef dx translated">打破脸书开源时间序列预测程序背后的方程式</h3></div><div class="lf l"><p class="bd b fp z dy lc ea eb ld ed ef dx translated">medium.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll jn kx"/></div></div></a></div><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lm ln l"/></div></figure><div class="ku kv ez fb kw kx"><a href="https://databricks.com/blog/2020/01/27/time-series-forecasting-prophet-spark.html" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab dw"><div class="kz ab la cl cj lb"><h2 class="bd hi fi z dy lc ea eb ld ed ef hg bi translated">用Prophet &amp; Spark进行时间序列预测</h2><div class="le l"><h3 class="bd b fi z dy lc ea eb ld ed ef dx translated">试试Databricks中的时间序列预测笔记本时间序列预测的进步使零售商能够…</h3></div><div class="lf l"><p class="bd b fp z dy lc ea eb ld ed ef dx translated">databricks.com</p></div></div><div class="lg l"><div class="lo l li lj lk lg ll jn kx"/></div></div></a></div></div></div>    
</body>
</html>