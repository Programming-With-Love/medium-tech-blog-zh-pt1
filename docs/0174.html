<html>
<head>
<title>Building a Faster Web Experience with the postTask Scheduler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用任务后计划程序构建更快的Web体验</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/building-a-faster-web-experience-with-the-posttask-scheduler-276b83454e91?source=collection_archive---------1-----------------------#2021-05-20">https://medium.com/airbnb-engineering/building-a-faster-web-experience-with-the-posttask-scheduler-276b83454e91?source=collection_archive---------1-----------------------#2021-05-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c94938a0399040976c964b4d891c9bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jE9sERwYdWpv_nUoRDRXlg.jpeg"/></div></div></figure><p id="bbb0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你上一次在网站上打开一个页面并试图多次点击某个东西以使其工作是什么时候？或者你最后一次在旋转木马上滑动图像时，它会不自然地结巴和移动？</p><p id="db17" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然这种类型的体验经常发生，但我们可以使用工具来帮助我们为用户提供更好、更具响应性的体验。有效地安排和优先处理任务可能是反应灵敏的体验和感觉迟钝的体验之间的区别。</p><p id="a0fe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Airbnb，我们一直在与Chrome团队合作，使用优先任务调度程序来提高性能，以实现新的模式并提高现有模式的性能。</p><h1 id="5ac6" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">满足优先任务后计划程序的要求</h1><p id="0752" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated"><a class="ae kq" href="https://github.com/WICG/scheduling-apis/blob/main/explainers/prioritized-post-task.md" rel="noopener ugc nofollow" target="_blank">优先级任务后API </a>旨在为我们高效调度任务提供更多的灵活性和能力。与<a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback" rel="noopener ugc nofollow" target="_blank"> requestIdleCallback </a>和<a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank"> setTimeout </a>类似，有效地使用它可以帮助减少<a class="ae kq" href="https://web.dev/tbt/" rel="noopener ugc nofollow" target="_blank">总阻塞时间</a>、<a class="ae kq" href="https://web.dev/fcp/" rel="noopener ugc nofollow" target="_blank">第一次内容绘制</a>、<a class="ae kq" href="https://web.dev/fid/" rel="noopener ugc nofollow" target="_blank">输入延迟</a>和<a class="ae kq" href="https://web.dev/custom-metrics/#long-tasks-api" rel="noopener ugc nofollow" target="_blank">其他关键指标</a>。</p><p id="fb32" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然许多性能工作都集中在初始页面加载上，但我们希望在页面加载后改善用户体验。我们以多种方式使用了任务后调度器——从我们如何在传送带上预加载图像到使我们的地图更加灵敏。</p><p id="e45f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了了解自这项工作开始以来我们所取得的进展，<a class="ae kq" href="https://www.youtube.com/watch?v=e215_uiU3LQ" rel="noopener ugc nofollow" target="_blank">我们创建了新的真实用户监控性能指标</a>，并利用来自工具<a class="ae kq" href="https://www.webpagetest.org/easy" rel="noopener ugc nofollow" target="_blank">网页测试</a>和<a class="ae kq" href="https://developers.google.com/web/tools/lighthouse" rel="noopener ugc nofollow" target="_blank">灯塔</a>的现有基于实验室的指标。</p><p id="4be7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">怎么开始的</strong></p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ks"><img src="../Images/155a9801a7ef07f42a2fab70f9496d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GM30aPSBUMR78m0J"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Total Blocking Time was nearly 16 seconds loading our search results page</figcaption></figure><p id="6222" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最近怎么样</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lb"><img src="../Images/bbe9367ea513c15a3f57bf5cea7dad9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sPuqPzLVckzRSj4z"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Total Blocking Time improved by nearly 10 seconds for a typical mobile web user on average hardware</figcaption></figure><h1 id="0c74" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是任务后调度程序？</h1><p id="ea15" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">与requestAnimationFrame、setTimeout或requestIdleCallback非常相似，scheduler.postTask允许我们在浏览器的事件循环上调度一个函数。然后，该功能将被优先化并由浏览器运行。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es lc"><img src="../Images/eca136486ea161a829fe0908c33f80ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*qJMiqKGd5cas7iqRRz0JJQ.png"/></div></figure><p id="e779" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">“前两个——微任务和不让步——通常与计划和提高响应能力的目标是对立的。它们是开发者可以并且确实使用的隐含优先级。”</p><h1 id="e3a5" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">分解长时间的任务</h1><p id="ae01" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">为了提高响应能力，我们可以也应该将我们的长期任务分解开来。下面是一个长任务的例子，它设置了基本的错误跟踪和事件日志。注意浏览器是如何将任务标记为一个<a class="ae kq" href="https://w3c.github.io/longtasks/" rel="noopener ugc nofollow" target="_blank">长任务</a>的。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ld"><img src="../Images/c0e54038139b366eda0680aee42d4512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gCfCj2i4HRyprPFWHLYR4Q.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">249ms long task early during the page lifecycle</figcaption></figure><p id="be8a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦我们确定了一个长任务，我们可以使用postTask将任务分解成更小的任务。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lg"><img src="../Images/ac3f82c1e1a7ca6e5e191bc338907693.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iHMjICJM8p_4MJKXIoknKw.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">After using scheduler.postTask, we no longer have any long tasks, only smaller ones below the Long Task threshold</figcaption></figure><h1 id="a05a" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">你好，任务后</h1><p id="e642" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">目前，postTask是在chrome://flags下的# enable-experimental-web-platform-features标志后面的chrome中实现的<a class="ae kq" href="https://www.chromestatus.com/features/6031161734201344" rel="noopener ugc nofollow" target="_blank">，并计划在即将到来的版本中完全支持Chrome。虽然polyfill已经存在，但在撰写本文时，polyfill还没有被开源。官方的polyfill状态可以在WICG repo </a>上追踪，但在那之前我们可以在Chrome Canary上试用。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="b75b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的例子中，我们向postTask传递了一个新的<strong class="ir hi">延迟</strong>和<strong class="ir hi">优先级</strong>参数，告诉它我们希望在等待1秒钟后在后台运行我们的任务。任务后调度程序目前支持3种不同的优先级。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lh"><img src="../Images/8d92199ea314f442723f507e3a8be9fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqiJr6uePtE406jIAhXjKw.png"/></div></div></figure><p id="b951" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">任务后调度器的好处之一是它建立在<a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal" rel="noopener ugc nofollow" target="_blank">中止信号</a>之上，允许我们取消一个已经排队但尚未执行的任务。API还定义了一个新的<a class="ae kq" href="https://wicg.github.io/scheduling-apis/#sec-task-controller" rel="noopener ugc nofollow" target="_blank"> TaskController </a>，它允许信号使用优先级来控制任务和优先级。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><h1 id="e875" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">推迟非关键任务</h1><p id="e4d7" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">大多数网站加载了大量的第三方库，比如Google Analytics、Tag Manager、logging libraries等等。衡量和理解这些对用户初始加载体验的影响很重要。</p><p id="e022" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，Airbnb优先考虑让用户可以输入搜索词，这需要我们加载一些JavaScript并用React“水合”我们的页面。将某些任务推迟到关键时刻完成可能是有意义的。</p><h1 id="370a" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍实验性的“scheduler.wait”</h1><p id="5a51" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">scheduler.wait是一个提议的扩展，允许等待页面中的某个里程碑，在我们的例子中是一个定制的DOM事件。让我们看看如何在加载完页面后使用它来加载Google Tag Manager。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div><figcaption class="kx ky et er es kz la bd b be z dx">Without a polyfill, this won’t work in any browser yet!</figcaption></figure><p id="e68e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种方法的美妙之处在于它的简单性——我们得到一个承诺，我们可以阻止它，直到我们的自定义事件被触发。</p><p id="fd4c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还可以在任何任务中指定这个选项，作为传递给postTask的选项，从而进一步简化我们的Google Tag Manager注册。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="afd1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">按照现在的定义，多填充等待函数相对来说比较容易，因为它采用与postTask相同的选项，但不需要指定任务。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="ad38" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还需要在上面的shim中使用的postTask方法周围创建一个包装器，以便在调用scheduler.postTask时支持事件选项。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="dd68" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面waitForEvent调用的代码是一个将DOM事件映射到promise的包装器，promise在触发时解析，允许我们等待postTask包装器中的任何事件。对于这将如何进行，还没有标准定义的方法。我们的实现非常简单——例如，如果我们在一个单页面应用程序中，并且页面发生了变化，它不能在事件被触发后重置事件的状态。在这种情况下，我们可能想要触发一个新的加载事件。在<a class="ae kq" href="https://github.com/WICG/scheduling-apis#apis-and-status" rel="noopener ugc nofollow" target="_blank">提议的API增加</a>中有一系列的选项正在探索，所以预计这将继续发展。</p><h1 id="9a62" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">用例:预取重要资源</h1><p id="a271" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">在用户加载之前，预加载图片轮播中的下一张图片或页面的细节，可以极大地提高站点的性能和用户的感知性能。我们最近使用postTask调度器为我们的主要搜索结果图像传送带实现了一个延迟的、交错的、可取消的图像预加载器。让我们看看如何使用postTask构建它的简单版本。</p><p id="d380" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">对我们列表传送带上的图像预加载器的要求:</strong></p><ul class=""><li id="12c8" class="li lj hh ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated">等到列表在屏幕上大约50%可见</li><li id="c6d3" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">延迟一秒；如果用户仍在查看它，加载转盘中的下一个图像</li><li id="d37e" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">如果用户在一幅图像上滑动，预载接下来的三幅图像，<em class="kr">每一幅在前一幅开始后的100毫秒</em></li><li id="ec89" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">如果圆盘传送带在一秒钟计时器结束之前的任何时候离开了视窗，我们应该取消所有尚未完成的预加载任务。如果用户导航到另一个页面，也取消所有的预加载任务</li></ul><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lw"><img src="../Images/f2b3737d71ab2d580f305a0004498b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QLlVrXv404cqYzxOvDwP9Q.gif"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">When the next slide scrolls into view, the 2nd image loads. Once we swipe, the next 3 load, each beginning 100ms after the previous one</figcaption></figure><p id="119d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从第一部分开始，如果用户将卡片滚动至少50%一秒钟，就预加载转盘中的下一张图像。虽然我们在接下来的几个示例中使用React，但这并不是必需的。这里的所有概念也可以用其他框架实现，或者更重要的是，根本不用框架。</p><p id="7dd0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设我们有一个名为preloadImages的方法，它开始获取下一个图像，并在完成图像预加载后切换一个布尔字段。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="136c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以将它与交叉点观察器和任务后调度器结合起来，并在一秒钟内完成50%视图后加载第二个图像。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="8ca6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">幕后有一大堆逻辑在运行，所以让我们把它分解成更小的步骤来理解发生了什么。</p><p id="6ad6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们先来看看如何确定一个用户是否至少有50%进入了我们的视野。对于这个任务，我们可以使用交叉点观察器。我们使用一个小助手来设置它们，但是你也可以不用库来使用它们。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="cf3a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然我们已经知道何时我们已经滚动到视图的50%,我们可以使用一个结合了scheduler.postTask的useEffect钩子来等待它们在视图中停留一秒钟。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="4d53" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为我们还传递了一个关联的TaskSignal，所以当用户滚动到视图之外时，对abort()的调用将取消任何对preloadImages的未决调用。我们还注意删除对控制器的引用，以便在它们滚动回视图时允许重新启动流。</p><p id="56a2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">交错网络资源<br/> </strong>我们需要实现的最后一个需求是交错接下来的几个图像请求，每个请求在用户在旋转木马上滑动之后100毫秒。让我们看看如何使用任务后调度程序来修改现有代码，以解决这种情况。首先，让我们添加一个钩子来调用我们的预加载逻辑，当用户与它交互时，有三个图像要预加载。我们将跳过第一张图片，因为我们已经加载了它。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="fde5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">任务后调度器的目标之一是提供一个底层API来构建。我们已经建立了一个集成，当在React中使用我们认为非常有用的模式或策略时，它可以让我们执行许多不同的模式或策略。</p><h1 id="73eb" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">在React中有效使用后任务</h1><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/de85d49e11223041bd1f329d8397a551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WG39QbJaL86XeWlY"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Opt-in debugging, showing total time taken and other useful information</figcaption></figure><p id="ff44" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同时与React、Vue、Angular、Lit等进行自定义集成。没有必要，我们可以通过这样做获得一些主要的好处。例如，在React中，当一个组件卸载时，我们通常希望取消任何仍在排队的任务。</p><p id="7fda" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以通过将一个函数作为返回值传递给useEffect来实现。然而，记住每次都这样做是一个挑战，不这样做可能会导致内存泄漏。当我们调用abort()时，记住捕捉调度程序抛出的任何AbortError也是一个挑战，因为这些都是非常期望的，但不是我们可以一概而论的异常。</p><p id="5c58" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们为usePostTaskScheduler挂钩列出一些好处，让人们更容易使用。</p><ul class=""><li id="5902" class="li lj hh ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated">传递一个enabled标志，允许绕过调度程序，使A/B测试更容易</li><li id="d6ff" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">允许轻松取消，包括卸载时自动取消</li><li id="949d" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">将信号自动传播到scheduler.postTask和scheduler.wait</li><li id="c497" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">捕捉和压制流产或任何类似的东西</li><li id="1c2d" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">支持强大的调试功能</li><li id="9f29" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">允许为常见模式指定一个策略，比如我们在这篇文章中提到的2个模式</li><li id="7d06" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">添加一个等待延迟完成的挂钩</li></ul><p id="1756" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然深入研究这个钩子的实现超出了本文的范围，但是让我们看看它如何简化React中的postTask调度程序的使用。让我们延迟加载一个高成本、低重要性的React组件，直到加载事件触发之后，并在加载之后清除一些旧的localStorage状态。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="b04d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里我们可以看到，我们有一个布尔标志，它将指示加载何时完成，还有一个传统的回调，它让我们可以清理localStorage键。在这种情况下，如果该组件在该事件之前卸载，我们将取消cleanupLocalStorageKeys的任务，并且不再呈现<ExpensiveComponent/>。在我们的例子中，ExpensiveComponent是异步加载的，因此通过延迟它，我们可以在阻塞时间和包大小成本方面显著降低初始水合的成本。</p><p id="d6b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看如何在后台加载事件后五秒再加载我们的服务人员。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div><figcaption class="kx ky et er es kz la bd b be z dx">Loads our service-worker 5 seconds after the <a class="ae kq" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event" rel="noopener ugc nofollow" target="_blank">load</a> event fires</figcaption></figure><h1 id="cfd6" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">前方的道路</h1><p id="6f7a" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated"><strong class="ir hi">浏览器兼容性<br/> </strong> Chromium率先实现并原型化了这个新的API然而，该API正在<a class="ae kq" href="https://github.com/WICG" rel="noopener ugc nofollow" target="_blank"> WICG </a>中公开开发，目标是标准化并被所有浏览器采用。同样值得注意的是，即使没有原生支持，我们也看到了Safari和Chrome等浏览器通过使用polyfill实现了许多性能提升，因为它强制实施了良好的优先级和调度模式。</p><p id="21b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们很高兴有机会测试<a class="ae kq" href="https://github.com/WICG/scheduling-apis/blob/main/explainers/prioritized-post-task.md" rel="noopener ugc nofollow" target="_blank">任务后调度器</a>，希望在这篇博文中你能感受到它带来的开发者体验和性能提升。我们期待着看到它通过标准机构的进展，并开始登陆web浏览器供应商。</p><h1 id="d758" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">鸣谢❤️</h1><p id="fd9e" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">这一努力是在这么多人的支持下才得以实现的。我们感谢Scott Haseley(谷歌)、Shubhie Panicker(谷歌)、Aditya Punjani、Josh Nelson、Elliott Sprehn、Casey Klimkowsky、Etienne Tripier、Victor Lin和Kevin Weber。</p><h1 id="f24c" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">改善顾客体验</h1><p id="55a9" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">在过去的一年里，除了性能，我们还致力于重新设计我们技术堆栈的大部分，以支持我们的客户的新产品使用案例。通过注册参加我们即将于6月8日中午12点(太平洋标准时间)举行的技术讲座<a class="ae kq" href="https://reengineeringtravel.splashthat.com/" rel="noopener ugc nofollow" target="_blank">再造旅行</a>，与我们的客户体验技术团队一起走进幕后。在本次演讲中，我们将分享更多关于我们如何构建平台和流程以适应当今旅行的信息。</p></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><p id="c12a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kr"> JavaScript是Oracle America，Inc .的注册商标。React是脸书，Inc .的注册商标。Chrome、Google Analytics、Angular和Chromium是Google LLC或Google，Inc .的注册商标。除了Airbnb与这些公司之间的各种协议中合法达成并记录的权利和所有权之外，Airbnb对任何这些产品不主张任何权利或所有权。</em></p></div></div>    
</body>
</html>