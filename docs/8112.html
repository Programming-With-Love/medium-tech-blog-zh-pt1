<html>
<head>
<title>Data Lake Workloads Synchronization Using Google PubSub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Google PubSub的数据湖工作负载同步</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/data-lake-workloads-synchronization-using-google-pubsub-17b85e75c51c?source=collection_archive---------7-----------------------#2022-04-07">https://medium.com/walmartglobaltech/data-lake-workloads-synchronization-using-google-pubsub-17b85e75c51c?source=collection_archive---------7-----------------------#2022-04-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="07ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇博客是由<a class="jc jd ge" href="https://medium.com/u/b4a06d6c3926?source=post_page-----17b85e75c51c--------------------------------" rel="noopener" target="_blank">斯里达尔·丽卡拉</a> &amp; <a class="jc jd ge" href="https://medium.com/u/2dccc845553f?source=post_page-----17b85e75c51c--------------------------------" rel="noopener" target="_blank">罗希特·博加拉朱</a>共同撰写的</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/d2d382ca64374c3be28d060591f783e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*38tXArVErEqdqoqC7tP-3g.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Relay race depicting workload dependencies</figcaption></figure><p id="c527" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为沃尔玛全球技术公司的数据工程师，我们在大规模环境中运行多种工作负载，处理的数据比以往任何时候都多。就像在接力赛中一样，我们监视大量的源团队工作负载，并等待它们完成。接力棒交给我们后，我们开始工作，然后移交给下一个团队，他们的工作依赖于我们的数据。始终存在满足服务级别协议(SLA)的竞赛，这些工作负载的相互依赖性在数据完整性和向企业及时交付数据方面起着至关重要的作用。我们将讨论承认这些相互依赖性所遵循的常见模式，以及我们的工作流同步框架如何使我们能够解决一些关键挑战。</p><h2 id="a0fa" class="ju jv hh bd jw jx jy jz ka kb kc kd ke ip kf kg kh it ki kj kk ix kl km kn ko bi translated">对工作负载同步的期望</h2><p id="7973" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">如今，数据被视为一种产品。它应该在正确的时间、正确的地点可用，并且有向自助式数据基础设施的巨大转变，通过数据网格连接数据湖。有了这些分布式架构，工作负载之间的联系比以前更加紧密。工作负载需要更多关于数据可用性的信息，而不是基于接触文件的确认。此外，创建、查看和管理特定于工作负载的触控文件在规模上也极具挑战性。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/6d3e940920761305f80c213ba62011b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NVOLnOr8U0XV4I4D-uqsFQ.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Workload interdependency patterns</figcaption></figure><p id="ead6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一种常见的做法是基于时间的调度。大多数时候，我们会看到工作负载提前完成。如果从属工作负载在父工作负载完成后立即得到通知，那么我们可以提前交付关键业务报告。有时，数据刷新通过电子邮件通信通知，相关团队将通过电子邮件跟进并启动他们的工作负载。</p><p id="c10e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">应用程序和BI工具需要基于推送的通知来启动数据刷新，而不是全天轮询。同时，我们需要能够存储同步数据，以便我们可以运行分析来优化工作负载。</p><p id="e433" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决上述需求，我们构建了一个基于事件的消息传递框架，该框架包装在Google PubSub周围，用于同步工作负载，而不考虑它们运行的调度程序或应用程序。以下部分详细介绍了该框架。</p><h2 id="e466" class="ju jv hh bd jw jx jy jz ka kb kc kd ke ip kf kg kh it ki kj kk ix kl km kn ko bi translated">工作流同步框架</h2><p id="1f19" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">工作流同步框架建立在抽象消息中间件的思想上，使不同平台上的生产者和订户能够同步他们的工作流。它为由消息生产者团队管理的板载项目和创建主题提供了灵活性。例如，项目A和项目B可以属于不同的团队，每个团队都可以创建自己的主题、管理订阅和定义访问控制。以下段落提供了该框架每个组成部分的更多细节。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kv"><img src="../Images/2afd8475f45a0389c1c6785c2d66a92a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q9aXek1cGCKk2gOLdIIDwQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Workflow synchronization framework</figcaption></figure><p id="007b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">消息生产者</strong></p><p id="c5fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">消息生产者通过REST API将消息发布到主题。API代理会将消息重定向到在不同项目上创建的相关主题。生产者可以通过在服务注册中心注册而自行加入，他们将被分配一个惟一的消费者id，该id必须与REST API调用的附加头一起传递。此外，服务注册中心提供了添加关于传入吞吐量、延迟等的策略的能力。对于传入的请求。</p><p id="407a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，请求通过发布者抽象器，发布者抽象器接收请求，验证请求，并通过Pubsub API将消息发布到主题。一旦消息被发布到主题，API返回一个消息id作为确认，消息框架负责将消息发送给订阅者。</p><p id="38fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">消息订阅者</strong></p><p id="8119" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">订阅者可以通过REST API使用消息，也可以在客户端库中查看消息。就像消息生成者一样，订阅者也可以通过service registry自行加入主题列表。注册时，将为该主题创建一个订阅，每个订阅者将被分配一个唯一的消费者id。在入职期间，订阅者可以选择配置订阅，如下所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kw"><img src="../Images/9ce80e58202f7240c2d3881cae99fad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*KKZKaaUol6kZIaxTea3G-g.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx">A sample subscription configuration for a daily load</figcaption></figure><p id="06cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">消息格式</strong></p><p id="269d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">消息格式(模式)充当生产者和消费者之间的契约，并根据需要发展。该框架提供了可用主题及其消息格式的列表，这有助于订阅者应用过滤器并在他们结束时解析消息。</p><pre class="jf jg jh ji fd kx ky kz la aw lb bi"><span id="d9fa" class="ju jv hh ky b fi lc ld l le lf">{<br/> “data”: {<br/> “schemaName”: “sales_dl_rpt”,<br/> “tableName”: “item_sales”,<br/> “status”: “completed”,<br/> “loadType”: “incremental”,<br/> “loadedTime”:1641270222<br/> },<br/> “attributes”: {<br/> “source”: “datalake”,<br/> “subjectArea”: “sales”,<br/> “storageLayer”: “object store”<br/> }<br/>}</span></pre><p id="6cf6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的示例消息格式显示加载了一个特定的表。消息本身包含关于模式、表、状态和加载时间的详细信息。属性中有几个字段，订阅可以根据需要使用它们来过滤消息。框架在创建主题时不强制模式。消息结构也可以在生产者抽象层中定义。</p><p id="ef36" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">监控和记录</strong></p><p id="473b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该框架提供了一个集中的位置来监控主题、生成的消息、订阅的消息、项目的延迟和审计操作，例如主题的创建、数据访问和系统事件。团队还可以构建自己的监控仪表板和控制台来检查日志。</p><p id="e861" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">前进</strong></p><p id="ac51" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用这个框架已经有一段时间了，并且成功地同步了下游团队的工作负载和应用程序，因为工作负载是从源完成的。门户网站帮助生产者和订阅者自助，下一步，我们将增加新功能，以提供对工作负载谱系的可见性。</p></div></div>    
</body>
</html>