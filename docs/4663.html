<html>
<head>
<title>5 Common Misconceptions About TDD &amp; Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于TDD和单元测试的5个常见误解</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/5-common-misconceptions-about-tdd-unit-tests-863d5beb3ce9?source=collection_archive---------3-----------------------#2016-05-26">https://medium.com/javascript-scene/5-common-misconceptions-about-tdd-unit-tests-863d5beb3ce9?source=collection_archive---------3-----------------------#2016-05-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b85ed1dd5e85be747d6ebb16ec482c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dWXlzZKzDbZw-AcHbw71xg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Confused Dog — Gimcor (CC-BY-NC-2.0)</figcaption></figure><p id="6937" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">大多数开发人员似乎同意测试是好的，但是开发人员经常对如何测试有不同意见。在本文中，我将打破一些常见的误解，并希望教你一些关于如何从TDD(测试驱动开发)和单元测试中获得最大收益的事情。</p><h2 id="511d" class="jr js hh bd jt ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl bi translated">1.TDD太费时间了。业务团队绝不会同意</h2><p id="016b" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">这是不进行测试的一个常见借口，它真的会伤害您的开发团队和业务。让我们澄清事实。</p><blockquote class="kr"><p id="92fc" class="ks kt hh bd ku kv kw kx ky kz la jq dx translated">业务团队根本不关心你使用的开发过程，只要它是有效的。</p></blockquote><p id="bf85" class="pw-post-body-paragraph it iu hh iv b iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm lf jo jp jq ha bi translated">他们真正关心的是业务指标。TDD如何影响业务度量？</p><p id="5070" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">TDD可以:</p><ul class=""><li id="f4f6" class="lg lh hh iv b iw ix ja jb je li ji lj jm lk jq ll lm ln lo bi translated">提高开发人员的生产力(长期)</li><li id="4792" class="lg lh hh iv b iw lp ja lq je lr ji ls jm lt jq ll lm ln lo bi translated">减少客户放弃</li><li id="ac44" class="lg lh hh iv b iw lp ja lq je lr ji ls jm lt jq ll lm ln lo bi translated">增加应用程序的病毒因素(即用户增长)</li><li id="af75" class="lg lh hh iv b iw lp ja lq je lr ji ls jm lt jq ll lm ln lo bi translated">降低客户服务成本</li></ul><p id="d8c4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">像微软、IBM和Springer这样的公司已经在实际项目中测试了TDD的好处，他们发现TDD过程是非常有益的。他们的发现是:</p><blockquote class="kr"><p id="be9e" class="ks kt hh bd ku kv kw kx ky kz la jq dx translated"><a class="ae lu" href="https://link.springer.com/article/10.1007/s10664-008-9062-z" rel="noopener ugc nofollow" target="_blank">“四个产品的预发布缺陷密度下降了40%-90%”</a></p></blockquote><p id="da7b" class="pw-post-body-paragraph it iu hh iv b iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm lf jo jp jq ha bi translated">如果没有测试，甚至在实现后添加测试，更多的bug会通过开发阶段，进入生产的每个bug不仅会浪费开发人员的时间，还会损害公司的品牌和质量声誉。它在客户支持成本上浪费了大量资源。</p><p id="5021" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">修复bug会中断软件开发的正常流程，这会导致上下文切换，每个bug会花费20分钟的时间。在这20分钟里，开发人员没有做任何有成效的事情——只是试图重新启动他们的大脑来找出新问题的背景，然后恢复他们在中断之前正在处理的问题的背景。</p><p id="d7f4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">根据您所关注的研究，TDD过程会增加10% — 30%的初始开发成本，但是随着时间的推移，当您将持续的维护和错误修复考虑在内时，TDD可以提高开发人员的工作效率，减少客户放弃，增加您的应用程序的增长因素，并降低客户服务的成本。</p><p id="ef81" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果你认为业务团队会抵制TDD，你根本没有用事实来证明这一点。</p><h2 id="1757" class="jr js hh bd jt ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl bi translated">2.在你知道设计之前，你不能写测试，在你实现代码之前，你不能知道设计</h2><p id="3a5a" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">让我们现在就澄清这件事。一项又一项的研究得出结论，先编写测试比以后再添加测试更有效。有效多少？<a class="ae lu" href="https://www.computer.org/csdl/mags/so/2007/03/s3024.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="iv hi">生产中的bug减少40–80%</strong></a>效率更高。</p><p id="2338" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果你认为在编写测试之前，你在实现方面做得很好，我在这里告诉你，从统计上来说，你给了自己一个很大的障碍。TDD需要纪律，这需要一些时间来学习。</p><p id="9584" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">没有开发测试优先的TDD规程的开发人员通常在他们知道API将会是什么样子之前就投入到代码的实现中。</p><blockquote class="kr"><p id="47e2" class="ks kt hh bd ku kv kw kx ky kz la jq dx translated">他们甚至在设计函数签名之前就开始实现代码。</p></blockquote><p id="bee1" class="pw-post-body-paragraph it iu hh iv b iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm lf jo jp jq ha bi translated"><em class="lv">这是TDD的对立面。</em>TDD的要点在于，它迫使你在开始冲锋陷阵之前心中有一个方向，心中有一个方向会带来更好的设计。</p><p id="d2e3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在我编写第一个测试之前，我创建了一个<strong class="iv hi"> RDD </strong>文档(RDD代表自述驱动开发)。在开始编写代码之前，我不会尝试以RDD的形式来充实系统的整个设计，但我确实决定了，<em class="lv">我正在构建一个执行x的模块，它需要一个接受y并返回z的函数签名</em></p><p id="575b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">换句话说，我制作了一个包含<strong class="iv hi">梦想代码</strong>的RDD文档，其中举例说明了如何使用一个单元的API。您将在软件库“入门”和API指南中看到的同类示例。</p><p id="579b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">对于我的许多测试用例，我只是简单地复制和粘贴来自RDD的例子，这给了我一个简单测试的起点。</p><p id="a2bd" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">例如，数字范围生成器的梦想代码RDD可能如下所示:</p><figure class="lw lx ly lz fd ii"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="b0b8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这给了我实际的和预期的值，我可以将它们复制并粘贴到我的单元测试中。上面的第一种用法可以在下面的测试中重新使用，依此类推:</p><figure class="lw lx ly lz fd ii"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="9377" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">关于如何编写这样的测试，请参见<a class="ae lu" rel="noopener" href="/javascript-scene/what-every-unit-test-needs-f6cd34d9836d">“每个单元测试必须回答的五个问题”</a>。</p><h2 id="dc9b" class="jr js hh bd jt ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl bi translated">3.您必须在开始编写代码之前编写所有的测试</h2><p id="44c8" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">开发人员很难想象TDD工作的原因是因为软件设计是一个迭代的、发现驱动的过程。顺便说一句，建造摩天大楼也是如此。与普遍的看法相反，建筑师在任何工作开始之前都不会设计完整的摩天大楼。摄制组必须出去勘察地貌。他们必须检查将要建地基的地面。他们必须确保地面能够支撑摩天大楼的重量。他们必须探测地下，以发现是否有可能坍塌的洞穴系统，是否有水的问题需要解决等等。</p><p id="e0e8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">100%预先设计在任何类型的工程中都是一个神话。设计是探索性的。我们尝试一些东西，扔掉它们，尝试不同的东西，直到找到我们喜欢的东西。现在，如果你在编写一行实现代码之前就预先编写了每个测试，这将会阻碍探索过程，但是这并不是成功的TDD的工作方式。相反:</p><ol class=""><li id="3099" class="lg lh hh iv b iw ix ja jb je li ji lj jm lk jq mc lm ln lo bi translated">编写<strong class="iv hi">一个</strong>测试</li><li id="66f4" class="lg lh hh iv b iw lp ja lq je lr ji ls jm lt jq mc lm ln lo bi translated">看着它失败</li><li id="277e" class="lg lh hh iv b iw lp ja lq je lr ji ls jm lt jq mc lm ln lo bi translated">实现代码</li><li id="1325" class="lg lh hh iv b iw lp ja lq je lr ji ls jm lt jq mc lm ln lo bi translated">观看测试通过</li><li id="f127" class="lg lh hh iv b iw lp ja lq je lr ji ls jm lt jq mc lm ln lo bi translated">重复</li></ol><h2 id="8014" class="jr js hh bd jt ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl bi translated">4.红绿，永远重构？</h2><p id="ef03" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">对于上面的指令列表，一个常见的回答是“你忘记了<strong class="iv hi">重构</strong>！”。不，我没有。TDD的一个巨大好处是，它可以在你需要的时候帮助你重构<em class="lv">，</em>但是我要跟你说实话:除非你的代码非常难读，或者你已经对它进行了基准测试，发现它太慢了，<strong class="iv hi">你可能不需要重构。</strong></p><blockquote class="kr"><p id="278f" class="ks kt hh bd ku kv kw kx ky kz la jq dx translated">“完美是好的敌人。”~伏尔泰</p></blockquote><p id="1798" class="pw-post-body-paragraph it iu hh iv b iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm lf jo jp jq ha bi translated">当然，检查你的代码，看看是否有机会让它变得更好，但是不要为了重构而重构。时间在浪费。继续下一个测试。</p><h2 id="ecea" class="jr js hh bd jt ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl bi translated">5.一切都需要单元测试</h2><p id="5a9f" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">单元测试最适合于<strong class="iv hi">纯函数</strong>——这些函数:</p><ol class=""><li id="0efd" class="lg lh hh iv b iw ix ja jb je li ji lj jm lk jq mc lm ln lo bi translated">给定相同的输入，总是返回相同的输出</li><li id="e0e9" class="lg lh hh iv b iw lp ja lq je lr ji ls jm lt jq mc lm ln lo bi translated">没有副作用(不改变共享状态、保存数据、与网络对话、在屏幕上画图、登录控制台等)</li></ol><p id="40c1" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">单元测试并不专门针对纯函数，但是你的代码越少依赖任何共享状态或I/O依赖，测试就越容易。你的很多代码不容易进行单元测试。您的许多代码将与网络对话、查询数据库、在屏幕上绘图、捕捉用户输入等等。负责所有这些的代码是不纯的，因此，用单元测试来测试要困难得多。</p><p id="36b8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">人们最终嘲笑数据库驱动程序、网络I/O、用户I/O和所有其他种类的东西，以努力遵循您的单元需要被隔离测试的规则。</p><p id="8156" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这里有一个将改变你生活的建议:</p><blockquote class="kr"><p id="cfa1" class="ks kt hh bd ku kv kw kx ky kz la jq dx translated"><a class="ae lu" rel="noopener" href="/javascript-scene/mocking-is-a-code-smell-944a70c90a6a">嘲讽是一种码闻</a>。</p></blockquote><p id="01d4" class="pw-post-body-paragraph it iu hh iv b iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm lf jo jp jq ha bi translated">如果你不得不做很多嘲讽来创建一个合适的单元测试，<strong class="iv hi"> <em class="lv">也许代码根本不需要单元测试。</em>T15】</strong></p><p id="4e6c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">也许功能测试会更适合。试图对I/O相关代码使用单元测试<a class="ae lu" href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html" rel="noopener ugc nofollow" target="_blank">会导致问题</a>，我估计那些抱怨测试优先很难的人正在落入那个陷阱。</p><p id="edb7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你的代码应该足够模块化，这样很容易在程序的边缘保留I/O相关的模块，让应用程序的大部分可以很容易地进行单元测试，但是如果你觉得你只是为了测试而强制模块化，而不是因为它实际上使你的应用程序架构更好，你应该重新考虑你的测试策略。</p><p id="18a0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">也就是说，如果你想用功能/e2e测试来做所有的测试<strong class="iv hi"/>，那也是有问题的。</p><p id="09c9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你最终会得到:</p><ol class=""><li id="95fb" class="lg lh hh iv b iw ix ja jb je li ji lj jm lk jq mc lm ln lo bi translated">不充分的测试覆盖，没有正确地运用你的代码的模块单元，以及…</li><li id="cc10" class="lg lh hh iv b iw lp ja lq je lr ji ls jm lt jq mc lm ln lo bi translated">一个紧密结合的整体，随着时间的推移变得难以维护。</li></ol><p id="f1c9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">非常小的项目可以摆脱这两者，但是真正成功的项目往往会从那个阶段中成长起来，并且会从更模块化的架构和更好的测试规程中受益。</p><p id="92d5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">健康的测试套件会认识到有三种主要类型的软件测试都在发挥作用，你的测试覆盖率会在它们之间建立一个平衡。</p></div><div class="ab cl md me go mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ha hb hc hd he"><p id="8085" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">成员们，看看<a class="ae lu" href="https://ericelliottjs.com/2016/05/25/introduction-to-unit-tests/" rel="noopener ugc nofollow" target="_blank">【单元测试简介】</a>。通过编写生成器库来学习单元测试。包含大量示例、一个介绍视频和6个视频演练。不是会员？</p><h1 id="8575" class="mk js hh bd jt ml mm mn jx mo mp mq kb mr ms mt ke mu mv mw kh mx my mz kk na bi translated"><a class="ae lu" href="https://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank">跟随埃里克·埃利奥特学习JavaScript】</a></h1></div><div class="ab cl md me go mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ha hb hc hd he"><p id="4044" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="lv">埃里克·艾略特</em> </strong> <em class="lv">著有</em> <a class="ae lu" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="lv">【编程JavaScript应用】</em> </a> <em class="lv">(奥赖利)，以及</em> <a class="ae lu" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">【跟埃里克·艾略特学JavaScript】</em></a><em class="lv">。他曾为Adobe Systems</em><strong class="iv hi"><em class="lv"/></strong><em class="lv"/><strong class="iv hi"><em class="lv">Zumba Fitness</em></strong><em class="lv"/><strong class="iv hi"><em class="lv">华尔街日报、</em></strong><em class="lv"/><strong class="iv hi"><em class="lv">BBC</em></strong><em class="lv">和顶级录音师包括</em><strong class="iv hi"><em class="lv">Usher</em></strong><em class="lv"/></p><p id="61a2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>