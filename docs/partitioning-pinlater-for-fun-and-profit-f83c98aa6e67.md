# Partitioning Pinlater 为了好玩(？)和利润(！)

> 原文：<https://medium.com/pinterest-engineering/partitioning-pinlater-for-fun-and-profit-f83c98aa6e67?source=collection_archive---------3----------------------->

Ernie Souhrada |数据库工程师和钻头维护者

2015 年 11 月，我们的异步作业执行系统 pinlate 的[开源声明中包含了自【2014 年最初的博文](/pinterest-engineering/open-sourcing-pinlater-an-asynchronous-job-execution-system-d8ec4e39859a)描述其创建以来对该系统所做的一些改进。其中值得注意的是从 Redis 到 MySQL/InnoDB 作为后端数据存储的转换，因为它增强了耐用性和高效处理比系统内存大得多的数据集的能力。在过去的几年中，这种新的、改进的 Pinlater 的使用有了突飞猛进的发展，超过了最初每秒 100，000 个作业的总处理速率许多倍，可靠性更好，成本也比基于 Redis 的解决方案低得多。然而，正如您所料，更大的规模通常会带来新的挑战。

询问任何有经验的 MySQL 工程师，他们是否认为 InnoDB 是一个很好的队列系统的后备存储，该系统将处理即使是适度高的查询量，您可能会收到从极度厌恶到无法控制的笑声的各种反应。是的，它相对容易实现，在自动递增主键和用于并发控制的行级锁定之间，在排队系统中可能需要的许多基本元素在默认情况下都存在，但是没有免费的小狗这样的东西。一开始你可能觉得它很可爱，想抱抱，但最终它会饿，开始叫，让你晚上睡不着，或者如果你不经常带它出去锻炼，它会毁了你的鞋子，在你的地毯上撒尿。减轻使用 MySQL 作为排队系统的负面影响，就像小狗维护一样，是一项艰巨的任务。

# **第一步:找到丢失的磁盘空间**

对不推荐将 MySQL 用作队列存储的所有原因的完整解释超出了这篇博文的范围；相反，我将重点介绍我们最近如何解决一个具体问题，这是 Pinlater 中大量运营开销和资源利用效率低下的根源:磁盘浪费。

InnoDB 数据文件的一个显著特性是它们不会自行收缩。从一个空表开始，向其中写入一百万行，然后在 MySQL 数据目录中查看该文件占用了多少磁盘空间。然后，一个接一个地开始删除行，直到只剩下一行。即使您最终删除了最后一行，文件的大小也会和表满时一样。这样做足够多次，最终你的服务器将耗尽磁盘空间，即使它几乎没有任何数据。对于一个排队系统来说，它不断地向任意给定的 MySQL 服务器上的数十甚至数百个不同的表中写入新的作业，然后在旧作业完成或不再需要时删除它们，不难看出臃肿的数据文件会造成怎样的问题。

我们对此问题的早期解决方案简单明了，但也不是最理想的，而且是不必要的劳动密集型:要么重建具有大量空闲空间的表(可能会影响以后的 Pinlater 成功率，因为对表的写入会被阻止)，要么设置警报集群以停止新作业的排队并提供新集群来替换它们。

# **第二步:？？？？**

快进到 2018 年。作为一个更大的 Pinlater 效率项目的一部分，我开始查看前面提到的 InnoDB 行为实际上浪费了多少磁盘空间，这些数字令人吃惊。总体而言，所有至少具有 5GB 可回收空间的 Pinlater 表占用了 100TB 的磁盘空间，但它们仅包含 3.5TB 的实际数据。当然，这可以通过自动化我上面描述的一些回收任务来解决，但是我建议我们尝试一些不同的东西:MySQL 分区。

为了说明这一点，下面是分区前 Pinlater 表的一个简化模式定义。

创建表作业(
local _ id BIGINT NOT NULL AUTO _ INCREMENT 主键，
state TINYINT NOT NULL，
…
updated _ at TIMESTAMP NOT NULL，
created_at TIMESTAMP NOT NULL，
run_after TIMESTAMP NOT NULL，
INDEX (state，run_after)
)

Pinlater 中的基本作业流是，每个作业从状态 0(新)开始，然后一旦被一个工作线程请求，就转换到状态 1 (IPR =进行中)，最终以状态 2(正常)或状态 3(失败)结束。成功或失败的作业会定期从表中清除。在最初的设计中，这是通过一个简单的删除查询来完成的，这通常会导致不希望的锁争用或 CPU 高峰，并且如前所述，没有采取任何措施来回收未使用的磁盘空间。

这是我提出的解决方案的一个简化方案。

创建表作业(
local_id BIGINT NOT NULL AUTO _ INCREMENT，
state TINYINT NOT NULL，
…
updated_at DATETIME NOT NULL，
created_at TIMESTAMP NOT NULL，
run_after TIMESTAMP NOT NULL，
主键(local _ id，state，updated _ at)，
INDEX (run_after)，
按范围列分区(state，updated_at) (
分区 pNEW _ 2020051200 _ 120)
分区 pIPR_2020050800_24 值小于(1，' 2020–05–08 00:00:00 ')，
分区 pIPR_2020050900_24 值小于(1，' 2020–05–09 00:00:00 ')，
分区 pIPR_FUTURE 值小于(1，MAXVALUE)，
分区 pOK_2020050

使用修改后的设计，所有相同的状态更改都会在作业的整个生命周期中发生，但不是 Pinlater 仅仅更新行中的值，而是随着状态转换的发生，行本身会从一个分区移动到下一个分区。当需要清除旧的/过期的作业时，我们只需运行一系列 ALTER TABLE foo DROP PARTITION bar 查询。作为这个维护 cron 的一部分，我们还对每个未来的分区进行重新分区，以创建新的空分区来替换被删除的非空分区。没有更多有争议的删除，因为分区的数据文件实际上是从文件系统中删除的，否则会被浪费的宝贵磁盘空间可以被回收用于其他作业队列。额外的好处是，因为即使是新任务也有一个有限的 TTL，如果有人创建了一个队列，然后忘记了它，维护脚本会自动清理它。

# **第三步:盈利！**

成功了吗？比我想象的要好。我们推出了这一新模式，更新了 SQL(因为为了利用 MySQL 的分区修剪，它可以快速缩小搜索范围，只搜索满足查询所需的分区，您需要在查询中使用分区键的每个组件)，以及 2019 年上半年的新维护工作。在这个项目的开始，235 个 MySQL 集群被用于 Pinlater。在最后？不到这个数字的一半:113。不仅如此，备份速度也得到了提高，现在我们针对这些服务器的磁盘利用率指标实际上非常有用，因为我们不再计算长期删除的行。还不错！

# 承认

感谢来自核心服务团队的 Isabel Tallam 和 Purajit Malalur，感谢他们对 Pinlater 进行必要的代码更改以及后续的测试和部署。