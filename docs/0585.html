<html>
<head>
<title>A pragmatic guide to Hilt with Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用指南剑柄与科特林</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/a-pragmatic-guide-to-hilt-with-kotlin-a76859c324a1?source=collection_archive---------1-----------------------#2020-11-13">https://medium.com/androiddevelopers/a-pragmatic-guide-to-hilt-with-kotlin-a76859c324a1?source=collection_archive---------1-----------------------#2020-11-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/b07555fbeb7cabf07ce1f73109da516b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9cp9m4LO4zkpgv2s30Cg9A.png"/></div></div></figure><div class=""/><div class=""><h2 id="8ad7" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">在Android应用中使用依赖注入的简单方法</h2></div><p id="c3f4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><a class="ae kd" href="https://developer.android.com/training/dependency-injection/hilt-android" rel="noopener ugc nofollow" target="_blank"> Hilt </a>是建立在<a class="ae kd" href="https://developer.android.com/training/dependency-injection/dagger-basics" rel="noopener ugc nofollow" target="_blank"> Dagger </a>之上的一个新的依赖注入库，简化了它在Android应用中的使用。本指南展示了一些代码片段的核心功能，以帮助您开始在项目中使用Hilt。</p><h1 id="b014" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">设置刀柄</h1><p id="0ee1" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">要在您的应用程序中设置Hilt，请先遵循<a class="ae kd" href="https://dagger.dev/hilt/gradle-setup" rel="noopener ugc nofollow" target="_blank"> Gradle Build设置</a>指南。</p><p id="8dd0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">安装完所有的依赖项和插件后，用<code class="du lb lc ld le b">@HiltAndroidApp</code>注释你的<code class="du lb lc ld le b">Application</code>类以使用Hilt。您不需要做任何其他事情或者直接调用它。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="f7ce" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">定义和注入依赖关系</h1><p id="915a" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">当您编写使用依赖注入的代码时，有两个主要组件需要考虑:</p><ol class=""><li id="cbca" class="ll lm hs jj b jk jl jn jo jq ln ju lo jy lp kc lq lr ls lt bi translated">具有要注入的依赖项的类。</li><li id="21da" class="ll lm hs jj b jk lu jn lv jq lw ju lx jy ly kc lq lr ls lt bi translated">可以作为依赖项注入的类。</li></ol><p id="328e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这些并不相互排斥，在许多情况下，你的类既可注入又有依赖关系。</p><h2 id="bb44" class="lz kf hs bd kg ma mb mc kk md me mf ko jq mg mh kq ju mi mj ks jy mk ml ku mm bi translated">使依赖关系可注入</h2><p id="c2e2" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">要在Hilt中创建可注入的东西，你必须告诉Hilt如何创建那个东西的一个实例。这些指令被称为<em class="mn">绑定</em>。</p><p id="c2d7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">有三种方法来定义一个绑定。</p><ol class=""><li id="772a" class="ll lm hs jj b jk jl jn jo jq ln ju lo jy lp kc lq lr ls lt bi translated">用<code class="du lb lc ld le b">@Inject</code>标注构造函数</li><li id="8c27" class="ll lm hs jj b jk lu jn lv jq lw ju lx jy ly kc lq lr ls lt bi translated">在模块中使用<code class="du lb lc ld le b">@Binds</code></li><li id="c754" class="ll lm hs jj b jk lu jn lv jq lw ju lx jy ly kc lq lr ls lt bi translated">在一个模块中使用<code class="du lb lc ld le b">@Provides</code></li></ol><p id="960b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">⮕ <strong class="jj ht">用</strong> <code class="du lb lc ld le b"><strong class="jj ht">@Inject</strong></code>标注构造器</p><p id="5459" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">任何类都可以有一个用<code class="du lb lc ld le b">@Inject</code>注释的构造函数，这使得它可以作为项目中任何地方的依赖项。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="72f0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">⮕ <strong class="jj ht">使用模块</strong></p><p id="d48e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在Hilt中实现可注入的另外两种方法涉及到使用模块。</p><p id="3505" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">一个<a class="ae kd" href="https://dagger.dev/hilt/modules" rel="noopener ugc nofollow" target="_blank"> Hilt模块</a>可以被认为是一个“配方”的集合，告诉Hilt如何创建一个没有构造器的东西的实例——比如一个接口或者一个系统服务。</p><p id="36f6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">此外，在您的测试中，任何模块都可以用不同的模块来替换。例如，这使得用模拟替换接口实现变得很容易。</p><p id="0a10" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">模块安装在使用<code class="du lb lc ld le b">@InstallIn</code>注释指定的<a class="ae kd" href="https://dagger.dev/hilt/components.html" rel="noopener ugc nofollow" target="_blank">手柄组件</a>中。稍后我会更详细地解释这一点。</p><p id="6632" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><em class="mn">选项1:使用</em> <code class="du lb lc ld le b"><em class="mn">@Binds</em></code> <em class="mn">为一个接口</em>创建绑定</p><p id="e949" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果您想在请求<code class="du lb lc ld le b">Milk</code>时在代码中使用<code class="du lb lc ld le b">OatMilk</code>，请在模块中创建一个抽象方法并用<code class="du lb lc ld le b">@Binds</code>对其进行注释。注意，<code class="du lb lc ld le b">OatMilk</code>本身必须是可注入的，这可以通过用<code class="du lb lc ld le b">@Inject</code>注释其构造函数来实现。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="73d4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><em class="mn">选项二:使用</em> <code class="du lb lc ld le b"><em class="mn">@Provides</em></code> <em class="mn">创建工厂功能</em></p><p id="8702" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当不能直接构造实例时，可以创建一个提供者。提供者是返回对象实例的工厂函数。</p><p id="3e6c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这方面的一个例子是需要从上下文中获得的系统服务，如<code class="du lb lc ld le b">ConnectivityManager</code>。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="d0da" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">默认情况下，<code class="du lb lc ld le b">Context</code>对象是可注入的，只要用<code class="du lb lc ld le b">@ApplicationContext</code>或<code class="du lb lc ld le b">@ActivityContext</code>对其进行注释。</p><h2 id="46e3" class="lz kf hs bd kg ma mb mc kk md me mf ko jq mg mh kq ju mi mj ks jy mk ml ku mm bi translated">注入依赖性</h2><p id="0098" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">一旦你的依赖项是可注入的，你可以用两种方式使用Hilt注入它们。</p><ol class=""><li id="2019" class="ll lm hs jj b jk jl jn jo jq ln ju lo jy lp kc lq lr ls lt bi translated">作为构造函数参数</li><li id="08ef" class="ll lm hs jj b jk lu jn lv jq lw ju lx jy ly kc lq lr ls lt bi translated">作为字段</li></ol><p id="ddd5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht"> ⮕作为构造函数的参数</strong></p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="35dd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果构造函数标有<code class="du lb lc ld le b">@Inject</code>，那么Hilt会根据您为这些类型定义的绑定注入所有的参数。</p><p id="ac54" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht"> ⮕作为地头</strong></p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="cdbe" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果这个类是一个入口点，这里用<code class="du lb lc ld le b">@AndroidEntryPoint</code>注释指定(下一节将详细介绍)，那么所有用<code class="du lb lc ld le b">@Inject</code>注释的字段都会被注入。</p><p id="93f9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">用<code class="du lb lc ld le b">@Inject</code>标注的字段必须是公共的。使它们成为<code class="du lb lc ld le b">lateinit</code>也很方便，以避免使它们为空，因为它们在注入前的初始值是<code class="du lb lc ld le b">null</code>。</p><p id="8da2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">注意，只有当你的类必须有一个不带参数的构造函数，比如<code class="du lb lc ld le b">Activity</code>时，将依赖项作为字段注入才有用。在大多数情况下，您会希望通过构造函数参数注入。</p><h1 id="0c80" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">其他重要概念</h1><h2 id="c215" class="lz kf hs bd kg ma mb mc kk md me mf ko jq mg mh kq ju mi mj ks jy mk ml ku mm bi translated">入口点</h2><p id="58dc" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">还记得我说过在很多情况下，你的类是通过注入<em class="mn">而</em>被注入依赖项而创建的吗？在某些情况下，你会有一个不是通过依赖注入<em class="mn">创建</em>的类，但是仍然有依赖注入其中。一个很好的例子就是activities，它通常是由Android框架而不是Hilt创建的。</p><p id="3f1f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这些类是<a class="ae kd" href="https://dagger.dev/hilt/entry-points.html" rel="noopener ugc nofollow" target="_blank"> <em class="mn">到Hilt的依赖图的入口点</em> </a>，Hilt需要知道它们有需要注入的依赖。</p><p id="eb1e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht"> ⮕安卓入口点</strong></p><p id="1609" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您的大多数入口点将是这些所谓的<a class="ae kd" href="https://dagger.dev/hilt/android-entry-point.html" rel="noopener ugc nofollow" target="_blank"> Android入口点</a>之一:</p><ul class=""><li id="89f4" class="ll lm hs jj b jk jl jn jo jq ln ju lo jy lp kc mo lr ls lt bi translated">活动</li><li id="65be" class="ll lm hs jj b jk lu jn lv jq lw ju lx jy ly kc mo lr ls lt bi translated">碎片</li><li id="109b" class="ll lm hs jj b jk lu jn lv jq lw ju lx jy ly kc mo lr ls lt bi translated">视角</li><li id="f121" class="ll lm hs jj b jk lu jn lv jq lw ju lx jy ly kc mo lr ls lt bi translated">服务</li><li id="69be" class="ll lm hs jj b jk lu jn lv jq lw ju lx jy ly kc mo lr ls lt bi translated">广播接收机</li></ul><p id="2ca8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果是这样，用<code class="du lb lc ld le b">@AndroidEntryPoint</code>注释。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="7af2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht"> ⮕其他切入点</strong></p><p id="32e4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">大多数应用程序只需要Android入口点，但是如果你正在与非Dagger库或者还不被Hilt支持的Android组件交互，你可能需要创建你自己的入口点来手动访问Hilt图。你可以阅读更多关于<a class="ae kd" href="https://dagger.dev/hilt/entry-points.html" rel="noopener ugc nofollow" target="_blank">把任意类变成入口点</a>的内容。</p><h2 id="4aa0" class="lz kf hs bd kg ma mb mc kk md me mf ko jq mg mh kq ju mi mj ks jy mk ml ku mm bi translated">视图模型</h2><p id="8fac" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">一个<code class="du lb lc ld le b">ViewModel</code>是一个特例:它没有被直接实例化，因为框架需要创建它们，但它也不是Android的入口点。相反，<code class="du lb lc ld le b">ViewModel</code>使用特殊的<code class="du lb lc ld le b">@ViewModelInject</code>注释，当使用<code class="du lb lc ld le b">by viewModels()</code>创建依赖项时，允许Hilt将依赖项注入其中，类似于<code class="du lb lc ld le b">@Inject</code>对其他类的工作方式。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="03cd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果您需要访问您的<code class="du lb lc ld le b">ViewModel</code>中保存的状态，通过添加<code class="du lb lc ld le b">@Assisted</code>注释注入一个<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle" rel="noopener ugc nofollow" target="_blank">SavedStateHandle</a></code>作为构造函数参数。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="a908" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要使用<code class="du lb lc ld le b">@ViewModelInject</code>，您需要添加更多的依赖项。更多信息见<a class="ae kd" href="https://developer.android.com/training/dependency-injection/hilt-jetpack" rel="noopener ugc nofollow" target="_blank">手柄和喷射包集成</a>。</p><h2 id="a973" class="lz kf hs bd kg ma mb mc kk md me mf ko jq mg mh kq ju mi mj ks jy mk ml ku mm bi translated">成分</h2><p id="e023" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">每个模块安装在一个用<code class="du lb lc ld le b">@InstallIn(<em class="mn">&lt;component&gt;</em>)</code>指定的<a class="ae kd" href="https://dagger.dev/hilt/components.html" rel="noopener ugc nofollow" target="_blank">手柄组件</a>内。模块的组件主要用于防止在错误的位置意外注入依赖项。例如，<code class="du lb lc ld le b">@InstallIn(ServiceComponent.class)</code>会阻止注释模块中的绑定和提供者在活动中使用。</p><p id="1bc8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">此外，绑定的范围可以是模块所在的组件。这让我想到…</p><h2 id="21bd" class="lz kf hs bd kg ma mb mc kk md me mf ko jq mg mh kq ju mi mj ks jy mk ml ku mm bi translated">领域</h2><p id="5386" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">默认情况下，绑定未被划分。在上面的例子中，这意味着每次你注入<code class="du lb lc ld le b">Milk</code>，你会得到一个<code class="du lb lc ld le b">OatMilk</code>的新实例。如果您添加了<code class="du lb lc ld le b">@ActivityScoped</code>注释，您将把绑定范围扩大到<code class="du lb lc ld le b">ActivityComponent</code>。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="5dee" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">既然您的模块已经确定了范围，那么Hilt将只为每个活动实例创建一个<code class="du lb lc ld le b">OatMilk</code>。此外，<code class="du lb lc ld le b">OatMilk</code>实例将被绑定到活动的生命周期——它将在活动的<code class="du lb lc ld le b">onCreate()</code>被调用时被创建，在活动的<code class="du lb lc ld le b">onDestroy()</code>被调用时被销毁。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="1eda" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这种情况下，<code class="du lb lc ld le b">milk</code>和<code class="du lb lc ld le b">moreMilk</code>都将指向同一个<code class="du lb lc ld le b">OatMilk</code>实例。但是，如果您有多个<code class="du lb lc ld le b">LatteActivity</code>实例，那么它们都有自己的<code class="du lb lc ld le b">OatMilk</code>实例。</p><p id="7fdc" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">相应地，注入到该活动中的其他依赖项具有相同的范围，因此它们也将使用相同的<code class="du lb lc ld le b">OatMilk</code>实例:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="a689" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">范围取决于您的模块安装在哪个组件中，例如<code class="du lb lc ld le b">@ActivityScoped</code>只能应用于安装在<code class="du lb lc ld le b">ActivityComponent</code>中的模块内部的绑定。</p><p id="ff30" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">该范围还决定了注入实例的生命周期:在这种情况下，当<code class="du lb lc ld le b">onCreate()</code>被<code class="du lb lc ld le b">LatteActivity</code>调用时，创建由<code class="du lb lc ld le b">Fridge</code>和<code class="du lb lc ld le b">LatteActivity</code>使用的单个<code class="du lb lc ld le b">Milk</code>实例，并在其<code class="du lb lc ld le b">onDestroy()</code>中销毁。这也意味着我们的<code class="du lb lc ld le b">Milk</code>不会在配置变更中“幸存”,因为这将涉及到在活动中调用<code class="du lb lc ld le b">onDestroy()</code>。您可以通过使用生命周期更长的作用域来克服这个问题，比如<code class="du lb lc ld le b">@ActivityRetainedScope</code>。</p><p id="4e1e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">有关可用范围、它们对应的组件以及它们遵循的相应生命周期的列表，请参见<a class="ae kd" href="https://dagger.dev/hilt/components.html" rel="noopener ugc nofollow" target="_blank">手柄组件</a>。</p><h2 id="1b95" class="lz kf hs bd kg ma mb mc kk md me mf ko jq mg mh kq ju mi mj ks jy mk ml ku mm bi translated">提供商注入</h2><p id="9825" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">有时，您希望对注入实例的创建进行更直接的控制。例如，根据您的业务逻辑，您可能希望仅在需要时注入某个东西的一个或几个实例。在这种情况下，可以使用<code class="du lb lc ld le b"><a class="ae kd" href="https://dagger.dev/api/latest/dagger/Provider.html" rel="noopener ugc nofollow" target="_blank">dagger.Provider</a></code>。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="3b1b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">无论依赖项是什么以及如何注入，都可以使用提供者注入。任何可以被注入的东西都可以被包装在<code class="du lb lc ld le b">Provider&lt;…&gt;</code>里面，让它使用provider注入来代替。</p></div><div class="ab cl mp mq go mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ha hb hc hd he"><p id="e9e4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">依赖注入框架(如Dagger和<a class="ae kd" href="https://github.com/google/guice" rel="noopener ugc nofollow" target="_blank"> Guice </a>)传统上与大型复杂项目相关联。然而，由于易于上手和设置，Hilt将Dagger的所有功能打包在一个包中，可以被任何类型的应用程序使用，无论它的代码库有多大。</p><p id="7919" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你想了解更多关于Hilt的信息，它是如何工作的，以及你可能会发现有用的其他特性，去<a class="ae kd" href="https://dagger.dev/hilt/" rel="noopener ugc nofollow" target="_blank">的官方网站</a>，在那里你可以找到更详细的概述和参考文档。</p></div></div>    
</body>
</html>