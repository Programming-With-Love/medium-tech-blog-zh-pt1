<html>
<head>
<title>Develop React + GraphQL + Spring Data JPA + UCP + Oracle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发React+graph QL+Spring Data JPA+UCP+Oracle</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/develop-react-graphql-spring-boot-data-jpa-ucp-oracle-dcb7c4d3b1d4?source=collection_archive---------0-----------------------#2022-09-19">https://medium.com/oracledevs/develop-react-graphql-spring-boot-data-jpa-ucp-oracle-dcb7c4d3b1d4?source=collection_archive---------0-----------------------#2022-09-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2778" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi">​</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/fd594809c7ab337ae5937e3ab61c3767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f4sk1YNmlIzXUGumxFvrQQ.png"/></div></div></figure><p id="2ebb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">撰写本博客是为了给出一个现代全栈微服务应用程序的简洁描述和示例，该应用程序包括一个React前端服务，该服务针对Spring Boot数据JPA后端服务执行GraphQL查询，该后端服务进而映射到Oracle数据库。</strong></p><p id="bfb8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我将从应用程序源的链接开始:<a class="ae jo" href="https://github.com/paulparkinson/react-graphql-springboot-jpa-oracle-ucp-example" rel="noopener ugc nofollow" target="_blank">https://github . com/Paul Parkinson/react-graph QL-spring boot-JPA-Oracle-UCP-example</a></p><p id="f623" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">按照下面的简单说明，只需几分钟就可以构建并运行:</p><ol class=""><li id="4660" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated"><code class="du jy jz ka kb b">cd spring-data-jpa-graphql-ucp-oracle</code></li><li id="f611" class="jp jq hh ig b ih kc il kd ip ke it kf ix kg jb ju jv jw jx bi translated">修改<code class="du jy jz ka kb b">src/main/resources/application.properties</code>以设定<code class="du jy jz ka kb b">spring.datasource.url</code>、<code class="du jy jz ka kb b">spring.datasource.username</code>和<code class="du jy jz ka kb b">spring.datasource.password</code>的值</li><li id="c3c8" class="jp jq hh ig b ih kc il kd ip ke it kf ix kg jb ju jv jw jx bi translated">运行<code class="du jy jz ka kb b">mvn clean install</code></li><li id="3896" class="jp jq hh ig b ih kc il kd ip ke it kf ix kg jb ju jv jw jx bi translated">运行<code class="du jy jz ka kb b">java -jar target/spring-data-jpa-graphql-oracle-0.0.1-SNAPSHOT.jar</code></li><li id="9055" class="jp jq hh ig b ih kc il kd ip ke it kf ix kg jb ju jv jw jx bi translated">(在单独的终端/控制台中)<code class="du jy jz ka kb b">cd react-graphql</code></li><li id="1da3" class="jp jq hh ig b ih kc il kd ip ke it kf ix kg jb ju jv jw jx bi translated">运行<code class="du jy jz ka kb b">yarn add @apollo/client graphql</code>(该项目只需要运行一次)</li><li id="c319" class="jp jq hh ig b ih kc il kd ip ke it kf ix kg jb ju jv jw jx bi translated">运行<code class="du jy jz ka kb b">npm run build</code></li><li id="4099" class="jp jq hh ig b ih kc il kd ip ke it kf ix kg jb ju jv jw jx bi translated">运行<code class="du jy jz ka kb b">npm start</code></li></ol><p id="6b70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个浏览器窗口将打开到<a class="ae jo" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>这是一个React应用程序，它将使用Apollo对运行在localhost:8080上的Spring Boot服务进行GraphQL查询，后者又使用JPA通过从UCP获得的连接查询Oracle数据库。</p><p id="da71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">关于GraphQL的优势和细节有很多文章，特别是因为它们非常适合许多微服务架构。我将尝试通过实际的应用程序源</strong>来说明这一点，并在此简要说明GraphQL查询允许客户端动态地准确指定查询中需要的内容(无论是读还是写)，而服务器使用最合适和最有效的方式来提供这一结果，这样做可以减少所需的请求数量并提高性能。</p><p id="7194" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">从后向前工作的一些细节… </strong></p><p id="3800" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">您要做的第一件事是获得一个Oracle数据库，并配置Spring Boot服务使用UCP连接到它。</strong></p><p id="8e84" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">任何Oracle数据库(本地、容器内、云……)都可以。<a class="ae jo" href="https://apexapps.oracle.com/pls/apex/r/dbpm/livelabs/view-workshop?wid=637" rel="noopener ugc nofollow" target="_blank">利用融合Oracle数据库简化微服务研讨会</a>是创建免费Oracle云数据库的一种非常便捷的方式(同时还设置了一个完整的微服务环境，尽管这对于这个简单的示例来说当然不是必需的)。</p><p id="13c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">默认情况下，Spring Boot目前使用光连接池，但是，Oracle的通用连接池(UCP)提供了许多优势，包括性能和一些功能，如标签、请求边界、应用程序连续性、RAC故障转移、分片、诊断和监控，在未来的版本中还会提供更多功能。为了使用UCP而不是光，必须设置特定的数据源配置属性，并且需要添加适当的依赖项。</p><p id="ecd4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kh"> application.properties </em>文件中配置属性的示例片段:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="24a8" class="km kn hh kb b fi ko kp l kq kr">spring.datasource.url=jdbc:oracle:thin:@someServiceName_tp?TNS_ADMIN=/someLocation/Wallet_someWallet<br/>spring.datasource.username=someUser<br/>spring.datasource.password=somePassword<br/>spring.datasource.driver-class-name=oracle.jdbc.OracleDriver<br/>spring.datasource.type=oracle.ucp.jdbc.PoolDataSource<br/>spring.datasource.oracleucp.connection-factory-class-name=oracle.jdbc.replay.OracleDataSourceImpl<br/>spring.datasource.oracleucp.database-name=oracleADBForGraphQL<br/>spring.datasource.oracleucp.data-source-name=oracleADBForGraphQLDataSource<br/>spring.datasource.oracleucp.description="Oracle ADB Used For GraphQL"</span></pre><p id="15e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">*有关可以设置的其他可选UCP属性，包括池化和日志记录设置，请参见src repos。</p><p id="2bd7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以通过几种方式设置Oracle驱动程序和UCP库的依赖关系。</p><p id="b7dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，可以使用生产pom，如以下pom.xml片段所示:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="622e" class="km kn hh kb b fi ko kp l kq kr">&lt;dependency&gt;<br/>   &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt;<br/>   &lt;artifactId&gt;ojdbc11-production&lt;/artifactId&gt;<br/>   &lt;version&gt;21.1.0.0&lt;/version&gt;<br/>   &lt;type&gt;pom&lt;/type&gt;<br/>&lt;/dependency&gt;</span></pre><p id="cac1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">或者可以使用单独的依赖项，如pom.xml片段所示:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="ff18" class="km kn hh kb b fi ko kp l kq kr">&lt;dependency&gt;<br/>   &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt;<br/>   &lt;artifactId&gt;ojdbc11&lt;/artifactId&gt;<br/>   &lt;version&gt;21.1.0.0&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;com.oracle.database.jdbc&lt;/groupId&gt;<br/>   &lt;artifactId&gt;ucp&lt;/artifactId&gt;<br/>   &lt;version&gt;21.1.0.0&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;com.oracle.database.ha&lt;/groupId&gt;<br/>   &lt;artifactId&gt;ons&lt;/artifactId&gt;<br/>   &lt;version&gt;21.1.0.0&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;com.oracle.database.security&lt;/groupId&gt;<br/>   &lt;artifactId&gt;oraclepki&lt;/artifactId&gt;<br/>   &lt;version&gt;21.1.0.0&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;com.oracle.database.security&lt;/groupId&gt;<br/>   &lt;artifactId&gt;osdt_core&lt;/artifactId&gt;<br/>   &lt;version&gt;21.1.0.0&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;com.oracle.database.security&lt;/groupId&gt;<br/>   &lt;artifactId&gt;osdt_cert&lt;/artifactId&gt;<br/>   &lt;version&gt;21.1.0.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="db25" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">接下来要注意的是，春季数据JPA的基础没有变化。</strong></p><p id="93bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，就模型和存储库抽象而言，Spring Data JPA源中不存在针对UCP或GraphQL逻辑的特殊的、额外的逻辑(在本例中是<em class="kh"> Account </em>和<em class="kh"> Bank </em>)。</p><p id="1b39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">然后注意Spring Boot的服务器端GraphQL的基础知识</strong></p><p id="e221" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GraphQL包括模式、查询和变异的概念。<br/>模式描述了哪些数据可以被查询和操作。如在<br/><em class="kh">src/main/resources/graph QL/account . graph qls</em>中我们看到:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="3c2d" class="km kn hh kb b fi ko kp l kq kr">type Account {<br/>   id: ID!<br/>   balance: BigDecimal!<br/>   description: String<br/>   bank: Bank<br/>}</span></pre><p id="e017" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所料，查询描述了可以读取/查询的信息。再次在<em class="kh"> account.graphqls </em>中我们看到:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="319a" class="km kn hh kb b fi ko kp l kq kr">extend type Query {<br/>   findAllAccounts: [Account]!<br/>   countAccounts: Long!<br/>}</span></pre><p id="1a9f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">突变描述了可以被创建、删除和更新的信息。再次在<em class="kh"> account.graphqls </em>中我们看到:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="f38f" class="km kn hh kb b fi ko kp l kq kr">extend type Mutation {<br/>   createAccount(balance: BigDecimal!, description: String, bank: ID!): Account!<br/>   updateAccount(id: ID!, balance: BigDecimal, description: String): Account!<br/>   deleteAccount(id: ID!): Boolean<br/>}</span></pre><p id="70c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">GraphQL和Spring数据JPA之间的映射逻辑在<em class="kh">解析器</em>包中，其中实现了<em class="kh"> GraphQLQueryResolver(查询)、GraphQL resolver&lt;Account&gt;(</em>Account resolver)<em class="kh">和GraphQLMutationResolver(突变)</em> <br/>都是直接的中介。下面是一些源代码片段作为示例:</p><p id="708f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Query.class:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="7eec" class="km kn hh kb b fi ko kp l kq kr">public Iterable&lt;Account&gt; findAllAccounts() {<br/>   return accountRepository.findAll();<br/>}</span></pre><p id="0875" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">AccountResolver.class:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="2cb5" class="km kn hh kb b fi ko kp l kq kr">public Bank getBank(Account account) {<br/>   return bankRepository.findById(account.getBank().getId()).orElseThrow(null);<br/>}</span></pre><p id="eae0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">突变.类别:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="85f7" class="km kn hh kb b fi ko kp l kq kr">public Account updateAccount(Long id, BigDecimal balance, String description) throws Exception {<br/>   Optional&lt;Account&gt; optionalAccount = accountRepository.findById(id);<br/>   if (optionalAccount.isPresent()) {<br/>      Account account = optionalAccount.get();<br/>      if (balance != null)<br/>         account.setBalance(balance);<br/>      if (description != null)<br/>         account.setDescription(description);<br/>      accountRepository.save(account);<br/>      return account;<br/>   }<br/>   throw new Exception("No account found to update.");<br/>}</span></pre><p id="4f8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">*请注意，我们在这里使用的“GraphQL的Spring是GraphQL Java团队的GraphQL Java Spring项目的继承者”，它“旨在成为所有Spring、GraphQL应用程序的基础。”。因此，我可能会使用该技术发布这个应用程序的新版本/分支(它为graphqls功能提供了方便的注释，等等)。)，然而，这个新功能在2022年5月才达到1.0版本，所以我在这里使用最初的、更广泛使用的方法。</p><p id="7f3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">最后，试用应用程序，看看行为。</strong></p><p id="0621" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Postman是一个方便而简单的测试工具，因此我们将使用它来创建一个或多个银行，但使用带有gql(图形查询语言—一种有意类似于SQL的语言)的GraphQL POST，如下所示:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ks"><img src="../Images/4f3e1e4bbd0626677cef22129deb3eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIyTq5z3jpZGYT_RtSVb2w.png"/></div></div></figure><p id="9310" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">示例应用程序在application.properties文件中有<em class="kh"> spring.jpa.show-sql: true </em>，因此可以在日志中看到数据库的相关SQL JPA问题。在这个createBank案例中，我们看到:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="5c60" class="km kn hh kb b fi ko kp l kq kr">Hibernate: select hibernate_sequence.nextval from dual<br/>Hibernate: insert into bank (name, routing, id) values (?, ?, ?)</span></pre><p id="a103" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们继续为创建的银行/银行id创建一个或多个帐户:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es kt"><img src="../Images/3c37404c333189874f7f47bd221ebced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jjg9DTuNJkM0vl_D3gmTg.png"/></div></div></figure><p id="5327" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们使用下面的gql进行一个<em class="kh"> findAllAccounts </em>查询:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ku"><img src="../Images/99d23044b2bf4f357a112486054c7fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IE9bGQXESjKtdr42dgDPDQ.png"/></div></div></figure><p id="5cb2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这次在Spring Boot日志中我们看到:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="1b6c" class="km kn hh kb b fi ko kp l kq kr">Hibernate: select bank0_.id as id1_1_0_, bank0_.name as name2_1_0_, bank0_.routing as routing3_1_0_ from bank bank0_ where bank0_.id=?</span></pre><p id="650c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">现在让我们看看前端React客户端，以及它如何使用Apollo对Spring Boot服务进行GraphQL查询。</strong></p><p id="9543" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Apollo是ReactJS中最流行的GraphQL库，可以通过运行</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="4770" class="km kn hh kb b fi ko kp l kq kr">yarn add @apollo/client graphql</span></pre><p id="fbb6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在index.tsx中，我们看到了指向Spring Data JPA服务的客户端的创建，以及呈现回复的代码:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="e31c" class="km kn hh kb b fi ko kp l kq kr">const client = new ApolloClient({<br/>    uri: 'http://localhost:8080/apis/graphql',<br/>    cache: new InMemoryCache()<br/>});</span><span id="a953" class="km kn hh kb b fi kv kp l kq kr">render(<br/>    &lt;ApolloProvider client={client}&gt;<br/>        &lt;App /&gt;<br/>    &lt;/ApolloProvider&gt;,<br/>    document.getElementById('root'),<br/>);</span></pre><p id="c61e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在App.tsx中，我们看到了之前在Postman中为<em class="kh"> findAllAccounts </em>查询发布的pql:</p><pre class="jd je jf jg fd ki kb kj kk aw kl bi"><span id="db3d" class="km kn hh kb b fi ko kp l kq kr">const ACCOUNT_INFORMATION_QUERY = gql`<br/>  {findAllAccounts {<br/>      id<br/>      balance<br/>      description<br/>      bank {<br/>          id<br/>          name<br/>      }<br/>  }}<br/>`;</span><span id="fd82" class="km kn hh kb b fi kv kp l kq kr">function AccountInformation() {<br/>    const {loading, error, data} = useQuery(ACCOUNT_INFORMATION_QUERY);<br/>    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;<br/>    if (error) return &lt;p&gt;Error :(&lt;/p&gt;;<br/>    return data.findAllAccounts.map( (account:any) =&gt;<br/>        &lt;div key={account.id}&gt;<br/>            bank id: {account.bank.id} , bank name: {account.bank.name} , account id: {account.id}, account description: {account.description}, account balance: {account.balance}<br/>        &lt;/div&gt;<br/>    );<br/>}</span><span id="f863" class="km kn hh kb b fi kv kp l kq kr">function App() {<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;h2&gt;Bank Account(s) Information...&lt;/h2&gt;<br/>            &lt;AccountInformation/&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="a6c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，当我们运行React应用程序时，我们会看到预期的相同查询结果。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es kw"><img src="../Images/e3b8e5c19789b5cc1a1b5eeb00df0c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G-KhYyt-xy88Jk3lHc3-1A.png"/></div></div></figure><p id="aa2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Oracle非常重视对React、GraphQL和Spring Boot数据社区的强大而简单的支持，并在即将发布的版本中计划了额外的功能和创新。</strong>稍后详细介绍。</p><p id="92b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如有任何意见或问题，请随时与我联系，感谢您的阅读！</p><p id="b87b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi">​</p></div></div>    
</body>
</html>