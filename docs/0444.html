<html>
<head>
<title>Suspending over views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在视图上暂停</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/suspending-over-views-19de9ebd7020?source=collection_archive---------1-----------------------#2019-12-02">https://medium.com/androiddevelopers/suspending-over-views-19de9ebd7020?source=collection_archive---------1-----------------------#2019-12-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/06b55745db5efc7d978190f3bb0d727c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdsNE11vDNyjKccOMGCEzA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" rel="noopener" href="/@VPoltrack">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="3680" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">协程如何简化UI编程</h2></div><p id="f6e7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Kotlin协同程序允许我们像模拟同步代码一样模拟异步问题。这很好，但是大多数使用似乎集中在I/O任务和并发操作上。协同程序非常擅长建模跨线程工作的问题，但也可以在同一个<em class="ki">线程上建模异步问题。</em></p><p id="68e7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我认为有一个地方真正从中受益，那就是使用Android view系统。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="be5e" class="kq kr hx bd ks kt ku kv kw kx ky kz la jd lb je lc jg ld jh le jj lf jk lg lh bi translated">Android视图💘复试</h1><p id="e790" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">Android view系统爱回调；喜欢<strong class="jo hy"> <em class="ki">真的</em> </strong>爱回调。给你一个思路，目前在Android框架中的view和widgets类中有80+个回调，然后在Jetpack中有另外200+个(包括非UI库，但是你明白思路了)。</p><p id="ec10" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">常用的例子包括:</p><ul class=""><li id="e2c6" class="ln lo hx jo b jp jq js jt jv lp jz lq kd lr kh ls lt lu lv bi translated">知道一个动画师什么时候完成。</li><li id="b4ca" class="ln lo hx jo b jp ma js mb jv mc jz md kd me kh ls lt lu lv bi translated"><code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.OnScrollListener" rel="noopener ugc nofollow" target="_blank">RecyclerView.OnScrollListener</a></code>了解滚动状态何时改变。</li><li id="2e2d" class="ln lo hx jo b jp ma js mb jv mc jz md kd me kh ls lt lu lv bi translated"><code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.OnLayoutChangeListener.html" rel="noopener ugc nofollow" target="_blank">View.OnLayoutChangeListener</a></code>知道一个观点是什么时候提出来的。</li></ul><p id="1425" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">然后是接受一个<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/java/lang/Runnable.html" rel="noopener ugc nofollow" target="_blank">Runnable</a></code>来执行异步动作的API，比如<code class="du lw lx ly lz b">View.post()</code>或<code class="du lw lx ly lz b">View.postDelayed()</code>等。</p><p id="cc2e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">之所以有这么多回调，是因为Android上的用户界面编程本来就是异步的。从测量和布局、绘图到插入调度，一切都是异步执行的。一般来说，某个东西(通常是一个视图)向系统请求遍历，然后一段时间后，系统调度该调用，然后触发任何侦听器。</p><h1 id="e278" class="kq kr hx bd ks kt mf kv kw kx mg kz la jd mh je lc jg mi jh le jj mj jk lg lh bi translated">KTX扩展功能</h1><p id="138d" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">对于我们上面提到的许多API，团队已经在Jetpack中添加了扩展功能，以改善开发人员的人机工程学。我最喜欢的一个是<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/core/view/package-summary#doonpredraw" rel="noopener ugc nofollow" target="_blank">View.doOnPreDraw()</a></code>，它<em class="ki">大大简化了等待下一次抽奖的过程。还有很多其他的我每天都在用:举两个例子:<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/core/view/package-summary#doonlayout" rel="noopener ugc nofollow" target="_blank">View.doOnLayout()</a></code>和<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/core/animation/package-summary#(android.animation.Animator).doOnEnd(kotlin.Function1)" rel="noopener ugc nofollow" target="_blank">Animator.doOnEnd()</a></code>。</em></p><p id="4c14" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是这些扩展函数只能做到这一步:它们把一个老派的回调API变成了一个Kotlin友好的基于lambda的API。它们使用起来更好，但是我们仍然以不同的形式处理回调，这使得执行复杂的UI操作更加困难。既然我们在讨论异步操作，那么我们能从协程中获益吗？🤔</p><h1 id="505d" class="kq kr hx bd ks kt mf kv kw kx mg kz la jd mh je lc jg mi jh le jj mj jk lg lh bi translated">救援协管员</h1><p id="1264" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">这篇博客文章假设了协程知识的工作水平。如果你对下面的内容感到陌生，我们今年早些时候发表了一系列博客文章来帮助你回顾:</p><div class="hg hh ez fb hi mk"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb"><div class="ml ab dw"><div class="mm ab mn cl cj mo"><h2 class="bd hy fi z dy mp ea eb mq ed ef hw bi translated">Android上的协同程序(第一部分):了解背景</h2><div class="mr l"><h3 class="bd b fi z dy mp ea eb mq ed ef dx translated">协程解决什么问题？</h3></div><div class="ms l"><p class="bd b fp z dy mp ea eb mq ed ef dx translated">medium.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my ho mk"/></div></div></a></div><p id="0869" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">挂起函数是协程的基本单元之一，它允许我们以非阻塞的方式编写代码。这在我们处理Android UI时很重要，因为我们从不希望阻塞主线程，这可能导致类似<a class="ae hu" href="https://developer.android.com/topic/performance/vitals/render" rel="noopener ugc nofollow" target="_blank"> <em class="ki"> jank </em> </a>的性能问题。</p><h1 id="1f9d" class="kq kr hx bd ks kt mf kv kw kx mg kz la jd mh je lc jg mi jh le jj mj jk lg lh bi translated">suspendCancellableCoroutine</h1><p id="5a6e" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">在Kotlin协同程序库中，有许多协同程序构建器函数，它们支持用挂起函数包装基于回调的API。主要的API是<code class="du lw lx ly lz b"><a class="ae hu" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/suspend-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCoroutine()</a></code>，有一个可取消的版本叫做<code class="du lw lx ly lz b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCancellableCoroutine()</a></code>。</p><p id="7876" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们建议始终使用<code class="du lw lx ly lz b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCancellableCoroutine()</a></code>，因为它允许我们处理两个方向的取消:</p><p id="5468" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> #1:当异步操作挂起时，协程可以被取消</strong>。根据协程运行的范围，如果视图从视图层次结构中删除，协程可能会被取消。示例:从堆栈中弹出片段。处理这个方向允许我们取消任何异步操作，并清理任何正在进行的资源。</p><p id="e29a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> #2:当协程被挂起时，异步UI操作被取消(或者抛出一个错误)。</strong>不是所有的操作都有取消或错误状态，但是对于那些有取消或错误状态的操作，比如下面的<code class="du lw lx ly lz b">Animator</code>，我们应该将这些状态传播到协程，允许方法的调用者处理错误。</p><h1 id="042f" class="kq kr hx bd ks kt mf kv kw kx mg kz la jd mh je lc jg mi jh le jj mj jk lg lh bi translated">等待一个视图被布局</h1><p id="e1ec" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">让我们来看一个例子，它完成了等待视图中下一次布局传递的任务(例如，您已经更改了一个<code class="du lw lx ly lz b">TextView</code>的文本，需要等待一次布局传递才能知道它的新大小):</p><figure class="mz na nb nc fd hj"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="9806" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">该函数仅支持一个方向的取消，从协程到操作<em class="ki"> (#1) </em>，因为布局没有我们可以观察到的错误状态。</p><p id="6c3b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们可以这样使用它:</p><figure class="mz na nb nc fd hj"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="1b2c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们刚刚为视图的布局构建了一个await函数。相同的方法可以应用于许多常用的回调，例如<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/core/view/package-summary#doonpredraw" rel="noopener ugc nofollow" target="_blank">doOnPreDraw()</a></code>知道绘制过程何时将要发生，<code class="du lw lx ly lz b">postOnAnimation()</code>知道下一个动画帧是什么时候，等等。</p><h1 id="ac45" class="kq kr hx bd ks kt mf kv kw kx mg kz la jd mh je lc jg mi jh le jj mj jk lg lh bi translated">范围</h1><p id="8f76" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">你会注意到在上面的例子中，我们使用了一个<code class="du lw lx ly lz b">lifecycleScope</code>来启动我们的协程。那是什么？</p><p id="00bd" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">当我们接触UI时，用来运行任何协程的范围尤其重要，以避免意外泄漏内存。幸运的是，对于我们的视图来说，有许多合适的范围。然后，我们可以使用<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope" rel="noopener ugc nofollow" target="_blank">lifecycleScope</a></code>扩展属性来获得一个适用于该生命周期的<code class="du lw lx ly lz b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/" rel="noopener ugc nofollow" target="_blank">CoroutineScope</a></code>。</p><blockquote class="nf ng nh"><p id="5422" class="jm jn ki jo b jp jq iy jr js jt jb ju ni jw jx jy nj ka kb kc nk ke kf kg kh ha bi translated"><code class="du lw lx ly lz b"><em class="hx">LifecycleScope</em></code> <em class="hx">在AndroidX </em> <code class="du lw lx ly lz b"><em class="hx">lifecycle-runtime-ktx</em></code> <em class="hx">库中可用。你可以在这里</em>  <em class="hx">找到更多信息</em> <a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/coroutines" rel="noopener ugc nofollow" target="_blank"> <em class="hx">。</em></a></p></blockquote><p id="5d3d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">一个常用的生命周期所有者是<code class="du lw lx ly lz b">Fragment</code>的<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/androidx/fragment/app/Fragment.html#getViewLifecycleOwner()" rel="noopener ugc nofollow" target="_blank">viewLifecycleOwner</a></code>，只要附加了片段的视图，它就是活动的。一旦片段的视图被移除，附加的<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope" rel="noopener ugc nofollow" target="_blank">lifecycleScope</a></code>会自动取消。因为我们在挂起函数中增加了取消支持，所以如果发生这种情况，一切都会被自动清除。</p><h1 id="791e" class="kq kr hx bd ks kt mf kv kw kx mg kz la jd mh je lc jg mi jh le jj mj jk lg lh bi translated">等待动画师完成</h1><p id="f106" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">让我们看另一个例子，这次等待动画师来完成:</p><figure class="mz na nb nc fd hj"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="0a17" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">该功能支持<em class="ki">和</em>两个方向的取消，因为<code class="du lw lx ly lz b">Animator</code>和协程都可以单独取消。</p><p id="bc65" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> #1:当动画师运行</strong>时，协程被取消。我们可以使用<code class="du lw lx ly lz b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellable-continuation/invoke-on-cancellation.html" rel="noopener ugc nofollow" target="_blank">invokeOnCancellation</a></code>回调来知道协同程序何时被取消，从而使我们也能够取消动画制作程序。</p><p id="74ca" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> #2:当协程暂停时，动画程序被取消。</strong>我们可以使用<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/android/animation/Animator.AnimatorListener.html#onAnimationCancel(android.animation.Animator)" rel="noopener ugc nofollow" target="_blank">onAnimationCancel()</a></code>回调来知道动画师何时被取消，从而允许我们调用<code class="du lw lx ly lz b">cancel()</code>来取消暂停的协程。</p><p id="1032" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们刚刚学习了将回调API封装到挂起的await函数中的基础知识。🏅</p><h1 id="6e61" class="kq kr hx bd ks kt mf kv kw kx mg kz la jd mh je lc jg mi jh le jj mj jk lg lh bi translated">指挥乐队</h1><p id="a96b" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">在这一点上，你可能会想“<em class="ki">太好了，但是这给了我什么</em>？”孤立地看，这些功能不会做很多事情，但是当你开始将它们结合在一起时，它们会变得非常强大。</p><p id="1999" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">下面是一个使用<code class="du lw lx ly lz b">Animator.awaitEnd()</code>依次运行3个动画的例子:</p><figure class="mz na nb nc fd hj"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="05e2" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">对于这个特殊的例子，你可以把它们都放到一个<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/android/animation/AnimatorSet.html" rel="noopener ugc nofollow" target="_blank">AnimatorSet</a></code>中，得到同样的效果。</p><p id="8f72" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是这种技术适用于不同类型的异步操作；这里使用了一个<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/android/animation/ValueAnimator.html" rel="noopener ugc nofollow" target="_blank">ValueAnimator</a></code>、一个<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.html" rel="noopener ugc nofollow" target="_blank">RecyclerView</a></code>平滑滚动和一个<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/android/animation/Animator.html" rel="noopener ugc nofollow" target="_blank">Animator</a></code>:</p><figure class="mz na nb nc fd hj"><div class="bz dy l di"><div class="nd ne l"/></div></figure><p id="8f5f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">尝试用<code class="du lw lx ly lz b">AnimatorSet</code>来做这件事🤯。要在没有协程的情况下实现这一点，意味着要向每个操作添加侦听器，这会启动下一个操作，依此类推。呸。</p><blockquote class="nl"><p id="5af2" class="nm nn hx bd no np nq nr ns nt nu kh dx translated">通过将不同的异步操作建模为<code class="du lw lx ly lz b">suspend</code>函数，我们获得了表达性和简洁性地编排它们的能力。</p></blockquote><p id="6c54" class="pw-post-body-paragraph jm jn hx jo b jp nv iy jr js nw jb ju jv nx jx jy jz ny kb kc kd nz kf kg kh ha bi translated">尽管如此，我们还可以更进一步…</p><p id="d422" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy">如果我们想让</strong> <code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/android/animation/ValueAnimator" rel="noopener ugc nofollow" target="_blank">ValueAnimator</a></code> <strong class="jo hy">和平滑滚动同时启动，然后在两者都完成后再启动</strong> <code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/android/animation/ObjectAnimator" rel="noopener ugc nofollow" target="_blank">ObjectAnimator</a></code> <strong class="jo hy">怎么办？</strong>因为我们正在使用协程，我们可以使用<code class="du lw lx ly lz b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" rel="noopener ugc nofollow" target="_blank">async()</a></code>并发运行它们:</p><figure class="mz na nb nc fd hj"><div class="bz dy l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="5890" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是如果你想让滚动延迟开始呢？(类似于<code class="du lw lx ly lz b"><a class="ae hu" href="https://developer.android.com/reference/android/animation/Animator.html#setStartDelay(long)" rel="noopener ugc nofollow" target="_blank">Animator.startDelay</a></code>)。好吧，协程也已经把你包括在内了，我们可以使用<code class="du lw lx ly lz b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html" rel="noopener ugc nofollow" target="_blank">delay()</a></code>函数:</p><figure class="mz na nb nc fd hj"><div class="bz dy l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="477c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy">如果我们想要一个重复的过渡怎么办？</strong>我们可以用<code class="du lw lx ly lz b"><a class="ae hu" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html" rel="noopener ugc nofollow" target="_blank">repeat()</a></code>函数包装整个事情(或者使用<code class="du lw lx ly lz b">for</code>循环)。以下是一个视图淡入淡出3次的示例:</p><figure class="mz na nb nc fd hj"><div class="bz dy l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="c093" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">你甚至可以通过重复计数来完成一些简单的事情。假设您想要渐强渐弱在每次重复时逐渐变慢:</p><figure class="mz na nb nc fd hj"><div class="bz dy l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="db21" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在我看来，这就是在Android view系统中使用协程真正发挥作用的地方。我们可以创建一个复杂的异步转换，结合不同的动画类型，而不必将不同类型的回调链接在一起。</p><p id="270b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">通过使用我们在应用程序的数据层上使用的相同的协程原语，我们也使UI编程更容易访问。对于新接触代码的人来说，一个<em class="ki"> await </em>函数比许多看似不相关的回调函数更具可读性。</p><h1 id="943d" class="kq kr hx bd ks kt mf kv kw kx mg kz la jd mh je lc jg mi jh le jj mj jk lg lh bi translated">post.resume()</h1><p id="7039" class="pw-post-body-paragraph jm jn hx jo b jp li iy jr js lj jb ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">希望这篇文章能让你思考还有哪些API可以从协程中获益！</p><p id="8644" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这篇文章的后续文章展示了如何使用协程来编排复杂的转换，并包括一些常见视图的实现，可以在下面找到:</p><div class="hg hh ez fb hi mk"><a rel="noopener follow" target="_blank" href="/androiddevelopers/suspending-over-views-example-260ce3dc9100"><div class="ml ab dw"><div class="mm ab mn cl cj mo"><h2 class="bd hy fi z dy mp ea eb mq ed ef hw bi translated">在视图上暂停-示例</h2><div class="mr l"><h3 class="bd b fi z dy mp ea eb mq ed ef dx translated">让我们把我们在上一篇文章中学到的东西应用到一个真实的应用用例中。这里我们有电视节目…</h3></div><div class="ms l"><p class="bd b fp z dy mp ea eb mq ed ef dx translated">medium.com</p></div></div><div class="mt l"><div class="oa l mv mw mx mt my ho mk"/></div></div></a></div></div></div>    
</body>
</html>