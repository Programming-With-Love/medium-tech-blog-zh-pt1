<html>
<head>
<title>Boost Smooth Scrolling with iOS 10 Pre-Fetching API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用iOS 10预取API提升平滑滚动</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/boost-smooth-scrolling-with-ios-10-pre-fetching-api-818c25cd9c5d?source=collection_archive---------0-----------------------#2017-04-03">https://medium.com/capital-one-tech/boost-smooth-scrolling-with-ios-10-pre-fetching-api-818c25cd9c5d?source=collection_archive---------0-----------------------#2017-04-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/bc1d076797cab967abf71c98e3740d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uex834n-V3T6PlQzlEwRzA.png"/></div></div></figure><p id="f05a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<a class="ae jn" rel="noopener" href="/capital-one-developers/smooth-scrolling-in-uitableview-and-uicollectionview-a012045d77f">之前的帖子</a>中，我们探索了一些常见的策略来实现我们的iOS移动应用程序的平滑滚动。应用这些策略的主要目的是避免<em class="jo">起伏的滚动</em>，这是一个对用户体验产生负面影响的常见问题。为了帮助开发者完成这样的任务，苹果在iOS10中对<strong class="ir hi"> UICollectionView </strong>做了一些非常有用的改动。但是在回顾这个新引入的功能之前，让我们先来看看是什么促使了对它们的需求。</p><h1 id="af66" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">什么原因导致滚动不稳定？</h1><p id="0367" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">你曾经使用过滚动不稳定的应用程序吗？如果答案是“是”，那么你就知道当你试图快速滚动时，应用程序内容出现口吃是多么令人失望。您可能会问自己，是什么触发了这种起伏不定的滚动行为以及随之而来的糟糕用户体验。</p><p id="bcaa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">简短的回答是:应用程序被<em class="jo">丢帧</em>。但是这到底是什么意思呢？</strong></p><p id="11c8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了确保一致的平滑滚动，应用程序需要能够稳定地显示60 FPS(每秒帧数)。或者换句话说，应用程序需要每秒钟刷新60次内容。这意味着每帧大约有16毫秒(1000毫秒/60帧~ 16毫秒/帧)要渲染。在不幸的情况下，显示一帧花费的时间比分配的时间长，没有显示下一帧的数据，据说应用程序“<em class="jo">丢弃了一帧“</em>”。下图显示了这种不幸的情况。蓝色标记表示绘制操作，其粗细表示完成渲染所需的时间。正如我们所看到的，在第二帧中，我们有一些渲染事件花费了超过分配的时间(大约16毫秒)，因此，第三帧被丢弃了。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es ks"><img src="../Images/a36345417ee295170b825f277f9051a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*uT_0CPeVRvXn0W3FjJelLw.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx">Dropped Frame</figcaption></figure><p id="beaa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以从刷新操作花费的CPU时间的角度来看这个场景。在下图中，峰值对应于应用程序刷新当前内容的时间超过预期的16毫秒时出现的丢帧。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es lb"><img src="../Images/1d18bce9c601ab3668f097cf67239eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*f0k4kFKTobUtm3CDch8_zg.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx">Display Refreshes</figcaption></figure><p id="04b8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了获得良好的用户体验，刷新时间必须始终低于允许的最大值约16ms。理想情况下，由于我们想要创建一个<em class="jo">出色的</em>用户体验(而不仅仅是一个好的体验)，每次刷新时间应该是:</p><ul class=""><li id="2de7" class="lc ld hh ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated">始终远低于允许的最长时间(约16毫秒)。</li><li id="3a42" class="lc ld hh ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">尽可能低，以节省可用于其他任务的CPU时间。</li></ul><p id="33eb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">丢帧最常见的原因是从主线程为单元加载昂贵的数据模型。这种情况的典型例子有:</p><ul class=""><li id="9f54" class="lc ld hh ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated">从URL加载图像。</li><li id="763d" class="lc ld hh ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">从数据库或CoreData访问项目。</li></ul><p id="7638" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在iOS10中，苹果对单元格的加载和显示方式进行了一些优化。让我们来看看iOS10的改进，以及它们如何让开发人员更容易创建平滑滚动的用户体验。</p><h1 id="4415" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">iOS9中的细胞生命周期</h1><p id="b201" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">一个<strong class="ir hi"> UICollectionViewCell </strong>的生命周期可以被可视化如下:</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/0746098f52d142fc0bbc292910a41eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ERdoa46MnULV8I3vVZ1ftw.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">iOS9 cell lifecycle</figcaption></figure><p id="6546" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">集合视图及其单元格之间的主要交互是:</p><ul class=""><li id="6ee1" class="lc ld hh ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated">集合视图正在请求将要显示的单元格的内容— <em class="jo">该单元格将要进入可见字段:</em> <code class="du lr ls lt lu b"><a class="ae jn" href="https://developer.apple.com/reference/uikit/uicollectionviewdatasource/1618029-collectionview" rel="noopener ugc nofollow" target="_blank">collectionView(_:cellForItemAt:)</a></code>。</li><li id="9f0b" class="lc ld hh ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">集合视图正在请求显示单元格— <em class="jo">刚刚进入可见字段的单元格:</em> <code class="du lr ls lt lu b"><a class="ae jn" href="https://developer.apple.com/reference/uikit/uicollectionviewdelegate/1618087-collectionview" rel="noopener ugc nofollow" target="_blank">collectionView(_:willDisplay:forItemAt:)</a></code>。</li><li id="0222" class="lc ld hh ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">集合视图正在移除单元格— <em class="jo">单元格在可见字段</em> : <code class="du lr ls lt lu b"><a class="ae jn" href="https://developer.apple.com/reference/uikit/uicollectionviewdelegate/1618006-collectionview" rel="noopener ugc nofollow" target="_blank">collectionView(didEndDisplaying:forItemAt:)</a></code>之外。</li></ul><h1 id="d7fb" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">iOS10中的细胞生命周期</h1><p id="8016" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在iOS10中，一个单元的生命周期与iOS9中的基本相同。然而，还是有一些显著的区别。</p><p id="cf44" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一个区别是操作系统调用<code class="du lr ls lt lu b">collectionView(_:cellForItemAt:)</code>的时间比以前早了很多。这意味着两件事:</p><ul class=""><li id="87d0" class="lc ld hh ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated">加载单元的繁重工作可以在需要显示单元之前完成。</li><li id="eaed" class="lc ld hh ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">该单元格可能最终根本不会被显示(因为它可能永远不会被带入可视区域)。</li></ul><p id="fb27" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第二个区别是当一个细胞离开可见视野时会发生什么。在iOS10中，<code class="du lr ls lt lu b">collectionView(didEndDisplaying:forItemAt:)</code>像往常一样被调用，但该单元不会立即被回收。操作系统将它保留一段时间，以防用户反转滚动方向；如果发生这种情况，单元格仍然可用，可以再次显示(<code class="du lr ls lt lu b">collectionView(_:willDisplay:forItemAt:)</code>将被调用)，而不必重新加载其内容。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/90fca187d5390de632bc88f3d9ebee23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HBwvMeo353VApdhE23-aEA.png"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">iOS10 cell lifecycle changes</figcaption></figure><p id="0138" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将这与iOS9上发生的情况进行比较。您会注意到，对于这个特定的用例，不再需要重载单元格(<code class="du lr ls lt lu b">collectionView(_:cellForItemAt:)</code>)。这种优化允许我们在用户快速滚动和改变滚动方向时更快地渲染单元格。</p><p id="f149" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">iOS9和iOS10之间的第三个重要区别是多栏布局的收藏视图的单元格加载方式。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es lv"><img src="../Images/3cb8e0f89845c3fa6423822a6dbd54af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*O5nqdJvcar-ktGvPA8dBFw.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx">iOS9</figcaption></figure><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es lw"><img src="../Images/8485eca3b5429c630941b406f3df8872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*7bjflYPIDGYGNkNoJWyCvg.png"/></div><figcaption class="kx ky et er es kz la bd b be z dx">iOS10</figcaption></figure><p id="b885" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用iOS10，每个关于进入可见场的单元格都是单独加载的(<code class="du lr ls lt lu b">collectionView(_:cellForItemAt:)</code>)。正如我们在检查单元格生命周期时看到的，这比每个单元格实际需要显示的时间要早得多。这为优化打开了大门，因为操作系统将能够处理不同的请求，将它们与单元负载交错。</p><p id="430b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当一行单元格进入可视字段时，这些单元格被显示为一个单独的批次(同时对整行调用<code class="du lr ls lt lu b">collectionView(_:willDisplay:forItemAt:)</code>),因为这个操作在CPU周期方面不是很昂贵(至少与加载单元格内容相比)。</p><p id="9bd0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种加载多栏布局的差异是最重要的iOS10 <strong class="ir hi"> UICollectionView </strong>优化的核心:<em class="jo">预取</em>。让我们更详细地探讨一下。</p><h1 id="4d7c" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">预取API</h1><p id="0451" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在展示iOS10时，苹果吹捧<a class="ae jn" href="https://developer.apple.com/videos/play/wwdc2016/219/" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">预取</strong> </a>是一项<em class="jo">自适应技术</em>。这意味着<em class="jo">预取</em>将尝试利用用户与应用程序的交互方式来执行一些旨在提高滚动性能的优化。例如，这项新技术将寻找空闲时间(当用户缓慢滚动或根本不滚动时)来加载(<em class="jo">预取</em>)新单元。根据用户的滚动模式，可能有更多(或更少)的机会让<em class="jo">预取</em>来执行这样的优化。</p><p id="e7a4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在回顾可用的API之前，让我们看一下使用这项技术的一些最佳实践。为了充分利用<em class="jo">预取</em>，必须在<code class="du lr ls lt lu b">collectionView(_:cellForItemAt:)</code>中执行大部分设置单元内容的操作。在<code class="du lr ls lt lu b">collectionView(_:willDisplay:forItemAt:)</code>和<code class="du lr ls lt lu b">collectionView(didEndDisplaying:forItemAt:)</code>中执行的操作应该保持最小化，并且必须是非CPU密集型的。更好的是，如果我们可以对那些生命周期事件不执行任何操作，那就更好了！此外，请记住，即使某个单元格调用了<code class="du lr ls lt lu b">collectionView(_:cellForItemAt:)</code>，该单元格仍有可能永远不会显示。</p><p id="9a62" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一些非常好的消息是，对于在iOS10上编译的应用程序，默认情况下会启用<em class="jo">预取</em>。但是，可以通过将<strong class="ir hi"> UICollectionView </strong>的<code class="du lr ls lt lu b">isPrefetchingEnabled</code>属性设置为<code class="du lr ls lt lu b">false</code>来关闭此功能。同样值得注意的是，<em class="jo">预取</em>与单元生命周期一起工作。这意味着我们已经编写的实现集合视图的代码不需要修改——充分利用<em class="jo">预取</em>所需的唯一动作是实现<em class="jo">预取API </em>。</p><h2 id="1c05" class="lx jq hh bd jr ly lz ma jv mb mc md jz ja me mf kd je mg mh kh ji mi mj kl mk bi translated">预取API和UICollectionView</h2><p id="adfe" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在<code class="du lr ls lt lu b"><a class="ae jn" href="https://developer.apple.com/reference/uikit/uicollectionviewdatasourceprefetching" rel="noopener ugc nofollow" target="_blank">UICollectionViewDataSourcePrefetching</a></code>协议中定义了<strong class="ir hi"> UICollectionView </strong>的预取API。API定义了以下两种方法。</p><p id="6146" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lr ls lt lu b"><a class="ae jn" href="https://developer.apple.com/reference/uikit/uicollectionviewdatasourceprefetching/1771767-collectionview" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">collectionView(_:prefetchItemsAt:)</strong></a></code>(必需)—该方法允许异步加载由<code class="du lr ls lt lu b">[IndexPath]</code>参数指定的单元格所需的数据。异步加载可以通过<a class="ae jn" href="https://developer.apple.com/reference/dispatch" rel="noopener ugc nofollow" target="_blank">大调度</a>或<code class="du lr ls lt lu b"><a class="ae jn" href="https://developer.apple.com/reference/foundation/operationqueue" rel="noopener ugc nofollow" target="_blank">OperationQueue</a></code>进行。实现这些方法时最重要的是编写代码，将数据加载的负担从主队列转移到后台队列。这样做的目的是减少主队列的工作负载，使其能够将大部分时间用于执行显示刷新等关键任务。</p><p id="5853" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lr ls lt lu b"><a class="ae jn" href="https://developer.apple.com/reference/uikit/uicollectionviewdatasourceprefetching/1771769-collectionview" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">collectionView(_:cancelPrefetchingForItemsAt:)</strong></a></code>(可选)—该方法告知不再需要由<code class="du lr ls lt lu b">[IndexPath]</code>参数指定的单元格的数据。实现这个方法允许我们根据需要取消挂起的数据加载，这是通过取消不必要的工作(通常是因为用户改变了滚动方向)来节省CPU时间的好方法。</p><p id="4fa2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如前所述，<em class="jo">预取</em>是一种<em class="jo">自适应技术</em>。因此，上述方法是基于用户与app的交互方式而触发的。这样做的一个后果是，不能为集合视图中的每个单元格调用<code class="du lr ls lt lu b">collectionView(_:prefetchItemsAt:)</code>方法。这意味着当通过<code class="du lr ls lt lu b">collectionView(_:cellForItemAt:)</code>加载单元格时，应用程序应该能够处理以下所有场景:</p><ul class=""><li id="5ef5" class="lc ld hh ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated">数据已被预取，并准备好显示。</li><li id="810b" class="lc ld hh ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">当前正在获取数据，尚未准备好显示。</li><li id="84b9" class="lc ld hh ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">数据尚未被请求。</li></ul><h2 id="e5d3" class="lx jq hh bd jr ly lz ma jv mb mc md jz ja me mf kd je mg mh kh ji mi mj kl mk bi translated">预取API和UITableView</h2><p id="3440" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">iOS10还为<strong class="ir hi"> UITableView </strong>引入了<em class="jo">预取</em>。我们为<strong class="ir hi"> UICollectionView </strong>展示的所有主要概念都以类似的方式适用于<strong class="ir hi"> UITableView </strong>。<strong class="ir hi"> UITableView </strong>的<em class="jo">预取API </em>在<code class="du lr ls lt lu b"><a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableviewdatasourceprefetching" rel="noopener ugc nofollow" target="_blank">UITableViewPrefetchingDataSource</a></code>协议中定义。API定义了以下两种方法。</p><p id="5edc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lr ls lt lu b"><a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableviewdatasourceprefetching/1771764-tableview" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">tableView(_:prefetchRowsAt:)</strong></a></code>(必需)—该方法允许异步加载由<code class="du lr ls lt lu b">[IndexPath]</code>参数指定的单元格所需的数据。</p><p id="998e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lr ls lt lu b"><a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableviewdatasourceprefetching/1771765-tableview" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">tableView(_:cancelPrefetchingForRowsAt:)</strong></a></code>(可选)—此方法告知不再需要由<code class="du lr ls lt lu b">[IndexPath]</code>参数指定的单元格的数据。</p><p id="0ef9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为每个<strong class="ir hi"> UICollectionView </strong> <em class="jo">预取API </em>方法提出的建议同样适用于每个模拟<strong class="ir hi"> UITableView </strong> <em class="jo">预取API </em>方法。</p><h1 id="c6ee" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="14ea" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">我已经为<strong class="ir hi"> UITableView </strong>和<strong class="ir hi"> UICollectionView </strong>更新了我的代码示例，以支持iOS10上的<em class="jo">预取</em>。这里可以找到<a class="ae jn" href="https://github.com/andrea-prearo/SwiftExamples/tree/master/SmoothScrolling/Client" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ebcb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我们回顾了iOS10的改进，以提高<strong class="ir hi"> UICollectionView </strong>和<strong class="ir hi"> UITableView </strong>的平滑滚动。特别是，我们看到，通过实施特定的<em class="jo">预取API </em>，可以充分利用所有新的操作系统优化，并在与我们的移动应用程序交互时提供最佳的用户体验。</p><h2 id="cfc3" class="lx jq hh bd jr ly lz ma jv mb mc md jz ja me mf kd je mg mh kh ji mi mj kl mk bi translated">有关系的</h2><ul class=""><li id="89da" class="lc ld hh ir b is kn iw ko ja ml je mm ji mn jm lh li lj lk bi translated"><a class="ae jn" rel="noopener" href="/capital-one-developers/reference-and-value-types-in-swift-de792db330b2">Swift中的引用和值类型</a></li><li id="99cc" class="lc ld hh ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated"><a class="ae jn" rel="noopener" href="/capital-one-developers/smooth-scrolling-in-uitableview-and-uicollectionview-a012045d77f">在UITableView和UICollectionView中平滑滚动</a></li><li id="fce7" class="lc ld hh ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated"><a class="ae jn" rel="noopener" href="/capital-one-developers/generic-data-sources-in-swift-c6fbb531520e">Swift中的通用数据源</a></li><li id="a3c5" class="lc ld hh ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated"><a class="ae jn" rel="noopener" href="/capital-one-developers/an-alternative-to-type-erasure-for-generic-protocols-a9a48e96618a">通用协议类型擦除的替代方案</a></li></ul></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><p id="c4ab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权均为其各自所有者所有。本文为2017首都一。</p></div></div>    
</body>
</html>