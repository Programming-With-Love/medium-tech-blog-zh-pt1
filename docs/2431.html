<html>
<head>
<title>Build Progressive Web Apps — Chapter 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建渐进式网络应用——第5章</h1>
<blockquote>原文：<a href="https://medium.easyread.co/build-progressive-web-apps-chapter-5-60f6213f1075?source=collection_archive---------0-----------------------#2019-11-30">https://medium.easyread.co/build-progressive-web-apps-chapter-5-60f6213f1075?source=collection_archive---------0-----------------------#2019-11-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9e95" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">服务工作者丹缓存技术</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e28770274e6a9d1dce0b841c324823e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dVlfyYWOH1GnGNeL.jpg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Service Workers Lifecycle</figcaption></figure><h1 id="8273" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">构建渐进式Web应用程序-列表</h1><p id="b55e" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><a class="ae mg" href="https://medium.com/easyread/build-progressive-web-apps-6248a7152730" rel="noopener"> <strong class="lm io">第0章—PWA</strong></a><br/><a class="ae mg" href="https://medium.com/easyread/build-progressive-web-apps-chapter-1-d3d2b449ab42" rel="noopener"><strong class="lm io">介绍及案例分析第1章—PWA</strong></a><strong class="lm io"><br/></strong><a class="ae mg" href="https://medium.com/easyread/build-progressive-web-apps-chapter-2-pwa-components-428295c2d524" rel="noopener"><strong class="lm io">第2章—PWA的组件&amp;架构模式</strong></a><strong class="lm io"><br/></strong><a class="ae mg" href="https://medium.com/easyread/build-progressive-web-apps-chapter-3-a73269d627b2" rel="noopener"><strong class="lm io">第3章—准备及工具</strong></a><strong class="lm io"><br/></strong><a class="ae mg" href="https://medium.com/easyread/build-progressive-web-apps-chapter-4-b85ef6e6d465" rel="noopener"><strong class="lm io">第4章—创建一个简单的SPA</strong></a></p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><p id="15fa" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">在前面的<a class="ae mg" href="https://medium.com/@jansutris10/build-progressive-web-apps-chapter-4-b85ef6e6d465" rel="noopener">章节</a>中，我们已经使用Materialize CSS框架和一些JavaScript代码制作了一个简单的SPA来改变页面内容。但据说我们在SPA上使用了shell应用程序，这并不完美。因为即使作为多页网站切换页面时页面没有重新加载，设备离线或没有连接时，shell应用程序仍然不会出现。换句话说，我们的shell应用程序不是一个有效的本地应用程序，它甚至在用户界面组件脱机时仍然显示用户界面组件。要做到这一点，我们需要两种web浏览器技术，服务工作器和缓存。</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="1626" class="ks kt in bd ku kv mt kx ky kz mu lb lc jt mv ju le jw mw jx lg jz mx ka li lj bi translated">服务人员注册</h1><p id="dd6d" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">Service Worker是浏览器在后台运行的脚本，与浏览器网页上的其他脚本是分开的。服务工作者是使用JavaScript编程语言编写的，但是调用方式不同于一般的JavaScript代码。在我们这次的案例研究中，服务工作者充当请求路径的监管者，对缓存中哪些资产已经可以立即使用，哪些资产需要首先向网络请求。</p><p id="31f3" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">如何调用服务工作者代码与一般的JavaScript代码略有不同。通常，我们使用页面上的<script>标签插入代码文件或JavaScript库。同时，为了调用服务工作者文件，我们使用了&lt;code class="fe my mz na nb b"&gt;&lt;strong class="lm io"&gt;navigator.serviceWorker.register (‘/ service-worker.js’)&lt;/strong&gt;&lt;/code&gt;方法。&lt;/root&gt;</script></p><h1 id="f9af" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">预缓存资产</h1><p id="d0e3" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">在<strong class="lm io"> service-worker.js </strong>文件中，编写代码来缓存资产并提供已经缓存的资产，以便它们可以在将来的页面调用中使用。为了在缓存中注册资产，我们从浏览器使用缓存API，包括<code class="fe my mz na nb b"><strong class="lm io">caches.open()</strong></code>打开缓存、<code class="fe my mz na nb b"> <strong class="lm io">caches.add()</strong></code>和<code class="fe my mz na nb b"><strong class="lm io">cache.addAll()</strong></code>在缓存中存储资产，以及<code class="fe my mz na nb b"><strong class="lm io">caches.match()</strong></code>检查请求的资产是否已经在缓存中。API缓存是基于承诺的。如果你不熟悉承诺，你可以在“承诺和获取API”一章中学习。</p><p id="3a4b" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">你可以在下一章了解更多关于服务工作器和缓存API的知识。现在，我们将继续下一个codelab，以便我们的应用程序即使在离线网络条件下也能继续显示UI组件。</p><p id="8c11" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">在第一个codelab中，我们将更改本教程前面创建的单页应用程序，以逐步逐个实现PWA功能。最早的步骤是向创建的应用程序注册一个服务人员。</p><h1 id="1dd3" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">注册服务人员</h1><p id="e25a" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">在项目文件夹中创建一个名为<strong class="lm io"> service-worker.js </strong>的文件。先留空。</p><p id="1b5b" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">然后重新打开<strong class="lm io">index.html</strong>文件，在结束标签<strong class="lm io"> &lt; /body &gt; </strong>前的底部添加以下代码:</p><pre class="kd ke kf kg gt nc nb nd ne aw nf bi"><span id="5a85" class="ng kt in nb b gy nh ni l nj nk">&lt;script&gt;<br/>  // REGISTER SERVICE WORKER<br/>  if ("serviceWorker" in navigator) {<br/>    window.addEventListener("load", function() {<br/>      navigator.serviceWorker<br/>        .register("/service-worker.js")<br/>        .then(function() {<br/>          console.log("Pendaftaran ServiceWorker berhasil");<br/>        })<br/>        .catch(function() {<br/>          console.log("Pendaftaran ServiceWorker gagal");<br/>        });<br/>    });<br/>  } else {<br/>    console.log("ServiceWorker belum didukung browser ini.");<br/>  }<br/>&lt;/script&gt;</span></pre><p id="609f" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">在上面的代码中，我们首先检查navigator对象是否已经在浏览器中。这意味着如果对象不存在，所使用的浏览器不支持服务工作器功能，因为服务工作器在对象导航器内运行。</p><p id="dcc4" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">然后我们使用<code class="fe my mz na nb b"><strong class="lm io">navigator.serviceWorker.register()</strong></code>方法注册service-worker.js文件。注册过程仅在具有<strong class="lm io"> https: // </strong>或<strong class="lm io"> http: // </strong>域名的网站上成功(仅在开发期间允许)。重新加载您的应用程序，您将能够在Chrome DevTools面板的Service Worker部分的应用程序选项卡中检查注册过程是成功还是失败(可以在应用程序的左侧菜单中访问):</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/f40ef0d6f6fe6fcaa353d01bde17b1c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mpcig79mDMbStuvZ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Service Worker section</figcaption></figure><p id="74fc" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">在“控制台”选项卡上，您还可以看到来自服务人员注册代码的日志消息，这些消息指示服务人员注册成功还是失败。</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="90b8" class="ks kt in bd ku kv mt kx ky kz mu lb lc jt mv ju le jw mw jx lg jz mx ka li lj bi translated">将资产保存到缓存</h1><p id="2bf4" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">现在我们将在<strong class="lm io"> service-worker.js </strong>文件中编写服务工作者代码。在文件中添加以下代码:</p><pre class="kd ke kf kg gt nc nb nd ne aw nf bi"><span id="f447" class="ng kt in nb b gy nh ni l nj nk">const CACHE_NAME = "firstpwa";<br/>var urlsToCache = [<br/>  "/",<br/>  "/nav.html",<br/>  "/index.html",<br/>  "/pages/home.html",<br/>  "/pages/about.html",<br/>  "/pages/contact.html",<br/>  "/css/materialize.min.css",<br/>  "/js/materialize.min.js",<br/>  "/js/nav.js"<br/>];<br/> <br/>self.addEventListener("install", function(event) {<br/>  event.waitUntil(<br/>    caches.open(CACHE_NAME).then(function(cache) {<br/>      return cache.addAll(urlsToCache);<br/>    })<br/>  );<br/>});</span></pre><p id="9422" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">在上面的代码中，我们创建了一个常量变量<strong class="lm io"> CACHE_NAME </strong>，其中包含一个字符串，我们稍后将使用该字符串作为缓存名称。我们还创建了一个<strong class="lm io"> urlsToCache </strong>变量，以便更容易地编写资产列表以及哪些页面将被缓存。</p><p id="4db0" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">然后，我们为install事件注册事件监听器，该事件监听器将在服务工作者注册过程成功后被调用。在其中，我们用我们写的名字打开缓存。如果它不存在，则会创建一个同名的新缓存。打开缓存后，我们立即将资产存储在缓存中，这是我们使用<code class="fe my mz na nb b"><strong class="lm io">cache.addAll()</strong></code>方法在<strong class="lm io"> urlsToCache </strong>变量中创建的资产列表。</p><p id="79e6" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">如果代码运行良好，那么资产应该在浏览器缓存中列出。您可以在<strong class="lm io">缓存存储</strong>部分的<strong class="lm io"> DevTools </strong>应用选项卡上检查已注册的缓存。点击<strong class="lm io">缓存存储</strong>菜单左侧的三角形，查看缓存列表。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/8e9da1d2b0e5c69d23f773497695c4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5tUMTb_Mc5Bbujzn.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Cache Storage</figcaption></figure><p id="d398" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">此时，我们只在缓存中存储资产。如果您检查“网络”选项卡并刷新页面，页面仍会使用来自服务器请求的资产。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/9871ec2fc584e88a4eb4ace7aaacc2e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RkrXkaj573lEgAEm.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Network tab</figcaption></figure><p id="6dea" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">在上面的示例图像中，大小列似乎仍然显示从服务器加载的资源的大小。</p><h1 id="cec2" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">使用缓存中的资产</h1><p id="93ee" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">将以下代码添加到service-worker.js文件中，以便该页面使用已缓存的资产:</p><pre class="kd ke kf kg gt nc nb nd ne aw nf bi"><span id="f4f7" class="ng kt in nb b gy nh ni l nj nk">self.addEventListener("fetch", function(event) {<br/>  event.respondWith(<br/>    caches<br/>      .match(event.request, { cacheName: CACHE_NAME })<br/>      .then(function(response) {<br/>        if (response) {<br/>          console.log("ServiceWorker: Gunakan aset dari cache: ", response.url);<br/>          return response;<br/>        }<br/> <br/>        console.log(<br/>          "ServiceWorker: Memuat aset dari server: ",<br/>          event.request.url<br/>        );<br/>        return fetch(event.request);<br/>      })<br/>  );<br/>});</span></pre><p id="7c3d" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">在上面的代码中，我们为服务工作者获取事件注册了事件监听器，每次浏览器向网络发送请求时都会调用该事件监听器，例如<strong class="lm io">加载页面、css、js、图形资产和字体。</strong>我们首先检查请求是否匹配已经存储在缓存中的资产之一。如果有匹配的，那么我们直接在页面上返回要使用的资产。如果没有找到，我们将继续使用<code class="fe my mz na nb b"><strong class="lm io">fetch()</strong> </code>方法发送请求。</p><p id="157c" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">如果您现在刷新页面，您将在Network选项卡上看到应用程序仍然没有使用缓存中的资产。这是因为活动的服务工作者仍然是旧代码。浏览器将等待激活过程，直到我们在新的会话中打开应用程序。只要我们打开应用程序，就会计算一个会话，直到我们关闭浏览器选项卡或浏览器窗口。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/e2c4378baba6761066ba503770595356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4RgnqD29B7CUFlWP.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">service workers tab</figcaption></figure><p id="0ace" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">在上图中，我们看到活动的和运行的工作线程的服务状态仍然是旧版本，我们添加到事件监听器获取代码的最新版本已经收到，但尚未激活。</p><p id="26d8" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">要激活最新的服务人员，您可以首先关闭应用程序的浏览器选项卡，然后再次打开以获得新的会话。但是这种方法在开发过程中效率较低。一种更简单的方法是单击最新工作人员服务状态旁边的<strong class="lm io"> skipWaiting </strong>链接。或者为了更有效率，你可以激活服务人员面板顶部的<strong class="lm io">重新加载时更新</strong>选项复选框。因此，每次有更新时，浏览器都会立即激活服务人员。</p><p id="294b" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">在最近的服务工作者被激活之后，您可以重新加载该页面，现在该页面应该已经使用了来自缓存的资产，这在Size列中被指示，该列现在被写为资产是由服务工作者提供的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/a5830515e040cbac0edc405e477cff02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HitnEfff9yzEZWJp.png"/></div></div></figure><p id="2f91" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">现在你可以尝试在<strong class="lm io">离线模式</strong>下调用页面，以确保应用程序仍然出现，即使它没有连接到网络。你可以关闭web服务器，或者在DevTools的<strong class="lm io">网络</strong>选项卡上，你可以激活面板顶部的离线选项复选框来模拟<strong class="lm io">离线</strong>网络模式。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/98783f3b9811bc1f08ba71e421c4a015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gJJnQnkFQhKoNlCs.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Offline option</figcaption></figure><p id="d026" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">恭喜您，您已经实现了服务工作器的主要功能，即离线访问。因此，您的应用程序用户仍然可以访问应用程序，即使它没有连接到互联网！</p><h1 id="2db4" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">删除旧缓存</h1><p id="a0cf" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">当我们改变应用程序页面的内容，或者改变CSS代码时会发生什么？是的，您在浏览器页面中看不到任何变化，因为应用程序显示使用了缓存中的资产。但是如果您在DevTools的Service Workers面板中激活了Update on reload选项，那么每次我们刷新应用程序页面时，内容和资产中的所有更改都会更新到缓存中。</p><p id="61a7" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">重新加载时更新选项在应用程序开发过程中非常有用。但是当应用程序已经发布给用户时，就不能依赖这个选项了，因为我们不能强迫用户打开DevTools并激活这个选项。尤其是当用户通过移动设备打开应用时。</p><p id="4fd7" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">使更新发生在用户端的解决方案是更改服务工作器中使用的缓存的名称。如果之前我们的缓存名称是firstpwa，那么我们可以用另一个名称替换它。我们通常只是添加一个版本标记，这样我们就可以轻松地跟踪已经发生的更改，例如，我们将缓存的名称更改为firstpwa-v1、firstpwa-v2等等。要点是每次向用户发布应用程序更新时，必须确保也更改缓存名称。</p><p id="fec3" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">现在尝试对页面(内容或CSS)做一些小的更改，并在<strong class="lm io"> service-worker.js </strong>文件中重命名缓存:</p><pre class="kd ke kf kg gt nc nb nd ne aw nf bi"><span id="c638" class="ng kt in nb b gy nh ni l nj nk">const CACHE_NAME = 'firstpwa-v1';</span></pre><p id="c94a" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">因此，当刷新应用程序页面时，将会出现更改并创建一个新的缓存。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/0d7a1659c455a3b2903c524d3c800ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/0*0ytgw2hkbDY51HE6.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">firstpwa-v1</figcaption></figure><p id="389f" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">新的问题会出现。我们越频繁地更改缓存的名称，用户的浏览器中就会有很多垃圾缓存，当然它会占用用户设备的存储空间。为此，我们必须创建一个旧的缓存删除机制，以免给用户带来负担。在service-worker.js文件的末尾添加以下代码:</p><pre class="kd ke kf kg gt nc nb nd ne aw nf bi"><span id="6ef9" class="ng kt in nb b gy nh ni l nj nk">self.addEventListener("activate", function(event) {<br/>  event.waitUntil(<br/>    caches.keys().then(function(cacheNames) {<br/>      return Promise.all(<br/>        cacheNames.map(function(cacheName) {<br/>          if (cacheName != CACHE_NAME) {<br/>            console.log("ServiceWorker: cache " + cacheName + " dihapus");<br/>            return caches.delete(cacheName);<br/>          }<br/>        })<br/>      );<br/>    })<br/>  );<br/>});</span></pre><p id="8d0f" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">在上面的代码中，我们注册了服务工作器激活事件的事件侦听器，该事件将在服务工作器安装过程结束后立即激活服务工作器时调用。我们首先获取所有注册的缓存名称。然后，我们逐一检查缓存名称是否与服务工作者正在使用的缓存名称不同，然后我们在<strong class="lm io"> caches.delete() </strong>方法中调用它以将其删除。</p><p id="742d" class="pw-post-body-paragraph lk ll in lm b ln mo jo lp lq mp jr ls lt mq lv lw lx mr lz ma mb ms md me mf ig bi translated">您可以尝试重新打开应用程序，看到缓存存储浏览器中的缓存现在只剩下正在使用的缓存。</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div></div>    
</body>
</html>