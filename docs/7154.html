<html>
<head>
<title>iOS 9 upgrade: Why did my unit tests grind to a halt?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS 9升级:为什么我的单元测试陷入停顿？</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/ios-9-upgrade-why-did-my-unit-tests-grind-to-a-halt-7460ae8285bb?source=collection_archive---------1-----------------------#2016-04-27">https://medium.com/square-corner-blog/ios-9-upgrade-why-did-my-unit-tests-grind-to-a-halt-7460ae8285bb?source=collection_archive---------1-----------------------#2016-04-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="d5d0" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">关于为什么从iOS 8升级到9 SDK会导致测试变慢的调查。</h2></div><p id="c6c4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">作者</em> <a class="jt ju ge" href="https://medium.com/u/6710389d9d0?source=post_page-----7460ae8285bb--------------------------------" rel="noopener" target="_blank"> <em class="js">艾伦·芬伯格</em> </a> <em class="js">。</em></p><blockquote class="jv"><p id="3300" class="jw jx hh bd jy jz ka kb kc kd ke jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae kf" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="2213" class="pw-post-body-paragraph iw ix hh iy b iz kg ii jb jc kh il je jf ki jh ji jj kj jl jm jn kk jp jq jr ha bi translated"><em class="js">在将Square Register从iOS 8升级到iOS 9时，我们发现我们的单元测试行为发生了难以诊断的变化。我们调查了这个问题，并追溯我们的步骤以找到根本原因。最终，我们发现潜在的问题不仅仅是Square特有的，而是一个可能影响任何iOS开发者的问题。</em></p><h1 id="5463" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">测试现在又慢又不可靠</h1><p id="084b" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">在将近7岁的时候，Square Register for iOS是一个庞大的应用程序，包含超过一百万行代码。虽然从iOS 8或iOS 9迁移基础SDK看起来很简单，但这种变化的规模带来了许多挑战。</p><p id="c99f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些挑战中最主要的是应用程序的测试套件。在实现变更后不久，我们注意到我们的单元测试套件——为每个构建运行了数千个测试——已经明显变慢了，并且最终会失败。这些测试失败在单独运行时从来没有发生过，但是作为一个更大的测试套件的一部分经常失败，并且不总是以相同的方式。因为没有一个测试是错误的，一个合理的解释表明共享测试环境的污染。</p><h1 id="8e02" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">是主队列！</h1><p id="1ef3" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">下一步是缩小我们的干草堆。我们开始注释掉测试以缩小范围。注释掉一个又一个文件变得很乏味——我们加入了一个分类技巧，让生活变得更简单(如下)。不幸的是，没有更好的方法来运行符合iOS命名模式的测试子集:</p><figure class="li lj lk ll fd lm"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="2618" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上面的<em class="js">:一个有用的类别，只运行一组特定的匹配一些字符串模式的测试。</em></p><p id="9c69" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用这种过滤，我们将范围缩小到少数测试类，以便一致地重现失败。然后我们注意到一件奇怪的事情:运行哪些测试本身并不重要；决定结果的是考试的数量。</p><p id="c48f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们看到这组测试需要运行大约三分钟；少一点，他们都会通过。有一项测试会先于所有其他测试失败，这也成为了调查的重点:</p><figure class="li lj lk ll fd lm"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="7830" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上图:我们试图追踪的主要测试失败。注意旋转runloop(等待期望)和锁定的使用。</p><p id="b8ce" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">故障发生在旋转运行回路之后，即预期从未实现。我们正在等待队列中的工作被执行，但是测试将会超时。所以，我们决定查看所有的队列…</p><p id="bd0d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">啊哈！当我们在更大的测试运行中达到问题测试时，主队列已经被过多的操作阻塞了:</p><pre class="li lj lk ll fd lp lq lr ls aw lt bi"><span id="5c43" class="lu km hh lq b fi lv lw l lx ly">(lldb) p (int) [[NSOperationQueue mainQueue] operationCount]<br/>(int) $6 = 2781</span></pre><p id="20f3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们已经找到了罪魁祸首:测试很慢，因为主队列负担过重，我们的第一次测试失败是由于等待一个解锁操作，该操作卡在了这个队列上。</p><p id="95ff" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了证明队列是问题的根源，我们在测试的tearDown方法中添加了对<em class="js">[[nsoperationqueue main queue]cancelAllOperations]</em>的调用；测试现在通过了！</p><p id="3c78" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过一行一行地检查并观察<em class="js">[[NSOpertaionQueue main queue]operation count]</em>中的变化，我们追踪到在设置测试夹具时调用的特定模块。它将为创建的每个测试夹具向主队列添加4个调度操作(每个<em class="js">设置</em>一个)。这些操作会累积，因为它们没有机会从<em class="js">主队列</em>中排出。这就解释了为什么大量的测试显示了这个问题，而少量的测试却没有。</p><p id="e035" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看起来案子已经结了。我们准备对有问题的模块做一些调整，然后“到此为止”,但是这个特殊的“日子”不会这么容易就“结束”,并且这个案例仍然是开放的！</p><h1 id="c065" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">其实不是这样的！</h1><p id="7dff" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">我们已经修复了测试夹具的调度问题，但是发现仍然有一个问题。</p><p id="32da" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们首先尝试通过<a class="ae kf" href="http://nshipster.com/method-swizzling/" rel="noopener ugc nofollow" target="_blank">重组</a> <em class="js"> NSOperationQueue </em>来验证我们的修复，这样它拒绝了添加到主操作队列上的所有其他工作，<em class="js">除了失败测试所做的工作</em>。</p><p id="b0d4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">坏消息:失败仍然发生，但是现在，它需要一个更大的测试套件来重现！即使当主队列只有一个操作要执行时，也会出现故障，令人困惑的是，为什么这个队列——只有一个操作——不会耗尽。很明显，这并不像之前认为的那样，只是队列被“猛”了一下。</p><p id="ef2a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">换句话说，即使主队列如下所示，相同的测试仍然会永远等待主队列上的操作:</p><pre class="li lj lk ll fd lp lq lr ls aw lt bi"><span id="c27b" class="lu km hh lq b fi lv lw l lx ly">(lldb) p (int) [[NSOperationQueue mainQueue] operationCount]<br/>(int) $6 = 1</span></pre><p id="475b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">解锁操作仍然滞留在队列中，即使队列中没有其他东西！</em></p><h1 id="802d" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">退后一步</h1><p id="b545" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">由于我们的测试失败表现为一个死锁(一个从未释放的锁)，我们深入研究同步代码(节选如下)并搜索下一个竞争条件。因为测试是平行进行的，这看起来似乎是合理的，但这是在抓救命稻草。虽然我们经常认为我们正在做一些事情，但是当我们发现一个竞争条件时，我们却两手空空。</p><figure class="li lj lk ll fd lm"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="8756" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">即使涉及到主队列和锁，不管我们多么想找到一个竞争条件，这都不是问题。</p><p id="81cf" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">出于想法，我们开始拆开问题测试，看看有什么浮出水面。我们尽可能地注释掉或替换它，以缩小它的范围，甚至用手工滚动的runloop spinning替换了XCTestExpectation。</p><h1 id="bfdc" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">一次愉快的事故</h1><p id="f3dd" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">我在替换<em class="js">waitforexceptionswithtime out</em>时犯了一个时间单位转换错误，现在测试将会持续1000倍于预期的持续时间。当调试器旋转时，我暂停了它，并注意到一些奇怪的事情。通常情况下，暂停调试器会依靠<em class="js"> processPendingChanges </em>，这是一种<em class="js"> NSManagedObjectContext </em>用来保存CoreData更新的方法。</p><p id="9450" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然在问题测试开始时暂停调试器是我首先尝试(并放弃)的事情之一，但直到此刻我才发现任何有趣的事情(如果我想到使用时间分析器，仪器也可以提供线索)。错过了几次机会，但现在我们有所收获。</p><p id="77bd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">等待时再次出现<em class="js"> processPendingChanges </em>似乎很有趣，但我们需要更多信息来确定这意味着什么。</p><p id="fa24" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了查看有多少个<em class="js"> NSManagedObjectContext </em>正在调用<em class="js"> processPendingChanges </em>，我们使用静态<em class="js"> NSHashTable </em>将实例日志记录添加到我们的<em class="js"> NSManagedObjectContext </em>类中(类似于下面的示例):</p><figure class="li lj lk ll fd lm"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="1c00" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">我们子类化了NSManagedObjectContext，并添加了类似于上面示例的实例跟踪。</em></p><p id="3daa" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用这个实例跟踪，我们发现在测试运行之间有数百个，甚至数千个这样的上下文持续存在。更糟糕的是，它们会在主运行循环上执行工作，这些泄漏的上下文似乎有可能将NSOperationQueues挤出运行循环。</p><p id="2ab9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">换句话说，在运行循环期间，NSManagedObjectContext processPendingChanges调用蜂拥而至，使我们的NSOperationQueue处于饥饿状态。我们的主队列无法耗尽，因为这种排山倒海的调度调用在每个周期都耗尽了runloop的所有可用带宽。</p><h1 id="0488" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">是内存泄露！</h1><p id="9b51" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">好了，NSManagedObjectContext在两次测试运行之间被保留(泄露)。这就归结为找出对象的保留计数在哪里增加了，在哪里减少了，以及为什么前者大于后者。</p><p id="47e4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">幸运的是，Xcode附带了一个名为<em class="js"> Instruments </em>的工具，它有一个泄漏诊断工具。因此，我们只需右键单击测试名称，并选择<em class="js">Profile SQOTAdditionsTest</em>和<em class="js">瞧</em>，仪器就能让一切一目了然。不对！可悲的是，这些都没有发生，从仪器通过这个菜单连接自己开始:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/dfef1ab3b46e6b04fde83a602c9a4967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T2iQFuQnM3psrEWM.png"/></div></div></figure><p id="b349" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">令人沮丧的是，Xcode的这个特性只是启动了一个惰性的仪器实例，而不是附加到一个进程上。</p><p id="7b10" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">相反，为了分析测试运行，我们必须:</p><ul class=""><li id="5444" class="mg mh hh iy b iz ja jc jd jf mi jj mj jn mk jr ml mm mn mo bi translated">在代码中设置一个断点，</li><li id="7d61" class="mg mh hh iy b iz mp jc mq jf mr jj ms jn mt jr ml mm mn mo bi translated">运行测试，</li><li id="8d7a" class="mg mh hh iy b iz mp jc mq jf mr jj ms jn mt jr ml mm mn mo bi translated">发射仪器，</li><li id="904e" class="mg mh hh iy b iz mp jc mq jf mr jj ms jn mt jr ml mm mn mo bi translated">小心地通过进程ID附加到正确的进程(下拉列表中可能有重复)</li><li id="f24a" class="mg mh hh iy b iz mp jc mq jf mr jj ms jn mt jr ml mm mn mo bi translated">创下记录。</li></ul><p id="7aad" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Leaks工具不认为NSManagedObjectContext(下面截图中的SDManagedObjectContext)是泄漏，因为它最终被拆除了。但是它报告了一个保留/释放对列表。因此，我们查看了单个对象的超过6000个保留/释放的列表。当时，我们没有看到罪魁祸首，所以又回到了通过lldb进行调试。</p><p id="80b1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">经过大量的调试并打印出[context retainCount]之后，我们发现上下文的save:方法添加了一个retain，如果我们注释掉这一行，上下文就像预期的那样被清除了。)，漏洞被堵上了。</p><p id="3e77" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我回到Instruments，用这个新信息反复检查它的报告，果然，它在那里:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mu"><img src="../Images/ac45245c4f3243cb2d60a6931c48967a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Orhvu8PTQlSdX3Kx.png"/></div></div></figure><p id="e894" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">罗，一个不成对的保留者。</em></p><p id="ae24" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">导致泄漏的挡板详图:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div class="er es mv"><img src="../Images/af3ec049e2dacc918d12c47d11531cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/0*e5z2NFDshkN9QM-r.png"/></div></figure><p id="c8b7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">仪器详细视图:堆栈跟踪包括save:、CFRetain和_ registerAyncReferenceCallback(sic)</em></p><h1 id="d2fa" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">诊断</h1><p id="dbe6" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">为了进行调试，我重写并为[NSManagedObjectContext(_ NSCoreDataSPI)performWithOptions:and block](基于上面的仪器输出)设置了一个符号断点。我不擅长汇编，但是我可以通过阅读评论来理解:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mu"><img src="../Images/60ea6790f0c06704a684216180890224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T-883kiTz_bmqm5s.png"/></div></div></figure><p id="7d6f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在第91行，我们增加了保留计数。在第132行，我们将异步工作添加到一个队列中。</p><p id="49a8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们推断，当调用save:时，上下文正在将一些工作排队，同时保留自己(单步执行并调用p (int)[$esi retainCount]证实了这一点)。这项工作也减少了保留计数，但是由于它停留在队列中，自保留上下文将永远保留。在使用sqlite3和时，我们也逐步完成了。转储以验证如果排队的工作从未运行，没有数据丢失。</p><p id="3bde" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们认为我们最终理解了正在发生的事情，我们离开去创建一个小的测试项目来隔离我们的怀疑，并确认这个问题存在于一个更简单的例子中。已经确定了！示例项目展示了相同的问题(<a class="ae kf" href="https://github.com/alanf/deadlock" rel="noopener ugc nofollow" target="_blank">试用一下</a>！).</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mu"><img src="../Images/2926b3ccdf076b1f76e4ef68b76211ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YUM6XzSzjcVkTjZx.png"/></div></div></figure><p id="8ed6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">使用符号断点确定Xcode 6 v. 7中的行为差异</em></p><p id="8d49" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们使用这个测试项目比较了iOS 8和iOS 9。很明显:保存:iOS8中没有异步！**</p><p id="cde8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">**让我来限定一下:(据我从汇编中得知<em class="js">)iOS 8 save:在其“标准代码路径”中是同步的，并且没有使用dispatch_async对工作进行排队。从iOS 9开始，它现在是异步的，并立即调用dispatch_async作为其“标准代码路径”的一部分。我鼓励检查一下<a class="ae kf" href="https://github.com/alanf/deadlock" rel="noopener ugc nofollow" target="_blank">示例项目</a>，并在Xcode 6和Xcode 7中进行比较(将masterbranch和xcode-6进行比较)。</em></p><h1 id="896a" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">处理</h1><p id="ebf4" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">不幸的是，让上下文的异步工作脱离主队列的唯一方法是旋转runloop。如果不管，操作将在后台建立，当runloop最终运行时，上下文将使操作队列饥饿。</p><p id="050d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，我们的解决方案是添加如下所示的代码来拆卸:</p><pre class="li lj lk ll fd lp lq lr ls aw lt bi"><span id="0b66" class="lu km hh lq b fi lv lw l lx ly">[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate dateWithTimeIntervalSinceNow:0.001]];</span></pre><p id="7c6a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在此之后，一些上下文仍然会泄漏，但这些是来自没有完全拆除的服务的合法内存泄漏。</p><p id="5e96" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">确保我们所有的t都是点状的，我将条件断点添加到上下文的dealloc断点，并让它在有超过24个实例时发出声音并暂停:</p><figure class="li lj lk ll fd lm er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mu"><img src="../Images/dce7f491e5c17626abf2447b601c28b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YJwHmEKRo4FeavBm.png"/></div></div></figure><p id="4311" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">播放声音和使用条件意味着我们可以让测试运行，并在太多实例堆积时得到警告。</em></p><p id="0ee4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">尽管完成整个测试套件需要一段时间，但是由于我们的实例跟踪，这是一个机械的过程来跟踪剩余的漏洞并验证没有任何漏洞存在。</p><h1 id="af48" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">成功！</h1><p id="40c1" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">在跟踪剩余的漏洞并在拆卸时添加一些runloop旋转之后，runloop变得清晰，测试速度提高了28%。尽管调试花费了相当多的时间，但希望这种时间损失在未来通过更短、更稳定的测试运行得到补偿——更不用说我们从中获得了一篇博客帖子。</p><p id="20c5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">感谢</em> <a class="ae kf" href="https://twitter.com/kyleve" rel="noopener ugc nofollow" target="_blank"> <em class="js">凯尔·范·埃森</em></a><em class="js"/><a class="ae kf" href="https://twitter.com/theprofessor22" rel="noopener ugc nofollow" target="_blank"><em class="js">埃里克·穆勒</em></a><em class="js"/><a class="ae kf" href="https://github.com/justinseanmartin" rel="noopener ugc nofollow" target="_blank"><em class="js">贾斯汀·马丁</em> </a> <em class="js">对他们的援助！</em></p></div><div class="ab cl mw mx go my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ha hb hc hd he"><div class="li lj lk ll fd nd"><a rel="noopener follow" target="_blank" href="/@dunbar151"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hi fi z dy ni ea eb nj ed ef hg bi translated">艾伦·芬伯格-简介</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">债务:最初的5000年给我留下了深刻的印象，所以我急切地阅读了大卫·格雷伯的《规则的乌托邦》。它…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">medium.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr me nd"/></div></div></a></div></div></div>    
</body>
</html>