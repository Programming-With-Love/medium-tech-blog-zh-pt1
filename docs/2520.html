<html>
<head>
<title>Unit Test (SQL) in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中的单元测试(SQL)</h1>
<blockquote>原文：<a href="https://medium.easyread.co/unit-test-sql-in-golang-5af19075e68e?source=collection_archive---------0-----------------------#2020-06-19">https://medium.easyread.co/unit-test-sql-in-golang-5af19075e68e?source=collection_archive---------0-----------------------#2020-06-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/eb0497b6bee0a9742b1748896fe4445b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QmIL6exhRn1H36_p-yFOAg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://pixabay.com/photos/macbook-mac-apple-ipad-iphone-577758/" rel="noopener ugc nofollow" target="_blank">pixabay.com</a></figcaption></figure><p id="11ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">大家好！和我一起，一次又一次地，分享一些关于软件工程领域技术相关的经验、想法或观点。如果昨天我分享了关于单元测试模仿Redis(你可以通过下面的链接访问)，今天我想分享如何在SQL代码中模仿。</p><div class="ky kz gp gr la lb"><a href="https://medium.com/easyread/unit-test-redis-in-golang-c22b5589ea37" rel="noopener follow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">Golang的单元测试(Redis)</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">如何在Golang中模拟Redis进行单元测试</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">medium.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp jt lb"/></div></div></a></div><p id="4e4f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在Golang中模仿sql代码非常容易，因为我们可以使用DATA-DOG中流行的SQL模仿库。详情请访问下面的存储库链接。</p><div class="ky kz gp gr la lb"><a href="https://github.com/DATA-DOG/go-sqlmock" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">数据狗/go-sqlmock</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">sqlmock是一个实现sql/driver的模拟库。它只有一个目的——模拟任何sql驱动程序的行为…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">github.com</p></div></div><div class="lk l"><div class="lq l lm ln lo lk lp jt lb"/></div></div></a></div><p id="3259" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实际上，这个单元测试的材料将与我在这个中型故事中使用的相同，只是在迁移部分有一点不同。</p><div class="ky kz gp gr la lb"><a href="https://medium.com/easyread/integration-test-database-in-golang-using-dockertest-59ed3b35240e" rel="noopener follow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">使用Dockertest在Golang中进行集成测试(数据库)</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">用Dockertest进行Golang集成测试的另一种方法</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">medium.com</p></div></div><div class="lk l"><div class="lr l lm ln lo lk lp jt lb"/></div></div></a></div><p id="fcab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，像这样创建项目结构:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="dd62" class="mb mc in lx b gy md me l mf mg"><em class="mh">+ your_gopath/<br/>|<br/>+--+ src/github.com/moemoe89<br/>|  |<br/>|  +--+ go-unit-test-sql/<br/>|     |<br/>|     +--+ main.go<br/>|        + repository/<br/>|        |<br/>|        +--+ repository.go<br/>|        |<br/>|        +--+ mysql<br/>|        |  |<br/>|        |  +--+ mysql.go<br/>|        |     + mysql_test.go<br/>|        |<br/>|        +--+ postgres<br/>|           |<br/>|           +--+ postgres.go<br/>|              + postgres_test.go<br/>|<br/>+--+ bin/<br/>|  |<br/>|  +-- ... executable file<br/>|<br/>+--+ pkg/<br/>   |<br/>   +-- ... all dependency_library required</em></span></pre><p id="ac73" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为MySQL和PosgteSQL有相似的代码，我们将只关注MySQL部分。然后我们需要制作3个文件:<code class="fe mi mj mk lx b"><strong class="kc io">repository</strong></code>目录下的<code class="fe mi mj mk lx b"><strong class="kc io">repository.go</strong></code>和<code class="fe mi mj mk lx b"><strong class="kc io">repository/mysql</strong></code>目录下的<code class="fe mi mj mk lx b"><strong class="kc io">mysql.go</strong></code>和<code class="fe mi mj mk lx b"><strong class="kc io">mysql_test.go</strong></code>。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="59d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mi mj mk lx b"><strong class="kc io">repository.go</strong></code>只包含数据模型的实现和结构的接口。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="5dd1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，<code class="fe mi mj mk lx b"><strong class="kc io">mysql.go</strong></code>将有CRUD函数的<code class="fe mi mj mk lx b"><strong class="kc io">repository</strong></code>接口的实现。如果您已经熟悉了干净架构的概念和依赖注入，那么代码对您来说就很容易了。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8a8f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，测试文件<code class="fe mi mj mk lx b"><strong class="kc io">mysql_test.go</strong></code>将使用模拟数据测试存储库代码。我将对这一部分进行更多的解释，因为我们将在这个实现中使用模拟代码。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="591f" class="mb mc in lx b gy md me l mf mg"><strong class="lx io">func </strong>NewMock() (*sql.DB, sqlmock.Sqlmock) {<br/>   db, mock, err := sqlmock.New()<br/>   <strong class="lx io">if </strong>err != nil {<br/>      log.Fatalf(<strong class="lx io">"an error '%s' was not expected when opening a stub database connection"</strong>, err)<br/>   }<br/><br/>   <strong class="lx io">return </strong>db, mock<br/>}</span></pre><p id="e94b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">NewMock函数将生成假sql。数据库服务器(记得我们使用sql。DB作为实际代码的连接)和Sqlmock接口。每个测试用例都需要这个，因为每个实现都需要刷新模拟。然后，让我们分解测试代码，我将用例子解释1 read ( <strong class="kc io"> FindByID </strong>)和1 write ( <strong class="kc io"> Create </strong>)测试部分。因为<strong class="kc io"> FindByID </strong>和<strong class="kc io"> Find </strong>相似，所以<strong class="kc io">创建</strong>，<strong class="kc io">更新</strong>和<strong class="kc io">删除</strong>。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="5c77" class="mb mc in lx b gy md me l mf mg"><strong class="lx io">func </strong>TestFindByID(t *testing.T) {<br/>   db, mock := NewMock()<br/>   repo := &amp;repository{db}<br/>   <strong class="lx io">defer func</strong>() {<br/>      repo.Close()<br/>   }()<br/><br/>   query := <strong class="lx io">"SELECT id, name, email, phone FROM users WHERE id = \\?"<br/><br/>   </strong>rows := sqlmock.NewRows([]string{<strong class="lx io">"id"</strong>, <strong class="lx io">"name"</strong>, <strong class="lx io">"email"</strong>, <strong class="lx io">"phone"</strong>}).<br/>      AddRow(u.ID, u.Name, u.Email, u.Phone)<br/><br/>   mock.ExpectQuery(query).WithArgs(u.ID).WillReturnRows(rows)<br/><br/>   user, err := repo.FindByID(u.ID)<br/>   assert.NotNil(t, user)<br/>   assert.NoError(t, err)<br/>}</span></pre><p id="2995" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上面的代码，我们做了一些部分，如:</p><ul class=""><li id="7282" class="mn mo in kc b kd ke kh ki kl mp kp mq kt mr kx ms mt mu mv bi translated">调用模拟函数<code class="fe mi mj mk lx b">NewMock()</code></li><li id="5d86" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">启动我们的回购<code class="fe mi mj mk lx b">repo := &amp;repository{db}</code></li><li id="1632" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">准备模拟查询<code class="fe mi mj mk lx b">SELECT id ....</code>，请注意像<code class="fe mi mj mk lx b">?</code>这样的特殊字符，我们应该用双反斜杠<code class="fe mi mj mk lx b">\\</code>对其进行转义</li><li id="0e37" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">准备模拟结果数据<code class="fe mi mj mk lx b">rows := sqlmock.NewRows( ... AddRow( ...</code></li><li id="21f1" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">模拟查询、参数和结果<code class="fe mi mj mk lx b">mock.ExpectQuery(query).WithArgs(u.ID).WillReturnRows(rows)</code></li></ul><p id="67c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很好，下一步我们将运行我们的<strong class="kc io"> FindByID </strong>，结果应该不会出错。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="bc14" class="mb mc in lx b gy md me l mf mg"><strong class="lx io">func </strong>TestCreate(t *testing.T) {<br/>   db, mock := NewMock()<br/>   repo := &amp;repository{db}<br/>   <strong class="lx io">defer func</strong>() {<br/>      repo.Close()<br/>   }()<br/><br/>   query := <strong class="lx io">"INSERT INTO users \\(id, name, email, phone\\) VALUES \\(\\?, \\?, \\?, \\?\\)"<br/><br/>   </strong>prep := mock.ExpectPrepare(query)<br/>   prep.ExpectExec().WithArgs(u.ID, u.Name, u.Email, u.Phone).WillReturnResult(sqlmock.NewResult(0, 1))<br/><br/>   err := repo.Create(u)<br/>   assert.NoError(t, err)<br/>}</span></pre><p id="0b75" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于创建测试代码，由于代码的执行使用了prepare query，我们应该在测试代码中也遵循。</p><ul class=""><li id="52d3" class="mn mo in kc b kd ke kh ki kl mp kp mq kt mr kx ms mt mu mv bi translated">准备查询<code class="fe mi mj mk lx b">prep := mock.ExpectPrepare(query)</code></li><li id="1344" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">模拟查询、参数和结果<code class="fe mi mj mk lx b">prep.ExpectExect().WithArgs(u.ID ...).WillReturnResult(...)</code></li><li id="2ccc" class="mn mo in kc b kd mw kh mx kl my kp mz kt na kx ms mt mu mv bi translated">因为我们用UUID作为主键。对于lastInsertID参数，NewResult将设置为0，对于rowsAffected，new result将设置为1</li></ul><p id="d9be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">酷，下一步我们将运行我们的<strong class="kc io">创建</strong>，结果应该不会出错。</p><p id="ddd6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧！是时候进行测试了。使用<code class="fe mi mj mk lx b"><strong class="kc io">go test ./...</strong></code>执行测试用例。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/812eee7a3d96f447272bcc8a498d0e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f3G0AQIMEEML7RMxDKTgLg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Picture Unit Test Passed</figcaption></figure><p id="7086" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是啊…很好，我们通过了测试！！</p><p id="f082" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用CircleCI等CI服务在我们的云存储库上运行测试。在我的存储库中，您可以看到我正在使用CircleCI来执行测试！</p><p id="b798" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是<code class="fe mi mj mk lx b"><strong class="kc io">.cirlceci</strong></code>目录中的示例<code class="fe mi mj mk lx b"><strong class="kc io">config.yml</strong></code>文件。</p><figure class="ls lt lu lv gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="7fd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您想查看这个测试的完整示例项目，您可以访问我在GitHub上的这个项目的存储库，<a class="ae jz" href="https://github.com/moemoe89/go-unit-test-sql" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">moe moe 89/go-unit-test-SQL</strong>。</a></p><div class="ky kz gp gr la lb"><a href="https://github.com/moemoe89/go-unit-test-sql" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">moemoe89/go-unit-test-sql</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">通过在GitHub上创建帐户，为moemoe89/go-unit-test-sql开发做出贡献。</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">github.com</p></div></div><div class="lk l"><div class="nc l lm ln lo lk lp jt lb"/></div></div></a></div><p id="decb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望你喜欢它，我很高兴如果这篇文章对你有用！测试愉快！</p><p id="942d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢大家！</p></div></div>    
</body>
</html>