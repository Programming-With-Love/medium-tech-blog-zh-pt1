<html>
<head>
<title>Midway: Simplifying Mocked Responses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中途:简化被嘲笑的回答</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/midway-simplifying-mocked-responses-da5601fc667d?source=collection_archive---------4-----------------------#2018-12-06">https://medium.com/walmartglobaltech/midway-simplifying-mocked-responses-da5601fc667d?source=collection_archive---------4-----------------------#2018-12-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/65fd544c128eee31983f3c8670420ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ruqIE4tOxCwZUqJVKEhRA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="http://i2.wp.com/www.datadependence.com/wp-content/uploads/2016/03/MOCKS-1.jpg" rel="noopener ugc nofollow" target="_blank">http://i2.wp.com/www.datadependence.com/wp-content/uploads/2016/03/MOCKS-1.jpg</a></figcaption></figure><blockquote class="iu iv iw"><p id="0518" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">这篇博客内容假设你对<a class="ae it" href="http://testarmada.io" rel="noopener ugc nofollow" target="_blank">测试舰队的</a>开源嘲讽舰队<a class="ae it" href="https://www.npmjs.com/package/testarmada-midway" rel="noopener ugc nofollow" target="_blank">中途</a>有基本的了解，并且经历过<a class="ae it" href="http://testarmada.io/documentation/Mocking/rWeb/JAVASCRIPT/Training%20Guide/" rel="noopener ugc nofollow" target="_blank">中途的训练</a> 101和201。</p></blockquote><p id="b02f" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">通过移除所有下划线依赖性来孤立地测试和调试应用程序是非常强大的——这导致了模拟的使用。尽管模拟非常强大，但它同时也非常复杂和费力，尤其是在处理可能需要模拟数十个外部服务的测试用例或场景时，并且可能导致测试:</p><ul class=""><li id="902f" class="jz ka hh ja b jb jc jf jg jw kb jx kc jy kd jv ke kf kg kh bi translated">更难理解</li><li id="4c6c" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv ke kf kg kh bi translated">更难维护</li></ul><blockquote class="iu iv iw"><p id="0116" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">当以不同的数据预期多次调用多个Rest APIs时，Mocks的复杂性会增加。</p></blockquote><p id="94c0" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">如果我告诉你，使用Midway的<strong class="ja hi"><em class="iz">Mock from Container</em></strong>特性，在为复杂场景创建Mock时，你可以告别大部分的复杂性，会怎么样？如果这让你兴奋，继续读下去…</p><p id="8289" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">当使用内联测试用例模拟或者通过使用模拟服务器来创建模拟时；复杂测试用例的最大挑战是设置模拟<em class="iz">(基于被模拟的API被调用的次数，每次都返回单独的数据集)</em>并在以后维护它们，特别是如果被测试的特性不断发展的话。Midway的<strong class="ja hi"><em class="iz">Mock from Container</em></strong>特性使得在使用Midway-Server进行模仿时，所有被模仿的响应都能够从特定的数据容器中返回，并且与测试用例实现完全分离，这使得维护它们变得轻而易举。</p><h1 id="56ec" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">它是如何工作的？</h1><p id="d33e" class="pw-post-body-paragraph ix iy hh ja b jb ll jd je jf lm jh ji jw ln jl jm jx lo jp jq jy lp jt ju jv ha bi translated"><strong class="ja hi">场景:</strong>假设您的测试用例或场景需要模拟两个GET Rest API<code class="du lq lr ls lt b">/api/message</code>和<code class="du lq lr ls lt b">/api/product/getStatus</code>，两个端点都被调用了三次。对于第一个端点，您总是希望使用HTTP代码200返回相同的数据(在JSON中),而对于第二个端点，您希望使用HTTP代码200为第一次和第三次调用返回相同的数据(在html中),并使用HTTP代码201为第二次调用返回不同的数据(在JSON中)。</p><p id="e50a" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="ja hi">实现:</strong>在你的测试目录<em class="iz">的<code class="du lq lr ls lt b"><em class="iz">mocked-data</em></code>文件夹下创建一个文件夹(这个文件夹的名字可以在你启动</em>中途服务器<em class="iz">时通过传递</em> <code class="du lq lr ls lt b"><em class="iz">mockedDirectory</em></code> <em class="iz">选项来配置)</em>的名字<code class="du lq lr ls lt b"><em class="iz">test1</em></code>。在这个文件夹下，为您的模拟响应添加以下文件。</p><ol class=""><li id="f129" class="jz ka hh ja b jb jc jf jg jw kb jx kc jy kd jv lu kf kg kh bi translated"><code class="du lq lr ls lt b"><em class="iz">api-message-GET.json</em></code> -这将为第一个端点的所有调用返回默认HTTP响应代码200</li><li id="a9d7" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv lu kf kg kh bi translated"><code class="du lq lr ls lt b"><em class="iz">api-product-getStatus-GET.html</em></code> -这将为第二个端点的所有调用返回默认的HTTP响应代码200，除了第二个端点，因为它有自己的文件</li><li id="f5ad" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv lu kf kg kh bi translated"><code class="du lq lr ls lt b"><em class="iz">api-product-getStatus-GET-2-code-201.json</em></code> -这将为第二个端点的第二次调用返回响应代码201。</li></ol><p id="5c0e" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">通过Midway对象、Midway-UI或REST API——可以调用<em class="iz"> SetMockId </em> API来设置值:</p><pre class="lv lw lx ly fd lz lt ma mb aw mc bi"><span id="5173" class="md ko hh lt b fi me mf l mg mh">midway.setMockId(“test1”);</span><span id="0ddb" class="md ko hh lt b fi mi mf l mg mh">or </span><span id="9dc7" class="md ko hh lt b fi mi mf l mg mh">curl http://localhost:8000/_admin/api/midway/setMockId/test1</span></pre><p id="eadb" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="ja hi">解释:</strong>underline Midway mock服务会自动计算出文件扩展名，因此您不必指定它。如果同一文件具有多个文件扩展名，则使用以下顺序:</p><ul class=""><li id="2919" class="jz ka hh ja b jb jc jf jg jw kb jx kc jy kd jv ke kf kg kh bi translated">JSON</li><li id="28bc" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv ke kf kg kh bi translated">超文本标记语言</li><li id="013c" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv ke kf kg kh bi translated">文本文件（textfile）</li><li id="e377" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv ke kf kg kh bi translated">遇到任何其他扩展名的第一个文件。</li></ul><p id="9608" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="ja hi">带有模拟响应数据的文件名</strong>是基于被模拟的Rest API创建的，例如Rest API <code class="du lq lr ls lt b"><em class="iz">/api/message</em></code>的文件名是<code class="du lq lr ls lt b"><em class="iz">api-message-GET.json</em></code>。方法名用于区分不同的Rest方法，因为同一个Rest API路径可以支持两种不同的REST方法。如果在上面的例子中，我想为第一个请求返回一个不同的响应，那么我会添加另一个名为<code class="du lq lr ls lt b"><em class="iz">api-message-GET-1.json</em></code>的文件。然后，对于第一次调用，将使用<code class="du lq lr ls lt b"><em class="iz">api-message-GET-1.json</em></code>，对于所有其他调用，将使用默认文件<code class="du lq lr ls lt b"><em class="iz">api-message-GET.json</em></code>。对于POST调用，文件名将简单地更改为<code class="du lq lr ls lt b"><em class="iz">api-message-POST.json</em></code>。</p><blockquote class="iu iv iw"><p id="d627" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">小费！一旦调用了<code class="du lq lr ls lt b">midway.setMockId(“test1”)</code> API，Midway只在<code class="du lq lr ls lt b">test1</code>文件夹下寻找响应。如果没有找到响应，它将返回带有没有找到的文件名的<code class="du lq lr ls lt b">404</code>。在调用<code class="du lq lr ls lt b">midway.setMockId(“test1”)</code> API后，Midway在内部跟踪每个单独端点被调用的次数，并首先查找具有count特定名称的文件，如<code class="du lq lr ls lt b">api-message-GET-1.json</code>，如果没有找到所述文件，则查找默认文件<code class="du lq lr ls lt b">api-message-GET.json</code>。</p></blockquote><h2 id="282e" class="md ko hh bd kp mj mk ml kt mm mn mo kx jw mp mq lb jx mr ms lf jy mt mu lj mv bi translated"><strong class="ak">很高兴知道</strong></h2><p id="e012" class="pw-post-body-paragraph ix iy hh ja b jb ll jd je jf lm jh ji jw ln jl jm jx lo jp jq jy lp jt ju jv ha bi translated">如果设置了<em class="iz"> SetMockId </em>，则自定义文件路径</p><pre class="lv lw lx ly fd lz lt ma mb aw mc bi"><span id="d8ca" class="md ko hh lt b fi me mf l mg mh"> <!-- -->midway.util.respondWithFile(this, reply,{filePath:‘./default.json’}<br/>);<!-- --> </span></pre><p id="c031" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">和基于URL路径的文件<code class="du lq lr ls lt b"><em class="iz">../mocked-data/api/message/get/default.json</em></code>被忽略。以下是文件查找遵循的顺序:</p><ul class=""><li id="046b" class="jz ka hh ja b jb jc jf jg jw kb jx kc jy kd jv ke kf kg kh bi translated">SetMockId</li><li id="8673" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv ke kf kg kh bi translated">默认或变体端点的自定义文件路径。</li><li id="5526" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv ke kf kg kh bi translated">基于默认或变体端点的URL路径的文件。</li></ul><h2 id="f76f" class="md ko hh bd kp mj mk ml kt mm mn mo kx jw mp mq lb jx mr ms lf jy mt mu lj mv bi translated"><strong class="ak">其他公用事业</strong></h2><p id="08b7" class="pw-post-body-paragraph ix iy hh ja b jb ll jd je jf lm jh ji jw ln jl jm jx lo jp jq jy lp jt ju jv ha bi translated">设置完<em class="iz"> SetMockId </em>后，您可能需要重置URL计数或重置模拟Id，以返回到自定义文件路径或基于URL或变量的文件路径。为此，您可以使用UI、Rest APIs或Midway命令:</p><ul class=""><li id="a272" class="jz ka hh ja b jb jc jf jg jw kb jx kc jy kd jv ke kf kg kh bi translated"><strong class="ja hi"> ResetCount </strong> —将URL调用计数重置为零，并且不影响当前模拟id。此后，Midway将从零开始计算端点呼叫计数。</li></ul><pre class="lv lw lx ly fd lz lt ma mb aw mc bi"><span id="ace8" class="md ko hh lt b fi me mf l mg mh">midway.resetCount();</span><span id="ce99" class="md ko hh lt b fi mi mf l mg mh">or </span><span id="9555" class="md ko hh lt b fi mi mf l mg mh">curl http://localhost:8000/_admin/api/midway/resetURLCount</span></pre><ul class=""><li id="7cd1" class="jz ka hh ja b jb jc jf jg jw kb jx kc jy kd jv ke kf kg kh bi translated"><strong class="ja hi"> ResetMockId </strong> —这将删除当前的<em class="iz"> SetMockId </em>并将URL计数设置为零</li></ul><pre class="lv lw lx ly fd lz lt ma mb aw mc bi"><span id="91b6" class="md ko hh lt b fi me mf l mg mh">midway.<!-- -->resetMockId<!-- -->();</span><span id="5029" class="md ko hh lt b fi mi mf l mg mh">or</span><span id="2973" class="md ko hh lt b fi mi mf l mg mh">curl http://localhost:8000/_admin/api/midway/resetMockId</span></pre><ul class=""><li id="f3f9" class="jz ka hh ja b jb jc jf jg jw kb jx kc jy kd jv ke kf kg kh bi translated"><strong class="ja hi"> GetMockId </strong> —获取中途服务器的当前mock-id集</li></ul><pre class="lv lw lx ly fd lz lt ma mb aw mc bi"><span id="7b32" class="md ko hh lt b fi me mf l mg mh">midway.getMockId();</span><span id="2651" class="md ko hh lt b fi mi mf l mg mh">or</span><span id="36fb" class="md ko hh lt b fi mi mf l mg mh">curl http://localhost:8000/_admin/api/midway/getMockId</span></pre><ul class=""><li id="4807" class="jz ka hh ja b jb jc jf jg jw kb jx kc jy kd jv ke kf kg kh bi translated"><strong class="ja hi"> GetURLCount </strong> —获取所有被中途服务器模拟的Rest APIs的URL计数</li></ul><pre class="lv lw lx ly fd lz lt ma mb aw mc bi"><span id="59cb" class="md ko hh lt b fi me mf l mg mh">midway.getURLCount();</span><span id="5bb9" class="md ko hh lt b fi mi mf l mg mh">or </span><span id="1ae7" class="md ko hh lt b fi mi mf l mg mh">curl http://localhost:8000/_admin/api/midway/getURLCount</span></pre><h2 id="5d43" class="md ko hh bd kp mj mk ml kt mm mn mo kx jw mp mq lb jx mr ms lf jy mt mu lj mv bi translated"><strong class="ak"> <em class="mw">模仿来自容器方法的优点:</em> </strong></h2><p id="978f" class="pw-post-body-paragraph ix iy hh ja b jb ll jd je jf lm jh ji jw ln jl jm jx lo jp jq jy lp jt ju jv ha bi translated">当您想要为一个特定的测试存根化所有的端点，而不需要手动为这些端点编写路径时，这个特性是非常方便的。通常适用于一个流需要多次调用一个或多个端点，且预期数据结果不同的场景。</p><ul class=""><li id="c25c" class="jz ka hh ja b jb jc jf jg jw kb jx kc jy kd jv ke kf kg kh bi translated"><strong class="ja hi">Stub Multiple Rest API</strong>—根据Rest API路径，根据您的场景需要，在模拟文件夹中放置尽可能多的文件。</li><li id="ed94" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv ke kf kg kh bi translated"><strong class="ja hi">多次调用模拟Rest API&amp;不同的数据预期</strong> —将调用计数添加到文件名中，该文件将根据API被调用的时间返回。</li><li id="a9d2" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv ke kf kg kh bi translated"><strong class="ja hi">降低测试复杂性</strong> —测试与设置模拟响应分离，从而使测试易于阅读。</li><li id="b9a9" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv ke kf kg kh bi translated"><strong class="ja hi">无变体</strong> —对于同一个API的多次调用，可以为不同的数据集添加一个新文件，这样就不需要创建任何变体。</li><li id="d04d" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv ke kf kg kh bi translated"><strong class="ja hi">易维护</strong> —如果发生任何变化，只需更改文件内容或名称。</li><li id="a983" class="jz ka hh ja b jb ki jf kj jw kk jx kl jy km jv ke kf kg kh bi translated"><strong class="ja hi">开发者天堂</strong> —让开发一个特性变得超级简单，因为如果模仿行为需要改变，不需要修改任何代码。</li></ul><p id="ae65" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="ja hi"> <em class="iz">敬请关注未来的博客，深入了解架构和特性。与此同时，请随意浏览中途的</em> </strong> <a class="ae it" href="http://testarmada.io/documentation/Mocking/rWeb/JAVASCRIPT/Introduction" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hi"> <em class="iz">文档</em> </strong> </a> <strong class="ja hi"> <em class="iz">或者尝试从</em> </strong> <a class="ae it" href="https://www.npmjs.com/package/testarmada-midway" rel="noopener ugc nofollow" target="_blank"> <strong class="ja hi"> <em class="iz">这里</em> </strong> </a> <strong class="ja hi"> <em class="iz">下载。</em>T29】</strong></p><p id="8d2d" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><em class="iz">相关博客</em> : <a class="ae it" rel="noopener" href="/walmartlabs/midway-walmarts-mocking-journey-84c34fcc4593">中途:沃尔玛的嘲讽之旅……</a></p></div></div>    
</body>
</html>