<html>
<head>
<title>Java Concurrency in a Nutshell : Types of Thread Pools (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java并发性概述:线程池的类型(第3部分)</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/java-concurrency-in-a-nutshell-types-of-thread-pools-part-3-ef95510b7ce8?source=collection_archive---------2-----------------------#2018-09-21">https://medium.com/quick-code/java-concurrency-in-a-nutshell-types-of-thread-pools-part-3-ef95510b7ce8?source=collection_archive---------2-----------------------#2018-09-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="d934" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="97b9" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi ka translated">在之前的文章中，我们讨论了线程池的基础知识。我们已经提供了<strong class="je hi">执行器服务、可调用、未来和线程池执行器</strong>的概述。在本文中，我们将研究Java提供的不同类型的内置和常用线程池。</p><figure class="kk kl km kn fd ko er es paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="er es kj"><img src="../Images/79edd1c9c923543ca47493955e25aa42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIk_C7AngyMPozIaUkB3ig.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">Photo by <a class="ae kz" href="https://unsplash.com/photos/Vwf8q3RzBRE?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Tim Johnson</a> on <a class="ae kz" href="https://unsplash.com/search/photos/fixed-no-of-items?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="73f8" class="la if hh bd ig lb lc ld ik le lf lg io jn lh li is jr lj lk iw jv ll lm ja ln bi translated">固定线程池</h2><p id="6abc" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这是一个通用线程池，其中线程池使用用户提供的线程数(nThreads)进行初始化。在任何时间点，这个线程池都包含n个线程。它在内部管理一个<strong class="je hi"> LinkedBlockingQueue </strong>，当池中的所有线程都忙并且新任务不能立即处理时，它将额外的任务流入排队。</p><p id="b1e5" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">通过调用<strong class="je hi"> Executors </strong>类的<strong class="je hi"> newFixedThreadPool() </strong>可以创建一个固定线程池。在下面的代码片段中，创建了一个包含10个线程的线程池。</p><pre class="kk kl km kn fd lt lu lv lw aw lx bi"><span id="71ae" class="la if hh lu b fi ly lz l ma mb">ExecutorService executorService = Executors.newFixedThreadPool(10);</span></pre><p id="f21a" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">一旦线程池被创建，任何数量的<strong class="je hi">可运行的</strong>或<strong class="je hi">可调用的</strong>任务都可以提交给它进行处理。</p><pre class="kk kl km kn fd lt lu lv lw aw lx bi"><span id="abb1" class="la if hh lu b fi ly lz l ma mb">executorService.submit(() -&gt; {<br/>    System.out.println("Hello world");<br/>});</span></pre><p id="cde4" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">所有任务完成后，池仍将处于活动状态，直到被显式关闭。Java提供了两种关闭方法来关闭池。</p><p id="4a69" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">对池调用<strong class="je hi"> shutdown </strong>()将阻止池接受新任务，但允许当前运行的任务完成。调用<strong class="je hi"> shutdownow() </strong>会阻止接受新任务，并试图取消当前正在运行的任务。</p><p id="bda5" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">下面的代码片段描述了固定线程池的用法:</p><figure class="kk kl km kn fd ko"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="e603" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">Java提供了两个实现来创建一个固定的线程池。我们已经看到了默认的线程池，用户只需要提供创建线程池所需的线程数量。在这个实现中，Java用它的内部线程工厂创建线程。</p><p id="e1da" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">在另一个实现中，Java为用户提供了自定义<strong class="je hi"> ThreadFactory </strong>实现来定制线程创建。当用户想要定制线程创建的某些方面时，这个版本是有用的。例如，用户想要改变线程组、线程池命名模式、线程优先级等等。</p><p id="2006" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">以下示例显示了自定义应用程序线程和自定义应用程序线程工厂的实现:</p><figure class="kk kl km kn fd ko"><div class="bz dy l di"><div class="mc md l"/></div><figcaption class="kv kw et er es kx ky bd b be z dx">Custom Application Thread</figcaption></figure><p id="5ebc" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">以下代码片段描述了自定义线程工厂的创建:</p><figure class="kk kl km kn fd ko"><div class="bz dy l di"><div class="mc md l"/></div><figcaption class="kv kw et er es kx ky bd b be z dx">Custom Thread Factory</figcaption></figure><p id="7808" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">以下示例显示了固定线程与自定义线程工厂实现的用法:</p><figure class="kk kl km kn fd ko"><div class="bz dy l di"><div class="mc md l"/></div><figcaption class="kv kw et er es kx ky bd b be z dx">Fixed thread pool with custom thread factory</figcaption></figure></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><h2 id="81fb" class="la if hh bd ig lb lc ld ik le lf lg io jn lh li is jr lj lk iw jv ll lm ja ln bi translated">缓存线程池</h2><p id="5810" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">缓存线程池是Java提供的线程池的另一种变体，用于一般用途。当提交进行处理的任务不应该等待并且需要在提交后立即处理时，缓存线程池非常有用。为了满足这个需求，如果池中没有线程来处理任务，Java会为提交的任务创建一个新线程。一个缓存线程池最多可以有2个线程。实际上，这个池是用于短期异步任务的。</p><p id="2dca" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">如果池中没有活动线程，缓存线程池使用一个<strong class="je hi"> SynchronousQueue </strong>来缓冲任务。一旦提交了新任务，就会产生一个新线程，并使用提交的任务进行处理。在SynchronousQueue中，每个插入操作都必须等待另一个线程的相应移除操作，反之亦然。同步队列没有任何内部容量，甚至没有一个容量。这意味着一旦任务被提交，线程就需要消耗该任务。缓存线程池中的线程在终止之前可以空闲60秒。</p><p id="f62e" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">通过调用<strong class="je hi"> Executors </strong>类的<strong class="je hi"> newCachedThreadPool() </strong>创建一个缓存线程池。</p><pre class="kk kl km kn fd lt lu lv lw aw lx bi"><span id="6a89" class="la if hh lu b fi ly lz l ma mb">ExecutorService executorService = Executors.newCachedThreadPool();</span></pre><p id="3ac0" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">我们还可以提供自定义线程工厂类来覆盖Java默认线程工厂，并提供我们自己的实现:</p><pre class="kk kl km kn fd lt lu lv lw aw lx bi"><span id="1339" class="la if hh lu b fi ly lz l ma mb">ExecutorService executorService = Executors.newCachedThreadPool(new AppThreadFactory(CUSTOM_CACHED_POOL));</span></pre><p id="d24c" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">以下示例显示了默认和自定义线程工厂实现的线程池的用法:</p><figure class="kk kl km kn fd ko"><div class="bz dy l di"><div class="mc md l"/></div><figcaption class="kv kw et er es kx ky bd b be z dx">Cached thread pool example</figcaption></figure><p id="0665" class="pw-post-body-paragraph jc jd hh je b jf lo jh ji jj lp jl jm jn lq jp jq jr lr jt ju jv ls jx jy jz ha bi translated">具有自定义线程工厂的缓存线程池:</p><figure class="kk kl km kn fd ko"><div class="bz dy l di"><div class="mc md l"/></div><figcaption class="kv kw et er es kx ky bd b be z dx">Cached thread pool with custom thread factory</figcaption></figure></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><h2 id="e21e" class="la if hh bd ig lb lc ld ik le lf lg io jn lh li is jr lj lk iw jv ll lm ja ln bi translated">单线线程池</h2><p id="57a9" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">通常，它需要启动并运行一个线程来处理提交的任务。这可以通过使用固定线程池执行器，将池中的线程数设置为1来完成。然而，Java已经为此提供了一个内置的线程池。在Singlethreadpool中，池最多可以有一个线程，所有提交的作业按提交顺序执行。</p></div></div>    
</body>
</html>