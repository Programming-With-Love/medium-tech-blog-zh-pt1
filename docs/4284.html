<html>
<head>
<title>Exploring Dynamic Feature Navigation on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Android上的动态功能导航</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/exploring-dynamic-feature-navigation-on-android-c803bdbbca9b?source=collection_archive---------0-----------------------#2020-03-19">https://medium.com/google-developer-experts/exploring-dynamic-feature-navigation-on-android-c803bdbbca9b?source=collection_archive---------0-----------------------#2020-03-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/09ec6e59367ac0bb9d0927db749ebf74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2d4I0SdC9fRNY9iHeNr-0g.png"/></div></div></figure><p id="2709" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">自从在Android上引入了<a class="ae jn" href="https://developer.android.com/guide/navigation/navigation-getting-started" rel="noopener ugc nofollow" target="_blank">导航组件</a>之后，导航我们应用程序的不同部分变得更加容易实现。我们已经能够更好地将导航逻辑从我们的活动和片段中分离出来，并且能够更容易地测试这些路径。然而，导航组件只允许我们使用Android应用程序或库模块中包含的组件来实现这些事情——这些不是我们的Android项目支持的唯一模块类型，开发人员一直渴望导航组件包含更多的模块类型。例如，当在我们的应用程序中使用<a class="ae jn" href="https://developer.android.com/guide/app-bundle/dynamic-delivery#customize_delivery" rel="noopener ugc nofollow" target="_blank">动态特性模块</a>时，不能通过使用导航组件导航到这些模块。在这些情况下，新的动态功能导航库从导航组件扩展而来，允许我们执行涉及动态功能模块中定义的目的地的导航。</p><p id="502f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然能够使用导航库执行动态功能导航非常有用，但可能会出现一个大问题——如果导航时动态功能实际上没有安装在设备上，该怎么办？幸运的是，新的动态导航库提供了一些类来帮助我们解决这方面的问题。因为这些模块既可以随初始应用程序下载一起提供，也可以在需要时安装，所以我们不能像处理应用程序的其他部分一样导航到这些组件。除了导航时没有安装动态功能之外，如果该功能仍在下载，或者在导航到之前下载失败，该怎么办？当谈到这些情况时，有许多不同的状态需要考虑。幸运的是，新的动态特性导航组件旨在简化这一过程，不仅处理动态特性的导航，还处理动态特性可能处于的不同安装状态。</p><p id="d2cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我们将深入动态特性导航库，不仅了解如何在我们的应用程序中使用它，还了解它的组件是如何工作的。</p><p id="c9f3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>本文中的一些概念将引用导航组件。如果您对提到的任何概念不熟悉，那么查看导航组件的<a class="ae jn" href="https://developer.android.com/guide/navigation/navigation-getting-started" rel="noopener ugc nofollow" target="_blank">指南/文档是值得的。</a></p><blockquote class="jo jp jq"><p id="0a4c" class="ip iq jr ir b is it iu iv iw ix iy iz js jb jc jd jt jf jg jh ju jj jk jl jm ha bi translated"><em class="hh">此文原帖于</em><a class="ae jn" href="https://joebirch.co/2020/02/21/exploring-the-android-11-developer-preview-permission-changes/" rel="noopener ugc nofollow" target="_blank"><em class="hh">【joebirch.co】</em></a></p></blockquote></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><h1 id="f6fb" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">导航至动态要素目标</h1><p id="6471" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">在我们开始使用这个库之前，我们需要继续将依赖项添加到我们的应用程序中。值得注意的是，该库仍处于alpha阶段——因此，如果您有机会使用它，那么这是向开发人员提供反馈的好时机。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="1d8b" class="lo kd hh lk b fi lp lq l lr ls">implementation "androidx.navigation:navigation-dynamic-features-<br/>    fragment:2.3.0-alpha03"</span></pre><p id="40c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们以前使用导航组件库，我们的主机片段应该是这样的:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="4079" class="lo kd hh lk b fi lp lq l lr ls">&lt;androidx.fragment.app.FragmentContainerView<br/>    android:id="@+id/nav_host_fragment"<br/>    android:name="androidx.navigation.fragment.NavHostFragment"<br/>    app:defaultNavHost="true"<br/>    app:navGraph="@navigation/main_nav" /&gt;</span></pre><p id="44f3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当谈到动态导航器时，我们需要为新的DynamicNavHostFragment进行切换。这个导航主机类允许我们使用在动态功能模块中定义的目的地来处理导航。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="0a18" class="lo kd hh lk b fi lp lq l lr ls">&lt;androidx.fragment.app.FragmentContainerView<br/>    android:id="@+id/nav_host_fragment"<br/><strong class="lk hi">    android:name="androidx.navigation.dynamicfeatures</strong><br/><strong class="lk hi">        .fragment.DynamicNavHostFragment"</strong><br/>    app:defaultNavHost="true"<br/>    app:navGraph="@navigation/main_nav" /&gt;</span></pre><p id="42a4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们的导航主机正在使用DynamicNavHostFragment类，我们可以继续将我们的第一个导航目的地从我们的功能模块添加到我们的图中。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="988d" class="lo kd hh lk b fi lp lq l lr ls">&lt;navigation xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    android:id="@+id/main_nav"<br/>    app:startDestination="@id/mainFragment"&gt;<br/><br/>    &lt;fragment<br/>        android:id="@+id/mainFragment"<br/>        android:name="co.joebirch.navigationsample.MainFragment" &gt;<br/><br/>&lt;/navigation&gt;</span></pre><p id="0412" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此时，我们有了导航图，以及定义为mainFragment引用的<strong class="ir hi"> startDestination </strong>。声明后，我们现在要继续向我们的图表添加一个目的地——我们的第一个目的地将来自一个动态特征模块。让我们继续将它添加到我们的导航图中。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="6bd0" class="lo kd hh lk b fi lp lq l lr ls">&lt;navigation xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    android:id="@+id/main_nav"<br/>    app:startDestination="@id/mainFragment"&gt;<br/><br/>    &lt;fragment<br/>        android:id="@+id/mainFragment"<br/>        android:name="co.joebirch.navigationsample.MainFragment" /&gt;<br/><br/>    &lt;fragment<br/>        app:moduleName="feature_one"<br/>        android:id="@+id/featureOneFragment"<br/>        android:name="co.joebirch.feature_one.FeatureOneFragment" /&gt;<br/><br/>&lt;/navigation&gt;</span></pre><p id="ed86" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们在这里添加了id为<strong class="ir hi"> featureOneFragment </strong>的目的地。您会注意到，我们在片段目的地上设置了三个不同的属性:</p><ul class=""><li id="1d94" class="lt lu hh ir b is it iw ix ja lv je lw ji lx jm ly lz ma mb bi translated"><strong class="ir hi">moduleName</strong>–这是我们的导航目的地所在模块的名称。当定位目的地时，库将查看这个模块的内部，充当导航图和特定目的地之间的粘合剂。与应用程序/库模块导航相比，这是一项重要的附加功能。</li><li id="d835" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><strong class="ir hi">id</strong>–导航目的地的id</li><li id="9393" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><strong class="ir hi">名称</strong>–用于该导航目的地的片段的名称</li></ul><p id="3387" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了这些定义，我们的图现在有足够的信息来定位被用作目的地的片段——现在我们需要实际配置到它的导航。说到这一点，这种方法看起来非常类似于我们为应用程序和库模块导航配置导航组件的方式。</p><p id="1d4d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，我们将继续向mainFragment添加一个操作，这样我们就可以导航到我们的功能模块目的地:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="3669" class="lo kd hh lk b fi lp lq l lr ls">&lt;fragment<br/>    android:id="@+id/mainFragment"<br/>    android:name="co.joebirch.navigationsample.MainFragment" &gt;<br/><br/>        &lt;action<br/>            android:id="<br/>                @+id/action_mainFragment_to_featureOneFragment"<br/>            app:destination="@id/featureOneFragment" /&gt;<br/><br/>&lt;/fragment&gt;</span></pre><p id="d3a9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从我们的代码中，我们现在可以使用一个<strong class="ir hi">导航控制器</strong>引用来触发这个动作，并执行它所定义的导航:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="13c1" class="lo kd hh lk b fi lp lq l lr ls">findNavController().navigate(<br/>    R.id.action_mainFragment_to_featureOneFragment)</span></pre></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><h1 id="5f85" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">包括来自动态特征模块的图形</h1><p id="cf49" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">此时，我们已经使用导航图为动态功能模块添加了导航，但是在某些情况下，我们可能需要配置稍微复杂一些的导航。例如，我们可能有一个动态特性模块，它定义了自己的导航图——这需要从我们上面定义的导航图中引用。假设我们在第二个动态特征模块中定义了以下导航图:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="6195" class="lo kd hh lk b fi lp lq l lr ls">&lt;navigation    <br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    app:startDestination="@id/secondFeatureFragmentOne"&gt;<br/><br/>    &lt;fragment<br/>        android:id="@+id/secondFeatureFragmentOne"<br/>        android:name="co.joebirch.navigationsample.<br/>            feature_two.FeatureTwoFragmentOne"&gt;<br/><br/>        &lt;action<br/>            android:id="@+id/action_secondFeatureFragmentOne<br/>                _to_secondFeatureFragmentTwo"<br/>            app:destination="@id/secondFeatureFragmentTwo" /&gt;<br/>    &lt;/fragment&gt;<br/><br/>    &lt;fragment<br/>        android:id="@+id/secondFeatureFragmentTwo"<br/>        android:name="co.joebirch.navigationsample.<br/>            feature_two.FeatureTwoFragmentTwo" /&gt;<br/><br/>&lt;/navigation&gt;</span></pre><p id="b897" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个动态特性模块中，假设我们让它定义了自己的导航图——不管这个图是否比这个图更复杂，这有助于保持它的责任。现在，我们要将它作为我们最初定义的全局导航图的一部分，这样我们就可以导航到这个新图中定义的片段。如果我们回到主导航图，我们可以添加以下信息:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="00fd" class="lo kd hh lk b fi lp lq l lr ls">&lt;include-dynamic<br/>    android:id="@+id/featureNav"<br/>    app:moduleName="secondFeature"<br/>    app:graphResName="second_feature_nav"<br/>    app:graphPackage="co.joebirch.navigationsample.feature_two" /&gt;</span></pre><p id="00aa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">导航库中已经有了<strong class="ir hi"> include </strong>标签，允许我们从项目中的标准库模块添加导航图。动态特性导航库添加了这个新的<strong class="ir hi"> include-dynamic </strong>标签，该标签可用于从动态特性模块中添加对导航图的引用。该标签有四个可以定义的属性:</p><ul class=""><li id="a25d" class="lt lu hh ir b is it iw ix ja lv je lw ji lx jm ly lz ma mb bi translated"><strong class="ir hi">id</strong>–导航图的id</li><li id="3831" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><strong class="ir hi">moduleName</strong>–图形所在模块的名称</li><li id="7134" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><strong class="ir hi">graph resname</strong>–用于图形的资源标识符</li><li id="8d42" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><strong class="ir hi">图形包</strong>–图形文件所在的包</li></ul><p id="b1e9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将这个<strong class="ir hi"> include-dynamic </strong>标签添加到我们原来的<strong class="ir hi"> main_nav </strong>图中，我们现在可以在上面执行导航操作。让我们在我们的图形中替换<strong class="ir hi">action _ main fragment _ to _ featureone fragment</strong>动作，以便我们可以导航到包含在我们的<strong class="ir hi"> include-dynamic </strong>标记中的图形。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="71b2" class="lo kd hh lk b fi lp lq l lr ls">&lt;action<br/>    android:id="@+id/action_mainFragment_to_featureNav"<br/>    app:destination="@id/featureNav" /&gt;</span></pre><p id="93f3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样，当我们从导航控制器中触发<strong class="ir hi">action _ main fragment _ to _ featureNav</strong>动作时，将显示feature nav图表中的startDestination，并从该图表中获取任何后续导航行为。</p></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><h1 id="4c27" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">在导航期间处理动态特征安装</h1><p id="fc7f" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">虽然能够使用导航库执行动态功能导航非常有用，但可能会出现一个大问题——如果导航时设备上没有安装动态功能，该怎么办？幸运的是，动态特性导航库提供了一些类，可以帮助我们解决这方面的问题。</p><p id="57e9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当导航到一个动态功能模块时，如我们图中目的地的<strong class="ir hi">模块</strong>属性所定义的，库将首先检查该功能是否安装在设备上。如果安装，将导航到目的地。否则，将显示进度片段，同时将安装动态功能，并且一旦安装完成，用户将被导航到目的地。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/96c4ec211bfd62584d23a322dc172cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qswWQ5f1XaV8lMJl"/></div></div></figure><p id="046c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当出现安装过程中显示的进度片段时，它将为我们处理整个安装过程，包括任何加载、成功或出现的错误状态。这个进度片段是以<strong class="ir hi"> DefaultProgressFragment </strong>类的形式——它从<strong class="ir hi"> AbstractProgressFragment </strong>类扩展而来。虽然这个默认片段为我们处理一切，但我们可能希望提供我们自己的定制实现，以便在安装过程中使用。但是，强烈建议使用DefaultProgressFragment，除非您需要为这部分流添加扩展功能，或者在缺省情况之外定制进度UI。</p><p id="f972" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当涉及到提供我们自己的进度片段时，它需要扩展<strong class="ir hi"> AbstractProgressFragment </strong>类，这意味着我们将需要实现以下方法:</p><ul class=""><li id="7b3c" class="lt lu hh ir b is it iw ix ja lv je lw ji lx jm ly lz ma mb bi translated"><strong class="ir hi"> onCancelled() </strong> —当用户取消安装过程时调用</li><li id="a1e8" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><strong class="ir hi">on failed(error code:Int)</strong>—当动态功能安装失败时调用，错误由提供的错误代码指示</li><li id="18bf" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><strong class="ir hi"> onProgress(status: Int，bytesDownloaded: Long，bytesTotal: Long) </strong> —每当有关于动态特性安装的进度更新时调用。这里，bytesDownloaded表示到目前为止已经下载的字节数，bytesTotal表示需要下载的总字节数。最后，状态将是<a class="ae jn" href="https://developer.android.com/reference/com/google/android/play/core/splitinstall/model/SplitInstallSessionStatus" rel="noopener ugc nofollow" target="_blank">SplitInstallSessionStatus</a>值之一，可用于确定动态特性安装的当前状态。</li></ul><p id="0032" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦我们有了定制的进度片段，我们可以使用<strong class="ir hi">app:progress destination</strong>属性将它设置为处理我们安装进度的目标ID。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/a7e1b5a37855d1929c86b1ec05178c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UZ1lrZPc3nrjWgV_"/></div></div></figure></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><h1 id="5e77" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">监控动态功能安装</h1><p id="87e8" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">在某些情况下，我们可能希望为我们的动态特性实现一个非阻塞的安装流程——例如，与其显示AbstractProgressFragment的某种形式，我们可能希望将用户保持在他们所处的当前上下文中。这种方法可以帮助用户获得更平滑的体验，并消除任何可能来自进度屏幕的阻塞体验。</p><p id="2b67" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在AbstractProgressFragment类中，有一些内部机制在监控动态特性的安装状态，通过<strong class="ir hi"> onProgress() </strong>覆盖将这些信息传递回我们的片段实现。这是使用DynamicInstallMonitor类处理的，它实际上可供我们在这个进度片段之外使用——这意味着我们可以允许用户从导航中触发安装，在他们继续当前任务的同时监视进度状态，并在安装完成后导航它们(处理过程中的任何其他状态，如错误)。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/9c66a9dfaf0625d80d013a0f3becf69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kACQAj_YbgNdlaHp"/></div></div></figure><p id="8499" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以从创建对该监视器的新引用开始:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="16e2" class="lo kd hh lk b fi lp lq l lr ls">val installMonitor = DynamicInstallMonitor()</span></pre><p id="a92e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们开始任何监控之前，我们首先要进行导航。这样做时，我们需要传入DynamicExtras类的一个实例。这个类本质上充当了一个容器，让我们在处理动态特性的导航时传递属性。要构建该类的实例，我们可以使用相应的构建器来完成:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="c2d3" class="lo kd hh lk b fi lp lq l lr ls">val dynamicExtras = DynamicExtras.Builder()<br/>    .setInstallMonitor(installMonitor)<br/>    .build()</span></pre><p id="3fe4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">构建器目前允许我们设置两种不同的参考:</p><ul class=""><li id="cf6d" class="lt lu hh ir b is it iw ix ja lv je lw ji lx jm ly lz ma mb bi translated"><strong class="ir hi"> installMonitor </strong> —用于监控动态特性当前安装状态的引用</li><li id="40c4" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><strong class="ir hi"> destinationExtras </strong> —任何导航器。我们希望为导航传递的额外内容</li></ul><p id="c713" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们有了对DynamicExtras的引用，我们可以继续在导航控制器上执行导航:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="00a8" class="lo kd hh lk b fi lp lq l lr ls">findNavController().navigate(<br/>    destinationId,<br/>    null,<br/>    null,<br/>    dynamicExtras<br/>)</span></pre><p id="6661" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦我们触发了这个导航操作，我们需要立即检查我们的动态特性的安装状态。我们之前实例化的安装监视器实例允许我们使用其isInstallRequired字段来检查这一点，这将返回:</p><ul class=""><li id="fea8" class="lt lu hh ir b is it iw ix ja lv je lw ji lx jm ly lz ma mb bi translated"><strong class="ir hi">假</strong> —意味着不需要安装，我们可以继续执行导航</li><li id="8cb2" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated"><strong class="ir hi">真</strong> —需要安装动态特性，这意味着我们需要观察安装状态，并在安装完成后执行导航。</li></ul><p id="defa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此时，如果需要安装，那么我们需要观察安装状态。当安装过程自动发生时，我们检查这个安装状态，以便我们知道是否观察动态特性的安装状态。我们的installMonitor参考公开了一个LiveData <splitinstallsessionstate>实例，它允许我们观察安装状态何时改变。然后，我们可以使用这个状态的值来描述应该在我们的UI中显示什么。最后，一旦状态表示一个终止状态，我们需要移除我们的观察者，因为不再需要观察。</splitinstallsessionstate></p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="451c" class="lo kd hh lk b fi lp lq l lr ls">installMonitor.status.observe(viewLifecycleOwner, <br/>   Observer { state -&gt;<br/>   when (state.status()) {<br/>       SplitInstallSessionStatus.INSTALLED -&gt; { }<br/>       SplitInstallSessionStatus.REQUIRES_USER_CONFIRMATION -&gt; {<br/>           // Larger feature downloads require user confirmation<br/>           splitInstallManager.startConfirmationDialogForResult(<br/>                state,<br/>                this,<br/>                REQUEST_CODE_INSTALL_CONFIRMATION<br/>           )<br/>       }<br/>       SplitInstallSessionStatus.FAILED -&gt; {}<br/>       SplitInstallSessionStatus.CANCELED -&gt; {}<br/>       ...<br/>   }</span><span id="10a1" class="lo kd hh lk b fi mi lq l lr ls">   if (state.hasTerminalStatus()) {<br/>       installMonitor.status.removeObservers(viewLifecycleOwner)<br/>   }<br/>})</span></pre><p id="b3dc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以在上面看到，流在任何时候都可能处于一系列状态，同时这取决于您计划在这里显示的UI，动态交付的<a class="ae jn" href="https://developer.android.com/guide/app-bundle/ux-guidelines" rel="noopener ugc nofollow" target="_blank"> UX指南</a>将有助于处理上述每个状态。</p></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><h1 id="c380" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">在后台</h1><p id="fc2c" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">现在我们知道了如何在我们的应用中处理动态功能导航，我想看看事情是如何在引擎盖下工作的。</p><p id="3272" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的章节中，我们提到了这个DynamicNavHostFragment类——这个新类实际上是从用于非动态特征导航的<a class="ae jn" href="https://developer.android.com/reference/androidx/navigation/fragment/NavHostFragment" rel="noopener ugc nofollow" target="_blank"> NavHostFragment </a>扩展而来的。DynamicNavHostFragment这样做是为了覆盖NavHostFragment的<strong class="ir hi"> onCreateNavController() </strong>函数，使用其中的新类集合来提供动态导航的功能。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/06aed60f4d99d2340ad613b26b8d2f83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MDQ-D7BBB90nhkrm"/></div></div></figure><p id="96c3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们从顶部开始，我们有NavHostFragment类——这在当前的导航库中已经可用，所以我不想对此做太多介绍。如果你还不熟悉它，这个类被用来作为导航图中显示内容的容器。如果您在上面的图表中注意到了，DynamicNavHostFragment是动态导航库中的一个新类，它充当动态功能的导航主机——该类扩展了原始的NavHostFragment，因此许多功能都是从该基类继承的。新的主机片段类实际上只覆盖了基类中的一个方法，onCreateNavController方法。该覆盖用于在初始化期间配置导航逻辑的一些额外部分。</p><p id="b726" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个onCreateNavController方法中，我们可以看到正在配置一组新的导航处理类。在此onCreateNavController过程中，所提供导航控制器的NavigatorProvider由动态导航所需的其他提供程序填充。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="944d" class="lo kd hh lk b fi lp lq l lr ls">override fun onCreateNavController(navController: NavController) {<br/>    super.onCreateNavController(navController)</span><span id="0dcc" class="lo kd hh lk b fi mi lq l lr ls">    ...<br/>    val navigatorProvider = navController.navigatorProvider<br/>    navigatorProvider += DynamicActivityNavigator(<br/>        requireActivity(), installManager)</span><span id="166d" class="lo kd hh lk b fi mi lq l lr ls">    val fragmentNavigator = DynamicFragmentNavigator(<br/>        requireContext(), childFragmentManager, id, installManager)<br/>    navigatorProvider += fragmentNavigator</span><span id="ade5" class="lo kd hh lk b fi mi lq l lr ls">    val graphNavigator = DynamicGraphNavigator(<br/>        navigatorProvider,<br/>        installManager<br/>    )<br/>    ...<br/>    navigatorProvider += graphNavigator<br/>    navigatorProvider += DynamicIncludeGraphNavigator(<br/>        requireContext(), navigatorProvider,         <br/>        navController.navInflater, installManager)<br/>}</span></pre><p id="bc5e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们看看默认的导航组件，我们可以看到有一个从Navigator抽象类扩展而来的类集合，这个类用于定义在应用程序中导航的机制。从这里扩展的类需要实现定义的方法，以便为定义的组件构建导航图。当涉及到动态特性导航时，这些原始类被重用来帮助实现动态导航。事实上，每个组件导航器都从其对应的导航器类扩展而来，覆盖navigate()函数来处理动态特性导航的新需求。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/2439e79ce1bf3cde10c4867fe04ff7ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UmfP6U4uRpgxjBsJ"/></div></div></figure><p id="da85" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，我们可以跳转到DynamicActivityNavigator类，并通过使用DynamicInstallManager来查看它处理导航的方式的不同:</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="0d69" class="lo kd hh lk b fi lp lq l lr ls">override fun navigate(<br/>   destination: ActivityNavigator.Destination,<br/>   args: Bundle?,<br/>   navOptions: NavOptions?,<br/>   navigatorExtras: Navigator.Extras?<br/>): NavDestination? {<br/>   val extras = navigatorExtras as? DynamicExtras<br/>   if (destination is Destination) {<br/>       val moduleName = destination.moduleName<br/>       if (moduleName != null &amp;&amp;<br/>           installManager.needsInstall(moduleName)) {<br/>           return installManager.performInstall(<br/>               destination, args, extras, moduleName)<br/>       }<br/>   }<br/>   return super.navigate(<br/>       destination,<br/>       args,<br/>       navOptions,<br/>       if (extras != null) {<br/>           extras.destinationExtras <br/>       } else {<br/>           navigatorExtras<br/>       }<br/>   )<br/>}</span></pre><p id="7e4d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与我们之前在这篇文章中看到的非常相似，对吗？检查功能是否可用，然后根据该状态处理导航的相同流程。如果没有这个新的navigator类，导航组件将无法处理动态特性的这些不同状态。</p><p id="6eaa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从导航组件中，您可能会想起NavDestination的概念，该类用于表示导航图中的单个节点，然后将这些节点(目的地)拼凑在一起，以创建表示应用程序导航流的图。导航组件中的每个导航器类都有自己的NavDestination实现。当涉及到动态特性和它们的导航器时，完全相同。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/d5b11a874f96d55e3dedad27fd7f495c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*buIfb6-c-MaXd8Rg"/></div></div></figure><p id="cec0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们再次使用DynamicActivityNavigator作为示例，我们可以看到该类的目的地是从初始ActivityNavigator扩展而来的。目的地类别。这个目的地的定义被用来存放包含动态特性的模块名，这是最初的实现所不支持的。当导航到这个活动时，可以在DynamicActivityNavigator类的navigate()方法中使用它。</p><pre class="lf lg lh li fd lj lk ll lm aw ln bi"><span id="2193" class="lo kd hh lk b fi lp lq l lr ls">class Destination : ActivityNavigator.Destination {<br/>    var moduleName: String? = null</span><span id="0b5f" class="lo kd hh lk b fi mi lq l lr ls">    constructor(navigatorProvider: NavigatorProvider) :   <br/>        super(navigatorProvider)constructor(<br/>        activityNavigator: <br/>            Navigator&lt;out ActivityNavigator.Destination&gt;<br/>    ) : super(activityNavigator)</span><span id="2239" class="lo kd hh lk b fi mi lq l lr ls">    override fun onInflate(context: Context, attrs: AttributeSet) {<br/>        super.onInflate(context, attrs)<br/>        context.withStyledAttributes(attrs, <br/>            R.styleable.DynamicActivityNavigator) {<br/>            moduleName = <br/>                getString(<br/>                    R.styleable.DynamicActivityNavigator_moduleName)<br/>        }<br/>    }<br/>}</span></pre><p id="3ac1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，导航组件以与之前相同的方式使用这些目的地类。这里，动态特征导航建立在已经存在的基础上，以扩展动态导航的功能。</p><p id="10c4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们从动态功能导航的源代码中可以看到的那样，导航组件的许多现有功能都是在的基础上构建的，以添加对通过动态功能导航的支持。这允许开发人员使用我们已经熟悉的导航方法，不仅在源代码中，而且在我们的项目中促进重用。</p><p id="3cf1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi">— -</p><p id="b013" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我们学习了如何使用动态功能导航库来导航我们的功能模型——不管它们在用户设备上的安装状态如何。使用这个库允许我们实现无摩擦的导航流程，将大部分艰苦工作转移到这个库上，让我们专注于构建优秀的应用程序。虽然我们没有深入研究它是如何工作的，但我们已经从较高的层面了解了它是如何工作的，以及如何重用原始导航组件的代码。</p><p id="997f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">综上所述，我期待看到您将如何使用这个库在您的应用程序中进行动态特性导航！如果你有任何关于如何使用它的问题，或者你想分享的想法，请在评论中联系我们🙌</p><p id="349e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">感谢<a class="mj mk ge" href="https://medium.com/u/65fe4f480b1c?source=post_page-----c803bdbbca9b--------------------------------" rel="noopener" target="_blank">本·韦斯</a>、<a class="mj mk ge" href="https://medium.com/u/4842ea54f33e?source=post_page-----c803bdbbca9b--------------------------------" rel="noopener" target="_blank">阿什戴维斯</a> &amp; <a class="mj mk ge" href="https://medium.com/u/de373fc05086?source=post_page-----c803bdbbca9b--------------------------------" rel="noopener" target="_blank">瓦贾哈特·卡里姆</a>对这篇文章的评论和反馈🙌</p></div></div>    
</body>
</html>