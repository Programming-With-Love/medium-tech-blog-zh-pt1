<html>
<head>
<title>LeakCanary: Detect all memory leaks!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeakCanary:检测所有内存泄漏！</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/leakcanary-detect-all-memory-leaks-875ff8360745?source=collection_archive---------0-----------------------#2015-05-08">https://medium.com/square-corner-blog/leakcanary-detect-all-memory-leaks-875ff8360745?source=collection_archive---------0-----------------------#2015-05-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="e529" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">Android和Java的内存泄漏检测库。</h2></div><p id="2f60" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">作者写的</em><a class="ae jt" href="https://twitter.com/Piwai" rel="noopener ugc nofollow" target="_blank"><em class="js"/></a><em class="js">。</em></p><blockquote class="ju"><p id="2d6a" class="jv jw hh bd jx jy jz ka kb kc kd jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jt" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><pre class="ke kf kg kh ki kj kk kl km aw kn bi"><span id="1ba0" class="ko kp hh kk b fi kq kr l ks kt">java.lang.OutOfMemoryError<br/>        at android.graphics.Bitmap.nativeCreate(Bitmap.java:-2)<br/>        at android.graphics.Bitmap.createBitmap(Bitmap.java:689)<br/>        at com.squareup.ui.SignView.createSignatureBitmap(SignView.java:121)</span></pre><h1 id="b30e" class="ku kp hh bd kv kw kx ky kz la lb lc ld in le io lf iq lg ir lh it li iu lj lk bi translated">没有人喜欢内存不足或崩溃</h1><p id="df1c" class="pw-post-body-paragraph iw ix hh iy b iz ll ii jb jc lm il je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">在Square Register中，我们<a class="ae jt" href="https://corner.squareup.com/2010/07/smooth-signatures.html" rel="noopener ugc nofollow" target="_blank">在位图缓存中绘制客户的签名</a>。这个位图是设备屏幕的大小，我们在创建它的时候遇到了很多内存不足(OOM)的问题。</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div class="er es lq"><img src="../Images/f1e5765ac9cbdf44d6f34832f8cad24f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*TpsPt3DHu_aMeoa2.png"/></div></figure><p id="2d3e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们尝试了几种方法，但都没有解决问题:</p><ul class=""><li id="a43b" class="ly lz hh iy b iz ja jc jd jf ma jj mb jn mc jr md me mf mg bi translated">使用位图。Config.ALPHA_8(签名不需要颜色)。</li><li id="8f49" class="ly lz hh iy b iz mh jc mi jf mj jj mk jn ml jr md me mf mg bi translated">捕捉OutOfMemoryError，触发GC并重试几次(灵感来自<a class="ae jt" href="https://android.googlesource.com/platform/packages/inputmethods/LatinIME/+/ics-mr1/java/src/com/android/inputmethod/latin/Utils.java" rel="noopener ugc nofollow" target="_blank"> GCUtils </a>)。</li><li id="a27b" class="ly lz hh iy b iz mh jc mi jf mj jj mk jn ml jr md me mf mg bi translated">我们没有想到从Java堆中分配位图。幸运的是，壁画还不存在。</li></ul><h1 id="c0d7" class="ku kp hh bd kv kw kx ky kz la lb lc ld in le io lf iq lg ir lh it li iu lj lk bi translated">我们看待它的方式是错误的</h1><p id="a196" class="pw-post-body-paragraph iw ix hh iy b iz ll ii jb jc lm il je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">位图大小不是问题。当内存快满时，任何地方都可能发生OOM。这种情况在创建大对象的地方更常见，比如位图。OOM是一个更深层次问题的征兆:内存泄漏。</p><h1 id="8e21" class="ku kp hh bd kv kw kx ky kz la lb lc ld in le io lf iq lg ir lh it li iu lj lk bi translated">什么是内存泄漏？</h1><p id="748f" class="pw-post-body-paragraph iw ix hh iy b iz ll ii jb jc lm il je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">一些对象具有有限的寿命。当它们的工作完成后，它们将被垃圾回收。如果一个引用链在一个对象的预期生命周期结束后仍将它保存在内存中，这将导致内存泄漏。当这些漏洞累积起来时，应用程序就会耗尽内存。</p><p id="a583" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，在调用Activity.onDestroy()之后，Activity、它的视图层次结构以及它们相关的位图都应该是垃圾可收集的。如果在后台运行的线程持有对该活动的引用，则相应的内存不能被回收。这最终会导致OutOfMemoryError崩溃。</p><h1 id="bdb4" class="ku kp hh bd kv kw kx ky kz la lb lc ld in le io lf iq lg ir lh it li iu lj lk bi translated">寻找内存泄漏</h1><p id="ab4a" class="pw-post-body-paragraph iw ix hh iy b iz ll ii jb jc lm il je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">寻找内存泄漏是一个手动过程，Raizlabs的<a class="ae jt" href="http://www.raizlabs.com/dev/2014/03/wrangling-dalvik-memory-management-in-android-part-1-of-2/" rel="noopener ugc nofollow" target="_blank"> Wrangling Dalvik </a>系列对此有很好的描述。</p><p id="9d92" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是关键步骤:</p><ol class=""><li id="9e84" class="ly lz hh iy b iz ja jc jd jf ma jj mb jn mc jr mm me mf mg bi translated">通过<a class="ae jt" href="https://bugsnag.com/" rel="noopener ugc nofollow" target="_blank"> Bugsnag </a>、<a class="ae jt" href="https://try.crashlytics.com/" rel="noopener ugc nofollow" target="_blank"> Crashlytics </a>或<a class="ae jt" href="https://play.google.com/apps/publish/" rel="noopener ugc nofollow" target="_blank">开发者控制台</a>了解OutOfMemoryError崩溃。</li><li id="087a" class="ly lz hh iy b iz mh jc mi jf mj jj mk jn ml jr mm me mf mg bi translated">尝试重现问题。您可能需要购买、借用或窃取遭受崩溃的特定设备。(并非所有设备都会出现所有泄漏！)您还需要找出是什么导航序列触发了泄漏，可能是通过蛮力。</li><li id="b67f" class="ly lz hh iy b iz mh jc mi jf mj jj mk jn ml jr mm me mf mg bi translated">当OOM发生时转储堆(<a class="ae jt" href="https://gist.github.com/pyricau/4726389fd64f3b7c6f32" rel="noopener ugc nofollow" target="_blank">下面是如何做的</a>)。</li><li id="211d" class="ly lz hh iy b iz mh jc mi jf mj jj mk jn ml jr mm me mf mg bi translated">用<a class="ae jt" href="http://eclipse.org/mat/" rel="noopener ugc nofollow" target="_blank"> MAT </a>或<a class="ae jt" href="https://www.yourkit.com/" rel="noopener ugc nofollow" target="_blank"> YourKit </a>在垃圾堆周围翻找，找到一个应该被垃圾收集的对象。</li><li id="ee7f" class="ly lz hh iy b iz mh jc mi jf mj jj mk jn ml jr mm me mf mg bi translated">计算从该对象到GC根的最短强引用路径。</li><li id="f225" class="ly lz hh iy b iz mh jc mi jf mj jj mk jn ml jr mm me mf mg bi translated">找出路径中不应该存在的引用，并修复内存泄漏。</li></ol><p id="715e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果一个库可以在你进入OOM之前完成所有这些工作，让你专注于修复内存泄漏，那会怎么样？</p><h1 id="3325" class="ku kp hh bd kv kw kx ky kz la lb lc ld in le io lf iq lg ir lh it li iu lj lk bi translated">介绍LeakCanary</h1><p id="82aa" class="pw-post-body-paragraph iw ix hh iy b iz ll ii jb jc lm il je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated"><a class="ae jt" href="https://github.com/square/leakcanary" rel="noopener ugc nofollow" target="_blank"> LeakCanary </a>是一个开源Java库，用于检测调试版本中的内存泄漏。</p><p id="80a4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看一个猫的例子:</p><pre class="lr ls lt lu fd kj kk kl km aw kn bi"><span id="85a9" class="ko kp hh kk b fi kq kr l ks kt"><strong class="kk hi">class</strong> <strong class="kk hi">Cat</strong> <strong class="kk hi">{</strong><br/><strong class="kk hi">}</strong><br/><strong class="kk hi">class</strong> <strong class="kk hi">Box</strong> <strong class="kk hi">{</strong><br/>  Cat hiddenCat<strong class="kk hi">;</strong><br/><strong class="kk hi">}</strong><br/><strong class="kk hi">class</strong> <strong class="kk hi">Docker</strong> <strong class="kk hi">{</strong><br/>  <strong class="kk hi">static</strong> Box container<strong class="kk hi">;</strong><br/><strong class="kk hi">}</strong></span><span id="57ee" class="ko kp hh kk b fi mn kr l ks kt"><em class="js">// ...</em></span><span id="a450" class="ko kp hh kk b fi mn kr l ks kt">Box box <strong class="kk hi">=</strong> <strong class="kk hi">new</strong> <strong class="kk hi">Box();</strong><br/>Cat schrodingerCat <strong class="kk hi">=</strong> <strong class="kk hi">new</strong> <strong class="kk hi">Cat();</strong><br/>box<strong class="kk hi">.</strong>hiddenCat <strong class="kk hi">=</strong> schrodingerCat<strong class="kk hi">;</strong><br/>Docker<strong class="kk hi">.</strong>container <strong class="kk hi">=</strong> box<strong class="kk hi">;</strong></span></pre><p id="17c0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">创建一个RefWatcher实例，并为其提供一个要监视的对象:</p><pre class="lr ls lt lu fd kj kk kl km aw kn bi"><span id="7019" class="ko kp hh kk b fi kq kr l ks kt"><em class="js">// We expect schrodingerCat to be gone soon (or not), let's watch it.</em><br/>refWatcher<strong class="kk hi">.</strong>watch<strong class="kk hi">(</strong>schrodingerCat<strong class="kk hi">);</strong></span></pre><p id="b90f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当检测到泄漏时，您会自动获得一个很好的泄漏跟踪:</p><pre class="lr ls lt lu fd kj kk kl km aw kn bi"><span id="06de" class="ko kp hh kk b fi kq kr l ks kt">* GC ROOT static Docker.container<br/>* references Box.hiddenCat<br/>* leaks Cat instance</span></pre><p id="8460" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们知道你正忙着写特性，所以我们使它非常容易设置。只需一行代码，LeakCanary就会自动检测活动泄漏:</p><pre class="lr ls lt lu fd kj kk kl km aw kn bi"><span id="41ce" class="ko kp hh kk b fi kq kr l ks kt"><strong class="kk hi">public</strong> <strong class="kk hi">class</strong> <strong class="kk hi">ExampleApplication</strong> <strong class="kk hi">extends</strong> Application <strong class="kk hi">{</strong><br/>  @Override <strong class="kk hi">public</strong> <strong class="kk hi">void</strong> <strong class="kk hi">onCreate()</strong> <strong class="kk hi">{</strong><br/>    <strong class="kk hi">super.</strong>onCreate<strong class="kk hi">();</strong><br/>    LeakCanary<strong class="kk hi">.</strong>install<strong class="kk hi">(this);</strong><br/>  <strong class="kk hi">}</strong><br/><strong class="kk hi">}</strong></span></pre><p id="26d3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">开箱后，您会收到一个通知和一个漂亮的显示:</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div class="er es lq"><img src="../Images/8168b1827e87cf0dbdc39a336b4f406e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*5zhG12WlfCp1nIlc.png"/></div></figure><h1 id="f804" class="ku kp hh bd kv kw kx ky kz la lb lc ld in le io lf iq lg ir lh it li iu lj lk bi translated">结论</h1><p id="bf19" class="pw-post-body-paragraph iw ix hh iy b iz ll ii jb jc lm il je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">启用LeakCanary后，我们发现并修复了应用程序中的许多内存泄漏。我们甚至在Android SDK 中发现了一些<a class="ae jt" href="https://github.com/square/leakcanary/blob/master/library/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java" rel="noopener ugc nofollow" target="_blank">漏洞。</a></p><p id="f98c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">结果是惊人的。我们现在从OOM错误中减少了94%的崩溃。</p><figure class="lr ls lt lu fd lv er es paragraph-image"><div class="er es lq"><img src="../Images/7e5e4e54455e149577527a489d3e2efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*8DpD5hZX4R4O4Vvr.png"/></div></figure><p id="f3dc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你想消除OOM崩溃，现在就安装leak canary！</p></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><div class="lr ls lt lu fd mv"><a href="https://twitter.com/Piwai" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab dw"><div class="mx ab my cl cj mz"><h2 class="bd hi fi z dy na ea eb nb ed ef hg bi translated">皮埃尔-伊夫·里考(@皮瓦伊)|推特</h2><div class="nc l"><h3 class="bd b fi z dy na ea eb nb ed ef dx translated">Pierre-Yves Ricau (@Piwai)的最新推文。安卓贝克@广场。巴黎/旧金山</h3></div><div class="nd l"><p class="bd b fp z dy na ea eb nb ed ef dx translated">twitter.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj lw mv"/></div></div></a></div></div></div>    
</body>
</html>