<html>
<head>
<title>What Future for the Legacy Applications?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遗留应用程序的未来如何？</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/what-future-for-the-legacy-applications-61b6d36ed089?source=collection_archive---------0-----------------------#2019-11-29">https://medium.com/quick-code/what-future-for-the-legacy-applications-61b6d36ed089?source=collection_archive---------0-----------------------#2019-11-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="dfd8" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">保存和处理之间的遗留应用程序的未来</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/bf80f31323477423281f7277c891a7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3QfvwKB8GATxQfxc"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Photo by <a class="ae jm" href="https://unsplash.com/@nobleshots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Noble</a> on <a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="188c" class="ju jv hh bd jw jx jy jz ka kb kc kd ke in kf io kg iq kh ir ki it kj iu kk kl bi translated">介绍</h1><p id="55e9" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">在技术飞速发展的时代，遗留应用程序保持了它们的地位和作用。</p><p id="0745" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">许多公司在80年代和90年代花费了时间和金钱来实现大型遗留应用程序，这些应用程序被证明是保持增长的正确选择。</p><p id="e760" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">今天，同样是这些公司问自己，这是否是追求的正确方式，或者是时候去创新了。</p><p id="afc9" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">在这个故事中，我将尝试分析一些转换遗留应用程序的方法。</p><p id="479a" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated"><strong class="ko hi"> <em class="ln">走吧！</em>T3】</strong></p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="1442" class="ju jv hh bd jw jx jy jz ka kb kc kd ke in kf io kg iq kh ir ki it kj iu kk kl bi translated">方法</h1><p id="1715" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">许多遗留应用程序在大型机上运行，并且实现了运行20年或更长时间的业务逻辑。</p><p id="848d" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">对于公司来说，当管理成本增加时，很难选择应用程序的未来。</p><p id="ffc1" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">根据我的经验，可以从以下三个层面攻击遗留应用程序:</p><ul class=""><li id="441b" class="lo lp hh ko b kp li ks lj kv lq kz lr ld ls lh lt lu lv lw bi translated"><strong class="ko hi">视图</strong>:用新的视图替换视图，维护代码和数据的核心</li><li id="3e01" class="lo lp hh ko b kp lx ks ly kv lz kz ma ld mb lh lt lu lv lw bi translated"><strong class="ko hi">业务</strong>:替换视图，重构业务逻辑，但是保持数据的结构</li><li id="871c" class="lo lp hh ko b kp lx ks ly kv lz kz ma ld mb lh lt lu lv lw bi translated"><strong class="ko hi">数据</strong>:替换视图、业务逻辑和数据</li></ul><p id="b16b" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">在攻击层的基础上更新遗留应用程序的可能方法有:</p><ul class=""><li id="9b43" class="lo lp hh ko b kp li ks lj kv lq kz lr ld ls lh lt lu lv lw bi translated">逻辑的保存</li><li id="4bd6" class="lo lp hh ko b kp lx ks ly kv lz kz ma ld mb lh lt lu lv lw bi translated">重构</li><li id="db67" class="lo lp hh ko b kp lx ks ly kv lz kz ma ld mb lh lt lu lv lw bi translated">移民</li></ul><p id="7712" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">这些继续进行的方法可能会有不同的成本和应用程序的影响，并建议在开始遵循一种方法之前进行良好的评估。</p><p id="9e6d" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">现在我将尝试详细解释这些方法。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="187d" class="ju jv hh bd jw jx jy jz ka kb kc kd ke in kf io kg iq kh ir ki it kj iu kk kl bi translated">逻辑的保存</h1><p id="ed82" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">第一种方法是由维护遗留应用程序中包含的大部分业务逻辑的思想决定的。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mc"><img src="../Images/c60270d97e4f5e5bc629d5902883e87f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MtFgAXd-akqDNixtI8dxJg.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Block diagram for preservation of logic approach</figcaption></figure><p id="1917" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">通常认为当前的实现是稳定的并且没有错误，因此决定维护数据库和包含业务逻辑的软件层。</p><p id="452d" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">这种方法提供了当前通过web服务(例如SOAP或REST服务)实现的业务逻辑，并在创建新的前端层以消除旧的可视化模型之后。</p><p id="6533" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">重构业务层和数据层的成本很低，因为开发人员唯一要做的就是公开当前代码的web服务:个性化代码以公开和实现web服务。</p><p id="84db" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">另一方面，视图实现的成本可能会很高，因为可能很难从新的前端协调将在没有任何修改的情况下公开的旧功能。</p><p id="abf8" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">原样功能的展示允许保留大部分代码，但是使前端的开发活动复杂化:在遗留应用程序上节省成本，但是在视图上花费更多。</p><p id="7f2e" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">这种方法的好处是，新应用程序的开发和上线可以与旧的遗留应用程序的利用并行进行。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="7c58" class="ju jv hh bd jw jx jy jz ka kb kc kd ke in kf io kg iq kh ir ki it kj iu kk kl bi translated">重构</h1><p id="0b2b" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">最常见的方法是实现一个新的维护数据层的web应用程序。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es md"><img src="../Images/38f507c3902582429178314b63598402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-hc2wM8QLDJzl4Nou7GIQ.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Block diagram for refactoring approach</figcaption></figure><p id="f1d0" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">考虑一个新的前端很容易，实现一个新的业务层也很容易(如果您有功能规范)，但是在许多情况下，很难考虑将数据库迁移到一个新的模型。</p><p id="098d" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">在设计阶段，可以决定创建一个直接访问数据层的业务层，或者在数据库和业务层之间创建一个API层，以分离这两个层，并提供对持久化信息的web访问(在可能的情况下也可以是异步的)。</p><p id="1493" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">可选地，可以实现API服务层，以允许通过web应用直接访问数据，将数据库的旧技术与更高层的新技术分离。</p><p id="d0a4" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">这种方法的成本太高:需要创建一个新的前端，重构和实现新的业务层，如果合适的话，还需要一个新的API层。</p><p id="842d" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">这种方法的一个好处可能是技术和应用技术的彻底改变。</p><p id="3d5a" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">通过对遗留应用程序进行深入评估，可以调查架构中是否存在缺陷或功能流程中是否存在bug，从而避免在新应用程序中出现这些问题。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="04c9" class="ju jv hh bd jw jx jy jz ka kb kc kd ke in kf io kg iq kh ir ki it kj iu kk kl bi translated">数据迁移</h1><p id="c6ae" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">最后一种方法被认为是更新遗留应用程序的所有层。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es me"><img src="../Images/8d9dcab25414c1376e733a62c430b935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GjDdbKgJyns3x2YRUv6RRw.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Block diagram for data migration approach</figcaption></figure><p id="c04a" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">采用这种方式来更新遗留应用程序的公司受到以下原因的推动:管理成本上升、迫使使用新技术的内部IT决策、招聘了解遗留应用程序编程语言的人员的困难和/或许多其他动机。</p><p id="82af" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">在许多情况下，传统应用程序是多年前开发的，并且多年来保持稳定，但随着时间的推移，已经暴露出漏洞和限制，只有完全更新软件堆栈才能修复这些漏洞和限制。</p><p id="ded2" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">将遗留应用程序的整个堆栈迁移到新架构的决策可以从定义新数据模型开始，新数据模型将迁移当前数据库。下一步可能是设计新业务层的架构，例如实现可由新前端调用的API，最后但同样重要的是新前端的设计和实现。</p><p id="e9a1" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">这种方法要求公司配备许多具有特定技能的特定专业人员，例如:</p><ul class=""><li id="5f84" class="lo lp hh ko b kp li ks lj kv lq kz lr ld ls lh lt lu lv lw bi translated"><strong class="ko hi">数据库架构师</strong>:推荐合适的数据库技术，建议采用关系型而非非关系型，并设计实体的数据模型；</li><li id="dd54" class="lo lp hh ko b kp lx ks ly kv lz kz ma ld mb lh lt lu lv lw bi translated"><strong class="ko hi">后端架构师</strong>:提出要采用的编程语言，设计后端架构，组织要使用的模式；</li><li id="0bf1" class="lo lp hh ko b kp lx ks ly kv lz kz ma ld mb lh lt lu lv lw bi translated"><strong class="ko hi">前端架构师</strong>:除了前端技术，与后端架构师有严格的联系；</li><li id="49cd" class="lo lp hh ko b kp lx ks ly kv lz kz ma ld mb lh lt lu lv lw bi translated"><strong class="ko hi"> UX设计师</strong>:设计新的用户体验，安装在新的网络应用之上；</li><li id="c2eb" class="lo lp hh ko b kp lx ks ly kv lz kz ma ld mb lh lt lu lv lw bi translated"><strong class="ko hi"> DevOps架构师</strong>:设计测试自动化、包创建和软件部署的新工作流程；</li><li id="5a56" class="lo lp hh ko b kp lx ks ly kv lz kz ma ld mb lh lt lu lv lw bi translated"><strong class="ko hi">前端和后端开发人员</strong>:每一个在现实中转化想法的项目的真实劳动力；</li><li id="1d1a" class="lo lp hh ko b kp lx ks ly kv lz kz ma ld mb lh lt lu lv lw bi translated"><strong class="ko hi">更多其他人员</strong>:最后，迁移还需要其他资源，如测试架构师、安全专家、基础设施和网络专家等。</li></ul><p id="dc61" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">这些资源的存在和数量可以根据项目的大小而变化。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="db52" class="ju jv hh bd jw jx jy jz ka kb kc kd ke in kf io kg iq kh ir ki it kj iu kk kl bi translated">结论</h1><p id="6bd4" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku kv kw kx ky kz la lb lc ld le lf lg lh ha bi translated">当任何人提出这个问题时，这一时刻的欢乐就会消失:</p><blockquote class="mf"><p id="8767" class="mg mh hh bd mi mj mk ml mm mn mo lh dx translated">遗留应用程序是否太旧，以至于我们需要放弃？</p></blockquote><p id="4e80" class="pw-post-body-paragraph km kn hh ko b kp mp ii kr ks mq il ku kv mr kx ky kz ms lb lc ld mt lf lg lh ha bi translated">许多遗留应用程序太大，因此会发现更新成本高于管理成本，并通常会决定按原样维护应用程序。</p><p id="39f5" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">更新的步骤可能是部分的或全部的，具有成本和影响。在迈出这一大步之前，强烈建议进行深入评估，以确定新应用程序的成本并假设其优势。</p><p id="1890" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated">当我们将所有这些信息都可以张贴在规模板，看看规模pend，但直到这一刻的申请更新将仍然只是一个想法。</p><p id="13c6" class="pw-post-body-paragraph km kn hh ko b kp li ii kr ks lj il ku kv lk kx ky kz ll lb lc ld lm lf lg lh ha bi translated"><strong class="ko hi"> <em class="ln">感谢您的宝贵时间！</em>T13】</strong></p></div></div>    
</body>
</html>