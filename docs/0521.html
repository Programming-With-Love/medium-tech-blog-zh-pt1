<html>
<head>
<title>Re-writing the AOSP DeskClock app in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用科特林语言重新编写AOSP桌面时钟应用程序</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/re-writing-the-aosp-deskclock-app-in-kotlin-76c836370cb?source=collection_archive---------0-----------------------#2020-07-16">https://medium.com/androiddevelopers/re-writing-the-aosp-deskclock-app-in-kotlin-76c836370cb?source=collection_archive---------0-----------------------#2020-07-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/af54db00abaa2bd6e09858c62ab8c8aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WtuWfzKmgABivxcqZZ13rg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by Virginia Poltrack</figcaption></figure><div class=""/><p id="5eaa" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android开源项目(AOSP)应用程序的主要目标之一是为开发者提供一个如何构建Android应用程序的范例。作为这一承诺的一部分，AOSP应用的开发考虑到了Android的最佳实践，包括使用<a class="ae js" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>作为他们的开发语言。最近，为了实现这个目标，我们开始将AOSP桌面时钟从Java重构为Kotlin。通过这个过程，我们学到了很多关于开发人员在转换他们自己的应用程序时可以期待什么。本文讨论了在这个过程中遇到的一些障碍，并提供了一些技巧，可以用来减少类似转换的工作量。您还将了解从Java转换到Kotlin的好处，重点关注桌面时钟转换带来的改进。</p><h1 id="7a59" class="jt ju hw bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">为什么是科特林？</h1><p id="6ea6" class="pw-post-body-paragraph iu iv hw iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">我们选择转换AOSP桌面时钟应用程序，部分原因是Kotlin相对于Java的诸多优势，包括:</p><ul class=""><li id="89d7" class="kw kx hw iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">内置的空安全，可以大大减少应用程序中的空指针异常。</li><li id="fdc3" class="kw kx hw iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">简洁，或写更少的代码做更多的工作。</li><li id="d6e5" class="kw kx hw iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">谷歌对Android开发的<a class="ae js" href="https://developer.android.com/kotlin/first" rel="noopener ugc nofollow" target="_blank">“Kotlin-first”支持</a>意味着新的Android开发工具和内容，如<a class="ae js" href="https://developer.android.com/jetpack" rel="noopener ugc nofollow" target="_blank"> Jetpack库</a>和在线培训，将首先考虑kot Lin用户。</li></ul><p id="517f" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，<a class="ae js" href="https://insights.stackoverflow.com/survey/2020#most-loved-dreaded-and-wanted" rel="noopener ugc nofollow" target="_blank">许多开发者调查</a>将Kotlin列为开发者满意度最高的语言之一。当用Kotlin而不是Java来维护代码库时，所有这些好处加在一起会使过程更加顺畅。</p><h1 id="caac" class="jt ju hw bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">转换过程</h1><p id="85fe" class="pw-post-body-paragraph iu iv hw iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated"><a class="ae js" href="https://android.googlesource.com/platform/packages/apps/DeskClock/" rel="noopener ugc nofollow" target="_blank"> DeskClock app </a>相当大，在转换开始前包含160个Java文件，总共31914行代码。由于其规模，代码必须进行增量转换。在AOSP，这是通过创建一个单独的<a class="ae js" href="https://source.android.com/setup/build" rel="noopener ugc nofollow" target="_blank"> Soong </a>构建目标(DeskClockKotlin)来完成的，不包括任何与Kotlin等价的Java文件。Kotlin与Java的互操作性使得这个过程变得简单明了，因为它允许DeskClockKotlin目标在转换相应的Java文件时不断地包含更多的Kotlin文件。</p><p id="cd0f" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第一个转换步骤是从<a class="ae js" href="https://developer.android.com/studio" rel="noopener ugc nofollow" target="_blank"> Android Studio </a>中的Kotlin插件运行<a class="ae js" href="https://developer.android.com/kotlin/add-kotlin#convert" rel="noopener ugc nofollow" target="_blank">自动Kotlin转换工具</a>。这个插件自动将代码从Java转换成Kotlin，通常运行良好，尽管您可能会看到一些常见问题，必须手动纠正，以使Kotlin代码更加习惯和健壮。增量转换一次只针对一小部分应用功能，有助于确保转换代码的正确性。除了手动测试，我们还为DeskClock应用运行了<a class="ae js" href="https://source.android.com/compatibility/cts" rel="noopener ugc nofollow" target="_blank">兼容性测试套件(CTS) </a>，以检查可能的功能退化。</p><h1 id="3c2a" class="jt ju hw bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">要做的手工工作</h1><p id="65de" class="pw-post-body-paragraph iu iv hw iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">在转换过程中，在运行自动转换工具后，我们遇到了一些需要更多手工操作的问题。本节深入讨论了几个更复杂的问题，然后是对其他次要问题的简短总结。</p><h2 id="2c95" class="lk ju hw bd jv ll lm ln jz lo lp lq kd jf lr ls kh jj lt lu kl jn lv lw kp lx bi translated">无法对某些文件运行自动转换</h2><p id="efde" class="pw-post-body-paragraph iu iv hw iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">我们遇到的最耗时的问题之一是无法在某些Java文件上运行Kotlin插件的自动转换工具。这不是一个常见的问题，在转换的前75个文件中只出现过两次。然而，我们确实需要要么用Kotlin完全重写Java代码，要么花时间研究这个问题。</p><p id="989c" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们第一次遇到这个问题是在<a class="ae js" href="https://cs.android.com/android/platform/superproject/+/master:packages/apps/DeskClock/src/com/android/deskclock/provider/ClockDatabaseHelper.java;drc=ff17acface9b98eba868fff0e2d70ddc85c5e4db;l=159" rel="noopener ugc nofollow" target="_blank">ClockDatabaseHelper.java</a>文件中。在该文件中，一个<a class="ae js" rel="noopener" href="/@appmattus/effective-kotlin-item-9-prefer-try-with-resources-to-try-finally-aec8c202c30a"> try-with-resources </a>块导致了这个问题。</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="d271" class="lk ju hw md b fi mh mi l mj mk">try (Cursor cursor = db.query(…)) {<br/>    // some code in here<br/>}</span></pre><p id="cfe6" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个try-with-resources语句在Kotlin中并不存在，尽管它在<code class="du ml mm mn md b"><a class="ae js" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html" rel="noopener ugc nofollow" target="_blank">use</a></code> <a class="ae js" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html" rel="noopener ugc nofollow" target="_blank">函数</a>中有一个对等的语句。Java中的try-with-resources语句处理给定资源不再使用时的释放(即在<code class="du ml mm mn md b">try</code>块之后)。类似地，Kotlin use <em class="mo"> </em>函数接受一个lambda表达式，并在lambda执行后释放调用了use <em class="mo"> </em>的资源。用Kotlin编写代码的一种方法如下:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="36d5" class="lk ju hw md b fi mh mi l mj mk">val cursor = db.query(…)<br/>cursor.use {<br/>   // some code in here<br/>}</span></pre><p id="c357" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">转换器无法自动进行此更改。在这种情况下，我们手动更新Java代码，在<code class="du ml mm mn md b">try</code>块之前声明<code class="du ml mm mn md b">Cursor</code>，而不是在try-with-resources语句中声明，这使得转换工具能够成功运行。</p><p id="41d1" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第二个无法自动转换的文件是<a class="ae js" href="https://cs.android.com/android/platform/superproject/+/master:packages/apps/DeskClock/src/com/android/deskclock/events/LogEventTracker.java;drc=7082447b8073bd4a7dc0c6be99d8461dcd1a6f58;l=46" rel="noopener ugc nofollow" target="_blank">LogEventTracker.java</a>文件。该文件包含如下定义的函数:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="ffa9" class="lk ju hw md b fi mh mi l mj mk">private String safeGetString(<a class="ae js" href="http://twitter.com/StringRes" rel="noopener ugc nofollow" target="_blank">@StringRes</a> int resId) {<br/>    return resId == 0 ? null : mContext.getString(resId);<br/>}</span></pre><p id="fa72" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">转换工具无法处理从该函数返回的三进制表达式<a class="ae js" href="https://kotlinlang.org/docs/reference/control-flow.html#if-expression" rel="noopener ugc nofollow" target="_blank">。这个工具似乎无法推断出相应的Kotlin函数的正确返回类型(本例中为<code class="du ml mm mn md b">String?</code>)。我们手动将该函数重写如下:</a></p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="6456" class="lk ju hw md b fi mh mi l mj mk">private fun safeGetString(<a class="ae js" href="http://twitter.com/StringRes" rel="noopener ugc nofollow" target="_blank">@StringRes</a> resId: Int): String? {<br/>    return if (resId == 0) null else context.getString(resId)<br/>}</span></pre><p id="eb81" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这两种情况下，重写Java代码的人工工作是最少的。但是，当遇到这样的问题时，转换器会跳过整个文件。这意味着对于包含小问题的大文件，在事先不知道根本原因的情况下，需要手动调查问题的来源。</p><p id="1fa2" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们用来发现问题的一种方法是注释掉文件中的大部分代码，然后逐步取消注释代码，直到遇到问题。这可能是一种省时的方法，可以确定哪个代码片段负责。</p><h2 id="b9cd" class="lk ju hw bd jv ll lm ln jz lo lp lq kd jf lr ls kh jj lt lu kl jn lv lw kp lx bi translated">静态常数继承</h2><p id="21de" class="pw-post-body-paragraph iu iv hw iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">我们遇到的另一个复杂问题是Java和Kotlin在继承能力上的差异。这个问题发生在<a class="ae js" href="https://cs.android.com/android/platform/superproject/+/master:packages/apps/DeskClock/src/com/android/deskclock/provider/ClockContract.java" rel="noopener ugc nofollow" target="_blank">ClockContract.java</a>文件中，其中静态常量值是在相互继承的接口中定义的。这本身不是问题。然而，代码库中的许多地方试图通过这些接口的子接口来引用常量，这在Kotlin 中是不可能的。</p><p id="f82a" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Kotlin中定义静态常量以便在Java代码中引用的一种常见方式是在伴随对象中，在这种情况下，在定义常量的接口中。由于增量转换，从Java代码中引用了<code class="du ml mm mn md b">ClockContract</code>接口，所以使用了这种伴随对象方法。Java和Kotlin的区别在于，伴随对象不是从接口的父对象继承的。例如，在接口A的伴随对象中定义的静态常量，其中接口B继承自A，将不能通过调用<code class="du ml mm mn md b">B.CONSTANT_NAME</code>来访问。这种访问方法在Java中可以很好地工作。</p><p id="9162" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了解决这个问题，我们选择用调用定义这些接口的接口中的常量来替换这些接口受影响的用法。继续上一段的例子，我们将改为引用<code class="du ml mm mn md b">A.CONSTANT_NAME</code>，而不是试图引用<code class="du ml mm mn md b">B.CONSTANT_NAME</code>，因为<code class="du ml mm mn md b">CONSTANT_NAME</code>是在接口a中定义的。这个问题也许可以通过改变这些常量继承的整体结构来解决，很可能不使用Kotlin中的接口。然而，所采用的方法实现起来很简单。</p><h2 id="ca1c" class="lk ju hw bd jv ll lm ln jz lo lp lq kd jf lr ls kh jj lt lu kl jn lv lw kp lx bi translated">手动空性修复</h2><p id="a2d7" class="pw-post-body-paragraph iu iv hw iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">在转换过程中出现的另一个常见问题是，在转换后的Kotlin代码中，偶尔会出现可空类型的不准确性。例如，转换后的代码错误地指定函数接受<code class="du ml mm mn md b">String </code>而不是<code class="du ml mm mn md b">String?</code>参数，这可能导致运行时错误。如果转换器工具能够从Java代码中推断出参数或返回类型是否可以为空，那么这些问题就可以避免。您可以用<code class="du ml mm mn md b">@Nullable</code>和<code class="du ml mm mn md b">@NonNull</code>对Java代码进行注释，以向IDE提供做出正确决策所需的信息。否则，可以通过跟踪代码并确定是否有可能接收或返回一个<code class="du ml mm mn md b">null</code>值来手动修复生成的Kotlin中的这些为空性问题。</p><h2 id="d5d1" class="lk ju hw bd jv ll lm ln jz lo lp lq kd jf lr ls kh jj lt lu kl jn lv lw kp lx bi translated">其他问题</h2><p id="4539" class="pw-post-body-paragraph iu iv hw iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">除了这些更复杂的问题，我们在转换过程中还遇到了多个更小的问题。每个问题都有一个快速解决方案，不需要花太多时间。</p><p id="7997" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">生成的Kotlin代码有时包含“===”和“！== "比较两个Int值时。使用“==”或“！=" <a class="ae js" href="https://kotlinlang.org/docs/reference/equality.html#referential-equality" rel="noopener ugc nofollow" target="_blank">足以比较<em class="mo"> Int </em>值</a>。</p><p id="2e55" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Java代码中出现的一些<code class="du ml mm mn md b">@NonNull</code>注释在生成的Kotlin代码中没有被删除。Kotlin不需要这些注释，因为该语言提供了可空性安全，所以它们被移除了。</p><p id="a42e" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有时候，Java函数中的单行注释会出现在生成的Kotlin代码中的两个不同位置。这些注释既出现在它们应该出现的地方，也出现在它们应该出现的函数之外的一般类范围内。我们删除了这些第二个实例。</p><p id="b3d9" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">生成的Kotlin代码排除了等效Java代码中存在的空行。这可能会导致一些函数被分隔成不同的逻辑部分，从而在生成的Kotlin代码中包含所有的行。</p><p id="0eb4" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当接受Long参数的函数被传递一个Int值时，生成的Kotlin代码有时会添加“<code class="du ml mm mn md b">as Long</code>”来尝试将Int <em class="mo"> </em>转换为Long <em class="mo">。</em>然而<a class="ae js" href="https://kotlinlang.org/docs/reference/basic-types.html#explicit-conversions" rel="noopener ugc nofollow" target="_blank">正确的做法</a>是在<code class="du ml mm mn md b">Int</code>上调用<code class="du ml mm mn md b">toLong()</code>。这也适用于其他号码类型(如<code class="du ml mm mn md b">Float</code><em class="mo"/>等)。).</p><p id="d600" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Java中，可以重新分配函数参数。然而，在Kotlin中，函数参数在幕后被定义为<code class="du ml mm mn md b">val</code>，因此不能被重新分配。在为这个场景生成的Kotlin代码中，在与函数参数同名的函数中定义了一个局部变量。为了避免局部变量对参数名称的<a class="ae js" href="https://stackoverflow.com/questions/49680040/why-kotlin-allows-to-declare-variable-with-the-same-name-as-parameter-inside-the" rel="noopener ugc nofollow" target="_blank">遮蔽，重命名局部变量<em class="mo"> </em>可能是有益的，以便通过不在参数和局部变量之间共享相同的名称来增加函数的可读性。</a></p><p id="9bf1" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当带有<code class="du ml mm mn md b">private</code> getter方法的<code class="du ml mm mn md b">private</code> Java属性被转换为Kotlin时，<code class="du ml mm mn md b">private</code>关键字有时会保留在属性的<code class="du ml mm mn md b">get()</code>访问函数上。然而，这是不必要的，因为被声明的属性<code class="du ml mm mn md b">private</code>已经足够了。</p><h1 id="6758" class="jt ju hw bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">快速转换技巧</h1><p id="b520" class="pw-post-body-paragraph iu iv hw iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">以下列表旨在将上述问题的更详细解释快速总结为可操作的项目，以帮助加快转换过程:</p><ul class=""><li id="fe43" class="kw kx hw iw b ix iy jb jc jf ky jj kz jn la jr lb lc ld le bi translated">确保“===”和“！== "用于检查<a class="ae js" href="https://kotlinlang.org/docs/reference/equality.html#referential-equality" rel="noopener ugc nofollow" target="_blank">参考相等</a></li><li id="3c25" class="kw kx hw iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">删除Kotlin代码中的任何<code class="du ml mm mn md b">@NonNull</code>或<code class="du ml mm mn md b">@Nullable</code>注释</li><li id="14e8" class="kw kx hw iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">检查单行注释是否位于所需的位置，并且没有重复</li><li id="6484" class="kw kx hw iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">添加回函数中删除的空行，以匹配Java代码的风格</li><li id="5739" class="kw kx hw iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">修复数值之间任何不正确的转换尝试</li><li id="b257" class="kw kx hw iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">通过重命名隐藏函数参数名称的局部变量来提高代码可读性</li><li id="46c8" class="kw kx hw iw b ix lf jb lg jf lh jj li jn lj jr lb lc ld le bi translated">移除私有属性的<code class="du ml mm mn md b">get()</code>访问器上不必要的<code class="du ml mm mn md b">private</code>关键字</li></ul><h1 id="e714" class="jt ju hw bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结果</h1><p id="6249" class="pw-post-body-paragraph iu iv hw iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">现在，大约一半的桌面时钟应用程序的Java文件已经被转换成Kotlin。我们用15，240行Kotlin代码替换了15，886行Java代码。这些Java文件的转换大约花了一个月的工程时间才完成。通过这个Kotlin转换过程以及本文，AOSP桌面时钟应用程序能够更好地实现其成为Android开发最佳实践范例的目标。</p><p id="06ea" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在将大约一半的DeskClock应用程序转换为Kotlin后，我们已经看到了做同等工作的代码行数的好处。代码的总行数从15，886行减少到15，240行，减少了大约5%。虽然到目前为止这并不是一个巨大的减少，但是随着越来越多的Java文件被转换成Kotlin，一些额外的样板代码可以被删除，因为Kotlin文件与Java文件的交互较少。</p><p id="2e0c" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们还研究了原始Java应用程序和半转换应用程序在构建时间和APK大小上的差异。部分转换的Kotlin应用程序的APK大小为6237217字节，而原始Java应用程序的APK大小为6117353字节。这种非常轻微的大小增加，大约2%，表明Kotlin在应用程序中的引入并没有显著影响APK的大小。当查看这两个版本的应用程序之间的构建时间变化时，Java应用程序的平均构建时间约为33秒，而部分转换的Kotlin应用程序的平均构建时间约为57秒。这些构建时间都是在一台48核、内存为128 GB的机器上执行干净的构建时记录的，没有以前编译过的类文件。</p><p id="8a81" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">除了桌面时钟应用程序转换的结果，其他开发人员也同样看到了转换到Kotlin的好处。<a class="ae js" href="https://developer.android.com/stories/apps/duolingo-kotlin" rel="noopener ugc nofollow" target="_blank"> Duolingo完成了应用程序的完整Kotlin迁移</a>,减少了30%的行数。同样，Google Home应用程序开始将Kotlin整合到他们的代码库中，<a class="ae js" href="https://android-developers.googleblog.com/2020/07/google-home-reduces-1-cause-of-crashes.html" rel="noopener ugc nofollow" target="_blank">减少了33%的NullPointerExceptions</a>。70%的顶级1k应用程序也包含Kotlin代码，60%的专业Android开发人员使用Kotlin。</p><h1 id="6a51" class="jt ju hw bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">后续步骤</h1><p id="8f00" class="pw-post-body-paragraph iu iv hw iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">要了解更多关于Java到Kotlin的Android转换过程，请查看Android上的Kotlin入门文档或面向Java开发人员的to Kotlin路径。如果你想看看代码库，你可以通过跟随<a class="ae js" href="https://source.android.com/setup/build/downloading" rel="noopener ugc nofollow" target="_blank">下载源代码</a>文档来查看AOSP源代码。</p></div></div>    
</body>
</html>