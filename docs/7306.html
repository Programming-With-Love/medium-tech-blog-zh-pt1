<html>
<head>
<title>Migrating to Warmer Times Ahead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迁徙到前方更温暖的时代</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/migrating-to-warmer-times-ahead-a5f6404fb09f?source=collection_archive---------5-----------------------#2018-04-23">https://medium.com/square-corner-blog/migrating-to-warmer-times-ahead-a5f6404fb09f?source=collection_archive---------5-----------------------#2018-04-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie"><p id="fba8" class="if ig hh bd ih ii ij ik il im in io dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae ip" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><figure class="ir is it iu iv iw er es paragraph-image"><div class="er es iq"><img src="../Images/49e52a6333c6e491d06f5fdb7e7d1efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:152/format:webp/1*sGXkL4UyLpoQ7CRpUbpnXw.png"/></div></figure><p id="33ba" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated"><a class="ae ip" href="https://www.trycaviar.com" rel="noopener ugc nofollow" target="_blank"> Caviar的</a>消费者网络前端架构这些年来发生了很大变化。它被构建为一个大型的<a class="ae ip" href="http://rubyonrails.org/" rel="noopener ugc nofollow" target="_blank"> Rails </a>应用程序，使用<a class="ae ip" href="http://slim-lang.com/" rel="noopener ugc nofollow" target="_blank"> Slim </a>作为模板引擎，并添加了<a class="ae ip" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> jQuery </a>和<a class="ae ip" href="http://coffeescript.org/" rel="noopener ugc nofollow" target="_blank"> CoffeeScript </a>来处理客户端逻辑。它们是当时使用它们的人最熟悉的工具。</p><p id="f052" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">随着现代web框架和库的飞速发展，Caviar的代码库和工程师的技能也在飞速发展。我们已经不再使用<a class="ae ip" href="https://github.com/rails/sprockets" rel="noopener ugc nofollow" target="_blank">链轮</a>来将我们的网络资产捆绑到令人惊叹的<a class="ae ip" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>和<a class="ae ip" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank"> Yarn </a>上，并且我们已经不再使用CoffeeScript(感谢一个Square伙伴编写的救命的<a class="ae ip" href="https://github.com/decaffeinate/decaffeinate" rel="noopener ugc nofollow" target="_blank">脱咖啡因</a>工具！)转化为现代的ES6+和<a class="ae ip" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">Babel</a>——同时保持功能性，这对于一个拥有小型工程团队的大型应用程序来说绝非易事。</p><p id="ca26" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">最值得注意的是跟随趋势，将更多的逻辑转移到客户端前端，以利用不断增加的浏览器处理能力。早在2015年初，我们就在代码库中引入了<a class="ae ip" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank">React</a>——当时这还是一项相对较新的技术；如今，流行的开源UI库和现代web开发的核心方面之一。</p><p id="5061" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">React最好也是最核心的部分之一就是它的灵活性。正如医生在其主页上所说:</p><blockquote class="jw jx jy"><p id="3d11" class="iz ja jz jb b jc jd je jf jg jh ji jj ka jl jm jn kb jp jq jr kc jt ju jv io ha bi translated">一次学习，随处写作</p><p id="dafe" class="iz ja jz jb b jc jd je jf jg jh ji jj ka jl jm jn kb jp jq jr kc jt ju jv io ha bi translated">我们不对您的技术堆栈的其余部分做出假设，因此您可以在React中开发新功能，而无需重写现有代码。</p></blockquote><p id="26f4" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">这对我们来说太棒了——我们可以在React中增量地编写新的东西，利用一个高度活跃的社区，并将我们新的和闪亮的组件集成到我们带有便利包<a class="ae ip" href="https://github.com/reactjs/react-rails" rel="noopener ugc nofollow" target="_blank"> react-rails </a>的超薄模板中。我们当时做的选择不会错吧？</p><h1 id="8941" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">问题是</h1><p id="795a" class="pw-post-body-paragraph iz ja hh jb b jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv io ha bi translated">过去几年没有改变的是我们对<a class="ae ip" href="http://fluxxor.com/" rel="noopener ugc nofollow" target="_blank">fluxor</a>的使用。这是一个简洁的小库，实现了<a class="ae ip" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> Flux </a>应用程序架构，用于处理通过应用程序其余部分的数据流。引用官方Flux <a class="ae ip" href="https://facebook.github.io/flux/docs/in-depth-overview.html#content" rel="noopener ugc nofollow" target="_blank"> docs </a>关于该模式如何工作的话:</p><blockquote class="jw jx jy"><p id="1b42" class="iz ja jz jb b jc jd je jf jg jh ji jj ka jl jm jn kb jp jq jr kc jt ju jv io ha bi translated">Flux避开MVC，支持单向数据流。当用户与React视图交互时，视图通过中央调度程序将一个动作传播到保存应用程序数据和业务逻辑的各个存储，从而更新所有受影响的视图。这与React的声明式编程风格配合得特别好，它允许存储发送更新，而无需指定如何在状态之间转换视图。</p></blockquote><figure class="lh li lj lk fd iw er es paragraph-image"><div class="er es lg"><img src="../Images/89bb2dafd5b51481284c2d0a858381a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*D5A9zCx5wfvC6usXrCzXPQ.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Sourced from Fluxxor’s documentation page <a class="ae ip" href="http://fluxxor.com/what-is-flux.html" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="ecba" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">它当时工作得很好，但是随着我们的应用程序变得越来越大，我们在客户端中有越来越多的状态，变得难以跟踪和保持正确——状态的变化使得在出错时调试变得非常困难，并且处理异步调用增加了整个其他级别的复杂性。随着时间的推移，Fluxxor尤其不适合我们的情况:</p><ul class=""><li id="34b3" class="lp lq hh jb b jc jd jg jh jk lr jo ls js lt io lu lv lw lx bi translated">我们的Fluxxor存储(复数)中的突变使得跟踪事情何时发生变化变得异常困难。</li><li id="d8af" class="lp lq hh jb b jc ly jg lz jk ma jo mb js mc io lu lv lw lx bi translated">Fluxxor要求使用mixins，React核心团队的一名开发人员认为这种模式是有害的。这意味着我们仍然依赖React v15和<code class="du md me mf mg b">React.createClass()</code>，这是一个在React v16中已经被弃用的API。</li><li id="3c08" class="lp lq hh jb b jc ly jg lz jk ma jo mb js mc io lu lv lw lx bi translated">自2015年9月<a class="ae ip" href="https://github.com/BinaryMuse/fluxxor/blob/master/build/fluxxor.js" rel="noopener ugc nofollow" target="_blank">日</a>以来，Fluxxor.js库一直没有更新。</li></ul><p id="29ae" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">我们作为一个团队决定转向另一个流行的管理数据流的选项，即屡试不爽的<a class="ae ip" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>。我不会深究为什么人们会选择使用Redux而不是Flux，但是在这里可以找到一个很好的论据<a class="ae ip" href="https://stackoverflow.com/questions/32461229/why-use-redux-over-facebook-flux" rel="noopener ugc nofollow" target="_blank"/>。与Fluxxor相比，Redux有许多明显的优势，包括:</p><ul class=""><li id="6ce8" class="lp lq hh jb b jc jd jg jh jk lr jo ls js lt io lu lv lw lx bi translated">一家店，仅此而已。这使得状态更容易跟踪，而不是将多个不同的存储绑定到不同的flux实例。</li><li id="7067" class="lp lq hh jb b jc ly jg lz jk ma jo mb js mc io lu lv lw lx bi translated">状态是不可变的——当我们的状态改变时，这对我们来说是显而易见的，因为每次任何事情改变时，必须返回一个新的状态对象。</li><li id="2828" class="lp lq hh jb b jc ly jg lz jk ma jo mb js mc io lu lv lw lx bi translated">Redux得到了积极的维护，文档非常优秀，网上有大量关于React和Redux的文章= &gt; Redux生态系统非常简单<a class="ae ip" href="https://redux.js.org/introduction/ecosystem" rel="noopener ugc nofollow" target="_blank">令人惊叹</a>。被困在一个问题上？肯定有一个堆栈溢出帖子或Github问题与这种情况有关。</li></ul><figure class="lh li lj lk fd iw er es paragraph-image"><div class="er es mh"><img src="../Images/6bc931811663eee99aee4d4747766d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*e7jARRKzU2d9lnfpbveTIw.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">The Redux Architecture: <a class="ae ip" href="https://www.safaribooksonline.com/library/view/javascript-by-example/9781788293969/1dfe8989-b67a-428f-bfcd-a667476f2149.xhtml" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><figure class="lh li lj lk fd iw er es paragraph-image"><div class="er es mi"><img src="../Images/8faf7ac281824860b26f35ebdfc53a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*QzC4jXzovsc4Kg_p6dWnag.png"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">How data flows in a React and Redux Application: <a class="ae ip" href="https://www.safaribooksonline.com/library/view/javascript-by-example/9781788293969/1dfe8989-b67a-428f-bfcd-a667476f2149.xhtml" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h1 id="b1e1" class="kd ke hh bd kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la bi translated">迁移过程</h1><p id="a9b2" class="pw-post-body-paragraph iz ja hh jb b jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv io ha bi translated">现在，选择使用Redux后剩下的唯一工作就是实际使用这个库。</p><figure class="lh li lj lk fd iw er es paragraph-image"><div class="er es mv"><img src="../Images/a2a58b2f0431ac609c5a71cf9fdcf975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*AsHeURsUJOnsNw73t8a3SA.gif"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Base gif from <a class="ae ip" href="https://media.giphy.com/media/lQRwl2XKnHJWE/giphy.gif" rel="noopener ugc nofollow" target="_blank">https://media.giphy.com/media/lQRwl2XKnHJWE/giphy.gif</a></figcaption></figure><p id="e6c7" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">一次性迁移整个鱼子酱前端是不可行的。代码库太大了——这将花费太长时间，而且会有太多地方出现错误。</p><p id="387c" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">为了谨慎起见，我们需要找到代码库的独立部分，我们可以在不影响其他部分的情况下重写这些部分。<a class="ae ip" href="https://www.trycaviar.com/for-companies" rel="noopener ugc nofollow" target="_blank"> Caviar for Teams </a>是Caviar的一部分，与整个Caviar代码库相比，它的代码库相对较小，并且体验完全独立于常规的单一用餐者消费者流。</p><p id="73cf" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">为了开始我们的迁移过程，我们需要准确理解Flux在哪里被使用，以及它是如何与我们的应用程序联系在一起的。值得注意的是，我们知道我们必须改变和重构代码库的以下部分:</p><ul class=""><li id="61cf" class="lp lq hh jb b jc jd jg jh jk lr jo ls js lt io lu lv lw lx bi translated">Flux存储:为应用程序域维护数据的对象。</li><li id="26ba" class="lp lq hh jb b jc ly jg lz jk ma jo mb js mc io lu lv lw lx bi translated">磁通异或。Flux类:允许我们访问存储和动作的对象，并管理调度程序。</li><li id="c0ca" class="lp lq hh jb b jc ly jg lz jk ma jo mb js mc io lu lv lw lx bi translated">从焊剂存储中接收状态的组件和容器。</li></ul><p id="4b93" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">对我们来说，从Flux到Redux的粗略和精确转换开始实验是有意义的——事实证明，从<a class="ae ip" href="https://redux.js.org/recipes/migrating-to-redux" rel="noopener ugc nofollow" target="_blank"> Flux到Redux </a>的映射过程相对简单。我们的Flux动作可以映射到一个等价的Redux动作，我们的Flux存储可以映射到Redux reducers，最后，我们的React组件可以重写为使用Redux。</p><p id="0baf" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">我们准备好开始迁移了。</p><figure class="lh li lj lk fd iw er es paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="er es mw"><img src="../Images/4ff93ae8f7a6e7c0eb6a615730012d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZDxkldLz-RIrDHZJ."/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Photo by <a class="ae ip" href="https://unsplash.com/@willpower?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">William Stitt</a> on <a class="ae ip" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h1 id="bced" class="kd ke hh bd kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la bi translated">行动</h1><p id="e865" class="pw-post-body-paragraph iz ja hh jb b jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv io ha bi translated">Redux和Flux中的动作只是指</p><blockquote class="jw jx jy"><p id="ff0e" class="iz ja jz jb b jc jd je jf jg jh ji jj ka jl jm jn kb jp jq jr kc jt ju jv io ha bi translated">…代表改变状态的意图。</p></blockquote><blockquote class="ie"><p id="7db2" class="if ig hh bd ih ii ij ik il im in io dx translated">动作是将数据放入存储的唯一方式。</p></blockquote><blockquote class="jw jx jy"><p id="6528" class="iz ja jz jb b jc nb je jf jg nc ji jj ka nd jm jn kb ne jq jr kc nf ju jv io ha bi translated">…表示在Flux应用程序中执行一些数据操作的意图…</p></blockquote><blockquote class="ie"><p id="106b" class="if ig hh bd ih ii ij ik il im in io dx translated">更新商店的唯一方法是向他们发送操作。</p></blockquote><p id="b90c" class="pw-post-body-paragraph iz ja hh jb b jc nb je jf jg nc ji jj jk nd jm jn jo ne jq jr js nf ju jv io ha bi translated">下面给出了一个在我们的Flux类中如何创建同步和异步动作的例子。</p><figure class="lh li lj lk fd iw"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="63ed" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">我们的React组件包含一个对SampleFlux类的引用，并调用<code class="du md me mf mg b">flux.actions.syncAction(...)</code>和<code class="du md me mf mg b">flux.actions.asyncAction(...)</code>来触发更新Flux存储的调用(下面组件部分中的示例)。</p><p id="cf3d" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">将同步Flux动作映射到Redux动作非常简单；Flux中的函数<code class="du md me mf mg b">syncAction</code>用动作类型和商店的有效负载数据调用<code class="du md me mf mg b">this.dispatch</code>，而Redux中的<code class="du md me mf mg b">syncAction</code>只是返回一个包含类型和有效负载的对象。</p><p id="02a6" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">为了将异步动作映射到我们的Redux动作，我们使用了一个名为<a class="ae ip" href="https://github.com/gaearon/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>的助手库来帮助将我们的异步动作创建器映射到一个可以像同步动作创建器一样被调用的版本中。我们还可以重用我们现有的用于进行HTTP调用的服务。</p><figure class="lh li lj lk fd iw"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="85c4" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">这些动作被绑定到Redux的<code class="du md me mf mg b"><a class="ae ip" href="https://redux.js.org/api-reference/bindactioncreators#somecomponent.js" rel="noopener ugc nofollow" target="_blank">bindActionCreators</a>()</code>函数提供的dispatch函数，并通过React-Redux的<code class="du md me mf mg b"><a class="ae ip" href="https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options" rel="noopener ugc nofollow" target="_blank">connect()</a></code>作为道具传递给组件。通过这样做，只需调用<code class="du md me mf mg b">this.props.syncAction(…)</code>和<code class="du md me mf mg b">this.props.asyncAction(…)</code>来触发Redux存储中的更新，就可以从React组件中分派动作(下面组件部分中的示例)。</p><h1 id="d241" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">还原剂</h1><p id="1e65" class="pw-post-body-paragraph iz ja hh jb b jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv io ha bi translated">Reducers是函数式编程世界中的纯函数。</p><blockquote class="jw jx jy"><p id="cd1e" class="iz ja jz jb b jc jd je jf jg jh ji jj ka jl jm jn kb jp jq jr kc jt ju jv io ha bi translated"><em class="hh">缩减器</em>(也称为<em class="hh">缩减功能</em>)是接受累加值并返回新累加值的功能。它们用于将值集合缩减为单个值。</p><p id="b0dc" class="iz ja jz jb b jc jd je jf jg jh ji jj ka jl jm jn kb jp jq jr kc jt ju jv io ha bi translated">在Redux中，累加的值是状态对象，被累加的值是动作。给定以前的状态和一个动作，Reducers计算新的状态…</p></blockquote><blockquote class="ie"><p id="5083" class="if ig hh bd ih ii ij ik il im in io dx translated">还原器是Redux中最重要的概念。</p></blockquote><p id="07d4" class="pw-post-body-paragraph iz ja hh jb b jc nb je jf jg nc ji jj jk nd jm jn jo ne jq jr js nf ju jv io ha bi translated">将Flux stores中的数据直接从突变转换为Redux reducers并保持不变性肯定比转换动作复杂得多。然而，我们的Flux存储中的许多逻辑可以在我们的reducer中重用，从纯函数的角度考虑状态更新立即使推理变得更容易——我们确切地知道reducer进出了什么，因为它们没有副作用！</p><p id="a62e" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">在我们的Flux存储中，我们初始化我们的状态，并将我们监听的每个动作类型绑定到一个相关的处理函数。在我们的处理函数中，我们改变了状态，并发出一个change事件，用新的状态更新我们的组件。</p><figure class="lh li lj lk fd iw"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="ef1e" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">现在，在Redux中，当reducer监听并接收具有某种动作类型的动作时，它将根据该动作类型执行一个switch语句，并在正确的case语句中执行一些逻辑。根据状态是否改变，缩减器或者返回一个带有更新值的新创建的状态副本，或者返回现有状态以指示没有改变。</p><p id="0168" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">根据存储的复杂程度，我们可以通过reducer组合来分解映射的reducer，以保持逻辑的可读性和清晰性，或者将状态完全分离成两个或更多个reducer，并使用Redux的<code class="du md me mf mg b">combineReducers</code>将较小的reducer组合成一个较大的reducer。这就是我们将通量储备改为减速器的方法。</p><figure class="lh li lj lk fd iw"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="3444" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">Flux store和Redux reducer之间的显著差异包括:</p><ul class=""><li id="5f7d" class="lp lq hh jb b jc jd jg jh jk lr jo ls js lt io lu lv lw lx bi translated">考虑与在Flux架构下直接改变状态相比，如何在Redux架构下将状态视为不可变的。这意味着如果状态已经通过<code class="du md me mf mg b">Object.assign()</code>或扩展操作符<code class="du md me mf mg b">…</code>更新，则总是返回一个新的状态。</li><li id="c14c" class="lp lq hh jb b jc ly jg lz jk ma jo mb js mc io lu lv lw lx bi translated">在Flux中显式发出变更事件的样板文件现在已经不存在了<code class="du md me mf mg b">this.emit('change')</code>！Redux为我们处理发布，所以代码更短，重复性更少。</li></ul><p id="7860" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">在这一点上，我们还添加了<a class="ae ip" href="https://github.com/reactjs/reselect" rel="noopener ugc nofollow" target="_blank">选择器</a>来返回状态的特定部分，并对可以记忆的状态执行计算，以提高性能。</p><h1 id="3775" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">成分</h1><p id="c544" class="pw-post-body-paragraph iz ja hh jb b jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv io ha bi translated">最后但同样重要的是，我们必须重构我们的容器和组件，以从Redux而不是Flux接收状态。在我们的组件通过mixins直接从Flux stores接收状态并到处使用<code class="du md me mf mg b">this.state</code>之前，我们的组件现在将通过Redux的<code class="du md me mf mg b">connect()</code>传递的props接收Redux状态并使用<code class="du md me mf mg b">this.props </code>来代替。</p><p id="b935" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">因此，以下组件与通量相关联—</p><figure class="lh li lj lk fd iw"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="e778" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">变成了以下连接到Redux的组件—</p><figure class="lh li lj lk fd iw"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="59d8" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">我们完事了。将Flux映射到Redux的第一步在我们更新组件后结束，它们已经成功渲染并通过了我们的测试(您应该有很多测试！).</p><figure class="lh li lj lk fd iw er es paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="er es ni"><img src="../Images/8f273612038fa19d8dc0e91c09079b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3Vnm2qb1SQBoChCA."/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Photo by <a class="ae ip" href="https://unsplash.com/@sarti46?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Massimo Sartirana</a> on <a class="ae ip" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><h1 id="5223" class="kd ke hh bd kf kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la bi translated">外卖食品</h1><p id="7047" class="pw-post-body-paragraph iz ja hh jb b jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv io ha bi translated">不变性是如此难以实施！状态对象变得越深，需要做的复制就越多，以确保对需要改变的数据的引用被更新。我遇到了许多奇怪和错误，我的选择器没有更新，组件没有重新呈现，因为状态被意外地改变了，reducers没有返回新的状态对象。</p><p id="8b4c" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">我将<a class="ae ip" href="https://facebook.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> Immutable.js </a>引入到我编写的归约器和选择器中。它保证了我所期望的不变性(哇哦！)，但我注意到一些问题:</p><ul class=""><li id="2c6a" class="lp lq hh jb b jc jd jg jh jk lr jo ls js lt io lu lv lw lx bi translated">Immutable的API对原生JavaScript不太友好。尽管可以用点符号访问常规JS对象的属性，但不可变需要使用特殊的getter ( <code class="du md me mf mg b">.get(), .getIn()</code>)和setter ( <code class="du md me mf mg b">.set(), .setIn(), .merge(), .update()</code>)函数。地图对象。而对于JS对象，人们可以在缩减器中的case语句的末尾做如下事情，</li></ul><pre class="lh li lj lk fd nj mg nk nl aw nm bi"><span id="bc33" class="nn ke hh mg b fi no np l nq nr">[ACTION_TYPE]: (state) =&gt; {<br/>  return {<br/>    ...state,<br/>    someNestedObject: {<br/>      someKey: true,<br/>    },<br/>  };<br/>}</span></pre><p id="ed1a" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">在不可变中，我们必须做一些事情，比如:</p><pre class="lh li lj lk fd nj mg nk nl aw nm bi"><span id="345e" class="nn ke hh mg b fi no np l nq nr">[ACTION_TYPE]: (state) =&gt; {<br/>  return state.setIn(['someNestedObject, 'someKey'], true);<br/>}</span></pre><p id="8252" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">这会变得很棘手。虽然我过去使用过不可变的，现在也很适应，但不是所有的队友都这样，因此有一个必须考虑的陡峭的学习曲线。</p><ul class=""><li id="5aa2" class="lp lq hh jb b jc jd jg jh jk lr jo ls js lt io lu lv lw lx bi translated">不可变引入了大量的范围蔓延。它不仅影响你的reducers和选择器中的几乎所有东西，为了获得库的性能优势，你还应该把不可变的数据结构传递到你的组件中。这是一项艰巨的任务，因为我们的组件期望常规的JS对象和数组，而不是不可变的映射和列表(get/set的API完全不同)。这将需要很长时间来重构我们所有的组件，坦白地说，我们没有足够的资源来做这件事。</li></ul><p id="d26c" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">为了解决这个问题，我们考虑在选择器的末尾使用<code class="du md me mf mg b">.toJS()</code>,这样我们就可以将常规的JS对象和数组传递给我们连接的组件，这样我们就不必修改现有组件中的逻辑。然而，任何对<code class="du md me mf mg b">.toJS()</code>的使用都会对您的应用程序造成性能上的影响，并且首先会消除不可变提供的许多性能优势。</p></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><p id="5c06" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">尽管在我们的整个应用程序中引入Immutable.js会消除一些关于数据可变性的问题，并给我们的组件带来性能上的好处(浅相等检查比深相等检查更快！)，我们最终决定暂时隐藏不可变的，并在将来的另一次访问中重新访问这个库。关于这个非常确切的主题(不可变的. js或不可变的. js)的一个很好的文章和链接集合可以在<a class="ae ip" href="https://redux.js.org/recipes/using-immutable.js-with-redux" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="5165" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">未来的步骤</h1><p id="26b8" class="pw-post-body-paragraph iz ja hh jb b jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv io ha bi translated">既然我们的应用程序正在Redux上工作，是时候开始考虑清理我们的前端架构和设计了。我们需要弄清楚在Redux中存储什么状态(比如全局应用程序状态)，以及将什么状态移动到各个组件(本地化/UI状态)。这意味着要重新设计我们的状态对象，因此我们决定在迁移之后再做这件事。我们还需要开始将大量计算从React组件中移出，并将它们存储在选择器中，以获得进一步的性能提升。</p><p id="7a24" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">将来，我们肯定会考虑添加Immutable.js来处理不可变Redux状态的保证。其他东西还包括持久性(<a class="ae ip" href="https://github.com/rt2zz/redux-persist" rel="noopener ugc nofollow" target="_blank"> redux-persist </a>)、路由(<a class="ae ip" href="https://reacttraining.com/react-router/" rel="noopener ugc nofollow" target="_blank"> react-router </a>)，以及升级到React 16.3以利用新的东西和性能提升(如纤程和新的生命周期方法以及异步渲染，我非常兴奋地使用)！</p><h1 id="7e0f" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">摘要</h1><p id="ebc0" class="pw-post-body-paragraph iz ja hh jb b jc lb je jf jg lc ji jj jk ld jm jn jo le jq jr js lf ju jv io ha bi translated">在这篇博文发表时，Caviar for Teams企业体验已经完全脱离了Flux，转而支持Redux，现在处于一个特性标志之下。在不久的将来，<a class="ae ip" href="https://www.trycaviar.com" rel="noopener ugc nofollow" target="_blank">trycaviar.com</a>的其余部分将慢慢从Flux迁移到Redux，并有望让我们创造和保持用餐者期待和信任我们的愉快体验。</p></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><p id="9626" class="pw-post-body-paragraph iz ja hh jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv io ha bi translated">感谢<a class="ns nt ge" href="https://medium.com/u/b8137d8ad34e?source=post_page-----a5f6404fb09f--------------------------------" rel="noopener" target="_blank">尼尔森·克雷斯波</a>、<a class="ns nt ge" href="https://medium.com/u/c3c6c4d10206?source=post_page-----a5f6404fb09f--------------------------------" rel="noopener" target="_blank">项瑾·邹</a>、<a class="ns nt ge" href="https://medium.com/u/53020358d869?source=post_page-----a5f6404fb09f--------------------------------" rel="noopener" target="_blank">凯斯·朱</a>、梅德琳·昂、<a class="ns nt ge" href="https://medium.com/u/d5b7f179363e?source=post_page-----a5f6404fb09f--------------------------------" rel="noopener" target="_blank">沈婷·陈</a>以及鱼子酱团队的其他成员。</p></div></div>    
</body>
</html>