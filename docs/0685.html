<html>
<head>
<title>Gradle and AGP Build APIs: Taking your plugin to the next step!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">格雷尔和AGP构建API:让你的插件更上一层楼！</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/gradle-and-agp-build-apis-taking-your-plugin-to-the-next-step-95e7bd1cd4c9?source=collection_archive---------2-----------------------#2021-12-01">https://medium.com/androiddevelopers/gradle-and-agp-build-apis-taking-your-plugin-to-the-next-step-95e7bd1cd4c9?source=collection_archive---------2-----------------------#2021-12-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/23c70bdc81b12d7b6cb24dad0ddb0123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WkRft2aAKv19MoIm.jpeg"/></div></div></figure><div class=""/><p id="6037" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">欢迎阅读MAD技能系列中关于Gradle和Android Gradle插件API的一篇新文章。在上一篇文章中，你学习了如何编写自己的插件和使用新的<a class="ae jn" href="https://developer.android.com/studio/build/extend-agp#variant-api-artifacts-tasks" rel="noopener ugc nofollow" target="_blank">变体API </a>。如果你喜欢看而不是读，这里有一些东西可以看看:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="22f7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，您将了解到Gradle任务、提供者、属性以及使用任务输入和输出。您还将进一步开发您的插件，并学习如何使用新的<a class="ae jn" href="https://developer.android.com/studio/build/extend-agp#variant-api-artifacts-tasks" rel="noopener ugc nofollow" target="_blank">构件API </a>访问各种构建构件。</p><h2 id="cf09" class="ju jv hs bd jw jx jy jz ka kb kc kd ke ja kf kg kh je ki kj kk ji kl km kn ko bi translated">性能</h2><p id="1937" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">比方说，我想构建一个插件，它可以用git版本自动更新应用程序清单中指定的版本代码。为此，我需要在我的构建中添加两个任务。第一个任务将获取git版本，第二个任务将使用该git版本更新清单文件。</p><p id="0e5b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从创建一个名为<code class="du ku kv kw kx b">GitVersionTask</code>的新任务开始。这个类需要扩展<code class="du ku kv kw kx b">DefaultTask</code>并实现带注释的<code class="du ku kv kw kx b">taskAction</code>函数。下面是一些查询git树顶端的代码。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="a834" class="ju jv hs kx b fi lc ld l le lf">abstract class GitVersionTask: DefaultTask() {</span><span id="d8ef" class="ju jv hs kx b fi lg ld l le lf">    @TaskAction<br/>    fun taskAction(){<br/>        // this would be the code to get the tip of tree version,<br/>        val process = ProcessBuilder(<br/>            "git", <br/>            "rev-parse --short HEAD"<br/>        ).start()<br/>        val error = process.errorStream.readBytes().toString()<br/>        if (error.isNotBlank()) {<br/>            System.err.println("Git error : $error")<br/>        }<br/>        var gitVersion = process.inputStream.readBytes().toString()</span><span id="eea9" class="ju jv hs kx b fi lg ld l le lf">        //...</span><span id="b8ea" class="ju jv hs kx b fi lg ld l le lf">    }<br/>}</span></pre><p id="1ba6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我不能缓存这个值，我想将版本信息存储在一个中间文件中，以便其他任务可以读取和使用这个值。为此，我需要使用一个<code class="du ku kv kw kx b"><a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/file/RegularFileProperty.html" rel="noopener ugc nofollow" target="_blank">RegularFileProperty</a></code>。属性可用于任务输入和输出。在这种情况下，<code class="du ku kv kw kx b"><a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Property.html" rel="noopener ugc nofollow" target="_blank">Property</a></code>将作为一个容器来表示任务输出。我创建了一个<code class="du ku kv kw kx b">RegularFileProperty</code>，并用<code class="du ku kv kw kx b">@get:OutputFile</code>对其进行了注释。<code class="du ku kv kw kx b"><a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/OutputFile.html" rel="noopener ugc nofollow" target="_blank">OutputFile</a></code>是附加到getter函数的标记注释。这样，<code class="du ku kv kw kx b">Property</code>被标记为该任务的输出文件。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="08d6" class="ju jv hs kx b fi lc ld l le lf">@get:OutputFile<br/>abstract val gitVersionOutputFile: RegularFileProperty</span></pre><p id="ccb9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我已经声明了我的任务输出，让我们跳回到<code class="du ku kv kw kx b">taskAction()</code>中，在那里我可以访问文件并写入我想要存储的文本。在这种情况下，我将存储git版本，它将是该任务的输出。为了简单起见，我用硬编码的字符串替换了git版本查询。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="3d92" class="ju jv hs kx b fi lc ld l le lf">abstract class GitVersionTask: DefaultTask() {<br/>    @get:OutputFile<br/>    abstract val gitVersionOutputFile: RegularFileProperty</span><span id="e757" class="ju jv hs kx b fi lg ld l le lf">    @TaskAction<br/>    fun taskAction() {<br/>        gitVersionOutputFile.get().asFile.writeText("1234")<br/>    }<br/>}</span></pre><p id="6478" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在任务已经准备好了，让我们在插件代码中注册这个任务。首先，我将创建一个名为<code class="du ku kv kw kx b">ExamplePlugin</code>的新插件类，并实现<code class="du ku kv kw kx b"><a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/Plugin.html" rel="noopener ugc nofollow" target="_blank">Plugin</a></code>。如果你不熟悉在<code class="du ku kv kw kx b">buildSrc</code>文件夹中创建插件，一定要看看本系列之前的视频[ <a class="ae jn" rel="noopener" href="/androiddevelopers/gradle-and-agp-build-apis-configure-your-build-9a10db5b2262"> 1 </a> ]、[ <a class="ae jn" rel="noopener" href="/androiddevelopers/gradle-and-agp-build-apis-how-to-write-a-plugin-1695b590e4ec"> 2 </a>。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es lh"><img src="../Images/a7ed3cc94e9d9a4c62d6cda41a114ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*IwdUlP5JgzfSm41ekDglPQ.png"/></div><figcaption class="li lj et er es lk ll bd b be z dx">buildSrc folder</figcaption></figure><p id="5652" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我将注册<code class="du ku kv kw kx b">GitVersionTask</code>，并将输出文件<code class="du ku kv kw kx b">Property</code>设置为构建文件夹中的一个中间文件。我还将<code class="du ku kv kw kx b">upToDateWhen</code>设置为<code class="du ku kv kw kx b">false</code>，这样这个任务以前执行的输出就不会被重用。这也意味着该任务将在每次构建时执行，因为它永远不会是最新的。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="ad86" class="ju jv hs kx b fi lc ld l le lf">override fun apply(project: Project) {<br/>    project.tasks.register(<br/>        "gitVersionProvider", <br/>        GitVersionTask::class.java<br/>    ) {<br/>        it.gitVersionOutputFile.set( <br/>            File(<br/>                project.buildDir,   <br/>                "intermediates/gitVersionProvider/output"<br/>            )<br/>        )<br/>        it.outputs.upToDateWhen { false }<br/>     }</span><span id="29b5" class="ju jv hs kx b fi lg ld l le lf">}</span></pre><p id="8a22" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">执行完任务后，我可以检查<code class="du ku kv kw kx b">build/intermediates</code>文件夹下的<code class="du ku kv kw kx b">output</code>文件，并验证该任务存储了我在任务中硬编码的值。</p><p id="fbed" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们切换到第二个任务，它将更新清单文件中的版本。我调用任务<code class="du ku kv kw kx b">ManifestTransformTask </code>并使用两个<code class="du ku kv kw kx b">RegularFileProperty</code>对象作为这个任务的输入。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="7092" class="ju jv hs kx b fi lc ld l le lf">abstract class ManifestTransformerTask: DefaultTask() {</span><span id="0c19" class="ju jv hs kx b fi lg ld l le lf">    @get:InputFile<br/>    abstract val gitInfoFile: RegularFileProperty</span><span id="e5df" class="ju jv hs kx b fi lg ld l le lf">    @get:InputFile<br/>    abstract val mergedManifest: RegularFileProperty</span><span id="681f" class="ju jv hs kx b fi lg ld l le lf">}</span></pre><p id="4842" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我将使用第一个<code class="du ku kv kw kx b">RegularFileProperty</code>来读取由<code class="du ku kv kw kx b">GitVersionTask</code>生成的输出文件的内容。我将使用第二个<code class="du ku kv kw kx b">RegularFileProperty</code>来读取app的清单文件。接下来，我可以用存储在来自<code class="du ku kv kw kx b">gitInfoFile</code>的<code class="du ku kv kw kx b">gitVersion</code>变量中的版本代码替换清单中的版本代码。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="8e12" class="ju jv hs kx b fi lc ld l le lf">@TaskAction<br/>fun taskAction() {<br/>    val gitVersion = gitInfoFile.get().asFile.readText()<br/>    var manifest = mergedManifest.asFile.get().readText()<br/>    manifest = manifest.replace(<br/>        "android:versionCode=\"1\"",     <br/>        "android:versionCode=\"${gitVersion}\""<br/>    )<br/>    <br/>}</span></pre><p id="1a68" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我可以编写更新的清单了。为此，首先我将为输出创建另一个<code class="du ku kv kw kx b">RegularFileProperty</code>，并用<code class="du ku kv kw kx b">@get:OutputFile</code>对其进行注释。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="88e3" class="ju jv hs kx b fi lc ld l le lf"><strong class="kx ht">@get:OutputFile</strong><br/>abstract val updatedManifest: RegularFileProperty</span></pre><blockquote class="lm ln lo"><p id="fc8a" class="ip iq lp ir b is it iu iv iw ix iy iz lq jb jc jd lr jf jg jh ls jj jk jl jm ha bi translated"><a class="ae jn" href="https://www.google.com/url?q=https://developer.android.com/reference/tools/gradle-api/7.1/com/android/build/api/variant/VariantOutput?hl%3Den%23versionCode:org.gradle.api.provider.Property&amp;sa=D&amp;source=docs&amp;ust=1636756364563000&amp;usg=AOvVaw1QJ3UW-VhsOQ6T_0hhP2ei" rel="noopener ugc nofollow" target="_blank">注意，我实际上可以使用VariantOutput来直接设置versionCode，而不必重写清单，但是我将使用这个示例向您展示如何使用工件转换来获得相同的效果。</a></p></blockquote><p id="ff3a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们回到插件来连接东西。首先我得到了<code class="du ku kv kw kx b"><a class="ae jn" href="https://developer.android.com/reference/tools/gradle-api/7.0/com/android/build/api/extension/AndroidComponentsExtension" rel="noopener ugc nofollow" target="_blank">AndroidComponentsExtension</a></code>。我希望这个新任务在AGP决定创建哪些变量之后运行，但在值被锁定且无法修改之前运行。在<code class="du ku kv kw kx b">onVariants()</code>回调之后是<code class="du ku kv kw kx b">beforeVariants()</code>回调，你可能还记得<a class="ae jn" rel="noopener" href="/androiddevelopers/gradle-and-agp-build-apis-how-to-write-a-plugin-1695b590e4ec">上一篇文章</a>。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="e4ac" class="ju jv hs kx b fi lc ld l le lf">val androidComponents = project.extensions.getByType(<br/>    AndroidComponentsExtension::class.java<br/>)</span><span id="cc1b" class="ju jv hs kx b fi lg ld l le lf">androidComponents.onVariants { variant -&gt;<br/>    //...<br/>}</span></pre><h2 id="0564" class="ju jv hs bd jw jx jy jz ka kb kc kd ke ja kf kg kh je ki kj kk ji kl km kn ko bi translated">提供者</h2><p id="9f25" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">您可以使用<code class="du ku kv kw kx b"><a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Provider.html" rel="noopener ugc nofollow" target="_blank">Provider</a></code> <a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Provider.html" rel="noopener ugc nofollow" target="_blank"> s </a>将<code class="du ku kv kw kx b">Property</code>连接到其他需要执行耗时操作的任务，例如从文件或网络等外部输入中读取数据。</p><p id="f1b4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我先从注册<code class="du ku kv kw kx b">ManifestTransformerTask</code>开始。该任务需要前一任务输出的<code class="du ku kv kw kx b">gitVersionOutput</code>文件。为了访问这个<code class="du ku kv kw kx b">Property</code>，我将使用一个<code class="du ku kv kw kx b">Provider</code>。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="42b4" class="ju jv hs kx b fi lc ld l le lf">val manifestUpdater: TaskProvider = project.tasks.register(<br/>    variant.name + "ManifestUpdater",   <br/>    ManifestTransformerTask::class.java<br/>) {<br/>    it.gitInfoFile.set(<br/>        //...<br/>    )<br/>}</span></pre><p id="75e9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个<code class="du ku kv kw kx b">Provider</code>可以用来访问一个给定类型的值，或者直接通过使用<code class="du ku kv kw kx b"><a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Provider.html#get--" rel="noopener ugc nofollow" target="_blank">get()</a></code>函数，或者通过使用运算符函数如<code class="du ku kv kw kx b"><a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Provider.html#map-org.gradle.api.Transformer-" rel="noopener ugc nofollow" target="_blank">map()</a></code>和<code class="du ku kv kw kx b"><a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Provider.html#flatMap-org.gradle.api.Transformer-" rel="noopener ugc nofollow" target="_blank">flatMap()</a></code>将该值转换成一个新的<code class="du ku kv kw kx b">Provider</code>。当我回头看<code class="du ku kv kw kx b">Property</code>接口时，它实现了<code class="du ku kv kw kx b">Provider</code>接口。您可以在<code class="du ku kv kw kx b">Property</code>上延迟设置值，然后使用<code class="du ku kv kw kx b">Provider</code>延迟访问这些值。</p><p id="4751" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我查看<code class="du ku kv kw kx b"><a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/TaskContainer.html#register-java.lang.String-" rel="noopener ugc nofollow" target="_blank">register()</a></code>函数的返回类型时，它返回给定类型的<code class="du ku kv kw kx b"><a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/TaskProvider.html" rel="noopener ugc nofollow" target="_blank">TaskProvider</a></code>。我将把它分配给新的<code class="du ku kv kw kx b">val</code>。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="de42" class="ju jv hs kx b fi lc ld l le lf"><strong class="kx ht">val gitVersionProvider</strong> = project.tasks.register(<br/>    "gitVersionProvider", <br/>    GitVersionTask::class.java<br/>) {<br/>    it.gitVersionOutputFile.set(<br/>        File(<br/>            project.buildDir, <br/>            "intermediates/gitVersionProvider/output"<br/>        )<br/>     )<br/>     it.outputs.upToDateWhen { false }<br/>}</span></pre><p id="c5ad" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在回到设置<code class="du ku kv kw kx b">ManifestTransformerTask</code>的输入。当我试图将值从<code class="du ku kv kw kx b">Provider</code>映射到输入<code class="du ku kv kw kx b">Property</code>时，我得到一个错误。<code class="du ku kv kw kx b">map()</code>的lambda参数接受一个值，如<code class="du ku kv kw kx b">T</code>，并产生另一个值类型，如<code class="du ku kv kw kx b">S</code>。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lt"><img src="../Images/d0d1c44706951215b05a43620c80a240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oefe6OQ_NFRHcolromJ-DA.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx">Error when using <code class="du ku kv kw kx b">map()</code></figcaption></figure><p id="898d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，在这种情况下，set函数需要一个<code class="du ku kv kw kx b">Provider</code>。我可以使用<code class="du ku kv kw kx b">flatMap()</code>函数，它同样接受一个值，比如<code class="du ku kv kw kx b">T</code>，但是这次产生一个<code class="du ku kv kw kx b">S</code>类型的<code class="du ku kv kw kx b">Provider</code>，而不是直接产生值<code class="du ku kv kw kx b">S</code>。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="9505" class="ju jv hs kx b fi lc ld l le lf">it.gitInfoFile.set(<br/>    gitVersionProvider.<strong class="kx ht">flatMap</strong>(<br/>        GitVersionTask::gitVersionOutputFile<br/>    )<br/>)</span></pre><h2 id="7999" class="ju jv hs bd jw jx jy jz ka kb kc kd ke ja kf kg kh je ki kj kk ji kl km kn ko bi translated">转换</h2><p id="7d86" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">接下来，我需要告诉这个变体的工件使用<code class="du ku kv kw kx b">manifestUpdater</code>，并将清单作为输入，将更新后的清单作为输出。最后，我调用<code class="du ku kv kw kx b"><a class="ae jn" href="https://developer.android.com/reference/tools/gradle-api/7.1/com/android/build/api/artifact/InAndOutFileOperationRequest#toTransform(com.android.build.api.artifact.InAndOutFileOperationRequest.toTransform.ArtifactTypeT)" rel="noopener ugc nofollow" target="_blank">toTransform()</a></code>函数来转换单个工件类型。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="1587" class="ju jv hs kx b fi lc ld l le lf">variant.artifacts.use(manifestUpdater)<br/>   .wiredWithFiles(<br/>       ManifestTransformerTask::mergedManifest,<br/>       ManifestTransformerTask::updatedManifest<br/>   ).<strong class="kx ht">toTransform</strong>(SingleArtifact.MERGED_MANIFEST)</span></pre><p id="a252" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我运行这个任务时，我可以看到应用程序清单中的版本代码现在用<code class="du ku kv kw kx b">gitVersion</code>文件中的值更新了。注意，我没有明确要求<code class="du ku kv kw kx b">GitProviderTask</code>运行。执行<code class="du ku kv kw kx b">GitProviderTask</code>是因为这个任务的输出被用作我请求运行的<code class="du ku kv kw kx b">ManifestTransformerTask</code>的输入。</p><h2 id="17cb" class="ju jv hs bd jw jx jy jz ka kb kc kd ke ja kf kg kh je ki kj kk ji kl km kn ko bi translated">BuiltArtifactsLoader</h2><p id="5b2f" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">让我们添加另一个任务，看看如何访问更新后的清单，并验证它是否更新成功。我将创建一个名为<code class="du ku kv kw kx b">VerifyManifestTask</code>的新任务。为了读取清单，我需要访问APK文件，这是构建任务的一个工件。为此，我需要将构建APK文件夹设置为该任务的输入。</p><p id="9af1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意这一次我使用了<code class="du ku kv kw kx b"><a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/file/DirectoryProperty.html" rel="noopener ugc nofollow" target="_blank">DirectoryProperty</a></code>而不是<code class="du ku kv kw kx b"><a class="ae jn" href="https://docs.gradle.org/current/javadoc/org/gradle/api/file/RegularFileProperty.html" rel="noopener ugc nofollow" target="_blank">FileProperty</a></code>，因为<code class="du ku kv kw kx b"><a class="ae jn" href="https://developer.android.com/reference/tools/gradle-api/7.0/com/android/build/api/artifact/SingleArtifact.APK" rel="noopener ugc nofollow" target="_blank">SingleArticfact.APK</a></code>对象表示构建后APK文件所在的目录。</p><p id="9a55" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为该任务的第二个输入，我需要另一个类型为<code class="du ku kv kw kx b"><a class="ae jn" href="https://developer.android.com/reference/tools/gradle-api/7.0/com/android/build/api/variant/BuiltArtifactsLoader" rel="noopener ugc nofollow" target="_blank">BuiltArtifactsLoader</a></code>的<code class="du ku kv kw kx b">Property</code>，我将使用它从描述APK目录中文件的元数据文件中加载<code class="du ku kv kw kx b"><a class="ae jn" href="https://developer.android.com/reference/tools/gradle-api/7.0/com/android/build/api/variant/BuiltArtifacts" rel="noopener ugc nofollow" target="_blank">BuiltArtifacts</a></code>实例。当您拥有本地组件、各种语言等等时，构建可以产生几个apk。<code class="du ku kv kw kx b">BuiltArtifactsLoader</code>抽象出识别每个apk的过程以及它们的属性，如ABI和语言。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="38f3" class="ju jv hs kx b fi lc ld l le lf">@get:Internal<br/>abstract val builtArtifactsLoader: Property&lt;BuiltArtifactsLoader&gt;</span></pre><p id="368c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在是执行任务的时候了。首先我加载<code class="du ku kv kw kx b">buildArtifacts</code>，确保它只包含一个APK，然后加载这个APK作为一个<code class="du ku kv kw kx b">File</code>实例。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="8da0" class="ju jv hs kx b fi lc ld l le lf">val builtArtifacts = builtArtifactsLoader.get().load(<br/>    apkFolder.get()<br/>)?: throw RuntimeException("Cannot load APKs")</span><span id="c4de" class="ju jv hs kx b fi lg ld l le lf">if (builtArtifacts.elements.size != 1)<br/>   throw RuntimeException("Expected one APK !")</span><span id="5c20" class="ju jv hs kx b fi lg ld l le lf">val apk = File(builtArtifacts.elements.single().outputFile).toPath()</span></pre><p id="62d8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此时，我可以访问APK中的清单，并验证版本是否已更新。为了简单起见，我只检查APK是否存在，在这里添加一个检查清单的提示并打印一条成功消息。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="e123" class="ju jv hs kx b fi lc ld l le lf">println("Insert code to verify manifest file in ${apk}")<br/>println("SUCCESS")</span></pre><p id="2fa1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在回到插件代码来注册这个任务。在插件代码中，我将新任务注册为<code class="du ku kv kw kx b">Verifier</code>，传入APK文件夹和当前变体工件的<code class="du ku kv kw kx b">buildArtifactLoader</code>对象。</p><pre class="jo jp jq jr fd ky kx kz la aw lb bi"><span id="03d8" class="ju jv hs kx b fi lc ld l le lf">project.tasks.register(<br/>    variant.name + "Verifier", <br/>    VerifyManifestTask::class.java<br/>) {<br/>    it.apkFolder.set(variant.artifacts.get(SingleArtifact.APK))<br/>    it.builtArtifactsLoader.set(<br/>        variant.artifacts.getBuiltArtifactsLoader()<br/>    )<br/>}</span></pre><p id="4e06" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这一次，当我运行任务时，我可以看到新任务加载了APK并打印了成功消息。注意，我没有明确地请求清单转换发生，但是因为<code class="du ku kv kw kx b">VerifierTask</code>请求了清单工件的最终版本，转换自动发生了。</p><h2 id="f806" class="ju jv hs bd jw jx jy jz ka kb kc kd ke ja kf kg kh je ki kj kk ji kl km kn ko bi translated">摘要</h2><p id="2564" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">我的<a class="ae jn" href="https://github.com/android/gradle-recipes/blob/agp-7.1/BuildSrc/manifestUpdaterTest/buildSrc/src/main/kotlin/ExamplePlugin.kt" rel="noopener ugc nofollow" target="_blank">插件</a>有三个任务:我的插件<a class="ae jn" href="https://github.com/android/gradle-recipes/blob/agp-7.1/BuildSrc/manifestUpdaterTest/buildSrc/src/main/kotlin/GitVersion.kt" rel="noopener ugc nofollow" target="_blank">首先检查</a>当前git版本树，并将版本存储在中间文件中。<a class="ae jn" href="https://github.com/android/gradle-recipes/blob/agp-7.1/BuildSrc/manifestUpdaterTest/buildSrc/src/main/kotlin/ManifestTransformerTask.kt" rel="noopener ugc nofollow" target="_blank">接下来</a>，我的插件使用这个任务的输出，使用一个提供者用版本代码更新当前清单。<a class="ae jn" href="https://github.com/android/gradle-recipes/blob/agp-7.1/BuildSrc/manifestUpdaterTest/buildSrc/src/main/kotlin/VerifyManifestTask.kt" rel="noopener ugc nofollow" target="_blank">最后</a>，我的插件使用另一个任务来访问构建工件并检查清单是否更新。</p><p id="ddc4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就是这样！从7.0版本开始，Android Gradle插件提供了官方扩展点，这样你就可以编写自己的插件了！有了这些新的API，您可以控制构建输入，读取、修改甚至替换中间和最终的工件。</p><p id="2b22" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要了解更多并保持构建高效，请确保查看<a class="ae jn" href="https://developer.android.com/studio/build/extend-agp" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae jn" href="https://github.com/android/gradle-recipes" rel="noopener ugc nofollow" target="_blank">配方</a>。</p></div></div>    
</body>
</html>