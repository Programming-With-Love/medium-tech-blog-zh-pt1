<html>
<head>
<title>All about Proto DataStore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于原始数据存储的所有信息</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/all-about-proto-datastore-1b1af6cd2879?source=collection_archive---------2-----------------------#2022-01-31">https://medium.com/androiddevelopers/all-about-proto-datastore-1b1af6cd2879?source=collection_archive---------2-----------------------#2022-01-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/b6b4fbababc3e21bb09fb33126f1ce92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UtNu7pmbt3WEA213SW9p9Q.png"/></div></div></figure><div class=""/><p id="882a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本帖中，我们将了解两个<a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7">数据存储实现</a>之一的<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore#datastore-typed" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">原型数据存储</strong> </a>。我们将讨论如何<strong class="ir ht">创建它，读取和写入数据，以及如何处理异常</strong>，以更好地理解使Proto成为最佳选择的场景。</p><p id="b40a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Proto DataStore使用由<a class="ae jn" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">协议缓冲区</strong> </a>支持的类型化对象来存储较小的数据集，同时提供<strong class="ir ht">类型安全。</strong>它消除了使用键值对的需要，使其<strong class="ir ht">在结构上</strong>不同于其<code class="du jo jp jq jr b">SharedPreferences</code>前身及其兄弟实现<a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-preferences-datastore-cc7995679334">首选项数据存储</a>。然而，这还不是全部——数据存储为<strong class="ir ht">带来了</strong>超过<code class="du jo jp jq jr b">SharedPreferences</code>的许多其他改进。请随意快速跳回我们<a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7"> <strong class="ir ht">系列的第一篇文章</strong> </a>，看看我们在那里做的详细比较。接下来，除非另有说明，我们将把<code class="du jo jp jq jr b">Proto DataStore</code>简称为<code class="du jo jp jq jr b">Proto</code>。</p><p id="df79" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总而言之:</p><ul class=""><li id="80fe" class="js jt hs ir b is it iw ix ja ju je jv ji jw jm jx jy jz ka bi translated">提供一个完全异步的API来检索和保存数据，使用Kotlin协同程序的能力</li><li id="ecb5" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><strong class="ir ht">不提供现成的同步支持</strong>——它直接避免做任何阻塞UI线程的工作</li><li id="35b0" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated">依赖于Flow的内部错误信号机制，允许您在读取或写入数据时安全地<strong class="ir ht">捕捉和处理异常</strong></li><li id="3c57" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated">在<strong class="ir ht">原子读取-修改-写入操作</strong>中安全处理数据更新，提供强大的<a class="ae jn" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank"> ACID </a>保证</li><li id="c822" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated">允许<strong class="ir ht">轻松简单的数据迁移</strong></li><li id="0ed8" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated">需要<strong class="ir ht">全类型安全</strong>并且你的数据需要处理更多的<strong class="ir ht">复杂类</strong>，比如枚举或列表？这对于<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore#datastore-preferences" rel="noopener ugc nofollow" target="_blank">偏好</a>是不可能的，所以选择<strong class="ir ht">原型</strong>来代替</li></ul><h1 id="9afd" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">协议缓冲区介绍</h1><p id="7238" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">要使用Proto DataStore，您需要熟悉<a class="ae jn" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">协议缓冲区</strong></a><strong class="ir ht"/>——一种语言中立、平台中立的机制，用于<strong class="ir ht">序列化结构化数据</strong>。它比XML更快、更小、更简单、更明确，并且比其他类似的数据格式更容易阅读。</p><p id="8cfb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您定义了一个关于您希望如何构建数据的模式，并指定了一些选项，比如使用哪种语言来生成代码。然后，编译器根据您的规范生成类。这让你可以轻松地从各种数据流中读写结构化数据，在不同平台间共享，使用多种不同的语言，如<a class="ae jn" href="https://developers.google.com/protocol-buffers/docs/kotlintutorial" rel="noopener ugc nofollow" target="_blank">科特林</a>。</p><p id="bd90" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">.proto</code>文件中某些数据的模式示例:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="5fbd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如何使用生成的Kotlin代码构建您的数据模型:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="2657" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者，您可以尝试新发布的<a class="ae jn" href="https://developers.googleblog.com/2021/11/announcing-kotlin-support-for-protocol.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> Kotlin DSL对协议缓冲区的支持</strong> </a>，以更习惯的方式构建您的数据模型:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="e1ec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">投入更多的时间来学习这种新的序列化机制绝对是值得的，因为它带来了<strong class="ir ht">类型安全性、改进的可读性和整体代码简单性</strong>。</p><h1 id="2f8b" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">原始数据存储依赖关系设置</h1><p id="d54a" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">现在让我们看一些代码，了解一下<strong class="ir ht"> Proto </strong>是如何工作的。</p><p id="68fb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将使用<a class="ae jn" href="https://github.com/googlecodelabs/android-datastore/tree/proto_datastore" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">Proto DataStore</strong></a>codelab示例。如果您对更具实践性的实施方法感兴趣，我们真的鼓励您自己完成使用Proto DataStore codelab  的<a class="ae jn" href="https://developer.android.com/codelabs/android-proto-datastore#0" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">。</strong></a></p><p id="3c56" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个示例应用程序显示了一个任务列表，用户可以选择按照任务的完成状态进行过滤，或者按照优先级和截止日期进行排序。我们希望存储他们的选择—一个用于显示已完成任务的<strong class="ir ht">布尔值</strong>和一个在Proto中的<strong class="ir ht">排序顺序枚举</strong>。</p><p id="15be" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将首先添加Proto依赖项和一些基本的protobuf设置到你的模块的<code class="du jo jp jq jr b">build.gradle</code>。如果你对Protobuf编译的更高级定制感兴趣，请查看Gradle notes  的<a class="ae jn" href="https://github.com/google/protobuf-gradle-plugin" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> Protobuf插件:</strong></a></p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><blockquote class="lp lq lr"><p id="f126" class="ip iq ls ir b is it iu iv iw ix iy iz lt jb jc jd lu jf jg jh lv jj jk jl jm ha bi translated"><em class="hs">💡快速提示——如果您想缩小您的构建，请确保在您的</em> <code class="du jo jp jq jr b"><em class="hs">proguard-rules.pro</em></code> <em class="hs">文件中添加一个额外的规则，以防止您的字段被删除:</em></p></blockquote><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="6e48" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">Proto DataStore的Protobuf设置</h1><p id="e2a9" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">我们的Proto之旅从在一个<code class="du jo jp jq jr b">.proto</code>文件中定义你的<strong class="ir ht">持久化数据</strong>的结构开始。可以把它想象成你的可读模式和编译器的蓝图。我们将命名我们的<code class="du jo jp jq jr b">user_prefs.proto</code>，并将其添加到<code class="du jo jp jq jr b">app/src/main/proto</code>目录中。</p><p id="31d7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">遵循<a class="ae jn" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank"> Protobuf语言指南</a>，在这个文件中我们将为我们想要序列化的每个数据结构添加一个<strong class="ir ht">消息，然后为消息中的每个字段指定一个<strong class="ir ht">名称</strong>和一个<strong class="ir ht">类型</strong>。为了有助于形象化，让我们看一下Kotlin数据类和相应的protobuf模式。</strong></p><p id="7e2d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">UserPreferences</code> —科特林数据类别:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="a31b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">UserPreferences</code> — <code class="du jo jp jq jr b"> .proto </code>模式:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="55cc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您以前没有使用过protobufs，您可能也会对模式中的前几行感到好奇。让我们来分解一下:</p><ul class=""><li id="2d9f" class="js jt hs ir b is it iw ix ja ju je jv ji jw jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">syntax</code> —指定您正在使用<code class="du jo jp jq jr b"><a class="ae jn" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank">proto3</a></code>语法</li><li id="c558" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">java_package</code> —为您生成的类指定<strong class="ir ht">包声明</strong>的文件选项，这有助于防止不同项目之间的<strong class="ir ht">命名冲突</strong></li><li id="4f80" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">java_multiple_files</code> —文件选项，指定是否仅为该<code class="du jo jp jq jr b">.proto</code>生成具有嵌套子类的<strong class="ir ht">单个文件</strong>(设置为false时)，或者是否为每个顶级消息类型生成<strong class="ir ht">单独的文件</strong>(设置为true时)；默认情况下，它为假</li></ul><p id="ddf3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来是我们的消息定义。消息是一个包含<strong class="ir ht">一组类型化字段</strong>的集合。许多标准的简单数据类型可以作为字段类型，包括<code class="du jo jp jq jr b">bool</code>、<code class="du jo jp jq jr b">int32</code>、<code class="du jo jp jq jr b">float</code>、double和<code class="du jo jp jq jr b">string</code>。您还可以通过使用<strong class="ir ht">其他消息类型作为字段类型</strong>来为您的消息添加进一步的结构，就像我们对<code class="du jo jp jq jr b">SortOrder</code>所做的那样。</p><p id="8486" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个元素上的<code class="du jo jp jq jr b">= 1</code>、<code class="du jo jp jq jr b">= 2</code>标记标识字段在二进制编码中使用的唯一“标签”——就像一个排序ID。<strong class="ir ht">一旦您的消息类型被使用，这些号码就不能更改。</strong></p><p id="b0fa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您在<code class="du jo jp jq jr b">.proto,</code>上运行协议缓冲编译器时，编译器会以您选择的语言生成代码。在我们的具体例子中，当编译器运行时，这将导致在您的应用程序的<code class="du jo jp jq jr b">build/generated/source/proto</code> …目录中生成<code class="du jo jp jq jr b">UserPreferences</code>类:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><blockquote class="lp lq lr"><p id="c86c" class="ip iq ls ir b is it iu iv iw ix iy iz lt jb jc jd lu jf jg jh lv jj jk jl jm ha bi translated"><em class="hs">💡快速提示——您还可以尝试新发布的</em> <a class="ae jn" href="https://developers.googleblog.com/2021/11/announcing-kotlin-support-for-protocol.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> <em class="hs"> Kotlin DSL对协议缓冲区的支持</em> </strong> </a> <em class="hs">，以使用更习惯的方式构建您的数据模型。</em></p></blockquote><p id="524b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们已经有了<code class="du jo jp jq jr b">UserPreferences</code>，我们需要指定<strong class="ir ht">指南</strong>来说明Proto应该如何读写它们。我们通过数据存储库<code class="du jo jp jq jr b">Serializer</code>来做到这一点，数据存储库决定了数据存储时的最终格式<strong class="ir ht">以及如何正确地访问它。这需要覆盖:</strong></p><ul class=""><li id="61ed" class="js jt hs ir b is it iw ix ja ju je jv ji jw jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">defaultValue</code> —找不到数据返回什么</li><li id="6d50" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">writeTo </code> —如何将我们的数据对象的内存表示转换成适合存储的格式</li><li id="9fd6" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">readFrom</code> —与上述相反，如何从存储格式转换成相应的内存表示</li></ul><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="28ba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了尽可能保证代码的安全，<strong class="ir ht">处理</strong> <code class="du jo jp jq jr b"><strong class="ir ht">CorruptionException</strong></code>以避免当文件由于格式损坏而无法反序列化时令人不快的意外。</p><blockquote class="lp lq lr"><p id="dff3" class="ip iq ls ir b is it iu iv iw ix iy iz lt jb jc jd lu jf jg jh lv jj jk jl jm ha bi translated"><em class="hs">💡快速提示—如果在任何时候您的AS都找不到任何与</em> <code class="du jo jp jq jr b"><em class="hs">UserPreferences</em></code> <em class="hs">相关的东西，</em> <strong class="ir ht"> <em class="hs">清理并重建</em> </strong> <em class="hs">您的项目以启动protobuf类的生成。</em></p></blockquote><h1 id="cfc9" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">创建原型数据存储</h1><p id="70a8" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">您通过一个<code class="du jo jp jq jr b">DataStore&lt;UserPreferences&gt;</code>实例与Proto交互。<code class="du jo jp jq jr b">DataStore</code>是<strong class="ir ht">授权访问持久化信息</strong>的接口，在我们的例子中是以生成的<code class="du jo jp jq jr b">UserPreferences</code>的形式。</p><p id="d6e0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要创建这个实例，建议使用委托<code class="du jo jp jq jr b">dataStore</code>并传递强制的<code class="du jo jp jq jr b">fileName</code>和<code class="du jo jp jq jr b">serializer</code>参数:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="ee56" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">fileName</code>用于创建一个<code class="du jo jp jq jr b">File</code>用于存储数据。这就是为什么<code class="du jo jp jq jr b">dataStore</code>委托是一个<a class="ae jn" href="https://kotlinlang.org/docs/extensions.html#extension-properties" rel="noopener ugc nofollow" target="_blank"> Kotlin扩展属性</a>，它的接收者类型必须是<code class="du jo jp jq jr b">Context</code>的实例，因为这是通过<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/training/data-storage/app-specific#internal-access-store-files" rel="noopener ugc nofollow" target="_blank">applicationContext.filesDir</a></code>创建文件所需要的。避免在Proto之外以任何方式使用该文件，因为这会破坏数据的一致性。</p><p id="0246" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du jo jp jq jr b">dataStore</code>委托中，您可以再传递一个可选参数— <code class="du jo jp jq jr b">corruptionHandler</code>。当<strong class="ir ht">数据无法反序列化</strong>时，如果序列化程序抛出<code class="du jo jp jq jr b">CorruptionException</code>，则调用该处理程序。<code class="du jo jp jq jr b">corruptionHandler</code>然后会指示Proto如何替换损坏的数据:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="22b1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您不应该为一个给定文件创建多个数据存储实例，<strong class="ir ht">因为这样做会破坏所有数据存储功能。</strong>因此，您可以在Kotlin文件的顶层添加一次委托构造，并在整个应用程序中使用它，以便将其作为<strong class="ir ht"> singleton </strong>传递。在后面的文章中，我们将看到如何通过依赖注入来实现这一点。</p><h1 id="b671" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">读取数据</h1><p id="043c" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">为了读取存储的数据，在<code class="du jo jp jq jr b">UserPreferencesRepository</code>中，我们从<code class="du jo jp jq jr b">userPreferencesStore.data</code>暴露一个<code class="du jo jp jq jr b">Flow&lt;UserPreferences&gt; </code>。这提供了对<strong class="ir ht">最新保存状态</strong>的有效访问，并且<strong class="ir ht">随着每次改变</strong>而发出。这是Proto的<strong class="ir ht">最大优势</strong>之一——你的<code class="du jo jp jq jr b">Flow</code>的值已经以生成的<code class="du jo jp jq jr b">UserPreferences</code>的形式出现。这意味着<strong class="ir ht">您不需要像使用<code class="du jo jp jq jr b">SharedPreferences</code>或<code class="du jo jp jq jr b">Preferences DataStore</code>那样，从保存的数据到Kotlin数据类模型做任何额外的转换</strong>:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="fab1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当试图从磁盘中读取时，该流将总是发出一个值或者<strong class="ir ht">抛出一个异常</strong>。我们将在后面的章节中研究异常处理。DataStore还确保工作总是在<code class="du jo jp jq jr b"><strong class="ir ht">Dispatchers.IO</strong></code>上执行，所以您的UI线程不会被阻塞。</p><p id="7ace" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">🚨<strong class="ir ht">不要创建任何缓存存储库</strong>来镜像您的原始数据的当前状态。这样做会使DataStore对数据一致性的保证失效。如果您需要您的数据的单个快照，而不订阅进一步的流发射，则首选使用<code class="du jo jp jq jr b"><strong class="ir ht">userPreferencesStore.data</strong>.<a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html" rel="noopener ugc nofollow" target="_blank">first()</a></code>:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h1 id="d464" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">写入数据</h1><p id="5429" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">对于写数据，我们将使用一个暂停<code class="du jo jp jq jr b">DataStore&lt;UserPreferences&gt;.updateData(transform: suspend (t: T) -&gt; T)</code>函数。</p><p id="0085" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们来分解一下:</p><ul class=""><li id="0943" class="js jt hs ir b is it iw ix ja ju je jv ji jw jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">DataStore&lt;UserPreferences&gt;</code>接口——我们目前使用<code class="du jo jp jq jr b">userPreferencesStore</code>作为具体的原型实现</li><li id="220a" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">transform: suspend (t: T) -&gt; T) </code> —一个挂起块，用于将指定的更改应用到我们的T类型的持久化数据</li></ul><p id="2ed6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同样，您可能会注意到与<code class="du jo jp jq jr b">Preferences DataStore</code>的不同之处，它依赖于使用<code class="du jo jp jq jr b">Preferences</code>和<code class="du jo jp jq jr b">MutablePreferences</code>，类似于<code class="du jo jp jq jr b">Map</code>和<code class="du jo jp jq jr b">MutableMap</code>，作为默认的数据表示。</p><p id="db74" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在可以用它来改变我们的<code class="du jo jp jq jr b">showCompleted</code>布尔值。<strong class="ir ht">协议缓冲区也简化了这一过程</strong>，消除了与数据类之间的任何手动转换需求:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="4b1b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有几个步骤需要分析:</p><ul class=""><li id="97b5" class="js jt hs ir b is it iw ix ja ju je jv ji jw jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">toBuilder() </code>——获取我们的<code class="du jo jp jq jr b">currentPreferences</code>的<code class="du jo jp jq jr b">Builder</code>版本，该版本“解锁”它以进行更改</li><li id="5c91" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">.setShowCompleted(completed)</code> —设置新值</li><li id="f28b" class="js jt hs ir b is kb iw kc ja kd je ke ji kf jm jx jy jz ka bi translated"><code class="du jo jp jq jr b">.build()</code> —通过将其转换回<code class="du jo jp jq jr b">UserPreferences</code>来完成更新过程</li></ul><p id="998d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<a class="ae jn" href="https://en.wikipedia.org/wiki/Read%E2%80%93modify%E2%80%93write" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">原子读-修改-写操作</strong> </a>中以事务方式完成数据更新。这意味着数据处理操作的特定顺序保证了<strong class="ir ht">一致性</strong>和<strong class="ir ht">防止竞争条件</strong>，在此期间数据被其他线程锁定。只有在<code class="du jo jp jq jr b">transform</code>和<code class="du jo jp jq jr b">updateData</code>协程成功完成后，数据才会持久保存到磁盘，并且<code class="du jo jp jq jr b">userPreferencesStore.data</code>流会反映更新。</p><p id="868e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">🚨请记住，这是更改数据存储状态的唯一方式。保留一个<code class="du jo jp jq jr b">UserPreferences</code>引用并在<code class="du jo jp jq jr b">transform</code>完成<strong class="ir ht">后手动改变它不会改变Proto中的持久化数据</strong>，所以你不应该试图在<code class="du jo jp jq jr b">transform</code>块之外修改<code class="du jo jp jq jr b">UserPreferences</code>。</p><p id="898f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果写入操作由于任何原因失败，事务将被中止并引发异常。</p><h1 id="7c12" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">从SharedPreferences迁移</h1><p id="0873" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">如果你之前已经在你的应用中使用了<code class="du jo jp jq jr b">SharedPreferences</code>，并且想要安全地将其数据传输到Proto，你可以使用<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/datastore/migrations/SharedPreferencesMigration" rel="noopener ugc nofollow" target="_blank">SharedPreferencesMigration</a></code>。它需要一个上下文、<code class="du jo jp jq jr b">SharedPreferences</code>名称和一个关于如何将<code class="du jo jp jq jr b">SharedPreferences</code>键值对转换成<code class="du jo jp jq jr b">migrate</code>参数中的<code class="du jo jp jq jr b">UserPreferences</code>的指令。通过<code class="du jo jp jq jr b">dataStore</code>委托的<code class="du jo jp jq jr b">produceMigrations</code>参数传递它，以便于迁移:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="d6b7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个例子中，我们经历了构建<code class="du jo jp jq jr b">UserPreferences</code>并将其<code class="du jo jp jq jr b">sortOrder</code>设置为先前存储在相应的<code class="du jo jp jq jr b">SharedPreferences</code>键-值对中的值，或者简单地默认为NONE。</p><p id="e010" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">produceMigrations</code>将确保<code class="du jo jp jq jr b">migrate() </code>在对数据存储库的任何潜在数据访问之前运行<strong class="ir ht">。这意味着您的迁移<strong class="ir ht">必须在数据存储发出任何进一步的值之前和开始对数据进行任何新的更改之前成功完成</strong>。一旦你成功迁移，停止使用<code class="du jo jp jq jr b">SharedPreferences</code>是安全的，因为键<strong class="ir ht">只被迁移一次</strong>，然后<strong class="ir ht">从<code class="du jo jp jq jr b">SharedPreferences</code>中移除</strong>。</strong></p><p id="6373" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">produceMigrations</code>接受<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/datastore/core/DataMigration" rel="noopener ugc nofollow" target="_blank">DataMigration</a></code>的列表。我们将在后面的章节中看到如何将它用于其他类型的数据迁移。如果不需要迁移，可以忽略这一点，因为它已经有了一个默认的<strong class="ir ht"/><code class="du jo jp jq jr b"><strong class="ir ht">listOf()</strong></code><strong class="ir ht">提供的</strong>。</p><h1 id="002f" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">异常处理</h1><p id="cd67" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">DataStore相对于<code class="du jo jp jq jr b">SharedPreferences</code>的一个主要优势是其用于捕获和处理异常的<strong class="ir ht">简洁机制</strong>。虽然<code class="du jo jp jq jr b">SharedPreferences</code>将解析错误作为运行时异常抛出，为意外的、未捕获的崩溃留出了空间，但是当读/写数据发生错误时，数据存储抛出<code class="du jo jp jq jr b"><strong class="ir ht">IOException</strong></code>。</p><p id="dc85" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以通过使用<code class="du jo jp jq jr b">catch()</code>流操作符并发出<code class="du jo jp jq jr b">getDefaultInstance()</code>来安全地处理这个问题:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="c42a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者用简单的<code class="du jo jp jq jr b">try-catch </code>块书写:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="f421" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果抛出了不同类型的异常，最好重新抛出。</p><h1 id="ed67" class="kg kh hs bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">待续</h1><p id="ed1e" class="pw-post-body-paragraph ip iq hs ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">我们已经介绍了<a class="ae jn" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">协议缓冲区</strong> </a> <strong class="ir ht"> </strong>和<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/datastore?gclid=CjwKCAiA55mPBhBOEiwANmzoQtX8aFaxx5WFTDOpYVN429tF3U8X3BnZu8ZMfJhRqGtyme_PzaypHhoCQDsQAvD_BwE&amp;gclsrc=aw.ds#datastore-typed" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">数据存储的Proto </strong> </a>实现——何时以及如何使用它来读写数据，如何处理错误以及如何从<code class="du jo jp jq jr b">SharedPreferences</code>迁移。在下一篇也是最后一篇文章中，我们将更进一步，看看数据存储如何适应你的<strong class="ir ht">应用的架构</strong>、<strong class="ir ht">如何用柄</strong>注入它，当然还有<strong class="ir ht">如何测试它</strong>。回头见！</p><p id="5376" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在这里找到我们的Jetpack数据存储系列的所有帖子:<br/><a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-jetpack-datastore-3dc8d74139e7">Jetpack数据存储简介</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-preferences-datastore-cc7995679334">所有关于首选项数据存储</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/all-about-proto-datastore-1b1af6cd2879">所有关于原型数据存储</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-dependency-injection-ea32b95704e3">数据存储和依赖注入</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-kotlin-serialization-8b25bf0be66c">数据存储和Kotlin序列化</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-synchronous-work-576f3869ec4c">数据存储和同步工作</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-data-migration-fdca806eb1aa">数据存储和数据迁移</a> <br/> <a class="ae jn" rel="noopener" href="/androiddevelopers/datastore-and-testing-edf7ae8df3d8">数据存储和测试</a></p></div></div>    
</body>
</html>