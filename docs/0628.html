<html>
<head>
<title>Navigation: Conditional Navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">导航:条件导航</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/navigation-conditional-navigation-e82d7e4905f0?source=collection_archive---------4-----------------------#2021-04-26">https://medium.com/androiddevelopers/navigation-conditional-navigation-e82d7e4905f0?source=collection_archive---------4-----------------------#2021-04-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/78243efcf455993e6100439f3f7a559a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7S7LKg4TlrMRlneeP224Q.jpeg"/></div></div></figure><div class=""/><p id="0df9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是导航系列的第二篇文章。如果你更喜欢看这些内容而不是阅读，看看下面的视频:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="jr js l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Conditional Navigation</figcaption></figure><h1 id="61c7" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">介绍</h1><p id="4264" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">在上一篇文章中，我使用了<code class="du la lb lc ld b">NavigationUI</code>，在应用程序中实现了底部导航，还添加了一个<code class="du la lb lc ld b">SelectionFragment</code>来启用或禁用咖啡跟踪。然而，无论我们禁用还是启用咖啡跟踪器，用户仍然可以导航到看起来不太正确的<code class="du la lb lc ld b">CoffeeList</code>片段。</p><p id="f9fd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我将通过添加条件导航并指导用户在第一次启动应用程序时做出选择来解决这个问题。我将使用<a class="ae le" href="https://developer.android.com/topic/libraries/architecture/datastore" rel="noopener ugc nofollow" target="_blank">数据存储API </a>来保存用户的选择，并使用它来决定在底部导航中显示<code class="du la lb lc ld b">coffeeList</code>目的地。</p><h1 id="9711" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">为条件导航准备应用程序</h1><p id="0a9a" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">这里是对我自上一篇文章以来所做的<a class="ae le" href="https://github.com/google-developer-training/android-demos/tree/starter/DonutTracker/ConditionalNavigation" rel="noopener ugc nofollow" target="_blank">改变</a>的快速回顾。</p><ul class=""><li id="c00e" class="lf lg hs ir b is it iw ix ja lh je li ji lj jm lk ll lm ln bi translated">首先，我添加了一个<code class="du la lb lc ld b"><a class="ae le" href="https://github.com/google-developer-training/android-demos/blob/starter/DonutTracker/ConditionalNavigation/app/src/main/java/com/android/samples/donuttracker/UserPreferencesRepository.kt" rel="noopener ugc nofollow" target="_blank">UserPreferencesRepository</a></code>，它使用数据存储API来保存用户的选择。</li><li id="6c68" class="lf lg hs ir b is lo iw lp ja lq je lr ji ls jm lk ll lm ln bi translated">为了访问存储库，我对ViewModelFactories以及如何构造<code class="du la lb lc ld b"><a class="ae le" href="https://github.com/google-developer-training/android-demos/blob/starter/DonutTracker/ConditionalNavigation/app/src/main/java/com/android/samples/donuttracker/donut/DonutListViewModel.kt" rel="noopener ugc nofollow" target="_blank">DonutListViewModel</a></code>和<code class="du la lb lc ld b"><a class="ae le" href="https://github.com/google-developer-training/android-demos/blob/starter/DonutTracker/ConditionalNavigation/app/src/main/java/com/android/samples/donuttracker/setup/SelectionViewModel.kt" rel="noopener ugc nofollow" target="_blank">SelectionViewModel</a></code>做了一些更改。</li></ul><p id="79e3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想回顾这些变化，你可以在这里查看回购<a class="ae le" href="https://github.com/google-developer-training/android-demos/tree/starter/DonutTracker/ConditionalNavigation" rel="noopener ugc nofollow" target="_blank"/>。如果您想继续学习，也可以查看这个回购的代码！</p><p id="39a3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该应用程序现在可以在3个不同的状态。</p><ul class=""><li id="ba9c" class="lf lg hs ir b is it iw ix ja lh je li ji lj jm lk ll lm ln bi translated"><code class="du la lb lc ld b">DONUT_ONLY</code>，表示用户禁用了咖啡跟踪功能</li><li id="c8f4" class="lf lg hs ir b is lo iw lp ja lq je lr ji ls jm lk ll lm ln bi translated"><code class="du la lb lc ld b">DONUT_AND_COFFEE</code>，这意味着用户想要跟踪甜甜圈和咖啡的消费</li><li id="19be" class="lf lg hs ir b is lo iw lp ja lq je lr ji ls jm lk ll lm ln bi translated"><code class="du la lb lc ld b">NOT_SELECTED</code>这意味着用户还没有做出选择，可能是第一次运行应用<em class="lt">或者他们只是很难下定决心</em>🤷</li></ul><h1 id="6530" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">实现条件导航</h1><p id="261e" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">我将开始在SelectionFragment中实现条件导航。首先，我获得了selectionViewModel的一个实例，因此我可以访问数据存储。接下来，我观察用户的选择，并使用它来恢复复选框的状态。为了持久化用户的选择，我将通过调用<code class="du la lb lc ld b">saveCoffeeTrackerSelection()</code>来更新复选框被点击时的状态。</p><pre class="jn jo jp jq fd lu ld lv lw aw lx bi"><span id="8e66" class="ly jy hs ld b fi lz ma l mb mc"><strong class="ld ht">val selectionViewModel: SelectionViewModel by viewModels {<br/>    SelectionViewModelFactory(<br/>        UserPreferencesRepository.getInstance(requireContext())<br/>    )<br/>}</strong></span><span id="124f" class="ly jy hs ld b fi md ma l mb mc"><strong class="ld ht">selectionViewModel.checkCoffeeTrackerEnabled().observe(<br/>    viewLifecycleOwner<br/>) { selection -&gt;<br/>    if (selection == UserPrefRepository.Selection.DONUT_AND_COFFEE){<br/>        binding.checkBox.isChecked = true<br/>    }<br/>}</strong></span><span id="6d8f" class="ly jy hs ld b fi md ma l mb mc">binding.button.setOnClickListener { button -&gt;<br/>    <strong class="ld ht">val coffeeSelected = binding.checkBox.isChecked                <br/>    selectionViewModel.saveCoffeeTrackerSelection(coffeeSelected)</strong><br/>    //...</span></pre><p id="71ea" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在是时候用用户的选择来更新底部的选项卡了。如果用户选择禁用咖啡跟踪，底部标签中剩下的唯一选项将是<code class="du la lb lc ld b">donutList</code>，这意味着我们可以安全地删除底部标签。在<code class="du la lb lc ld b">MainActivity</code>中，我添加了一个观察者并更新了底部标签的可见性。为此，我将添加一个观察者，并根据用户选择更新<code class="du la lb lc ld b">BottomNavigation</code>的可见性。</p><pre class="jn jo jp jq fd lu ld lv lw aw lx bi"><span id="3fb1" class="ly jy hs ld b fi lz ma l mb mc">private fun setupMenu(<br/>    selection: UserPreferencesRepository.Selection<br/>) {<br/>    val bottomNav = findViewById&lt;BottomNavigationView&gt;(R.id.bottom_nav_view)<br/>    bottomNav.isVisible = when (selection) {<br/>        UserPreferencesRepository.Selection.DONUT_AND_COFFEE -&gt; true<br/>        else -&gt; false<br/>    }<br/>}</span></pre><p id="8513" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在onCreate()中:</p><pre class="jn jo jp jq fd lu ld lv lw aw lx bi"><span id="4142" class="ly jy hs ld b fi lz ma l mb mc">val selectionViewModel: SelectionViewModel by viewModels {<br/>    SelectionViewModelFactory(<br/>        UserPreferencesRepository.getInstance(this)<br/>    )<br/>}</span><span id="20ce" class="ly jy hs ld b fi md ma l mb mc">selectionViewModel.checkCoffeeTrackerEnabled().observe(this) { s -&gt;<br/>    setupMenu(s)<br/>}</span></pre><p id="17a6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种状态下运行应用程序，你会看到启用或禁用咖啡跟踪器会添加或删除应用程序的底部标签。这很棒，但如果我们在用户第一次运行应用程序时自动让他们做出选择，这不是很好吗？</p><p id="ad33" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du la lb lc ld b">DonutList</code>是默认片段，也是我们的开始目的地，这意味着应用程序总是以<code class="du la lb lc ld b">DonutList</code>开始，我检查用户之前是否做了选择，如果没有，则触发导航到<code class="du la lb lc ld b">SelectionFragment</code>。</p><pre class="jn jo jp jq fd lu ld lv lw aw lx bi"><span id="eb35" class="ly jy hs ld b fi lz ma l mb mc">donutListViewModel.isFirstRun().observe(viewLifecycleOwner) { s -&gt;<br/>    if (s == UserPreferencesRepository.Selection.NOT_SELECTED) {<br/>        val navController = findNavController()<br/>        navController.navigate(<br/>            DonutListDirections.actionDonutListToSelectionFragment()<br/>        )<br/>    }<br/>}</span></pre><p id="d7a6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我测试之前，我从设备上卸载了应用程序，这样我就可以确定没有保存我之前运行的偏好设置。现在，当我运行应用程序时，它会将我带到<code class="du la lb lc ld b">selectionFragment</code>。以后启动该应用程序时，它会记住我所做的选择，并引导我到达正确的起始目的地。</p><p id="3892" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就是这样！我们在甜甜圈跟踪器应用程序中添加了条件导航。但是我们如何测试这个流程呢？每次运行测试之前删除应用程序或应用程序数据并不理想。这就是测试拯救的地方！</p><h1 id="efae" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">测试导航</h1><p id="6b74" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">我在androidTestFolder中创建了一个名为<code class="du la lb lc ld b">OneTimeFlowTest</code>的新测试。然后我创建一个名为<code class="du la lb lc ld b">testFirstRun()</code>的测试，并用<code class="du la lb lc ld b">@Test</code>对其进行注释。现在我可以开始实现测试了。首先我通过使用<code class="du la lb lc ld b">applicationContext</code>创建一个<code class="du la lb lc ld b">TestNavHostController() </code>。我还将应用程序中的<code class="du la lb lc ld b">nav_graph</code>设置为我刚刚创建的<code class="du la lb lc ld b">testNavigationController</code>实例。</p><pre class="jn jo jp jq fd lu ld lv lw aw lx bi"><span id="d866" class="ly jy hs ld b fi lz ma l mb mc">@Test<br/>fun testFirstRun() {<br/>    // Create a mock NavController<br/>    val mockNavController = TestNavHostController(<br/>        ApplicationProvider.getApplicationContext()<br/>    )</span><span id="f358" class="ly jy hs ld b fi md ma l mb mc">    mockNavController.setGraph(R.navigation.nav_graph)</span><span id="64df" class="ly jy hs ld b fi md ma l mb mc">    //...<br/>}</span></pre><p id="cff4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du la lb lc ld b">mockNavigationController</code>已经可以使用了。是时候创建场景了。为此，我用<code class="du la lb lc ld b">DonutList</code>片段启动应用程序，并设置我之前创建的<code class="du la lb lc ld b">mockNavigationController</code>实例。然后检查app是否如预期自动导航到<code class="du la lb lc ld b">selectionFragment</code>。</p><pre class="jn jo jp jq fd lu ld lv lw aw lx bi"><span id="5b0e" class="ly jy hs ld b fi lz ma l mb mc">val scenario = launchFragmentInContainer {<br/>    DonutList().also { fragment -&gt;<br/>        fragment.viewLifecycleOwnerLiveData.observeForever{   <br/>            viewLifecycleOwner -&gt;<br/>            if (viewLifecycleOwner != null){<br/>                Navigation.setViewNavController(<br/>                    fragment.requireView(), <br/>                    mockNavController<br/>                )<br/>            }<br/>        }<br/>    }<br/>}</span><span id="4510" class="ly jy hs ld b fi md ma l mb mc">scenario.onFragment {<br/>    assertThat(<br/>        mockNavController.currentDestination?.id<br/>    ).isEqualTo(R.id.selectionFragment)<br/>}</span></pre><p id="09b4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我运行测试并等待结果…测试成功通过了！<em class="lt">或者井可能只是绿色的</em>。</p><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es me"><img src="../Images/a1db1e4e9b3d79b45531f5fde10481e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pt3F5xop_U6K2GdVmDg7iQ.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Testing Navigation</figcaption></figure><h1 id="c3e7" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">摘要</h1><p id="de24" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">在本文中，我在DonutTracker应用程序中添加了条件导航，还添加了一个测试来验证流程是否有效！你可以点击查看解决方案代码<a class="ae le" href="https://github.com/google-developer-training/android-demos/tree/main/DonutTracker/ConditionalNavigation" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5842" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过条件导航，甜甜圈追踪器应用程序将在用户第一次启动应用程序时触发一次性流程，将用户带到选择片段。如果用户选择禁用咖啡跟踪器，应用程序会从导航菜单中移除<code class="du la lb lc ld b">coffeeList</code>。</p><p id="9484" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样，咖啡跟踪器的功能就完成了！在接下来的文章中，我们将学习如何使用嵌套图和模块化这个应用程序。</p></div></div>    
</body>
</html>