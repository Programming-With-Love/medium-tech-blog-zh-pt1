<html>
<head>
<title>Anything Java can do Kotlin can do better</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java能做的任何事情Kotlin都能做得更好</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/anything-java-can-do-kotlin-can-do-better-a1c1ddae8ffd?source=collection_archive---------0-----------------------#2017-08-18">https://medium.com/pinterest-engineering/anything-java-can-do-kotlin-can-do-better-a1c1ddae8ffd?source=collection_archive---------0-----------------------#2017-08-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="ac06" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Zach Westlake | Pinterest工程师，核心体验</p><p id="2d71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然最近有很多关于Kotlin的讨论，但你可能仍然会问自己为什么要使用它。Kotlin做了哪些Java做不到的事情？对任何新技术保持健康的怀疑态度是有好处的。</p><p id="7548" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是Kotlin的秘密在于——这种语言本身基本上不会做Java做不到的事情。只要有足够的技巧，Kotlin做的很多事情都可以在Java中复制。的确，您可以从头开始编写所有代码，而忽略Kotlin添加到开发环境中的过多工具和有用的附加功能。很多应用不使用Kotlin和ship就可以了。然而，Kotlin比Java做得更好的是通过使代码简单易读来加速开发，同时消除一些您习惯编写的样板代码。</p><p id="85c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我们将关注两个特别有用的领域:Kotlin中的属性和可空性。</p><h2 id="0e62" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated"><strong class="ak">属性</strong></h2><p id="a86d" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">让我们从用户模型开始，这是一个你可能在一个新的应用程序中创建的常见模型。用户模型有两个字段，电子邮件地址(即字符串)和用户年龄(例如整数)。在Java中，您可能习惯于将它写出来，或者让您喜欢的IDE自动生成它。下面是Java中的一个例子:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="6a44" class="jc jd hh kh b fi kl km l kn ko">public final class User {</span><span id="31cf" class="jc jd hh kh b fi kp km l kn ko"> @NotNull</span><span id="002e" class="jc jd hh kh b fi kp km l kn ko"> private final String email;</span><span id="8d3c" class="jc jd hh kh b fi kp km l kn ko"> private final int age;<br/></span><span id="4405" class="jc jd hh kh b fi kp km l kn ko"> public User(@NotNull String email, int age) {</span><span id="b405" class="jc jd hh kh b fi kp km l kn ko">  if (email == null) {</span><span id="5949" class="jc jd hh kh b fi kp km l kn ko">   throw new RuntimeException("Email can't be null");</span><span id="ec4a" class="jc jd hh kh b fi kp km l kn ko">  }</span><span id="5122" class="jc jd hh kh b fi kp km l kn ko">  super();</span><span id="5e9b" class="jc jd hh kh b fi kp km l kn ko">  this.email = email;</span><span id="7020" class="jc jd hh kh b fi kp km l kn ko">  this.age = age;</span><span id="8f47" class="jc jd hh kh b fi kp km l kn ko"> }</span><span id="1282" class="jc jd hh kh b fi kp km l kn ko"> @NotNull</span><span id="e75b" class="jc jd hh kh b fi kp km l kn ko"> public final String getEmail() {</span><span id="c537" class="jc jd hh kh b fi kp km l kn ko">  return this.email;</span><span id="32ea" class="jc jd hh kh b fi kp km l kn ko"> }</span><span id="306c" class="jc jd hh kh b fi kp km l kn ko"> public final int getAge() {</span><span id="e889" class="jc jd hh kh b fi kp km l kn ko">  return this.age;</span><span id="e8bd" class="jc jd hh kh b fi kp km l kn ko"> }</span><span id="b09e" class="jc jd hh kh b fi kp km l kn ko"> public String toString() {</span><span id="bef0" class="jc jd hh kh b fi kp km l kn ko">  return "User(email=" + this.email + ", age=" + this.age + ")";</span><span id="b5d6" class="jc jd hh kh b fi kp km l kn ko"> }</span><span id="7a4b" class="jc jd hh kh b fi kp km l kn ko"> public int hashCode() {</span><span id="fa5e" class="jc jd hh kh b fi kp km l kn ko">  return (this.email != null ? this.email.hashCode() : 0) * 31 + this.age;</span><span id="c105" class="jc jd hh kh b fi kp km l kn ko"> }</span><span id="171b" class="jc jd hh kh b fi kp km l kn ko"> @NotNull</span><span id="7a01" class="jc jd hh kh b fi kp km l kn ko"> public final User copy(@NotNull String email, int age) {</span><span id="3e6a" class="jc jd hh kh b fi kp km l kn ko">  Intrinsics.checkParameterIsNotNull(email, "email");</span><span id="eeb3" class="jc jd hh kh b fi kp km l kn ko">  return new User(email, age);</span><span id="fb19" class="jc jd hh kh b fi kp km l kn ko"> }</span><span id="2ef4" class="jc jd hh kh b fi kp km l kn ko"> public boolean equals(Object otherObject) {</span><span id="3567" class="jc jd hh kh b fi kp km l kn ko">  if(this != otherObject) {</span><span id="7da0" class="jc jd hh kh b fi kp km l kn ko">   if(otherObject instanceof User) {</span><span id="164f" class="jc jd hh kh b fi kp km l kn ko">    User otherUser = (User)otherObject;</span><span id="2304" class="jc jd hh kh b fi kp km l kn ko">    if(this.email.equals(otherUser.email) &amp;&amp; this.age == otherUser.age) {</span><span id="3a79" class="jc jd hh kh b fi kp km l kn ko">     return true;</span><span id="0fcb" class="jc jd hh kh b fi kp km l kn ko">   }</span><span id="d6b3" class="jc jd hh kh b fi kp km l kn ko">  }</span><span id="9e92" class="jc jd hh kh b fi kp km l kn ko">   return false;</span><span id="5705" class="jc jd hh kh b fi kp km l kn ko">  } else {</span><span id="0d6d" class="jc jd hh kh b fi kp km l kn ko">   return true;</span><span id="d8b3" class="jc jd hh kh b fi kp km l kn ko">  }</span><span id="ab5f" class="jc jd hh kh b fi kp km l kn ko"> }</span><span id="302f" class="jc jd hh kh b fi kp km l kn ko">}</span></pre><p id="31eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建用户模型所需的getters、setters和equal函数大约需要50行代码。现在让我们在科特林做吧。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="80ec" class="jc jd hh kh b fi kl km l kn ko">data class <strong class="kh hi">User</strong>(val email: String, val age: Int)</span></pre><p id="83a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总的来说，Kotlin以简单取胜，只有一行代码。这不是错误，这也不是vim golf——它在功能上与Java代码完全相同。事实上，从技术上讲，这并不是100%正确的，因为Kotlin代码还保护开发人员在编译时不会意外地将email作为空值传递。</p><h2 id="b1d1" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated"><strong class="ak">可空性</strong></h2><p id="0a0e" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">让我们继续讨论可空性。在这种情况下，Kotlin在类型系统中内置了null。这到底是什么意思？当你在Kotlin中定义一个对象时，你必须指定你是否允许它为空，因为默认情况下，对象是不可空的。</p><p id="6688" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，让我们用Java编写一个简单的日志类，它需要用户的电子邮件来记录事件。</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="ec21" class="jc jd hh kh b fi kl km l kn ko"><strong class="kh hi">public</strong> <strong class="kh hi">class</strong> <strong class="kh hi">LoggingClass</strong> {</span><span id="8a36" class="jc jd hh kh b fi kp km l kn ko"> <strong class="kh hi">private</strong> <strong class="kh hi">final</strong> User myUser;</span><span id="130a" class="jc jd hh kh b fi kp km l kn ko"> <strong class="kh hi">public</strong> <strong class="kh hi">LoggingClass</strong>(User myUser) {<br/>  <strong class="kh hi">this</strong>.myUser = myUser;<br/> }</span><span id="97a7" class="jc jd hh kh b fi kp km l kn ko"> <strong class="kh hi">public</strong> <strong class="kh hi">void</strong> <strong class="kh hi">logEvent</strong>(String eventName) {<br/>  String userEmail = myUser.getEmail();<br/>  AnalyticsClient.logEvent(eventName, userEmail);<br/> }<br/> <br/>}</span></pre><p id="82d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此Java代码的问题是，如果myUser为空，调用logEvent可能会导致NullPointerException，从而导致崩溃，所以您尝试修复它:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="bcfa" class="jc jd hh kh b fi kl km l kn ko"><strong class="kh hi">public</strong> <strong class="kh hi">class</strong> <strong class="kh hi">LoggingClass</strong> {</span><span id="bf9e" class="jc jd hh kh b fi kp km l kn ko"> <strong class="kh hi">private</strong> <strong class="kh hi">final</strong> User myUser;</span><span id="8e4b" class="jc jd hh kh b fi kp km l kn ko"> <strong class="kh hi">public</strong> <strong class="kh hi">LoggingClass</strong>(User myUser) {<br/>  <strong class="kh hi">this</strong>.myUser = myUser;<br/> }</span><span id="9e9d" class="jc jd hh kh b fi kp km l kn ko"> <strong class="kh hi">public</strong> <strong class="kh hi">void</strong> <strong class="kh hi">logEvent</strong>(String eventName) {<br/>  <strong class="kh hi">if (myUser != null) {<br/></strong>   String userEmail = myUser.getEmail();<br/>   AnalyticsClient.logEvent(eventName, userEmail);<br/>  <strong class="kh hi">}</strong><br/> }<br/> <br/>}</span></pre><p id="1d3b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们诚实的话，我们都在某个时候见过或做过这种事。虽然这是一个快速的短期解决方案，但从长远来看，你只是把问题越拖越远。崩溃已经修复，但问题仍然存在，现在只是静静地失败，副作用是我们不再正确地记录事件，可能会导致痛苦的调试会话，试图找出原因。</p><p id="32cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们用Kotlin写同样的类:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="68f9" class="jc jd hh kh b fi kl km l kn ko"><strong class="kh hi">class</strong> <strong class="kh hi">LoggingClass</strong>(<strong class="kh hi">private</strong> <strong class="kh hi">val</strong> <strong class="kh hi">myUser</strong>: <strong class="kh hi">User</strong>) {</span><span id="679b" class="jc jd hh kh b fi kp km l kn ko"> fun <strong class="kh hi">logEvent</strong>(eventName: String) {<br/>  val userEmail = myUser.email<br/>  AnalyticsClient.logEvent(eventName, userEmail)<br/> }</span><span id="3eaf" class="jc jd hh kh b fi kp km l kn ko">}</span></pre><p id="9874" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个例子中，如果传递给它的用户模型可能为null，那么(在正常情况下)就不可能编译这个应用程序。Kotlin的一个优点是编译器会在这里生成一个错误，防止您创建一个NullPointerException。</p><figure class="kc kd ke kf fd kr er es paragraph-image"><div class="er es kq"><img src="../Images/cb9be70dde3170ae475c43c7d9a9d193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*X1btx5-Dxz6f4wEKgjvT0g.png"/></div></figure><p id="bbd1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如上所示，编译器不允许我们将一个可能为null的用户传递给记录器。这意味着您不必担心用户对象为空，并且您可以通过保护空值来编写日志记录类，而不必担心用户模型的状态。</p><p id="cd9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么Kotlin在这里做什么来强制一个不能为空的值呢？让我们反编译我们的Kotlin代码来看看。除了编译时检查，Kotlin还增加了运行时检查:</p><pre class="kc kd ke kf fd kg kh ki kj aw kk bi"><span id="e33d" class="jc jd hh kh b fi kl km l kn ko"><strong class="kh hi">public</strong> <strong class="kh hi">LoggingClass</strong>(@NotNull User myUser) {<br/> Intrinsics.checkParameterIsNotNull(myUser, “myUser”);<br/> <strong class="kh hi">super</strong>();<br/> <strong class="kh hi">this</strong>.myUser = myUser;<br/>}</span></pre><p id="6c84" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以轻松地创建自己的util类，在运行时用Java实现这一点，并通过足够的技巧编写一个linter，在编译时提供帮助，或者您可以使用Kotlin轻松地免费获得它。</p><h2 id="72fa" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated"><strong class="ak">结论</strong></h2><p id="3979" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">Kotlin使开发人员能够编写更少的代码，从而减少错误、节省时间和减轻压力。开发人员可以花更少的时间编写样板代码或修复NullPointerExceptions，并将更多的时间用于产品创新和为用户提供更好的体验。</p><figure class="kc kd ke kf fd kr er es paragraph-image"><div class="er es ku"><img src="../Images/c2e708437034ef3a06c845ca00e483ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:290/format:webp/1*VS-SIyipZqIIfQYxAvva3A.png"/></div></figure></div><div class="ab cl kv kw go kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ha hb hc hd he"><p id="0c27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lc">这是我们关于科特林系列的第三篇文章。看看这些其他的:</em></p><ul class=""><li id="1944" class="ld le hh ig b ih ii il im ip lf it lg ix lh jb li lj lk ll bi translated"><a class="ae lm" rel="noopener" href="/@Pinterest_Engineering/kotlin-for-grumpy-java-developers-8e90875cb6ab"> <em class="lc"> Kotlin针对脾气暴躁的Java开发者</em> </a></li><li id="86d8" class="ld le hh ig b ih ln il lo ip lp it lq ix lr jb li lj lk ll bi translated"><a class="ae lm" rel="noopener" href="/@Pinterest_Engineering/the-case-against-kotlin-2c574cb87953"> <em class="lc">诉科特林案</em> </a></li></ul></div></div>    
</body>
</html>