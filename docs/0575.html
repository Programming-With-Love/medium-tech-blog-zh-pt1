<html>
<head>
<title>Breaking down destructuring declarations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分解析构声明</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/breaking-down-destructuring-declarations-e21334ac1e9?source=collection_archive---------0-----------------------#2020-10-27">https://medium.com/androiddevelopers/breaking-down-destructuring-declarations-e21334ac1e9?source=collection_archive---------0-----------------------#2020-10-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f1f064469350b2336414178de85f7e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0QJqxE7mPdvAWzGCdat6g.png"/></div></div></figure><div class=""/><div class=""><h2 id="7f64" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">科特林词汇——解构</h2></div><p id="8c21" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">有时你只想分解一个包含多个字段的对象来初始化几个独立的变量。要实现这一点，可以使用Kotlin的析构声明。请继续阅读，了解如何使用这个特性，默认情况下Kotlin类型提供了哪些特性，如何在自己的类中实现这个特性，或者如何为那些您无法控制但认为可以从析构中获益的类实现这个特性，以及一切是如何工作的。</p><h1 id="a7f8" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">使用</h1><p id="2317" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">析构声明允许我们这样定义<strong class="jj ht">局部</strong>值/变量:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="2ef3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是处理来自函数或集合的数据的一种便捷方式:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="f4f1" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">默认情况下，所有数据类都支持析构。</p><p id="9812" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您可以决定只使用类字段中的变量子集:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="b4f9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">析构不允许你选择你想要使用的字段；它将始终使用前x个字段，其中x是您声明的变量的数量。这样做的坏处是很容易出错。例如，下面的代码片段可能会产生意外的结果:</p><pre class="la lb lc ld fd lg lh li lj aw lk bi"><span id="ecd9" class="ll ke hs lh b fi lm ln l lo lp">val (name, rating) = goodDoggo</span></pre><p id="0d7f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">等级值实际上包含goodDoggo.breed的值。您将得到一条警告:“变量名' rating '与不同组件的名称相匹配”，并建议将等级重命名为breed。由于这只是IDE中的警告，而不是编译警告，所以很容易被忽略。</p><figure class="la lb lc ld fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/f6fabf2427e55e8610e356fdd2f58d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gYYP640wiKB1RCFA"/></div></div></figure><p id="f36e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">使用了错误的析构变量声明</p><p id="2c63" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你只需要不连续字段的子集，对那些你不感兴趣的字段使用<code class="du lr ls lt lh b">_</code>，Kotlin会跳过它们。上面的例子变成了:</p><pre class="la lb lc ld fd lg lh li lj aw lk bi"><span id="1e70" class="ll ke hs lh b fi lm ln l lo lp">val (name, _, rating) = goodDoggo</span></pre><h1 id="2305" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">在后台</h1><p id="e504" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">让我们来看看一个反编译的数据类，看看发生了什么。在这篇文章中，我们将只关注为析构生成的函数。关于数据类的更多信息，请关注以后的文章。</p><p id="35f8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要查看Java反编译代码，进入工具-&gt; Kotlin -&gt;显示Kotlin字节码，然后按反编译按钮。</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="ce12" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们看到，为主构造函数中声明的每个属性生成了名为componentN的函数，其中N是主构造函数中字段的索引。</p><h1 id="9e26" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">实现析构</h1><p id="6ff6" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">正如我们所见，析构依赖于componentN函数。因此，如果你想给一个不支持析构功能的类添加析构功能，那么只需实现相应的componentN操作符函数。确保在它们前面加上operator关键字。</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><h1 id="f147" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">为不属于自己的类实现析构</h1><p id="4538" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">Kotlin允许你通过扩展函数为你不拥有的类实现析构。比如<a class="ae lu" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/-entry/" rel="noopener ugc nofollow" target="_blank">地图。条目</a>只是一个接口，默认情况下它不支持析构。为了克服这个问题，创建了component1()和component2()函数，它们返回Map.Entry的键和值。</p><h1 id="484e" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">结论</h1><p id="b9bb" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">每当需要将对象的字段解包为值/变量时，使用析构。在幕后，析构是通过提供componentN运算符函数来实现的，因此您可以自己为您认为受益于该功能的类提供这些函数。</p></div></div>    
</body>
</html>