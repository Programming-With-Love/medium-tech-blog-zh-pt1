# JUnit 5 参数化特性

> 原文：<https://medium.com/globant/junit-5-parameterized-feature-c8cbe6a70aa0?source=collection_archive---------0----------------------->

![](img/d7058e6079bfc8d5af87d9ad9ecd2332.png)

# **简介**

JUnit5 是下一代测试框架，是开发人员编写单元测试类的一个非常常用的工具。本文将教你如何使用一个名为参数化的新特性。让我们从一个概述开始，然后，我们将讨论如何配置和如何使用这个特性。

## **6 月 5 日概述**

JUnit5 是该框架的新版本，由以下组件组成:

*   **JUnit 平台**，JVM 上的测试框架。
*   JUnit Jupiter，编写测试类的新扩展。
*   **JUnit Vintage，**运行 Junit 3 和 Junit 4 的测试引擎。

## **配置参数化**

在开始使用 Junit 参数化特性之前，我们需要在 pom.xml 文件中添加依赖关系:

对于我们使用 maven 的项目:

对于我们使用 Gradle 的项目:

> 注:版本 **5.7.0** 是本文发布时可用的最新版本。

## **使用参数化特征**

让我们使用 EmailValidator 类来展示 JUnit 参数化的不同用例。这个类非常简单，但应该足以展示它的功能。

*   ***测试没有参数化的特性，*** *w* e 可以编写一个简单的测试类实现下面的测试用例:

如果您看到上面的测试类，我们需要创建两个不同的方法来测试这两种情况，检查有效和无效的电子邮件地址。但是如果我们使用参数化特性，上面的代码可以改为:

我们可以看到两种方法，一种允许我们检查多个有效的电子邮件地址，另一种用于检查多个无效的电子邮件地址，我们需要的所有输入值对于这两种方法来说都更清楚，但是我们仍然有两种方法，所以，让我们看看使用参数化功能可以使用的另一个选项:

在这种情况下，我们使用一种方法作为测试(输入值)有效和无效电子邮件地址所需的所有数据的来源。通过这个选项，我们减少了测试类中的代码。然而，我们还有另一个选择，让我们看看下面的代码:

我们可以看到注解 ***@CsvFileSource。*** 这允许我们用测试中需要的所有输入数据定义一个 CSV 文件，让我们看看这个文件:

该文件对每个输入数据都进行了预期的验证，在本例中，包括有效和无效的电子邮件地址。我们可以看到测试我们的类的很好的选项，但是我们仍然需要执行额外的测试，即可能有空的和 null 的输入值。让我们看看如何测试这些情况。

*   ***测试空输入值*，**在这种情况下，要使用的正确特性是 ***@NullSource，*** 这个注释允许我们在测试类中捕捉空值，让我们看看实现这个注释的单元测试方法:

简单吧？有了这个特性，我们的测试更加清晰和简洁。

*   ***测试空输入值*，**在这种情况下，要使用的正确特性是 ***@EmptySource，*** 这个注释允许我们在测试类中捕捉空值，让我们看看实现这个注释的 uni test 方法。

太棒了。然而，我们现在有两种方法来测试这两种情况，空值和空值，但是框架为我们提供了另一个有用的特性，叫做***@ NullAndEmptySource***让我们看看实现这个注释的单元测试方法:

正如我们所看到的，这个注释进一步减少了我们的代码。但是，我们可以组合特性来创建比上面更小的测试用例，并执行更多的测试，让我们来看看:

在本例中，我们将测试 null、空值、制表符和换行符，所有可能的输入值都需要在 EmailValidator 类中进行测试。

我们需要做的另一件事是当我们的 EmailValidator 类收到不正确的输入值时抛出异常，让我们看看测试这种情况的选项。

*   ***使用 Try-catch 子句，*** 使用这个子句是一个很好的方法，因为我们达到了目标，这就是捕捉异常让我们看看代码:

验证是正确的，但是让我们看看通过使用 JUnit 5 我们可以获得的特性。

有了这个特性，测试就更干净、更简单了，对吗？

## **结论**

我们刚刚经历了一些使用 Junit 5 的新特性，它为我们的开发人员提供了一些非常好的选项来创建我们的单元测试，并避免增加类大小的样板代码，希望这个概述能让您快速了解这些特性能做什么，如果您发现它们有用，请确保在您的下一个项目中使用它们。