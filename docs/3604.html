<html>
<head>
<title>GraphQL: The Query Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL:查询语言</h1>
<blockquote>原文：<a href="https://medium.com/globant/graphql-the-query-language-3d1b1807a1d1?source=collection_archive---------2-----------------------#2021-01-08">https://medium.com/globant/graphql-the-query-language-3d1b1807a1d1?source=collection_archive---------2-----------------------#2021-01-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/5876461436bfb5b10a1a63f56b3d901a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*RHWi_Erl7eAzfsiDf3sanQ.png"/></div></figure><p id="e4b3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我相信你已经看到了使用GraphQL 的一些有趣的方面，这就是为什么你想更深入地研究它。</p><p id="5d7b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果没有，可以在一篇关于<a class="ae jj" rel="noopener" href="/@sagar.barawade/introduction-overview-of-graphql-56ac0285077b"> <strong class="in hi">简介:GraphQL </strong> </a> <strong class="in hi">概述中对GraphQL进行架构概述。</strong></p><p id="c24a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">到本文结束时，您将对如何在前端应用程序中使用<a class="ae jj" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>有一个大致的了解。我们将通过一些例子和使用<a class="ae jj" href="https://docs.github.com/en/free-pro-team@latest/" rel="noopener ugc nofollow" target="_blank">GitHub API</a>来试验GraphQL查询。</p><ol class=""><li id="747b" class="jk jl hh in b io ip is it iw jm ja jn je jo ji jp jq jr js bi translated"><a class="ae jj" href="https://docs.github.com/en/free-pro-team@latest/rest" rel="noopener ugc nofollow" target="_blank">GitHub REST API</a></li><li id="f595" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated"><a class="ae jj" href="https://docs.github.com/en/free-pro-team@latest/graphql" rel="noopener ugc nofollow" target="_blank">GitHub graph QL API</a></li></ol><p id="ce34" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们看看<a class="ae jj" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>对于实时API实现有什么意义。</p><h1 id="9c3c" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated"><strong class="ak">入门:真正的快速</strong></h1><p id="ea1f" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">为了把你从探索GraphQL 的所有设置中解救出来，我们有一个完美的地方，在那里我们可以尽情发挥查询语言及其特性。</p><p id="cc08" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你只需要:</p><ol class=""><li id="88ae" class="jk jl hh in b io ip is it iw jm ja jn je jo ji jp jq jr js bi translated">下载<a class="ae jj" href="https://www.electronjs.org/apps/graphiql" rel="noopener ugc nofollow" target="_blank"> GraphiQL </a>并安装在您的系统上。</li><li id="80a1" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">为您的GitHub帐户创建一个“个人访问令牌”。</li><li id="5de1" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">用创建的令牌配置GraphiQL中的“Authorization”头。</li><li id="af27" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">用“<a class="ae jj" href="https://api.github.com/graphql" rel="noopener ugc nofollow" target="_blank">https://api.github.com/graphql</a>”配置服务器端点。</li><li id="8ef7" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">转到<a class="ae jj" href="https://docs.github.com/en/free-pro-team@latest/graphql" rel="noopener ugc nofollow" target="_blank">GitHub graph QL API</a>浏览文档。</li></ol><p id="ac63" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">运筹学</p><ol class=""><li id="c655" class="jk jl hh in b io ip is it iw jm ja jn je jo ji jp jq jr js bi translated">授权GitHub APIs使用您的帐户数据。</li><li id="b55a" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">转到以下链接:</li></ol><p id="dd12" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jj" href="https://developer.github.com/v4/explorer/" rel="noopener ugc nofollow" target="_blank">https://developer.github.com/v4/explorer/</a></p><p id="0fca" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这里，您已经有了一个现成的GraphQL服务器设置，其中包含大量数据和完整的API文档。您可以在这里尽情探索GraphQL。这个工具叫做<a class="ae jj" href="https://github.com/graphql/graphiql" rel="noopener ugc nofollow" target="_blank"> GraphiQL </a>。这是一个GraphQL IDE，相当于其他API文档工具，如<a class="ae jj" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> Swagger </a>。</p><p id="7841" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当我们在那里探索<a class="ae jj" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>时，让我们理解<a class="ae jj" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>的一些基本概念，以便它将帮助您修改查询并对其进行试验。</p><p id="2787" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">构建</strong> <a class="ae jj" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a> <strong class="in hi">查询<br/> </strong>假设你想从服务器获取用户的详细信息。如果服务器提供REST APIs，那么您将使用如下API端点:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="3e1b" class="lk jz hh lg b fi ll lm l ln lo">GET /user/john-doe/</span></pre><p id="316c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在<a class="ae jj" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>中，为了获取相同的数据，典型的<a class="ae jj" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>查询如下所示:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="3014" class="lk jz hh lg b fi ll lm l ln lo">query GetUser {<br/>  user(login: "john-doe") {<br/>    login<br/>    id<br/>    avatarUrl<br/>    ...<br/>  }<br/>}</span></pre><p id="4d00" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一个<a class="ae jj" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>查询有一些来自以下的基本构件:</p><ol class=""><li id="2adf" class="jk jl hh in b io ip is it iw jm ja jn je jo ji jp jq jr js bi translated">菲尔茨</li><li id="0f75" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">争论</li><li id="c614" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">变量</li><li id="6201" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">(计划或理论的)纲要</li><li id="c549" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">别名</li><li id="f335" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">碎片</li><li id="efed" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">指令</li><li id="b0de" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">突变</li><li id="9232" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">接口</li><li id="c088" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">联合</li></ol><h1 id="2298" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.菲尔茨</h1><p id="41b7" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">假设我们想从服务器获取用户的详细信息。我们只想显示其中的<code class="du lp lq lr lg b">name</code>和<code class="du lp lq lr lg b">avatar_url</code>。</p><p id="ecc0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在REST中，我们可能有一个类似于<code class="du lp lq lr lg b">GET /user/:user_id.</code>的API端点，它将返回以下数据:</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es ls"><img src="../Images/0847ffc3ff48d8230e1ed654dc4c15a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*Wcr1134N5ozNbsH8OiDSmg.png"/></div></figure><p id="f1d3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">反响巨大。不是吗？我们只想知道用户的<code class="du lp lq lr lg b">name</code>和<code class="du lp lq lr lg b">avatar_url</code>。但是在上面的响应中，有太多我们不需要的额外字段。但是在REST中，我们通常不能开箱即用地只选择那些必需的字段。</p><p id="ff2b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这就是GraphQL字段的用处。在GraphQL中，您可以灵活地指定希望包含数据的字段。您可以通过以下查询经由GraphQL从服务器获取所需的信息:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="1854" class="lk jz hh lg b fi ll lm l ln lo">Request:<br/>{<br/>  github {<br/>    user(login: “john-doe”) {<br/>      name<br/>      avatarUrl<br/>    }<br/>  }<br/>}</span></pre><p id="8baa" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这将返回以下响应数据:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="a1e9" class="lk jz hh lg b fi ll lm l ln lo">Response:<br/>{<br/>  "data": {<br/>    "github": {<br/>      "user": {<br/>        "name": "John Doe",<br/>        "avatarUrl":<br/>            "https://avatars1.githubusercontent.com/u/XXXXXXXX?v=4"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="66c3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">假设，如果您还想获取用户的GitHub存储库信息，那么您将不得不单独调用API端点<code class="du lp lq lr lg b">GET /user/:user_id/repos </code>。</p><p id="2c1c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">但是对于GraphQL，您可以通过下面的GraphQL查询在一个API调用中获取这两个细节:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="25e6" class="lk jz hh lg b fi ll lm l ln lo">Request:<br/>{<br/>  user(login: "john-doe") {<br/>    login<br/>    id<br/>    avatarUrl<br/>    repositories(first: 5) {<br/>      totalCount<br/>      nodes {<br/>        id<br/>        name<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="31d3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这将为您返回以下数据:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="07dc" class="lk jz hh lg b fi ll lm l ln lo">Response:<br/>{<br/>  "data": {<br/>    "user": {<br/>      "login": "john-doe",<br/>      "id": "MDQ6VXNlcjE3MDQxNzY=",<br/>      "avatarUrl": "<a class="ae jj" href="https://avatars0.githubusercontent.com/u/1704176?v=4" rel="noopener ugc nofollow" target="_blank">https://avatars0.githubusercontent.com/u/1704176?v=4</a>",<br/>      "repositories": {<br/>        "totalCount": 1,<br/>        "nodes": [<br/>          {<br/>            "id": "MDEwOlJlcG9zaXRvcnk0MjE5ODgz",<br/>            "name": "my-first-app"<br/>          }<br/>        ]<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="85ed" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">从上面的例子中，我们可以说，在从后端查询数据时选择响应中的字段的能力是GraphQL最有用的特性，它使前端团队的工作变得更容易。</p><p id="8f01" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">GraphQL字段有不同的数据类型。让我们来理解GraphQL拥有的这些不同的数据类型。这将有助于我们更好地理解GraphQL查询语言。</p><ol class=""><li id="0cdf" class="jk jl hh in b io ip is it iw jm ja jn je jo ji jp jq jr js bi translated"><strong class="in hi">根字段:</strong> <br/>根字段定义了要从中获取数据的服务。您可以指定多个服务，如github、reddit等。这样，在将应用程序与多种服务集成时，GraphQL就派上了用场。</li><li id="bc5b" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated"><strong class="in hi">标量字段:</strong> <br/>标量字段是具有原始数据类型的字段。例如字符串、整型、布尔型等。</li><li id="a56d" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated"><strong class="in hi">复杂字段:</strong> <br/>复杂字段是指数据类型来源于某种预定义模式的字段。例如，用户，它具有由用户模式定义的多个属性，如<code class="du lp lq lr lg b">id, name, avatar_url</code>等。</li></ol><h1 id="c808" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.争论</h1><p id="82e6" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">既然我们现在知道了要使用哪个服务以及要获取哪些字段，那么您可以创建一个示例查询。在上面的查询中，我们提到了用户ID“John-doe”，它作为参数<code class="du lp lq lr lg b">username</code>的一个参数。</p><h1 id="0e0f" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.变量</h1><p id="b530" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">在大多数应用中，这些变量将是动态的。为了使<code class="du lp lq lr lg b">username</code>动态，我们将编写如下查询:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="b730" class="lk jz hh lg b fi ll lm l ln lo">query GetGitHubUser($input: String!) {<br/>  user(login: $input) {<br/>    login<br/>    id<br/>    avatarUrl<br/>    repositories(first: 5) {<br/>      totalCount<br/>      nodes {<br/>        id<br/>        name<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="2217" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">注意关键词<code class="du lp lq lr lg b">String</code>。这样我们就定义了名为<code class="du lp lq lr lg b">input</code>的变量的数据类型。此外，感叹号<code class="du lp lq lr lg b">(!)</code>将该参数定义为<strong class="in hi"> required。</strong></p><h1 id="ef97" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4. (计划或理论的)纲要</h1><p id="b6e3" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">GraphQL是一种类型化语言。服务器定义它返回的数据的数据类型。该数据类型是根据模式定义的。</p><p id="04ee" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在我们的例子中，我们获取的用户实体在服务器上有一个定义的类型。它的每个属性都在模式中声明并被赋予一个类型。</p><p id="cb9e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">另外，注意<code class="du lp lq lr lg b">repos</code>字段也有自己的数据类型。那里的用户模式可以定义如下:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="bf6f" class="lk jz hh lg b fi ll lm l ln lo">type GithubUser {<br/>  login: String<br/>  id: Int<br/>  avatar_url: String<br/>  repos: [GithubRepo]<br/>}</span></pre><p id="32ff" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">所以在这里，<code class="du lp lq lr lg b">repos</code>字段的类型为<code class="du lp lq lr lg b">GithubRepo</code>模式，可以定义为:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="437c" class="lk jz hh lg b fi ll lm l ln lo">type GithubRepo  {<br/>  id: Int<br/>  name: String<br/>  commits(limit: Int): [GithubCommit]<br/>  owner: GithubUser<br/>}</span></pre><p id="48eb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这里，每个<code class="du lp lq lr lg b">GithubRepo</code>都有一个类型为<code class="du lp lq lr lg b">GithubUser</code>的<code class="du lp lq lr lg b">owner</code>和一个类型为<code class="du lp lq lr lg b">GithubCommit.</code>的<code class="du lp lq lr lg b">commits</code>数组</p><p id="3924" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">模式作为实体的API文档。您可以在GraphiQL的文档浏览器中看到所有这些模式。</p><p id="5183" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，模式<code class="du lp lq lr lg b">GithubCommit</code>指定字段<code class="du lp lq lr lg b">commits</code>采用名为<code class="du lp lq lr lg b">limit</code>的参数来限制要返回的提交数量。</p><h1 id="ba28" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">5.别名</h1><p id="7292" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">您一定已经注意到，响应数据包含的属性名称与查询中指定的字段名称完全相同。其实是反过来的。我们提到的字段名等于该实体的模式中指定的属性名。</p><p id="7513" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果我们想根据自己的选择命名它们，我们使用别名的概念。您可以使用别名为同一属性指定其他名称，如下所示:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="8c67" class="lk jz hh lg b fi ll lm l ln lo">query GetGitHubUser($input: String!) {<br/>  user(login: $input) {<br/>    username: login<br/>    userId: id<br/>    profileImage: avatarUrl<br/>    repositories(first: 5) {<br/>      totalRepositories: totalCount<br/>      data: nodes {<br/>        repositoryId: id<br/>        repositoryName: name<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="9cd5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这将产生以下结果:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="1ad4" class="lk jz hh lg b fi ll lm l ln lo">{<br/>  "data": {<br/>    "user": {<br/>      "username": "john-doe",<br/>      "userId": "MDQ6VXNlcjE3MDQxNzY=",<br/>      "profileImage": "<a class="ae jj" href="https://avatars0.githubusercontent.com/u/1704176?v=4" rel="noopener ugc nofollow" target="_blank">https://avatars0.githubusercontent.com/u/1704176?v=4</a>",<br/>      "repositories": {<br/>        "totalRepositories": 1,<br/>        "data": [<br/>          {<br/>            "repositoryId": "MDEwOlJlcG9zaXRvcnk0MjE5ODgz",<br/>            "repositoryName": "my-first-app"<br/>          }<br/>        ]<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="6b13" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当我们希望在一个查询中多次查询同一个实体时，这就很方便了。例如</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="5378" class="lk jz hh lg b fi ll lm l ln lo">query GetRepositories($input: String!) {<br/>  user(login: $input) {<br/>    username: login<br/>    userId: id<br/>    profileImage: avatarUrl<br/>    ownRepositories: repositories(first: 5, isFork: false) {<br/>      totalRepositories: totalCount<br/>      data: nodes {<br/>        repositoryId: id<br/>        repositoryName: name<br/>      }<br/>    }<br/>    forkedRepositories: repositories(first: 5, isFork: true) {<br/>      totalRepositories: totalCount<br/>      data: nodes {<br/>        repositoryId: id<br/>        repositoryName: name<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h1 id="3714" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">6.碎片</h1><p id="3aa2" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">在上面的例子中，我们重复了<code class="du lp lq lr lg b">owner</code>和<code class="du lp lq lr lg b">contributor</code>的字段。根据应用程序的要求，我们可能需要多次重复某些字段。</p><p id="090c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了帮助我们进行这种重复，GraphQL提供了称为<strong class="in hi">片段的可重用单元。</strong></p><p id="f642" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">片段允许您构造字段集，然后在需要时将它们包含在查询中。下面是一个如何使用片段解决上述情况的例子:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="e994" class="lk jz hh lg b fi ll lm l ln lo">query GetOwnerAndContributor($input: String!) {<br/>  user(login: $input) {<br/>    username: login<br/>    userId: id<br/>    profileImage: avatarUrl<br/>    ownRepositories: repositories(first: 5, isFork: false) {<br/>      ...repositoryFields<br/>    }<br/>    forkedRepositories: repositories(first: 5, isFork: true) {<br/>      ...repositoryFields<br/>    }<br/>  }<br/>}</span><span id="7524" class="lk jz hh lg b fi lt lm l ln lo">fragment <strong class="lg hi">repositoryFields</strong> on RepositoryConnection {<br/>  totalRepositories: totalCount<br/>  data: nodes {<br/>    repositoryId: id<br/>    repositoryName: name<br/>  }<br/>}</span></pre><p id="ffa9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，我们可以在任何需要的地方重用<code class="du lp lq lr lg b">repositoryFields</code>片段。这些片段还可以在它们被使用的范围内访问这些变量。</p><h1 id="a0ec" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">7.指令</h1><p id="b6f7" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">我们讨论了片段如何帮助我们重用查询组件。现在让我们讨论一下我们可以赋予查询的条件行为。</p><p id="21a2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们已经编写了一个查询来获取包括存储库在内的用户详细信息。如果我们只想在某些地方获取存储库呢？</p><p id="436d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这里，指令进入画面。指令可以附加到字段或片段包含中，并且可以以客户端希望服务器执行和构建所需响应的方式影响查询的执行。</p><p id="8073" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">核心GraphQL规范支持两个指令:</p><ul class=""><li id="2a23" class="jk jl hh in b io ip is it iw jm ja jn je jo ji lu jq jr js bi translated"><code class="du lp lq lr lg b">@include(if: Boolean)</code>仅当参数为<code class="du lp lq lr lg b">true</code>时，才在结果中包含该字段。</li><li id="1df8" class="jk jl hh in b io jt is ju iw jv ja jw je jx ji lu jq jr js bi translated"><code class="du lp lq lr lg b">@skip(if: Boolean)</code>如果参数为<code class="du lp lq lr lg b">true</code>，则跳过该字段。</li></ul><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="87dc" class="lk jz hh lg b fi ll lm l ln lo">query GetGitHubUser($withRepos: Boolean!) {<br/>  user(login: "john-doe") {<br/>    login<br/>    id<br/>    avatarUrl<br/>    repositories (first: 5) <a class="ae jj" href="http://twitter.com/include" rel="noopener ugc nofollow" target="_blank">@include</a>(if: $withRepos) {<br/>      totalCount<br/>      nodes {<br/>        id<br/>        name<br/>      }<br/>    }<br/>  }<br/>}</span><span id="3907" class="lk jz hh lg b fi lt lm l ln lo">------------------------------------------------------<br/>Variables:<br/><br/>{<br/>    "withRepos": true<br/>}</span></pre><p id="3188" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">服务器可以定义自己的指令来添加自定义行为。</p><p id="177b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我想说，这足以让你知道GraphQL将如何帮助你理解如何使用GraphQL来获取数据。</p><p id="d7bc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们看看如何使用GraphQL修改数据。</p><h1 id="2964" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">突变</h1><p id="8d4c" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">突变用于修改服务器上的数据。变异服务于RESTful APIs的POST、PUT、DELETE等方法所提供的相似目的。</p><p id="4c9f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">就像在查询中一样，如果突变字段返回一个对象类型，您可以要求嵌套字段。这对于在更新后获取对象的新状态非常有用。让我们看一个简单的突变例子:</p><p id="53b6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">以下突变查询将星号添加到指定的存储库中:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="bc2a" class="lk jz hh lg b fi ll lm l ln lo">mutation addStar($input: AddStarInput!) {<br/>  addStar(input: $input) {<br/>    clientMutationId<br/>    starrable {<br/>      id<br/>      stargazerCount<br/>    }<br/>  }<br/>}</span></pre><p id="baf6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">以下突变查询从指定的存储库中删除一个星号:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="70db" class="lk jz hh lg b fi ll lm l ln lo">mutation removeStar($input: RemoveStarInput!) {<br/>  removeStar(input: $input) {<br/>    clientMutationId<br/>    starrable {<br/>      id<br/>      stargazerCount<br/>    }<br/>  }<br/>}</span></pre><h1 id="57b8" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">接口</h1><p id="d165" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">作为一种严格类型的语言，GraphQL支持接口。一个<em class="lv">接口</em>是一个抽象类型，它包含一组特定的字段，一个类型必须包含这些字段来实现接口。</p><p id="4806" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们在这里创建一个自定义界面:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="6732" class="lk jz hh lg b fi ll lm l ln lo">interface I<!-- -->Movie<!-- --> {<br/>  id: ID!<br/>  name: String!<br/>  duration: String! <br/>  casts: [Character]<br/>  rating: Int<br/>}</span></pre><p id="8312" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在任何实体类型中实现这个接口意味着实体需要有这些精确的字段，以及这些参数和返回类型。</p><p id="a9fb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果我们创建一个实现接口<code class="du lp lq lr lg b">IMovie</code>的类型<code class="du lp lq lr lg b">Movie</code>，它将如下所示:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="f7ce" class="lk jz hh lg b fi ll lm l ln lo">type <!-- -->Movie<!-- --> implements I<!-- -->Movie<!-- --> {<br/>  id: ID!<br/>  name: String!<br/>  duration: String! <br/>  casts: [Character]<br/>  rating: Int<br/>}</span></pre><h1 id="2f39" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">联合</h1><p id="b071" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">联合是一种对象。但是，当从union中选择字段时，我们需要指定从union中指定的类型中获取哪种类型。</p><p id="afa4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，让我们创建一个联合<code class="du lp lq lr lg b">SearchResult</code>，它将包含来自<code class="du lp lq lr lg b">WebSeries</code>列表或<code class="du lp lq lr lg b">Movie</code>列表的数据。在此，我们将声明该联盟如下:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="9003" class="lk jz hh lg b fi ll lm l ln lo">union SearchResult = WebSeries | Movie</span></pre><p id="6b8a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在获取这些数据时，我们必须根据对象的类型来指定哪些字段要包含在服务器发送的响应中:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="c4a1" class="lk jz hh lg b fi ll lm l ln lo">query GetVideos($searchText: String!) {<br/>  search(text: $searchText) {<br/>    __typename<br/>    ... on WebSeries {<br/>      name<br/>      noOfSeasons<br/>      noOfEpisodes<br/>    }<br/>    ... on Movie {<br/>      name<br/>      duration<br/>    }<br/>  }<br/>}</span></pre><p id="0a0b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><code class="du lp lq lr lg b">__typename</code>字段解析为<code class="du lp lq lr lg b">String</code>,让您在客户端区分不同的数据类型。</p><p id="297b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">所以上面的查询会给你下面的结果。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="8dd9" class="lk jz hh lg b fi ll lm l ln lo">{<br/>  "data": {<br/>    "search": [<br/>      {<br/>        "__typename": "Movie",<br/>        "name": "The Matrix",<br/>        "duration": "2h 30m"<br/>      },<br/>      {<br/>        "__typename": "WebSeries",<br/>        "name": "The Big Band Theory",<br/>        "noOfSeasons": 12,<br/>        "noOfEpisodes": 279<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><figure class="lb lc ld le fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="a7e1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">就是这样。现在您已经了解了GraphQL的所有基础知识。您可以先行一步，即<a class="ae jj" rel="noopener" href="/@rppawar2010/play-it-your-way-poc-on-graphql-bf7e083c8b76"> <strong class="in hi">实现GraphQL后端服务器</strong> </a> <strong class="in hi">。</strong></p><p id="b994" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">转到<a class="ae jj" rel="noopener" href="/@rahul.pawar_25862/play-it-your-way-poc-on-graphql-590d2f0e830e"> <strong class="in hi">随心所欲:关于GraphQL的概念证明</strong> </a>文章。在那里，您可以找到一个逐步的指南来创建一个带有GraphiQL UI的GraphQL服务器。</p><p id="2422" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我希望这有助于您理解GraphQL:查询语言。</p><p id="1bd8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">谢谢你。</p></div></div>    
</body>
</html>