<html>
<head>
<title>My best practice for adding a java dependency to Mendix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我向Mendix添加java依赖项的最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/mendix/best-practice-for-adding-a-java-dependency-to-mendix-c10069fa1a10?source=collection_archive---------1-----------------------#2021-01-07">https://medium.com/mendix/best-practice-for-adding-a-java-dependency-to-mendix-c10069fa1a10?source=collection_archive---------1-----------------------#2021-01-07</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/8265ad398551dbfcff7e597e06f9a184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m3qC7ASwJ81R9gvxTQXdmw.png"/></div></div></figure><div class=""/><h1 id="e932" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">我和Mendix的旅程始于四年多前。由于我的Mendix项目的性质，我不得不多次使用第三方java库，基于两年前的经验，我写了一篇关于管理Mendix模块的java依赖关系的博文。从那以后，我对这个过程有了更多的了解，想和大家分享一下。</h1><p id="f885" class="pw-post-body-paragraph kb kc if bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这篇博文的目的是记录我在向Mendix项目添加java库方面的经验和最佳实践，并看看如何在实际例子中应用它们。</p><p id="5e98" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">激动吗？我们走吧！</p><h1 id="bc18" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">最优方法</h1><blockquote class="ld le lf"><p id="3277" class="kb kc lg bd b kd ky kf kg kh kz kj kk lh la kn ko li lb kr ks lj lc kv kw kx hn dt translated"><em class="if">在我看来，向Mendix添加第三方依赖的最佳方式是首先建立一个单独的纯java项目(使用gradle或maven ),该项目包含依赖并提供一个易于使用的接口。然后使用一个影子插件生成一个所谓的</em> fat <em class="if"> jar，其中包含所有的依赖项，并将其导入到您的Mendix项目中。</em></p></blockquote><p id="352d" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这在一定程度上与我之前的博客文章中的信息相同。然而，正如您将从下面的列表中看到的，通过稍微做些不同的事情，使用这种方法的好处可以大大扩展。以下是使用上述过程的优势列表:</p><ol class=""><li id="3b17" class="lk ll if bd b kd ky kh kz kl lm kp ln kt lo kx lp lq lr ls dt translated"><strong class="bd lt">自动处理传递依赖。</strong>几乎每个java库都有它依赖的其他java库。一个一个地下载它们很麻烦，容易出错，而且不可维护。Gradle和maven都支持开箱即用的依赖性管理。他们将为您计划使用的库找到并下载正确的依赖项。此外，因为所有的依赖项都在一个jar中，所以任何不再需要的依赖项都会在构建时自动删除，从而使更新过程变得容易，这与许多Mendix模块不同，在这些模块中，开发人员需要在升级时手动删除未使用的或旧的依赖项。</li><li id="5bdd" class="lk ll if bd b kd lu kh lv kl lw kp lx kt ly kx lp lq lr ls dt translated"><strong class="bd lt">避免传递依赖的版本冲突。</strong>不幸的是，基于<a class="ae ka" href="https://en.wikipedia.org/wiki/OSGi" rel="noopener ugc nofollow" target="_blank"> OSGI </a>的Mendix java类加载器不能处理一个依赖的多个版本。如果您尝试使用的库需要加载依赖项的特定版本，而Mendix运行时或另一个Mendix模块正在使用同一依赖项的不同版本，则这可能是一个阻塞问题。由于shadow插件，这种依赖关系可以被隐藏，从而使类加载器能够同时加载它们。</li><li id="da5b" class="lk ll if bd b kd lu kh lv kl lw kp lx kt ly kx lp lq lr ls dt translated">孤立地了解java库。使用一个你不熟悉的第三方库本身就够难的了。试图在大型Mendix项目的背景下做到这一点要困难一千倍。如果有些东西不工作，很难说错误是来自库、java代码、Mendix和java之间的集成还是Mendix应用程序本身。另外，当您每次都必须启动Mendix运行时，测试和调试会更加复杂和耗时。</li><li id="bd2a" class="lk ll if bd b kd lu kh lv kl lw kp lx kt ly kx lp lq lr ls dt translated"><strong class="bd lt">编码到你想要的界面。</strong>很多时候java库会有复杂的接口要用。这毕竟是java，所以为了做像函数调用这样简单的事情，你可能需要检查通常的嫌疑人列表:工厂、构建者和管理者，直到你有了一个可以实际调用该方法的对象。最好将这种复杂性隐藏起来，构建一个简单的适配器/facade，它具有您想要和需要的接口。一个额外的好处是，您可以用第三方库替换另一个库，而不必接触Mendix应用程序。</li><li id="8796" class="lk ll if bd b kd lu kh lv kl lw kp lx kt ly kx lp lq lr ls dt translated"><strong class="bd lt">轻松设置单元测试，作为回归套件。这一点非常重要，我想在这个列表中重复十遍。当一个复杂的应用程序出现问题时，很难确定故障的确切位置。因此，通过一些测试，您可以非常容易地检查问题是出在第三方库还是您的Mendix逻辑中的其他地方。进行测试的另一个很好的理由是减少与修改代码或将库升级到新版本相关的风险。理论上，你可以在Mendix中实现这一点，但是与gradle或maven相比，这要复杂得多，耗费大量资源和时间，并且更难集成到你的构建过程中。</strong></li><li id="aeed" class="lk ll if bd b kd lu kh lv kl lw kp lx kt ly kx lp lq lr ls dt translated"><strong class="bd lt">单独版本控制。这是一个小问题，但是我更喜欢将依赖关系保存在单独的存储库中。另外，您可以使用不同的版本控制(git)系统，因为您不受Mendix (svn)的限制。git已经为gradle和maven忽略列表提供了很好的模板。</strong></li></ol><h1 id="1083" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">逐步指南</h1><p id="3f9d" class="pw-post-body-paragraph kb kc if bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">为了使上面的最佳实践更有基础，让我们回顾一下添加具体的第三方库的步骤。一个markdown解析器<a class="ae ka" href="https://github.com/vsch/flexmark-java" rel="noopener ugc nofollow" target="_blank">https://github.com/vsch/flexmark-java</a>怎么样？Mendix Market Place中关于markdown转换的一个<a class="ae ka" href="https://marketplace.mendix.com/link/component/1289" rel="noopener ugc nofollow" target="_blank">模块</a>现在已经使用了7年，并且使用了不再维护的废弃库，因此这将是一个不错的升级。</p><p id="aa85" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">目标是在Mendix项目中使用这个库将一些markdown文本转换成HTML。最终结果应该是这样的:<a class="ae ka" href="https://markdownconverter-sandbox.mxapps.io" rel="noopener ugc nofollow" target="_blank">https://markdowncoverter-sandbox . MX apps . io</a></p><h1 id="7648" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">先决条件</h1><p id="c8fa" class="pw-post-body-paragraph kb kc if bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">🟣:我将在本指南中使用格雷尔。Maven也可以做同样的事情。</p><p id="1c5b" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><strong class="bd lt"> Gradle v5.5 </strong>:按照官方教程<a class="ae ka" href="https://gradle.org/install/" rel="noopener ugc nofollow" target="_blank">https://gradle.org/install/</a>安装即可。较新或较旧的版本也应该工作，但这是本教程中使用的版本。</p><p id="fc9f" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">它是一个命令行工具，负责依赖性管理、隐藏和构建。</p><h1 id="09cb" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">步骤1:初始化项目</h1><p id="88eb" class="pw-post-body-paragraph kb kc if bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">在空目录中创建新的git项目。然后打开命令行窗口，键入:</p><p id="2e76" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><code class="eh lz ma mb mc b">gradle init</code></p><p id="d0b5" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这将启动设置gradle项目的过程。按照说明仔细选择，我推荐以下选项，但您可能有其他偏好:</p><ul class=""><li id="4707" class="lk ll if bd b kd ky kh kz kl lm kp ln kt lo kx md lq lr ls dt translated">项目类型:3:库(不需要主方法)</li><li id="5625" class="lk ll if bd b kd lu kh lv kl lw kp lx kt ly kx md lq lr ls dt translated">语言:3: java</li><li id="c097" class="lk ll if bd b kd lu kh lv kl lw kp lx kt ly kx md lq lr ls dt translated">构建脚本:1: groovy</li><li id="f924" class="lk ll if bd b kd lu kh lv kl lw kp lx kt ly kx md lq lr ls dt translated">测试框架:1: JUnit4</li></ul><p id="b6da" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">一旦<code class="eh lz ma mb mc b">init</code>命令完成，它将生成一个类似于以下内容的项目文件结构:</p><figure class="mf mg mh mi fq hw fe ff paragraph-image"><div class="fe ff me"><img src="../Images/028773a9ac6d981dd530a107c6f0fce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*e6Br32SEXEXXZ4Jf55g8dg.png"/></div></figure><p id="24ab" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我们将使用的一些重要位置是:</p><ul class=""><li id="c6c4" class="lk ll if bd b kd ky kh kz kl lm kp ln kt lo kx md lq lr ls dt translated">src \ main —这是java代码的位置</li><li id="a470" class="lk ll if bd b kd lu kh lv kl lw kp lx kt ly kx md lq lr ls dt translated">src \ test —这是测试代码所在的地方</li><li id="8c44" class="lk ll if bd b kd lu kh lv kl lw kp lx kt ly kx md lq lr ls dt translated">build.gradle —定义依赖项、插件等</li></ul><h1 id="e922" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">步骤2:通过gradle添加依赖项</h1><p id="29cc" class="pw-post-body-paragraph kb kc if bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">做到这一点最简单的方法是前往Maven存储库并搜索您想要添加的依赖项。比如这是flexmark依赖<a class="ae ka" href="https://mvnrepository.com/artifact/com.vladsch.flexmark/flexmark-all/0.62.2" rel="noopener ugc nofollow" target="_blank">https://mvn repository . com/artifact/com . Vlad sch . flex mark/flex mark-all/0 . 62 . 2</a>。在这个页面上有一个代码片段，其中包含可以用来将这个依赖项添加到gradle项目中的命令。</p><p id="feab" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><code class="eh lz ma mb mc b">compile group: 'com.vladsch.flexmark', name: 'flexmark-all', version: '0.62.2'</code></p><p id="be8d" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">复制这段代码，并将其添加到<code class="eh lz ma mb mc b">dependencies</code>下的<code class="eh lz ma mb mc b">build.gradle</code>文件中。您可以删除gradle自动添加的其他编译依赖项，它们只是一个示例，但是请确保保留测试依赖项，否则测试将无法工作。</p><h1 id="f6a5" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">步骤3:编写并实现第三方库的接口</h1><p id="9d28" class="pw-post-body-paragraph kb kc if bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">最后，是时候写一些代码了。您可以使用任何编辑器或IDE，但我发现IntelliJ与gradle一起工作最为可靠。这一点很重要，因为如果不解析类路径来找到梯度依赖，您的代码将无法编译，并将抛出许多错误(并且没有自动完成)。</p><p id="0773" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">下面是一个将markdown转换成HTML的简单接口和一个实现它的类(我主要是从<a class="ae ka" href="https://github.com/vsch/flexmark-java/blob/master/flexmark-java-samples/src/com/vladsch/flexmark/java/samples/BasicSample.java" rel="noopener ugc nofollow" target="_blank">这里</a>复制过来的)。</p><pre class="mf mg mh mi fq mj mc mk ml aw mm dt"><span id="c07d" class="mn jd if mc b fv mo mp l mq mr">package flexmark.mendix;</span><span id="5f20" class="mn jd if mc b fv ms mp l mq mr">import com.vladsch.flexmark.html.HtmlRenderer;<br/>import com.vladsch.flexmark.parser.Parser;<br/>import com.vladsch.flexmark.util.ast.Node;<br/>import com.vladsch.flexmark.util.data.MutableDataSet;</span><span id="90ba" class="mn jd if mc b fv ms mp l mq mr">public interface MarkdownToHTMLConverter {</span><span id="374a" class="mn jd if mc b fv ms mp l mq mr">    // main method<br/>    String convert(String markdown);</span><span id="a59b" class="mn jd if mc b fv ms mp l mq mr">    // factory method<br/>    static MarkdownToHTMLConverter create() {<br/>        return new FlexmarkConverter();<br/>    }<br/>}</span><span id="892e" class="mn jd if mc b fv ms mp l mq mr">class FlexmarkConverter implements MarkdownToHTMLConverter {</span><span id="18c5" class="mn jd if mc b fv ms mp l mq mr">    @Override<br/>    public String convert(String markdown) {<br/>        MutableDataSet options = new MutableDataSet();<br/>        Parser parser = Parser.builder(options).build();<br/>        HtmlRenderer renderer = HtmlRenderer.builder(options).build();<br/>        Node document = parser.parse(markdown);<br/>        String html = renderer.render(document);<br/>        return html;<br/>    }<br/>}</span></pre><p id="1d3f" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">注意，类和接口通常不应该在同一个文件中，我这样做只是为了简洁。</p><h1 id="0514" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">步骤4:编写单元测试</h1><p id="3260" class="pw-post-body-paragraph kb kc if bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">因为这是一个库项目，所以它没有主类。检查某个东西是否工作的最简单的方法是编写一个测试。这实际上是完美的，因为它迫使我们编写测试，我们可以在将来任何时候进行更改时使用这些测试来验证一切都正常工作。</p><p id="23c8" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">出于本文的目的，我将添加一个简单的测试。对于生产使用，确保您的测试涵盖了您计划使用的库的所有方面，并且有真实的输入。但是不要走极端，我们的目标不是测试库本身，因为它可能已经被很好地测试过了。</p><pre class="mf mg mh mi fq mj mc mk ml aw mm dt"><span id="9c4d" class="mn jd if mc b fv mo mp l mq mr">package flexmark.mendix;</span><span id="4666" class="mn jd if mc b fv ms mp l mq mr">import org.junit.Assert;<br/>import org.junit.Test;</span><span id="bac6" class="mn jd if mc b fv ms mp l mq mr">public class MarkdownToHTMLConverterTest {</span><span id="8eb4" class="mn jd if mc b fv ms mp l mq mr">    @Test public void basicTest() {<br/>        MarkdownToHTMLConverter converter = MarkdownToHTMLConverter.createConverter();<br/>        Assert.assertEquals("&lt;p&gt;This is &lt;em&gt;Sparta&lt;/em&gt;&lt;/p&gt;\\n", converter.convert("This is *Sparta*"));<br/>    }</span><span id="a697" class="mn jd if mc b fv ms mp l mq mr">}</span></pre><p id="d8c3" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">点击绿色小<em class="lg">运行</em>按钮，即可从IntelliJ启动测试。如果测试通过，下一步就是打包(构建)这个库，这样它就可以被导入到我们的Mendix项目中。</p><h1 id="e1c0" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">第五步:建造一个胖罐子</h1><p id="7a31" class="pw-post-body-paragraph kb kc if bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">这个特性不是gradle自带的，所以首先我们需要安装一个gradle插件。</p><p id="5b11" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">将以下代码片段添加到<code class="eh lz ma mb mc b">plugins</code>下的<code class="eh lz ma mb mc b">build.gradle</code>文件的顶部(java上方)</p><p id="192f" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><code class="eh lz ma mb mc b">id 'com.github.johnrengelman.shadow' version '5.1.0'</code></p><p id="0a2e" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这将插件添加到项目中，并让我们使用gradle的新命令。在命令行窗口中键入:</p><p id="71a4" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><code class="eh lz ma mb mc b">gradle shadowJar</code></p><p id="b1a3" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这将生成一个jar文件，包含<code class="eh lz ma mb mc b">build\\libs\\</code>下的所有依赖项。每当您对代码或依赖项进行更改时，都需要重复这个过程。</p><h1 id="bc7a" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">第六步:跟踪</h1><p id="3394" class="pw-post-body-paragraph kb kc if bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated"><a class="ae ka" href="https://stackoverflow.com/questions/49810578/what-is-a-shaded-jar-and-what-is-the-difference-similarities-between-uber-jar-a#:~:text=If%20your%20uber%20JAR%20is,packages%20within%20the%20uber%20JAR.)" rel="noopener ugc nofollow" target="_blank">隐藏</a>是在字节代码级别重命名java包的过程，以允许在一个java应用程序中使用两个同名的包。这样做通常是为了避免包的两个不同版本之间的版本冲突。在gradle中，可以通过在<code class="eh lz ma mb mc b">build.gradle</code>文件的底部添加以下代码片段来隐藏包。</p><p id="9169" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><code class="eh lz ma mb mc b">shadowJar { relocate 'org.apache', 'flexmark.mendix.org.apache' }</code></p><p id="0840" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">这将把所有以<code class="eh lz ma mb mc b">org.apache</code>开始的java包重命名为<code class="eh lz ma mb mc b">flexmark.mendix.org.apache</code>。要确认重命名是否有效，请使用类似7-zip的zip检查器检查jar文件内容。</p><p id="ce62" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">为了将来的证明，最好隐藏所有的依赖项，甚至那些今天可能不会引起问题的依赖项。通过添加多个<code class="eh lz ma mb mc b">relocate</code>行，可以隐藏多个依赖项。</p><p id="81b5" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">🔴不幸的是，隐藏不能处理依赖于反射的库，所以如果你遇到了类加载问题，可能需要取消隐藏那些有问题的库。</p><h1 id="d9e6" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">步骤7:使用Mendix中的库</h1><p id="621f" class="pw-post-body-paragraph kb kc if bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">将fat jar从<code class="eh lz ma mb mc b">build\\libs\\</code>复制到您的Mendix项目目录的<code class="eh lz ma mb mc b">userlib</code>文件夹中。</p><p id="7405" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">然后创建一个Mendix Java动作，以便可以从微流中调用Java库。参数和返回值的数量和类型将根据使用情况而变化。设计好的java动作可能需要一篇单独的博客文章。这里我只提一招:</p><p id="b30a" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">以下划线结尾命名参数。这防止了一个已知的Mendix问题，即如果参数名是一个保留字，它将在java中以后缀形式出现。下划线阻止了这种情况的发生，并且在微流中调用java操作时实际上是不可见的。</p><figure class="mf mg mh mi fq hw fe ff paragraph-image"><div class="fe ff mt"><img src="../Images/ea9fa1754bc979e20b939f2278760c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*D9MARmPKLgFRQclgDUQCAQ.png"/></div></figure><p id="021f" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">最后，从java操作中调用在步骤3中编码的接口。因为我们使用一个外观来隐藏第三方库的复杂性，所以这部分通常只有一两行。</p><pre class="mf mg mh mi fq mj mc mk ml aw mm dt"><span id="e8f3" class="mn jd if mc b fv mo mp l mq mr">import flexmark.mendix.MarkdownToHTMLConverter;</span><span id="6f52" class="mn jd if mc b fv ms mp l mq mr">// LINES OMMITED FOR BREVITY</span><span id="f35b" class="mn jd if mc b fv ms mp l mq mr">@java.lang.Override<br/>	public java.lang.String executeAction() throws Exception<br/>	{<br/>		// BEGIN USER CODE<br/>		MarkdownToHTMLConverter converter = MarkdownToHTMLConverter.create();<br/>		return converter.convert(Markdown_);<br/>		// END USER CODE<br/>	}</span></pre><p id="1114" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">分步指南到此结束。你可以在https://github.com/gajduk/flexmark-mendix<a class="ae ka" href="https://github.com/gajduk/flexmark-mendix" rel="noopener ugc nofollow" target="_blank">找到完整的源代码。</a></p><h1 id="5e18" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">包裹</h1><p id="36c5" class="pw-post-body-paragraph kb kc if bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx hn dt translated">向Mendix添加java库可能会非常棘手。简单的往userlib文件夹里扔东西肯定会惹上麻烦。多年来，我遇到了许多问题，这些问题促使我开发了上面描述的过程。</p><p id="a2ad" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">虽然我的过程还远非完美，所以如果你有任何改进的建议，请通过Mendix slack或电子邮件联系我，这将是一个很好的学习机会。</p><p id="e470" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">您添加第三方依赖项的流程是什么？</p><p id="b3f9" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">我希望你喜欢这篇博文，并且它能帮助你更容易地使用java依赖项。</p></div><div class="ab cl mu mv hb mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><p id="ea62" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><em class="lg">最初发表于</em> <a class="ae ka" href="https://www.notion.so/gajduk/Best-practice-for-adding-a-java-dependency-to-Mendix-e2ee2b5776c145f99f8e9fc77f2b62b6" rel="noopener ugc nofollow" target="_blank"> <em class="lg">安德烈·加杜克的博客</em> </a> <em class="lg">。</em></p><figure class="mf mg mh mi fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nb"><img src="../Images/90fb4a8b8f00c6028af91adfa6dcff90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLXQ7C11zwe1zlhv5QoQ4A.jpeg"/></div></div></figure></div><div class="ab cl mu mv hb mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="hn ho hp hq hr"><p id="3315" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><em class="lg">来自发布者- </em></p><p id="f886" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">如果你喜欢这篇文章，你可以在我们的 <a class="ae ka" href="https://medium.com/mendix" rel="noopener"> <em class="lg">媒体页面</em> </a> <em class="lg">或我们自己的</em> <a class="ae ka" href="https://developers.mendix.com/community-blog/" rel="noopener ugc nofollow" target="_blank"> <em class="lg">社区博客网站</em> </a> <em class="lg">找到更多类似的内容。</em></p><p id="9453" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated"><em class="lg">希望入门的创客可以注册一个</em> <a class="ae ka" href="https://developers.mendix.com/meetups/#meetupsNearYou" rel="noopener ugc nofollow" target="_blank"> <em class="lg">免费账号</em> </a> <em class="lg">，通过我们的</em> <a class="ae ka" href="https://academy.mendix.com/link/home" rel="noopener ugc nofollow" target="_blank"> <em class="lg">学苑</em> </a> <em class="lg">获得即时学习。</em></p><p id="1698" class="pw-post-body-paragraph kb kc if bd b kd ky kf kg kh kz kj kk kl la kn ko kp lb kr ks kt lc kv kw kx hn dt translated">有兴趣加入我们的社区吗？你可以加入我们的 <a class="ae ka" href="https://join.slack.com/t/mendixcommunity/shared_invite/zt-hwhwkcxu-~59ywyjqHlUHXmrw5heqpQ" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> slack社区频道</em> </a> <em class="lg">或者那些想更多参与的人，看看加入我们的</em> <a class="ae ka" href="https://developers.mendix.com/meetups/#meetupsNearYou" rel="noopener ugc nofollow" target="_blank"> <em class="lg">聚会</em> </a> <em class="lg">。</em></p></div></div>    
</body>
</html>