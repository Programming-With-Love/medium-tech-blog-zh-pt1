<html>
<head>
<title>Animating your keyboard (part 2): reacting to WindowInset animations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作键盘动画(第2部分):对窗口插入动画做出反应</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/animating-your-keyboard-reacting-to-inset-animations-839be3d4c31b?source=collection_archive---------1-----------------------#2020-08-24">https://medium.com/androiddevelopers/animating-your-keyboard-reacting-to-inset-animations-839be3d4c31b?source=collection_archive---------1-----------------------#2020-08-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/4a97ea2f7650ef944f9c0c944db7be52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUpssTgj4RtmJaV67TwJWQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/_kiranpuri" rel="noopener ugc nofollow" target="_blank">Kiran Puri</a></figcaption></figure><div class=""/><div class=""><h2 id="0c63" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">使用WindowInsetAnimation创建无缝键盘动画</h2></div><p id="b7de" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在上一篇博文中，我们介绍了与边缘到边缘相关的API的所有变化:</p><div class="hg hh ez fb hi ki"><a rel="noopener follow" target="_blank" href="/androiddevelopers/animating-your-keyboard-fb776a8fb66d"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hy fi z dy kn ea eb ko ed ef hw bi translated">动画你的键盘</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">新的WindowInsets APIs用于检查键盘(IME)的可见性和大小</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">medium.com</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw ho ki"/></div></div></a></div></div><div class="ab cl kx ky go kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ha hb hc hd he"><p id="3f93" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这篇博文中，我们继续实际的键盘动画任务。为了演示什么是可能的，这里你可以看到一个相同的应用程序的例子，在左边的Android 10上运行，在右边的<a class="ae hu" href="http://developer.android.com/android11" rel="noopener ugc nofollow" target="_blank"> Android 11 </a>(以20%的速度):</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es le"><img src="../Images/4f4047fc3678ee48dea0fe3721817a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9wELaIXfyzEQrHlsU2jkug.gif"/></div></div></figure><p id="4383" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在运行Android 10及更早版本的设备上，当用户点击文本输入来键入回复时，键盘会自动就位，但应用程序会在不同状态之间切换。这是你已经在你的设备上看到一段时间的行为，只是在20%的速度下更容易看到。</p><p id="7715" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在右边，你可以看到同样的场景运行在<a class="ae hu" href="https://developer.android.com/android11" rel="noopener ugc nofollow" target="_blank"> Android 11 </a>上。这一次，当用户点击文本输入时，应用程序用键盘的移动<strong class="jo hy">，创造了一个更加无缝的体验。</strong></p><p id="a592" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">那么如何将这种体验加入到你的app中呢？这都是由一些新的API驱动的…</p><h1 id="bc30" class="lj lk hx bd ll lm ln lo lp lq lr ls lt jd lu je lv jg lw jh lx jj ly jk lz ma bi translated">窗口动画</h1><p id="3b3f" class="pw-post-body-paragraph jm jn hx jo b jp mb iy jr js mc jb ju jv md jx jy jz me kb kc kd mf kf kg kh ha bi translated">Android 11中支持这一点的API是新的<code class="du mg mh mi mj b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsAnimation" rel="noopener ugc nofollow" target="_blank">WindowInsetsAnimation</a></code>类，它封装了一个包含插图的动画。应用程序可以通过<code class="du mg mh mi mj b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsAnimation.Callback" rel="noopener ugc nofollow" target="_blank">WindowInsetsAnimation.Callback</a></code>类监听动画事件，该类可以在视图上设置:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="50de" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">所以让我们来看看回调类，以及它提供的函数:</p><p id="c76f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">假设键盘当前是关闭的，用户刚刚点击了一个<code class="du mg mh mi mj b">EditText</code>。系统现在将开始显示键盘，由于我们有了一个<code class="du mg mh mi mj b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsAnimation.Callback" rel="noopener ugc nofollow" target="_blank">WindowInsetsAnimation.Callback</a></code>集合，我们将依次收到以下调用:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="cb1e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这就是回调在理论上的工作方式，现在让我们将它应用到一个场景中…</p><h1 id="a087" class="lj lk hx bd ll lm ln lo lp lq lr ls lt jd lu je lv jg lw jh lx jj ly jk lz ma bi translated">实现示例</h1><p id="15f2" class="pw-post-body-paragraph jm jn hx jo b jp mb iy jr js mc jb ju jv md jx jy jz me kb kc kd mf kf kg kh ha bi translated">我们将使用<code class="du mg mh mi mj b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsAnimation.Callback" rel="noopener ugc nofollow" target="_blank">WindowInsetsAnimation.Callback</a></code>来实现你在这篇博文开头看到的例子。所以让我们开始实现我们的回调:</p><h2 id="300c" class="mm lk hx bd ll mn mo mp lp mq mr ms lt jv mt mu lv jz mv mw lx kd mx my lz mz bi translated">onPrepare()</h2><p id="0179" class="pw-post-body-paragraph jm jn hx jo b jp mb iy jr js mc jb ju jv md jx jy jz me kb kc kd mf kf kg kh ha bi translated">首先我们将覆盖<code class="du mg mh mi mj b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsAnimation.Callback#onPrepare(android.view.WindowInsetsAnimation)" rel="noopener ugc nofollow" target="_blank">onPrepare()</a></code>，并记录视图的<strong class="jo hy">底部坐标</strong>，在发生任何布局变化之前的<em class="na">:</em></p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nb"><img src="../Images/69c35d6946af1d8dc2094edda0007ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtS-M93Qjv0lhQegXsPgDg.png"/></div></div></figure><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="c671" class="mm lk hx bd ll mn mo mp lp mq mr ms lt jv mt mu lv jz mv mw lx kd mx my lz mz bi translated">Insets派遣</h2><p id="e9d2" class="pw-post-body-paragraph jm jn hx jo b jp mb iy jr js mc jb ju jv md jx jy jz me kb kc kd mf kf kg kh ha bi translated">此时，结束状态的insets将被发送，我们的<code class="du mg mh mi mj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/OnApplyWindowInsetsListener" rel="noopener ugc nofollow" target="_blank">OnApplyWindowInsetsListener</a></code>被调用。我们的侦听器更新容器视图的填充，这导致内容被向上推。</p><p id="89b4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">用户永远看不到这一点，我们将在下面看到。</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nb"><img src="../Images/66888fec9ec8bcf5744e434e930588a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qw75S_SOJ8_HZN40LsBOgA.png"/></div></div></figure><h2 id="c332" class="mm lk hx bd ll mn mo mp lp mq mr ms lt jv mt mu lv jz mv mw lx kd mx my lz mz bi translated">onStart()</h2><p id="1022" class="pw-post-body-paragraph jm jn hx jo b jp mb iy jr js mc jb ju jv md jx jy jz me kb kc kd mf kf kg kh ha bi translated">接下来是我们的<code class="du mg mh mi mj b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsAnimation.Callback#onStart(android.view.WindowInsetsAnimation,%20android.view.WindowInsetsAnimation.Bounds)" rel="noopener ugc nofollow" target="_blank">onStart()</a></code>函数，它首先允许我们记录视图的<strong class="jo hy">结束</strong>位置。</p><p id="f8da" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们还使用<code class="du mg mh mi mj b">translationY</code>将视图可视地向下移动到原始位置，因为我们不希望用户看到现在的结束状态。用户看不到闪烁，因为系统保证从上面的插入过程触发的任何布局都在与<code class="du mg mh mi mj b">onStart()</code>相同的帧中被调用。</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nb"><img src="../Images/2cbd13577cb8ffb8785a4b8d39701a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_EYNFB4cNL61AhviJSiBmw.gif"/></div></div></figure><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="319d" class="mm lk hx bd ll mn mo mp lp mq mr ms lt jv mt mu lv jz mv mw lx kd mx my lz mz bi translated">onProgress()</h2><p id="c027" class="pw-post-body-paragraph jm jn hx jo b jp mb iy jr js mc jb ju jv md jx jy jz me kb kc kd mf kf kg kh ha bi translated">最后，我们覆盖了<code class="du mg mh mi mj b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsAnimation.Callback#onProgress(android.view.WindowInsets,%20java.util.List%3Candroid.view.WindowInsetsAnimation%3E)" rel="noopener ugc nofollow" target="_blank">onProgress()</a></code>,它允许我们在键盘滑入时更新视图。</p><p id="5ae8" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们再次使用<code class="du mg mh mi mj b">translationY</code>，在开始和结束状态之间进行插值，以使视图与键盘同步移动。</p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nc"><img src="../Images/4d19945870d924c8a9cc179a950072e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dAYsHps6Q3BOsFpel1B0kA.gif"/></div></div></figure><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="mk ml l"/></div></figure></div><div class="ab cl kx ky go kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ha hb hc hd he"><h1 id="b6bc" class="lj lk hx bd ll lm nd lo lp lq ne ls lt jd nf je lv jg ng jh lx jj nh jk lz ma bi translated">键盘协同</h1><p id="ebdd" class="pw-post-body-paragraph jm jn hx jo b jp mb iy jr js mc jb ju jv md jx jy jz me kb kc kd mf kf kg kh ha bi translated">这样，我们就实现了键盘和应用程序视图之间的同步。如果您想查看完整的实现，请查看<a class="ae hu" href="https://github.com/android/user-interface-samples/tree/master/WindowInsetsAnimation" rel="noopener ugc nofollow" target="_blank"><strong class="jo hy">windowinsetanimation</strong></a>示例:</p><div class="hg hh ez fb hi ki"><a href="https://github.com/android/user-interface-samples/tree/master/WindowInsetsAnimation" rel="noopener  ugc nofollow" target="_blank"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hy fi z dy kn ea eb ko ed ef hw bi translated">Android/用户界面-示例</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">这个例子展示了如何对屏幕键盘(IME)改变可见性做出反应，以及如何控制IME的…</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">github.com</p></div></div><div class="kr l"><div class="ni l kt ku kv kr kw ho ki"/></div></div></a></div><p id="1e50" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你把它添加到你的应用中，请在<a class="ae hu" href="https://twitter.com/chrisbanes" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或下面的评论中告诉我们，以及你是如何找到它的！</p><p id="1eee" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在下一篇博文中，我们将探索你的应用程序如何<strong class="jo hy">控制</strong>键盘，允许像列表滚动这样的事情自动打开键盘。敬请期待！</p></div><div class="ab cl kx ky go kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ha hb hc hd he"><h2 id="27ae" class="mm lk hx bd ll mn mo mp lp mq mr ms lt jv mt mu lv jz mv mw lx kd mx my lz mz bi translated"><strong class="ak">视图剪辑</strong></h2><p id="af1e" class="pw-post-body-paragraph jm jn hx jo b jp mb iy jr js mc jb ju jv md jx jy jz me kb kc kd mf kf kg kh ha bi translated">如果你尝试在你自己的视图中实现这一点，你会发现我们在这篇博文中讨论的技术会导致视图在动画中被剪切。这是因为我们正在翻译视图，这些视图可能已经通过您的<code class="du mg mh mi mj b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/OnApplyWindowInsetsListener" rel="noopener ugc nofollow" target="_blank">OnApplyWindowInsetsListener</a></code>的布局更改进行了调整。</p><p id="50f7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们将在以后的博客文章中探讨如何解决这一问题，但现在我建议浏览一下<a class="ae hu" href="https://github.com/android/user-interface-samples/tree/master/WindowInsetsAnimation" rel="noopener ugc nofollow" target="_blank"><strong class="jo hy">windowinsetanimation</strong></a>示例，其中包含一种避免这一问题的技巧。</p></div></div>    
</body>
</html>