<html>
<head>
<title>Services. The life with/without. And WorkManager.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务。有/没有的生活。和工作管理器。</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/services-the-life-with-without-and-worker-6933111d62a6?source=collection_archive---------0-----------------------#2018-05-10">https://medium.com/google-developer-experts/services-the-life-with-without-and-worker-6933111d62a6?source=collection_archive---------0-----------------------#2018-05-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d194" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随着最近Android版本处理后台，它变得比以往任何时候都更加复杂。就像《星球大战》的情节一样，它变得越来越复杂，因此，谷歌发布了<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/workmanager" rel="noopener ugc nofollow" target="_blank">工作管理器</a>作为<a class="ae jc" href="https://developer.android.com/jetpack/" rel="noopener ugc nofollow" target="_blank"> JetPack </a>的一部分——以帮助我们处理这样的背景。</p><p id="e5c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在了解什么是WorkManager之前，有必要了解我们为什么需要它，以及构建它的原因是什么。<em class="jd">那些知道组件/库背后发生了什么，并且理解他们为什么使用它的开发人员是一个更好的开发人员。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/a3a337db12256c61a75f2f42149df7e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DLWaaHF41cdm8A_cuAFenQ.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Better developer</figcaption></figure><p id="9518" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将是一篇很长的文章，所以准备一杯好咖啡&amp;几块饼干。<br/>它由3部分组成:<br/>第1部分—内存基础知识<br/>第2部分—现有后台解决方案<br/>第3部分—工作管理器</p><p id="9a6a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，在开始所有后台工作之前，我们需要了解Android处理内存管理的一些基础知识。<br/>这将是我们的第一部分:</p><h1 id="e3bc" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">第1部分:安卓内存101</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ks"><img src="../Images/665b6d57b823e29a675429d507049296.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*gY5aVHyzaPAmzTmY104-GA.png"/></div></figure><p id="5523" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很久很久以前，在一个遥远的星系——Android内核第一次被开发出来，它是基于Linux内核的。Android和所有其他基于Linux内核的系统的主要区别在于，Android没有一个叫做“交换空间”的东西。</p><p id="002c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jd">Linux中的交换空间</em>在物理内存(RAM)满的时候使用。如果系统需要更多的内存资源并且RAM已满，内存中的非活动页面将被移动到交换空间。虽然交换空间可以帮助具有少量RAM的机器，但是它不应该被认为是更多RAM的替代品。交换空间位于硬盘上，硬盘的访问时间比物理内存慢</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kt"><img src="../Images/e452184aa85d3aa4e2ee5217b97bfa96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hjtc7CUeUyrLcWBuH3zoHw.png"/></div></div></figure><p id="d732" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Android中，没有“交换空间”这种东西。当系统内存不足时，它使用OOM黑仔来拯救一个星系。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/b1811baba45f15071b91863fa5ac0dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92pIQu01ijeZ08BulvDm3Q.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Out Of Memory Killer</figcaption></figure><p id="b79d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个人的目标是根据进程的“可见性状态”和消耗的内存量来杀死进程，从而释放内存。</p><p id="6b33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个流程由活动管理器给出其<code class="du kv kw kx ky b">oom_adj</code>分数。它是应用程序状态的组合(例如，前台、后台、带有服务的后台等)。).以下是所有<code class="du kv kw kx ky b">oom_adj</code>值的简短示例:</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="8a53" class="ld jv hh ky b fi le lf l lg lh"># Define the oom_adj values for the classes of processes that can be<br/># killed by the kernel.  These are used in ActivityManagerService.<br/>    setprop ro.FOREGROUND_APP_ADJ 0<br/>    setprop ro.VISIBLE_APP_ADJ 1<br/>    setprop ro.SECONDARY_SERVER_ADJ 2<br/>    setprop ro.BACKUP_APP_ADJ 2<br/>    setprop ro.HOME_APP_ADJ 4<br/>    setprop ro.HIDDEN_APP_MIN_ADJ 7<br/>    setprop ro.CONTENT_PROVIDER_ADJ 14<br/>    setprop ro.EMPTY_APP_ADJ 15</span></pre><p id="5cab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更高的<code class="du kv kw kx ky b">omm_adj</code>值更容易被内核的oom杀手杀死。当前前台应用的<code class="du kv kw kx ky b">omm_adj</code>为0。</p><p id="24c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">OOM killer使用基于空闲内存和<code class="du kv kw kx ky b">omm_adj</code>阈值的可配置规则。即，规则声明“如果释放内存&lt; X1，用<code class="du kv kw kx ky b">omm_adj</code>Y1杀死进程&gt;</p><p id="b000" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以基本上流程会是这样的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es li"><img src="../Images/b6791c60f4c6de5d44828653ff6003d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ly74zGARWEa1w8-peaYKlA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Every process assigned a score</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lj"><img src="../Images/7635ceb6587c3c4e3f0c5671bf545df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRvQ_NuncfJpA8GKLQsMVA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Kill all process with adj_oom &gt; 7 and memory consumption &gt; 10kb</figcaption></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lk"><img src="../Images/62ebcd22b6365e69b2a6f8d8c6a27c43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PfaGp9ZIE5LJPwbnt-hD1w.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">The memory is freed. The galaxy in good hands now.</figcaption></figure><p id="304d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">到目前为止，我希望你有这样的想法，你消耗的内存越少，你就有更好的机会去完成重要的事情。</p><p id="c601" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个重要的想法是理解应用程序的状态是至关重要的。因此，当你的应用程序进入后台，而你仍然想把卢克送入太空时，你必须使用“服务”</p><blockquote class="ll lm ln"><p id="5eff" class="ie if jd ig b ih ii ij ik il im in io lo iq ir is lp iu iv iw lq iy iz ja jb ha bi translated">服务是可以在<strong class="ig hi">后台</strong>执行<strong class="ig hi">长时间运行操作</strong>的应用组件，它不提供用户界面。</p></blockquote><p id="62e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您应该使用服务有几个原因:</p><p id="5b4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.告诉系统您有一个长时间运行的操作，并相应地获得您的流程<code class="du kv kw kx ky b">oom_adj</code>分数</p><p id="2490" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.Android应用程序的4个入口点之一(<code class="du kv kw kx ky b">BroadcastReceiver</code>、<code class="du kv kw kx ky b">Activity</code>、<code class="du kv kw kx ky b">ContentProvider</code>是其余3个)。</p><p id="8572" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.在单独的进程上运行<code class="du kv kw kx ky b">Service</code></p><p id="0b68" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是使用服务也有不好的一面:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lr"><img src="../Images/d944224320aa3cff730cbab36128b3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*GdgZ3ZCBfqNPcOkf-ozm6A.png"/></div></figure><p id="27e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我编写第一个应用程序时，我成功地在不到3小时内将电池从100%耗尽到0%。怎么会？让服务每3分钟从服务器获取数据:)</p><p id="774e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我是一个年轻的没有经验的学徒。</p><p id="fd5f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但不知何故，6年后，有一些其他未知的应用程序不知何故成功地做了同样的事情:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ls"><img src="../Images/33b6922f4f0a47ef6e02da02d169a9f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hm15Qj2G8Pd8oYG18gqWQg.png"/></div></div></figure><p id="9aa6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个开发人员都在后台做他们想做的事情，没有任何限制。那只是蛮荒的西部，西斯统治着银河系，只有少数绝地反击。</p><p id="d904" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是谷歌有一些好的反叛者可以反击</p><p id="f868" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从棉花糖开始，然后是牛轧糖，接着引入了瞌睡模式:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lk"><img src="../Images/7f39793aab687675f4022a2946f14fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*knsDGvw9BVaOPgCfro-k7g.png"/></div></div></figure><p id="10a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你不熟悉瞌睡模式，你真的应该熟悉。:)简而言之——用户关闭设备屏幕后，瞌睡模式就会启动，并禁用网络、同步、GPS、警报和wifi扫描。它会一直亮着，直到用户打开屏幕或连接到充电器。这个想法——减少做不重要工作的应用程序的数量，这样做——可以节省用户的电池:)</p><p id="fb7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但这感觉就像大海中的一滴水，所以谷歌走得更远——从Android Oreo (API 26)开始</p><p id="750b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果针对Android 8.0的应用程序试图在不允许创建后台服务的情况下使用该方法，则<code class="du kv kw kx ky b">startService()</code>方法现在会抛出<a class="ae jc" href="https://developer.android.com/reference/java/lang/IllegalStateException.html" rel="noopener ugc nofollow" target="_blank"> </a> <code class="du kv kw kx ky b"><a class="ae jc" href="https://developer.android.com/reference/java/lang/IllegalStateException.html" rel="noopener ugc nofollow" target="_blank">IllegalStateException</a></code>。</p><p id="f1cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不针对SDK 26很容易解决这个问题。一些“知名”应用程序决定以API 22为目标，因为不想处理运行时权限。</p><p id="4426" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是更多的还在后面:</p><ul class=""><li id="052c" class="lt lu hh ig b ih ii il im ip lv it lw ix lx jb ly lz ma mb bi translated">【2018年8月:要求针对API等级26 (Android 8.0)或更高的新应用。</li><li id="b276" class="lt lu hh ig b ih mc il md ip me it mf ix mg jb ly lz ma mb bi translated">【2018年11月:针对API等级26或更高要求对现有应用进行更新。</li><li id="67eb" class="lt lu hh ig b ih mc il md ip me it mf ix mg jb ly lz ma mb bi translated"><strong class="ig hi"> 2019年起</strong>:targetSdkVersion要求每年都会提高。在每次Android甜点发布后的一年内，新的应用程序和应用程序更新将需要针对相应的API级别或更高的级别。</li></ul><p id="8eb3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">说了这么多——(我相信你会得出同样的结论):</p><blockquote class="mh"><p id="c797" class="mi mj hh bd mk ml mm mn mo mp mq jb dx translated">我们今天所知道的服务已经过时了。</p><p id="091f" class="mi mj hh bd mk ml mm mn mo mp mq jb dx translated">它不再被允许实现其主要目的，即在后台执行长期运行的任务。因此它不再可用。</p></blockquote><figure class="mr ms mt mu mv jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lj"><img src="../Images/cb42c2b55c91946608207774db44c3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ISeFOxwzOKMzsoz3SMm9Nw.png"/></div></div></figure><p id="e2b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除非你没有使用服务作为前台服务，否则没有任何理由使用服务。如果你需要依赖它，你需要一份工作。</p><h1 id="ec77" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">第2部分:我有一个网络呼叫。外面是什么:</h1><p id="8da1" class="pw-post-body-paragraph ie if hh ig b ih mw ij ik il mx in io ip my ir is it mz iv iw ix na iz ja jb ha bi translated">让我们以一个简单的网络调用为例，它可以下载几千字节的数据。</p><p id="9960" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，最直接的方法(也是不正确的方法)是用一个单独的线程来执行您的存储库/活动。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="47dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">考虑登录场景。你的用户填写电子邮件，密码，并点击登录按钮。用户网络3G差，用户走电梯。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es nd"><img src="../Images/7923255be80f08111ad34a687785a05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*DowodaaAVVGQzl-myMEOAw.gif"/></div></figure><p id="6f32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当网络通话进行时，用户会接到一个电话。</p><p id="d423" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jd"> OkHttp </em>默认超时蛮大<br/> <code class="du kv kw kx ky b">connectTimeout = 10_000;<br/>readTimeout = 10_000;<br/>writeTimeout = 10_000;</code></p><p id="2d6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通常，我们将默认设置为三次网络重试。</p><p id="2041" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，在最坏的情况下:3 * 30 = 90秒。</p><p id="78a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在试着回答一个问题—</p><h1 id="ffbe" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">登录成功了吗？</h1><p id="280b" class="pw-post-body-paragraph ie if hh ig b ih mw ij ik il mx in io ip my ir is it mz iv iw ix na iz ja jb ha bi translated">好吧，虽然你的应用程序在后台，但问题是——你不知道。正如我们所了解的，您不能依赖您的进程将保持活动来完成网络调用、处理响应和保存用户登录信息。更不用说用户的手机可以离线，失去互联网连接。</p><p id="5386" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从用户的角度来看——“我已经输入了我的电子邮件、密码，并点击了登录按钮。因此我已经登录了”。如果没有，相信我——用户会对你的UX有一些不好的看法。但这不是UX的问题，这是技术问题。<br/>下一步你可能会想——好吧，所以一旦我收到应用程序将转到后台的回调，我将切换到服务。但是……等等。不可以！！！:(</p><p id="1485" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以这里<code class="du kv kw kx ky b">JobScheduler</code>来救援了。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="116c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">预定了一场<code class="du kv kw kx ky b">Job</code>开始。当合适的时候——系统将启动你的<code class="du kv kw kx ky b">MyJobService</code>并执行<code class="du kv kw kx ky b">onStartJob()</code>方法中的任何东西。<br/>这个想法在理论上是好的，但是<code class="du kv kw kx ky b">JobScheduler</code>只能从min API 21获得。但是，API 21 &amp; 22中的… <br/> <code class="du kv kw kx ky b">JobScheduler</code>有一个非常容易出错的组件。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ne"><img src="../Images/c7856fdcad9c69f1ce5b1ccc616e40ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WW4PPUhUV47MbAiBC1wxFQ.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nf"><img src="../Images/7aeecbf7df75e096dffe0005d4b8e7cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5OvGQThDySJnNudb1paWg.png"/></div></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ng"><img src="../Images/222045629566e1f069e7fa0f89a6c90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pzfHagD5tJCHjDf6w7oWpg.png"/></div></div></figure><p id="350a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着你可以使用的真正的明斯克<code class="du kv kw kx ky b">JobScheduler</code>是从23开始的。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nh"><img src="../Images/34bf421b09cc6c65c1fdbabf44bdfbe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86eW_Ec87-MLg6Z4RAKe_w.png"/></div></div></figure><p id="6d53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在你的minSDK &lt; 23.. Then you have a  【T1】  option</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="11eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Wait. It’s requires Google Play Services!!</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ni"><img src="../Images/a970d175589c075afb4ea06a63d0cb75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHQqhpPYKNcK817BLbJ71g.png"/></div></div></figure><p id="ac28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Therefore If you are going to use it, you will leave tens of millions users out — all Amazon Fire, Amazon TV and hundreds of Chinese manufacturers:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nj"><img src="../Images/062b32e99cc5112068687822547860a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEQjxdfyz_gBBAO-CXUz7A.png"/></div></div></figure><p id="a90e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Therefore…  【T2】  probably isn’t a good option… So  【T3】 ? To schedule recurring alarms to fire and check if network call succeeds and then try to execute it again?…</p><p id="586f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">And what if you still want to benefit from old services on pre-O devices and run services to have zero-time latency to execute calls.</p><p id="150b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Than  【T4】  might help Jedis to save a galaxy:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nk"><img src="../Images/ea14c586fd228715aff7e882581548da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4acReBCQvng9JxElyT7l3A.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">JobIntentService</figcaption></figure><p id="1ce5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">It will give you the ability to execute jobs with regular IntentService on SDK lower than 26 and  【T5】  on SDK ≥ 26, and it’s part of the Support Library.</p><p id="da6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Aaaaand… It does not help to execute calls ASAP on Android Oreo devices… So we are back to where we started: , manage with an Android version we are running on, execute calls in the background and reschedule them when the app goes background with a proper scheduler, based on the device state.</p><p id="1cdf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Gosh… It’s so hard to be a good Jedi who is willing to save the users battery life and provide amazing UX to our users…</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/1432884fc0cc006b90b024f34c726200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_cJEvEKoo7EhTnNSTg0Wgg.gif"/></div></div></figure><h1 id="922f" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Part 3: WorkManager. Just because work should be easy to do.</h1><p id="5ddc" class="pw-post-body-paragraph ie if hh ig b ih mw ij ik il mx in io ip my ir is it mz iv iw ix na iz ja jb ha bi translated">So there are different solutions for different device states; Android versions and with/without Google Play Services devices. You probably will start to think that you need to implement all this hard work by yourself and combine different solutions based on “what and how.” The good thing is that the folks at the Android framework hear all our complaints — and they decided to rescue us and the whole galaxy from those Sith’s refactoring :)</p><p id="11ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">On the last Google I/O Android framework, the team announced WorkManager:</p><blockquote class="ll lm ln"><p id="b1f8" class="ie if jd ig b ih ii ij ik il im in io lo iq ir is lp iu iv iw lq iy iz ja jb ha bi translated">WorkManager aims to simplify the developer experience by providing a first-class API for system-driven background processing. It is intended for background jobs that should run even if the app is no longer in the foreground. Where possible, it uses <a class="ae jc" href="https://developer.android.com/reference/android/app/job/JobScheduler.html" rel="noopener ugc nofollow" target="_blank"> JobScheduler </a>或<a class="ae jc" href="https://github.com/firebase/firebase-jobdispatcher-android" rel="noopener ugc nofollow" target="_blank"> Firebase JobDispatcher </a>中做工作；如果你的应用程序在前台，它甚至会尝试直接在你的进程中工作。</p></blockquote><p id="a8f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">哇！这正是我们所需要的——所有这些疯狂的后台执行选项的简单包装。</p><p id="36fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">工作管理器库有几个组件:</p><p id="24cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">WorkManager</code> —接收带有参数&amp;约束的工作，并将其排入队列。</p><p id="1c87" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">Worker</code> —只有一个方法来实现在后台线程上执行的doWork()。它是你所有后台任务应该完成的地方。尽量保持简单。</p><p id="3a83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">WorkRequest</code> —工作请求指定哪个工人以什么参数排队，以及对它有什么约束(例如，互联网、收费)。</p><p id="3a70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">WorkResult</code> —成功，失败，重试。</p><p id="9bef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">Data</code> —一组持久的键/值对，传递给工作人员或从工作人员处接收。</p><p id="bd44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，创建新的类扩展<code class="du kv kw kx ky b">Worker</code>并实现<code class="du kv kw kx ky b">doWork()</code>方法:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="4d10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二次调用<code class="du kv kw kx ky b">WorkManager</code>来执行这项工作:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="fc59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">WorkManager</code>会负责休息。它会选择最佳的时间表来排列您的工作；它将存储所有的参数，工作细节，并更新您的工作状态。您甚至可以使用<code class="du kv kw kx ky b">LiveData</code>订阅来观察工作状态:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="225a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下面，工作管理器库的架构将如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nl"><img src="../Images/daa5c6d16de31dca7bc6a2852a9329a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VkznGM_XrSK9kmOujJCV6w.png"/></div></div></figure><p id="74f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您创建新的<code class="du kv kw kx ky b">Work</code>并指定哪个<code class="du kv kw kx ky b">Worker</code>应该在哪个<code class="du kv kw kx ky b">Constraints</code>下与哪个<code class="du kv kw kx ky b">Arguments</code>一起工作。<code class="du kv kw kx ky b">WorkManager</code>将工作保存在DB使用空间中，并立即入队<code class="du kv kw kx ky b">Work</code>。它选择可能的最佳调度程序(<code class="du kv kw kx ky b">Jobscheduler</code>、<code class="du kv kw kx ky b">JobDispatcher</code>、<code class="du kv kw kx ky b">Executor aka GreedyScheduler</code>、<code class="du kv kw kx ky b">AlarmManager</code>)并调用<code class="du kv kw kx ky b">doWork()</code>方法。结果通过<code class="du kv kw kx ky b">LiveData</code>发布，使用<code class="du kv kw kx ky b">Arguments</code>可获得输出</p><p id="d7b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就这么简单。</p><p id="116e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，还有更多。</p><p id="1299" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以安排一项周期性工作:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="dee1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以按顺序链接两个或多个作业:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="1060" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并行:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="10a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并混合在它们之间。</p><blockquote class="ll lm ln"><p id="f7fe" class="ie if jd ig b ih ii ij ik il im in io lo iq ir is lp iu iv iw lq iy iz ja jb ha bi translated">注意:不能将周期性工作和一次性工作一起排入队列。</p></blockquote><p id="7687" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你还可以用<code class="du kv kw kx ky b">WorkManager</code>做很多其他的事情:取消<code class="du kv kw kx ky b">Work</code>，合并<code class="du kv kw kx ky b">Work</code>，链接工作，合并一个<code class="du kv kw kx ky b">Work</code>到另一个<code class="du kv kw kx ky b">Work</code>的参数。我鼓励您研究这些文档。它有很多很好的例子。</p><h2 id="cf49" class="ld jv hh bd jw nm nn no ka np nq nr ke ip ns nt ki it nu nv km ix nw nx kq ny bi translated"><strong class="ak">现实生活场景</strong></h2><p id="ccfa" class="pw-post-body-paragraph ie if hh ig b ih mw ij ik il mx in io ip my ir is it mz iv iw ix na iz ja jb ha bi translated">我们需要建立一个应用程序，每15分钟跟踪用户的位置。</p><p id="ea2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们创建一个作业来获取位置。没有内置的异步方式来完成任务，因为<code class="du kv kw kx ky b"> doWork()</code>应该返回<code class="du kv kw kx ky b">Result.SUCCESS</code>，所以如果你需要一种异步方式来执行<code class="du kv kw kx ky b">doWork()</code>(例如，查询GPS位置)，你可以使用<code class="du kv kw kx ky b">Latch</code>和另一种机制来阻止执行:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="0e56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">计划它:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div><figcaption class="jq jr et er es js jt bd b be z dx">15 minutes is a minimum period for Periodic work</figcaption></figure><p id="da17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们完成位置获取操作时，我们将释放闩锁，当然还要清理所有的垃圾:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="8fd6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">获得LocationTracker后，我们需要将其上传到我们的服务器，因此我们将安排另一项一次性工作来将其上传到服务器:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="b3d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上传作品本身:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="nb nc l"/></div></figure><p id="a808" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">看起来简单？事实上——的确如此。<br/>不再有复杂的job schedulers/job dispatcher/Greed Executors样板代码。你创作一件作品，安排好时间，它就完成了。就这么简单。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/f06b41b1e21df6324ab10b8237c288cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iZro1zde22AxDI2qjWu47Q.gif"/></div></div></figure><h1 id="e6ca" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">总结</strong></h1><p id="350f" class="pw-post-body-paragraph ie if hh ig b ih mw ij ik il mx in io ip my ir is it mz iv iw ix na iz ja jb ha bi translated">在过去/未来的Android版本中，遵循节省用户电池的意愿，在后台运行变得更加复杂。感谢Android团队，我们有了一个工作管理器，使得处理背景变得更加自然和简单。</p><p id="5d46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后一件事。</p><p id="5bb7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">手机没电池了看起来怎么样？</p><p id="3ff5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi">.</p><p id="ef66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi">.</p><p id="c5c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi">.</p><p id="1675" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi">.</p><p id="ae0c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi">.</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nz"><img src="../Images/b63bbe9d96c06630eedb405dd1ceb50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-iyk5AoCAaxuxDEtD3XFw.png"/></div></div></figure><p id="1cbd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi">****</p><p id="bc61" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jd">感谢阅读。如果你喜欢它，请给我你的</em>👏<em class="jd">T11】👏<em class="jd">和大家分享一下这个。我也很乐意听到你的意见和建议:)谢谢</em></em></p></div></div>    
</body>
</html>