<html>
<head>
<title>Master Inheritance In Java With Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Java中的继承并举例说明</h1>
<blockquote>原文：<a href="https://medium.com/edureka/inheritance-in-java-f638d3ed559e?source=collection_archive---------1-----------------------#2018-12-20">https://medium.com/edureka/inheritance-in-java-f638d3ed559e?source=collection_archive---------1-----------------------#2018-12-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/9eea30f53067b2b64423c1151da9d5e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*s11OLfJQCnLjyi5wsITJeA.png"/></div><figcaption class="il im et er es in io bd b be z dx">Inheritance in Java - Edureka</figcaption></figure><p id="5346" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">面向对象编程(或者更好地称为OOPs)是Java的主要支柱之一，它充分利用了其强大的功能和易用性。要成为一名专业的Java开发人员，您必须对各种Java OOPs概念(如继承、抽象、封装和多态)有一个完美的控制。通过这篇文章，我将让你全面了解OOPs的一个最重要的概念，即Java中的继承，以及它是如何实现的。</p><p id="bcb4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是我将在本文中讨论的主题:</p><ul class=""><li id="c5bd" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">Java中的继承介绍</li><li id="81a2" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Java中的继承类型</li></ul><ol class=""><li id="803d" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kb jt ju jv bi translated">单一遗传</li><li id="e1f8" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">多层次继承</li><li id="dc41" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">分层继承</li><li id="c326" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">混合遗传</li></ol><ul class=""><li id="64ff" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">Java中的继承规则</li></ul><h1 id="74ac" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Java中的继承介绍</h1><p id="166b" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">在面向对象程序设计中，计算机程序是以这样一种方式设计的，即一切都是一个相互作用的对象。继承是Java OOPs不可分割的一部分，它允许一个类的属性被另一个类继承。它基本上有助于重用代码，并在不同的类之间建立关系。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lf"><img src="../Images/ce6ee11fa44621f2a315cfddc401960d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_14-yZeofO4AghAKbXiBPw.png"/></div></div></figure><p id="1647" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们知道，孩子继承父母的财产。在Java中遵循类似的概念，我们有两个类:</p><p id="8145" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1.父类(超类或基类)</p><p id="fce8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.子类(子类或派生类)</p><p id="093f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">继承属性的类称为子类，而属性被继承的类称为父类。</p><p id="d845" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">语法:</strong></p><p id="8185" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，为了继承一个类，我们需要使用<em class="lo">扩展</em>关键字。在下面的例子中，类Son是子类，类Mom是父类。Son类继承了Mom类的属性和方法。</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="32fb" class="lu kd hh lq b fi lv lw l lx ly">class Son extends Mom<br/>{<br/>//your code<br/>}</span></pre><p id="d428" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们来看一个小程序，了解一下它的工作原理。在这个例子中，我们有一个基类教师和一个子类Hadoop教师。由于HadoopTeacher类扩展了基类的属性，我们不需要在子类中声明这些属性和方法。</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="38ff" class="lu kd hh lq b fi lv lw l lx ly">class Teacher{<br/>String designation = "Teacher";<br/>String collegeName = "Edureka";<br/>void does(){<br/>System.out.println("Teaching");<br/>}<br/>}<br/>public class HadoopTeacher extends Teacher{<br/>String mainSubject = "Spark";<br/>public static void main(String args[]){<br/>HadoopTeacher obj = new HadoopTeacher();<br/>System.out.println(obj.collegeName);<br/>System.out.println(obj.designation);<br/>System.out.println(obj.mainSubject);<br/>obj.does();<br/>}<br/>}</span></pre><p id="a27c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">输出:</strong></p><p id="0600" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">爱德华卡</p><p id="d93e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">教师</p><p id="3a19" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">火花</p><p id="d1a6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">教学</p><p id="04eb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们进一步看看Java支持的各种类型的继承。</p><h1 id="e475" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Java中的继承类型</h1><p id="1778" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">下图描绘了继承的类型:</p><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lz"><img src="../Images/839d2dee86bf0d6ca6fbbec1ffa47962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0yDypFMUrzyweO0H9n3dw.png"/></div></div></figure><h2 id="df4f" class="lu kd hh bd ke ma mb mc ki md me mf km ja mg mh kq je mi mj ku ji mk ml ky mm bi translated">单一遗传</h2><p id="f664" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">在单一继承中，一个类继承另一个类的属性。它使派生类能够从单个父类继承属性和行为。反过来，这将支持代码的可重用性，并为现有的代码添加新的特性。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es mn"><img src="../Images/e76bb680b69126963fa47c37ed84dadb.png" data-original-src="https://miro.medium.com/v2/resize:fit:252/format:webp/1*HsLA3BVi9I2Z_-EK3HIWpw.png"/></div></figure><p id="1246" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，A类是你的父类，B类是你的子类，继承了父类的属性和行为。类似的概念在下面的代码中表示:</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="458c" class="lu kd hh lq b fi lv lw l lx ly">class Animal{<br/>void eat(){System.out.println(“eating”);}<br/>}<br/>class Dog extends Animal{<br/>void bark(){System.out.println(“barking”);}<br/>}<br/>class TestInheritance{<br/>public static void main(String args[]){<br/>Dog d=new Dog();<br/>d.bark();<br/>d.eat();<br/>}<br/>}</span></pre><h2 id="d90c" class="lu kd hh bd ke ma mb mc ki md me mf km ja mg mh kq je mi mj ku ji mk ml ky mm bi translated">多层次继承</h2><p id="f20b" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">当一个类从另一个类派生的类派生时，即一个类具有一个以上的父类但在不同的级别，这种类型的继承称为多级继承。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es mo"><img src="../Images/6bfb56e30ad74227bc10dff3dd4b0291.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*iPuEeVDfPjLBmc34yWSmog.png"/></div></figure><p id="03b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们讨论流程图，B类继承A类的属性和行为，C类继承B类的属性。这里A是B的父类，B类是C的父类。所以在这种情况下，C类隐式继承A类和B类的属性和方法。这就是多级继承。</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="7d79" class="lu kd hh lq b fi lv lw l lx ly">class Animal{<br/>void eat(){System.out.println(“eating…”);}<br/>}<br/>class Dog extends Animal{<br/>void bark(){System.out.println(“barking…”);}<br/>}<br/>class Puppy extends Dog{<br/>void weep(){System.out.println(“weeping…”);}<br/>}<br/>class TestInheritance2{<br/>public static void main(String args[]){<br/>Puppy d=new Puppy();<br/>d.weep();<br/>d.bark();<br/>d.eat();<br/>}<br/>}</span></pre><h2 id="9bcb" class="lu kd hh bd ke ma mb mc ki md me mf km ja mg mh kq je mi mj ku ji mk ml ky mm bi translated">分层继承</h2><p id="165a" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">当一个类有不止一个子类(子类)时，或者换句话说，不止一个子类有相同的父类，那么这种继承称为<strong class="ir hi">层次</strong>。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es mp"><img src="../Images/f3c2f6ef07a4777a0a2ca57c3856fa21.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*Px1aoITCk9vW925K6BSm-g.png"/></div></figure><p id="564c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的流程图中，B类和C类是继承自父类(即a类)的子类</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="1447" class="lu kd hh lq b fi lv lw l lx ly">class Animal{<br/>void eat(){System.out.println(“eating…”);}<br/>}<br/>class Dog extends Animal{<br/>void bark(){System.out.println(“barking…”);}<br/>}<br/>class Cat extends Animal{<br/>void meow(){System.out.println(“meowing…”);}<br/>}<br/>class TestInheritance3{<br/>public static void main(String args[]){<br/>Cat c=new Cat();<br/>c.meow();<br/>c.eat();<br/>}<br/>}</span></pre><h2 id="dd55" class="lu kd hh bd ke ma mb mc ki md me mf km ja mg mh kq je mi mj ku ji mk ml ky mm bi translated">混合遗传</h2><p id="f0cd" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">混合<strong class="ir hi"> </strong>遗传是两种或两种以上类型遗传的结合。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es mq"><img src="../Images/eda56823ef780255c98e79a063a8a2b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*2IVUxS-DoB9Oo5UTTXU-_w.png"/></div></figure><p id="9354" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们知道了什么是继承及其各种类型，让我们更进一步，看看继承类时应该考虑的一些重要规则。</p><h1 id="450b" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Java中的继承规则</h1><h2 id="9634" class="lu kd hh bd ke ma mb mc ki md me mf km ja mg mh kq je mi mj ku ji mk ml ky mm bi translated">规则Java中不允许多重继承。</h2><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es mr"><img src="../Images/4e5cbf71bd2b0005f2c32c4899a0c5a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*7Uhrp9bt5IjvvHQqYPGXFw.png"/></div></figure><p id="0470" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">多重继承指的是一个子类试图扩展多个父类的过程。在上图中，A类是B类和C类的父类，它们由d类进一步扩展。这导致了菱形问题。为什么？假设在类B和C中都有一个方法show()，但是功能不同。当D类扩展B类和C类时，它会自动继承B类和C类的特性，包括show()方法。现在，当您试图调用类B的show()时，编译器会弄不清要调用哪个show()(要么从类B调用，要么从类C调用)。因此，它会导致歧义。</p><p id="ce65" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lo">例如:</em> </strong></p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="b286" class="lu kd hh lq b fi lv lw l lx ly">class Demo1<br/>{<br/>//code here<br/>}<br/>class Demo2<br/>{<br/>//code here<br/>}<br/>class Demo3 extends Demo1, Demo2<br/>{<br/>//code here<br/>}<br/>class Launch<br/>{<br/>public static void main(String args[])<br/>{<br/>//code here<br/>}<br/>}</span></pre><p id="e72e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的代码中，Demo3是一个试图继承两个父类Demo1和Demo2的子类。这是不允许的，因为它会导致菱形问题和歧义。</p><blockquote class="ms mt mu"><p id="fe90" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated"><em class="hh">注意:Java不支持多重继承，但是您仍然可以使用接口来实现它。</em></p></blockquote><h2 id="3965" class="lu kd hh bd ke ma mb mc ki md me mf km ja mg mh kq je mi mj ku ji mk ml ky mm bi translated">规则Java中不允许循环继承。</h2><p id="b642" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">它是一种继承类型，在这种类型中，类扩展自己并形成自己的循环。现在想一想，如果一个类以任何方式扩展自己，如果它在用户定义的类中形成循环，那么还有机会扩展Object类。这就是Java中不允许它的原因。</p><p id="c662" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lo">例如:</em> </strong></p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="7afe" class="lu kd hh lq b fi lv lw l lx ly">class Demo1 extends Demo2<br/>{<br/>//code here<br/>}<br/>class Demo2 extends Demo1<br/>{<br/>//code here<br/>}</span></pre><p id="fd35" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的代码中，两个类都试图继承对方的字符，这是不允许的，因为这会导致歧义。</p><h2 id="bdb2" class="lu kd hh bd ke ma mb mc ki md me mf km ja mg mh kq je mi mj ku ji mk ml ky mm bi translated">规则3:私有成员不能被继承。</h2><p id="69b6" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated"><strong class="ir hi"> <em class="lo">例如:</em> </strong></p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="73c7" class="lu kd hh lq b fi lv lw l lx ly">class You<br/>{<br/>private int an;<br/>private int pw;<br/>You{<br/>an =111;<br/>pw= 222;<br/>}<br/>}<br/>class Friend extends You<br/>{<br/>void change Data()<br/>{<br/>an =8888;<br/>pw=9999;<br/>}<br/>}<br/>void disp()<br/>{<br/>System.out.println(an);<br/>System.out.println(pw);<br/>}<br/>}<br/>class Launch<br/>{<br/>public static void main(String args[])<br/>{<br/>Friend f = new Friend();<br/>f.change.Data();<br/>f.disp();<br/>}<br/>}</span></pre><p id="8517" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当你执行上面的代码时，猜猜会发生什么，你认为私有变量<em class="lo"> an </em>和<em class="lo"> pw </em>会被继承吗？绝对不行。它保持不变，因为它们特定于特定的类。</p><h2 id="8d40" class="lu kd hh bd ke ma mb mc ki md me mf km ja mg mh kq je mi mj ku ji mk ml ky mm bi translated">规则Java中不能继承构造函数。</h2><p id="24ad" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">构造函数不能被继承，因为子类总是有不同的名字。</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="3046" class="lu kd hh lq b fi lv lw l lx ly">class A {<br/>   A();}<br/> <br/>class B extends A{<br/>   B();}</span></pre><p id="2fee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你只能做:</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="4a60" class="lu kd hh lq b fi lv lw l lx ly">B b = new B(); // and not new A()</span></pre><p id="53be" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">相反，方法是以“相同的名称”继承的，并且可以使用。尽管如此，您仍然可以在B的实现中使用构造函数:</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="7086" class="lu kd hh lq b fi lv lw l lx ly"><strong class="lq hi">class</strong> <!-- -->B <strong class="lq hi">extends</strong> <!-- -->A{<br/>B() { <strong class="lq hi">super</strong>(); }<br/>}</span></pre><h2 id="825a" class="lu kd hh bd ke ma mb mc ki md me mf km ja mg mh kq je mi mj ku ji mk ml ky mm bi translated">规则5:在Java中，我们给子对象分配父引用。</h2><p id="100d" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">父对象是对恰好是父对象的子类型的对象的引用，即子对象。<em class="lo">为什么用这个？</em>嗯，简而言之，它防止你的代码与单个类紧密耦合。因为引用是父类的，所以它可以保存它的任何子类对象，即，它可以引用它的任何子类。</p><p id="63a8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它具有以下优点</p><ol class=""><li id="8177" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kb jt ju jv bi translated">动态方法调度允许Java支持方法的覆盖，这是运行时多态性的核心。</li><li id="5c97" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">它允许一个类指定对它的所有派生方法通用的方法，同时允许子类定义一些或所有这些方法的具体实现。</li><li id="884e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">它还允许子类添加其特定的方法子类来定义一些特定的实现。</li></ol><p id="5a4d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设您将getEmployeeDetails添加到父类，如以下代码所示:</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="fbe3" class="lu kd hh lq b fi lv lw l lx ly">public String getEmployeeDetails() {<br/>    return "Name: " + name;<br/>}</span></pre><p id="a663" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以在Child中覆盖该方法以提供更多的细节。</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="d3e1" class="lu kd hh lq b fi lv lw l lx ly">@Override<br/>public String getEmployeeDetails() {<br/>    return "Name: " + name + " Salary: " + salary;<br/>}</span></pre><p id="1159" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，您可以编写一行代码来获取任何可用的详细信息，无论该对象是父对象还是子对象，如下所示:</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="6572" class="lu kd hh lq b fi lv lw l lx ly">parent.getEmployeeDetails();</span></pre><p id="dcac" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后检查以下代码:</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="d8d2" class="lu kd hh lq b fi lv lw l lx ly">Parent parent = new Parent();<br/>parent.name = 1;<br/>Child child = new Child();<br/>child.name = 2;<br/>child.salary = 2000;<br/>Parent[] employees = new Parent[] { parent, child };<br/>for (Parent employee : employees) {<br/>    employee.getEmployeeDetails();<br/>}</span></pre><p id="92eb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将导致以下输出:</p><pre class="lg lh li lj fd lp lq lr ls aw lt bi"><span id="da51" class="lu kd hh lq b fi lv lw l lx ly">Name: 1 <br/>Name: 2 Salary: 2000</span></pre><p id="0840" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里我们使用了一个子类作为父类引用。它有一个子类所特有的特殊行为，但是如果我们调用getEmployeeDetails()，我们可以忽略功能差异，而专注于父类和子类是如何相似的。</p><h2 id="0f91" class="lu kd hh bd ke ma mb mc ki md me mf km ja mg mh kq je mi mj ku ji mk ml ky mm bi translated">规则6:由于构造函数中存在super()，所以构造函数会被执行。</h2><p id="5589" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">正如您已经知道的，构造函数不会被继承，但是会因为super()关键字而被执行。“super()”用于引用扩展类。默认情况下，它将引用对象类。Object中的构造函数不执行任何操作。如果一个构造函数没有显式调用超类构造函数，那么Java编译器默认会插入一个对超类的无参数构造函数的调用。</p><p id="e04b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就把我们带到了“Java中的继承”这篇文章的结尾。希望，你发现它信息丰富，有助于增加你的知识价值。</p><p id="0646" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想查看更多关于人工智能、DevOps、道德黑客等市场最热门技术的文章，你可以参考Edureka的官方网站。</p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释Java的各个方面。</p><blockquote class="ms mt mu"><p id="f1b5" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">1.<a class="ae my" rel="noopener" href="/edureka/object-oriented-programming-b29cfd50eca0">面向对象编程</a></p><p id="2217" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">2.<a class="ae my" rel="noopener" href="/edureka/java-tutorial-bbdd28a2acd7"> Java教程</a></p><p id="d320" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">3.<a class="ae my" rel="noopener" href="/edureka/polymorphism-in-java-9559e3641b9b">Java中的多态性</a></p><p id="8497" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">4.<a class="ae my" rel="noopener" href="/edureka/java-abstraction-d2d790c09037">Java中的抽象</a></p><p id="a0f2" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">5.<a class="ae my" rel="noopener" href="/edureka/java-string-68e5d0ca331f"> Java字符串</a></p><p id="1a6d" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">6.<a class="ae my" rel="noopener" href="/edureka/java-array-tutorial-50299ef85e5"> Java数组</a></p><p id="cfab" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">7.<a class="ae my" rel="noopener" href="/edureka/java-collections-6d50b013aef8"> Java集合</a></p><p id="e3a9" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">8.<a class="ae my" rel="noopener" href="/edureka/java-thread-bfb08e4eb691"> Java线程</a></p><p id="46ce" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">9.<a class="ae my" rel="noopener" href="/edureka/java-servlets-62f583d69c7e">Java servlet简介</a></p><p id="dfa3" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">10.<a class="ae my" rel="noopener" href="/edureka/servlet-and-jsp-tutorial-ef2e2ab9ee2a"> Servlet和JSP教程</a></p><p id="982a" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">11.<a class="ae my" rel="noopener" href="/edureka/java-exception-handling-7bd07435508c">Java中的异常处理</a></p><p id="c3ec" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">12.<a class="ae my" rel="noopener" href="/edureka/advanced-java-tutorial-f6ebac5175ec">高级Java教程</a></p><p id="8ec9" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">13.<a class="ae my" rel="noopener" href="/edureka/java-interview-questions-1d59b9c53973"> Java面试问题</a></p><p id="b945" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">14.<a class="ae my" rel="noopener" href="/edureka/java-programs-1e3220df2e76"> Java程序</a></p><p id="da6c" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">15.<a class="ae my" rel="noopener" href="/edureka/kotlin-vs-java-4f8653f38c04">科特林vs Java </a></p><p id="093b" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">16.<a class="ae my" rel="noopener" href="/edureka/what-is-dependency-injection-5006b53af782">依赖注入使用Spring Boot </a></p><p id="d990" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">17.<a class="ae my" rel="noopener" href="/edureka/comparable-in-java-e9cfa7be7ff7">Java中的可比</a></p><p id="3bcd" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">18.<a class="ae my" rel="noopener" href="/edureka/java-frameworks-5d52f3211f39">十大Java框架</a></p><p id="8f86" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">19.<a class="ae my" rel="noopener" href="/edureka/java-reflection-api-d38f3f5513fc"> Java反射API </a></p><p id="72a8" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">20.<a class="ae my" rel="noopener" href="/edureka/pattern-programs-in-java-f33186c711c8">Java中的30大模式</a></p><p id="c534" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">21.<a class="ae my" rel="noopener" href="/edureka/java-cheat-sheet-3ad4d174012c">核心Java备忘单</a></p><p id="d088" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">22.<a class="ae my" rel="noopener" href="/edureka/socket-programming-in-java-f09b82facd0">Java中的套接字编程</a></p><p id="83be" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">23.<a class="ae my" rel="noopener" href="/edureka/java-oop-cheat-sheet-9c6ebb5e1175"> Java OOP备忘单</a></p><p id="259e" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">24.<a class="ae my" rel="noopener" href="/edureka/annotations-in-java-9847d531d2bb">Java中的注释</a></p><p id="4330" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">25.<a class="ae my" rel="noopener" href="/edureka/library-management-system-project-in-java-b003acba7f17">Java中的图书管理系统项目</a></p><p id="85dd" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">26.<a class="ae my" rel="noopener" href="/edureka/java-binary-tree-caede8dfada5">Java中的树</a></p><p id="c8bd" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">27.<a class="ae my" rel="noopener" href="/edureka/machine-learning-in-java-db872998f368">Java中的机器学习</a></p><p id="b98b" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">28.<a class="ae my" rel="noopener" href="/edureka/data-structures-algorithms-in-java-d27e915db1c5">Java中的顶级数据结构&amp;算法</a></p><p id="d56f" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">29.<a class="ae my" rel="noopener" href="/edureka/java-developer-skills-83983e3d3b92"> Java开发者技能</a></p><p id="8981" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">30.<a class="ae my" rel="noopener" href="/edureka/servlet-interview-questions-266b8fbb4b2d">前55个Servlet面试问题</a></p><p id="adea" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">31.<a class="ae my" rel="noopener" href="/edureka/java-exception-handling-7bd07435508c"> </a> <a class="ae my" rel="noopener" href="/edureka/java-projects-db51097281e3">顶级Java项目</a></p><p id="a9cf" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">32.<a class="ae my" rel="noopener" href="/edureka/java-string-cheat-sheet-9a91a6b46540"> Java字符串备忘单</a></p><p id="6d4f" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">33.<a class="ae my" rel="noopener" href="/edureka/nested-classes-java-f1987805e7e3">Java中的嵌套类</a></p><p id="6688" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">34.<a class="ae my" rel="noopener" href="/edureka/java-collections-interview-questions-162c5d7ef078"> Java集合面试问答</a></p><p id="07f3" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">35.<a class="ae my" rel="noopener" href="/edureka/deadlock-in-java-5d1e4f0338d5">Java中如何处理死锁？</a></p><p id="d813" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">36.<a class="ae my" rel="noopener" href="/edureka/java-collections-interview-questions-6d20f552773e">你需要知道的50大Java集合面试问题</a></p><p id="9a52" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">37.<a class="ae my" rel="noopener" href="/edureka/java-string-pool-5b5b3b327bdf">Java中的字符串池是什么概念？</a></p><p id="e21b" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">38.<a class="ae my" rel="noopener" href="/edureka/difference-between-c-cpp-and-java-625c4e91fb95">C、C++和Java有什么区别？</a></p><p id="42fc" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">39.<a class="ae my" rel="noopener" href="/edureka/palindrome-in-java-5d116eb8755a">Java中的回文——如何检查一个数字或字符串？</a></p><p id="3737" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">40.<a class="ae my" rel="noopener" href="/edureka/mvc-interview-questions-cd568f6d7c2e">你需要知道的顶级MVC面试问答</a></p><p id="9579" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">41.<a class="ae my" rel="noopener" href="/edureka/applications-of-java-11e64f9588b0">Java编程语言的十大应用</a></p><p id="345e" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">42.<a class="ae my" rel="noopener" href="/edureka/deadlock-in-java-5d1e4f0338d5">Java中的死锁</a></p><p id="c6d7" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">43.<a class="ae my" rel="noopener" href="/edureka/java-sqrt-method-59354a700571">Java中的平方和平方根</a></p><p id="0263" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">44.<a class="ae my" rel="noopener" href="/edureka/type-casting-in-java-ac4cd7e0bbe1">Java中的类型转换</a></p><p id="b93e" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">45.<a class="ae my" rel="noopener" href="/edureka/operators-in-java-fd05a7445c0a">Java中的运算符及其类型</a></p><p id="836c" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">46.<a class="ae my" rel="noopener" href="/edureka/destructor-in-java-21cc46ed48fc">Java中的析构函数</a></p><p id="ce21" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">47.<a class="ae my" rel="noopener" href="/edureka/binary-search-in-java-cf40e927a8d3">Java中的二分搜索法</a></p><p id="7708" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">48.<a class="ae my" rel="noopener" href="/edureka/mvc-architecture-in-java-a85952ae2684">Java中的MVC架构</a></p><p id="fa9e" class="ip iq lo ir b is it iu iv iw ix iy iz mv jb jc jd mw jf jg jh mx jj jk jl jm ha bi translated">49.<a class="ae my" rel="noopener" href="/edureka/hibernate-interview-questions-78b45ec5cce8"> Hibernate面试问答</a></p></blockquote></div><div class="ab cl mz na go nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ha hb hc hd he"><p id="33a3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lo">原载于2018年12月20日www.edureka.co</em><a class="ae my" href="https://www.edureka.co/blog/inheritance-in-java/" rel="noopener ugc nofollow" target="_blank"><em class="lo"/></a><em class="lo">。</em></p></div></div>    
</body>
</html>