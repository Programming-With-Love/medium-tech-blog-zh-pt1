<html>
<head>
<title>Room + Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">房间+时间</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/room-time-2b4cf9672b98?source=collection_archive---------0-----------------------#2017-10-18">https://medium.com/androiddevelopers/room-time-2b4cf9672b98?source=collection_archive---------0-----------------------#2017-10-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/94e6a3ced380aedff89670a24214cf9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wgZOQYzFyN0IEw4SAj0Lw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://flic.kr/p/oz1D44" rel="noopener ugc nofollow" target="_blank">Big Ben</a> by James Cullen</figcaption></figure><p id="6a12" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您已经开始使用<a class="ae it" href="https://developer.android.com/topic/libraries/architecture/room.html" rel="noopener ugc nofollow" target="_blank"> Room </a>(如果您还没有使用的话，您应该这样做)，那么您很可能需要存储+检索某种日期/时间。Room没有提供任何现成的支持，而是提供了可扩展的<a class="ae it" href="https://developer.android.com/reference/android/arch/persistence/room/TypeConverter.html" rel="noopener ugc nofollow" target="_blank"> @TypeConverter </a>注释，允许您提供从任意对象到Room理解的类型的映射，反之亦然。</p><p id="4d5e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该API的<a class="ae it" href="https://developer.android.com/topic/libraries/architecture/room.html#type-converters" rel="noopener ugc nofollow" target="_blank">文档</a>中的典型示例实际上是日期/时间:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="bef8" class="kb kc hh jx b fi kd ke l kf kg">public class Converters {<br/>    @TypeConverter<br/>    public static Date fromTimestamp(Long value) {<br/>        return value == null ? null : new Date(value);<br/>    }<br/><br/>    @TypeConverter<br/>    public static Long dateToTimestamp(Date date) {<br/>        return date == null ? null : date.getTime();<br/>    }<br/>}</span></pre><p id="228e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我在我的应用程序中使用了完全相同的代码，虽然它在技术上可行，但它有两个大问题。首先，它使用了<a class="ae it" href="https://developer.android.com/reference/java/util/Date.html" rel="noopener ugc nofollow" target="_blank"> Date </a>类，在几乎所有情况下都应该避免使用<a class="ae it" href="https://codeblog.jonskeet.uk/2017/04/23/all-about-java-util-date/" rel="noopener ugc nofollow" target="_blank">类。<code class="du kh ki kj jx b">Date</code>的主要问题是它<strong class="iw hi">不支持时区</strong>。一点也不。</a></p><p id="cf3b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第二个问题是它将值作为简单的<code class="du kh ki kj jx b">Long</code>持久化，这同样不能存储任何时区信息。</p><p id="3212" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，假设我们使用上面的转换器将一个日期实例保存到数据库中，然后再检索它。如何知道原始值来自哪个时区？简单的回答就是你不能知道。您能做的最好的事情是尝试并确保所有的日期实例使用一个共同的时区，比如UTC。虽然这允许您将不同的检索值相互比较(例如，用于排序)，但您永远无法找到原始时区。</p><p id="eed7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我决定花一个小时尝试修复我的应用程序中的时区问题。</p><h2 id="3f73" class="kb kc hh bd kk kl km kn ko kp kq kr ks jf kt ku kv jj kw kx ky jn kz la lb lc bi translated">SQLite +日期/时间</h2><p id="bb67" class="pw-post-body-paragraph iu iv hh iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">我调查的第一件事是SQLite对日期和时间值的支持，事实上它确实支持它们。当您使用Room时，它控制您的类值映射到哪些SQL数据类型。比如<code class="du kh ki kj jx b">String</code>会映射到<code class="du kh ki kj jx b">TEXT</code>，<code class="du kh ki kj jx b">Int</code>会映射到<code class="du kh ki kj jx b">INTEGER</code>等等。但是我们如何告诉Room映射我们的对象日期+时间值呢？简单的答案是我们不需要。</p><p id="f630" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">SQLite是一个松散类型的数据库系统，它将所有值存储为:<code class="du kh ki kj jx b">NULL</code>、<code class="du kh ki kj jx b">INTEGER</code>、<code class="du kh ki kj jx b">TEXT</code>、<code class="du kh ki kj jx b">REAL</code>或<code class="du kh ki kj jx b">BLOB</code>之一。您会注意到，没有其他数据库系统中常见的特殊日期或时间类型。相反，他们提供了以下关于如何存储日期/时间值的<a class="ae it" href="https://sqlite.org/datatype3.html#datetime" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="li lj lk"><p id="58db" class="iu iv ll iw b ix iy iz ja jb jc jd je lm jg jh ji ln jk jl jm lo jo jp jq jr ha bi translated">SQLite没有专门用于存储日期和/或时间的存储类。相反，SQLite的内置<a class="ae it" href="https://sqlite.org/lang_datefunc.html" rel="noopener ugc nofollow" target="_blank">日期和时间函数</a>能够将日期和时间存储为文本、实数或整数值</p></blockquote><p id="bff2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正是这些日期和时间函数允许我们以最小/无精度损失存储高保真的日期时间值，特别是使用<code class="du kh ki kj jx b">TEXT</code>类型，因为它支持<a class="ae it" href="https://en.wikipedia.org/wiki/ISO_8601" rel="noopener ugc nofollow" target="_blank"> ISO 8601 </a>字符串。</p><p id="f992" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，我们只需要将我们的值保存为特殊格式的文本，其中包含我们需要的所有信息。如果需要，我们可以使用上面提到的SQLite函数将文本转换成SQL中的日期/时间。我们唯一需要做的就是确保我们的代码使用正确的格式。</p><h2 id="6c5f" class="kb kc hh bd kk kl km kn ko kp kq kr ks jf kt ku kv jj kw kx ky jn kz la lb lc bi translated">回到应用程序</h2><p id="2789" class="pw-post-body-paragraph iu iv hh iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">所以我们知道SQLite支持我们所需要的，但是我们需要决定如何在我们的应用程序中表现它。</p><p id="f5f4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我在我的应用程序中使用的是ThreeTen-BP，它是JDK 8的日期和时间库(JSR-310)的移植，但是可以在JDK 6+上运行。这个库支持时区，所以我们将使用它的一个类来表示应用程序中的日期+时间:<a class="ae it" href="http://www.threeten.org/threetenbp/apidocs/org/threeten/bp/OffsetDateTime.html" rel="noopener ugc nofollow" target="_blank"> OffsetDateTime </a>。这个类是UTC/GMT特定偏移量内的时间和日期的不可变表示。</p><p id="8d01" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以当我们看我的一个实体时，我们现在使用OffsetDateTime而不是Date:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="ebea" class="kb kc hh jx b fi kd ke l kf kg">@Entity(tableName = "users")<br/>data class User(<br/>        @PrimaryKey val id: Long? = null,<br/>        val username: String,<br/>        <strong class="jx hi">val joined_date: OffsetDateTime? = null</strong><br/>)</span></pre><p id="cd29" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是更新的实体，但现在我们必须更新我们的TypeConverters，以便Room了解如何保存/恢复<code class="du kh ki kj jx b">OffsetDateTime</code>值:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="4001" class="kb kc hh jx b fi kd ke l kf kg">object TiviTypeConverters {<br/>    private val formatter = DateTimeFormatter.<strong class="jx hi"><em class="ll">ISO_OFFSET_DATE_TIME</em></strong><em class="ll"><br/><br/>    </em>@TypeConverter<br/>    @JvmStatic<br/>    fun toOffsetDateTime(value: String?): OffsetDateTime? {<br/>        return value?.<em class="ll">let </em><strong class="jx hi">{<br/>            </strong>return formatter.parse(value, OffsetDateTime::from)<br/>        <strong class="jx hi">}<br/>    </strong>}<br/><br/>    @TypeConverter<br/>    @JvmStatic<br/>    fun fromOffsetDateTime(date: OffsetDateTime?): String? {<br/>        return date?.format(formatter)<br/>    }<br/>}</span></pre><p id="ad79" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们现在将<code class="du kh ki kj jx b">OffsetDateTime</code>映射到<code class="du kh ki kj jx b">String</code>，而不是之前的<code class="du kh ki kj jx b">Date</code>到/从<code class="du kh ki kj jx b">Long</code>的映射。</p><p id="56af" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些方法看起来非常简单:一个将OffsetDateTime格式化为字符串，另一个将字符串解析为OffsetDateTime。这里的关键难题是确保我们使用正确的字符串格式。谢天谢地，ThreeTen-BP为我们提供了一个兼容的版本<code class="du kh ki kj jx b">DateTimeFormatter.<strong class="iw hi">ISO_OFFSET_DATE_TIME</strong></code>。</p><p id="e6cc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不过您可能没有使用这个库，所以让我们来看一个格式化字符串的例子:<code class="du kh ki kj jx b">2013-10-07T17:23:19.540-04:00</code>。希望您能看到这代表着什么日期:UTC-4，2013年10月7日17:23:19.540。只要您格式化/解析成这样的字符串，SQLite就能够理解它。</p><p id="8fd4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">至此，我们差不多完成了。如果您运行应用程序，通过适当的数据库版本增加+迁移，您会看到一切都应该工作得很好。</p><p id="c2f7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">更多关于带房间迁移的信息，请看<a class="lp lq ge" href="https://medium.com/u/d5885adb1ddf?source=post_page-----2b4cf9672b98--------------------------------" rel="noopener" target="_blank">弗洛里纳·芒特内斯库</a>的帖子:</p><div class="lr ls ez fb lt lu"><a rel="noopener follow" target="_blank" href="/google-developers/understanding-migrations-with-room-f01e04b07929"><div class="lv ab dw"><div class="lw ab lx cl cj ly"><h2 class="bd hi fi z dy lz ea eb ma ed ef hg bi translated">了解迁移与空间</h2><div class="mb l"><h3 class="bd b fi z dy lz ea eb ma ed ef dx translated">用SQLite API执行数据库迁移总是让我感觉像是在拆除一颗炸弹——好像我就是一颗…</h3></div><div class="mc l"><p class="bd b fp z dy lz ea eb ma ed ef dx translated">medium.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi in lu"/></div></div></a></div><h2 id="6eec" class="kb kc hh bd kk kl km kn ko kp kq kr ks jf kt ku kv jj kw kx ky jn kz la lb lc bi translated">整理房间</h2><p id="8951" class="pw-post-body-paragraph iu iv hh iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">我们还没有解决的一件事是在SQL中查询日期列。之前的日期/长整型映射有一个隐含的好处，即数字的排序和查询效率极高。移动到字符串多少会破坏这一点，所以让我们来修复它。</p><p id="931e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设我们以前有一个查询，它返回按加入日期排序所有用户。您可能会看到这样的内容:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="4320" class="kb kc hh jx b fi kd ke l kf kg">@Dao<br/>interface UserDao {<br/>    @Query("<strong class="jx hi">SELECT * FROM users ORDER BY joined_date</strong>")<br/>    fun getOldUsers(): List&lt;User&gt;<br/>}</span></pre><p id="f9d3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于<code class="du kh ki kj jx b">joined_date</code>是一个数字(<code class="du kh ki kj jx b">long</code>，记住)，SQLite会做一个简单的数字比较并返回结果。如果您使用新的文本实现运行相同的查询，您可能会注意到结果看起来是一样的，但是它们是一样的吗？</p><p id="2c74" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">答案是肯定的，大部分时间是这样。对于文本实现，SQLite进行的是文本排序，而不是数字排序，这在大多数情况下是正确的。让我们来看一些示例数据:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="fda4" class="kb kc hh jx b fi kd ke l kf kg"><strong class="jx hi">id  |  joined_date</strong><br/>------------------------------------<br/>1   |  2017-10-17T07:23:19.120+00:00<br/>2   |  2017-10-17T09:36:27.526+00:00<br/>3   |  2017-10-17T11:01:12.972+00:00<br/>4   |  2017-10-17T17:57:01.784+00:00</span></pre><p id="2483" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个简单的从左到右的字符串排序在这里起作用，因为字符串的所有组成部分都是按降序排列的(年、月、日等等)。问题来自字符串的最后一部分，时区偏移量。让我们稍微调整一下数据，看看会发生什么:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="7285" class="kb kc hh jx b fi kd ke l kf kg"><strong class="jx hi">id  |  joined_date</strong><br/>------------------------------------<br/>1   |  2017-10-17T07:23:19.120+00:00<br/>2   |  2017-10-17T09:36:27.526+00:00<br/>3   |  2017-10-17T11:01:12.972<strong class="jx hi">-02:00</strong><br/>4   |  2017-10-17T17:57:01.784+00:00</span></pre><p id="c2d4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以看到第三行的时区已经从UTC更改为UTC-2。这导致它的加入时间实际上是UTC的<code class="du kh ki kj jx b">09:01:12</code>,因此它实际上应该被排序为第二行。但是返回的列表包含了和以前一样的顺序。这是因为我们仍然使用字符串排序，它没有考虑时区。</p><h2 id="bab8" class="kb kc hh bd kk kl km kn ko kp kq kr ks jf kt ku kv jj kw kx ky jn kz la lb lc bi translated">SQLite日期时间函数</h2><p id="19d2" class="pw-post-body-paragraph iu iv hh iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">那我们怎么解决呢？还记得那些SQLite日期/时间函数吗？我们只需要确保在与SQL中的任何日期/时间列交互时使用它们。SQLite提供了5个<a class="ae it" href="https://sqlite.org/lang_datefunc.html" rel="noopener ugc nofollow" target="_blank">函数</a>:</p><ol class=""><li id="e4fc" class="mj mk hh iw b ix iy jb jc jf ml jj mm jn mn jr mo mp mq mr bi translated"><code class="du kh ki kj jx b">date(...)</code>只返回日期。</li><li id="b43f" class="mj mk hh iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated"><code class="du kh ki kj jx b">time(...)</code>返回正确的时间。</li><li id="3824" class="mj mk hh iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated"><code class="du kh ki kj jx b">datetime(...)</code>返回日期和时间。</li><li id="7877" class="mj mk hh iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated"><code class="du kh ki kj jx b">julianday(...)</code>返回<a class="ae it" href="https://en.wikipedia.org/wiki/Julian_day" rel="noopener ugc nofollow" target="_blank">儒略日</a>。</li><li id="1663" class="mj mk hh iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated"><code class="du kh ki kj jx b">strftime(...)</code>返回用给定格式字符串格式化的值。前四个可以被认为是具有预定义格式的<code class="du kh ki kj jx b">strftime</code>的变体。</li></ol><p id="c6a9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为我们想对日期和时间进行排序，我们可以使用<code class="du kh ki kj jx b">datetime(...)</code>函数。如果我们回到我们的DAO，查询现在变成了:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="fcde" class="kb kc hh jx b fi kd ke l kf kg">@Dao<br/>interface UserDao {<br/>    @Query("<strong class="jx hi">SELECT * FROM users ORDER BY datetime(joined_date)</strong>")<br/>    fun getOldUsers(): List&lt;User&gt;<br/>}</span></pre><p id="6998" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">够简单了吧？完成这一更改后，我们现在得到了正确的语义排序:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="3cfb" class="kb kc hh jx b fi kd ke l kf kg"><strong class="jx hi">id  |  joined_date</strong><br/>------------------------------------<br/>1   |  2017-10-17T07:23:19.120+00:00<br/>3   |  2017-10-17T11:01:12.972<strong class="jx hi">-02:00<br/></strong>2   |  2017-10-17T09:36:27.526+00:00<br/>4   |  2017-10-17T17:57:01.784+00:00</span></pre><p id="4434" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就是我工作完成的时间！我们现在支持房间内的时区日期/时间。</p><div class="lr ls ez fb lt lu"><a href="https://github.com/chrisbanes/tivi/commit/bd517e2b2fb54046a5e3c8bdcd31133ad1db1b19" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab dw"><div class="lw ab lx cl cj ly"><h2 class="bd hi fi z dy lz ea eb ma ed ef hg bi translated">使用DateTimeOffset代替Date chrisbanes/tivi@bd517e2</h2><div class="mb l"><h3 class="bd b fi z dy lz ea eb ma ed ef dx translated">tivi - Tivi是一个追踪Android应用程序的正在进行中的电视节目，它连接到Trakt.tv。它仍处于早期…</h3></div><div class="mc l"><p class="bd b fp z dy lz ea eb ma ed ef dx translated">github.com</p></div></div><div class="md l"><div class="mx l mf mg mh md mi in lu"/></div></div></a></div></div><div class="ab cl my mz go na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ha hb hc hd he"><p id="344c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">* 1小时调查+代码，3小时写这篇博文。🙃</p><p id="af6a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="ll">注意:我在这篇文章中使用了ThreeTenBP，但是它可以与任何支持时区的时间/日期API一起工作，例如</em> <a class="ae it" href="https://developer.android.com/reference/android/icu/util/Calendar.html" rel="noopener ugc nofollow" target="_blank"> <em class="ll"> ICU日历</em> </a> <em class="ll">(在API 24+上)</em><a class="ae it" href="http://www.joda.org/joda-time/" rel="noopener ugc nofollow" target="_blank"><em class="ll">Joda-Time</em></a><em class="ll">，甚至是</em> <a class="ae it" href="https://developer.android.com/reference/java/util/Calendar.html" rel="noopener ugc nofollow" target="_blank"> <em class="ll">日历</em> </a> <em class="ll">类。我将把它作为一个练习留给读者，让他们为他们希望使用的API找出TypeConverter实现。</em></p></div></div>    
</body>
</html>