<html>
<head>
<title>Profile guided optimization for native Android applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">针对原生Android应用的配置文件引导优化</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/pgo-for-native-android-applications-1a48a99e95d0?source=collection_archive---------2-----------------------#2020-07-15">https://medium.com/androiddevelopers/pgo-for-native-android-applications-1a48a99e95d0?source=collection_archive---------2-----------------------#2020-07-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/0577dd4f93611bae4ab3a0df27e48fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qOA2f-PTyDaeG9YBQGjgDw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by Claudia Sanchez</figcaption></figure><div class=""/><p id="2992" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">由软件工程师Pirama Arumuga Nainar发布</em></p><p id="b50d" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Profile-guided optimization (PGO)是一种众所周知的编译器优化技术。在PGO中，编译器使用程序执行的运行时配置文件来对内联和代码布局做出最佳选择。这导致了性能的提高和代码量的减少。开发者现在可以利用谷歌的工具包轻松部署PGO工具，并改进他们的原生Android应用程序。</p><p id="0866" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在选定的Android系统组件上，启用PGO可将性能提高6–8%。PGO还在一个组件中提供了代码大小的改进，同时略微增加了其他两个组件的代码大小。</p><figure class="ju jv jw jx fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jt"><img src="../Images/73321946da730d09bd219978bf1b027f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kgGIsb9KqBGuU8zn"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Benefits of PGO for Android system components</figcaption></figure><h1 id="0eb7" class="jy jz hw bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">可以通过以下步骤将PGO部署到您的应用程序或库中:</h1><ol class=""><li id="888b" class="kw kx hw iw b ix ky jb kz jf la jj lb jn lc jr ld le lf lg bi translated">确定有代表性的工作负载。</li><li id="c1b1" class="kw kx hw iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">收集个人资料。</li><li id="fe0f" class="kw kx hw iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated">在发布版本中使用概要文件。</li></ol><h1 id="a2b1" class="jy jz hw bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">步骤1:确定代表性的工作负载</h1><p id="c8c4" class="pw-post-body-paragraph iu iv hw iw b ix ky iz ja jb kz jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">首先，为您的应用程序确定一个有代表性的基准或工作负载。这是一个关键的步骤，因为从工作负载中收集的概要文件可以识别代码中的热区域和冷区域。当使用概要文件时，编译器将在热点区域执行积极的优化和内联。编译器也可以选择在牺牲性能的同时减少冷区域的代码大小。</p><p id="8d4d" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">确定一个好的工作负载也有利于跟踪总体性能。</p><h1 id="cb16" class="jy jz hw bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">第二步:收集个人资料</h1><p id="8521" class="pw-post-body-paragraph iu iv hw iw b ix ky iz ja jb kz jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">通过在应用程序的检测构建上运行步骤1中的工作负载来收集概要文件。要生成一个插装的构建，将<code class="du lp lq lr ls b">-fprofile-generate</code>添加到编译器和链接器标志中。这个标志应该由一个单独的构建变量控制，因为在默认的构建过程中不需要这个标志。</p><p id="9d3c" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在运行检测的二进制文件时收集配置文件，并在退出时写入文件。然而，用<code class="du lp lq lr ls b">atexit</code>注册的功能不会在Android应用程序中调用——应用程序会被终止。应用程序/工作负载必须通过调用<code class="du lp lq lr ls b">__llvm_profile_write_file</code>函数来明确触发配置文件写入。</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx"><strong class="ak">Example for triggering profile write at end of workload</strong></figcaption></figure><p id="7915" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果工作负载是一个独立的二进制文件，那么编写概要文件会更简单——只需在运行二进制文件之前设置<a class="ae lv" href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html#running-the-instrumented-program" rel="noopener ugc nofollow" target="_blank"> LLVM_PROFILE_FILE环境变量</a>。</p><p id="2456" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">配置文件为<code class="du lp lq lr ls b">.profraw</code>格式。使用NDK中的<code class="du lp lq lr ls b">llvm-profdata</code>实用程序将<code class="du lp lq lr ls b">.profraw</code>转换为<code class="du lp lq lr ls b">.profdata</code>，然后可以将其传递给编译器。</p><figure class="ju jv jw jx fd hj"><div class="bz dy l di"><div class="lt lu l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx"><strong class="ak">Command to convert .profraw files to .profdata</strong></figcaption></figure><p id="cf23" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用来自同一个NDK版本的<code class="du lp lq lr ls b">llvm-profdata</code>和<code class="du lp lq lr ls b">clang</code>来避免配置文件格式的版本不匹配。</p><h1 id="749c" class="jy jz hw bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用概要文件构建应用程序</h1><p id="5e12" class="pw-post-body-paragraph iu iv hw iw b ix ky iz ja jb kz jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">通过将<code class="du lp lq lr ls b">-fprofile-use=&lt;&gt;.profdata</code>传递给编译器和链接器，在应用程序的发布构建过程中使用上一步中的概要文件。这些概要文件甚至可以随着代码的发展而使用Clang编译器可以容忍源代码和概要文件之间的轻微不匹配。</p><h1 id="c124" class="jy jz hw bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">个案研究</h1><p id="8447" class="pw-post-body-paragraph iu iv hw iw b ix ky iz ja jb kz jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">“<code class="du lp lq lr ls b">dex2oat</code>”是Android的车载AOT编译器。为了获得<code class="du lp lq lr ls b">dex2oat</code>的代表性工作负载，我们在Play store中随机选择了前100个安装量最大的应用中的25个。我们还随机生成了<a class="ae lv" href="https://source.android.com/devices/tech/dalvik/configure#compilation_options" rel="noopener ugc nofollow" target="_blank"> dex2oat的编译选项</a>。</p><p id="fcb3" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了生成PGO概要文件，我们构建了一个装有PGO的<code class="du lp lq lr ls b">dex2oat</code>二进制文件，并使用它来编译工作负载。然后，我们生成了一个使用这些PGO配置文件的<code class="du lp lq lr ls b">dex2oat </code>发布版本，并评估了100个安装量最大的应用中剩余的75个应用的性能增益。</p><p id="84b9" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们利用Android团队可用的测试基础设施来自动收集这些PGO配置文件，以便可以轻松地保持更新。</p><h1 id="c621" class="jy jz hw bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="214a" class="pw-post-body-paragraph iu iv hw iw b ix ky iz ja jb kz jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">PGO是一种非常有用的性能优化技术。在工作负载的初始设置和构建过程中的集成之后，它以最少的维护提供了令人印象深刻的性能改进。</p><p id="f6c7" class="pw-post-body-paragraph iu iv hw iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是一些有助于提高Android应用程序性能的其他主题:</p><ol class=""><li id="61d8" class="kw kx hw iw b ix iy jb jc jf lw jj lx jn ly jr ld le lf lg bi translated"><a class="ae lv" href="https://llvm.org/docs/LinkTimeOptimization.html" rel="noopener ugc nofollow" target="_blank">链接时间优化</a> : LTO + PGO各自比各自好。</li><li id="c881" class="kw kx hw iw b ix lh jb li jf lj jj lk jn ll jr ld le lf lg bi translated"><a class="ae lv" href="https://android-developers.googleblog.com/2019/04/improving-app-performance-with-art.html" rel="noopener ugc nofollow" target="_blank">面向Java应用的云配置文件</a></li></ol></div></div>    
</body>
</html>