<html>
<head>
<title>Testing SSL Pinning in a mobile Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在移动应用程序中测试SSL固定</h1>
<blockquote>原文：<a href="https://medium.com/globant/testing-ssl-pinning-in-a-mobile-application-2dcac9ab3d0c?source=collection_archive---------0-----------------------#2020-07-20">https://medium.com/globant/testing-ssl-pinning-in-a-mobile-application-2dcac9ab3d0c?source=collection_archive---------0-----------------------#2020-07-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="9954" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">摘要</h1><p id="986c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">本文描述了SSL固定的概念及其在移动项目中实现的重要性，以防止专用网络上的应用程序使用代理拦截TLS/SSL请求。</p><h1 id="c2d6" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">描述</h1><p id="ef18" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">OWASP将SSL固定定义为<em class="ka">“用户和开发人员在他们的应用程序中发送和接收数据时，期望端到端的安全性，尤其是受VPN、SSL或TLS保护的通道上的敏感数据。虽然控制DNS(域名系统)和CA(证书颁发机构)的组织已将大多数威胁模型中的风险降低到微不足道的水平，但用户和开发人员受制于他人的DNS和公共CA的层级，他们面临着不小的风险"</em>。在移动应用程序的情况下，应该考虑的一个优先事项是，对应用程序使用的服务的调用或请求不应该被拦截。如果用户(在特定情况下是恶意用户)可以捕获应用程序对后端/服务的请求以及它传递给它的参数，攻击者就可以操纵所发出的请求，方法是操纵请求中发送的参数、请求头、您发出的请求的类型、将不同类型的参数传递给那些在前端层而不是后端层验证的预期参数，等等。</p><p id="1cf1" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">恶意用户捕获应用程序请求(即使它们受到安全通道的保护)的方法之一是，通过他/她自己的CA安装签名证书，并配置一个使用该证书捕获应用程序发送的请求的代理。通过依赖代理证书，即使请求通过安全通道，也有可能捕获请求，并公开发送到应用程序使用的服务的请求的参数、标头、URL和类型。避免这类重大威胁的一种方法是在应用程序中实现SSL固定。</p><p id="232b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">也就是说，SSL pin接受主机或服务的证书或公钥散列；它可以在开发时添加到应用程序中，并在应用程序每次发送请求时与发布的服务进行比较。它也可以添加到应用程序和服务之间的第一次握手中。最好选择第一种方法，因为预加载证书或带外公钥通常意味着攻击者无法发现pin。如果证书或公钥是在第一次遇到时添加的，它可能会锁定攻击者的证书。</p><p id="9a32" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">SSL固定利用用户与组织或服务之间的现有关系来帮助做出更好的安全相关决策。因为您已经有了关于服务器或服务的信息，所以您不需要依赖通用的机制来解决密钥分发问题。也就是说，您不需要通过DNS获得名称/地址，也不需要通过CA分配获得链接和状态。</p><p id="717c" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">每次应用程序向主机或服务发送请求时，它都会将应用程序中的证书与从服务收到的证书进行比较，如果它们匹配，则表示它们之间存在安全连接，否则应用程序不会发送数据，并将通知用户连接错误。可以对叶证书、中间证书或根证书进行锁定。Mathew Dolan在他的<a class="ae kg" rel="noopener" href="/@appmattus/android-security-ssl-pinning-1db8acb6621e"> Android Security: SSL Pinning文章</a>中广泛解释了每种类型、差异和实现。</p><p id="ca2a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">以下概念证明(PoC)是一个关于SSL固定重要性的示例。该示例用登录表单捕获请求，以纯文本形式公开凭据，并通过代理工具修改它们。第二个示例包括SSL Pinning的实现，它防止登录表单被拦截。此PoC包括Burp Suite Community Edition，用于捕获应用程序请求，其中包含一个代理，可以设置该代理来执行捕获。</p><h1 id="9b6f" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">概念开发的证明</h1><h2 id="18f5" class="kh if hh bd ig ki kj kk ik kl km kn io jn ko kp is jr kq kr iw jv ks kt ja ku bi translated"><strong class="ak">拓扑</strong></h2><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/c7ec4fd522c90c842058862dc42bc93a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FlUDduYTcHf6Jhm_MdskGQ.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 1: Topology Context Diagram</em></figcaption></figure><h2 id="09df" class="kh if hh bd ig ki kj kk ik kl km kn io jn ko kp is jr kq kr iw jv ks kt ja ku bi translated"><strong class="ak">代理设置</strong></h2><p id="39ae" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">对于这个特定的案例，使用了Burp Suite Community Edition工具。这个工具带有一个集成的代理功能。不同的工具可用于此目的，例如:Charles、MitM Proxy、ZAP等。</p><p id="1492" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">对于此WLAN，Burp代理的IP在端口8080上设置为10.30.6.134。这些配置必须在装有要测试的应用程序的手机上进行设置。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lm"><img src="../Images/68b9304e5bef0c380edf4cc81949c80f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KzL5XGB7qfs6iF8g"/></div></div></figure><h2 id="616c" class="kh if hh bd ig ki kj kk ik kl km kn io jn ko kp is jr kq kr iw jv ks kt ja ku bi translated"><strong class="ak">移动配置</strong></h2><p id="b3b5" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">对于WLAN，将在其中测试应用程序的客户端/电话(iPhone 7 v13.3.1)的私有IP设置为10.30.6.133。然后，我们还需要用上一步中定义的IP来配置电话使用的代理。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es ln"><img src="../Images/4b1ab4e71e8ea4a7c3e9ff62ad906c13.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*HNAWnmJHkKZaKLnV6J5vgg.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 3: Mobile IP Topology configuration</em></figcaption></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lo"><img src="../Images/ef9d224e94dff6fcf8fea1caa399ef1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*JglbEjoMqCUC2bTfyQXpOg.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 4: Mobile Proxy Topology configuration</em></figcaption></figure><p id="aff0" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果您使用的是Android Studio模拟器，则必须在设置菜单和代理选项卡中的模拟器扩展控件中配置代理。在本例中，IP设置如拓扑所示。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lp"><img src="../Images/0d19d69623f5e2ef624f18d5ce82e1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R5mi1cMdRR5Q3yyr"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Image 5: Android Studio emulator proxy configuration</figcaption></figure><h2 id="843a" class="kh if hh bd ig ki kj kk ik kl km kn io jn ko kp is jr kq kr iw jv ks kt ja ku bi translated"><strong class="ak">手机证书配置</strong></h2><p id="91fe" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">Burp证书(Portswigger CA)必须设置为“完全信任”,以便Burp拦截请求。安装证书的所有步骤都可以在官方Portswigger文档中找到，这些文档适用于<a class="ae kg" href="https://portswigger.net/support/installing-burp-suites-ca-certificate-in-an-ios-device" rel="noopener ugc nofollow" target="_blank"> iOS </a>和<a class="ae kg" href="https://portswigger.net/support/installing-burp-suites-ca-certificate-in-an-android-device" rel="noopener ugc nofollow" target="_blank"> Android </a>。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lq"><img src="../Images/365079363e7afffd9748d7f09e259e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*SHzSPvHTB4Sjq3E8a2r7xA.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 6: Mobile certificate configuration full trust</em></figcaption></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lr"><img src="../Images/f787cff959dbe1faf6eefaa2ca6315cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*Lam9SX0q88yXZ93EXykVfA.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 7: Mobile certificate configuration verified</em></figcaption></figure><h1 id="c785" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">捕获请求</h1><p id="0ac0" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在这一步，我们可以开始测试和拦截请求。请注意，在拦截请求时，代理捕获受SSL保护的URL的请求，即使它通过安全通道传输，也可以以纯文本形式看到请求的参数。</p><h2 id="3f41" class="kh if hh bd ig ki kj kk ik kl km kn io jn ko kp is jr kq kr iw jv ks kt ja ku bi translated">登录不正确的凭据测试</h2><p id="9e5e" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">第一个测试是对一个应用程序进行的，该应用程序有一个发送电子邮件和密码的表单，用于验证应用程序内部的用户。在这个测试中，为了以纯文本形式显示请求中发送的参数，我们使用表单中不正确的凭证对其进行了测试，并在Burp上捕获了这些凭证。</p><ul class=""><li id="d2ec" class="ls lt hh je b jf kb jj kc jn lu jr lv jv lw jz lx ly lz ma bi translated"><strong class="je hi">通过移动应用发送凭证</strong></li></ul><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lo"><img src="../Images/30f3a3445bacdd2f577adb43b29318a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*0bfYGOHV48eQ5HEE9awdUw.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Image 8 Mobile application login test</figcaption></figure><ul class=""><li id="d9a3" class="ls lt hh je b jf kb jj kc jn lu jr lv jv lw jz lx ly lz ma bi translated"><strong class="je hi">代理拦截请求凭证不正确</strong></li></ul><p id="af5f" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">请求在Burp代理中被拦截，我们可以看到公开的端点的URL，并且在参数中发送的用户凭证以纯文本显示。这些参数被发送到应用程序后端，并且可以在具有Burp的repeater工具上操作。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mb"><img src="../Images/0268d9302ad58be679b3bef603ac884e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ufV5OPTMSQl2P8pf"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 9: Proxy request intercepted incorrect credentials</em></figcaption></figure><ul class=""><li id="582d" class="ls lt hh je b jf kb jj kc jn lu jr lv jv lw jz lx ly lz ma bi translated"><strong class="je hi">代理历史请求不正确的凭证</strong></li></ul><p id="8125" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">对于这个测试，我们还可以在proxy HTTP history选项卡中看到请求响应的状态。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mc"><img src="../Images/d1bac08094edee06afbe08de90fe8f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pYGcJMii9NXHtgLS"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 10: Proxy history request incorrect credentials</em></figcaption></figure><ul class=""><li id="8639" class="ls lt hh je b jf kb jj kc jn lu jr lv jv lw jz lx ly lz ma bi translated"><strong class="je hi">代理历史响应凭证不正确</strong></li></ul><p id="032e" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">我们还可以看到从端点收到的请求响应。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es md"><img src="../Images/c5af92cbbf5fbd1129749bccd59fea38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HcoGzHclFez0ERaP"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 11: Proxy history response incorrect credentials</em></figcaption></figure><h2 id="bf67" class="kh if hh bd ig ki kj kk ik kl km kn io jn ko kp is jr kq kr iw jv ks kt ja ku bi translated"><strong class="ak">使用正确的凭证登录测试</strong></h2><p id="79f6" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">下一个例子是使用相同应用程序表单的正确凭证，并截取应用程序后端服务的响应。</p><ul class=""><li id="7956" class="ls lt hh je b jf kb jj kc jn lu jr lv jv lw jz lx ly lz ma bi translated"><strong class="je hi">代理历史请求正确的凭证</strong></li></ul><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mc"><img src="../Images/6e4a76c5be89a5e0a29b12372559cc97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zYeAhl_MqYxpP9wG"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 12: Proxy history request correct credentials</em></figcaption></figure><ul class=""><li id="02b3" class="ls lt hh je b jf kb jj kc jn lu jr lv jv lw jz lx ly lz ma bi translated"><strong class="je hi">代理历史响应正确凭证</strong></li></ul><p id="4619" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">正如您在这个测试中看到的，响应显示了一个access_token和关于用户的更多信息。这些信息和第一次测试中显示的信息可以用来自动对该应用程序后端进行暴力攻击，或者对其进行DDoS攻击。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es me"><img src="../Images/eac90ba5d09472621e463f952e52aecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MdtSTC4QTpoDJ52-"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 13: Proxy history request correct credentials</em></figcaption></figure><h1 id="ab80" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">SSL固定实施</h1><h2 id="4346" class="kh if hh bd ig ki kj kk ik kl km kn io jn ko kp is jr kq kr iw jv ks kt ja ku bi translated">ios</h2><p id="546b" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">Swift 5.2为iOS应用程序提供了一种相对简单的实现SSL锁定的方法。必须下载终端的证书。下载证书后，必须将证书作为文件放在resource文件夹中，以便可以在希望调用它的项目类中识别它。在这个例子中，它被称为“certificade-file-name”。der扩展。比较现有证书并解决来自服务的“挑战”。每次应用程序发送请求时，它都使用开发的方法。在本例中是“urlSession”方法。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mf"><img src="../Images/21ff58ef35ce79f59c843d00aae504e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1ZQ8w5WzeaihreV9"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 14: Swift code SSL pinning, credits to Ivan Rapoport</em></figcaption></figure><h2 id="ed52" class="kh if hh bd ig ki kj kk ik kl km kn io jn ko kp is jr kq kr iw jv ks kt ja ku bi translated">机器人</h2><p id="80dd" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在Android的情况下，不需要下载整个证书，只需要包含散列并与来自服务的散列进行比较。在extras部分，您可以找到bash代码来提取公共证书的散列。OkHttp3库在客户端有一个方法，处理每个请求的散列验证。在下一个Kotlin代码示例中，它在构建okHttpClientBuilder对象的部分执行锁定，创建一个单独的CertificadePinner类型的对象，其中包含作为<em class="ka"> sha256 </em>的散列。CertificadePinner对象作为okHttpClientBuilder对象的certificatePinner方法中的参数发送:</p><pre class="kw kx ky kz fd mg mh mi mj aw mk bi"><span id="be3d" class="kh if hh mh b fi ml mm l mn mo">//OkHttp3 Client<br/>val okHttpClientBuilder = OkHttpClient.Builder()<br/> .authenticator(CustomAuthenticator.getInstance(context))<br/><br/>//SSL Pinning<br/>val certPin = CertificatePinner.Builder()<br/> .add(BuildConfig.PATTERN, “sha256/<strong class="mh hi">YOUR-HASH-HERE</strong>”)<br/> .build()</span><span id="552b" class="kh if hh mh b fi mp mm l mn mo">okHttpClientBuilder.certificatePinner(certPin)</span></pre><p id="980a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">更多Android中的实现方法:</p><div class="mq mr ez fb ms mt"><a rel="noopener follow" target="_blank" href="/@appmattus/android-security-ssl-pinning-1db8acb6621e"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">Android安全性:SSL锁定</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">在Android应用中使用SSL很容易，但是确保连接的安全却是另一回事。一个…</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh lf mt"/></div></div></a></div><h1 id="209a" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">实现SSL固定的测试请求捕获</h1><p id="71a4" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">实现完成后，是时候再次检查前面部分中完成的过程并比较结果了。</p><p id="5a97" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">首先，在Burp仪表板上的事件日志中可以看到，当在应用程序上发送请求时，连接SSL无法完成，因为它在证书交换时失败。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ni"><img src="../Images/895d6b510b25fb694960d5a55aba737b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EWqBplNb_0I0Lhi8"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 15: Burp certificate negotiation error</em></figcaption></figure><p id="d4dd" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">同样，如果您有可能使用Logcat调试应用程序，对于Okhttp3库，您可以看到一个错误，通知您一个SSL握手异常，即已配置的证书pin与应用程序和端点之间当前交易的pin不匹配。换句话说，库无法找到在当前请求中收到的证书的路径，并且不允许在证书对之间建立连接。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es mf"><img src="../Images/f0760433ad38ccedc65b1afaa161e6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pkUbBg1G9TCoRaB4"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx"><em class="ll">Image 16: Android logcat Okhttp3 pinning error</em></figcaption></figure><h1 id="4402" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">风险</h1><p id="35d9" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">应用程序中SSL固定的错误或无效配置会暴露移动应用程序对其后端的调用。恶意用户可以将此作为攻击媒介。</p><p id="34b9" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">SSL牵制是一种预防方法，但是仍然有办法避免这种保护，例如使用程序，如Frida，允许注入snipes，允许您绕过这一措施。另一个例子是对应用程序执行逆向工程，改变散列(在Android上)并重新构建它。建议在应用程序与其后端之间的通信中对敏感信息使用加密算法，这样如果有人看到请求，请求就不会是明文。</p><h1 id="7ec4" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">临时演员</h1><p id="c914" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在iOS上安装burp证书<br/> <a class="ae kg" href="https://portswigger.net/support/installing-burp-suites-ca-certificate-in-an-ios-device" rel="noopener ugc nofollow" target="_blank">在iOS设备上安装Burp的CA证书</a></p><p id="f417" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">在Android上安装burp证书<br/> <a class="ae kg" href="https://portswigger.net/support/installing-burp-suites-ca-certificate-in-an-android-device" rel="noopener ugc nofollow" target="_blank">在Android设备上安装Burp的CA证书</a></p><p id="ecdc" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">Bash代码，用于提取公共证书的<em class="ka"> sha256 </em>中的哈希(提取自:<a class="ae kg" rel="noopener" href="/@appmattus/android-security-ssl-pinning-1db8acb6621e"> Android Security: SSL Pinning。在Android应用中使用SSL很容易……|作者马修·多兰</a></p><pre class="kw kx ky kz fd mg mh mi mj aw mk bi"><span id="11f4" class="kh if hh mh b fi ml mm l mn mo">#!/bin/bash<br/>certs=`openssl s_client -servername $1 -host $1 -port 443 -showcerts &lt;/dev/null 2&gt;/dev/null | sed -n ‘/Certificate chain/,/Server certificate/p’`<br/>rest=$certs<br/>while [[ “$rest” =~ ‘ — — -BEGIN CERTIFICATE — — -’ ]]<br/>do<br/> cert=”${rest%% — — -END CERTIFICATE — — -*} — — -END CERTIFICATE — — -”<br/> rest=${rest#* — — -END CERTIFICATE — — -}<br/> echo `echo “$cert” | grep ‘s:’ | sed ‘s/.*s:\(.*\)/\1/’`<br/> echo “$cert” | openssl x509 -pubkey -noout |<br/> openssl rsa -pubin -outform der 2&gt;/dev/null |<br/> openssl dgst -sha256 -binary | openssl enc -base64<br/>Done</span></pre><h1 id="c50c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">参考</h1><ol class=""><li id="03e5" class="ls lt hh je b jf jg jj jk jn nj jr nk jv nl jz nm ly lz ma bi translated"><a class="ae kg" href="https://owasp.org/www-community/controls/Certificate_and_Public_Key_Pinning" rel="noopener ugc nofollow" target="_blank">证书和公钥锁定控制</a></li><li id="7290" class="ls lt hh je b jf nn jj no jn np jr nq jv nr jz nm ly lz ma bi translated"><a class="ae kg" href="https://portswigger.net/burp/documentation/desktop/tools/proxy/options/installing-ca-certificate" rel="noopener ugc nofollow" target="_blank">安装Burp的CA证书</a></li><li id="001a" class="ls lt hh je b jf nn jj no jn np jr nq jv nr jz nm ly lz ma bi translated"><a class="ae kg" rel="noopener" href="/@appmattus/android-security-ssl-pinning-1db8acb6621e">安卓安全:SSL牵制。在Android应用中使用SSL很容易……|作者Matthew Dolan </a></li></ol></div></div>    
</body>
</html>