<html>
<head>
<title>Android Studio Project Marble: Apply Changes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android Studio项目Marble:应用更改</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-studio-project-marble-apply-changes-e3048662e8cd?source=collection_archive---------2-----------------------#2019-02-22">https://medium.com/androiddevelopers/android-studio-project-marble-apply-changes-e3048662e8cd?source=collection_archive---------2-----------------------#2019-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/a787c8986da958497b123edff5420dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dAZ5ygLJ9llUxAr7_TmKrg.png"/></div></div></figure><div class=""/><div class=""><h2 id="6af7" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">深入探讨Android Studio团队如何构建即时运行的继任者Apply Changes。</h2></div><p id="e0bf" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是Android工作室团队发布的一系列博客中的第一篇，深入了解了 <a class="ae ke" href="https://android-developers.googleblog.com/2019/01/android-studio-33.html" rel="noopener ugc nofollow" target="_blank"> <em class="kd">项目大理石</em> </a> <em class="kd">的一些细节和幕后情况。从发布</em><a class="ae ke" href="https://android-developers.googleblog.com/2019/01/android-studio-33.html" rel="noopener ugc nofollow" target="_blank"><em class="kd">Android Studio 3.3</em></a><em class="kd">开始，Project Marble就是一个多版本，致力于打造IDE坚如磐石的基本功能。以下帖子由应用更改团队的Jon Tsao(产品经理)、Esteban de la Canal(技术主管)、杨奇煜Sanglard(工程师)和Alan Leung(工程师)撰写。</em></p><p id="1291" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Android Studio的一个关键目标是提供工具，让您可以快速编辑和验证应用程序中的代码更改。当我们创建Instant Run时，我们希望显著地加速您的开发流程，但是我们知道这个特性没有达到预期。作为项目大理石的一部分，我们一直在努力重新思考即时运行，并在Android Studio中用一个更实用的解决方案来取代它。最初<a class="ae ke" href="https://androidstudio.googleblog.com/2019/01/android-studio-35-canary-1-available.html" rel="noopener ugc nofollow" target="_blank">在Android Studio 3.5的金丝雀频道中预览了</a>，应用更改是可预见地加速开发工作流的新方法。在这篇文章中，我们想对这个特性，它是如何工作的，以及我们到目前为止的旅程给出更多的见解。</p><h1 id="706d" class="kf kg hs bd kh ki kj kk kl km kn ko kp iy kq iz kr jb ks jc kt je ku jf kv kw bi translated">瞬间奔跑</h1><p id="5209" class="pw-post-body-paragraph jh ji hs jj b jk kx it jm jn ky iw jp jq kz js jt ju la jw jx jy lb ka kb kc ha bi translated">通过即时运行，我们希望解决两个问题:1)降低设备的构建和部署速度，2)能够在不丢失状态的情况下将更改部署到应用。为了在即时运行中实现这一点，我们依赖于在构建时重写apk来注入钩子，从而允许动态替换类。要更详细地了解Instant Run背后的架构，请参见几年前的这篇文章。</p><p id="93be" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对于简单的应用程序，这种解决方案通常是好的，但对于更复杂的应用程序，这可能会导致更长的构建时间或由应用程序和Instant Run的构建过程之间的冲突引起的令人头疼的错误。随着这些问题的出现，我们继续投资改进后续版本的即时运行。然而，我们从来没有能够完全解决这些问题，并使功能符合我们的期望。</p><p id="107b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们后退一步，决定从头开始构建一个新的架构，这就是应用更改。与即时运行不同，应用更改不再修改构建期间的APK。相反，我们依靠Android 8.0 (Oreo)和更新的设备和仿真器支持的运行时工具来动态地重新定义类。</p><h1 id="9d6a" class="kf kg hs bd kh ki kj kk kl km kn ko kp iy kq iz kr jb ks jc kt je ku jf kv kw bi translated">应用更改</h1><p id="0df3" class="pw-post-body-paragraph jh ji hs jj b jk kx it jm jn ky iw jp jq kz js jt ju la jw jx jy lb ka kb kc ha bi translated">对于运行在Android 8.0或更新版本上的设备和仿真器，Android Studio现在提供了三个按钮来控制应用程序的重启量:</p><ul class=""><li id="6b92" class="lc ld hs jj b jk jl jn jo jq le ju lf jy lg kc lh li lj lk bi translated"><strong class="jj ht">运行</strong>将继续部署所有更改并重启应用程序。</li><li id="08cf" class="lc ld hs jj b jk ll jn lm jq ln ju lo jy lp kc lh li lj lk bi translated"><strong class="jj ht">应用更改</strong>将尝试应用您的资源和代码更改，并仅重启您的活动，而不重启您的应用。</li><li id="3ca8" class="lc ld hs jj b jk ll jn lm jq ln ju lo jy lp kc lh li lj lk bi translated"><strong class="jj ht">应用代码更改</strong>将尝试只应用你的代码更改而不重启任何东西。</li></ul><p id="8013" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">兼容的代码更改通常仅限于在方法体内更改的代码。</p><h1 id="e63f" class="kf kg hs bd kh ki kj kk kl km kn ko kp iy kq iz kr jb ks jc kt je ku jf kv kw bi translated">原则</h1><p id="d64a" class="pw-post-body-paragraph jh ji hs jj b jk kx it jm jn ky iw jp jq kz js jt ju la jw jx jy lb ka kb kc ha bi translated">根据Instant Run的经验和反馈，我们采用了一些原则来应用指导我们的架构和决策制定的变更:</p><ol class=""><li id="8abe" class="lc ld hs jj b jk jl jn jo jq le ju lf jy lg kc lq li lj lk bi translated"><strong class="jj ht">分离构建/部署速度和丢失状态</strong>。我们希望将降低构建/部署速度与能够在不丢失状态的情况下看到您的更改这两个问题分开。快速构建和部署应该是<em class="kd">所有</em>类型部署的目标，无论是常规运行/调试会话还是热交换代码。作为构建应用更改的一部分，我们已经发现了许多围绕构建和部署速度进行优化的领域，我们将在未来的帖子中详细介绍这些领域。</li><li id="4a82" class="lc ld hs jj b jk ll jn lm jq ln ju lo jy lp kc lq li lj lk bi translated"><strong class="jj ht">功能的稳定性至关重要</strong>。即使该功能以极快的速度运行了100次中的99次，如果应用程序因为该功能而崩溃了一次，并且你花了半个小时试图找出原因，那么你已经失去了在它运行的其他99次中获得的生产力提升。由于我们坚持这一原则，应用更改，不像即时运行，不再修改你的APK在建设。一个副产品是，在这个初始版本中，我们已经针对稳定性进行了优化，应用更改平均比即时运行稍慢，但我们将继续提高构建和部署速度。</li><li id="fc26" class="lc ld hs jj b jk ll jn lm jq ln ju lo jy lp kc lq li lj lk bi translated"><strong class="jj ht">没有魔法</strong>。我们采纳了您对即时运行按钮行为的不可预测性和不一致性的反馈，该按钮将在必要时自动决定是否重新启动您的应用程序或活动。我们希望始终保持清晰和透明，以了解您对应用更改的预期，以及如果您有不兼容的更改会发生什么，因此，如果我们检测到您的更改与应用更改不兼容，我们现在会明确提示您。</li></ol><h1 id="8dcb" class="kf kg hs bd kh ki kj kk kl km kn ko kp iy kq iz kr jb ks jc kt je ku jf kv kw bi translated">体系结构</h1><p id="5172" class="pw-post-body-paragraph jh ji hs jj b jk kx it jm jn ky iw jp jq kz js jt ju la jw jx jy lb ka kb kc ha bi translated">让我们深入了解应用更改是如何工作的。应用更改需要弄清楚如何应用设备上安装/运行的应用程序和刚刚在Android Studio中编译的应用程序之间的差异。这个过程可以分为两个不同的步骤:1)找出差异，2)将差异发送到设备并应用它。</p><p id="c525" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了快速确定差异，应用更改会避免从设备获取完整的APK。取而代之的是，它执行一个快速请求给设备，以拉已安装的APK的相应的<a class="ae ke" href="https://en.wikipedia.org/wiki/Zip_(file_format)#Central_directory_file_header" rel="noopener ugc nofollow" target="_blank">目录</a>和<a class="ae ke" href="https://source.android.com/security/apksigning" rel="noopener ugc nofollow" target="_blank">签名</a>。通过将这两条信息与新构建的APK进行比较，应用更改可以高效地生成自上次部署以来已更改文件的列表，而无需检查全部内容。请注意，该算法不依赖于构建系统，因为增量不是根据以前的构建计算的，而是根据设备上安装的内容计算的。由于“应用更改”仅对APK文件之间的差异进行操作，因此它不要求Gradle插件版本与Gradle同步。事实上，应用更改将在所有构建系统上工作。</p><p id="0dba" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">生成已更改的文件列表后，根据更改的内容，需要执行不同的操作来将这些更改应用到正在运行的应用程序，这也决定了应用程序需要重新启动多长时间才能使这些更改生效:</p><p id="969b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">资源/资产档案发生变化</strong>。<br/>在这种情况下，应用程序被重新安装，但是应用程序仅经历一次活动重启，并且被修改的资源被拾取。只有改变的资源被发送到设备。</p><p id="1f58" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><a class="ae ke" href="https://source.android.com/devices/tech/dalvik/dex-format" rel="noopener ugc nofollow" target="_blank"> <strong class="jj ht">。dex </strong> </a> <strong class="jj ht">文件已更改</strong>。<br/>Android 8.0的Android运行时提供了交换加载类的字节码的能力，只要新的字节码不改变内存中现有的对象布局。这意味着对与应用更改兼容的代码更改的限制:方法、类名和签名不会更改，它们的字段也不会更改。</p><p id="4ff2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这种机制在类级别有效，而不是在。dex级别。否则，如果一个. dex文件包含数百或数千个类，那么尝试交换所有的类将是低效的，即使只有一个类发生了变化。相反，我们比较。索引并计算已经更改的确切类，并且只尝试交换那些类。如果交换成功(即，类布局没有改变)，则应用程序也在后台安装，以避免应用程序的运行版本和安装版本之间的不一致。</p><p id="f499" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">。dex文件和资源文件已经更改</strong>。<br/>这个案例是以上两个案例的结合。首先执行代码步骤，如果成功，安装将使用新资源继续进行。为了加载新的资源，需要重新启动主活动。这是一个全有或全无的操作，如果您的代码更改无法应用，则运行的应用程序上不会有任何更改。</p><p id="bf51" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">还有什么变化吗</strong>。<br/>最坏的情况，像AndroidManifest.xml或native这样的文件。所以文件变了。在这种情况下，我们不可能在不重启应用程序的情况下应用更改。“应用更改”和“应用代码更改”操作都不会尝试部署，并且还会通知用户应用程序需要重新启动。</p><figure class="ls lt lu lv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lr"><img src="../Images/5f8dc37cc5b9b3d6d651f164204def98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aD1y7EprEnSzM-3FwbUsRQ.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx"><em class="ma">Flow of the architecture described above</em></figcaption></figure><p id="8b44" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><em class="kd">关于架构的更多细节，请听Android开发者后台播客的</em> <a class="ae ke" href="http://androidbackstage.blogspot.com/2019/02/episode-108-instant-re-run.html" rel="noopener ugc nofollow" target="_blank"> <em class="kd">最近一集</em> </a> <em class="kd">，其中技术负责人Esteban de la Canal深入探讨了应用变化。</em></p><h1 id="0830" class="kf kg hs bd kh ki kj kk kl km kn ko kp iy kq iz kr jb ks jc kt je ku jf kv kw bi translated">比较。dex文件</h1><p id="898b" class="pw-post-body-paragraph jh ji hs jj b jk kx it jm jn ky iw jp jq kz js jt ju la jw jx jy lb ka kb kc ha bi translated">上一节解释了应用更改需要比较和提取设备中被更改(修改/添加/删除)的单个类。为了在不增加从设备获取大块内容的开销的情况下做到这一点，它在后台进程中利用<a class="ae ke" href="https://android-developers.googleblog.com/2018/04/android-studio-switching-to-d8-dexer.html" rel="noopener ugc nofollow" target="_blank"> D8 </a>的DEX文件分析功能来检查每个内容。dex文件Android Studio部署到设备。基于校验和的指纹是在。并将结果临时存储在主机工作站上的缓存数据库中。通过将新编译的指纹与以前编译的指纹进行比较，应用更改能够在短时间内有效地提取更改的类。</p><h1 id="55e7" class="kf kg hs bd kh ki kj kk kl km kn ko kp iy kq iz kr jb ks jc kt je ku jf kv kw bi translated">三角推进</h1><p id="36bf" class="pw-post-body-paragraph jh ji hs jj b jk kx it jm jn ky iw jp jq kz js jt ju la jw jx jy lb ka kb kc ha bi translated">如上所述，只有已更改的文件才会发送到设备。我们称之为“三角洲推进”。与上面提到的DEX文件比较类似，应用更改需要计算已安装的apk和最近构建的apk之间的不同文件，而不必从设备获取所有内容。这一次，它只获取压缩文件的<a class="ae ke" href="https://en.wikipedia.org/wiki/Zip_(file_format)#Central_directory_file_header" rel="noopener ugc nofollow" target="_blank">中心目录</a>,并对相应apk之间的差异进行保守估计。通过只传输发生变化的部分，Android Studio传输的数据比完整的APK上传要少得多。在大多数使用案例中，总负载减少到几个KiB，而不是几个MiB。</p><h1 id="f24a" class="kf kg hs bd kh ki kj kk kl km kn ko kp iy kq iz kr jb ks jc kt je ku jf kv kw bi translated">后续步骤</h1><p id="d7da" class="pw-post-body-paragraph jh ji hs jj b jk kx it jm jn ky iw jp jq kz js jt ju la jw jx jy lb ka kb kc ha bi translated">金丝雀发布频道上的Android Studio 3.5现在提供了应用更改。我们欢迎您到<a class="ae ke" href="https://developer.android.com/studio/preview/install-preview" rel="noopener ugc nofollow" target="_blank">下载最新的Android Studio </a>，并尝试在您的项目中应用更改，并尽早给我们反馈。提醒一下，你可以<a class="ae ke" href="https://developer.android.com/studio/preview/install-preview#install_alongside_your_stable_version" rel="noopener ugc nofollow" target="_blank">同时运行Android Studio的稳定版和金丝雀发布版</a>。如果您在使用应用更改时遇到任何问题，请<a class="ae ke" href="https://issuetracker.google.com/issues/new?component=550294&amp;template=1207130" rel="noopener ugc nofollow" target="_blank">提交一个bug </a>并附上您相应的<a class="ae ke" href="https://intellij-support.jetbrains.com/hc/en-us/articles/207241085-Locating-IDE-log-files" rel="noopener ugc nofollow" target="_blank"> idea.log文件</a>。我们将继续优化部署性能，修复错误，并采纳您的建议和反馈。</p></div></div>    
</body>
</html>