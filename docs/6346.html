<html>
<head>
<title>99% to 99.9% SLO: High Performance Kubernetes Control Plane at Pinterest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">99%到99.9% SLO:Pinterest的高性能Kubernetes控制平面</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/99-to-99-9-slo-high-performance-kubernetes-control-plane-at-pinterest-894bc8a964f9?source=collection_archive---------0-----------------------#2022-03-22">https://medium.com/pinterest-engineering/99-to-99-9-slo-high-performance-kubernetes-control-plane-at-pinterest-894bc8a964f9?source=collection_archive---------0-----------------------#2022-03-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8c6e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">李舜尧|软件工程师，云运行时</p><p id="bcdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在过去的三年里，云运行时团队的旅程已经从"<a class="ae jc" rel="noopener" href="/pinterest-engineering/building-a-kubernetes-platform-at-pinterest-fb3d9571c948">为什么是Kubernetes？</a>【到】<a class="ae jc" rel="noopener" href="/pinterest-engineering/scaling-kubernetes-with-assurance-at-pinterest-a23f821168da">如何规模化？</a>”。毫无疑问，基于Kubernetes的计算平台在Pinterest取得了巨大的成功。我们一直在支持大数据处理、机器学习、分布式培训、工作流引擎、CI/CD、内部工具——支持Pinterest的每一位工程师。</p><h1 id="743d" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">为什么控制平面延迟很重要</h1><p id="f9f2" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">随着Kubernetes上的业务关键型工作负载越来越多，拥有一个高效协调每个工作负载的高性能控制平面变得越来越重要。如果将用户工作负载转化为Kubernetes native pods所需的时间过长，内容模型培训和广告报告渠道等关键工作负载将会延迟。</p><p id="aca5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了衡量控制平面性能，我们在2021年初通过服务水平指标和目标(SLI/SLO)引入了顶线业务指标。我们通过<strong class="ig hi">协调延迟</strong>来测量控制平面SLI，协调延迟被定义为<strong class="ig hi">从接收到用户变更到它传播出控制平面</strong>的时间。例如，批处理作业的协调延迟度量之一是工作负载创建和Pod创建之间的延迟。</p><p id="932f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">初始SLO设置为99%。在写这篇文章的时候，我们很自豪地服务于<strong class="ig hi"> 99.9% </strong>的控制平面SLO。这篇文章是关于我们如何改进控制平面以获得高性能的。</p><h1 id="340c" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">简而言之，控制平面</h1><p id="098b" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">控制平面是Kubernetes平台的神经中枢，负责工作负载协调。它监听来自Kubernetes API的更改，将资源的期望状态与它们的实际状态进行比较，并采取措施确保实际资源状态与期望状态相匹配(协调)。工作负载协调还包括做出关于将工作负载放置在何处的调度决策。</p><p id="a507" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Kubernetes控制平面由一组资源控制器组成。我们的资源控制器是在<a class="ae jc" href="https://github.com/operator-framework" rel="noopener ugc nofollow" target="_blank">控制器框架</a>中编写的，它有一个<a class="ae jc" href="https://pkg.go.dev/k8s.io/client-go/informers" rel="noopener ugc nofollow" target="_blank">通知器-反射器-缓存</a>架构。<strong class="ig hi">告密者</strong>使用<a class="ae jc" href="https://pkg.go.dev/k8s.io/client-go/tools/cache#ListerWatcher" rel="noopener ugc nofollow" target="_blank">列表监视</a>机制从Kubernetes API获取并监视资源变化。<strong class="ig hi"> Reflector </strong>用资源变化更新缓存，并调度事件进行处理。<strong class="ig hi">缓存</strong>存储资源对象，服务List和Get调用。控制器框架遵循<strong class="ig hi">生产者-消费者</strong>模式。事件处理程序是生产者，负责对协调请求进行排队，而控制器工作池是消费者，从工作队列中提取项目来运行协调逻辑。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/866d10ab4cbad50422994aae2236d66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/0*WDEo1JSrEK91UAeS"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Figure 1: Kubernetes Controller Framework</figcaption></figure><h1 id="1877" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">挑战1:工人池效率</h1><p id="6122" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">控制器工作池是实际状态到期望状态协调发生的地方。我们利用<a class="ae jc" href="https://pkg.go.dev/k8s.io/client-go/util/workqueue" rel="noopener ugc nofollow" target="_blank">工作队列包</a>提供的指标来深入了解工人池的效率。这些指标是:</p><ul class=""><li id="8592" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">工作持续时间:处理工作队列中的项目所需的时间</li><li id="a3d0" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">队列持续时间:项目在被处理之前在工作队列中停留的时间</li><li id="72ab" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">入队率:项目入队的频率</li><li id="2d5f" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">重试率:项目重试的频率</li><li id="2a6a" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">队列深度:工作队列的当前深度</li></ul><p id="b59c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这些指标中，队列深度引起了我们的注意，因为它的峰值与控制平面性能下降高度相关。队列深度的峰值表示<strong class="ig hi">队列头阻塞</strong>。当大量不相关的项目在短时间内排队时，通常会出现这种情况。对于那些真正需要协调的项目，它们最终会在队列中等待更长的时间，并导致SLI下降。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/3f16a4de3e80280623119be2892baccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6kW_MBvuXEhKr4eA"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Figure 2: Correlation between control plane queue depth spikes and control plane instant SLI dips.</figcaption></figure><p id="8915" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决行首阻塞，我们对通知者事件进行分类，并以不同的优先级处理它们。用户触发的事件具有高优先级，需要立即协调，例如，由用户创建工作负载触发的创建事件或由用户更新工作负载标签触发的更新事件。另一方面，一些系统触发的事件是低优先级的，例如，在信息程序初始化期间的创建事件，或者在信息程序周期性再同步期间的更新事件。它们不会影响我们的SLI，也不像用户触发事件那样对时间敏感。它们可以被延迟，这样它们就不会堆积在队列中，阻塞紧急事件。下一节是关于如何识别和延迟这些系统触发的事件。</p><h2 id="5b81" class="ll je hh bd jf lm ln lo jj lp lq lr jn ip ls lt jr it lu lv jv ix lw lx jz ly bi translated">在Informer初始化期间创建事件</h2><p id="7a75" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">每次我们更新控制器时，informer通过向API服务器发出一个List调用来初始化它的List-Watch机制。然后，它将返回的结果存储在其缓存中，并为每个结果触发一个Create事件。这导致队列深度出现峰值。解决方案是延迟现有对象的任何后续创建事件；用户不能创建一个对象两次，任何后续的创建事件必须来自informer初始化。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lz"><img src="../Images/b127fc930016ef4deef87fd72adb077b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z5A_E6_l3m7pvZpy"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Figure 3: Control plane queue depth spikes to 10k during an informer initialization, resulting in a dip in control plane instant SLI.</figcaption></figure><h2 id="0c09" class="ll je hh bd jf lm ln lo jj lp lq lr jn ip ls lt jr it lu lv jv ix lw lx jz ly bi translated">Informer定期重新同步期间更新事件</h2><p id="51d3" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">informer定期检查其缓存中剩余的所有项目，为每个项目触发一个更新事件。这些事件同时排队，并导致队列深度峰值。如图2所示，队列深度峰值与我们配置的informer定期重同步间隔一致。</p><p id="b8a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由周期性再同步触发的更新事件很容易识别，其中旧对象和新对象总是相同的，因为它们都来自informer缓存。解决方案是延迟新旧对象深度相等的更新事件。延迟是随机的，因此可以通过将再同步请求分散在一段时间内来消除队列深度尖峰。</p><h2 id="8433" class="ll je hh bd jf lm ln lo jj lp lq lr jn ip ls lt jr it lu lv jv ix lw lx jz ly bi translated">结果</h2><p id="4920" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">上述优化解决了效率低下的工作池导致的队列头阻塞问题。因此，控制平面队列深度不会再出现峰值。informer定期重新同步期间的平均队列深度<strong class="ig hi">减少了97%，从1k减少到30。</strong> <strong class="ig hi">由控制平面队列深度尖峰引起的瞬间SLI低凹处已经消除。</strong></p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lz"><img src="../Images/742d494cacb1f31e939bd596291bf181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-qALos6-GgX8yy4i"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Figure 4: Improvement on workqueue efficiency</figcaption></figure><h1 id="16cc" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">挑战2:领导权的转换</h1><p id="15c6" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">只有控制器群中的领导者执行实际的协调工作，并且在部署或控制器盒驱逐期间，领导者切换经常发生。长时间的领导切换会对控制平面的即时SLI产生相当大的负面影响。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lz"><img src="../Images/c2f4258b3d424da3d41532fc62b9864c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qfvef_EdOO28q33c"/></div></div></figure><p id="9bba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图5:控制平面领导切换导致SLI瞬时下降。</p><h2 id="d8c3" class="ll je hh bd jf lm ln lo jj lp lq lr jn ip ls lt jr it lu lv jv ix lw lx jz ly bi translated">领导人选举机制</h2><p id="7268" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">Kubernetes控制平面有两种常见的领导者选举机制。</p><ul class=""><li id="8322" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated"><strong class="ig hi">Leader-with-lease</strong>:Leader pod定期更新租约，当它不能更新租约时放弃领导权。Kubernetes本地组件包括<a class="ae jc" href="https://pkg.go.dev/k8s.io/autoscaler/cluster-autoscaler" rel="noopener ugc nofollow" target="_blank">集群自动缩放器</a>、<a class="ae jc" href="https://pkg.go.dev/k8s.io/kubernetes/cmd/kube-controller-manager" rel="noopener ugc nofollow" target="_blank"> kube控制器管理器</a>和<a class="ae jc" href="https://pkg.go.dev/k8s.io/kubernetes/cmd/kube-scheduler" rel="noopener ugc nofollow" target="_blank"> kube调度器</a>在<a class="ae jc" href="https://pkg.go.dev/k8s.io/client-go/tools/leaderelection" rel="noopener ugc nofollow" target="_blank">客户端运行</a>中使用leader-with-lease。</li><li id="ef32" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated"><strong class="ig hi">Leader-for-life</strong>:Leader pod只有在被删除且其依赖的configmap被垃圾收集时才会放弃领导权。配置图被用作领导的真理来源，因此不可能同时有两个领导(又名裂脑)。我们控制平面中的所有资源控制器都使用来自<a class="ae jc" href="https://pkg.go.dev/github.com/operator-framework/operator-lib/leader" rel="noopener ugc nofollow" target="_blank">操作符框架</a>的终身领导者选举机制，以确保我们一次最多有一个领导者。</li></ul><p id="56ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本帖中，我们将重点关注终身领导方法的优化，以减少控制平面领导切换时间并提高控制平面性能。</p><h2 id="9d8e" class="ll je hh bd jf lm ln lo jj lp lq lr jn ip ls lt jr it lu lv jv ix lw lx jz ly bi translated">监视</h2><p id="65ee" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">为了监控领导权交接时间，我们实施了细粒度的领导权交接指标，包括以下阶段:</p><ul class=""><li id="c8e6" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated"><strong class="ig hi">无领导</strong>:无领导时</li><li id="d643" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated"><strong class="ig hi"> Leader ramp-up </strong>:从一个控制器盒成为Leader到其第一次协调的时间。新的领导者圆荚体不能一成为领导者就开始调和；相反，它必须等到所有相关的通知者都同步。</li></ul><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ma"><img src="../Images/a2c840e3b4f3baaec74ce414bb4b0d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGVrPgz8V45bK5FgiyYo1w.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Figure 6: Diagram of the leadership switch procedure</figcaption></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lz"><img src="../Images/c46ee4eeab5be0318e2475e9ed711680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i5GHi6uyVx6r7G_Y"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Figure 7: Control plane leadership switch monitored by the proposed leadership switch metrics</figcaption></figure><p id="c3c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如图7所示，控制平面领导切换通常需要一分多钟才能完成，这对于高性能控制平面来说是不可接受的。我们提出了以下解决方案来减少领导层切换时间。</p><h2 id="ffd0" class="ll je hh bd jf lm ln lo jj lp lq lr jn ip ls lt jr it lu lv jv ix lw lx jz ly bi translated">减少无领导时间</h2><p id="430a" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">终身领导者套餐硬编码了尝试成为领导者之间的指数后退间隔，从1秒到最大16秒。当一个容器需要一些时间来初始化时，它总是达到最大值16秒。我们使退避间隔可配置，并减少它以适应我们的情况。我们还向运营商框架社区反馈了我们的解决方案。</p><h2 id="fbdf" class="ll je hh bd jf lm ln lo jj lp lq lr jn ip ls lt jr it lu lv jv ix lw lx jz ly bi translated">减少领导者的上升时间</h2><p id="385d" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在leader ramp-up期间，每个集群中的每个资源通知器向API服务器发起一个List调用，并将其缓存与返回的结果同步。只有当所有告密者缓存同步时，领导者才会开始协调。</p><p id="a32b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">预载信息缓存</strong></p><p id="a3b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">缩短leader上升时间的一种方法是让备用控制器pod预加载其informer缓存。换句话说，informer缓存的初始化不再是leader独有的，而是在创建时应用于每个控制器pod。注意，注册事件处理程序仍然是领导的专属，否则我们会患裂脑症。</p><p id="a45d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">使用就绪探测器确保平稳滚动升级</strong></p><p id="a853" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">informer缓存预加载程序在后台运行，不会阻止备用pod成为主pod。为了实施阻塞，我们通过HTTP GET请求定义了一个就绪探测器，以定期检查所有的通知器缓存是否同步。通过滚动升级策略，旧的主pod在新的备用pod准备好之后被杀死，这确保了新的pod在成为主pod时总是被预热。</p><h2 id="a00d" class="ll je hh bd jf lm ln lo jj lp lq lr jn ip ls lt jr it lu lv jv ix lw lx jz ly bi translated">结果</h2><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mb"><img src="../Images/c91692ef506a012cb3d8ae03a6327ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5DVX4zxQ-WEWfCuPyY-5g.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Table 1: Improvement on control plane leadership switch monitored by the proposed leadership switch metrics (4 observations before and after)</figcaption></figure><p id="7c3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">表1显示了控制平面领导开关的改进。<strong class="ig hi">平均控制平面领导切换时间从64秒减少到10秒，提高了85%。</strong></p><h1 id="94d8" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">下一步是什么</h1><p id="7938" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">通过这些努力，我们改进了控制平面的性能，并将其SLO从99%重新定义为99.9%。对于基于Kubernetes的计算平台来说，这是一个巨大的里程碑，展示了前所未有的可靠性和可用性。我们正在努力实现更高的SLO，并确定了以下可以进一步提高控制平面性能的领域。</p><ul class=""><li id="efc8" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated"><strong class="ig hi">主动的领导权交接</strong>:终身领导中的领导权交接是被动的，因为它依赖于外部组件的观察来释放资源锁。花在垃圾收集上的时间占我们目前领导权交接时间的50%。当领导者接收到SIGTERM并在退出前有意释放其锁时，由领导者执行主动领导移交。这将大大减少领导层转换的时间。</li><li id="1019" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated"><strong class="ig hi">协调服务质量(QoS) </strong>:在本文中，我们将从延迟入队和立即入队两个方面展示我们对工作池效率的优化。对于未来的工作，我们希望引入协调QoS和工作队列分层(例如，为不同的工作负载层创建不同的队列，以确保高层不会受到干扰和阻塞)。</li></ul><h1 id="76a9" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">确认</h1><p id="bcc1" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">向Suli Xu和致敬，感谢他们在构建高性能控制平台以支持业务需求方面做出的巨大贡献。特别感谢June Liu、Anson Qian、Haniel Martino、、Quentin Miao、Robson Braga和Martin Stankard的反馈和支持。</p><p id="259c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="mc">要在Pinterest了解更多工程知识，请查看我们的</em> <a class="ae jc" href="https://medium.com/pinterest-engineering" rel="noopener"> <em class="mc">工程博客</em> </a> <em class="mc">，并访问我们的</em><a class="ae jc" href="https://www.pinterestlabs.com/?utm_source=medium&amp;utm_medium=blog-link&amp;utm_campaign=li-march-22-2022" rel="noopener ugc nofollow" target="_blank"><em class="mc">Pinterest Labs</em></a><em class="mc">网站。要查看和申请空缺职位，请访问我们的</em> <a class="ae jc" href="https://www.pinterestcareers.com/?utm_source=medium&amp;utm_medium=blog-link&amp;utm_campaign=li-march-22-2022" rel="noopener ugc nofollow" target="_blank"> <em class="mc">招聘</em> </a> <em class="mc">页面</em></p></div></div>    
</body>
</html>