<html>
<head>
<title>Oracle Offline Persistence Toolkit — Before Request Sync Listener</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle离线持久性工具包—请求前同步监听程序</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/oracle-offline-persistence-toolkit-before-request-sync-listener-86d3ba015a2e?source=collection_archive---------7-----------------------#2018-10-02">https://medium.com/oracledevs/oracle-offline-persistence-toolkit-before-request-sync-listener-86d3ba015a2e?source=collection_archive---------7-----------------------#2018-10-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="30db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我写的另一篇文章是关于Oracle离线持久性工具包的。我已经描述了请求后监听程序如何在同步后读取响应数据Oracle离线持久性工具包—请求后同步监听程序。今天将解释before request监听器何时有用。与请求后监听程序相同，它是在持久性管理器注册期间定义的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/413c35845766694afb977c0bea0774bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nImdUcVY70po3klUSNXZA.png"/></div></div></figure><p id="dd3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在请求之前，听者必须返回承诺。我们可以控制决心行动。例如如果没有需要更新的请求，我们只需返回<em class="jp">继续</em>。如果在同步期间同一行被多次更新，我们将需要更新请求。必须在请求有效负载中更新更改指示符值。我们从数组中读取最新变化指示器值，在请求后监听器中初始化。请求有效负载被转换成JSON，值被更新，然后我们构造新的请求并用<em class="jp"> replay </em>解决它。API允许通过替换原始请求来提供新请求:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jq"><img src="../Images/572954888ab9d8d1937ae991f36c3fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SSSSWHqqHUMYgFu94goVA.png"/></div></div></figure><p id="f7ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是使用案例。离线时—更新值:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jr"><img src="../Images/a31cc5d5d15ee4159f1417c7574a459a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b9pfivO1IbNpUjF1TTVTsA.png"/></div></div></figure><p id="b787" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">保持脱机时，再次更新相同的值:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es js"><img src="../Images/3e560c7f6c89e18ff3462e0260997962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viusSAagDHHKYWZoquzJ_A.png"/></div></div></figure><p id="81a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们应该在联机时跟踪同步期间执行的请求。由第一变化发起的第一请求使用变化指示符值292:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jt"><img src="../Images/a319a5df3745ffd21b66773c1a20e528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9F_anvE6kEh4bfkN4MLppA.png"/></div></div></figure><p id="ae31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个请求使用更新的变化指示符值293:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/216e4046480dfa9be21ebaff7af12e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1W38omlk7tUMpDiv6NC0Qw.png"/></div></div></figure><p id="fef6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果没有之前和之后的请求侦听器逻辑，第二个请求将以与第一个请求相同的更改指示符值执行。这将导致后端的数据冲突。</p><p id="0280" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">示例应用程序代码可在<a class="ae jc" href="https://github.com/abaranovskis-redsamurai/persistencejetapp" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><p id="b545" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jp">原载于2018年10月2日</em><a class="ae jc" href="https://andrejusb.blogspot.com/2018/10/oracle-offline-persistence-toolkit.html" rel="noopener ugc nofollow" target="_blank"><em class="jp">andrejusb.blogspot.com</em></a><em class="jp">。</em></p></div></div>    
</body>
</html>