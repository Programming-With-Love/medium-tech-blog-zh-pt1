<html>
<head>
<title>JSON Processing Pipelines with gron</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用gron的JSON处理管道</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/json-processing-pipelines-with-gron-6fbd531155d7?source=collection_archive---------0-----------------------#2018-10-15">https://medium.com/capital-one-tech/json-processing-pipelines-with-gron-6fbd531155d7?source=collection_archive---------0-----------------------#2018-10-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="2504" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">使用Linux工具解析和操作用gron转换的JSON</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/cbf2e26597ba9ac8c011dd3be5d364e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNLmGKS0eu4_0LLqk8kyTg.jpeg"/></div></div></figure><p id="e7e0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">作为一名通晓多种语言的程序员，我总是努力使用最简单的方法和最好的工具来完成工作。我在Java、Python和Go中解析过JSON，但是我认为太多时候我们忽略了诸如sed、awk、cut等UNIX/Linux工具。太多的程序员编写笨重的数据解析器，这是多余的。有了<a class="ae ke" href="https://github.com/tomnomnom/gron" rel="noopener ugc nofollow" target="_blank"> gron </a>转换，我发现利用这些强大的UNIX/Linux文本编辑、操作和过滤工具变得更加容易。</p><p id="209c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然jq在解析已知的JSON结构方面很强大，但是它的主要缺点是需要知道正在解析的JSON结构。gron限制较少，可以很容易地与上面的Linux工具结合起来，构建非常强大的解析管道，而不需要确切地知道在哪里可以得到特定的结构或值。</p><h1 id="2c74" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">安装gron </strong></h1><p id="60b6" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">安装gron的说明可以在<a class="ae ke" href="https://github.com/tomnomnom/gron#installation" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我使用brew安装gron，然后，出于稍后将显而易见的原因，我添加了以下别名:</p><p id="58c1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">别名norg="gron — ungron "。</p><h1 id="28bf" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">使JSON可greppable </strong></h1><p id="e309" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">显然，作为基于文本的，JSON已经是“greppable”了。然而，gron的优势在于它能够将JSON分解成被称为“离散赋值”的行。</p><p id="4ad7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">给出下面的JSON片段(来自AWS EC2 CLI调用):</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="7459" class="lh kg hh ld b fi li lj l lk ll">{  <br/>     "Reservations": [  <br/>         {  <br/>             "OwnerId": "&lt;OWNER_ID&gt;",   <br/>             "ReservationId": "&lt;RES_ID&gt;",   <br/>             "Groups": [],   <br/>             "Instances": [  <br/>                 {  <br/>                     "Monitoring": {  <br/>                         "State": "disabled"  <br/>                     },   <br/>                     "PublicDnsName": "",   <br/>                     "State": {  <br/>                         "Code": 16,   <br/>                         "Name": "running"  <br/>                     },   <br/>                     "EbsOptimized": false,   <br/>                     "LaunchTime": "2016-08-31T22:39:37.000Z",   <br/>                     "PublicIpAddress": "&lt;PUBLIC_IP&gt;",   <br/>                     "PrivateIpAddress": "&lt;PRIVATE_IP&gt;",   <br/>                     "ProductCodes": [],   <br/>                     "VpcId": "&lt;VPC_ID&gt;",   <br/>                     "StateTransitionReason": "",   <br/>                     "InstanceId": "&lt;ID&gt;",   <br/>                     "ImageId": "&lt;AMI_ID&gt;",   <br/>                     "PrivateDnsName": "&lt;PRIVATE_DNS_NAME&gt;",   <br/>                     "KeyName": "&lt;KEY_NAME&gt;",   <br/>                     "SecurityGroups": [...</span></pre><p id="f24a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">gron将解析(cat ~/ec2.json | gron)并将json转换成离散赋值行:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="6e1d" class="lh kg hh ld b fi li lj l lk ll">json = {};  <br/>json.Reservations = [];  <br/>json.Reservations[0] = {};  <br/>json.Reservations[0].Groups = [];  <br/>json.Reservations[0].Instances = [];  <br/>json.Reservations[0].Instances[0] = {};  <br/>json.Reservations[0].Instances[0].AmiLaunchIndex = 0;  <br/>json.Reservations[0].Instances[0].Architecture = "x86_64";  <br/>json.Reservations[0].Instances[0].BlockDeviceMappings = [];  <br/>json.Reservations[0].Instances[0].BlockDeviceMappings[0] = {};  <br/>json.Reservations[0].Instances[0].BlockDeviceMappings[0].DeviceName = "/dev/xvda";  <br/>json.Reservations[0].Instances[0].BlockDeviceMappings[0].Ebs = {};  <br/>json.Reservations[0].Instances[0].BlockDeviceMappings[0].Ebs.AttachTime = "2016-08-21T22:00:41.000Z";  <br/>json.Reservations[0].Instances[0].BlockDeviceMappings[0].Ebs.DeleteOnTermination = true;  <br/>json.Reservations[0].Instances[0].BlockDeviceMappings[0].Ebs.Status = "attached";  <br/>json.Reservations[0].Instances[0].BlockDeviceMappings[0].Ebs.VolumeId = "&lt;VOL_ID&gt;";  <br/>json.Reservations[0].Instances[0].ClientToken = "&lt;CLIENT_TOKEN&gt;";  <br/>json.Reservations[0].Instances[0].EbsOptimized = false;  <br/>json.Reservations[0].Instances[0].Hypervisor = "xen";  <br/>json.Reservations[0].Instances[0].ImageId = "&lt;AMI_ID&gt;";  <br/>json.Reservations[0].Instances[0].InstanceId = "&lt;ID&gt;";  <br/>json.Reservations[0].Instances[0].InstanceType = "t2.small";  <br/>json.Reservations[0].Instances[0].KeyName = "&lt;KEY_NAME&gt;";  <br/>json.Reservations[0].Instances[0].LaunchTime = "2016-08-31T22:39:37.000Z";  <br/>json.Reservations[0].Instances[0].Monitoring = {};  <br/>json.Reservations[0].Instances[0].Monitoring.State = "disabled";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces = [];  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0] = {};  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Association = {};  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Association.IpOwnerId = "&lt;OWNER_ID&gt;";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Association.PublicDnsName = "";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Association.PublicIp = "&lt;PUBLIC_IP&gt;";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Attachment = {};  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Attachment.AttachTime = "2016-08-21T22:00:40.000Z";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Attachment.AttachmentId = "&lt;ENI_ID&gt;";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Attachment.DeleteOnTermination = true;  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Attachment.DeviceIndex = 0;  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Attachment.Status = "attached";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Description = "Primary network interface";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Groups = [];  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Groups[0] = {};  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Groups[0].GroupId = "&lt;SG_ID&gt;";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Groups[0].GroupName = "Bastion";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].MacAddress = "&lt;MAC_ADDRESS&gt;";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].NetworkInterfaceId = "&lt;ENI_ID&gt;";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].OwnerId = "&lt;OWNER_ID&gt;";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddress = "&lt;PRIVATE_IP&gt;";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddresses = [];  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddresses[0] = {};  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddresses[0].Association = {};  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddresses[0].Association.IpOwnerId = "&lt;OWNER_ID&gt;";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddresses[0].Association.PublicDnsName = "";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddresses[0].Association.PublicIp = "&lt;PUBLIC_IP&gt;";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddresses[0].Primary = true;  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].PrivateIpAddresses[0].PrivateIpAddress = "&lt;PRIVATE_IP&gt;";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].SourceDestCheck = true;  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].Status = "in-use";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].SubnetId = "&lt;SUBNET_ID&gt;";  <br/>json.Reservations[0].Instances[0].NetworkInterfaces[0].VpcId = "&lt;VPC_ID&gt;";  <br/>json.Reservations[0].Instances[0].Placement = {};  <br/>json.Reservations[0].Instances[0].Placement.AvailabilityZone = "us-east-1a";  <br/>json.Reservations[0].Instances[0].Placement.GroupName = "";  <br/>json.Reservations[0].Instances[0].Placement.Tenancy = "default";  <br/>json.Reservations[0].Instances[0].PrivateDnsName = "&lt;DNS_NAME&gt;";  <br/>json.Reservations[0].Instances[0].PrivateIpAddress = "&lt;PRIVATE_IP&gt;";  <br/>json.Reservations[0].Instances[0].ProductCodes = [];  <br/>json.Reservations[0].Instances[0].PublicDnsName = "";  <br/>json.Reservations[0].Instances[0].PublicIpAddress = "&lt;PUBLIC_IP&gt;";  <br/>json.Reservations[0].Instances[0].RootDeviceName = "/dev/xvda";  <br/>json.Reservations[0].Instances[0].RootDeviceType = "ebs";  <br/>json.Reservations[0].Instances[0].SecurityGroups = [];...</span></pre><h1 id="5830" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">通过命令行流水线输出Munging gron】</strong></h1><p id="14b9" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">JSON比gron输出更紧凑，适合用于传输和集成的数据结构。虽然更冗长，但gron输出是一种更有用的格式，可以通过Linux的文本操作和过滤工具，甚至是<a class="ae ke" href="https://www.gnu.org/software/sed/manual/sed.html" rel="noopener ugc nofollow" target="_blank"> sed </a>和<a class="ae ke" href="https://www.gnu.org/software/gawk/manual/gawk.html" rel="noopener ugc nofollow" target="_blank"> awk </a>进行文本搜索、过滤和操作。例如，考虑以下命令:</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="7bbb" class="lh kg hh ld b fi li lj l lk ll">$ cat ~/ec2.json | gron | grep AvailabilityZone</span><span id="4d16" class="lh kg hh ld b fi lm lj l lk ll">json.Reservations[0].Instances[0].Placement.AvailabilityZone = “us-east-1a”;</span></pre><p id="31ca" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">上面的命令“pipeline”在gronned JSON中搜索文本“AvailabilityZone”值，并返回离散赋值行。</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="9135" class="lh kg hh ld b fi li lj l lk ll">$ cat ~/ec2.json | gron | grep AvailabilityZone|cut -d\” -f2</span><span id="a06d" class="lh kg hh ld b fi lm lj l lk ll">us-east-1a</span></pre><p id="c7f5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">上面的管道通过Linux cut命令提取AvailabilityZone值。</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="75c6" class="lh kg hh ld b fi li lj l lk ll">$ cat ~/ec2s.json | gron | grep InstanceId | cut -d\” -f2</span><span id="295e" class="lh kg hh ld b fi lm lj l lk ll">…<br/>&lt;ID_1&gt;<br/>&lt;ID_2&gt;<br/>&lt;ID_3&gt;<br/>…</span></pre><p id="6ab0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">上面的管道从AWS EC2 CLI输出中提取所有EC2实例id，并创建一个id列表。</p><h1 id="d6c9" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">用gron和ungron(又名norg)转换JSON</strong></h1><p id="0d60" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">前面，我引用了指向ungron命令的norg别名。使用这个命令，gron将把gron离散赋值转换回JSON。考虑下面的命令:</p><p id="34c6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">注:</strong>去掉了cat，直接调用了gron。</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="cafa" class="lh kg hh ld b fi li lj l lk ll">$ gron ~/ec2s.json | grep InstanceId | norg</span><span id="3e87" class="lh kg hh ld b fi lm lj l lk ll">...<br/>{<br/>      "Instances": [<br/>        {<br/>          "InstanceId": "&lt;ID&gt;"<br/>        }<br/>      ]<br/>    },<br/>    {<br/>      "Instances": [<br/>        {<br/>          "InstanceId": "&lt;ID&gt;"<br/>        }<br/>      ]<br/>    },<br/>...</span></pre><p id="66ff" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">上面的管道grons JSON，greps for instance id字段，然后转换离散赋值的行</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="637a" class="lh kg hh ld b fi li lj l lk ll">(json.Reservations[999].Instances[0].InstanceId = “&lt;ID&gt;”;) </span></pre><p id="ec5a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从grepped gron输出返回到可用且简化的JSON。</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="9e0f" class="lh kg hh ld b fi li lj l lk ll">$ gron ~/ec2s.json | egrep InstanceId\|ImageId | norg</span><span id="335a" class="lh kg hh ld b fi lm lj l lk ll">...<br/>    {<br/>      "Instances": [<br/>        {<br/>          "ImageId": "&lt;AMI_ID&gt;",<br/>          "InstanceId": "&lt;ID&gt;"<br/>        }<br/>      ]<br/>    },<br/>    {<br/>      "Instances": [<br/>        {<br/>          "ImageId": "&lt;AMI_ID&gt;",<br/>          "InstanceId": "&lt;ID&gt;"<br/>        }<br/>      ]<br/>    },<br/>...</span></pre><p id="3668" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">上面的管道使用egrep将ImageId添加到转换后的JSON中(是的，我知道GNU已经弃用egrep来代替grep -E)。</p><h1 id="0aa8" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak"> sed </strong></h1><p id="7f7f" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">sed是一个强大的流编辑器，可以方便地对文本文件执行查找/替换算法。</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="8804" class="lh kg hh ld b fi li lj l lk ll">$ gron ~/ec2s.json | egrep InstanceId\|ImageId\|InstanceType | sed -e ‘s/Instances/node/g;s/ImageId/ami/g;s/InstanceType/type/g;s/InstanceId/id/g’ | norg</span><span id="f8a1" class="lh kg hh ld b fi lm lj l lk ll">...<br/>{<br/>      "node": [<br/>        {<br/>          "ami": "&lt;AMI_ID&gt;",<br/>          "id": "&lt;ID&gt;",<br/>          "type": "t2.small"<br/>        }<br/>      ]<br/>    },<br/>    {<br/>      "node": [<br/>        {<br/>          "ami": "&lt;AMI_ID&gt;",<br/>          "id": "&lt;ID&gt;",<br/>          "type": "t2.micro"<br/>        }<br/>      ]<br/>    },<br/>...</span></pre><p id="5869" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">上面的管道添加了sed流编辑，以执行多个内联字符串替换。</p><pre class="ix iy iz ja fd lc ld le lf aw lg bi"><span id="5bf5" class="lh kg hh ld b fi li lj l lk ll">$ gron ~/ec2s.json | egrep InstanceId\|ImageId\|InstanceType | sed -e ‘s/Instances/node/g;s/ImageId/ami/g;s/InstanceType/type/g;s/InstanceId/id/g’ | norg | tr -d ‘\n’ | sed “s/ //g”</span><span id="91fa" class="lh kg hh ld b fi lm lj l lk ll">...<br/>{"node":[{"ami":"&lt;AMI_ID&gt;","id":"&lt;ID&gt;","type":"t2.small"}]},{"node":[{"ami":"&lt;AMI_ID&gt;","id":"&lt;ID&gt;","type":"t2.micro"}]},<br/>...</span></pre><p id="d521" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">上面的管道添加了translate命令tr来删除换行符，然后添加了另一个sed命令来删除剩余的空白。这对于最小化JSON文件很方便。</p><h1 id="c1f1" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">总结</strong></h1><p id="b4fa" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">gron将结构化JSON转换成离散赋值行。这种转换使流程能够将文本传输到grep和sed等本地工具，以执行强大的文本操作。一旦被操作，离散赋值可以通过gron -u| — ungron命令转换回JSON。这使得gron成为grep和sed等现有工具的补充，用于管理JSON数据。</p></div><div class="ab cl ln lo go lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ha hb hc hd he"><p id="fdee" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lu">声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为Capital One 2018。</em></p></div></div>    
</body>
</html>