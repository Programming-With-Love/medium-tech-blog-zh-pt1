<html>
<head>
<title>Troubleshooting ProGuard issues on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上的ProGuard问题疑难解答</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/troubleshooting-proguard-issues-on-android-bce9de4f8a74?source=collection_archive---------1-----------------------#2017-09-29">https://medium.com/androiddevelopers/troubleshooting-proguard-issues-on-android-bce9de4f8a74?source=collection_archive---------1-----------------------#2017-09-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="0602" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">为什么是ProGuard？</h1><p id="b7c2" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">ProGuard是一个缩小、优化和混淆代码的工具。虽然有其他工具可供开发人员使用，但ProGuard很容易作为Android Gradle构建过程的一部分，并随SDK一起提供。</p><p id="fdea" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在构建应用程序时，您可能有很多原因想要启用ProGuard。一些开发人员更关心混淆部分，但对我来说，主要的好处是删除了所有未使用的代码，否则这些代码会作为classes.dex文件的一部分随APK一起提供。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/8bdb4f3fa8f00efc3dadf6cdbc003962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qPTtQ4y-0g9kMye3."/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx">An example size distribution chart of an Android app. Data source: <a class="ae kv" href="https://github.com/googlesamples/android-topeka" rel="noopener ugc nofollow" target="_blank">Topeka sample app</a>.</figcaption></figure><p id="48cd" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">让你的代码(和应用)变小有很多实实在在的好处，比如增加用户留存和满意度，更快的下载和安装时间，以及接触低端设备上的用户，尤其是在新兴市场。甚至在某些情况下，你需要限制你的应用程序的大小，例如<a class="ae kv" href="https://developer.android.com/topic/instant-apps/faqs.html#apk-size" rel="noopener ugc nofollow" target="_blank">即时应用程序</a>的4MB限制，这证明ProGuard是不可或缺的。</p><p id="2676" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">如果这还不足以说服你，那么考虑去掉未使用的代码并模糊所有的名字具有累积效应，并且可以解锁更多的优化:</p><ul class=""><li id="62a2" class="kw kx hh je b jf ka jj kb jn ky jr kz jv la jz lb lc ld le bi translated">在某些版本的Android上，DEX代码在安装时或运行时被编译成机器代码。原始的DEX和优化后的代码一直保留在设备上，所以计算很简单:<strong class="je hi">代码越少，设备上的编译时间就越短，使用的存储空间也就越少</strong>。</li><li id="4e47" class="kw kx hh je b jf lf jj lg jn lh jr li jv lj jz lb lc ld le bi translated">ProGuard可以做的另一件事对代码大小有很大影响，那就是<strong class="je hi">将所有标识符(包、类和类成员)改为使用简称</strong>，比如<code class="du lk ll lm ln b">a.A</code>和<code class="du lk ll lm ln b">a.a.B</code>。这个过程被称为<em class="lo">混淆</em>。模糊处理以两种方式减少代码大小:表示这些名称的实际字符串更短，此外，如果它们共享相同的签名，它们现在有更高的机会被不同的方法和字段重用，这减少了字符串池中的总项数。</li><li id="9f80" class="kw kx hh je b jf lf jj lg jn lh jr li jv lj jz lb lc ld le bi translated">使用ProGuard是启用<a class="ae kv" href="https://developer.android.com/studio/build/shrink-code.html#shrink-resources" rel="noopener ugc nofollow" target="_blank">资源收缩器</a>的先决条件。<strong class="je hi">资源收缩器</strong> <strong class="je hi">去除项目</strong>中代码未引用的资源(例如图像，这通常是APK的最大部分)。</li><li id="e857" class="kw kx hh je b jf lf jj lg jn lh jr li jv lj jz lb lc ld le bi translated"><strong class="je hi">移除代码还可以把你从</strong> <a class="ae kv" href="https://developer.android.com/studio/build/multidex.html" rel="noopener ugc nofollow" target="_blank"> <strong class="je hi"> 64K dex方法参考问题</strong> </a>中解救出来。通过仅将您的代码实际使用的方法打包到APK中，特别是当您考虑第三方库时，您可以大大减少在您的应用程序中使用Multidex的需要。</li></ul><blockquote class="lp lq lr"><p id="6b01" class="jc jd lo je b jf ka jh ji jj kb jl jm ls kc jp jq lt kd jt ju lu ke jx jy jz ha bi translated"><strong class="je hi">我觉得每个安卓app都应该用代码收缩吗？是啊！</strong></p></blockquote><p id="e206" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">但在你采取行动之前，请继续阅读，了解当你启用ProGuard时，你的应用程序中可能出现的问题，有时是以非常微妙的方式出现的。虽然有些错误会阻止你构建你的应用程序，但也有一些错误你只能在运行时发现，所以确保你彻底测试了你的应用程序。</p><h1 id="c459" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">怎么ProGuard？</h1><p id="1a4d" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在您的项目中启用ProGuard非常简单，只需在您的主应用程序模块的<code class="du lk ll lm ln b">build.gradle</code>文件中添加这些行(如果它们不在那里的话):</p><pre class="kg kh ki kj fd lv ln lw lx aw ly bi"><span id="aeac" class="lz if hh ln b fi ma mb l mc md">buildTypes {</span><span id="6dd7" class="lz if hh ln b fi me mb l mc md"><em class="lo">/* you will normally want to enable ProGuard only for your release<br/>builds, as it’s an additional step that makes the build slower and can make debugging more difficult */<br/>  <br/>  </em>release {<br/>    minifyEnabled true<br/>    proguardFiles getDefaultProguardFile(‘proguard-android.txt’), ‘proguard-rules.pro’</span><span id="6730" class="lz if hh ln b fi me mb l mc md">  }<br/>}</span></pre><p id="6c8e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">ProGuard本身的配置是通过一个单独的配置文件来完成的。你可以在上面的片段中看到，我已经包含了Android Gradle插件<a class="ae kv" href="#9ca6" rel="noopener ugc nofollow"> </a>提供的默认配置，然后我将在<code class="du lk ll lm ln b">proguard-rules.pro</code>中添加一些与我的项目相关的选项。</p><p id="736e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">您可以在ProGuard网站上找到描述所有可能选项的<a class="ae kv" href="https://www.guardsquare.com/en/proguard/manual/usage#keepoptions" rel="noopener ugc nofollow" target="_blank">手册。在深入研究配置之前，最好先了解一下ProGuard是如何工作的，以及为什么我们需要指定额外的选项。</a></p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es mf"><img src="../Images/7eaf03c4559bc9b2d9a7a0f58269205e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y0tJVDd5RnFy_qUL."/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx">You can also watch <a class="ae kv" href="https://youtu.be/AdfKNgyT438?t=6m50s" rel="noopener ugc nofollow" target="_blank">part of this Google I/O session</a> to see Shai Barack’s explanation.</figcaption></figure><p id="a0ac" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">简而言之，ProGuard将项目的类文件作为输入，然后查看所有可能的应用程序入口点，并计算从这些入口点可到达的所有代码的映射，然后删除剩余的代码(死代码，或因为从未被调用而永远无法运行的代码)。</p><p id="1490" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">阅读ProGuard手册时，您应该跳过输入/输出部分，因为Android Gradle插件将为您指定输入(您的类)和库jar(您构建应用程序所依据的Android框架类)。</p><p id="450c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">正确配置ProGuard的重要部分是让它知道你的代码的哪些部分在运行时被访问，哪些不应该被删除(并且当模糊处理打开时，它们的名字也应该保持不变)。当只动态访问类或方法(使用反射)时，ProGuard有时在构建所用代码的图形时无法确定它们的“活性”,并且会错误地删除这些类。当您只从XML资源中引用代码时(通常在幕后使用反射)，也会发生这种情况。</p><p id="a30c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在典型的Android构建过程中，AAPT(处理资源的工具)会生成一个额外的ProGuard规则文件。它为<strong class="je hi"> </strong> Android应用程序入口点添加了明确的<a class="ae kv" href="https://www.guardsquare.com/en/proguard/manual/usage#keepoptions" rel="noopener ugc nofollow" target="_blank"> <strong class="je hi"> keep规则</strong> </a> <strong class="je hi"> </strong>，因此Android清单中的所有活动、服务、广播接收者和内容提供者都应该保持不变。这就是为什么在上面的动画中，<code class="du lk ll lm ln b">MyActivity</code>类没有被删除或重命名。</p><p id="b34a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">AAPT还将<strong class="je hi">保留</strong>XML布局中使用的所有视图(及其构造函数)和一些其他类，比如从动画过渡资源引用的过渡。您可以通过打开<code class="du lk ll lm ln b">&lt;your_project&gt;/&lt;app_module&gt;/build/intermediates/proguard-rules/&lt;variant&gt;/aapt_rules.txt:</code>来检查由AAPT在执行构建之后生成的配置文件</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es mg"><img src="../Images/60a1a83e8e209486af4178bfa73b2ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nVWailJWyOyv4sa5."/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx">An example ProGuard configuration created by AAPT during build</figcaption></figure><p id="ec40" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我将在本文的<a class="ae kv" href="#5a16" rel="noopener ugc nofollow">后面的</a>部分详细讨论<strong class="je hi">保持</strong>规则，但在此之前，最好先了解一下当…</p><h1 id="2c85" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">当启用ProGuard会破坏您的构建时</h1><p id="5d01" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在启用ProGuard测试运行时是否一切正常之前，首先您需要构建您的应用程序。不幸的是，当ProGuard检测到您的代码有问题时，例如引用丢失的类，它会在编译时发出警告，从而使您的构建失败。</p><p id="ab62" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">修复构建的关键是查看构建输出消息，理解警告是关于什么的，并解决它们，通常是通过修复您的依赖关系或者将<a class="ae kv" href="https://www.guardsquare.com/en/proguard/manual/usage#dontwarn" rel="noopener ugc nofollow" target="_blank"> <strong class="je hi"> -dontwarn </strong> </a>规则添加到您的ProGuard配置中。</p><p id="805b" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">出现警告的原因之一是当您的一个依赖项针对不在您的构建路径上的jar进行编译时，比如当使用<em class="lo">提供的</em>(仅编译时)依赖项时。有时候，在Android上运行库代码时，使用这些依赖关系的代码路径实际上并没有被调用。让我们看一个真实世界的例子。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es mh"><img src="../Images/f336e823372d30e27981a64ec161bb7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/0*a4_7ZBbkOG3gncuN."/></div><figcaption class="kr ks et er es kt ku bd b be z dx">Build output when building a project depending on OkHttp 3.8.0</figcaption></figure><p id="dde0" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">OkHttp库在3.8.0版本中给它们的类添加了新的注释(<code class="du lk ll lm ln b">javax.annotation.Nullable</code>)。因为它们使用了编译时依赖，注释本身不会进入依赖OkHttp的应用程序的最终版本(除非应用程序显式添加了<code class="du lk ll lm ln b">com.google.code.findbugs:jsr305</code>),并且<a class="ae kv" href="https://github.com/square/okhttp/issues/3355" rel="noopener ugc nofollow" target="_blank"> ProGuard会抱怨</a>缺少类。</p><p id="70e4" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">因为我们知道这些注释类不会在运行时使用，所以我们可以通过在ProGuard配置中添加<strong class="je hi"> -dontwarn </strong>规则来安全地忽略该警告，正如<a class="ae kv" href="https://github.com/square/okhttp/pull/3354/files" rel="noopener ugc nofollow" target="_blank">在OkHttp手册</a>中所建议的:</p><pre class="kg kh ki kj fd lv ln lw lx aw ly bi"><span id="e196" class="lz if hh ln b fi ma mb l mc md">-dontwarn javax.annotation.Nullable<br/>-dontwarn javax.annotation.ParametersAreNonnullByDefault</span></pre><p id="b60b" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">对于您在输出中看到的所有警告，您应该经历一个类似的过程，然后重新构建并重试，直到您的构建通过。重要的是理解为什么你会得到警告，忽略它是否安全，或者你是否真的在你的构建中遗漏了一些类。</p><p id="5c08" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">现在，您可能想使用<strong class="je hi">-</strong><a class="ae kv" href="https://www.guardsquare.com/en/proguard/manual/usage#ignorewarnings" rel="noopener ugc nofollow" target="_blank"><strong class="je hi">ignore warnings</strong></a>选项来忽略所有警告，但这很少是个好主意。在某些情况下，ProGuard警告实际上会让你知道会阻止你的应用程序工作的错误，以及你的配置的其他问题。</p><p id="f7ed" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">您可能还想阅读ProGuard <em class="lo">注释</em>(优先级低于警告的消息)，它可以突出通过反射访问的类的问题。虽然它们不会破坏您的构建，但会导致严重的运行时崩溃。这可能发生在…</p><h1 id="5a16" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">当ProGuard移除过多时</h1><p id="988f" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在某些情况下，ProGuard不知道一个类或方法正在被使用，比如当它只被反射、XML资源或JNI代码引用时。为了防止代码被删除或重命名，您必须在ProGuard配置中指定额外的<a class="ae kv" href="https://www.guardsquare.com/en/proguard/manual/usage#keepoptions" rel="noopener ugc nofollow" target="_blank"> <strong class="je hi"> keep </strong> rules </a>。开发人员有责任找出代码的哪些部分可能有问题，并提供必要的规则。</p><p id="9e1e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在运行时得到一个<code class="du lk ll lm ln b">ClassNotFoundException</code>或<code class="du lk ll lm ln b">MethodNotFoundException</code>是您丢失类或方法的一个明确标志，要么是因为ProGuard删除了它们，要么是因为错误配置的依赖关系导致它们首先丢失。彻底测试应用的发布版本(启用ProGuard)并处理这些错误是非常重要的。</p><p id="65a2" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">您可以使用不同风格的keep选项来配置Proguard:</p><ul class=""><li id="eee2" class="kw kx hh je b jf ka jj kb jn ky jr kz jv la jz lb lc ld le bi translated"><strong class="je hi">保留</strong> —保留所有匹配类规范的类和方法</li><li id="afac" class="kw kx hh je b jf lf jj lg jn lh jr li jv lj jz lb lc ld le bi translated"><strong class="je hi"> keepclassmembers — </strong>指定要保留的成员，但是仅当它们的父类由于某种其他原因而被保留时(可以从入口点访问或者由另一个规则保留)</li><li id="a3be" class="kw kx hh je b jf lf jj lg jn lh jr li jv lj jz lb lc ld le bi translated"><strong class="je hi"> keepclasseswithmembers </strong> —将保留类及其成员，但前提是类规范中列出的所有成员都存在</li></ul><p id="3455" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我建议您熟悉ProGuard中的<a class="ae kv" href="https://www.guardsquare.com/en/proguard/manual/usage#classspecification" rel="noopener ugc nofollow" target="_blank">类规范语法</a>，上面提到的所有keep规则都使用它，上一节讨论的<strong class="je hi"> -dontwarn </strong>选项也使用它。还有三个keep规则的版本，只防止混淆(重命名)，不防止收缩。您可以在ProGuard网站上的一个方便的<a class="ae kv" href="https://www.guardsquare.com/en/proguard/manual/usage#keepoverview" rel="noopener ugc nofollow" target="_blank">表格</a>中查看所有keep选项的概述。</p><p id="7a0c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">作为编写复杂的ProGuard规则的替代方法，您可以在不希望被ProGuard移除或重命名的单个类/方法/字段上添加一个<code class="du lk ll lm ln b"><a class="ae kv" href="https://developer.android.com/reference/android/support/annotation/Keep.html" rel="noopener ugc nofollow" target="_blank"><strong class="je hi">@Keep</strong></a></code> <a class="ae kv" href="https://developer.android.com/reference/android/support/annotation/Keep.html" rel="noopener ugc nofollow" target="_blank">注释</a>。您需要在构建中包含默认的Android ProGuard配置文件来使用这种技术。</p><h1 id="cda6" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">APK分析仪和程序</h1><p id="3f06" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">Android Studio中的<a class="ae kv" href="https://developer.android.com/studio/build/apk-analyzer.html" rel="noopener ugc nofollow" target="_blank"> APK分析器</a>可以帮助你查看哪些类被ProGuard删除，并为它们生成keep规则。当您在启用ProGuard的情况下构建APK时，会在<code class="du lk ll lm ln b">&lt;app_module&gt;/build/outputs/mapping/</code> <strong class="je hi"> </strong>中创建额外的输出文件，这些文件包含有关删除的代码以及从模糊名称到原始名称的映射的信息。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es mi"><img src="../Images/050a1acb327b9301a5abb2e61d8e1c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/0*ds03uyRBXdHyi7pV."/></div><figcaption class="kr ks et er es kt ku bd b be z dx">Loading ProGuard mappings in APK Analyzer unlocks more information in the DEX viewer</figcaption></figure><p id="c288" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">当您将这些映射加载到APK分析器时(使用<em class="lo">“Load Proguard mappings……”</em>按钮)，您会在DEX树形视图中获得一些额外的功能:</p><ul class=""><li id="6496" class="kw kx hh je b jf ka jj kb jn ky jr kz jv la jz lb lc ld le bi translated">所有的名字都去泡沫化了(你可以看到原来的名字)</li><li id="d735" class="kw kx hh je b jf lf jj lg jn lh jr li jv lj jz lb lc ld le bi translated">由ProGuard配置规则保存的<strong class="je hi">包、类、方法和字段以<strong class="je hi">粗体</strong>显示</strong></li><li id="7bae" class="kw kx hh je b jf lf jj lg jn lh jr li jv lj jz lb lc ld le bi translated">您可以启用“显示删除的节点”选项来查看ProGuard删除的任何内容(以删除线显示)。右键单击树中的一个节点可以生成一个keep规则，您可以将它粘贴到ProGuard配置文件中。</li></ul><h1 id="a017" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">当ProGuard移除太少时</h1><p id="66d0" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">Android ProGuard规则包括每个Android应用程序的一些安全默认设置，例如确保<code class="du lk ll lm ln b">View</code>getter和setters通常通过反射访问——以及许多其他常见的方法和类没有被删除。虽然这将防止你的应用程序在许多情况下崩溃，但配置可能不是100%适合你的应用程序。您可以删除默认的ProGuard文件并使用自己的文件。</p><p id="cb4b" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">如果您希望ProGuard删除所有未使用代码，您应该避免保留太宽泛的规则，例如涉及整个包的通配符匹配。相反，选择特定于类的规则或使用前面提到的<code class="du lk ll lm ln b">@Keep</code>注释。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es mj"><img src="../Images/9c5d3f030259a4760f5cd1e359b9f78d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p4zsl6tqrwy6jOUr."/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx">Use the <code class="du lk ll lm ln b">-whyareyoukeeping &lt;class-specification&gt;</code> option to see why classes are not removed</figcaption></figure><p id="92ea" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">如果您不确定为什么ProGuard没有删除您期望删除的部分代码，您可以在ProGuard配置文件中添加<a class="ae kv" href="https://www.guardsquare.com/en/proguard/manual/usage#whyareyoukeeping" rel="noopener ugc nofollow" target="_blank"><strong class="je hi">-whyareyoukeeping</strong></a>选项，然后重新构建您的APK。在构建输出中，您将能够看到使ProGuard决定保留代码的使用链。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es mk"><img src="../Images/57fa9482c7718055ffb610717c2f45f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SFubaEvLatNnVmDr."/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx">See references to classes and methods in APK Analyzer to track down what’s keeping them in the DEX</figcaption></figure><p id="468b" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">另一种方法不太准确，但不需要重新构建，并且适用于任何APK，那就是在APK分析器中打开DEX文件，右键单击您感兴趣的类/方法。选择“<em class="lo"> Find usages </em>”，你将能够浏览一个参考链，它可能会指导你哪部分代码正在使用给定的类/方法，从而防止它被移除。</p><h1 id="d593" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">程序保护和模糊堆栈跟踪</h1><p id="68cf" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我提到过，在构建过程中处理类文件时，ProGuard会输出映射和日志。每当您存储构建工件时，您应该将这些文件与您的APK一起保存。映射文件不能跨不同的版本使用，并且只能与生成它们的APK一起正确工作。拥有可用的映射将有助于您调试来自用户设备的崩溃，否则由于混淆的名称而难以检查。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es ml"><img src="../Images/b3c18d443ba002fb2c7759a4ac7ea80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wzjVsQyikWNXSjbO."/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx">Upload the ProGuard mapping file with your APK to Google Play Console in order to get deobfuscated stack traces</figcaption></figure><p id="5c71" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">当在游戏控制台上发布你的混淆版本APK时，记得也上传每个版本的映射文件。这样，无论何时你进入<em class="lo"> ANRs &amp;崩溃</em>页面，报告的堆栈跟踪将显示真实的类名和方法名以及行号，而不是缩短的和模糊的。</p><h1 id="7cc4" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">关于ProGuard和第三方库</h1><p id="e3c9" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">正如您有责任为自己的代码提供keep规则一样，第三方库创建者也有责任为您提供必要的配置，以便在启用ProGuard时，您的构建不会失败或应用程序不会崩溃。</p><p id="4f38" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">一些项目只是在其手册或自述文件中提到必要的规则，以便您可以将它们复制并粘贴到您的主ProGuard文件中。然而，有一个更好的方法。对于库模块和作为AAR发布的库，库的维护者可以指定AAR将提供的规则，并通过将以下代码片段添加到模块的<code class="du lk ll lm ln b">build.gradle</code>文件中，自动向库消费者的构建系统公开:</p><pre class="kg kh ki kj fd lv ln lw lx aw ly bi"><span id="561c" class="lz if hh ln b fi ma mb l mc md">release { //or your own build type<br/>  consumerProguardFiles ‘consumer-proguard.txt’<br/>}</span></pre><p id="a1b2" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">您放在<code class="du lk ll lm ln b">consumer-proguard.txt</code>文件中的规则将被附加到主ProGuard配置中，并在整个应用程序构建过程中使用。</p></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><blockquote class="lp lq lr"><p id="beb1" class="jc jd lo je b jf ka jh ji jj kb jl jm ls kc jp jq lt kd jt ju lu ke jx jy jz ha bi translated"><strong class="je hi">请参考我们的</strong> <a class="ae kv" href="https://developer.android.com/studio/build/shrink-code.html" rel="noopener ugc nofollow" target="_blank"> <strong class="je hi">文档页面</strong> </a> <strong class="je hi">了解更多关于代码和资源收缩的信息。</strong></p></blockquote></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><p id="5c74" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">启用ProGuard一开始可能会有点令人生畏，但我个人认为好处是值得的，只需一点时间投资，你就会得到一个更苗条、更优化的应用程序。更重要的是，现在花时间配置你的应用程序意味着你将准备好迎接名为R8的<a class="ae kv" href="https://r8.googlesource.com/r8" rel="noopener ugc nofollow" target="_blank">实验性progguard替代产品</a>的推出，它将与现有的progguard规则文件一起工作。</p><p id="162a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">除了让你的代码变得更小，ProGuard和R8可以选择性地应用优化来改变你的代码，让它运行得更快，但这是另一篇文章的主题…</p></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><p id="9ca6" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><a class="ae kv" href="#6c8e" rel="noopener ugc nofollow"/>ProGuard-Android . txt文件之前取自Sdk tools文件夹(<code class="du lk ll lm ln b">Sdk/tools/ProGuard/ProGuard-android.txt</code>)，但在较新版本的SDK Tools和Android Gradle plugin 2.2.0+中，它是在构建过程中从Android plugin jar中解压缩出来的。您可以在<code class="du lk ll lm ln b">&lt;your_project&gt;/build/intermediates/ProGuard-files/</code>中构建您的项目后找到配置文件</p></div></div>    
</body>
</html>