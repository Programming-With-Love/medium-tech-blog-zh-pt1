<html>
<head>
<title>Butter Smooth Performance of TableView and CollectionView with Prefetching API iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过预取API iOS使TableView和CollectionView的性能更加流畅</h1>
<blockquote>原文：<a href="https://medium.com/globant/butter-smooth-performance-of-tableview-and-collectionview-with-prefetching-api-ios-428fcc46c56e?source=collection_archive---------0-----------------------#2020-07-16">https://medium.com/globant/butter-smooth-performance-of-tableview-and-collectionview-with-prefetching-api-ios-428fcc46c56e?source=collection_archive---------0-----------------------#2020-07-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="ff84" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">起伏滚动</h1><p id="993d" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">平滑滚动符合每秒60帧(FPS)的显示限制。因此，应用程序需要每秒刷新60次用户界面，这意味着每帧大约有16毫秒的时间来呈现内容。系统会丢弃显示内容时间过长的帧。</p><p id="88cc" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">当应用程序跳过一些帧并移动到下一帧时，会有起伏的滚动体验。丢帧操作的一个可能原因是长时间运行阻塞了主线程。</p><p id="64f3" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">所以你必须分离出长时间运行的操作，并把它们转移到后台线程。这允许用户处理任何触摸事件。当后台操作完成时，您可以根据操作在主线程上进行任何所需的UI更新。</p><p id="12ac" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">下图显示了丢帧的情况:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/3a44315f1fe88d0bac98d65ee9331af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*tcMbYymwXZGw2mo0.png"/></div></figure><p id="b079" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">一旦你把工作移到后台，事情看起来就像这样:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/6e1aca48e7a7007e0b7a685118bda413.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*syHCaIy7tobdSxF2.png"/></div></figure><p id="d1ca" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">现在，您有两个并发线程正在运行，以提高您的应用程序的性能。</p><h1 id="2dab" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">预取的工作原理</h1><p id="930a" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">如果能在单元格必须显示数据之前就开始获取数据，那就更好了。<br/>所以在iOS 10中，苹果推出了预取<strong class="je hi"> UITableView </strong>和<strong class="je hi"> UICollectionView的API。在这个故事中，我将解释预取的用途以及如何正确使用预取</strong></p><p id="e955" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">当我们需要从远程或本地内存下载大型对象(图像或视频文件)时，预取非常有用。预取在访问数据模型时也给了我们惰性加载:我们不需要获取所有的数据模型，只需要下载差不多就可以显示了。预取减少了电池和CPU的消耗。它提供了更好的用户体验和流畅度。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/9dfef98938ebf007ba207445e3ef01e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*x8rgmeg6JAHvncdB.png"/></div></figure><p id="758e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">苹果没有提到可视单元格之外将预取多少行。</p><ul class=""><li id="8ca3" class="kr ks hh je b jf ka jj kb jn kt jr ku jv kv jz kw kx ky kz bi translated"><strong class="je hi">tableView(_ table view:UITableView，prefetchRowsAt index paths:[index path])</strong>对于最初在屏幕上可见但没有滚动的行，不会调用table view。</li><li id="f5d3" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz bi translated">在最初可见的行变得可见之后，将立即调用table view<strong class="je hi">(_ table view:UITableView，prefetchRowsAt indexPaths:[index path])</strong>，index paths变量包含大约7到10个最接近可见区域的行。</li><li id="ed4e" class="kr ks hh je b jf la jj lb jn lc jr ld jv le jz kw kx ky kz bi translated">取决于滚动速度，预取中的<strong class="je hi">索引路径</strong>，该方法将包含不同数量的行。在正常的滚动速度下，它通常包含一行。如果你快速滚动，它将包含多行。</li></ul><h1 id="bbb2" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">实施</h1><p id="9622" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在<strong class="je hi"> UITableView </strong>和<strong class="je hi"> UICollectionView </strong>中引入了新的属性prefetchDataSource:</p><pre class="kg kh ki kj fd lf kq lg lh aw li bi"><span id="e084" class="lj if hh kq b fi lk ll l lm ln"><strong class="kq hi">@available</strong>(iOS 10.0, <strong class="kq hi">*</strong>)<br/><strong class="kq hi">weak</strong> <strong class="kq hi">open</strong> <strong class="kq hi">var</strong> prefetchDataSource: <strong class="kq hi">UITableViewDataSourcePrefetching</strong>?</span></pre><p id="e937" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们必须确认UITableViewDataSourcePrefetching协议与UITableViewDataSource和UITableViewDelegate相同。</p><pre class="kg kh ki kj fd lf kq lg lh aw li bi"><span id="208d" class="lj if hh kq b fi lk ll l lm ln">Class ViewController: UITableViewDataSourcePrefetching {</span><span id="2e8a" class="lj if hh kq b fi lo ll l lm ln">}</span></pre><p id="47d4" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">通过编程或从故事板(界面)将视图控制器绑定到表视图预取数据源</p><pre class="kg kh ki kj fd lf kq lg lh aw li bi"><span id="8345" class="lj if hh kq b fi lk ll l lm ln">tableView.prefetchDataSource = self</span></pre><p id="30e9" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">运筹学</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lp"><img src="../Images/8a26ee6a08b3bd5f7fe68f08b00d69ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*hA5eP_munUfwXrfbjF7jBg.png"/></div></figure><p id="27f0" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">苹果推出的预取API <code class="du kn ko kp kq b">UITableViewDataSourcePrefetching</code>协议有两种方法:</p><pre class="kg kh ki kj fd lf kq lg lh aw li bi"><span id="90fa" class="lj if hh kq b fi lk ll l lm ln">Required method:</span><span id="3a88" class="lj if hh kq b fi lo ll l lm ln"><strong class="kq hi">public</strong> <strong class="kq hi">func</strong> <strong class="kq hi">tableView</strong>(_ tableView: <strong class="kq hi">UITableView</strong>, prefetchRowsAt indexPaths: <strong class="kq hi">[IndexPath]</strong>)</span><span id="dc68" class="lj if hh kq b fi lo ll l lm ln">Optional<!-- --> method:</span><span id="7e69" class="lj if hh kq b fi lo ll l lm ln"><strong class="kq hi">optional</strong> <strong class="kq hi">public</strong> <strong class="kq hi">func</strong> <strong class="kq hi">tableView</strong>(_ tableView: <strong class="kq hi">UITableView</strong>, cancelPrefetchingForRowsAt indexPaths: <strong class="kq hi">[IndexPath]</strong>)</span></pre><h1 id="23dc" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">例子</h1><pre class="kg kh ki kj fd lf kq lg lh aw li bi"><span id="f823" class="lj if hh kq b fi lk ll l lm ln">func tableView(_ tableView: UITableView, prefetchRowsAt indexPaths: [IndexPath]) {</span><span id="b3a4" class="lj if hh kq b fi lo ll l lm ln">    for indexPath in indexPaths {</span><span id="bc75" class="lj if hh kq b fi lo ll l lm ln">       guard operations[indexPath] == nil else { return }</span><span id="4567" class="lj if hh kq b fi lo ll l lm ln">       if let loader = dataStore.downloadImage(indexPath.row) {</span><span id="6756" class="lj if hh kq b fi lo ll l lm ln">       operationQueue.addOperation(loader)<br/>       operations[indexPath] = loader</span><span id="7013" class="lj if hh kq b fi lo ll l lm ln">      }<br/>    }<br/>}</span></pre><p id="7390" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">当不再需要时，取消下载(正在进行的数据):</p><pre class="kg kh ki kj fd lf kq lg lh aw li bi"><span id="ae10" class="lj if hh kq b fi lk ll l lm ln">func tableView(_ tableView: UITableView, cancelPrefetchingForRowsAt indexPaths: [IndexPath]) {</span><span id="7355" class="lj if hh kq b fi lo ll l lm ln">    for indexPath in indexPaths {</span><span id="40bc" class="lj if hh kq b fi lo ll l lm ln">      if let loader = operations[indexPath] {</span><span id="7a32" class="lj if hh kq b fi lo ll l lm ln">        loader.cancel()<br/>        operations[indexPath] = nil<br/>    }<br/>  }<br/>}</span></pre><p id="cb6c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">检查willDisplay方法中的while数据是否已在运行。</p><pre class="kg kh ki kj fd lf kq lg lh aw li bi"><span id="0300" class="lj if hh kq b fi lk ll l lm ln">func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {</span><span id="cd9c" class="lj if hh kq b fi lo ll l lm ln">  guard let cell = cell as? ImageTableViewCell else { return }</span><span id="8895" class="lj if hh kq b fi lo ll l lm ln">cell.downloadImageView?.image = nil</span><span id="137b" class="lj if hh kq b fi lo ll l lm ln">  if let loader = operations[indexPath] {</span><span id="0beb" class="lj if hh kq b fi lo ll l lm ln">     if let image = loader.image {<br/>       cell.downloadImageView.image = image<br/>     } else {<br/>      loader.completeHandler = { [weak self, weak cell] image in<br/>         guard self != nil else {return}<br/>         cell?.downloadImageView.image = image</span><span id="05dd" class="lj if hh kq b fi lo ll l lm ln">       }<br/>     }</span><span id="0287" class="lj if hh kq b fi lo ll l lm ln">} else {</span><span id="a070" class="lj if hh kq b fi lo ll l lm ln">      if let loader = dataStore.downloadImage(indexPath.row) {<br/>          operationQueue.addOperation(loader)<br/>          operations[indexPath] = loader<br/>          loader.completeHandler = { [weak self, weak cell] image in<br/>          guard self != nil else {return}<br/>          cell?.downloadImageView.image = image<br/>      }<br/>  }<br/> }<br/>}</span></pre><h1 id="487d" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">性能检查</h1><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lq"><img src="../Images/1c860b76c628d6c9d7981aad88cf97a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*idOWB6m8a_iwhsKv93Emnw.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Without Prefetching 8 frame missed</figcaption></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lq"><img src="../Images/83b871caa7844e3da2bc9b637e333642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*NoqAhiFsT-_kXZfqU-x2cg.png"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">With Prefetching 0 frame missed</figcaption></figure><h1 id="bcf8" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论</h1><p id="93fe" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">预取协议允许我们在显示行之前延迟加载数据和加载的数据，这允许良好的用户体验以及更平滑的滚动和加载过程。</p><p id="2d3b" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">参考来自<a class="ae lv" href="https://developer.apple.com/videos/play/wwdc2016/219/" rel="noopener ugc nofollow" target="_blank">苹果WWDC</a>T3】参考图片来自<a class="ae lv" href="https://www.raywenderlich.com/7341-uicollectionview-tutorial-prefetching-apis" rel="noopener ugc nofollow" target="_blank"> Raywenderlich </a></p></div></div>    
</body>
</html>