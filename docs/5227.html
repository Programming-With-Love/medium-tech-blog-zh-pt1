<html>
<head>
<title>Lightning Fast SQL with Real Time Materialized Views: 12 Things Developers Will Love About Oracle Database 12c Release 2 Part 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有实时物化视图的闪电般快速的SQL:开发人员会喜欢的关于Oracle Database 12c第2版第5部分的12件事</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/lightning-fast-sql-with-real-time-materialized-views-12-things-developers-will-love-about-oracle-54bcc9eac358?source=collection_archive---------0-----------------------#2016-11-10">https://medium.com/oracledevs/lightning-fast-sql-with-real-time-materialized-views-12-things-developers-will-love-about-oracle-54bcc9eac358?source=collection_archive---------0-----------------------#2016-11-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="15b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">物化视图可以带来惊人的性能提升。一旦基于查询创建了一个语句，Oracle就可以直接从MV中获得结果，而不用执行语句本身。这可以显著提高SQL的速度。尤其是当查询处理数百万行，但输出中只有少数几行时。</p><p id="554b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">只有一个问题。</p><p id="a675" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MV里的数据必须是新鲜的。否则甲骨文不会重写。</p><p id="b37a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你当然可以直接查询MV。但是数据仍然是旧的。</p><p id="cd24" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以您需要保持物化视图是最新的。最简单的方法是将其声明为“提交时快速刷新”。</p><p id="68de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但这说起来容易做起来难。这样做有几个问题:</p><p id="95f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，如果您有复杂的SQL，您可能无法使用查询重写。即使可以，在高事务系统上，刷新开销可能会使系统瘫痪。</p><p id="97c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以不是“提交时快速刷新”，而是让MV“按需快速刷新”。并创建一个作业来更新它。每秒钟都在运行！</p><p id="5417" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，无论您多频繁地运行作业，总会有MV过时的时候。因此查询性能可以在快如闪电和慢如狗之间切换。一个保证让你的用户不安的方法！</p><p id="1981" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么如何克服这一点呢？</p><p id="e1f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实时物化视图！</p><p id="5122" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些都是两全其美的。可以按需刷新MV。但是仍然让它返回最新信息。</p><p id="7f85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，使用子句创建MV:</p><p id="435b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于查询计算</p><p id="7790" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="5912" class="jl jm hh jh b fi jn jo l jp jq">create table t (<br/>  x not null primary key, y not null<br/>) as <br/>  select rownum x, mod(rownum, 10) y <br/>  from   dual connect by level &lt;= 1000; </span><span id="bc1e" class="jl jm hh jh b fi jr jo l jp jq">create materialized view log on t <br/>  with rowid (x, y) including new values; </span><span id="2b79" class="jl jm hh jh b fi jr jo l jp jq">create materialized view mv <br/>refresh fast on demand <br/>enable on query computation <br/>enable query rewrite as <br/>  select y , count(*) c1 <br/>  from   t <br/>  group by y;</span></pre><p id="081c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这样，您可以向表中添加更多数据:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="58c6" class="jl jm hh jh b fi jn jo l jp jq">insert into t <br/>  select 1000+rownum, 1 from dual <br/>  connect by level &lt;= 100; </span><span id="aef0" class="jl jm hh jh b fi jr jo l jp jq">commit;</span></pre><p id="b554" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">而且甲骨文还可以用MV来重写。<em class="js">即使MV已经陈旧</em>！</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="3cd3" class="jl jm hh jh b fi jn jo l jp jq">select /*+ rewrite */y , count(*) from t group by y;</span></pre><p id="3677" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它通过以下方式做到这一点:</p><ul class=""><li id="ef99" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated">查询过时的MV</li><li id="93e0" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">然后对其应用MV日志中的插入、更新和删除</li></ul><p id="f0a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这可能会导致一些可怕的执行计划！</p><figure class="jc jd je jf fd ki er es paragraph-image"><div class="er es kh"><img src="../Images/b97a073a14fac52dffcc2e6ab580478c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/0*y4Z1HkWnZQJKVVfK.png"/></div></figure><p id="3b7f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要记住的一点是，Oracle正在读取物化视图日志。然后将更改应用到MV。因此，两次刷新间隔的时间越长，数据就越多。您需要进行测试，找到平衡刷新过程和在查询重写时应用MV更改日志的最佳点。</p><p id="4cd3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你甚至可以在直接查询MV的时候获得最新的信息。为此，请添加fresh_mv提示:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="93a2" class="jl jm hh jh b fi jn jo l jp jq">select /*+ fresh_mv */* from mv;</span></pre><p id="d8cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最酷的部分是什么？</p><p id="d8b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以使用以下命令将现有的MVs转换为实时:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="14e3" class="jl jm hh jh b fi jn jo l jp jq">alter materialized view mv enable on query computation;</span></pre><p id="161e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这使得MVs更容易使用，打开了您的查询调优选项！</p></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><p id="6512" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">【blogs.oracle.com】全文原载于2016年11月10日<a class="ae ks" href="https://blogs.oracle.com/sql/12-things-developers-will-love-about-oracle-database-12c-release-2" rel="noopener ugc nofollow" target="_blank"><em class="js"/></a><em class="js">。</em></p></div></div>    
</body>
</html>