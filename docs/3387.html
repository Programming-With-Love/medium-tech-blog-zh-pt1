<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/globant/easy-way-to-implement-rest-api-calls-in-flutter-9859d1ab5396?source=collection_archive---------0-----------------------#2020-01-14">https://medium.com/globant/easy-way-to-implement-rest-api-calls-in-flutter-9859d1ab5396?source=collection_archive---------0-----------------------#2020-01-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/67a50967861ec37f0fe777fd1b2ef7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlk0_8LPtgHbGe8B6VcF0w.jpeg"/></div></div></figure><p id="58a3" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated"><strong class="ht ip">颤振中的改型实施</strong></p><p id="e405" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">通过以一种更加定制和安全的方式发送动态头、参数、打印请求和响应来调用Rest API是最好的解决方案。要将改造集成到您的项目中，请在pubspec.yaml文件中添加以下依赖项。</p><ol class=""><li id="29ad" class="iq ir hs ht b hu hv hy hz ic is ig it ik iu io iv iw ix iy bi translated"><strong class="ht ip">依赖关系:</strong></li></ol><figure class="iz ja jb jc fd hj"><div class="bz dy l di"><div class="jd je l"/></div></figure><p id="e8ac" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">运行命令“flutter pub get”下载依赖项。</p><p id="6574" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated"><strong class="ht ip"> 2。</strong>创建一个抽象类来添加基本URL，改进配置。这是我用基本URL、连接超时和响应超时在我的应用程序中创建的类。</p><figure class="iz ja jb jc fd hj"><div class="bz dy l di"><div class="jd je l"/></div></figure><p id="5a78" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">翻新在与ApiClient相同的文件夹中生成零件文件。这个文件有处理API调用的逻辑。</p><pre class="iz ja jb jc fd jf jg jh ji aw jj bi"><span id="f215" class="jk jl hs jg b fi jm jn l jo jp">Part file allows you to split a file into multiple dart files.</span></pre><p id="29c0" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">最初，没有生成零件文件，所以它将在_ApiClient给出一个错误。要创建零件文件，运行命令<code class="du jq jr js jg b">flutter pub run build_runner build</code>，它将显示警告“丢失”零件‘API _ client . g . dart’；“现在在ApiClient中添加一个零件文件，即<strong class="ht ip">part ' package:API _ client . g . dart '</strong>；再次运行相同的命令，将生成零件文件。</p><blockquote class="jt ju jv"><p id="d43d" class="hq hr jw ht b hu hv hw hx hy hz ia ib jx id ie if jy ih ii ij jz il im in io ha bi translated">如果您在ApiClient中进行了任何更改，那么也运行相同的命令来更新零件文件或运行命令<code class="du jq jr js jg b">flutter pub run build_runner watch</code>,它会观察项目文件中的更改，并在需要时自动构建文件。启动观察器一次并在后台运行是安全的</p></blockquote><p id="b86e" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated"><strong class="ht ip"> 3。API声明</strong></p><p id="138a" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">方法和URL参数上的注释决定了如何处理请求。每个方法都必须有HTTP注释和相关参数。有内置的注释，如GET、PUT、POST、PATCH、DELETE &amp; HEADER。在ApiClient中添加带注释的方法，如下所示。</p><figure class="iz ja jb jc fd hj"><div class="bz dy l di"><div class="jd je l"/></div></figure><p id="4194" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated"><strong class="ht ip">方法参数:</strong></p><p id="0245" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">@Path-要动态更新URL，用{ }括起来的替换块必须使用相同的字符串用@Path进行注释。<br/> @Body-发送dart对象作为请求体。<br/> @Query-用于追加网址。<br/>@ Headers——动态传递头。</p><p id="c18d" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated"><strong class="ht ip"> 4 </strong>。转换器:我们从JSON格式的API得到一个响应，我们必须在dart类中转换它。有两种方法可以解析JSON -</p><p id="f2d4" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated"><strong class="ht ip"> 4.1 </strong> <strong class="ht ip">手动序列化</strong>:改型使用Post.fromJson方法自动将“JSON”响应转换为“Post”。</p><figure class="iz ja jb jc fd hj er es paragraph-image"><div class="er es ka"><img src="../Images/a893cebe53f23daf9ee888b6bcf25130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*Po8kc0anZSd5jkakrKmxhA.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx">post.dart</figcaption></figure><p id="e4ad" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated"><strong class="ht ip"> 4.2自动序列化</strong>:</p><figure class="iz ja jb jc fd hj er es paragraph-image"><div class="er es kf"><img src="../Images/0c741648dc19c9e81f706704211d7b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*T08ez5tUDDY3btCyRmHNoA.png"/></div><figcaption class="kb kc et er es kd ke bd b be z dx">post.dart</figcaption></figure><p id="b081" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated"><strong class="ht ip">依赖关系:</strong></p><figure class="iz ja jb jc fd hj"><div class="bz dy l di"><div class="jd je l"/></div></figure><p id="b875" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">获取依赖项并运行<code class="du jq jr js jg b">flutter pub run build_runner build</code>来创建零件文件并导入到类中。生成的零件文件与dart文件同名，即“post.g.dart”</p><p id="18ea" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">这种序列化方法更适合大中型项目，因为我们不需要手写的样板代码和打字错误。这种方法的缺点是我们需要初始设置，并且为每个dart类创建部件文件，这可能会在项目中产生视觉混乱。</p><p id="3462" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated"><strong class="ht ip"> 5。错误处理</strong>:</p><p id="06a2" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">大多数情况下，在执行网络操作时，我们会遇到异常，如SocketConnectionException、ConnectionTimeout和无效状态代码。改造抛出了错误，我们必须处理它以避免应用程序被终止。我编写了一个ServerError类来处理异常。</p><figure class="iz ja jb jc fd hj"><div class="bz dy l di"><div class="jd je l"/></div></figure><p id="4d59" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated"><strong class="ht ip"> 6。回应:</strong></p><p id="c8f5" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">API响应应该是通用的，这样我们可以通过使用单个类来获得错误和成功响应。这是获得一般响应的基本模型。</p><figure class="iz ja jb jc fd hj"><div class="bz dy l di"><div class="jd je l"/></div></figure><p id="7e7c" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">现在一切都完成了，让我们执行网络操作:</p><figure class="iz ja jb jc fd hj"><div class="bz dy l di"><div class="jd je l"/></div></figure><p id="2b9e" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">这都是关于flutter中Rest API的实现。在下一篇博客中，我们将看到如何修改请求和响应日志。</p><p id="23f1" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">感谢您的阅读！</p><p id="c813" class="pw-post-body-paragraph hq hr hs ht b hu hv hw hx hy hz ia ib ic id ie if ig ih ii ij ik il im in io ha bi translated">参考资料:</p><div class="hg hh ez fb hi kg"><a href="https://square.github.io/retrofit/" rel="noopener  ugc nofollow" target="_blank"><div class="kh ab dw"><div class="ki ab kj cl cj kk"><h2 class="bd ip fi z dy kl ea eb km ed ef kn bi translated">加装</h2><div class="ko l"><h3 class="bd b fi z dy kl ea eb km ed ef dx translated">接口方法及其参数上的注释表明了如何处理请求。请求方法每隔…</h3></div><div class="kp l"><p class="bd b fp z dy kl ea eb km ed ef dx translated">square.github.io</p></div></div></div></a></div><div class="hg hh ez fb hi kg"><a href="https://flutter.dev/docs/development/data-and-backend/json" rel="noopener  ugc nofollow" target="_blank"><div class="kh ab dw"><div class="ki ab kj cl cj kk"><h2 class="bd ip fi z dy kl ea eb km ed ef kn bi translated">JSON和序列化</h2><div class="ko l"><h3 class="bd b fi z dy kl ea eb km ed ef dx translated">很难想象有哪个移动应用程序不需要与web服务器通信或轻松存储结构化数据…</h3></div><div class="kp l"><p class="bd b fp z dy kl ea eb km ed ef dx translated">颤振. dev</p></div></div><div class="kq l"><div class="kr l ks kt ku kq kv ho kg"/></div></div></a></div><div class="hg hh ez fb hi kg"><a href="https://pub.dev/packages/retrofit" rel="noopener  ugc nofollow" target="_blank"><div class="kh ab dw"><div class="ki ab kj cl cj kk"><h2 class="bd ip fi z dy kl ea eb km ed ef kn bi translated">翻新| Dart套装</h2><div class="ko l"><h3 class="bd b fi z dy kl ea eb km ed ef dx translated">dart是一个类型转换dio客户端生成器，使用source_gen，受Chopper和retrieve的启发。</h3></div><div class="kp l"><p class="bd b fp z dy kl ea eb km ed ef dx translated">公共开发</p></div></div><div class="kq l"><div class="kw l ks kt ku kq kv ho kg"/></div></div></a></div></div></div>    
</body>
</html>