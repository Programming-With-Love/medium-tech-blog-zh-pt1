<html>
<head>
<title>Compose O’Clock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构成时钟</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/compose-oclock-50c778a6360?source=collection_archive---------3-----------------------#2021-03-03">https://medium.com/google-developer-experts/compose-oclock-50c778a6360?source=collection_archive---------3-----------------------#2021-03-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="69ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">原载于</em><a class="ae jd" href="https://zsmb.co/compose-o-clock/" rel="noopener ugc nofollow" target="_blank"><em class="jc">zsmb.co</em></a><em class="jc">。</em></p><p id="4955" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">前几天在Reddit上见过<a class="ae jd" href="https://www.reddit.com/r/oddlysatisfying/comments/lsa654/this_clock_hitting_midnight_is_oddly_satisfying/" rel="noopener ugc nofollow" target="_blank">这个花里胡哨的钟</a>。看到我是如何在本周开始使用Jetpack Compose的，我觉得尝试用我们新的Android UI工具包重新实现那个时钟会很有趣。</p><p id="3c91" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">几个小时前，我看到Aurimas Liutikas <a class="ae jd" href="https://twitter.com/_aurimas/status/1366557927067185157" rel="noopener ugc nofollow" target="_blank">已经创建了一个相同设计的Compose实现</a>，但我故意不看源代码，因为我真的想自己弄清楚如何做到这一点。</p><p id="5505" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我在学习Jetpack Compose两天后，经过大约一个小时的反复试验得出的结论。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/a5547be7305f8ae4143d05451368b55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/1*vkBEZUMJyRWiLtR_h0x80g.gif"/></div></figure><p id="219f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们一步一步来看看如何构建它。</p><blockquote class="jm jn jo"><p id="aa2a" class="ie if jc ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated"><em class="hh">如果您正在寻找该示例的完整代码，GitHub </em>  <em class="hh">上的</em> <a class="ae jd" href="https://github.com/zsmb13/ComposeClock/blob/main/app/src/main/java/co/zsmb/composeclock/MainActivity.kt" rel="noopener ugc nofollow" target="_blank"> <em class="hh">都可以找到。</em></a></p></blockquote><h1 id="e1df" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">一位数</h1><p id="7add" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">首先，我们将创建一个<code class="du kv kw kx ky b">Number</code> composable，它包含一个固定大小的<code class="du kv kw kx ky b"><a class="ae jd" href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary.html#text" rel="noopener ugc nofollow" target="_blank">Text</a></code>。这需要一个参数，它应该显示的数值。</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="62b7" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>fun Number(value: Int) {<br/>    Text(<br/>        text = value.toString(),<br/>        fontSize = 20.sp,<br/>        modifier = Modifier.size(40.dp)<br/>    )<br/>}</span></pre><p id="cfba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个带有<code class="du kv kw kx ky b">Number</code>的<code class="du kv kw kx ky b">@Preview</code>让我们快速检查一下这个看起来如何:</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="fba0" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>@Preview<br/>fun NumberPreview() {<br/>    Number(3)<br/>}</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/5fcffe146a7532c0e72d146645b1b371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PVvySceAProCOHnU.png"/></div></div></figure><p id="73c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将数字呈现在左上角，但是我们希望将这个<code class="du kv kw kx ky b">Text</code>放在它的<code class="du kv kw kx ky b">40dp</code>乘<code class="du kv kw kx ky b">40dp</code>区域的中心。在它上面设置<code class="du kv kw kx ky b">textAlign</code>可以水平解决这个问题，但是我没有找到任何类似的垂直对齐方式。因此，让我们用一个<code class="du kv kw kx ky b"><a class="ae jd" href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#box" rel="noopener ugc nofollow" target="_blank">Box</a></code>将它包起来，以实现对齐。</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="c05b" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>fun Number(value: Int) {<br/>    Box(<br/>        contentAlignment = Alignment.Center,<br/>        modifier = Modifier.size(40.dp),<br/>    ) {<br/>        Text(<br/>            text = value.toString(),<br/>            fontSize = 20.sp,<br/>        )<br/>    }<br/>}</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/be045625ef7331300c77bac6403e0f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZzVbjQtFKixckv3g.png"/></div></div></figure><p id="5971" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">继续，是时候添加一些颜色了！<code class="du kv kw kx ky b">Box</code>将提供深色背景，文本为白色:</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="f91c" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>fun Number(value: Int) {<br/>    Box(<br/>        contentAlignment = Alignment.Center,<br/>        modifier = Modifier<br/>            .size(40.dp)<br/>            .background(MaterialTheme.colors.primary),<br/>    ) {<br/>        Text(<br/>            text = value.toString(),<br/>            fontSize = 20.sp,<br/>            color = Color.White,<br/>        )<br/>    }<br/>}</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/73c322d42fb75cc374c69f568ade9a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eAII0dU6FaZOp32G.png"/></div></div></figure><p id="b93f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当前选择的数字在其列中应该有不同的背景颜色。这需要composable中有一个新的<code class="du kv kw kx ky b">Boolean</code>参数，然后一个简单的<code class="du kv kw kx ky b">if</code>语句就可以决定使用哪种颜色。</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="d8a2" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>fun Number(value: Int, active: Boolean) {<br/>    val backgroundColor = if (active) {<br/>        MaterialTheme.colors.primary<br/>    } else {<br/>        MaterialTheme.colors.primaryVariant<br/>    }<br/><br/>    Box(<br/>        contentAlignment = Alignment.Center,<br/>        modifier = Modifier<br/>            .size(40.dp)<br/>            .background(backgroundColor),<br/>    ) {<br/>        Text(<br/>            text = value.toString(),<br/>            fontSize = 20.sp,<br/>            color = Color.White,<br/>        )<br/>    }<br/>}</span></pre><p id="811c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们也更新预览，以便它显示每一种风格的<code class="du kv kw kx ky b">Number</code>:</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="076f" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>@Preview<br/>fun NumberPreview() {<br/>    Column {<br/>        Number(value = 3, active = true)<br/>        Number(value = 7, active = false)<br/>    }<br/>}</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/174f1a3ba50d56f8ca01615fc7f6038c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BcrbfPoTsp4GTDYb.png"/></div></div></figure><h1 id="bfe0" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">一列数字</h1><p id="df15" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">单个数字就这样！现在，用一个新的<code class="du kv kw kx ky b">NumberColumn</code> composable来呈现一列。它采用一系列有效值和当前选择的值作为其参数。一个<code class="du kv kw kx ky b"><a class="ae jd" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier).clip(androidx.compose.ui.graphics.Shape)" rel="noopener ugc nofollow" target="_blank">clip</a></code>修改器给了我们整洁的圆角，创建每个<code class="du kv kw kx ky b">Number</code>就像迭代提供的<code class="du kv kw kx ky b">range</code>一样简单。</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="81f7" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>fun NumberColumn(<br/>    range: IntRange,<br/>    current: Int,<br/>) {<br/>    Column(<br/>        Modifier.clip(RoundedCornerShape(percent = 25))<br/>    ) {<br/>        range.forEach { num -&gt;<br/>            Number(num, num == current)<br/>        }<br/>    }<br/>}</span></pre><p id="a241" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们再次快速预览一下:</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="b89c" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>@Preview<br/>fun NumberColumnPreview() {<br/>    NumberColumn(range = 0..9, current = 5)<br/>}</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/9341f01937ed2b1ebab72d90c6cf466b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dThbRp9_Y5wElo0Z.png"/></div></div></figure><p id="c3c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">目前看起来不错！</p><h1 id="b31f" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建时钟</h1><p id="753a" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">是时候让它看起来像时钟一样工作了。这需要六个这样的<code class="du kv kw kx ky b">NumberColumn</code>，每个接收一个当前时间的数字作为它的参数。时间将由一个<code class="du kv kw kx ky b">Time</code>数据类提供。这些列排列在一个<code class="du kv kw kx ky b"><a class="ae jd" href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#row" rel="noopener ugc nofollow" target="_blank">Row</a></code>中，占据了整个屏幕，并在水平和垂直方向将所有内容居中。</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="8188" class="ld jt hh ky b fi le lf l lg lh">data class Time(val hours: Int, val minutes: Int, val seconds: Int)<br/><br/>@Composable<br/>fun Clock(time: Time) {<br/>    Row(<br/>        modifier = Modifier.fillMaxSize(),<br/>        horizontalArrangement = Arrangement.Center,<br/>        verticalAlignment = Alignment.CenterVertically,<br/>    ) {<br/>        NumberColumn(0..2, time.hours / 10)<br/>        NumberColumn(0..9, time.hours % 10)<br/>        NumberColumn(0..5, time.minutes / 10)<br/>        NumberColumn(0..9, time.minutes % 10)<br/>        NumberColumn(0..5, time.seconds / 10)<br/>        NumberColumn(0..9, time.seconds % 10)<br/>    }<br/>}</span></pre><p id="fbcd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们可以在预览中显示一个静态时间:</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="3bcc" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>@Preview<br/>fun ClockPreview() {<br/>    Clock(Time(14, 15, 59))<br/>}</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/fe0a99d66b958b5d7ade8a5dc2f6df01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iu0pdMLBTTilBLQv.png"/></div></div></figure><p id="6c6d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这正确地显示了给定的时间，但是我们没有对齐有效的数字。我们希望根据当前数字与列中间的距离垂直偏移每一列。如果当前数字在中间，则不需要偏移。如果它在末尾，我们想把它偏移列高的一半。</p><p id="6b76" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个问题的数学计算结果是当前数字到中点的距离乘以每个数字的高度。<code class="du kv kw kx ky b"><a class="ae jd" href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary.html#(androidx.compose.ui.Modifier).offset(androidx.compose.ui.unit.Dp,%20androidx.compose.ui.unit.Dp)" rel="noopener ugc nofollow" target="_blank">offset</a></code>修改器给了我们一个非常简单的解决方案:</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="b328" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>fun NumberColumn(<br/>    range: IntRange,<br/>    current: Int,<br/>) {<br/>    val mid = (range.last - range.first) / 2f<br/>    val offset = 40.dp * (mid - current)<br/><br/>    Column(<br/>        Modifier<br/>            .offset(y = offset)<br/>            .clip(RoundedCornerShape(percent = 25))<br/>    ) {<br/>        range.forEach { num -&gt;<br/>            Number(num, num == current)<br/>        }<br/>    }<br/>}</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/11f85ef2841b618795ff50bb2966af88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BCgBf_5oWsl_6wQG.png"/></div></div></figure><p id="516e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们有了正确的外观，是时候输入当前时间，并保持更新。</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="e3fe" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>@Preview<br/>fun ClockPreview() {<br/>    fun currentTime(): Time { // 1<br/>        val cal = Calendar.getInstance()<br/>        return Time(<br/>            hours = cal.get(Calendar.HOUR_OF_DAY),<br/>            minutes = cal.get(Calendar.MINUTE),<br/>            seconds = cal.get(Calendar.SECOND),<br/>        )<br/>    }<br/><br/>    var time by remember { mutableStateOf(currentTime()) } // 2<br/>    LaunchedEffect(0) { // 3<br/>        while (true) {<br/>            time = currentTime()<br/>            delay(1000)<br/>        }<br/>    }<br/><br/>    Clock(time)<br/>}</span></pre><p id="9c23" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们一步一步来看看这是如何做到的:</p><ol class=""><li id="a1b1" class="ln lo hh ig b ih ii il im ip lp it lq ix lr jb ls lt lu lv bi translated"><code class="du kv kw kx ky b">currentTime</code>函数获取一个<code class="du kv kw kx ky b">Calendar</code>来获得当前时间，并创建一个我们的<code class="du kv kw kx ky b">Time</code>对象，<code class="du kv kw kx ky b">Clock</code>可以使用它。</li><li id="1cf9" class="ln lo hh ig b ih lw il lx ip ly it lz ix ma jb ls lt lu lv bi translated">这一行创建了一个可变状态，Compose理解这个可变状态，并且当它的值改变时可以重新组合。这被初始化为当前时间。</li><li id="8ec5" class="ln lo hh ig b ih lw il lx ip ly it lz ix ma jb ls lt lu lv bi translated"><code class="du kv kw kx ky b"><a class="ae jd" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#launchedeffect_1" rel="noopener ugc nofollow" target="_blank">LaunchedEffect</a></code>运行传递给它的暂停lambda，它将每秒更新<code class="du kv kw kx ky b">time</code>。<code class="du kv kw kx ky b">LaunchedEffect</code>只有在它的<code class="du kv kw kx ky b">key</code>参数改变时才会重新编译:这里硬编码的虚拟0值确保它只开始这个循环一次。当包含它的<code class="du kv kw kx ky b">Composable</code>离开组合时，协程将被取消。</li></ol><p id="9d9e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这为我们提供了一个正常工作的时钟，它在不同的状态之间跳动，就像这样:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/edc31f0ee0eb281a227377b7446f347b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/1*v32EUx6eI26ZxwrLbDqj2A.gif"/></div></figure><h1 id="d592" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">动画片</h1><p id="0b91" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">我们仍然有一些工作要做，但是会很容易。为了动画显示每个<code class="du kv kw kx ky b">Number</code>的颜色变化，我们可以使用<code class="du kv kw kx ky b"><a class="ae jd" href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#animatecolorasstate" rel="noopener ugc nofollow" target="_blank">animateColorAsState</a></code>。将我们的颜色包装到这个辅助函数中会在颜色之间创建一个平滑的默认动画，而不是一个瞬间的变化。</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="544c" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>fun Number(value: Int, active: Boolean) {<br/>    val backgroundColor by animateColorAsState(<br/>        if (active) MaterialTheme.colors.primary else MaterialTheme.colors.primaryVariant,<br/>    )<br/><br/>    Box(<br/>        contentAlignment = Alignment.Center,<br/>        modifier = Modifier<br/>            .size(40.dp)<br/>            .background(backgroundColor),<br/>    ) { ... }<br/>}</span></pre><p id="013e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个故事非常类似于制作柱子运动的动画。我们简单地使用<code class="du kv kw kx ky b"><a class="ae jd" href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#animatedpasstate" rel="noopener ugc nofollow" target="_blank">animateDpAsState</a></code>函数包装它们的偏移值:</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="58a7" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>fun NumberColumn(<br/>    range: IntRange,<br/>    current: Int,<br/>) {<br/>    val mid = (range.last - range.first) / 2f<br/>    val offset by animateDpAsState(targetValue = 40.dp * (mid - current))<br/><br/>    Column(<br/>        Modifier<br/>            .offset(y = offset)<br/>            .clip(RoundedCornerShape(percent = 25))<br/>    ) { ... }<br/>}</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/dee1194410e270948857dde59b00bcf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/1*zyli5lB6G8zFvFiB4kVRTA.gif"/></div></figure><p id="395c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这看起来棒极了！通过修改几行代码添加动画。</p><h1 id="756a" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">清理和调整</h1><p id="0dd4" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">让我们稍微调整一下UI，让它看起来更好。首先，我们将为<code class="du kv kw kx ky b">Number</code>添加一个<code class="du kv kw kx ky b">modifier</code>参数，允许它的用户定制它。例如，以前我们的<code class="du kv kw kx ky b">Number</code>有一个固定的<code class="du kv kw kx ky b">40dp</code>大小——这是更好的外部控制。</p><p id="727f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将在<code class="du kv kw kx ky b">Number</code> composable的根处的<code class="du kv kw kx ky b">Box</code>上使用该参数，并在其上添加我们自己的修饰符。</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="1bd5" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>fun Number(value: Int, active: Boolean, modifier: Modifier = Modifier) {<br/>    val backgroundColor by animateColorAsState(<br/>        if (active) MaterialTheme.colors.primary else MaterialTheme.colors.primaryVariant,<br/>    )<br/><br/>    Box(<br/>        modifier = modifier.background(backgroundColor),<br/>        contentAlignment = Alignment.Center,<br/>    ) { ... }<br/>}</span></pre><p id="a161" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<code class="du kv kw kx ky b">NumberColumn</code>中，我们将创建一个<code class="du kv kw kx ky b">size</code>值，我们将在偏移计算中使用它，并将其传递给每个<code class="du kv kw kx ky b">Number</code>。这样，调整用户界面的大小就可以在这里完成，只需在代码中的一个地方。</p><p id="5c74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">NumberColumn</code>也将有自己的<code class="du kv kw kx ky b">modifier</code>参数，允许一些定制。</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="e909" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>fun NumberColumn(<br/>    range: IntRange,<br/>    current: Int,<br/>    modifier: Modifier = Modifier,<br/>) {<br/>    val size = 40.dp<br/>    val mid = (range.last - range.first) / 2f<br/>    val offset by animateDpAsState(size * (mid - current))<br/><br/>    Column(<br/>        modifier<br/>            .offset(y = offset)<br/>            .clip(RoundedCornerShape(percent = 25))<br/>    ) {<br/>        range.forEach { num -&gt;<br/>            Number(num, num == current, Modifier.size(size))<br/>        }<br/>    }<br/>}</span></pre><p id="7345" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将使用<code class="du kv kw kx ky b">modifier</code>参数在每一列上添加一些填充，我们还可以在列对之间添加一些<code class="du kv kw kx ky b"><a class="ae jd" href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#spacer" rel="noopener ugc nofollow" target="_blank">Spacer</a></code>:</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="64d0" class="ld jt hh ky b fi le lf l lg lh">@Composable<br/>fun Clock(time: Time) {<br/>    Row(<br/>        modifier = Modifier.fillMaxSize(),<br/>        horizontalArrangement = Arrangement.Center,<br/>        verticalAlignment = Alignment.CenterVertically,<br/>    ) {<br/>        val padding = Modifier.padding(horizontal = 4.dp)<br/><br/>        NumberColumn(0..2, time.hours / 10, padding)<br/>        NumberColumn(0..9, time.hours % 10, padding)<br/>        Spacer(Modifier.size(16.dp))<br/>        NumberColumn(0..5, time.minutes / 10, padding)<br/>        NumberColumn(0..9, time.minutes % 10, padding)<br/>        Spacer(Modifier.size(16.dp))<br/>        NumberColumn(0..5, time.seconds / 10, padding)<br/>        NumberColumn(0..9, time.seconds % 10, padding)<br/>    }<br/>}</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/3dbf7f17bfd7d62ed6d7f4acb82b3079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/1*xDmFiO9oVLcuAdoxH6qJkg.gif"/></div></figure><p id="fe6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为最后的调整，让我们为列重置时添加一个特殊的动画——从最高值到最低值——因为这种情况与以前的默认偏移动画相比看起来有点太跳跃了。</p><p id="b0cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<code class="du kv kw kx ky b">animateDpAsState</code>调用中，我们可以指定一个<code class="du kv kw kx ky b"><a class="ae jd" href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/AnimationSpec" rel="noopener ugc nofollow" target="_blank">AnimationSpec</a></code>，它控制值如何从一个<code class="du kv kw kx ky b">targetValue</code>转换到下一个<code class="du kv kw kx ky b"><a class="ae jd" href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/AnimationSpec" rel="noopener ugc nofollow" target="_blank">AnimationSpec</a></code>。不同类型的动画在<a class="ae jd" href="https://developer.android.com/jetpack/compose/animation#animationspec" rel="noopener ugc nofollow" target="_blank">官方文档</a>中列出。我们将使用一个<code class="du kv kw kx ky b">spring()</code>用于重置动画(有一点反弹)，一个简单的<code class="du kv kw kx ky b">tween()</code>用于剩余的偏移改变。</p><pre class="jf jg jh ji fd kz ky la lb aw lc bi"><span id="fbc4" class="ld jt hh ky b fi le lf l lg lh">val reset = current == range.first<br/>val offset by animateDpAsState(<br/>    targetValue = size * (mid - current),<br/>    animationSpec = if (reset) {<br/>        spring(<br/>            dampingRatio = Spring.DampingRatioLowBouncy,<br/>            stiffness = Spring.StiffnessLow,<br/>        )<br/>    } else {<br/>        tween(<br/>            durationMillis = 300,<br/>            easing = LinearOutSlowInEasing,<br/>        )<br/>    }<br/>)</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/1c15006241ed736449c5b320fea097e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/1*0MHkm5aSa9KmYs1Uw2-Q4A.gif"/></div></figure><h1 id="4943" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="5878" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">就是这样！这是一个用Jetpack Compose构建UI的快速演示。本例的完整代码可从GitHub 上的<a class="ae jd" href="https://github.com/zsmb13/ComposeClock/blob/main/app/src/main/java/co/zsmb/composeclock/MainActivity.kt" rel="noopener ugc nofollow" target="_blank">获得。</a></p><p id="e35e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Compose是Android UI开发的明确未来路径，用它来构建UI真的很令人兴奋。用非常基本的框架知识组合这个例子的速度让我对Compose的未来充满希望。</p></div></div>    
</body>
</html>