<html>
<head>
<title>JUnit 5 parameterized feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JUnit 5参数化特性</h1>
<blockquote>原文：<a href="https://medium.com/globant/junit-5-parameterized-feature-c8cbe6a70aa0?source=collection_archive---------0-----------------------#2021-08-11">https://medium.com/globant/junit-5-parameterized-feature-c8cbe6a70aa0?source=collection_archive---------0-----------------------#2021-08-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/d7058e6079bfc8d5af87d9ad9ecd2332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YOuKdoRvV7TO1dnxUjodpQ.jpeg"/></div></div></figure><div class=""/><h1 id="7e44" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">简介</strong></h1><p id="c031" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">JUnit5是下一代测试框架，是开发人员编写单元测试类的一个非常常用的工具。本文将教你如何使用一个名为参数化的新特性。让我们从一个概述开始，然后，我们将讨论如何配置和如何使用这个特性。</p><h2 id="d27c" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated"><strong class="ak">6月5日概述</strong></h2><p id="b3ce" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">JUnit5是该框架的新版本，由以下组件组成:</p><ul class=""><li id="e7b2" class="kz la hs jp b jq lb ju lc jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ht"> JUnit平台</strong>，JVM上的测试框架。</li><li id="11b4" class="kz la hs jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">JUnit Jupiter，编写测试类的新扩展。</li><li id="9e10" class="kz la hs jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated"><strong class="jp ht"> JUnit Vintage，</strong>运行Junit 3和Junit 4的测试引擎。</li></ul><h2 id="4bbb" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated"><strong class="ak">配置参数化</strong></h2><p id="c871" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在开始使用Junit参数化特性之前，我们需要在pom.xml文件中添加依赖关系:</p><p id="6d79" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">对于我们使用maven的项目:</p><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="9517" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">对于我们使用Gradle的项目:</p><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><blockquote class="ly lz ma"><p id="1e2a" class="jn jo mb jp b jq lb js jt ju lc jw jx mc lp ka kb md lq ke kf me lr ki kj kk ha bi translated">注:版本<strong class="jp ht"> 5.7.0 </strong>是本文发布时可用的最新版本。</p></blockquote><h2 id="c927" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated"><strong class="ak">使用参数化特征</strong></h2><p id="bb73" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">让我们使用EmailValidator类来展示JUnit参数化的不同用例。这个类非常简单，但应该足以展示它的功能。</p><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><ul class=""><li id="8cc6" class="kz la hs jp b jq lb ju lc jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ht"> <em class="mb">测试没有参数化的特性，</em> </strong> <em class="mb"> w </em> e可以编写一个简单的测试类实现下面的测试用例:</li></ul><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="7602" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">如果您看到上面的测试类，我们需要创建两个不同的方法来测试这两种情况，检查有效和无效的电子邮件地址。但是如果我们使用参数化特性，上面的代码可以改为:</p><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="6374" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">我们可以看到两种方法，一种允许我们检查多个有效的电子邮件地址，另一种用于检查多个无效的电子邮件地址，我们需要的所有输入值对于这两种方法来说都更清楚，但是我们仍然有两种方法，所以，让我们看看使用参数化功能可以使用的另一个选项:</p><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="bba5" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">在这种情况下，我们使用一种方法作为测试(输入值)有效和无效电子邮件地址所需的所有数据的来源。通过这个选项，我们减少了测试类中的代码。然而，我们还有另一个选择，让我们看看下面的代码:</p><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="1935" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">我们可以看到注解<strong class="jp ht"> <em class="mb"> @CsvFileSource。</em> </strong>这允许我们用测试中需要的所有输入数据定义一个CSV文件，让我们看看这个文件:</p><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="a359" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">该文件对每个输入数据都进行了预期的验证，在本例中，包括有效和无效的电子邮件地址。我们可以看到测试我们的类的很好的选项，但是我们仍然需要执行额外的测试，即可能有空的和null的输入值。让我们看看如何测试这些情况。</p><ul class=""><li id="ce54" class="kz la hs jp b jq lb ju lc jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ht"> <em class="mb">测试空输入值</em>，</strong>在这种情况下，要使用的正确特性是<strong class="jp ht"> <em class="mb"> @NullSource，</em> </strong>这个注释允许我们在测试类中捕捉空值，让我们看看实现这个注释的单元测试方法:</li></ul><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="9ec0" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">简单吧？有了这个特性，我们的测试更加清晰和简洁。</p><ul class=""><li id="c929" class="kz la hs jp b jq lb ju lc jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ht"> <em class="mb">测试空输入值</em>，</strong>在这种情况下，要使用的正确特性是<strong class="jp ht"> <em class="mb"> @EmptySource，</em> </strong>这个注释允许我们在测试类中捕捉空值，让我们看看实现这个注释的uni test方法。</li></ul><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="de1f" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">太棒了。然而，我们现在有两种方法来测试这两种情况，空值和空值，但是框架为我们提供了另一个有用的特性，叫做<strong class="jp ht"><em class="mb">@ NullAndEmptySource</em></strong>让我们看看实现这个注释的单元测试方法:</p><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="809b" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">正如我们所看到的，这个注释进一步减少了我们的代码。但是，我们可以组合特性来创建比上面更小的测试用例，并执行更多的测试，让我们来看看:</p><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="58ec" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">在本例中，我们将测试null、空值、制表符和换行符，所有可能的输入值都需要在EmailValidator类中进行测试。</p><p id="54f5" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">我们需要做的另一件事是当我们的EmailValidator类收到不正确的输入值时抛出异常，让我们看看测试这种情况的选项。</p><ul class=""><li id="a518" class="kz la hs jp b jq lb ju lc jy ld kc le kg lf kk lg lh li lj bi translated"><strong class="jp ht"> <em class="mb">使用Try-catch子句，</em> </strong>使用这个子句是一个很好的方法，因为我们达到了目标，这就是捕捉异常让我们看看代码:</li></ul><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="0e21" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">验证是正确的，但是让我们看看通过使用JUnit 5我们可以获得的特性。</p><figure class="ls lt lu lv fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="05ac" class="pw-post-body-paragraph jn jo hs jp b jq lb js jt ju lc jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ha bi translated">有了这个特性，测试就更干净、更简单了，对吗？</p><h2 id="40a1" class="kl iq hs bd ir km kn ko iv kp kq kr iz jy ks kt jd kc ku kv jh kg kw kx jl ky bi translated"><strong class="ak">结论</strong></h2><p id="909c" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们刚刚经历了一些使用Junit 5的新特性，它为我们的开发人员提供了一些非常好的选项来创建我们的单元测试，并避免增加类大小的样板代码，希望这个概述能让您快速了解这些特性能做什么，如果您发现它们有用，请确保在您的下一个项目中使用它们。</p></div></div>    
</body>
</html>