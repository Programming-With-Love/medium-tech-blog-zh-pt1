<html>
<head>
<title>Routing in ASP.NET Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP.NET核心中的路由</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/routing-in-asp-net-core-c433bff3f1a4?source=collection_archive---------0-----------------------#2019-01-28">https://medium.com/quick-code/routing-in-asp-net-core-c433bff3f1a4?source=collection_archive---------0-----------------------#2019-01-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c07d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ASP.NET核心中的路由是将传入请求映射到驻留在控制器和方法中的应用程序逻辑的过程。</p><p id="ac5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ASP。NET Core基于您在应用程序中配置的<strong class="ig hi">路由</strong>来映射传入的请求，并且对于每个路由，您可以设置特定的配置，比如默认值、消息处理程序、约束等等。</p><p id="832d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在ASP.NET核心应用程序中，有几种控制路由的方法，但是在本文中，我们将集中讨论两种最常见的方法:</p><ul class=""><li id="b9e2" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated"><strong class="ig hi">常规路由</strong>:路由是根据路由模板中定义的约定确定的，在运行时，路由模板会将请求映射到控制器和动作(方法)。</li><li id="75f6" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><strong class="ig hi">基于属性的路线</strong>:路线是根据您在控制器和方法上设置的属性确定的。这些将定义控制器动作的映射。</li></ul><h1 id="5570" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">传统路由</h1><p id="17d7" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">在传统的路由风格中，在应用程序启动期间，您定义路由模板，每次收到传入请求时都会查询这些模板，以便进行URL匹配。这个过程最终会映射到一个控制器和其中的一个方法。如果没有为传入请求找到路由，将向调用者返回HTTP错误404(未找到)。</p><p id="301c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当你在你的启动类中调用了<code class="du kt ku kv kw b">ConfigureServices</code>方法内的<code class="du kt ku kv kw b">AddMvc</code>和<code class="du kt ku kv kw b">Configure</code>方法内的<code class="du kt ku kv kw b">UseMvcWithDefaultRoute</code>方法，同时，在幕后，MVC框架添加了一个路由处理程序，并将路由设置为默认模板，看起来是这样的:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="bb21" class="lf jr hh kw b fi lg lh l li lj">"{controller=Home}/{action=Index}/{id?}"</span></pre><p id="92ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该模板定义了对于收到的每个请求，请求管道将尝试断开其URL，以便第一部分将被映射到控制器名称，第二部分(<code class="du kt ku kv kw b">/</code>之后的部分)将被映射到控制器内部的方法，第三部分(如果存在)将被用作路由参数(用花括号<code class="du kt ku kv kw b">{}</code>括起来)以映射到使用<code class="du kt ku kv kw b">id</code>方法的参数。</p><p id="baf8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当ASP.NET核心搜索控制器时，它从模板中取出控制器部分，并将其与后缀控制器连接起来。这意味着，您可以只编写<code class="du kt ku kv kw b">/Example/SomeAction</code>，而不是使用<code class="du kt ku kv kw b">/ExampleController/SomeAction</code>形式的URL。</p><h2 id="97b7" class="lf jr hh bd js lk ll lm jw ln lo lp ka ip lq lr ke it ls lt ki ix lu lv km lw bi translated">定义新的路线模板</h2><p id="34c6" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">要在应用程序中定义路由模板，最简单的方法是使用<code class="du kt ku kv kw b">UseMvc</code>方法，而不是在启动类的<code class="du kt ku kv kw b">Configure</code>方法中使用<code class="du kt ku kv kw b">UseMvcWithDefaultRoute</code>。此方法允许您在应用程序中定义想要的路线。例如，在<code class="du kt ku kv kw b">GiveNTake</code>应用程序中，如果我们希望我们的应用程序不仅支持默认路由，还公开带有<code class="du kt ku kv kw b">api</code>前缀的RESTful API(即以<code class="du kt ku kv kw b">/api/[controller]/[action]</code>形式的URL)，那么这就是我们需要如何更改我们的<code class="du kt ku kv kw b">Configure</code>方法:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="c577" class="lf jr hh kw b fi lg lh l li lj">public void Configure(IApplicationBuilder app, IHostingEnvironment env)<br/>{<br/>    ... </span><span id="7547" class="lf jr hh kw b fi lx lh l li lj">   app.UseMvc(routes =&gt;<br/>   {<br/>       routes<br/>           .MapRoute(name: "default", template: "{controller=Home}/{action=Index}/{id?}")<br/>           .MapRoute(name: "api", template: "api/{controller}/{action}/{id?}");<br/>   });</span><span id="ed86" class="lf jr hh kw b fi lx lh l li lj">}</span></pre><p id="0e50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kt ku kv kw b">MapRoute</code>方法是您可以为您的应用程序定义路线的方法，您可以多次调用它来设置多个路线模板。</p><p id="3d1a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了测试您刚刚配置的路由，在<code class="du kt ku kv kw b">Controllers</code>文件夹中添加一个新的空类，并将其命名为<code class="du kt ku kv kw b">MessagesController</code>。将以下代码粘贴到您创建的文件中。它应该如下所示:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="cc9a" class="lf jr hh kw b fi lg lh l li lj">using Microsoft.AspNetCore.Mvc;</span><span id="e75d" class="lf jr hh kw b fi lx lh l li lj">namespace GiveNTake.Controllers<br/>{<br/>    public class MessagesController : Controller<br/>    {<br/>        public string[] My()<br/>        {<br/>            return new[]<br/>            {<br/>                "Is the Microwave working?",<br/>                "Where can i pick the washing machine from?",<br/>            };<br/>        }</span><span id="b4ab" class="lf jr hh kw b fi lx lh l li lj">        public string Details(int id)<br/>        {<br/>            return $"{id} - Is the Microwave working?";<br/>        }<br/>    }<br/>}</span></pre><p id="a0b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行项目并在浏览器中导航到<code class="du kt ku kv kw b"><a class="ae ly" href="http://localhost:{port}/api/messages/my." rel="noopener ugc nofollow" target="_blank">http://localhost:{port}/api/messages/my</a></code> <a class="ae ly" href="http://localhost:{port}/api/messages/my." rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8f1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您的浏览器应该会显示如下页面:</p><figure class="kx ky kz la fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es lz"><img src="../Images/041ea188d6e464428453617ee4eebee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4IHDlDqv0v5y3ukxFjUBg.png"/></div></div></figure><p id="5857" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kt ku kv kw b">MapRoute</code>方法允许您以更高级的方式控制路线。这里是完整的<code class="du kt ku kv kw b">MapRoute</code>签名，但是它有重载，使得一些参数是可选的:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="8951" class="lf jr hh kw b fi lg lh l li lj">IRouteBuilder MapRoute(this IRouteBuilder routeBuilder, <br/>    string name, <br/>    string template, <br/>    object defaults, <br/>    object constraints, <br/>    object dataTokens)</span></pre><p id="1994" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些参数操作如下:</p><ul class=""><li id="b06f" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated"><code class="du kt ku kv kw b">name</code>:每条路线都应该有一个唯一的名称，以便识别。该名称不影响路由过程，但在出现路由故障时非常有用，ASP.NET核心会通知您路由问题。</li><li id="8cf4" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><code class="du kt ku kv kw b">template</code>:这是路线的核心。这定义了应该映射到控制器、动作和参数的URL结构和令牌。</li><li id="ca6d" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><code class="du kt ku kv kw b">defaults</code>:这定义了不同令牌的默认值，以防它们在请求URL中丢失。</li><li id="cd9d" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><code class="du kt ku kv kw b">constraints</code>:此参数包含路由中令牌的单个约束规则，这些规则确定该值对于该路由中的令牌是否可接受。</li><li id="0b4c" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><code class="du kt ku kv kw b">data token</code>:这些是与路线相关的附加值。它们不会影响匹配过程，但是当路由确定后，这些值将被添加到控制器的<code class="du kt ku kv kw b">RouteData.DataTokens</code>集合属性中，并可以在它的逻辑中使用。</li></ul><p id="98ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是我们的API路由定义的一个改进版本，它将控制器的默认值设置为<code class="du kt ku kv kw b">Messages</code>，将动作设置为<code class="du kt ku kv kw b">My</code>，并且还对<code class="du kt ku kv kw b">id</code>参数设置了一个约束，只允许整数:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="5b13" class="lf jr hh kw b fi lg lh l li lj">MapRoute(<br/>   name: "api", <br/>   template: "api/{controller}/{action}/{id?}",<br/>   defaults: new { Controller = "Messages", action="My" },<br/>   constraints: new { id = new IntRouteConstraint() });</span></pre><p id="1948" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kt ku kv kw b">defaults</code>和<code class="du kt ku kv kw b">constraints</code>也可以在模板本身内部设置，因此我们之前创建的API定义与此相同:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="40e0" class="lf jr hh kw b fi lg lh l li lj">MapRoute(<br/>   name: "api",<br/>   template: "api/{controller=Messages}/{action=My}/{id:int?}");</span></pre><p id="3bc0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">传统路由是一种简单的机制，通常适用于小规模的API。但是随着API的增长，您很快就会发现需要一种更细粒度的方法来定义路由，如果是这样的话，最好使用基于属性的路由。此外，开发网站或应用程序可以通过学习<a class="ae ly" href="https://coursesity.com/free-tutorials-learn/asp-net" rel="noopener ugc nofollow" target="_blank">ASP.NET教程</a>轻松完成。</p><h1 id="f238" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">基于属性的路由</h1><p id="ad8c" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">通过使用修饰控制器和方法的属性，基于属性的路由允许您控制每个控制器和动作参与的确切路线。我建议您对大多数API使用这种方法，因为这将使您的代码更加明确，并减少在添加更多控制器和动作时可能引入的路由错误。</p><p id="1939" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kt ku kv kw b">ProductsController</code>看起来是这样的:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="094a" class="lf jr hh kw b fi lg lh l li lj">[Route("api/Products")]<br/>[ApiController]<br/>public class ProductsController : Controller<br/>{<br/>    ...   <br/>}</span></pre><p id="7a9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">修饰<code class="du kt ku kv kw b">ProductController</code>的<code class="du kt ku kv kw b">RouteAttribute</code>属性包含映射到这个控制器的URL模板。在这种情况下，带有前缀为<code class="du kt ku kv kw b">/api/products/</code>的URL的每个请求都将被路由到这个控制器。您可以在控制器和方法上使用<code class="du kt ku kv kw b">RouteAttribute</code>属性，但是对于方法，建议使用<code class="du kt ku kv kw b">Http[Verb]Attribute</code>属性，其中<code class="du kt ku kv kw b">[Verb]</code>是标准HTTP动词之一(<code class="du kt ku kv kw b">Get</code>、<code class="du kt ku kv kw b">Post</code>、<code class="du kt ku kv kw b">Put</code>、<code class="du kt ku kv kw b">Delete</code>等等)。</p><p id="4b53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以多次分配<code class="du kt ku kv kw b">Http[Verb]Attribute</code>和<code class="du kt ku kv kw b">RouteAttribute</code>属性来定义多个路由，并且是分层的，这意味着它们支持路由继承。这意味着如果您在控制器上配置了一个路由，那么您在方法上定义的路由将会扩展它。</p><p id="789e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，下面是如何配置将<code class="du kt ku kv kw b">ProductsController.GetProducts</code>方法映射到URL <code class="du kt ku kv kw b">/api/products/all</code>和URL <code class="du kt ku kv kw b">/api/products</code>的<code class="du kt ku kv kw b">HttpGet</code>请求:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="4130" class="lf jr hh kw b fi lg lh l li lj">[HttpGet]<br/>[HttpGet("all")]<br/>public string[] GetProducts()<br/>{<br/>    ...    <br/>}</span></pre><blockquote class="mh mi mj"><p id="1037" class="ie if mk ig b ih ii ij ik il im in io ml iq ir is mm iu iv iw mn iy iz ja jb ha bi translated"><strong class="ig hi">注</strong></p><p id="21b1" class="ie if mk ig b ih ii ij ik il im in io ml iq ir is mm iu iv iw mn iy iz ja jb ha bi translated">如果您在一个方法上设置的<code class="du kt ku kv kw b">Http[Verb]Attribute</code>包含一个以<code class="du kt ku kv kw b">/</code>开头的字符串，那么它将不会与控制器中定义的路由相结合，而是定义一个自己的路由。</p></blockquote><h2 id="63c0" class="lf jr hh bd js lk ll lm jw ln lo lp ka ip lq lr ke it ls lt ki ix lu lv km lw bi translated">参数化路线模板</h2><p id="55fc" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">基于属性的路由支持一些放在方括号(<code class="du kt ku kv kw b">[</code>和<code class="du kt ku kv kw b">]</code>)中的预定义标记，它们将在运行时被替换为相应的值:</p><ul class=""><li id="0e1e" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated"><code class="du kt ku kv kw b">[controller]</code>:这将被替换为控制器名称。</li><li id="61a6" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><code class="du kt ku kv kw b">[action]</code>:这将被替换为方法名。</li><li id="65f6" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><code class="du kt ku kv kw b">[area]</code>:如果您的应用程序支持区域，这将被替换为控制器所在的区域。区域功能不在本书讨论范围内，但是更多信息可以参考<a class="ae ly" href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/areas" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/aspnet/core/MVC/controllers/areas</a>。</li></ul><p id="53a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，我们可以这样写，而不是在<code class="du kt ku kv kw b">RouteAttribute</code>中显式地写<code class="du kt ku kv kw b">ProductsController</code>:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="3055" class="lf jr hh kw b fi lg lh l li lj">[Route("api/<strong class="kw hi">[controller]</strong>")]<br/>[ApiController]<br/>public class ProductsController : Controller<br/>{<br/>    ...<br/>}</span></pre><p id="487f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">花括号(<code class="du kt ku kv kw b">{}</code>)中的标记定义了路由参数，如果路由匹配，这些参数将被绑定到方法参数。</p><p id="6a11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，假设您希望公开一个API来搜索产品，基于关键字，以对格式为<code class="du kt ku kv kw b">/api/products/search/keyword</code>的URL的<code class="du kt ku kv kw b">GET</code>请求的形式。你可以这样写:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="0bc8" class="lf jr hh kw b fi lg lh l li lj">[HttpGet("search/{keyword}")]<br/>public string[] SearchProducts(string keyword)<br/>{<br/>    ...<br/>}</span></pre><p id="deff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就像传统的布线一样，您可以在布线参数上定义默认值和约束。</p><h1 id="b322" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">默认值</h1><p id="0f87" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">默认值是通过在路径参数旁放置等号来定义的。请注意，将默认值放在方法参数上(不在根模板中)是行不通的，因为路由管道无法通过查看可选参数来找到匹配。</p><p id="a1b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，<code class="du kt ku kv kw b">GiveNTake</code>应用程序允许用户通过指定类别和子类别来搜索产品；但是，子类别是可选的，如果省略，默认的<code class="du kt ku kv kw b">subcategory</code>将是<code class="du kt ku kv kw b">all</code>。以下代码片段向您展示了如何定义这些规则:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="276a" class="lf jr hh kw b fi lg lh l li lj">[HttpGet("searchcategory/{category}/{subcategory=all}/")]<br/>public string[] SearchByProducts(string category,string subcategory)<br/>{<br/>    return new[]<br/>    {<br/>        $"Category: {category}, Subcategory: {subcategory}"<br/>    };<br/>}</span></pre><p id="7985" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行应用程序并导航至<code class="du kt ku kv kw b">http://localhost:[port]/api/products/searchcategory/furniture/kitchen</code>，然后导航至<code class="du kt ku kv kw b"><a class="ae ly" href="http://localhost:[port]/api/products/searchcategory/furniture." rel="noopener ugc nofollow" target="_blank">http://localhost:[port]/api/products/searchcategory/furniture</a></code> <a class="ae ly" href="http://localhost:[port]/api/products/searchcategory/furniture." rel="noopener ugc nofollow" target="_blank">。</a></p><p id="afad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于第一个URL，您应该会看到类似如下的结果:</p><figure class="kx ky kz la fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mo"><img src="../Images/d8e8fbec43dfff85f9de229b31560407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXv_FclOtnVjOATvPHqw5g.png"/></div></div></figure><p id="0631" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个URL应该产生如下输出:</p><figure class="kx ky kz la fd ma er es paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="er es mo"><img src="../Images/ee4270c47179b78de4cfdd8d1494ca7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCr-6-_AsA2L0CoF3rXxSg.png"/></div></div></figure><h1 id="13b6" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">限制</h1><p id="7dde" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">路由属性中的内联约束是通过在路由参数名称后放置一个带有约束名称<code class="du kt ku kv kw b">:constraint-name</code>的冒号来使用的，其中constraint-name是通过创建一个实现<code class="du kt ku kv kw b">IRouteConstraint</code>接口的类来定义的约束，或者只是通过使用aspnet文档中指定的内置约束之一来定义的约束，该文档位于<a class="ae ly" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?highlight=routing#route-constraint-reference" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/aspnet/core/fundamentals/routing？highlight = routing # route-constraint-reference</a></p><p id="4435" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的例子展示了我们如何将一个<code class="du kt ku kv kw b">search</code>方法添加到我们的<code class="du kt ku kv kw b">ProductsController</code>中，该方法根据产品在线发布的日期进行搜索。此操作的URL必须将日期参数限制为仅使用<code class="du kt ku kv kw b">datetime</code>格式；因此，我们将像这样使用<code class="du kt ku kv kw b">datetime</code>约束:</p><pre class="kx ky kz la fd lb kw lc ld aw le bi"><span id="6842" class="lf jr hh kw b fi lg lh l li lj">[HttpGet("search/<strong class="kw hi">{date:datetime}</strong>/{keyword}/")]<br/>public string[] Search(string date, string keyword)<br/>{<br/>    return new[]<br/>    {<br/>        $"Date: {date}, keyword: {keyword}"<br/>    };<br/>}</span></pre><p id="9d34" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ASP.NET核心中的路由基础设施非常复杂，还有很多本书范围之外的特性没有涉及。有关aspnet核心中路由功能的更多详细信息，请参考位于<a class="ae ly" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/aspnet/Core/fundamentals/routing</a>的文档。</p><p id="9c46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="mk">如果你喜欢阅读这篇文章，你一定要看看</em> <a class="ae ly" href="https://www.amazon.com/Hands-Full-Stack-Development-ASP-NET-Core/dp/178862288X" rel="noopener ugc nofollow" target="_blank"> <em class="mk">用ASP.NET核心</em> </a> <em class="mk">动手做全栈Web开发。一个包含示例的分步指南，</em> <a class="ae ly" href="https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core" rel="noopener ugc nofollow" target="_blank"> <em class="mk">使用ASP.NET核心</em> </a> <em class="mk">进行实际操作的全栈Web开发，带您构建一个包含后端和前端产品的完整系统，包括ASP.NET核心、实体框架、TypeScript、Angular、React、Vue和Azure。</em></p></div></div>    
</body>
</html>