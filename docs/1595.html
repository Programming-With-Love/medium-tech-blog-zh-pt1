<html>
<head>
<title>Deploying Multiple Environments with Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform部署多个环境</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/deploying-multiple-environments-with-terraform-kubernetes-7b7f389e622?source=collection_archive---------0-----------------------#2018-08-27">https://medium.com/capital-one-tech/deploying-multiple-environments-with-terraform-kubernetes-7b7f389e622?source=collection_archive---------0-----------------------#2018-08-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/259d4eb9694126bb6eb7d58127f9d780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IP3e_QYPxJkbdPreA4mvA.jpeg"/></div></div></figure><p id="60e6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Terraform是提供不可变基础设施的一个很好的工具。它允许您以声明的方式以编程方式创建基础结构，同时跟踪基础结构的状态。对于更复杂的部署和更可重用的代码，必须让Terraform为它们服务。幸运的是，Terraform提供了实现这一目标所需的大部分工具。在这篇文章中，我将展示如何让Terraform为我工作，同时成功地将基础设施部署到多个环境中。</p><h1 id="0202" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">背景</strong></h1><p id="6fbe" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">当我开始这个Kubernetes基础设施项目时，我以前从未使用过Terraform，尽管我对它很熟悉。<a class="ae kq" href="https://wwwa.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>是由<a class="ae kq" href="https://www.hashicorp.com/" rel="noopener ugc nofollow" target="_blank"> HashiCorp </a>开发的工具，提供开源和企业版本。它是用Go编写的，有一个专有的DSL用于用户交互。</p><p id="f81e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">过去，我使用过许多其他工具，如Puppet、Ansible、Foreman和CloudFormation，以及其他围绕各种SDK和库的“自己开发”的工具。通过这个项目，我想学习一些新的东西；输入Terraform。</p><p id="9d84" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该项目有一些简单的要求，特别是我们需要能够将基础架构部署到以下环境中:</p><ul class=""><li id="1f77" class="kr ks hh ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated">发展</li><li id="1bc4" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">质量保证</li><li id="3b2e" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">脚手架</li><li id="c601" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">生产</li></ul><p id="8cbb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它还需要能够从开发人员的机器上运行，部署个人基础设施，最后，用户体验需要简单。这意味着命令行参数需要保持最小，并且不需要复杂的配置文件。</p><h1 id="25e7" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">构建工具</strong></h1><p id="ba32" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">如上所述，我想为这个项目学习一个新的工具，一些我熟悉但从未亲自使用过的东西。我对自己的另一个挑战是尽可能地尝试和实施<a class="ae kq" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> DRY原则。</a></p><p id="e002" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">DRY原则旨在减少模式和代码中的重复。坚持这一点意味着我不会为我想要部署的每个环境重复Terraform代码。我会编写最少的代码来实现最大的可重用性。</p><p id="7a6c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在对Terraform做了大量阅读后，我决定使用一些特性来满足需求。我的Terraform项目将围绕使用<strong class="ir hi">远程状态</strong>、<strong class="ir hi">工作区</strong>、<strong class="ir hi">模块</strong>、<strong class="ir hi">局部变量</strong>和<strong class="ir hi">变量</strong>的想法来构建。</p><h2 id="48e4" class="lf jo hh bd jp lg lh li jt lj lk ll jx ja lm ln kb je lo lp kf ji lq lr kj ls bi translated"><strong class="ak">工作区</strong></h2><p id="2a64" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">Terraform工作空间是Terraform环境的继承者。工作区允许您分离状态和基础结构，而无需更改代码中的任何内容。这是构建我的工具的一个很好的开始，因为我希望将完全相同的代码库部署到多个环境中，而不会出现重叠。我决定所有的工作空间名称都将受到该工具的支持，并且每个工作空间都将被视为一个环境。</p><p id="cd9c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于开发人员的个人基础设施，我不会根据我想出的一些任意的约定来限制命名。我决定支持开发人员想要使用的任何工作区名称，并将其视为开发环境。</p><h2 id="1161" class="lf jo hh bd jp lg lh li jt lj lk ll jx ja lm ln kb je lo lp kf ji lq lr kj ls bi translated"><strong class="ak">远程状态</strong></h2><p id="3556" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">在远程文件中保存地形状态是必须的。我不应该去探究原因。相信我，去做吧。我决定将我的项目状态存储在S3，因为它设置起来既快又容易。使用远程状态文件时，有两个要点需要记住。</p><ol class=""><li id="9d07" class="kr ks hh ir b is it iw ix ja kt je ku ji kv jm lt kx ky kz bi translated">这是Terraform用来计算基础设施变化的文件。如果这些信息没有保存在一个集中的位置，那么您将无法负责任地管理您的基础架构。</li><li id="9a3b" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm lt kx ky kz bi translated">我的每个环境都需要单独的状态文件来避免冲突。通过使用工作区，我能够将工作区名称添加到状态文件的路径前面，确保每个工作区(环境)都有自己的状态。反过来，这意味着每个环境都有自己独立的基础设施；其中也包括开发人员的个人集群。</li></ol><h2 id="1d89" class="lf jo hh bd jp lg lh li jt lj lk ll jx ja lm ln kb je lo lp kf ji lq lr kj ls bi translated"><strong class="ak">当地人</strong></h2><p id="ad3b" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">Terraform有一个称为本地值(locals)的特性。局部变量有一个分配给表达式的名称；例如，映射查找或三元。这些值可以被认为是函数的局部变量。我确信它们有很好的用例，但是我主要把它们作为其他模块的输入。</p><h2 id="5231" class="lf jo hh bd jp lg lh li jt lj lk ll jx ja lm ln kb je lo lp kf ji lq lr kj ls bi translated"><strong class="ak">变量</strong></h2><p id="261b" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">就像任何工具或语言一样，Terraform支持变量。所有典型的数据类型都被支持，这使得它们非常有用和灵活。我在Terraform中发现的一个好东西是输入变量的概念。输入变量本质上是Terraform模块的参数。这些输入变量可用于填充资源的配置输入，甚至确定其他变量的值。</p><p id="b3b7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我的项目中，我决定在Terraform中使用独特的变量。我将制作用于确定环境和基础设施规模的变量，以及容纳所有资源配置变量的专用模块。</p><h2 id="574a" class="lf jo hh bd jp lg lh li jt lj lk ll jx ja lm ln kb je lo lp kf ji lq lr kj ls bi translated"><strong class="ak">模块</strong></h2><p id="0f7d" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">如果Terraform代码不能重用和模块化，就不值得使用。因此，像现在的其他配置工具一样，Terraform支持模块。模块只不过是通用的、高度参数化的代码，可以很容易地在多个用例中重用。对于我的用例，我制作了一个如上所述的变量模块。</p><h2 id="9d66" class="lf jo hh bd jp lg lh li jt lj lk ll jx ja lm ln kb je lo lp kf ji lq lr kj ls bi translated"><strong class="ak">综合考虑</strong></h2><p id="1d62" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">我做的第一件事是为项目创建一组变量。这些变量存在于<code class="du lu lv lw lx b">variables.tf</code>文件中。我创建了一个变量，将Terraform <code class="du lu lv lw lx b">workspace</code>名称映射到环境名称。这就创造了一套“已知环境”，允许支持开发、qa、试运行和生产，但不允许支持个人开发基础设施。</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="cea3" class="lf jo hh lx b fi mg mh l mi mj">variable “workspace_to_environment_map” {<br/>  type = “map”</span><span id="4b96" class="lf jo hh lx b fi mk mh l mi mj">  default = {<br/>    dev     = “dev”<br/>    qa      = “qa”<br/>    staging = “staging”<br/>    prod    = “prod”<br/>  }<br/>}</span></pre><p id="ddeb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在已经知道了环境，下一个变量是将环境映射到基础设施的大小。为此，我选择了旧的“t恤尺寸”。每种大小都将映射到基础架构的不同大小的实例。例如:<code class="du lu lv lw lx b">small</code>可能是<code class="du lu lv lw lx b">t2.small</code>，<code class="du lu lv lw lx b">medium</code>可能是<code class="du lu lv lw lx b">t2.medium</code>。</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="e4c1" class="lf jo hh lx b fi mg mh l mi mj">variable “environment_to_size_map” {<br/>  type = “map”</span><span id="3fc1" class="lf jo hh lx b fi mk mh l mi mj">  default = {<br/>    dev     = “small”<br/>    qa      = “medium”<br/>    staging = “large”<br/>    prod    = “xlarge”<br/>  }<br/>}</span></pre><p id="bcdb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然“已知环境”得到了支持，我就需要支持开发人员的个人基础设施。为此，我创建了一个变量映射Terraform工作空间的大小。没有周围的环境，这没有多大意义，但相信我，它来了。</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="b0cc" class="lf jo hh lx b fi mg mh l mi mj">variable “workspace_to_size_map” {<br/>  type = “map”</span><span id="caab" class="lf jo hh lx b fi mk mh l mi mj">  default = {<br/>    dev = “small"<br/>  }<br/>}</span></pre><p id="9bdf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然“已知环境”得到了支持，我就需要支持开发人员的个人基础设施。为此，我创建了一个变量映射Terraform工作空间的大小。没有周围的环境，这没有多大意义，但相信我，它来了。</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="96c7" class="lf jo hh lx b fi mg mh l mi mj">variable “workspace_to_size_map” {<br/>  type = “map”</span><span id="421f" class="lf jo hh lx b fi mk mh l mi mj">  default = {<br/>    dev = “small”<br/>  }<br/>}</span></pre><p id="4f4b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我已经有了基本变量，我需要找到在代码库中使用它们的方法…进入<code class="du lu lv lw lx b">locals</code>。</p><p id="72c3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在<code class="du lu lv lw lx b"> main.tf</code>为环境和<code class="du lu lv lw lx b">size</code>创造了两个当地人。每一个都有自己的表达式来计算正确的值。</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="8e18" class="lf jo hh lx b fi mg mh l mi mj">locals {<br/>  environment = “${lookup(var.workspace_to_environment_map, terraform.workspace, “dev”)}”<br/>  size = “${local.environment == “dev” ? lookup(var.workspace_to_size_map, terraform.workspace, “small”) : var.environment_to_size_map[local.environment]}”<br/>}</span></pre><p id="0675" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">在继续之前，让我们把它分解一下……</strong></p><p id="a980" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lu lv lw lx b">environment</code>局部值是使用Terraform <code class="du lu lv lw lx b">workspace</code>名称对<code class="du lu lv lw lx b">workspace_to_environment_map</code>的查找。如果地形<code class="du lu lv lw lx b">workspace</code>名称在地图中不存在，它将默认为环境开发。</p><p id="59d3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本地值<code class="du lu lv lw lx b">size</code>是一个带有查找的三元值，并使用前述的<code class="du lu lv lw lx b">environment</code>本地值。如果<code class="du lu lv lw lx b">environmen</code> t的本地值是dev，那么它将使用Terraform工作区名称查找<code class="du lu lv lw lx b">workspace_to_size_map</code>。如果它不在地图中，它将默认为小尺寸。如果<code class="du lu lv lw lx b">environment</code>本地值不是dev，那么它将得到<code class="du lu lv lw lx b">environment_to_size_map</code>的值为<code class="du lu lv lw lx b">environment</code>本地值的值。</p><p id="cffc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就像这样，我们现在支持所有“已知环境”以及开发人员想给他们的个人基础设施命名的任何工作区名称。信不信由你，这是最难的部分。艰苦的工作已经完成，现在剩下的唯一事情就是构建变量模块。</p><p id="1d7b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为我的项目的所有变量都是配置值，所以我选择将它们与项目代码完全分开。这允许在不接触实际代码库的情况下更新配置。</p><p id="e8e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du lu lv lw lx b">main.tf</code>中，我使用GitHub URL作为源代码声明了一个变量模块。该模块配置了两个输入，<code class="du lu lv lw lx b">environment</code>和<code class="du lu lv lw lx b">size</code>，它们是上述<code class="du lu lv lw lx b">locals</code>的值。</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="de8b" class="lf jo hh lx b fi mg mh l mi mj">module “variables” {<br/>  source = “git::https://github.com/project/config//variables"</span><span id="4ebc" class="lf jo hh lx b fi mk mh l mi mj">  environment = “${local.environment}”<br/>  size        = “${local.size}”<br/>}</span></pre><p id="fcba" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦声明，模块中的任何变量都可以通过引用为<code class="du lu lv lw lx b">module.variables.&lt;variable name&gt;</code>在项目中使用。由于输入被传递到模块，这允许项目动态地检索所有变量的正确值。</p><p id="b493" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在变量模块代码中，有一个<code class="du lu lv lw lx b">inputs.tf</code>声明了模块的输入变量。这些输入用于查找正确的值。</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="180d" class="lf jo hh lx b fi mg mh l mi mj">variable “environment” {<br/>  description = “The cluster deployment environment”<br/>}</span><span id="e57e" class="lf jo hh lx b fi mk mh l mi mj">variable “size” {<br/>  description = “The size of the instances”<br/>}</span></pre><p id="d251" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当在模块中构建变量时，我需要考虑哪些变量需要根据环境来检索，哪些变量需要根据大小来检索。</p><p id="6d4c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">根据环境编写变量的一个例子是子网id。</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="3047" class="lf jo hh lx b fi mg mh l mi mj">variable “subnet_map” {<br/>  description = “A map from environment to a comma-delimited list of     the subnets”<br/>  type = “map”</span><span id="d798" class="lf jo hh lx b fi mk mh l mi mj">default = {<br/>    dev     = “subnet-c59403abe,subnet-69483bdb33c”<br/>    qa      = “subnet-e48unjd9a1,subnet-c085uhd93a4”<br/>    staging = “subnet-65489uuhfn9,subnet-448hjdh86b”,<br/>    prod    = “subnet-6dfjn2344f,subnet-0f4u3bjbd47”<br/>  }<br/>}</span><span id="aeb6" class="lf jo hh lx b fi mk mh l mi mj">output “subnets” {<br/>  value = [“${split(“,”, var.subnet_map[var.environment])}”]<br/>}</span></pre><p id="ba71" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">基于大小编写变量的一个例子是实例类型。</p><pre class="ly lz ma mb fd mc lx md me aw mf bi"><span id="e210" class="lf jo hh lx b fi mg mh l mi mj">variable “instance_type_map” {<br/>  description = “A map from environment to the type of EC2 instance”<br/>  type = “map”</span><span id="f4c6" class="lf jo hh lx b fi mk mh l mi mj">  default = {<br/>    small  = “t2.large”<br/>    medium = “t2.xlarge”<br/>    large  = “m4.large”<br/>    xlarge = “m4.xlarge”<br/>  }<br/>}</span><span id="2cf1" class="lf jo hh lx b fi mk mh l mi mj">output “instance_type” {<br/>  value = “${var.instance_type_map[var.size]}”<br/>}</span></pre><p id="1347" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦在模块中创建了所有变量，现在就可以在Terraform代码中引用它们作为资源和其他模块的输入。这使得在将基础设施部署到具有不同配置和需求的不同环境时，核心代码库完全是动态的。</p><h1 id="bf0c" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">胜负</strong></h1><p id="528e" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">在构建了这个设计并通过一些开发周期运行了Kubernetes集群之后，它看起来对于所有环境都工作得很好，很可靠。Kubernetes集群已经在CI/CD环境中使用Terraform构建的基础架构投入生产运行了四个多月，没有出现任何问题。</p><p id="de8f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">也许你正在使用Terraform，这是一个新的设计模式，你可以在你的代码库中实现。也许您正在使用另一种工具，这激发了您探索Terraform如何融入您的环境的兴趣。无论哪种方式，我都鼓励你去探索Terraform和其他人是如何使用它的，你永远不知道从长远来看，什么时候采用一种新工具会有回报。</p><h2 id="82aa" class="lf jo hh bd jp lg lh li jt lj lk ll jx ja lm ln kb je lo lp kf ji lq lr kj ls bi translated">相关:</h2><ul class=""><li id="b3f6" class="kr ks hh ir b is kl iw km ja ml je mm ji mn jm kw kx ky kz bi translated"><a class="ae kq" rel="noopener" href="/capital-one-tech/building-feature-toggles-into-terraform-d75806217647">建筑特征切换成地形</a></li><li id="cb6c" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated"><a class="ae kq" rel="noopener" href="/capital-one-tech/multi-region-deployments-with-terraform-kubernetes-a1f51bb96974">使用Terraform进行多区域部署</a></li><li id="23f5" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated"><a class="ae kq" rel="noopener" href="/capital-one-tech/treating-your-terraform-like-an-application-why-terraform-in-a-docker-container-31e802314b4">像对待应用程序一样对待你的Terraform:第1部分——为什么Terraform要放在Docker容器中？</a></li><li id="6f30" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">像对待一个应用程序一样对待你的地形:第2部分——如何对接地形</li></ul></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><p id="73d9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="mv">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>