<html>
<head>
<title>Android Data Binding: Animations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android数据绑定:动画</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-data-binding-animations-55f6b5956a64?source=collection_archive---------2-----------------------#2016-11-30">https://medium.com/androiddevelopers/android-data-binding-animations-55f6b5956a64?source=collection_archive---------2-----------------------#2016-11-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="er es hf"><img src="../Images/b4dda3d4b006b4193950e3f793e40f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*YG-qoYvdS6nkFGqNPLapHw.gif"/></div></figure><div class=""/><div class=""><h2 id="ab20" class="pw-subtitle-paragraph il hn ho bd b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc dx translated">当数据在一瞬间没有变化时</h2></div><p id="a1cd" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">我已经展示了如何在数据改变时使用Android数据绑定来更新视图。这是查看UI即时更新的一个很好的方式，但是有时您想引起对数据变化的注意，或者只是提供一个平滑的过渡。使用数据绑定添加动画有两种方法:使用绑定适配器或使用OnRebindCallback。</p><h2 id="51d9" class="ka kb ho bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku bi translated">绑定适配器动画</h2><p id="8257" class="pw-post-body-paragraph jd je ho jf b jg kv ip ji jj kw is jl jm kx jo jp jq ky js jt ju kz jw jx jy ha bi translated">绑定适配器是一种在数据绑定值更改时设置视图值的方法。为动画使用绑定适配器非常简单，但是如果您需要复习，可以看看<a class="ae jz" rel="noopener" href="/google-developers/android-data-binding-custom-setters-55a25a7aea47#.tlzme9784">自定义设置器文章</a>。我们可以使用一个绑定适配器来截取值的变化，并使其动画化。</p><p id="bfbd" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">这是一个淡入或淡出视图的方法:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="e7c6" class="ka kb ho lf b fi lj lk l ll lm">@BindingAdapter(<strong class="lf hp">"animatedVisibility"</strong>)<br/><strong class="lf hp">public static void </strong>setVisibility(<strong class="lf hp">final </strong>View view,<br/>                                 <strong class="lf hp">final int </strong>visibility) {<br/>    <em class="ln">// Were we animating before? If so, what was the visibility?<br/>    </em>Integer endAnimVisibility =<br/>            (Integer) view.getTag(R.id.<strong class="lf hp"><em class="ln">finalVisibility</em></strong>);<br/>    <strong class="lf hp">int </strong>oldVisibility = endAnimVisibility == <strong class="lf hp">null<br/>            </strong>? view.getVisibility()<br/>            : endAnimVisibility;<br/><br/>    <strong class="lf hp">if </strong>(oldVisibility == visibility) {<br/>        <em class="ln">// just let it finish any current animation.<br/>        </em><strong class="lf hp">return</strong>;<br/>    }<br/><br/>    <strong class="lf hp">boolean </strong>isVisibile = oldVisibility == View.<strong class="lf hp"><em class="ln">VISIBLE</em></strong>;<br/>    <strong class="lf hp">boolean </strong>willBeVisible = visibility == View.<strong class="lf hp"><em class="ln">VISIBLE</em></strong>;<br/><br/>    view.setVisibility(View.<strong class="lf hp"><em class="ln">VISIBLE</em></strong>);<br/>    <strong class="lf hp">float </strong>startAlpha = isVisibile ? 1f : 0f;<br/>    <strong class="lf hp">if </strong>(endAnimVisibility != <strong class="lf hp">null</strong>) {<br/>        startAlpha = view.getAlpha();<br/>    }<br/>    <strong class="lf hp">float </strong>endAlpha = willBeVisible ? 1f : 0f;<br/><br/>    <em class="ln">// Now create an animator<br/>    </em>ObjectAnimator alpha = ObjectAnimator.<em class="ln">ofFloat</em>(view,<br/>            View.<strong class="lf hp"><em class="ln">ALPHA</em></strong>, startAlpha, endAlpha);<br/>    alpha.setAutoCancel(<strong class="lf hp">true</strong>);<br/><br/>    alpha.addListener(<strong class="lf hp">new </strong>AnimatorListenerAdapter() {<br/>        <strong class="lf hp">private boolean isCanceled</strong>;<br/><br/>        @Override<br/>        <strong class="lf hp">public void </strong>onAnimationStart(Animator anim) {<br/>            view.setTag(R.id.<strong class="lf hp"><em class="ln">finalVisibility</em></strong>, visibility);<br/>        }<br/><br/>        @Override<br/>        <strong class="lf hp">public void </strong>onAnimationCancel(Animator anim) {<br/>            <strong class="lf hp">isCanceled </strong>= <strong class="lf hp">true</strong>;<br/>        }<br/><br/>        @Override<br/>        <strong class="lf hp">public void </strong>onAnimationEnd(Animator anim) {<br/>            view.setTag(R.id.<strong class="lf hp"><em class="ln">finalVisibility</em></strong>, <strong class="lf hp">null</strong>);<br/>            <strong class="lf hp">if </strong>(!<strong class="lf hp">isCanceled</strong>) {<br/>                view.setAlpha(1f);<br/>                view.setVisibility(visibility);<br/>            }<br/>        }<br/>    });<br/>    alpha.start();<br/>}</span></pre><p id="bb20" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">你可以看到，当视图处于动画过程中时，我考虑了当前的alpha。这是一点额外的工作，但它将有助于用户流畅的动画体验。为了更好，你还可以考虑持续时间中的alpha，这样当淡入被淡出打断时，淡出会更短。由于这是一个简短的动画，它看起来并不太糟糕，即使被打断。</p><p id="61b1" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">我选择使用自定义属性，这样只有我使用“app:androidvisibility”的视图才会淡入淡出。如果我为“android:visibility”创建了一个绑定适配器，那么所有在该属性上有绑定表达式的视图都会淡入淡出。</p><h2 id="3866" class="ka kb ho bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku bi translated">OnRebindCallback</h2><p id="2cdc" class="pw-post-body-paragraph jd je ho jf b jg kv ip ji jj kw is jl jm kx jo jp jq ky js jt ju kz jw jx jy ha bi translated">ViewDataBinding有一个监听器，可以让您很好地控制绑定步骤OnRebindCallback。您可以使用它在绑定实际做出更改之前拦截它。它没有告诉您将要进行什么更改(它还不知道)，所以它不像绑定适配器那样工作。然而，这对于<a class="ae jz" href="https://developer.android.com/reference/android/transition/TransitionManager.html#beginDelayedTransition(android.view.ViewGroup, android.transition.Transition)" rel="noopener ugc nofollow" target="_blank">transition manager . begindelayedtransition()</a>来说是完美的，它必须在做出更改之前立即被调用。</p><p id="912f" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">Chet Haase在上面做了很棒的开发(以及一篇关于早期版本过渡支持的<a class="ae jz" rel="noopener" href="/google-developers/transitions-in-the-android-support-library-8bc86a1d688e#.8ztxrqk3a">文章</a>)，但是我将总结一下过渡做了什么。当您调用beginDelayedTransition()时，转换会捕获视图层次结构的状态。在下一个布局之后，转换捕获结束状态。然后，为变化的视图生成动画。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="c7a7" class="ka kb ho lf b fi lj lk l ll lm">binding.addOnRebindCallback(<strong class="lf hp">new </strong>OnRebindCallback() {<br/>    @Override<br/>    <strong class="lf hp">public boolean </strong>onPreBind(ViewDataBinding binding) {<br/>        TransitionManager.<em class="ln">beginDelayedTransition</em>(<br/>                (ViewGroup)binding.getRoot());<br/>        <strong class="lf hp">return super</strong>.onPreBind(binding);<br/>    }<br/>});</span></pre><p id="1651" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">TransitionManager为我创建所有的动画，所以非常容易。另一方面，当绑定表达式变脏并且有额外的开销时，就会调用这个函数。幸运的是，这通常每帧只有一次，所以如果您更改了数据模型的几个部分，您只会看到一次开销。</p><h2 id="5a45" class="ka kb ho bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku bi translated">我用哪一个？</h2><p id="df11" class="pw-post-body-paragraph jd je ho jf b jg kv ip ji jj kw is jl jm kx jo jp jq ky js jt ju kz jw jx jy ha bi translated">绑定适配器机制的优点:</p><ul class=""><li id="db7a" class="lo lp ho jf b jg jh jj jk jm lq jq lr ju ls jy lt lu lv lw bi translated">精细控制—只有您想要制作动画的视图才会制作动画</li><li id="f127" class="lo lp ho jf b jg lx jj ly jm lz jq ma ju mb jy lt lu lv lw bi translated">开销少于转换(性能)</li><li id="b615" class="lo lp ho jf b jg lx jj ly jm lz jq ma ju mb jy lt lu lv lw bi translated">非常灵活——你可以创建任何你想要的动画</li></ul><p id="c8bf" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">OnRebindCallback机制的优点:</p><ul class=""><li id="3e3e" class="lo lp ho jf b jg jh jj jk jm lq jq lr ju ls jy lt lu lv lw bi translated">简单易用</li><li id="cb53" class="lo lp ho jf b jg lx jj ly jm lz jq ma ju mb jy lt lu lv lw bi translated">不必使用自定义属性(或覆盖默认行为)</li><li id="d073" class="lo lp ho jf b jg lx jj ly jm lz jq ma ju mb jy lt lu lv lw bi translated">可以用相同的代码制作许多东西的动画(参见<a class="ae jz" href="https://developer.android.com/reference/android/transition/Transition.html" rel="noopener ugc nofollow" target="_blank">过渡</a>子类)</li></ul><p id="0ae0" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">你可以看到它们都很有用，你甚至可以把它们结合起来。如果您这样做，转换应该<a class="ae jz" href="https://developer.android.com/reference/android/support/transition/Transition.html#excludeTarget(android.view.View, boolean)" rel="noopener ugc nofollow" target="_blank">排除您想要使用绑定适配器的视图</a>。</p><p id="39c9" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">有了这两种技术，当数据发生变化时，您将能够提供平滑的动画，让您的用户高兴。</p></div></div>    
</body>
</html>