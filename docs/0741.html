<html>
<head>
<title>Important Performance Metrics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重要的绩效指标</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/important-performance-metrics-c7dacf018eb3?source=collection_archive---------0-----------------------#2022-08-11">https://medium.com/androiddevelopers/important-performance-metrics-c7dacf018eb3?source=collection_archive---------0-----------------------#2022-08-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/041053fb8512a9ec47c0393a13bd6ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Be4McwKM10m3XAPmLEWG3Q.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by Claudia Sanchez</figcaption></figure><div class=""/><p id="110e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在您开始有效地处理性能之前，我们建议您熟悉关键性能指标。通过了解应该查看哪些指标，您将更容易检查、改进和监控性能。</p><p id="3434" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这篇关于<strong class="iv hx">重要性能指标</strong>的MAD Skills文章将向您介绍<strong class="iv hx">初创公司</strong>和<strong class="iv hx">帧速率指标</strong>，并为本系列其余部分的性能带来重要数据点。应用程序启动和创建流畅的用户体验对用户满意度和应用程序的单个业务指标有着持久的影响，这就是为什么我们选择这些领域作为本文的重点。</p><p id="ec6a" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在本系列的后面，我们准备了工具和库，使您可以更容易地检查、改进和监控性能。</p><p id="1b40" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你可以在这里观看这篇文章的视频。</p><figure class="jr js jt ju fd hj"><div class="bz dy l di"><div class="jv jw l"/></div></figure><h1 id="6731" class="jx jy hw bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">启动阶段</h1><p id="ad34" class="pw-post-body-paragraph it iu hw iv b iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq ha bi translated">应用启动是与用户互动的第一点。留下持久而积极的第一印象在规模上甚至更重要。所以你的目标是让app启动尽可能的快，无缝，流畅。</p><blockquote class="la lb lc"><p id="7f24" class="it iu ld iv b iw ix iy iz ja jb jc jd le jf jg jh lf jj jk jl lg jn jo jp jq ha bi translated">App启动可以分三个阶段来衡量:冷启动、暖启动、热启动。</p></blockquote><p id="1a2d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">启动阶段由应用程序的当前状态决定。</p><figure class="jr js jt ju fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lh"><img src="../Images/464aff0d2c08235e7401cdeafabc0c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RNrYCsNHSe5Y4YJY"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">App startup phases</figcaption></figure><h2 id="c4be" class="li jy hw bd jz lj lk ll kd lm ln lo kh je lp lq kl ji lr ls kp jm lt lu kt lv bi translated">冷启动</h2><p id="36f5" class="pw-post-body-paragraph it iu hw iv b iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq ha bi translated">创建应用程序的进程时，冷启动开始。这是用户在安装您的应用程序后第一次启动它、在重启设备后启动应用程序或在系统因某种原因完全停止应用程序后重启应用程序时的体验。</p><p id="04ea" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在冷启动期间，<code class="du lw lx ly lz b">Application.onCreate()</code>被调用。你的应用程序启动所需的一切都是从磁盘加载的。当冷启动开始时，内存缓存也是空的。冷启动是最慢的启动类型，因为它们在进程创建时开始，在热启动完成的同时结束。若要体验应用程序的冷启动，请强制关闭它，然后从启动器再次打开它。</p><blockquote class="ma"><p id="bc13" class="mb mc hw bd md me mf mg mh mi mj jq dx translated">冷启动应该快于500毫秒。</p></blockquote><p id="00ed" class="pw-post-body-paragraph it iu hw iv b iw mk iy iz ja ml jc jd je mm jg jh ji mn jk jl jm mo jo jp jq ha bi translated">当冷启动时间超过500毫秒时，你的用户会注意到，可能会变得越来越不耐烦，可能会决定离开你的应用。所以保持冷启动尽可能快是极其重要的。</p><h2 id="06d3" class="li jy hw bd jz lj lk ll kd lm ln lo kh je lp lq kl ji lr ls kp jm lt lu kt lv bi translated">热启动</h2><p id="611f" class="pw-post-body-paragraph it iu hw iv b iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq ha bi translated">热启动是从调用<code class="du lw lx ly lz b">Activity.onCreate()</code>时开始测量的，就在视图层次膨胀之前。</p><p id="8a98" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">此时，一些资源已经膨胀，内存缓存已经预热。</p><blockquote class="la lb lc"><p id="6630" class="it iu ld iv b iw ix iy iz ja jb jc jd le jf jg jh lf jj jk jl lg jn jo jp jq ha bi translated"><em class="hw">热启动通常发生在活动被销毁后打开应用程序，但应用程序的进程仍在运行时。</em></p></blockquote><p id="506e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果一个应用程序已经在后台运行了一段时间，但还没有长到让系统终止整个进程，这种情况就会发生。此外，每当方向改变迫使活动被破坏和重新创建，这是一个温暖的开始。</p><h2 id="6475" class="li jy hw bd jz lj lk ll kd lm ln lo kh je lp lq kl ji lr ls kp jm lt lu kt lv bi translated">热起动</h2><p id="a06c" class="pw-post-body-paragraph it iu hw iv b iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq ha bi translated">最后也是最短的app启动类型叫做热启动。在热启动期间，正在运行的应用程序(例如暂停的活动)变得对用户可见，并进入已启动状态。</p><p id="5908" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这里第一帧准备好绘制，调用<code class="du lw lx ly lz b">Activity.onStart()</code>。当你在应用程序之间来回切换时，可能会发生热启动。</p><figure class="jr js jt ju fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lh"><img src="../Images/9701cde70a9351ffd20bba367b81c578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VVYrHNh4rECJoPsY"/></div></div></figure><p id="2d69" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">由于启动类型的性质，冷启动需要的时间最多。暖启动和热启动时间会更短。</p><blockquote class="la lb lc"><p id="731b" class="it iu ld iv b iw ix iy iz ja jb jc jd le jf jg jh lf jj jk jl lg jn jo jp jq ha bi translated">所有三种启动类型，冷、暖、热，都是从它们相应的起始点到两个结束状态中的至少一个来测量的。</p></blockquote><h1 id="0c74" class="jx jy hw bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">启动结束状态</h1><h2 id="17f0" class="li jy hw bd jz lj lk ll kd lm ln lo kh je lp lq kl ji lr ls kp jm lt lu kt lv bi translated">初始显示时间</h2><p id="da77" class="pw-post-body-paragraph it iu hw iv b iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq ha bi translated">默认的应用程序启动结束状态称为初始显示时间。简称<strong class="iv hx"> TTID </strong>。当您的应用程序的第一个框架准备好绘制时，它会自动报告。</p><p id="a054" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您也可以通过打开logcat并查找值为<code class="du lw lx ly lz b">Displayed</code>的<code class="du lw lx ly lz b">ActivityTaskManager</code>标签来查看TTID。它会告诉你显示一个特定的活动花了多少时间。因为这是自动报告的，所以不需要您进行任何配置。默认情况下，每个应用程序都会报告这一情况。</p><h2 id="9c15" class="li jy hw bd jz lj lk ll kd lm ln lo kh je lp lq kl ji lr ls kp jm lt lu kt lv bi translated">完全显示的时间</h2><p id="f9be" class="pw-post-body-paragraph it iu hw iv b iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq ha bi translated">虽然初始显示时间是自动报告的，但下一个状态可以自定义。这就是所谓的充分展示时间，或TTFD。完全显示时间是一个可选指标，Android可以使用它来进一步优化应用程序的启动时间。在应用程序上运行启动基准时也会用到它。</p><p id="bbae" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在logcat中也可以看到带有<code class="du lw lx ly lz b">ActivityTaskManager</code>标签的TTFD。寻找<code class="du lw lx ly lz b">ActivityTaskManager: Fully drawn</code>。</p><p id="7970" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当所有东西都画在屏幕上，并且用户与应用程序交互所需的数据可用时，您应该报告完全显示的时间。</p><blockquote class="ma"><p id="80ce" class="mb mc hw bd md me mf mg mh mi mj jq dx translated">要使用的API是Activity的reportFullyDrawn()</p></blockquote><p id="2a79" class="pw-post-body-paragraph it iu hw iv b iw mk iy iz ja ml jc jd je mm jg jh ji mn jk jl jm mo jo jp jq ha bi translated"><code class="du lw lx ly lz b">reportFullyDrawn</code>不依赖于活动生命周期方法，您必须选择合适的时间调用对您的应用有意义的API。</p><p id="2e07" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">虽然在应用程序准备就绪时调用该方法很重要，但不要求在帧级别上绝对精确<em class="ld">。</em></p><p id="605e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Android 示例应用程序中的<a class="ae mp" href="http://github.com/android/nowinandroid" rel="noopener ugc nofollow" target="_blank">现在被认为是在兴趣和提要都已加载的情况下被完全绘制。</a></p><p id="8532" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一旦满足这两个状态，当当前局部视图准备好被绘制时，我们调用<code class="du lw lx ly lz b">reportFullyDrawn</code>。你可以在GitHub 的<a class="ae mp" href="https://github.com/android/nowinandroid/blob/bc2fc8bb5e07139562a523fa33509d405b98d2b6/feature-foryou/src/main/java/com/google/samples/apps/nowinandroid/feature/foryou/ForYouScreen.kt#L168" rel="noopener ugc nofollow" target="_blank">中查看代码的更多细节。</a></p><h1 id="ad86" class="jx jy hw bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">帧时序度量</h1><p id="c7f5" class="pw-post-body-paragraph it iu hw iv b iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq ha bi translated">确保不丢帧对于流畅的用户体验非常重要。大多数帧在静态下不会被丢弃，但是当用户滚动或者你以其他方式制作动画内容时会被丢弃。如果一个应用程序在主线程上做了太多的工作来满足帧计时窗口，就会导致缓慢和冻结的帧。</p><p id="0aa3" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们称这种行为为邱建。邱建非常令人沮丧，所以知道如何避免它是很重要的。</p><h2 id="c5b4" class="li jy hw bd jz lj lk ll kd lm ln lo kh je lp lq kl ji lr ls kp jm lt lu kt lv bi translated">帧速率</h2><p id="4e54" class="pw-post-body-paragraph it iu hw iv b iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq ha bi translated">每秒钟可以画很多次屏幕。每秒重新绘制的数量称为帧速率。</p><p id="4b82" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">历史上，Android设备的刷新率为每秒60帧。这给了你的应用程序1/60秒的时间在主线程上执行工作，然后一个帧就会被延迟或者最终不得不被丢弃。最近，帧速率已经增加到每秒90帧甚至120帧。</p><p id="c9cc" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">此外，设备还可以根据用户的选择、开发人员的决定，甚至设备的电源或散热状态，在不同的帧速率之间切换。</p><p id="6fbf" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在我们的现代Android开发指南中，我们建议您优化至少每秒90帧的帧速率。这意味着两帧之间的所有工作必须在小于11.1毫秒的窗口内完成。<em class="ld">时间非常非常少。</em></p><blockquote class="ma"><p id="e826" class="mb mc hw bd md me mf mg mh mi mj jq dx translated">实现高帧速率的一个很好的方法是让尽可能多的工作远离主线程。</p></blockquote><figure class="mq mr ms mt mu hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lh"><img src="../Images/e5925b36b4e2f1701d6838418196c3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BByWrku9g21L02tR"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Different frame rates for an Android device</figcaption></figure><h1 id="863f" class="jx jy hw bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">当你等待的时候</h1><p id="d397" class="pw-post-body-paragraph it iu hw iv b iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq ha bi translated">在下一篇文章中，我们将向您详细介绍检查性能问题。</p><p id="7a5e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">此外，请务必查看我们关于性能调试的完整MAD技能系列，了解如何检查代码中正在发生的事情。</p><figure class="jr js jt ju fd hj"><div class="bz dy l di"><div class="jv jw l"/></div></figure><p id="8c45" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">去看看我们改进的开发者<a class="ae mp" href="http://d.android.com/performance" rel="noopener ugc nofollow" target="_blank">文档</a>，我们已经用MAD指南更新了它。</p><p id="fbfd" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要获得更多的实践经验，请查看GitHub上的<a class="ae mp" href="http://github.com/android/performance-samples" rel="noopener ugc nofollow" target="_blank">示例</a>。</p><p id="c785" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">或者参加<a class="ae mp" href="https://goo.gle/baseline-profiles-codelab" rel="noopener ugc nofollow" target="_blank">宏观基准测试代码实验室</a>或<a class="ae mp" href="https://goo.gle/baseline-profiles-codelab" rel="noopener ugc nofollow" target="_blank">基准配置文件代码实验室</a>以获得主题的实际指导。</p><p id="46c9" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">此外，确保在视频评论或Twitter上提出你的问题，使用<a class="ae mp" href="https://twitter.com/search?q=%23MADPerfQA" rel="noopener ugc nofollow" target="_blank"> #MADPerfQA </a>直接从致力于Android性能的工程师那里获得答案。</p></div></div>    
</body>
</html>