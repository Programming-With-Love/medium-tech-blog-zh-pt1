<html>
<head>
<title>Export Functionality via Google Cloud Functions and Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过谷歌云功能和Java导出功能</h1>
<blockquote>原文：<a href="https://medium.com/globant/export-functionality-via-google-cloud-functions-and-java-12a34df00458?source=collection_archive---------0-----------------------#2022-09-30">https://medium.com/globant/export-functionality-via-google-cloud-functions-and-java-12a34df00458?source=collection_archive---------0-----------------------#2022-09-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><blockquote class="il im in"><p id="1285" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用的技术:Java，Gradle，GCP</p></blockquote><p id="5afd" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">Google Cloud Function (GCF)是一个无服务器架构，你可以在其中构建小型云服务。服务可以用不同的语言编写，包括Python、Node.js、Java、PHP和其他一些语言。GCF旨在服务于一个目的，因此我们创建的服务不应该有很大的功能。我的感觉是，我们应该把大的功能分解成更简单、更小的服务，这些服务可以写在它们自己的GCF中。</p><p id="55c9" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">GCF由不同的事件触发。这些事件可以是HTTP触发器、基于事件的触发器或一些附加触发器。我将重点关注基于事件的触发器，尤其是发布/订阅触发器。</p><blockquote class="il im in"><p id="d72e" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意</strong>:截至目前，HTTP驱动函数的最大函数执行时间为3600秒(60分钟)，事件驱动函数的最大函数执行时间为540秒(9分钟)，之后函数超时。</p></blockquote><p id="942e" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">其他触发器包括云存储触发器(基于事件)、云日志、云调度器、云任务和gmail。</p><p id="60d1" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">这里我举一个导出功能的例子，它是我们在GCF中作为服务创建的。这个GCF将通过订阅一个发送到GCP主题的事件来触发。</p><h1 id="e690" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">导出功能</h1><p id="8ee2" class="pw-post-body-paragraph io ip hh ir b is ko iu iv iw kp iy iz jn kq jc jd jo kr jg jh jp ks jk jl jm ha bi translated">我创建的导出功能包括将数据导出到excel文件中。然后，我将这个excel文件存储到云存储中。</p><p id="784e" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">然后，可以使用预先签名的url从存储中下载该excel文件。(我不打算在这里讨论这一部分)</p><p id="ad78" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">我们在GCF中使用Java，对于excel生成，我使用Apache POI依赖。</p><p id="6388" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><strong class="ir hi">设计</strong>:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es kt"><img src="../Images/6cbc459eae40f7ab84e9413f202d8a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oeH4cM3B-AQtGGGKkw0LA.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">End to End Export Functionality</figcaption></figure><p id="0e7d" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">一旦事件从源发布到发布/订阅主题，比如说<strong class="ir hi">导出主题</strong>，它将被我们的订阅订阅，比如说<strong class="ir hi">导出到excel-sub </strong>，只要它通过所需的过滤器(如果有的话)。该订阅将是推送订阅。因此，在订阅事件时，它将触发我们的GCF。</p><p id="7a00" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">要部署GCF，可以使用以下命令:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="1afe" class="lo jr hh lk b fi lp lq l lr ls">gcloud functions deploy export-function --entry-point functions.ExportToExcel --runtime java17 --trigger-http --memory 512MB --allow-unauthenticated</span></pre><p id="3a89" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">其中<code class="du lt lu lv lk b">ExportToExcel</code>是GCF的限定类名，就像SpringBoot应用程序类名一样。</p><p id="edcb" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">我们GCF的端点可以从GCF部署日志中获取，也可以在部署后通过google cloud控制台上的这个命令获取:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="ee95" class="lo jr hh lk b fi lp lq l lr ls">gcloud functions describe export-function</span></pre><p id="09db" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">这里，<code class="du lt lu lv lk b">export-function</code>是注册到google cloud的GCF的名称。</p><p id="9d41" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">这是一个端点想要的:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="79b6" class="lo jr hh lk b fi lp lq l lr ls">https://GCP_REGION-PROJECT_ID.cloudfunctions.net/<!-- -->export-function</span></pre><p id="18fa" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">以下是我的GCP订阅使用GCF推送端点的示例:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lw"><img src="../Images/f6206b8f49b7792fffc11f145d01c830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Um7JzvnLitvuU0PMH_411A.jpeg"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">GCP subscription — export-to-excel-sub</figcaption></figure><p id="e23b" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">要在本地测试GCF，可以使用下面的命令来生成端点:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="b77f" class="lo jr hh lk b fi lp lq l lr ls">gradle runFunction -Prun.functionTarget=functions.<!-- -->ExportToExcel</span></pre><p id="c342" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">这为我们提供了一个本地端点，<a class="ae lx" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"><em class="iq">http://localhost:8080/</em></a>，可以用来测试功能。</p><h1 id="ade3" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">定义依赖关系</h1><p id="3c8a" class="pw-post-body-paragraph io ip hh ir b is ko iu iv iw kp iy iz jn kq jc jd jo kr jg jh jp ks jk jl jm ha bi translated">我一直在使用Gradle，这就是我的构建中的依赖部分。</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="9104" class="lo jr hh lk b fi lp lq l lr ls">dependencies {<br/>  // Necessary to have Functions Framework API.<br/>  compileOnly 'com.google.cloud.functions:functions-framework-api:1.0.4'<br/><br/>  // Necessary to run function locally<br/>  invoker 'com.google.cloud.functions.invoker:java-function-invoker:1.1.0'<!-- --> </span><span id="12e5" class="lo jr hh lk b fi ly lq l lr ls">  // Needed to access Microsoft format files (Excel in our case)<br/>  implementation 'org.apache.poi:poi-ooxml:5.2.2'</span><span id="bf36" class="lo jr hh lk b fi ly lq l lr ls">  // Only needed by the tests.<br/>  testImplementation 'com.google.cloud.functions:functions-framework-api:1.0.4'<br/>  testImplementation 'junit:junit:4.13.2'<br/>  testImplementation 'com.google.truth:truth:1.1.3'<br/>  testImplementation 'org.mockito:mockito-core:4.5.1'<br/><br/>}</span></pre><p id="0ddd" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">要在本地运行GCF，需要在build.gradle中注册该函数，如下所示:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="5eec" class="lo jr hh lk b fi lp lq l lr ls">// Register a "runFunction" task<br/>tasks.register("runFunction", JavaExec) <strong class="lk hi">{<br/>    </strong>main = 'com.google.cloud.functions.invoker.runner.Invoker'<br/>    classpath(configurations.invoker)<br/>    inputs.files(configurations.runtimeClasspath, sourceSets.main.output)<br/>    args(<br/>            '--target', project.findProperty('run.functionTarget') ?: 'functions.<strong class="lk hi">ExportToExcel</strong>',<br/>            '--port', project.findProperty('run.port') ?: 8080<br/>    )<br/>    doFirst <strong class="lk hi">{<br/>        </strong>args('--classpath', files(configurations.runtimeClasspath, sourceSets.main.output).asPath)<br/>    <strong class="lk hi">}<br/>}</strong></span></pre><h1 id="e920" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">创建源文件</h1><p id="5f9b" class="pw-post-body-paragraph io ip hh ir b is ko iu iv iw kp iy iz jn kq jc jd jo kr jg jh jp ks jk jl jm ha bi translated">在我们项目的源文件目录中，我创建了我们的源文件:ExportToExcel.java。</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="2140" class="lo jr hh lk b fi lp lq l lr ls">src/main/java/functions/ExportToExcel.java</span></pre><p id="e75b" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">这是初始文件的样子:</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="4bc3" class="lo jr hh lk b fi lp lq l lr ls">package functions;<br/><br/>import com.google.cloud.functions.HttpFunction;<br/>import com.google.cloud.functions.HttpRequest;<br/>import com.google.cloud.functions.HttpResponse;<br/>import java.io.BufferedWriter;<br/>import java.io.IOException;<br/><br/>public class ExportToExcel implements HttpFunction {<br/>  // Cloud function to create an Excel containing some data and upload it onto cloud storage<br/>  @Override<br/>  public void service(HttpRequest request, HttpResponse response)<br/>      throws IOException {<br/>    BufferedWriter writer = response.getWriter();<br/>    writer.write("Excel Exporter");<br/>  }<br/>}</span></pre><p id="2106" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">每个Http触发的GCF实现HttpFunction接口，这是一个函数接口。因此，需要向服务方法提供一个动作。调用服务方法来处理Http请求。</p><p id="3b16" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">从<code class="du lt lu lv lk b">request</code>读取数据，在我们的操作完成后，响应应该被写入<code class="du lt lu lv lk b">response</code>。</p><p id="beb5" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">在读取输入请求时，我尝试连接到数据库并获取所需的数据。然后结果集被处理并存储在excel文件中。</p><p id="9684" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">apache poi库的<strong class="ir hi"> HSSFWorkbook </strong>或<strong class="ir hi"> XSSFWorkbook </strong>或<strong class="ir hi"> SXSSFWorkbook </strong>类可以用来创建excel文件。</p><p id="2332" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">XSSFWorkbook比较慢，因为它将所有单元格都保存在内存中，直到excel被保存。因此，在某个时间点之后，它耗尽了堆内存。另一方面，SXSSFWorkbook是XSSFWorkbook的流式扩展。</p><blockquote class="il im in"><p id="42bf" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong> SXSSFWorkbook实现了一种策略，允许在不耗尽内存的情况下写入非常大的文件，因为在任何时候都只有可配置的一部分行保留在内存中。</p></blockquote><p id="7d83" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">SXSSFWorkbook在刷新之前要在内存中保留的行数，可以在其对象创建期间通过名为'<strong class="ir hi"> rowAccessWindowSize </strong>'的整数参数来完成。</p><p id="376c" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated">假设我有一个从数据库中提取的大型结果集，下面是我的示例代码，说明如何将数据导出到excel中:</p><p id="1cfc" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><strong class="ir hi">createExportFileForData</strong><em class="iq">方法用于填充Excel文件并上传到GCS bucket。它返回“EXPORTED”或“FAILED”字符串消息，以传递给http响应。它是我们功能的入口点，并将要导出的数据作为输入。</em></p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="19bb" class="lo jr hh lk b fi lp lq l lr ls"><em class="iq"><br/>    </em>public String <strong class="lk hi">createExportFileForData</strong>(ResultSet data) {<br/>        //Default file status<br/>        String file_status = "EXPORTED";<br/>        //Default_Window_Size is 100<br/>        try (SXSSFWorkbook workbook = new SXSSFWorkbook(SXSSFWorkbook.<em class="iq">DEFAULT_WINDOW_SIZE</em>)) {<br/>            //Sheet name as parameter<br/>            Sheet sheet = workbook.createSheet("SHEET_NAME");<br/>            <em class="iq">createSheetHeader</em>(workbook, sheet);<br/>            <em class="iq">createSheetBody</em>(workbook, sheet, data);</span><span id="baad" class="lo jr hh lk b fi ly lq l lr ls">            //To upload the file to GCS, we need byte array, hence we write the workbook to ByteArrayOutputStream.<br/>            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();<br/>            workbook.write(outputStream);<br/>            uploadToBucket(outputStream.toByteArray(), "FileName.xlsx");<br/>        }<br/>        catch (Exception e) {<br/>            <em class="iq">LOGGER</em>.info("Failed to generate and upload file to storage");<br/>            <em class="iq">LOGGER</em>.warning("Error : " + e);<br/>            file_status = "FAILED";<br/>        }<br/>        return file_status;<br/>    }</span></pre><p id="2b1f" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><strong class="ir hi"> createSheetBody </strong> <em class="iq">方法用于将数据写入Excel表中。它是从createExportFileForData方法调用的。</em></p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="2039" class="lo jr hh lk b fi lp lq l lr ls"><em class="iq">    </em>private void <strong class="lk hi">createSheetBody</strong>(SXSSFWorkbook workbook, Sheet sheet, ResultSet data) throws SQLException {<br/><br/>        //Row 0 would be the header row<br/>        int rowNumber = 1;<br/>        while(data.next()) {<br/>            Row dataRow = sheet.createRow(rowNumber++);<br/>            <em class="iq">createSheetCell</em>(dataRow, 0, data.getObject("name", String.class));<br/>            <em class="iq">createSheetCell</em>(dataRow, 1, data.getObject("address", String.class));<br/>//            .<br/>//            .<br/>//            .<br/>            <em class="iq">createSheetCell</em>(dataRow, <em class="iq">N</em>, data.getObject("phone_no", String.class));<br/>        }<br/>    }</span></pre><p id="931a" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><strong class="ir hi"> createSheetHeader </strong>方法为数据表创建标题行。它是从createExportFileForData方法调用的。</p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="65f2" class="lo jr hh lk b fi lp lq l lr ls">private void <strong class="lk hi">createSheetHeader</strong>(SXSSFWorkbook workbook, Sheet sheet) {<br/>        //Creating an SXSSFRow for row number 0 (index starts from 0)<br/>        Row headerRow = sheet.createRow(0);<br/>        Font headerFont = workbook.createFont();<br/>        headerFont.setBold(true);<br/>        <br/>        <em class="iq">fillHeaderData</em>(headerRow);<br/>    }</span></pre><p id="c83b" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><strong class="ir hi"> fillHeaderData </strong> <em class="iq">方法用于填充标题行(列名)。它是从</em>createshetheader<em class="iq">方法中调用的。</em></p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="a3dd" class="lo jr hh lk b fi lp lq l lr ls">private void <strong class="lk hi">fillHeaderData</strong>(Row headerRow) {<br/>        //Passing columnNo and value to the createSheetCell method<br/>        <em class="iq">createSheetCell</em>(headerRow, 0, "Name");<br/>        <em class="iq">createSheetCell</em>(headerRow, 1, "Address");<br/>        //Similar n cells<br/>//        .<br/>//        .<br/>//        .<br/>        <em class="iq">createSheetCell</em>(headerRow, <em class="iq">N</em>, "Phone Number");<br/>    }</span></pre><p id="9109" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><strong class="ir hi"> createSheetCell </strong> <em class="iq">方法用于创建每一行的单元格。从</em>createshetheader<em class="iq">方法调用。</em></p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="56e6" class="lo jr hh lk b fi lp lq l lr ls">private void <strong class="lk hi">createSheetCell</strong>(Row row, int columnNo, Object value) {<br/>    Cell cell = row.createCell(columnNo);<br/>    if (value == null) {<br/>        cell.setCellValue("");<br/>    } else if (value instanceof String) {<br/>        cell.setCellValue((String) value);<br/>    } else if (value instanceof Timestamp) {<br/>        cell.setCellValue(((Timestamp) value).toLocalDateTime().format(DateTimeFormatter.<em class="iq">ISO_LOCAL_DATE_TIME</em>));<br/>    } else if (value instanceof BigInteger) {<br/>        cell.setCellValue(((BigInteger) value).doubleValue());<br/>    } else if (value instanceof UUID) {<br/>        cell.setCellValue(value.toString());<br/>    } else if (value instanceof BigDecimal) {<br/>        cell.setCellValue(String.<em class="iq">valueOf</em>(value));<br/>    }<br/>}</span></pre><p id="fdba" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><strong class="ir hi"><em class="iq">uploadToBucket</em></strong><em class="iq">方法是从createExportFileForData方法中调用的，用于将我的导出文件上传到GCP桶中。</em></p><pre class="ku kv kw kx fd lj lk ll lm aw ln bi"><span id="61cd" class="lo jr hh lk b fi lp lq l lr ls">private void <strong class="lk hi">uploadToBucket</strong>(byte[] bytes, String fileName) {<br/>        String bucketName = "BUCKET_NAME";<br/>        //Using the google cloud lib classes to insert the byte data of the file into the blob and upload it to GCS bucket<br/>        BlobId blobId = BlobId.<em class="iq">of</em>(bucketName, fileName);<br/>        //BlobInfo will contain the info about in GCS<br/>        BlobInfo blobInfo = BlobInfo.<em class="iq">newBuilder</em>(blobId).build();<br/>        Storage storage = StorageOptions.<em class="iq">newBuilder</em>().setProjectId("PROJECT_NAME").build().getService();<br/>        storage.create(blobInfo, bytes);<br/>    }</span></pre><h1 id="4758" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="15d7" class="pw-post-body-paragraph io ip hh ir b is ko iu iv iw kp iy iz jn kq jc jd jo kr jg jh jp ks jk jl jm ha bi translated">GCF，即服务功能(FaaS ),在执行功能以响应事件触发时非常有用。对于旨在实现单一行动/目的的小型请求，GCF非常有用。</p><blockquote class="il im in"><p id="3b7b" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">更多的语言和触发器正在被不断添加到谷歌云功能中。</p></blockquote></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h2 id="bc85" class="lo jr hh bd js lz ma mb jw mc md me ka jn mf mg ke jo mh mi ki jp mj mk km ml bi translated">参考</h2><p id="acd1" class="pw-post-body-paragraph io ip hh ir b is ko iu iv iw kp iy iz jn kq jc jd jo kr jg jh jp ks jk jl jm ha bi translated"><a class="ae lx" href="https://cloud.google.com/functions/docs/" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://cloud.google.com/functions/docs/</em></a></p><p id="a4e3" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><a class="ae lx" href="https://poi.apache.org/apidocs/4.0/org/apache/poi/xssf/" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://poi.apache.org/apidocs/4.0/org/apache/poi/xssf/</em></a></p><p id="06ef" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"><a class="ae lx" href="https://andriymz.github.io/misc/apache-poi-slow-excel-generation/" rel="noopener ugc nofollow" target="_blank"><em class="iq">https://andriymz . github . io/misc/Apache-poi-slow-excel-generation/</em></a></p><p id="65d4" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jn jb jc jd jo jf jg jh jp jj jk jl jm ha bi translated"># Google cloud function # Java # Apache poi # export data # excel file generate # FAAS # GCF</p></div></div>    
</body>
</html>