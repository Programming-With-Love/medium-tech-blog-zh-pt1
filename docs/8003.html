<html>
<head>
<title>Resiliency Through Message-Driven Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过消息驱动的架构实现弹性</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/resiliency-through-message-driven-architecture-137c4547dc80?source=collection_archive---------0-----------------------#2021-04-21">https://medium.com/walmartglobaltech/resiliency-through-message-driven-architecture-137c4547dc80?source=collection_archive---------0-----------------------#2021-04-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/118af029a118ed50e0a2ca0b9f207914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qj1FsLKVT5SmNfBkKg0BxA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo credit: <a class="ae it" href="https://pixabay.com/illustrations/letters-envelope-news-message-5614727/" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><h2 id="0109" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">语境</h2><p id="d6fd" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">弹性是现代系统的一个关键属性，被认为是保持业务的主要因素。在本文中，我们将研究<strong class="ju hi"> <em class="kn">消息驱动的</em> </strong>架构如何在参考实现的帮助下为系统带来弹性。</p><h2 id="a544" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">什么是弹性？</h2><blockquote class="ko kp kq"><p id="04a8" class="js jt kn ju b jv kr jx jy jz ks kb kc kt ku ke kf kv kw kh ki kx ky kk kl km ha bi translated">在软件工程中，<strong class="ju hi">弹性</strong>被定义为尽管整个系统出现某些故障，仍能保持响应的能力。</p></blockquote><p id="5e03" class="pw-post-body-paragraph js jt hh ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km ha bi translated">现代系统在本质上是分布式的——多个组件(或微服务)一起工作来执行整个系统提供的业务。例如，一个电子商务网站可能有多个服务负责目录、项目、购物车、预订、库存等..所有这些服务协同工作，以方便客户购买产品。预订订单时显示<strong class="ju hi"> <em class="kn">预期交付日期</em> </strong>这样的简单请求可能需要从多个微服务中提取信息，以便考虑库存、运输和位置来计算结果。如果一个(或多个)上游服务停止，站点会停止接受订单吗？弹性就是在这种局部故障下保持整个系统的响应。</p><h2 id="c858" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">什么是消息驱动架构？</h2><blockquote class="ko kp kq"><p id="6dde" class="js jt kn ju b jv kr jx jy jz ks kb kc kt ku ke kf kv kw kh ki kx ky kk kl km ha bi translated">在<strong class="ju hi">消息驱动架构中</strong>组件通过传递消息来相互交流。<strong class="ju hi">消息</strong>是发送到特定目的地的数据项。</p></blockquote><p id="4acc" class="pw-post-body-paragraph js jt hh ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km ha bi translated">消息在两个松散耦合的组件之间架起了一座上下文边界的桥梁。每个组件都拥有整个系统的一部分，并且独立工作。通过隔离组件，故障也包含在组件内，不会扩散到整个系统。处理故障是组件的局部问题，而不是整个系统的问题。</p><h2 id="2203" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">问题是</h2><p id="0ec3" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">我们在上一节中简要地谈到了<strong class="ju hi"> <em class="kn">预计交货日期</em> </strong>的计算问题，让我们放大到这一点。</p><p id="b011" class="pw-post-body-paragraph js jt hh ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km ha bi translated">假设购物车中的商品在几个<strong class="ju hi"><em class="kn"/></strong>履行中心都有库存，为了简单起见，我们只考虑一个<strong class="ju hi"> <em class="kn"> FC </em> </strong>。有库存不代表能在恒定时间内发货。这将取决于许多属性，如<strong class="ju hi"><em class="kn"/></strong><strong class="ju hi"><em class="kn">截止时间</em> </strong>等。每个<strong class="ju hi"> <em class="kn"> FC </em> </strong>可能与不同的<strong class="ju hi"> <em class="kn">承运商</em> </strong>有关联，如<em class="kn"> FedEx或UPS </em>，它们可能有自己的<strong class="ju hi"> <em class="kn">工作日历</em> </strong> <em class="kn">、</em> <strong class="ju hi"> <em class="kn">截止日期</em> </strong> <em class="kn">、</em> <strong class="ju hi"> <em class="kn">运输时间</em> </strong> <em class="kn"> </em>和其他贡献此外，每个FC可以在任何给定的一天处理一组有限的订单(称为<strong class="ju hi"> <em class="kn"> FC能力</em> </strong> <em class="kn">)。</em>每辆运输车可以装载一套固定的箱子(<strong class="ju hi"> <em class="kn">运输车容量</em> </strong> <em class="kn"> ) </em>也装在拖车里。项目维度决定了箱子的数量。物品属性过滤掉某些承运商，例如不通过<em class="kn">航空承运商</em>运输<em class="kn">危险品</em>物品。</p><p id="1efc" class="pw-post-body-paragraph js jt hh ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km ha bi translated">如果你觉得上面的模型看起来很复杂，我同意你的观点！我刚刚试图用几句话解释一个电子商务网站的潜在的<strong class="ju hi"><em class="kn"/></strong><em class="kn"/>采购引擎工作流程。无论如何，这里的关键是——有一个系统依赖于多个组件来执行其工作，如<strong class="ju hi"> <em class="kn">图像图1 </em> </strong>所示</p><figure class="la lb lc ld fd ii er es paragraph-image"><div class="er es kz"><img src="../Images/08ba5090cc6bb833662264dc47e4ff51.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*h7v4bZwWh0zUzqqGJCDHDQ.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Figure 1</figcaption></figure><p id="5e5e" class="pw-post-body-paragraph js jt hh ju b jv kr jx jy jz ks kb kc jf ku ke kf jj kw kh ki jn ky kk kl km ha bi translated">很明显，这些依赖组件中的一个组件的故障可能会对整个系统产生连锁效应。<strong class="ju hi">、<em class="kn">、</em>、</strong>或仔细定义的<strong class="ju hi">、<em class="kn">、</em>、</strong>的断路器可以用来把故障减少到一定程度。然而，某些依赖是无法避免的，我们可以实现的最好方法可能是快速失败。</p><h2 id="cf16" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">解决办法</h2><p id="f83e" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated"><strong class="ju hi"> <em class="kn">消息驱动</em> </strong>解决这个问题的方法如图<strong class="ju hi"> <em class="kn">图2 </em> </strong>所示。所有相关系统都将其状态更改发布到消息总线。<strong class="ju hi">关键的依赖性从它的运行时中被消除。上游组件故障是孤立的，不会级联到整个系统。</strong></p><figure class="la lb lc ld fd ii er es paragraph-image"><div class="er es le"><img src="../Images/20351506ed2aeecaaeaa836141fbf0c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*q1FBLv6tADpWH8ZubYI7bA.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Figure 2</figcaption></figure><h2 id="598e" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">警告</h2><p id="8573" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated"><strong class="ju hi"> <em class="kn">消息驱动</em> </strong>架构并不适用于所有用例，应谨慎使用。使用它之前，需要考虑以下几点:</p><ul class=""><li id="794d" class="lf lg hh ju b jv kr jz ks jf lh jj li jn lj km lk ll lm ln bi translated">由于数据是异步流动的，它可能不如从源系统获取的数据新鲜。对于不能承受陈旧数据的系统，消息驱动可能不是最佳选择。</li><li id="e7b5" class="lf lg hh ju b jv lo jz lp jf lq jj lr jn ls km lk ll lm ln bi translated">应该高效地实现消息消费者，以匹配生产者的速度。需要对滞后进行监控，并在达到阈值时发出警报。</li><li id="70cd" class="lf lg hh ju b jv lo jz lp jf lq jj lr jn ls km lk ll lm ln bi translated">还应该在生产者端实现一些智能监控，以捕捉消息发布或组件故障，这样消费者就不会误以为自己是最新的，并据此采取行动。</li><li id="f962" class="lf lg hh ju b jv lo jz lp jf lq jj lr jn ls km lk ll lm ln bi translated">消费者端的存储应该高度冗余，否则将成为单点故障。</li></ul><h2 id="add8" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结论</h2><p id="aa1b" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">在分布式系统中，某些组件的故障是不可避免的。<strong class="ju hi"> <em class="kn">消息驱动的</em> </strong>架构有助于构建真正解耦的组件，其中这种部分故障是允许的并且可以被包含。这种松散耦合为整个系统带来了弹性，并使其具有响应性。</p><h2 id="a0ca" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">参考资料:</h2><ol class=""><li id="93bd" class="lf lg hh ju b jv jw jz ka jf lt jj lu jn lv km lw ll lm ln bi translated"><a class="ae it" href="https://www.reactivemanifesto.org/" rel="noopener ugc nofollow" target="_blank">https://www.reactivemanifesto.org/</a></li><li id="e76d" class="lf lg hh ju b jv lo jz lp jf lq jj lr jn ls km lw ll lm ln bi translated"><a class="ae it" href="https://developer.lightbend.com/docs/akka-platform-guide/concepts/message-driven-event-driven.html" rel="noopener ugc nofollow" target="_blank">https://developer . light bend . com/docs/akka-platform-guide/concepts/message-driven-event-driven . html</a></li></ol></div></div>    
</body>
</html>