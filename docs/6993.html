<html>
<head>
<title>Use ESLint to Enforce Design System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ESLint加强设计系统</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/use-eslint-to-enforce-design-system-eaffbb1cd4e7?source=collection_archive---------1-----------------------#2021-11-16">https://medium.com/quick-code/use-eslint-to-enforce-design-system-eaffbb1cd4e7?source=collection_archive---------1-----------------------#2021-11-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="9390" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">了解ESLint如何构建测试规则，以确保设计系统组件在生产中得到正确使用</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/6f8a5569083a7d84a6af9ea433c19d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e5ffrHBBo8Sq_NzKymVhaw.png"/></div></div></figure><p id="c388" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您正在为您的公司或开源社区创建一个设计系统组件库，那么您很可能对最终用户应该如何使用您的设计系统有强烈的意见。</p><p id="6e36" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了确保您的设计系统以预期的方式使用，并减少可能的错误数量，您可能希望您的用户遵循您的最佳实践。以下是两个可能的最佳实践示例:</p><ul class=""><li id="65cb" class="ke kf hh jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated">避免元素中的内联样式</li><li id="cf8e" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated">确保工具提示不包含交互式内容。</li></ul><blockquote class="ks kt ku"><p id="adf3" class="ji jj kv jk b jl jm ii jn jo jp il jq kw js jt ju kx jw jx jy ky ka kb kc kd ha bi translated">如果你是唯一一个设计、开发和使用你的设计系统的人，那么你可以放心地睡觉，因为你知道你的设计系统被完全按照预期的方式使用。</p></blockquote><p id="0e93" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">有可能你不是唯一一个开发设计系统的人，当有人使用它的时候你肯定不会在场。你如何确信每个人都遵守你的设计系统的最佳实践？您可以祈祷并相信您的最终用户会阅读文档，注意您的警告，并且永远不会不遵守您的规则。</p><p id="c556" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">不幸的是，情况往往不是这样，很容易错过警告或误解如何正确使用工具。</p><p id="8be9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">鼓励你的消费者遵循你的最佳实践的一个好方法是通过使用<a class="ae kz" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>，一个静态分析工具来发现你的代码中的问题。</p><p id="2d2f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">默认情况下，ESLint附带了一些通用的最佳实践，称为<em class="kv">规则</em>，如果违反了这些规则，它会在你的IDE中显示红色的曲线。这些规则包括:</p><ul class=""><li id="83fb" class="ke kf hh jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated">对象中没有重复的键</li><li id="5e64" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated">没有不可及的代码</li><li id="9dc5" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated">没有未使用的变量</li></ul><p id="407a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，您在项目中启用的规则不需要直接来自ESLint。像<a class="ae kz" href="https://www.cypress.io/" rel="noopener ugc nofollow" target="_blank"> Cypress </a>、<a class="ae kz" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>和<a class="ae kz" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>这样的流行库都有ESLint配置，任何人都可以在自己的项目中使用，以确保用户遵循最佳实践。如果您是JavaScript语言的勇敢探索者，您可以更进一步，创建特定于您的设计系统的自定义规则，您可以导出这些规则供其他人在他们的项目中使用。</p><p id="2b67" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在本文中，我们将花一些时间来理解像ESLint这样的工具是如何将JavaScript解析成一种叫做<em class="kv">抽象语法树</em> (AST)的数据结构的。然后我们会谈到ESLint规则是如何工作的，以及如何将Lit模板解析成HTML。最后，我们将开始创建我们的第一个规则。我们甚至将使用ESLint的内置测试工具来确保我们的规则在各种条件下都能工作。</p><p id="ad5b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">本文的先决条件是一些JavaScript + HTML知识。使用ESLint和Lit的一点经验可能会派上用场，但不是必需的。</p><h1 id="24c1" class="la lb hh bd lc ld le lf lg lh li lj lk in ll io lm iq ln ir lo it lp iu lq lr bi translated">什么是抽象语法树？</h1><p id="d657" class="pw-post-body-paragraph ji jj hh jk b jl ls ii jn jo lt il jq jr lu jt ju jv lv jx jy jz lw kb kc kd ha bi translated">对于那些以前没有接触过编译器的人来说，构想我们在IDE中编写的人类可读语言是如何被像<a class="ae kz" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>、<a class="ae kz" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">pretty</a>和<a class="ae kz" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>这样的工具理解(和转换)的，感觉就像是魔法一样。</p><p id="e028" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在幕后，当像ESLint这样的工具想要对你的JavaScript执行动作时，它会解析你的代码。解析是获取您编写的JavaScript并将其转换成代码的树表示的过程，一个<em class="kv">抽象语法树</em> (AST)。</p><p id="ca66" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个解析过程分为两个部分，<em class="kv">标记化</em>和<em class="kv">树构建</em>。</p><p id="b783" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">标记化将代码分割成称为标记的东西，这些标记描述了语法的独立部分。</p><p id="f22d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">JavaScript程序的标记，如:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="df35" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">看起来会像这样:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="c840" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">解析过程的第二步是<em class="kv">树构建</em>，它将令牌重新格式化为AST。AST描述了语法的每个部分及其与其他部分的关系。</p><blockquote class="ks kt ku"><p id="2e64" class="ji jj kv jk b jl jm ii jn jo jp il jq kw js jt ju kx jw jx jy ky ka kb kc kd ha bi translated">在这个例子中，我们使用了<a class="ae kz" href="https://github.com/lydell/js-tokens" rel="noopener ugc nofollow" target="_blank"> js-tokens </a>作为标记js的一种快速方式，但是在本文中，我们不会自己直接处理标记化。</p></blockquote><p id="1be8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以通过解析以下JavaScript语句来可视化这种关系:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="1abc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">它将被转换成AST，具有以下结构:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/43be3b957fc3f0c656bc2fdb91f6e20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Fn6_TS16-_MiYDUL.png"/></div></div></figure><p id="a2c0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">像Babel和Prettier这样的工具可以把你写的JavaScript转换成AST来分析和转换我们写的代码。Babel使用AST将我们的代码转换成浏览器友好的JavaScript版本，而Prettier使用AST重新格式化您的代码。</p><h1 id="4eee" class="la lb hh bd lc ld le lf lg lh li lj lk in ll io lm iq ln ir lo it lp iu lq lr bi translated">对AST Explorer感到好奇</h1><p id="95d1" class="pw-post-body-paragraph ji jj hh jk b jl ls ii jn jo lt il jq jr lu jt ju jv lv jx jy jz lw kb kc kd ha bi translated">要真正探索AST是什么样子，可以使用<a class="ae kz" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST explorer </a>。熟悉AST explorer，因为我们将在本文后面使用它。</p><p id="fe46" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">写一个简单的语句，如下所示:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="8c20" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您将看到树的顶层描述了整个程序，我们可以查看<em class="kv">主体</em>数组，以查看AST中表示的上述语句的各个组成部分。</p><p id="2846" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您将鼠标悬停在<code class="du lz ma mb mc b">VariableDeclaration</code>上，您可以看到左侧的整个语句被高亮显示。如果我们深入到<code class="du lz ma mb mc b">declarations</code>数组，您会看到一个额外的节点<code class="du lz ma mb mc b">VariableDeclarator</code>。如果我们继续前进，我们最终会到达谷底。在我们的hello world语句中，它包含变量的<code class="du lz ma mb mc b">Identifier</code>和变量的<code class="du lz ma mb mc b">Literal</code>值。</p><p id="a8de" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们回顾一下之前的组件:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="2be5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您在AST explorer中遍历树，您可以看到该结构与我们之前的图像相匹配。请特别注意<code class="du lz ma mb mc b">TaggedTemplateExpression</code>节点和<code class="du lz ma mb mc b">TemplateLiteral</code>节点。当我们编写ESLint规则时，这些将会派上用场。</p><p id="a24c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们对<code class="du lz ma mb mc b">html</code>函数的调用是一个表达式，但它看起来与其他函数定义有点不同。让我们看看AST与如下表达式有何不同:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="9d1a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果我们将鼠标悬停在<code class="du lz ma mb mc b">heyThere()</code> <code class="du lz ma mb mc b">ExpressionStatement</code>上，我们会看到属性与我们的<code class="du lz ma mb mc b">html</code> ExpressionStatement相匹配。主要区别在于<code class="du lz ma mb mc b">expression</code>属性中的值看起来不同。这次的表达式是一个<code class="du lz ma mb mc b">CallExpression</code>，和我们的<code class="du lz ma mb mc b">TaggedTemplateExpression</code>有一组不同的属性。</p><p id="bace" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果我们回头看看我们的<code class="du lz ma mb mc b">TaggedTemplateExpression</code>，我们可以看到我们有类似tag和quasi的属性。</p><p id="3fdf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">标签给了我们一些关于函数名的细节。在这种情况下是<code class="du lz ma mb mc b">html</code>。</p><p id="9273" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这意味着当我们编写ESlint规则时，我们可以这样做:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="2b04" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">最后，如果您查看<code class="du lz ma mb mc b">TaggedTemplateExpression</code>对象，您会看到一个名为<code class="du lz ma mb mc b">quasi</code>的属性。这个属性包含了我们两个值得注意的属性<code class="du lz ma mb mc b">expressions</code>和<code class="du lz ma mb mc b">quasis</code>。以下面的表达式为例:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es md"><img src="../Images/8198a6ed3f9497c3882b7c924a1b536c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AkkKWFKVAsD10l2a.png"/></div></div></figure><p id="3437" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">第二条绿色下划线将位于<code class="du lz ma mb mc b">expressions</code>数组中，并提供对变量名称的引用。像<code class="du lz ma mb mc b">quasis</code>一样，数组中的项目按照它们被定义的顺序排列。这使得稍后协调模板文字变得非常容易。</p><p id="74a2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里有一个问题，如果我们的模板文字的第一个字符是一个表达式，会发生什么？这在我们的AST中是如何表示的？在AST浏览器中尝试以下代码片段:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="24cf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你对准词语和表达仍然感到陌生，那就多花点时间去探索它们。</p><blockquote class="ks kt ku"><p id="1fbb" class="ji jj kv jk b jl jm ii jn jo jp il jq kw js jt ju kx jw jx jy ky ka kb kc kd ha bi translated">当访问您的quasis中的值时，您将看到字符串可以是<em class="hh"> raw </em>或<em class="hh"> cooked。</em>这些值决定是否忽略或解释转义序列。Axel Rauschmayer在本文中对此做了更详细的介绍。</p></blockquote><p id="6f77" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">幸运的是，在编写ESLint规则时，我们不需要直接处理解析过程。我们已经覆盖了很多领域，因为对工具如何工作有一个高层次的理解，有助于以后更直观的开发体验。</p><blockquote class="ks kt ku"><p id="8d43" class="ji jj kv jk b jl jm ii jn jo jp il jq kw js jt ju kx jw jx jy ky ka kb kc kd ha bi translated">如果你有兴趣学习更多关于整个编译过程的知识，超级小编译器是一种非常有趣的方式，只需要几百行代码就可以构建你自己的JavaScript编译器。</p></blockquote><h1 id="1257" class="la lb hh bd lc ld le lf lg lh li lj lk in ll io lm iq ln ir lo it lp iu lq lr bi translated">Eslint规则是如何工作的？</h1><h1 id="2e11" class="la lb hh bd lc ld le lf lg lh li lj lk in ll io lm iq ln ir lo it lp iu lq lr bi translated">访问者模式</h1><p id="0bc9" class="pw-post-body-paragraph ji jj hh jk b jl ls ii jn jo lt il jq jr lu jt ju jv lv jx jy jz lw kb kc kd ha bi translated">幸运的是，在编写ESLint规则时，我们不需要进行任何转换，而是在代码中针对特定的节点类型编写检查。这些节点是我们代码的AST片段。</p><p id="b61a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一旦ESLint将您的代码解析成AST，它就会遍历您的树，<em class="kv">访问沿途的每个节点。对于那些熟悉编程设计模式的人来说，您可能会将这种模式称为<em class="kv"> visitor </em>模式。</em></p><p id="7c9a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">访问者模式是一种在不修改对象的情况下对对象运行新逻辑的方式。ESLint使用visitor模式将用于对您的代码进行检查的代码与AST分开。</p><p id="5f04" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们来看看<a class="ae kz" href="https://codesandbox.io/s/mystifying-morning-lk3xh?file=/src/index.js" rel="noopener ugc nofollow" target="_blank">访客模式在起作用</a>。</p><p id="eade" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">你可以看到，我用3个代码块实现了访问者:</p><ol class=""><li id="7e0d" class="ke kf hh jk b jl jm jo jp jr kg jv kh jz ki kd me kk kl km bi translated"><code class="du lz ma mb mc b">ast.js</code>:用于<code class="du lz ma mb mc b">const name = 'andrico'</code>的AST</li><li id="9024" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd me kk kl km bi translated"><code class="du lz ma mb mc b">traverser.js</code>:遍历AST节点的算法。</li><li id="a6ed" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd me kk kl km bi translated"><code class="du lz ma mb mc b">visitors.js</code>:一个方法对象，当遍历器到达其对应的节点时，给定的方法被触发。在我们的例子中，当遍历器到达一个<code class="du lz ma mb mc b">VariableDeclarator</code>节点时，它触发我们的访问者函数。</li></ol><p id="4b96" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们把<code class="du lz ma mb mc b">traverser</code>再分解一下:</p><p id="5973" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们从<code class="du lz ma mb mc b">index.js</code>开始，创建我们的<code class="du lz ma mb mc b">Traverser</code>类的一个实例，并通过我们的AST和我们的visitors。在幕后，我们的<code class="du lz ma mb mc b">Traverser</code>类将AST和visitors存储为实例变量，供我们以后使用。</p><p id="5689" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然后我们调用实例的<code class="du lz ma mb mc b">traverse</code>方法。如果您移动到<code class="du lz ma mb mc b">traverser.js</code>文件，您可以看到当我们调用<code class="du lz ma mb mc b">traverse</code>时会发生5件事情:</p><ol class=""><li id="a35d" class="ke kf hh jk b jl jm jo jp jr kg jv kh jz ki kd me kk kl km bi translated">节点是<code class="du lz ma mb mc b">null</code>，当我们手动调用没有任何参数的<code class="du lz ma mb mc b">traverse</code>方法时就会发生这种情况。当这种情况发生时，我们使用在类初始化期间存储的AST开始遍历函数。</li><li id="28f1" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd me kk kl km bi translated"><em class="kv">节点</em>的类型为<code class="du lz ma mb mc b">Program</code>，这将发生在我们的AST中的顶级节点上。当这种情况发生时，我们在子节点上递归调用遍历方法。</li><li id="b862" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd me kk kl km bi translated"><em class="kv">节点</em>的类型与访问者函数相匹配。当这种情况发生时，我们触发我们的访问者函数，并通过节点作为参数。</li><li id="ecf4" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd me kk kl km bi translated">节点有额外的声明，所以我们继续在这些子声明上调用我们的遍历函数。</li><li id="d2fc" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd me kk kl km bi translated">我们的<em class="kv">节点</em>不满足这些条件，这将导致我们的遍历方法退出。</li></ol><p id="f427" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在我们的<code class="du lz ma mb mc b">const name = 'andrico'</code>示例的上下文中，我们的遍历函数将继续遍历AST，直到到达<code class="du lz ma mb mc b">VariableDeclarator</code>，在那里它将调用我们在<code class="du lz ma mb mc b">visitors.js</code>中定义的访问者。在这个visitor中，我们检查值是否为<code class="du lz ma mb mc b">Andrico</code>,如果是，我们记录一条消息说这是一个无效的名称。</p><p id="8288" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在CodeSandbox中打开控制台，查看它的输出。尝试在您的访问者中更改支票，看看会发生什么。</p><p id="b190" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">好消息是ESLint为我们的JavaScript处理遍历逻辑。另一个好消息是，我们需要为解析后的HTML实现遍历逻辑😄</p><h1 id="b5f9" class="la lb hh bd lc ld le lf lg lh li lj lk in ll io lm iq ln ir lo it lp iu lq lr bi translated">Eslint规则看起来像什么？</h1><p id="f530" class="pw-post-body-paragraph ji jj hh jk b jl ls ii jn jo lt il jq jr lu jt ju jv lv jx jy jz lw kb kc kd ha bi translated">编写ESLint规则不需要任何花哨的东西，它只是一个普通的旧JavaScript对象。对象的顶层可以接收两个属性:<code class="du lz ma mb mc b">meta</code>和<code class="du lz ma mb mc b">create</code>。</p><p id="05e3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><code class="du lz ma mb mc b">meta</code>为规则提供元数据。</p><p id="5e79" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><code class="du lz ma mb mc b">create</code>属性是一个函数，它返回ESLint在访问每个节点时调用的visitors对象。这与codesandbox中的代码片段遵循相同的原则。与我们的codesandbox中的演示非常相似，每个访问者函数的名称就是我们想要访问的节点的名称。</p><p id="5b95" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">事实上，我们甚至可以重新利用前面的伪代码，并用特定于ESLint的样板文件来修饰它:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="867f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><code class="du lz ma mb mc b">create</code>函数还提供了一个上下文对象，它提供了一些额外的助手和关于当前规则的信息。我们现在最关心的助手是<code class="du lz ma mb mc b">report()</code>方法。每当我们希望在控制台或IDE中显示ESLint错误时，我们都可以调用<code class="du lz ma mb mc b">report</code>。</p><p id="42c9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae kz" href="http://Context.report" rel="noopener ugc nofollow" target="_blank"> Context.report </a>获取一个具有少量属性的对象，但我们最感兴趣的是以下内容:</p><ul class=""><li id="5b4c" class="ke kf hh jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated">消息:问题的描述</li><li id="2b6d" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated">节点:与问题相关的AST节点</li></ul><p id="ec14" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在继续之前，为什么不考虑调整上面的伪代码，以便在调用带标签的模板时显示ESLint错误，而模板文字没有内容，就像这样:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="ec06" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对JavaScript的AST、访问者模式和ESLint规则的剖析有了基本的了解之后，剩下要做的唯一一件事就是在开始创建规则之前，如何将模板字符串解析成HTML。</p><p id="cbc2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">要更深入地解读ESLint规则，没有比官方文件<a class="ae kz" href="https://eslint.org/docs/developer-guide/working-with-rules" rel="noopener ugc nofollow" target="_blank">更好的地方了。</a></p><h1 id="3553" class="la lb hh bd lc ld le lf lg lh li lj lk in ll io lm iq ln ir lo it lp iu lq lr bi translated">我们如何将模板转换成HTML？</h1><p id="7b81" class="pw-post-body-paragraph ji jj hh jk b jl ls ii jn jo lt il jq jr lu jt ju jv lv jx jy jz lw kb kc kd ha bi translated">当使用ESLint时，我们可以享受ESLint为我们提供的解析后的JavaScript AST。虽然ESLint不能解析我们的HTML，但我们可以使用像<code class="du lz ma mb mc b"><a class="ae kz" href="https://github.com/inikulin/parse5" rel="noopener ugc nofollow" target="_blank">parse5</a></code>这样的库将有效的HTML字符串解析成数据结构，这与我们的JavaScript AST没有什么不同。</p><p id="83ad" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们花了很多时间探索的AST explorer甚至有显示<a class="ae kz" href="https://astexplorer.net/#/1CHlCXc4n4" rel="noopener ugc nofollow" target="_blank">HTML AST</a>的设置。</p><p id="e2dc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因为我们的一个规则将阻止我们传递内联样式，所以让我们看看以下内容是如何被表示为AST的:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="f1bf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果我们深入AST并寻找我们的div，我们可以看到我们得到了一些有用的信息。最值得注意的是:</p><p id="48a4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">标记名</strong>:html元素的名称。(本例中为<code class="du lz ma mb mc b">div</code>)。</p><p id="1af0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">attrs :这是一个属性数组，表示为一个键值对。我们的div的<code class="du lz ma mb mc b">attrs</code>属性保存单个项目。物品有一个<code class="du lz ma mb mc b">style</code>的<code class="du lz ma mb mc b">name</code>和一个<code class="du lz ma mb mc b">display:inline;</code>的<code class="du lz ma mb mc b">value</code>。</p><p id="70df" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">利用这些信息，我们已经可以开始了解如何将我们所学的一切拼凑起来，创建我们的第一个lint规则。</p><p id="4f5c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是我们如何使用<code class="du lz ma mb mc b">parse5</code>库解析JavaScript模板:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="63a9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">感谢像parse 5和ESLint这样的工具，我们可以卸载大量复杂的处理，并专注于为我们的特定规则编写代码。</p><h1 id="2191" class="la lb hh bd lc ld le lf lg lh li lj lk in ll io lm iq ln ir lo it lp iu lq lr bi translated">更进一步</h1><p id="22b9" class="pw-post-body-paragraph ji jj hh jk b jl ls ii jn jo lt il jq jr lu jt ju jv lv jx jy jz lw kb kc kd ha bi translated">我们已经学习了ESLINT如何工作的基础知识，以及如何编写第一个规则来测试我们的代码是否符合简单的设计系统指南。在下一篇文章中，我们将更深入地探讨如何设置和构建更复杂的ESLint规则，并将我们所学到的一切应用到您自己的设计系统中。</p></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><p id="5f13" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="kv">原载于</em><a class="ae kz" href="https://backlight.dev/blog/best-practices-w-eslint-part-1" rel="noopener ugc nofollow" target="_blank"><em class="kv">https://back light . dev</em></a><em class="kv">撰写于2021年11月16日</em><a class="ae kz" href="https://twitter.com/AndricoKaroulla" rel="noopener ugc nofollow" target="_blank">@ AndricoKaroulla</a><em class="kv">。</em></p></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><p id="b331" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">资源:</p><p id="1cff" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">沙箱:</p><ul class=""><li id="5547" class="ke kf hh jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated"><a class="ae kz" href="https://codesandbox.io/s/mystifying-morning-lk3xh?file=/src/index.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/mystifying-morning-lk3xh?file=/src/index.js </a></li></ul><p id="b542" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">资源:</p><ul class=""><li id="a485" class="ke kf hh jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated"><a class="ae kz" href="https://github.com/lydell/js-tokens" rel="noopener ugc nofollow" target="_blank">js-令牌</a></li><li id="58a6" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated"><a class="ae kz" href="https://github.com/inikulin/parse5" rel="noopener ugc nofollow" target="_blank"> pars5 </a></li><li id="5c8b" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated"><a class="ae kz" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST浏览器</a></li><li id="4039" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated"><a class="ae kz" href="https://egghead.io/lessons/javascript-introduction-to-abstract-syntax-trees" rel="noopener ugc nofollow" target="_blank">抽象语法树肯特·多兹</a></li><li id="0e62" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated"><a class="ae kz" href="https://blog.sessionstack.com/how-javascript-works-parsing-abstract-syntax-trees-asts-5-tips-on-how-to-minimize-parse-time-abfcf7e8a0c8" rel="noopener ugc nofollow" target="_blank">JS中的解析和ASTs</a></li><li id="ad19" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated"><a class="ae kz" href="https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js" rel="noopener ugc nofollow" target="_blank">超级微型编译器</a></li><li id="aa24" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated"><a class="ae kz" href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/get-started/ch1.md" rel="noopener ugc nofollow" target="_blank">你还不知道JS</a>—第1章</li><li id="a867" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated"><a class="ae kz" href="https://eslint.org/docs/developer-guide/working-with-rules" rel="noopener ugc nofollow" target="_blank">使用规则— ESLint </a></li><li id="b951" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated"><a class="ae kz" href="https://eslint.org/docs/developer-guide/nodejs-api#ruletester" rel="noopener ugc nofollow" target="_blank">ESLint rule tester</a><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#interactive_content" rel="noopener ugc nofollow" target="_blank">T5】互动内容</a></li><li id="5e7b" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated"><a class="ae kz" href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md" rel="noopener ugc nofollow" target="_blank">巴别塔插件手册</a></li><li id="c23d" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated"><a class="ae kz" href="https://github.com/open-wc/open-wc/tree/master/packages/eslint-plugin-lit-a11y" rel="noopener ugc nofollow" target="_blank"> ESLint插件点亮A11y </a></li><li id="3254" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated"><a class="ae kz" href="https://github.com/43081j/eslint-plugin-lit" rel="noopener ugc nofollow" target="_blank"> ESLint插件点亮</a></li></ul></div></div>    
</body>
</html>