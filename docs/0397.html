<html>
<head>
<title>WindowInsets — listeners to layouts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WindowInsets —布局的监听器</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/windowinsets-listeners-to-layouts-8f9ccc8fa4d1?source=collection_archive---------1-----------------------#2019-04-12">https://medium.com/androiddevelopers/windowinsets-listeners-to-layouts-8f9ccc8fa4d1?source=collection_archive---------1-----------------------#2019-04-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/00852170c13aadc54ea355852ae5afbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UG3ipXuDiwcAmTIBwYvP0w.png"/></div></div></figure><div class=""/><div class=""><h2 id="55b2" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">将我们处理插入的地方移到我们的视图所在的地方，布局文件</h2></div><p id="d17e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你看过我的<a class="ae kd" href="https://chris.banes.dev/talks/2017/becoming-a-master-window-fitter-lon/" rel="noopener ugc nofollow" target="_blank">成为窗户装配工大师</a>的演讲，你就会知道处理窗户嵌入物可能是复杂的。最近，我一直在改进一些应用程序的系统栏操作，使它们能够在状态栏和导航栏后面绘图。我想出了一些让处理insets更容易的方法。</p><h1 id="4e2d" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">在导航栏后面绘图</h1><p id="7afd" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">在这篇文章的剩余部分，我们将通过一个简单的例子使用一个<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/com/google/android/material/bottomnavigation/BottomNavigationView" rel="noopener ugc nofollow" target="_blank">BottomNavigationView</a></code>，它被安排在屏幕的底部。它的实现非常简单，如下所示:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="43fc" class="ln kf hs le b fi lo lp l lq lr">&lt;BottomNavigationView<br/>    android:layout_height="wrap_content"<br/>    android:layout_width="match_parent" /&gt;</span></pre><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/5bacf227fbe546b6014c511b632dedda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eBoHflxjI7gL-Hhz.png"/></div></div></figure><p id="7053" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">默认情况下，您的活动内容将在系统提供的UI(导航条等)中进行布局，因此我们的视图与导航条齐平。我们的设计师已经决定，他们希望应用程序开始在导航栏后面绘图。为此，我们将使用适当的标志调用<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/android/view/View.html#setSystemUiVisibility(int)" rel="noopener ugc nofollow" target="_blank">setSystemUiVisibility()</a></code>:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="ac47" class="ln kf hs le b fi lo lp l lq lr">rootView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or<br/>        View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</span></pre><p id="1fe5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">最后，我们将更新我们的主题，以便我们有一个半透明的导航栏，带有黑色图标:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="656d" class="ln kf hs le b fi lo lp l lq lr">&lt;style name="AppTheme" parent="Theme.MaterialComponents.Light"&gt;<br/>    <em class="lt">&lt;!-- Set the navigation bar to 50% translucent white --&gt;</em><br/>    &lt;item name="android:navigationBarColor"&gt;#80FFFFFF&lt;/item&gt;<br/>    <em class="lt">&lt;!-- Since the nav bar is white, we will use dark icons --&gt;</em><br/>    &lt;item name="android:windowLightNavigationBar"&gt;true&lt;/item&gt;<br/>&lt;/style&gt;</span></pre><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/d3df98c7c98c11cd5e22f7e88fd29c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iXJpVAiLQYwGkjr2.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx">The view is being displayed behind the navigation bar</figcaption></figure><p id="5fb9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如你所见，这只是我们需要做的事情的开始。既然活动现在是在导航栏后面布局，我们的<code class="du lb lc ld le b">BottomNavigationView</code>也是。这意味着用户实际上不能点击任何导航项目。为了解决这个问题，我们需要处理系统调度的任何<a class="ae kd" href="https://developer.android.com/reference/android/view/WindowInsets" rel="noopener ugc nofollow" target="_blank"> WindowInsets </a>，并使用这些值对视图应用适当的填充。</p><h1 id="e267" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">通过填充处理插图</h1><p id="e462" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">处理<a class="ae kd" href="https://developer.android.com/reference/android/view/WindowInsets" rel="noopener ugc nofollow" target="_blank"> WindowInsets </a>的一个常用方法是给视图添加填充，这样它们的内容就不会显示在系统视图的后面。为此，我们可以在applywindowsetslistener上设置一个<a class="ae kd" href="https://developer.android.com/reference/android/view/View.OnApplyWindowInsetsListener" rel="noopener ugc nofollow" target="_blank">来向视图添加必要的底部填充，确保其内容不会被遮挡。</a></p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="543d" class="ln kf hs le b fi lo lp l lq lr">bottomNav.setOnApplyWindowInsetsListener { view, insets -&gt;<br/>    view.updatePadding(bottom = insets.systemWindowInsetBottom)<br/>    insets<br/>}</span></pre><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/7ee164c1067c393ed1e7917ded977e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EgsMo-kCmNBll7sb.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx">The view now has bottom padding which matches the navigation bar size</figcaption></figure><p id="7a8c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">好极了，我们现在已经正确处理了底部系统窗口插入。但是后来设计师决定在布局中也添加一些填充:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="55bc" class="ln kf hs le b fi lo lp l lq lr">&lt;BottomNavigationView<br/>    android:layout_height="wrap_content"<br/>    android:layout_width="match_parent"<br/>    <strong class="le ht">android:paddingVertical="24dp"</strong> /&gt;</span></pre><p id="be0a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><em class="lt">注意:我不建议在BottomNavigationView上使用24dp的垂直填充，我在这里使用一个大值只是为了让效果更明显。</em></p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/b7fb991810a7b2fcfaf833060082cd96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N94H4sV0C4IYGi62.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx">The view has the correct top padding, but the intended bottom padding isn’t there</figcaption></figure><p id="7928" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">嗯，那不对。你能看出问题吗？我们从<code class="du lb lc ld le b">OnApplyWindowInsetsListener</code>对<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/kotlin/androidx/core/view/package-summary#updatepadding" rel="noopener ugc nofollow" target="_blank">updatePadding()</a></code>的调用现在将从布局中清除预期的底部填充。</p><p id="3129" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">啊哈！让我们把当前的填充和插入加在一起:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="313f" class="ln kf hs le b fi lo lp l lq lr">bottomNav.setOnApplyWindowInsetsListener { view, insets -&gt;<br/>  view.updatePadding(<br/>    bottom = view.paddingBottom + insets.systemWindowInsetsBottom<br/>  )<br/>  insets<br/>}</span></pre><p id="55b8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们现在有了一个新问题。在一个视图的生命周期中，WindowInsets可以在<em class="lt">任何</em>时间被调度，也可以在<em class="lt">多次被调度。这意味着我们的新逻辑第一次会工作得很好，但是对于每个调度，我们将添加越来越多的底部填充。不是我们想要的。🤦</em></p><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ly"><img src="../Images/2af4f0860be8a005d57be559c089097e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l75ORIqElx8ESHDo.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx">The accumulated padding after 3 WindowInset dispatches</figcaption></figure><p id="0476" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我想到的解决方案是在膨胀后记录视图的填充值，然后引用这些值。示例:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="0ac4" class="ln kf hs le b fi lo lp l lq lr"><em class="lt">// Keep a record of the intended bottom padding of the view</em><br/><strong class="le ht">val</strong> bottomNavBottomPadding = bottomNav.paddingBottom<br/><br/>bottomNav.setOnApplyWindowInsetsListener { view, insets -&gt;<br/>  <em class="lt">// We've got some insets, set the bottom padding to be the</em><br/>  /<em class="lt">/ original value + the inset value</em><br/>  view.updatePadding(<br/>    bottom = bottomNavBottomPadding + insets.systemWindowInsetBottom<br/>  )<br/>  insets<br/>}</span></pre><figure class="lf lg lh li fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/24da38c419dd7d23808b9bd117241bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uoHifoxfNKOcgiB1.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx">Finally, what we intended</figcaption></figure><p id="9c32" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这非常有效，这意味着我们保持了布局中填充的意图，并且我们仍然根据需要插入视图。虽然为每个填充值保留对象级属性非常麻烦，但我们可以做得更好…🤔</p><h1 id="f407" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">doOnApplyWindowInsets</h1><p id="4968" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">输入我新的<code class="du lb lc ld le b">doOnApplyWindowInsets()</code>扩展方法。这是一个围绕<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/android/view/View.html#setOnApplyWindowInsetsListener(android.view.View.OnApplyWindowInsetsListener)" rel="noopener ugc nofollow" target="_blank">setOnApplyWindowInsetsListener()</a></code>的包装器，它概括了上面的模式:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="f0a7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当我们需要一个视图来处理插入时，我们现在可以做以下事情:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="e54f" class="ln kf hs le b fi lo lp l lq lr">bottomNav.doOnApplyWindowInsets { view, insets, padding -&gt;<br/>    // padding contains the original padding values after inflation<br/>    view.updatePadding(<br/>        bottom = padding.bottom + insets.systemWindowInsetBottom<br/>    )<br/>}</span></pre><p id="d233" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">好多了！😏</p><h1 id="f0db" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">requestApplyInsetsWhenAttached()</h1><p id="731c" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">你可能已经注意到了上面的<code class="du lb lc ld le b">requestApplyInsetsWhenAttached()</code>。这并不是绝对必要的，但确实解决了WindowInsets调度方式的限制。如果一个视图调用了<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/android/view/View.html#requestApplyInsets()" rel="noopener ugc nofollow" target="_blank">requestApplyInsets()</a></code>，而它并没有被附加到视图层次结构中，那么这个调用将被丢弃并被忽略。</p><p id="b1e4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是在<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/androidx/fragment/app/Fragment.html#onCreateView(android.view.LayoutInflater,%20android.view.ViewGroup,%20android.os.Bundle)" rel="noopener ugc nofollow" target="_blank">Fragment.onCreateView()</a></code>中创建视图时的常见场景。解决方法是确保简单地调用<code class="du lb lc ld le b"><a class="ae kd" href="https://developer.android.com/reference/androidx/fragment/app/Fragment.html#onStart()" rel="noopener ugc nofollow" target="_blank">onStart()</a></code>中的方法，或者使用一个监听器请求附加的insets。以下扩展函数处理这两种情况:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h1 id="7802" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">用活页夹把它包起来</h1><p id="f738" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">至此，我们已经大大简化了如何处理窗口插入。我们实际上在一些即将到来的应用中使用了这个功能，包括一个即将到来的会议😉。尽管如此，它仍然有一些缺点:</p><ul class=""><li id="e90a" class="mb mc hs jj b jk jl jn jo jq md ju me jy mf kc mg mh mi mj bi translated">逻辑远离我们的布局，这意味着它很容易被遗忘。</li><li id="2875" class="mb mc hs jj b jk mk jn ml jq mm ju mn jy mo kc mg mh mi mj bi translated">我们可能需要在很多地方使用它，导致大量几乎相同的副本遍布整个应用程序。</li></ul><p id="f718" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我知道我们可以做得更好。</p><p id="e80d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">到目前为止，整篇文章只关注代码，以及通过设置监听器来处理insets。我们在这里讨论的是视图，所以在理想的情况下，我们应该声明在布局文件中处理插入的意图。</p><p id="d602" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">输入<a class="ae kd" href="https://developer.android.com/topic/libraries/data-binding/binding-adapters" rel="noopener ugc nofollow" target="_blank">数据绑定适配器</a>！如果您以前从未使用过它们，它们让我们将代码映射到布局属性(当您使用数据绑定时)。你可以在这里了解更多信息:</p><div class="hg hh ez fb hi mp"><a rel="noopener follow" target="_blank" href="/androiddevelopers/android-data-binding-custom-setters-55a25a7aea47"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd ht fi z dy mu ea eb mv ed ef hr bi translated">Android数据绑定:自定义设置器</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">让数据绑定做你想做的</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">medium.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ho mp"/></div></div></a></div><p id="9841" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因此，让我们创建一个属性来完成这项工作:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="20b7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在我们的布局中，我们可以简单地使用新的<code class="du lb lc ld le b">paddingBottomSystemWindowInsets</code>属性，它会自动更新任何插入的内容。</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="b4cd" class="ln kf hs le b fi lo lp l lq lr">&lt;BottomNavigationView<br/>    android:layout_height="wrap_content"<br/>    android:layout_width="match_parent"<br/>    android:paddingVertical="24dp"<br/>    <strong class="le ht">app:paddingBottomSystemWindowInsets="@{ true }"</strong> /&gt;</span></pre><p id="ac4b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">希望你能看到与单独使用<code class="du lb lc ld le b">OnApplyWindowListener</code>相比，这是多么符合人体工程学和易于使用。🌠</p><p id="9efb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">但是等等，绑定适配器被硬编码为只设置底部维度。如果我们还需要处理顶部的插入怎么办？还是左边？还是对的？幸运的是，绑定适配器让我们很好地将所有维度的模式一般化:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="7ac7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这里我们声明了一个具有多个属性的适配器，每个属性都映射到相关的方法参数。需要注意的一点是<code class="du lb lc ld le b">requireAll = false</code>的用法，这意味着适配器可以处理被设置属性的任何组合。这意味着我们可以执行以下操作，例如，设置左侧和底部:</p><pre class="lf lg lh li fd lj le lk ll aw lm bi"><span id="98dc" class="ln kf hs le b fi lo lp l lq lr">&lt;BottomNavigationView<br/>    android:layout_height="wrap_content"<br/>    android:layout_width="match_parent"<br/>    android:paddingVertical="24dp"<br/>    <strong class="le ht">app:paddingBottomSystemWindowInsets="@{ true }"<br/>    app:paddingLeftSystemWindowInsets="@{ true }"</strong> /&gt;</span></pre><p id="9cad" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">易用性级别:💯</p><h2 id="dfc2" class="ln kf hs bd kg ne nf ng kk nh ni nj ko jq nk nl kq ju nm nn ks jy no np ku nq bi translated">android:fitSystemWindows</h2><p id="5bbd" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">你可能读过这篇文章，并且想“<em class="lt">为什么他没有提到fitSystemWindows属性？</em>”。其原因是因为属性带来的功能性并不是<em class="lt">通常是</em>我们想要的。</p><p id="3d9b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你正在使用<a class="ae kd" href="https://developer.android.com/reference/com/google/android/material/appbar/AppBarLayout.html" rel="noopener ugc nofollow" target="_blank"> AppBarLayout </a>、<a class="ae kd" href="https://developer.android.com/reference/androidx/coordinatorlayout/widget/CoordinatorLayout.html" rel="noopener ugc nofollow" target="_blank"> CoordinatorLayout </a>、<a class="ae kd" href="https://developer.android.com/reference/androidx/drawerlayout/widget/DrawerLayout.html" rel="noopener ugc nofollow" target="_blank"> DrawerLayout </a>和好友，那么可以使用它。构建这些视图是为了识别属性，并以与这些视图相关的自以为是的方式应用窗口插入。</p><p id="821d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du lb lc ld le b">android:fitSystemWindows</code>的默认视图实现意味着使用insets来填充每个维度，但对于上面的例子是不可行的。如需了解更多信息，请参见这篇仍然很有意义的博文:</p><div class="hg hh ez fb hi mp"><a rel="noopener follow" target="_blank" href="/androiddevelopers/why-would-i-want-to-fitssystemwindows-4e26d9ce1eec"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd ht fi z dy mu ea eb mv ed ef hr bi translated">我为什么要安装系统窗口？</h2><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">medium.com</p></div></div><div class="my l"><div class="nr l na nb nc my nd ho mp"/></div></div></a></div><h1 id="beba" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">人机工程学FTW</h1><p id="7af6" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">唷，这是一篇很长的帖子！除了我们让<code class="du lb lc ld le b">WindowInsets</code>更容易处理之外，希望它展示了扩展函数、lambdas和绑定适配器等特性如何让任何API更容易使用。</p></div></div>    
</body>
</html>