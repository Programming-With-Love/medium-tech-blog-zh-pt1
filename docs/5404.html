<html>
<head>
<title>Shredding and Querying with Oracle Offline Persistence in JET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JET中的Oracle离线持久化分解和查询</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/shredding-and-querying-with-oracle-offline-persistence-in-jet-8b67fe47c86?source=collection_archive---------1-----------------------#2018-02-17">https://medium.com/oracledevs/shredding-and-querying-with-oracle-offline-persistence-in-jet-8b67fe47c86?source=collection_archive---------1-----------------------#2018-02-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="94f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我觉得离线功能话题应该会成为未来的一个趋势。Oracle已经提供了离线解决方案——Oracle离线持久性工具包，这真是太好了。这是我的第二篇关于离线支持的帖子，请阅读上一篇帖子— <a class="ae jc" href="http://andrejusb.blogspot.lt/2018/01/oracle-offline-persistence-toolkit.html" rel="noopener ugc nofollow" target="_blank"> Oracle离线持久性工具包JET的简单GET响应示例</a>。我已经用示例应用程序测试并解释了它如何处理简单的离线获取响应。今天，我想更进一步，看看如何过滤离线数据——离线粉碎和查询。</p><p id="dabb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">示例应用程序正在获取雇员列表——获取雇员按钮。它显示在线/离线状态—参见右上角的图标。我们在线，并且持久性工具包缓存了GET响应:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/a5d13f134f7a78a50abcd9d379179d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Quuc1OFWEaiLR3CDTVW86g.png"/></div></div></figure><p id="5d9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以很容易地测试离线行为——这可以通过Chrome开发者工具来完成——打开离线模式。顺便说一下，查看GET请求的<em class="jp">发起方</em>字段——它来自Oracle离线持久性工具包。正如我在之前的<a class="ae jc" href="http://andrejusb.blogspot.lt/2018/01/oracle-offline-persistence-toolkit.html" rel="noopener ugc nofollow" target="_blank">帖子</a>中提到的——一旦启用了持久性工具包，所有REST调用都将通过工具包，这就是它能够缓存响应数据的方式:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jq"><img src="../Images/ac5b42df4044caaa1222f23ae11e71d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*APAUz9FxjULUNgkU4b6yZw.png"/></div></div></figure><p id="f858" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">离线时，单击Get Employees按钮—您应该会看到从缓存返回的数据。您注意到了吗——右上角的图标被更改为表示我们处于离线状态:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/1768caf64dcbd531da1f7cbf87f3b815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K69A1I4xtVnWqxK0kGngDg.png"/></div></div></figure><p id="97c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好了，现在我们来看看粉碎机制是如何工作的(更多信息请阅读<a class="ae jc" href="https://github.com/oracle/offline-persistence-toolkit" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)。离线时，我们可以搜索缓存数据子集。<em class="jp">通过名称</em>进行搜索，它从缓存条目中获取<em class="jp"> Lex </em>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jq"><img src="../Images/36bdb029347f9c27fa20d8812a23eafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kN-arFHnQlkeya7u_VxO1A.png"/></div></div></figure><p id="b9d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">切换到联机状态，再次调用相同的操作，但使用不同的名称— REST调用将按预期对后端服务器进行调用。同样，它对JET开发人员是透明的，无需担心应用程序状态是在线还是离线，在两种情况下都会执行相同的REST请求:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jr"><img src="../Images/4fd2c8a678f70c694a3da3a572687729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3D1qynxWpKc17sNvEKc9g.png"/></div></div></figure><p id="ed48" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们快速看一下实现部分(完整的例子可以在我的<a class="ae jc" href="https://github.com/abaranovskis-redsamurai/persistencejetapp" rel="noopener ugc nofollow" target="_blank"> GitHub </a>库中找到)。</p><p id="e892" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在线/离线状态图标由可观察变量控制:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es js"><img src="../Images/330bf7a6b0c49225959c493f983fde91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SP7VbEYyFnN0usKw9SMl4w.png"/></div></div></figure><p id="c7b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">确定在线/离线状态非常简单。我们需要为联机/脱机添加事件监听器，并相应地重置可观察变量:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jt"><img src="../Images/5dd5800fdf571470abe99ba93730369c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1IAOqTAWpnQCUphaULV_9A.png"/></div></div></figure><p id="ea73" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">持久性工具包支持<em class="jp">简单</em>和<em class="jp"> Oracle </em>粉碎/查询处理程序。我使用ADF BC REST作为后端，所以我选择oracleRestJsonShredding和oracleRestQueryHandler。Oracle shredder理解ADF BC REST返回的REST结构。Oracle查询处理程序支持ADF BC REST脱机过滤的过滤参数—这允许联机和脱机使用相同的查询格式。我很高兴看到Oracle查询处理程序明确支持ADF BC REST — <a class="ae jc" href="https://oracle.github.io/offline-persistence-toolkit/queryHandlers.html" rel="noopener ugc nofollow" target="_blank">查询处理程序</a>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/1c300f5b121c35f5aa2e6aaa0a2a336e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4RNT4g-G717vdlGYtr3-Cw.png"/></div></div></figure><p id="3c95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在线和离线执行带有过滤的相同REST调用:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jv"><img src="../Images/a84218462fabe11319f49f8ab5674d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ncz5tIhxLIA1cGhCueZN-Q.png"/></div></div></figure></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><p id="53a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jp">原载于2018年2月17日</em><a class="ae jc" href="https://andrejusb.blogspot.lt/2018/02/shredding-and-querying-with-oracle.html" rel="noopener ugc nofollow" target="_blank"><em class="jp">andrejusb.blogspot.com</em></a><em class="jp">。</em></p></div></div>    
</body>
</html>