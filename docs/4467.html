<html>
<head>
<title>The True Meaning of Line Coverage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线覆盖的真正含义</h1>
<blockquote>原文：<a href="https://medium.com/compendium/the-true-meaning-of-line-coverage-9cabd20cfad?source=collection_archive---------6-----------------------#2018-05-28">https://medium.com/compendium/the-true-meaning-of-line-coverage-9cabd20cfad?source=collection_archive---------6-----------------------#2018-05-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c6a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">人们可以花几个小时甚至几天来讨论一个人真正需要多少测试覆盖率。应该是60%，还是更接近80%？还是应该一直是100%？但是，也许最好研究一下术语“行覆盖”的真正含义，以及它告诉我们关于系统源代码和单元测试的什么。</p><p id="ca95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">行覆盖率通常是这样衡量的:所有的自动化单元测试都是针对源代码运行的，在测试运行过程中至少执行一次的每一行源代码都算作“覆盖”。然后将这个数字除以源代码的可执行行数，得到一个更接近100%而不是0%的百分比。对于分支覆盖率，也做了同样的练习，但是计算分支而不是代码行。</p><p id="da1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种测量测试覆盖率的方法有几个问题。例如，并不是所有的工具都验证单元测试以断言或者期望抛出异常来结束。除了一些特殊的情况，没有断言，就没有真正测试过任何东西，单元测试期间执行的行和分支不应该被算作被覆盖。</p><p id="deb1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，即使存在断言，断言也不总是验证与被测试的源代码有关的东西。也许断言只是验证了在源代码运行之后，2 + 2仍然是4。因此，仅凭断言的存在并不足以得出单元测试所覆盖的行确实已经被测试的结论。关于这些线和分支，我们唯一知道的是它们没有阻止单元测试成功完成。这与正确测试或正确完全不同。</p><p id="8fbb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让它变得清晰:如果一个系统有70%的测试覆盖率，那就意味着</p><ul class=""><li id="3a64" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">30%的源代码根本没有被单元测试执行，</li><li id="e291" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">70%的源代码没有阻止单元测试成功运行，</li><li id="1a02" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">我们真的不知道单元测试是否有任何意义。</li></ul><p id="bd5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，如果开发人员愿意编写覆盖70%源代码的单元测试，我们从经验中知道单元测试很有可能做一些有意义的事情。最有可能的是，源代码比没有这种测试覆盖率的项目要好得多。对少量单元测试的快速检查通常足以证实这一点，或者揭示相反的情况。</p><p id="b8ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，如果您想要更有力的证据来证明源代码确实被单元测试测试过，您应该使用单元测试及其测试覆盖率之外的其他技术和方法。突变测试就是这样一种技术，而且是一种非常强大的技术。当然，这也不完全可靠，因为最终，一切都取决于你的项目团队中是否有好的开发人员。但是对于懒惰的开发人员来说，编写毫无意义的单元测试只是为了杀死更多的变种人，这是太多的工作了，而且通常也太困难了。这是我所知道的确保单元测试高质量的最好保证之一。</p></div></div>    
</body>
</html>