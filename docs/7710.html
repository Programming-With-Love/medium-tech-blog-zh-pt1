<html>
<head>
<title>Structure &amp; Attribute Based Graph Partitioning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于结构和属性的图划分</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/structure-attribute-based-graph-partitioning-9c3fabf8cc12?source=collection_archive---------1-----------------------#2018-05-18">https://medium.com/walmartglobaltech/structure-attribute-based-graph-partitioning-9c3fabf8cc12?source=collection_archive---------1-----------------------#2018-05-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="b142" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><strong class="ak">应用于沃尔玛分类分析</strong></h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/a9d7f09f0eb8b7f145b7a3cc91055ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3jYOTQNpgT0HQhJ6tbx9Jg.png"/></div></div></figure><p id="73a0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">沃尔玛为其顾客提供了种类繁多的产品。对于许多分析来说，将产品归入相似的可替代组比单独考虑它们更有用。一个这样的分析结果是一个树状结构，称为客户行为树(以下简称为CBT ),以项目作为叶节点。“行为”在这里意味着分组不是基于明确的项目特征，而是基于顾客显示的偏好的隐含的项目相似性。树表示这样一种结构，其中同一父节点的子节点比不同父节点的子节点更具可替换性(最好用树状图表示)。该CBT可作为所有进一步分类和定价决策的有用分组。</p><p id="3757" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然对数百万件商品进行分类本身就具有挑战性，但由于沃尔玛在美国有4500多家商店，90多个部门，总计约7200个类别，为数百万顾客提供服务，因此复杂性成倍增加。除了沃尔玛的庞大规模，一些类别，特别是普通商品类别，没有足够的给定家庭的重复购买信息，导致市场购物篮分析和关联规则的可用性受到限制。毕竟，人们不会像购买酸奶或罐装豆子那样频繁地购买锤子或婴儿家具。</p><p id="032c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">班加罗尔沃尔玛实验室的分类分析团队通过将销售点(PoS、交易)数据建模为适当的图形，并使用图形分区方法对商品进行聚类，解决了这一问题。对于给定的类别，使用过去几年所有商店中所有商品的交易信息创建结构图。每个物品被认为是一个顶点，当且仅当一对物品在所考虑的时期内至少被一个家庭购买过一次时，图中的一对物品之间才有一条边。每个边被赋予一个适当的权重(仅从销售数据的角度计算)，该权重可以被认为是可替代性的度量。</p><p id="d50a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这篇文章将讨论划分聚类图的过程。但是，在此之前，先给出图划分方法的高级概述。</p><h1 id="3c93" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">理解图表</h1><p id="6534" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">图形是一种数学结构，表示为由“边”(线)连接的一组“顶点”(节点)，表示多个对象(节点)之间的关系。一个图可以是有向的或无向的，也可以是加权的或未加权的。</p><p id="8417" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">图划分问题旨在将给定的图划分成更小的组件，具有特定的属性(通常是相似的子图)。换句话说，图划分的目标是基于各种标准，如顶点连通性或邻域相似性，将大型图中的顶点划分成<strong class="jk hi">簇</strong>。</p><blockquote class="lb"><p id="2b51" class="lc ld hh bd le lf lg lh li lj lk kd dx translated"><strong class="ak"/>聚类的基本原理:</p><p id="7b1f" class="lc ld hh bd le lf lg lh li lj lk kd dx translated">同一组(或群)中的对象比其他组(或群)中的对象彼此更相似(在某种意义上)</p></blockquote><p id="0eec" class="pw-post-body-paragraph ji jj hh jk b jl ll ii jn jo lm il jq jr ln jt ju jv lo jx jy jz lp kb kc kd ha bi translated">类似地，一个图的好的划分被定义为这样一个图，其中在分离的部分之间运行的边的数量很少。一种流行的分区算法是Google的PageRank算法。</p><p id="0467" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">通常，图划分问题属于NP难问题的范畴。这些问题的解决方案通常是使用试探法和近似算法得出的。</p><h1 id="9966" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">图形划分</h1><p id="1f62" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">结构图划分的主旨是将一个图G = (V，E)划分成<em class="lq"> k </em>个子图，使得每个子图尽可能紧密连接，并且穿过划分的边的总权重最小。</p><p id="c823" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">由于这是一个NP难问题，实际的解决方案是基于启发式的。有两大类解决方案，本地和全球。</p><p id="1844" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">类似于贪婪算法的局部解决方案虽然更快，但严重依赖于起点。全局解决方案(主要基于最短路径)依赖于整个图的属性，因此对于大型和/或密集的图来说往往会变慢。</p><p id="487a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">贪婪算法从随机顶点开始，在每一步贪婪地将具有最大边权重的边合并到它的路径中，从而遍历图；而全局解决方案总是查看任意两个顶点之间的最短路径，并使用该信息对图形进行聚类。</p><p id="805a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">所有上述方法只考虑图的结构，因此假设顶点的特征是一致的。顶点的特征将取决于数据的明确性质，在该数据上创建图形。在沃尔玛的用例中，由于顶点是物品，它们的特征会强烈地依赖于物品的特征，比如属性(品牌、颜色、尺寸、材料、耐用性等)。)、价格、可用性、忠诚度等。基于属性的图划分的目标是将图G = (V，E)划分为子图，使得给定子图中的所有顶点具有相似的属性并且不同于另一个子图的顶点。就我们的目的而言，理想情况下，我们希望拥有具有非常相似的项目属性的项目子组，这样它们就可以被视为替代品。</p><h1 id="ea96" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">计划方法</h1><p id="2e1a" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">为什么我们不把这两种算法的优点结合起来，尝试根据图的结构和顶点属性来划分图呢？通过这种方式，我们可以从父图中获得子图，每个子图都由属性相似且密集连接的顶点组成。</p><h2 id="0ebe" class="lr kf hh bd kg ls lt lu kk lv lw lx ko jr ly lz kq jv ma mb ks jz mc md ku me bi translated"><strong class="ak">高层算法解释如下:</strong></h2><h1 id="09fe" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated"><strong class="ak">算法</strong></h1><p id="3c25" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated"><strong class="jk hi">第一步:定义父图G = (V，E，W) </strong></p><p id="b87d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">考虑一个加权图G = (V，E，W)，</p><p id="6e71" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在哪里</p><p id="e685" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">v:顶点集</p><p id="e8d2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">边缘集</p><p id="1f3a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">w:边权重矩阵(归结为</p><p id="075c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对于未加权或均匀加权的图)。</p><p id="52f4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lq">例如，考虑以下图形，具有6个顶点、8条边和边权重Wij: </em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mf"><img src="../Images/bf02044d9bcbc8f329617732af121021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gPLZHEYKLZRHtllL0jlobg.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx">Figure 1 : a graph with 6 vertices, 8 edges and edge weights Wij</figcaption></figure><p id="bed0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">第二步:定义属性图G_a = (V，E，W，V_a，W_a) </strong></p><p id="49c8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在上面定义的图G中，V中的每个顶点都具有关于<em class="lq"> n </em>属性的信息，其中第I个属性具有<em class="lq"> k_i </em>级别，<em class="lq"> i </em> in 1，2，…，n</p><p id="fbfc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">还知道每个属性的相对重要性(属性权重)，定义为1，2，…，n中的<em class="lq"> a_i </em>，<em class="lq"> i </em>。</p><p id="d424" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里，V_a是顶点的集合，用它们相应的属性值来标记，W_a是属性权重的集合。</p><p id="02e9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lq">例如，考虑上面提到的具有n = 2个属性的图的属性信息，即属性A(具有2个级别和属性权重</em> <strong class="jk hi"> <em class="lq"> a </em> </strong> <em class="lq">)和属性B(具有3个级别和属性权重</em> <strong class="jk hi"> <em class="lq"> b </em> </strong> <em class="lq">)。</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mk"><img src="../Images/e40b32825cd49df384e85b512be1b17d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgoREmKdj24JObRh3h0sYw.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx">Attribute information as per above mentioned example</figcaption></figure><p id="ff9f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lq">为了重新绘制上面的图形以及属性信息，我们有如下的，其中每个顶点都用它们的属性值标记:</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ml"><img src="../Images/b3539fabcab289ca30f17d7208d87d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZv-X-n43mDdiZYbpKIr3g.png"/></div></div></figure><p id="6bc4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">第三步:将父图G与属性图G_a叠加，得到G*_a = (V*_a，E*_a，W*_a) </strong></p><p id="e929" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，我们将不得不图形化地吸收来自</p><p id="ae44" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了做到这一点，我们引入了<em class="lq">k _ 1</em>+<em class="lq">k _ 2</em>+…+<em class="lq">k _ n</em>个新顶点(以下称为属性顶点)，每个顶点对应于所有属性的不同级别。</p><p id="d2d4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">所以，V * _ a = V U {属性顶点}</p><p id="94e4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从每个属性顶点，定义到G的每个原始顶点的边(此后称为结构顶点)，如果所关心的顶点属于各自的属性(这样的边此后称为属性边)。因此，每个结构顶点将正好有<em class="lq"> n个</em>属性边。</p><p id="20ae" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">所以，E * _ a = E U {属性边}</p><p id="2438" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如此定义的每个属性边的边权重将按照G_a中定义的属性权重。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mm"><img src="../Images/92e90a5cab51eba9619f8d7118a023a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*GfGATrWqUQpJy8Wsy1eSHw.png"/></div></figure><p id="9d85" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lq">使用上述例子形成的G*_a的图示将是:</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mn"><img src="../Images/769164545b2c145b9c51c68ea4dadc19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hxcQ6o73GIpcqd5zR-1RDw.png"/></div></div></figure><p id="7422" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">步骤4:将G*_a分割成子图</strong></p><p id="80c7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">考虑G*_a上的随机行走，其中转移概率矩阵定义为<strong class="jk hi"> P =((p_ij)) </strong>，</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mo"><img src="../Images/e0b00de1f29c9f7ad68b36faa8ac624a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Ko17raoiR0UQz4t_SWUaQ.png"/></div></div></figure><p id="8bf7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">定义统一邻域矩阵<strong class="jk hi"> R = ((r_ij)) </strong>，其中<strong class="jk hi"> r_ij </strong>是从顶点<strong class="jk hi"> <em class="lq"> i </em> </strong>到顶点<strong class="jk hi"> <em class="lq"> j </em> </strong>的概率。</p><p id="3db4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">定义，</p><p id="194c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lq"> c </em> =随机漫步重启概率(用户定义)</p><p id="0bdf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lq"> L </em> =随机漫步的最大可能长度(用户定义，越大越好)</p><p id="1050" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然后，</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mp"><img src="../Images/7283e24953e763d088123da61c970f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*jS20wdaX91oIGFDJoIceWw.png"/></div></figure><p id="1029" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在某种程度上，<strong class="jk hi"> R </strong>是距离矩阵的反义词。为了从<strong class="jk hi"> R </strong>中创建距离矩阵，可以如下创建距离矩阵<strong class="jk hi"> R* </strong>:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mq"><img src="../Images/6a99f46f4bb4033ea81c6d1ef9d16c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6APFCF66Ljvk6dzZ3YfVSQ.png"/></div></div></figure><p id="8cf6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，可以在结构顶点上使用常见的聚类方法，如<strong class="jk hi"> k-medoids、k-means </strong>或任何其他层次聚类技术<strong class="jk hi">，以获得划分的子图。</strong></p><h1 id="d3d8" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">在一个例子上实现所提出的算法</h1><p id="bb95" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">上述算法在<strong class="jk hi"> <em class="lq">图1 </em> </strong>中提到的图上演示。我们从U(10，50)分布中随机生成了结构边权重，从U(80，100)分布中随机生成了属性权重。</p><p id="ccdd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在获得的随机样本中，</p><p id="6845" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"><em class="lq">w _ 12</em></strong>= 26.60983</p><p id="6832" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"><em class="lq">w _ 13</em></strong>= 27.13616</p><p id="2801" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"><em class="lq">w _ 14</em></strong>= 13.86644</p><p id="57de" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"><em class="lq">w _ 23</em></strong>= 15.31082</p><p id="7384" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"><em class="lq">w _ 25</em></strong>= 37.38426</p><p id="186b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"><em class="lq">w _ 46</em></strong>= 49.21425</p><p id="cbaa" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"><em class="lq">w _ 45</em></strong>= 37.61334</p><p id="667d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"><em class="lq">w _ 56</em></strong>= 47.53184</p><p id="2d25" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">和</p><p id="e6dc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="lq">一</em> </strong> = 81.42791</p><p id="86d4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="lq"> b </em> </strong> = 87.21310</p><p id="8496" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">获得的转移概率矩阵(<strong class="jk hi"> P </strong>):</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mr"><img src="../Images/0aa2083f3398fdcce250fb410d8754be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lkD2iezBMpmcFZtTUum9yg.png"/></div></div></figure><p id="c3ca" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lq"> c </em> = 0.01、<em class="lq"> L </em> = 200的均匀邻域矩阵(<strong class="jk hi"> R </strong>)为:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ms"><img src="../Images/a0c3a227d1836b209a205dba9fe20503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W75O7kZWsxAPl9DjMMjiOQ.png"/></div></div></figure><p id="1c90" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在对<strong class="jk hi"> R* </strong> = ((1/ <strong class="jk hi"> r_ij </strong>))的结构顶点子矩阵应用k-means和k-medoids之后，我们获得了最佳的聚类数为2，如下所示。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mt"><img src="../Images/7b703ef75632b4880d2659371a2035b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTh7zb4B3XnlOOdlFpWpEw.png"/></div></div></figure><p id="bd93" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对于沃尔玛中的商品分组问题，我们进一步将商品属性的味道注入到前面定义的结构图中，通过用对应的商品属性标记图的每个顶点，从而返回关于沃尔玛交易数据的包含属性的结构图。此后，在其上运行前述的图划分算法，以获得期望的CBT。</p><p id="da50" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这种项目分组在评估可替代组内的项目忠诚度、做出项目删除决策、理解现有项目缺货或添加新项目时项目间的客户需求转移、或理解相关项目的价格弹性方面具有重要作用。</p></div></div>    
</body>
</html>