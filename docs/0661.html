<html>
<head>
<title>Do more with your widget in Android 12!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android 12中使用您的widget做更多事情！</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/do-more-with-your-widget-in-android-12-e33f12710532?source=collection_archive---------0-----------------------#2021-08-27">https://medium.com/androiddevelopers/do-more-with-your-widget-in-android-12-e33f12710532?source=collection_archive---------0-----------------------#2021-08-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/211e89af65620c059b762bf24f9cc777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n2yzxtqyowiF228QBQwugA.png"/></div></div></figure><div class=""/><h1 id="899e" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">在Android 12中使用您的Widget做更多事情！</h1><p id="e188" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这篇文章是我写的关于为Android 12更新你的小部件的系列文章的第二篇。在<a class="ae kl" rel="noopener" href="/androiddevelopers/updating-your-widget-for-android-12-92e7de87424c">最后一部分</a>中，我们探索了一些简单的方法来实现对应用程序用户高度可见的可视化更新。在这一部分，我们将看看一些更高级的功能，使您的小部件更具交互性，更易于配置，并在Android 12上提供更好的UI体验。</p><h1 id="ae8e" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><strong class="ak">更简单的配置</strong></h1><p id="e398" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在Android 12之前，重新配置小部件意味着用户必须删除现有的小部件，然后用新的配置重新添加。Android 12在几个方面改进了小部件的配置方式，并帮助用户更容易地个性化小部件。</p><h2 id="d06b" class="km iq hs bd ir kn ko kp iv kq kr ks iz jy kt ku jd kc kv kw jh kg kx ky jl kz bi translated">允许用户重新配置放置的小部件</h2><p id="fc75" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">可重新配置的小部件允许用户将小部件定制为他们想要的设置。使用Android 12，他们将不再需要删除和重新添加小工具来调整这些设置。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div class="er es la"><img src="../Images/bcf3c9e5fce41df211f27a45ca3af199.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*evkjdvJSF4d-8vwh2ystbA.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx">You can adjust the size and reconfigure the settings of the widget</figcaption></figure><p id="c975" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">要启用此功能，请将<code class="du lo lp lq lr b">appwidget-provider</code>中的<code class="du lo lp lq lr b">widgetFeatures</code>属性设置为<code class="du lo lp lq lr b">reconfigurable</code>。</p><pre class="lb lc ld le fd ls lr lt lu aw lv bi"><span id="193f" class="km iq hs lr b fi lw lx l ly lz"><a class="ae kl" href="https://github.com/android/user-interface-samples/blob/main/AppWidget/app/src/main/res/xml/app_widget_info_checkbox_list.xml" rel="noopener ugc nofollow" target="_blank"><em class="ma">xml/app_widget_info_checkbox_list.xml</em></a><em class="ma"><br/></em>&lt;!-- Copyright 2019 Google LLC.<br/>SPDX-License-Identifier: Apache-2.0 --&gt;</span><span id="856c" class="km iq hs lr b fi mb lx l ly lz">&lt;appwidget-provider<br/>    android:configure="com.example.android.appwidget.ListWidgetConfigureActivity"<br/>    android:widgetFeatures="<strong class="lr ht">reconfigurable</strong>"<br/>    ... /&gt;</span></pre><h2 id="c1e5" class="km iq hs bd ir kn ko kp iv kq kr ks iz jy kt ku jd kc kv kw jh kg kx ky jl kz bi translated">默认配置</h2><p id="8bfe" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">如果您的小部件可以依赖默认设置，您可以跳过启动初始配置活动，在Android 12中使用默认配置设置小部件。</p><p id="8548" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">让我们看一下样例小部件，看看它是如何工作的。在这个用例中，我们希望用户能够在两种不同的小部件布局之间进行选择，杂货列表和待办事项列表。我们希望使用杂货列表作为默认，这样用户就不需要经历配置步骤，除非他们想切换到待办事项列表。</p><p id="235d" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">要实现这个用例，您可以存储用户的选择，并在没有预先选择的情况下返回默认的杂货店列表。</p><pre class="lb lc ld le fd ls lr lt lu aw lv bi"><span id="26aa" class="km iq hs lr b fi lw lx l ly lz"><a class="ae kl" href="https://github.com/android/user-interface-samples/blob/main/AppWidget/app/src/main/java/com/example/android/appwidget/ListAppWidget.kt" rel="noopener ugc nofollow" target="_blank"><em class="ma">ListAppWidget.kt</em></a><em class="ma"><br/></em>&lt;!-- Copyright 2019 Google LLC.<br/>SPDX-License-Identifier: Apache-2.0 --&gt;</span><span id="9241" class="km iq hs lr b fi mb lx l ly lz"><strong class="lr ht">val layoutId = ListSharedPrefsUtil.loadWidgetLayoutIdPref(<br/>    context, appWidgetId<br/>)</strong></span><span id="346e" class="km iq hs lr b fi mb lx l ly lz">val remoteViews = if (layoutId == R.layout.widget_grocery_list) {<br/>    // Specify the maximum width and height in dp and a layout, <br/>    // which you want to use for the specified size<br/>    val viewMapping = mapOf(<br/>        SizeF(150f, 150f) to constructRemoteViews(<br/>            R.layout.widget_grocery_list<br/>        ), SizeF(250f, 150f) to constructRemoteViews(<br/>            R.layout.widget_grocery_grid<br/>        )<br/>    )<br/>        RemoteViews(viewMapping)<br/>    } else {<br/>        constructRemoteViews(<br/>            layoutId<br/>        )<br/>    }<br/><strong class="lr ht">appWidgetManager.updateAppWidget(appWidgetId, remoteViews)</strong></span></pre><p id="b427" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">现在小部件被配置为提供默认配置，您需要将<code class="du lo lp lq lr b">configuration_optional</code>标志设置为<code class="du lo lp lq lr b">widgetFeatures</code>属性。这跳过了额外的配置步骤，将您的小部件直接放在用户的主屏幕上。在这样做的同时，确保添加<code class="du lo lp lq lr b">reconfigurable</code>标志，以便用户可以在以后更改应用的默认设置。</p><pre class="lb lc ld le fd ls lr lt lu aw lv bi"><span id="044f" class="km iq hs lr b fi lw lx l ly lz"><a class="ae kl" href="https://github.com/android/user-interface-samples/blob/main/AppWidget/app/src/main/res/xml/app_widget_info_checkbox_list.xml" rel="noopener ugc nofollow" target="_blank"><em class="ma">xml/app_widget_info_checkbox_list.xml</em></a><em class="ma"><br/></em>&lt;!-- Copyright 2019 Google LLC.<br/>SPDX-License-Identifier: Apache-2.0 --&gt;</span><span id="4976" class="km iq hs lr b fi mb lx l ly lz">&lt;appwidget-provider <br/>    android:configure="com.example.android.appwidget.ListWidgetConfigureActivity"<br/>    android:widgetFeatures="<strong class="lr ht">reconfigurable|configuration_optional</strong>"<br/>    ... /&gt;</span></pre><p id="8163" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">通过这一更改，当用户将小部件添加到主屏幕时，它会自动使用杂货列表布局。因为配置活动被添加到了<code class="du lo lp lq lr b">appwidget-provider</code>的<code class="du lo lp lq lr b">configure</code>属性中，所以当用户长按小部件并单击编辑/重新配置按钮时，它就会启动。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div class="er es mc"><img src="../Images/5656dc289b5308d4c90cf61944002d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/0*AUaLBtRiRW-ksMxj"/></div><figcaption class="lf lg et er es lh li bd b be z dx">ListWidgetConfigureActivity will be launched when users click edit/reconfigure button</figcaption></figure><p id="0466" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">当用户配置小工具时，这个新的配置存储在<code class="du lo lp lq lr b">ListWidgetConfigureActivity</code>中。</p><pre class="lb lc ld le fd ls lr lt lu aw lv bi"><span id="f6d1" class="km iq hs lr b fi lw lx l ly lz"><a class="ae kl" href="https://github.com/android/user-interface-samples/blob/main/AppWidget/app/src/main/java/com/example/android/appwidget/ListWidgetConfigureActivity.kt" rel="noopener ugc nofollow" target="_blank"><em class="ma">ListWidgetConfigureActivity.kt</em></a><em class="ma"><br/></em>&lt;!-- Copyright 2019 Google LLC.<br/>SPDX-License-Identifier: Apache-2.0 --&gt;</span><span id="30bb" class="km iq hs lr b fi mb lx l ly lz">private fun onWidgetContainerClicked(@LayoutRes widgetLayoutResId: Int) {<br/>    <strong class="lr ht">ListSharedPrefsUtil.saveWidgetLayoutIdPref(this, appWidgetId, widgetLayoutResId)<br/>    </strong>// It is the responsibility of the configuration activity to update the app widget<br/>    <strong class="lr ht">val appWidgetManager = AppWidgetManager.getInstance(this)<br/>    ListAppWidget.updateAppWidget(this, appWidgetManager, appWidgetId)</strong></span><span id="0f15" class="km iq hs lr b fi mb lx l ly lz">    // Make sure we pass back the original appWidgetId<br/>    val resultValue = Intent()<br/>    resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)<br/>    setResult(RESULT_OK, resultValue)<br/>    finish()<br/>}</span></pre><h1 id="b2c6" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">新的和改进的API</h1><p id="6f57" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">说到运行Android的设备，有许多不同的外形可供选择，无论是手机、平板电脑、可折叠还是另一种产品。Android 12引入了更精细的尺寸属性和更灵活的布局，使小部件更容易定制，在不同设备和屏幕尺寸上更可靠。</p><h2 id="db5a" class="km iq hs bd ir kn ko kp iv kq kr ks iz jy kt ku jd kc kv kw jh kg kx ky jl kz bi translated">小部件大小限制</h2><p id="6771" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Android 12除了现有的<code class="du lo lp lq lr b">minWidth</code>、<code class="du lo lp lq lr b">minHeight</code>、<code class="du lo lp lq lr b">minResizeWidth</code>、<code class="du lo lp lq lr b">minResizeHeight</code>之外，还增加了新的<code class="du lo lp lq lr b">appwidget-provider</code>属性。</p><p id="0a4a" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">您可以使用新的<code class="du lo lp lq lr b">maxResizeWidth</code>和<code class="du lo lp lq lr b">maxResizeHeight</code>属性来定义用户可以调整小部件大小的最大高度和宽度。新的<code class="du lo lp lq lr b">targetCellWidth</code>和<code class="du lo lp lq lr b">targetCellHeight</code>属性定义了设备主屏幕上的默认小部件大小。</p><p id="6d4d" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">当定义了<code class="du lo lp lq lr b">targetCellWidth</code>和<code class="du lo lp lq lr b">targetCellHeight</code>属性后，运行Android 12的设备将使用这些属性，而不是<code class="du lo lp lq lr b">minWidth</code>和<code class="du lo lp lq lr b">minHeight</code>。运行Android 11及更低版本的设备将继续使用<code class="du lo lp lq lr b">minWidth</code>和<code class="du lo lp lq lr b">minHeight</code>属性。</p><blockquote class="md me mf"><p id="7e60" class="jn jo ma jp b jq lj js jt ju lk jw jx mg ll ka kb mh lm ke kf mi ln ki kj kk ha bi translated">注意:<code class="du lo lp lq lr b">targetCellWidth</code>和<code class="du lo lp lq lr b">targetCellHeight</code>属性在单元格中定义，而<code class="du lo lp lq lr b">maxResizeWidth</code>和<code class="du lo lp lq lr b">maxResizeHeight</code>属性在dps中定义。</p></blockquote><pre class="lb lc ld le fd ls lr lt lu aw lv bi"><span id="2f9d" class="km iq hs lr b fi lw lx l ly lz"><a class="ae kl" href="https://github.com/android/user-interface-samples/blob/main/AppWidget/app/src/main/res/xml/app_widget_info_checkbox_list.xml" rel="noopener ugc nofollow" target="_blank"><em class="ma">xml/app_widget_info_checkbox_list.xml</em></a><em class="ma"><br/></em>&lt;!-- Copyright 2019 Google LLC.<br/>SPDX-License-Identifier: Apache-2.0 --&gt;</span><span id="a17e" class="km iq hs lr b fi mb lx l ly lz">&lt;appwidget-provider<br/>    <strong class="lr ht">android:maxResizeWidth="240dp"<br/>    android:maxResizeHeight="180dp"<br/>    </strong>android:minWidth="180dp"<br/>    android:minHeight="110dp"<br/>    android:minResizeWidth="180dp"<br/>    android:minResizeHeight="110dp"<br/>    <strong class="lr ht">android:targetCellWidth="3"<br/>    android:targetCellHeight="2"<br/>    </strong>... /&gt;</span></pre><figure class="lb lc ld le fd hj er es paragraph-image"><div class="er es mj"><img src="../Images/434fe6333aaddefab6dbb97d7f2986e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/0*59O1jTl_4Amnq1U0"/></div><figcaption class="lf lg et er es lh li bd b be z dx">In Android 12, <code class="du lo lp lq lr b">targetCellWidth</code> and <code class="du lo lp lq lr b">targetCellHeight</code> attributes are used instead of <code class="du lo lp lq lr b">minWidth</code> and <code class="du lo lp lq lr b">minHeight</code></figcaption></figure><h2 id="ac59" class="km iq hs bd ir kn ko kp iv kq kr ks iz jy kt ku jd kc kv kw jh kg kx ky jl kz bi translated">响应式布局</h2><p id="c4d6" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">虽然使用大小约束可以帮助用户根据需要调整小部件的大小，但是您可能希望根据小部件的大小提供不同的布局和内容类型。这也使系统能够在不唤醒应用程序的情况下以不同的大小显示小部件。</p><p id="721f" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">要实现这一点，首先为一系列尺寸创建一组布局，然后调用<code class="du lo lp lq lr b">updateAppWidget() </code>函数并传递这组布局，如下例所示。当小部件尺寸改变时，系统自动改变布局。</p><pre class="lb lc ld le fd ls lr lt lu aw lv bi"><span id="079f" class="km iq hs lr b fi lw lx l ly lz">&lt;!-- Copyright 2019 Google LLC.<br/>SPDX-License-Identifier: Apache-2.0 --&gt;</span><span id="769d" class="km iq hs lr b fi mb lx l ly lz">val viewMapping: MutableMap&lt;SizeF, RemoteViews&gt; = mutableMapOf()<br/>// Specify the maximum width and height in dp and a layout, which <br/>// you want to use for the specified size<br/>val viewMapping = mapOf(<br/>    SizeF(150f, 110f) to RemoteViews(<br/>        context.packageName,<br/>        R.layout.widget_grocery_list<br/>    ),<br/>    SizeF(250f, 110f) to RemoteViews(<br/>        context.packageName,<br/>        R.layout.widget_grocery_grid<br/>    ),<br/>)<br/>appWidgetManager.updateAppWidget(appWidgetId, RemoteViews(viewMapping))<br/>//...</span></pre><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mk"><img src="../Images/53f89778196e77c8585da889f6b94dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ELfc8FdR6NDTK_FgN_BZg.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Responsive layouts offer better usability when users resize their widgets</figcaption></figure><h2 id="60b5" class="km iq hs bd ir kn ko kp iv kq kr ks iz jy kt ku jd kc kv kw jh kg kx ky jl kz bi translated">复合按钮</h2><p id="ca78" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">用户可以在Android 12中使用widgets做更多事情，而无需启动应用程序！使用新的复合按钮，您可以使您的小工具更具交互性。这不会改变小部件的无状态特性，但是可以让您添加一个监听器来观察状态变化事件。当状态改变事件发生时，您可以调用<code class="du lo lp lq lr b">RemoteResponse.fromPendingIntent()</code>并在监听器中传递一个<code class="du lo lp lq lr b">PendingIntent</code>。</p><pre class="lb lc ld le fd ls lr lt lu aw lv bi"><span id="26b6" class="km iq hs lr b fi lw lx l ly lz"><a class="ae kl" href="https://github.com/android/user-interface-samples/blob/main/AppWidget/app/src/main/java/com/example/android/appwidget/ItemsCollectionAppWidget.kt" rel="noopener ugc nofollow" target="_blank"><em class="ma">ItemsCollectionAppWidget.kt</em></a><em class="ma"><br/></em>&lt;!-- Copyright 2019 Google LLC.<br/>SPDX-License-Identifier: Apache-2.0 --&gt;</span><span id="e841" class="km iq hs lr b fi mb lx l ly lz">remoteViews.setOnCheckedChangeResponse(<br/>    R.id.item_switch,<br/>    <strong class="lr ht">RemoteViews.RemoteResponse.fromPendingIntent(<br/>        onCheckedChangePendingIntent<br/>    )<br/></strong>)</span></pre><p id="07d8" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">另一方面，如果你的小部件有一个控件列表，你不应该在集合的单个项目上设置<code class="du lo lp lq lr b">PendingIntent</code> s，因为这会导致性能下降。在这种情况下，在集合上设置一个单个的<code class="du lo lp lq lr b">PendingIntent</code>模板，调用<code class="du lo lp lq lr b">RemoteResponse.fromFillInIntent()</code>，并在状态改变事件发生时在监听器中传递一个fillInIntent。</p><pre class="lb lc ld le fd ls lr lt lu aw lv bi"><span id="5853" class="km iq hs lr b fi lw lx l ly lz"><a class="ae kl" href="https://github.com/android/user-interface-samples/blob/main/AppWidget/app/src/main/java/com/example/android/appwidget/ItemsCollectionAppWidget.kt" rel="noopener ugc nofollow" target="_blank"><em class="ma">ItemsCollectionAppWidget.kt</em></a><em class="ma"><br/></em>&lt;!-- Copyright 2019 Google LLC.<br/>SPDX-License-Identifier: Apache-2.0 --&gt;</span><span id="2b26" class="km iq hs lr b fi mb lx l ly lz">remoteViews.setOnCheckedChangeResponse(<br/>    R.id.item_switch,<br/>    <strong class="lr ht">RemoteViews.RemoteResponse.fromFillInIntent(<br/>        onCheckedChangeFillInIntent<br/>    )<br/></strong>)</span></pre><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ml"><img src="../Images/95b244a37acaac9c143ee828d1142c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0soPLeUWatfPJttyO71LAg.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx">Widgets are more interactive with compound buttons</figcaption></figure><h2 id="9913" class="km iq hs bd ir kn ko kp iv kq kr ks iz jy kt ku jd kc kv kw jh kg kx ky jl kz bi translated">集合的简化远程视图</h2><p id="50e3" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Android 12引入了一个新的API来简化传递集合以填充小部件中的列表。以前，如果您想用项目集合填充一个<code class="du lo lp lq lr b">ListView</code>、<code class="du lo lp lq lr b">GridView</code>、<code class="du lo lp lq lr b">StackView</code>或其他视图，您需要实现<code class="du lo lp lq lr b">RemoteViewsService</code>来返回<code class="du lo lp lq lr b">RemoteViewsFactory</code>。有了新的<code class="du lo lp lq lr b">setRemoteAdapter()</code> API，你可以简单地用你的主<code class="du lo lp lq lr b">RemoteView</code>传递一个集合。我们也在研究<code class="du lo lp lq lr b">androidx</code> backport，以支持在旧版本的Android上使用这个API。</p><p id="7be4" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">如果该集合不使用一组恒定的布局，您可以使用<code class="du lo lp lq lr b">setViewTypeCount()</code>函数来设置该集合中的<code class="du lo lp lq lr b">RemoteView</code>将使用的布局id的最大数量。</p><pre class="lb lc ld le fd ls lr lt lu aw lv bi"><span id="d73c" class="km iq hs lr b fi lw lx l ly lz"><a class="ae kl" href="https://github.com/android/user-interface-samples/blob/main/AppWidget/app/src/main/java/com/example/android/appwidget/ItemsCollectionAppWidget.kt" rel="noopener ugc nofollow" target="_blank"><em class="ma">ItemsCollectionAppWidget.kt</em></a><em class="ma"><br/></em>&lt;!-- Copyright 2019 Google LLC.<br/>SPDX-License-Identifier: Apache-2.0 --&gt;</span><span id="b838" class="km iq hs lr b fi mb lx l ly lz">remoteViews.setRemoteAdapter(<br/>    R.id.items_list_view,<br/>    RemoteViews.RemoteCollectionItems.Builder()<br/>        .addItem(/* id= */ ID_1, RemoteViews(...))<br/>        .addItem(/* id= */ ID_2, RemoteViews(...))<br/>        //...<br/>        .setViewTypeCount(MAX_NUM_DIFFERENT_REMOTE_VIEWS_LAYOUTS)<br/>        .build()<br/>)</span></pre><h1 id="fbf2" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">摘要</h1><p id="96b9" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">就是这样！将您现有的widget更新到Android 12将立即带来更清新的外观，并使您的widget更具交互性。</p><p id="ecd5" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">既然您已经阅读了本文中的可配置性和新的或改进的API，请查看第一部分<a class="ae kl" rel="noopener" href="/androiddevelopers/updating-your-widget-for-android-12-92e7de87424c">以了解如何更新您的小部件的设计，并在小部件选择器中提供更好的用户体验。为了更进一步，请确保查看整篇文章中使用的</a><a class="ae kl" href="https://github.com/android/user-interface-samples/tree/main/AppWidget" rel="noopener ugc nofollow" target="_blank">示例代码</a>。</p><p id="825a" class="pw-post-body-paragraph jn jo hs jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ha bi translated">如果您正在构建新的小部件，请留意未来的公告。我们正在努力使建立新的部件更加容易！</p></div></div>    
</body>
</html>