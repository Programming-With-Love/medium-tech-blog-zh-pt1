<html>
<head>
<title>Navigating your way around customizable delivery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在可定制的交付中导航</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/navigating-your-way-around-customizable-delivery-e7a882390aa?source=collection_archive---------6-----------------------#2020-05-05">https://medium.com/androiddevelopers/navigating-your-way-around-customizable-delivery-e7a882390aa?source=collection_archive---------6-----------------------#2020-05-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/d08c907622e8b68eb1146927938857c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IkQuRLG00Q19vxp6ZTwu1Q.png"/></div></div></figure><div class=""/><div class=""><h2 id="9c95" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">如何模块化您的应用程序，并利用Android应用程序捆绑条件交付功能。</h2></div><p id="75f5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><em class="kd">合著</em><a class="ke kf ge" href="https://medium.com/u/ff0b1fb4e6b6?source=post_page-----e7a882390aa--------------------------------" rel="noopener" target="_blank"><em class="kd">Dom Elliott</em></a><em class="kd">和</em> <a class="ke kf ge" href="https://medium.com/u/65fe4f480b1c?source=post_page-----e7a882390aa--------------------------------" rel="noopener" target="_blank"> <em class="kd"> Ben Weiss </em> </a></p><p id="c264" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Android应用捆绑包是Android应用的新发布格式，取代了单一的APK。app捆绑包不是直接安装的。相反，Google Play会从应用捆绑包中为每个设备生成优化的apk。与整体式APK相比，捆绑包生成的apk通常要小得多。开发体验也更简单，您不必为每个版本的不同设备配置管理和发布多个apk，从而节省了大量时间。</p><p id="6b25" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Android应用捆绑背后的势头令人难以置信。Google Play上超过450，000个应用和游戏在生产中使用应用捆绑包，占活跃安装的30%以上。与使用通用APK相比，切换到[[bundle]的应用平均节省了16%的大小。这种规模节省使合作伙伴的安装量增加了11%。</p><p id="92f0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当您模块化您的应用程序时，您可以利用应用程序捆绑包的条件交付功能。您可以根据条件(如用户的国家或设备特性)选择在安装时交付模块。按需交付意味着您可以在应用程序需要模块时即时安装和卸载模块。我们看到合作伙伴为各种使用情形构建模块，例如:</p><ul class=""><li id="b262" class="kg kh hs jj b jk jl jn jo jq ki ju kj jy kk kc kl km kn ko bi translated">只有一小部分用户使用的大型功能</li><li id="dbdc" class="kg kh hs jj b jk kp jn kq jq kr ju ks jy kt kc kl km kn ko bi translated">特定的硬件或软件功能，例如向兼容设备提供增强现实模块</li><li id="2cf8" class="kg kh hs jj b jk kp jn kq jq kr ju ks jy kt kc kl km kn ko bi translated">特定Android版本</li><li id="c711" class="kg kh hs jj b jk kp jn kq jq kr ju ks jy kt kc kl km kn ko bi translated">提供生命周期有限的大型库，可以在不再需要时安装和移除。</li></ul><p id="38f2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这些高级功能是可选的，您可以只使用应用捆绑包进行发布。您还可以模块化您的应用程序，而无需使用任何其他可定制的交付选项。</p><p id="8288" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这篇文章详细探讨了创建和交付模块化应用的特性，重点是定义模块依赖和应用导航。但是，首先，我将向您介绍一些最新的和计划中的捆绑包特性。</p><h1 id="5778" class="ku kv hs bd kw kx ky kz la lb lc ld le iy lf iz lg jb lh jc li je lj jf lk ll bi translated">最新最棒的</h1><p id="5000" class="pw-post-body-paragraph jh ji hs jj b jk lm it jm jn ln iw jp jq lo js jt ju lp jw jx jy lq ka kb kc ha bi translated">我们对应用捆绑包的愿景更进一步。我们正在开发一个有更多选择的动态框架。</p><p id="4eb6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这些选项包括应用内更新，使您能够完全在应用内触发和完成更新。我们还致力于可定制的资产交付，使应用捆绑包包含资产包。这个特性对于想要将大型游戏资产和他们的游戏二进制文件打包成一个工件的游戏开发者来说尤其有用。我们进一步介绍了向用户交付这些资产的几个选项。</p><p id="787a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们正在引入补充这一动态框架的新功能。例如，Google Play控制台中的<a class="ae lr" href="https://support.google.com/googleplay/android-developer/answer/9302563?hl=en" rel="noopener ugc nofollow" target="_blank">应用大小报告</a>提供了应用下载大小和设备上的大小等数据。当你使用应用套装时，它也能为你提供尺寸指导。最近，我们添加了与您的用户相关的新指标，并向您展示了设备存储容量较低的活跃用户的比例。这些用户可能会带来卸载风险，优化您的应用程序大小是降低这种风险的一种方法。</p><p id="f878" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们还为Google Play的应用签名服务添加了一项新功能，使您能够将您的应用签名密钥升级为新安装的加密性更强的新签名密钥。如果您很久以前就创建了应用程序签名密钥，并且它没有您希望的那么强，那么这一点尤其有用。</p><p id="7e19" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">最后，还有内部应用程序共享，这使得测试应用程序捆绑包和动态交付更加容易。内部应用共享为您提供了一种快速共享应用进行本地测试的方式。使用这种机制，Google Play将测试应用程序安装在设备上，就像应用程序发布时一样。你所需要做的就是上传一个捆绑包到Google Play，然后与你的测试人员分享一个URL，然后他们在他们的设备上打开这个URL来安装应用程序。使用内部应用程序共享的开发人员表示，这加快了他们的工作流程。您可以让您公司的任何人上传内部应用程序共享，而不授予他们对Play控制台的任何其他访问权限。</p><figure class="lt lu lv lw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/83aec77b3d33d8c8a2e6d3325bd3689f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Skx0Kq45VT8SQQqn"/></div></div></figure><p id="17c5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你有其他上传到Play控制台的工件，你也可以获得它们的安装链接。对于应用程序捆绑包，进入捆绑包浏览器并切换到旧版本，您可以复制一个安装链接。在Play Store <a class="ae lr" rel="noopener" href="/androiddevelopers/developer-tools-on-play-store-85fb710ee33b">这里</a>找到更多关于开发者工具的信息。</p><p id="bc37" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">最后，我们添加了<code class="du lx ly lz ma b">FakeSplitInstallManager</code>类来玩核心。这使您能够离线测试具有动态特性的应用程序。通常，当你在应用中加载一个点播动态功能时，<code class="du lx ly lz ma b">SplitInstallManager</code>会请求Play Store为该动态功能安装拆分，你必须等待它们加载。使用<code class="du lx ly lz ma b">FakeSplitInstallManager</code>，你的应用程序离线安装本地需要的分割。您不必等待Play来交付和安装拆分。这使得在开发过程的早期迭代动态特性变得容易，不需要在线，也不需要等待Play Store。当你准备好的时候，你仍然可以切换到<code class="du lx ly lz ma b">SplitInstallManager</code>并通过内部应用程序共享进行全面的在线测试。这在最新的Play Core版本中现已提供。</p><p id="07e4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这些测试功能都是为了让您更轻松地测试您的应用捆绑包和动态交付，作为您工作流程的一部分。</p><p id="b573" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在你已经对Android应用捆绑包的最新特性有了一个大致的了解，让我们更仔细地看看你的应用中的特性和模块化。</p><h1 id="1657" class="ku kv hs bd kw kx ky kz la lb lc ld le iy lf iz lg jb lh jc li je lj jf lk ll bi translated">功能对功能的依赖性</h1><p id="febb" class="pw-post-body-paragraph jh ji hs jj b jk lm it jm jn ln iw jp jq lo js jt ju lp jw jx jy lq ka kb kc ha bi translated">在讨论特性对特性的依赖之前，让我们回顾一下应用捆绑包的一个关键功能:动态模块。</p><figure class="lt lu lv lw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/1045a760e467e062f8dd7750429adf52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*57E1AHCF2RbtBLzz"/></div></div></figure><p id="cd90" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">假设你有一个具有三种不同特性的应用程序。其中一个提供摄像头支持(绿色)，一个提供视频支持(橙色)，第三个提供支付支持(蓝色)。将你的应用模块化的目标是将它分解成动态的特性，这样你就可以更好的分离代码。动态功能的模块化也意味着不同的用户可以获得应用程序的不同部分:用户1可能会使用相机支持，用户2可能会更高级一些，使用相机和视频支持，用户3可能会使用相机和支付功能。</p><p id="e2b3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这种方法的优点是，每个用户都可以获得他们需要的应用程序的任何部分，并且与作为整体APK交付的应用程序相比，他们安装的应用程序要小得多。</p><blockquote class="mb"><p id="ffe1" class="mc md hs bd me mf mg mh mi mj mk kc dx translated">Google Play的统计数据显示，应用程序大小每减少3兆字节，转化率最高可增加1%。</p></blockquote><p id="1b7f" class="pw-post-body-paragraph jh ji hs jj b jk ml it jm jn mm iw jp jq mn js jt ju mo jw jx jy mp ka kb kc ha bi translated">模块化应用程序还有其他好处。第一个是更快的增量构建时间，因为它能够只构建模块的子集。这意味着你花更少的时间来构建你的应用程序，花更多的时间来开发它。另一个优点是代码的逻辑分离。例如，如果一个团队想开发相机功能，而另一个团队想开发视频功能，那么跨团队的依赖性应该会更少。</p><p id="7821" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在谷歌，我们是模块化应用开发的忠实信徒:它加快了开发速度，提高了质量。模块化方法意味着团队独立工作来构建、测试和调试功能，而不需要每个人都在一个庞大、复杂的应用程序代码块上工作的复杂性。</p><p id="08f9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要了解更多信息，请查看我的文章<a class="ae lr" rel="noopener" href="/androiddevelopers/local-development-and-testing-with-fakesplitinstallmanager-57083e1840a4">使用按需模块进行本地开发和测试</a>。</p><h1 id="2ff9" class="ku kv hs bd kw kx ky kz la lb lc ld le iy lf iz lg jb lh jc li je lj jf lk ll bi translated">动态功能交付</h1><p id="85f4" class="pw-post-body-paragraph jh ji hs jj b jk lm it jm jn ln iw jp jq lo js jt ju lp jw jx jy lq ka kb kc ha bi translated">一旦你的应用中有了动态特性，你就有三种方法来实现它们:</p><ul class=""><li id="e9a9" class="kg kh hs jj b jk jl jn jo jq ki ju kj jy kk kc kl km kn ko bi translated">安装时间交付，用户安装应用程序，动态功能会自动下载到设备上。</li><li id="078a" class="kg kh hs jj b jk kp jn kq jq kr ju ks jy kt kc kl km kn ko bi translated">按需交付，在应用程序请求时下载动态功能。</li><li id="3dad" class="kg kh hs jj b jk kp jn kq jq kr ju ks jy kt kc kl km kn ko bi translated">有条件交付，取决于用户设备的配置。例如，支持AR的设备将安装支持动态特性的AR，而不支持AR的设备则不会。</li></ul><p id="06d4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您还可以将所有这些交付机制与即时应用或游戏交付一起使用，这是您交付小版本(最多10 MB)应用的地方，用户可以通过在Play Store中选择“立即尝试”来加载该应用。但是，如果您将即时启用的动态功能标记为安装时交付，这些功能会在用户选择安装应用程序时自动安装。此外，当您将功能标记为按需交付并在安装时交付中使用它们时，您必须提示用户从已安装的应用程序下载这些功能，因为当用户从即时应用程序开始使用已安装的应用程序时，它们不会自动下载。</p><h1 id="6b52" class="ku kv hs bd kw kx ky kz la lb lc ld le iy lf iz lg jb lh jc li je lj jf lk ll bi translated">基地APK属地</h1><p id="d45e" class="pw-post-body-paragraph jh ji hs jj b jk lm it jm jn ln iw jp jq lo js jt ju lp jw jx jy lq ka kb kc ha bi translated">最初，动态特性依赖于基础APK。因此，请使用我们的应用程序，它具有针对相机、视频和支付的动态功能。如果相机和视频功能依赖于通用图像处理软件，该软件必须驻留在APK。</p><figure class="lt lu lv lw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/b4cfaf7ba73d1b0a57577f2477d67b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XkhPKnyjxqf0lpIR"/></div></div></figure><p id="8093" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这意味着，如果用户只想要支付功能，他们仍然必须下载包含图像处理软件的APK。这限制了你优化下载大小的能力。</p><p id="cbf5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">使用Android Studio 4.0，您可以定义依赖于其他动态特性的动态特性。因此，在示例应用程序中，您现在可以将所有这些图像处理代码放入相机动态特性中。</p><figure class="lt lu lv lw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/dcf13b5cafdfedabd6e7c1b412f310fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kL6mkmB5dpQoyBeu"/></div></div></figure><p id="9f7c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，想使用支付功能的用户不必安装包含图像处理软件的APK。这意味着你能够提供一个更小的APK，并有望提高转化率。</p><p id="2711" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要开始使用这个功能，请安装<a class="ae lr" href="https://developer.android.com/studio/preview/?gclid=Cj0KCQjw6_vzBRCIARIsAOs54z7jxNYupUraP6H1nHp3L1sUB7JfwQm2FxajcpinArb-DH79MdwoGb4aAkTXEALw_wcB" rel="noopener ugc nofollow" target="_blank">Android Studio 4 . x Canary/Beta</a>。</p><p id="f69f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">一旦你开发了你的特性，你就把它们列在基础应用的<em class="kd"> build.gradle </em>文件中。如果您正在调整现有功能的依赖关系，则不需要进行任何更改。</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="52db" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">接下来，在每个特性的<em class="kd"> build.gradle </em>文件中定义依赖关系。如果您正在调整现有功能的依赖关系，您只需将对:camera的依赖关系添加到视频功能<em class="kd"> build.gradle </em>文件中。</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="5bdd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">一旦完成，Android Studio将解析依赖关系树，以便在新的Android Studio Canary特性依赖关系功能中使用。但是，在使用这些功能之前，您必须添加一个功能标志。为此，进入<strong class="jj ht">帮助</strong> &gt; <strong class="jj ht">编辑自定义虚拟机选项</strong>，将<code class="du lx ly lz ma b">rundebug.feature.on.feature</code>添加到文件中，保存更改，并重启Android Studio。</p><figure class="lt lu lv lw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ms"><img src="../Images/8ec8ee07073a73b86ab525a9d4f6efbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rpj4lAo_Dt_LI6k4"/></div></div></figure><p id="48b9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在打开<strong class="jj ht">运行</strong> &gt; <strong class="jj ht">编辑配置</strong>，在<strong class="jj ht">运行/调试配置</strong>中，您可以定义各种测试安装配置。</p><figure class="lt lu lv lw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mt"><img src="../Images/5b11125e6038f62cec1ea86f2d36b142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vJVa8HUxI-CnqWkH"/></div></div></figure><p id="6432" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果选择视频功能，您会看到视频功能需要摄像机功能。所以，当你测试视频功能时，Android Studio会自动选择相机功能，并在你运行测试时安装它。此外，如果您取消选择相机功能，视频功能也会取消选择，因为您没有相机功能，您将无法使用视频功能。</p><p id="e10c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在正常构建您的应用程序，并将其上传到Play控制台。然后，Play会自动为您的设备提供正确的动态功能模块。</p><h1 id="5168" class="ku kv hs bd kw kx ky kz la lb lc ld le iy lf iz lg jb lh jc li je lj jf lk ll bi translated">应用导航</h1><p id="997e" class="pw-post-body-paragraph jh ji hs jj b jk lm it jm jn ln iw jp jq lo js jt ju lp jw jx jy lq ka kb kc ha bi translated">传统的导航方式是使用框架API，它提供了两个选项:</p><ul class=""><li id="d53f" class="kg kh hs jj b jk jl jn jo jq ki ju kj jy kk kc kl km kn ko bi translated">使用意图开始一个活动，这是为你的应用程序开始一个新屏幕的最简单的方法。</li><li id="76ca" class="kg kh hs jj b jk kp jn kq jq kr ju ks jy kt kc kl km kn ko bi translated">使用<code class="du lx ly lz ma b">supportFragmentManager</code>替换片段，因为您需要它们从一个屏幕导航到另一个屏幕。</li></ul><p id="14e2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Jetpack导航架构组件使导航屏幕变得更加容易。该组件包括导航编辑器，您可以在其中定义目的地，然后操作这些目的地的导航路径。导航编辑器中定义的导航填充了<code class="du lx ly lz ma b">res/navigation/graph.xml file</code>，消除了手写代码的需要:尽管如果您愿意，您仍然可以进行手动编辑。</p><p id="79c5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您必须在layout.xml文件中编写一点代码来引用<code class="du lx ly lz ma b">NavHostFragment</code>。您将它设置为默认片段，并引用您创建的图ID，无论是手动创建还是使用导航编辑器创建。</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="dd02" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">更改之后，您不必手动启动活动或与片段管理器本身交互，因为导航组件会为您处理所有这些。</p><h1 id="2eec" class="ku kv hs bd kw kx ky kz la lb lc ld le iy lf iz lg jb lh jc li je lj jf lk ll bi translated">导航动态功能</h1><p id="2235" class="pw-post-body-paragraph jh ji hs jj b jk lm it jm jn ln iw jp jq lo js jt ju lp jw jx jy lq ka kb kc ha bi translated">应用捆绑包和动态功能模块改变了应用从基础模块导航到功能的方式。一个应用程序可以有多个动态功能模块，这些模块可以在安装时安装，也可以在以后使用上面提到的一个可定制的交付选项进行安装。这意味着当您的应用程序导航到某个模块时，该模块可能不会被安装。这给导航组件带来了问题，因为当应用程序导航到某个模块时，库期望该模块在设备上。动态特征导航库解决了这个问题。</p><p id="08a4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Dynamic Feature Navigator是一组基于动态特性、导航组件和Play核心库构建的AndroidX库。该图书馆现在在阿尔法可用，在我们的指南<a class="ae lr" href="https://developer.android.com/guide/navigation/navigation-dynamic" rel="noopener ugc nofollow" target="_blank">这里</a>找到更多。</p><p id="ef29" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了说明从导航到动态特征导航的过渡应该有多平滑，让我们看一个示例导航图和按需模块。以下是您将遵循的步骤:</p><ol class=""><li id="0c9f" class="kg kh hs jj b jk jl jn jo jq ki ju kj jy kk kc mu km kn ko bi translated">在您的layout.xml文件中，用<code class="du lx ly lz ma b">DynamicNavHostFragment</code>替换<code class="du lx ly lz ma b">NavHostFragment</code>，这是一个新类，它提供了基本实现和与动态特性导航器交互的最简单方式。</li></ol><p id="9acf" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><em class="kd">在</em>之前</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="421d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><em class="kd">在</em>之后</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="dd0d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">2.对导航图进行更改。这个过程与中的方法相似。你在<em class="kd"> build.gradle </em>文件中声明模块名来告诉你的应用程序安装了哪些模块。在这种情况下，对于每个特性，您添加一个模块名和每个特性的目的地，以便动态特性导航器知道在哪里找到并安装需要的特性。</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="29f2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">通过这些更改，您可以从基本模块导航，下载并安装新模块，并根据需要启动它。所有这些都不涉及任何其他代码。导航器会为您处理安装状态进度和所有中间状态。</p><p id="aa8e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">让我们看一看引擎盖下，看看这是如何工作的。当您使用导航组件时，<code class="du lx ly lz ma b">navigate()</code>被调用，导航器知道如何从一个目的地导航到另一个目的地。</p><figure class="lt lu lv lw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/739a7bb1a1d70cde4126390ee8c043be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T22ZhY4Z54BYWuz4"/></div></div></figure><p id="2300" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当您使用未安装的动态功能模块时，导航组件不知道如何从A到达b。动态功能导航器通过提供中间进度目的地解决了这一难题。</p><figure class="lt lu lv lw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/c259f94b19952494389b61722405e426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MYL-no-U8bEpXvxO"/></div></div></figure><p id="87bb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这个ProgressDestination检查是否安装了一个模块。如果安装了该模块，导航器将直接透明地导航到目的地。如果未安装该模块，动态功能导航器将下载并安装该功能，然后启动到目标功能。</p><p id="0e02" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您还可以使用通过扩展<code class="du lx ly lz ma b">AbstractProgressFragment</code>提供的API定制这个过程。您可以为想要显示的内容传递一个布局ID。然后覆盖<code class="du lx ly lz ma b">onProgress</code>函数，该函数透明地向下调用Play Core API，因此您的应用程序可以向您的用户显示进度。还有一些函数可以覆盖您可能想要处理的进度状态。</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="21d8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要设置定制的<code class="du lx ly lz ma b">progress</code>片段，打开<code class="du lx ly lz ma b">graph.xml</code>并添加片段的ID作为<code class="du lx ly lz ma b">progressFragment</code>。</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="17c8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您还必须在导航图层次结构中的某个位置设置带有片段ID的进度片段，以便导航组件能够捕捉到它。</p><p id="6c79" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果自定义进度目标还不够，您可以更进一步，使用类似toast的通知或您选择的任何UI来显示安装进度。</p><p id="a6c7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要实现这一点，请将附加的DynamicInstallMonitor传入。导航()调用，并检查<code class="du lx ly lz ma b">DynamicInstallMonitor.installRequired</code>以确定是否需要安装。如果返回<code class="du lx ly lz ma b">false</code>，你的app可以跳转到该模块。否则，您可以订阅安装状态，从<code class="du lx ly lz ma b">SplitInstallSessionStates</code>获取实时数据。您还可以检查安装是否到达结束状态，以确定安装是否失败或被取消，以及您的应用程序是否无法继续该功能。要使用<code class="du lx ly lz ma b">SplitInstallSessionStates</code>，创建<code class="du lx ly lz ma b">InstallMonitor</code>并将其传递给<code class="du lx ly lz ma b">DynamicExtras</code>。这些<code class="du lx ly lz ma b">DynamicExtras</code>然后被传递到navigate函数中，在这里您可以订阅实时数据并观察分割状态。</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="251e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">动态特性导航器库可通过AndroidX <code class="du lx ly lz ma b">navigation-dynamic-features-core</code>完全定制，AndroidX提供了所有导航器API和用于具有动态特性的活动导航和具有动态特性的片段导航的API。</p><p id="fa36" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">从片段版本开始，因为这为您提供了与动态特性导航器交互的最简单方式。如果需要，您可以一直深入到核心，构建完全自定义的体验。</p><p id="3c84" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">首先，将依赖项添加到您的<code class="du lx ly lz ma b">build.gradle</code>文件中:</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="c62f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">而且，当你在快照中发现一个bug或其他问题时，会有一个功能请求，在goo.gle/navigation-bug.归档</p><h1 id="1098" class="ku kv hs bd kw kx ky kz la lb lc ld le iy lf iz lg jb lh jc li je lj jf lk ll bi translated">用于Play Core的Kotlin扩展库</h1><p id="e3d5" class="pw-post-body-paragraph jh ji hs jj b jk lm it jm jn ln iw jp jq lo js jt ju lp jw jx jy lq ka kb kc ha bi translated">不是每个应用程序都使用导航组件，也不是每个动态功能都有UI、片段或活动。这就是用于Play Core的Kotlin扩展库的用武之地。由于它是一个扩展库，它不会取代主游戏核心工件，而是建立在它之上。它在底层使用相同的API。</p><p id="ab2c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在现有API的基础上，我们抓住机会对其进行了简化，并帮助指导您使用正确的流程和推荐的API使用模式。这是通过利用Kotlin协程的能力来实现的。举例来说，这是原始的Play核心API，并且是异步的。</p><pre class="lt lu lv lw fd mv ma mw mx aw my bi"><span id="4e6b" class="mz kv hs ma b fi na nb l nc nd">manager.startInstall(request): Task</span></pre><p id="ddf2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du lx ly lz ma b">SplitInstallManager</code>中的大多数方法会立即返回，并带有设置回调的任务。例如，<code class="du lx ly lz ma b">addOnSuccessListener</code>让您监听要完成的工作，这样您就可以在工作完成后采取行动。您还需要添加失败监听器，在那里您可以获得异常并处理任何失败。</p><p id="eb6f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">那么，这在Play core KTX中是如何工作的呢？这是同一个电话，但它有几个不同之处。</p><figure class="lt lu lv lw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/26ecf22b0dfa800ba45802e837e6195e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1lnbKtokPlMVOWZ7"/></div></div></figure><p id="ffac" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">第一，没有难看的回调。这个调用是顺序的:它返回一个带有会话ID的结果，而不是通过任务和回调来传递。这是因为这个函数实际上是一个挂起函数，所以它必须在一个协程中运行。它挂起了，但没有阻塞，所以从主线程调用是安全的。并且，它返回一个可以赋值的结果。</p><p id="60ae" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是作为建立在现有API之上的<code class="du lx ly lz ma b">SplitInstallManager</code>的扩展功能实现的。只要有意义，我们就使用所有的科特林语法。在这个例子中，我们使用默认和命名参数，所以调用这些方法更容易。这对于返回单个结果的函数非常有效。然而，Play Core API要复杂得多。此示例显示了拆分的安装过程。</p><figure class="lt lu lv lw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/3034de008b15a9addaba3d9aa7c41213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E-erKnfkE1XFCZqF"/></div></div></figure><p id="1a75" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">它经历许多步骤并发出许多状态事件，简单的挂起协程函数是行不通的。通常，在Play Core中，您将使用类似于以下代码的侦听器来处理它:</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="eab0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这段代码让您来处理，例如，添加一个子类监听器并提供您自己的状态处理。重要的是，每当侦听器或对象离开作用域时，您需要在适当的时候清理侦听器，以防止内存泄漏和生命周期问题。</p><p id="2006" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">输入一个名为<a class="ae lr" href="https://kotlinlang.org/docs/reference/coroutines/flow.html" rel="noopener ugc nofollow" target="_blank"> Flow </a>的API，它是Kotlin协同程序库的一部分。该示例请求一个流，该流从Play Core API发出有关拆分安装的状态事件。</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="a9d3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Flow上的collect函数也是挂起的，这意味着它将在一个协程中运行。协程还有一个重要的特性:它们支持取消。在AndroidX的KTX库中，您可以获得视图模型、活动和片段的扩展。这些扩展为您提供了运行协程的范围，只要您的视图模型(或片段或活动)是活动的，您就会不断地获得事件。</p><p id="a6c0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">一旦用户导航离开该屏幕并且范围被取消，我们也取消该流，清除任何侦听器，并且在您的生命周期结束后，您将不会再获得任何事件。最重要的是，Flow和Kotlin协程库内置了许多操作符，因此您可以用更好的方式处理事件流。</p><p id="822d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">例如，我在这里过滤事件流，只过滤我感兴趣的模块的更新:</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="e232" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是使用该API的一种更好的方式。</p><p id="635e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">模块安装过程相当复杂，它经历了许多不同的状态。作为一名开发人员，您如何知道哪些是重要的，哪些是需要一个句柄才能继续安装的，哪些只是影响UI，而不是完成安装所必需的呢？</p><p id="507f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这里有一个方便的函数，它接受lambdas，并为您创建侦听器。</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="mq mr l"/></div></figure><p id="2b31" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对于您需要处理的强制状态，比如下载大型模块的用户确认，您需要提供这些参数。当然，所有其他状态都是可选参数，所以您也可以处理它们并在您的UI中显示出来。</p><h1 id="fff7" class="ku kv hs bd kw kx ky kz la lb lc ld le iy lf iz lg jb lh jc li je lj jf lk ll bi translated">最后的话</h1><p id="43e0" class="pw-post-body-paragraph jh ji hs jj b jk lm it jm jn ln iw jp jq lo js jt ju lp jw jx jy lq ka kb kc ha bi translated">将你的应用程序模块化可以简化开发，并且可以帮助你提高代码的质量。将模块化与Android应用捆绑包相结合意味着您可以利用动态特性为用户提供他们想要使用的特性的最佳代码。</p><p id="59b5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这篇文章中介绍的新特性使您能够利用依赖的动态特性实现更大的代码大小优化。新的导航和Kotlin功能简化了确保应用导航与动态功能无缝协作所需的编码。</p><p id="e8d5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">充分利用应用捆绑包的动态功能来确保最大限度地减少应用和游戏的下载和设备上的大小，可以帮助您实现更好的转换，并降低卸载的可能性。</p><p id="b10a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要了解更多信息，请参见Android开发者网站上的<a class="ae lr" href="https://developer.android.com/platform/technology/app-bundle" rel="noopener ugc nofollow" target="_blank"> Android应用捆绑包</a>。</p></div></div>    
</body>
</html>