<html>
<head>
<title>Mocking composition of Traits with Self-Types in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中特征与自身类型的模拟合成</h1>
<blockquote>原文：<a href="https://medium.com/globant/mocking-a-trait-composition-in-scala-d52c5305b8c9?source=collection_archive---------0-----------------------#2021-08-19">https://medium.com/globant/mocking-a-trait-composition-in-scala-d52c5305b8c9?source=collection_archive---------0-----------------------#2021-08-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/4f78afc9424e7d91af19587b5cb1dbbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*4Bj1SZp5nJObH1ftOD8HUQ.jpeg"/></div></figure><p id="c68e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Scala的<strong class="in hi"> <em class="jj">特性</em> </strong>是一个强大的建模工具，它们让我们实现“复合胜于继承”，从而在面向对象设计中实现更大的灵活性。然而，在一些情况下，在单元测试中模仿这样的组合类是困难的，甚至是不可能的。让我们来看看其中的一种情况:具有<em class="jj">自身类型</em>的特质构成。</p><h1 id="2821" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">自身类型</h1><p id="7fdf" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">通过使用自类型，我们可以在我们创建的特征中实施依赖约束，这表明任何混合了我们的特征<em class="jj">的类也必须混合我们指定为自类型</em>的特征。例如:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="896e" class="kw jl hh ks b fi kx ky l kz la">trait OurTrait { this: ASelfTypeTrait =&gt;<br/>  def doThisAndThat() = …<br/>}</span><span id="cf8b" class="kw jl hh ks b fi lb ky l kz la">// Wrong: must extend also ASelfTypeTrait<br/>class OurCustomClass extends OurTrait {<br/>...<br/>}</span><span id="8933" class="kw jl hh ks b fi lb ky l kz la">// OK<br/>class OurCustomClass extends OurTrait with ASelfTypeTrait {<br/>}</span></pre><p id="3203" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">好了，现在让我们进入正题。</p><h1 id="a3e1" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">我们的案子</h1><p id="a82d" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">让我们假设我们的代码库包含这样一个特征:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="247b" class="kw jl hh ks b fi kx ky l kz la">trait BaseTrait {<br/><br/>  val optMultiplier: Option[Int]<br/>  val <em class="jj">multiplier </em>= optMultiplier.getOrElse(0)<br/><br/>  def multiplyIt(v: Float): Float = v * <em class="jj">multiplier<br/>  </em>def squareIt(v: Float): Float = v * v<br/><br/>}</span></pre><p id="f40e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">而且它还包含了另一个以上面那个为自型的特质:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="f81a" class="kw jl hh ks b fi kx ky l kz la">trait IntermediateTrait { this: BaseTrait =&gt;<br/><br/>  def oneTenth(v: Float): Float = v / 10<br/><br/>}</span></pre><p id="1ba5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们的代码库还包含另外两个特征，每一个都定义了独立的方法集，以实现关注点的分离:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="b601" class="kw jl hh ks b fi kx ky l kz la">trait FirstUpperTrait extends IntermediateTrait { this: BaseTrait =&gt;<br/><br/>  def squarePolinomial(v: Float): Float =<br/>    squareIt(v) + multiplyIt(v)<br/><br/>}</span><span id="9cdd" class="kw jl hh ks b fi lb ky l kz la">trait SecondUpperTrait<br/>  extends IntermediateTrait { this: BaseTrait =&gt;<br/><br/>  def quarterIt(v: Float): Float = v / 4<br/><br/>}</span></pre><p id="1c34" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们创建一个组件作为前面特征的组合:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="2ea8" class="kw jl hh ks b fi kx ky l kz la">class MyComponentImpl(<br/>  override val optMultiplier: Option[Int] = <em class="jj">Some</em>(3)<br/>) extends BaseTrait<br/>  with IntermediateTrait<br/>  with FirstUpperTrait<br/>  with SecondUpperTrait</span></pre><p id="0a97" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">该组件包含了我们剩余代码中所需的所有基本操作，并确保<strong class="in hi"> optMultiplier </strong>仅初始化<strong class="in hi"> <em class="jj">一次</em> </strong>。这个例子看起来很琐碎，但是想象一下这不仅仅是一个<strong class="in hi"> <em class="jj">选项【Int】</em></strong>而是一个数据库连接或者其他一些只需要初始化一次的昂贵资源。</p><p id="2ba4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">最后，我们有一个消费者组件(姑且称之为<strong class="in hi"> <em class="jj">用户组件</em> </strong>)，它恰好依赖于由<strong class="in hi"><em class="jj">FirstUpperTrait</em></strong>定义的操作:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="8b4a" class="kw jl hh ks b fi kx ky l kz la">class UserComponent(val cmp: FirstUpperTrait) {<br/><br/>  private val <em class="jj">Value </em>= 4<br/><br/>  def process(): Float =<br/>    cmp.squarePolinomial(<em class="jj">Value</em>) + cmp.oneTenth(<em class="jj">Value</em>)<br/><br/></span></pre><p id="7221" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们遵循最佳实践，因此我们将为<strong class="in hi"><em class="jj">user component</em></strong>创建一个单元测试。我们将使用<strong class="in hi"> <em class="jj"> ScalaTest </em> </strong>对其进行编码:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="2e24" class="kw jl hh ks b fi kx ky l kz la">class UserComponentTest extends AnyFlatSpec with MockFactory {<br/><br/>  <em class="jj">behavior </em>of "UserComponentTest"<br/><br/>  <em class="jj">it </em>should "process" in {<br/>    val myCmp = mock[FirstUpperTrait]<br/><br/>    (myCmp.squarePolinomial _).expects(4).returns(28.0F)<br/>    (myCmp.oneTenth _).expects(4).returns(0.4F)<br/><br/>    val userComponent = new UserComponent(myCmp)<br/><br/>    val result = userComponent.process()<br/><br/>    assertResult(result)(28.4F)<br/>  }<br/><br/>}</span></pre><p id="6b0f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后我们尝试编译并启动它…哎呀！发生了什么事？</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="d8c2" class="kw jl hh ks b fi kx ky l kz la">illegal inheritance;<br/> self-type delegation.test.FirstUpperTrait does not conform to delegation.test.FirstUpperTrait’s selftype delegation.test.FirstUpperTrait with delegation.test.BaseTrait<br/> val myCmp = mock[FirstUpperTrait]</span></pre><p id="c913" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这意味着我们试图创建的mock是一个扩展了<strong class="in hi"><em class="jj">FirstUpperTrait</em></strong>的新类，同样，它也应该扩展其自身类型(<strong class="in hi"> <em class="jj"> BaseTrait </em> </strong>)。这使得我们的<strong class="in hi"><em class="jj">user component</em></strong>基本上不可测试。</p><h1 id="f68b" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">解决办法</h1><p id="f854" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">首先，我们将创建一个新的trait AbstractFirstUpperTrait，它将声明由<strong class="in hi"><em class="jj">user component</em></strong>使用的所有操作:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="a609" class="kw jl hh ks b fi kx ky l kz la">trait AbstractFirstUpperTrait {<br/><br/>  def squarePolinomial(v: Float): Float<br/>  def oneTenth(v: Float): Float<br/>}</span></pre><p id="bb31" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">其次，我们让FirstUpperTrait也扩展这个新特征:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="b907" class="kw jl hh ks b fi kx ky l kz la">trait FirstUpperTrait extends AbstractFirstUpperTrait<br/>  with IntermediateTrait { this: BaseTrait =&gt;<br/><br/>  def squarePolinomial(v: Float): Float =<br/>    squareIt(v) + multiplyIt(v)<br/><br/>}</span></pre><p id="582b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第三，我们将更改UserComponent，使其依赖于<strong class="in hi"><em class="jj">abstractfirstoppertrait</em></strong>而不是<strong class="in hi"><em class="jj">firstoppertrait</em></strong>:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="8bfa" class="kw jl hh ks b fi kx ky l kz la">class UserComponent(val cmp: AbstractFirstUpperTrait) {<br/><br/>  private val <em class="jj">Value </em>= 4<br/><br/>  def process(): Float =<br/>    cmp.squarePolinomial(<em class="jj">Value</em>) + cmp.oneTenth(<em class="jj">Value</em>)<br/><br/>}</span></pre><p id="0e99" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后，作为最后一步，我们将只修改单元测试中的一行代码:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="701c" class="kw jl hh ks b fi kx ky l kz la">val myCmp = mock[AbstractFirstUpperTrait]</span></pre><p id="db33" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在让我们再次尝试构建和启动:</p><figure class="kn ko kp kq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lc"><img src="../Images/b0a736214a8438c4e38e67d05043f0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ggmWNzSjSN7ANHAC84SLVw.png"/></div></div></figure><p id="d522" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">好吧，成功了！</p><p id="7a0f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，这是否意味着<strong class="in hi"> <em class="jj"> UserComponent </em> </strong>和<strong class="in hi"> <em class="jj"> MyComponentImpl </em> </strong>将一起工作？是的，会的。让我们看看使用这两个类的示例主程序:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="63ce" class="kw jl hh ks b fi kx ky l kz la">object Main extends App {<br/><br/>  class MyComponentImpl(override val optMultiplier: Option[Int] = <em class="jj">Some</em>(3))<br/>    extends BaseTrait<br/>    with IntermediateTrait<br/>    with FirstUpperTrait<br/>    with SecondUpperTrait<br/><br/>  val <em class="jj">myCmp </em>= new MyComponentImpl()<br/>  val <em class="jj">userCmp </em>= new UserComponent(<em class="jj">myCmp</em>)<br/><br/>  <em class="jj">println</em>(<em class="jj">userCmp</em>.process())<br/>}</span></pre><p id="382e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果我运行它(为了简单起见，从我的ide内部运行):</p><figure class="kn ko kp kq fd ii er es paragraph-image"><div class="er es lh"><img src="../Images/af5d82fb4e854ab5c7c5c45a198d726d.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*spv2xTOkqiU9bbOmR5Y66A.png"/></div></figure><p id="79f6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">与单元测试中的结果相同。</p><h1 id="7c1c" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="68d1" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">在本文中，我们介绍了一个示例案例，其中一个类由于使用自身类型来约束依赖关系而变得不可测试，还有一个解决方案对依赖关系进行建模，使其变得可测试。</p></div></div>    
</body>
</html>