<html>
<head>
<title>Implementing Dependency Inversion using Dagger components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dagger组件实现依赖倒置</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/implementing-dependency-inversion-using-dagger-components-d6b0fb3b6b5e?source=collection_archive---------0-----------------------#2019-06-12">https://medium.com/google-developer-experts/implementing-dependency-inversion-using-dagger-components-d6b0fb3b6b5e?source=collection_archive---------0-----------------------#2019-06-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/0fb2f098d232dd92f04f37d0663ae22a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BhB6FX1MDmiTtz4cV08joA.jpeg"/></div></div></figure><div class=""/><p id="285a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">《稳健原则》是罗伯特·马丁在21世纪初首次提出的。这篇<a class="ae jn" href="https://fi.ort.edu.uy/innovaportal/file/2032/1/design_principles.pdf" rel="noopener ugc nofollow" target="_blank">论文</a>解释了五个原理即使没有使用缩写词SOLID，后面也会介绍。这是很久以前的事了，但它们今天仍然有效:它们是许多Android应用程序中使用的干净架构的基础。SOLID是一个缩写:D代表<em class="jo">依赖倒置</em>，可能是五个原则中最复杂的(但也是最重要的)。</p><p id="6c12" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">依赖性反转原则通常是这样定义的:</p><blockquote class="jp"><p id="c3a7" class="jq jr hs bd js jt ju jv jw jx jy jm dx translated">高级模块不应该依赖于低级模块</p></blockquote><p id="9868" class="pw-post-body-paragraph ip iq hs ir b is jz iu iv iw ka iy iz ja kb jc jd je kc jg jh ji kd jk jl jm ha bi translated"><em class="jo">高层</em>模块通常包含应用程序的业务逻辑，<em class="jo">低层</em>模块包含实现细节。例如，计算某些东西的算法在高级模块中定义，而数据库代码在低级模块中定义。</p><p id="8c16" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">是时候看看如何在多模块Android项目上应用这一原则，以及如何利用Dagger来管理以这种方式组织的依赖关系了。开始吧！</p><h2 id="0139" class="ke kf hs bd kg kh ki kj kk kl km kn ko ja kp kq kr je ks kt ku ji kv kw kx ky bi translated">实践中的依赖倒置</h2><p id="1f04" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">让我们看一个例子来解释如何使用依赖倒置。<code class="du le lf lg lh b">WeatherUseCase</code>类返回基于设备位置的天气状况:</p><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="70af" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它使用协程和其他东西，并且可能以一种糟糕的方式管理异常，这里重要的一点是在构造函数中声明了两个依赖项。这个类使用了<em class="jo">依赖注入</em>，它也使用了依赖反转吗？名字相似但意义不同。</p><p id="2788" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要回答这个问题，我们需要从更高的层面来看这个例子，这些类可以组织成三个模块:</p><figure class="li lj lk ll fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lo"><img src="../Images/600624b5391b7ddbebd7370ba52f5c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZeLmrCsH26RpBws47E1nQ.png"/></div></div></figure><p id="6122" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du le lf lg lh b">domain</code>模块(在这篇文章中，单词<em class="jo">模块</em>总是指Android Studio模块)只包含了<code class="du le lf lg lh b">WeatherUseCase</code>类。它依赖于定义接口和类实现的其他两个模块来获取设备位置和从远程服务器检索天气。看着这个图，我们可以回答前面的问题:这个例子使用了依赖注入，但是没有使用依赖倒置。原因是，与原理相反，<em class="jo">高电平</em>模块<code class="du le lf lg lh b">domain</code>依赖于<em class="jo">低电平</em>模块<code class="du le lf lg lh b">weather</code>和<code class="du le lf lg lh b">location</code>。</p><h2 id="41e5" class="ke kf hs bd kg kh ki kj kk kl km kn ko ja kp kq kr je ks kt ku ji kv kw kx ky bi translated">多模块项目中的匕首</h2><p id="ae0f" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">在前面的例子中，Dagger可以以多种方式配置，例如使用子组件、组件依赖或Dagger Android。这里我们将使用组件依赖，一种类似于本文中<a class="ae jn" rel="noopener" href="/androiddevelopers/dependency-injection-in-a-multi-module-project-1a09511c14b7">描述的方法。</a></p><p id="67b3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Dagger代码有两种组织方式:</p><ul class=""><li id="8f4e" class="lp lq hs ir b is it iw ix ja lr je ls ji lt jm lu lv lw lx bi translated">Dagger代码只能在顶层模块(通常是应用程序)中定义</li><li id="bbd7" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated">每个模块可以定义自己的匕首配置</li></ul><p id="fd51" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一种方法似乎更清晰，因为使用它，项目中的大多数模块都不知道Dagger。虽然它对小项目很有效，但是当有很多类需要管理时，我更喜欢在每个模块中定义Dagger配置。</p><p id="d342" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">回到前面的例子，每个模块都可以定义自己的Dagger组件，在<code class="du le lf lg lh b">weather</code>和<code class="du le lf lg lh b">location</code>中定义的组件非常简单:</p><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="b140" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du le lf lg lh b">domain</code>模块中定义的<code class="du le lf lg lh b">DomainComponent</code>使用另外两个组件作为<em class="jo">依赖</em>:</p><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="7990" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里有一个与上一个类似的图表，显示了组件之间的依赖关系:</p><figure class="li lj lk ll fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es md"><img src="../Images/7c541303a711f9fc52d9d4f54040848d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXxaNKveg689vkGFT6-b8Q.png"/></div></div></figure><p id="c1aa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du le lf lg lh b">WeatherUseCase</code>然后使用<code class="du le lf lg lh b">@Inject</code>对构造函数进行注释:</p><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="4b48" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过这种方式，Dagger可以使用由<code class="du le lf lg lh b">LocationComponent</code>和<code class="du le lf lg lh b">WeatherComponent</code>提供的对象作为构造函数参数来创建一个新的<code class="du le lf lg lh b">WeatherUseCase</code>实例。</p><h2 id="3a58" class="ke kf hs bd kg kh ki kj kk kl km kn ko ja kp kq kr je ks kt ku ji kv kw kx ky bi translated">让我们颠倒依赖关系！</h2><p id="b1eb" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">我们如何在这个项目中应用依赖反转？目标是颠倒依赖关系，<code class="du le lf lg lh b">weather</code>和<code class="du le lf lg lh b">location</code>应该依赖于<code class="du le lf lg lh b">domain</code>。最简单的方法是将接口<code class="du le lf lg lh b">LocationManager</code>和<code class="du le lf lg lh b">TemperatureRepository</code>移至<code class="du le lf lg lh b">domain</code>模块:</p><figure class="li lj lk ll fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es me"><img src="../Images/63375317d154c243cd6bd30a7fc64393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rd5yP_t6_NdS1I9kFKOG9w.png"/></div></div></figure><p id="bdbe" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在类之间的依赖关系是相同的，但是我们可以看到模块的依赖关系与最初的例子相反。低级模块依赖于高级模块，所以我们使用依赖倒置。</p><p id="f05a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">依赖倒置在Clean架构中大量使用，其主要优点与该架构相同:</p><blockquote class="mf mg mh"><p id="c66e" class="ip iq jo ir b is it iu iv iw ix iy iz mi jb jc jd mj jf jg jh mk jj jk jl jm ha bi translated"><code class="du le lf lg lh b">domain</code>模块是独立于框架的，它不包含任何对用于实现的框架的引用</p></blockquote><p id="f98f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">基于这一考虑，我们还有另外两个重要优势:</p><ul class=""><li id="3369" class="lp lq hs ir b is it iw ix ja lr je ls ji lt jm lu lv lw lx bi translated">代码约定Vs架构:即使在许多项目中没有使用依赖倒置，<code class="du le lf lg lh b">domain</code>也不包含任何对Android类的引用，并且可以使用JVM测试来测试。但在那个项目中，可能只是因为代码约定，开发者知道不应该在那个模块上使用Android类。使用依赖倒置，我们100%确定Android类(或其他低级框架类)没有在那里使用，它们不在类路径中，所以在使用它们的情况下存在编译错误。</li><li id="9a60" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated">JVM测试很快:类路径真的很小，它只包含对一些实用程序库的一些依赖，对其他模块没有依赖。所以在那个模块上的JVM测试可以非常快地执行，从而支持TDD。而<code class="du le lf lg lh b">domain</code>包含业务逻辑，即值得测试的代码。</li></ul><p id="e70e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在Droidcon Italy 2019上的演讲是关于干净的架构，尤其是依赖性反转。如果你感兴趣，这里有演讲的幻灯片和视频。</p><h2 id="2cd7" class="ke kf hs bd kg kh ki kj kk kl km kn ko ja kp kq kr je ks kt ku ji kv kw kx ky bi translated">使用具有反向依赖关系的Dagger</h2><p id="2967" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">在最初的例子中，<code class="du le lf lg lh b">DomainComponent</code>依赖于另外两个组件，在颠倒了依赖关系后，这段代码不再编译，因为<code class="du le lf lg lh b">domain</code>模块不依赖于另外两个模块。</p><p id="fa8d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">依赖性反转也可以用来解决这个问题，我们可以移除对<code class="du le lf lg lh b">LocationComponent</code>和<code class="du le lf lg lh b">WeatherComponent</code>的依赖性，并用新的接口<code class="du le lf lg lh b">DomainDependencies</code>替换它们:</p><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="1aca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du le lf lg lh b">DomainDependencies</code>接口包含了<code class="du le lf lg lh b">DomainComponent</code>创建<code class="du le lf lg lh b">WeatherUseCase</code>的新实例所需的对象。需要注意的是，这个新接口没有使用<code class="du le lf lg lh b">@Component</code>进行注释，它是一个具有两个属性的标准Kotlin接口(它甚至可以定义两个方法来代替属性)。</p><p id="b3bd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du le lf lg lh b">DomainDependencies</code>实现必须在依赖于所有其他模块的模块中定义，通常应用程序可以用来连接所有组件。一个简单的实现可以只是委托给<code class="du le lf lg lh b">LocationComponent</code>和<code class="du le lf lg lh b">WeatherComponent</code>:</p><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="092d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">带有组件依赖关系的图表稍微复杂一些:</p><figure class="li lj lk ll fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ml"><img src="../Images/5f339efd54316fbbd72183299449def2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfahhDklP0QTCa8zkzSDzw.png"/></div></div></figure><p id="0a46" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇关于Dagger on library development的<a class="ae jn" href="https://proandroiddev.com/dagger-component-dependencies-for-library-development-e2df7ce68233" rel="noopener ugc nofollow" target="_blank">帖子</a>中可以找到一个类似的例子。想法是相似的，但是它被用来管理稍微不同的东西。</p><h2 id="42f7" class="ke kf hs bd kg kh ki kj kk kl km kn ko ja kp kq kr je ks kt ku ji kv kw kx ky bi translated">组件依赖关系和范围</h2><p id="b67c" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">也可以使用真正的Dagger组件创建<code class="du le lf lg lh b">DomainDependencies</code>实现。我们可以创建一个用<code class="du le lf lg lh b">Component</code>注释的接口:</p><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="bf08" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du le lf lg lh b">DomainDependenciesImpl</code>知道如何创建<code class="du le lf lg lh b">DomainDependencies</code>中定义的对象，这得益于对其他两个组件的依赖。所以不需要定义额外的方法，它就可以工作！</p><p id="5153" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编辑:这要感谢Dagger 2.27中引入的一个特性。使用旧版本的hacky解决方案是必要的(详见<a class="ae jn" href="https://github.com/google/dagger/issues/1225" rel="noopener ugc nofollow" target="_blank"> 1225 </a>)。</p><p id="af66" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在一个多模块项目中，组织方式类似于这篇<a class="ae jn" href="https://jeroenmols.com/blog/2019/03/18/modularizationarchitecture/" rel="noopener ugc nofollow" target="_blank">文章</a>中描述的方式，我认为为每个模块定义一个作用域组件是一个好主意。这样，每个组件都可以定义自己的单例对象。范围取决于组件存储的位置，在本例中，所有组件都保存在<code class="du le lf lg lh b">Application</code>中。</p><p id="381d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">定义的三个组件使用自己的范围注释(例如<code class="du le lf lg lh b">LocationSingleton</code>和<code class="du le lf lg lh b">WeatherSingleton</code>)。这不是必需的，即使对每个组件使用相同的注释也可以。需要注意的是，必须定义一个自定义注释，因为使用标准<code class="du le lf lg lh b">Singleton</code>注释确定作用域的组件不能依赖于其他作用域的组件。然而，我认为定义多个注释代码更清晰，出错时的错误消息也更明确。</p><p id="f7c1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以从这种组织中受益的应用程序的一个真实例子是一个使用<code class="du le lf lg lh b">OkHttp</code>、<code class="du le lf lg lh b">Picasso</code>、<code class="du le lf lg lh b">Retrofit</code>和<code class="du le lf lg lh b">Apollo</code>的应用程序(假设一些特性使用REST端点，而其他特性使用GraphQL端点)。在这个例子中，我们可以创建四个组件，每个组件定义它自己的单例(像<code class="du le lf lg lh b">OkHttpClient</code>或<code class="du le lf lg lh b">ApolloClient</code>)。另外三个模块使用<code class="du le lf lg lh b">OkHttp</code>模块来共享同一个<code class="du le lf lg lh b">OkHttpClient</code>。我们可以使用一个定义所有单体的匕首<code class="du le lf lg lh b">Component</code>来实现类似的东西，但是使用多个组件可以更好地分离关注点，一个特性模块可以只包含需要的模块(和库)。如果一个特性模块只使用一个GraphQL端点，它可以忽略定义改进内容的模块。</p><h2 id="2116" class="ke kf hs bd kg kh ki kj kk kl km kn ko ja kp kq kr je ks kt ku ji kv kw kx ky bi translated">包扎</h2><p id="86a3" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">依赖倒置是一个原则，它可以很好地帮助在小的独立模块中组织一个大项目。在这篇文章中，我们已经看到了一个如何在一个项目中组织Dagger组件的例子，这个项目应用了依赖倒置。这个<a class="ae jn" href="https://github.com/fabioCollini/CleanWeather/tree/dagger" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>的<code class="du le lf lg lh b">dagger</code> <a class="ae jn" href="https://github.com/fabioCollini/CleanWeather/tree/dagger" rel="noopener ugc nofollow" target="_blank">分支</a>上有完整的例子。</p></div></div>    
</body>
</html>