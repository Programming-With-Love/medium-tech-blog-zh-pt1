<html>
<head>
<title>GraphQL Delivery on Golang’s Clean Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang清洁建筑的GraphQL交付</h1>
<blockquote>原文：<a href="https://medium.easyread.co/graphql-delivery-on-golangs-clean-architecture-5c995a17b3a8?source=collection_archive---------1-----------------------#2019-09-24">https://medium.easyread.co/graphql-delivery-on-golangs-clean-architecture-5c995a17b3a8?source=collection_archive---------1-----------------------#2019-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="41d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Golang Clean架构上实现GraphQL</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0281a65b06ce1bd8e10202ebdf07579f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qporpLMOCFrQF6-W"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@rosebox?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">RoseBox رز باکس</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="79e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> C </span>精益架构，是编程中流行的架构之一。它以各层之间良好的分离关系而闻名。每一层都不需要知道另一层的实现，所以我们可以很容易地改变实现，而不用在另一层上做任何改变。如果你想了解更多关于洁净建筑的知识，你可以在这里阅读<a class="ae kv" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">因为我不会在这篇文章中详细解释。</a></p><p id="98e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我想在我的朋友关于Golang清洁架构的代码中实现GraphQL，你可以在这里阅读他的精彩帖子“<a class="ae kv" href="https://medium.com/hackernoon/golang-clean-archithecture-efd6d7c43047" rel="noopener">在Golang上尝试清洁架构</a>”。在那篇文章中，作者使用REST API作为交付层，现在我将尝试添加更多使用GraphQL的HTTP层。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="900e" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">GraphQL</h1><p id="21f3" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">GraphQL是什么？根据他们<a class="ae kv" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank">网站</a>的定义:</p><blockquote class="nf ng nh"><p id="612a" class="kw kx ni ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated">GraphQL是一种API查询语言，也是一种用现有数据完成这些查询的运行时语言。GraphQL为API中的数据提供了完整且易于理解的描述，使客户能够准确地要求他们需要的东西，使API更容易随时间发展，并支持强大的开发工具。</p></blockquote><p id="1db6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，GraphQL是一种查询语言，让客户只得到他们要求，而不接收未使用的数据。所以如果我们有一个像这样的article对象:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="86bb" class="nr mj iq nn b gy ns nt l nu nv">{<br/>   "id": "article-id",<br/>   "title": "Indonesia won the award of best clean air of South East    Asia",<br/>   "author": "Kurio"<br/>}</span></pre><p id="2595" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而客户端只想要<code class="fe nw nx ny nn b">title</code>字段，服务器只会返回:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="9dcd" class="nr mj iq nn b gy ns nt l nu nv">{<br/>   "title": "Indonesia won the award of best clean air of South East    Asia"<br/>}</span></pre><h2 id="ddac" class="nr mj iq bd mk nz oa dn mo ob oc dp ms lf od oe mu lj of og mw ln oh oi my oj bi translated">GraphQL模式</h2><p id="984e" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">要开始使用GraphQL，我们需要基于我们的<code class="fe nw nx ny nn b">Model</code>和<code class="fe nw nx ny nn b">Usecase</code>层定义我们的模式。所以基于这个<a class="ae kv" href="https://github.com/bxcodec/go-clean-arch" rel="noopener ugc nofollow" target="_blank"> github </a>，我们有了文章结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">article struct</figcaption></figure><p id="fb0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在GraphQL模式上创建这样的文章类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Type on the GraphQL schema</figcaption></figure><p id="3dca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>上，它有5个默认标量类型，有:</p><ul class=""><li id="d78e" class="om on iq ky b kz la lc ld lf oo lj op ln oq lr or os ot ou bi translated">（同Internationalorganizations）国际组织</li><li id="72e9" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated">浮动</li><li id="c724" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated">线</li><li id="2af0" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated">布尔代数学体系的</li><li id="703c" class="om on iq ky b kz ov lc ow lf ox lj oy ln oz lr or os ot ou bi translated">身份证明</li></ul><p id="4a23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们可以将Golang <code class="fe nw nx ny nn b">string</code>和<code class="fe nw nx ny nn b">int64</code>数据类型映射到GraphQL上的<code class="fe nw nx ny nn b">String</code>和<code class="fe nw nx ny nn b">Int</code>标量类型。对于Golang上的<code class="fe nw nx ny nn b">Time</code>类型，GraphQL支持创建自定义标量类型，因此我们需要在我们编写的模式中定义<code class="fe nw nx ny nn b">Time</code>标量类型。</p><p id="7972" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建对象类型后，我们需要为GraphQL模式创建<code class="fe nw nx ny nn b">Query</code>和<code class="fe nw nx ny nn b">Mutation</code>。这两种类型将基于清洁架构代码的<code class="fe nw nx ny nn b">Usecase</code>接口创建，这里是<code class="fe nw nx ny nn b">usecase</code>接口的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">usecase interface code</figcaption></figure><p id="e54a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GraphQL中的<code class="fe nw nx ny nn b">Query</code>和<code class="fe nw nx ny nn b">Mutation</code>有什么区别？简而言之，<code class="fe nw nx ny nn b">Query</code>用于检索数据，而<code class="fe nw nx ny nn b">Mutation</code>用于在服务器上修改或创建数据。所以基于<code class="fe nw nx ny nn b">usecase</code>接口，我们可以编写这样的查询和变异:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">query and mutation schema</figcaption></figure><p id="bcbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你一定在问，</p><blockquote class="nf ng nh"><p id="b926" class="kw kx ni ky b kz la jr lb lc ld ju le nj lg lh li nk lk ll lm nl lo lp lq lr ij bi translated">等等，FetchArticle行上的ArticlesResult <em class="iq">是什么？以前在类型架构中没有ArticlesResult类型！为什么不直接返回文章列表呢？</em></p></blockquote><p id="ebdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nw nx ny nn b">FetchArticle</code>函数中，我们需要分页和光标功能，所以我们不会通过一个请求得到所有的文章。在GraphQL中，有一个实现分页的标准类型，基于这个<a class="ae kv" href="https://graphql.org/learn/pagination/" rel="noopener ugc nofollow" target="_blank">页面</a>我们需要创建一个连接(edge)和当前对象的信息(pageInfo)，这就是为什么我们需要创建<code class="fe nw nx ny nn b">ArticlesResult</code>对象。下面是<code class="fe nw nx ny nn b">ArticlesResult</code>的模式类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">articles_result GraphQL schema</figcaption></figure><p id="6a37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nw nx ny nn b">Edge</code>型将有<code class="fe nw nx ny nn b">cursor</code>带<code class="fe nw nx ny nn b">String</code>型和<code class="fe nw nx ny nn b">node</code>带<code class="fe nw nx ny nn b">Article</code>型。cursor是当前文章与其相邻文章的连接值。我们可以用这个<code class="fe nw nx ny nn b">cursor</code>值得到下一篇文章。</p><p id="3353" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nw nx ny nn b">PageInfo</code>型将有<code class="fe nw nx ny nn b">endCursor</code>带<code class="fe nw nx ny nn b">String</code>型和<code class="fe nw nx ny nn b">hasNextPage</code>带<code class="fe nw nx ny nn b">Boolean</code>型。<code class="fe nw nx ny nn b">endCursor</code>是当前边的最后一个光标的值，所以我们可以用这个值得到下一条边。<code class="fe nw nx ny nn b">hasNextPage</code>将是我们的标志，不管这个边缘列表是否有下一页。</p><p id="8771" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nw nx ny nn b">ArticlesResult</code>类型将有<code class="fe nw nx ny nn b">edges</code>类型和<code class="fe nw nx ny nn b">Edge</code>类型的数组，<code class="fe nw nx ny nn b">pageInfo</code>和<code class="fe nw nx ny nn b">PageInfo</code>类型，<code class="fe nw nx ny nn b">totalCount</code>和<code class="fe nw nx ny nn b">Int</code>类型。<code class="fe nw nx ny nn b">totalCount</code>将有当前边的总项数的值。</p><p id="4bbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有的GraphQL类型(对象、变异和模式)都可以写在同一个文件中，所以这里是<code class="fe nw nx ny nn b">schema.graphql</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">schema.graphql</figcaption></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="b882" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">深入GraphQL Go</h1><p id="bf83" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">在模式已经定义之后，我们需要把它转换成Golang的代码。对于本教程，我们将使用<a class="ae kv" href="https://github.com/graphql-go/graphql" rel="noopener ugc nofollow" target="_blank"> graphql </a>包。我选择使用这个包是因为它的模块化，所以我们可以在干净的代码架构中使用它。</p><h2 id="2f1e" class="nr mj iq bd mk nz oa dn mo ob oc dp ms lf od oe mu lj of og mw ln oh oi my oj bi translated">转换对象类型模式</h2><p id="38dc" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">首先，我们需要根据我们的模式创建GraphQL对象，代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">schema go object based on GraphQL schema</figcaption></figure><h2 id="a149" class="nr mj iq bd mk nz oa dn mo ob oc dp ms lf od oe mu lj of og mw ln oh oi my oj bi translated">准备解析程序</h2><p id="7305" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">为了能够利用解析器的<a class="ae kv" href="https://github.com/graphql-go/graphql" rel="noopener ugc nofollow" target="_blank">包</a>函数，我们需要创建一个实现<code class="fe nw nx ny nn b">FieldResolveFn</code>的函数。我们可以只为每个解析器创建一个函数，但是这次我们将创建一个接口，它包含模式中的所有<code class="fe nw nx ny nn b">Query</code>和<code class="fe nw nx ny nn b">Mutation</code>函数，因此它可以通过注入文章服务层来启动(并且更容易测试)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">resolver.go</figcaption></figure><h2 id="e43d" class="nr mj iq bd mk nz oa dn mo ob oc dp ms lf od oe mu lj of og mw ln oh oi my oj bi translated">创建架构构造函数</h2><p id="1515" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我们将需要创建所有类型都显式编写的GraphQL对象。我的意思是我们必须为<code class="fe nw nx ny nn b">Mutation</code>创建一个声明了<code class="fe nw nx ny nn b">UpdateArticle</code>、<code class="fe nw nx ny nn b">StoreArticle</code>和<code class="fe nw nx ny nn b">DeleteArticle</code>的对象。先前的解析器将被注入到GraphQL对象模式中，以便能够使用它的方法。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">schema_object constructor</figcaption></figure><h2 id="168f" class="nr mj iq bd mk nz oa dn mo ob oc dp ms lf od oe mu lj of og mw ln oh oi my oj bi translated">实现解析器</h2><p id="6604" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">别忘了写<code class="fe nw nx ny nn b">Resolver</code>接口的实现。我们将创建一个内部结构，它实现了接口的所有必需方法，并且还注入了文章服务层，因此我们可以访问文章数据。</p><p id="ac42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么不直接注入文章存储库层呢？这是因为我们将resolver作为另一个交付层，交付层不能直接访问存储层，所以我们需要利用服务层。</p><ul class=""><li id="2d31" class="om on iq ky b kz la lc ld lf oo lj op ln oq lr or os ot ou bi translated"><strong class="ky ir"> FetchArticle </strong></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">FetchArticle implementation</figcaption></figure><ul class=""><li id="0528" class="om on iq ky b kz la lc ld lf oo lj op ln oq lr or os ot ou bi translated"><strong class="ky ir">更新文章</strong></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">UpdateArticle implementation</figcaption></figure><p id="bab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为自己编写另一个实现将是一个很好的实践，这样您就可以探索这个包还有哪些其他选项。但总的来说，代码会写成这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">resolver.go with implementation</figcaption></figure><h2 id="1b7a" class="nr mj iq bd mk nz oa dn mo ob oc dp ms lf od oe mu lj of og mw ln oh oi my oj bi translated">正在初始化GraphQL传递</h2><p id="7e3a" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">最后一步，我们需要在<code class="fe nw nx ny nn b">main.go</code>文件上初始化我们的GraphQL交付。只需像这样修改文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="4644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<a class="ae kv" href="https://github.com/graphql-go/handler" rel="noopener ugc nofollow" target="_blank">https://github.com/graphql-go/handler</a>包创建一个GraphQL HTTP处理程序，并将该处理程序传递给<code class="fe nw nx ny nn b">echo</code> WrapHandler函数，但是如果你不想使用它，可以按照<a class="ae kv" href="https://graphql.org/learn/serving-over-http/" rel="noopener ugc nofollow" target="_blank">https://graphql.org/learn/serving-over-http/</a>的规则创建自己的处理程序。</p><p id="5c19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们的<a class="ae kv" href="https://github.com/bxcodec/go-clean-arch" rel="noopener ugc nofollow" target="_blank"> go-clean-arch </a>已经有了另一个使用GraphQL的交付层，只需运行您的应用程序并从<code class="fe nw nx ny nn b">/graphql</code>路径访问它。我们也将有GraphQL用户界面来尝试graph QL的查询。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/9b12805d54cdc9bea33057d48f3708ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P03s5reWhRcWASpSDjMdmg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">graphiql user interface</figcaption></figure><p id="89af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这篇教程能帮助你理解GraphQL和Golang中干净架构的有用性。</p><p id="97df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里看到我的Github的完整代码:</p><div class="pb pc gp gr pd pe"><a href="https://github.com/ridhoperdana/go-clean-arch" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd ir gy z fp pj fr fs pk fu fw ip bi translated">ridhoperdana/清洁拱门</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">github.com</p></div></div></div></a></div><p id="ca16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">祝你愉快，🖖🏼！</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="ed25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢<a class="pn po ep" href="https://medium.com/u/ef42567fbbae?source=post_page-----5c995a17b3a8--------------------------------" rel="noopener" target="_blank"> Iman Tumorang </a>为Golang提供干净的代码架构，<a class="pn po ep" href="https://medium.com/u/eda7c68a1225?source=post_page-----5c995a17b3a8--------------------------------" rel="noopener" target="_blank">Bastian Paskal sitamorang</a>，<a class="pn po ep" href="https://medium.com/u/f007fd80d249?source=post_page-----5c995a17b3a8--------------------------------" rel="noopener" target="_blank"> Reza Indra </a>，<a class="pn po ep" href="https://medium.com/u/2432a6a8de52?source=post_page-----5c995a17b3a8--------------------------------" rel="noopener" target="_blank"> Nugroho Cahyono </a>来自<a class="ae kv" href="https://kurio.id/" rel="noopener ugc nofollow" target="_blank"> Kurio </a>帮助我在Golang中实现GraphQL😎</p></div></div>    
</body>
</html>