<html>
<head>
<title>Set up continuous application build and delivery from Git to Kubernetes with Oracle Wercker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Oracle Wercker建立从Git到Kubernetes的持续应用构建和交付</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/set-up-continuous-application-build-and-delivery-from-git-to-kubernetes-with-oracle-wercker-533df64b0232?source=collection_archive---------0-----------------------#2018-02-22">https://medium.com/oracledevs/set-up-continuous-application-build-and-delivery-from-git-to-kubernetes-with-oracle-wercker-533df64b0232?source=collection_archive---------0-----------------------#2018-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="febe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这很好——将代码推送到Git存储库中的一个分支，过一会儿就会发现新构建的应用程序已经启动并在实际环境中运行。这正是沃克能为我做的。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/0cf029e5c361a9c5290526c2fcfb04ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tsh11iVpuM8-XtG9."/></div></div></figure><p id="813e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Oracle + Wercker云服务允许我基于Git存储库定义应用程序。对于每个应用程序，可以定义一个或多个由一个或多个管道(步骤)组成的工作流。Git存储库中特定分支上的提交可以触发工作流。管道可以做各种事情，包括:从源代码构建Docker容器作为应用程序的运行时，将Docker容器推送到容器注册表，并将容器从该容器注册表部署到Kubernetes集群。</p><p id="3ec3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我将展示我为一个Node JS应用程序建立端到端工作流的步骤，这个应用程序是我在本地开发和测试的，然后被推送到GitHub上的一个存储库中。对主分支的任何提交都会触发这个端到端的工作流。它构建应用程序运行时容器，存储它并将其部署到运行在Oracle云基础设施(容器引擎云)上的Kubernetes集群。</p><p id="5f4f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">起点是位于<a class="ae jo" href="https://github.com/lucasjellema/eventmonitor-microservice-soaring-clouds-sequel" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/lucasjellema/event monitor-microservice-sowing-clouds-sequel的GitHub存储库中的应用程序—event monitor-microservice-sowing-clouds-sequel</a>。我已经在wer cker(【http://www.wercker.com/】T2)上有了一个免费账户</p><p id="99e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">步骤:</p><h1 id="ae42" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1.向我的Wercker帐户添加应用程序</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/830a45917a19fb75b37acf25c86d64f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gnytc2yAGnKcksfk."/></div></div></figure><h1 id="fce8" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2.逐步完成应用程序向导:</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/f631701b4b9d0e3fba725ffb3f87ab2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DgQ5PNjFq6B5dWat."/></div></div></figure><p id="b839" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">选择GitHub(在我的例子中)。</p><p id="fd1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为我使用我的GitHub帐户信息登录到Wercker，所以我得到了一个我所有仓库的列表。我选择保存我添加的应用程序代码的那个:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/080bd16dae59625842e3118d7ec8f080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z5GRHW5feHU3E5n5."/></div></div></figure><p id="33d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接受在没有SSH密钥的情况下签出代码:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/d86ee6c8bff989102776b9969a654fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oo-Hh1obgS7Png4L."/></div></div></figure><p id="aba7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">步骤4显示了应用程序的配置信息。按“创建”以完成应用程序的定义。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/8cd448b83e3082c4c575dedb546ce75c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5rhnGFtMQZf_WXtE."/></div></div></figure><p id="33c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">表明应用程序创建成功。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/b52008ad86ec875f814222486badc026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XDBIKHRnRNB6oFOa."/></div></div></figure><h1 id="7499" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.在wercker.yml中定义构建步骤</h1><p id="87e9" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">Wercker执行的构建步骤由一个wercker.yml文件描述。该文件应该位于源存储库的根目录中。</p><p id="845d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Wercker为构建文件的创建提供帮助。对于一种特定的语言，它可以生成一个框架wercker.yml文件，该文件已经引用了基本盒(一种特定于语言的运行时),并且具有构建和推送容器的步骤大纲。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/f349916986337e65709b4e257db6ea88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y1Xe1kFo-hEu8FH6."/></div></div></figure><p id="5946" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我的例子中，我已经手动创建了wercker.yml文件，并且已经将它包含在我的源repo中。</p><p id="fede" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是文件的一部分。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ks"><img src="../Images/b6c94d6eb81a45926edf520589ad4770.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/0*ECH5WU7ChzY7N6-x."/></div></figure><p id="b83d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于box <em class="kt"> node8 </em>(基本容器映像)，它定义了三个构建块:构建、发布和部署。第一个是节点应用程序的标准并构建应用程序(它收集了所有节点模块)。第二个函数获取第一步得到的容器映像，并将其推送到Wercker容器注册中心，该注册中心带有一个由分支名称和git提交id组成的标记。第三个稍微详细一点。它从Wercker注册表中获取容器映像，并创建一个Kubernetes部署，随后将该部署推送到Kubernetes集群，该集群由环境变量KUBERNETES_MASTER和KUBERNETES_TOKEN指示。</p><h1 id="1355" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">4.定义管道和工作流</h1><p id="84b7" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在Wercker控制台中，我可以为我的应用程序定义工作流。这些工作流由按特定顺序组织的管道组成。每个管道都是由前一个管道的完成触发的。第一个管道通常由源存储库中的提交事件触发。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/a5256256f3f20c7ba117feaba6f2ec28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GvDZZnVynJEtJYh1."/></div></div></figure><p id="2d4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在构建我需要的工作流之前，我首先必须设置管道——对应于应用程序源repo中wercker.yml文件中的构建步骤。点击添加新管道。</p><p id="0090" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">定义新管道的名称(您喜欢的任何名称)和YML管道的名称——这个名称必须与wercker.yml文件中构建块的名称完全一致。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/5b1b650ffa0454c30a6d871f43c6f87c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xfPOTJE5WjeHskTL."/></div></div></figure><p id="7901" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">点击创建。</p><p id="9e2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，在YML文件中为“部署到oke”步骤创建一个管道</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/0736892298a0e4d95227a4905b90e775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UmNhEWl2mE9j-5p5."/></div></div></figure><p id="cc73" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">按“创建”也创建此管道。</p><p id="eb22" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了所有三个可用的管道，我们就可以完成工作流了。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/ab540c302d51089940f204271d63eef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kegu5Zu7YFEaZ19j."/></div></div></figure><p id="3ec4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">单击加号图标在工作流程中添加步骤。将此步骤与pipeline push-docker-image-to-releases相关联:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ku"><img src="../Images/3580c886aca7af42ef36662b64214128.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/0*APBJIamqu_LYJgkD."/></div></figure><p id="a3b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，为最终管道添加一个步骤:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/fc7cfeb05f4df8f5937a953bef0234d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*arIL4V6NyzJNrIF0."/></div></div></figure><p id="085f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就完成了工作流程。如果您现在将代码提交到GitHub repo的主分支，工作流将被触发并开始执行。然而，执行将会失败:wercker.yml文件包含对变量的各种引用，这些变量需要在工作流成功之前为应用程序(或工作流，甚至单个管道)定义。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kv"><img src="../Images/7598dc4d9077ea09388b159a1ab3418a.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/0*OugCV9Lsk6pxw58X."/></div></figure><p id="b8a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">成功部署到Kubernetes的关键是文件Kubernetes-deployment . yml . template和ingress.yml.template。这些文件定义了重要的细节，例如:</p><ul class=""><li id="8a82" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lb lc ld le bi translated">Wercker容器注册表中要为其创建窗格的容器图像</li><li id="0e93" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">从每个Pod暴露的端口</li><li id="6087" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">要在Pod内部发布的环境变量</li><li id="a3dd" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">访问应用程序端点的URL路径(在ingress.yml.template中)</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lk"><img src="../Images/a900a4085d43d55b2882d5f662630d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/0*1h8QdoAJ5C-5XQ0o."/></div></figure><h1 id="9550" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">5.定义环境变量</h1><p id="7b1d" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">单击环境选项卡。为wercker.yml文件中使用的所有变量设置值。其中一些定义了应该部署到的Kubernetes环境，另一些提供了注入到Kubernetes Pod中的值，并在运行时作为环境变量提供给应用程序</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/dff71a18e1f5e7e0481107cb3ea18d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8y-Q3e0CTURPnp0X."/></div></div></figure><h1 id="84ab" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">6.触发应用程序的构建</h1><p id="d53c" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">此时，应用程序真正做好了构建和部署的准备。触发这种情况的一种方法是向主分支提交一些东西。这里显示了另一个选项:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/3fcf1823870b3bb3cb26d02592bf91bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7VX903luCQd0z5kB."/></div></div></figure><p id="b144" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">构建被触发。控制台中提供了每个步骤的输出:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/3ab07408b72bfb7f4754d4b280b9f60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dbm_da9QJ7q8M91h."/></div></div></figure><p id="6458" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">构建完成后，控制台会反映结果。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/05554e496d8b19d798d2c589a5108dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*od2WULaVpLtNKvwm."/></div></div></figure><p id="3537" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以单击每个管道来检查所有单个步骤的详细信息，例如部署到Kubernetes:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/517fab47611c497797ef9032edc464d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M_YhfIqEqKWT-bpK."/></div></div></figure><p id="5df6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个步骤都可以扩展到更多细节:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ll"><img src="../Images/0f96d5e2302835be52f98572d15d7044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/0*iQgT6PNaLvO8jbEs."/></div></figure><p id="ab85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这些细节中，我们可以找到为环境变量注入的值。</p><h1 id="71e4" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">7.访问实时应用程序</h1><p id="37b4" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">这最后一步不是Wercker特有的。然而，实际使用应用程序是锦上添花。</p><p id="07df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">应用程序的入口定义规定:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lm"><img src="../Images/974e78d09b99185f18b0c4ed5e5b3902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/0*2mepnaYHZAtuhvqY."/></div></figure><p id="5939" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着可以在K8S入口的端点上通过路径/eventmonitor-ms/app/访问应用程序。</p><p id="877d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">给定入口服务的外部IP地址，我现在可以访问应用程序:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/d9bc711480e5a29beb4611ba07c759d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e-XRivJMjP6mVJtA."/></div></div></figure><p id="715b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:/health是应用程序支持的操作之一。</p><h1 id="6b84" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">8.改变应用程序并实施改变——最终证明</h1><p id="4073" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">这种管道的真正证明是改变应用程序，并通过Git提交将这种改变推广出去。</p><p id="e5e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我做了一点小小的改动，将改动提交给GitHub</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/2a0d70be356aa6389c62ff7d2aa5f46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KrKO4QycmAsj_bpJ."/></div></div></figure><p id="3526" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">推动变革。几乎立即触发工作流程:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/7ebb78d5011b9a5a2f0c4de7ebb00bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hgySRqtBYiAx2iyf."/></div></div></figure><p id="1cab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大约一分钟后，工作流程完成:</p><p id="f11c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更新后的应用程序在Kubernetes上运行:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/9078d752514988a192f6e90f404be4a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J9bf-_EWhCHea8Sr."/></div></div></figure><p id="a007" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">检查Pod中的实时日志:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/d0a2e43cd9ba7e60432acab472a6c919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lDnxIED_c-rl7Eww."/></div></div></figure><p id="8b49" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并再次访问应用程序—现在显示更新的版本:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/75a84e8ab11370e1677ef9d454d5a859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vyNm1eBk0gR0kzrH."/></div></div></figure><p id="d70c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kt">原载于2018年2月22日</em><a class="ae jo" href="https://technology.amis.nl/2018/02/22/set-up-continuous-application-build-and-delivery-from-git-to-kubernetes-with-oracle-wercker/" rel="noopener ugc nofollow" target="_blank"><em class="kt">technology . amis . nl</em></a><em class="kt">。</em></p></div></div>    
</body>
</html>