<html>
<head>
<title>Android Data Binding: Dependent Properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android数据绑定:依赖属性</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-data-binding-dependent-properties-516d3235cd7c?source=collection_archive---------1-----------------------#2017-03-03">https://medium.com/androiddevelopers/android-data-binding-dependent-properties-516d3235cd7c?source=collection_archive---------1-----------------------#2017-03-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="er es hf"><img src="../Images/c462e754a0734abb38ba882e6d20c058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*jReCDKhe0f9_wkxocJ9glw.jpeg"/></div></figure><div class=""/><div class=""><h2 id="6c5f" class="pw-subtitle-paragraph il hn ho bd b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc dx translated">声明而不是编码依赖项</h2></div><p id="819c" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated"><a class="ae jz" href="https://android-developers.googleblog.com/2017/03/android-studio-2-3.html" rel="noopener ugc nofollow" target="_blank"> Android Studio 2.3已经发布</a>，我可以谈一点关于数据绑定的特性，你将能够使用它。您可以做的一件很酷的事情是创建从属属性。</p><h2 id="892b" class="ka kb ho bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku bi translated">名字，名字，名字</h2><p id="3a6d" class="pw-post-body-paragraph jd je ho jf b jg kv ip ji jj kw is jl jm kx jo jp jq ky js jt ju kz jw jx jy ha bi translated">在我的应用程序中，我有一个表示用户的视图模型。它包含名、姓、用户名和显示名。每当这些值改变时，UI应该更新，所以<a class="ae jz" rel="noopener" href="/google-developers/android-data-binding-observability-9de4ff3fe038#.6dnmytszy">我已经使它可观察到</a>。</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="c823" class="ka kb ho lf b fi lj lk l ll lm"><strong class="lf hp">public class </strong>User <strong class="lf hp">extends </strong>BaseObservable {<br/>    <strong class="lf hp">private </strong>String <strong class="lf hp">firstName</strong>;<br/>    <strong class="lf hp">private </strong>String <strong class="lf hp">lastName</strong>;<br/>    <strong class="lf hp">private </strong>String <strong class="lf hp">userName</strong>;<br/>    <strong class="lf hp">private </strong>Resources <strong class="lf hp">resources</strong>;</span><span id="d6b3" class="ka kb ho lf b fi ln lk l ll lm">    <strong class="lf hp">public </strong>User(Resources resources) {<br/>        <strong class="lf hp">this.</strong>resources = resources<strong class="lf hp">;</strong><br/>    }</span><span id="6468" class="ka kb ho lf b fi ln lk l ll lm">    @Bindable<br/>    <strong class="lf hp">public </strong>String getFirstName() {<br/>        <strong class="lf hp">return firstName</strong>;<br/>    }<br/><br/>    <strong class="lf hp">public void </strong>setFirstName(String firstName) {<br/>        <strong class="lf hp">this</strong>.<strong class="lf hp">firstName </strong>= firstName;<br/>        notifyPropertyChanged(BR.firstName);<br/>        notifyPropertyChanged(BR.displayName);<br/>    }<br/><br/>    @Bindable<br/>    <strong class="lf hp">public </strong>String getLastName() {<br/>        <strong class="lf hp">return lastName</strong>;<br/>    }<br/><br/>    <strong class="lf hp">public void </strong>setLastName(String lastName) {<br/>        <strong class="lf hp">this</strong>.<strong class="lf hp">lastName </strong>= lastName;<br/>        notifyPropertyChanged(BR.lastName);<br/>        notifyPropertyChanged(BR.displayName);<br/>    }<br/><br/>    @Bindable<br/>    <strong class="lf hp">public </strong>String getUserName() {<br/>        <strong class="lf hp">return userName</strong>;<br/>    }<br/><br/>    <strong class="lf hp">public void </strong>setUserName(String userName) {<br/>        <strong class="lf hp">this</strong>.<strong class="lf hp">userName </strong>= userName;<br/>        notifyPropertyChanged(BR.userName);<br/>        notifyPropertyChanged(BR.displayName);<br/>    }<br/><br/>    @Bindable<br/>    <strong class="lf hp">public </strong>String getDisplayName() {<br/>        <strong class="lf hp">if </strong>(<strong class="lf hp">firstName </strong>== <strong class="lf hp">null</strong>) {<br/>            <strong class="lf hp">if </strong>(<strong class="lf hp">lastName </strong>== <strong class="lf hp">null</strong>) {<br/>                <strong class="lf hp">return userName</strong>;<br/>            } <strong class="lf hp">else </strong>{<br/>                <strong class="lf hp">return lastName</strong>;<br/>            }<br/>        } <strong class="lf hp">else if </strong>(<strong class="lf hp">lastName </strong>== <strong class="lf hp">null</strong>) {<br/>            <strong class="lf hp">return firstName</strong>;<br/>        } <strong class="lf hp">else </strong>{<br/>            <strong class="lf hp">return resources</strong>.getString(R.id.name<strong class="lf hp">,<br/>                firstName</strong>, <strong class="lf hp">lastName</strong>);<br/>        }<br/>    }<br/>}</span></pre><p id="f108" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">您可以看到显示名称没有支持字段。它检查其他字段并根据其他字段生成一个值。</p><p id="d393" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">使用我的用户类，可以针对所有属性编写数据绑定表达式。每当firstName、lastName和userNames发生变化时，包含displayName的表达式也会更新，因为我已经通知了displayName在相应的setter方法中发生了变化。</p><p id="0d35" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">这是一个常见的场景:一个属性依赖于其他属性。作为依赖项的属性(例如setFirstName())也必须通知它的依赖属性发生了变化，这并不好。</p><h2 id="0652" class="ka kb ho bd kc kd ke kf kg kh ki kj kk jm kl km kn jq ko kp kq ju kr ks kt ku bi translated">声明的依赖属性</h2><p id="9441" class="pw-post-body-paragraph jd je ho jf b jg kv ip ji jj kw is jl jm kx jo jp jq ky js jt ju kz jw jx jy ha bi translated">在<a class="ae jz" href="https://android-developers.googleblog.com/2017/03/android-studio-2-3.html" rel="noopener ugc nofollow" target="_blank"> Android Studio 2.3 </a>中，你现在可以声明一个依赖于其他属性的可绑定属性:</p><pre class="la lb lc ld fd le lf lg lh aw li bi"><span id="172f" class="ka kb ho lf b fi lj lk l ll lm"><strong class="lf hp">public class </strong>User <strong class="lf hp">extends </strong>BaseObservable {<br/>    //...<br/><br/>    @Bindable<br/>    <strong class="lf hp">public </strong>String getFirstName() { ... }<br/>    <strong class="lf hp">public void </strong>setFirstName(String firstName) {<br/>        <strong class="lf hp">this</strong>.<strong class="lf hp">firstName </strong>= firstName;<br/>        notifyPropertyChanged(BR.firstName);<br/>    }<br/><br/>    @Bindable<br/>    <strong class="lf hp">public </strong>String getLastName() { ... }<br/>    <strong class="lf hp">public void </strong>setLastName(String lastName) {<br/>        <strong class="lf hp">this</strong>.<strong class="lf hp">lastName </strong>= lastName;<br/>        notifyPropertyChanged(BR.lastName);<br/>    }<br/><br/>    @Bindable<br/>    <strong class="lf hp">public </strong>String getUserName() { ... }<br/><br/>    <strong class="lf hp">public void </strong>setUserName(String userName) {<br/>        <strong class="lf hp">this</strong>.<strong class="lf hp">userName </strong>= userName;<br/>        notifyPropertyChanged(BR.userName);<br/>    }<br/><br/>    @Bindable({<strong class="lf hp">"firstName"</strong>, <strong class="lf hp">"lastName"</strong>, <strong class="lf hp">"userName"</strong>})<br/>    <strong class="lf hp">public </strong>String getDisplayName() { ... }<br/>}</span></pre><p id="8b8d" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">可绑定注释现在采用一个可选参数来声明依赖关系。displayName属性被声明为依赖于firstName、lastName和userName属性。每当这些属性中的任何一个发生通知更改时，包含displayName的表达式也将被刷新。</p><p id="f707" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">依赖关系在生成的绑定类中被完全评估。这意味着，如果您将一个Observable附加到User，那么当其他属性发生更改时，您将不会收到displayName的通知。</p><p id="e742" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">使用从属属性有助于清理视图模型。虽然底层数据模型是相对规范化的——数据不会在多个属性中重复——但视图模型是根据UI中显示的内容定制的。这意味着属性经常相互影响。</p><p id="ae74" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">例如，假设您的UI显示一张发票，您的商店根据购买的数量提供折扣。折扣取决于小计。以后，如果您将折扣更改为也依赖于运输州，则只更新折扣属性，而不更新州属性。</p><p id="1653" class="pw-post-body-paragraph jd je ho jf b jg jh ip ji jj jk is jl jm jn jo jp jq jr js jt ju jv jw jx jy ha bi translated">从属属性应该有助于保持视图模型的整洁和易于维护。</p></div></div>    
</body>
</html>