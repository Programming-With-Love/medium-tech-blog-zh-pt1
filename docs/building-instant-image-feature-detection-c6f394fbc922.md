# 建筑即时图像特征检测

> 原文：<https://medium.com/pinterest-engineering/building-instant-image-feature-detection-c6f394fbc922?source=collection_archive---------3----------------------->

Kent Brewster | Pinterest 产品工程工程师

上个月，我们在 Chrome 浏览器扩展中推出了[视觉搜索。](/@Pinterest_Engineering/engineering-visual-search-inside-pinterest-browser-extensions-90e7ed9d2b14)在我们发货后，我们注意到很多点击显示“网站”的注释更仔细的检查发现，这些总是来自于从上下文菜单发起的搜索，该菜单在从浏览器窗口生成的屏幕截图上运行视觉搜索。(要用 Chrome 试试这个，右击任何页面的空白处，选择“搜索”。)

全窗口截图的结果和注释非常令人失望。由于它们倾向于匹配之前保存到 Pinterest 的截图，我们显示的结果是“网站”、“互联网网站”和“Wordpress 主题”，而不是截图中有趣的对象。

我们没有一个后端 API 准备好看一个截图，返回里面有趣的东西的列表。即使我们这样做了，它也会慢得令人无法接受，在最好的情况下，会使用户第一次看到选择工具时延迟几秒钟。

我们没有将每一张截图发送回 Pinterest 进行分析，而是想出了一种方法，在浏览器扩展中只使用 JavaScript 来检测有趣的东西。

## 将屏幕截图转换为数据

要搜索图像内部，我们需要查看单个像素的颜色。使用普通的 HTML、CSS 和 JavaScript 通常不可能做到这一点，但是因为我们在浏览器扩展中，所以我们有更高的特权。这里有一个原始截图，渲染到一个

<canvas>标签:</canvas>

![](img/5da619e8311aa2eb10b9390968605ba0.png)

## 对原始数据进行缩减采样

屏幕截图可能会很大，我们将进行一系列递归函数调用，这是一个很好的方式来崩溃浏览器的最大调用堆栈大小超过错误。因此，在我们做任何其他事情之前，让我们将统计世界的大小从 1100x800(几乎一百万像素)减少到最大 80x80。

为此，我们取两个维度(高度或宽度)中较大的一个，除以 80 得到样本大小。如果我们的原始图像是 1100x800，我们将使用 14x14 的样本，将我们的原始图像转换成类似这样的图像:

![](img/3695466032fa6486ed3f90bd6370a904.png)

我们没有做任何花哨的事情，比如平均每个样本样本中的所有颜色；我们只是使用左上角的像素。当被采样的页面没有滚动时，这似乎给了我们更好的结果；顶行和左列的左上角像素往往是主要的背景色。

# 计算并宣布最流行的颜色为“背景色”

一旦我们进行了缩减采样，我们依次查看每个样本样本，并计算我们看到它的颜色的次数。完成后，我们按计数排序，最终得到如下颜色列表:

```
[ “#ffffff”: 1321, “#ffeeee”: 910, “#ffeeaa”: 317 … “#a5e290”: 1]
```

显示最常见颜色的样本(这里我们将使用前三种)被标记为背景。

一旦我们知道我们的背景颜色，我们再次投票所有前景样本。这一次，我们将红绿蓝(RGB)值转换为色调-饱和度-值(HSV)值，并找到与顶部背景色具有相同色调和值的所有样本。当我们找到这些样本时，我们声明它们本身也是背景样本。这捕捉到了许多放大图像下有半透明背景的情况，例如 Twitter 图像和 Instagram 帖子的特写视图。

在计算和标记背景之后，剩下的就是这些了。背景块设置为绿色，所以发生了什么在视觉上很明显。剩余的前景块已经被灰度化，因为它们的颜色不再重要。

![](img/c41a235c5274ce7e0840476d654ed68a.png)

## 移除孤立像素

看到那些绿色的白色和灰色的小岛了吗？那些不够大，无法搜索，所以我们需要一种方法来摆脱它们。我们一次一个样本地浏览图像，并移除任何在北面、南面、东面或西面有包含背景颜色的相邻块的样本。剩下的看起来简单多了:

![](img/384ef1b1fe0a74e6901a2b08c72c0dda.png)

## 填充剩余的前景块，注意高度和宽度

我们只剩下几件事了。现在我们需要选出获胜者。我们是这样做的。

1.  扫描每个样本，计算前景样本的总数**，**这样我们就知道什么时候完成了。
2.  再次扫描。这一次，当我们遇到一个前景块，对它和它所有的邻居**，**进行泛色填充，减少每个块剩下的前景块的数量。
3.  当每个前景区域的整体填充完成时，注意每个区域的最小和最大行和列。每组坐标给我们一个矩形区域，其中包含填充区域内的任何不规则性。转换为行、列、高度和宽度，并添加到感兴趣的矩形列表中。
4.  继续扫描，直到没有任何前景块留下来填充。

还剩下什么？只有有趣的矩形，这里显示为白色:

![](img/41b786d47df759451d8e157004e7b2ed.png)

## 找到世界上最有趣的矩形

矩形更有趣，如果它是:

*   面积大于画布大小的 1/16
*   宽度不超过高度的 3 倍
*   肖像而不是风景
*   比其他相同大小的矩形更靠近左上角

如果矩形是这样的，它就一点也不有趣:

*   尺寸小于 100x100 像素
*   宽度是高度的 5 倍多

重要提示:我们实际上并没有试图寻找矩形或任何其他形状。我们只是在寻找相邻像素之间的颜色差异。如果我们有一个全屏的背景图片，在深绿色的背景上有一朵不规则的黄色的花，我们希望我们的选择器能够围绕着这朵花，即使它不是一个矩形。

一旦我们有了分数，排序和扭转，以找到最好的地区选择。规则没有禁止的最佳矩形获胜。如果我们没有找到一个可接受的矩形，像以前一样选择整个截图。无论哪种方式，画出选择工具，运行搜索，沐浴在更多相关结果的光辉中！

![](img/277c49b8a3b52f26f969e4b00fee5652.png)

## 结果

在我们的浏览器扩展中首次发布视觉搜索后，我们检查了一个匿名的全窗口截图样本，该样本已经由 Pinners 使用选择器工具进行了优化。即时图像特征检测在 85%的情况下与 Pinner 选择的一致(或有所改进)。在所有检测到有趣事物的案例中，搜索注释都返回了比“网站”更好的东西

这些改进现在对每个人都适用，我们在 96%的时间里都能在截图中检测到有趣的东西，相关搜索结果出现和保存的比率更高，所有这些都不需要 Pinner 来优化初始选择。

鸣谢:徐克雷、瑞恩·施、史蒂文·拉姆库玛&史蒂文·沃林