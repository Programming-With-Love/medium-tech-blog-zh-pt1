<html>
<head>
<title>Two-way communication without internet: Nearby Connections (Part 2 of 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有互联网的双向通信:邻近连接(第2部分，共3部分)</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/two-way-communication-without-internet-nearby-connections-b118530cb84d?source=collection_archive---------4-----------------------#2021-06-30">https://medium.com/androiddevelopers/two-way-communication-without-internet-nearby-connections-b118530cb84d?source=collection_archive---------4-----------------------#2021-06-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/c17c31be8bce1dbf08c135f478def54f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWwXoytU0-9xj6yIMKMblg.png"/></div></div></figure><div class=""/><p id="a779" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://developers.google.com/nearby/connections/overview" rel="noopener ugc nofollow" target="_blank">nearly Connections API</a>允许您的用户即使在没有互联网可用的情况下也能相互连接。该API使用蓝牙和其他技术，允许近距离对等通信，通常在100米内。</p><p id="dd37" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这为用户可以做什么或分享什么开辟了许多可能性。例如，用户可以在一个大的组内协作，或者共享视频、文件和文本消息。</p><p id="e651" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当然，团队的规模是有限制的。蓝牙一次只能维持大约4个连接；WiFi一次最多可以连接10到100个连接，这取决于墙上供电的路由器是否可以作为网桥。</p><p id="1e98" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然<a class="ae jn" href="https://developers.google.com/nearby/messages/overview" rel="noopener ugc nofollow" target="_blank">nearly Messages API</a>可以在Android和iOS上运行，但Nearby Connections API只能在Android设备上运行。邻近连接API相对于消息的两个主要优势是:</p><ol class=""><li id="f2bd" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">它允许通过蓝牙和点对点WiFi传输无限量的数据，而“信息”只能传输小数据包(最大4kb)</li><li id="7a70" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">它允许用户在没有互联网连接的情况下相互交流，而“信息”需要互联网连接</li></ol><p id="c503" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要允许您的应用程序为用户启用附近连接API，您必须首先在您的应用程序模块中添加以下Gradle依赖项的<a class="ae jn" href="https://developers.google.com/nearby/messages/android/get-started#step_4_configure_your_project" rel="noopener ugc nofollow" target="_blank">最新版本</a>。</p><figure class="kc kd ke kf fd hj"><div class="bz dy l di"><div class="kg kh l"/></div></figure><p id="3cef" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同样重要的是，Android目前会提示用户代表你向你的应用授予<code class="du ki kj kk kl b">ACCESS_FINE_LOCATION </code>权限。</p><p id="e318" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">即使没有提示用户授予权限，也需要将以下附加权限添加到清单中:</p><ul class=""><li id="7b92" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm km ju jv jw bi translated"><code class="du ki kj kk kl b">BLUETOOTH</code></li><li id="e295" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm km ju jv jw bi translated"><code class="du ki kj kk kl b">BLUETOOTH_ADMIN</code></li><li id="d3bf" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm km ju jv jw bi translated"><code class="du ki kj kk kl b">ACCESS_WIFI_STATE</code></li><li id="402a" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm km ju jv jw bi translated"><code class="du ki kj kk kl b">CHANGE_WIFI_STATE</code></li><li id="4323" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm km ju jv jw bi translated"><code class="du ki kj kk kl b">ACCESS_FINE_LOCATION</code></li></ul><p id="ef5f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Android 10 (API等级29)之前，你的应用只需要请求<code class="du ki kj kk kl b">ACCESS_COARSE_LOCATION</code>权限。但是运行Android 10及更高版本的设备需要<code class="du ki kj kk kl b">ACCESS_FINE_LOCATION</code>。因为在Android框架中精细的位置许可意味着粗略的位置许可——反之则不然——你的应用可以简单地请求所有API级别的<code class="du ki kj kk kl b">ACCESS_FINE_LOCATION</code>。</p><p id="33f2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">重要的是要记住，如果用户没有授予你的应用程序所需的权限，该功能将不会工作，你的应用程序应该<a class="ae jn" href="https://developer.android.com/training/permissions/requesting" rel="noopener ugc nofollow" target="_blank">优雅地处理拒绝</a>。用户可以随时转到<a class="ae jn" href="https://support.google.com/android/answer/3118621?hl=en" rel="noopener ugc nofollow" target="_blank">设置</a>来撤销授予的权限，此时该功能将停止工作。</p><p id="e106" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要让应用程序的两个用户(设备X和设备Y)使用附近的连接API连接和共享内容，必须满足以下条件:</p><p id="b196" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">两个用户必须选择相同的策略。</strong></p><p id="222e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Nearby Connections API要求您指定您的应用程序用于通信的对等<a class="ae jn" href="https://developers.google.com/android/reference/com/google/android/gms/nearby/connection/Strategy" rel="noopener ugc nofollow" target="_blank">策略</a>。</p><p id="71f3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有三种策略选项:</p><ol class=""><li id="2e39" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><code class="du ki kj kk kl b">P2P_CLUSTER</code></li><li id="e7b4" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><code class="du ki kj kk kl b">P2P_STAR</code></li><li id="cb6a" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><code class="du ki kj kk kl b">P2P_POINT_TO_POINT.</code></li></ol><p id="b03b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然带宽限制可能不是您最终选择哪种策略的决定性因素，但是知道<code class="du ki kj kk kl b">P2P_CLUSTER</code>往往会导致比<code class="du ki kj kk kl b">P2P_STAR</code>更低的带宽连接，并且<code class="du ki kj kk kl b">P2P_POINT_TO_POINT</code>往往是三者中吞吐量最高的。</p><figure class="kc kd ke kf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kn"><img src="../Images/0b183239e32a8f8d3c6254372d0764a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zK5abJqeprY8V7mHdwdf3w.png"/></div></div></figure><p id="4275" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦你决定了一个<code class="du ki kj kk kl b">Strategy</code>，广告商必须用它来做广告:</p><figure class="kc kd ke kf fd hj"><div class="bz dy l di"><div class="kg kh l"/></div></figure><p id="17f3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">发现者必须在发现过程中使用相同的<code class="du ki kj kk kl b">Strategy</code>:</p><figure class="kc kd ke kf fd hj"><div class="bz dy l di"><div class="kg kh l"/></div></figure><p id="4f3c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">两台设备上的应用程序必须使用相同的服务Id </strong></p><p id="f136" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du ki kj kk kl b"> serviceId</code>只是你的应用程序发送给API的一个标识符，因此API可以将你的应用程序与其他应用程序区分开来。</p><p id="8b3e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通信只发生在相同的serviceId之间:例如，<code class="du ki kj kk kl b">serviceId=”YouTube”</code>永远不会发现一个设备广告<code class="du ki kj kk kl b">serviceId=”Gmail”</code>。标识符应该是唯一的。因此，最佳实践是使用应用程序的包名作为所有需要它的API调用的唯一标识符。</p><p id="675e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">呼叫和响应</strong></p><p id="447d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当你在设备X上的应用程序调用<code class="du ki kj kk kl b">startAdvertising()</code>时，会传输一个蓝牙信号。</p><p id="bede" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当信号到达设备Y时，附近的连接API调用设备Y上的应用程序中的<code class="du ki kj kk kl b"><a class="ae jn" href="https://developers.google.com/android/reference/com/google/android/gms/nearby/connection/EndpointDiscoveryCallback" rel="noopener ugc nofollow" target="_blank">EndpointDiscoveryCallback</a></code>回调。</p><figure class="kc kd ke kf fd hj"><div class="bz dy l di"><div class="kg kh l"/></div></figure><p id="7c5b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">响应于检测到来自设备X的广告，设备Y可以选择向设备X发送连接请求</p><p id="4c9d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">注意</strong>:在发现模式下，设备Y可能会从附近的100个设备中发现端点，在这种情况下，onEndpointFound()方法将被触发100次。因此，用户通常必须选择向哪个设备发送连接请求。在我们的例子中，用户选择设备x。</p><figure class="kc kd ke kf fd hj"><div class="bz dy l di"><div class="kg kh l"/></div></figure><p id="1076" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">建立连接</strong></p><p id="140d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管响应于来自设备X的广告，连接请求源自设备Y，但是设备X和设备Y都必须接受该连接，以便在两个设备之间建立实际的连接。</p><p id="40aa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">实际的接受发生在回调<code class="du ki kj kk kl b"><a class="ae jn" href="https://developers.google.com/android/reference/com/google/android/gms/nearby/connection/ConnectionLifecycleCallback" rel="noopener ugc nofollow" target="_blank">ConnectionLifecycleCallback</a></code>中。如前面的代码片段所示，广告客户通过<code class="du ki kj kk kl b"> startAdvertising()</code>方法调用将回调传递给API，而发现者通过<code class="du ki kj kk kl b">requestConnection() </code>方法调用传递回调。</p><p id="3874" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管如此，连接请求还是被发送到<code class="du ki kj kk kl b"><a class="ae jn" href="https://developers.google.com/android/reference/com/google/android/gms/nearby/connection/ConnectionLifecycleCallback#onConnectionInitiated(java.lang.String,%20com.google.android.gms.nearby.connection.ConnectionInfo)" rel="noopener ugc nofollow" target="_blank">ConnectionLifecycleCallback#onConnectionInitiated()</a></code>。</p><figure class="kc kd ke kf fd hj"><div class="bz dy l di"><div class="kg kh l"/></div></figure><p id="cba0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">前面代码片段中显示的连接会被自动接受，但是在共享敏感数据时，您应该采取进一步的预防措施。</p><p id="bc6b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">API通过<code class="du ki kj kk kl b">onConnectionInitiated(String endpointId</code>的<code class="du ki kj kk kl b"><a class="ae jn" href="https://developers.google.com/android/reference/com/google/android/gms/nearby/connection/ConnectionInfo" rel="noopener ugc nofollow" target="_blank">ConnectionInfo</a></code>对象为每个连接提供一个唯一的令牌</p><p id="13d9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">，<code class="du ki kj kk kl b">ConnectionInfo info)</code>。您可以从<code class="du ki kj kk kl b"><a class="ae jn" href="https://developers.google.com/android/reference/com/google/android/gms/nearby/connection/ConnectionInfo#getAuthenticationDigits()" rel="noopener ugc nofollow" target="_blank">info.getAuthenticationDigits()</a>.</code>获得令牌</p><p id="895f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们建议向两个用户显示令牌，这样他们可以直观地确认它们是否相等。如果因为用户看不到彼此的屏幕而无法进行视觉确认，您可以让一台设备加密<a class="ae jn" href="https://developers.google.com/android/reference/com/google/android/gms/nearby/connection/ConnectionInfo#public-byte[]-getrawauthenticationtoken" rel="noopener ugc nofollow" target="_blank">原始令牌</a>，在开始共享敏感内容之前将其发送到另一台设备进行解密和比较(更多关于Android加密的信息<a class="ae jn" rel="noopener" href="/androiddevelopers/improve-your-apps-cryptography-from-message-authentication-to-user-presence-869277f50d34">)。</a></p><p id="954f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">通讯</strong></p><p id="e0d2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当两个设备连接时，它们可以通过<code class="du ki kj kk kl b"><a class="ae jn" href="https://developers.google.com/android/reference/com/google/android/gms/nearby/connection/ConnectionsClient#sendPayload(java.lang.String,%20com.google.android.gms.nearby.connection.Payload)" rel="noopener ugc nofollow" target="_blank">sendPayload()</a> </code>方法调用和<code class="du ki kj kk kl b"><a class="ae jn" href="https://developers.google.com/android/reference/com/google/android/gms/nearby/connection/PayloadCallback" rel="noopener ugc nofollow" target="_blank">onPayloadReceived()</a></code>回调向对方发送内容。</p><p id="ed74" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个<code class="du ki kj kk kl b"><a class="ae jn" href="https://developers.google.com/android/reference/com/google/android/gms/nearby/connection/Payload" rel="noopener ugc nofollow" target="_blank">Payload</a> </code>可以是你的用户想要分享的任何东西:流、文件、音乐、视频、照片、文本等等。</p><p id="0870" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个设备通过<code class="du ki kj kk kl b">Nearby.getConnectionsClient(context).acceptConnection(endpointId, payloadCallback)</code>注册他们的<code class="du ki kj kk kl b">onPayloadReceived()</code>回调。然后，任何时候他们想要分享内容，他们只需打电话:</p><figure class="kc kd ke kf fd hj"><div class="bz dy l di"><div class="kg kh l"/></div></figure><p id="ab36" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">总结</strong></p><p id="6d25" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">附近的连接API非常适合Android用户之间的双向通信，特别是如果他们想在不需要蜂窝数据或互联网连接的情况下共享内容。</p><p id="c25a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有关如何使用邻近连接API的更多信息，请参见我们的<a class="ae jn" href="https://developers.google.com/nearby/connections/overview" rel="noopener ugc nofollow" target="_blank">邻近连接API文档</a> <a class="ae jn" href="https://developers.google.com/nearby/connections/overview" rel="noopener ugc nofollow" target="_blank">页面</a>。请继续关注本系列的第3部分，我们将讨论快速配对服务。</p><p id="d6f9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">查看本博客系列的第3部分，点击<a class="ae jn" rel="noopener" href="/androiddevelopers/connect-your-android-users-with-a-tap-fast-pair-ce31d486baff?source=user_profile---------0----------------------------">查看更多内容。</a></p></div></div>    
</body>
</html>