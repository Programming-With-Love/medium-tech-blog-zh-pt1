<html>
<head>
<title>MemQ: An efficient, scalable cloud native PubSub system</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MemQ:一个高效、可扩展的云原生发布系统</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/memq-an-efficient-scalable-cloud-native-pubsub-system-4402695dd4e7?source=collection_archive---------1-----------------------#2021-11-16">https://medium.com/pinterest-engineering/memq-an-efficient-scalable-cloud-native-pubsub-system-4402695dd4e7?source=collection_archive---------1-----------------------#2021-11-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="a897" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Ambud Sharma |测井平台技术主管兼工程经理</p><p id="76f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">日志平台支持Pinterest上的所有数据接收和传输。Pinterest日志平台的核心是分布式PubSub系统，帮助我们的客户异步传输/缓冲数据和消费。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/319aaf0bfc2d7e7bfb876d1dbc521942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mVN3nUAmqABWw4x4w140DA.png"/></div></div></figure><p id="1314" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇博客中，我们介绍了MemQ ( <em class="jo">读作mem — queue </em>)，这是一个为Pinterest的云开发的高效、可扩展的PubSub系统，自2020年年中以来一直为我们提供近实时数据传输用例，并补充了Kafka，同时成本效率提高了90%。</p><h1 id="e52a" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">历史</strong></h1><p id="853d" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">近十年来，<a class="ae ks" rel="noopener" href="/pinterest-engineering/optimizing-kafka-for-the-cloud-4e936643fde0"> Pinterest依赖Apache Kafka </a>作为唯一的发布系统。随着Pinterest的增长，数据量也在增长，围绕运营超大规模分布式PubSub平台的挑战也在增加。大规模运行Apache Kafka让我们对如何构建可扩展的PubSub系统有了更多的了解。在对我们的PubSub环境的运营和可扩展性挑战进行深入调查后，我们得出了以下主要结论:</p><ol class=""><li id="45ef" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">并非每个数据集都需要亚秒级延迟服务，延迟和成本应该成反比(延迟越低，成本越高)</li><li id="e4c3" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">PubSub系统的存储和服务组件需要分开，以实现基于资源的独立可伸缩性。</li><li id="b3d6" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">按读取而不是写入排序为特定的消费者使用情形提供了所需的灵活性(不同的应用程序可能对同一数据集有不同的要求)</li><li id="a503" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">在大多数情况下，严格的分区排序在Pinterest上是不必要的，并且经常会导致可伸缩性的挑战。</li><li id="c4f0" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">Kafka中的重新平衡成本很高，通常会导致性能下降，并对饱和集群上的客户产生负面影响。</li><li id="4cd6" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">在云环境中运行定制复制是非常昂贵的。</li></ol><p id="5a7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2018年，我们试验了一种新型的PubSub系统，该系统将本机利用云。2019年，我们开始正式探索如何解决PubSub可扩展性挑战的选项，并根据运营成本以及现有技术的再造成本评估了多种PubSub技术，以满足Pinterest的需求。我们最终得出结论，我们需要一种PubSub技术，这种技术基于Apache Kafka、Apache Pulsar和脸书LogDevice的知识，并且是为云构建的。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lh"><img src="../Images/f795deca0317232e2d3247cff0dfed75.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*EE99yLv6KnxDDBDV"/></div></figure><p id="8339" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> MemQ是一个新的PubSub系统，它在Pinterest </strong>增强了卡夫卡。它使用了类似于<a class="ae ks" href="https://pulsar.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇脉冲星</a>和<a class="ae ks" href="https://logdevice.io/" rel="noopener ugc nofollow" target="_blank">脸书日志设备</a>的解耦存储和服务架构；但是，它依赖于可插入的复制存储层，即对象存储/ DFS / NFS来存储数据。最终结果是一个PubSub系统，它:</p><ul class=""><li id="8f9f" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb li kz la lb bi translated">处理GB/s流量</li><li id="7d54" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb li kz la lb bi translated">独立扩展、写入和读取</li><li id="a835" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb li kz la lb bi translated">不需要昂贵的重新平衡来处理流量增长</li><li id="1d88" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb li kz la lb bi translated">比我们的卡夫卡足迹高90%的成本效益吗</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lj"><img src="../Images/8dd7f518fe02f5e5c82ab6c89dd60938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4GeCtQgZ2cuYk3xp"/></div></div></figure><h1 id="e363" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">秘制酱</strong></h1><p id="27c9" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">MemQ的秘密在于，它利用微批处理和不可变写入来创建一种架构，在这种架构中，存储层上每秒必要的输入/输出操作数(IOPS)显著减少，从而允许经济高效地使用亚马逊S3这样的云本地对象存储。这种方法类似于网络的分组交换(vs电路交换，即单个大的连续数据存储，如kafka分区)。</p><p id="1608" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MemQ将连续的日志流分解成块(对象)，类似于Pulsar中的分类账，但不同之处在于它们被写成对象并且是不可变的。这些“数据包”/“对象”的大小(在MemQ内部称为“批处理”)在确定端到端(E2E)延迟方面起着重要作用。数据包越小，以更多IOPS为代价写得越快。因此，MemQ允许以更高的IOPs为代价来调整E2E延迟。这种体系结构的一个关键性能优势是能够根据底层存储层分离读和写硬件，允许写和读作为可以跨存储层分布的数据包独立扩展。</p><p id="acfe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这也消除了卡夫卡式的限制，为了恢复一个复制品，一个分区必须从头开始重新复制。在MemQ的情况下，底层复制存储只需要恢复特定的批处理，在存储故障的情况下，该批处理的副本数量由于故障而减少。然而，由于Pinterest的MemQ运行在亚马逊S3上，存储的恢复、分割和扩展由AWS处理，无需Pinterest的任何手动干预。</p><h1 id="f168" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">MemQ的组件</h1><h2 id="3629" class="lk jq hh bd jr ll lm ln jv lo lp lq jz ip lr ls kd it lt lu kh ix lv lw kl lx bi translated"><strong class="ak">客户</strong></h2><p id="9146" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">MemQ客户端使用种子节点发现集群，然后连接到种子节点以发现元数据和托管给定主题的主题处理器的代理，或者对于消费者，是通知队列的地址。</p><h2 id="384c" class="lk jq hh bd jr ll lm ln jv lo lp lq jz ip lr ls kd it lt lu kh ix lv lw kl lx bi translated"><strong class="ak">经纪人</strong></h2><p id="6b1e" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">与其他PubSub系统类似，MemQ也有代理的概念。MemQ代理是集群的一部分，主要负责处理元数据和写请求。</p><p id="c169" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jo">注意:除非使用读取代理，否则MemQ中的读取请求可以直接由存储层处理</em></p><h2 id="2bdb" class="lk jq hh bd jr ll lm ln jv lo lp lq jz ip lr ls kd it lt lu kh ix lv lw kl lx bi translated"><strong class="ak">集群调速器</strong></h2><p id="7846" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">总监是MemQ集群中的领导者，负责自动重新平衡和主题处理器分配。群集中的任何经纪人都可以被选为州长，并且它使用Zookeeper与经纪人通信，zoo keeper也用于州长选举。</p><p id="cfbb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">管理者使用可插入的分配算法做出分配决定。默认情况下，评估代理的可用容量以做出分配决定。调控器还使用此功能来处理代理故障和恢复主题的容量。</p><h2 id="a18f" class="lk jq hh bd jr ll lm ln jv lo lp lq jz ip lr ls kd it lt lu kh ix lv lw kl lx bi translated"><strong class="ak">主题&amp;主题处理器</strong></h2><p id="05a5" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">与其他PubSub系统类似，MemQ使用了主题的逻辑概念。代理上的MemQ主题由一个名为TopicProcessor的模块处理。一个代理可以托管一个或多个主题处理器，其中每个主题处理器实例处理一个主题。主题有写分区和读分区。写分区用于创建主题处理器(1:1关系)，读分区用于确定消费者处理数据所需的并行级别。读取分区计数等于通知队列的分区数。</p><h2 id="c33f" class="lk jq hh bd jr ll lm ln jv lo lp lq jz ip lr ls kd it lt lu kh ix lv lw kl lx bi translated"><strong class="ak">储存</strong></h2><p id="63dd" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">MemQ存储由两部分组成:</p><ol class=""><li id="5fcc" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">复制存储(对象存储/ DFS)</li><li id="2a18" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">通知队列(卡夫卡、脉冲星等))</li></ol><h2 id="19d3" class="lk jq hh bd jr ll lm ln jv lo lp lq jz ip lr ls kd it lt lu kh ix lv lw kl lx bi translated">1.复制存储</h2><p id="ffda" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">MemQ允许可插入的存储处理程序。目前，我们已经为亚马逊S3实施了一个存储处理程序。亚马逊S3为容错、按需存储提供了一个经济高效的解决方案。MemQ使用S3的以下前缀格式来创建高吞吐量和可扩展的存储层:</p><p id="88e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jo"> s3:// &lt;七叶树名称&gt; / &lt; (a)批处理中第一个客户端请求id的2字节哈希&gt; / &lt; (b)集群&gt;/主题/ &lt;主题名称&gt;/T9】</em></p><p id="eea6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(a) =用于S3内部的分区，以便在需要时处理更高的请求速率</p><p id="4183" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(b)= MemQ集群的名称</p><p id="1e6f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">可用性&amp;容错</strong></p><p id="d9b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于S3是一个高度可用的网络规模的对象商店，MemQ依赖它的可用性作为第一道防线。为了适应未来的S3重新划分，MemQ在前缀的第一级添加了一个两位数的十六进制散列，创建了256个基本前缀，理论上，这些前缀可以由独立的S3分区处理，只是为了将来证明它。</p><p id="4a21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">一致性</strong></p><p id="dffd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">底层存储层的一致性决定了MemQ的一致性特征。在S3的情况下，对S3标准的每次写入(PUT)都保证在被确认之前复制到至少三个可用性区域(az)。</p><h2 id="ee3a" class="lk jq hh bd jr ll lm ln jv lo lp lq jz ip lr ls kd it lt lu kh ix lv lw kl lx bi translated">2.通知队列</h2><p id="8b24" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">MemQ使用通知系统向消费者传递数据位置的指针。目前，我们使用Kafka形式的外部通知队列。一旦数据被写入存储层，存储处理器生成通知消息，记录写入的属性，包括其位置、大小、主题等。消费者使用此信息从存储层检索数据(批量)。也有可能使MemQ代理以效率为代价为消费者代理批次。通知队列还为消费者提供集群/负载平衡。</p><p id="6849" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> MemQ数据格式</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ly"><img src="../Images/4f381ff0ddfe82fdf59f98aa39c34ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/0*jf1k7GtZAYjD8gSW"/></div></figure><p id="ad0a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MemQ为消息和批处理使用定制的存储/网络传输格式。</p><p id="1b30" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MemQ中最低的传输单位称为日志消息。这类似于脉冲星信息或卡夫卡制作人记录。</p><p id="c4d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">LogMessage上的包装器允许MemQ进行不同级别的批处理。单位层级:</p><ol class=""><li id="d9db" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">批次(持久性单位)</li><li id="ffb0" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">消息(生产者上传单位)</li><li id="b0d4" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">日志消息(单元应用程序交互)</li></ol><p id="16d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">生产数据</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lz"><img src="../Images/5126e15d3cbfcb89f747a8fc49443d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*Z6PfqgsikFXiN9bl"/></div></figure><p id="39e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MemQ生产者负责向代理发送数据。它使用异步调度模型，允许非阻塞发送发生，而不需要等待确认。</p><p id="0582" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了隐藏底层存储层的上传延迟，同时维护存储级确认，此模型至关重要。这导致了自定义MemQ协议和客户端的实现，因为我们不能使用现有的PubSub协议，它依赖于同步确认。MemQ支持三种类型的ack:ack = 0(生产者开火&amp;忘记)，ack=1(代理收到)，ack=all(存储收到)。在ack=all的情况下，复制因子(RF)由底层存储层确定(例如，在S3标准RF = 3[跨三个az])。如果确认失败，MemQ生产者可以显式或隐式触发重试。</p><p id="f00c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">存储数据<br/></strong>MemQ主题处理器在概念上是一个环形缓冲区。该虚拟环被细分为多个批次，从而简化了写入操作。当消息通过网络到达时，它们被排队到当前可用的批中，直到该批被填满或者基于时间的触发发生。一旦批处理完成，它就被交给存储处理者，以便上传到存储层(如S3)。如果上传成功，如果生产者请求ack，则使用AckHandler通过通知队列将通知连同批中各个消息的确认(ack)一起发送给它们各自的生产者。</p><p id="c0db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">消费数据</strong> <br/> MemQ消费者允许应用程序从MemQ中读取数据。消费者使用代理元数据API来发现指向通知队列的指针。我们向应用程序公开了一个基于轮询的接口，其中每个轮询请求返回一个LogMessages迭代器，以允许成批读取所有LogMessages。这些批处理是使用通知队列发现的，并直接从存储层检索。</p><p id="ca4b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">其他特性</strong> <br/> <em class="jo">数据丢失检测:</em>将工作负载从Kafka迁移到MemQ需要对数据丢失进行严格的验证。因此，MemQ有一个内置的审计系统，可以高效地跟踪每条消息的E2E传递，并近乎实时地发布指标。</p><p id="9926" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jo">批处理&amp;流统一:</em>由于MemQ使用外部化的存储系统，因此它能够提供对原始MemQ数据运行直接批处理的支持，而无需将其转换为其他格式。这允许用户对MemQ执行特别检查，只要存储层可以单独扩展读取和写入，就不用担心寻道性能。根据存储引擎的不同，MemQ消费者可以执行并发读取，以便在某些流情况下实现更快的回填。</p><p id="2c15" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">性能<br/>延迟</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ma"><img src="../Images/ce1c08609046bbf57356db97ff0ea2a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BmcJVIx69BDVWlCV"/></div></div></figure><p id="424a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MemQ支持对存储层的基于大小和时间的刷新，除了一些抑制抖动的优化之外，还支持对最大尾部延迟的硬限制。到目前为止，我们能够通过AWS S3存储实现30秒的p99 E2E延迟，并且正在积极改善MemQ延迟，这增加了可以从Kafka迁移到MemQ的用例数量。</p><p id="5e7f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">成本</strong>这些节省来自几个因素，如:<br/> -减少IOPS <br/> -消除排序限制<br/> -分离计算和存储<br/> -因消除计算硬件而降低复制成本<br/> -放宽延迟限制</p><p id="03c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">可扩展性</strong> <br/>采用S3的MemQ可根据读写吞吐量需求按需扩展。MemQ调控器执行实时重新平衡，以确保只要可以调配计算，就有足够的写入容量可用。代理通过添加额外的代理和更新流量容量要求来线性扩展。如果消费者需要额外的并行性来处理数据，则手动更新读取分区。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ma"><img src="../Images/58823463f2c806e93e8d4b95e64fa11c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gtwKxMISaPmYd-DQ"/></div></div></figure><p id="1781" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Pinterest，我们直接在EC2上运行MemQ，并根据流量和新用例需求扩展集群。</p><p id="77c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">未来工作</strong> <br/>我们正在积极致力于以下领域:<br/> -减少MemQ的E2E延迟(&lt; 5s)以支持更多用例<br/> -支持与流式&amp;批处理系统的本机集成<br/> -读取时的键排序</p><h1 id="bd41" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">结论</strong></h1><p id="32b4" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">MemQ为PubSub提供了一种灵活、低成本的云本地方法。MemQ今天支持Pinterest上所有ML训练数据的收集和传输。我们正在积极研究将其扩展到其他数据集，并进一步优化延迟。除了解决PubSub之外，MemQ存储还可以公开使用PubSub数据进行批处理的能力，而不会对性能产生重大影响，从而实现低延迟批处理。</p><p id="a0c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请继续关注关于我们如何优化MemQ内部以应对可伸缩性挑战和MemQ开源版本的其他博客。</p><h1 id="beb2" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">承认</h1><p id="ad45" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">没有戴夫·伯吉斯和王春燕的坚定支持，MemQ的建立是不可能的。也非常感谢平-林敏，他是MemQ中bug修复和性能优化的关键驱动者，使得大规模生产的推出成为可能。</p><p id="5576" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，感谢Saurabh Joshi、Se Won Jang、、Divye Kapoor、Zhao、和伐木团队促成了MemQ的推出。</p><p id="dcd6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jo">要在Pinterest上了解更多工程知识，请查看我们的</em> <a class="ae ks" href="https://medium.com/pinterest-engineering" rel="noopener"> <em class="jo">工程博客</em> </a> <em class="jo">，并访问我们的</em><a class="ae ks" href="https://www.pinterestlabs.com/?utm_source=medium&amp;utm_medium=blog-article-link&amp;utm_campaign=sharma-november-16-2021" rel="noopener ugc nofollow" target="_blank"><em class="jo">Pinterest Labs</em></a><em class="jo">网站。要查看和申请公开招聘机会，请访问我们的</em> <a class="ae ks" href="https://www.pinterestcareers.com/?utm_source=medium&amp;utm_medium=blog-article-link&amp;utm_campaign=sharma-november-16-2021" rel="noopener ugc nofollow" target="_blank"> <em class="jo">招聘</em> </a> <em class="jo">页面。</em></p></div></div>    
</body>
</html>