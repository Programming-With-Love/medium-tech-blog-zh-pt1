<html>
<head>
<title>Demystifying Louvain’s Algorithm and Its implementation in GPU</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解密Louvain算法及其在GPU中的实现</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/demystifying-louvains-algorithm-and-its-implementation-in-gpu-9a07cdd3b010?source=collection_archive---------0-----------------------#2019-11-21">https://medium.com/walmartglobaltech/demystifying-louvains-algorithm-and-its-implementation-in-gpu-9a07cdd3b010?source=collection_archive---------0-----------------------#2019-11-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/c3d0175439a6067052cfce59b4e9b5b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xt0OcAbBtWqAnVb0AMwjJw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Photo Credit : <a class="ae hu" href="https://pixabay.com/illustrations/network-social-social-networks-1911678/" rel="noopener ugc nofollow" target="_blank">Community Detection</a></figcaption></figure><div class=""/><h1 id="4cf9" class="iu iv hx bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak"> 1。简介:</strong></h1><p id="6801" class="pw-post-body-paragraph js jt hx ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">今天，大多数运行业务的系统都可以用网络的形式来表示。在这个数字时代，网络是代表实体的合适方式，因为今天所有的系统都连接得很好。以网络形式表示的数据也称为图形。与需要更大空间来存储这些关系的关系数据库相比，图表是研究社交媒体、有组织犯罪链接、地理链接等多层次关系网络的更好方式。此外，由于链接元素的冗余存储，搜索链接实体的计算复杂度也会增加。在这篇博客中，我将尝试使用GPU中的Louvain算法来解释图论和社区检测的基本术语。快乐阅读！！</p><h1 id="7a1e" class="iu iv hx bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak"> 2。图表的应用:</strong></h1><ul class=""><li id="6467" class="kq kr hx ju b jv jw jz ka kd ks kh kt kl ku kp kv kw kx ky bi translated"><strong class="ju hy">社交媒体网络:</strong>用户被视为顶点，他们之间的友谊被视为顶点(用户)之间的边的存在。这在好友推荐中很有用。</li><li id="21b2" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated"><strong class="ju hy">零售产品推荐</strong> <strong class="ju hy">零售</strong>:将产品表示为节点，将同一张发票中的采购量表示为边，可以展开产品之间新的多级关系。这些关系推动了向客户推荐产品。</li><li id="8924" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated"><strong class="ju hy">零售欺诈网络</strong>:使用相同信用卡、电话号码、IP地址、设备的客户分析可以使用图表来完成，以识别与股票缩水、支付欺诈等所涉及的客户之间的勾结相关的欺诈。</li><li id="0c28" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated"><strong class="ju hy">地理地图</strong>:每个地图应用程序都使用图形，根据交通拥堵和实际道路距离(边缘)计算两个位置(顶点)之间的最短路径。</li><li id="f7ec" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp kv kw kx ky bi translated"><strong class="ju hy">无监督机器学习</strong>K-Means聚类等算法以图形的形式存储元素，以便更快地计算成对距离。</li></ul><h1 id="e5f5" class="iu iv hx bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak"> 3。理解卢万算法所需的图形术语</strong></h1><p id="1d50" class="pw-post-body-paragraph js jt hx ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">在这一节中，我将带你浏览图形术语，这是理解卢万算法的先决条件。</p><p id="e075" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">什么是图？</strong></p><p id="3d5c" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">图是包含由边连接的节点的非线性数据结构，其中边可以是有向的或无向的。所有术语都将以下面的示例图作为参考进行解释。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lj"><img src="../Images/51630cec998f0bd6cd8bd6b6d07e834b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xnQ2GrEeEFpx5ka719Forw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Basic Graph Example</figcaption></figure><p id="106b" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">节点/顶点:</strong></p><p id="4b25" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">图中用线连接起来的点称为节点。在上图中，节点标记为1到8。</p><p id="ae39" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">边缘:</strong></p><p id="af6e" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">连接<strong class="ju hy">图</strong>中任意两个<strong class="ju hy">节点</strong>的线或弧称为边。</p><p id="483c" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">邻接矩阵:</strong></p><p id="5c98" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">简单标记图的邻接矩阵(也称为连接矩阵)是具有由图节点标记的行和列的矩阵，基于节点是否相邻，图节点在位置(ni，nj)上具有1或0。在下面的矩阵中，行和列标签表示节点，矩阵元素表示边的存在。我们可以观察到，边被标记为1，而它们之间没有链接/边的顶点对被标记为0。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lo"><img src="../Images/f276f3f800de720ac320d40ce99f3313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSLyHjZ7X_M7-pAwWW67gQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Adjacency Matrix Example</figcaption></figure><p id="6097" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">有向和无向图</strong>:</p><p id="df88" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">边没有方向的图称为无向图，而有向图有特定方向的边。在任何社交网络网站中，如果个人是节点，那么他们之间的友谊将是一个无向图，因此该图将被称为无向图。如果边代表谁发送或接收了好友请求，那么它将成为一个有向图。</p><p id="182c" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">社区检测</strong></p><p id="f1ab" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">在任何图结构中，如果节点可以形成多个组，使得与其他组中的节点相比，节点更多地关联/链接到组内的节点，则这些组被称为形成社区。下图显示了分别以蓝色和橙色标识的两个社区。边长代表边的重量。基于边长，与节点5、6、7、8和9相比，蓝色社区中的节点1、2、3和4彼此更接近。这也适用于橙色节点。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lp"><img src="../Images/0069f86cc08acb4efbf48473fa48b7ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tx8CRTCwTHhMXqSUP6a3oQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Community Detection Example</figcaption></figure><p id="9f76" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">在下面的部分中，我们将探索一种最常用的社区检测算法，即Louvain算法。</p><h1 id="3e24" class="iu iv hx bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak"> 4。用于社区检测的Louvain算法:</strong></h1><p id="6f66" class="pw-post-body-paragraph js jt hx ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">Louvain算法是由Vincent D. Blondel，Jean-Loup Guillaume，Renaud Lambiotte和Etienne Lefebvre于2008年在这篇论文中提出的。它是以比利时的一个城市命名的，2007年3月，在比利时的UCL( Louvain-la-Neuve)发表硕士论文时，Etienne Lefebvre首次开发了这种算法。</p><p id="6912" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">简介和成本函数</strong></p><p id="7239" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">任何无监督或有监督的机器学习算法都需要损失/优化/成本函数来决定收敛标准。在社区检测场景中，模块性是一个最合适的优化度量。卢万的算法是基于非常有效地优化模块化。在讨论算法中遵循的步骤之前，让我们首先理解模块化概念。</p><p id="77e4" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">下文中称为分区的社区的质量通过分区的模块性来衡量。模块化Q被定义为下图所示的公式。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/fb45adbe25cd8421259aa0dbf13a1a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ud_jFcElSHEYOT-vRQNDEw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Modularity Definition</figcaption></figure><p id="9240" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">为了更好地解释它，让我们举一个小图表的例子。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lr"><img src="../Images/7790fb9b32c34ce0a76a3a74f822fea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDSetpkTx1AsHQqvWwCxAw.png"/></div></div></figure><p id="6adb" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">根据前面章节中解释的邻接矩阵Aij的定义，该图看起来如下所示。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/2316757ab3f675c3db7a17af763eeb8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lE4H2bM6sWhgJYv-Xi9DA.png"/></div></div></figure><p id="39ea" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">将分区分配视为:</p><p id="8455" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><em class="lt">分区1</em>–1，3，4</p><p id="9536" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><em class="lt">分区2–2，5 </em></p><p id="0046" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">链接数量，m = 5</p><p id="c13a" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">ki，kj是各个节点的度数(在我们的例子中是2)</p><p id="1d9d" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">如果节点属于同一分区，则d(x，y)为0，否则为1。</p><p id="2bb4" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">使用模块化的公式，</p><p id="1284" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">Q = 1/(2 * 5)((0–2 * 2/(2 * 5))* 1+</strong><em class="lt">#节点1到1 - &gt;不存在，相同成员</em></p><p id="8759" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">(1–2 * 2/(2 * 5))* 0+</strong><em class="lt">#节点1到2 - &gt;存在，不同成员</em></p><p id="1292" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">(0–2 * 2/(2 * 5))* 1+</strong><em class="lt">#节点1至4 - &gt;不存在，成员相同</em></p><p id="8ef2" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">(0–2 * 2/(2 * 5))* 0+</strong><em class="lt">#节点1到5 - &gt;存在，不同成员</em></p><p id="da51" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">(1–2 * 2/(2 * 5))* 1+</strong><em class="lt">#节点1至3 - &gt;存在，相同成员</em></p><p id="6313" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">继续矩阵的其余部分，最终简化为:</p><p id="23ff" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">Q = 1/10(7 *(0–2/5)+6 *(1–2/5))= 4/50 = 0.08</strong></p><p id="fee4" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">感谢<a class="ae hu" href="https://www.researchgate.net/post/Can_anyone_provide_a_short_example_of_how_the_modularity_is_being_calculated_in_networks" rel="noopener ugc nofollow" target="_blank">Matthew Joseph在<a class="ae hu" href="https://www.researchgate.net/" rel="noopener ugc nofollow" target="_blank"> ResearchGate </a>中的</a>回答，分享了模块化计算的一次演练。这个解释来自同一个例子。模块性得分的范围在-1和1之间，模块性得分越高，意味着检测到的社区越好，越紧密。</p><p id="36f1" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">算法中遵循的步骤</strong>:</p><p id="8e43" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">算法大致遵循迭代重复的两个步骤(A和B)。</p><p id="4075" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy">一个</strong>。设图网络中有N个节点。在我们的示例中，我们有N = 9个节点，如下图所示。每条边都有特定的权重。</p><ol class=""><li id="4342" class="kq kr hx ju b jv le jz lf kd lu kh lv kl lw kp lx kw kx ky bi translated">首先，每个节点被分配到不同的社区或分区。分区数量等于节点数量n。</li></ol><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ly"><img src="../Images/7639025403277c47b1954ac35b8dd999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BBAq6F6_oZgYD9oltztCfQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Communities Initialisation represented by dotted rings</figcaption></figure><p id="3225" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">2.对于节点I的每个邻居j，通过将I从其分区移动到分区j来检查整体模块性是否增加。节点I被移动到模块性增益最高的分区j(增益应该总是正的)。如果观察到的增益都不是正数，I将保留原来的分区标签。</p><p id="fcd8" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">3.按顺序对所有节点重复步骤2。这称为一次迭代。重复迭代，直到不能实现模块化的改进。这个想法是为了达到模块性的局部最大值，之后模块性不可能进一步增加。请注意，一个节点可以并且很可能被访问不止一次，以通过将它的邻居移动到不同的分区来评估模块性的变化。</p><p id="0e3c" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><strong class="ju hy"> B </strong>。第二步包括通过将步骤a中标记在相同社区中的节点组合在一起(合并单个节点)来重建新网络</p><p id="04b1" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">通过将从一个社区中的每个节点到另一个社区的边的权重相加，来确定两个新社区(包含多于1个节点)之间的边的权重。下面的图片将补充我对算法步骤的解释。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lz"><img src="../Images/a0b9cec5461e22a208e6157e59dc3d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VgKmfhg3BcktWGxxvAy5bQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Nodes 1 and 2 merged into one community</figcaption></figure><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/558450648e33536f1052d1690a4e6e93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PdxJ1RtmrTEUlPPDhD_1A.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Node 3 also got merged with 2 and 3</figcaption></figure><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mb"><img src="../Images/8e4f6e9aaaa9afbff33080039a3753af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zQR8w7wK7CldkjFrkSpizA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Nodes 5 and 7 gets merged into same community and process continues</figcaption></figure><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lz"><img src="../Images/7788dbb46ea6892710a9e71dc6edf12f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-ok_1K2qLMhn_Dorh0vFQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Final community assignments for nodes</figcaption></figure><p id="d237" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">同一社区的节点内的边形成自循环。这意味着即使是邻接矩阵中的对角线元素也将是非零的。</p><p id="e5c4" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">步骤A和B的一次迭代称为一次<strong class="ju hy"> <em class="lt">通过。</em> </strong>第一遍后，算法尝试第二遍，依此类推。每次通过后，社区的数量都会减少。这一直持续到观察到社区标签没有变化，并且达到最大模块化。大多数计算发生在最初的几个过程中，并在最后的过程中以指数方式减少。</p><h1 id="cc3e" class="iu iv hx bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak"> 5。在GPU中实现</strong></h1><p id="4434" class="pw-post-body-paragraph js jt hx ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">在本节中，我将带您了解安装在微软Azure上的CUDA RAPIDS GPU中的<strong class="ju hy"> Louvain算法</strong>的实现步骤。</p><p id="dc18" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">系统配置:</p><p id="f209" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">GPU风味:Volta-100 GPU</p><p id="6bec" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">CUDA-版本9.2</p><p id="5cd2" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">Rapids-版本0.9</p><p id="0ebc" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">云服务提供商:微软</p><p id="9f2d" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">Azure实例类型:N系列NCsv3</p><p id="c778" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">我不打算详细介绍如何为数据科学配置基于GPU云的系统。你可以参考<a class="ae hu" href="https://blogs.nvidia.com/blog/2019/03/18/cuda-x-ai-microsoft-azure/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae hu" href="https://azure.microsoft.com/en-in/blog/azure-machine-learning-service-now-supports-nvidia-s-rapids/" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多详情。</p><p id="ecaf" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">我们将使用一个虚拟数据集，其中包含消息服务/应用程序的成对客户之间交换的消息数量。客户是节点，客户(节点)之间交换的消息数量是各自的边长/权重。</p><p id="a17b" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">将使用两个CUDA库CUDF和CUGRAPH。CUDF 是vanilla python中Pandas的CUDA等价物，用于处理数据框和探索性数据分析。<a class="ae hu" href="https://github.com/rapidsai/cugraph" rel="noopener ugc nofollow" target="_blank"> CUGRAPH </a>包含CUDA RAPIDS中基于图的算法实现。参考<a class="ae hu" href="https://docs.rapids.ai/" rel="noopener ugc nofollow" target="_blank">链接</a>了解更多关于在急流城从事机器学习的工作。</p><p id="002c" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">接下来的步骤:</p><ol class=""><li id="6c6c" class="kq kr hx ju b jv le jz lf kd lu kh lv kl lw kp lx kw kx ky bi translated">导入所需的库</li></ol><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="0e1b" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">2.导入数据集</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mc md l"/></div></figure><figure class="lk ll lm ln fd hj er es paragraph-image"><div class="er es me"><img src="../Images/c3beb2c220843d7b4e67a9fb34449bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*Hx8RpWVqlE5vYqoIzXGg3g.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Sample Data Used for Implementation</figcaption></figure><p id="5984" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">字段<em class="lt">邀请者</em>和<em class="lt">被邀请者</em>是节点，并且<em class="lt"> MsgCount </em>字段包含边权重。字段<em class="lt"> Num表示节点<em class="lt">之间的边/链接</em>。</em></p><p id="5ee5" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">3.节点应该作为整数输入。我们必须从<em class="lt">邀请人</em>和<em class="lt">被邀请人</em>列中删除字符“P”。</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="ec90" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">检查数据。<em class="lt"> src_node </em>和<em class="lt"> des_node </em>是去掉‘P’后的新字段。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mf"><img src="../Images/9c490371bfe785c1b3393b4d6d1950fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aq6qcaAkCwT_dZEgriA5bg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Intermediate Data after removing character “P” from nodes</figcaption></figure><p id="05dc" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">4.将节点的数据类型转换为整数，将边权重转换为浮点数。</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="187d" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">5.CUGRAPH的Louvain算法实现要求节点从零开始。我们必须将每个节点减去1，因为它在我们的数据集中从1开始。</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="fdda" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated"><em class="lt"> src_0 </em>和<em class="lt"> dest_0 </em>是表示要馈送给Louvain算法的节点的字段。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mg"><img src="../Images/4aa958af9a08ff5e50405da6e79d5a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DCL5ih-cCBDVUmny_ABmfw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Sample Data with Nodes starting from 0</figcaption></figure><p id="baa4" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">6.下一步是将这个结构化的表格数据转换成一个Graph对象。</p><p id="ad24" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">我们将创建一个空图。</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mc md l"/></div></figure><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mh"><img src="../Images/50df46f684797958f8b6c5ae912ed817.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4vkjfuWsdkM8_02KGBbBQ.png"/></div></div></figure><p id="5cfa" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">然后从数据帧<em class="lt"> df_chat添加节点和边。</em></p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="6549" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">我们图中的节点总数是131。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/f1e132c728c3267700267c7e8d8f54ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1BUMAOEm8xAFOik_SO4EAg.png"/></div></div></figure><p id="135f" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">7.清算的时刻到了！！运行Louvain社区检测算法，将社区信息存储在<em class="lt"> df_chat_partition </em>对象中，将模块性得分存储在变量<em class="lt"> mod中。</em></p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="ddaa" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">0.94的模块化得分意味着我们检测到了非常封闭的社区:)正如之前本博客<em class="lt">简介和成本函数</em>一节所讨论的。</p><p id="270f" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">每个节点都将被分配一个分区/社区。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mj"><img src="../Images/2eb0f6bbfb7917be7dfb7b3678cb850d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZb1O20SQFH_QaWxBLmh4g.png"/></div></div></figure><p id="1ff6" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">9.检查分区/社区的数量，并探索每个社区的成员。</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="9148" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">检测到47个社区。</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mk"><img src="../Images/3043bf259bbf8ededf368e07a54999a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wz8RxMaiGfFc56fXhIPFGw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Sample data showing communities and its members</figcaption></figure><p id="b3f8" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">我已经展示了几个社区的样本。例如，节点15、76和81属于社区'<em class="lt">分区9' </em>，这意味着与任何其他成员相比，成员P15、p76和P81倾向于在彼此之间交换更多的消息。</p><p id="c10b" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">这就是你如何将Louvain的算法应用于你选择的任何数据集，以迎合类似的需求。代码结构与基于python的pandas代码非常相似，任何熟悉python数据分析的人都可以轻松采用。</p><p id="e407" class="pw-post-body-paragraph js jt hx ju b jv le jx jy jz lf kb kc kd lg kf kg kh lh kj kk kl li kn ko kp ha bi translated">我希望这篇博客给了你一个很好的概述，一般来说是图中的社区发现，特别是Louvain的算法。目前，我正在探索在增量的基础上对新添加到数据集中的节点进行社区标记的策略。我会在以后的博客中分享更多的细节。在此之前，探索在你所属的组织、机构和企业中进行社区检测的可能性。非常感谢你的阅读！！</p><h1 id="ced5" class="iu iv hx bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">6.参考资料:</h1><ol class=""><li id="76fa" class="kq kr hx ju b jv jw jz ka kd ks kh kt kl ku kp lx kw kx ky bi translated"><a class="ae hu" href="https://arxiv.org/pdf/0803.0476.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/0803.0476.pdf</a></li><li id="f344" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp lx kw kx ky bi translated">https://docs.rapids.ai/<a class="ae hu" href="https://docs.rapids.ai/" rel="noopener ugc nofollow" target="_blank"/></li><li id="1f47" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp lx kw kx ky bi translated">【https://github.com/rapidsai/cudf T4】</li><li id="a025" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp lx kw kx ky bi translated"><a class="ae hu" href="https://github.com/rapidsai/cugraph" rel="noopener ugc nofollow" target="_blank">https://github.com/rapidsai/cugraph</a></li><li id="c359" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp lx kw kx ky bi translated"><a class="ae hu" href="https://github.com/rapidsai/notebooks/blob/branch-0.11/cugraph/Louvain.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/rapidsai/notebooks/blob/branch-0.11/Cu graph/louvain . ipynb</a></li><li id="2119" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp lx kw kx ky bi translated"><a class="ae hu" href="https://www.researchgate.net/post/Can_anyone_provide_a_short_example_of_how_the_modularity_is_being_calculated_in_networks" rel="noopener ugc nofollow" target="_blank">https://www . research gate . net/post/Can _ any one _ provide _ a _ short _ example _ of _ how _ the _ modularity _ is _ being _ calculated _ in _ networks</a></li><li id="7df4" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp lx kw kx ky bi translated"><a class="ae hu" href="https://en.wikipedia.org/wiki/Graph_theory" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Graph_theory</a></li><li id="7ed6" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp lx kw kx ky bi translated"><a class="ae hu" href="http://mathworld.wolfram.com/Graph.html" rel="noopener ugc nofollow" target="_blank">http://mathworld.wolfram.com/Graph.html</a></li><li id="8652" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp lx kw kx ky bi translated"><a class="ae hu" href="https://azure.microsoft.com/en-us/pricing/details/virtual-machines/series/" rel="noopener ugc nofollow" target="_blank">https://azure . Microsoft . com/en-us/pricing/details/virtual-machines/series/</a></li><li id="94b8" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp lx kw kx ky bi translated"><a class="ae hu" href="https://developer.nvidia.com/how-to-cuda-python" rel="noopener ugc nofollow" target="_blank">https://developer.nvidia.com/how-to-cuda-python</a></li><li id="7f52" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp lx kw kx ky bi translated"><a class="ae hu" href="https://blogs.nvidia.com/blog/2019/03/18/cuda-x-ai-microsoft-azure/" rel="noopener ugc nofollow" target="_blank">https://blogs . NVIDIA . com/blog/2019/03/18/cuda-x-ai-Microsoft-azure/</a></li><li id="caff" class="kq kr hx ju b jv kz jz la kd lb kh lc kl ld kp lx kw kx ky bi translated"><a class="ae hu" href="https://azure.microsoft.com/en-in/blog/azure-machine-learning-service-now-supports-nvidia-s-rapids/" rel="noopener ugc nofollow" target="_blank">https://azure . Microsoft . com/en-in/blog/azure-machine-learning-service-now-supports-NVIDIA-s-rapids/</a></li></ol></div></div>    
</body>
</html>