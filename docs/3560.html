<html>
<head>
<title>Twirl Modularity with Lazy loading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">延迟加载的旋转模块</h1>
<blockquote>原文：<a href="https://medium.com/globant/twirl-modularity-with-lazy-loading-c6b93dc87ab3?source=collection_archive---------2-----------------------#2020-11-26">https://medium.com/globant/twirl-modularity-with-lazy-loading-c6b93dc87ab3?source=collection_archive---------2-----------------------#2020-11-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="d013" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">了解Reactjs的惰性加载，并使用它来实现模块化级别的路由</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/af7dd1e9ad704b2639e2e4a6e3528a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pzSlPbXpon9HwheCUKUnbw.jpeg"/></div></div></figure><p id="099d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">代码可重用性和<strong class="jk hi">代码分离</strong>是任何应用程序最重要的方面。考虑到这一点，我们可以通过多种方式来分离和编写可重用的代码，</p><ol class=""><li id="b676" class="ke kf hh jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated"><strong class="jk hi">分离组件</strong></li></ol><p id="41e3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">2.<strong class="jk hi">分离模块</strong></p><p id="c7ef" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">有了<strong class="jk hi">可重用性</strong>和<strong class="jk hi">分离</strong>，还有一个更重要的方面我们在编写程序时应该牢记在心。就是应用的<strong class="jk hi">性能</strong>。任何应用程序的性能都可以很容易地通过其初始加载时间来定义，或者直接与应用程序启动时加载的代码块成比例。对于每个组件和模块，都有一大块代码被加载。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es kn"><img src="../Images/0d0ea418ceb9065da14e3dc7a8a48e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oqs1ZzkXcy2lyxsA"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Photo by <a class="ae ks" href="https://unsplash.com/@michaelfenton?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michael Fenton</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7819" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">同样，对于每个组件或模块的路由，特定的代码块<strong class="jk hi">被加载到浏览器中。我们可以通过开发者工具中的<strong class="jk hi">网络</strong>标签看到这些块的<strong class="jk hi">大小</strong>以及它们加载到我们的应用程序中所花费的时间。最初加载的这些代码块应该很小，加载时间应该尽可能短。为了实现这一点，我们只需要在加载应用程序</strong>的<strong class="jk hi">时间加载那些绝对<strong class="jk hi">必需的<strong class="jk hi">组件/模块</strong>。</strong></strong></p><h2 id="e848" class="kt ku hh bd kv kw kx ky kz la lb lc ld jr le lf lg jv lh li lj jz lk ll lm ln bi translated">Reactjs中如何实现惰性加载？</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lo"><img src="../Images/828e9c88a044ef2edc7731e169d3d13b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j7LK8dREcg5UwJaQ"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Photo by <a class="ae ks" href="https://unsplash.com/@tiniiiii?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Martina Misar-Tummeltshammer</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="177d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> React.lazy </strong>函数允许我们在应用程序中动态呈现<strong class="jk hi"> import </strong>语句。</p><p id="ca77" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在下面的代码示例中，我们使用lazy方法导入About Component。当该组件第一次被<strong class="jk hi">渲染</strong>时，<strong class="jk hi">将加载</strong>由about组件包含的<strong class="jk hi">包</strong>。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lp"><img src="../Images/d36c9a21503fd63eacd3b01935362b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_gjASLUaBJ66MA1ktvXi5A.png"/></div></div></figure><p id="5b1d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> lazy() </strong>方法采用一个必须动态调用<strong class="jk hi"> import() </strong>方法的函数。这个方法的<strong class="jk hi">返回</strong>类型是<strong class="jk hi">承诺</strong>，它将被<strong class="jk hi">解析</strong>为一个<strong class="jk hi">模块</strong>，带有一个<strong class="jk hi">导出默认</strong>，包含<strong class="jk hi">反应</strong>组件。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lq"><img src="../Images/ea4f9afe8e206d57691cfe20422c6880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0zOuPiw7alLZvDo4u9GrWA.png"/></div></div></figure><p id="eb52" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">惰性加载的about组件需要在悬念方法中呈现，这将允许在等待组件加载时加载一些后备内容或UI。和上面的例子一样，我们使用fallback UI作为加载器组件。</p><h1 id="da0b" class="lr ku hh bd kv ls lt lu kz lv lw lx ld in ly io lg iq lz ir lj it ma iu lm mb bi translated">具有惰性加载路由的基于模块的代码分离</h1><p id="2ae0" class="pw-post-body-paragraph ji jj hh jk b jl mc ii jn jo md il jq jr me jt ju jv mf jx jy jz mg kb kc kd ha bi translated">应用中可以有<strong class="jk hi">多个</strong> <strong class="jk hi">模块</strong>。在每个<strong class="jk hi">模块</strong>中，可以有<strong class="jk hi">多条</strong> <strong class="jk hi">路线</strong>。我们可以让那些<strong class="jk hi">路线</strong>到<strong class="jk hi">在<strong class="jk hi">申请</strong> <strong class="jk hi">启动</strong>时不需要的</strong><strong class="jk hi"/>。让我们通过一个例子来理解这一点。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mh"><img src="../Images/6d33cf02264ec6e86680f31dcf896032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PgElUt8Pqy9oaXAf2Y2vg.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Lazy Loaded AboutModule</figcaption></figure><p id="a8ae" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在上面的代码片段中，我们为将被<strong class="jk hi">延迟</strong>加载的about组件定义了路由，然后我们使用那个<strong class="jk hi">路由</strong>并通过<strong class="jk hi">about模块</strong>导出它。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mi"><img src="../Images/7f79a292d0ee9060ed01cccd569a1900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8TjEVmCeKfCvsp0qbVzyw.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Todo Component Routing</figcaption></figure><p id="3c4e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在上面的代码片段中，我们定义了<strong class="jk hi"> todo </strong>路线，然后<strong class="jk hi">通过<strong class="jk hi"> TodoModule </strong>导出</strong>路线。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mj"><img src="../Images/f676d3b9d0d44b57f97416bbf5b32042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jDXzFQdA5DeKJSW-6K_nFw.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">App Routing with Todo and About module</figcaption></figure><p id="bbb4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在上面的代码片段中，我们使用了<strong class="jk hi">默认的</strong>路径作为<strong class="jk hi">//</strong><em class="mk">，这将加载</em><strong class="jk hi"><em class="mk"/></strong><em class="mk"/><strong class="jk hi"><em class="mk"/>todo</strong>组件作为<strong class="jk hi">默认。每当我们转到<strong class="jk hi"> /about时，About组件将被延迟加载。</strong>当我们进入任何模块中未涉及的任何路线时，我们将<strong class="jk hi">重定向</strong>到<strong class="jk hi">/404</strong>-页面<strong class="jk hi">组件</strong>。</strong></p><h1 id="0bca" class="lr ku hh bd kv ls lt lu kz lv lw lx ld in ly io lg iq lz ir lj it ma iu lm mb bi translated">结论</h1><p id="f0d9" class="pw-post-body-paragraph ji jj hh jk b jl mc ii jn jo md il jq jr me jt ju jv mf jx jy jz mg kb kc kd ha bi translated">使用上述技术，我们可以提高应用程序的性能，并实现最佳的编码实践。</p></div><div class="ab cl ml mm go mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ha hb hc hd he"><blockquote class="ms"><p id="411b" class="mt mu hh bd mv mw mx my mz na nb kd dx translated">“编写易于删除而不易于扩展的代码”</p><p id="1575" class="mt mu hh bd mv mw mx my mz na nb kd dx translated">— Tef，编程太可怕了</p></blockquote></div><div class="ab cl ml mm go mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ha hb hc hd he"><p id="c68a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">感谢阅读</strong>！做<strong class="jk hi">拍手</strong>👏如果你觉得<strong class="jk hi">有用</strong>😉</p><div class="nc nd ez fb ne nf"><a href="https://eloquentjavascript.net/10_modules.html" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hi fi z dy nk ea eb nl ed ef hg bi translated">模块::雄辩的JavaScript</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">写容易删除，不容易扩展的代码。Tef，编程是可怕的理想的程序有一个…</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">eloquentjavascript.net</p></div></div><div class="no l"><div class="np l nq nr ns no nt jg nf"/></div></div></a></div><div class="nc nd ez fb ne nf"><a href="https://reactjs.org/docs" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hi fi z dy nk ea eb nl ed ef hg bi translated">开始行动-做出反应</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">用于构建用户界面的JavaScript库</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">reactjs.org</p></div></div><div class="no l"><div class="nu l nq nr ns no nt jg nf"/></div></div></a></div></div></div>    
</body>
</html>