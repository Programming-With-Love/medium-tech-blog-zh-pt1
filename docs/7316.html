<html>
<head>
<title>Challenge — Table of Contents Generator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">挑战—目录生成器</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/challenge-table-of-contents-generator-c99171fde831?source=collection_archive---------3-----------------------#2018-06-19">https://medium.com/square-corner-blog/challenge-table-of-contents-generator-c99171fde831?source=collection_archive---------3-----------------------#2018-06-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/332128cada1e7fe04fcff2704fbe59ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q7GNAiDHc9grllbQ8WSVCw.png"/></div></div></figure><blockquote class="ip iq ir"><p id="a065" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jr" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="862a" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">介绍开发者挑战！这是一个新的系列，我们发布了由现实世界应用激发的挑战。</p><p id="b4cd" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">虽然本文后面会给出解决方案，但我们鼓励您先尝试一下这个挑战！我们将在推特<a class="ae jr" href="https://twitter.com/SquareDev" rel="noopener ugc nofollow" target="_blank"> @SquareDev </a>上重点介绍我们获得的顶级解决方案。</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jv"><img src="../Images/a314d9d7b37f513d95c06d9ff4bdd195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M554vJvZJPOYpM2jFgsfkw.png"/></div></div></figure><h1 id="4b40" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题是</h1><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es ky"><img src="../Images/5417a74f34859865d58624681a1112db.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*NSWGCTnlFmhY-je5K3IJ7w.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx">Questions questions, we’ve got a question.</figcaption></figure><p id="5792" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">给定一个具有多个标题的HTML页面，我们希望提取标题来制作一个目录:</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="2d3f" class="li kb hh le b fi lj lk l ll lm">&lt;h1&gt;Main title of the page&lt;/h1&gt;</span><span id="f1fd" class="li kb hh le b fi ln lk l ll lm">&lt;h2&gt;Sub title&lt;/h2&gt;</span><span id="97a2" class="li kb hh le b fi ln lk l ll lm">&lt;p&gt;Some text content&lt;/p&gt;</span><span id="bcba" class="li kb hh le b fi ln lk l ll lm">&lt;h2&gt;Another sub title&lt;/h2&gt;</span><span id="9ff0" class="li kb hh le b fi ln lk l ll lm">&lt;p&gt;description&lt;/p&gt;</span><span id="1158" class="li kb hh le b fi ln lk l ll lm">&lt;h3&gt;Sub sub title&lt;/h3&gt;</span><span id="e045" class="li kb hh le b fi ln lk l ll lm">&lt;p&gt;sub description&lt;/p&gt;</span></pre><p id="217c" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">现在我们最想要的是从这个列表中提取一个目录。现在我们可以从一个无序列表开始:</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="f54d" class="li kb hh le b fi lj lk l ll lm">&lt;ul&gt;<br/>  &lt;li&gt;Main title of the page<br/>    &lt;ul&gt;<br/>      &lt;li&gt;Sub title&lt;/li&gt;<br/>      &lt;li&gt;Another sub title<br/>        &lt;ul&gt;<br/>          &lt;li&gt;Sub sub title&lt;/li&gt;<br/>        &lt;/ul&gt;<br/>      &lt;/li&gt;<br/>    &lt;/ul&gt;<br/>  &lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="607a" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这个，放在我们的内容上面，看起来像这样:</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lo"><img src="../Images/44dd15570425ae402dd3a9d716d8f197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1u3TAfuLu7564zLLMS2quA.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx">The apex of HTML styling. Beautiful.</figcaption></figure><p id="56b9" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">因此，给定一个页面，目标是返回一个无序列表，表示它的目录。</p><h1 id="845e" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">试试看！</h1><p id="2001" class="pw-post-body-paragraph is it hh iv b iw lp iy iz ja lq jc jd js lr jg jh jt ls jk jl ju lt jo jp jq ha bi translated">想试试吗？下面是Ruby中使用RSpec的一些基本规范:</p><figure class="jw jx jy jz fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="3c64" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">话虽如此，让我们深入探讨解决方案吧！在你尝试之前不要偷看。</p><h1 id="b48e" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">一个解决方案</h1><p id="254f" class="pw-post-body-paragraph is it hh iv b iw lp iy iz ja lq jc jd js lr jg jh jt ls jk jl ju lt jo jp jq ha bi translated">这个问题有趣的地方在于，我们试图把一些线性的东西做成树状结构。</p><p id="d3a4" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">请注意，我们的解决方案不会被完美地分解，但会寻求一种可行的技术来解决这个问题。我们将把它作为一个练习留给有抱负的读者。</p><p id="c422" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><strong class="iv hi">树节点</strong></p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es lw"><img src="../Images/531ae88bc1f05dbade3d1a9a2bfca9e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*MoUK1hl48wMpwPO8qfiPqw.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx">We can branch out a bit</figcaption></figure><p id="31e7" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">为此，我们将从树节点的概念开始:</p><figure class="jw jx jy jz fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="327f" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们希望能够捕捉标题标签的概念，它有潜在的子标题和潜在的父标题。</p><p id="4835" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">举一个简单的例子，我们可能会这样:</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="37ff" class="li kb hh le b fi lj lk l ll lm">h1 = TreeNode.new('h1', 'Title')<br/>h1.add_child('h2', 'Subtitle')<br/>h1.add_child('h2', 'Another Subtitle')</span></pre><p id="f625" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">现在你可以自由地添加子标签到一个头节点，还有一个<code class="du lx ly lz le b">to_s</code>和<code class="du lx ly lz le b">to_h</code>方法可以让我们深入了解:</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="ebf7" class="li kb hh le b fi lj lk l ll lm">puts h1<br/># [h1] Title<br/>#   [h2] Subtitle<br/>#   [h2] Another Subtitle</span><span id="f80a" class="li kb hh le b fi ln lk l ll lm">h1.to_h<br/>{<br/>  "name" =&gt; "Title",<br/>  "children" =&gt; [<br/>    {"name"=&gt;"Subtitle", "children"=&gt;[]},<br/>    {"name"=&gt;"Another Subtitle", "children"=&gt;[]}<br/>  ]<br/>}</span></pre><p id="2430" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们还可以判断一个特定的标签是否是另一个标签的后代:</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="a232" class="li kb hh le b fi lj lk l ll lm">h1.descendant?('h2') # =&gt; true<br/>h1.descendant?('h3') # =&gt; true</span></pre><p id="0550" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">考虑到这一点，如果有人试图添加一个不是后代的孩子，我们可能会引发一个错误，但我们也不会直接使用它。</p><p id="7825" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这里的最后一个东西是一个<code class="du lx ly lz le b">to_html</code>方法，它将赋予我们递归生成HTML的能力。如果我们在<a class="ae jr" href="https://github.com/threedaymonk/htmlbeautifier" rel="noopener ugc nofollow" target="_blank">html beautiier</a>中运行它，它会更容易解析:</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="d9ee" class="li kb hh le b fi lj lk l ll lm">puts HtmlBeautifier.beautify(h1.to_html)<br/>&lt;li&gt;Title<br/>  &lt;ul&gt;<br/>    &lt;li&gt;Subtitle&lt;/li&gt;<br/>    &lt;li&gt;Another Subtitle&lt;/li&gt;<br/>  &lt;/ul&gt;<br/>&lt;/li&gt;</span></pre><p id="0e86" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">但这带来了上面提到的那个<code class="du lx ly lz le b">h0</code>的有趣问题，以及奇怪的缺少外部<code class="du lx ly lz le b">&lt;ul&gt;</code>元素。这是有原因的，我们将在下一部分强调。</p><p id="5200" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这就把我们带到了解决方案的下一部分:提取内容。</p><p id="449a" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><strong class="iv hi"> Nokogiri </strong></p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es ky"><img src="../Images/74a6938584bf389321889fad95db0297.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*_KxXsF4JSqlEVFlqoSTtmQ.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx">Tag! You’re it.</figcaption></figure><p id="610d" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">第一步是我们需要从给定的HTML中获取header标签。为此，我们可以利用Nokogiri和<code class="du lx ly lz le b">css</code>选择器:</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="a5ae" class="li kb hh le b fi lj lk l ll lm"><strong class="le hi">require 'nokogiri'</strong></span><span id="e188" class="li kb hh le b fi ln lk l ll lm">Nokogiri('&lt;h1&gt;title&lt;/h1&gt;')<br/>  .<strong class="le hi">css</strong>('h1, h2, h3, h4, h5, h6')</span><span id="4eb7" class="li kb hh le b fi ln lk l ll lm"># =&gt; [#&lt;Nokogiri::XML::Element:0x3fd76d0be044 name="h1" children=[#&lt;Nokogiri::XML::Text:0x3fd76c96944c "title"&gt;]&gt;]</span></pre><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es ma"><img src="../Images/1542140542369be35a005562d2946986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*FG9TxOe6XpMAcR3Vpr40Mw.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx">We only want to grab the header tags, everything else can be ignored</figcaption></figure><p id="0d46" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">问题是，这对于碎片来说就不那么管用了:</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="cb85" class="li kb hh le b fi lj lk l ll lm">Nokogiri('&lt;h1&gt;title&lt;/h1&gt;&lt;h2&gt;test&lt;/h2&gt;&lt;h2&gt;test2&lt;/h2&gt;')<br/>  .css('h1, h2, h3, h4, h5, h6')</span><span id="4506" class="li kb hh le b fi ln lk l ll lm"># =&gt; [#&lt;Nokogiri::XML::Element:0x3fd76c9719a8 name="h1" children=[#&lt;Nokogiri::XML::Text:0x3fd76c970e40 "title"&gt;]&gt;]</span></pre><p id="0410" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">所以我们可以欺骗一下:</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="6a4a" class="li kb hh le b fi lj lk l ll lm">html = '&lt;h1&gt;title&lt;/h1&gt;&lt;h2&gt;test&lt;/h2&gt;&lt;h2&gt;test2&lt;/h2&gt;'<br/>Nokogiri("<strong class="le hi">&lt;html&gt;</strong>#{html}<strong class="le hi">&lt;/html&gt;</strong>")<br/>  .css('h1, h2, h3, h4, h5, h6')</span><span id="b03a" class="li kb hh le b fi ln lk l ll lm"># =&gt; [#&lt;Nokogiri::XML::Element:0x3fd76dcd40cc name="h1" children=[#&lt;Nokogiri::XML::Text:0x3fd76e40bee4 "title"&gt;]&gt;, #&lt;Nokogiri::XML::Element:0x3fd76e40bac0 name="h2" children=[#&lt;Nokogiri::XML::Text:0x3fd76e40b8f4 "test"&gt;]&gt;, #&lt;Nokogiri::XML::Element:0x3fd76e40b73c name="h2" children=[#&lt;Nokogiri::XML::Text:0x3fd76e40b570 "test2"&gt;]&gt;]</span></pre><p id="f135" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这样我们就获得了所有的头，这意味着我们可以进入下一部分:头提取器。</p><p id="c03e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><strong class="iv hi">割台提取器</strong></p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es ky"><img src="../Images/2c5b0fedb768abb2e2bf7e959c55067f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*jrOL4V_qkZCs2ol7xXjGBw.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx">Descending the nodes</figcaption></figure><p id="9d75" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">现在我们有了一种获取头的方法，让我们将它与前面的TreeNode结合起来:</p><figure class="jw jx jy jz fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/7d09e6f983b06d6131051a7fff3e4f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tBOPmDsK5wWmuLMK36IXTA.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx">Root node goes in, children get added, and we return the root node afterwards</figcaption></figure><p id="649b" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">现在这个可能很密集。我们来分解一下！</p><p id="12c3" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><em class="iu">根节点</em></p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/4eb11885bd59a84fd073a5cd06f8b44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*5PTDDspAoXEinyRACTJ-OQ.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx">It’s rooting for you</figcaption></figure><p id="c13c" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">第一部分定义了一个“根节点”,我们可以用它来捕获任何级别的头。在<em class="iu">和</em>的情况下，一个页面上有多个<code class="du lx ly lz le b">h1</code>标签，或者根本没有标签，这使得创建一个树变得非常困难。甚至可能会有一个<code class="du lx ly lz le b">h3</code>第一，这使得它更加有趣。</p><p id="c7f1" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这意味着我们在迭代的时候必须忽略它，但是它在相对深度上给我们提供了很大的灵活性。当然，在顺序上让一个<code class="du lx ly lz le b">h3</code>优先于一个<code class="du lx ly lz le b">h1</code>是不寻常的，但是这是留给读者的一个练习，希望HTML作者能这样做。</p><p id="11e8" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><em class="iu"> Nokogiri CSS </em></p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es ky"><img src="../Images/74a6938584bf389321889fad95db0297.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*_KxXsF4JSqlEVFlqoSTtmQ.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx">Oi, no tag backs</figcaption></figure><p id="fb6b" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们已经看到了这个，唯一的区别是我们把标题作为可选参数传入，并把它精简到只挖掘到<code class="du lx ly lz le b">h3</code>。</p><p id="8829" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><em class="iu">彻底还原</em></p><p id="ece0" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这就是它变得有点有趣的地方。</p><p id="75e3" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">第一个要素是上升:</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="8990" class="li kb hh le b fi lj lk l ll lm">current_tree = current_tree.parent <strong class="le hi">until<br/>  </strong>current_tree.descendant?(tag.name)</span></pre><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es ky"><img src="../Images/9a38c413cab64b1de1594c3a64fb58e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*yvKTHn0jYSTPQjtqIIUVIQ.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx">Ascending nodes until we find one which has a higher hierarchy than the tag</figcaption></figure><p id="3c2e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们正在做的是一步一步地回到树上，直到我们找到它的后代。由于根节点是顶层父节点，我们可以确保总有一个顶层可以将任何标签作为后代。</p><p id="0ce2" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">在我们到达我们想要的树之后，我们给它添加一个孩子:</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="b70b" class="li kb hh le b fi lj lk l ll lm">current_tree.<strong class="le hi">add_child</strong>(tag.name, tag.text)</span></pre><p id="05af" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">如果我们回头看看前面的实现，我们会注意到它返回了子树，这意味着现在这是我们的新树。假设我们有一个<code class="du lx ly lz le b">h2</code>和另一个<code class="du lx ly lz le b">h2</code>，这意味着它上升一次，然后添加到第一个<code class="du lx ly lz le b">h2</code>的父节点。</p><p id="679c" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><em class="iu">回根</em></p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es lw"><img src="../Images/531ae88bc1f05dbade3d1a9a2bfca9e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*MoUK1hl48wMpwPO8qfiPqw.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx">…and then there was a tree! Fancy that!</figcaption></figure><p id="2e5e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">既然我们已经检查了所有的头，我们只需要返回根节点和所有完整的子节点。</p><p id="3371" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">考虑到我们之前的<code class="du lx ly lz le b">to_h</code>方法和<code class="du lx ly lz le b">to_s</code>方法，我们可以试一试！我们来看看jquery.com:</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="1c5f" class="li kb hh le b fi lj lk l ll lm">require 'net/http'<br/>html = Net::HTTP.get(URI('https://jquery.com'))</span><span id="c5df" class="li kb hh le b fi ln lk l ll lm">puts header_extractor(html)<br/>[h0] ROOT<br/>  [h2] jQuery<br/>    [h3] Lightweight Footprint<br/>    [h3] CSS3 Compliant<br/>    [h3] Cross-Browser<br/>  [h2] What is jQuery?<br/>  [h2] Other Related Projects<br/>    [h3] Resources<br/>  [h2] A Brief Look<br/>    [h3] DOM Traversal and Manipulation<br/>    [h3] Event Handling<br/>    [h3] Ajax<br/>    [h3] Books</span></pre><p id="c950" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们可以看到早期使用多个顶级节点的潜在乐趣。这种类型的问题在处理多个片段时尤其普遍。</p><h1 id="c4b1" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">完整的解决方案</h1><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es ky"><img src="../Images/b537432130f65f1681c4c8fa1704adcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*oyz65yehxWw6kzh6Q-eEoQ.png"/></div><figcaption class="kz la et er es lb lc bd b be z dx">Tu too rooooo! Victory! You got 15 exp. Whimsy leveled up!</figcaption></figure><p id="ffae" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这样我们就有了完整的解决方案:</p><figure class="jw jx jy jz fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="b900" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">…测试呢？</p><pre class="jw jx jy jz fd ld le lf lg aw lh bi"><span id="3e96" class="li kb hh le b fi lj lk l ll lm">Finished in 0.44593 seconds (files took 0.21331 seconds to load)<br/>5 examples, 0 failures</span></pre><p id="6c8d" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">厉害！</p><h1 id="48c0" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">有解决办法吗？</h1><p id="bdbd" class="pw-post-body-paragraph is it hh iv b iw lp iy iz ja lq jc jd js lr jg jh jt ls jk jl ju lt jo jp jq ha bi translated">我们希望看到您的解决方案！请发推文到<a class="ae jr" href="https://twitter.com/SquareDev" rel="noopener ugc nofollow" target="_blank"> @SquareDev </a>给我们，我们将在下一轮挑战开始时重点介绍最佳解决方案。</p><p id="fcd1" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">下次见。</p><p id="ac88" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><em class="iu">想要更多吗？</em> <a class="ae jr" href="https://www.workwithsquare.com/developer-newsletter.html?channel=Online%20Social&amp;sqmethod=Blog" rel="noopener ugc nofollow" target="_blank"> <em class="iu">注册</em> </a> <em class="iu">为你的每月开发者简讯或</em> <a class="ae jr" href="https://squ.re/2Hks3YE" rel="noopener ugc nofollow" target="_blank"> <em class="iu">顺道拜访</em></a><em class="iu">the Square dev Slack channel并说声“嗨！”</em></p></div></div>    
</body>
</html>