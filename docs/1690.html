<html>
<head>
<title>Serverless Stream Consumers — Common Pitfalls and Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器流消费者——常见陷阱和最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/serverless-stream-consumers-common-pitfalls-and-best-practices-8fd431a892f?source=collection_archive---------2-----------------------#2019-06-17">https://medium.com/capital-one-tech/serverless-stream-consumers-common-pitfalls-and-best-practices-8fd431a892f?source=collection_archive---------2-----------------------#2019-06-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/cadb9277cca3d2ffa97e1c80d5959606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jb9In35eBCFMbOp1"/></div></div></figure><p id="4312" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">乍一看，总是可用的基于AWS Lambda的流消费者的想法看起来像是一种反模式。您希望如何(或者为什么)在一个短暂的容器中运行一个永久的、高容量的流消费者？从运营效率的角度来看，好处是易于基础架构管理。有了无服务器的流消费者，同一公司的不同团队可以利用、贡献和采用代码库，而不需要管理基础设施。</p><p id="9bc6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">像网飞这样的公司已经证明了流处理即服务(SpaaS)模式的好处，例如他们的<a class="ae jn" rel="noopener" href="/netflix-techblog/keystone-real-time-stream-processing-platform-a3ee651812a"> Keystone </a>和<a class="ae jn" rel="noopener" href="/netflix-techblog/stream-processing-with-mantis-78af913f51a6"> Mantis </a>平台等项目。在这种模式中，您希望您的工程团队专注于交付提供业务价值的解决方案，而不是在同一组织内的团队之间复制现有的基础架构。</p><h2 id="628b" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">为什么选择AWS Lambda？</h2><p id="a9ff" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">将流消费者作为AWS Lambda函数运行的好处通常与无服务器计算的好处密切相关。亚马逊提供了一项名为AWS Kinesis的服务，允许开发人员经济高效地处理流媒体数据。通过<a class="ae jn" href="https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis-example.html" rel="noopener ugc nofollow" target="_blank">几行代码</a>，你可以建立一个简单的、事件驱动的应用程序，当新事件出现时执行动作。</p><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ko"><img src="../Images/94a1412637763da03fec92cbae14df34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGn-sM6e-jdTgZwP-grreQ.png"/></div></div></figure><p id="6bd4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您预计事件发生的频率较低，那么与基于服务器的基础架构相比，当事件未被处理时，让您的无服务器应用程序处于“停机”状态具有显著的成本效益优势。</p><h2 id="0014" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">事件驱动的消费者架构</h2><p id="74bc" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">虽然Kinesis和Lambda的结合可以方便地集成到您的VPC中，但当试图消耗大量数据时，事件驱动范式并不总是最有效的。为了保证顺序处理，每个Lambda消费者被分配到一个单独的Kinesis分片，这意味着当你扩展时，<a class="ae jn" href="https://docs.aws.amazon.com/streams/latest/dev/kinesis-using-sdk-java-resharding.html" rel="noopener ugc nofollow" target="_blank">你可能需要重新分片</a>。因为你是按片收费的，分割会增加你的成本。</p><figure class="kp kq kr ks fd ii er es paragraph-image"><div class="er es kt"><img src="../Images/6e7f659a482d2129f136d66052f63d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*baVKnSoglkfjYBUn"/></div></figure><p id="aa80" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">事件驱动的设计也可能遇到延迟问题。在这个场景中，每批记录触发一个Lambda函数，该函数必须读取记录，有条件地对这些记录执行一个操作，然后<em class="ku">将它们写入一个新的流</em>。此外，您还必须确保在函数超时之前正确处理数据接收器连接。如果您正在处理流中出现的零星事件，您就不得不<a class="ae jn" href="https://read.acloud.guru/how-to-keep-your-lambda-functions-warm-9d7e1aa6e2f0" rel="noopener ugc nofollow" target="_blank">保持Lambda函数温暖</a>以保持可用性，这又增加了一层基础设施管理开销。</p><h2 id="eb32" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">持续轮询消费者架构</h2><p id="f91c" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">出于这些原因，我想探索一个特定的用例，它使用一组不断轮询的Lambda函数来利用Apache Kafka，每个Lambda函数都被分配给一个Kafka主题分区。为每个主题分区分配一个Lambda函数的好处是简化了设计和性能。</p><p id="f634" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">想象一下这样一种情况，每个Lambda函数都没有明确地分配给一个主题分区；当部署Lambdas组时，它们不会同时出现，这意味着Kafka集群的代理(充当组协调器)会在每次出现新消费者时尝试重新平衡消费者。消费者再平衡延迟很大程度上取决于集群的大小和消费者的数量；等待可能需要几分钟，而不是几秒钟。这种长时间的不可用是不可接受的，尤其是当每个Lambda函数每次仅可用15分钟时。</p><p id="63f5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">相反，每个Lambda函数应该充当一个专用的分区消费者，不断地轮询记录，近乎实时地应用条件动作，然后接收数据。该函数始终可用，由CloudWatch事件按照固定的时间表调用。在这种情况下，需要权衡集成的便利性和性能。也就是说，绕过AWS Kinesis和事件驱动的AWS Lambda消费者架构，选择更细致的Kafka和恒定轮询Lambda设计并不容易。</p><h2 id="2aab" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">陷阱</h2><p id="b8ea" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">AWS Lambda服务作为一个整体有一些限制，需要一些工程来允许我们将它们作为健壮的、持久的数据流消费者使用。这是遇到的四个最紧迫的技术问题:</p><ol class=""><li id="82dd" class="kv kw hh ir b is it iw ix ja kx je ky ji kz jm la lb lc ld bi translated">消费者群体必须持续运行，才能捕获数据流中的所有数据，然而AWS Lambda将每个功能的寿命限制在<strong class="ir hi">15分钟</strong>。</li><li id="e1c1" class="kv kw hh ir b is le iw lf ja lg je lh ji li jm la lb lc ld bi translated">AWS Lambda函数在第一次被Amazon CloudWatch事件调用时会经历<strong class="ir hi">冷启动</strong>，这意味着在它们开始运行之前可能会存在<strong class="ir hi">微小的延迟</strong>，尤其是如果它们存在于虚拟私有云内。</li><li id="b1a8" class="kv kw hh ir b is le iw lf ja lg je lh ji li jm la lb lc ld bi translated">Amazon CloudWatch事件保证<strong class="ir hi">至少调用</strong>一次，这意味着完全有可能在短时间内多次调用同一个Lambda函数。由于Kafka通过唯一的消费者ID跟踪补偿，这可能是一个主要问题。当具有相同使用者组ID的多个使用者试图从同一个Kafka分区读取消息时，偏移量不会被正确跟踪，从而导致数据丢失。</li><li id="4872" class="kv kw hh ir b is le iw lf ja lg je lh ji li jm la lb lc ld bi translated">对于同一个Lambda函数的每一次调用，<a class="ae jn" href="https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/" rel="noopener ugc nofollow" target="_blank"> AWS有时会重用一个回收的ECS容器来运行您的流程</a>。如果您不在函数终止时<strong class="ir hi">关闭所有线程</strong>，线程将继续运行，并可能在将来Lambda函数被重新调用时导致意外行为。此外，如果您的调用计划确保Lambda函数始终可用(背靠背调用)，那么连续的函数将不会重用同一个容器。相反，所有其他函数都将使用回收容器，这意味着在未处理线程上运行的进程可能会比预期执行得晚。</li></ol><h2 id="b236" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">最佳实践</h2><p id="9134" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">值得注意的是，这些“最佳实践”是针对基于AWS Lambda的流消费者在Kafka主题上进行操作的通用指南。一个高性能、高容量的无服务器流消费者可能会被调整到特定的用例以及特定于实现的约束。希望这些建议有助于激发更强大的架构设计和实施决策:</p><ul class=""><li id="9394" class="kv kw hh ir b is it iw ix ja kx je ky ji kz jm lj lb lc ld bi translated">为了解决每个Lambda函数15分钟生命周期的最紧迫问题，<strong class="ir hi">使用一个外部存储来跟踪状态。每个Lambda函数都应该包含某种状态管理器，它不断地轮询像DynamoDB这样的服务。您可以利用每个Lambda容器的上下文对象来获取调用时间、AWS请求ID(一个惟一的标识符)和函数本身的名称。状态管理器可以轮询外部存储器的状态(开始、停止等)。)，以及前面提到的字段，以允许函数之间的运行时切换每14分钟左右成功一次。换句话说，<em class="ku">当旧的Lambda停止执行时，一个新的Lambda已经被调用，并准备好从旧的Lambda停止的地方开始使用数据，几乎是立即开始。</em></strong></li><li id="44d4" class="kv kw hh ir b is le iw lf ja lg je lh ji li jm lj lb lc ld bi translated">Amazon CloudWatch Events允许您设置一个cron作业来定期触发Lambda函数。<strong class="ir hi">为了最小化启动Lambda函数的延迟影响，您应该将调用调度设置为每隔<em class="ku"> n — 1 </em>分钟运行一次，</strong>其中<em class="ku"> n </em>是您为每个函数指定的执行超时长度(Lambda目前最多支持15分钟)<strong class="ir hi">。</strong>如果需要始终可用的基础设施，那么您将需要一个Lambda函数来随时准备使用记录；等待大约1分钟让新的开始运转是不可接受的。通过利用外部状态存储，您可以编写逻辑来允许同一Lambda函数的连续调用之间的无缝切换:通过在14分钟的时间表中重叠调用同一函数(旧函数失效时，15分钟的时间不足以让新函数可用)，您可以确保消费者始终准备好消费数据，并最大限度地减少冷启动延迟；<em class="ku">Lambda</em>继续消耗数据，同时AWS启动<em class="ku"> Lambda B的</em>容器预热。在这个例子中，<em class="ku">λA</em>不断地轮询状态表。一旦<em class="ku"> Lambda B </em>被调用，它会立即覆盖状态存储中的唯一ID和调用时间，通知现在已经过时的<em class="ku"> Lambda A </em>停止执行并减速。<em class="ku">Lambda</em>公布它消耗的最后一条记录的偏移量，而<em class="ku"> Lambda B </em> <strong class="ir hi">从该点继续消耗，停机时间最短。</strong></li></ul><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/bc21f33160570626b036768bd04b4e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zBkJle-e6aruQdCbpawXnA.png"/></div></div></figure><ul class=""><li id="e99c" class="kv kw hh ir b is it iw ix ja kx je ky ji kz jm lj lb lc ld bi translated">如前所述，<strong class="ir hi">AWS</strong><strong class="ir hi">cloud watch Events保证至少调用一次</strong>，这意味着您必须考虑到<strong class="ir hi"> AWS在任何给定时间同时调用同一函数的多个实例</strong>。Kafka消费者不是线程安全的，这意味着这可能是一个大问题。这是利用外部存储作为状态管理器的另一个原因:如果您正确地编写了逻辑，复制实例将发现它的(假定的)惟一容器ID已经存在于表中，并在Kafka将其注册为消费者之前立即关闭该函数。灾难避免了。</li><li id="0431" class="kv kw hh ir b is le iw lf ja lg je lh ji li jm lj lb lc ld bi translated">这个建议不言而喻，但是当Lambda准备降速并被替换时，请确保关闭您的消费者的Kafka连接和辅助执行线程。多线程问题调试起来并不有趣，尤其是当它们是AWS Lambda特有的，并且每次需要更改代码时都必须重新部署基础设施时。</li></ul><h2 id="92f5" class="jo jp hh bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">结论</h2><p id="4da7" class="pw-post-body-paragraph ip iq hh ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">虽然无服务器技术仍处于相对早期的发展阶段，但它可以用来创建强大而灵活的数据流消费者。虽然并非在所有情况下都是理想的，但组织可以构建无服务器的流消费者来降低云提供商的成本，并消除工程团队之间的重复工作。与任何新兴领域一样，最佳实践也在不断发展。我希望这些建议能帮助你避免陷阱，构建更健壮的系统。</p></div><div class="ab cl ll lm go ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ha hb hc hd he"><p id="ff0e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">披露声明:2019首创一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</p></div></div>    
</body>
</html>