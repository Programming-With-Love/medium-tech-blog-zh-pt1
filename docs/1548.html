<html>
<head>
<title>Event-Streaming: An Additional Architectural Style to Supplement API Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事件流:补充API设计的另一种架构风格</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/event-streaming-an-additional-architectural-style-to-supplement-api-design-703c4f801722?source=collection_archive---------0-----------------------#2018-04-18">https://medium.com/capital-one-tech/event-streaming-an-additional-architectural-style-to-supplement-api-design-703c4f801722?source=collection_archive---------0-----------------------#2018-04-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a88e325669246ea72df30464ff6999a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4_YF4Q5HLgSqznI8eUZHw.jpeg"/></div></div></figure><p id="e590" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">基于web的API的增长和采用是任何企业转型技术之旅的关键。这些API，无论是否是RESTful的，都保持同步。像web一样，它们利用HTTP模式来实现请求-响应交互方法。</p><p id="3133" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">举例来说，假设我们有一个具有以下交互的项目管理API:</p><ol class=""><li id="5bc0" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">创建项目(例如文章/项目)</li><li id="3aa6" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">创建新任务(例如POST/projects/{ projectId }/tasks)</li><li id="611e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">将任务分配给我们团队中的某个人(例如，POST/tasks/{ taskId }/assignee)</li><li id="30b5" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">工作负责人将任务标记为完成(例如，PUT /tasks/{taskId})</li></ol><p id="e62c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果用户界面的设计很好地反映了这些端点，那么遵循这种设计的API就可以工作。但是假设一个额外的应用程序需求是在另一个用户标记完成时“自动”更新任务的状态。对于请求/响应web-API，一种选择是不间断地轮询状态API，以防状态发生变化。这既麻烦又容易出错。</p><p id="2dff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">代替轮询，我们可以引入一个<strong class="ir hi">事件驱动的架构</strong>。</p><h2 id="9d1d" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated">事件驱动架构简介</h2><p id="20a2" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">在事件驱动架构(EDA)中，应用程序由独立的组件组成，这些组件对其他组件发布的事件做出反应。EDA在分布式应用中很受欢迎，因为可以在解决方案中引入新组件来解决新出现的问题，而无需了解以前开发的组件。消息代理被用作通信的中介，通过防止组件之间直接通信来产生松散耦合的设计。</p><p id="4368" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你熟悉面向服务的架构(SOA)，你就经历过EDA。大多数面向服务的架构使用企业服务总线(ESB)进行服务通信，而不是消息代理。事件被发布到ESB，然后被路由到其他服务以集成两个或更多的软件系统。然而，ESB被证明是有问题的，因为它们被用作“集成粘合剂”，导致集成代码分散在服务、应用程序和ESB中；脆弱的系统被创造出来。这种脆弱性产生了团队之间更大的协作需求，减缓了软件交付。</p><h2 id="56df" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated">微服务和事件驱动架构的出现</h2><p id="aacf" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">为了克服这种增加的协调，引入了微服务架构作为传统SOA的替代。这种基于API和微服务的新型分布式架构鼓励“哑管道、智能端点”集成逻辑被推给消费者和生产者。消息代理，而不是ESB，用于消息路由，而不是集成逻辑。服务和API相互对话，同时隐藏实现细节。随着新需求的出现，这种松散耦合使得软件更能适应演化。</p><p id="ced6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着企业转向由微服务架构支持的API，发布的事件数量大幅增长。消息代理本质上通常是事务性的，确保一次且仅一次的消息传递。虽然对于传统的软件开发很有用，但是消息代理的事务性质限制了服务通信的可伸缩性。</p><p id="130b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">分布式流数据平台，如<a class="ae lb" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Kafka </a>，现在为企业提供了比传统消息代理更高的吞吐量。Kafka不再需要消息代理中的事务性消息传递，而是选择将事件转化为消息流。这些流可由任何授权用户访问，并且可以从预定位置或在流的开始处被实时访问或顺序处理。</p><h2 id="a563" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated">使用事件流的API设计</h2><p id="a4eb" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">事件流帮助软件扩展到REST、GraphQL和gRPC等web API风格常见的请求-响应方法之外。软件可以双向通信，消除了API消费者不断轮询状态变化的需要。相反，API将事件发布到事件流中，以便将数据更改或重要的业务事件通知给任意数量的订阅服务进行进一步处理。</p><p id="fd77" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们重温一下我们之前的例子。我们需要解决两个独立的需求:</p><ol class=""><li id="364d" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">任务标记为完成时的通知。如果没有消息驱动的架构，我们唯一的选择就是要求相关方不断地调用API来查看任务是否已经完成(也就是轮询)</li><li id="749a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">当任务被修改或标记为已完成时提醒项目所有者。我们唯一的选择是，通过让API发送电子邮件，将我们的用户界面问题与我们的API混合起来。API不再负责管理项目和任务，它现在负责电子邮件提醒的内容和外观</li></ol><p id="89d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们将消息驱动的架构引入到我们的解决方案中，我们可以开发一个API来交付提供必要功能(创建、读取、更新、删除和标记为完成)的项目和任务资源。我们的API不需要知道如何使用任务完成事件通知，包括发送电子邮件。它需要做的只是在事件发生时发布事件消息，并允许其他服务采取适当的行动。此API可能发布的事件包括:</p><figure class="ld le lf lg fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/e38a39510d26a2d6a34aed343dfe0c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uCVbUtcr5F1rQa5gkzZ_5A.jpeg"/></div></div></figure><p id="b191" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">感兴趣的团体可以订阅他们感兴趣的事件，并安全地忽略其他事件。在我们的例子中，我们可能最终有三个组件</p><ol class=""><li id="a1d2" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi">项目API </strong> —通过基于REST的API管理项目和项目任务资源。API可能由一个或多个微服务组成，这些微服务实现REST API提供的功能。当上表中的任何事件发生时，API会将事件发布到适当的消息流中，供事件订阅者使用</li><li id="98a6" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">任务完成邮件微服务</strong> —订阅<em class="lh">任务。完成</em>事件，当任何任务被标记为完成时，通过电子邮件通知项目经理</li><li id="b26a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">任务修改邮件微服务</strong> —订阅<em class="lh">任务。更新了</em>事件，当任何任务被编辑时，通过电子邮件通知所有团队成员</li></ol><p id="4d68" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">API不知道订阅特定事件的两个微服务；它只是将事件发布到适当的消息流中。该解决方案被认为是松散耦合的，因此能够随着新需求的出现而不断发展，可能会出现新类型的通知(例如SMS、web dashboard alerts)或集成(例如同步到JIRA)。</p><h2 id="c5bf" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated">结论</h2><p id="b46f" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">对更健壮的软件通信方法的需求正在推动当今接口解决方案的极限。基于请求/响应的API至关重要。然而，今天的技术问题现在需要事件驱动的支持——除了请求/响应之外——来改进API的功能提供。</p><p id="72e9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为API设计者，我们必须努力使用所有可用的工具来提供更好的开发者体验。随着现有API的增强和新API的出现，问问自己:</p><ol class=""><li id="85c9" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">我的解决方案架构如何通过超越标准REST APIs并进入松耦合的事件驱动架构来改进？</li><li id="43a2" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">我的API应该发布哪些对API消费者有益的事件？</li><li id="cbf6" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">我的API消费者将如何从这些事件的添加中受益，他们如何利用这些事件？</li></ol><p id="f492" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们将我们的方法从严格的请求-响应转变为思考我们的API如何不仅可以为请求提供端点，还可以为使API能够推送到其他服务的事件提供端点。结果将是在我们的业务线内部和之间增加创新和更具变革性的API。</p><h1 id="cd89" class="li kc hh bd kd lj lk ll kh lm ln lo kl lp lq lr ko ls lt lu kr lv lw lx ku ly bi translated">有关系的</h1><ul class=""><li id="4b20" class="jn jo hh ir b is kw iw kx ja lz je ma ji mb jm mc jt ju jv bi translated"><a class="ae lb" rel="noopener" href="/capital-one-developers/choosing-between-rest-web-apis-and-message-streaming-8e2f4813a058">在Web APIs和消息流之间选择</a></li><li id="c149" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mc jt ju jv bi translated"><a class="ae lb" rel="noopener" href="/capital-one-developers/5-principles-for-designing-evolvable-event-streams-f32e90dcbb79">设计演化事件流的5个原则</a></li><li id="4360" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mc jt ju jv bi translated"><a class="ae lb" rel="noopener" href="/capital-one-developers/api-product-ownership-is-key-for-api-adoption-6a12c64b2c83"> API产品所有权是API采用的关键</a></li></ul><figure class="ld le lf lg fd ii er es paragraph-image"><a href="https://medium.com/capital-one-tech/api/home"><div class="er es md"><img src="../Images/c6c5bb1f3967049ba012aebf5757e08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*x8RfN3y_bm7aDVs1vHMfkg.jpeg"/></div></a><figcaption class="me mf et er es mg mh bd b be z dx">k</figcaption></figure><p id="02f1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lh">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权均为其各自所有者所有。本文为2018资本一</em>。</p></div></div>    
</body>
</html>