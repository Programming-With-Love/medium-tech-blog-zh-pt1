<html>
<head>
<title>Things to know about Flow’s shareIn and stateIn operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于流的shareIn和stateIn操作符需要知道的事情</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/things-to-know-about-flows-sharein-and-statein-operators-20e6ccb2bc74?source=collection_archive---------1-----------------------#2021-05-07">https://medium.com/androiddevelopers/things-to-know-about-flows-sharein-and-statein-operators-20e6ccb2bc74?source=collection_archive---------1-----------------------#2021-05-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f00272b8dcaa4837eeca156a2a6ec168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hlJ_DUMSWuoldjw8ZEBpBQ.png"/></div></div></figure><div class=""/><p id="cee0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b"><a class="ae jr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html" rel="noopener ugc nofollow" target="_blank">Flow.shareIn</a></code>和<code class="du jn jo jp jq b"><a class="ae jr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html" rel="noopener ugc nofollow" target="_blank">Flow.stateIn</a></code>操作符将<em class="js">冷</em>流转换为<em class="js">热</em>流:它们可以将来自冷上游流的信息多播到多个收集器。它们通常用于提高性能，在收集器不存在时添加缓冲区，甚至用作缓存机制。</p><blockquote class="jt ju jv"><p id="397b" class="ip iq js ir b is it iu iv iw ix iy iz jw jb jc jd jx jf jg jh jy jj jk jl jm ha bi translated"><strong class="ir ht">注意</strong> : <strong class="ir ht">冷流</strong>是按需创建的，并在被观察时发出数据。<strong class="ir ht">热流</strong>始终<em class="hs">处于活动状态，无论是否被观察到都可以发出数据。</em></p></blockquote><p id="1deb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇博文中，您将通过示例熟悉<code class="du jn jo jp jq b">shareIn</code>和<code class="du jn jo jp jq b">stateIn</code>操作符。您将学习如何配置它们来执行某些用例，并避免您可能遇到的常见陷阱。</p><h1 id="5e9a" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">底层流生成器</h1><p id="6ee2" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">继续我在<a class="ae jr" rel="noopener" href="/androiddevelopers/a-safer-way-to-collect-flows-from-android-uis-23080b1f8bda">上一篇博文</a>中的例子，我们使用的底层流生成器发出位置更新。这是一个<em class="js">冷</em>流，因为它是使用<code class="du jn jo jp jq b"><a class="ae jr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html" rel="noopener ugc nofollow" target="_blank">callbackFlow</a></code>实现的。每一个新的收集器都会触发flow producer块，一个新的回调会被添加到<code class="du jn jo jp jq b">FusedLocationProviderClient</code>。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="b8cd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看如何使用<code class="du jn jo jp jq b">shareIn</code>和<code class="du jn jo jp jq b">stateIn</code>操作符来优化不同用例的<code class="du jn jo jp jq b">locationsSource</code>流程。</p><h1 id="e427" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">分享还是陈述？</h1><p id="a139" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">我们要讨论的第一个话题是<code class="du jn jo jp jq b">shareIn</code>和<code class="du jn jo jp jq b">stateIn</code>的区别。<code class="du jn jo jp jq b">shareIn</code>操作符返回一个<code class="du jn jo jp jq b"><a class="ae jr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/" rel="noopener ugc nofollow" target="_blank">SharedFlow</a></code>实例，而<code class="du jn jo jp jq b">stateIn</code>返回一个<code class="du jn jo jp jq b"><a class="ae jr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/index.html" rel="noopener ugc nofollow" target="_blank">StateFlow</a></code>。</p><blockquote class="jt ju jv"><p id="c11f" class="ip iq js ir b is it iu iv iw ix iy iz jw jb jc jd jx jf jg jh jy jj jk jl jm ha bi translated"><strong class="ir ht">注意</strong>:要了解更多关于<code class="du jn jo jp jq b">StateFlow</code>和<code class="du jn jo jp jq b">SharedFlow</code>的信息，请查看<a class="ae jr" href="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow" rel="noopener ugc nofollow" target="_blank">我们的文档</a>。</p></blockquote><p id="6ad8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">StateFlow</code>是针对共享状态优化的<code class="du jn jo jp jq b">SharedFlow</code>的专门配置:最后发出的项目被重放给新的收集器，项目被<em class="js">使用<code class="du jn jo jp jq b"><a class="ae jr" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html" rel="noopener ugc nofollow" target="_blank">Any.equals</a></code>合并</em>。您可以在<code class="du jn jo jp jq b"><a class="ae jr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/index.html" rel="noopener ugc nofollow" target="_blank">StateFlow</a></code> <a class="ae jr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多相关信息。</p><p id="db7d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些API之间的主要区别在于，<code class="du jn jo jp jq b">StateFlow</code>接口允许您通过读取它的<code class="du jn jo jp jq b">value</code>属性来同步访问最后发出的值。<code class="du jn jo jp jq b">SharedFlow</code>就不是这样了。</p><h1 id="ab2c" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">提高性能</h1><p id="7992" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">这些API可以通过共享由所有收集器观察的流的相同实例来提高性能，而不是按需创建相同流的新实例。</p><p id="deb2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下面的例子中，<code class="du jn jo jp jq b">LocationRepository</code>使用由<code class="du jn jo jp jq b">LocationDataSource</code>公开的<code class="du jn jo jp jq b">locationsSource</code>流，并应用shareIn操作符使每个对用户位置感兴趣的人从流的同一个实例中收集数据。只有一个<code class="du jn jo jp jq b">locationsSource</code>流实例被创建并为所有收集器共享:</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="c0cb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b"><a class="ae jr" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-sharing-started/-while-subscribed.html" rel="noopener ugc nofollow" target="_blank">WhileSubscribed</a></code>共享策略用于在没有采集器时取消上游流量。这样，我们避免了在没有人对位置更新感兴趣时浪费资源。</p><blockquote class="jt ju jv"><p id="a00b" class="ip iq js ir b is it iu iv iw ix iy iz jw jb jc jd jx jf jg jh jy jj jk jl jm ha bi translated"><strong class="ir ht">安卓应用提示！</strong>在最后一个收集器消失后，您可以在大部分时间使用<code class="du jn jo jp jq b"><strong class="ir ht">WhileSubscribed(5000)</strong></code>来保持上游流活动5秒钟以上。这避免了在诸如配置改变的某些情况下重新启动上游流。当创建上游流的成本很高，并且在视图模型中使用这些操作符时，这个技巧特别有用。</p></blockquote><h1 id="9603" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">缓冲事件</h1><p id="70e5" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">对于这个例子，我们的要求已经改变，现在我们被要求<em class="js">始终</em>监听位置更新，并在应用程序从后台出现时在屏幕上显示最后10个位置:</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="2a03" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用一个值为10的<code class="du jn jo jp jq b">replay</code>,将最后10个发出的条目保存在内存中，并在每次收集器观察到流时重新发出这些条目。为了保持底层流始终处于活动状态并发出位置更新，使用<code class="du jn jo jp jq b">SharingStarted.Eagerly</code>策略来监听更新，即使没有收集器。</p><h1 id="3053" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">缓存数据</h1><p id="2da8" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">我们的需求又变了，在这种情况下，如果应用程序在后台，我们就不需要总是<em class="js">监听位置更新。但是，我们需要缓存最后发出的项，以便用户在获取当前位置时，总是可以在屏幕上看到一些数据，即使是陈旧的数据。对于这种情况，我们可以使用<code class="du jn jo jp jq b">stateIn</code>操作符。</em></p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="51d7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">Flow.stateIn</code>将最后发出的项目缓存并重放到新的收集器中。</p><h1 id="7690" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">小心！不要在每次函数调用时创建新的实例</h1><p id="808d" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><strong class="ir ht"> NEVER </strong>使用<code class="du jn jo jp jq b">shareIn</code>或<code class="du jn jo jp jq b">stateIn</code>创建一个新的流，该流在调用函数时返回。这将在每次函数调用时创建一个新的<code class="du jn jo jp jq b">SharedFlow</code>或<code class="du jn jo jp jq b">StateFlow</code>，它们将一直保留在内存中，直到作用域被取消，或者当没有对它的引用时被垃圾收集。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><h1 id="fea5" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">需要输入的流程</h1><p id="a26f" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">需要输入的流，如<code class="du jn jo jp jq b">userId</code>，不能使用<code class="du jn jo jp jq b">shareIn</code>或<code class="du jn jo jp jq b">stateIn</code>轻易共享。以<a class="ae jr" href="https://github.com/google/iosched" rel="noopener ugc nofollow" target="_blank"> iosched </a>开源项目——Google I/O的Android应用程序——从<a class="ae jr" href="https://firebase.google.com/docs/firestore/quickstart" rel="noopener ugc nofollow" target="_blank"> Firestore </a>获取用户事件的流程是使用<code class="du jn jo jp jq b">callbackFlow</code>实现的，你可以在源代码中看到<a class="ae jr" href="https://github.com/google/iosched/blob/main/shared/src/main/java/com/google/samples/apps/iosched/shared/data/userevent/FirestoreUserEventDataSource.kt#L107" rel="noopener ugc nofollow" target="_blank">。因为它将<code class="du jn jo jp jq b">userId</code>作为一个参数，所以使用<code class="du jn jo jp jq b">shareIn</code>或<code class="du jn jo jp jq b">stateIn</code>操作符不能轻易重用这个流。</a></p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="89e4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">优化此用例取决于您的应用程序的要求:</p><ul class=""><li id="1702" class="li lj hs ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated">你允许同时接收来自多个用户的事件吗？您可能需要创建一个<code class="du jn jo jp jq b">SharedFlow</code> / <code class="du jn jo jp jq b">StateFlow</code>实例的映射，并在<code class="du jn jo jp jq b">subscriptionCount</code>达到零时删除引用和取消上游流。</li><li id="cbce" class="li lj hs ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">如果您只允许一个用户，并且所有的收集器都需要更新到新用户，那么您可以向所有收集器的公共<code class="du jn jo jp jq b">SharedFlow</code> / <code class="du jn jo jp jq b">StateFlow</code>发出事件更新，并使用公共流作为类中的变量。</li></ul></div><div class="ab cl lw lx go ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ha hb hc hd he"><p id="a8a7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">shareIn</code>和<code class="du jn jo jp jq b">stateIn</code>操作符可以与冷流一起使用，以提高性能，在收集器不存在时添加缓冲区，甚至作为缓存机制！明智地使用它们，不要在每次函数调用时都创建新的实例——它不会像您预期的那样工作！</p></div></div>    
</body>
</html>