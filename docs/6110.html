<html>
<head>
<title>Building native video Pins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建本机视频引脚</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/building-native-video-pins-7ff89ad3ec33?source=collection_archive---------2-----------------------#2016-11-15">https://medium.com/pinterest-engineering/building-native-video-pins-7ff89ad3ec33?source=collection_archive---------2-----------------------#2016-11-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c30e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">柳斌| Pinterest产品工程师</p><p id="95b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每天都有数十亿视频在互联网上被观看，但Pinterest上的视频是独一无二的。在Pinterest上，你总是可以保存网络上的视频，在2013年，我们可以在你点击时在Pin上播放它们。视频帮助人们可视化如何将想法带入生活，这使它们成为Pinterest的完美媒介。事实上，我们发现在智能手机上观看视频的人在Pinterest上看到视频时采取行动的可能性是在其他应用程序上看到视频的两倍多。</p><p id="450e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">今天，随着我们第一个本地视频播放器的推出，我们正在让在Pinterest上观看视频变得更加无缝。从今天开始，人们可以在Pinterest新推出的<a class="ae jc" href="https://blog.pinterest.com/en/explore-today%E2%80%99s-top-ideas" rel="noopener ugc nofollow" target="_blank">探索、</a>中观看专家和品位创造者的原生视频，也可以在他们的主页订阅源中观看他们关注的保存视频。</p><p id="a934" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本帖中，我们将深入探讨如何将视频构建到我们的iOS应用中，包括我们在与AVFoundation合作时学到的最佳实践，以及从头开始构建原生视频体验。</p><h2 id="ff56" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">AVFoundation 101</h2><p id="afed" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">在这里，我们将介绍AVFoundation中的一些关键概念，作为本文其余部分的背景。对于那些一直在使用AVFoundation或AVKit的人，请随意跳过。</p><p id="f283" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用AVFoundation构建我们的视频体验，av foundation是苹果提供的标准框架，位于核心媒体、核心音频和核心动画之上。它提供了一个强大框架的接口，允许开发者创建基于时间的视听媒体。</p><p id="36b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">条款</strong></p><ul class=""><li id="e257" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated"><strong class="ig hi">av player:</strong>iOS上视频播放的引擎，提供视频播放的控制接口。</li><li id="60dc" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><code class="du kr ks kt ku b">/* Examples of Provided APIs */ - (AVPlayerStatus)status; - play(); - pause(); - (void)seekToTime:(CMTime)time; - addPeriodicTimeObserverForInterval; - addBoundaryTimeObserverForTimes;</code></li><li id="be5f" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">av player layer:av player将其视觉输出指向的CALayer的子类。可以把它想象成一个显示器:它为连接的AVPlayer呈现内容。这是你如何创建一个:</li><li id="e176" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><code class="du kr ks kt ku b">+ (AVPlayerLayer *)playerLayerWithPlayer:(AVPlayer *)player;</code></li><li id="9f81" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">AVFoundation中我们最喜欢的功能之一是允许开发人员针对单个AVPlayer创建多个AVPlayerLayers，以便所有AVPlayerLayers同步播放该AVPlayer的输出。这使得模块化播放器容器视图和视图控制器之间的转换很容易实现。</li><li id="0d76" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">AVPlayerItem:AVPlayerItem用AVAsset初始化，表示一个可播放的资源。</li></ul><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es kv"><img src="../Images/880596c0026064e2266332e2430f01ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/0*0SiL4TOJZyOJdlxa.png"/></div></figure><h2 id="00e4" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">目标</h2><p id="b629" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">在构建视频框架时，我们有三个主要目标:</p><ol class=""><li id="7bdc" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ld kj kk kl bi translated">满足当前和潜在的长期产品需求。因为我们正在构建一个客户端基础设施来适应未来的产品需求，所以我们将视频组件模块化、可移植且坚固耐用。</li><li id="92a5" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ld kj kk kl bi translated">了解资源，因为视频可能是极其资源密集型的，并可能导致OOM崩溃或磁盘空间不足的关机。此外，如果我们不小心，我们可能会很快耗尽用户的数据或电池。</li><li id="42f9" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ld kj kk kl bi translated">在滚动和过渡过程中，优先考虑性能并最大限度地减少丢帧。播放视频本质上是主线程密集型的，所以我们必须平衡视频播放体验及其潜在的UI性能影响。</li></ol><h2 id="0557" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">用户场景</h2><p id="e160" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">在深入研究该架构之前，让我们考虑以下用户场景:</p><ol class=""><li id="5f25" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ld kj kk kl bi translated">用户在主页馈送中发现视频大头针自动播放。</li><li id="3de8" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ld kj kk kl bi translated">用户点击它，视频放大到大头针特写镜头，并继续播放。</li><li id="dd6e" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ld kj kk kl bi translated">用户点击全屏按钮，视频放大到全屏视图。</li></ol><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es le"><img src="../Images/ae4aad6a438560587498957093f14b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*HxEw--zqSqqvpgpd.gif"/></div></figure><p id="0269" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个场景中，涉及三个ViewControllers，Feed、Pin close up和Full Screen。每一个都是复杂和模块化的，但它们都连续播放相同的视频，并由两个不同的交互式过渡连接，因此视频在过渡期间连续播放。此外，每个都有不同的播放控制界面。</p><h2 id="e6ef" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">概观</h2><p id="955a" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">从上面描述的用户场景中，我们希望建立一些基线需求:</p><ol class=""><li id="4ea2" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ld kj kk kl bi translated">确保播放同一视频的所有ViewControllers共享一个AVPlayer-AVPlayerItem对，以避免每个ViewControllers加载单独的缓冲区并维护单独的播放状态。</li><li id="3eb3" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ld kj kk kl bi translated">因为#1，ViewControllers不应该拥有AVPlayer-AVPlayerItem对。</li><li id="f88c" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ld kj kk kl bi translated">每个ViewController都应该管理自己的视图层次结构。由于ViewControllers在整个应用程序中被大量使用，如果它们共享相同的视图，管理移交可能会变得很有挑战性。</li></ol><p id="2567" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用以下关键组件构建了我们的第一个架构迭代:</p><ul class=""><li id="80a3" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated"><strong class="ig hi"> PlayerController </strong>(一个数据结构)保存AVPlayer-AVPlayerItem对，并提供API来控制回放和缓冲。</li><li id="e254" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi"> PlayerControllerManager </strong>(单例管理器)通过一个以视频标识符为关键字的字典持有对PlayerControllers的强引用。</li><li id="5b7b" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi"> PlayerLayerContainer </strong>(一个容器视图类)在所有ViewControllers中使用，包含一个从PlayerController的AVPlayer中创建的AVPlayerLayer。</li></ul><p id="2f1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所有这些术语可能会令人困惑，因此下面的基本架构图应该会有所帮助。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lf"><img src="../Images/7fb317bc2bb54feeea3efc2b43db5d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/0*CDOBDGcBDvKOBzTg.png"/></div></figure><p id="5568" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图的顶部是单例管理器，它持有对PlayerControllers的强引用(在应用程序的其他地方只允许弱引用)。要访问PlayerController，您只需要视频ID。中央管理器设计使我们能够在需要时进行预取或清除。</p><p id="4938" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">视图控制器中的灰色框是PlayerLayerContainers。每个都通过共享的AVPlayer创建一个AVPlayerLayer，并将AVPlayerLayer放在其视图层次结构中。这有助于使这些视图控制器模块化，但是有一个警告，我们稍后会谈到。</p><h2 id="dd8e" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">控制</h2><p id="6196" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">控制接口可以归纳为两类:推送器和拉出器。推动器是Pinners可以执行的操作，例如播放/暂停、静音/取消静音、搜索等。拉出器控制监听回放状态变化并相应地更新自身的元件(例如，进度指示符、缓冲指示符、时间戳等)。).</p><p id="2f69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">推杆控制很简单，但是拉杆稍微复杂一点。为了反映准确的回放状态，您必须收听许多不同的广播通知，并在各种属性值上设置键值观察。突出一对夫妇:</p><pre class="kw kx ky kz fd lg ku lh li aw lj bi"><span id="e988" class="jd je hh ku b fi lk ll l lm ln">/* Notifications names */<br/>AVPlayerItemDidPlayToEndTimeNotification<br/>AVPlayerItemPlaybackStalledNotification <br/>AVPlayerItemNewAccessLogEntryNotification<br/><br/><br/>/* Properties to KVO */<br/>BOOL playbackLikelyToKeepUp;<br/>NSArray&lt;NSValue *&gt; *loadedTimeRanges;</span></pre><p id="dbe7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们iOS开发者经常会遇到的一个问题是设置和移除观察者。特别麻烦的是看到一堆与观察者相关的代码到处都是。我们决定将所有这些逻辑包装在一个EventObserver对象中，该对象根据自己的对象生命周期处理侦听器和观察者的删除。它只监听基于其委托标志的特定事件，因为处理事件回调可能是相当密集的主线程。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lo"><img src="../Images/4ef602958329a259992e227b8ca1f5b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/0*rF4r8yP_CVL8W0ff.png"/></div></figure><h2 id="5332" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">警告</h2><p id="781f" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">我们并不是生活在一个完美的世界中，SDK中总是隐藏着一些棘手的警告。</p><ul class=""><li id="2e35" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated"><strong class="ig hi">问题:</strong>当视频正在播放时，针对AVPlayer创建AVPlayerLayer会导致播放中出现明显的跳跃。正因为如此，我们不能允许每个风投都有自己的AVPlayerLayer。相反，他们必须共享同一个播放器层，以避免播放中的跳跃。</li><li id="79d2" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">解决方案:</strong>我们扩展了PlayerController以拥有AVPlayerLayer的共享实例以及AVPlayer-AVPlayerItem对，同时重构PlayerLayerContainer的工作方式。我们从UIKit的第一个响应者类比中得到启发，提出了一个解决方案，其中每当PlayerLayerContainer变得可见时，它会声称自己是PlayerController的当前呈现者，然后返回AVPlayerLayer，以便容器可以将其添加到视图层次结构中。</li><li id="d0f2" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">问题:</strong> AVPlayerLayer持有对其AVPlayer的强引用，因此它无法在需要时清除缓冲区。</li><li id="157f" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">解决方案:</strong>问题#1中的重构帮助解决了这个问题。当PlayerLayerContainer变得不可见时，它会重新提交当前演示者并删除其对AVPlayer的引用，从而允许PlayerController删除对av player的所有引用。</li><li id="300e" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">问题</strong>:错误代码:“无法解码”是由于一个app最多允许四个“渲染管道”的限制(参考<a class="ae jc" href="http://stackoverflow.com/a/9933853/1218605" rel="noopener ugc nofollow" target="_blank"> Stackoverflow </a>)。我们注意到一个应用程序可以创建四个以上的AVPlayer实例，但不能用AVPlayerItems连接四个以上的av player。</li><li id="7fee" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">解决方案:</strong>我们不<em class="lp">而</em>设置AVPlayer的currentItem到AVPlayerItem，直到我们需要开始播放。然后，一旦不再需要回放，我们就移除当前项目。</li></ul><h2 id="197c" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">其他提示</h2><ol class=""><li id="fe79" class="kd ke hh ig b ih jy il jz ip lq it lr ix ls jb ld kj kk kl bi translated"><em class="lp">AVPlayerItemNewAccessLogEntryNotification</em>载有<em class="lp">AVPlayerItemAccessLogEvent</em>的最新条目，其中包含许多有用的信息，并已被证明非常有助于深入了解视频性能。</li><li id="bb6d" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ld kj kk kl bi translated">视频播放的内置缓冲策略有助于避免开始播放时的停顿。在网络连接不良的情况下，如3G网络，播放器有时会在开始播放前缓冲10秒以上的数据。苹果在iOS10中引入了新的API，<em class="lp">preferredForwardBufferDuration</em>，允许开发者调整这种内置行为。遗憾的是，对于iOS 9及以下版本，我们无能为力。</li><li id="e346" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ld kj kk kl bi translated">音频对于出色的视频体验非常重要，但有时也是多余的，尤其是对移动用户而言。iOS将复杂的声音行为分为几个标准类别，我们目前混合使用两个最常用的类别:</li></ol><ul class=""><li id="ffa4" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated"><em class="lp">avaudiosessioncategory playback</em>:这个音频类别的两个重要特征:</li><li id="eefe" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">你的应用程序会切断后台播放的任何音乐/视频应用程序。</li><li id="6b78" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">无论iPhone的硬件铃声静音控制如何，应用程序的音频流都会播放声音。</li><li id="3f51" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><em class="lp">AVAudioSessionCategoryAmbient</em>:当你的应用的音频会话设置为这个类别时，音频流将尊重硬件振铃器静音开关，这意味着当用户的硬件静音打开时，你将无法播放任何声音。<br/>请注意，您的应用不需要拘泥于这些提供的类别之一。我们对不同的用户场景使用不同的类别。</li></ul><ol class=""><li id="31f1" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ld kj kk kl bi translated">如果您需要在视频缓冲时显示加载微调器，AVPlayerItem上的<em class="lp"> playbackLikelyToKeepUp </em>属性是您最好的朋友。</li><li id="6cf9" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ld kj kk kl bi translated">如果你对视频流使用HLS协议，充分利用<em class="lp"> preferredPeakBitRate </em>属性。当用户使用蜂窝网络时，我们将其设置为较低的值，以便前几个片段加载更快(导致等待时间更短)，这样我们就不会因加载不必要的高分辨率视频流而耗尽用户的蜂窝网络数据。</li></ol><h2 id="f6bb" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">前瞻性产品开发</h2><p id="4454" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">当我们在代码库中构建新的产品特性时，我们必须提前考虑产品进展，这样我们才能做出正确的架构决策。例如，我们希望建立一种方法，让本地视频在大头针特写时播放，我们预计下一步将建立一个沉浸式全屏视图，连续播放相同的视频。之后，我们可以考虑在中间添加一个自定义过渡，视频可以在过渡期间连续播放。这样的例子不胜枚举。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lt"><img src="../Images/9ee1636df45c06d2af4f201a85af0a2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*H3LAbrp1s3OIA8pv.gif"/></div></figure><p id="75ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">提前思考在很多方面都让我们受益。特别是，因为我们已经构建了大多数组件，我们能够在短短几周内为<a class="ae jc" href="http://pin.it/Td6AtBk" rel="noopener ugc nofollow" target="_blank"> Explore </a>构建一个身临其境的iOS视频体验。</p><p id="029c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">今天就访问新的<a class="ae jc" href="http://pin.it/Td6AtBk" rel="noopener ugc nofollow" target="_blank"> Pinterest Explore </a>，亲自尝试一下这个新框架。</p><p id="a102" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lp">鸣谢:非常感谢Ricky Cancro，他与我紧密合作，不知疲倦地从头开始设计和实现所有的视频组件。感谢Steven Ramkumar、Scott Goodson和Max Gu一路上提供的宝贵反馈和建议！</em></p></div></div>    
</body>
</html>