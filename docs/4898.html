<html>
<head>
<title>The problem with extension functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩展函数的问题是</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/the-problem-with-extension-functions-dffd22eb5df9?source=collection_archive---------3-----------------------#2019-10-21">https://blog.kotlin-academy.com/the-problem-with-extension-functions-dffd22eb5df9?source=collection_archive---------3-----------------------#2019-10-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/d7ac68c5fcecbc32cf157dcc4580f583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMJlVLiDbxb1YtL0BIFqug.jpeg"/></div></div></figure><div class=""/><p id="c907" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">扩展函数——像成员函数一样使用，但是在类之外定义的函数——是一个很好的特性，受到很多人的喜爱。虽然它们开始被过度使用，但导致了我们还不知道如何解决的问题。相反，你可以看到一些图书馆是如何使用棘手而糟糕的解决方案来避免这些问题的。这是关于扩展函数的黑暗面的故事。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="7c31" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">fun </strong>CharSequence.isBlank(): Boolean = <br/>    <strong class="ky iz">length </strong>== 0 || <em class="li">indices</em>.<em class="li">all </em><strong class="ky iz">{ this</strong>[<strong class="ky iz">it</strong>].<em class="li">isWhitespace</em>() <strong class="ky iz">}</strong></span><span id="cbda" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">"  "</strong>.<em class="li">isBlank</em>() <em class="li">// true<br/></em><strong class="ky iz">" :) "</strong>.<em class="li">isBlank</em>() <em class="li">// false</em></span></pre><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/23164fa051ae361715b2aed9af583921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JFhDQrHlekRxuGez.png"/></div></div></figure><h1 id="d378" class="ll ld iy bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">为什么我们需要扩展函数？</h1><p id="96e1" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">在某种程度上，扩展函数的行为类似于成员函数。有一些不同——比如扩展是在类型上，而不是在类上(所以我们可以在<code class="fe mn mo mp ky b">String?</code>或<code class="fe mn mo mp ky b">List&lt;Int&gt;</code>上进行扩展)，或者它们不是虚拟的(所有的不同都在<a class="ae mq" href="https://leanpub.com/effectivekotlin/" rel="noopener ugc nofollow" target="_blank"> Effective Kotlin </a>的第40项中详细解释)。尽管通常扩展的使用类似于成员函数。例如，所有的收集处理功能都是作为<code class="fe mn mo mp ky b">List&lt;T&gt;</code>的扩展来实现的:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="9464" class="lc ld iy ky b gy le lf l lg lh">listOf(1,2,3)<br/>    .filter <strong class="ky iz">{ </strong>it % == 2 <strong class="ky iz">}<br/>    </strong>.map <strong class="ky iz">{ </strong>it * 2 <strong class="ky iz">}<br/>    </strong>.sort()</span><span id="f47d" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>&lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): List&lt;T&gt; {<br/>    <strong class="ky iz">return </strong><em class="li">filterTo</em>(ArrayList&lt;T&gt;(), predicate)<br/>}</span></pre><p id="cab3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">修改可变集合也是如此:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1abc" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">val </strong>mutable = <em class="li">arrayListOf</em>(4,2,3)<br/>mutable.sort()</span><span id="d58a" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>&lt;T : Comparable&lt;T&gt;&gt; MutableList&lt;T&gt;.sort() {<br/>    <strong class="ky iz">if </strong>(<strong class="ky iz">size </strong>&gt; 1) java.util.Collections.sort(<strong class="ky iz">this</strong>)<br/>}</span></pre><p id="8f71" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它们还用于定义类外部的运算符重载:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1494" class="lc ld iy ky b gy le lf l lg lh"><em class="li">listOf</em>(1,2) + <em class="li">listOf</em>(3,4)</span><span id="6380" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">operator fun </strong>&lt;T&gt; Collection&lt;T&gt;.plus(elements: Iterable&lt;T&gt;): List&lt;T&gt;{<br/>    <strong class="ky iz">if </strong>(elements <strong class="ky iz">is </strong>Collection) {<br/>        <strong class="ky iz">val </strong>result = ArrayList&lt;T&gt;(<strong class="ky iz">this</strong>.size + elements.size)<br/>        result.addAll(<strong class="ky iz">this</strong>)<br/>        result.addAll(elements)<br/>        <strong class="ky iz">return </strong>result<br/>    } <strong class="ky iz">else </strong>{<br/>        <strong class="ky iz">val </strong>result = ArrayList&lt;T&gt;(<strong class="ky iz">this</strong>)<br/>        result.addAll(elements)<br/>        <strong class="ky iz">return </strong>result<br/>    }<br/>}</span></pre><p id="f11f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然还有一个更重要的扩展函数使用。<strong class="jx iz">它们是Kotlin </strong>中DSL定义的基础。在DSLs函数中，打开lambda表达式，在它们内部，有其他函数被另一个lambda表达式调用。但问题是这个函数调用的本地化很重要，因为它们在修改父函数。想想下面这个简单的DSL:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="ff8e" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">fun </strong>View.makeView() = <em class="li">table </em><strong class="ky iz">{ <br/>    </strong><em class="li">tr </em><strong class="ky iz">{ <br/>        </strong><em class="li">td </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"A" }<br/>        </strong><em class="li">td </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"B" }<br/>    } <br/>    </strong><em class="li">tr </em><strong class="ky iz">{ <br/>        </strong><em class="li">td </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"C" }<br/>        </strong><em class="li">td </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"D" }<br/>    }<br/>}</strong></span></pre><p id="6c95" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要注意的是<code class="fe mn mo mp ky b">tr</code>只能用在<code class="fe mn mo mp ky b">table</code>的范围内，而且它修饰了它(所以有关系)。与<code class="fe mn mo mp ky b">td</code>和<code class="fe mn mo mp ky b">tr</code>相同。这是可能的，因为<code class="fe mn mo mp ky b">table</code>、<code class="fe mn mo mp ky b">tr</code>和<code class="fe mn mo mp ky b">td</code>中的函数不是普通函数，而是带有接收器的函数类型，并且<code class="fe mn mo mp ky b">table</code>、<code class="fe mn mo mp ky b">tr</code>和<code class="fe mn mo mp ky b">td</code>是接收器上的方法(成员或扩展函数)。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="578e" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">fun </strong>View.makeView() = this@makeView.<em class="li">table </em><strong class="ky iz">{ <br/>    </strong>this@<em class="li">table</em>.<em class="li">tr </em><strong class="ky iz">{ <br/>        </strong>this@<em class="li">tr</em>.<em class="li">td </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"A" }<br/>        </strong>this@<em class="li">tr</em>.<em class="li">td </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"B" }<br/>    } <br/>    </strong>this@<em class="li">table</em>.<em class="li">tr </em><strong class="ky iz">{ <br/>        </strong>this@<em class="li">tr</em>.<em class="li">td </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"C" }<br/>        </strong>this@<em class="li">tr</em>.<em class="li">td </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"D" }<br/>    }<br/>}</strong></span><span id="a259" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>View.table(init: Table.()-&gt;Unit) { /*...*/ }<br/><strong class="ky iz">fun </strong>Table.tr(init: Tr.()-&gt;Unit) { /*...*/ }<br/><strong class="ky iz">fun </strong>Table.td(init: Td.()-&gt;Unit) { /*...*/ }</span></pre><p id="8ddf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更好地理解这个概念，下面是一个非常简单的Kotlin DSL的完整实现:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="7a78" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">abstract class </strong>View(<br/>   <strong class="ky iz">var childrens</strong>: List&lt;View&gt; = <em class="li">emptyList</em>()<br/>) {<br/>    <em class="li">// This already must be a member extension<br/>    // because we need 2 receivers: Text and String<br/>    </em><strong class="ky iz">operator fun </strong>String.unaryPlus() {<br/>        <strong class="ky iz">childrens </strong>+= Text(<strong class="ky iz">this</strong>)<br/>    }<br/>}</span><span id="c563" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">class </strong>Table: View()<br/><strong class="ky iz">class </strong>Tr: View()<br/><strong class="ky iz">class </strong>Td: View()<br/><strong class="ky iz">class </strong>Div: View() <br/><strong class="ky iz">class </strong>Text(<strong class="ky iz">var text</strong>: String): View()</span><span id="a233" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>View.table(init: Table.()-&gt;Unit) {<br/>    <strong class="ky iz">val </strong>view = Table()<br/>    view.init()<br/>    <strong class="ky iz">childrens </strong>+= view<br/>}</span><span id="339f" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>View.div(init: Div.()-&gt;Unit) {<br/>    <strong class="ky iz">val </strong>view = Div()<br/>    view.init()<br/>    <strong class="ky iz">childrens </strong>+= view<br/>}</span><span id="06aa" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>Table.tr(init: Tr.()-&gt;Unit) {<br/>    <strong class="ky iz">val </strong>view = Tr()<br/>    view.init()<br/>    <strong class="ky iz">childrens </strong>+= view<br/>}</span><span id="7d01" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>Table.td(init: Td.()-&gt;Unit) {<br/>    <strong class="ky iz">val </strong>view = Td()<br/>    view.init()<br/>    <strong class="ky iz">childrens </strong>+= view<br/>}</span><span id="3c64" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>View.makeView() = <em class="li">div </em><strong class="ky iz">{ <br/>    </strong><em class="li">table </em><strong class="ky iz">{ <br/>        </strong><em class="li">tr </em><strong class="ky iz">{ <br/>            </strong><em class="li">td </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"A" }<br/>            </strong><em class="li">td </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"B" }<br/>        } <br/>        </strong><em class="li">tr </em><strong class="ky iz">{ <br/>            </strong><em class="li">td </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"C" }<br/>            </strong><em class="li">td </em><strong class="ky iz">{ </strong><em class="li">div </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"D" } }<br/>        }<br/>    }<br/>}</strong></span></pre><p id="0f07" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(更好的是，我们可以使用apply来简化这种语法，这是DSL的一种流行的习语)</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="6631" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">fun </strong>View.table(init: Table.()-&gt;Unit) {<br/>    <strong class="ky iz">childrens </strong>+= Table().<em class="li">apply</em>(init)<br/>}</span><span id="c5e5" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>View.div(init: Div.()-&gt;Unit) {<br/>    <strong class="ky iz">childrens </strong>+= Div().<em class="li">apply</em>(init)<br/>}</span><span id="abab" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>Table.tr(init: Tr.()-&gt;Unit) {<br/>    <strong class="ky iz">childrens </strong>+= Tr().<em class="li">apply</em>(init)<br/>}</span><span id="6b21" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>Table.td(init: Td.()-&gt;Unit) {<br/>    <strong class="ky iz">childrens </strong>+= Td().<em class="li">apply</em>(init)<br/>}</span></pre><p id="5841" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以创建<code class="fe mn mo mp ky b">table</code>、<code class="fe mn mo mp ky b">div</code>、<code class="fe mn mo mp ky b">tr</code>和<code class="fe mn mo mp ky b">td</code>成员函数，但这只是指定接收者的不同方式。问题是，现在接收者在表达关系中有一个非常重要的角色，问题之一是我们只有一个(或两个)接收者的空间，不能再多了。</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi mr"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h1 id="a178" class="ll ld iy bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">许多关系</h1><p id="10dc" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">如果你在DSL中有一些重复的行为，你可以使用一个函数来提取它，但是为了保持与父类的关系，它必须是一个扩展函数。</p><p id="8c98" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，当我们在HTML DSL中有一个重复块时:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="bb53" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">body {<br/>    div</strong>(classes = <strong class="ky iz">"main-head"</strong>) <strong class="ky iz">{<br/>        </strong>+<strong class="ky iz">"Title1"<br/>    }<br/>}</strong></span><span id="6df4" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">body {<br/>    div</strong>(classes = <strong class="ky iz">"main-head"</strong>) <strong class="ky iz">{<br/>        </strong>+<strong class="ky iz">"Title2"<br/>    }<br/>}</strong></span></pre><p id="656c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以用一个函数提取它:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="e3b1" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">body {<br/>    </strong><em class="li">head</em>(<strong class="ky iz">"Title1"</strong>)<br/><strong class="ky iz">}</strong></span><span id="fa37" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">body {<br/>    </strong><em class="li">head</em>(<strong class="ky iz">"Title2"</strong>)<br/><strong class="ky iz">}</strong></span><span id="ce11" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>BODY.head(title: String) {<br/>    <strong class="ky iz">div</strong>(classes = <strong class="ky iz">"main-head"</strong>) <strong class="ky iz">{<br/>        </strong>+title<br/>    <strong class="ky iz">}<br/></strong>}</span></pre><p id="e15c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，当我们在Ktor DSL中有一个重复响应模块时:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="a3c0" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">get</strong>(<strong class="ky iz">"endpoint1"</strong>) <strong class="ky iz">{<br/>    </strong>ok()<br/><strong class="ky iz">}</strong></span><span id="bbb0" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">get</strong>(<strong class="ky iz">"endpoint2"</strong>) <strong class="ky iz">{<br/>    </strong>ok()<br/><strong class="ky iz">}</strong></span><span id="a98d" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">suspend fun </strong>PipelineContext&lt;Unit, ApplicationCall&gt;.ok() {<br/>    <em class="li">call</em>.<em class="li">respond</em>(HttpStatusCode.<strong class="ky iz">OK</strong>)<br/>}</span></pre><p id="e9b7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果我们想要提取一个属于2 DSLs的行为呢？比如构建HTML和使用关于呼叫的数据？</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1822" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">get</strong>(<strong class="ky iz">"endpoint1"</strong>) <strong class="ky iz">{<br/>    </strong><em class="li">call</em>.<em class="li">respondHtml </em><strong class="ky iz">{<br/>        body {<br/>            val </strong>name = <em class="li">call</em>.<strong class="ky iz">parameters</strong>[<strong class="ky iz">"name"</strong>]<br/>            <em class="li">application</em>.<strong class="ky iz">environment</strong>.<strong class="ky iz">log</strong>.info(<strong class="ky iz">"Parameter name is $</strong>name<strong class="ky iz">"</strong>)<br/>            <strong class="ky iz">div</strong>(classes = <strong class="ky iz">"param-display"</strong>) <strong class="ky iz">{<br/>                </strong>+<strong class="ky iz">"Parameter name is $</strong>name<strong class="ky iz">"<br/>            }<br/>        }<br/>    }<br/>}<br/>get</strong>(<strong class="ky iz">"endpoint2"</strong>) <strong class="ky iz">{<br/>    </strong><em class="li">call</em>.<em class="li">respondHtml </em><strong class="ky iz">{<br/>        body {<br/>            val </strong>surname = <em class="li">call</em>.<strong class="ky iz">parameters</strong>[<strong class="ky iz">"surname"</strong>]<br/>            <em class="li">application</em>.<strong class="ky iz">environment</strong>.<strong class="ky iz">log</strong>.info(<strong class="ky iz">"Parameter surname is $</strong>surname<strong class="ky iz">"</strong>)<br/>            <strong class="ky iz">div</strong>(classes = <strong class="ky iz">"param-display"</strong>) <strong class="ky iz">{<br/>                </strong>+<strong class="ky iz">"Parameter surname is $</strong>surname<strong class="ky iz">"<br/>            }<br/>        }<br/>    }<br/>}</strong></span></pre><p id="4734" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们只能隐式传递一个接收者。另一个需要作为参数显式传递(如果你真的想这么做的话)。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="94f3" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">get</strong>(<strong class="ky iz">"endpoint1"</strong>) <strong class="ky iz">{<br/>    </strong><em class="li">call</em>.<em class="li">respondHtml </em><strong class="ky iz">{<br/>        body {<br/>            </strong><em class="li">parameterDisplay</em>(<strong class="ky iz">this</strong>@get, <strong class="ky iz">"name"</strong>)<br/>        <strong class="ky iz">}<br/>    }<br/>}<br/>get</strong>(<strong class="ky iz">"endpoint2"</strong>) <strong class="ky iz">{<br/>    </strong><em class="li">call</em>.<em class="li">respondHtml </em><strong class="ky iz">{<br/>        body {<br/>            </strong><em class="li">parameterDisplay</em>(<strong class="ky iz">this</strong>@get, <strong class="ky iz">"surname"</strong>)<br/>        <strong class="ky iz">}<br/>    }<br/>}</strong></span><span id="5e77" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">private fun </strong>BODY.parameterDisplay(<br/>    pipelineContext: PipelineContext&lt;Unit, ApplicationCall&gt;,<br/>    paramName: String<br/>) {<br/>    <strong class="ky iz">val </strong>value = pipelineContext.<em class="li">call</em>.<strong class="ky iz">parameters</strong>[paramName]<br/>    pipelineContext.<em class="li">application</em>.<strong class="ky iz">environment</strong>.<strong class="ky iz">log</strong>.info(<strong class="ky iz">"Parameter $</strong>paramName<strong class="ky iz"> is $</strong>value<strong class="ky iz">"</strong>)<br/>    <strong class="ky iz">div</strong>(classes = <strong class="ky iz">"param-display"</strong>) <strong class="ky iz">{<br/>        </strong>+<strong class="ky iz">"Parameter $</strong>paramName<strong class="ky iz"> is $</strong>value<strong class="ky iz">"<br/>    }<br/></strong>}</span></pre><p id="2492" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这看起来像一个可怕的反模式，但这样的想法听起来并不不可思议。我们越来越频繁地使用DSL，我们想要提取功能，但是我们已经有了这样一种情况，即一个接收器已经被占用，而我们不能按照我们想要的方式来做。</p><h1 id="19c7" class="ll ld iy bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">只是多了一个接收器</h1><p id="0015" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">有一种方法可以再隐藏一个接收者——使用成员扩展。它已经在<code class="fe mn mo mp ky b">table</code>的例子中使用了。<code class="fe mn mo mp ky b">unaryPlus</code>需要成为<code class="fe mn mo mp ky b">String</code>上的运算符，并且需要修改类型<code class="fe mn mo mp ky b">View</code>的父类型。唯一的解决方案是使它成为成员扩展:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="6a23" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">abstract class </strong>View(<br/>   <strong class="ky iz">var childrens</strong>: List&lt;View&gt; = <em class="li">emptyList</em>()<br/>) {<br/>    <em class="li">// This already must be a member extension<br/>    // because we need 2 receivers: Text and String<br/>    </em><strong class="ky iz">operator fun </strong>String.unaryPlus() {<br/>        <strong class="ky iz">childrens </strong>+= Text(<strong class="ky iz">this</strong>)<br/>    }<br/>}</span><span id="913c" class="lc ld iy ky b gy lj lf l lg lh"><em class="li">td </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"A" }<br/></strong><em class="li">div </em><strong class="ky iz">{ </strong>+<strong class="ky iz">"B" }</strong></span></pre><p id="7bc9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总的来说，这是一个可怕的模式，我在<a class="ae mq" href="https://leanpub.com/effectivekotlin/" rel="noopener ugc nofollow" target="_blank">有效科特林</a>的第41项中警告过它。这个技巧应该只在某些DSL内部使用，并且只在我们真正需要的时候使用。不应该成为一个标准。</p><h1 id="7869" class="ll ld iy bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结构化并发</h1><p id="e2aa" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">一个流行的DSL例子是Kotlin协程中的结构化并发。它的工作方式是除了<code class="fe mn mo mp ky b">runBlocking</code>(所以<code class="fe mn mo mp ky b">launch</code>，<code class="fe mn mo mp ky b">async</code>)之外的所有协程构建器都是<code class="fe mn mo mp ky b">CoroutineScope</code>的扩展:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="c835" class="lc ld iy ky b gy le lf l lg lh"><em class="li">runBlocking </em><strong class="ky iz">{<br/>    </strong><em class="li">launch </em><strong class="ky iz">{ <br/>        val </strong>a = <em class="li">async </em><strong class="ky iz">{ </strong><em class="li">getValue1</em>() <strong class="ky iz">}<br/>        val </strong>b = <em class="li">async </em><strong class="ky iz">{ </strong><em class="li">getValue2</em>() <strong class="ky iz">}<br/>        </strong><em class="li">print</em>(a.await() + b.await())<br/>    <strong class="ky iz">}<br/>}</strong></span><span id="7a94" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">public fun </strong>CoroutineScope.launch(<br/>    context: CoroutineContext = EmptyCoroutineContext,<br/>    start: CoroutineStart = CoroutineStart.DEFAULT,<br/>    block: <strong class="ky iz">suspend </strong>CoroutineScope.() -&gt; Unit<br/>): Job {<br/>    <strong class="ky iz">val </strong>newContext = newCoroutineContext(context)<br/>    <strong class="ky iz">val </strong>coroutine = <strong class="ky iz">if </strong>(start.isLazy)<br/>        LazyStandaloneCoroutine(newContext, block) <strong class="ky iz">else<br/>        </strong>StandaloneCoroutine(newContext, active = <strong class="ky iz">true</strong>)<br/>    coroutine.start(start, coroutine, block)<br/>    <strong class="ky iz">return </strong>coroutine<br/>}</span><span id="2725" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">public fun </strong>&lt;T&gt; CoroutineScope.async(<br/>    context: CoroutineContext = EmptyCoroutineContext,<br/>    start: CoroutineStart = CoroutineStart.<strong class="ky iz">DEFAULT</strong>,<br/>    block: <strong class="ky iz">suspend </strong>CoroutineScope.() -&gt; T<br/>): Deferred&lt;T&gt; {<br/>    <strong class="ky iz">val </strong>newContext = <em class="li">newCoroutineContext</em>(context)<br/>    <strong class="ky iz">val </strong>coroutine = <strong class="ky iz">if </strong>(start.<strong class="ky iz">isLazy</strong>)<br/>        LazyDeferredCoroutine(newContext, block) <strong class="ky iz">else<br/>        </strong>DeferredCoroutine&lt;T&gt;(newContext, active = <strong class="ky iz">true</strong>)<br/>    coroutine.start(start, coroutine, block)<br/>    <strong class="ky iz">return </strong>coroutine<br/>}</span></pre><p id="1bd8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个<code class="fe mn mo mp ky b">CoroutineScope</code>是一个由父节点生成，由子节点使用的作用域。因此，它形成了作为结构化并发基础的父子关系。它在每个协程函数中都是需要的，或者至少曾经是需要的，因为这个协程作用域正在建立这种关系。</p><p id="5ff4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管有必要在<code class="fe mn mo mp ky b">CoroutineScope</code>上扩展所有这些功能，但这确实是一种限制。默认情况下，接收器位置被锁定。例如，看到集合处理是如何实现的(在<code class="fe mn mo mp ky b">Iterable&lt;T&gt;</code>上的扩展函数)，您可能会怀疑我们应该为Kotlin通道提供类似的东西。尽管这不是官方文档建议实现处理器的方式:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="4d54" class="lc ld iy ky b gy le lf l lg lh">fun CoroutineScope.produceNumbers() = produce&lt;Int&gt; {<br/>   var x = 1 // start from 1<br/>   while (true) {<br/>   send(x++) // produce next<br/>   delay(100) // wait 0.1s<br/>   }<br/>}</span><span id="26b3" class="lc ld iy ky b gy lj lf l lg lh">fun CoroutineScope.launchProcessor(id: Int, channel: ReceiveChannel&lt;Int&gt;) = launch {<br/>   for (msg in channel) {<br/>   println(“Processor #$id received $msg”)<br/>   } <br/>}</span><span id="691c" class="lc ld iy ky b gy lj lf l lg lh">val producer = produceNumbers()<br/>repeat(5) { launchProcessor(it, producer) }<br/>delay(950)<br/>producer.cancel() // cancel producer coroutine and thus kill them all</span></pre><p id="b6fe" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能会说，这是因为信道代表了一种不同的抽象，它现在已经在<code class="fe mn mo mp ky b">Flows</code>中很好地(实验性地)实现了:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="48f9" class="lc ld iy ky b gy le lf l lg lh">flow.<em class="li">filter </em><strong class="ky iz">{ it </strong>% 2 == 0 <strong class="ky iz">}<br/>      </strong>.<em class="li">map </em><strong class="ky iz">{ it </strong>* 2 <strong class="ky iz">}</strong></span></pre><p id="ac80" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种关系显然存在。您可以在示例中看到，因为我在不同的上下文中启动了<code class="fe mn mo mp ky b">collect</code>，所以它在不同的调度程序中执行，我也可以从外部取消它:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="6457" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">import </strong>kotlinx.coroutines.*<br/><strong class="ky iz">import </strong>kotlinx.coroutines.flow.*<br/>@UseExperimental(InternalCoroutinesApi::<strong class="ky iz">class</strong>)<br/><strong class="ky iz">fun </strong>main() {<br/>    <em class="li">runBlocking </em><strong class="ky iz">{<br/>        val </strong>foo: Flow&lt;Int&gt; = <em class="li">flow </em><strong class="ky iz">{<br/>            for </strong>(i <strong class="ky iz">in </strong>1..100) {<br/>                <strong class="ky iz">val </strong>threadName = Thread.currentThread().<em class="li">name<br/>                println</em>(<strong class="ky iz">"Emitting $</strong>i<strong class="ky iz"> at $</strong>threadName<strong class="ky iz">"</strong>)<br/>                emit(i)<br/>                <em class="li">delay</em>(500)<br/>            }<br/>        <strong class="ky iz">}<br/>                </strong>.<em class="li">filter </em><strong class="ky iz">{ it </strong>% 2 == 0 <strong class="ky iz">}<br/>                </strong>.<em class="li">map </em><strong class="ky iz">{ it </strong>* 2 <strong class="ky iz">}<br/><br/>        val </strong>consume: <strong class="ky iz">suspend </strong>(Int) -&gt; Unit = <strong class="ky iz">{ </strong>value: Int <strong class="ky iz">-&gt;<br/>            </strong><em class="li">println</em>(<strong class="ky iz">"Consumed $</strong>value<strong class="ky iz"> at ${</strong>Thread.currentThread().<em class="li">name</em><strong class="ky iz">}"</strong>)<br/><br/>        <strong class="ky iz">}<br/><br/>        val </strong>job = <em class="li">Job</em>()<br/>        <em class="li">launch</em>(job + <em class="li">newSingleThreadContext</em>(<strong class="ky iz">"MyThread"</strong>)) <strong class="ky iz">{<br/>            </strong>foo.<em class="li">collect</em>(consume)<br/>            <em class="li">/*<br/>            Emitting 1 at MyThread<br/>            Emitting 2 at MyThread<br/>            Consumed 4 at MyThread<br/>            Emitting 3 at MyThread<br/>            */<br/>        </em><strong class="ky iz">}<br/>        </strong><em class="li">delay</em>(1200)<br/>        job.<em class="li">cancelAndJoin</em>()<br/>    <strong class="ky iz">}<br/></strong>}</span></pre><p id="e4d2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么为了使它成为可能，我们需要在这个<code class="fe mn mo mp ky b">collect</code>功能和上下文之间有一些联系。它过去是通过<code class="fe mn mo mp ky b">CoroutineScope</code>接收器传递的，但现在显然不是了。答案是这个问题以一种有点狡猾的方式被回避了。<code class="fe mn mo mp ky b">CoroutineContext</code>(这是<code class="fe mn mo mp ky b">CorouitneScope</code>接口的唯一组件)出现在continuation中(隐式传递给挂起函数)，并从那里获取。制作这种把戏的一种方法是暂停函数以获取上下文，然后立即恢复它。这就是<code class="fe mn mo mp ky b">coroutineScope</code>目前的实现方式:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="acbe" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">suspend fun </strong>&lt;R&gt; coroutineScope(block: <strong class="ky iz">suspend </strong>CoroutineScope.() -&gt; R): R =<br/>    <em class="li">suspendCoroutineUninterceptedOrReturn </em><strong class="ky iz">{ </strong>uCont <strong class="ky iz">-&gt;<br/>        val </strong>coroutine = ScopeCoroutine(uCont.<strong class="ky iz">context</strong>, uCont)<br/>        coroutine.<em class="li">startUndispatchedOrReturn</em>(coroutine, block)<br/>    <strong class="ky iz">}</strong></span></pre><p id="14ba" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯……这是一个棘手的方法，但由于这一点，我们不需要接收者，但仍然与父母有关系。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="58cc" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">suspend fun </strong>fakeOperation(): Int = <strong class="ky iz">try </strong>{<br/>    <em class="li">delay</em>(Long.<strong class="ky iz">MAX_VALUE</strong>)<br/>    42<br/>} <strong class="ky iz">finally </strong>{<br/>    <em class="li">println</em>(<strong class="ky iz">"Cancelled"</strong>)<br/>}<br/><br/><strong class="ky iz">suspend fun </strong>fakeOperations() = <em class="li">coroutineScope </em><strong class="ky iz">{<br/>    val </strong>a = <em class="li">async </em><strong class="ky iz">{ </strong><em class="li">fakeOperation</em>() <strong class="ky iz">}<br/>    val </strong>b = <em class="li">async </em><strong class="ky iz">{ </strong><em class="li">fakeOperation</em>() <strong class="ky iz">}<br/>    </strong>a.await() + b.await()<br/><strong class="ky iz">}<br/><br/>suspend fun </strong>main() = <em class="li">coroutineScope </em><strong class="ky iz">{<br/>    val </strong>job = <em class="li">Job</em>()<br/>    <em class="li">launch</em>(job) <strong class="ky iz">{<br/>        val </strong>ret = <em class="li">fakeOperations</em>()<br/>        <em class="li">print</em>(ret)<br/>    <strong class="ky iz">}<br/>    </strong><em class="li">delay</em>(1000)<br/>    job.<em class="li">cancelAndJoin</em>()<br/>    <em class="li">// Cancelled<br/>    // Cancelled<br/></em><strong class="ky iz">}</strong></span></pre><p id="5ff7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吃吗？修正了一些重要的用例，但是使得子节点和父节点之间的关系更加隐含。不久前，Kotlin为此推出了一个更强大的工具。现在，您可以在Kotlin stdlib中找到以下扩展属性:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="8064" class="lc ld iy ky b gy le lf l lg lh"><em class="li">/**<br/> * Returns the context of the current coroutine.<br/> */<br/></em>@SinceKotlin(<strong class="ky iz">"1.3"</strong>)<br/>@Suppress(<strong class="ky iz">"WRONG_MODIFIER_TARGET"</strong>)<br/>@InlineOnly<br/><strong class="ky iz">public suspend inline val </strong><em class="li">coroutineContext</em>: CoroutineContext<br/>    <strong class="ky iz">get</strong>() {<br/>        <strong class="ky iz">throw </strong>NotImplementedError(<strong class="ky iz">"Implemented as intrinsic"</strong>)<br/>    }</span></pre><p id="8899" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于这个原因，我们可以得到每个挂起函数的上下文:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="7412" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">suspend fun </strong>a() {<br/>    <em class="li">coroutineContext<br/></em>}</span></pre><p id="a8cd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例用途:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="b5fb" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">import </strong>kotlin.coroutines.<em class="li">coroutineContext</em></span><span id="cb27" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">suspend fun </strong>a() {<br/>    <em class="li">print</em>(<em class="li">coroutineContext</em>[CoroutineName]?.<strong class="ky iz">name</strong>)<br/>}</span><span id="02a7" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">fun </strong>main() {<br/>    <em class="li">runBlocking </em><strong class="ky iz">{<br/>        </strong><em class="li">withContext</em>(CoroutineName(<strong class="ky iz">"A"</strong>)) <strong class="ky iz">{<br/>            </strong><em class="li">a</em>() <em class="li">// A<br/>        </em><strong class="ky iz">}<br/>        </strong><em class="li">withContext</em>(CoroutineName(<strong class="ky iz">"B"</strong>)) <strong class="ky iz">{<br/>            </strong><em class="li">a</em>() <em class="li">// B<br/>        </em><strong class="ky iz">}<br/>    }<br/></strong>}</span></pre><p id="c99d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它之所以存在，是因为挂起函数将延续作为一个参数传递给彼此，并且它包含这个上下文。所以我们可以说我们找到了传递另一个隐式值的方法。它解决了一般的问题吗？不完全是。</p><p id="6333" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，挂起函数的实现方式有一些限制。挂起函数需要延续，所以只能在挂起函数中调用。这在非内联的lambdas中也可能是个问题。比方说，在Ktor框架中，我想基于来自数据库的数据构建HTML:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="6f24" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">get</strong>(<strong class="ky iz">"editPublicWorkshop/{key}"</strong>) <strong class="ky iz">{<br/>    val </strong>key = <em class="li">requireParameter</em>(<strong class="ky iz">"key"</strong>)<br/>    <em class="li">call</em>.<em class="li">respondHtml </em><strong class="ky iz">{<br/>        body {<br/>            form {<br/>                for </strong>(lang <strong class="ky iz">in </strong>Languages.values()) {<br/>                    <strong class="ky iz">val </strong>publicWorkshop = publicWorkshopsRepo.getPublicWorkshop(key, lang.<strong class="ky iz">key</strong>) // ERROR<br/>                    +lang.<strong class="ky iz">key<br/>                    textArea</strong>(cols = <strong class="ky iz">"60"</strong>, rows = <strong class="ky iz">"5"</strong>) <strong class="ky iz">{<br/>                        name</strong>=lang.<strong class="ky iz">key<br/>                        </strong>+(publicWorkshop?.<em class="li">toJson</em>() ?: <strong class="ky iz">""</strong>)<br/>                    <strong class="ky iz">}<br/>                </strong>}<br/>                <strong class="ky iz">button</strong>(type = ButtonType.<strong class="ky iz">submit</strong>) <strong class="ky iz">{ </strong>+<strong class="ky iz">"Submit" }<br/>            }<br/>        }<br/>    }<br/>}</strong></span></pre><p id="dc6f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看起来不错，但是不工作，因为<code class="fe mn mo mp ky b">getPublicWorkshop</code>是一个悬浮函数。它可以在<code class="fe mn mo mp ky b">get</code>的范围内工作，但不能在<code class="fe mn mo mp ky b">form</code>的范围内工作。这是解决问题的方法:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="7f71" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">get</strong>(<strong class="ky iz">"editPublicWorkshop/{key}"</strong>) <strong class="ky iz">{<br/>    val </strong>key = <em class="li">requireParameter</em>(<strong class="ky iz">"key"</strong>)<br/>    <strong class="ky iz">val </strong>langToPublicWorkshop = Languages.values()<br/>        .<em class="li">associate </em><strong class="ky iz">{ </strong>lang <strong class="ky iz">-&gt; </strong>lang <em class="li">to </em>publicWorkshopsRepo.getPublicWorkshop(key, lang.<strong class="ky iz">key</strong>) <strong class="ky iz">}</strong></span><span id="6709" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">    </strong><em class="li">call</em>.<em class="li">respondHtml </em><strong class="ky iz">{<br/>        body {<br/>            form {<br/>                for </strong>(lang <strong class="ky iz">in </strong>Languages.values()) {<br/>                    +lang.<strong class="ky iz">key<br/>                    textArea</strong>(cols = <strong class="ky iz">"60"</strong>, rows = <strong class="ky iz">"5"</strong>) <strong class="ky iz">{<br/>                        name</strong>=lang.<strong class="ky iz">key<br/>                        </strong>+(langToPublicWorkshop[lang]?.<em class="li">toJson</em>() ?: <strong class="ky iz">""</strong>)<br/>                    <strong class="ky iz">}<br/>                </strong>}<br/>                <strong class="ky iz">button</strong>(type = ButtonType.<strong class="ky iz">submit</strong>) <strong class="ky iz">{ </strong>+<strong class="ky iz">"Submit" }<br/>            }<br/>        }<br/>    }<br/>}</strong></span></pre><h1 id="4650" class="ll ld iy bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">Jetpack撰写</h1><p id="e9d5" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">另一个著名的DSL构建器是Jetpack Compose:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="6ada" class="lc ld iy ky b gy le lf l lg lh">@Composable<br/><strong class="ky iz">fun </strong>Counter() {<br/>    <strong class="ky iz">val </strong>amount = +state <strong class="ky iz">{ </strong>0 <strong class="ky iz">}</strong></span><span id="922d" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">    </strong>Column <strong class="ky iz">{<br/>        </strong>Text(text = <strong class="ky iz">"Counter demo"</strong>)<br/>        Button(text = <strong class="ky iz">"Add"</strong>, onClick = <strong class="ky iz">{ </strong>amount.<em class="li">value</em>++ <strong class="ky iz">}</strong>)<br/>        Button(text = <strong class="ky iz">"Subtract"</strong>, onClick = <strong class="ky iz">{ </strong>amount.<em class="li">value</em>-- <strong class="ky iz">}</strong>)<br/>        Text(text = <strong class="ky iz">"Clicks: ${</strong>amount.<em class="li">value</em><strong class="ky iz">}"</strong>)<br/>    <strong class="ky iz">}<br/></strong>}</span></pre><p id="1aa0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可能想知道为什么它没有扩展接收器。它确实和许多其他元素在一起，但它们都很复杂，而<code class="fe mn mo mp ky b">Composable</code>注释是作为一种更简单的方式引入的(在这里<a class="ae mq" href="http://intelligiblebabble.com/compose-from-first-principles/" rel="noopener ugc nofollow" target="_blank">阅读</a>)。因此，该位置已经被锁定，您可以忘记<code class="fe mn mo mp ky b">Composable</code>扩展功能。</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><a href="https://kt.academy/workshop/automaticTestingForBeginners"><div class="gh gi mr"><img src="../Images/3abcc7bf2c50c85e442eda42ef18d587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMYtScxROfxxZWVgepGaug.png"/></div></a></figure><h1 id="e4e7" class="ll ld iy bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">关闭</h1><p id="8db9" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">在我的演讲“Kotlin禁止做的事情”中，我把“隐藏太多”列为Kotlin开发者最大的错误之一。隐式传递parent的接收器在编程界是一个相对较新的想法，但它已经受到Kotlin开发人员的喜爱和高度使用。虽然我们开始触及边界，但我们只能通过一个接收器。这个限制会阻止我们以我们已经习惯的方式进行代码提取。</p><p id="36d9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">形式上，语言设计者可以允许一个以上的隐式接收者(比如在成员扩展中)，但是这个想法听起来非常可怕。不清楚什么东西来自哪里，修改了什么，优先级是什么…成员扩展已经是一个坏主意，允许更多的接收者就像增加了所有的问题。</p><p id="bbe8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一方面，在一些用例中，受阻挡的接收器位置会造成限制。对于协程程序，创建者设法用更隐含的技巧来避免这个问题。现在<code class="fe mn mo mp ky b">coroutineContext</code>为既有趣又有点可怕的可能性打开了大门。</p><p id="4720" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目前，对于这种设计限制还没有通用的解决方案。我们的感知在进化，我们在寻找更好的方法。库设计者慢慢了解到强迫用户在接收器上操作的代价。这是一个有趣的话题，我会观察它的发展。</p></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><h1 id="fd25" class="ll ld iy bd lm ln mz lp lq lr na lt lu lv nb lx ly lz nc mb mc md nd mf mg mh bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="d95b" class="pw-post-body-paragraph jv jw iy jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae mq" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae mq" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><p id="c624" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您需要Kotlin工作室，请查看我们如何帮助您:<a class="ae mq" href="https://kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi mr"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>