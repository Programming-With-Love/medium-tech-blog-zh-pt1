<html>
<head>
<title>Jetpack Compose — When should I use derivedStateOf?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack Compose —何时应该使用derivedStateOf？</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/jetpack-compose-when-should-i-use-derivedstateof-63ce7954c11b?source=collection_archive---------0-----------------------#2022-11-29">https://medium.com/androiddevelopers/jetpack-compose-when-should-i-use-derivedstateof-63ce7954c11b?source=collection_archive---------0-----------------------#2022-11-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/078a61e7f1529fde5fd48e03bbeb891b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cJ6d21rzC_zSUrMa0nCvJQ.png"/></div></div></figure><div class=""/><p id="79a4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们看到的一个常见问题是，何时何地使用这个API才是正确的？</p><p id="4fb8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个问题的答案是<code class="du jn jo jp jq b"><strong class="ir ht">derivedStateOf {}</strong></code> <strong class="ir ht">应该在你的状态或者按键变化超过你想要更新UI </strong>的时候使用。或者换句话说，<code class="du jn jo jp jq b">derivedStateOf</code>就像<code class="du jn jo jp jq b">distinctUntilChanged</code>来自<a class="ae jr" href="https://developer.android.com/kotlin/flow" rel="noopener ugc nofollow" target="_blank">科特林流</a>或者其他类似的反应式框架。记住，当Composables <a class="ae jr" href="https://developer.android.com/jetpack/compose/mental-model#recomposition" rel="noopener ugc nofollow" target="_blank">读取的compose状态对象改变时，compose </a>会重新组合。<code class="du jn jo jp jq b">derivedStateOf</code>允许你创建一个新的状态对象，只根据你的需要改变。</p><p id="a412" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看一个例子。这里我们有一个用户名字段和一个按钮，当用户名有效时启用。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="jw jx l"/></div></figure><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jy"><img src="../Images/0ef3f70b8caffcee470d32762e51f54c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_aJTh9ebhWd7C5pX"/></div></div><figcaption class="jz ka et er es kb kc bd b be z dx">Initial state of username and submitEnabled</figcaption></figure><p id="2401" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一开始是空的，所以我们的状态是假的。现在，当用户开始输入时，我们的状态会正确更新，我们的按钮会变为启用状态。</p><p id="0ee6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但问题是，当我们的用户不停地输入时，我们就不必要地一遍又一遍地向按钮发送状态。</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jy"><img src="../Images/86ea7183a4bd9a9fac2b43490e0c77bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A-hfipB2TcGGn5-A"/></div></div><figcaption class="jz ka et er es kb kc bd b be z dx">State updates after the user continues typing</figcaption></figure><p id="0300" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是<code class="du jn jo jp jq b">derivedStateOf</code>的用武之地。我们的状态变化超过了我们更新UI的需要，因此<code class="du jn jo jp jq b">derivedStateOf</code>可以用于减少重新组合的次数。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="jw jx l"/></div></figure><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kd"><img src="../Images/53e50bb27b2c3829e52db0593e55fcd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GIAxMyKUUgcw0Ki8"/></div></div><figcaption class="jz ka et er es kb kc bd b be z dx">Updating the code to use <code class="du jn jo jp jq b">derivedStateOf</code></figcaption></figure><p id="21af" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们再看一遍同一个例子，看看有什么不同。</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jy"><img src="../Images/c6b77ffde74f90a66f65e460d54d5587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2XM1Vdu7EJ8D3rAp"/></div></div><figcaption class="jz ka et er es kb kc bd b be z dx">State updates with derivedStateOf</figcaption></figure><p id="459e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用户开始输入，但是这次我们的用户名状态是唯一改变的。提交状态保持不变。当然，如果我们的用户名无效。我们的派生状态再次正确更新。</p><p id="e5c5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个例子有点过于简单了。在真实的应用程序中，Compose最有可能<a class="ae jr" href="https://developer.android.com/jetpack/compose/mental-model#recomposition" rel="noopener ugc nofollow" target="_blank">跳过submit composable的重组</a>，因为它的输入参数没有改变。</p><p id="567b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">事实是，你需要<code class="du jn jo jp jq b">derivedStateOf</code>的情况少之又少。但是当你找到一个案例时，它在最小化重组方面非常有效。</p><blockquote class="ke kf kg"><p id="61d7" class="ip iq kh ir b is it iu iv iw ix iy iz ki jb jc jd kj jf jg jh kk jj jk jl jm ha bi translated"><strong class="ir ht">始终记住，输入参数和输出结果之间的变化量需要有差异，这样</strong> <code class="du jn jo jp jq b"><strong class="ir ht">derivedStateOf</strong></code> <strong class="ir ht">才有意义。</strong></p></blockquote><p id="eb70" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">何时可以使用它的一些例子(不详尽):</p><ul class=""><li id="97f8" class="kl km hs ir b is it iw ix ja kn je ko ji kp jm kq kr ks kt bi translated">观察滚动是否超过阈值(scrollPosition &gt; 0)</li><li id="9fcf" class="kl km hs ir b is ku iw kv ja kw je kx ji ky jm kq kr ks kt bi translated">列表中的项目大于阈值(项目&gt; 0)</li><li id="8b34" class="kl km hs ir b is ku iw kv ja kw je kx ji ky jm kq kr ks kt bi translated">表单验证如上(username.isValid())</li></ul><h1 id="5275" class="kz la hs bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">常见问题</h1><p id="e448" class="pw-post-body-paragraph ip iq hs ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">现在，我们来看看其他一些关于<code class="du jn jo jp jq b">derivedStateOf</code>的常见问题。</p><h1 id="af5a" class="kz la hs bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">derivedStateOf一定要被记住吗？</h1><p id="0e68" class="pw-post-body-paragraph ip iq hs ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">如果它在一个可组合的函数中，是的。<code class="du jn jo jp jq b">derivedStateOf</code>就像<code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#mutableStateOf(kotlin.Any,androidx.compose.runtime.SnapshotMutationPolicy)" rel="noopener ugc nofollow" target="_blank">mutableStateOf</a></code>或者其他任何需要重组才能存活的物体。如果你在一个可组合的函数中使用它，那么它应该被包装在一个<code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Any,kotlin.Any,kotlin.Any,kotlin.Function0)" rel="noopener ugc nofollow" target="_blank">remember</a></code>中，否则它将在每次重组时被重新分配。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="jw jx l"/></div></figure><h1 id="ee64" class="kz la hs bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">remember(key)和derivedStateOf有什么区别？</h1><p id="3d27" class="pw-post-body-paragraph ip iq hs ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">记住每个状态的按键和<code class="du jn jo jp jq b">derivedStateOf</code>乍一看似乎很相似。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="1bd9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">remember(key)</code>和<code class="du jn jo jp jq b">derivedStateOf</code>的区别在于重组的量。<code class="du jn jo jp jq b"><strong class="ir ht">derivedStateOf {}</strong></code> <strong class="ir ht">当你的状态或按键变化超过你想要更新UI的时候使用。</strong></p><p id="d395" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，只有当用户滚动了<code class="du jn jo jp jq b">LazyColumn</code>时才启用按钮。</p><p id="f7bf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">val isEnabled = lazyListState.firstVisibileItemIndex &gt; 0</code></p><p id="a877" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">firstVisibleItemIndex</code>会随着用户滚动而改变0、1、2等，并在每次改变时使读者重新编写。我们只关心它是否大于0。我们拥有的输入量和我们需要的输出量是不同的，所以这里使用<code class="du jn jo jp jq b">derivedStateOf</code>来缓冲不必要的重组。</p><p id="5393" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">val isEnabled = remember { <br/> derivedStateOf { lazyListState.firstVisibleItemIndex &gt; 0 } <br/>}</code></p><p id="3cb4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，假设我们有一个昂贵的函数，它用一个参数为我们计算一些东西。我们希望我们的UI在该函数的输出改变的任何时候重新组合(重要的是，该函数也是<a class="ae jr" href="https://en.wikipedia.org/wiki/Idempotence" rel="noopener ugc nofollow" target="_blank">幂等的</a>)。我们在这里使用remember with a key，<strong class="ir ht">，因为我们的UI需要随着键的变化而更新</strong>。也就是说，我们有相同数量的输入和输出。</p><p id="0b37" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">val output = remember(input) { expensiveCalculation(input) }</code></p><h1 id="ceda" class="kz la hs bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">我需要同时使用remember(键)和derivedStateOf吗？什么时候需要这个？</h1><p id="9656" class="pw-post-body-paragraph ip iq hs ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">这就是事情变得有点棘手的地方。<code class="du jn jo jp jq b">derivedStateOf</code>只能在读取撰写状态对象时更新。当派生状态被创建时，在<code class="du jn jo jp jq b">derivedStateOf</code>中读取的任何其他变量将捕获该变量的初始值。如果您需要在计算中使用这些变量，那么您可以将它们作为remember函数的关键字。这个概念用一个例子就容易理解多了。让我们以之前的<code class="du jn jo jp jq b">isEnabled</code>为例，将其扩展为也有一个何时启用按钮的阈值，而不是0。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="5fdf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里我们有一个按钮，当列表滚动超过一个阈值时启用。我们正确地使用了<code class="du jn jo jp jq b">derivedStateOf</code>来移除额外的重组，但是有一个微妙的错误。如果threshold参数发生变化，我们的<code class="du jn jo jp jq b">derivedStateOf</code>不会考虑新值，因为它会在创建任何不是compose state对象的变量时捕获初始值。由于threshold是一个<code class="du jn jo jp jq b">Int</code>，无论传递给我们的composable的第一个值是什么，都将被捕获并用于此后的计算。<code class="du jn jo jp jq b">ScrollToTopButton</code>仍然会重组，因为它的输入已经改变，但是记住重组时没有任何键缓存，它不会用新值重新初始化<code class="du jn jo jp jq b">derivedStateOf</code>。</p><p id="910d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以通过查看代码的输出来了解这一点。起初一切正常。</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mc"><img src="../Images/54ad13727727e1d662a4d3a1aadf525a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nN2LjodvibxFHqky6rIg1A.png"/></div></div></figure><p id="4c1e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是随后threshold的一个新值<code class="du jn jo jp jq b">(5)</code>被传入我们的composable。</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es md"><img src="../Images/04726e91b1d1f0667a43d581ffe20d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yiiq11IGf9RFC28kK6dIwQ.png"/></div></div></figure><p id="ce33" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">即使我们的<code class="du jn jo jp jq b">scrollPosition</code>小于<code class="du jn jo jp jq b">threshold</code>，但是<code class="du jn jo jp jq b">isEnabled</code>仍然被设置为<code class="du jn jo jp jq b">true</code>。</p><p id="1cd4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此处的修复是添加threshold作为remember键，这将在阈值改变时重新初始化我们的<code class="du jn jo jp jq b">derivedStateOf</code>状态。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="bb55" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们可以看到，当阈值改变时，<code class="du jn jo jp jq b">isEnabled</code>状态会正确更新。</p><figure class="js jt ju jv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es md"><img src="../Images/33895f05426cd8a0ab46f232ebee0038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2qHyx0_3_cgbRAnlgLLzw.png"/></div></div></figure><h1 id="f74e" class="kz la hs bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">我需要使用derivedStateOf将多个状态组合在一起吗？</h1><p id="66bd" class="pw-post-body-paragraph ip iq hs ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">如果你有多个状态组合在一起产生一个结果，那么你可能希望在其中一个改变的时候发生重组。</p><p id="839e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以一个表单为例，它接受名和姓，并显示全名。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="63e3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，由于我们的输出和输入变化一样多，derivedStateOf没有做任何事情，只是产生了一点开销。derivedStateOf对异步更新也没有帮助，Compose <a class="ae jr" href="https://dev.to/zachklipp/introduction-to-the-compose-snapshot-system-19cn" rel="noopener ugc nofollow" target="_blank">状态快照系统</a>正在单独处理这个问题，这里的这些调用是同步的。</p><p id="7f69" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种情况下，根本不需要额外的派生状态对象。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="jw jx l"/></div></figure><h1 id="a02c" class="kz la hs bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="0b3c" class="pw-post-body-paragraph ip iq hs ir b is lx iu iv iw ly iy iz ja lz jc jd je ma jg jh ji mb jk jl jm ha bi translated">总而言之，记住derivedStateOf是在你的状态或者键<strong class="ir ht">变化超过你想要更新UI的时候使用的。</strong>如果投入量与产出量相比没有差异，就不需要使用。</p></div></div>    
</body>
</html>