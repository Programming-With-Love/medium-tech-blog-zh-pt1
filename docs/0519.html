<html>
<head>
<title>Shrinking Kotlin libraries and applications using Kotlin reflection with R8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过R8使用Kotlin反射缩小Kotlin库和应用程序</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/shrinking-kotlin-libraries-and-applications-using-kotlin-reflection-with-r8-6fe0a0e2d115?source=collection_archive---------1-----------------------#2020-07-15">https://medium.com/androiddevelopers/shrinking-kotlin-libraries-and-applications-using-kotlin-reflection-with-r8-6fe0a0e2d115?source=collection_archive---------1-----------------------#2020-07-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/3c5d45b6e4e317f327273d7b5a72936a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgEQvGRB4PQmuAjXylmvsg.png"/></div></div></figure><div class=""/><p id="43e8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">莫滕·克罗-叶斯柏森和小麦·阿格合著</em></p><p id="3602" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jo" href="https://r8.googlesource.com/r8" rel="noopener ugc nofollow" target="_blank"> R8 </a>是安卓系统默认的应用收缩器。R8通过删除未使用的代码和优化剩余的代码来减少Android应用程序的大小。R8也支持缩小Android库。除了产生更小的库，库收缩还可以用来隐藏库的新特性，直到你准备好发布它们或者公开谈论它们。</p><p id="2cbd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Kotlin是编写Android应用程序和库的绝佳语言。然而，缩小使用Kotlin反射的Kotlin库或应用程序会带来一些挑战。Kotlin在Java类文件中使用<a class="ae jo" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-metadata/" rel="noopener ugc nofollow" target="_blank">元数据来标识Kotlin语言结构。如果您的应用程序收缩器不维护和更新Kotlin元数据，您的库或应用程序将无法工作。</a></p><p id="9149" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">R8现在支持维护和重写Kotlin元数据，以完全支持使用Kotlin反射的Kotlin库和应用程序的收缩。Android Gradle插件版本4.1.0-beta03中提供了该支持。请尝试一下，让我们知道它是如何为您工作的，并将您遇到的任何问题记录在<a class="ae jo" href="https://issuetracker.google.com/issues/new?component=326788&amp;template=1025938" rel="noopener ugc nofollow" target="_blank">我们的公共错误跟踪器</a>中。</p><p id="4b6b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这篇博文的其余部分提供了关于Kotlin元数据和R8对Kotlin元数据重写的支持的信息。</p><h1 id="9c84" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">科特林元数据</h1><p id="acff" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated"><a class="ae jo" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-metadata/" rel="noopener ugc nofollow" target="_blank"> Kotlin元数据</a>是存储在由Kotlin JVM编译器生成的Java类文件的注释中的额外信息。该元数据指定了类文件中给定的类或方法对应于哪种Kotlin语言结构。例如，Kotlin元数据允许Kotlin编译器识别类文件中的方法实际上是一个<a class="ae jo" href="https://kotlinlang.org/docs/reference/extensions.html" rel="noopener ugc nofollow" target="_blank"> Kotlin扩展函数</a>。</p><p id="a2c1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看一个简单的例子。下面的库代码定义了一个假想的基本命令生成器，用于构建编译器命令。</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="10d3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后我们可以在<code class="du ky kz la lb b">CommandBuilderBase</code>之上定义一个具体的、假设的<code class="du ky kz la lb b">D8CommandBuilder</code>来构建一个简化的D8命令。</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="8e06" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该示例使用扩展函数，以确保如果您在<code class="du ky kz la lb b">D8CommandBuilder</code>上调用<code class="du ky kz la lb b">setMinApi </code>方法，返回的对象类型将是<code class="du ky kz la lb b">D8CommandBuilder</code>而不是<code class="du ky kz la lb b">CommandBuilderBase</code>。这些扩展函数是顶级的，并且它们以文件类<code class="du ky kz la lb b">CommandBuilderKt</code>为例。让我们看看使用(简化的)<code class="du ky kz la lb b">javap</code>输出的那个类文件。</p><pre class="ks kt ku kv fd lc lb ld le aw lf bi"><span id="ca51" class="lg jq hs lb b fi lh li l lj lk">$ javap com/example/mylibrary/CommandBuilderKt.class<br/>Compiled from "CommandBuilder.kt"<br/>public final class CommandBuilderKt {<br/>public static final &lt;T extends CommandBuilderBase&gt; T addInput(T,      String);<br/>public static final &lt;T extends CommandBuilderBase&gt; T setMinApi(T, int);<br/>...<br/>}</span></pre><p id="7053" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du ky kz la lb b">javap</code>输出显示扩展函数被编译成静态方法，这些静态方法采用额外的第一个参数，即扩展接收器。这些信息不足以让Kotlin编译器理解这些方法可以从Kotlin代码中用作扩展函数。因此，Kotlin编译器也放了一个<a class="ae jo" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-metadata/" rel="noopener ugc nofollow" target="_blank"> kotlin。类文件中的元数据标注</a>。该注释包含元数据，其中包含该类的额外的Kotlin特定信息。如果我们使用带有<code class="du ky kz la lb b">javap</code>的详细标志，注释就会出现。</p><pre class="ks kt ku kv fd lc lb ld le aw lf bi"><span id="3ba4" class="lg jq hs lb b fi lh li l lj lk">$ javap -v com/example/mylibrary/CommandBuilderKt.class<br/>...<br/>RuntimeVisibleAnnotations:<br/>  0: kotlin/Metadata(<br/>   mv=[...],<br/>   bv=[...],<br/>   k=...,<br/>   xi=...,<br/>   d1=["^@.\n^B^H^B\n^B^X^B\n^@\n^B^P^N\n^B...^D"],<br/>   d2=["setMinApi", ...])</span></pre><p id="e8ce" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">元数据注释的d1字段包含协议缓冲区消息形式的大部分实际元数据。元数据的确切内容并不重要。重要的是，Kotlin编译器读取这些元数据，并使用它来判断这些方法是扩展函数，如下面的<code class="du ky kz la lb b">kotlinp</code>转储所示。</p><pre class="ks kt ku kv fd lc lb ld le aw lf bi"><span id="ccca" class="lg jq hs lb b fi lh li l lj lk">$ kotlinp com/example/mylibrary/CommandBuilderKt.class<br/>package {</span><span id="34ce" class="lg jq hs lb b fi ll li l lj lk">// signature:   addInput(CommandBuilderBase,String)CommandBuilderBase<br/>public final fun &lt;T : CommandBuilderBase&gt; T.addInput(input: kotlin/String): T</span><span id="ee5a" class="lg jq hs lb b fi ll li l lj lk">// signature: setMinApi(CommandBuilderBase,I)CommandBuilderBase<br/>public final fun &lt;T : CommandBuilderBase&gt; T.setMinApi(api: kotlin/Int): T</span><span id="4398" class="lg jq hs lb b fi ll li l lj lk">...<br/>}</span></pre><p id="e4d5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该元数据允许在Kotlin用户代码中将这些函数用作Kotlin扩展函数:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="6c00" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">R8过去是如何破坏科特林图书馆的</h1><p id="0ccb" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">如前一节所示，库类文件的Kotlin元数据对于能够使用库的Kotlin API非常重要。然而，元数据在注释中，并被编码为协议缓冲区消息，R8过去对此一无所知。因此，R8过去常做两件事之一:</p><ol class=""><li id="641c" class="lm ln hs ir b is it iw ix ja lo je lp ji lq jm lr ls lt lu bi translated">扔掉元数据。</li><li id="86a9" class="lm ln hs ir b is lv iw lw ja lx je ly ji lz jm lr ls lt lu bi translated">保留原始元数据。</li></ol><p id="9ebd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这两个方案都很糟糕。</p><p id="de6d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果元数据被丢弃，Kotlin编译器将不再理解扩展函数是扩展函数。因此，对于我们的示例，当编译诸如<code class="du ky kz la lb b">D8CommandBuilder().setMinApi(12)</code>这样的代码时，编译器将产生一个错误，指出不存在这样的方法。这很有意义，因为没有元数据，Kotlin编译器只能看到一个带有两个参数的Java静态方法。</p><p id="b926" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">保留原始元数据也不好。Kotlin元数据中记录的事情之一是类的超类型。所以，假设我们只希望<code class="du ky kz la lb b">D8CommandBuilder</code>类在收缩库时保留它们的名字。这意味着<code class="du ky kz la lb b">CommandBuilderBase</code>将被重命名，很可能是a。如果我们保留原始的Kotlin元数据，Kotlin编译器将寻找Kotlin元数据中记录的<code class="du ky kz la lb b">D8CommandBuilder</code>的超类型。如果我们使用原始元数据，记录的超类型是<code class="du ky kz la lb b">CommandBuilderBase</code>而不是<code class="du ky kz la lb b">a.</code>，那么编译将会失败，并显示一个错误，指出超类型<code class="du ky kz la lb b">CommandBuilderBase</code>不存在。</p><h1 id="001d" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">R8·科特林元数据重写</h1><p id="1a33" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">为了解决这些问题，R8扩展了维护和重写Kotlin元数据的能力。这是通过嵌入由R8 JetBrains开发的<a class="ae jo" href="https://github.com/JetBrains/kotlin/blob/master/libraries/kotlinx-metadata/jvm/ReadMe.md" rel="noopener ugc nofollow" target="_blank"> Kotlin元数据库</a>来实现的。元数据库用于读取原始输入中的Kotlin元数据。元数据信息记录在R8的内部数据结构中。当R8完成对库或应用程序的优化和缩减后，它会为显式保留的所有Kotlin类合成新的正确的Kotlin元数据。</p><p id="cb37" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看我们的例子是什么样子的。我们将示例代码放入Android Studio库项目中。我们通过像往常一样在gradle构建文件中将<code class="du ky kz la lb b">minifyEnabled</code>设置为true <a class="ae jo" href="https://developer.android.com/studio/build/shrink-code#enable" rel="noopener ugc nofollow" target="_blank">来启用收缩。我们更新收缩器配置以包含以下内容。</a></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="424d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这告诉R8保持<code class="du ky kz la lb b">D8CommandBuilder</code>和<code class="du ky kz la lb b">CommandBuilderKt</code>上的所有扩展功能。它还告诉R8保留注释，特别是保留<code class="du ky kz la lb b">kotlin.Metadata</code>注释。这些规则将只在显式保留的类上保留Kotlin元数据。因此，这将保持<code class="du ky kz la lb b">D8CommandBuilder</code>和<code class="du ky kz la lb b">CommandBuilderKt</code>上的元数据，但<strong class="ir ht">不会保持<code class="du ky kz la lb b">CommandBuilderBase</code>上的</strong>。我们这样做是为了确保您不会在应用程序和库中传送大量无用的元数据。</p><p id="75a9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，在启用收缩的情况下构建库会产生一个库，其中<code class="du ky kz la lb b">CommandBuilderBase</code>已被重命名为<code class="du ky kz la lb b">a</code>。此外，所有保留的类的Kotlin元数据已经被重写，因此任何对<code class="du ky kz la lb b">CommandBuilderBase</code>的引用现在都是指<code class="du ky kz la lb b">a</code>。这使得图书馆如预期的那样作为科特林图书馆工作。</p><p id="c721" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后一点，不在<code class="du ky kz la lb b">CommandBuilderBase</code>上保存Kotlin元数据意味着Kotlin编译器会将输出中的结果类视为Java类。这可能会导致您的库中出现奇怪的Kotlin类的Java实现细节。为了避免这种情况，可以保留类。如果我们这样做，元数据将被保留。我们可以在keep规则上使用<code class="du ky kz la lb b">allowobfuscation</code>修饰符来允许R8重命名该类，同时也为其生成Kotlin元数据，这样Kotlin编译器和Android Studio就会将该类视为Kotlin类。</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="42ae" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到目前为止，我们一直在谈论库收缩以及Kotlin库如何需要Kotlin元数据。通过kotlin-reflect库使用Kotlin反射的应用程序也需要Kotlin元数据。这些问题与图书馆的问题完全一样。如果Kotlin元数据被删除或没有正确更新，kotlin-reflect库将无法将代码理解为kotlin代码。</p><p id="25c3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">举个简单的例子，假设我们想在运行时查找并调用一个类的扩展函数。我们希望允许方法被重命名，因为我们不关心名称，我们只想找到它并在运行时调用它。</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="74c8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的代码中，我们添加了一个调用:<code class="du ky kz la lb b">reflect(ReflectOnMe())</code>。这将找到在<code class="du ky kz la lb b">ReflectOnMe</code>上定义的扩展函数，并使用给定的<code class="du ky kz la lb b">ReflectOnMe</code>实例作为接收者和字符串<code class="du ky kz la lb b">“reflection”</code>作为扩展接收者来调用它。</p><p id="d13a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，R8正确地重写了所有保留类的Kotlin元数据，我们可以使用下面的shrinker配置来缩小应用程序。</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="8f8a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这允许<code class="du ky kz la lb b">ReflectOnMe</code>和<code class="du ky kz la lb b">extension</code>都被重命名，它维护并重写Kotlin元数据，应用程序正常工作。</p><h1 id="81c6" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">试试看！</h1><p id="3e05" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">请在Kotlin库项目以及使用Kotlin反射的Kotlin项目上尝试R8对Kotlin元数据重写的支持。从版本4.1.0-beta03开始，Android Gradle插件中提供了这种支持。如果您在使用它时遇到任何问题，请在<a class="ae jo" href="https://issuetracker.google.com/issues/new?component=326788&amp;template=1025938" rel="noopener ugc nofollow" target="_blank">我们的公共错误跟踪器</a>中提交错误报告。</p><p id="3097" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">快乐缩水！</p></div></div>    
</body>
</html>