<html>
<head>
<title>Persist your data elegantly: U2020 way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优雅地保存您的数据:U2020方式</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/persist-your-data-elegantly-u2020-way-c50be19acf9?source=collection_archive---------1-----------------------#2015-09-01">https://medium.com/google-developer-experts/persist-your-data-elegantly-u2020-way-c50be19acf9?source=collection_archive---------1-----------------------#2015-09-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5343" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">SharedPreferences 非常棒，是在Android上持久保存用户数据的最简单方法。它允许您以键值对的形式存储/访问基本的偏好数据。支持存储/访问原始数据:<strong class="ig hi"> boolean、float、int、long、String、<em class="jc"> StringSet ( </em> </strong> <em class="jc">不巧不是数组)。</em></p><p id="c457" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">几乎所有安卓应用都用。尽管API的使用很简单，但它也有自己的问题。当您的代码库增长时，它变得很容易出错，因为它是初始化的，并与字符串文字一起使用。</p><p id="83bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将首先谈论访问<em class="jc">shared preferences</em>API的传统方法，并讨论所有常见方法的问题。当代码库变得更大时，这些问题尤其重要。</p><p id="7e1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我将给出另一种更简洁的方法，即使用依赖注入。我在杰克·沃顿<a class="ae jd" href="https://github.com/JakeWharton/" rel="noopener ugc nofollow" target="_blank">的一个名为</a><a class="ae jd" href="https://github.com/JakeWharton/u2020" rel="noopener ugc nofollow" target="_blank"> U2020 </a>的开源示例应用中遇到了这种方法。它使用<em class="jc"> Dagger </em>来访问<em class="jc"> SharedPreferences </em>。我们将在本帖中使用<em class="jc">匕首2 </em>。它是为Java和Android设计的最快的依赖注入库。</p><p id="4016" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你已经在使用<em class="jc"> Dagger，</em>你会发现一种更干净安全的方式来访问<em class="jc"> SharedPreferences。</em>如果你没有，并且想学习<em class="jc"> Dagger 2，</em>这是一篇很棒的帖子，因为它通过提供Dagger的真实使用案例展示了它的用处。我保证它没有咖啡，加热器和泵的例子☺</p><h1 id="b027" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">传统方式</h1><p id="0840" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">您首先需要访问一个<em class="jc"> SharedPreferences </em>类的实例。它可以通过两种不同的方式获得:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="27d0" class="kq jf hh km b fi kr ks l kt ku">//Use a static helper method.<br/>PreferenceManager.<em class="jc">getDefaultSharedPreferences</em>(Context context);</span><span id="3c53" class="kq jf hh km b fi kv ks l kt ku">//Or use a method in your Context<br/>getSharedPreferences(String name, int mode)</span></pre><p id="780b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jd" href="http://developer.android.com/reference/android/preference/PreferenceManager.html#getDefaultSharedPreferences(android.content.Context)" rel="noopener ugc nofollow" target="_blank">第一个方法</a>给出了默认的<em class="jc"> SharedPreferences </em>，它将数据保存到一个名为app包名的文件中。使用<a class="ae jd" href="http://developer.android.com/reference/android/content/Context.html#getSharedPreferences(java.lang.String, int)" rel="noopener ugc nofollow" target="_blank">第二种方法</a>，您可以选择提供首选项文件的文件名和访问它的模式。</p><p id="69c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，您可以获得如下数据:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="3442" class="kq jf hh km b fi kr ks l kt ku">String myValue = prefs.getString("myKey", "deafultValue");</span></pre><p id="c04b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里的问题是，每次使用时，您都必须提供一个<em class="jc">字符串</em>键和一个默认值。大多数开发人员不会为这些键使用一个<em class="jc">常量</em>文件，而是一遍又一遍地输入它们，这使得它容易出错。</p><p id="a5bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是为什么我在过去用如下方法创建了一个单独的<em class="jc"> PrefUtils </em>类来防止错误:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="bcb3" class="kq jf hh km b fi kr ks l kt ku">PrefUtils.getMyValue();<br/>PrefUtils.getMyValue(defaultValue);</span></pre><p id="9188" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">拥有一个用于访问<em class="jc"> SharedPreferences </em>的实用程序类也有它自己的问题。首先，当项目越来越大时，维护它就越来越困难。其次，由于您使用的是<em class="jc">上下文，</em>如果没有正确实现，就有导致内存泄漏的风险。我见过这个<em class="jc"> PrefUtils </em>类的许多不同实现。</p><p id="c781" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，当你想存储一些东西时，你会这样做:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c619" class="kq jf hh km b fi kr ks l kt ku">prefs.edit().putString("myKey", "newValue").apply();</span></pre><p id="38d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可能会意识到，我们在这里进行一连串的调用来存储数据。对于store操作，您必须首先使用<em class="jc"> edit() </em>方法(这将为您提供<em class="jc"> SharedPreferences。Editor </em> object)然后进行更改，最后使用<em class="jc"> apply()或commit() </em>方法。<a class="ae jd" href="http://developer.android.com/reference/android/content/SharedPreferences.Editor.html" rel="noopener ugc nofollow" target="_blank"> <em class="jc">共享优先。编辑器</em> </a>对象确保首选项值保持一致的状态。</p><p id="b58f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管有lint检查，但您可能会忘记在最后添加<em class="jc"> apply() </em>方法。而且你会花上几个小时去找出为什么你的数据没有保存下来。</p><h1 id="c611" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">U2020方式</h1><p id="d726" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">我非常喜欢这种方法，并开始在我的新项目中使用。它保护你不犯错误，使你的代码更干净。当你用匕首和<em class="jc">配合使用时，效果尤其好。</em></p><h2 id="68a6" class="kq jf hh bd jg kw kx ky jk kz la lb jo ip lc ld js it le lf jw ix lg lh ka li bi translated">优点是:</h2><ul class=""><li id="c91f" class="lj lk hh ig b ih kc il kd ip ll it lm ix ln jb lo lp lq lr bi translated">键和默认值在构造函数中给出。</li><li id="e1b9" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">不必将它们保存在单独的<em class="jc">常量</em>文件中，因为它们只被创建一次。</li><li id="a616" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">防止意外错误。</li><li id="9f8d" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">像<em class="jc"> set，get，isSet这样漂亮简单的方法。</em></li><li id="6ab1" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">存储<a class="ae jd" href="https://github.com/vngrs/PomoPomoAndroid/blob/develop/shared/src/main/java/com/vngrs/android/pomodoro/shared/data/prefs/EnumPreference.java" rel="noopener ugc nofollow" target="_blank"> <em class="jc">枚举</em> </a> <em class="jc"> </em>或更复杂的<a class="ae jd" href="https://github.com/vngrs/PomoPomoAndroid/blob/develop/shared/src/main/java/com/vngrs/android/pomodoro/shared/data/prefs/DateTimePreference.java" rel="noopener ugc nofollow" target="_blank">自定义数据。</a></li></ul><p id="cb66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是一个<em class="jc">字符串引用:</em>的代码</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5fb1" class="kq jf hh km b fi kr ks l kt ku">public class StringPreference {<br/>  private final SharedPreferences preferences;<br/>  private final String key;<br/>  private final String defaultValue;</span><span id="1d23" class="kq jf hh km b fi kv ks l kt ku">  ...</span><span id="f950" class="kq jf hh km b fi kv ks l kt ku">  public StringPreference(@NonNull SharedPreferences preferences, <br/>                          @NonNull String key, <br/>                          @Nullable String defaultValue) {<br/>    this.preferences = preferences;<br/>    this.key = key;<br/>    this.defaultValue = defaultValue;<br/>  }</span><span id="0864" class="kq jf hh km b fi kv ks l kt ku">  @Nullable<br/>  public String get() {<br/>    return preferences.getString(key, defaultValue);<br/>  }</span><span id="f120" class="kq jf hh km b fi kv ks l kt ku">  public boolean isSet() {<br/>    return preferences.contains(key);<br/>  }</span><span id="a47c" class="kq jf hh km b fi kv ks l kt ku">  public void set(@Nullable String value) {<br/>    preferences.edit().putString(key, value).apply();<br/>  }</span><span id="d79d" class="kq jf hh km b fi kv ks l kt ku">  public void delete() {<br/>    preferences.edit().remove(key).apply();<br/>  }<br/>}</span></pre><p id="0f4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后当你需要读/写你的数据时，你可以这样使用它:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5e38" class="kq jf hh km b fi kr ks l kt ku">StringPreference myPref = <br/>        new StringPreference(prefs, "myKey<em class="jc">", "defaultValue"</em>);</span><span id="a97d" class="kq jf hh km b fi kv ks l kt ku">String oldValue = mPref.get();<br/>mPref.set("newValue");</span></pre><p id="9837" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这样做的一个缺点是，您必须为每个想要持久化的值实例化这个对象。耐心点！匕首会来救你的。</p><h2 id="8e87" class="kq jf hh bd jg kw kx ky jk kz la lb jo ip lc ld js it le lf jw ix lg lh ka li bi translated">匕首2怎么用这些职业？</h2><p id="0bc9" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">在<em class="jc"> Dagger中，</em>你需要有模块来提供你要注入的对象。几乎所有的Android Dagger项目都有<em class="jc">应用模块</em>，在那里你提供<em class="jc">应用</em>特定对象。(例如<em class="jc"> Application，NotificationManager，GoogleApiClient </em>)你可以在<a class="ae jd" href="https://github.com/pomopomo/WearPomodoro/blob/develop/mobile/src/main/java/com/tasomaniac/android/pomodoro/AppModule.java" rel="noopener ugc nofollow" target="_blank">这里找到一个例子</a>。</p><p id="2c2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您的应用程序中可能也会有一个<a class="ae jd" href="https://github.com/pomopomo/WearPomodoro/blob/develop/shared/src/main/java/com/tasomaniac/android/pomodoro/shared/data/DataModule.java" rel="noopener ugc nofollow" target="_blank"> <em class="jc">数据模块</em> </a> <em class="jc"> </em>。所以最好在里面提供<em class="jc"> SharedPreferences </em>。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="95a8" class="kq jf hh km b fi kr ks l kt ku">@Module<br/>public final class DataModule {</span><span id="0724" class="kq jf hh km b fi kv ks l kt ku">  @Provides @Singleton<br/>  SharedPreferences provideSharedPreferences(Application app) {<br/>    return PreferenceManager.<em class="jc">getDefaultSharedPreferences</em>(app);<br/>  }<br/>  ...<br/>}</span></pre><p id="2643" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，我们把它变成了<em class="jc">单例。这样，<em class="jc">provideSharedPreferences</em>方法将只被调用一次。</em></p><p id="26da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">应用</em>对象<em class="jc">对象</em>由于在<em class="jc"> AppModule中提供，所以<em class="jc"> Dagger </em>会自动注入到这里。</em>还要注意，我们在这里使用<em class="jc">应用程序</em>作为<em class="jc">上下文</em>来防止内存泄漏问题。</p><p id="055e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们来看一个<em class="jc"> PrefsModule: </em></p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="a0ca" class="kq jf hh km b fi kr ks l kt ku">@Module(includes = DataModule.class)<br/>public class PrefsModule {<br/>  <br/>  ...</span><span id="14ed" class="kq jf hh km b fi kv ks l kt ku">  @Provides @Singleton<br/>  StringPreference provideMyValue(SharedPreferences prefs) {<br/>    return new StringPreference(prefs, "myKey<em class="jc">", "defaultValue"</em>);<br/>  }<br/>}</span></pre><p id="26bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以在这里提供我们所有的首选项，以便在整个应用程序中使用。在此模块中，只能一次提供关键字和默认值。</p><p id="6f85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，使用<em class="jc">注入</em>注释来访问它。当您这样做时，将只使用一个单例实例。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="6dc4" class="kq jf hh km b fi kr ks l kt ku">public class MainActivity extends Activity {<br/>  <br/>  @Inject StringPreference myPreference;</span><span id="3b50" class="kq jf hh km b fi kv ks l kt ku">  @Override<br/>  protected void onCreate(Bundle savedInstanceState) {<br/>    super.onCreate(savedInstanceState);</span><span id="1231" class="kq jf hh km b fi kv ks l kt ku">    String value = myPreference.get();</span><span id="e206" class="kq jf hh km b fi kv ks l kt ku">  }<br/>}</span></pre><p id="f970" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们已经为您想要持久化的每种数据类型创建了单独的类。然后我们有2个匕首模块。这看起来似乎有点多，但总体来说，我认为这是一种优雅且安全的使用<em class="jc"> SharedPreferences </em>的方式。</p><h1 id="b6e2" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">附录</h1><p id="e9d7" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">我的开源Wear Pomodoro应用程序中我使用了这种技术:<a class="ae jd" href="https://github.com/pomopomo/WearPomodoro/" rel="noopener ugc nofollow" target="_blank">https://github.com/pomopomo/WearPomodoro/</a></p><p id="2826" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">学习Dagger的优秀教程和视频:</p><ul class=""><li id="a8d5" class="lj lk hh ig b ih ii il im ip lx it ly ix lz jb lo lp lq lr bi translated">杰克·沃顿在Devoxx 和<a class="ae jd" href="https://speakerdeck.com/jakewharton/dependency-injection-with-dagger-2-devoxx-2014" rel="noopener ugc nofollow" target="_blank">滑梯甲板上的</a><a class="ae jd" href="https://www.parleys.com/tutorial/5471cdd1e4b065ebcfa1d557/" rel="noopener ugc nofollow" target="_blank">会议。</a></li><li id="c25b" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated"><a class="ae jd" href="https://www.youtube.com/watch?v=oK_XtfXPkqw" rel="noopener ugc nofollow" target="_blank">Gregory Kick的更多技术视频</a></li><li id="1ed1" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">【TutPlus的教程</li><li id="29a7" class="lj lk hh ig b ih ls il lt ip lu it lv ix lw jb lo lp lq lr bi translated">当然还有U2020应用程序，尽管它仍然使用Dagger 1。</li></ul></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="21a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关注我的<a class="ae jd" href="https://twitter.com/tasomaniac" rel="noopener ugc nofollow" target="_blank">@塔斯曼尼亚克</a>和<a class="ae jd" href="https://plus.google.com/+SaidTahsinDane/posts" rel="noopener ugc nofollow" target="_blank"> +SaidTahsinDane </a></p></div></div>    
</body>
</html>