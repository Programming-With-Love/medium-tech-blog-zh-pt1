<html>
<head>
<title>Android Data Binding: RecyclerView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android数据绑定:RecyclerView</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-data-binding-recyclerview-db7c40d9f0e4?source=collection_archive---------0-----------------------#2017-01-10">https://medium.com/androiddevelopers/android-data-binding-recyclerview-db7c40d9f0e4?source=collection_archive---------0-----------------------#2017-01-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/31053cad63abae52b91e1179b0b20af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NShiWWuJvGcsbywB-O7-Ng.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="f132" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">减少、重用、重新绑定</h2></div><p id="b8ad" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">虽然有时我喜欢这么想，但作为一个术语，<em class="kd">数据绑定</em>并不总是指Android数据绑定。RecyclerView有自己将数据绑定到UI的方式。RecyclerView有一个<a class="ae ke" href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter.html" rel="noopener ugc nofollow" target="_blank">适配器</a>，它有两个非常重要的方法，我们实现这两个方法来绑定数据:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="1ac1" class="ko kp hs kk b fi kq kr l ks kt">RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent,<br/>                                           <strong class="kk ht">int </strong>viewType);<br/><br/><strong class="kk ht">void </strong>onBindViewHolder(RecyclerView.ViewHolder holder, <strong class="kk ht">int </strong>position);</span></pre><p id="0515" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">RecyclerView在其API中将常见的<a class="ae ke" href="https://developer.android.com/training/improving-layouts/smooth-scrolling.html" rel="noopener ugc nofollow" target="_blank">视图持有者模式</a>作为一等公民公开。在onCreateViewHolder()中，视图被创建，视图持有者包含对它们的引用，以便可以快速设置数据。然后在onBindView()中，将特定的数据分配给视图。</p><h2 id="9220" class="ko kp hs bd ku kv kw kx ky kz la lb lc jq ld le lf ju lg lh li jy lj lk ll lm bi translated">RecyclerView中的Android数据绑定</h2><p id="a168" class="pw-post-body-paragraph jh ji hs jj b jk ln it jm jn lo iw jp jq lp js jt ju lq jw jx jy lr ka kb kc ha bi translated"><a class="ae ke" rel="noopener" href="/google-developers/android-data-binding-adding-some-variability-1fe001b3abcc#.1o06zcbx5">正如上一篇文章</a>中所讨论的，Android数据绑定可以像视图持有者模式一样对待。理想情况下，我们只需从onCreateViewHolder()返回生成的绑定类，但它不扩展recycle view . ViewHolder。因此，绑定类将必须由view holder包含在<em class="kd">中。</em></p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="481b" class="ko kp hs kk b fi kq kr l ks kt"><strong class="kk ht">public class </strong>MyViewHolder <strong class="kk ht">extends </strong>RecyclerView.ViewHolder {<br/>    <strong class="kk ht">private final </strong>ItemBinding <strong class="kk ht">binding</strong>;<br/><br/>    <strong class="kk ht">public </strong>MyViewHolder(ItemBinding binding) {<br/>        <strong class="kk ht">super</strong>(binding.getRoot());<br/>        <strong class="kk ht">this</strong>.<strong class="kk ht">binding </strong>= binding;<br/>    }<br/><br/>    <strong class="kk ht">public void </strong>bind(Item item) {<br/>        <strong class="kk ht">binding</strong>.setItem(item);<br/>        <strong class="kk ht">binding</strong>.executePendingBindings();<br/>    }<br/>}</span></pre><p id="6cb3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，我的适配器可以使用Android数据绑定来创建和绑定:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="03b5" class="ko kp hs kk b fi kq kr l ks kt"><strong class="kk ht">public </strong>MyViewHolder onCreateViewHolder(ViewGroup parent,<br/>                                       <strong class="kk ht">int </strong>viewType) {<br/>    LayoutInflater layoutInflater =<br/>        LayoutInflater.<em class="kd">from</em>(parent.getContext());<br/>    ItemBinding itemBinding = <br/>        ItemBinding.<em class="kd">inflate</em>(layoutInflater, parent, <strong class="kk ht">false</strong>);<br/>    <strong class="kk ht">return new </strong>MyViewHolder(itemBinding);<br/>}<br/><br/><strong class="kk ht">public void </strong>onBindViewHolder(MyViewHolder holder, <strong class="kk ht">int </strong>position) {<br/>    Item item = getItemForPosition(position);<br/>    holder.bind(item);<br/>}</span></pre><p id="7ea9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果您仔细观察，您会在MyViewHolder.bind()的末尾看到executePendingBindings()。这将强制绑定立即运行，而不是延迟到下一帧。RecyclerView将在onBindViewHolder之后立即测量视图。如果视图中有错误的数据，因为绑定一直等到下一帧，那么它将被不正确地测量。executePendingBindings()很重要！</p><h2 id="c856" class="ko kp hs bd ku kv kw kx ky kz la lb lc jq ld le lf ju lg lh li jy lj lk ll lm bi translated">重用视图保持器</h2><p id="afed" class="pw-post-body-paragraph jh ji hs jj b jk ln it jm jn lo iw jp jq lp js jt ju lq jw jx jy lr ka kb kc ha bi translated">如果您以前曾经使用过RecyclerView的ViewHolder，您可以看到我们保存了一些样板代码，其中的数据被设置到视图中。不幸的是，我们仍然必须为不同的RecyclerViews编写一堆ViewHolders。如果有多种视图类型，如何扩展也不清楚。我们可以解决这些问题。</p><p id="1582" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">通常只将一个数据对象传递给一个数据绑定类，就像上面的<em class="kd"> item </em>一样。当您拥有这种模式时，可以使用命名约定为所有RecyclerViews和所有视图类型创建一个视图容器。我们将使用的约定是将单视图模型对象命名为“obj”您可能更喜欢“item”或“data”，但是如果我使用“obj”，在示例中会更容易识别。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="343b" class="ko kp hs kk b fi kq kr l ks kt"><strong class="kk ht">public class </strong>MyViewHolder <strong class="kk ht">extends </strong>RecyclerView.ViewHolder {<br/>    <strong class="kk ht">private final </strong>ViewDataBinding <strong class="kk ht">binding</strong>;<br/><br/>    <strong class="kk ht">public </strong>MyViewHolder(ViewDataBinding binding) {<br/>        <strong class="kk ht">super</strong>(binding.getRoot());<br/>        <strong class="kk ht">this</strong>.<strong class="kk ht">binding </strong>= binding;<br/>    }<br/><br/>    <strong class="kk ht">public void </strong>bind(Object obj) {<br/>        <strong class="kk ht">binding</strong>.setVariable(BR.<strong class="kk ht"><em class="kd">obj</em></strong>, obj);<br/>        <strong class="kk ht">binding</strong>.executePendingBindings();<br/>    }<br/>}</span></pre><p id="d86f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在MyViewHolder中，我使用的是ViewDataBinding，它是所有生成的绑定的基类，而不是特定的ItemBinding。这样，我就可以在我的视图容器中支持任何布局。我还使用setVariable()而不是类型安全但特定于类的setObj()方法，这样我就可以分配我需要的任何视图模型对象类型。重要的部分是变量必须命名为“obj ”,因为我在setVariable()中使用BR.obj作为键。这意味着您的布局文件中必须有一个变量标记，如下所示:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="e4e6" class="ko kp hs kk b fi kq kr l ks kt">&lt;<strong class="kk ht">variable name="obj" type="Item"</strong>/&gt;</span></pre><p id="e3c6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当然，您的变量将具有数据绑定布局所需的任何类型，而不是“Item”</p><p id="d9f6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然后，我可以创建一个可用于我的所有RecyclerView适配器的基类。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="6620" class="ko kp hs kk b fi kq kr l ks kt"><strong class="kk ht">public abstract class </strong>MyBaseAdapter<br/>                <strong class="kk ht">extends </strong>RecyclerView.Adapter&lt;MyViewHolder&gt; {<br/>    <strong class="kk ht">public </strong>MyViewHolder onCreateViewHolder(ViewGroup parent,<br/>                                           <strong class="kk ht">int </strong>viewType) {<br/>        LayoutInflater layoutInflater =<br/>                LayoutInflater.<em class="kd">from</em>(parent.getContext());<br/>        ViewDataBinding binding = DataBindingUtil.<em class="kd">inflate</em>(<br/>                layoutInflater, viewType, parent, <strong class="kk ht">false</strong>);<br/>        <strong class="kk ht">return new </strong>MyViewHolder(binding);<br/>    }<br/><br/>    <strong class="kk ht">public void </strong>onBindViewHolder(MyViewHolder holder,<br/>                                 <strong class="kk ht">int </strong>position) {<br/>        Object obj = getObjForPosition(position);<br/>        holder.bind(obj);<br/>    }</span><span id="43e3" class="ko kp hs kk b fi ls kr l ks kt">    @Override<br/>    <strong class="kk ht">public int </strong>getItemViewType(<strong class="kk ht">int </strong>position) {<br/>        <strong class="kk ht">return </strong>getLayoutIdForPosition(position);<br/>    }<br/><br/>    <strong class="kk ht">protected abstract </strong>Object getObjForPosition(<strong class="kk ht">int </strong>position);<br/><br/>    <strong class="kk ht">protected abstract int </strong>getLayoutIdForPosition(<strong class="kk ht">int </strong>position);<br/>}</span></pre><p id="2e89" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这个适配器中，布局ID被用作视图类型，以便更容易展开正确的绑定。这使适配器可以处理任意数量的布局，但最常见的用法是使用单个布局的RecyclerView，因此我们可以为此创建一个基类:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="30f5" class="ko kp hs kk b fi kq kr l ks kt"><strong class="kk ht">public abstract class </strong>SingleLayoutAdapter <strong class="kk ht">extends </strong>MyBaseAdapter {<br/>    <strong class="kk ht">private final int layoutId</strong>;<br/>    <br/>    <strong class="kk ht">public </strong>SingleLayoutAdapter(<strong class="kk ht">int </strong>layoutId) {<br/>        <strong class="kk ht">this</strong>.<strong class="kk ht">layoutId </strong>= layoutId;<br/>    }<br/>    <br/>    @Override<br/>    <strong class="kk ht">protected int </strong>getLayoutIdForPosition(<strong class="kk ht">int </strong>position) {<br/>        <strong class="kk ht">return layoutId</strong>;<br/>    }<br/>}</span></pre><h2 id="0727" class="ko kp hs bd ku kv kw kx ky kz la lb lc jq ld le lf ju lg lh li jy lj lk ll lm bi translated">还剩下什么？</h2><p id="c880" class="pw-post-body-paragraph jh ji hs jj b jk ln it jm jn lo iw jp jq lp js jt ju lq jw jx jy lr ka kb kc ha bi translated">来自RecyclerView的所有样板文件现在都已处理完毕，剩下要做的就是最难的部分:从UI线程中加载数据，当数据发生变化时通知适配器，等等。Android数据绑定只是减少了枯燥的部分。</p><p id="39b9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您还可以扩展这种技术来支持多个变量。通常提供一个事件处理程序对象来处理像点击事件这样的事情，您可能希望将其与视图模型类一起传递。如果您总是传入活动或片段，您可以添加这些变量。只要使用一致的命名，就可以对所有的RecyclerViews使用这种技术。</p><p id="06a9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">将Android数据绑定与RecyclerViews结合使用非常简单，并且显著减少了样板代码。也许你的应用程序只需要一个视图持有者，你就再也不需要编写onCreateViewHolder()或onBindViewHolder()了！</p></div></div>    
</body>
</html>