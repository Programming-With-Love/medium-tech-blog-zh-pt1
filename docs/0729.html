<html>
<head>
<title>Jetpack Compose Stability Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">喷气背包撰写稳定性解释</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/jetpack-compose-stability-explained-79c10db270c8?source=collection_archive---------1-----------------------#2022-06-30">https://medium.com/androiddevelopers/jetpack-compose-stability-explained-79c10db270c8?source=collection_archive---------1-----------------------#2022-06-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/94132dbcc2bc40218db5410f6ad88580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLEtRB3BpIkD6CgjWFP2RQ.png"/></div></div></figure><div class=""/><p id="ee2e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你有没有测量过你的可组合程序的性能，发现它重新组合的代码比你预期的要多？我以为Compose的意思是当状态没有改变时智能地跳过可组合文件？“你可能会问。或者在阅读Compose代码时，您可能会看到用<code class="du jo jp jq jr b"><a class="ae js" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/Stable" rel="noopener ugc nofollow" target="_blank">@Stable</a></code>或<code class="du jo jp jq jr b"><a class="ae js" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/Immutable" rel="noopener ugc nofollow" target="_blank">@Immutable</a></code>标注的类，并想知道这些是什么意思？这些概念可以用组合稳定性来解释。在这篇博文中，我们将看看Compose stability实际上意味着什么，如何调试它，以及你是否应该担心它。</p><h1 id="65d4" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">TL/DR</h1><p id="85a7" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">这是一个大帖子！这是TL/DR。</p><ul class=""><li id="be30" class="kw kx hs ir b is it iw ix ja ky je kz ji la jm lb lc ld le bi translated">Compose决定了你的组件的每个参数的稳定性，以确定在重组过程中是否可以跳过它。</li><li id="3999" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">如果您注意到您的可组合组件没有被跳过<strong class="ir ht">并且导致了性能问题</strong>，您应该首先检查不稳定的明显原因，比如<code class="du jo jp jq jr b">var</code>参数。</li><li id="2eee" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">您可以使用<a class="ae js" href="https://github.com/androidx/androidx/blob/androidx-main/compose/compiler/design/compiler-metrics.md" rel="noopener ugc nofollow" target="_blank">编译器报告</a>来确定您的类的稳定性。</li><li id="a9f1" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">像<code class="du jo jp jq jr b">List</code>、<code class="du jo jp jq jr b">Set</code>和<code class="du jo jp jq jr b">Map</code>这样的集合类总是被确定为不稳定的，因为不能保证它们是不可变的。您可以使用<a class="ae js" href="https://github.com/Kotlin/kotlinx.collections.immutable" rel="noopener ugc nofollow" target="_blank"> Kotlinx不可变集合</a>来代替，或者将您的类注释为<code class="du jo jp jq jr b">@Immutable</code>或<code class="du jo jp jq jr b">@Stable</code>。</li><li id="3e3f" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">来自没有运行Compose编译器的模块的类总是被确定为不稳定的。在compose runtime上添加一个依赖项，并在您的模块中将它们标记为稳定的，或者如果需要，将这些类包装在UI模型类中。</li><li id="cedc" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">每个可组合的都应该是可跳过的吗？号码</li></ul><h1 id="5d72" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是重组？</h1><p id="7617" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">在我们讨论稳定性之前，让我们快速回顾一下重组的定义:</p><blockquote class="lk"><p id="1631" class="ll lm hs bd ln lo lp lq lr ls lt jm dx translated">"<em class="lu">重组是在输入改变时再次调用可组合函数的过程。当函数的输入改变时，就会发生这种情况。当Compose基于新的输入重新组合时，它只调用</em> <strong class="ak"> <em class="lu">可能</em> </strong> <em class="lu">已经改变的函数或lambdas，而跳过其余的。通过跳过所有没有改变参数的函数或lambdas，Compose可以高效地重新组合。</em></p></blockquote><p id="8e23" class="pw-post-body-paragraph ip iq hs ir b is lv iu iv iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ha bi translated">注意这里的关键字——“可能是”。当快照状态改变时，Compose将触发重组，并跳过任何未改变的组件。重要的是，只有当Compose可以<strong class="ir ht"> <em class="jn">确定</em> </strong>没有一个可组合的参数被更新时，一个可组合的才会被跳过。否则，如果Compose <strong class="ir ht">和<em class="jn">不能确定，那么</em>和</strong>将会在它的父Compose被重组时<strong class="ir ht">总是</strong>被重组。如果Compose不这样做，将导致很难诊断重组不触发的错误。正确且性能稍差比不正确但速度稍快要好得多。</p><p id="46c0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们用一个显示联系信息的<code class="du jo jp jq jr b">Row</code>的例子:</p><figure class="ma mb mc md fd hj"><div class="bz dy l di"><div class="me mf l"/></div></figure><h1 id="ee3a" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用不可变对象</h1><p id="8786" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">首先，假设我们将<code class="du jo jp jq jr b">Contact</code>类定义为一个不可变的数据类，因此如果不创建一个新对象，它就不能被更改:</p><pre class="ma mb mc md fd mg jr mh mi aw mj bi"><span id="40cc" class="mk ju hs jr b fi ml mm l mn mo">data class Contact(val name: String, val number: String)</span></pre><p id="753b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当点击切换按钮时，我们改变选择的状态。这将触发Compose来评估<code class="du jo jp jq jr b">ContactRow</code>中的代码是否应该重新编写。当涉及到<code class="du jo jp jq jr b">ContactDetails</code> composable时，Compose将跳过对它的重新编写。这是因为它可以看到没有一个参数，在这个例子中是<code class="du jo jp jq jr b">contact</code>，发生了变化。<code class="du jo jp jq jr b">ToggleButton</code>另一方面，输入已经改变，因此它被正确地重组。</p><h1 id="1760" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用可变对象</h1><p id="fd0a" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">如果我们的联系类是这样定义的呢？</p><pre class="ma mb mc md fd mg jr mh mi aw mj bi"><span id="33da" class="mk ju hs jr b fi ml mm l mn mo">data class Contact(<strong class="jr ht">var</strong> name: String, <strong class="jr ht">var</strong> number: String)</span></pre><p id="cc41" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们的<code class="du jo jp jq jr b">Contact</code>类不再是不可变的，它的属性可以在Compose不知道的情况下被改变。Compose将不再跳过<code class="du jo jp jq jr b">ContactDetails</code> composable，因为这个类现在被认为是“不稳定的”(更多细节在下面)。因此，每当<code class="du jo jp jq jr b">selected</code>改变时，<code class="du jo jp jq jr b">ContactRow</code>也会重新组合。</p><h1 id="f818" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">在Compose编译器中实现</h1><p id="1c7e" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">现在我们知道了Compose试图确定的理论，让我们看看它在实践中是如何发生的。</p><p id="3571" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，来自Compose文档的一些定义(<a class="ae js" href="https://github.com/androidx/androidx/blob/androidx-main/compose/compiler/design/compiler-metrics.md#functions-that-are-restartable-but-not-skippable" rel="noopener ugc nofollow" target="_blank"> 1 </a>、<a class="ae js" href="https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md#stable-types" rel="noopener ugc nofollow" target="_blank"> 2 </a>)。</p><p id="6d75" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">功能可以是可跳过的和/或可重启的:</p><blockquote class="mp mq mr"><p id="3939" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated"><strong class="ir ht"> Skippable </strong> —在重新组合期间调用时，如果所有参数都等于它们以前的值，compose能够跳过该函数。</p><p id="2763" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated"><strong class="ir ht">可重新启动的</strong> —这个函数作为一个“作用域”,在这里可以开始重新组合(换句话说，这个函数可以作为一个入口点，Compose可以在这里开始重新执行代码，以便在状态改变后重新组合)。</p></blockquote><p id="22fa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">类型可以是不可变的或稳定的:</p><blockquote class="mp mq mr"><p id="d7b4" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated"><strong class="ir ht">不可变</strong> —表示一种类型，其中任何属性的值在对象被构造后都不会改变，并且所有方法都是引用透明的。所有的原始类型(<code class="du jo jp jq jr b">String</code>、<code class="du jo jp jq jr b">Int</code>、<code class="du jo jp jq jr b">Float</code>等)都被认为是不可变的。</p><p id="ac23" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated"><strong class="ir ht">稳定</strong> —表示可变的类型，但是当任何公共属性或方法行为产生与先前调用不同的结果时，将通知合成运行时。</p></blockquote><p id="d5f6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当Compose编译器在您的代码上运行时，它会查看每个函数和类型，并标记任何匹配这些定义的函数和类型。Compose查看传递给composable的类型，以确定该composable的可跳过性。值得注意的是，参数不必是不可变的，只要Compose运行时被告知所有的更改，它们就可以是可变的。对于大多数类型来说，这是一个不切实际的契约，但是Compose提供了支持这个契约的可变类，比如<code class="du jo jp jq jr b"><a class="ae js" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState" rel="noopener ugc nofollow" target="_blank">MutableState</a></code>、<code class="du jo jp jq jr b"><a class="ae js" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/snapshots/SnapshotStateMap" rel="noopener ugc nofollow" target="_blank">SnapshotStateMap</a></code>/<code class="du jo jp jq jr b"><a class="ae js" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/" rel="noopener ugc nofollow" target="_blank">List</a></code>/等等。因此，为您的可变属性使用这些类型将允许您的类支持<code class="du jo jp jq jr b">@Stable</code>的契约。实际上，这看起来会像下面这样</p><figure class="ma mb mc md fd hj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="e629" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当组合状态改变时，组合在树中读取这些状态对象的所有点上方寻找最近的可重启函数。理想情况下，这将是重新运行最小可能代码的直接祖先。重组在这里重新开始。当重新执行代码时，如果参数没有改变，任何可跳过的函数都将被跳过。让我们再来看一下前面的例子</p><figure class="ma mb mc md fd hj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="f7ab" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，当<code class="du jo jp jq jr b">selected</code>改变时，离实际读取状态最近的“可重启”功能/组合范围是<code class="du jo jp jq jr b">ContactRow</code>。您可能想知道为什么<code class="du jo jp jq jr b">Row</code>没有被选为最近的可重启scope？<code class="du jo jp jq jr b">Row</code>(以及许多其他基础组件，如<code class="du jo jp jq jr b">Column</code>和<code class="du jo jp jq jr b">Box</code>)实际上是一个<a class="ae js" href="https://kotlinlang.org/docs/inline-functions.html" rel="noopener ugc nofollow" target="_blank">内联函数</a>，<strong class="ir ht">内联函数不是可重启的作用域</strong>，因为它们在编译后实际上并不是最终的函数。所以<code class="du jo jp jq jr b">ContactRow</code>是下一个最高的作用域，因此<code class="du jo jp jq jr b">ContactRow</code>重新执行。它看到的第一个可组合对象是<code class="du jo jp jq jr b">Row</code>，正如已经详述的，这不是一个可重启的作用域，这也意味着它是不可跳过的，并且总是在重组时重新执行。下一个可组合的是<code class="du jo jp jq jr b">ContactDetails</code>，<code class="du jo jp jq jr b">ContactDetails</code>已经被标记为skippable，因为<code class="du jo jp jq jr b">Contact</code>类已经被推断为不可变的，所以由Compose编译器添加的生成代码检查是否有任何可组合的参数已经改变。由于<code class="du jo jp jq jr b">contact</code>保持不变，跳过<code class="du jo jp jq jr b">ContactDetails</code>。接下来，<code class="du jo jp jq jr b">ToggleButton</code>。<code class="du jo jp jq jr b">ToggleButton</code>是可跳过的，但在这种情况下没关系，它的一个参数<code class="du jo jp jq jr b">selected</code>已经改变，因此它被重新执行。这就把我们带到了可重启函数/作用域的末尾，重组也结束了。</p><figure class="ma mb mc md fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mv"><img src="../Images/bcc9f242cb08237192ecc8da34ebace8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UtnzUYqd1jpNcTWq"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx">The steps of recomposition.</figcaption></figure><p id="3d3e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此时您可能会想，“这真的很复杂！为什么我需要知道这些？!"答案是，大多数时候你不应该这么做。我们的目标是让编译器优化您自然编写的代码，以提高效率。跳过可组合函数是实现这一点的一个重要因素，但它也需要100%安全，否则会导致很难诊断错误。由于这个原因，对于要被跳过的函数的要求是强烈的。我们正在努力改进编译器对可跳过性的推断，但总会有编译器无法解决的情况。了解在这种情况下跳过函数是如何工作的可以帮助您提高性能，但是只有在稳定性导致性能问题的情况下才应该考虑这样做。如果可组合组件是轻量级的，或者它本身只包含可跳过的可组合组件，那么不可跳过的可组合组件可能没有任何效果。</p><h1 id="ac83" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">调试稳定性</h1><p id="8662" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">你如何知道你的组件是否被忽略了？你可以在<a class="ae js" href="https://developer.android.com/jetpack/compose/tooling#layout-inspector" rel="noopener ugc nofollow" target="_blank">布局检查器</a>里看到！Android Studio Dolphin在布局检查器中包含了对Compose的支持，它还会显示你的composables被重组和跳过的次数。</p><figure class="ma mb mc md fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es na"><img src="../Images/1de40c282c933ed336c34b0968409053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aaAe6osG_tpVsfH9"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx">Recomposition counts in the Layout Inspector.</figcaption></figure><p id="cc94" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么，如果您看到您的可组合组件没有被跳过，即使它的参数都没有改变，您会怎么做呢？最简单的方法是检查它的定义，看看它的参数中是否有明显可变的。你传入的是一个带有<code class="du jo jp jq jr b">var</code>属性的类型还是一个带有已知不稳定类型的<code class="du jo jp jq jr b">val</code>属性的类型？如果你是，那么这个组合将永远不会被跳过！</p><p id="1518" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是当你找不到任何明显的错误时，你会怎么做呢？</p><h1 id="ea07" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">撰写编译器报告</h1><p id="5bf2" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">compose编译器可以输出其稳定性推断的结果以供检查。使用这个输出，您可以确定哪些组件是可跳过的，哪些是不可跳过的。这篇文章总结了如何使用这些报告，但是关于这些报告的详细信息，请参见<a class="ae js" href="https://github.com/androidx/androidx/blob/androidx-main/compose/compiler/design/compiler-metrics.md" rel="noopener ugc nofollow" target="_blank">技术文档</a>。</p><blockquote class="mp mq mr"><p id="e6c6" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated"><strong class="ir ht"> ⚠️警告:</strong>只有当您确实遇到与稳定性相关的性能问题时，才应该使用这种技术。试图让你的整个UI可以跳过是不成熟的优化，可能会导致将来的维护困难。在优化稳定性之前，请确保您遵循我们的<a class="ae js" href="http://goo.gle/compose-performance" rel="noopener ugc nofollow" target="_blank">最佳作曲性能实践</a>。</p></blockquote><p id="39b1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">缺省情况下，编译器编译器报告是不启用的。它们通过一个编译器标志启用，<a class="ae js" href="https://github.com/androidx/androidx/blob/androidx-main/compose/compiler/design/compiler-metrics.md#enabling-metrics" rel="noopener ugc nofollow" target="_blank">确切的设置</a>根据你的项目不同而不同，但是对于大多数项目，你可以将下面的脚本粘贴到你的根<code class="du jo jp jq jr b">build.gradle</code>文件中。</p><figure class="ma mb mc md fd hj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="193c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">(这些gradle助手的灵感来自于<a class="ae js" href="http://twitter.com/chrisbanes" rel="noopener ugc nofollow" target="_blank"> Chris Banes </a>和他在<a class="ae js" href="https://chris.banes.dev/composable-metrics/" rel="noopener ugc nofollow" target="_blank"> Composable metrics </a>上的精彩帖子)</p><p id="1101" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要调试组件的稳定性，可以按如下方式运行任务:</p><pre class="ma mb mc md fd mg jr mh mi aw mj bi"><span id="840e" class="mk ju hs jr b fi ml mm l mn mo">./gradlew assembleRelease -PcomposeCompilerReports=true</span></pre><blockquote class="mp mq mr"><p id="d43f" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated">⚠️ <strong class="ir ht">警告:</strong> <strong class="ir ht">确保总是在发布版本上运行它，以确保结果准确。</strong></p></blockquote><p id="d668" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此任务将输出三个文件。(包括来自<a class="ae js" href="https://github.com/android/compose-samples/tree/master/Jetsnack" rel="noopener ugc nofollow" target="_blank"> Jetsnack </a>的示例输出)</p><p id="e33a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">&lt;modulename&gt;-classes . txt—</strong>该模块中类的稳定性报告。<a class="ae js" href="https://gist.github.com/bentrengrove/9b823045a160d8a5d986bb4b31106245" rel="noopener ugc nofollow" target="_blank">样品</a>。</p><p id="4762" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">&lt;modulename&gt;-composables . txt</strong>—关于该模块中组件的可重启性和可跳过性的报告。<a class="ae js" href="https://gist.github.com/bentrengrove/a8ee3716a7df136144041134575f5fcb" rel="noopener ugc nofollow" target="_blank">样</a>。</p><p id="9c50" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">&lt;modulename&gt;-composables . csv</strong>—上述文本文件的CSV版本，用于导入电子表格或通过脚本进行处理。<a class="ae js" href="https://gist.github.com/bentrengrove/2beb1b2993f68f61a7ba3ed91a1c75c9" rel="noopener ugc nofollow" target="_blank">样品</a>。</p><p id="9705" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您转而运行<code class="du jo jp jq jr b">composeCompilerMetrics</code>任务，您将获得项目中可组装组件数量的总体统计数据以及其他类似信息。这不在本文讨论范围之内，因为它对调试没什么用。</p><p id="66d3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">打开<code class="du jo jp jq jr b">composables.txt</code>文件，你会看到该模块的所有可组合函数，每个函数都标有是否可重启、可跳过以及参数的稳定性。这里有一个来自<a class="ae js" href="https://github.com/android/compose-samples/tree/master/Jetsnack" rel="noopener ugc nofollow" target="_blank"> Jetsnack </a>的假想例子，这是一个编写示例应用程序。</p><pre class="ma mb mc md fd mg jr mh mi aw mj bi"><span id="62a4" class="mk ju hs jr b fi ml mm l mn mo">restartable skippable scheme(“[androidx.compose.ui.UiComposable]”) fun SnackCollection(</span><span id="0ae8" class="mk ju hs jr b fi nb mm l mn mo">   stable snackCollection: SnackCollection</span><span id="f25e" class="mk ju hs jr b fi nb mm l mn mo">   stable onSnackClick: Function1&lt;Long, Unit&gt;</span><span id="5707" class="mk ju hs jr b fi nb mm l mn mo">   stable modifier: Modifier? = @static Companion</span><span id="5156" class="mk ju hs jr b fi nb mm l mn mo">   stable index: Int = @static 0</span><span id="ef00" class="mk ju hs jr b fi nb mm l mn mo">   stable highlight: Boolean = @static true</span><span id="d782" class="mk ju hs jr b fi nb mm l mn mo">)</span></pre><p id="3cf7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个<code class="du jo jp jq jr b">SnackCollection</code>组件是完全可重启的、可跳过的和稳定的。如果可能的话，这通常是你想要的，尽管远不是强制性的(更多细节在文章末尾)。</p><p id="c0e5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，让我们看看另一个例子。</p><pre class="ma mb mc md fd mg jr mh mi aw mj bi"><span id="6e32" class="mk ju hs jr b fi ml mm l mn mo">restartable scheme(“[androidx.compose.ui.UiComposable]”) fun HighlightedSnacks(</span><span id="778d" class="mk ju hs jr b fi nb mm l mn mo">   stable index: Int</span><span id="0b72" class="mk ju hs jr b fi nb mm l mn mo">   <strong class="jr ht">unstable</strong> snacks: List&lt;Snack&gt;</span><span id="6203" class="mk ju hs jr b fi nb mm l mn mo">   stable onSnackClick: Function1&lt;Long, Unit&gt;</span><span id="7981" class="mk ju hs jr b fi nb mm l mn mo">   stable modifier: Modifier? = @static Companion</span><span id="9f88" class="mk ju hs jr b fi nb mm l mn mo">)</span></pre><p id="b43b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">HighlightedSnacks</code> composable是不可跳过的——在重组过程中任何时候调用它，它也会重组，即使它的参数都没有改变。</p><p id="ce9e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是由不稳定参数<code class="du jo jp jq jr b">snacks</code>造成的。</p><p id="a358" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们可以切换到<code class="du jo jp jq jr b"><em class="jn">classes.txt</em></code>文件来检查<code class="du jo jp jq jr b">Snack</code>的稳定性。</p><pre class="ma mb mc md fd mg jr mh mi aw mj bi"><span id="1bc5" class="mk ju hs jr b fi ml mm l mn mo">unstable class Snack {</span><span id="b84c" class="mk ju hs jr b fi nb mm l mn mo">   stable val id: Long</span><span id="910a" class="mk ju hs jr b fi nb mm l mn mo">   stable val name: String</span><span id="832f" class="mk ju hs jr b fi nb mm l mn mo">   stable val imageUrl: String</span><span id="1f64" class="mk ju hs jr b fi nb mm l mn mo">   stable val price: Long</span><span id="5c76" class="mk ju hs jr b fi nb mm l mn mo">   stable val tagline: String</span><span id="45d5" class="mk ju hs jr b fi nb mm l mn mo">   <strong class="jr ht">unstable</strong> val tags: Set&lt;String&gt;</span><span id="f4ea" class="mk ju hs jr b fi nb mm l mn mo">   &lt;runtime stability&gt; = Unstable</span><span id="7c43" class="mk ju hs jr b fi nb mm l mn mo">}</span></pre><p id="9b4c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为参考，这是<code class="du jo jp jq jr b">Snack</code>的声明方式</p><figure class="ma mb mc md fd hj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="8ffa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">零食不稳定。它具有最稳定的参数，但是标签集被认为是不稳定的。但这是为什么呢？<code class="du jo jp jq jr b">Set</code>看似不可改变，其实不是<code class="du jo jp jq jr b">MutableSet</code>。</p><p id="6338" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不幸的是，<code class="du jo jp jq jr b">Set</code>(以及<code class="du jo jp jq jr b">List</code>和其他标准集合类，稍后将详细介绍)在Kotlin中被定义为接口，这意味着底层实现仍然是可变的。例如，你可以写</p><pre class="ma mb mc md fd mg jr mh mi aw mj bi"><span id="1218" class="mk ju hs jr b fi ml mm l mn mo">val set: Set&lt;String&gt; = mutableSetOf(“foo”)</span></pre><p id="9237" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">变量是常量，它声明的类型不是可变的，但是它的实现仍然是<em class="jn">可变的。Compose编译器不能确定这个类的不变性，因为它只看到声明的类型，因此声明它是不稳定的。现在让我们来看看如何使它稳定。</em></p><h1 id="c1a6" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">稳定不稳定因素</h1><p id="e346" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">当面对一个导致性能问题的不稳定的类时，尝试使它稳定是一个好主意。首先要做的就是让这个类完全不可变。</p><blockquote class="mp mq mr"><p id="7c49" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated"><strong class="ir ht">不可变</strong> —表示一种类型，其中任何属性的值在对象被构造后都不会改变，并且所有方法都是引用透明的。所有的原始类型(<code class="du jo jp jq jr b">String</code>、<code class="du jo jp jq jr b">Int</code>、<code class="du jo jp jq jr b">Float</code>等)都被认为是不可变的。</p></blockquote><p id="7134" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">换句话说，使所有的<code class="du jo jp jq jr b">var</code>属性<code class="du jo jp jq jr b">val</code>，以及所有那些属性成为不可变类型。</p><p id="362f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果这是不可能的，那么您将不得不对任何可变属性使用Compose state。</p><blockquote class="mp mq mr"><p id="0398" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated"><strong class="ir ht">稳定的</strong> —表示可变的类型，但是如果并且当任何公共属性或方法行为将产生与先前调用不同的结果时，将通知合成运行时。</p></blockquote><p id="da42" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这意味着在实践中，任何可变属性都应该由组合状态支持，例如<code class="du jo jp jq jr b">mutableStateOf(…)</code>。</p><p id="8492" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">回到<code class="du jo jp jq jr b">Snack</code>的例子，这个类看起来是不可变的，那么我们如何修复它呢？</p><p id="56b6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以有多种选择。</p><h1 id="0d11" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Kotlinx不可变集合</h1><p id="c3fe" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">Compose编译器1.2版支持<a class="ae js" href="https://github.com/Kotlin/kotlinx.collections.immutable" rel="noopener ugc nofollow" target="_blank"> Kotlinx不可变集合</a>。这些集合保证是不可变的，并且将由编译器推断出来。这个库仍然处于alpha阶段，所以预计它的API可能会有变化。您应该评估这对于您的项目是否可以接受。</p><p id="5e29" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将<code class="du jo jp jq jr b">tags</code>声明转换为下面的声明使得<code class="du jo jp jq jr b">Snack</code>类变得稳定。</p><pre class="ma mb mc md fd mg jr mh mi aw mj bi"><span id="3a50" class="mk ju hs jr b fi ml mm l mn mo">val tags: ImmutableSet&lt;String&gt; = persistentSetOf()</span></pre><h1 id="2aba" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">用稳定或不可变进行注释</h1><p id="577d" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">基于上面的规则，类也可以用<code class="du jo jp jq jr b">@Stable</code>或<code class="du jo jp jq jr b">@Immutable</code>来注释。</p><blockquote class="mp mq mr"><p id="734f" class="ip iq jn ir b is it iu iv iw ix iy iz ms jb jc jd mt jf jg jh mu jj jk jl jm ha bi translated"><strong class="ir ht"> ⚠️警告:需要注意的是，这是一份遵循相应规则的合同注释。它不会让一个类自己成为不可变的/稳定的。错误地注释类可能会导致重组中断。</strong></p></blockquote><p id="a115" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注释一个类是覆盖编译器推断出的关于你的类的东西，这样它就类似于<a class="ae js" href="https://kotlinlang.org/docs/null-safety.html#the-operator" rel="noopener ugc nofollow" target="_blank">！！科特林的操作员</a>。您应该非常小心地使用这些注释，因为覆盖编译器行为可能会导致不可预见的错误。如果没有注释也能使你的类稳定，你应该努力通过这种方式达到稳定。</p><p id="6676" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对<code class="du jo jp jq jr b">Snack</code>示例的注释如下:</p><figure class="ma mb mc md fd hj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="ea12" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">无论选择哪种方法，<code class="du jo jp jq jr b">Snack</code>类都被认为是稳定的。</p><p id="9cb3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，回到<code class="du jo jp jq jr b">HighlightedSnacks</code>可组合的部分，<code class="du jo jp jq jr b">HighlightedSnacks</code>仍然没有被标记为可跳过:</p><pre class="ma mb mc md fd mg jr mh mi aw mj bi"><span id="4f01" class="mk ju hs jr b fi ml mm l mn mo">unstable snacks: List&lt;Snack&gt;</span></pre><p id="7e96" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当涉及集合类型时，参数面临与类相同的问题，<code class="du jo jp jq jr b"><strong class="ir ht">List</strong></code> <strong class="ir ht">总是被确定为不稳定的，即使它是稳定类型的集合。</strong></p><p id="0b76" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您也不能将单个参数标记为稳定的，也不能将可组合参数注释为总是可跳过的。那么你能做什么呢？同样，有多条前进的道路。</p><p id="e683" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用kotlinx不可变集合，而不是<code class="du jo jp jq jr b">List</code>。</p><figure class="ma mb mc md fd hj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="bcf3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您不能使用不可变集合，那么在最简单的情况下，您可以将列表包装在一个带注释的稳定类中，以便为Compose编译器将其标记为不可变。不过，根据您的需求，您很可能希望为此创建一个通用的包装器。</p><figure class="ma mb mc md fd hj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="0ce1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，您可以将它用作可组合文件中的参数类型。</p><figure class="ma mb mc md fd hj"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="d2de" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">采用这两种方法中的任何一种后，<code class="du jo jp jq jr b">HighlightedSnacks</code> composable现在既是可跳过的，也是可重启的。</p><pre class="ma mb mc md fd mg jr mh mi aw mj bi"><span id="096c" class="mk ju hs jr b fi ml mm l mn mo">restartable skippable scheme(“[androidx.compose.ui.UiComposable]”) fun HighlightedSnacks(</span><span id="9c97" class="mk ju hs jr b fi nb mm l mn mo">   stable index: Int</span><span id="6dda" class="mk ju hs jr b fi nb mm l mn mo">   stable snacks: ImmutableList&lt;Snack&gt;</span><span id="4de1" class="mk ju hs jr b fi nb mm l mn mo">   stable onSnackClick: Function1&lt;Long, Unit&gt;</span><span id="7ae7" class="mk ju hs jr b fi nb mm l mn mo">   stable modifier: Modifier? = @static Companion</span><span id="bc76" class="mk ju hs jr b fi nb mm l mn mo">)</span></pre><p id="8774" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">HighlightedSnacks</code>现在当它的输入没有变化时会跳过重组。</p><h1 id="ef83" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">多个模块</h1><p id="fec3" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">您可能遇到的另一个常见问题与多模块体系结构有关。如果一个类引用的所有非基元类型要么被显式标记为稳定，要么在一个也是用Compose编译器构建的模块中，则Compose编译器只能推断该类是否稳定。如果你的数据层在一个独立于UI层的模块中，<a class="ae js" href="https://developer.android.com/topic/architecture" rel="noopener ugc nofollow" target="_blank">这是推荐的方法</a>，这可能是你会遇到的一个问题。要解决这个问题，您可以:</p><ul class=""><li id="4c6a" class="kw kx hs ir b is it iw ix ja ky je kz ji la jm lb lc ld le bi translated">在您的数据层模块上启用Compose编译器，或者在适当的地方用<code class="du jo jp jq jr b">@Stable</code>或<code class="du jo jp jq jr b">@Immutable</code>标记您的类。</li><li id="823a" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">这将涉及到向数据层添加一个组合依赖项，但是它只是组合运行时的依赖项，而不是组合UI的依赖项。</li><li id="a79f" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">将数据层类包装在UI模块中特定于UI的包装类中。</li></ul><p id="012e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除非使用Compose编译器，否则外部库也会出现同样的问题。</p><p id="8730" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个已知的限制，我们目前正在研究多模块架构和外部库的更好的解决方案。</p><h1 id="c6e8" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">每个可组合的都应该是可跳过的吗？</h1><p id="d501" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated"><strong class="ir ht">号</strong></p><p id="ea34" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">追求应用程序中每个组件的完全可跳过性是一种不成熟的优化。可跳过实际上<a class="ae js" rel="noopener" href="/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd">增加了一点开销</a>，这可能不值得，如果您确定可重启的开销大于它的价值，您甚至可以将您的composable注释为<a class="ae js" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/NonRestartableComposable" rel="noopener ugc nofollow" target="_blank">不可重启的</a>。在许多其他情况下，可跳过并没有任何真正的好处，只会导致代码难以维护。例如:</p><ul class=""><li id="887d" class="kw kx hs ir b is it iw ix ja ky je kz ji la jm lb lc ld le bi translated">不常重组或根本不重组的可组合词。</li><li id="35d5" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">本身只调用可跳过的可组合组件的可组合组件。</li></ul><h1 id="09f3" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">摘要</h1><p id="2c3b" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">这篇博文提供了很多信息，让我们总结一下。</p><ul class=""><li id="a35e" class="kw kx hs ir b is it iw ix ja ky je kz ji la jm lb lc ld le bi translated">Compose决定了你的组件的每个参数的稳定性，以确定在重组过程中是否可以跳过它。</li><li id="de23" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">如果您注意到您的composable没有被跳过<strong class="ir ht">并且导致了性能问题</strong>，您应该首先检查不稳定的明显原因，比如var参数。</li><li id="2a27" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">您可以使用<a class="ae js" href="https://github.com/androidx/androidx/blob/androidx-main/compose/compiler/design/compiler-metrics.md" rel="noopener ugc nofollow" target="_blank">编译器报告</a>来确定您的类的稳定性。</li><li id="fc8d" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">像<code class="du jo jp jq jr b">List</code>、<code class="du jo jp jq jr b">Set</code>和<code class="du jo jp jq jr b">Map</code>这样的集合类总是被确定为不稳定的，因为不能保证它们是不可变的。您可以使用<a class="ae js" href="https://github.com/Kotlin/kotlinx.collections.immutable" rel="noopener ugc nofollow" target="_blank"> Kotlinx不可变集合</a>来代替，或者将您的类注释为<code class="du jo jp jq jr b">@Immutable</code>或<code class="du jo jp jq jr b">@Stable</code>。</li><li id="ca07" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">来自没有运行Compose编译器的模块的类总是被确定为不稳定的。在compose runtime上添加一个依赖项，并在您的模块中将它们标记为稳定的，或者如果需要，将这些类包装在UI模型类中。</li><li id="c229" class="kw kx hs ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">每个可组合的都应该是可跳过的吗？号码</li></ul><p id="592c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要了解更多关于编写性能的调试技巧，请查看我们的<a class="ae js" href="http://goo.gle/compose-performance" rel="noopener ugc nofollow" target="_blank">最佳实践指南</a>和<a class="ae js" href="https://www.youtube.com/watch?v=EOQB8PTLkpY" rel="noopener ugc nofollow" target="_blank"> I/O对话</a>。</p></div></div>    
</body>
</html>