# 使用 Kotlin 扩展扩展您的代码可读性

> 原文：<https://medium.com/androiddevelopers/extend-your-code-readability-with-kotlin-extensions-542bf702aa36?source=collection_archive---------0----------------------->

![](img/f1f064469350b2336414178de85f7e03.png)

## 科特林词汇表:扩展函数和属性

你是否曾经使用过一个 API，并想给它添加功能或属性？

您可以从类继承，或者创建一个接受类实例的函数来解决这个问题。Java 编程语言通常用一个 Utils 类来解决这个问题，但这在 autocomplete 中并没有显示出来，这使得查找起来更困难，使用起来也不直观。这两种方法都是解决方案，但都不提倡简单易读的代码。

谢天谢地，Kotlin 用[扩展函数和属性](https://kotlinlang.org/docs/reference/extensions.html)来拯救我们。这些使您可以向类中添加功能，而无需继承或创建接受该类的函数。与 Java 编程语言的等效语言不同，扩展出现在 Android Studio 的自动完成功能中。扩展可以用于第三方库、Android SDK 或用户定义的类。

请继续阅读，了解如何使用扩展来扩展代码的可读性！

# 扩展功能—用途

假设您有一个名为`Dog`的类，它有一个名字、品种和年龄。

如果有人对收养感兴趣，收养机构可能希望扩展`Dog`类，使其具有打印狗的信息的功能。为了做到这一点，我们实现了一个`extension function`，它的设置就像一个普通的函数，只是有一点不同:在函数名之前添加要扩展的类，并在函数名之间加一个点。在函数实现中，您可以使用它来引用 receiver 对象，并且可以访问您的函数块中 receiver 类的所有成员。

您可以像调用`Dog`类中的任何其他函数一样调用`printDogInformation()`。

## 从 Java 代码中调用扩展函数

扩展函数不是我们正在扩展的类的一部分，所以当试图从 Java 编程语言中调用它们时，我们不会在该类的其他方法中找到它们。正如我们将在后面看到的，扩展反编译成你定义它们的文件的静态方法，并作为参数接收我们正在扩展的类的一个实例。这就是从 Java 中调用`printDogInformation()`扩展的样子。

## 可空类型上的扩展函数

您甚至可以在可空类型上使用扩展。我们可以在可空类型上创建扩展函数，并使空检查成为函数实现的一部分，而不是在调用扩展函数之前进行空检查。这就是使用可空类型的`printInformation()`的样子。

如您所见，在调用`printInformation()`之前，您不需要进行 null 检查。

# 扩展属性—用法

收养机构可能也想知道狗是否足够大可以被收养。为此，我们实现了一个名为`isReadyToAdopt`的扩展属性，它检查狗的年龄是否超过 1 岁。

您可以像调用`Dog`类中的任何其他属性一样调用这个扩展属性。

# 扩展功能覆盖

您不能重写现有的成员函数。如果你定义一个扩展函数和一个已经存在的成员函数有相同的签名，那么这个成员函数总是会被调用，因为被调用的函数依赖于变量声明的静态类型，而不是依赖于变量中存储的值的运行时类型。比如不能在 String 上扩展`toUppercase()`，但是可以扩展`convertToUppercase()`。

当您扩展一个不属于您的类型，并且库所有者向他们的库中添加了一个与您的扩展具有相同签名的方法时，就会显示出这种行为的后果。在这种情况下，将调用库扩展。您将得到的唯一信息是您的扩展函数变成了一个未使用的方法。

# 在后台

我们可以通过进入**Tools/kot Lin/Show kot Lin Bytecode**，然后按下 **Decompile** 按钮，在 Android Studio 中对`printDogInformation()`进行反编译。如果我们将`printDogInformation()`方法视为反编译代码，我们会得到这样的结果:

在幕后，扩展函数只是常规的静态函数，它接受 receiver 类的一个实例。它们与接收器类没有任何其他联系。这就是为什么没有支持字段——它们实际上并没有将成员插入到类中。

# 结论

总的来说，扩展是一个需要慎重使用的有用工具，当你使用它们来使你的代码更加直观和可读时，记住下面的提示。

请记住:

*   扩展是静态解析的。
*   成员函数总是会赢。
*   领养一只狗！

编码快乐！