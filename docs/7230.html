<html>
<head>
<title>Surfacing Hidden Change to Pull Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">显示拉取请求的隐藏更改</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/surfacing-hidden-change-to-pull-requests-6a371266e479?source=collection_archive---------2-----------------------#2017-07-13">https://medium.com/square-corner-blog/surfacing-hidden-change-to-pull-requests-6a371266e479?source=collection_archive---------2-----------------------#2017-07-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie"><p id="528e" class="if ig hh bd ih ii ij ik il im in io dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们在https://developer.squareup.com/blog<a class="ae ip" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">的新家</a></p></blockquote><p id="836f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm io ha bi translated">编程经常处理可见的变化:代码中的逻辑、声明的依赖项、公开的API。然而，有相当多的相关隐藏更改:可传递的依赖关系、生成的代码和清单文件。</p><p id="ef7a" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">在代码审查中，我们关注可见的东西，因为那是在差异中呈现给我们的东西。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/37ffc0b67aff78000fe7ca09129b8e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SjC7gMew-9Jbiir3DYNDw.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">A visible logic change in a pull request.</figcaption></figure><p id="17a5" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">同样重要的是，在代码审查期间要注意隐藏的变化。可传递的依赖关系更改或生成的代码更改可能会使生成的二进制文件膨胀或降低性能。清单更改可能会导致下游不兼容。这些问题通常在发布过程的后期才被发现，需要进行调查以找到原因。</p><p id="4e86" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">在Cash Android团队中遇到一些隐藏更改的问题后，我们决定在它们更改的地方提升它们的可见性:拉请求。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es ki"><img src="../Images/0060875a50fa5e7f33d9ff80838c27dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6YsUG_dx7HhAWTbgPJILg.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">APK size and method count diff on an automatic PR comment.</figcaption></figure><p id="9ef3" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">在每个CI构建中，我们计算有趣的数据片段，如二进制大小和方法计数(Android应用程序的一个重要指标)，并将它们写入共享存储。当CI构建为pull请求运行时，我们会计算出这些值与主服务器上的祖先提交的值之间的差异。这些数字以注释的形式发送回pull请求，以确保作者和任何审阅者都得到通知。</p><p id="929d" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">这些重要的度量现在明确地呈现出来，以确保结果是您想要的。这个新的依赖项仅仅增加了10个方法，还是增加了10，000个方法？那个新英雄形象是只加20KB还是占2MB？</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es kq"><img src="../Images/257bdbe74dc5de8fce0108b4bfc8df08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CT3YnmfTfvT36IA8ZP7iOw.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">A full dependency graph diff is included when a dependency changes.</figcaption></figure><p id="3386" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">除了这些简单的数字统计之外，我们还捕获了应用程序和Gradle的构建脚本(构建系统依赖项)的整个依赖图。</p><p id="3f77" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">在这里，我们将Kotlin从1.0.4升级到了1.1里程碑。我们不仅保存了3个方法，而且我们可以看到它们从<code class="du kr ks kt ku b">kotlin-runtime</code>工件向JetBrains的<code class="du kr ks kt ku b">annotations</code>工件添加了一个依赖项。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="a6f9" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">Android构建使用所谓的清单合并来创建应用程序的最终清单。它将您定义的清单与您使用的库中嵌入的清单合并在一起。从Android操作系统的角度来看，这个合并的清单本质上是应用程序的公共API，定义了入口点、公开的服务和所需的权限等内容。跟踪清单中的变化非常重要，因为这可能会在升级时导致不兼容。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es kv"><img src="../Images/4b3a9909559dff4a8385c908609fa4d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4OwUfuTRN_NuQGpdGTr6FA.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">A merged manifest diff is included when something changes.</figcaption></figure><p id="2f07" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">Square的开源库<a class="ae ip" href="https://github.com/square/whorlwind" rel="noopener ugc nofollow" target="_blank"> Whorlwind </a>简化了向应用程序添加指纹支持。它的清单中包含了使用指纹识别器的权限。当将库添加到Cash中时，该权限最终出现在我们的合并清单中，因此显示在pull请求注释中。</p><p id="e2a1" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">虽然这个示例是无害的，但意外的权限或错误公开的组件可能会合并进来，并为您的用户带来升级问题或安全漏洞。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="4fe9" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">并不是所有隐含的信息都应该直接暴露在这个注释中。例如，方法计数的变化总是引起我的兴趣，我想看看各个方法的实际差异。这些计数有时数以千计，这将使评论无法使用和恼人的。我们没有在注释中直接显示方法diff，而是将diff呈现到一个文件中，该文件作为附件包含在CI构建中。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kw"><img src="../Images/024bfb4aa928a7ab25f7629f1d357044.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*QUksQbOx6RECo4n9kA6gfQ.png"/></div><figcaption class="ke kf et er es kg kh bd b be z dx">More detailed information on what changed is attached to CI shards.</figcaption></figure><p id="f57e" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">当您想了解评论中包含的更多详细信息时，您只需点击CI服务器。此示例显示了一个提供完整方法diff的构建碎片，一个ProGuard删除内容的报告，一个resource shrinker删除内容的报告，一个显示构建速度的Gradle profile，以及一个项目模块图的图像呈现。其他碎片包括像Android的Lint报告或测试执行摘要之类的东西。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="82b7" class="pw-post-body-paragraph iq ir hh is b it jn iv iw ix jo iz ja jb jp jd je jf jq jh ji jj jr jl jm io ha bi translated">您选择在注释或CI中包含的内容取决于您的项目。对于现金机器人，这些是我们认为最有价值的东西。目标应该是一样的:表面信息很重要，但是隐藏起来看不见。</p></div></div>    
</body>
</html>