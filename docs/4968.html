<html>
<head>
<title>Say Hello 👋 to Jetpack Compose and Compare with XML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打招呼👋Jetpack编写并与XML进行比较</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/say-hello-to-jetpack-compose-and-compare-with-xml-6bc6053aec13?source=collection_archive---------0-----------------------#2021-12-05">https://blog.kotlin-academy.com/say-hello-to-jetpack-compose-and-compare-with-xml-6bc6053aec13?source=collection_archive---------0-----------------------#2021-12-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c50e3ca28a82a975b97e75a04de2d5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e9mVOG4_saWP2AJG"/></div></div></figure><h1 id="31a0" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="eaea" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">大家好👋我会试着解释一下<strong class="kv io"> <em class="lr"> Jetpack Compose基础知识</em> </strong>和<strong class="kv io"> <em class="lr">我为什么要用Jetpack Compose。Jetpack Compose很重要，因为它是在Android中构建现代UI的一种新方式。</em>让我们深入研究一下没有XML的Android中的UI开发。</strong></p><blockquote class="ls lt lu"><p id="a2a4" class="kt ku lr kv b kw lv ky kz la lw lc ld lx ly lg lh lz ma lk ll mb mc lo lp lq ig bi translated">在我看来，Jetpack Compose是Android UI开发的未来，我们必须尽快采用。</p></blockquote><h1 id="c661" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">什么是Jetpack Compose？</h1><blockquote class="ls lt lu"><p id="01f1" class="kt ku lr kv b kw lv ky kz la lw lc ld lx ly lg lh lz ma lk ll mb mc lo lp lq ig bi translated">Jetpack Compose是Android用于构建原生UI的现代工具包。它简化并加速了Android - Google上的UI开发</p></blockquote><p id="ec54" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">Jetpack Compose是一个现代的工具包，它允许我们以声明的方式编写更少的代码来构建我们的屏幕。Android UI开发现在更加强大，也更加去耦合。</p><p id="8b9c" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">在Jetpack Compose之前，我们使用XML布局来构建原生UI。当我们用XML构建屏幕时，我们有一个非常依赖的结构。此外，片段对于UI来说是非常沉重的组件。Jetpack Compose允许我们用声明式UI方法和更少的代码构建相同的UI。</p><h1 id="c64c" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">为什么我应该使用Jetpack Compose？</h1><p id="2dd4" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在我看来，从XML和科特林·❤️来看，这要容易得多</p><p id="81d7" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">如果我们从技术上看:</p><ul class=""><li id="a081" class="md me in kv b kw lv la lw le mf li mg lm mh lq mi mj mk ml bi translated">声明式用户界面比命令式用户界面更简洁、易读、高效。</li><li id="a221" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated">与XML相比，Compose允许您用更少的代码做更多的事情。</li><li id="3f0f" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated">作曲很直观。这意味着您只需要告诉Compose您想要向用户显示什么。</li><li id="0070" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated">Compose与您现有的所有代码兼容:您可以从视图调用Compose代码，也可以从Compose调用视图。还集成了许多Jetpack库。</li><li id="75bd" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated">撰写提高您的建设时间和APK的大小。</li></ul><h1 id="fed1" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">XML设计与Jetpack合成</h1><h2 id="4c74" class="mr jw in bd jx ms mt dn kb mu mv dp kf le mw mx kj li my mz kn lm na nb kr nc bi translated">合成—重组—状态管理</h2><p id="74dd" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">每个组件都有一个<strong class="kv io">初始组合</strong>。只有当我们第一次在屏幕上看到一个视图时，初始合成才会运行。</p><p id="f9a4" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">组件可以保持一个<strong class="kv io">状态</strong>并在状态改变时重新运行。这叫做<strong class="kv io">重组</strong>。</p><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/293e9a94b08c73a61cbbd64d14b86533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NaAY2t4rQJBT5TCi.png"/></div></div></figure><h2 id="84c9" class="mr jw in bd jx ms mt dn kb mu mv dp kf le mw mx kj li my mz kn lm na nb kr nc bi translated">原子设计</h2><p id="0e0a" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在Compose中，组件继承是用函数实现的，因为组件就是函数。一个可组合函数只能在另一个可组合函数中调用。当我们编写更小的组件时，我们得到了更灵活的组件结构。</p><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/a9820ca1bd7e379c4ca5c1e6e6b7bfa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*745f11SgIyNiC8AX.png"/></div></div></figure><h1 id="e728" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">XML与Jetpack组合代码示例</h1><h2 id="f782" class="mr jw in bd jx ms mt dn kb mu mv dp kf le mw mx kj li my mz kn lm na nb kr nc bi translated">1.基本用户界面组件</h2><p id="08c3" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">现在让我们使用Xml和Jetpack Compose构建同一个视图，看看代码方面的区别。<br/>以下是目标视图结构:</p><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8290d046efd9c517d448e0fef0fa4c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*790lNRXn5cGtHVjgHLI5Ew.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">example-view-structure</figcaption></figure><p id="2aaf" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io">使用Xml构建</strong></p><figure class="ne nf ng nh gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c72e" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io">使用Jetpack构建</strong></p><figure class="ne nf ng nh gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="1410" class="mr jw in bd jx ms mt dn kb mu mv dp kf le mw mx kj li my mz kn lm na nb kr nc bi translated">2.列表项目</h2><p id="264c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kv io">用Xml构建</strong></p><p id="b566" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">我们需要用Xml在屏幕上显示列表的几个文件/类:</p><ol class=""><li id="4738" class="md me in kv b kw lv la lw le mf li mg lm mh lq nq mj mk ml bi translated">adapter_item_list.xml</li><li id="26dd" class="md me in kv b kw mm la mn le mo li mp lm mq lq nq mj mk ml bi translated">ListItemAdapter.kt</li><li id="1d12" class="md me in kv b kw mm la mn le mo li mp lm mq lq nq mj mk ml bi translated">ListItemViewHolder(内部类)</li><li id="677c" class="md me in kv b kw mm la mn le mo li mp lm mq lq nq mj mk ml bi translated">填充活动/片段</li></ol><p id="388e" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io">使用Jetpack构建</strong></p><p id="4264" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">我们只需要<strong class="kv io"> <em class="lr">惰性栏</em> </strong> <em class="lr"> </em>就可以在屏幕上显示列表项。不需要适配器类或项目设计xml文件。我们可以在<strong class="kv io">项目/项目</strong> <strong class="kv io">范围内描述项目设计。</strong></p><figure class="ne nf ng nh gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/b27ff37c16b7ca7a6a5561ab2b0d37bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_P5TdqI4HKWgklHU4bc_xg.png"/></div></div></figure><h1 id="989c" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">状态管理</h1><blockquote class="ls lt lu"><p id="86c3" class="kt ku lr kv b kw lv ky kz la lw lc ld lx ly lg lh lz ma lk ll mb mc lo lp lq ig bi translated">"应用程序中的状态是任何可以随时间变化的值."-谷歌</p></blockquote><p id="3b7d" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">Compose是声明性的，所以更新它的唯一方法是用不同的参数调用。</p><blockquote class="ls lt lu"><p id="25e8" class="kt ku lr kv b kw lv ky kz la lw lc ld lx ly lg lh lz ma lk ll mb mc lo lp lq ig bi translated"><strong class="kv io"> <em class="in">初始合成:</em> </strong> <em class="in">第一次运行composables创建合成。</em></p><p id="388b" class="kt ku lr kv b kw lv ky kz la lw lc ld lx ly lg lh lz ma lk ll mb mc lo lp lq ig bi translated"><strong class="kv io"> <em class="in">重组:</em> </strong> <em class="in">当数据(状态)发生变化时，重新运行组件可以更新合成。</em></p></blockquote><p id="d27e" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">用<strong class="kv io">存储一个数据记住:</strong></p><pre class="ne nf ng nh gt ns nt nu nv aw nw bi"><span id="3658" class="mr jw in nt b gy nx ny l nz oa">val data by remember { mutableStateOf(INITIAL_VALUE) }<!-- --> </span></pre><figure class="ne nf ng nh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/e1bb997ddd9a6b604bfb57783233f444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LMJ9_IxCXcf-bK9uJGGAQA.gif"/></div></div></figure></div><div class="ab cl oc od hr oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ig ih ii ij ik"><p id="e304" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">如果您想在配置改变时保留数据，您应该使用<strong class="kv io">remembers saveable:</strong>存储数据</p><pre class="ne nf ng nh gt ns nt nu nv aw nw bi"><span id="3113" class="mr jw in nt b gy nx ny l nz oa">var tite by rememberSaveable { mutableStateOf("") }<br/>Text(<br/>    text = title,<br/>    modifier = Modifier.padding(bottom = 10.dp),<br/>    style = MaterialTheme.typography.h5<br/>)</span></pre><h1 id="10f9" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">航行</h1><p id="5749" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">一切都是可组合的，甚至导航。我们需要导航主机和屏幕。每个屏幕都应该有一条<strong class="kv io">路线</strong>。</p><blockquote class="ls lt lu"><p id="05ca" class="kt ku lr kv b kw lv ky kz la lw lc ld lx ly lg lh lz ma lk ll mb mc lo lp lq ig bi translated"><strong class="kv io"> <em class="in"> Route: </em> </strong> <em class="in">定义你的可组合路径的字符串。每个目的地应该有一个独特的路线。</em></p><p id="a1d2" class="kt ku lr kv b kw lv ky kz la lw lc ld lx ly lg lh lz ma lk ll mb mc lo lp lq ig bi translated"><strong class="kv io"><em class="in">navgraphbuilder . composable:</em></strong><em class="in">一个使用导航图绑定唯一路线的函数。</em></p></blockquote><p id="2d39" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">下面是一个用于创建NavHost的可组合函数:</p><ul class=""><li id="6f42" class="md me in kv b kw lv la lw le mf li mg lm mh lq mi mj mk ml bi translated"><strong class="kv io"> MainActivity.kt: </strong></li></ul><pre class="ne nf ng nh gt ns nt nu nv aw nw bi"><span id="ae7e" class="mr jw in nt b gy nx ny l nz oa">@Composable<br/>fun AppNavigation() {<br/>    val navController = rememberNavController()<br/>    NavHost(<br/>        navController = navController,<br/>        startDestination = NavScreen.getStartDestination()<br/>    ) {<br/>        composable(NavScreen.Home.route) { HomeScreen(navController) }<br/>        composable(NavScreen.Explore.route) { ExploreScreen(navController) }<br/>    }</span><span id="cd99" class="mr jw in nt b gy oj ny l nz oa">}</span><span id="20eb" class="mr jw in nt b gy oj ny l nz oa">sealed class NavScreen(val route: String) {<br/>    object Home : NavScreen("home")<br/>    object Explore : NavScreen("explore")</span><span id="f52a" class="mr jw in nt b gy oj ny l nz oa">    companion object {<br/>        fun getStartDestination() = Home.route<br/>    }<br/>}</span></pre><ul class=""><li id="fb21" class="md me in kv b kw lv la lw le mf li mg lm mh lq mi mj mk ml bi translated"><strong class="kv io"> HomeScreen.kt: </strong></li></ul><pre class="ne nf ng nh gt ns nt nu nv aw nw bi"><span id="0e7e" class="mr jw in nt b gy nx ny l nz oa">@Composable<br/>fun HomeScreen(<br/>    navController: NavController = rememberNavController(),<br/>    homeViewModel: HomeViewModel = viewModel()<br/>) {<br/>    Column(<br/>        modifier = Modifier.fillMaxSize(),<br/>        horizontalAlignment = Alignment.CenterHorizontally,<br/>        verticalArrangement = Arrangement.Center<br/>    ) {<br/>        Text(text = homeViewModel.getTitle())</span><span id="7eea" class="mr jw in nt b gy oj ny l nz oa">        Button(<br/>            onClick = { navController.navigate(NavScreen.Explore.route) },<br/>        ) {<br/>            Text(text = "Go to Explore screen")<br/>        }<br/>    }<br/>}</span></pre><ul class=""><li id="2098" class="md me in kv b kw lv la lw le mf li mg lm mh lq mi mj mk ml bi translated"><strong class="kv io"> ExploreScreen.kt </strong></li></ul><pre class="ne nf ng nh gt ns nt nu nv aw nw bi"><span id="b268" class="mr jw in nt b gy nx ny l nz oa">@Composable<br/>fun ExploreScreen(<br/>    navController: NavController = rememberNavController(),<br/>    exploreViewModel: ExploreViewModel = viewModel()<br/>) {<br/>    Column(<br/>        modifier = Modifier.fillMaxSize(),<br/>        horizontalAlignment = Alignment.CenterHorizontally,<br/>        verticalArrangement = Arrangement.Center<br/>    ) {<br/>        Text(text = exploreViewModel.getTitle())</span><span id="0d5b" class="mr jw in nt b gy oj ny l nz oa">        Button(<br/>            onClick = { navController.navigateUp() },<br/>        ) {<br/>            Text(text = "back to previous screen")<br/>        }<br/>    }<br/>}</span></pre><h1 id="869f" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论</h1><figure class="ne nf ng nh gt jo"><div class="bz fp l di"><div class="ok np l"/></div></figure><p id="c7de" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">我们结束了。在本文中，我想解释Jetpack Compose的内容以及Compose和基于XML的设计之间的区别。</p><p id="721a" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">对我来说，Jetpack Compose是Android UI开发的一次革命。更少的代码和更容易理解的代码、声明式UI方法、管理状态等等。此外，它可以直接与jetpack库一起工作。</p><p id="3e40" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">我希望这篇文章是有帮助的。如果是这样，你可以离开鼓掌👏 👏如果你觉得不对劲，请给我留言。</p><p id="b82a" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><a class="ae ol" href="https://twitter.com/mustafayigitt_" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">Twitter</strong></a><strong class="kv io">&amp;</strong><a class="ae ol" href="https://www.linkedin.com/in/mustafayigitt/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">Linkedin</strong></a><strong class="kv io">&amp;</strong><a class="ae ol" href="https://github.com/mustafayigitt" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">Github</strong></a></p><h1 id="89ab" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">资源</h1><ul class=""><li id="01fe" class="md me in kv b kw kx la lb le om li on lm oo lq mi mj mk ml bi translated"><a class="ae ol" href="https://github.com/mustafayigitt/JetpackComposeComponents" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> Github </strong> </a></li><li id="7e93" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated"><strong class="kv io">其他来源</strong></li></ul><p id="058c" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><a class="ae ol" href="https://developer.android.com/jetpack/compose/why-adopt" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/jetpack/compose/why-adopt</a></p><p id="137e" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated">https://developer.android.com/jetpack/compose/ergonomics<a class="ae ol" href="https://developer.android.com/jetpack/compose/ergonomics" rel="noopener ugc nofollow" target="_blank"/></p><p id="fc6c" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><a class="ae ol" href="https://medium.com/androiddevelopers/jetpack-compose-before-and-after-8b43ba0b7d4f" rel="noopener">喷气背包作曲——前后</a></p><p id="cb73" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><a class="ae ol" href="https://medium.com/androiddevelopers/jetpack-compose-before-and-after-8b43ba0b7d4f" rel="noopener">https://medium . com/androiddevelopers/jetpack-compose-before-and-after-8b 43 ba 0 b 7d 4 f</a></p><p id="6d91" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><a class="ae ol" href="https://developer.android.com/jetpack/compose/mental-model" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/jetpack/compose/mental-model</a></p><p id="9586" class="pw-post-body-paragraph kt ku in kv b kw lv ky kz la lw lc ld le ly lg lh li ma lk ll lm mc lo lp lq ig bi translated"><strong class="kv io">子线程</strong></p><ul class=""><li id="5faf" class="md me in kv b kw lv la lw le mf li mg lm mh lq mi mj mk ml bi translated"><a class="ae ol" href="https://developer.android.com/jetpack/compose/state#state-and-composition" rel="noopener ugc nofollow" target="_blank">合成/重组</a></li><li id="93e9" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated"><a class="ae ol" href="https://developer.android.com/jetpack/compose/state" rel="noopener ugc nofollow" target="_blank">状态管理</a></li><li id="1003" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated"><a class="ae ol" href="https://developer.android.com/jetpack/compose/state#state-in-composables" rel="noopener ugc nofollow" target="_blank">记住/记住可保存/不可修改</a></li><li id="46ee" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated"><a class="ae ol" href="https://developer.android.com/jetpack/compose/animation" rel="noopener ugc nofollow" target="_blank">动画</a></li><li id="4e1f" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated"><a class="ae ol" href="https://developer.android.com/jetpack/compose/side-effects" rel="noopener ugc nofollow" target="_blank">副作用</a></li><li id="016e" class="md me in kv b kw mm la mn le mo li mp lm mq lq mi mj mk ml bi translated"><a class="ae ol" href="https://developer.android.com/jetpack/compose/mental-model#paradigm" rel="noopener ugc nofollow" target="_blank">声明式用户界面</a></li></ul></div></div>    
</body>
</html>