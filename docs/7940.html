<html>
<head>
<title>Grocery Item’s Nil Pick prediction using a Machine Learning Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习模型预测杂货项目的零拣选</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/grocery-items-nil-pick-prediction-using-a-machine-learning-model-191e273f2795?source=collection_archive---------0-----------------------#2020-11-12">https://medium.com/walmartglobaltech/grocery-items-nil-pick-prediction-using-a-machine-learning-model-191e273f2795?source=collection_archive---------0-----------------------#2020-11-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="a883" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">当所订购的商品不可用时，物品替代品在客户满意度方面发挥着关键作用，因此是客户订单不可或缺的一部分。</h2></div><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/27c5acce5970dc03646e4045f9720ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FCwaWcbhjJmehCJS"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo by <a class="ae ju" href="https://unsplash.com/@justinlim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Justin Lim</a> on <a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8faf" class="jv jw hh bd jx jy jz ka kb kc kd ke kf in kg io kh iq ki ir kj it kk iu kl km bi translated">它是如何工作的…</h1><p id="bff2" class="pw-post-body-paragraph kn ko hh kp b kq kr ii ks kt ku il kv kw kx ky kz la lb lc ld le lf lg lh li ha bi translated">电子商务平台已经将购物提升到了一个完全不同的水平，顾客可以舒舒服服地坐在沙发上，从成千上万的商品中挑选，然后送货上门，但这说起来容易做起来难。</p><p id="a03a" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">电子商务订单履行是一个复杂的过程，涉及供应链、商店/仓库、物流、支付等多个团队的协作。让我们讨论一下订单是如何体现在实际包装/装运中的。</p><p id="63a2" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">订单由电子商务平台提供的属于不同类别的各种项目组成。为了完成订单，员工将从商店/仓库的不同区域挑选这些商品，将它们放入手推车/篮子中，最后准备发货。从技术上讲，订单履行之旅始于商店提货人(员工的术语)，他下载订单详细信息，其中包含要从商店或仓库提货的商品。随后，生成一条优化路径(称为挑选行走)来挑选订购的商品，以便最大限度地减少收集所有订购商品的时间。现在，这就是物品替代发挥作用的地方，它构成了我们打算讨论的问题的核心。</p></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><h2 id="a57d" class="lv jw hh bd jx lw lx ly kb lz ma mb kf kw mc md kh la me mf kj le mg mh kl mi bi translated">问题陈述…</h2><p id="78e2" class="pw-post-body-paragraph kn ko hh kp b kq kr ii ks kt ku il kv kw kx ky kz la lb lc ld le lf lg lh li ha bi translated">在提货过程中，商品可能缺货，或者其包装存在质量问题。在这种情况下，提货人会依靠某个商品的替代品来替换原来订购的商品。但有时，即使是替补队员也没有资格入选</p><ol class=""><li id="9f2e" class="mj mk hh kp b kq lj kt lk kw ml la mm le mn li mo mp mq mr bi translated">与原项目相比，替代品<strong class="kp hi">不合适</strong>。</li></ol><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ms"><img src="../Images/318fae1f6b5d86af27ad1aaca0ef394f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qMXDiFUo2ZAsrIw_"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo reference <a class="ae ju" href="https://images.app.goo.gl/fnwj6DKTgsqpvj6X7" rel="noopener ugc nofollow" target="_blank">https://images.app.goo.gl/fnwj6DKTgsqpvj6X7</a></figcaption></figure><p id="bf2a" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">2.替代品<strong class="kp hi">缺货</strong>。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/7a7d6b1f75f5a05da24f75ae60c250c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dlBwJUDGVgUoSdV_"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo by <a class="ae ju" href="https://unsplash.com/@simonbhray?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Simon Ray</a> on <a class="ae ju" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8253" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">3.替代品有<strong class="kp hi">体积问题</strong>，因为它可能不适合用于提货的手提袋/手推车。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mt"><img src="../Images/6e1cbdccf92664661e03e59df8203c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uy-_iGcspCDK0mxoV9ieNQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Photo Reference <a class="ae ju" href="https://www.flickr.com/photos/schuminweb/12231549264/in/photostream/" rel="noopener ugc nofollow" target="_blank">https://www.flickr.com/photos/schuminweb/12231549264/in/photostream/</a></figcaption></figure><p id="8c73" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">这就导致了零提货(即商品或其替代品无法提货，因此无法在订单中履行)或人工提货(提货人根据自己的判断和尽职调查选择商品)。这种情况导致了</p><ol class=""><li id="cf3b" class="mj mk hh kp b kq lj kt lk kw ml la mm le mn li mo mp mq mr bi translated">客户拒绝的增加——因为客户不喜欢我们提供的替代品。</li><li id="b4aa" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li mo mp mq mr bi translated">整体履行时间增加——因为手动挑选的替代品可能需要商店经理的批准。</li></ol></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><h2 id="7ac1" class="lv jw hh bd jx lw lx ly kb lz ma mb kf kw mc md kh la me mf kj le mg mh kl mi bi translated">建议的解决方案…</h2><p id="383b" class="pw-post-body-paragraph kn ko hh kp b kq kr ii ks kt ku il kv kw kx ky kz la lb lc ld le lf lg lh li ha bi translated">机器学习是目前科技行业最受欢迎的工具之一。这些数学模型的应用范围从无人驾驶汽车到虚拟助手。我们希望利用机器学习的数学方法，根据上面讨论的原因来预测零拣选和人工拣选。因此，我们首先建立一个假设，即机器学习模型将有助于以纯数学的方式证明。</p><p id="e2cb" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">假设验证将包括:</p><ol class=""><li id="bfa3" class="mj mk hh kp b kq lj kt lk kw ml la mm le mn li mo mp mq mr bi translated">商店数据的处理和分析。</li><li id="ce86" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li mo mp mq mr bi translated">创建一个数据管道，并开发一个基于回归的机器学习模型来预测零拣货。可以遵循类似的方法来预测人工挑选。</li><li id="258c" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li mo mp mq mr bi translated">执行模型来解释结果。</li></ol></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><h2 id="1059" class="lv jw hh bd jx lw lx ly kb lz ma mb kf kw mc md kh la me mf kj le mg mh kl mi bi translated">选择机器学习模型的困惑</h2><p id="6f1e" class="pw-post-body-paragraph kn ko hh kp b kq kr ii ks kt ku il kv kw kx ky kz la lb lc ld le lf lg lh li ha bi translated">人工智能使用的人工神经网络有三类。</p><ol class=""><li id="09f4" class="mj mk hh kp b kq lj kt lk kw ml la mm le mn li mo mp mq mr bi translated">前馈神经网络/多层感知器</li><li id="2fb1" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li mo mp mq mr bi translated">卷积神经网络</li><li id="6d1d" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li mo mp mq mr bi translated">递归神经网络</li></ol><p id="34d3" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">前向神经网络</em> </strong>是第一种被创造出来的人工神经网络，可以认为是当今最常用的人工神经网络。这些神经网络被称为前馈神经网络，因为通过网络的信息流是单向的，不经过环路。</p><blockquote class="na nb nc"><p id="cb28" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated">基于中间隐藏层的存在，前馈神经网络可以进一步分为单层网络或多层网络。</p></blockquote><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ng"><img src="../Images/8becf304f65bd9bff9e64e230b551fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SmfL6gdOxOv_LRdDfKU2vQ.png"/></div></div></figure><p id="8bce" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">层数取决于需要执行的功能的复杂程度。单层前馈神经网络仅由两层神经元组成，并且在它们之间没有隐藏层。多层感知器由输入和输出层之间的多个隐藏层组成，允许多阶段的信息处理。</p><p id="80b3" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">使用MLPs为:</em> </strong></p><ul class=""><li id="a472" class="mj mk hh kp b kq lj kt lk kw ml la mm le mn li nh mp mq mr bi translated">表格数据集</li><li id="934b" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li nh mp mq mr bi translated">分类预测问题</li><li id="201c" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li nh mp mq mr bi translated">回归预测问题</li></ul><p id="cd52" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">优点</em> </strong></p><ul class=""><li id="1479" class="mj mk hh kp b kq lj kt lk kw ml la mm le mn li nh mp mq mr bi translated">高度灵活，可应用于各种数据集，如表格、图像和文本等。</li><li id="8956" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li nh mp mq mr bi translated">适用于在给定一组输入的情况下预测实数值的回归预测问题。</li></ul><p id="ddf5" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">缺点</em> </strong></p><ul class=""><li id="1457" class="mj mk hh kp b kq lj kt lk kw ml la mm le mn li nh mp mq mr bi translated">由于它是一个完全连接的模型，总参数可能会增长到非常高的数量，这可能会在更高层中造成冗余和低效。</li></ul><blockquote class="na nb nc"><p id="ff38" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated">第1层感知器的数量乘以第2层p的#乘以第3层p的#等等。</p></blockquote><ul class=""><li id="55b9" class="mj mk hh kp b kq lj kt lk kw ml la mm le mn li nh mp mq mr bi translated">不适用于影像数据集，因为它忽略了空间信息。</li></ul><p id="b3d1" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">卷积神经网络</em> </strong>，自从它的概念提出以来，几乎只与计算机视觉应用有关。这是因为他们的架构特别适合执行复杂的可视化分析。</p><p id="bdba" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">卷积神经网络架构由神经元的三维排列来定义，而不是标准的二维阵列。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ni"><img src="../Images/aae906f022addda7c94624a2d1c0f21f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rp4VJriyHfqcBRf8"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Image Reference <a class="ae ju" href="https://images.app.goo.gl/JaNc7quRC6CJRV61A" rel="noopener ugc nofollow" target="_blank">https://images.app.goo.gl/JaNc7quRC6CJRV61A</a></figcaption></figure><p id="cfa6" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">这种神经网络的第一层称为卷积层。卷积层中的每个神经元只处理来自一小部分视野的信息。卷积层之后是整流层单元或ReLU，这使CNN能够处理复杂的信息，并有助于分类/识别。</p><p id="36a6" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">使用CNN进行:</em> </strong></p><ul class=""><li id="02d0" class="mj mk hh kp b kq lj kt lk kw ml la mm le mn li nh mp mq mr bi translated">机器视觉和自动驾驶汽车等物体识别应用。</li><li id="901f" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li nh mp mq mr bi translated">用于情感分析的文档分类及相关问题。</li></ul><p id="e3c6" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"><em class="mz">【RNN】</em></strong>递归神经网络，顾名思义，涉及循环形式的递归运算。这些比前馈网络复杂得多，并且可以执行比基本图像识别更复杂的任务</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ni"><img src="../Images/5cdca8d13fb81b9677e488cf0451fd5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Arax6zmW5-9nfiuE"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Image Reference <a class="ae ju" href="https://images.app.goo.gl/FUW6XCinS3uL9i5W6" rel="noopener ugc nofollow" target="_blank">https://images.app.goo.gl/FUW6XCinS3uL9i5W6</a></figcaption></figure><p id="6709" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">使用RNNs进行:</em> </strong></p><ul class=""><li id="b2f2" class="mj mk hh kp b kq lj kt lk kw ml la mm le mn li nh mp mq mr bi translated">序列预测问题。</li><li id="5c00" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li nh mp mq mr bi translated">语音和文本预测。</li><li id="08c4" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li nh mp mq mr bi translated">自然语言生成。</li></ul><p id="6513" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">递归神经网络不适用于表格和图像数据集。它们很难训练，而且短期记忆很差，这限制了它们的功能。为了克服记忆的限制，一种新形式的RNN，被称为LSTM或长短期记忆网络被使用。</p><blockquote class="na nb nc"><p id="cc33" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated">在比较了上面讨论的机器学习模型之后，我们选择为我们的尼克选择预测构建一个预测性的<strong class="kp hi">多层感知器</strong>，因为它最适合我们的问题陈述，原因如下:<br/> 1 .我们的训练数据集是与错误替换和容量问题相关的逗号分隔存储数据。CNN和RNN都不适合CSV/表格数据集。<br/> 2。我们打算建立一个预测模型。CNN适合于图像分析用例，而RNN适合于序列预测问题。此外，RNNs和LSTMs已经在预测问题上进行了测试，但是已经被应用于相同数据的基于简单MLPs的回归模型所超越。</p></blockquote></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><h2 id="c38b" class="lv jw hh bd jx lw lx ly kb lz ma mb kf kw mc md kh la me mf kj le mg mh kl mi bi translated">TensorFlow Docker设置</h2><p id="0afa" class="pw-post-body-paragraph kn ko hh kp b kq kr ii ks kt ku il kv kw kx ky kz la lb lc ld le lf lg lh li ha bi translated">TensorFlow启动Docker命令</p><pre class="jf jg jh ji fd nj nk nl nm aw nn bi"><span id="9fc6" class="lv jw hh nk b fi no np l nq nr">$ docker run -it -p 8888:8888 -p 6006:6006 -v &lt;NOTEBOOK_PATH_ON_LOCAL_SYSTEM&gt;:/tf/notebooks tensorflow/tensorflow:latest-jupyter</span></pre><p id="5f77" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">在Docker容器中安装熊猫</p><pre class="jf jg jh ji fd nj nk nl nm aw nn bi"><span id="9dca" class="lv jw hh nk b fi no np l nq nr">$ pip install --trusted-host pypi.org --trusted-host files.pythonhosted.org pandas</span></pre><h2 id="5d16" class="lv jw hh bd jx lw lx ly kb lz ma mb kf kw mc md kh la me mf kj le mg mh kl mi bi translated">商店数据分析</h2><p id="391e" class="pw-post-body-paragraph kn ko hh kp b kq kr ii ks kt ku il kv kw kx ky kz la lb lc ld le lf lg lh li ha bi translated">来自不同商店的数据被收集以形成训练和评估数据集。该数据是每周的不良替换、体积问题实例和零选择的计数。</p><blockquote class="na nb nc"><p id="f9c8" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated">1.熊猫数据帧:将CSV数据读入熊猫数据帧。</p></blockquote><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><blockquote class="na nb nc"><p id="b2ea" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated">2.散点图:解释数据的最重要部分是能够可视化数据集特征之间的趋势和相关性，在我们的情况下，这包括错误的替换、体积问题和零选择。我们通过数据图来做到这一点，这使我们能够轻松地发现数据集中有趣的模式/相关性，并决定数据集是否适用于训练机器学习模型。</p></blockquote><p id="5262" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">我们使用Matplotlib的<a class="ae ju" href="https://matplotlib.org/api/pyplot_api.html" rel="noopener ugc nofollow" target="_blank"><strong class="kp hi"><em class="mz">py plot</em></strong></a>API创建数据图。数据分析最常用的图之一是二维散点图。它用于绘制数值相关特征(Y轴)和数值无关特征(X轴)之间的关系。零选择和手动选择代表我们用例的因变量</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nu"><img src="../Images/5701b1138ddd6e4d032a9429fc734f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iKrrmXl0CRU-VS5__CuneQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 1. Nil Pick Scatter Plots</figcaption></figure><blockquote class="na nb nc"><p id="9bc3" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated">3.解释图:创建数据集图后，我们分析它们以确定Nil Pick是否与不良Subs或容器不适合特性有任何关联。在图中要注意的主要事情是非均匀分布的。诸如正态分布或多模态分布的非均匀分布示出了不良接头和/或容器不适合特征可能被机器学习模型用来预测零拣选。因此，相关性(图1。)之间的差异为构建机器学习模型来预测零拣选提供了强有力的理由。</p></blockquote></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><h2 id="18b2" class="lv jw hh bd jx lw lx ly kb lz ma mb kf kw mc md kh la me mf kj le mg mh kl mi bi translated">数据处理</h2><p id="594f" class="pw-post-body-paragraph kn ko hh kp b kq kr ii ks kt ku il kv kw kx ky kz la lb lc ld le lf lg lh li ha bi translated">在本节中，我们打算为训练和评估Nil Pick机器学习模型构建输入管道。</p><p id="8b2f" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">输入管道表示在训练或评估的每个步骤中，数据将如何传递到模型中。由于训练模型需要数千个步骤，输入管道必须尽可能高效。</p><p id="b168" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">我们创建的商店数据集存储在pandas data frame<strong class="kp hi"><em class="mz">store _ dataset</em></strong>中。由于数据帧对于输入管道来说不是最有效的数据存储，我们需要执行额外的处理来创建一个更有效的解决方案。</p><p id="8082" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">拆分商店数据集</em> </strong></p><p id="b212" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">创建机器学习模型有两个主要部分:训练和评估。训练是机器学习的基础，但评测同样重要。模型评估让我们具体了解模型在训练后有多好，并允许我们比较模型不同配置的性能。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es nv"><img src="../Images/09371476c7ef225703bd5740505b81fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfWAR8a3IZUS5vsw63rpQw.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 2. Splitting Dataset</figcaption></figure><p id="67c6" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">现在，我们如何决定用于训练和评估的数据量。在训练中使用更多的数据可能会提高模型的性能，但由于评估集大小有限，这将限制我们评估的准确性。另一方面，拥有更大的评估集会让我们对评估过程的准确性更有信心，但这可能会限制训练中数据的数量和多样性。</p><p id="3476" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">根据使用情况做出谨慎的选择，我们选择90–10分割，这意味着训练集占最终数据集的90%，而评估集占10%。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="ae71" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">张量流示例对象</em> </strong></p><p id="5071" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">为了优化输入管道，我们希望将每个DataFrame行转换成一个TensorFlow示例对象。通过在输入管道中使用示例对象，我们能够有效地将数据输入到机器学习模型中。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="66f4" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">将示例数据写入TensorFlow记录</em> </strong></p><p id="b706" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">既然我们已经完成了将每个DataFrame行转换为示例对象的函数，我们就可以为训练集和评估集创建高效的输入管道存储了。数据存储将采用TFRecords文件的形式，其中包含序列化的示例对象。</p><p id="243b" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><code class="du nw nx ny nk b">write_tfrecords</code>函数(如下所示)将数据从给定的数据帧写入TFRecords文件。它使用<code class="du nw nx ny nk b">create_example</code>函数将数据集的每一行转换成一个示例对象。然后，每个示例对象被序列化并写入TFRecords文件。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="e11a" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">然后，我们使用<strong class="kp hi"><em class="mz">write _ tfrecords</em></strong>函数将训练集的序列化示例数据写入名为<strong class="kp hi"><em class="mz">train . TFRecords</em></strong>的TF records文件，将评估集的序列化示例数据写入名为<strong class="kp hi"><em class="mz">eval . TF records</em></strong>的TF records文件。然后，这些文件将用于机器学习模型的输入管道中。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="0d31" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">序列化TFRecords </em> </strong></p><p id="cf17" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">数据作为序列化的示例对象存储在TFRecords文件中。为了有效地解析输入管道中的示例对象，我们需要创建一个示例规范。</p><p id="71e7" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">示例规范是一个Python字典，将特征名称映射到<code class="du nw nx ny nk b">FixedLenFeature</code>对象。对于我们的商店数据集，每个<code class="du nw nx ny nk b">FixedLenFeature</code>对象都有形状<code class="du nw nx ny nk b">()</code>。这是因为每个要素包含每个数据观察的单个值。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="79fb" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">对于训练和评估，我们都需要对数据进行标记，以计算我们的机器学习模型的损失。由于我们的模型被训练来预测<code class="du nw nx ny nk b">Nil Pick</code>，我们使用<code class="du nw nx ny nk b">'Nil Pick'</code>特征作为每个数据观察的<strong class="kp hi">标签</strong>。</p><p id="07b9" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">然后，我们使用<code class="du nw nx ny nk b">tf.parse_single_example</code>函数解析单个示例的特征数据(代表一个DataFrame行的数据)。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="4b36" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">模型</em> </strong>的训练和评估TFRecords数据集</p><p id="c6f1" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">我们最终准备好从TFRecords文件创建TensorFlow数据集，用于训练和评估。</p><p id="95d0" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">TFRecords数据集包含序列化的示例对象。然后，我们使用示例规范和特征解析函数，将每个序列化的示例转换为一个元组，该元组包含示例的特征数据以及训练和评估数据的标签。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="a0a2" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">TFRecords数据集的<code class="du nw nx ny nk b">map</code>函数允许我们将解析函数(<code class="du nw nx ny nk b">parse_fn</code>)应用于数据集中的每个序列化示例。由于<code class="du nw nx ny nk b">parse_features</code>函数接受两个参数，而<code class="du nw nx ny nk b">map</code>只能用于只有一个参数的函数，我们使用一个单参数lambda函数来包装<code class="du nw nx ny nk b">parse_features</code>。</p><p id="0a3a" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">此外，我们应用具有100000缓冲区大小的均匀随机洗牌，并配置数据集批次(用于训练和评估)，以便每个训练/评估步骤包含多个数据观察。</p></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><h2 id="934d" class="lv jw hh bd jx lw lx ly kb lz ma mb kf kw mc md kh la me mf kj le mg mh kl mi bi translated"><strong class="ak"> <em class="nz">模型输入层</em> </strong></h2><p id="4e09" class="pw-post-body-paragraph kn ko hh kp b kq kr ii ks kt ku il kv kw kx ky kz la lb lc ld le lf lg lh li ha bi translated">我们的数据集现在包含每个观测的要素数据和标注。我们必须将这些特征数据转换成机器学习模型的输入层。为此，我们首先需要设置必要的特性列。</p><p id="035c" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">数字特征列用于数据集中的数字数据，即可量化的数据。三个特征包含数字数据:<code class="du nw nx ny nk b">'Store'</code>、<code class="du nw nx ny nk b">'Containter_404'</code>和<code class="du nw nx ny nk b">'Bad_Subs'</code>。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="07f3" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">我们为每个输入数据要素创建要素列的原因是，我们可以轻松地为机器学习模型创建输入图层矢量。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es oa"><img src="../Images/80c9ccf7779e25691ebef3ee211958e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*lisQXIUOA5Fb02HoffTQ9Q.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 3. Input Feature Vector</figcaption></figure><blockquote class="na nb nc"><p id="cf7f" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated">我们的机器学习模型遵循标准的MLP架构。这意味着它由多个完全连接的层组成，其中每个隐藏层使用ReLU激活，最后一层不使用激活。MLP的输入图层由来自输入管道的一批数据观测值组成。</p></blockquote><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ob"><img src="../Images/1a8c2dd832608e1adbfb3fd5b77cf1b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*B9DleaPljc_kOInsaB4Cgw.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 4. Machine Learning Architecture</figcaption></figure><p id="f425" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">注</em> </strong> <em class="mz">:更大的模型(即更多的隐藏层和节点)有更高的潜力做出更准确的预测，但它们也可能需要更长的训练时间，并且有更高的过拟合几率。尝试不同的模型大小是很好的，这样我们可以最终选择最好的模型。</em></p><p id="17bf" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">对于我们的MLP模型，我们从两个隐藏层开始。第一个隐藏层包含200个节点，而第二个包含100个节点。</p><p id="feb5" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">我们在<strong class="kp hi"> SubstitutionModel </strong>类的构造函数中初始化隐藏层。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="9618" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">分类vs回归</em> </strong></p><p id="480a" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">MLP在行业中有两个主要的用例:分类和回归。</p><blockquote class="na nb nc"><p id="1ec0" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated">分类是指在给定其特征数据的情况下，为数据观察预测一个<em class="hh">类</em>。MLP在行业中的另一个主要用途是回归。</p><p id="66bb" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated">回归指的是在给定其特征数据的情况下，预测数据观测的实数值。</p></blockquote><p id="c156" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">对于我们的问题陈述，我们打算利用回归函数基于<code class="du nw nx ny nk b">Bad Subs</code>和<code class="du nw nx ny nk b">Volumetric Issue</code>特征来预测<code class="du nw nx ny nk b">Nil Pick</code>。</p><p id="0081" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">回归损失</em> </strong></p><p id="3378" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">对于回归模型，可以使用两个主要的损失函数来训练模型:平均绝对误差<code class="du nw nx ny nk b">MAE</code>和均方误差<code class="du nw nx ny nk b">MSE</code>。平均绝对误差取标签(在我们的例子中，是零选择的实际值)和模型预测值之间的平均绝对差。均方差采用类似的方法，但使用的是平方差而不是绝对差。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es oc"><img src="../Images/fc29da78506598e4a9c6f3aa324a69b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E9_WngExHC1x5K1oWYPDcA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 5. Error Functions</figcaption></figure><p id="d062" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">由于平方操作，MSE(也称为L2损耗)放大大的误差值(例如，1000的差值)并最小化小误差值(例如，0.01的差值)。因为我们预测范围从50到200的零选择，MAE(也称为L1损失)是首选，以避免不必要的误差放大。</p><p id="4385" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">使用<strong class="kp hi"> <em class="mz">模型输入层</em> </strong>部分的特征列功能，我们为我们的模型创建了输入层。模型的输入图层只是一个矢量，它来自于商店数据集中所有数字特征值的组合。</p><p id="3fe3" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><code class="du nw nx ny nk b"><a class="ae ju" href="https://www.tensorflow.org/api_docs/python/tf/feature_column/input_layer" rel="noopener ugc nofollow" target="_blank">tf.feature_column.input_layer</a></code>函数允许我们轻松地将解析的特征值字典和特征列列表转换为模型的输入层。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="8753" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">带训练模式的张量流估计器规格</em> </strong></p><p id="3479" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">完成机器学习模型有三个阶段:<em class="mz">训练</em>、<em class="mz">评估</em>和<em class="mz">预测</em>。使用TensorFlow，我们可以很容易地将三个阶段捆绑成一个函数，对每个阶段使用<code class="du nw nx ny nk b"><a class="ae ju" href="https://www.tensorflow.org/api_docs/python/tf/estimator/EstimatorSpec" rel="noopener ugc nofollow" target="_blank">EstimatorSpec</a></code>对象。</p><p id="4e64" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><code class="du nw nx ny nk b">EstimatorSpec</code>对象有三种模式，对应三个阶段:</p><ul class=""><li id="c4cd" class="mj mk hh kp b kq lj kt lk kw ml la mm le mn li nh mp mq mr bi translated">训练:<code class="du nw nx ny nk b">tf.estimator.ModeKeys.TRAIN</code></li><li id="7add" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li nh mp mq mr bi translated">评测:<code class="du nw nx ny nk b">tf.estimator.ModeKeys.EVAL</code></li><li id="ad04" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li nh mp mq mr bi translated">预测:<code class="du nw nx ny nk b">tf.estimator.ModeKeys.PREDICT</code></li></ul><p id="f15d" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">然后我们为模型训练创建并返回<code class="du nw nx ny nk b">EstimatorSpec</code>对象。</p><blockquote class="na nb nc"><p id="4f29" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated">返回用<code class="du nw nx ny nk b"><em class="hh">mode</em></code>作为必需参数、<code class="du nw nx ny nk b"><em class="hh">loss</em></code>和<code class="du nw nx ny nk b"><em class="hh">train_op</em></code>作为<code class="du nw nx ny nk b"><em class="hh">loss</em></code>和<code class="du nw nx ny nk b"><em class="hh">train_op</em></code>关键字参数初始化的<code class="du nw nx ny nk b"><em class="hh">tf.estimator.EstimatorSpec</em></code>。</p></blockquote><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><blockquote class="na nb nc"><p id="26fc" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated"><code class="du nw nx ny nk b"><strong class="kp hi"><em class="hh">global_step</em></strong></code>用于记录在多次不同的训练运行中进行的总训练步数。等于<code class="du nw nx ny nk b"><strong class="kp hi"><em class="hh">tf.train.get_or_create_global_step</em></strong></code> <strong class="kp hi"> </strong>不带参数应用。</p></blockquote><p id="5d45" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">为了最小化模型在训练期间的损失，我们通过<code class="du nw nx ny nk b">AdamOptimizer</code>对象使用了<a class="ae ju" href="https://arxiv.org/abs/1412.6980" rel="noopener ugc nofollow" target="_blank"> ADAM </a>优化方法。</p><blockquote class="na nb nc"><p id="ab80" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated"><code class="du nw nx ny nk b"><strong class="kp hi"><em class="hh">adam</em></strong></code> <strong class="kp hi"> </strong>等于<strong class="kp hi"> </strong> <code class="du nw nx ny nk b"><strong class="kp hi"><em class="hh">tf.train.AdamOptimizer</em></strong></code> <strong class="kp hi"> </strong>初始化时没有参数。</p></blockquote><p id="2deb" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">带评估预测模式的tensor flow estimator spec</em></strong></p><p id="faa6" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><em class="mz">评估模式:</em>评估模型时，我们使用平均绝对误差作为度量。这是因为我们的目标是让模型的<code class="du nw nx ny nk b">Nil Pick</code> <strong class="kp hi">预测</strong>尽可能接近<strong class="kp hi">实际标签</strong>，这相当于最小化预测和标签之间的平均绝对误差。</p><p id="18d2" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><em class="mz">预测模式:</em>对于回归函数中的预测模式，我们初始化并返回一个<code class="du nw nx ny nk b">EstimatorSpec</code>对象，该对象包含一个带有模型预测的字典。模型的预测需要采用二维张量格式，形状为<code class="du nw nx ny nk b">(batch_size, 1)</code>。</p><p id="3fa8" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">在对TFRecords数据集进行预测时，使用1-D张量版本(用于计算损失)将导致索引错误。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><h2 id="5802" class="lv jw hh bd jx lw lx ly kb lz ma mb kf kw mc md kh la me mf kj le mg mh kl mi bi translated"><strong class="ak"> <em class="nz">带估计量对象的回归模型</em> </strong></h2><p id="85fa" class="pw-post-body-paragraph kn ko hh kp b kq kr ii ks kt ku il kv kw kx ky kz la lb lc ld le lf lg lh li ha bi translated">整个回归模型，从训练到评估再到预测，都可以封装在一个单独的<code class="du nw nx ny nk b"><a class="ae ju" href="https://www.tensorflow.org/api_docs/python/tf/estimator/Estimator" rel="noopener ugc nofollow" target="_blank">Estimator</a></code>对象中。<code class="du nw nx ny nk b">Estimator</code>对象是用回归函数和一些关键字参数初始化的。</p><p id="986b" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">其中一个关键字参数是<code class="du nw nx ny nk b">model_dir</code>，它表示包含模型检查点的目录的路径。检查点是我们保存和恢复模型参数以进行训练、评估和预测的方式。</p><p id="01ef" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">我们使用的另一个关键字参数是<code class="du nw nx ny nk b">config</code>，它为模型指定了一个定制配置。对于我们的回归模型，我们设置的唯一自定义配置是记录频率，即模型在训练期间将损耗和全局步长值记录到屏幕的频率。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="9a4a" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">同</em> </strong> <code class="du nw nx ny nk b"><strong class="kp hi"><em class="mz">Estimator</em></strong></code>一起训练</p><p id="9ac6" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">然后，我们使用我们在  <em class="mz">部分</em>的<strong class="kp hi"> <em class="mz">训练和评估tfrecords数据集中创建的<em class="mz"> train.tfrecords </em>文件来训练该模型。<code class="du nw nx ny nk b">Estimator</code>对象包含一个用于训练模型的<code class="du nw nx ny nk b"><a class="ae ju" href="https://www.tensorflow.org/api_docs/python/tf/estimator/Estimator#train" rel="noopener ugc nofollow" target="_blank">train</a></code>函数。</em></strong></p><p id="7106" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><code class="du nw nx ny nk b">train</code>函数唯一需要的参数是一个没有输入参数的函数。这个函数应该为模型训练建立输入管道。</p><p id="92ae" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">在我们的例子中，它使用<strong class="kp hi"> <em class="mz">训练和评估TFRecords数据集的<code class="du nw nx ny nk b">get_traing_data</code>函数为模型</em> </strong>部分<em class="mz">返回训练数据集。</em></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="655d" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">用</em> </strong> <code class="du nw nx ny nk b"><strong class="kp hi"><em class="mz">Estimator</em></strong></code>评估</p><blockquote class="na nb nc"><p id="cc9c" class="kn ko mz kp b kq lj ii ks kt lk il kv nd ll ky kz ne lm lc ld nf ln lg lh li ha bi translated">我们训练模型的时间足够长，以至于损失开始显示收敛的迹象(对于我们的2隐藏层MLP模型，这是围绕2M训练步骤)。</p></blockquote><p id="280f" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">我们使用<code class="du nw nx ny nk b">Estimator</code>进行评估的方式几乎与我们训练的方式相同，主要区别在于我们使用<code class="du nw nx ny nk b"><a class="ae ju" href="https://www.tensorflow.org/api_docs/python/tf/estimator/Estimator#evaluate" rel="noopener ugc nofollow" target="_blank">evaluate</a></code>函数而不是<code class="du nw nx ny nk b">train</code>函数。</p><p id="229a" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">评估数据集包含在<em class="mz"> eval.tfrecords </em>文件中。创建评估tfrecords数据集的批量大小仅影响评估速度。较大的批处理大小可以加速计算，尽管您必须确保该批处理足够小，可以包含在内存中。</p><p id="e02f" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">在我们的评估中，我们使用了20个批量，请参考<strong class="kp hi"> <em class="mz">训练和评估TFRecords数据集中为模型</em> </strong>部分<em class="mz">定义的<code class="du nw nx ny nk b">get_eval_data</code>函数。</em></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="b3d7" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">预言同</em> </strong> <code class="du nw nx ny nk b"><strong class="kp hi"><em class="mz">Estimator</em></strong></code></p><p id="632b" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">在不断训练和评估<code class="du nw nx ny nk b">Nil Pick</code>预测模型之后，我们尝试预测测试数据集的<code class="du nw nx ny nk b">Nil Pick</code>值。</p><p id="e397" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">使用<code class="du nw nx ny nk b">Estimator</code>对象的<code class="du nw nx ny nk b"><a class="ae ju" href="https://www.tensorflow.org/api_docs/python/tf/estimator/Estimator#predict" rel="noopener ugc nofollow" target="_blank">predict</a></code>函数，我们对未标记的数据集进行预测，一次一个观察(即批量大小为1)。<code class="du nw nx ny nk b">predict</code>函数返回一个生成器对象，我们将它转换成一个预测值列表。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure><p id="aab5" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">模型图</em> </strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es od"><img src="../Images/97c35d51dbccac1ab0bffdd805db7386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v5IqNtUSC5zCoBUZnChG2A.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 6. Graph depicting the conceptual view of the ML Model</figcaption></figure><p id="5922" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated"><strong class="kp hi"> <em class="mz">最终替代模型类</em> </strong></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ns nt l"/></div></figure></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><h2 id="845b" class="lv jw hh bd jx lw lx ly kb lz ma mb kf kw mc md kh la me mf kj le mg mh kl mi bi translated">结论</h2><p id="1380" class="pw-post-body-paragraph kn ko hh kp b kq kr ii ks kt ku il kv kw kx ky kz la lb lc ld le lf lg lh li ha bi translated">我们试验了模型的两个隐藏层的节点数，以进行超过400K次迭代的训练。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es oe"><img src="../Images/19206a9852ebb16e74743476054957de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32XM_OpNwjtDh1fojmUq-w.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Figure 7. Model Loss for different hidden layer configurations</figcaption></figure><p id="b388" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">在模型的多次运行之后，发现具有200和100个节点的2个隐藏层在预测零选择方面具有更好的准确性。本练习验证了我们的假设，即基于其原因在商店中的数量分布的零拣货预测。</p><p id="d788" class="pw-post-body-paragraph kn ko hh kp b kq lj ii ks kt lk il kv kw ll ky kz la lm lc ld le ln lg lh li ha bi translated">…最后，在开发任何机器学习模型时，最重要的是在趋势中识别和权衡不同的深度学习方法，并进行相同的实验，因为这些技术可能是也可能不是我们用例的理想选择，但它们可能有助于解决我们在大型训练数据集下的一些问题陈述(混合模型)。</p></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><h2 id="dea0" class="lv jw hh bd jx lw lx ly kb lz ma mb kf kw mc md kh la me mf kj le mg mh kl mi bi translated">参考</h2><ul class=""><li id="3000" class="mj mk hh kp b kq kr kt ku kw of la og le oh li nh mp mq mr bi translated"><a class="ae ju" href="https://otexts.com/fpp2/nnetar.html" rel="noopener ugc nofollow" target="_blank">神经网络模型</a></li><li id="65c2" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li nh mp mq mr bi translated"><a class="ae ju" href="https://en.wikipedia.org/wiki/Mean_absolute_error" rel="noopener ugc nofollow" target="_blank">平均绝对误差</a></li><li id="a808" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li nh mp mq mr bi translated"><a class="ae ju" href="https://learning.oreilly.com/library/view/introduction-to-linear/9780470542811/#toc" rel="noopener ugc nofollow" target="_blank">线性回归分析介绍</a></li><li id="9731" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li nh mp mq mr bi translated"><a class="ae ju" href="https://www.tensorflow.org/tensorboard/get_started" rel="noopener ugc nofollow" target="_blank">开始使用Tensorflow </a></li><li id="3bd9" class="mj mk hh kp b kq mu kt mv kw mw la mx le my li nh mp mq mr bi translated"><a class="ae ju" href="https://pandas.pydata.org/docs/" rel="noopener ugc nofollow" target="_blank">熊猫文献</a></li></ul></div></div>    
</body>
</html>