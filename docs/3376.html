<html>
<head>
<title>Android databinding Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android数据绑定系列</h1>
<blockquote>原文：<a href="https://medium.com/globant/android-databinding-series-84a90e706a35?source=collection_archive---------3-----------------------#2019-11-05">https://medium.com/globant/android-databinding-series-84a90e706a35?source=collection_archive---------3-----------------------#2019-11-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/be086d8d4b1d1399f5b25d36021ce930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xMRZrizDu_db8bQXSAQY4A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Android Databinding</figcaption></figure><p id="3227" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们已经经历了太多的android架构变化。首先，我们有MVC，它把所有的控制器逻辑放在活动文件中。然后，我们想出了一个拥有MVP的好主意，按照SOLID原则将所有逻辑分成单独的文件，因此我们将业务逻辑放在presenter中，并使用接口将数据传递给UI。出于某种原因，我们需要一个自动发生的反应，所以我们不需要每次都通知屏幕，我们想出了MVVM和数据绑定。还有更多的架构，如BOB叔叔模式和viper等。但是现在让我们专注于数据绑定。</p><p id="fb9d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">首先，我们将从基础开始，了解它是如何工作的，然后我们如何通过让注释处理器生成代码来更快更好地开发应用程序。</p><p id="154c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">请密切关注粗体项目，因为我们将使用它作为参考。</p><figure class="jr js jt ju fd ii"><div class="bz dy l di"><div class="jv jw l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">@copyrights with <a class="ae jx" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">https://giphy.com</a></figcaption></figure><ol class=""><li id="41ff" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated"><strong class="iv hi">设置</strong></li></ol><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="d8a6" class="km kn hh ki b fi ko kp l kq kr">apply plugin: 'kotlin-kapt' //If you have kotlin configured<br/>android {<br/>    dataBinding {<br/>        enabled = true<br/>    }<br/>}</span></pre><p id="b9bf" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">2.让我们创建一个模型</p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="1e20" class="km kn hh ki b fi ko kp l kq kr">data class User(<br/>    var age: String = "0",<br/>    var property: String = "property"<br/>)</span></pre><p id="cddc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这里我们有一个用户类，它有年龄和属性变量。我们将使用XML中的变量</p><p id="b84f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">3.对布局文件的更改</p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="39c7" class="km kn hh ki b fi ko kp l kq kr">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/><strong class="ki hi">&lt;layout</strong> xmlns:android="http://schemas.android.com/apk/res/android"&gt;<br/><br/>    <strong class="ki hi">&lt;data</strong>&gt;<br/>        <strong class="ki hi">&lt;variable</strong><br/>            name="user"<br/>            type="com.parthdave93.databindingdemo.User" /&gt;<br/>    <strong class="ki hi">&lt;/data</strong>&gt;<br/>    &lt;androidx.constraintlayout.widget.ConstraintLayout<br/>        .. name space and all...&gt;<br/><br/>        &lt;TextView<br/>            android:id="@+id/tvAge"<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            <strong class="ki hi">android:text='@{user.age}'</strong><br/>            app:layout_constraintBottom_toBottomOf="parent"<br/>            app:layout_constraintLeft_toLeftOf="parent"<br/>            app:layout_constraintRight_toRightOf="parent"<br/>            app:layout_constraintTop_toTopOf="parent" /&gt;<br/><br/>        &lt;TextView<br/>            android:id="@+id/tvProperty"<br/>            android:layout_width="wrap_content"<br/>            android:layout_height="wrap_content"<br/>            <strong class="ki hi">android:text='@{user.property}'</strong><br/>            app:layout_constraintLeft_toLeftOf="parent"<br/>            app:layout_constraintRight_toRightOf="parent"<br/>            app:layout_constraintTop_toTopOf="parent" /&gt;<br/><br/>    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;<br/><strong class="ki hi">&lt;/layout</strong>&gt;</span></pre><p id="e8b8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注释处理器的工作方式是检查<strong class="iv hi"> &lt;布局</strong>标签，如果任何文件包含带有<strong class="iv hi"> &lt;数据</strong>标签的布局，这意味着这是数据绑定布局，它需要生成对在屏幕上设置数据很重要的文件。<br/>这里我们使用了两个文本视图来显示我们之前创建的用户模型中的年龄和属性。<br/> <strong class="iv hi"> &lt; data </strong>标签包含所有你想要的变量和导入，以便在屏幕上设置数据。</p><p id="9840" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> @{} </strong>用于单向数据绑定意味着视图/布局本身不会改变数据，但会改变代码。我们使用<strong class="iv hi"> @={} </strong>让视图/布局像edittext一样改变对象的数据，如果用户在编辑文本中输入，我们不需要从编辑文本中获取细节并手动设置它，这可以由生成的代码在内部完成。</p><p id="296c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">4.活动类的变化</p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="19bd" class="km kn hh ki b fi ko kp l kq kr">class MainActivity : AppCompatActivity() {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        <strong class="ki hi">val binding = DataBindingUtil.setContentView&lt;ActivityMainBinding&gt;(this, R.layout.<em class="ks">activity_main</em>)</strong><br/><br/>        val user = User() // Initialise Data class object as needed<br/><br/>        binding.<em class="ks">user </em>= user<br/>    }<br/>}</span></pre><p id="3700" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">因此<strong class="iv hi"> DataBindingUtil </strong>将设置该活动的内容，我们将获得绑定对象，我们将设置布局文件中声明的用户变量。屏幕将会更新。</p></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><figure class="jr js jt ju fd ii"><div class="bz dy l di"><div class="la jw l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">@copyrights with <a class="ae jx" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">https://giphy.com</a></figcaption></figure><p id="6bdc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们深入了解它在幕后是如何运作的…</p><p id="2bc4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当我们构建项目时，数据绑定的注释处理器将运行并生成<strong class="iv hi"> ActivityMainBinding </strong>类的<strong class="iv hi">ActivityMainBinding impl</strong>实现。(注释处理器如何工作是一个不同的话题，但作为参考，您可以查看我在<strong class="iv hi"/><a class="ae jx" href="https://github.com/parthdave93/DemoAptProcessor" rel="noopener ugc nofollow" target="_blank"><strong class="iv hi">链接</strong> </a>上的旧回购)</p><p id="c242" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">剖析类文件是用绑定作为后缀颠倒布局。我们有activity_main所以ActivityMainBinding。你可以在android studio中通过快速搜索双转移(或者其他快捷键)找到这个类。</p><p id="bf5f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">于是就有了两个类一个<strong class="iv hi"> ActivityMainBinding ( </strong>类ActivityMainBindingImpl扩展ActivityMainBinding <strong class="iv hi"> ) </strong>和<strong class="iv hi"> ActivityMainBindingImpl ( </strong>抽象类ActivityMainBinding扩展ViewDataBinding <strong class="iv hi">)。</strong></p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="b6ed" class="km kn hh ki b fi ko kp l kq kr">val binding = DataBindingUtil.setContentView<strong class="ki hi">&lt;ActivityMainBinding&gt;</strong>(this, R.layout.<em class="ks">activity_main</em>)</span></pre><p id="ed15" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当我们编写上述代码行时，Databinding util的setContentView方法将被调用，它最终将调用bind方法。</p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="900f" class="km kn hh ki b fi ko kp l kq kr">static &lt;T extends <strong class="ki hi">ViewDataBinding</strong>&gt; T bind(DataBindingComponent bindingComponent, View root,<br/>        int layoutId) {<br/>    return <strong class="ki hi">(T) <em class="ks">sMapper</em>.getDataBinder(bindingComponent, root, layoutId)</strong>;<br/>}</span></pre><p id="d571" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">看看<strong class="iv hi"> <em class="ks"> sMapper </em>。getDataBinder </strong> sMapper基本上是一个映射器，它将布局id映射到代码生成的实现。</p><p id="cea9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">还记得我们在DataBindingUtil中使用setContentView方法时，如何使用layout id(因为R.layout.activity_main是一个整数)知道它需要将哪个绑定对象返回给我们吗？这个<strong class="iv hi">映射器</strong>负责处理它。</p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="b72d" class="km kn hh ki b fi ko kp l kq kr">private static DataBinderMapper <em class="ks">sMapper </em>= new DataBinderMapperImpl();</span><span id="164a" class="km kn hh ki b fi lb kp l kq kr">addMapper(new com.parthdave93.databindingdemo.<strong class="ki hi">DataBinderMapperImpl</strong>());</span></pre><p id="efd2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">那个<strong class="iv hi"> DataBinderMapperImpl </strong>类拥有将布局id映射到绑定实现的所有逻辑。</p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="0deb" class="km kn hh ki b fi ko kp l kq kr">@Override<br/>public ViewDataBinding getDataBinder(DataBindingComponent component, View view, int layoutId) {<br/>  ...<br/>    switch(localizedLayoutId) {<br/>      case  <strong class="ki hi"><em class="ks">LAYOUT_ACTIVITYMAIN</em>:</strong> {<br/>        if ("layout/activity_main_0".equals(tag)) {<br/>          return new <strong class="ki hi">ActivityMainBindingImpl</strong>(component, view);<br/>        }<br/>        throw new IllegalArgumentException("The tag for activity_main is invalid. Received: " + tag);<br/>      }<br/>    }<br/>  }<br/>  return null;<br/>}</span></pre><p id="bff5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在我们有了ActivityMainBindingImpl，它将在布局文件中声明变量，如用户变量。</p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="df0d" class="km kn hh ki b fi ko kp l kq kr">binding.<em class="ks">user </em>= user</span><span id="f99c" class="km kn hh ki b fi lb kp l kq kr">//internal method of ActivityMainBindingImpl<br/>public void <strong class="ki hi">setUser</strong>(@Nullable com.parthdave93.databindingdemo.User User) {<br/>    this.mUser = User;<br/>    synchronized(this) {<br/>        mDirtyFlags |= 0x1L;<br/>    }<br/>    notifyPropertyChanged(BR.<em class="ks">user</em>);<br/>    super.requestRebind();<br/>}</span></pre><p id="ef2b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一旦我们使用它，该类将更新dirtyFlags并请求重新绑定，这将最终调用执行挂起的绑定并在屏幕上更新视图。</p><p id="3080" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">到目前为止，我们在布局中设置用户变量，当我们以异步方式设置用户时，绑定将更新textview。假设在设置了用户之后，我们改变了用户对象变量，比如属性，视图不会更新，为什么？</p><p id="e7e4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">值得注意的是，它不是反应式的，它是异步的，或者我应该说它会等待，当setUser方法被调用时，它会更新那些视图。当我们改变一个对象的属性时，我们没有设置更新UI的逻辑。</p><p id="b981" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为此，让我们稍微修改一下模型:</p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="4302" class="km kn hh ki b fi ko kp l kq kr">import androidx.databinding.BaseObservable<br/>import androidx.databinding.Bindable<br/>//BaseObservable class</span><span id="b63d" class="km kn hh ki b fi lb kp l kq kr">class User: <strong class="ki hi">BaseObservable</strong>() {<br/>    @<strong class="ki hi">get:Bindable</strong><br/>    var age: String = "0"<br/><br/>    @get:Bindable<br/>    var property: String = "property"<br/>    <strong class="ki hi">set</strong>(value) {<br/>        field = value<br/>        notifyPropertyChanged(BR.property)<br/>    }<br/>}</span></pre><p id="de74" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这里，我们用基本可观察对象扩展了类，当我们更新属性时，我们用该属性的整数通知基本可观察对象，只有当我们用Bindable(@<strong class="iv hi">get:Bindable</strong>)注释属性时才会生成该属性。</p><p id="26c7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">因此，让我们来看看这些变化是如何改变activityMainBindingImpl中的setUser方法的。</p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="eb14" class="km kn hh ki b fi ko kp l kq kr">public void setUser(@Nullable com.parthdave93.databindingdemo.User User) {<br/>    <strong class="ki hi">updateRegistration(0, User);</strong><br/>    this.mUser = User;<br/>    synchronized(this) {<br/>        mDirtyFlags |= 0x1L;<br/>    }<br/>    notifyPropertyChanged(BR.<em class="ks">user</em>);<br/>    super.requestRebind();<br/>}</span></pre><p id="a8e4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当我们调用notifyPropertyChanged方法时，更新注册方法使用weakObservables来监听用户类的更改，因此更新会自动推送到屏幕上。</p><p id="307c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们来看案例2，我们的用户类已经被Person类扩展了，我们需要数据绑定类BaseObservable来扩展，在这种情况下我们应该怎么做？</p><p id="b53b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">此时，我们需要通过实现一个<em class="ks">可观察的</em>接口来编写更多的代码来做同样的事情。</p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="d76e" class="km kn hh ki b fi ko kp l kq kr">import androidx.databinding.Bindable<br/>import androidx.databinding.Observable<br/>import androidx.databinding.PropertyChangeRegistry<br/><br/>//Observable interface<br/>class User: Person(), Observable {<br/><br/>    private val registry = <strong class="ki hi">PropertyChangeRegistry</strong>()<br/><br/>    override fun <strong class="ki hi">removeOnPropertyChangedCallback</strong>(callback: Observable.OnPropertyChangedCallback?) {<br/>        registry.remove(callback)<br/>    }<br/><br/>    override fun <strong class="ki hi">addOnPropertyChangedCallback</strong>(callback: Observable.OnPropertyChangedCallback?) {<br/>        registry.add(callback)<br/>    }<br/><br/>    @get:Bindable<br/>    var age: String = "0"<br/><br/>    @get:Bindable<br/>    var property: String = "property"<br/>    set(value) {<br/>        field<strong class="ki hi"> </strong>= value<br/>        <strong class="ki hi">registry.notifyChange(this, BR.property)</strong><br/>    }<br/>}</span></pre><p id="b67b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">PropertyChangeRegistry是用于PropertyChangeCallbacks通知更改的类。好了</p><figure class="jr js jt ju fd ii"><div class="bz dy l di"><div class="lc jw l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">@copyrights with <a class="ae jx" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">https://giphy.com</a></figcaption></figure></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><p id="cbb0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> TL'DR </strong></p><p id="556d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">数据绑定帮助我们利用注释处理器的能力，比以往任何时候都更快地构建UI。我们已经看了在幕后生成的类以及它是如何工作的。有许多其他的东西可以帮助我们超越常规的适配器和类文件生成，这将在下一篇文章中讨论。</p><p id="b7c8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">感谢阅读，我希望你喜欢它。如果你有什么建议或者我写错了什么，我很乐意修改它，请评论。</p></div></div>    
</body>
</html>