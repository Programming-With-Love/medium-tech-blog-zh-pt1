<html>
<head>
<title>Normalization in SQL and its types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL及其类型中的规范化</h1>
<blockquote>原文：<a href="https://medium.com/edureka/normalization-sql-97d38ffb32e?source=collection_archive---------1-----------------------#2019-10-03">https://medium.com/edureka/normalization-sql-97d38ffb32e?source=collection_archive---------1-----------------------#2019-10-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/7c82f911a6a2ae54ec7b0cd6624c4aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*Jur_Hr6eJl0DHoHFcOgCgQ.jpeg"/></div></figure><p id="7564" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">数据库中的数据存储数量巨大。如果数据没有正确组织，检索某些数据将是一项单调乏味的任务。在规范化的帮助下，我们可以组织这些数据并减少冗余数据。通过这篇文章，我将让您全面了解SQL中的规范化。</p><p id="4ff2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">本文将涵盖以下主题:</p><ol class=""><li id="9237" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">什么是数据库中的规范化？</li></ol><p id="a5c9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">2.什么是1NF、2NF、3NF和BCNF范式？</p><ul class=""><li id="f947" class="jj jk hh in b io ip is it iw jl ja jm je jn ji js jp jq jr bi translated">第一范式(1NF)</li><li id="5766" class="jj jk hh in b io jt is ju iw jv ja jw je jx ji js jp jq jr bi translated">第二范式(2NF)</li><li id="e857" class="jj jk hh in b io jt is ju iw jv ja jw je jx ji js jp jq jr bi translated">第三范式</li><li id="5b9d" class="jj jk hh in b io jt is ju iw jv ja jw je jx ji js jp jq jr bi translated">博伊斯-科德范式(BCNF)</li></ul><h1 id="4e1e" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是数据库中的规范化？</h1><p id="f466" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">它是减少表中数据冗余并提高数据完整性的过程。那么，为什么需要这样做呢？如果没有SQL的规范化，我们可能会面临许多问题，例如</p><ol class=""><li id="9b60" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated"><strong class="in hi"> <em class="lb">插入异常</em> </strong>:在没有其他属性存在的情况下，我们无法向表中插入数据时，就会出现这种情况</li><li id="d91e" class="jj jk hh in b io jt is ju iw jv ja jw je jx ji jo jp jq jr bi translated"><strong class="in hi"> <em class="lb">更新异常</em> </strong>:数据冗余和数据部分更新导致的数据不一致。</li><li id="818d" class="jj jk hh in b io jt is ju iw jv ja jw je jx ji jo jp jq jr bi translated"><strong class="in hi"> <em class="lb">删除异常</em> </strong>:因删除其他属性而丢失某些属性时发生。</li></ol><p id="6ae8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">简而言之，规范化是组织数据库中数据的一种方式。规范化需要组织数据库的列和表，以确保它们的依赖关系由数据库完整性约束来正确实施。</p><p id="6a71" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">它通常会将一个大表分成多个小表，因此效率更高。1970年，Edgar F Codd定义了第一个范式，最终，其他范式也被定义了。</p><p id="15fb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">介于两者之间的一个问题是，SQL与规范化有什么关系。SQL是用来与数据库交互的语言。要启动任何交互，数据库中的数据必须是规范化的形式。否则我们无法继续下去，因为它会导致异常。</p><p id="5bd5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">SQL中的规范化将增强数据的分布。现在让我们用例子来理解每一个范式。</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es lc"><img src="../Images/de9b2a5b05ffaa65f8babf728c76bb34.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*tbqTg8qXVkGO8dtv.png"/></div></figure><h2 id="4d33" class="lh jz hh bd ka li lj lk ke ll lm ln ki iw lo lp km ja lq lr kq je ls lt ku lu bi translated">第一范式(1NF)</h2><p id="b275" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">在这种范式中，我们处理原子性的问题。在这里，原子性意味着表中的值不应该被进一步划分。简单来说，一个单元格不能保存多个值。如果表包含复合属性或多值属性，则违反了第一范式。</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es lv"><img src="../Images/395fe3a0eac35c2e4e53cbf0eeab1595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*MQbvf6mtyBhkPG76YNXV9w.png"/></div></figure><p id="ae27" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在上表中，我们可以清楚地看到<code class="du lw lx ly lz b">Phone Number</code>列有两个值。因此，它违反了第一NF。现在，如果我们将第一个NF应用于上表，我们得到下表作为结果。</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es ma"><img src="../Images/2bd1b4f06c66763a54d1fdcfb2aecc34.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*m1w9BzRzypB4vFDVtkHN6w.png"/></div></figure><p id="4e35" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这样，我们实现了原子性，并且每一列都有唯一的值。</p><h2 id="6998" class="lh jz hh bd ka li lj lk ke ll lm ln ki iw lo lp km ja lq lr kq je ls lt ku lu bi translated">第二范式(2NF)</h2><p id="d7de" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">第二个NF中的第一个条件是表必须在第一个NF中。该表也不应包含部分依赖项。这里的部分依赖意味着候选关键字的真子集决定了一个非主属性。为了更好地理解，让我们看下面的例子。</p><p id="dde8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">考虑一下桌子</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es mb"><img src="../Images/64637403937e7ceb862ad75fb5a8eae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*YrxfFKJl-9wtlspU-YQk2Q.png"/></div></figure><p id="2fd6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">该表有一个复合主键<code class="du lw lx ly lz b"><strong class="in hi">Emplyoee ID</strong>, <strong class="in hi">Department ID</strong></code>。非关键属性为<code class="du lw lx ly lz b"><strong class="in hi">Office Location</strong></code>。在这种情况下，<code class="du lw lx ly lz b"><strong class="in hi">Office Location</strong></code>只依赖于<code class="du lw lx ly lz b"><strong class="in hi">Department ID</strong></code>，T3只是主键的一部分。所以这个表不满足第二范式。</p><p id="3d0d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了使这个表达到第二范式，我们需要把它分成两部分。这将为我们提供以下表格:</p><figure class="ld le lf lg fd ii er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mc"><img src="../Images/cb57ac377c807c1a6452acca4af61d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPq1FrfTi7jUhFVyagepPw.png"/></div></div></figure><p id="3c40" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如您所见，我们已经移除了最初的部分功能依赖。现在，在该表中，<code class="du lw lx ly lz b"><strong class="in hi">Office Location</strong></code>列完全依赖于该表的主键<code class="du lw lx ly lz b"><strong class="in hi">Department ID</strong></code>。</p><p id="73c4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们已经学习了第一和第二范式，让我们进入SQL文章中规范化的下一部分。</p><h2 id="2d08" class="lh jz hh bd ka li lj lk ke ll lm ln ki iw lo lp km ja lq lr kq je ls lt ku lu bi translated">第三范式</h2><p id="8021" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">同样的规则也适用于前面，即在进行到3NF之前，表必须在2NF中。另一个条件是非质数属性不应该有传递依赖。这意味着非主属性(不构成候选键)不应该依赖于给定表中的其他非主属性。所以传递依存关系是一种函数依存关系，其中X → Z (X决定Z)通过X → Y和Y → Z间接实现(Y → X不存在)</p><p id="2fda" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们借助一个例子来更清楚地理解这一点:</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es ma"><img src="../Images/c9d92e2eebc995799243779ed2eeacac.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*vjIXbYJ94kWUeZAaTHOeYw.png"/></div></figure><p id="088f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">上表中，<code class="du lw lx ly lz b"><strong class="in hi">Student ID</strong></code>决定<code class="du lw lx ly lz b"><strong class="in hi">Subject ID</strong></code>，而<code class="du lw lx ly lz b"><strong class="in hi">Subject ID</strong></code>决定<code class="du lw lx ly lz b"><strong class="in hi">Subject</strong></code>。因此，<code class="du lw lx ly lz b"><strong class="in hi">Student ID</strong></code>通过<code class="du lw lx ly lz b"><strong class="in hi">Subject ID</strong></code> <strong class="in hi">决定<code class="du lw lx ly lz b"><strong class="in hi">Subject</strong></code>。</strong>这暗示我们有一个传递性的函数依赖，这个结构不满足第三范式。</p><p id="6c62" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在为了实现第三范式，我们需要如下所示划分表格:</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es mh"><img src="../Images/4328581b68a076219f32443a88ad9011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*tcGUT9yibBcBVT87iDgaqw.png"/></div></figure><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es lc"><img src="../Images/d9afda5851af727b7b1c44e7ff202acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*D8ORZM7iyTBfgyP7.png"/></div></figure><p id="e82d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">从上表中可以看出，所有非键属性现在都完全依赖于主键。在第一个表格中，列<code class="du lw lx ly lz b"><strong class="in hi">Student Name</strong></code> <strong class="in hi">、</strong> <code class="du lw lx ly lz b"><strong class="in hi">Subject ID</strong></code>和<code class="du lw lx ly lz b"><strong class="in hi">Address</strong></code>仅依赖于<code class="du lw lx ly lz b"><strong class="in hi">Student ID</strong></code>。在第二个表中，<code class="du lw lx ly lz b"><strong class="in hi">Subject</strong></code>只依赖于<code class="du lw lx ly lz b"><strong class="in hi">Subject ID</strong></code>。</p><h2 id="4943" class="lh jz hh bd ka li lj lk ke ll lm ln ki iw lo lp km ja lq lr kq je ls lt ku lu bi translated">Boyce Codd范式(BCNF)</h2><p id="758a" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">这也被称为3.5 NF。它是3NF的更高版本，由Raymond F. Boyce和Edgar F. Codd开发，用于解决某些3NF没有解决的异常情况。</p><p id="25a7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在进入BCNF之前，该表必须满足第三范式。</p><p id="a121" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在BCNF中，如果每个函数依赖关系<strong class="in hi"> A → B </strong>，那么<strong class="in hi"> A </strong>必须是那个特定表的<strong class="in hi">超级键</strong>。</p><p id="530b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">考虑下表:</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es mi"><img src="../Images/7fa38a4942c3f041f19a049ee42429bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*n359wYL5gFxtS3ka4H8fnA.png"/></div></figure><ul class=""><li id="e4b4" class="jj jk hh in b io ip is it iw jl ja jm je jn ji js jp jq jr bi translated">一个学生可以注册多个科目。</li><li id="5a87" class="jj jk hh in b io jt is ju iw jv ja jw je jx ji js jp jq jr bi translated">可以有多位教授教授一门课程</li><li id="6bd4" class="jj jk hh in b io jt is ju iw jv ja jw je jx ji js jp jq jr bi translated">而且，对于每一门学科，都会给学生指派一名教授</li></ul><p id="aa50" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这个表中，除了BCNF，所有的范式都满足。为什么？</p><p id="c64e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如您所见，<code class="du lw lx ly lz b"><strong class="in hi">Student ID,</strong></code>和<code class="du lw lx ly lz b"><strong class="in hi"> Subject</strong></code>构成了主键，这意味着<code class="du lw lx ly lz b"><strong class="in hi">Subject</strong></code>列是一个<strong class="in hi">主属性</strong>。但是，还有一个依赖，→ <code class="du lw lx ly lz b"><strong class="in hi">Subject</strong></code>。</p><p id="c904" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">而<code class="du lw lx ly lz b"><strong class="in hi">Subject</strong></code>是主属性，<code class="du lw lx ly lz b"><strong class="in hi">Professor</strong></code>是<strong class="in hi">非主属性</strong>，这是BCNF不允许的。</p><p id="21a4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在为了满足BCNF，我们将把桌子分成两部分。一个表将保存已经存在的和新创建的列<code class="du lw lx ly lz b"><strong class="in hi">Professor ID</strong></code>。</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es mj"><img src="../Images/5491448c253c5be7d881e19e14889ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*gecoj3iiWUuPSYztEi1ayw.png"/></div></figure><p id="fde8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在第二个表中，我们将有列<code class="du lw lx ly lz b">Professor ID</code>、<code class="du lw lx ly lz b"> Professor</code>和<code class="du lw lx ly lz b">Subject</code>。</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es mk"><img src="../Images/c0434f257da7fc2ca1b3008d7dc582a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*C2NcTiu1dYnT_60QNv0zbA.png"/></div></figure><p id="6bfb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">通过这样做，我们对Boyce Codd范式感到满意。</p><p id="078c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这样，我们就结束了SQL文章中的规范化。我希望现在您对规范化概念有了清晰的认识。</p><p id="9406" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">至此，我们结束了对SQL和NoSQL的比较。我希望你们喜欢这篇文章，并理解所有的差异。如果你想查看更多关于人工智能、DevOps、道德黑客等市场最热门技术的文章，那么你可以参考<a class="ae ml" href="https://www.edureka.co/blog/?utm_source=medium&amp;utm_medium=content-link&amp;utm_campaign=normalization-in-sql" rel="noopener ugc nofollow" target="_blank"> Edureka的官方网站。</a></p><p id="0e97" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">请留意本系列中的其他文章，它们将解释SQL的各个方面。</p><blockquote class="mm mn mo"><p id="9362" class="il im lb in b io ip iq ir is it iu iv mp ix iy iz mq jb jc jd mr jf jg jh ji ha bi translated"><em class="hh"> 1。</em><a class="ae ml" rel="noopener" href="/edureka/sql-vs-nosql-db-5d9b69ace6ac"><em class="hh">SQL之间的差异&amp; NoSQL数据库</em> </a></p><p id="9928" class="il im lb in b io ip iq ir is it iu iv mp ix iy iz mq jb jc jd mr jf jg jh ji ha bi translated"><em class="hh"> 2。</em><a class="ae ml" rel="noopener" href="/edureka/sql-for-data-science-a8fe10fe2ef9"><em class="hh">SQL For Data Science</em></a></p><p id="dcf1" class="il im lb in b io ip iq ir is it iu iv mp ix iy iz mq jb jc jd mr jf jg jh ji ha bi translated"><a class="ae ml" rel="noopener" href="/edureka/sql-interview-questions-162f97f37ac2"> <em class="hh"> 3。前65个SQL面试问题</em> </a></p></blockquote></div><div class="ab cl ms mt go mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ha hb hc hd he"><p id="c418" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="lb">原载于2019年10月3日https://www.edureka.co</em><em class="lb">的</em> <a class="ae ml" href="https://www.edureka.co/blog/normalization-in-sql/" rel="noopener ugc nofollow" target="_blank"> <em class="lb">。</em></a></p></div></div>    
</body>
</html>