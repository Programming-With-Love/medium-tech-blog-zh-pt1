<html>
<head>
<title>Find routes around the world without the Internet (For developers)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在没有互联网的情况下查找世界各地的路线(针对开发人员)</h1>
<blockquote>原文：<a href="https://medium.com/globant/find-routes-around-the-world-without-internet-for-developers-5bd97b32c1b8?source=collection_archive---------0-----------------------#2018-07-06">https://medium.com/globant/find-routes-around-the-world-without-internet-for-developers-5bd97b32c1b8?source=collection_archive---------0-----------------------#2018-07-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e0eb55d1442103f2943597cda6b39a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6yrKOamg0P6qgmQBTMcPQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">find a peace full place</figcaption></figure><p id="6721" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我看一下现实世界中的应用程序，在我们向用户提供的所有应用程序中，有最好的场景，即<br/> 1)用户将拥有良好的互联网连接。<br/> 2)用户拥有大存储容量和ram的高端手机。<br/> 3)用户没有<strong class="iv hi">计量连接</strong>。</p><p id="6726" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但现实中，用户并没有<strong class="iv hi">高端手机</strong>或<strong class="iv hi">大存储容量</strong>和<strong class="iv hi">无限数据包</strong>(Jio服务除外)。</p><p id="279c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">到目前为止，我们一直在做API调用，从来没有试图缓存它们，甚至也没有试图在一个同步服务中一起上传片段。如果用户没有互联网，他们就不能喜欢或订阅帖子。这就像我们给软件一个单一的状态</p><blockquote class="jr js jt"><p id="c831" class="it iu ju iv b iw ix iy iz ja jb jc jd jv jf jg jh jw jj jk jl jx jn jo jp jq ha bi translated">用户需要互联网来喜欢这篇文章或使用此功能，请检查您的互联网</p></blockquote><p id="675e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">API可以用各种方式缓存，数据库和所有的，但是让我们看看像地图这样的难题。</p><blockquote class="jr js jt"><p id="8081" class="it iu ju iv b iw ix iy iz ja jb jc jd jv jf jg jh jw jj jk jl jx jn jo jp jq ha bi translated"><strong class="iv hi">如何离线显示地图？</strong></p></blockquote><p id="d8ba" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要求:<br/> 1)地图文件(包含您所在地区的地理结构，或者我所说的您在谷歌或任何其他地图上看到的标记下方的纹理)<br/> 2)该地区的OSM文件(如果您需要显示路线并在经度之间离线查找路线，则为OSM文件)<br/> 3) Graphhopper(我不知道OsmDroid是否会离线查找路线，但现在我已经检查了Graphhopper，工作正常)。</p><ol class=""><li id="b6d0" class="jy jz hh iv b iw ix ja jb je ka ji kb jm kc jq kd ke kf kg bi translated">从这里找到地图文件:<br/><a class="ae kh" href="http://www.openandromaps.org/en/" rel="noopener ugc nofollow" target="_blank"><em class="ju">openandromaps</em></a>这些都是很好的轮廓值得捐赠。<a class="ae kh" href="http://download.mapsforge.org/" rel="noopener ugc nofollow" target="_blank">download.mapsforge.org</a>官方地图伪造出处。<br/> <a class="ae kh" href="http://openmaps.eu/download?format=mapsforge" rel="noopener ugc nofollow" target="_blank"> openmaps.eu </a>我没有试过这些(没有英国..)<br/></li><li id="8857" class="jy jz hh iv b iw ki ja kj je kk ji kl jm km jq kd ke kf kg bi translated">如果你不想在两个纬度之间寻找路线，跳过这一步(目前我不知道如何在graphhopper offline中从名字中追溯点或位置，如果你知道，让我和其他人知道)。<br/> 1。<strong class="iv hi"> D </strong>从<a class="ae kh" href="https://github.com/graphhopper/graphhopper" rel="noopener ugc nofollow" target="_blank"> github </a>下载graphhopper源码。<br/> 2。抽出并前往打开端子<br/> 3的位置。命令:<br/>。/graphhopper.sh导入canary-islands-latest.osm(其中一个有着好听轨迹的岛屿)<br/>。/graphhopper.sh导入canary-islands-170716.osm.pbf(生成路线)<br/> 4 .现在你有了一个加那利群岛的文件夹或者是graphhopper文件夹中的osm文件<br/> 5。如果这些文件很小，则创建一个API或将它们添加到资产中，或者执行一些逻辑操作将文件下载到用户设备上</li><li id="b0de" class="jy jz hh iv b iw ki ja kj je kk ji kl jm km jq kd ke kf kg bi translated">好去打开Android工作室和开发阶段如下所述</li></ol><blockquote class="jr js jt"><p id="e4aa" class="it iu ju iv b iw ix iy iz ja jb jc jd jv jf jg jh jw jj jk jl jx jn jo jp jq ha bi translated">渲染地图等东西的依赖关系<br/>编译' org.mapsforge:maps forge-core:0 . 8 . 0 '<br/>编译' org . maps forge:maps forge-map:0 . 8 . 0 '<br/>编译' org . maps forge:maps forge-poi:0 . 8 . 0 '<br/>编译' org . maps forge:maps forge-poi-Android:0 . 8 . 0 '<br/>编译' org . maps forge</p><p id="0661" class="it iu ju iv b iw ix iy iz ja jb jc jd jv jf jg jh jw jj jk jl jx jn jo jp jq ha bi translated">路由搜索的依赖关系<br/>编译(组:' com.graphhopper '，名称:' graphhopper-core '，版本:' 0.10-SNAPSHOT') { <br/>排除组:' com.google.protobuf '，模块:' protobuf-java' <br/>排除组:' org . openstreetmap . osm-binary '<br/>排除组:' org.apache.xmlgraphics '，模块:' xmlgraphics-commons' <br/> } <br/>编译' org.slf4j:slf</p></blockquote><p id="8a28" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">地图设置</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="d19b" class="kw kx hh ks b fi ky kz l la lb"><strong class="ks hi">private void </strong>setUpMap() {<br/>   AndroidGraphicFactory.<em class="ju">createInstance</em>(<strong class="ks hi">this</strong>.getApplication());<br/>   <strong class="ks hi">this</strong>.<strong class="ks hi">mapView </strong>= <strong class="ks hi">new </strong>MapView(<strong class="ks hi">this</strong>);<br/>   setContentView(<strong class="ks hi">this</strong>.<strong class="ks hi">mapView</strong>);<br/>   <strong class="ks hi">this</strong>.<strong class="ks hi">mapView</strong>.setClickable(<strong class="ks hi">true</strong>);<br/>   <strong class="ks hi">this</strong>.<strong class="ks hi">mapView</strong>.getMapScaleBar().setVisible(<strong class="ks hi">true</strong>);<br/>   <strong class="ks hi">this</strong>.<strong class="ks hi">mapView</strong>.setBuiltInZoomControls(<strong class="ks hi">true</strong>);<br/>   <strong class="ks hi">this</strong>.<strong class="ks hi">tileCache </strong>= AndroidUtil.<em class="ju">createTileCache</em>(<strong class="ks hi">this</strong>, <strong class="ks hi">"mapcache"</strong>, <strong class="ks hi">mapView</strong>.getModel().<strong class="ks hi">displayModel</strong>.getTileSize(), 1f, <strong class="ks hi">this</strong>.<strong class="ks hi">mapView</strong>.getModel().<strong class="ks hi">frameBufferModel</strong>.getOverdrawFactor());<br/>   <br/>   MapDataStore mapDataStore = <strong class="ks hi">new </strong>MapFile(<strong class="ks hi">new </strong>File(Environment.<em class="ju">getExternalStorageDirectory</em>(), <strong class="ks hi"><em class="ju">MAP_FILE</em></strong>));<br/>   <strong class="ks hi">this</strong>.<strong class="ks hi">tileRendererLayer </strong>= <strong class="ks hi">new </strong>TileRendererLayer(<strong class="ks hi">tileCache</strong>, mapDataStore, <strong class="ks hi">this</strong>.<strong class="ks hi">mapView</strong>.getModel().<strong class="ks hi">mapViewPosition</strong>, AndroidGraphicFactory.<em class="ju">INSTANCE</em>);<br/>   <strong class="ks hi">tileRendererLayer</strong>.setXmlRenderTheme(InternalRenderTheme.<strong class="ks hi"><em class="ju">DEFAULT</em></strong>);<br/>   <strong class="ks hi">this</strong>.<strong class="ks hi">mapView</strong>.getLayerManager().getLayers().add(<strong class="ks hi">tileRendererLayer</strong>);<br/>   <strong class="ks hi">this</strong>.<strong class="ks hi">mapView</strong>.setCenter(<strong class="ks hi">new </strong>LatLong(28.3778434,-16.5694826));<br/>   createPositionMarker(28.3778434,-16.5694826);<br/>   <strong class="ks hi">this</strong>.<strong class="ks hi">mapView</strong>.setZoomLevel((<strong class="ks hi">byte</strong>) 17);<br/>}</span></pre><p id="4fc6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">其中mapview来自mapforge库，这将帮助我们渲染标记和地图设备。定义中心要在中心制作动画，您可以制作自己的中心或用户的位置</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="b0cd" class="kw kx hh ks b fi ky kz l la lb"><strong class="ks hi">private void </strong>getDirections() {<br/>      <em class="ju">// create one GraphHopper instance<br/>      </em><strong class="ks hi">hopper </strong>= <strong class="ks hi">new </strong>GraphHopper().forMobile();<br/>      <strong class="ks hi">hopper</strong>.setDataReaderFile(Environment.<em class="ju">getExternalStorageDirectory</em>()+<strong class="ks hi">"/Downloads/tenerife.osm"</strong>);<br/><em class="ju">//    grassHopperOsmFile = new File(Environment.getExternalStorageDirectory()+"/Downloads/tenerife.osm").getAbsolutePath();<br/>//    hopper.setDataReaderFile(grassHopperOsmFile);<br/>      <br/>      // where to store graphhopper files?<br/>      </em>String grassHopperFolder  = Environment.<em class="ju">getExternalStorageDirectory</em>()+<strong class="ks hi">"/grasshopper"</strong>;<br/>      <strong class="ks hi">if</strong>(!(<strong class="ks hi">new </strong>File(grassHopperFolder).exists())){<br/>         <strong class="ks hi">new </strong>File(grassHopperFolder).mkdir();<br/>      }<br/>      <strong class="ks hi">hopper</strong>.setGraphHopperLocation(grassHopperFolder);<br/>      <br/>      <em class="ju">// now this can take minutes if it imports or a few seconds for loading<br/>      // of course this is dependent on the area you import<br/>      </em><strong class="ks hi">hopper</strong>.load(grassHopperFolder);<br/>      <br/>      GHRequest req = <strong class="ks hi">new </strong>GHRequest(28.5743, -16.1657, 28.4288, -16.4060).setAlgorithm(Parameters.Algorithms.<strong class="ks hi"><em class="ju">DIJKSTRA_BI</em></strong>);<em class="ju">//setWeighting("fastest");<br/>      </em>GHResponse rsp = <strong class="ks hi">hopper</strong>.route(req);<br/>      <br/>      <em class="ju">// first check for errors<br/>      </em><strong class="ks hi">if</strong>(rsp.hasErrors()) {<br/>         <em class="ju">// handle them!<br/>         // rsp.getErrors()<br/>         </em><strong class="ks hi">return</strong>;<br/>      }<em class="ju"><br/>      <br/>      </em>Polyline polyline = createPolyline(rsp);<br/>      <br/>      <strong class="ks hi">this</strong>.<strong class="ks hi">mapView</strong>.getLayerManager().getLayers().add(polyline);<br/>   }</span><span id="3b7e" class="kw kx hh ks b fi lc kz l la lb"><strong class="ks hi">private </strong>Polyline createPolyline(GHResponse response)<br/>{<br/>   GraphicFactory gf=AndroidGraphicFactory.<em class="ju">INSTANCE</em>;<br/>   Paint paint=gf.createPaint();<br/>   paint.setColor(AndroidGraphicFactory.<em class="ju">INSTANCE</em>.createColor(Color.<strong class="ks hi"><em class="ju">BLACK</em></strong>));<br/>   paint.setStyle(Style.<strong class="ks hi"><em class="ju">STROKE</em></strong>);<br/>   paint.setDashPathEffect(<strong class="ks hi">new float</strong>[] { 25, 15 });<br/>   paint.setStrokeWidth(8);<br/>   Polyline line = <strong class="ks hi">new </strong>Polyline(paint,AndroidGraphicFactory.<em class="ju">INSTANCE</em>);<br/>   <br/>   List&lt;LatLong&gt; geoPoints = line.getLatLongs();<br/>   PointList tmp = response.getBest().getPoints();<br/>   <strong class="ks hi">for </strong>(<strong class="ks hi">int </strong>i = 0; i &lt; response.getBest().getPoints().getSize(); i++) {<br/>      geoPoints.add(<strong class="ks hi">new </strong>LatLong(tmp.getLatitude(i), tmp.getLongitude(i)));<br/>   }<br/>   <br/>   <strong class="ks hi">return </strong>line;<br/>}</span></pre><p id="2257" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">GraphHopper用于对routes<br/><strong class="iv hi">hopper</strong>=<strong class="iv hi">new</strong>graph hopper()进行请求。for mobile()；<br/>当我们为Android/iOS手机编码时会使用forMobile，如果我们在后端工作，它将用于Server()</p><p id="6196" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">料斗</strong>。load(grassHopperFolder)；<br/>用于定位我们使用命令创建的grasshopper文件的文件夹。最终，当您想要查找如下代码所示的路线时，将会使用该工具，在该代码中，它使用Dijkstra算法查找两点之间的路线。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="8d4c" class="kw kx hh ks b fi ky kz l la lb">GHRequest req = <strong class="ks hi">new </strong>GHRequest(28.5743, -16.1657, 28.4288, -16.4060).setAlgorithm(Parameters.Algorithms.<strong class="ks hi"><em class="ju">DIJKSTRA_BI</em></strong>);</span></pre><p id="41f9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">GHRequest对象用于定义我们需要在其间找到最佳路线的点。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="58f0" class="kw kx hh ks b fi ky kz l la lb">GHResponse rsp = hopper.route(req);<br/><br/><em class="ju">// first check for errors<br/></em><strong class="ks hi">if </strong>(rsp.hasErrors()) {<br/>   <em class="ju">// handle them!<br/>   // rsp.getErrors()<br/>   </em>Iterator&lt;Throwable&gt; throwableIterator = rsp.getErrors().iterator();<br/>   <strong class="ks hi">while </strong>(throwableIterator.hasNext()) {<br/>      Throwable throwable = throwableIterator.next();<br/>      throwable.printStackTrace();<br/>      System.<strong class="ks hi"><em class="ju">out</em></strong>.println(<strong class="ks hi">"Message:" </strong>+ throwable.getMessage());<br/>   }<br/>   <strong class="ks hi">return</strong>;<br/>}</span></pre><p id="2edc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在请求检查Graphhopper响应和它们的错误格式之后，像OpenGL有从数组中读取的错误格式，它们也有一个throwables列表。</p><p id="4ec4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果没有任何错误，并且您想要找到这些点的时间和距离，那么您可以检查以下代码:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="2086" class="kw kx hh ks b fi ky kz l la lb">Iterator&lt;PathWrapper&gt; pathWrapperIterator = rsp.getAll().iterator();<br/><br/><strong class="ks hi">while </strong>(pathWrapperIterator.hasNext()) {<br/>   PathWrapper pathWrapper = pathWrapperIterator.next();<br/>   <br/>   System.<strong class="ks hi"><em class="ju">out</em></strong>.println(<strong class="ks hi">"Time:" </strong>+ pathWrapper.getTime());<br/>   System.<strong class="ks hi"><em class="ju">out</em></strong>.println(<strong class="ks hi">"Distance:" </strong>+ pathWrapper.getDistance());<br/>}</span></pre><p id="5960" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">pathwrapper将有路径的时间和距离，这样您可以在导航地图时计算或在屏幕上显示一些内容。</p><p id="cb14" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要像谷歌地图一样绘制折线，你可以创建一个你想要的颜色的绘画对象。然后创建mapforge polyline对象，并通过迭代您从之前的搜索响应中收到的响应来添加latlong点，并将它们添加到geopoints中。并将地理点添加到多边形线，并通过此显示多边形线。<strong class="iv hi"> mapView </strong>。getLayerManager()。getLayers()。添加(多段线)；<br/>全法如下:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="35d9" class="kw kx hh ks b fi ky kz l la lb">Polyline polyline = createPolyline(rsp);<br/><br/><strong class="ks hi">this</strong>.<strong class="ks hi">mapView</strong>.getLayerManager().getLayers().add(polyline);<br/><strong class="ks hi">hopper</strong>.close();</span><span id="fe00" class="kw kx hh ks b fi lc kz l la lb"><strong class="ks hi">private </strong>Polyline createPolyline(GHResponse response) {<br/>   GraphicFactory gf = AndroidGraphicFactory.<em class="ju">INSTANCE</em>;<br/>   Paint paint = gf.createPaint();<br/>   paint.setColor(AndroidGraphicFactory.<em class="ju">INSTANCE</em>.createColor(Color.<strong class="ks hi"><em class="ju">BLACK</em></strong>));<br/>   paint.setStyle(Style.<strong class="ks hi"><em class="ju">STROKE</em></strong>);<br/>   paint.setDashPathEffect(<strong class="ks hi">new float</strong>[]{25, 15});<br/>   paint.setStrokeWidth(8);<br/>   Polyline line = <strong class="ks hi">new </strong>Polyline(paint, AndroidGraphicFactory.<em class="ju">INSTANCE</em>);<br/>   <br/>   List&lt;LatLong&gt; geoPoints = line.getLatLongs();<br/>   PointList tmp = response.getBest().getPoints();<br/>   <strong class="ks hi">for </strong>(<strong class="ks hi">int </strong>i = 0; i &lt; response.getBest().getPoints().getSize(); i++) {<br/>      geoPoints.add(<strong class="ks hi">new </strong>LatLong(tmp.getLatitude(i), tmp.getLongitude(i)));<br/>   }<br/>   <br/>   <strong class="ks hi">return </strong>line;<br/>}</span></pre><div class="ld le ez fb lf lg"><a href="https://github.com/mapsforge/mapsforge/blob/master/docs/POI.md" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hi fi z dy ll ea eb lm ed ef hg bi translated">地图伪造/地图伪造</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">mapsforge -用Java写的矢量地图库-运行在Android和桌面上。</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">github.com</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu in lg"/></div></div></a></div><div class="ld le ez fb lf lg"><a href="https://github.com/mapsforge/mapsforge/blob/master/mapsforge-poi-writer/src/main/config/poi-mapping.xml" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hi fi z dy ll ea eb lm ed ef hg bi translated">地图伪造/地图伪造</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">mapsforge -用Java写的矢量地图库-运行在Android和桌面上。</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">github.com</p></div></div><div class="lp l"><div class="lv l lr ls lt lp lu in lg"/></div></div></a></div><div class="ld le ez fb lf lg"><a href="https://github.com/mapsforge/mapsforge/tree/master/mapsforge-poi-writer" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab dw"><div class="li ab lj cl cj lk"><h2 class="bd hi fi z dy ll ea eb lm ed ef hg bi translated">地图伪造/地图伪造</h2><div class="ln l"><h3 class="bd b fi z dy ll ea eb lm ed ef dx translated">mapsforge -矢量地图库和writer -运行在Android和桌面上。</h3></div><div class="lo l"><p class="bd b fp z dy ll ea eb lm ed ef dx translated">github.com</p></div></div><div class="lp l"><div class="lw l lr ls lt lp lu in lg"/></div></div></a></div><p id="4bc3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在你会得到黑线的基本路线。希望这篇教程能帮到你。让我知道是否有任何替代的方法来找到路线，以便其他人可以检查最好的。</p><p id="a4a1" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">感谢你阅读:D</p></div></div>    
</body>
</html>