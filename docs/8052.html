<html>
<head>
<title>WebAssembly | An Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebAssembly |简介</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/webassembly-an-introduction-4a6b5b6b0e2b?source=collection_archive---------0-----------------------#2021-08-19">https://medium.com/walmartglobaltech/webassembly-an-introduction-4a6b5b6b0e2b?source=collection_archive---------0-----------------------#2021-08-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/55ebb25c698f0d791230acb3b631cafb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ga20VNGCHnd7aHDRutpFyQ.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx"><a class="ae ip" href="https://soshace.com/introduction-to-webassembly-the-magic-of-native-code-in-web-apps/" rel="noopener ugc nofollow" target="_blank">Photo Credit</a></figcaption></figure><p id="5c41" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">如果我告诉你，你现在可以用你最喜欢的语言写代码，并且它可以在网络上工作，那会怎么样？令人生畏，不是吗？我知道JavaScript有庞大的库和强大的支持系统；当谈到用JavaScript实现时，我们经历了相当多的挣扎。别忘了表演！</p><p id="d08d" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">2017年，当WEB ASSEMBLY公布时，它是我们都在等待的解决方案。将C、C++等高级语言转换成机器代码，然后在浏览器上运行。听起来很神奇，不是吗？</p><p id="6f62" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">让我们深入了解它，看看它是什么。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><h2 id="924e" class="jv jw hh bd jx jy jz ka kb kc kd ke kf jb kg kh ki jf kj kk kl jj km kn ko kp bi translated"><strong class="ak">什么是WebAssembly？</strong></h2><p id="0878" class="pw-post-body-paragraph iq ir hh is b it kq iv iw ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn ha bi translated">WebAssembly是一种低级的类似汇编的语言，以接近本机的性能运行。它可以看起来像这样——50% web和50% assembly，这意味着它是一种用于现代web浏览器的汇编语言。用最简单的术语来说，我们可以将汇编语言定义为一组指令，这些指令被转换成机器代码并提供超快的性能。Web Assembly为Web带来了同样的功能。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kv"><img src="../Images/ca557e6d5b8d1cc8b960b5dd591035ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OxTY9Z2fPtEjvGalsXnb3w.png"/></div></div><figcaption class="il im et er es in io bd b be z dx"><a class="ae ip" href="https://www.youtube.com/watch?v=3sU557ZKjUs&amp;t=1106s" rel="noopener ugc nofollow" target="_blank">Compilation and Execution in Micro-Processors</a></figcaption></figure><p id="692a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">上图解释了高级语言代码如何在微处理器上执行。编写高级语言代码，编译并进一步转换成机器代码。然后，有一个抽象层，称为虚拟微处理器，它有自己的汇编语言，帮助代码在多个物理微处理器上运行。WebAssembly对于浏览器来说也是同样的思路。任何高级语言，如C/C++或C#，代码都可以编译成WebAssembly字节码，并创建一个所有主流浏览器都可以运行和使用的文件。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="ff15" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">既然有JavaScript，为什么还要web assembly</strong></p><p id="d093" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">JavaScript是一种非常强大的网络语言。历史上，网络平台只能加载JavaScript。它易于编码，易于阅读。它有一个庞大的生态系统，提供强大的库、框架和工具。</p><p id="7fad" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">尽管如此，JavaScript中还是有一些具有挑战性的角落。它在3D游戏、音乐应用、图像/视频编辑或虚拟和增强现实中存在一些严重的性能问题。除此之外，JavaScript文件在浏览器中执行之前需要下载、标记和解析。这个过程每次都会发生。是的，浏览器中有缓存，但这是一个影响浏览器中JavaScript性能的昂贵过程。</p><p id="5115" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">WebAssembly解决了这个问题。可以禁止在浏览器中执行文件之前的所有预处理。编译是将任何高级语言代码转换成紧凑二进制格式所需的唯一预处理。因此，这种接近本机的性能与JavaScript有很大不同。</p><p id="3b75" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">但是WebAssembly不是JavaScript的替代品。它旨在补充JavaScript，允许web开发人员同时使用两者。WebAssembly可以被认为是JavaScript中用于高效生成高性能函数的特性。WebAssembly JavaScript API提供了创建模块、内存、表和实例的能力。一个可以导入到另一个中，并可以调用另一个中定义的方法。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es le"><img src="../Images/a9603da49a88c5eeca00f253ccb4f6b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZHx-yqcXjxUWfZPmKJRAg.png"/></div></div><figcaption class="il im et er es in io bd b be z dx"><a class="ae ip" href="https://www.fortinet.com/blog/threat-research/webassembly-101-bringing-bytecode-to-the-web" rel="noopener ugc nofollow" target="_blank">Interaction between files</a></figcaption></figure><p id="f74c" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">以上是这些文件如何相互作用的一个基本例子。在目前的场景中，WebAssembly不具备与DOM交互的功能，因此使用JavaScript“粘合”代码来实现这一点。为了创建一个web组装模块，使用fetch并给出WASM文件的路径。然后，这个获取用于实例化流，流将异步检索模块。一旦模块被导入，就可以像JavaScript函数一样调用和使用方法。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="a8b6" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">JavaScript web assembly API</strong></p><p id="a8ac" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">以下是加载WASM文件并在浏览器中执行所需的必要API列表:</p><ol class=""><li id="4f63" class="lf lg hh is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated"><strong class="is hi"> fetch()浏览器API </strong> — fetch() API用于加载WASM文件网络资源。它回报承诺。</li></ol><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lo"><img src="../Images/08bb1549a083b980fc53f5144700c9e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*knn4WzuoTIScfEiY1oP8fw.png"/></div></div><figcaption class="il im et er es in io bd b be z dx"><a class="ae ip" href="https://gist.github.com/apoorva-11596/d6faa66f26f1bbb0dbf5c59c569fe46e" rel="noopener ugc nofollow" target="_blank">Source Link</a></figcaption></figure><p id="c05f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">2.<strong class="is hi">web assembly . compile(buffer)</strong>—用于编译从WASM文件中取出的模块细节。WASM文件中的代码必须转换成类型化数组或数组缓冲区，然后才能作为输入进行编译。这个API返回一个将编译模块的承诺。</p><p id="1f9d" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi"> 3。WebAssembly.instance </strong> —这个API将为您提供已编译模块的可执行实例，可以进一步执行该实例以获得输出。返回值将是一个带有可执行的导出函数数组的对象。</p><p id="aaad" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi"> 4。WebAssembly . instantiate streaming</strong>—这负责从给定的WASM代码中编译和实例化web assembly模块。它将返回一个承诺，包含模块和实例的详细信息。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="9caf" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">关键概念</strong></p><p id="cb6e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">组件</p><p id="06fb" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">它是文件中的一个字节代码，扩展名为WASM。它被浏览器编译成可执行的机器代码，具有导出的功能。它被认为是无状态的，因此可以在多个窗口和web workers之间共享。</p><p id="4d6a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">记忆</p><p id="c8c1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">WebAssembly中的内存是一个数组缓冲区，用于保存指令以二进制代码读写的数据。您可以使用JavaScript API web assembly . memory()来分配内存。</p><p id="abbc" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">桌子</p><p id="b70a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">它是一个可调整大小的类型化引用数组，驻留在WebAssembly内存之外，具有方法的地址。</p><p id="38ca" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">情况</p><p id="3932" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">实例是一个对象/模块，包含它在运行时使用的所有状态，包括内存、表和所有导入集。它是从JavaScript调用的，在浏览器内部执行。</p><p id="9041" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">堆垛机模型</p><p id="d223" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">WebAssembly使用堆栈机器模型来执行指令。在WASM，所有的指令都被压入堆栈。参数被弹出，结果被推回堆栈。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lp"><img src="../Images/4b4ad037441574e3b4cf78586a747315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ysEh5orNU6kjTd-GzxGItA.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Code</figcaption></figure><p id="0357" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">以上是文本格式的WASM代码示例。一切都存在于模块中。并且可以被认为是容器。可以使用“func”关键字语法来声明函数。例如，add函数将两个参数作为32位整数，并将它们的结果作为32位整数返回。要导出这些函数，使用“export”关键字。</p><p id="f9c6" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当执行行“local.get $a”时，它将获得传递给add函数的第一个参数，并放入堆栈。执行“local.get $b”时也会发生同样的情况。当调用add时，它将从堆栈中弹出两个值，将它们相加并将结果放回堆栈中。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="3f3f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">使用C/C++的WebAssembly】</strong></p><p id="e843" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">对于要用WebAssembly编译的C/C++代码，需要emscripten工具。它是一个低级虚拟机(LLVM ),获取从C/C++生成的字节码，并将其编译成可以在浏览器中高效执行的JavaScript</p><p id="7d6d" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">【Emscripten工具的设置:</p><p id="8d90" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">首先，克隆Emscripten工具的git repo并转到目录。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lo"><img src="../Images/197d5ff0781a359640092b95164d6d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4bZvT4DAnLw1I9LdaH45_A.png"/></div></div><figcaption class="il im et er es in io bd b be z dx"><a class="ae ip" href="https://gist.github.com/apoorva-11596/7b43b45280278a56c5a92ce9771545d8" rel="noopener ugc nofollow" target="_blank">Source Link</a></figcaption></figure><p id="931e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">运行以下命令，在当前终端中安装并激活路径和环境变量:</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lq"><img src="../Images/b0e6d58981d3184af01adb1cd71d7de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PApIcNO5s2FyX-ynkv35QA.png"/></div></div><figcaption class="il im et er es in io bd b be z dx"><a class="ae ip" href="https://gist.github.com/apoorva-11596/a7a85f5fdad20914d60f536c6b806fdc" rel="noopener ugc nofollow" target="_blank">Source Link</a></figcaption></figure><p id="23ad" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">【Hello World入门:</p><p id="8533" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">假设我们有这个示例C代码，它在屏幕上显示“Hello World ”,文件保存为helloWorld.c。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lr"><img src="../Images/bf6ace292b960353585bd38bcd059434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFMxHd2q92vNnp_DQF7uYw.png"/></div></div><figcaption class="il im et er es in io bd b be z dx"><a class="ae ip" href="https://gist.github.com/apoorva-11596/a60b7d0c570fe27acca9bc0caba19510" rel="noopener ugc nofollow" target="_blank">Source Link</a></figcaption></figure><p id="3158" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">对于编译，在激活了Emscripten工具路径的同一终端中，移动到C代码文件所在的路径，然后运行以下命令创建WASM文件:</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lq"><img src="../Images/c512d3024901edd3018c966e928bc935.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LxGxk7mz6qiJvtPzIK_iEQ.png"/></div></div><figcaption class="il im et er es in io bd b be z dx"><a class="ae ip" href="https://gist.github.com/apoorva-11596/5c160b90c9f8f3d8d8f88d64381d20eb" rel="noopener ugc nofollow" target="_blank">Source Link</a></figcaption></figure><p id="e4d3" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">命令参数被描述为:</p><p id="4db1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">1.-s WASM=1:这指定我们想要WASM输出</p><p id="0e83" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">2.-o helloWorld.html:这表明我们希望有一个HTML文件也能在浏览器和WASM模块上运行，并有JavaScript粘合代码来编译和实例化WASM，以便它能在web环境中使用</p><p id="6833" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">因此，运行此命令后，在您的当前目录中，将会创建三个新文件，其名称如下:</p><p id="5c45" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">1.二进制WASM模块代码:helloWorld.wasm</p><p id="b9d4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">2.一个JavaScript文件，包含可以与WebAssembly代码交互的胶水代码:helloWorld.js</p><p id="2167" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">3.在浏览器中加载、编译和显示输出的HTML文件:helloWorld.html</p><p id="4b92" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">注意</strong>:如果你只想要WASM文件，并希望编写你自己的HTML模板和JS文件，那么你可以使用这个命令:</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ls"><img src="../Images/8a6024f2a63f21efc2efe6b3954dc6ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9RyJmtXsIqmIyCjSNsSGQg.png"/></div></div><figcaption class="il im et er es in io bd b be z dx"><a class="ae ip" href="https://gist.github.com/apoorva-11596/70075eb3710a6be388a9b1b3d8ac92b8" rel="noopener ugc nofollow" target="_blank">Source Link</a></figcaption></figure><p id="e076" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">在浏览器上加载HTML:</strong></p><p id="3fac" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">HTML文件需要通过HTTP服务器才能加载到浏览器上，否则您会收到一条错误消息，指出异步和同步获取WASM失败。最简单的方法是在本地机器上安装python，在所有这些文件所在的目录下，运行以下命令，在端口8000上运行一个简单的python HTTP服务器:</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lr"><img src="../Images/db100a9c90ca6ef9a6dafca8dad3362c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eK3ZJGB8yePGWjBEFyw2qA.png"/></div></div><figcaption class="il im et er es in io bd b be z dx"><a class="ae ip" href="https://gist.github.com/apoorva-11596/9146121feb52b463aaf3a2134cb629a0" rel="noopener ugc nofollow" target="_blank">Source Link</a></figcaption></figure><p id="cfd4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">服务器启动后，打开浏览器，进入<a class="ae ip" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8000/。</a>你会看到该目录中的所有文件都列在那里；点击helloWorld.html。该文件将被加载到浏览器上，您可以看到“Hello World”打印在那里。</p><p id="58e1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">参考文献:</strong></p><p id="99a9" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">【https://developer.mozilla.org/en-US/docs/WebAssembly/ T4】</p><p id="9d43" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><a class="ae ip" href="https://emscripten.org/docs/getting_started/downloads.html" rel="noopener ugc nofollow" target="_blank">https://emscripten.org/docs/getting_started/downloads.html</a></p><p id="5731" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><a class="ae ip" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank">https://webassembly.org/</a></p><p id="9132" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><a class="ae ip" href="https://wasmbyexample.dev/home.en-us.html" rel="noopener ugc nofollow" target="_blank">https://wasmbyexample.dev/home.en-us.html</a></p></div></div>    
</body>
</html>