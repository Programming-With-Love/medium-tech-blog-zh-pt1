<html>
<head>
<title>A 30MB native image with Helidon to run REST based microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Helidon运行基于REST的微服务的30MB原生映像</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/a-30mb-native-image-with-helidon-to-run-rest-based-microservices-19c481fdda3c?source=collection_archive---------0-----------------------#2018-09-10">https://medium.com/oracledevs/a-30mb-native-image-with-helidon-to-run-rest-based-microservices-19c481fdda3c?source=collection_archive---------0-----------------------#2018-09-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c8c8f378e7a52b3a75b628b76fbdafad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5j1pdo9K-sPvxSuf_eBWOA.png"/></div></div></figure><p id="a73d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你一定听说过甲骨文公司的新成员——<a class="ae jn" href="https://helidon.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">海利登</strong> </a>。它是一个开源的Java框架，使人们能够使用函数式和反应式编程范式编写轻量级的微服务。人们可以使用Helidon简单而强大的核心反应式web服务器来快速构建云原生微服务。如果你喜欢用12个因素的方法写申请，Helidon可以满足你。Helidon的配置组件提供了多个选项来加载和配置您的应用程序——从加载属性或YAML文件到从Git等外部源加载。开箱即用的指标和跟踪，你问…你得到了！</p><p id="45dc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我将带着Helidon兜一圈，构建一个样例CRUD微服务，它将作为JSON REST API公开。然后，我们将使用<a class="ae jn" href="https://docs.oracle.com/javase/10/tools/jlink.htm" rel="noopener ugc nofollow" target="_blank"> jlink </a>创建一个可以运行我们的微服务的定制本地映像。本机映像消除了对完整JRE的需求。削减运行时的规模和减少攻击面是云部署中的重要因素。当然，这种方法有一些缺点，但是让我们改天再讨论。</p><p id="bd89" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将使用JPMS和格雷尔来建立我们的项目。下面是相关的gradle构建文件，用于将Helidon库添加为我们的项目依赖项:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="55e2" class="jx jy hh jt b fi jz ka l kb kc">plugins {<br/>    id "java"<br/>    id "com.zyxist.chainsaw" version "0.3.1"<br/>}</span><span id="5f2e" class="jx jy hh jt b fi kd ka l kb kc">sourceCompatibility = "10"</span><span id="8877" class="jx jy hh jt b fi kd ka l kb kc">dependencies {<br/>    compile "io.helidon.webserver:helidon-webserver:0.9.1"<br/>    compile "io.helidon.webserver:helidon-webserver-netty:0.9.1"<br/>    compile "io.helidon.webserver:helidon-webserver-json:0.9.1"<br/>}</span></pre><p id="6d7d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以根据您的应用需求从Helidon提供的库列表中挑选。对于我们的示例CRUD服务，我们只需要Netty支持的反应式web服务器和JSON支持。因为我们正在使用JPMS创建一个模块化jar，所以让我们创建一个“module-info”类，并指定我们的应用程序所需的模块:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="22ca" class="jx jy hh jt b fi jz ka l kb kc">module example.api {<br/>    requires io.helidon.webserver;<br/>    requires io.helidon.webserver.json;<br/>    requires org.glassfish.java.json;<br/>}</span></pre><p id="adc0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，虽然Helidon使用JPMS完全模块化，但一些底层库如Netty却不是。这种库依赖于自动模块解析。</p><p id="37ed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了这个设置，让我们创建一个启动器类来托管main方法:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0f57" class="jx jy hh jt b fi jz ka l kb kc">import io.helidon.webserver.Http;<br/>import io.helidon.webserver.Routing;<br/>import io.helidon.webserver.WebServer;<br/>...</span><span id="37b0" class="jx jy hh jt b fi kd ka l kb kc">public class Launcher {<br/><br/>    public static void main(String[] args) {<br/>        WebServer<br/>                .<em class="ke">create</em>(<em class="ke">createRouting</em>())<br/>                .start()<br/>                .thenAccept(ws -&gt; <br/>                        <em class="ke">logger</em>.info("Service running at: http://localhost:" + ws.port()));<br/>    }<br/><br/>    private static Routing createRouting() {<br/>        return Routing.<em class="ke">builder</em>()<br/>                // Add JSON support to all end-points<br/>                .register(JsonSupport.<em class="ke">get</em>())<br/>                .register("/api", new UserService())<br/>                // Global exception handler<br/>                .error(Exception.class, (req, res, ex) -&gt; {<br/>                    res.status(Http.Status.<em class="ke">BAD_REQUEST_400</em>).send();<br/>                })<br/>                .build();<br/>    }<br/>}</span></pre><p id="1a9d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是使用Helidon启动web服务器所需的全部内容。不需要应用程序容器，不需要部署war，也不需要调整XML文件。</p><p id="2585" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意我们是如何使用fluent routing builder类来注册JSON支持并在基本路径“/api”下添加子路由的。在Helidon世界中，可以使用“服务”创建子路线它们提供了一种组织端点和相关逻辑的方法。还可以使用处理程序来响应传入的请求。你可以在这里阅读更多关于路由和Helidon提供的各种APIs】。</p><p id="1ceb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要运行这个微服务，我们只需要运行main方法。如您所知，这可以通过多种方式实现——通过使用IDE进行快速开发和测试，通过使用maven或gradle等构建工具，或者通过手动打包jar并自己运行java命令。一旦您启动了微服务，您就可以使用curl或您最喜欢的REST客户端来执行GET、POST、PUT和DELETE操作，这些操作是在我们的示例用户服务端点上定义的。例如，如果您第一次执行GET，您将得到一个空列表:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1a2b" class="jx jy hh jt b fi jz ka l kb kc">curl -X GET <a class="ae jn" href="http://localhost:8080/api/users/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/api/users/</a><br/>{"items":[]}</span></pre><p id="3771" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如你所见，Helidon使得开发REST APIs和微服务变得非常容易。我们仅仅触及了表面。</p><p id="b0db" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了这个工作原型，让我们构建一个可以运行原型的定制JRE映像。JDK 9引入了一个叫做“jlink”的工具，可以用来构建定制的本地映像。但是有一个问题——应用程序使用的所有jar都应该使用JPMS进行模块化。它们不能依赖自动模块名。在现实世界中，这将是一个挑战。例如，正如我之前提到的，Netty jars不是JPMS意义上的模块化。然而，我们可以使用“jdeps”工具来找出JDK中的哪些模块正在被我们的应用程序jar使用，包括它们的依赖项(=运行时jar)，并且基于这些知识，我们可以构建一个定制的本地JRE映像。</p><p id="449f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设您将所有运行时jar放在当前工作目录中。您可以运行jdeps命令来打印特定jar使用的模块的概要:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="dbf3" class="jx jy hh jt b fi jz ka l kb kc"><em class="ke">jdeps --module-path . -s </em>user-crud-microservice.jar</span></pre><p id="86c4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">输出应该是这样的:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="712b" class="jx jy hh jt b fi jz ka l kb kc">example.user.api -&gt; io.helidon.webserver<br/>example.user.api -&gt; io.helidon.webserver.json<br/>example.user.api -&gt; java.base<br/>example.user.api -&gt; java.logging<br/>example.user.api -&gt; org.glassfish.java.json</span></pre><p id="28cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以递归地执行所有运行时jar的jdeps，并找到JDK的公共模块，它们显然是以“java”开头的。事实上，我们可以使用unix工具，如find、sed、sort和grep来半自动化这个过程。您可以在这里参考用于我们的示例服务<a class="ae jn" href="https://github.com/udaychandra/user-crud-microservice/blob/master/build.sh" rel="noopener ugc nofollow" target="_blank">的完整脚本。一旦我们获得了Java模块的最终列表，我们就可以使用jlink命令创建一个定制的本地映像:</a></p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="dc46" class="jx jy hh jt b fi jz ka l kb kc"># Add jdk.unsupported to allow netty to access internal classes<br/>jlink --module-path "${JAVA_HOME}/jmods" \<br/>    --add-modules jdk.unsupported"${JAVA_BASE_MODS}" \<br/>    --strip-debug \<br/>    --compress 2 \<br/>    --no-header-files \<br/>    --no-man-pages \<br/>    --output myimage</span></pre><p id="ce5d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从上面的命令中生成的本机映像的大小大约为25 MB(根据平台的不同，可能会略有不同)。我们可以使用这个本地映像运行我们的示例微服务。我们需要向java命令传递一些额外的选项，让它知道在哪里寻找我们的运行时模块，并指定主类:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="131f" class="jx jy hh jt b fi jz ka l kb kc">myimage/bin/java --upgrade-module-path ${DEPLOY_DIR}/mods -m example.user.api/example.user.api.Launcher</span></pre><p id="6480" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的示例微服务的运行时jar的大小大约是5 MB。因此，借助总计30 MB的内存，我们能够创建一个自包含的本地映像，该映像可以使用Helidon运行基于REST的微服务。相当酷！</p><p id="69cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当然，像我们所做的那样执行几个手动步骤对于现实世界的项目来说是不可行的。我希望围绕jdeps和jlink的工具变得更好。更好的是，如果所有开源库都提供jar的模块化版本，那么创建原生映像将轻而易举。</p><p id="d885" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以前往<a class="ae jn" href="https://github.com/udaychandra/user-crud-microservice" rel="noopener ugc nofollow" target="_blank"> Github </a>来克隆和使用示例项目。编码快乐！</p></div></div>    
</body>
</html>