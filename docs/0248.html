<html>
<head>
<title>#SmallerAPK, Part 2: Minifying code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">#SmallerAPK，第2部分:缩小代码</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/smallerapk-part-2-minifying-code-554560d2ed40?source=collection_archive---------2-----------------------#2016-02-19">https://medium.com/androiddevelopers/smallerapk-part-2-minifying-code-554560d2ed40?source=collection_archive---------2-----------------------#2016-02-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/16742a27007b85054b45771a39fbd376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6OvLVi-G5Ldze7Novm7M0w.jpeg"/></div></div></figure><div class=""/><p id="c4ab" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="#7d6e" rel="noopener ugc nofollow"> <strong class="ir ht">更新1 </strong> </a>:上传ProGuard映射播放</p><p id="b669" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这一章中，你会发现适用于几乎所有应用的建议。这一切都是为了保持你的代码库整洁，检查你的依赖关系，并为你提供帮助你完成这些任务的工具。</p><h1 id="ef81" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Dex代码精简</h1><p id="7506" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">你要做的第一件事是启用内置的迷你。它将尝试去除任何未使用的类和类成员，并使用较短的名称重命名任何标识符。这两种操作都会使结果代码变得更小，但是后者会使调试变得麻烦，所以我建议您只对您的<em class="kr">版本</em>构建类型启用缩小:</p><h2 id="8a5d" class="ks jp hs bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated">build.gradle</h2><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="10cf" class="ks jp hs ll b fi lp lq l lr ls">android {<br/>    ...<br/>    buildTypes {<br/>        release {<br/>            minifyEnabled true<br/>            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'<br/>        }<br/>    }<br/>}</span></pre><p id="ee3c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第二行以<a class="ae jn" href="http://proguard.sourceforge.net/manual/usage.html" rel="noopener ugc nofollow" target="_blank"> ProGuard rules </a>格式为minifier提供配置文件。第一个配置文件(<a class="ae jn" href="https://android.googlesource.com/platform/sdk/+/master/files/proguard-android.txt" rel="noopener ugc nofollow" target="_blank">Sdk/tools/proguard/proguard-android . txt</a>)包含在Sdk中，包含每个Android项目的一些相同的默认设置。查看这些规则可以帮助您熟悉Proguard配置语法。例如，这将保留(换句话说，防止被移除或重命名)视图子类中的任何setter或getter方法:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="55da" class="ks jp hs ll b fi lp lq l lr ls"># keep setters in Views so that animations can still work.<br/># see <a class="ae jn" href="http://proguard.sourceforge.net/manual/examples.html#beans" rel="noopener ugc nofollow" target="_blank">http://proguard.sourceforge.net/manual/examples.html#beans</a><br/>-keepclassmembers public class * extends android.view.View {<br/>    void set*(***);<br/>    *** get*();<br/>}</span></pre><p id="d2a7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">幸运的话，您的应用程序将在默认配置下工作。在构建过程中，一个名为AAPT的工具还会生成必要的规则，用于保留清单中提到的所有活动和其他组件，以及XML布局中使用的任何视图。库依赖应该通过<a class="ae jn" href="#8c00" rel="noopener ugc nofollow">消费者程序文件</a>提供他们的迷你配置，尽管有时他们只在他们的网站或手册上提供必要的程序规则。在这种情况下，您需要将它们复制到您的<em class="kr"> app/proguard-rules.pro </em>文件中。</p><p id="dc52" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不幸的是，经常会出现这样的情况，在启用缩小后，你的应用要么不能编译，要么在运行时中断，通常是通过抛出<em class="kr"> ClassNotFoundException </em>来处理被缩小器移除的类。要解决这个问题，您需要在您的<em class="kr"> app/ </em>文件夹中创建一个<em class="kr"> proguard-rules.pro </em>文件，并提供消除编译时警告所需的规则(查看消息日志以获取信息)。您还必须确保保留运行时使用的、但被minifier剥离的所有类和成员。这些通常是通过反射访问的代码部分。</p><p id="08b4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个具体的例子是当XML布局中的自定义属性将类名作为字符串时，例如设置一个<em class="kr"> RecyclerView </em>的<em class="kr"> layoutManager </em>:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="dc9d" class="ks jp hs ll b fi lp lq l lr ls">&lt;android.support.v7.widget.RecyclerView<br/>    app:layoutManager=”android.support.v7.widget.GridLayoutManager”<br/>    ...<br/>/&gt;</span></pre><p id="5c2d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种情况下，AAPT将无法计算出类的用法并生成必要的ProGuard规则。要应用修复，您应该在ProGuard配置中放入以下代码行，以防止<em class="kr"> GridLayoutManager </em>类及其任何公共和受保护的方法被移除或重命名:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="8a2a" class="ks jp hs ll b fi lp lq l lr ls">-keep public class android.support.v7.widget.GridLayoutManager {<br/>    public protected *;<br/>}</span></pre><p id="5154" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了检查您编写的配置规则是否达到了预期的效果，您可以使用类似于<a class="ae jn" href="#0643" rel="noopener ugc nofollow"> ClassyShark </a>的工具检查结果APK中的<em class="kr"> classes.dex </em>文件。彻底测试你的应用程序也很重要！应用程序打开而不崩溃的事实并不表明微型配置是正确的。你<strong class="ir ht">必须</strong>测试你应用程序中的每一个屏幕和用户流是否崩溃。(我可以建议查看一下<a class="ae jn" href="https://google.github.io/android-testing-support-library/" rel="noopener ugc nofollow" target="_blank"> Android测试支持库和Espresso </a>吗？:)</p><h1 id="7d6e" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">上传要播放的ProGuard映射</h1><p id="bfc1" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">直到最近，分析用户设备上运行的混淆代码抛出的异常还是有点不方便的。通常，您必须从Play Developer Console复制stacktrace，并使用计算机上的工具和编译时生成的ProGuard映射文件来解码原始的类和方法名。</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lt"><img src="../Images/73e3a9623adb877cc801a6788f797d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3h-9CmwDuPv-sURh4Bx85w.png"/></div></div></figure><p id="e7ba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">游戏开发者控制台现在可以选择<a class="ae jn" href="https://support.google.com/googleplay/android-developer/answer/6295281" rel="noopener ugc nofollow" target="_blank">上传映射文件</a>和你的APK，并且会在崩溃和ANRs面板显示去模糊的堆栈轨迹。请记住，您使用的映射文件必须来自与您的发布APK完全相同的编译运行。</p><blockquote class="lu lv lw"><p id="12bd" class="ip iq kr ir b is it iu iv iw ix iy iz lx jb jc jd ly jf jg jh lz jj jk jl jm ha bi translated"><strong class="ir ht">注意</strong>:你会在你的项目文件夹下找到mappings.txt文件，路径:&lt;模块&gt;/build/outputs/mapping/mapping . txt</p></blockquote><h1 id="8c00" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">库的ProGuard配置</h1><p id="3e60" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">如果您正在构建一个AAR库，用于需要ProGuard规则工作的其他项目，您应该使用<em class="kr"> consumerProguardFiles </em>选项将一个ProGuard配置文件与AAR打包在一起。这样，任何使用你的库的人都不必担心在启用minifier时手动添加规则。在使用手册中的库编译项目时，也要确保提供关于任何其他需求的信息。</p><h2 id="b0d6" class="ks jp hs bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated">build.gradle</h2><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="054d" class="ks jp hs ll b fi lp lq l lr ls">android {<br/>    ...<br/>    defaultConfig {<br/>        consumerProguardFiles “proguard-rules.txt”<br/>    }<br/>}</span></pre><h1 id="f104" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">为Google Play服务使用粒度依赖性</h1><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/f15e5a349a79c47c28734d33e5e0c02a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nmsWPigHxVnyPfHO."/></div></div></figure><p id="a0c4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在项目中使用Google Play服务库时，记得切换到粒度依赖。这意味着，如果你只是使用广告、地图或GCM等几个功能，你就不会把整个客户端库都拉进来。这里有一个表格，里面有你可以在<a class="ae jn" href="https://developers.google.com/android/guides/setup" rel="noopener ugc nofollow" target="_blank">developers.google.com</a>上使用的所有Gradle依赖字符串。顺便说一句，ProGuard消费者规则包含在Play服务中，所以如果您为您的版本启用了代码精简器，它们应该可以正常工作。</p><h1 id="fb5d" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">追踪依赖关系</h1><p id="a835" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">为Android开发的好处是，如果你有问题，可能有人已经解决了。随着项目的增长，您通常会引入越来越多的外部依赖来加快开发时间。最常见的可能是向后兼容的Android支持库、Play服务、图像加载库、HTTP客户端和各种其他SDKs</p><p id="dd48" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">开发人员经常问我:我应该使用哪个图像库？多少依赖项对我的项目来说太多了？这些问题没有确定的答案。如果你真的需要使用一个库，因为它可以解决你的问题(并且你知道它的缺点)，那么就去用吧。重要的是要有合适的工具来帮助你决定它将对你的项目规模产生什么样的影响，这样你才能做出明智的决定。</p><h1 id="92cd" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">可传递的库依赖</h1><p id="6d5b" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">当你认为你“只是”添加了一个小的帮助器库，突然你的索引大小爆炸了，你的方法数飙升了，那可能是因为你通常在你的<em class="kr"> build.gradle </em>文件中看不到的传递依赖。幸运的是，有一些工具可以提供帮助:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5015" class="ks jp hs ll b fi lp lq l lr ls">$ ./gradlew app:dependencies</span><span id="a3d0" class="ks jp hs ll b fi mb lq l lr ls">...</span><span id="b08f" class="ks jp hs ll b fi mb lq l lr ls">compile — Classpath for compiling the main sources.<br/>+ — — com.android.support:appcompat-v7:23.1.1<br/>| \ — — com.android.support:support-v4:23.1.1<br/>| \ — — com.android.support:support-annotations:23.1.1<br/>+ — — com.android.support:cardview-v7:23.1.1<br/>+ — — com.android.support:design:23.1.1<br/>| + — — com.android.support:appcompat-v7:23.1.1 (*)<br/>| + — — com.android.support:recyclerview-v7:23.1.1<br/>| | + — — com.android.support:support-annotations:23.1.1<br/>| | \ — — com.android.support:support-v4:23.1.1 (*)<br/>| \ — — com.android.support:support-v4:23.1.1 (*)<br/>+ — — com.android.support:recyclerview-v7:23.1.1 (*)<br/>\ — — com.android.support.test.espresso:espresso-idling-resource:2.2.1</span></pre><p id="b310" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kr">&lt;modulename&gt;:dependencies</em>命令给出了项目中每个库及其依赖树的概述。版本号旁边的星号(*)告诉您，这个特定的依赖项以前已经在输出中提到过，所以它无论如何都会包含在您的项目中，除非您删除它的所有其他实例。</p><blockquote class="lu lv lw"><p id="6339" class="ip iq kr ir b is it iu iv iw ix iy iz lx jb jc jd ly jf jg jh lz jj jk jl jm ha bi translated"><strong class="ir ht">注意</strong>:如果您正在使用产品风格，并且您只需要一个用于您的应用程序的某些变体的库(例如，一个仅用于免费版本的Ads SDK)，您可以指定以您的风格名称为前缀的依赖项，例如<br/>依赖项{ freeCompile '…' }。</p></blockquote><h1 id="0643" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">用ClassyShark检查Dex文件</h1><p id="03ad" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">有时，为了保护开发人员免受版本冲突的影响，一个库将它的依赖项直接包含在它的代码中，但是使用了一个改变的包名，本质上是隐藏了原来的包名。这也意味着你不会在Gradle依赖树中看到这种依赖。</p><p id="5d63" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您想更好地查看您的APK中打包的确切的类和包名，您可以使用<a class="ae jn" href="https://github.com/google/android-classyshark" rel="noopener ugc nofollow" target="_blank"> ClassyShark </a>来检查您的Dex文件。这也有助于测试您的ProGuard规则，了解它们对最终APK的确切影响。</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mc"><img src="../Images/dd759d52be3dd32e169bf8d09c6e3939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icrlDNJPYDaqb0QuUDV_fw.png"/></div></div></figure><blockquote class="lu lv lw"><p id="9b47" class="ip iq kr ir b is it iu iv iw ix iy iz lx jb jc jd ly jf jg jh lz jj jk jl jm ha bi translated"><strong class="ir ht">注意</strong>:作为奖励，ClassyShark将显示包的方法计数，这可能有助于您识别最大的多索引违规者。</p></blockquote></div><div class="ab cl md me go mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ha hb hc hd he"><p id="76f1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">继续阅读<a class="ae jn" rel="noopener" href="/@wkalicinski/smallerapk-part-3-removing-unused-resources-1511f9e3f761">第3部分:移除未使用的资源</a></p></div></div>    
</body>
</html>