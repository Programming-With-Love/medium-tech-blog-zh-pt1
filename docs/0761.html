<html>
<head>
<title>Composable Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可组合函数</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/composable-functions-a505ab20b523?source=collection_archive---------0-----------------------#2022-09-22">https://medium.com/androiddevelopers/composable-functions-a505ab20b523?source=collection_archive---------0-----------------------#2022-09-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/52145c9370bb785e22eb90da1e9e801a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jPVPY4GjPRK3prnJ2o09cQ.png"/></div></figure><p id="01d9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在之前的MAD Skills Compose Basics <a class="ae jj" rel="noopener" href="/androiddevelopers/thinking-in-compose-c4ef150bb7cf">文章</a>中，您学习了如何在Compose中思考——您在Kotlin中将您的UI描述为函数。不需要更多的XML！在本文中，我们将深入研究这些函数，以及如何用它们来构建UI。</p><blockquote class="jk jl jm"><p id="9c21" class="il im jn in b io ip iq ir is it iu iv jo ix iy iz jp jb jc jd jq jf jg jh ji ha bi translated">提醒一下，我们将在10月13日的现场问答环节中回答您关于作曲基础的问题。请务必在这里、YouTube或Twitter上使用#MADCompose标签发表评论。</p></blockquote><p id="b006" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了理解这些函数是如何工作的，让我们看看如何构建<a class="ae jj" href="https://github.com/android/compose-samples/tree/main/Jetsurvey" rel="noopener ugc nofollow" target="_blank"> Jetsurvey </a>的单选问题屏幕，这是我们的<a class="ae jj" href="http://goo.gle/compose-samples" rel="noopener ugc nofollow" target="_blank">撰写示例</a>之一。</p><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es jr"><img src="../Images/bff620912ceb55b668b82f2fc497a2a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*g6LYEO6Or2nB5_EkoK5vJA.png"/></div></figure><p id="3d07" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你可以在这里观看本文的视频:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><h1 id="6c33" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">简单的可组合函数</h1><p id="4aaf" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">调查中的单个答案可以编写为包含一行图像、文本和单选按钮的函数。</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="70ed" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要在Compose中创建UI组件，我们必须用<strong class="in hi"> </strong> <code class="du lc ld le lf b"><strong class="in hi">@Composable</strong></code>注释来注释函数。这个注释告诉Compose编译器，这个函数的目的是将数据转换成UI，从而将答案转换成UI。</p><p id="9b70" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">带有该注释的函数也被称为<strong class="in hi">可组合</strong> <strong class="in hi">函数</strong>，或简称为composables。这些函数是Compose中UI的构建块。添加这个注释很快也很容易，它鼓励您将UI组织成一个可重用的元素库。</p><p id="0853" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，要实现一个可供选择的可能答案列表，我们可以定义一个名为<code class="du lc ld le lf b">SingleChoiceQuestion</code>的新函数，它接受一个答案列表，然后调用我们刚刚定义的<code class="du lc ld le lf b">SurveyAnswer</code>函数。</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="3e77" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><code class="du lc ld le lf b">SingleChoiceQuestion</code>接受允许由应用程序逻辑配置的参数。在这种情况下，它接受一个可能答案的列表，以便可以向UI显示这些选项。注意，composable不返回任何东西(它返回‘unit ’),而是发出UI 。具体来说，它发出了<code class="du lc ld le lf b">Column</code>布局composable，这是垂直排列项目的Compose toolkit的一部分。在该列中，它为每个答案发出一个可组合的<code class="du lc ld le lf b">SurveyAnswer</code>。</p><p id="8c5b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">组件是不可变的。您不能保存对它们的引用—就像保存对单个答案的引用一样—然后更新其内容。当你调用它的时候，你需要传递所有的信息作为参数。</p><p id="2652" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">注意，由于函数是用Kotlin编写的，我们可以使用完整的Kotlin语法和控制流来生成我们的UI。这里我们使用<code class="du lc ld le lf b">forEach</code>来遍历每个答案，并调用<code class="du lc ld le lf b">SurveyAnswer</code>来显示它们。如果我们想有条件地显示其他内容，那么使用If语句就很简单。不需要<code class="du lc ld le lf b">View.visibility = View.GONE</code>或<code class="du lc ld le lf b">View.INVISIBLE</code>。对于像Compose这样的声明式UI框架，如果您希望您的UI根据所提供的输入而有不同的外观，那么composable必须描述您的UI对于每个可能的输入值应该是什么样子。使用类似下面代码片段的条件语句可以实现这一点。</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="76bc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">组件必须<strong class="in hi">快速且无副作用</strong>。当用同一个参数多次调用它时，它的行为必须相同，并且它不应该修改属性或全局变量。我们说具有这种性质的函数是<em class="jn">幂等的</em>。该属性对于所有组件都是必需的，以便在用新值重新调用函数时可以正确发出UI。</p><p id="1adf" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">注意，提供给函数<strong class="in hi">的参数完全由</strong> <strong class="in hi">控制UI </strong>。这就是我们所说的将状态转化为UI。函数中的逻辑将保证UI永远不会失去同步。如果答案列表发生变化，那么通过再次执行该函数并在必要时重新绘制UI，从新的答案列表中生成一个新的UI。</p><p id="ee0c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这个在状态改变时重新生成UI的过程叫做<strong class="in hi">重组。</strong>由于组合是不可变的，重组是用新状态更新UI的机制。</p><h1 id="5cbb" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">可组合函数的重组和状态</h1><p id="f64c" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">当用不同的函数参数重新调用一个可组合函数时，就会发生重组。发生这种情况是因为状态函数依赖于变化。</p><p id="ceb6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，假设<code class="du lc ld le lf b">SurveyAnswer</code>组件接受一个参数<code class="du lc ld le lf b">isSelected</code>，该参数决定答案是否被选中。最初，没有选择答案:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="d105" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在视图世界中，通过点击其中一个答案UI元素进行交互会在视觉上切换它，因为视图拥有自己的状态。然而，在Compose世界中，因为<strong class="in hi"> false </strong>被提供给所有的<code class="du lc ld le lf b">SurveyAnswer</code> composables，所以尽管用户交互，所有的答案都将保持未被选择。为了使它们在视觉上响应用户交互，需要重新组合可组合组件，以便可以用新的状态重新生成UI。</p><p id="1428" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为此，需要引入一个新的变量来保存所选的答案。此外，变量需要是一个<code class="du lc ld le lf b"><a class="ae jj" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState" rel="noopener ugc nofollow" target="_blank">MutableState</a></code>——一个集成在Compose运行时中的可观察类型。对状态的任何更改都会自动为读取它的任何组件安排一个重组。可以用<code class="du lc ld le lf b"><a class="ae jj" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#mutableStateOf(kotlin.Any,androidx.compose.runtime.SnapshotMutationPolicy)" rel="noopener ugc nofollow" target="_blank">mutableStateOf</a></code>方法创建一个新的<code class="du lc ld le lf b">MutableState</code>，如下所示:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="4918" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">请注意，在上面的代码片段中，<code class="du lc ld le lf b">isSelected</code>的值已经更新，以便将当前答案与<code class="du lc ld le lf b">selectedAnswer</code>进行比较。由于<code class="du lc ld le lf b">selectedAnswer</code>属于<code class="du lc ld le lf b">MutableState</code>类型，我们必须使用value属性来获取所选答案。当该值改变时，Compose将自动重新执行<code class="du lc ld le lf b">SurveyAnswer</code>，以便突出显示所选答案。</p><p id="63fa" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然而，上面的片段不太适用。需要在整个重组过程中记住<code class="du lc ld le lf b">selectedAnswer</code>的值，以便在<code class="du lc ld le lf b">SingleChoiceQuestion</code>被重新调用时不会被覆盖。为了解决这个问题，<code class="du lc ld le lf b">mutableStateOf</code>调用应该在一个调用中执行。这保证了当可组合重新组合时，该值被记住，而不是被重置。为了记住配置变化的值，我们也可以使用<code class="du lc ld le lf b">rememberSaveable</code>:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="c5b0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">通过在<code class="du lc ld le lf b">selectedAnswer</code>变量上使用Kotlin的delegated property语法，可以进一步细化上面的代码片段。这样会将类型从<code class="du lc ld le lf b">MutableState&lt;Answer?&gt;</code>更改为简单的<code class="du lc ld le lf b">Answer?</code>。这种语法非常好，因为我们可以直接处理底层状态的值——不再需要调用<code class="du lc ld le lf b">MutableState</code>对象的<code class="du lc ld le lf b">value</code>属性:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="2577" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用我们新引入的状态，我们可以为<code class="du lc ld le lf b">onAnswerSelected</code>参数传递一个lambda函数，这样我们就可以在用户做出选择时执行一个操作。在这个lambda的定义中，我们可以将<code class="du lc ld le lf b">selectedAnswer</code>的值设置为新值:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="6b07" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您还记得上一篇文章，事件是状态更新的机制。这里，当用户通过点击答案进行交互时，将调用事件<code class="du lc ld le lf b">onAnswerSelected</code>。</p><p id="e507" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Compose运行时自动跟踪状态读取发生的位置，以便它可以智能地重新组合依赖于该状态的可组合组件。因此，<strong class="in hi">你不需要显式地观察状态，或者手动更新UI </strong>。</p><h1 id="e043" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">组件的行为和属性</h1><p id="4354" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">您还应该知道可组合函数的其他一些行为属性。由于这些行为，<strong class="in hi">重要的是，您的可组合函数没有副作用，并且在使用相同的参数</strong>多次调用时表现相同。</p><ol class=""><li id="2151" class="lg lh hh in b io ip is it iw li ja lj je lk ji ll lm ln lo bi translated"><a class="ae jj" href="https://developer.android.com/jetpack/compose/mental-model#any-order" rel="noopener ugc nofollow" target="_blank">组件可以以任何顺序执行</a></li></ol><p id="9b31" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">查看下面的代码片段，您可能会认为代码是按顺序运行的。但这不一定是真的。Compose可以识别出某些UI元素比其他元素优先级高，因此这些元素可能会先被绘制。比方说，您有一段代码，它在一个选项卡布局中绘制了三个屏幕。您可能会假设首先执行<code class="du lc ld le lf b">StartScreen</code>，但是，这些执行可以以任何顺序发生。</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="52db" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">2.<a class="ae jj" href="https://developer.android.com/jetpack/compose/mental-model#parallel" rel="noopener ugc nofollow" target="_blank">可组合功能可以并行运行</a></p><p id="aa5c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Composables可以并行运行，从而利用多个内核来提高屏幕的渲染性能。在下面的代码片段中，代码运行时没有副作用，并将输入列表转换为UI。</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="59cb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">但是，如果函数写入局部变量，比如下面的代码片段，代码就不再被认为是没有副作用的。做类似于下面代码的事情可能会导致你的用户界面出现奇怪的行为。</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="fb02" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">3.<a class="ae jj" href="https://developer.android.com/jetpack/compose/mental-model#skips" rel="noopener ugc nofollow" target="_blank">尽可能重组跳过</a></p><p id="0463" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Compose尽力只重组UI中需要更新部分。如果一个可组合不使用触发重组的状态，那么它将被跳过。在代码片段中，如果名称字符串发生变化，那么<code class="du lc ld le lf b">Header</code>和<code class="du lc ld le lf b">Footer</code>组合将不会被重新执行，因为它不依赖于那个状态。</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="7231" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">4.<a class="ae jj" href="https://developer.android.com/jetpack/compose/mental-model#optimistic" rel="noopener ugc nofollow" target="_blank">重组乐观</a></p><p id="acc5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">重组是乐观的—这意味着Compose期望在参数再次改变之前完成重组。如果某个参数在重组完成之前发生了更改，Compose可能会取消重组，并使用新参数重新启动它。</p><p id="818a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">5.<a class="ae jj" href="https://developer.android.com/jetpack/compose/mental-model#frequent" rel="noopener ugc nofollow" target="_blank">可组合功能可能会频繁运行</a></p><p id="8a9c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">最后，可组合函数可能会频繁运行。如果您的可组合函数包含需要为每一帧执行的动画，可能会出现这种情况。这就是为什么确保可组合函数快速运行以避免丢帧是很重要的。</p><p id="bd8d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果需要执行长时间运行的操作，不要在composable函数中执行，而是在UI线程之外执行，并且只使用composable函数中的结果。</p><h1 id="1d35" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">摘要</h1><p id="7bef" class="pw-post-body-paragraph il im hh in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">我们涵盖了很多！总结一下:</p><ul class=""><li id="da52" class="lg lh hh in b io ip is it iw li ja lj je lk ji lp lm ln lo bi translated">您可以使用<code class="du lc ld le lf b">@Composable </code>注释来创建可组合的函数</li><li id="a9fd" class="lg lh hh in b io lq is lr iw ls ja lt je lu ji lp lm ln lo bi translated">创建composables既快速又简单，鼓励您将UI组织成一个可重用组件库。</li><li id="f486" class="lg lh hh in b io lq is lr iw ls ja lt je lu ji lp lm ln lo bi translated">组件可以也应该接受参数来配置它们的行为</li><li id="b3ee" class="lg lh hh in b io lq is lr iw ls ja lt je lu ji lp lm ln lo bi translated"><strong class="in hi"> MutableState，remember </strong>和<strong class="in hi"> rememberSaveable </strong>可用于存储组件的状态，并让Compose自动跟踪和重新编写更改</li><li id="4c2c" class="lg lh hh in b io lq is lr iw ls ja lt je lu ji lp lm ln lo bi translated">成分应该是无副作用的</li></ul><p id="ef6b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们还学习了一些有趣的组合属性。组件可以:</p><ul class=""><li id="a85f" class="lg lh hh in b io ip is it iw li ja lj je lk ji lp lm ln lo bi translated">以任何顺序执行</li><li id="75fe" class="lg lh hh in b io lq is lr iw ls ja lt je lu ji lp lm ln lo bi translated">并行运行</li><li id="8798" class="lg lh hh in b io lq is lr iw ls ja lt je lu ji lp lm ln lo bi translated">被跳过</li><li id="3536" class="lg lh hh in b io lq is lr iw ls ja lt je lu ji lp lm ln lo bi translated">经常跑步</li></ul><p id="73be" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Compose toolkit提供了许多基础的、强大的组件，帮助您构建漂亮的应用程序。这就是我们接下来要讨论的内容。如果您想提前了解，请查看以下资源:</p><ul class=""><li id="68b5" class="lg lh hh in b io ip is it iw li ja lj je lk ji lp lm ln lo bi translated"><a class="ae jj" href="https://developer.android.com/codelabs/jetpack-compose-layouts" rel="noopener ugc nofollow" target="_blank">构成中的基本布局</a></li><li id="790e" class="lg lh hh in b io lq is lr iw ls ja lt je lu ji lp lm ln lo bi translated"><a class="ae jj" href="https://developer.android.com/codelabs/jetpack-compose-theming" rel="noopener ugc nofollow" target="_blank"> Jetpack撰写主题</a></li><li id="4f6f" class="lg lh hh in b io lq is lr iw ls ja lt je lu ji lp lm ln lo bi translated"><a class="ae jj" href="https://developer.android.com/jetpack/compose/themes" rel="noopener ugc nofollow" target="_blank">构图中的主题化</a></li><li id="c29e" class="lg lh hh in b io lq is lr iw ls ja lt je lu ji lp lm ln lo bi translated"><a class="ae jj" href="http://goo.gle/compose-samples" rel="noopener ugc nofollow" target="_blank">合成样本</a></li></ul><p id="43a1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">有什么问题吗？请在下面留下评论或使用Twitter上的#MADCompose标签，我们将在10月13日的直播问答中回答您的问题。敬请期待！</p></div><div class="ab cl lv lw go lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ha hb hc hd he"><p id="a649" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">不是所有用<code class="du lc ld le lf b">@Composable</code>标注的函数都返回UI。例如，调用<code class="du lc ld le lf b">remember</code>的函数不会返回UI，但是，它们会在编写UI树中产生一个节点。</p></div></div>    
</body>
</html>