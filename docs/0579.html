<html>
<head>
<title>Data classes — the classy way to hold data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据类——保存数据的经典方式</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/data-classes-the-classy-way-to-hold-data-ab3b11ea4939?source=collection_archive---------3-----------------------#2020-11-03">https://medium.com/androiddevelopers/data-classes-the-classy-way-to-hold-data-ab3b11ea4939?source=collection_archive---------3-----------------------#2020-11-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f1f064469350b2336414178de85f7e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0QJqxE7mPdvAWzGCdat6g.png"/></div></div></figure><div class=""/><div class=""><h2 id="3283" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">科特林词汇:数据类</h2></div><p id="a417" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">一只小狗有一个名字，一个品种和一大堆可爱之处。要建模一个只保存数据的类，您应该使用一个<code class="du kd ke kf kg b">data class</code>。编译器通过自动生成<code class="du kd ke kf kg b">toString()</code>、<code class="du kd ke kf kg b">equals()</code>和<code class="du kd ke kf kg b">hashCode()</code>来简化您的工作，并提供开箱即用的<a class="ae kh" rel="noopener" href="/androiddevelopers/breaking-down-destructuring-declarations-e21334ac1e9">析构</a>和复制功能，让您专注于需要表示的数据。请继续阅读，了解更多关于数据类的其他优点、它们的限制，并了解它们是如何实现的。</p><h1 id="6c11" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">使用概述</h1><p id="0a85" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">若要声明数据类，请使用data修饰符，并将类的属性指定为构造函数中的val或var参数。与任何函数或构造函数一样，您也可以提供默认参数，您可以直接访问和修改属性，并在您的类中定义函数。</p><p id="9d06" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">但是，与普通课程相比，你有几个优势:</p><ul class=""><li id="8025" class="lf lg hs jj b jk jl jn jo jq lh ju li jy lj kc lk ll lm ln bi translated"><code class="du kd ke kf kg b"><strong class="jj ht">toString()</strong></code> <strong class="jj ht">、</strong> <code class="du kd ke kf kg b"><strong class="jj ht">equals()</strong></code> <strong class="jj ht">和</strong> <code class="du kd ke kf kg b"><strong class="jj ht">hashCode()</strong></code> <strong class="jj ht">由Kotlin编译器为您实现</strong>，避免了一系列可能导致bug的人为小错误:比如每次添加或更新属性时忘记更新它们、实现<code class="du kd ke kf kg b">hashCode</code>时出现逻辑错误、在实现<code class="du kd ke kf kg b">equals</code>时忘记实现<code class="du kd ke kf kg b">hashCode</code>等等。</li><li id="048a" class="lf lg hs jj b jk lo jn lp jq lq ju lr jy ls kc lk ll lm ln bi translated"><strong class="jj ht">破坏</strong></li><li id="e619" class="lf lg hs jj b jk lo jn lp jq lq ju lr jy ls kc lk ll lm ln bi translated"><strong class="jj ht">通过调用<code class="du kd ke kf kg b">copy()</code>方法复制</strong>的简易性:</li></ul><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><h1 id="dbd0" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">限制</h1><p id="27a8" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">数据类有一系列的限制。</p><h1 id="d969" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">构造函数参数</h1><p id="6fbc" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">数据类是作为数据容器创建的。要执行这个角色，您必须向主构造函数传递至少一个参数，这些参数需要是<code class="du kd ke kf kg b"><strong class="jj ht">val</strong></code> <strong class="jj ht">或</strong> <code class="du kd ke kf kg b"><strong class="jj ht">var</strong></code> <strong class="jj ht"> </strong> <a class="ae kh" href="https://kotlinlang.org/docs/reference/properties.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jj ht">属性</strong> </a>。试图在没有<code class="du kd ke kf kg b">val</code> / <code class="du kd ke kf kg b">var</code>的情况下添加参数会导致编译错误。</p><p id="7889" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">作为最佳实践，考虑使用<code class="du kd ke kf kg b">val</code> s而不是<code class="du kd ke kf kg b">var</code> s，以提高不变性。否则，可能会出现微妙的问题，例如当使用数据类作为<code class="du kd ke kf kg b">HashMap</code>对象的键时，因为当<code class="du kd ke kf kg b">var</code>值改变时，容器可能会进入无效状态。</p><p id="d653" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">类似地，试图在主构造函数中添加一个<code class="du kd ke kf kg b">vararg</code>参数也会导致编译错误:</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="e137" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">由于<code class="du kd ke kf kg b">equals()</code>在JVM上对数组和集合的工作方式，不允许使用<code class="du kd ke kf kg b">vararg</code>。安德烈·布雷斯拉夫<a class="ae kh" href="https://blog.jetbrains.com/kotlin/2015/09/feedback-request-limitations-on-data-classes/" rel="noopener ugc nofollow" target="_blank">解释道</a>:</p><blockquote class="lz ma mb"><p id="68b2" class="jh ji mc jj b jk jl it jm jn jo iw jp md jr js jt me jv jw jx mf jz ka kb kc ha bi translated">集合在结构上是比较的，而数组不是，对它们来说，<code class="du kd ke kf kg b">equals()</code>简单地诉诸于引用相等:this <code class="du kd ke kf kg b">===</code> other。</p></blockquote><h1 id="483d" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">遗产</h1><p id="d9f9" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">数据类可以从接口、抽象类和类继承，但不能从其他数据类继承。数据类也不能标记为<code class="du kd ke kf kg b">open</code>。比如添加<code class="du kd ke kf kg b">open</code>会导致错误:<code class="du kd ke kf kg b">Modifier ‘open’ is incompatible with ‘data’</code>。</p><h1 id="3d19" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">在后台</h1><p id="4503" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">让我们检查一下Kotlin到底生成了什么，以便能够理解这些特性是如何实现的。为此，我们将查看Java反编译代码:工具-&gt; Kotlin -&gt;显示Kotlin字节码，然后按下反编译按钮。</p><h1 id="e2d1" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">性能</h1><p id="f7a0" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">与常规类一样，<code class="du kd ke kf kg b">Puppy</code>是一个<code class="du kd ke kf kg b"> public final class</code>，包含我们定义的属性以及它们的getters和setters:</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><h1 id="00e9" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">构造者</h1><p id="4fbf" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">生成了我们定义的构造函数。因为我们在构造函数中使用了一个默认参数，所以我们也得到第二个合成构造函数。</p><p id="0c7f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要了解关于默认参数和生成代码的更多信息，请查看这篇博文。</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><h1 id="94e9" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">toString()，hashCode()，等于()</h1><p id="eb17" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">Kotlin生成<code class="du kd ke kf kg b">toString()</code>、<code class="du kd ke kf kg b">hashCode()</code>和<code class="du kd ke kf kg b">equals()</code>方法。当您修改数据类、更新属性时，会自动为您生成正确的方法实现。这样你就知道<code class="du kd ke kf kg b">hashCode()</code>和<code class="du kd ke kf kg b">equals()</code>永远不会不同步。下面是他们如何寻找我们的<code class="du kd ke kf kg b">Puppy</code>类:</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="1d81" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">虽然<code class="du kd ke kf kg b">toString</code>和<code class="du kd ke kf kg b">hashCode</code>非常简单，看起来就像你实现它的方式，但是equals使用了执行结构等式的<code class="du kd ke kf kg b"><a class="ae kh" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/Intrinsics.java#L166" rel="noopener ugc nofollow" target="_blank">Intrinsics.areEqual</a></code>:</p><pre class="lt lu lv lw fd mg kg mh mi aw mj bi"><span id="63a3" class="mk kj hs kg b fi ml mm l mn mo">public static boolean areEqual(Object first, Object second) {<br/>    return first == null ? second == null : first.equals(second);<br/>}</span></pre><p id="3f1a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">通过使用方法调用而不是直接实现，Kotlin语言开发人员获得了更多的灵活性，因为如果需要，他们可以在未来的语言版本中更改areEqual的实现。</p><h1 id="1be3" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">成分</h1><p id="8697" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">为了支持析构，数据类生成只返回一个字段的<code class="du kd ke kf kg b">componentN()</code>方法。组件号遵循构造函数参数的顺序:</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="d43a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">从我们的<a class="ae kh" rel="noopener" href="/androiddevelopers/breaking-down-destructuring-declarations-e21334ac1e9">科特林词汇贴</a>中找到更多关于析构的信息。</p><h1 id="68ac" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">复制</h1><p id="7935" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">数据类生成一个<code class="du kd ke kf kg b">copy()</code>方法，可用于创建对象的新实例，保留0或更多的初始值。您可以将<code class="du kd ke kf kg b">copy()</code>看作一个方法，它获取数据类的所有字段作为参数，字段的值作为默认值。了解了这些，你就不会惊讶Kotlin生成2个<code class="du kd ke kf kg b">copy()</code>方法:<code class="du kd ke kf kg b">copy</code>和<code class="du kd ke kf kg b">copy$default</code>。后者是一种合成方法，确保当没有为参数传入值时，使用基类中的正确值:</p><figure class="lt lu lv lw fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><h1 id="e7c4" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">结论</h1><p id="8ee5" class="pw-post-body-paragraph jh ji hs jj b jk la it jm jn lb iw jp jq lc js jt ju ld jw jx jy le ka kb kc ha bi translated">数据类是最常用的Kotlin特性之一，有一个很好的理由——它们减少了您需要编写的样板代码，支持像析构和复制对象这样的特性，并让您专注于重要的东西:您的应用程序。</p></div></div>    
</body>
</html>