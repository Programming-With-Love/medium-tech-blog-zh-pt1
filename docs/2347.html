<html>
<head>
<title>Today I Learned: Making a Simple Interactive Shell Application in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">今天我学习了:用Golang制作一个简单的交互式Shell应用程序</h1>
<blockquote>原文：<a href="https://medium.easyread.co/today-i-learned-making-a-simple-interactive-shell-application-in-golang-aa83adcb266a?source=collection_archive---------2-----------------------#2018-11-08">https://medium.easyread.co/today-i-learned-making-a-simple-interactive-shell-application-in-golang-aa83adcb266a?source=collection_archive---------2-----------------------#2018-11-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d621" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我如何在Golang中制作一个简单的交互式外壳</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a3714c2350a6c00b47eabc3c3dcd1e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TEeZWyrO8mI2hXwE"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">“command computer keyboard key” by <a class="ae ks" href="https://unsplash.com/@hannahjoshua?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hannah Joshua</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c781" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以今天，我学习了一些新的东西和一些基本的东西。它正在制作一个简单的交互式外壳。这只是一个非常简单的应用程序，但它看起来有点酷。</p><p id="1ad5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我已经在Golang工作了一年多。人们已经创造了很多工具，例如:<code class="fe lp lq lr ls b">cobra</code>由<a class="ae ks" href="http://github.com/spf13/cobra" rel="noopener ugc nofollow" target="_blank"> spf13 </a>开发，或者更多帮助我们开发命令行应用的工具。但是，不知何故，我很好奇如何在不依赖其他外部库的情况下创建一个简单的库。</p><p id="45e8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以出于好奇，我开始在谷歌上搜索如何制作它。但我发现的只是使用其他外部依赖的教程。每个人都在推广他们自己的库，以方便制作一个交互式外壳😌。伙计们。我只需要用纯Golang包做一个简单的(没有外部依赖)😌</p><p id="b988" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，我发现了一篇关于做交互壳的文章，像这篇:<a class="ae ks" href="http://technosophos.com/2014/07/11/start-an-interactive-shell-from-within-go.html" rel="noopener ugc nofollow" target="_blank">http://technosophos . com/2014/07/11/start-an-interactive-shell-from-within-go . html</a>，但是，他做的并不是我想要的样子。所以后来只有我从Gobyexample.com等网站上找到的一些例子。</p><p id="594f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我自己做了一个简单的Shell应用程序。下面我来解释一下我是怎么做到的。</p><h2 id="6557" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">壳</h2><p id="35ea" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">所以在做一个简单的shell应用之前，我想确定我说的Shell和你说的意思是一样的。</p><p id="da8e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对我来说，Shell是一个应用程序，它将充当非常基本的用户界面(基于文本的界面)。有些人可能会说它是命令行界面(CLI)。</p><h2 id="29c3" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">提出申请</h2><p id="3481" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">为了制作这个应用程序，对于最简单的原型，我将这样制作它。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="a590" class="lt lu in ls b gy mv mw l mx my">$ ls<br/>go.mod  main.go</span></pre><h2 id="5378" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">从终端读取命令</h2><p id="9396" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">要做到这一点，首先要做的是读取输入。我需要从终端读取输入。对此，我是这样做的。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="c86b" class="lt lu in ls b gy mv mw l mx my">reader := bufio.NewReader(os.Stdin)<br/>cmdString, err := reader.ReadString('\n')<br/>if err != nil {<br/> fmt.Fprintln(os.Stderr, err)<br/>}</span></pre><h2 id="5629" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">执行命令</h2><p id="bd2c" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">然后执行命令。从终端读取命令字符串后，现在执行命令。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="7bc1" class="lt lu in ls b gy mv mw l mx my">cmdString = strings.TrimSuffix(cmdString, "\n")<br/>cmd := exec.Command(commandString)<br/>cmd.Stderr = os.Stderr<br/>cmd.Stdout = os.Stdout<br/>cmd.Run()</span></pre><p id="8198" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">到目前为止，我可以运行我的简单shell应用程序，但是它只能运行一个命令。运行命令后，它将停止。</p><h2 id="e032" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">添加无限循环</h2><p id="31da" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">以使它在执行一次之后接收每一个命令。我们需要将它添加到一个无限循环中。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="7f17" class="lt lu in ls b gy mv mw l mx my">for {<br/> fmt.Print("$ ")<br/> cmdString, err := reader.ReadString('\n')<br/> if err != nil {<br/>  fmt.Fprintln(os.Stderr, err)<br/> }</span><span id="28d1" class="lt lu in ls b gy mz mw l mx my">cmdString = strings.TrimSuffix(cmdString, "\n")</span><span id="5a3b" class="lt lu in ls b gy mz mw l mx my">cmd := exec.Command(cmdString)<br/> cmd.Stderr = os.Stderr<br/> cmd.Stdout = os.Stdout<br/> err = cmd.Run()<br/> if err != nil {<br/>  fmt.Fprintln(os.Stderr, err)<br/> }</span><span id="2624" class="lt lu in ls b gy mz mw l mx my">}</span></pre><p id="8017" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们运行该应用程序，它将如下所示</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/76195358e447923911c0da07a10077e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/1*LRYpG0IQy9EmvqkxuJOapw.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">simple shell application</figcaption></figure><h2 id="3c06" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">处理争论</h2><p id="5cba" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">直到这一行，我已经完成了我的第一个CLI应用程序。但它仍然不接受论点。如果我传递一个参数，那么它会抛出一个错误。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="9ac5" class="lt lu in ls b gy mv mw l mx my">$ ls -lah // this command wil throw error</span></pre><p id="f8d3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了阅读这些论点，我把它写成下面这样。首先，我将命令分成一个字符串数组。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="4389" class="lt lu in ls b gy mv mw l mx my">// ...<br/>cmdString = strings.TrimSuffix(cmdString, "\n")<br/>arrCommandStr := <strong class="ls io">strings.Fields</strong>(cmdString)<br/>cmd := exec.Command(arrCommandStr[0], arrCommandStr[1:]...)<br/>// ...</span></pre><p id="6517" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了分割文本，我使用了包<code class="fe lp lq lr ls b">string</code>中的<code class="fe lp lq lr ls b">Fields</code>函数。该函数类似于拆分字符串函数。如果<code class="fe lp lq lr ls b">string.Split</code>将通过给定的特定分隔符分割字符串。但是<code class="fe lp lq lr ls b">strings.Fields</code>会用空格分隔单词。</p><p id="35a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例:</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="4a50" class="lt lu in ls b gy mv mw l mx my">str := "Hello World    Beautiful World"<br/>arrString := strings.Fields(str)<br/>fmt.Println(arrString)<br/>// [Hello World Beautiful World]</span></pre><p id="ad75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我的简单shell已经接受并处理了给定的参数。现在，这个命令应该起作用了。</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="be6e" class="lt lu in ls b gy mv mw l mx my">$ ls -lah<br/>total 4280<br/>drwxr-xr-x  5 iman  staff   160B Nov  6 19:48 .<br/>drwxr-xr-x  6 iman  staff   192B Nov  6 11:41 ..<br/>-rw-r--r--  1 iman  staff    38B Nov  6 11:43 go.mod<br/>-rw-r--r--  1 iman  staff   606B Nov  6 20:11 main.go<br/>-rwxr-xr-x  1 iman  staff   2.1M Nov  6 19:49 simshel</span></pre><h2 id="9f47" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">添加退出命令</h2><p id="0f94" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">但是，该应用程序仅适用于在环境中注册的任何内置应用程序。像<code class="fe lp lq lr ls b">exit</code>这样的命令是不存在的，因为它被编程在每个CLI应用程序中。</p><p id="2473" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，我为系统中没有内置应用程序的每个命令创建一个switch-case处理程序，比如<code class="fe lp lq lr ls b">exit</code>命令。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="14f7" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">添加自定义命令</h2><p id="afb3" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">要添加自定义命令，我可以简单地将其添加到switch-case处理程序中。比如我想加一个类似<code class="fe lp lq lr ls b">plus</code>的命令。该命令在任何CLI应用程序中都不存在。我想把它做成这样:</p><pre class="kd ke kf kg gt mr ls ms mt aw mu bi"><span id="465a" class="lt lu in ls b gy mv mw l mx my">$ plus 2 4 5 6<br/>17</span></pre><p id="0ef5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为此，我只需要添加一个sum函数，并在<code class="fe lp lq lr ls b">switch-case</code>中添加命令案例处理程序</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="f1b1" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">结论</h2><p id="19a6" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">最后，它只是一个非常简单的应用程序。但可以肯定的是，在制作这个的时候，我学到了一些东西。而且，在写这篇文章的时候，我发现了一篇与这篇文章相似的文章(这里:<a class="ae ks" href="https://sj14.gitlab.io/post/2018-07-01-go-unix-shell/" rel="noopener ugc nofollow" target="_blank">https://sj14.gitlab.io/post/2018-07-01-go-unix-shell/</a>)。读完那篇文章后，我正考虑放弃我的草稿。但是，我已经在这里写了很多解释和例子，所以后来我决定张贴它无论如何XD。</p><p id="c10b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不管怎样，我已经把源代码放在我的Github里了:<a class="ae ks" href="https://github.com/bxcodec/simpleshell" rel="noopener ugc nofollow" target="_blank">https://github.com/bxcodec/simpleshell</a>，如果有机会，我以后会试着给它添加一些功能。</p><p id="10cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">*印尼版:<a class="ae ks" href="https://medium.com/easyread/today-i-learned-belajar-membuat-aplikasi-interactive-shell-sederhana-di-golang-2ef013003393" rel="noopener">https://medium . com/easy read/today-I-learned-Bela jar-mem UAT-aplikasi-interactive-shell-Seder HANA-di-golang-2ef 013003393</a><br/>*更新:再增加一个自定义命令的例子</p></div></div>    
</body>
</html>