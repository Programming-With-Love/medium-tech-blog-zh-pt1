<html>
<head>
<title>GitHub Actions for Android developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Android开发者的GitHub行动</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/github-actions-for-android-developers-6b54c8a32f55?source=collection_archive---------0-----------------------#2021-02-11">https://medium.com/google-developer-experts/github-actions-for-android-developers-6b54c8a32f55?source=collection_archive---------0-----------------------#2021-02-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/b2dc532f1801b439483ddc1357cc4b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hRA7u4cfsSghbQwyFD_8YQ.png"/></div></div></figure><div class=""/><p id="f5af" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你正在开发Android应用程序，你很可能在职业生涯的某个阶段遇到过任何类型的竞争情报。如果你认为Android碎片化是一件事，CI系统的广泛可用性对你来说应该很熟悉。</p><p id="8b90" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">GitHub Actions于2019年11月左右发布，从那时起，它已经证明了自己对于生产环境的可靠性(这是我们在承诺任何软件系统之前的要求之一)。像许多其他CI/CD系统一样，GitHub actions最终让我们为我们的应用程序定义一个工作流，以自动构建、测试和部署它们。</p><p id="3f35" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">GitHub Actions最闪亮的一面是它与GitHub的集成。对于已经托管在GitHub中的存储库，GitHub Actions允许我们在一个单一的平台上自动化这个过程，而不需要依赖任何外部工具。你的代码在GitHub上，你的CI/CD在GitHub上运行，如果你愿意，你也可以在GitHub上发布。</p><p id="ff99" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，GitHub Actions提供了深思熟虑的指南和文档，尽管对于以前没有使用过它的人来说，一开始使用它可能会感到力不从心。该文档为Android开发人员提供了一个基本设置的示例，但是您可能想知道<em class="jn">“我在哪里可以获得一些使用GitHub操作的灵感？”</em>。这篇文章旨在根据我使用GitHub Actions的个人经验提供一些答案。我一直在一个Android项目中使用它，因此我的经验(和这篇文章)仅限于这个平台。不要再耽搁了，我们走吧。</p><h2 id="d9da" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">我们的配置文件的结构</h2><p id="8985" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">GitHub Actions需要一个. yml文件来指定CI/CD的所有步骤。YAML文件让人不舒服，尤其是当它们变大的时候(缩进问题可能会被忽视，来自ide的支持也很少)。这些文件存储在文件夹<code class="du ko kp kq kr b">.github/workflows/file.yml</code>中。下面是它们外观的一个简单示例:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="606e" class="jo jp hs kr b fi la lb l lc ld"># Workflow name<br/>name: Build</span><span id="8c12" class="jo jp hs kr b fi le lb l lc ld">on:<br/># When it will be triggered<br/># And in which branch<br/>  pull_request:<br/>  push:<br/>    branches:<br/>      - main<br/></span><span id="57e2" class="jo jp hs kr b fi le lb l lc ld"># Where will they run<br/>jobs:<br/>  build:<br/><br/>    runs-on: ubuntu-latest</span></pre><h2 id="f089" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">行动</h2><p id="2d40" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">行动是一种特殊类型的步骤，可以帮助我们完成自动化CI/CD的任务。任何人都可以公开他们的行为，并且可以通过GitHub 浏览。我们可能想要实现的许多功能可能已经在这里了，因此值得看一看以避免重新发明轮子。当然，也可以<a class="ae lf" href="https://docs.github.com/en/free-pro-team@latest/actions/creating-actions" rel="noopener ugc nofollow" target="_blank">派生和修改现有的动作，或者</a>创建我们自己的动作。</p><p id="30a8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，这里列出了一些我们可以在Android中执行的操作的建议。正如CI/CD的名字一样，我们通常希望开始构建和部署应用程序，但我们可以应用一些好东西(通知某些渠道或平台等)。让我们开始吧。</p><h2 id="6bf9" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">设置我们的Android应用程序</h2><p id="74d6" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">最初，我们将设置我们的环境，为了做到这一点，我们需要检查我们的项目并设置我们的JDK。我们将在这里使用我们的第一个动作，<a class="ae lf" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank"> Checkout v2 </a>对我们的存储库执行<code class="du ko kp kq kr b">git checkout</code>操作，并且<a class="ae lf" href="https://github.com/actions/setup-java" rel="noopener ugc nofollow" target="_blank"> setup-java </a>准备我们的java环境。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="5d1e" class="jo jp hs kr b fi la lb l lc ld"><em class="jn">## Checkout our repository ###<br/></em>- name: Checkout<br/>  uses: actions/checkout@v2.3.3<br/><br/>- name: Set up our JDK environment<br/>  uses: actions/setup-java@v1.4.3<br/>  with:<br/>    java-version: 1.8</span></pre><h2 id="8ffa" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">建造我们的艺术品</h2><p id="ac5f" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">每个项目的基础是编译我们所有要上传和/或分发的工件。Android通常有一个特殊性，那就是我们可能会基于我们的风格或构建类型生成几个apk。它们中的一些是相关的(我们的发布工件可能直接进入我们的测试团队)，一些是不相关的(我们的测试工件仅仅用于开发)，这取决于你的团队结构。幸运的是，我们可以直接调用Gradle命令并生成相关的工件数量。我们将使用动作<a class="ae lf" href="https://github.com/eskatos/gradle-command-action" rel="noopener ugc nofollow" target="_blank"> gradle-command-action </a>来执行我们的gradle命令。下面是一个例子:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="239e" class="jo jp hs kr b fi la lb l lc ld"><em class="jn">## Build all our Build Types at once ##<br/></em>- name: Build all artifacts<br/>  id: buildAllApks<br/>  uses: eskatos/gradle-command-action@v1.3.3<br/>  with:<br/>    gradle-version: current<br/>    wrapper-cache-enabled: true<br/>    dependencies-cache-enabled: true<br/>    configuration-cache-enabled: true<br/>    arguments: assembleRelease</span></pre><p id="4563" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里的线<code class="du ko kp kq kr b">arguments: assembleRelease</code>是相关的线。我们可以很容易地用我们想要执行的Gradle命令来代替它。</p><h2 id="5cc2" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">测试</h2><p id="7cbe" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">我们可能希望在CI/CD环境中运行几个测试或分析工具。幸运的是，通过GitHub actions，我们可以直接运行Gradle命令。例如，可以通过直接调用相关的Gradle命令来轻松启动我们的测试或Lint:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="e671" class="jo jp hs kr b fi la lb l lc ld">- name: Run Kotlin Linter<br/>  run: ./gradlew ktlintStagingDebugCheck<br/><br/>- name: Run Unit Tests<br/>  run: ./gradlew testStagingDebugUnitTest</span></pre><p id="312f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还可以在GitHub Actions上运行我们的Espresso测试。有几个动作允许我们触发它们，我们将通过<a class="ae lf" href="https://github.com/ReactiveCircus" rel="noopener ugc nofollow" target="_blank">反应马戏团</a>展示<a class="ae lf" href="https://github.com/ReactiveCircus/android-emulator-runner" rel="noopener ugc nofollow" target="_blank"> android模拟器运行程序</a></p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="db4a" class="jo jp hs kr b fi la lb l lc ld">uses: reactivecircus/android-emulator-runner@v2<br/>    with:<br/>      api-level: 23<br/>      target: default<br/>      arch: x86<br/>      profile: Nexus 6<br/>      script: ./gradlew connectedCheck --stacktrace</span></pre><h2 id="f179" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">签名工件</h2><p id="963c" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">在创建我们的Android工件时，签名工件是下一个自然的步骤，因此它们可以安装在设备上。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="caba" class="jo jp hs kr b fi la lb l lc ld"><em class="jn">## Sign our artifact##<br/></em>- name: Sign artifact<br/>  id: signArtifact<br/>  uses: r0adkll/sign-android-release@v1.0.1<br/>  with:<br/>    releaseDirectory: app/build/outputs/apk/ourbuildtype/release<br/>    alias: ${{ secrets.KEYALIAS }}<br/>    signingKeyBase64: ${{ secrets.KEYSTORE }}<br/>    keyStorePassword: ${{ secrets.KEYSTORE_PASSWORD }}<br/>    keyPassword: ${{ secrets.KEY_PASSWORD }}<br/><br/>- name: Upload our APK<br/>  uses: actions/upload-artifact@v2.2.0<br/>  with:<br/>    name: Release artifact<br/>    path: app/build/outputs/apk/ourbuildtype/release/app-artifact-*.apk</span></pre><p id="bf60" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对这里发生的事情做进一步的解释:</p><p id="0781" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">名为“Sign artifact”的任务使用<a class="ae lf" href="https://github.com/r0adkll/sign-android-release" rel="noopener ugc nofollow" target="_blank"> sign-android-release </a>动作。这非常简单:我们需要指定与密钥相关的信息，这样APK就被签名了。如果我们需要，可以指定不同的任务(例如，因为我们需要用不同的密钥签署apk)。</p><p id="0d5d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">“上传我们的APK”任务从我们的工作流上传工件，允许我们在作业之间共享数据，并在工作流完成后存储数据。它使用动作<a class="ae lf" href="https://github.com/actions/upload-artifact" rel="noopener ugc nofollow" target="_blank">上传——神器</a>。注意，在path字段中，我们使用了通配符<code class="du ko kp kq kr b">app-artifact-*.apk</code>。</p><p id="4f9e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用Gradle，我们可以定制我们的配置文件，以确定我们的结果APK的名称。这会产生可读性更好的输出，而不是总是使用默认的APK名称。例如，下面的代码块将Gradle文件的名称更改为可读性更好的格式(app-{ flavor }-{ build name }-{ version name })。apk:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="1279" class="jo jp hs kr b fi la lb l lc ld">android.applicationVariants.all <strong class="kr ht">{ </strong>variant <strong class="kr ht">-&gt;<br/>    </strong>variant.outputs.all <strong class="kr ht">{<br/>        </strong>outputFileName = "app-$<strong class="kr ht">{</strong>variant.productFlavors[0].name<strong class="kr ht">}</strong>-$<strong class="kr ht">{</strong>variant.buildType.name<strong class="kr ht">}</strong>-$<strong class="kr ht">{</strong>variant.versionName<strong class="kr ht">}</strong>.apk"<br/>    <strong class="kr ht">}<br/>}</strong></span></pre><h2 id="e9ac" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated"><strong class="ak">创作发布</strong></h2><p id="5637" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">GitHub中提供了一些有趣的东西，可以在GitHub中创建一个版本，我们以后可以用它来分发我们的工件。例如，看看Kotlin协程的版本1.4.2 的发布页面是什么样子的:</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lg"><img src="../Images/3b967d07b2e5f1f8eef116ce289d4916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFLjegZEBD1h00JKhL5H-A.png"/></div></div></figure><p id="df13" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些版本中的每一个都可以包含许多工件、源代码、文档等。也有可能为某个特定的版本发布一些变更日志或注释(稍后将详细介绍如何自动创建)。在整个过程中自动创建它肯定是有用的。这是将在GitHub中创建发布的相关部分。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="c420" class="jo jp hs kr b fi la lb l lc ld">- name: Create Release<br/>  id: create_release<br/>  uses: actions/create-release@v1<br/>  env:<br/>    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}<br/>  with:<br/>    tag_name: ${{ github.ref }}<br/>    release_name: Release ${{ github.ref }}<br/>    draft: false<br/>    prerelease: false</span></pre><h2 id="1c72" class="jo jp hs bd jq jr js jt ju jv jw jx jy ja jz ka kb je kc kd ke ji kf kg kh ki bi translated">将我们的资产上传到GitHub</h2><p id="2647" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">随着发行版的创建，是时候上传我们自己的资产了。我们将使用一个辅助任务来收集我们的APK名称和路径(假设我们为它们定制了名称，如前所述)。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="9a9d" class="jo jp hs kr b fi la lb l lc ld">- name: Save name of our Artifact<br/>  id: set-result-artifact<br/>  run: |<br/>    ARTIFACT_PATHNAME_APK=$(ls app/build/outputs/apk/ourbuildtype/release/*.apk | head -n 1)<br/>    ARTIFACT_NAME_APK=$(basename $ARTIFACT_PATHNAME_APK)<br/>    echo "ARTIFACT_NAME_APK is " ${ARTIFACT_NAME_APK}<br/>    echo "ARTIFACT_PATHNAME_APK=${ARTIFACT_PATHNAME_APK}" &gt;&gt; $GITHUB_ENV<br/>    echo "ARTIFACT_NAME_APK=${ARTIFACT_NAME_APK}" &gt;&gt; $GITHUB_ENV</span></pre><p id="820c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意该代码块中的几个相关点:</p><ul class=""><li id="df95" class="lh li hs ir b is it iw ix ja lj je lk ji ll jm lm ln lo lp bi translated">我们在环境变量中设置路径和工件的名称，这些变量稍后会保存在GitHub上。这是在GitHub Actions中存储信息的一种极好的方式。</li><li id="6280" class="lh li hs ir b is lq iw lr ja ls je lt ji lu jm lm ln lo lp bi translated">我们正在运行一个命令来确定APK的名称(<code class="du ko kp kq kr b">ls app/build/outputs/apk/ourbuildtype/release/*.apk | head -n 1</code>)。这是非常通用的，因为我们基本上可以使用Unix/Mac命令来确定各种事情(稍后，将它们存储在我们的路径中，并在其他步骤中重用它们)。</li></ul><p id="abb1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">名称和路径已经存储在环境变量中，现在我们将把它们上传到我们的发布页面。这使用了动作<a class="ae lf" href="https://github.com/actions/upload-release-asset" rel="noopener ugc nofollow" target="_blank">上传-发布-资产</a>:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="d10d" class="jo jp hs kr b fi la lb l lc ld">- name: Upload our Artifact Assets<br/>  id: upload-release-asset<br/>  uses: actions/upload-release-asset@v1<br/>  env:<br/>    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}<br/>  with:<br/>    upload_url: ${{ steps.create_release.outputs.upload_url }}<br/>    asset_path: ${{ env.ARTIFACT_PATHNAME_APK }}<br/>    asset_name: ${{ env.ARTIFACT_NAME_APK }}<br/>    asset_content_type: application/zip</span></pre><p id="33ab" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这已经在GitHub上创建了我们的工件，我们准备分发它们。我们可以使用许多通知机制。例如，如果我们有一个Slack组，我们可以使用<a class="ae lf" href="https://github.com/act10ns/slack" rel="noopener ugc nofollow" target="_blank"> act10ns/slack </a>通知特定的通道我们的发布已经准备好了:</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="3c16" class="jo jp hs kr b fi la lb l lc ld">- name: Notify on Slack<br/>  uses: act10ns/slack@v1.0.9<br/>  with:<br/>    status: ${{ job.status }}<br/>    steps: ${{ toJson(steps) }}<br/>    if: always()</span></pre><p id="9a60" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">GitHub已经有很多可用的操作选项，包括通过<a class="ae lf" href="https://github.com/appleboy/telegram-action" rel="noopener ugc nofollow" target="_blank">电报</a>，通过<a class="ae lf" href="https://github.com/marketplace/actions/send-email" rel="noopener ugc nofollow" target="_blank">电子邮件</a>或<a class="ae lf" href="https://github.com/Ilshidur/action-discord" rel="noopener ugc nofollow" target="_blank">不和谐</a>进行通知。如果您能想到您需要的特定平台，很可能有一个GitHub动作可以涵盖它。</p><p id="be77" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以给它一个最后的触摸，这将是自动填充变更日志，获取一些已经可用的信息。可以想象，已经有一个<a class="ae lf" href="https://github.com/marketplace/actions/git-release" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>解决了这个问题。这个程序根据<a class="ae lf" href="https://keepachangelog.com/en/1.0.0/" rel="noopener ugc nofollow" target="_blank">keepchangelog.com</a>从CHANGELOG.md文件中获取信息，但是使用<strong class="ir ht"> git log - pretty=oneline </strong>或类似的格式并不难做到。</p><h1 id="27db" class="lv jp hs bd jq lw lx ly ju lz ma mb jy mc md me kb mf mg mh ke mi mj mk kh ml bi translated">摘要</h1><p id="bc58" class="pw-post-body-paragraph ip iq hs ir b is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ha bi translated">GitHub Actions是市场上又一个CI/CD引擎。如果你已经在使用GitHub，它提供了一个与你的代码、问题和发布工作流程非常好的集成。它是高度可定制的，提供API来创建你自己需要的动作，或者从<a class="ae lf" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank"> GitHub marketplace </a>访问它们。与任何基于云的解决方案(或任何技术解决方案，就其重要性而言)一样，在决定采用它是否有意义之前，有几个因素需要权衡。我相信这是一个舒适的解决方案，可以满足各种需求。</p><p id="fa19" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">感谢<a class="ae lf" href="https://twitter.com/zsmb13" rel="noopener ugc nofollow" target="_blank">马顿</a>、<a class="ae lf" href="https://twitter.com/jossiwolf" rel="noopener ugc nofollow" target="_blank">乔西</a>、<a class="ae lf" href="https://twitter.com/ubiratanfsoares" rel="noopener ugc nofollow" target="_blank">乌比拉坦</a>和<a class="ae lf" href="https://twitter.com/wajahatkarim?lang=en" rel="noopener ugc nofollow" target="_blank">瓦贾哈特</a>的善意和有益的评论，摇滚吧！</p><p id="4b13" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在我的推特账户上写下我对软件工程和生活的想法。如果你喜欢这篇文章或者它对你有帮助，请随意分享，👏和/或发表评论。这是给业余作家加油的货币。</p></div></div>    
</body>
</html>