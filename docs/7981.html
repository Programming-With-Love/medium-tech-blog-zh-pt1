<html>
<head>
<title>Lombok and Java — the beauty and the beast</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">龙目岛和爪哇——美女与野兽</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/lombok-the-beauty-and-the-beast-5e511dbf49f6?source=collection_archive---------0-----------------------#2021-03-03">https://medium.com/walmartglobaltech/lombok-the-beauty-and-the-beast-5e511dbf49f6?source=collection_archive---------0-----------------------#2021-03-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/09a566bf20e0575a1c38222f1291cea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y74ARjUJ2H87hYQsNK1mdA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo credit: <a class="ae it" href="https://pixabay.com/photos/indonesia-lombok-rinjani-landscape-4497577/" rel="noopener ugc nofollow" target="_blank">pixabay</a>, Lombok island, Indonesia</figcaption></figure><h2 id="cf3c" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">目录</h2><ul class=""><li id="8892" class="js jt hh ju b jv jw jx jy jf jz jj ka jn kb kc kd ke kf kg bi translated">介绍</li><li id="d8c2" class="js jt hh ju b jv kh jx ki jf kj jj kk jn kl kc kd ke kf kg bi translated">使用Lombok</li><li id="9e38" class="js jt hh ju b jv kh jx ki jf kj jj kk jn kl kc kd ke kf kg bi translated">getter/setter</li><li id="ecde" class="js jt hh ju b jv kh jx ki jf kj jj kk jn kl kc kd ke kf kg bi translated">等于/哈希码</li><li id="a517" class="js jt hh ju b jv kh jx ki jf kj jj kk jn kl kc kd ke kf kg bi translated">建设者</li><li id="1c77" class="js jt hh ju b jv kh jx ki jf kj jj kk jn kl kc kd ke kf kg bi translated">NoArgs/AllArgs构造函数</li><li id="3910" class="js jt hh ju b jv kh jx ki jf kj jj kk jn kl kc kd ke kf kg bi translated">不变</li><li id="1b80" class="js jt hh ju b jv kh jx ki jf kj jj kk jn kl kc kd ke kf kg bi translated">SneakyThrows</li><li id="ca08" class="js jt hh ju b jv kh jx ki jf kj jj kk jn kl kc kd ke kf kg bi translated">其余的</li><li id="e481" class="js jt hh ju b jv kh jx ki jf kj jj kk jn kl kc kd ke kf kg bi translated">德龙博克</li><li id="cb06" class="js jt hh ju b jv kh jx ki jf kj jj kk jn kl kc kd ke kf kg bi translated">逮到你了</li><li id="5efb" class="js jt hh ju b jv kh jx ki jf kj jj kk jn kl kc kd ke kf kg bi translated">结论</li></ul><h2 id="f640" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h2><p id="7bc5" class="pw-post-body-paragraph km kn hh ju b jv jw ko kp jx jy kq kr jf ks kt ku jj kv kw kx jn ky kz la kc ha bi lb translated">当我们设计和构建现代软件时，我们想要关注的一个关键方面是<a class="ae it" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"> <em class="lk">关注点分离</em> </a>。这对于任何好的软件来说都是必要的，尤其是在构建微服务的时候。dto(或<a class="ae it" href="https://en.wikipedia.org/wiki/Plain_old_Java_object" rel="noopener ugc nofollow" target="_blank">POJO</a>)有助于在服务内/跨服务通信时封装数据，也有助于将对象(从)序列化为JSON/XML等。</p><p id="1da0" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">dto是这种系统的一个重要方面，写起来同样乏味(并且容易出错)。它们包含许多样板代码，看起来微不足道。与此同时，一个小错误(比如丢失了<em class="lk"> final </em>关键字，或者返回了<em class="lk"> shallow copy </em>)可能会造成严重破坏，并且很难调试。</p><p id="8430" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">对于我们这些用Java编码的人来说，我们知道编写POJOs的痛苦。我们已经看到，随着我们添加更多的字段，永无止境的dto在规模上不断增长。对于添加的单个字段，我们可以添加最少的getters和setters。如果你喜欢冒险，你可能最终会修改构造函数和添加构造函数。更不用说，如果你加上<a class="ae it" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html" rel="noopener ugc nofollow" target="_blank">不变性</a>和<a class="ae it" href="https://www.baeldung.com/java-deep-copy" rel="noopener ugc nofollow" target="_blank">深度克隆</a>，事情就变得更加复杂了。</p><h2 id="8f9a" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">使用Lombok</h2><p id="a9af" class="pw-post-body-paragraph km kn hh ju b jv jw ko kp jx jy kq kr jf ks kt ku jj kv kw kx jn ky kz la kc ha bi translated">如果你曾经打开地图册，查找爪哇岛的位置，你可能会看到邻近的岛屿叫做龙目岛。难怪在编程语言的世界里，<a class="ae it" href="https://projectlombok.org/" rel="noopener ugc nofollow" target="_blank"> project Lombok </a>已经被用来帮助Java程序员了。</p><p id="8111" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">Lombok的目标是尽量减少POJOs的冗长。随着时间的推移，它引入了getters &amp; setters、toString、equals和hashCode、日志记录、构建器、不变性、同步等。目标是减少样板代码并提高工程生产率，这样工程师就可以专注于功能开发，而不是固定螺母和螺栓。它还可以简化可读性、重构和容易地识别错误。</p><p id="3e8b" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">那就是龙目岛的<strong class="ju hi"> <em class="lk">美女</em> </strong>。然而，如果你不真正了解幕后发生了什么，事情可能会很快变得很糟糕。测试用例可能会变得令人讨厌，代码覆盖率数字看起来会变得奇怪。</p><blockquote class="lq lr ls"><p id="bf34" class="km kn lk ju b jv ll ko kp jx lm kq kr lt ln kt ku lu lo kw kx lv lp kz la kc ha bi translated">如果你想要“美”，你需要知道如何驯服“野兽”。</p></blockquote><p id="2daf" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">在这里，我们将尝试理解Lombok是做什么的，以及是如何做到的。因此，我们会明白如何正确地使用它。</p><figure class="lx ly lz ma fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lw"><img src="../Images/435f6c7bcc0b7131c71f36ff61fa8d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIJj9Q-ulVWUb2E7FWF7Rg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Source code, byte code, and Lombok</figcaption></figure><p id="8202" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">因为Java是独立于平台的。java文件被转换成。类<a class="ae it" href="https://en.wikipedia.org/wiki/Bytecode" rel="noopener ugc nofollow" target="_blank">的字节码</a>被编译器编译。这就是JRE感兴趣的。JRE不是独立于平台的，并且在操作系统上执行字节码。</p><p id="b6f3" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">龙目岛介于。java和。类文件并将字节级代码注入到。用于<em class="lk">getter、setters、builders、</em>等的类文件。</p><p id="c7a1" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">除了。类文件，JRE不知道Lombok的存在(也不应该知道)。现在您可能已经理解了，Lombok只在编译时需要。因为这个原因，maven <em class="lk">范围</em>可以(也应该)设置为<em class="lk">编译/提供</em>。</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="ee5e" class="iu iv hh mc b fi mg mh l mi mj">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br/>    &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br/>    &lt;version&gt;1.18.18&lt;/version&gt;<br/>    &lt;scope&gt;provided&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="a268" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">Lombok注释用于减少冗长。这些注释取代了工程师通常编写的样板代码。在编译时，Lombok会读取注释并将相应的代码注入到生成的类文件中。接下来，我们将看看注释以及如何安全地使用它们。</p><h2 id="7483" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">getter/setter</h2><p id="85e8" class="pw-post-body-paragraph km kn hh ju b jv jw ko kp jx jy kq kr jf ks kt ku jj kv kw kx jn ky kz la kc ha bi translated">这些是最简单的开始。典型的POJO应该是这样的。对于类的4个属性，我们有8个方法和38个loc。</p><figure class="lx ly lz ma fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="f60d" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">您可以想象一个包含更多属性和一些自定义方法的DTO长达数百行。龙目岛不再是了:</p><figure class="lx ly lz ma fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="f967" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">等于/哈希码</h2><p id="3c7d" class="pw-post-body-paragraph km kn hh ju b jv jw ko kp jx jy kq kr jf ks kt ku jj kv kw kx jn ky kz la kc ha bi translated">在介绍这些注释之前，您应该理解<a class="ae it" href="https://www.baeldung.com/java-equals-hashcode-contracts" rel="noopener ugc nofollow" target="_blank"> equals()和hashCode() </a>的用法。否则，<a class="ae it" href="https://projectlombok.org/features/EqualsAndHashCode" rel="noopener ugc nofollow" target="_blank"> @EqualsAndHashCode </a>会生成不必要的代码，降低您的测试代码覆盖率。例如，如果您引入了这个注释，但是在相等性检查中，或者在这样的DTO的集合或映射中没有使用DTO(因此没有用于这样的场景的测试用例)，这些行将永远不会被执行。</p><p id="c4f9" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">下面是Lombok为单个属性生成的内容示例:</p><figure class="lx ly lz ma fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="e8c3" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">建设者</h2><p id="0a2b" class="pw-post-body-paragraph km kn hh ju b jv jw ko kp jx jy kq kr jf ks kt ku jj kv kw kx jn ky kz la kc ha bi translated"><a class="ae it" href="https://en.wikipedia.org/wiki/Builder_pattern" rel="noopener ugc nofollow" target="_blank">生成器</a>是一个非常有用的构造，特别是对于冗长的dto。生成器还有助于避免多个带有可选参数的构造函数。从下面的例子中我们可以看到，我们正在使用<a class="ae it" href="https://projectlombok.org/features/Builder" rel="noopener ugc nofollow" target="_blank"> @Builder </a>设置<em class="lk"> fName </em>和<em class="lk"> age </em>。这是基于构建器模式由<a class="ae it" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank"> <em class="lk">四人组</em> </a> <em class="lk">组成。</em></p><p id="a835" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">使用setters会生成更多的行，而使用构造函数，我们将需要多个重载来满足所有可能的场景(或者为剩余的字段传递null/default值)。与@EqualsAndHashCode非常相似，builder注释会生成大量代码，所以除非您有涵盖这些的测试用例，否则代码覆盖率肯定会下降。</p><p id="ecc0" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">注意，当使用构建器时，未设置的字段将被默认(原语的默认值为<a class="ae it" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" rel="noopener ugc nofollow" target="_blank">，其他为null)。还要注意，构建器不能像设置器一样改变对象。它应该用于一次性创建一个新对象。进一步的变异，如果需要的话，应该由设定者来完成。</a></p><figure class="lx ly lz ma fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="35ef" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">NoArgs/AllArgs构造函数</h2><p id="f523" class="pw-post-body-paragraph km kn hh ju b jv jw ko kp jx jy kq kr jf ks kt ku jj kv kw kx jn ky kz la kc ha bi translated">顾名思义，这些注释有助于创建默认(无参数)构造函数和全参数构造函数。Java(不是Lombok)创建默认的构造函数(在。类)，仅当没有任何用户定义的类时。因此，如果你没有这两个注释，java会创建一个无参数(顺便说一下，<a class="ae it" href="https://en.wikipedia.org/wiki/Jackson_(API)" rel="noopener ugc nofollow" target="_blank"> Jackson </a>利用了这一点)。但是，如果您使用@Builder或<a class="ae it" href="https://projectlombok.org/features/constructor" rel="noopener ugc nofollow" target="_blank"> @AllArgsConstructor </a>，并且还使用Jackson将对象序列化(反序列化)到JSON，请确保添加@NoArgsConstructor。Jackson需要构造函数正确地实例化对象。这适用于大多数JSON/XML处理API。</p><p id="0d32" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">长话短说，如果您引入了@Builder或@AllArgsConstructor而没有添加@NoArgsConstructor，一个正常工作的DTO-杰克森组合将开始失败。</p><figure class="lx ly lz ma fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="019f" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">不变</h2><p id="4673" class="pw-post-body-paragraph km kn hh ju b jv jw ko kp jx jy kq kr jf ks kt ku jj kv kw kx jn ky kz la kc ha bi translated">创建不可变类也是一个很好的特性，Lombok支持使用<a class="ae it" href="https://projectlombok.org/features/Value" rel="noopener ugc nofollow" target="_blank"> @Value </a>注释。它确保不生成setters，并且字段被定义为<em class="lk"> final </em>，这样它们的引用就不会被更改。下面是代码实际外观的一个例子。注意所有数据类型的<em class="lk">深度不变性</em>(包括自定义<em class="lk">地址类</em>)。</p><figure class="lx ly lz ma fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="c34b" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">如果你不需要不可变性，但是需要getters、setters、equals、hashCode和allArgsConstructor，而不是单独注释这些，你可以使用<a class="ae it" href="https://projectlombok.org/features/Data" rel="noopener ugc nofollow" target="_blank"> @Data </a>注释。除了不变性之外，@Data和@Value是相似的。此外，如果您对不可变的setters感兴趣，请使用检查<a class="ae it" href="https://projectlombok.org/features/With" rel="noopener ugc nofollow" target="_blank">@。</a></p><h2 id="4665" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">SneakyThrows</h2><p id="88c2" class="pw-post-body-paragraph km kn hh ju b jv jw ko kp jx jy kq kr jf ks kt ku jj kv kw kx jn ky kz la kc ha bi translated">如果你是一个优秀的程序员，你会确保所有的异常都得到妥善处理。这并不意味着每个方法中都有一个try-catch块。相反，您可以拥有一个调用多层函数的代理函数。较低级别的函数只是抛出异常，委托者函数优雅地处理它们。听起来不错！！但这意味着，所有较低级别的函数都需要在它们的方法签名中添加一个<em class="lk"> throws </em>子句，增加冗长性，或者在每次添加一个抛出特定异常的新代码片段时进行更改。</p><p id="cc51" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated"><a class="ae it" href="https://projectlombok.org/features/SneakyThrows" rel="noopener ugc nofollow" target="_blank"> @SneakyThrows </a>帮助将所有检查过的异常包装成未检查的异常，从而避免处理新异常的冗长或必要性。虽然它使代码更干净，但也使代码变得非常危险，因为不再有编译时警告。<em class="lk">你，只有你有责任在JVM崩溃之前处理未检查的异常。所以在使用这个注释</em>的时候要非常小心。这里有一个例子:</p><figure class="lx ly lz ma fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="4cbc" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">其余的</h2><p id="bc67" class="pw-post-body-paragraph km kn hh ju b jv jw ko kp jx jy kq kr jf ks kt ku jj kv kw kx jn ky kz la kc ha bi translated">使用<a class="ae it" href="https://projectlombok.org/features/log" rel="noopener ugc nofollow" target="_blank">记录器</a>，或者<a class="ae it" href="https://projectlombok.org/features/Synchronized" rel="noopener ugc nofollow" target="_blank">同步锁</a>也可以使用Lombok注释。有关全套注释，请参考<a class="ae it" href="https://projectlombok.org/features/all" rel="noopener ugc nofollow" target="_blank">此链接</a>。</p><p id="cc03" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated"><a class="ae it" href="https://howtodoinjava.com/java/cloning/a-guide-to-object-cloning-in-java/" rel="noopener ugc nofollow" target="_blank">深度克隆</a>可以使用构建器注释实现。克隆的首选方式是使用<em class="lk">复制构造函数</em>而不是使用<em class="lk">可克隆的</em>接口(您将被Sonar标记)。如果能通过Lombok获得一个复制构造函数就好了。这是<a class="ae it" href="https://projectlombok.org/features/experimental/all" rel="noopener ugc nofollow" target="_blank">实验特性</a>的列表，我们还没有看到任何这样的选项。</p><h2 id="7755" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">德龙博克</h2><p id="efc7" class="pw-post-body-paragraph km kn hh ju b jv jw ko kp jx jy kq kr jf ks kt ku jj kv kw kx jn ky kz la kc ha bi translated">如果你对Lombok生成的代码感兴趣，你可以随时“delombok”查看。这可以从类似于<a class="ae it" href="https://projectlombok.org/features/delombok" rel="noopener ugc nofollow" target="_blank"> this </a>的CLI中完成，或者从任何集成了Lombok的IDE中完成。IntelliJ是这样做的:</p><figure class="lx ly lz ma fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mm"><img src="../Images/714424ac9b0c069f4a862636d6ac2a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*diQp0XpKr6CDwKdm92gQdw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Delomking code in IDE</figcaption></figure><h2 id="9aa5" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">逮到你了</h2><p id="8313" class="pw-post-body-paragraph km kn hh ju b jv jw ko kp jx jy kq kr jf ks kt ku jj kv kw kx jn ky kz la kc ha bi translated">在生成getter/setter时，Lombok对本地布尔和装箱布尔的处理是不同的。请注意这可能会导致不正确的序列化(反序列化)。在推动此类更改之前，请始终测试您的序列化数据。查看以下“成人”和“吸烟者”的吸气剂:</p><figure class="lx ly lz ma fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><h2 id="c055" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结论</h2><p id="c757" class="pw-post-body-paragraph km kn hh ju b jv jw ko kp jx jy kq kr jf ks kt ku jj kv kw kx jn ky kz la kc ha bi translated">Lombok是一个漂亮的工具，可以减少很多样板代码。对于为微服务创建dto(甚至是共享dto)或者快速从log4j2迁移到slf4j(只需更改一个注释)，它可能特别有用。</p><p id="089c" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">你可能会说，最现代的ide有助于生成getter/setter/constructor。这是真的；然而，这并没有减少代码的冗长。以后需要修改代码的工程师仍然需要检查代码。想象一个DTO被覆盖了下面的<em class="lk"> setAddresses </em>:</p><figure class="lx ly lz ma fd ii"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="295e" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">如果同一个类有一些属性并且不是Lomboked的，简单的目测不会发现自定义setter，由于它的紧凑性，这在上面是如此清晰可见。</p><p id="382a" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">同时，既然是在玩字节码，就要负责，要谨慎。代码覆盖率、异常处理、(反)序列化是您需要小心的一些领域。</p><p id="7aef" class="pw-post-body-paragraph km kn hh ju b jv ll ko kp jx lm kq kr jf ln kt ku jj lo kw kx jn lp kz la kc ha bi translated">正如我前面提到的，如果你能驯服野兽，你应该不难找到龙目岛提供的美。龙目岛快乐！！</p></div></div>    
</body>
</html>