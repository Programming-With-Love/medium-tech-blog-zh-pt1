<html>
<head>
<title>AWS Lambda Java Tutorial: Best Practices to Lower Cold Starts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda Java教程:降低冷启动的最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/aws-lambda-java-tutorial-best-practices-to-lower-cold-starts-capital-one-dc1d8806118?source=collection_archive---------5-----------------------#2020-05-14">https://medium.com/capital-one-tech/aws-lambda-java-tutorial-best-practices-to-lower-cold-starts-capital-one-dc1d8806118?source=collection_archive---------5-----------------------#2020-05-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="0ffd" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">从海龟到飞人</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/042b627e98b31c8dc31cde3ae8e87efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L9i0QBQYwlLmgTGi.png"/></div></div></figure><p id="d7dd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">海龟经常被认为是动物王国中行动缓慢的人，作为一名云端Java工程师，我感觉自己与这些动物有某种精神上的联系。加入我的旅程，我们将带着我们的AWS Lambda Java函数从 <a class="ae kf" href="https://www.youtube.com/watch?v=i6nYWsXnl6M" rel="noopener ugc nofollow" target="_blank"> <em class="ke">【伯蒂】【超速王】乌龟</em> </a> <em class="ke">到</em> <a class="ae kf" href="https://www.discovermagazine.com/the-sciences/the-first-earthlings-around-the-moon-were-two-soviet-tortoises" rel="noopener ugc nofollow" target="_blank"> <em class="ke"> Zond 5乌龟</em> </a> <em class="ke">。</em></p><p id="5d9f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">嗨，我是肖恩·奥图尔。我是英国第一资本公司的首席软件工程师。我在2019年底参加了AWS re:Invent，学到了很多与我在云中工作的后端工程师角色相关的有趣的事情。我将写一系列关于我在re:Invent中学到的关于云工程实践的东西的帖子，希望将这些最佳实践灌输给Java社区。在第一部分AWS Lambda Java教程——中，我们将探讨AWS Lambda和Java的最佳实践，以帮助提高冷启动时的性能。</p><p id="2598" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">AWS工程师已经做了很多工作来帮助解决这个问题，例如<a class="ae kf" href="https://aws.amazon.com/blogs/aws/new-provisioned-concurrency-for-lambda-functions/" rel="noopener ugc nofollow" target="_blank">供应并发</a>，但是我们仍然应该努力编写更多适合云的代码来获得我们可以获得的性能。在这篇AWS Lambda教程中，我们将会看到11个最佳实践，当我们在Lambda这样的资源受限环境中工作时，这些实践会使我们的Java代码更适合云。这包括减少依赖性，利用更多lambda友好的库，减少反射，以及一些特定于lambda的技巧来获得更好的性能。所以，事不宜迟，让我们直接开始把你的应用从turtle变成hurtle。</p><h1 id="22c9" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">Java和AWS Lambda有什么问题？</h1><p id="945c" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">lambda <strong class="jk hi">里的Java可以</strong>慢。众所周知，Java在AWS Lambda冷启动执行时间方面有一段特别艰难的时间，这是AWS博客中的<a class="ae kf" href="https://aws.amazon.com/blogs/opensource/java-apis-aws-lambda" rel="noopener ugc nofollow" target="_blank">所涉及的内容，也是</a><a class="ae kf" href="https://levelup.gitconnected.com/aws-lambda-cold-start-language-comparisons-2019-edition-%EF%B8%8F-1946d32a0244" rel="noopener ugc nofollow" target="_blank">广泛发布的</a> <a class="ae kf" href="https://hackernoon.com/cold-starts-in-aws-lambda-f9e3432adbf0" rel="noopener ugc nofollow" target="_blank">其他地方发布的</a><a class="ae kf" href="https://mikhail.io/serverless/coldstarts/aws/" rel="noopener ugc nofollow" target="_blank"/>。这种行为甚至在控制诸如在VPC中运行时创建弹性网络接口之类的事情时也存在——尽管这本身最近已经通过<a class="ae kf" href="https://aws.amazon.com/blogs/compute/announcing-improved-vpc-networking-for-aws-lambda-functions/" rel="noopener ugc nofollow" target="_blank"> AWS对VPC网络</a>的更改而得到了改善。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ld"><img src="../Images/360574a97dca5cd93f02f86ed2f6647a.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/1*MTanUKyvDwoMImnVgnD5pQ.png"/></div></figure><p id="083c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">想象一只笨重的大乌龟，被冰覆盖着，从冬眠中醒来，仍然昏昏沉沉(<a class="ae kf" href="https://www.merriam-webster.com/dictionary/brumation" rel="noopener ugc nofollow" target="_blank"> brumation </a>)，你非常接近使用Java的AWS Lambda冷启动的感觉。这很大程度上归结于我们使用Java编写lambda函数的方式。有些事情我们已经依赖或认为是理所当然的——比如具有看似无限的CPU和内存的基础设施、廉价的反射以及服务生命周期内的一次启动——在lambda环境中并不成立。如果我们在我们正在处理的系统的约束下工作，并在考虑这些约束的情况下做出一些改进，我们就可以从冰上的海龟变成旱冰鞋上的海龟，并告别缓慢的冷启动。</p><h1 id="d0ff" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">有什么解决办法？尝试这些AWS Lambda Java最佳实践</h1><p id="1f5b" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">我们很幸运，因为我们可以做很多事情来提高Java函数的性能。在本教程中，我将介绍11个AWS Lambda Java最佳实践，并尝试给出一些实际例子来说明这是如何工作的。</p><h2 id="be02" class="le kh hh bd ki lf lg lh km li lj lk kq jr ll lm ks jv ln lo ku jz lp lq kw lr bi translated">衡量当前绩效</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ls"><img src="../Images/744e6b2a9b1dd0390d45332109eb8bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*Dh3PONbg6xTrzq0gRmy8pA.png"/></div></figure><p id="8d49" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">你要做的第一件事是评估你当前的表现。不幸的是，这并不像一只手拿着卡钳，一只手拿着海龟那么简单。相反，您可以通过将您的函数部署到AWS，调用它，然后测量完成调用需要多长时间来完成。就像前面提到的卡尺一样，有一些工具可以用来测量lambda的性能。一个这样的工具是<a class="ae kf" href="https://gatling.io/" rel="noopener ugc nofollow" target="_blank"> Gatling </a>，你可以用它来调用你的lambda很多次，然后看看报告中的响应时间，它会产生一个很好的可视化效果，并给你原始的数字。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lt"><img src="../Images/6ef7a2e6673404c838e47d416f08dff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*gjo6_lST_ZxCFHlqF3O8hw.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx">Report I generated in Gatling</figcaption></figure><p id="ba32" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">还有一个叫做<a class="ae kf" href="https://aws.amazon.com/xray/" rel="noopener ugc nofollow" target="_blank"> X射线</a>的AWS仪器工具非常出色。基本思想是用X射线调用来检测代码，然后在AWS控制台中检查结果，看事情要花多长时间。有许多内置的记录器可以监视HTTP调用、AWS SDK调用等。，该工具可以在检测lambda函数时自动显示JVM初始化时间。</p><p id="1ae4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">除此之外，还有第三方提供类似的功能，如<a class="ae kf" href="https://www.appdynamics.com/" rel="noopener ugc nofollow" target="_blank"> AppDynamics </a>和<a class="ae kf" href="https://www.datadoghq.com/" rel="noopener ugc nofollow" target="_blank"> DataDog </a>值得关注。</p><h2 id="dc95" class="le kh hh bd ki lf lg lh km li lj lk kq jr ll lm ks jv ln lo ku jz lp lq kw lr bi translated">分配更多内存</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ly"><img src="../Images/a171b6e4d9f313eeb737b62eff66b16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*seJ18Mv6HmHodcBQZiU32g.png"/></div></figure><p id="840a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">大象可能永远不会忘记，但一只200岁的乌龟肯定看到了一些东西。如果你给lambda函数分配更多的内存，它会运行得更快。好了，博文结束了，我现在可以不打字了吗？</p><p id="f938" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">好吧，所以这个有点逃避。但是如果你发现你的128mb lambda函数启动和执行的时间太长，你可以把它换成3008mb的lambda函数，它会运行得更快。这部分是由于AWS Lambda中的线性扩展资源模型，因为<a class="ae kf" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-console.html" rel="noopener ugc nofollow" target="_blank"> Lambda与配置的内存量</a>成比例地线性分配CPU功率。这意味着更多的内存意味着更多的CPU，这意味着更快的功能。</p><p id="2d02" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">不幸的是，这也意味着更多的钱。将所有128mb的lambda函数扩展到3008mb的不利之处在于，运行的<a class="ae kf" href="https://aws.amazon.com/lambda/pricing/" rel="noopener ugc nofollow" target="_blank">成本可能是运行</a>的25倍左右(取决于请求的数量和长度)。这听起来可能很糟糕，但它可能不像看起来那么重要，因为这完全取决于你的流量概况。在我的团队中，我们有一项服务，每月约有30万个呼叫，其中99%的呼叫在100毫秒内完成。在这种情况下，从128mb迁移到3008mb将使我们每月的计算费用从大约0.06美元增加到大约1.47美元。相对来说是一个很大的增长，但从表面上看，实际上并没有什么大不了的。</p><p id="34af" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，如果你的流量档案更接近于我们的姐妹团队所拥有的服务，你可能会看到一个更大的账单。他们的流量概况接近每月400，000，000个请求，耗时约300毫秒——这使你从每月2500美元(128mb内存)到惊人的58750美元。此外，lambda上可能有数百个服务，其流量配置文件介于这两个极端之间，因此在这种情况下，保持较低的内存大小绝对符合您的最佳利益。</p><h2 id="8249" class="le kh hh bd ki lf lg lh km li lj lk kq jr ll lm ks jv ln lo ku jz lp lq kw lr bi translated">减少依赖性</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lz"><img src="../Images/86f827c35702e3e3fcb1a02faf3c7fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*HZnGdvtpfC1lNW7aUOSr_w.png"/></div></figure><p id="fffb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">减少部署的jar中依赖项的数量将对函数的冷启动时间产生积极的影响。最初我认为这与jar的大小有关——更多的依赖项意味着将这些依赖项打包到jar中，这意味着更大的jar文件。理论上，这需要更长的时间来拉低，因此速度较慢。事实证明，虽然这是真的，但它在大格局中的影响可以忽略不计。</p><p id="6314" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">不管冷启动与否，jar几乎是直接被缓存的，网络IO永远不会成为问题，除非你有一个大得离谱的文件。拥有大量依赖项的实际问题是您必须加载的类的数量。</p><p id="d456" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们来看一个示例<a class="ae kf" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank">spring oot</a>应用程序，它利用<a class="ae kf" href="https://spring.io/guides/gs/spring-boot/" rel="noopener ugc nofollow" target="_blank">spring oot入门指南</a>返回“Hello World”。</p><p id="f375" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个项目在启动时加载了大约5，900个类，在第一次调用时又加载了大约200个。如果你像我一样，你从来没有真正研究过这个问题——在我的笔记本电脑上，启动服务器接受HTTP调用需要大约1.59秒，而<a class="ae kf" href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html" rel="noopener ugc nofollow" target="_blank"> jstat </a>报告所有的类都在大约1.8秒内完成加载。如果您运行在具有大量CPU和内存的大型EC2服务器上，这可能会更快。</p><p id="a35c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们忽略了这样一个事实，即大约6000个服务于一个HTTP请求的类是一个非常大的数目。从长远来看——如果运行“Hello World”jar，加载的基本Java运行时大约有460个类。使用<em class="ke"> aws-lambda-java-core </em>依赖项运行lambda的最低要求是增加另外9个类，所以对于一个全功能的lambda函数，我们只需要不到500个类。当使用<a class="ae kf" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> API网关</a>或<a class="ae kf" href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html" rel="noopener ugc nofollow" target="_blank">应用负载平衡器</a>连接时，您仍然能够服务HTTP请求。</p><p id="178f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如前所述，您可以使用<em class="ke"> jstat </em>自己做这个实验，它会给出加载的类的数量和花费的时间:</p><pre class="ix iy iz ja fd ma mb mc md aw me bi"><span id="38bd" class="le kh hh mb b fi mf mg l mh mi">$ java -jar &lt;your-jar&gt;<br/>$ jstat -class &lt;pid&gt; 1000</span></pre><p id="676e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">或者，您可以使用一个更成熟的工具，如<a class="ae kf" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jvisualvm.html" rel="noopener ugc nofollow" target="_blank"> jVisualVM </a>并执行堆转储，这将为您提供加载的类的概要以及当前正在使用的类的实例数量:</p><pre class="ix iy iz ja fd ma mb mc md aw me bi"><span id="dddc" class="le kh hh mb b fi mf mg l mh mi">$ jvisualvm — openpid &lt;pid&gt;</span></pre><p id="025c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您甚至可以在启动jar时使用一些详细的类日志记录，这将为您提供已经加载的所有单个类的列表。这种方法对于找出哪些依赖项花费了您最多的类非常有用:</p><pre class="ix iy iz ja fd ma mb mc md aw me bi"><span id="b89a" class="le kh hh mb b fi mf mg l mh mi">$ java -cp your.jar -verbose:class MainClass | grep Loaded &gt; loaded.txt</span></pre><p id="c91b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从这个文件中，您可以执行一些简单的grep命令来找出哪些依赖项的开销最大。</p><p id="1bfd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">举一个实际的例子，让我们看看前面的简单的SpringBoot应用程序。我将把命令和输出一行一行地分开，而不是使用神奇的一行程序，这样更容易理解。</p><pre class="ix iy iz ja fd ma mb mc md aw me bi"><span id="9abf" class="le kh hh mb b fi mf mg l mh mi">$ java -cp build/libs/springboot-app.jar -verbose:class org.springframework.boot.loader.JarLauncher &gt; startup.txt <br/>$ cat startup.txt | grep Loaded | sort &gt; loaded-classes.txt</span></pre><p id="6de4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这将为您提供一个文本文件，其中包含您在启动服务时加载的大约6000行类，我们可以检查该文件以获取一些数据。例如，这些类中有多少是直接依赖Spring的？</p><pre class="ix iy iz ja fd ma mb mc md aw me bi"><span id="9ef4" class="le kh hh mb b fi mf mg l mh mi">$ cat loaded-classes.txt | grep org.springframework | wc -l 2496</span></pre><p id="cc61" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">哎哟！那可是很多课啊。</p><p id="ae04" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，我并不主张在任何地方完全重新发明轮子，并且永远不再使用另一个依赖项，但是花时间适当地检查您正在引入的依赖项，并执行成本效益分析，以确定是否值得增加成本或增加延迟，这是我们都应该做的事情。</p><p id="7ad3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">有趣的海龟事实:海龟平均一窝产110个蛋，一个季节平均产2到8窝。他们不养育他们的幼仔，谈论减少依赖！</em></p><h2 id="0c83" class="le kh hh bd ki lf lg lh km li lj lk kq jr ll lm ks jv ln lo ku jz lp lq kw lr bi translated">使用AWS SDK v2</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mj"><img src="../Images/fc2cc5885c62873ea045b4c99bad8c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*t9bmYzzeLQv6O-Lbe7Wpww.png"/></div></figure><p id="4e02" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">你知道2018年底发布了新版本的<a class="ae kf" href="https://aws.amazon.com/sdk-for-java/" rel="noopener ugc nofollow" target="_blank"> AWS SDK </a>吗？我直到最近才使用它，并且惊讶地发现它在这种情况下是如何有用的。SDK的V1于2010年3月首次提供使用，尽管直到今天它仍在继续接收更新，但API和底层基础架构仍然与十年前的构建方式非常相似。V2最近于2018年11月面向大众发布，并针对lambda等无服务器框架进行了更好的优化。使用V2而不是V1的一些好处是，它包含更少的依赖性，允许非阻塞IO，并且比原始库有更好的配置选项，包括利用HTTP插件定制HTTP库的能力，等等。</p><p id="ddd9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">不要忘记排除你不使用的可传递依赖——V2包括Netty和Apache HTTP库，在大多数用例中你通常不需要它们。</p><p id="7713" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">还在用V1吗？亚马逊提供了一个<a class="ae kf" href="https://docs.aws.amazon.com/sdk-for-java/v2/migration-guide/what-is-java-migration.html" rel="noopener ugc nofollow" target="_blank">迁移指南</a>，用于更新你的代码以使用库的V2而不是V1。</p><h2 id="84e1" class="le kh hh bd ki lf lg lh km li lj lk kq jr ll lm ks jv ln lo ku jz lp lq kw lr bi translated">使用基本的HTTP客户端</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mk"><img src="../Images/a62b26fc52d58a37bc03059dcb14b790.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*SIYAh54kGL4iYIFsdCEk8g.png"/></div></figure><p id="d35a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">AWS SDK附带了许多不同的HTTP客户端库，可用于进行SDK调用。这些都是会唱歌、会跳舞的库，它们可以进行连接池和一大堆其他的东西，这些东西在一些场景中非常有用，比如当你在一个长生命周期的服务器上时。</p><p id="3cee" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Lambda不属于这种情况。实际上，大多数时候您将进行一次或者几次HTTP调用，然后将结果返回给您的客户机。由于lambda函数一次只能处理一个传入的请求，所以您甚至不太可能有机会执行您创建的任何其他连接。这意味着任何并发请求都将进入一个单独的lambda函数(有自己的连接池)。要么这样，要么你已经完成了在传递回你的响应时已经在使用的连接，所以它仍然可以被这个lambda的下一个请求再次使用。</p><p id="d04b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">内置的Java HTTP客户端对于lambda函数中的几乎所有用例来说都应该足够好，所以尽可能地使用它，除非您有令人信服的理由使用更复杂的东西。</p><h2 id="fc12" class="le kh hh bd ki lf lg lh km li lj lk kq jr ll lm ks jv ln lo ku jz lp lq kw lr bi translated">完全指定AWS SDK客户端</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ml"><img src="../Images/6753d4dcf3a11acaf7a5bef91ca29549.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*eeTrHXshBVG0Ig7aH3FfSw.png"/></div></figure><p id="0001" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">好的，你已经从AWS SDK的V1搬到了V2，但是你还可以做更多的改进。其中之一是完全指定单个SDK客户端的配置，而不是使用作为提供者链一部分的自动发现。</p><p id="d941" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您已经控制了环境和lambda函数，所以您应该知道您的凭证来自哪里、您正在运行的区域、您正在使用的AWS服务的服务端点等等。通过预先指定这些，您可以确保SDK不需要做比初始化时更多的工作。一个很好的例子是，如果你没有指定一个端点覆盖，那么SDK会使用<a class="ae kf" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank"> Jackson </a>读取并解析一个包含所有地区所有服务的所有端点的大型JSON文件——所以这里有IO和反射来解决一些已知的问题。</p><h2 id="b829" class="le kh hh bd ki lf lg lh km li lj lk kq jr ll lm ks jv ln lo ku jz lp lq kw lr bi translated">移除昂贵的依赖注入框架</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mm"><img src="../Images/ad5770d334f21879396d05036cb84f08.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*7ekyE2f8rq45G4sDr4TzbA.png"/></div></figure><p id="96e5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然注射可能对海龟有好处，但在lambda环境中对Java来说就不那么健康了。许多最常用的依赖注入框架运行起来可能很昂贵。当你要求它们时，它们会使用类路径扫描和反射来创建一大堆对象，并将它们链接在一起。这在lambda环境中不太好，因为在内存和CPU有限的环境中，反射非常慢。</p><p id="c1a5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果你正在使用基于反射的依赖注入框架，你有两个选择来提高速度:</p><ol class=""><li id="a224" class="mn mo hh jk b jl jm jo jp jr mp jv mq jz mr kd ms mt mu mv bi translated"><strong class="jk hi">转向一个不是基于反射的框架</strong>——比如<a class="ae kf" href="https://github.com/google/dagger" rel="noopener ugc nofollow" target="_blank">匕首</a>。这使用注释在编译时预先生成Java源代码，因此您不必在以后进行任何反射或字节码生成——这样会快很多。</li><li id="21fc" class="mn mo hh jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated"><strong class="jk hi">完全移除依赖注入框架。这听起来可能有些极端，但请听我说。如果你的lambda函数足够小(它应该足够小)，那么拥有一个完整的依赖注入框架所带来的好处并不像你想象的那么明显。一个三层的SpringBoot应用程序有一大堆深入到应用程序中的依赖关系(多个层),让依赖注入框架为您处理一切肯定会有好处。如果我们正在编写没有几层的小型lambda函数，那么依赖注入框架就没什么用了。一个有用的lambda可以有一个和Handler&gt;Service&gt;dynamo client一样小的层次结构，这更容易管理。这消除了对阿迪框架的需求，使得自己初始化对象并将它们传递给构造函数成为处理依赖链的一种更简单的方式。</strong></li></ol><h2 id="3a99" class="le kh hh bd ki lf lg lh km li lj lk kq jr ll lm ks jv ln lo ku jz lp lq kw lr bi translated">消除反射</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nb"><img src="../Images/747309967aa49d0586627daabf8a19fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*ApaH1SSsdrmKppoklo65xw.png"/></div></figure><p id="d2f0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">镜子，镜子，在湖上，我还能做些什么改变？摆脱反思，或者至少尽你最大的努力减少它。如上所述，在lambda等内存受限的环境中，反射真的很慢。这意味着你应该尽可能地避免自己动手，甚至可以毫不犹豫地开始使用不同的库，而不是我们经常使用的库。从前面的观点来看，依赖注入是一个明显的问题，我们已经讨论了一些选项。还有其他领域，比如使用Jackson的JSON编组和解组，有时可以用同样的方式替换代码生成库，比如<a class="ae kf" href="https://github.com/square/moshi" rel="noopener ugc nofollow" target="_blank"> Moshi </a>。</p><p id="f007" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这说起来容易做起来难，因为AWS SDK本身使用Jackson来执行自己的解组。然而，您也许可以在自己的代码中使用一些不同的东西。在我们的一些服务中，我们使用Moshi对ALB请求和响应进行编组和解组，利用RequestStreamHandler并对输入和输出流进行操作，这比Jackson编组更快，体验很好。</p><h2 id="ad4c" class="le kh hh bd ki lf lg lh km li lj lk kq jr ll lm ks jv ln lo ku jz lp lq kw lr bi translated"><strong class="ak">在初始化时初始化依赖关系</strong></h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nc"><img src="../Images/96f367737115646f704bd87648c2a365.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*18MxOZ6NGMzQToqNQclBcQ.png"/></div></figure><p id="dfd3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">你知道龟兔赛跑的故事吗？尽管兔子开始跑得很快，但他却变得自满，最终输掉了比赛。嗯，Lambda函数完全不是这样的-你开始得越快，完成得越快，有一个小技巧可以让你的乌龟像兔子一样开始比赛。</p><p id="5ea2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">先说理论。Lambda函数在被调用时会经历两个阶段- <em class="ke">初始化</em>和<em class="ke">运行时</em>。初始化只在lambda函数在没有执行上下文的情况下启动时运行，这就是我们所说的“冷启动”之后，它将尝试重用执行上下文，因此只运行运行时阶段。初始化阶段负责使您的函数代码可调用的一切——JVM启动、对象初始化等。-在运行时阶段调用handle方法所需的一切。</p><p id="52bb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这种两阶段方法的一个不太为人所知的事实是，在初始化期间，您可以提高对CPU的访问，然后在运行时降低访问。这意味着任何昂贵的操作最好在初始化时完成，因为它们将在访问更多CPU时更快地完成。</p><p id="5c3d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在现实世界中，这对于大多数实现来说可能不是问题——作为对象实例化的一部分创建的任何东西都会在初始化时发生。这包括静态字段和块、实例字段和块以及构造函数调用。大多数情况下，我们会在初始化时创建依赖项，对吗？但是，我们在第一次调用时延迟创建延迟加载的异议并不罕见，因为它很昂贵，并且您无意中让它在我们受到CPU限制时被创建——这可能会比我们只是提前创建它花费更长的时间。</p><h2 id="3376" class="le kh hh bd ki lf lg lh km li lj lk kq jr ll lm ks jv ln lo ku jz lp lq kw lr bi translated"><strong class="ak">初始化时的主要依赖关系</strong></h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nd"><img src="../Images/632f25bca831e87050a28dc56683d886.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/1*XLkI5oUYr2AEOTK21QcTsA.png"/></div></figure><p id="9ba1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这一步可能会比上一步更有用。在我们初始化了我们的SDK客户端并在初始化阶段设置好它们之后，这应该意味着我们可以在运行阶段毫无问题地使用它们，对吗？</p><p id="aa70" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">没有那么多。很多AWS SDKs都是延迟加载的——所以即使你预先初始化DynamoDB客户端，很多<em class="ke">实际的</em>初始化也不会发生，直到你调用GetItem或PutItem。例如，DynamoDB中的PutItem可能需要<strong class="jk hi">9</strong>秒来初始化Jackson marshallers、启动连接等。第一次调用它时，内存占用很小。</p><p id="56b3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">您可以通过使用上面的技巧来绕过这种昂贵的运行时初始化，但这次我们将进行“启动”方法调用，而不仅仅是实例化对象。这感觉不太好，但是如果将DynamoDB PutItem调用移到初始化阶段，访问提升CPU只需700毫秒，然后运行时阶段的后续调用将有一个准备就绪的客户端。</p><p id="bcff" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在您的“healthcheck”调用中使用这种方法可能是值得的——使用DynamoDB客户端对一个已知项目进行GetItem调用，这不仅会为您的客户端做好准备，还会检查您与DynamoDB的连接，使其成为更有用的健康检查。</p><h2 id="fa40" class="le kh hh bd ki lf lg lh km li lj lk kq jr ll lm ks jv ln lo ku jz lp lq kw lr bi translated">通过<strong class="ak"> GraalVM </strong>使用本地可执行文件</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ne"><img src="../Images/05e1f93f13083d30eeae2049b70efb5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*ZYXFwY0BE70jw2USLcJR7A.png"/></div></figure><p id="7aaf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这一部分肯定值得比这篇博客文章更深入的展开，但是未来开发的一个重要收获是使用诸如<a class="ae kf" href="https://www.graalvm.org/" rel="noopener ugc nofollow" target="_blank"> GraalVM </a>与<a class="ae kf" href="https://micronaut.io/" rel="noopener ugc nofollow" target="_blank"> Micronaut </a>或<a class="ae kf" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus </a>结合的工具来生成本机可执行文件，这些文件作为本机可执行文件直接在底层操作系统上运行，而不是在JVM上执行。它的设置看起来相当复杂，并且有很多信息，我无法在这里一一介绍，但它可能是一些有趣的东西，值得进一步研究。这种方法还不完全成熟，所以在生产服务中使用它之前，我会小心谨慎——但是这方面的事情发展很快，这肯定是需要注意的。</p><p id="9e5b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="ke">资源了解更多:</em> </strong></p><ol class=""><li id="e7ba" class="mn mo hh jk b jl jm jo jp jr mp jv mq jz mr kd ms mt mu mv bi translated">上面各个产品的链接包含入门指南，应该可以让您相对快速地入门。</li><li id="2a4d" class="mn mo hh jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">这篇<a class="ae kf" rel="noopener" href="/journeyintocloud/hello-world-on-quarkus-graalvm-gradle-5209357b423a">博客文章</a>深入到使用Quarkus创建一个HelloWorld应用程序，它可以让您在几分钟内启动并运行。</li><li id="0141" class="mn mo hh jk b jl mw jo mx jr my jv mz jz na kd ms mt mu mv bi translated">Opsgenie 上的这篇<a class="ae kf" href="https://engineering.opsgenie.com/run-native-java-using-graalvm-in-aws-lambda-with-golang-ba86e27930bf" rel="noopener ugc nofollow" target="_blank">文章通过一个使用Golang运行时在AWS Lambda中运行的本地Java示例，深入探讨了GraalVM的优势。</a></li></ol><h1 id="a02d" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">结论</h1><p id="a67c" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">使用Java时，我们可以遵循许多最佳实践来减少AWS Lambda冷启动时间。我们已经讨论了一些领域，比如测量您当前的性能，减少您的依赖项的数量和复杂性，以及减少反射的重要性。此外，我们还简要介绍了一些东西，如Quarkus和GraalVM，它们保证了将来更深入的研究。</p><p id="a761" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我希望你喜欢这篇AWS Lambda Java教程。要了解更多关于我们已经讨论过的内容，我推荐观看关于AWS Lambda和Java最佳实践的<a class="ae kf" href="https://www.youtube.com/watch?v=ddg1u5HLwg8" rel="noopener ugc nofollow" target="_blank">AWS re:Invent专题讲座</a>。很漂亮-你应该去看看。但可悲的是，没有任何海龟参考。</p><p id="2990" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">原载于</em><a class="ae kf" href="https://www.capitalone.com/tech/cloud/aws-lambda-java-tutorial-reduce-cold-starts/" rel="noopener ugc nofollow" target="_blank"><em class="ke"/></a><em class="ke">。</em></p></div><div class="ab cl nf ng go nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ha hb hc hd he"><p id="7f18" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">披露声明:2020资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>