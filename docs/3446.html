<html>
<head>
<title>Repository Cleanup (Merged Branch Deletion)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">储存库清理(合并分支删除)</h1>
<blockquote>原文：<a href="https://medium.com/globant/repository-cleanup-merged-branch-deletion-b41edf843117?source=collection_archive---------0-----------------------#2020-07-29">https://medium.com/globant/repository-cleanup-merged-branch-deletion-b41edf843117?source=collection_archive---------0-----------------------#2020-07-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="eadd" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated"><strong class="ak">总结- </strong></h1><p id="6e16" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这个博客面向那些负责维护一个巨大的源代码仓库的目标用户，这个仓库中有成百上千个分支，并且避免以后作为服务器上的清理或空间问题的一部分的可管理性问题。</p><h1 id="a37f" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated"><strong class="ak">历史- </strong></h1><p id="b7be" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们使用Bitbucket来大规模存储所有的存储库。我们有几十个项目，每个项目有数百个存储库，每个存储库有数千个分支，有些是活跃的，大多数在几年前就合并了。通过查看每个存储库，它是如此之大，以至于我们必须浏览多个页面才能找到一些东西，这种痛苦促使我们找到一种解决方案来清理所有合并的分支，但仅超过30天，以避免不必要的问题。</p><h1 id="6eea" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated"><strong class="ak">本期- </strong></h1><p id="e67c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">作为一名DevOps工程师，我多次观察到，大多数开发人员不断创建新的分支，并根据他们定义的分支模型将这些分支合并到目标分支。然而，他们往往会错过删除那些已经合并的分支，这些分支随后会堆积起来并消耗大量磁盘空间，导致存储库访问缓慢，浏览多个页面以找到特定的提交等。和可管理性问题。</p><h1 id="2aac" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated"><strong class="ak">解/s - </strong></h1><p id="00ec" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">对于这个问题，我们有三种不同的解决方案。我还添加了每个解决方案的<strong class="je hi">优点</strong>和<strong class="je hi">缺点</strong>。让我们看看下面这些-</p><p id="745c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">解决方案-1(使用复选框)</strong></p><p id="3dbd" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">大多数存储库提供程序中可用的一个解决方案是启用复选框，同时创建一个新的pull请求来删除合并的分支，或者在通过选择provide复选框从存储库控制台或命令行合并请求时处理它。</p><p id="ff94" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">比如说-</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/b13fdcd563a6093f941fc07676e0b54f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qzhlEDdILqBlfsY2"/></div></div></figure><p id="2e5c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">优点:</strong>通过选择这个选项，可以避免以后的堆积问题。您的存储库看起来整洁干净，只有活动的分支。</p><p id="6539" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">缺点:</strong>每次审批请购单时，记住选中合并复选框会很痛苦。</p><p id="e395" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">解决方案2(使用删除选项)</strong></p><p id="2e92" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">实现相同功能的另一个解决方案是从dashboard中删除所有合并的分支(它依赖于像GitHub、git lab、Bitbucket等存储库提供者)。)通过手动选择每个分支，如果您有大量分支分布在许多页面上，这对于删除是不可行的。</p><p id="14ff" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">比如说-</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kr"><img src="../Images/384c4a179b52cf95ca666a0a37e9dbfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZfDBeKetRqomC2Dfiy6tg.png"/></div></div></figure><p id="7c4c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">优点:</strong>通过选择这个选项，一个人可以一次性删除所有合并的分支，但是他必须定期执行这个任务，这可能是手工的和耗时的。然而，它比解决方案1更好。</p><p id="38f1" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">缺点:你必须记住一个执行清理任务的时间表，这个任务仍然是手动的。</p><p id="bf26" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">解决方案-3(脚本)</strong></p><p id="fee2" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们开发的解决方案是创建一个可以定期删除合并分支的自动化。</p><p id="1301" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">以下是为处理删除所有超过30天的合并分支而开发的脚本-</p><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="a5a4" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">优点:</strong>通过选择此选项，用户可以避免手动执行并记住清理任务的时间表。将脚本用作Cron作业，并定期运行它。</p><p id="965f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">缺点:</strong>您可能需要在第一次运行脚本时配置系统并提供适当的空间。</p><h1 id="c558" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated"><strong class="ak">免责声明- </strong></h1><p id="e9ba" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这个脚本只在Bitbucket项目及其存储库上测试。如果你有另一个像GitHub，git lab等这样的库管理器。，您仍然可以使用实际的分支删除逻辑。为此，请参考下面的第4点。</p><p id="889a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">注释- </strong></p><ol class=""><li id="d105" class="kv kw hh je b jf ka jj kb jn kx jr ky jv kz jz la lb lc ld bi translated">如果您的存储库足够大，可能需要更多的时间(在我们的例子中，完成这个过程需要5个多小时)</li><li id="401a" class="kv kw hh je b jf le jj lf jn lg jr lh jv li jz la lb lc ld bi translated">它消耗本地磁盘空间，因为它在本地克隆每个存储库，然后在稍后删除(确保本地有足够的空间来执行此活动。)</li><li id="abcc" class="kv kw hh je b jf le jj lf jn lg jr lh jv li jz la lb lc ld bi translated">分支删除被有意注释，以避免任何意外的删除调用(<strong class="je hi"><em class="ku"># git push origin—delete $ branch</em></strong>)。从该行移除<strong class="je hi"> # </strong>以启用它。</li><li id="73d4" class="kv kw hh je b jf le jj lf jn lg jr lh jv li jz la lb lc ld bi translated">如果你使用其他的库管理器，比如GitHub，Git lab等等。除了Bitbucket，您仍然可以引用实际的删除代码，用粗体标记，作为脚本的一部分。(参考函数<strong class="je hi"><em class="ku">delete _ branch _ if _ merge _ longer _ than _ 30 _ days()</em></strong>)。您可以调整天数，根据您的要求排除其他分支。</li></ol><h1 id="c113" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated"><strong class="ak">结论</strong></h1><p id="8e11" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">最好实现一个自动化的解决方案或流程来确保分支在合并后被删除，而不是上面提到的选项solution-1 &amp; solution-2。</p></div></div>    
</body>
</html>