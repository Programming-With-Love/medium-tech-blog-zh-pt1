# Python 列表-它是什么以及如何使用它

> 原文：<https://medium.com/duomly-blockchain-online-courses/python-list-what-it-is-and-how-to-use-it-6a02ec62a8b3?source=collection_archive---------6----------------------->

![](img/00b2f3ced3d7e187116d0fbec38ca79e.png)

[Duomly — programming online courses](https://www.duomly.com)

本文最初发表于:

[](https://www.blog.duomly.com/python-list-definition-and-usage/) [## Python 列表-定义和用法- Duomly 博客-在线编程课程

### Python 有几种集合数据类型——可能一次保存多个数据项的类型。列表是不可变的…

www.blog.duomly.com](https://www.blog.duomly.com/python-list-definition-and-usage/) 

Python 有几个**集合数据类型**——可能一次保存多个数据项的类型。列表是不可变的有序 Python 序列集合。

更准确地说，集合不存储数据项。他们保留对它们的引用。您可以在一个列表中引用不同类型的对象(整数、浮点数、复数、布尔值、字符串、其他列表或元组、集合或字典、自定义类型等)。您也可以将函数或方法引用放在列表中。一个列表可以包含零个或多个对数据项的引用。

列表可以是其他序列或映射的项目(即列表、元组、集合、字典等)。它们也可以作为参数传递给函数和方法。

列表是内置的，这意味着您不需要导入任何包、类或函数来使用它们。

本文旨在全面介绍如何使用列表以及如何使用列表。它解释道:

*   如何创建列表
*   什么是以及如何获得列表的长度
*   如何测试一个项目是否在列表中
*   列出理解
*   如何将列表与类 map 和 filter 一起使用
*   如何访问带有索引的列表项
*   切片和大步走
*   如何对列表应用 del 语句
*   类列表的方法
*   如何添加和相乘列表
*   如何遍历列表

让我们从创建列表开始。

# 创建列表

用 Python 创建列表最常用的方法是将逗号分隔的项目放在括号内。如前所述，列表中的项目可以是不同的类型:

```
>>> my_list = [0, 1, 2.8, True, 'python', (3, 4, 5), {11, 12}, 64]
>>> my_list
[0, 1, 2.8, True, 'python', (3, 4, 5), {11, 12}, 64]
>>> type(my_list)
<class 'list'>
```

你也可以通过提供一些序列作为类列表初始化器的第一个也是唯一的参数来创建一个列表实例:

```
>>> my_tuple = (5, 12, 13)
>>> my_other_list = list(my_tuple)
>>> my_other_list
[5, 12, 13]
```

这种方法通常与内置类范围的使用相结合:

```
>>> list(range(0, 41, 5))
[0, 5, 10, 15, 20, 25, 30, 35, 40]
```

在 Python 中，字符串是序列，所以这也适用:

```
>>> my_list = list('ABCDEFGH')
>>> my_list
['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
```

创建空列表(没有元素的列表)与此类似。要么使用一对空括号，要么使用不带参数的列表:

```
>>> my_empty_list = []
>>> my_empty_list
[]
>>> my_empty_list = list()
>>> my_empty_list
[]
```

这些是创建列表的基本方法。在下面几节中，您将看到其他几种方法。

# 列表的长度

您可以通过调用内置函数 len()并以 list 作为参数来获取列表中的项目数:

```
>>> x = [2.0, 8.0, True]
>>> len(x)
3
>>> y = [2.0, 8.0, True, (0, 1)]
>>> len(y)
4
```

列表 x 有三项:两个浮点数(2.0 和 8.0)和一个布尔值(True)。列表 y 有四项:前三项与 x 中的相同，还有元组(0，1)。

空列表的长度为 0:

```
>>> z = []
>>> len(z)
0
```

在布尔上下文中，空列表被评估为 False，而任何非空列表被视为 True:

```
>>> bool(x)
True
>>> bool(y)
True
>>> bool(z)
False
```

在 if 语句中利用这一事实是非常巧妙的。例如，您不必这样做:

```
>>> if len(x) > 0:
...     print('there are some elements in the list x')
... else:
...     print('the list x is empty')
... 
there are some elements in the list x
```

相反，您可以利用 len(x)有其布尔值这一事实:

```
>>> if len(x):
...     print('there are some elements in the list x')
... else:
...     print('the list x is empty')
... 
there are some elements in the list x
```

这两个代码示例都工作得很好，但是下面的代码被认为更紧凑，并且如前所述，更 Pythonic 化。

# 测试成员资格

列表支持中的成员资格运算符，该运算符允许测试列表是否包含某些项目:

```
>>> x = [2, 8, 11.2, 8, 14, 2, False, 8, 'python rules']
>>> 8 in x
True
>>> 9 in x
False
```

在上面的例子中，列表 x 有第 8 项；因此，x 中的 8 返回 True。相反，x 不包含 9，所以 x 中的 9 是假的。

您可以不类似地使用该构造:

```
>>> 8 not in x
False
>>> 9 not in x
True
```

Python 集合是唯一项目的无序序列。它们比列表更便于成员资格测试。有时，创建对应于列表的集合并对该集合执行成员资格测试是一个好主意:

```
>>> set(x)
{False, 2, 8, 11.2, 14, 'python rules'}
>>> 8 in set(x)
True
```

一般来说，如果你需要一个列表中唯一的条目，并且不在乎它们的顺序，可以考虑创建相应的集合。

# 列出理解

列表理解是创建列表的一种有效且干净的方式。例如，这就是你如何用数字 2 的幂创建一个列表:

```
>>> my_list = [2**item for item in range(8)]
>>> my_list
[1, 2, 4, 8, 16, 32, 64, 128]
```

列表理解可以包含额外的 if 子句来过滤数据。例如，让我们用 my_list 中大于 50 的项目创建一个新列表:

```
>>> my_other_list = [item for item in my_list if item > 50]
>>> my_other_list
[64, 128]
```

这些只是一些简单的例子。列表理解可以包含更复杂的代码。

# 使用带有映射和过滤器的列表

您可以使用内置的 map 和 filter 类在函数式编程风格中创建列表，而不是使用列表理解。我们将使用与上一节相同的示例。

map 需要一个函数和一系列要应用该函数的值。它生成函数返回值的序列。例如:

```
>>> my_list = list(map(lambda item: 2**item, range(8)))
>>> my_list
[1, 2, 4, 8, 16, 32, 64, 128]
```

filter 还接受一个函数和一系列用作参数的值。它用原始序列中的值生成一个序列，使函数返回 True。例如:

```
>>> my_other_list = list(filter(lambda item: item > 50, my_list))
>>> my_other_list
[64, 128]
```

然而，在大多数情况下，列表理解被认为是创建列表的更好的方法。

# 使用索引访问元素

列表是有序的集合，您可以使用相应的整数索引来访问特定的元素。

在 Python 中，索引是*从零开始的*，这意味着索引 0 对应于第一个(最左边的)项，索引 1 对应于第二个，以此类推，而等于 len(x) — 1 的索引对应于列表 x 的最后一个(最右边的)项。

这是您访问和修改列表项目的方式:

```
>>> my_list = [12, 2, [0, 1], 5]
>>> my_list[0]
12
>>> my_list[0] = 1
>>> my_list
[1, 2, [0, 1], 5]
>>> my_list[1]
2
>>> my_list[1] = 24
>>> my_list
[1, 24, [0, 1], 5]
```

注意，第三项是另一个列表。您可以类似地访问它:

```
>>> my_list[2]
[0, 1]
```

您还可以访问和修改其项目:

```
>>> my_list[2][0]
0
>>> my_list[2][1]
1
>>> my_list[2][0] = 'i'
>>> my_list[2][1] = 'j'
>>> my_list
[1, 24, ['i', 'j'], 5]
```

Python 允许使用负整数作为索引。然后，-1 对应于列表的最后一个(最右边的)项目，-2 对应于倒数第二个项目，依此类推:

```
>>> my_list[-1]
5
>>> my_list[-2]
['i', 'j']
```

负索引可以像正索引一样用于访问和修改列表项。

# 切片和大步走

您可以从一个列表中提取对某些项目的引用，作为一个新的列表，使用 slicing 和 striding，符号如下:my_list[start:stop:step]。start 是定义提取开始位置的非独占整数索引，end 是显示提取结束位置的非独占整数索引，step 是显示单步移动多少位置的整数。例如:

```
>>> my_list = list('ABCDEFGH')
>>> my_list
['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
>>> my_list[1:6:2]
['B', 'D', 'F']
```

提取从索引 1 开始，即项目“B”。步骤为 2，因此下一项的索引为 3 (= 1 + 2)。对应的项目是' D '。下一个索引是 5 (= 3 + 2)，提取的项是‘F’。提取在之前*停止，我们到达停止值，在这种情况下是索引 6。*

如果省略了一个步骤，则使用默认值 1:

```
>>> my_list[1:6]
['B', 'C', 'D', 'E', 'F']
```

如果 step 为正且省略了 stop，则使用其缺省值 len(my_list ),即当到达列表末尾时提取完成:

```
>>> my_list[1:]
['B', 'C', 'D', 'E', 'F', 'G', 'H']
```

如果步长为正且省略了 start，则使用默认值 0，即从列表的开头开始提取:

```
>>> my_list[:6]
['A', 'B', 'C', 'D', 'E', 'F']
```

按照这个逻辑，您可以通过省略所有三个参数来获得列表的浅层副本:

```
>>> my_list[:]
['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
```

如果 start 大于 stop 并且 step 为负，则可以反向提取项目(以相反的顺序):

```
>>> my_list[4:1:-2]
['E', 'C']
```

利用这个事实可以得到列表的反向浅拷贝:

```
>>> my_list[::-1]
['H', 'G', 'F', 'E', 'D', 'C', 'B', 'A']
```

在这种情况下，默认情况下，计数从列表末尾开始，并在到达列表开头后结束。

如果步长为负，则默认情况下，start 的默认值为-1，stop 位于列表的开头之前。

您也可以使用负指数来表示开始或停止:

```
>>> my_list[:-1]
['A', 'B', 'C', 'D', 'E', 'F', 'G']
```

切片和跨步可用于修改列表:

```
>>> my_list[1:6:2] = ['b', 'd', 'f']
>>> my_list
['A', 'b', 'C', 'd', 'E', 'f', 'G', 'H']
```

如果停止点为 1(或省略)，则可以用任意数量的元素替换切片:

```
>>> my_list[2:6] = ['x', 'y']
>>> my_list
['A', 'b', 'x', 'y', 'G', 'H']
```

这包括零个元素，这是一个空列表:

```
>>> my_list[2:4] = []
>>> my_list
['A', 'b', 'G', 'H']
```

在上面的例子中，您实际上已经从列表中删除了项目“x”和“y”。您可以使用类似的逻辑来删除所有项目，即清除列表:

```
>>> my_list[:] = []
>>> my_list
[]
```

切片非常强大，在某些情况下，可以取代使用类列表的方法。

# 在 del 语句中使用列表

您可以使用 del 语句从列表中删除项目。

要删除单个项目，只需将它传递给 del 语句:

```
>>> x = [1, 2, 4, 8, 16, 32, 64, 128]
>>> del x[1]
>>> x
[1, 4, 8, 16, 32, 64, 128]
```

类似地，可以用一条 del 语句删除多个项目:

```
>>> del x[0], x[1]
>>> x
[4, 16, 32, 64, 128]
```

语句 del x[0]，x[1]首先删除索引 0 处的项，即项 1。然后，项目 8 成为第二个项目，即索引为 1 的项目。接下来就删了。

可以删除切片:

```
>>> del x[1:4]
>>> x
[4, 128]
```

作为此行为的扩展，您可以清除列表，即通过切片删除所有项目:

```
>>> del x[:]
>>> x
[]
```

记住，del x 删除了整个变量 x，如果你试图在那之后访问它，你会得到 NameError。

# 列出方法

类列表有几个有用的方法。它们中的一些可以用来代替切片、删除或连接操作。

。count()返回参数出现在列表中时项目通过的次数:

```
>>> x = [2, 8, 1, 12, 121, 8, 98, 423]
>>> x.count(8)
2
>>> x.count(9)
0
```

。index()返回作为第一个参数提供的项目的最左侧匹配项的索引。可选参数 start(包含，默认为 0)和 end(不包含)显示搜索开始和结束的索引。如果找不到任何项目，它将引发 ValueError:

```
>>> x.index(8)
1
>>> x.index(8, 1, 5)
1
>>> x.index(8, 2, 8)
5
>>> x.index(9)
Traceback (most recent call last):
  File "", line 1, in 
ValueError: 9 is not in list
```

。reverse()就地反转列表:

```
>>> y = [0, 1, True, False]
>>> y.reverse()
>>> y
[False, True, 1, 0]
```

。sort()就地对列表进行排序。可选参数 key(缺省为 None)定义了用于排序的属性。可选参数 reverse(默认为 False)定义了排序是否以相反的顺序进行:

```
>>> x.sort()
>>> x
[1, 2, 8, 8, 12, 98, 121, 423]
>>> x.sort(reverse=True)
>>> x
[423, 121, 98, 12, 8, 8, 2, 1]
```

内置函数 sorted()也可以用来对列表进行排序。它接受一个 list(或其他 iterable)和可选参数 key 和 reverse。它返回一个新列表，而不修改原始的 iterable:

```
>>> x = [2, 8, 1, 12, 121, 8, 98, 423]
>>> sorted(x)
[1, 2, 8, 8, 12, 98, 121, 423]
>>> sorted(x, reverse=True)
[423, 121, 98, 12, 8, 8, 2, 1]
>>> x
[2, 8, 1, 12, 121, 8, 98, 423]
```

。append()将作为参数传递的项追加到列表的末尾:

```
>>> y = [0, 1, True, False]
>>> y.append(1024)
>>> y
[0, 1, True, False, 1024]
```

您可以使用。append()方法使用一个循环来创建一个从空列表开始的列表:

```
>>> my_list = []
>>> for item in range(8):
...     my_list.append(2**item)
... 
>>> my_list
[1, 2, 4, 8, 16, 32, 64, 128]
```

列表理解是实现这一点的首选方式，尤其是在这种简单的情况下。的方法。append()在更复杂的情况下可能会有用。

。extend()将 iterable 中作为参数传递的所有项按顺序追加到列表的末尾:

```
>>> y.extend([2, 4, 8, 4])
>>> y
[0, 1, True, False, 1024, 2, 4, 8, 4]
```

。insert()将作为第二个参数提供的项插入到用第一个参数定义的位置:

```
>>> y.insert(0, -1)
>>> y
[-1, 0, 1, True, False, 1024, 2, 4, 8, 4]
>>> y.insert(2, 'python')
>>> y
[-1, 0, 'python', 1, True, False, 1024, 2, 4, 8, 4]
>>> y.insert(len(y), 'xyz')
>>> y
[-1, 0, 'python', 1, True, False, 1024, 2, 4, 8, 4, 'xyz']
```

。pop()移除带有作为参数提供的索引的项目并返回它。如果没有提供参数，它将删除并返回最右边的项目:

```
>>> y.pop(0)
-1
>>> y
[0, 'python', 1, True, False, 1024, 2, 4, 8, 4, 'xyz']
>>> y.pop()
'xyz'
>>> y
[0, 'python', 1, True, False, 1024, 2, 4, 8, 4]
```

。remove()移除作为参数传递的项目的最左边的匹配项。如果列表中没有这样的项目，它将引发 ValueError:

```
>>> y.remove(4)
>>> y
[0, 'python', 1, True, False, 1024, 2, 8, 4]
>>> y.remove(9)
Traceback (most recent call last):
  File "", line 1, in 
ValueError: list.remove(x): x not in list
```

。clear()从列表中删除所有项目:

```
>>> y.clear()
>>> y
[]
```

。copy()返回列表的浅层副本。这意味着原始列表和新列表包含对相同项目的引用。修改一个列表中的可变元素会影响另一个列表:

```
>>> z = [[2, 8], 'python', True]
>>> z_copy = z.copy()
>>> z_copy
[[2, 8], 'python', True]
>>> z_copy[0][0] = 100
>>> z
[[100, 8], 'python', True]
```

语句 z_copy[0][0] = 100 将 z_copy 的第一项，即列表[2，8]修改为[100，8]。z[0]引用了同一个列表。浅拷贝意味着 z[0]和 z_copy[0]引用同一个对象:修改后的列表。类似地，z[1]和 z_copy[1]指代相同的字符串，z[2]和 z_copy[2]指代相同的布尔值。

# 添加和相乘列表

您可以连接两个列表，并使用+运算符获得新列表，如下所示:

```
>>> x = [1, 10, 100, 1_000, 10_000]
>>> y = [0, False]
>>> x + y
[1, 10, 100, 1000, 10000, 0, False]
```

操作数 x 和 y 保持不变:

```
>>> x
[1, 10, 100, 1000, 10000]
>>> y
[0, False]
```

但是，运算符+=通过将左侧操作数的项添加到右侧操作数的末尾来修改左侧操作数:

```
>>> x += y
>>> x
[1, 10, 100, 1000, 10000, 0, False]
>>> y
[0, False]
```

用整数乘列表是令人兴奋的。它使用运算符*并返回一个包含重复项的新列表:

```
>>> [0, 1] * 4
[0, 1, 0, 1, 0, 1, 0, 1]
>>> z = [[2, 8], 'python', True]
>>> z3 = z * 3
>>> z3
[[2, 8], 'python', True, [2, 8], 'python', True, [2, 8], 'python', True]
```

在这里要小心！重复的是对实际对象的引用。这意味着修改一个对象也会改变相应的对象:

```
>>> z3[0][0] = 100
>>> z3
[[100, 8], 'python', True, [100, 8], 'python', True, [100, 8], 'python', True]
```

z3[0]是对 z3 的第一项的引用，即内部列表[2，8]。事情是这样的，z3[0]，z3[3]，z3[6]都是指同一个对象[2，8]。我们修改了这个对象(列表),将它的第一项从 2 改为 100。这些变化在 z3[3]和 z3[6]位置也是可见的。

运算符*=修改左侧的操作数:

```
>>> z *= 2
>>> z
[[100, 8], 'python', True, [100, 8], 'python', True]
```

当列表与可变项相乘时要小心(比如其他列表、集合或字典)！改变一个项目可能会影响到其他项目，而这通常是你想要的。

# 遍历列表

Python 列表是**可迭代的**。他们有方法。__iter__()。这意味着您可以调用内置函数 iter()，将一个列表作为参数，并获得与该列表对应的**迭代器**对象。

这就是为什么你可以像这样遍历列表的原因:

```
>>> my_list = [0, 1, 2.8, True, 'python', (3, 4, 5), {11, 12}, 64]
>>> for item in my_list:
...     print(item)
... 
0
1
2.8
True
python
(3, 4, 5)
{11, 12}
64
```

如果您想以相反的顺序遍历一个列表，您可以使用内置的 reversed 类并获得迭代器，该迭代器从最后一个开始产生值:

```
>>> for item in reversed(my_list):
...     print(item)
... 
64
{11, 12}
(3, 4, 5)
python
True
2.8
1
0
```

另一个很好内置类是 enumerate。您可以使用它来获取元组，每个元组包含一个项及其索引:

```
>>> for i, item in enumerate(my_list):
...     print(i, item)
... 
0 0
1 1
2 2.8
3 True
4 python
5 (3, 4, 5)
6 {11, 12}
7 64
```

迭代器和生成器在 Python 中非常重要。如果您想深入了解 for 循环和许多其他构造是如何工作的，它们值得进一步探索。

# 结论

本文介绍了如何在 Python 中应用列表。它展示了如何创建列表和修改它们的项目，如何操作切片，如何删除项目和切片，如何遍历列表，等等。希望它能帮助你开始有效地使用列表。

继续学习！

![](img/dc1cecdc7bb81a35e1ffcdef4beb820e.png)

[Duomly — programming online courses](https://www.duomly.com)

感谢您的阅读！

本文由我们的队友米尔科提供。