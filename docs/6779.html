<html>
<head>
<title>API Development: Rest Vs GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">API开发:Rest与GraphQL</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/api-development-rest-vs-graphql-c54c530b5dec?source=collection_archive---------0-----------------------#2019-12-19">https://medium.com/quick-code/api-development-rest-vs-graphql-c54c530b5dec?source=collection_archive---------0-----------------------#2019-12-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/22752f15c6382c1990ebb0eaac296cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eu0HlUjy_SQu4t3R_iBrjQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Source: codingthesmartway</figcaption></figure><p id="5cd2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">什么是休息？</p><p id="370c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">REST ( <strong class="iv hi">表述性状态转移)</strong>是一种架构模式，它定义了一组用于创建Web服务的约束。一个<strong class="iv hi"> RESTful API </strong> (RESTful web服务或REST API)——构建于表述性状态转移(<a class="ae jr" href="https://searchmicroservices.techtarget.com/definition/REST-representational-state-transfer" rel="noopener ugc nofollow" target="_blank"> REST </a>)技术之外。</p><p id="e481" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">RESTful API是一个应用程序编程接口(<a class="ae jr" href="https://searchmicroservices.techtarget.com/definition/application-program-interface-API" rel="noopener ugc nofollow" target="_blank"> API </a>)，它使用HTTP请求来获取、上传、发布和删除数据。随着云的使用越来越多，API开始公开web服务。REST是构建允许用户与云服务连接和交互的API的合理选择。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es js"><img src="../Images/a7a86d11b44d25c3d81ee39f462e4532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t5VOUSxT8UF9FPYW5uQYVw.png"/></div></div></figure><p id="6e5c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">什么是GraphQL？</strong></p><p id="982f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">GraphQL是一种API查询语言，也是一种用现有数据完成这些查询的运行时语言。GraphQL为API中的数据提供了完整且易于理解的描述，使客户能够准确地要求他们需要的东西，使API更容易随时间发展，并支持强大的开发工具。GraphQL也是一种开源技术。<em class="jx"> GraphQL由脸书于2012年开发，用于内部开发，但后来于2015年上市</em>。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jy"><img src="../Images/3bf225021aec960b4d32287b58c28842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_4IFJN4jzgg1Are1JONjwQ.png"/></div></div></figure><p id="8818" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">REST和GraphQL的区别</strong></p><ul class=""><li id="0b31" class="jz ka hh iv b iw ix ja jb je kb ji kc jm kd jq ke kf kg kh bi translated"><strong class="iv hi">相似:</strong>两者都有资源的概念，都可以为那些资源指定id。</li><li id="61db" class="jz ka hh iv b iw ki ja kj je kk ji kl jm km jq ke kf kg kh bi translated"><strong class="iv hi">相似:</strong>两者都可以通过带有URL的HTTP GET请求获取。</li><li id="aebb" class="jz ka hh iv b iw ki ja kj je kk ji kl jm km jq ke kf kg kh bi translated"><strong class="iv hi">类似:</strong>两者都可以在请求中返回JSON数据。</li><li id="2316" class="jz ka hh iv b iw ki ja kj je kk ji kl jm km jq ke kf kg kh bi translated"><strong class="iv hi">不同:</strong>在REST中，你调用的端点就是那个对象的身份。在GraphQL中，身份与获取身份的方式是分开的。</li><li id="a828" class="jz ka hh iv b iw ki ja kj je kk ji kl jm km jq ke kf kg kh bi translated"><strong class="iv hi">不同:</strong>在REST中，资源的形状和大小是由服务器决定的。在GraphQL中，服务器声明哪些资源是可用的，客户机询问它当时需要什么。</li></ul><p id="67f2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">注:</strong>REST API已经成为部署API和推出开发者平台的公司事实上的标准。REST的美妙之处在于，使用其他人的API的开发人员不需要任何特殊的初始化或库。请求可以简单地通过通用软件如cURL和网络浏览器发送。</p><p id="f676" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> REST和GraphQL(普罗斯/CONS) </strong></p><h1 id="726d" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">1.数据提取</h1><p id="0c61" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">假设我想构建一个显示博客作者信息的应用程序。我希望它显示作者的名字和作者写的博客文章以及作者最近写的三个博客主题。</p><h2 id="0889" class="lq ko hh bd kp lr ls lt kt lu lv lw kx je lx ly lb ji lz ma lf jm mb mc lj md bi translated">休息</h2><p id="f6b7" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">在表示状态转移(REST)中，我们调用一个端点来请求我们需要的数据。然后，服务器用响应来回应:</p><pre class="jt ju jv jw fd me mf mg mh aw mi bi"><span id="3607" class="lq ko hh mf b fi mj mk l ml mm">/blog/author/&lt;id&gt;</span></pre><p id="bbfa" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这个端点将获取作者的信息。然后，我需要另一个端点来访问博客文章。</p><pre class="jt ju jv jw fd me mf mg mh aw mi bi"><span id="280a" class="lq ko hh mf b fi mj mk l ml mm">/blog/author/&lt;id&gt;/posts</span></pre><p id="2562" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">最后，我需要另一个端点来获取博客主题。</p><pre class="jt ju jv jw fd me mf mg mh aw mi bi"><span id="b67b" class="lq ko hh mf b fi mj mk l ml mm">/blog/author/&lt;id&gt;/topics</span></pre><p id="da7b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">CONS: <strong class="iv hi">多次网络通话——休息</strong></p><p id="18dc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在使用REST获取所需数据的同时，您将进行典型数量的网络调用查询。REST端点失去控制，因为我们的数据需要扩展。这会导致多个网络调用，并导致响应时间变慢。</p><p id="ace7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">【REST的上取和下取问题</p><p id="9d20" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">往往有了REST，最终会得到不需要的数据。例如，当调用<em class="jx">博客/作者/ &lt; id &gt; </em>端点时，您将获得关于作者的所有数据。您可以获得类似于<em class="jx">创建日期、更新日期、年龄、性别</em>等数据。但是我们需要的只是作者的名字。这是一个在REST中过量提取的经典例子。</p><p id="f93e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在提取不足的情况下，您可以注意到，仅仅调用<em class="jx">blog/author/&lt;id&gt;</em>并不足以检索我们正在寻找的内容。为了获得作者写的最后三篇文章，我们必须调用另一个端点<em class="jx">blog/author/&lt;id&gt;</em>/posts。这种情况称为提取不足。</p><h1 id="35b9" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">GraphQL</h1><p id="a0a3" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">猜猜使用GraphQL会发生什么？<strong class="iv hi"> <em class="jx">您编写一个查询来查询您想要的内容</em> </strong>，然后您会得到您想要的内容。</p><blockquote class="mn mo mp"><p id="16bd" class="it iu jx iv b iw ix iy iz ja jb jc jd mq jf jg jh mr jj jk jl ms jn jo jp jq ha bi translated"><em class="hh">没有多个网络调用来获取GraphQL中的数据</em></p></blockquote><p id="4301" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您看到实际的查询和收到的响应，这将更有意义。</p><p id="c67a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> GraphQL查询请求</strong></p><p id="4a9f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这就是我们的查询看起来的样子。我们传递需要响应的字段。我们正在寻找作者的名字，最近写的三篇博文，以及他们写的最后三个主题。该查询旨在询问我们到底需要什么。</p><pre class="jt ju jv jw fd me mf mg mh aw mi bi"><span id="b955" class="lq ko hh mf b fi mj mk l ml mm">{<br/>  author (id: 6) {<br/>    name <br/>    posts (last: 3) {<br/>      title<br/>    }<br/>    topics (last : 3) {<br/>     name<br/>    }<br/>  }<br/>}</span></pre><p id="0420" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> GraphQL查询响应</strong></p><p id="7e33" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是我们从服务器上得到的信息。</p><pre class="jt ju jv jw fd me mf mg mh aw mi bi"><span id="7f30" class="lq ko hh mf b fi mj mk l ml mm">{<br/>  "data" : {<br/>    "author" : {<br/>      "name" : "Adhithi Ravichandran",<br/>      "posts" : [<br/>        { title: "React vs. Vue : A Wholesome Comparison"},<br/>        { title: "React Lifecycle Methods: A Deep Dive"},<br/>        { title: "5 Essential Skills A Frontend Developer Should Possess"}<br/>      ],<br/>      "topics" : [<br/>        { name: "React and Vue"},<br/>        { name: "React"},<br/>        { name: "General"}<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="47d6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">GraphQL:没有到服务器的多次往返，没有数据的上取和下取。</p><h1 id="d16d" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">2.客户端的快速产品开发</h1><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/14961acb96970c227a1ec79de235fbdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6LXeNKK46_vWI4is"/></div></div></figure><p id="2fe9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当使用REST APIs时，使用API的客户团队倾向于等待后端团队完成他们的API开发，然后开始使用它们。通常，前端团队会因为等待后端团队的API而导致开发缓慢。我曾多次遇到这种情况，前端开发人员被束缚住手脚，直到后端交出他们API的工作版本。</p><p id="9265" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="jx">这导致开发缓慢，并且极大地依赖后端团队来更快地交付，以便客户团队可以开始他们的工作来消费API。</em></p><p id="7652" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在GraphQL中，前端、后端或任何其他客户端都有并行开发，而不会停止开发。</p><blockquote class="mn mo mp"><p id="c9ac" class="it iu jx iv b iw ix iy iz ja jb jc jd mq jf jg jh mr jj jk jl ms jn jo jp jq ha bi translated"><em class="hh"> GraphQL:团队并行工作，带来快速的产品开发</em></p></blockquote><p id="a612" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">前端团队可以使用API的模拟版本，也可以使用像<a class="ae jr" href="https://github.com/APIs-guru/graphql-faker" rel="noopener ugc nofollow" target="_blank"> GraphQL Faker </a>这样的库创建假数据。编码可以完全用模拟数据完成，测试也可以编写。当后端团队准备好API时，模拟API可以与真正的API交换。</p><p id="096c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">graph QL的CONS</strong></p><h2 id="2e72" class="lq ko hh bd kp lr ls lt kt lu lv lw kx je lx ly lb ji lz ma lf jm mb mc lj md bi translated">贮藏</h2><p id="7265" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">缓存内置在HTTP规范中，RESTful APIs能够利用它。与缓存相关的GET vs POST语义被很好地定义，使得浏览器缓存、中间代理和服务器框架能够遵循。可以遵循以下准则:</p><ul class=""><li id="dab5" class="jz ka hh iv b iw ix ja jb je kb ji kc jm kd jq ke kf kg kh bi translated">GET请求可以被缓存</li><li id="6ec0" class="jz ka hh iv b iw ki ja kj je kk ji kl jm km jq ke kf kg kh bi translated">GET请求可以保留在浏览器历史记录中</li><li id="3e8d" class="jz ka hh iv b iw ki ja kj je kk ji kl jm km jq ke kf kg kh bi translated">GET请求可以加入书签</li><li id="9117" class="jz ka hh iv b iw ki ja kj je kk ji kl jm km jq ke kf kg kh bi translated">GET请求是幂等的</li></ul><p id="fc9f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">GraphQL不遵循HTTP规范进行缓存，而是使用单个端点。因此，开发人员有责任确保为可以缓存的非可变查询正确实现缓存。必须为缓存使用正确的密钥，这可能包括检查主体内容。</p><p id="eb6e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">虽然您可以使用像Relay或Data loader这样理解GraphQL语义的工具，但这仍然不能涵盖像浏览器和移动缓存这样的东西。</p><h2 id="b692" class="lq ko hh bd kp lr ls lt kt lu lv lw kx je lx ly lb ji lz ma lf jm mb mc lj md bi translated">暴露给任意请求</h2><p id="609b" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">虽然GraphQL的一个主要优点是使客户能够查询他们需要的数据，但这也是有问题的，特别是对于开放API，组织无法控制第三方客户的查询行为。必须非常注意确保GraphQL查询不会导致代价高昂的连接查询，这会降低服务器性能，甚至会造成服务器DDoS。RESTful APIs可以被约束以匹配所使用的数据模型和索引。</p><h1 id="36eb" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">查询的严格性</h1><p id="dfac" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">GraphQL消除了在API之上定制查询DSL或副作用操作的能力。例如，Elastic search API是RESTful的，但也有一个非常强大的Elastic search DSL来执行高级聚合和度量计算。这种聚合查询可能更难在GraphQL语言中建模。</p><h2 id="3d47" class="lq ko hh bd kp lr ls lt kt lu lv lw kx je lx ly lb ji lz ma lf jm mb mc lj md bi translated">不存在的监控</h2><p id="6158" class="pw-post-body-paragraph it iu hh iv b iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm lp jo jp jq ha bi translated">RESTful APIs的优势在于它像网站一样遵循HTTP规范。这使得许多工具能够探测URL。对于GraphQL APIs，除非您支持将查询作为URL参数放置，否则您可能无法利用此类工具，因为大多数ping工具不支持HTTP和请求主体。</p><p id="927d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">除了ping服务，很少有SaaS或开源工具支持API分析或对API调用进行更深入的分析。客户端错误在GraphQL API中显示为200 OK。预计会出现400个错误的现有工具将无法工作，因此您可能会错过API上发生的错误。然而与此同时，给予客户更多的灵活性需要更多的工具来捕捉和理解API的问题。</p></div></div>    
</body>
</html>