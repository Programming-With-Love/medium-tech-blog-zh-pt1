<html>
<head>
<title>Implementation of SSL Pinning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SSL固定的实现</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/implementation-of-ssl-pinning-7e57e280cc49?source=collection_archive---------7-----------------------#2021-03-16">https://medium.com/walmartglobaltech/implementation-of-ssl-pinning-7e57e280cc49?source=collection_archive---------7-----------------------#2021-03-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="e3aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的上一篇博客<a class="ae jc" rel="noopener" href="/walmartglobaltech/http-ssl-pinning-decoding-the-untold-1fa751c63c3e"> Mobile HTTP SSL PINNING:解码未知</a>中，我们了解了SSL PINNING是什么？现在，在这篇博客中，我们将讨论实现SSL固定的可能方法，以及每种方法的优缺点。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/33d7cca71510d7fd0a5fed4866c7ec23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yHsqtecj8J-jnIi0Oqy9A.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Image Source <a class="ae jc" href="https://pixabay.com/photos/implement-do-implementation-project-2372179/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/photos/implement-do-implementation-project-2372179/</a></figcaption></figure><p id="e989" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">SSL固定就是将证书相关信息存储在移动应用程序中(APK或IPA文件)。有4种不同的方法可以锁定与证书相关的信息</p><ul class=""><li id="b722" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated"><em class="kc">证书本身作为一个文件</em></li><li id="775b" class="jt ju hh ig b ih kd il ke ip kf it kg ix kh jb jy jz ka kb bi translated"><em class="kc">证书哈希</em></li><li id="cd80" class="jt ju hh ig b ih kd il ke ip kf it kg ix kh jb jy jz ka kb bi translated"><em class="kc">证书的公钥。</em></li><li id="aa5b" class="jt ju hh ig b ih kd il ke ip kf it kg ix kh jb jy jz ka kb bi translated"><em class="kc">公钥的哈希</em></li></ul><p id="b867" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">打算实现这一点的开发人员只剩下以上4种选择。因此，开发人员有必要了解哪一个更好，为什么？用推理。对于一个开发者来说，他需要理解证书的主要内容？。</p><p id="cf74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看证书的主要内容有哪些:</p><ul class=""><li id="9b28" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated">域名</li><li id="9788" class="jt ju hh ig b ih kd il ke ip kf it kg ix kh jb jy jz ka kb bi translated">证书有效期</li><li id="2ea5" class="jt ju hh ig b ih kd il ke ip kf it kg ix kh jb jy jz ka kb bi translated">证书颁发机构(CA)详细信息</li><li id="ab67" class="jt ju hh ig b ih kd il ke ip kf it kg ix kh jb jy jz ka kb bi translated">公开密钥</li><li id="49a9" class="jt ju hh ig b ih kd il ke ip kf it kg ix kh jb jy jz ka kb bi translated">公钥算法</li><li id="448f" class="jt ju hh ig b ih kd il ke ip kf it kg ix kh jb jy jz ka kb bi translated">证书签名算法</li><li id="11bd" class="jt ju hh ig b ih kd il ke ip kf it kg ix kh jb jy jz ka kb bi translated">SSL/TLS版本</li><li id="9c29" class="jt ju hh ig b ih kd il ke ip kf it kg ix kh jb jy jz ka kb bi translated">个性特征</li><li id="78ea" class="jt ju hh ig b ih kd il ke ip kf it kg ix kh jb jy jz ka kb bi translated">指纹算法</li></ul><p id="afb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通常，所有公司都有在特定时间框架后由根CA续订证书的策略。这一时间框架因公司而异，根据当今的标准，最长有效期为825天。因此，随着这种变化，证书的“有效期”也发生了变化。因此，证书内容将会改变，这进一步暗示了散列的改变。但是，公钥更改不会像证书更新那样频繁。因此，在移动应用程序中使用公钥是一个好主意。如果我们更进一步，公钥的散列更有意义。因为它需要较少的空间并且是一致的。</p><p id="eef0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">任何这种甚至适用于公钥锁定的锁定技术都有一个缺点。也就是说，当公钥轮换发生时，应用程序需要被强制更新。这本身就是一个问题。现在有办法解决这个问题吗？答案是肯定的，它被称为证书透明。</p><p id="af52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们稍微挖掘一下证书透明性，了解一下它是否比SSL pinning更好。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ki"><img src="../Images/ae5d8a8989775abdf6f3d010a4d286c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DP-I6TFZTkspp4cXC3QKbQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Image source <a class="ae jc" href="https://certificate.transparency.dev/" rel="noopener ugc nofollow" target="_blank">https://certificate.transparency.dev/</a></figcaption></figure><p id="f10b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">证书透明性与SSL固定的目的相同，但方式不同。在这种方法中，当SSL证书被颁发给移动应用程序时，它使用已经具有由可信根机构颁发的有效证书的副本的日志服务器来验证它是否有效。因此，如果黑客正在执行MITM，他的根CA将不会出现在日志服务器中，用户将免受MITM攻击。</p><p id="d53f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有关证书透明度的更多信息，请参考<a class="ae jc" href="https://www.certificate-transparency.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> <em class="kc">链接</em> </strong> </a> <strong class="ig hi"> <em class="kc">。</em>T9】</strong></p><p id="57cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">起初，证书透明性似乎比SSL固定更好，但是理解其局限性/缺点也同样重要。让我们考虑一个场景，其中日志服务器关闭。在这里，即使对应用程序的有效调用也会失败，因为无法重新确认证书的有效性。这是这种方法的主要缺点。因此，不允许停机的高可用性应用程序，他们最好使用SSL固定，在那里他们有完全的控制权，而不是依赖于日志服务器。反之亦然，如果不关心高可用性，那么证书透明性比SSL固定更好。</p><p id="01d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们已经了解了固定和固定与证书透明性的最佳方式。在接下来的博客中，我们将讨论如何在Android和iPhone中实现SSL pin。在那之前，注意安全。</p></div></div>    
</body>
</html>