<html>
<head>
<title>Remodeling Cash App Payments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重塑现金应用支付</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/remodeling-cash-app-payments-539e1f6c4276?source=collection_archive---------0-----------------------#2018-11-16">https://medium.com/square-corner-blog/remodeling-cash-app-payments-539e1f6c4276?source=collection_archive---------0-----------------------#2018-11-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e52f41535cb3a7b071a1b47351b928b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ve4lfjhJo4-3UP8PpbCt5g.png"/></div></div></figure><blockquote class="ip iq ir"><p id="af5c" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jr" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="fb28" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">在对数据库进行分区之前，我们需要准备数据模型。下面是我们如何将一个简单的标准化数据模型转变成一个可以进行规模划分的模型。</p><h2 id="b25b" class="jv jw hh bd jx jy jz ka kb kc kd ke kf js kg kh ki jt kj kk kl ju km kn ko kp bi translated">归一化的数据很漂亮</h2><p id="2b8e" class="pw-post-body-paragraph is it hh iv b iw kq iy iz ja kr jc jd js ks jg jh jt kt jk jl ju ku jo jp jq ha bi translated">Cash应用程序最初是一项简单的汇款服务。我们的MySQL数据库跟踪客户、他们关联的借记卡以及他们之间的支付。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="408c" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">使用规范化的持久性模型非常好！这使得我们很容易迭代我们的服务。我们构建了许多潜在的功能，并推出了最好的功能。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lb"><img src="../Images/a148e73f7b033ece912150bacd25accd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4zZrOIJxQM2DvLF6KZPtAw@2x.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">3 customers + 3 payments</figcaption></figure><p id="ff14" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们使用强大的状态机来管理支付生命周期。<code class="du lg lh li lj b">state</code>列随着支付通过该状态机的进行而改变。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/fdd6748af44748fd016ca07bdf0254ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mUFujt8ih-htZJrEuhI_Vw@2x.png"/></div></div></figure><p id="a842" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">该模式可用于编程查询和即席查询。例如，如果一张卡挂失，我们可以找到从它发出的付款，即使它与多个客户相关联。</p><pre class="kv kw kx ky fd ll lj lm ln aw lo bi"><span id="0326" class="jv jw hh lj b fi lp lq l lr ls">SELECT<br/>  p.id,<br/>  p.amount<br/>FROM<br/>  payments p,<br/>  cards c<br/>WHERE<br/>  p.sender_card_id = c.id AND<br/>  c.vault_token = 'b191a4884d216ea4';</span></pre><p id="bf7d" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">该模式让我们能够在客户和他们的支付之间进行原子操作。如果艾莉链接了一张新的借记卡，我们可以在状态机中提前支付她的所有款项。</p><p id="45fa" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">为现金数据库开发非常棒！但是我们预料到大规模运作会有困难。</p><h1 id="2378" class="lt jw hh bd jx lu lv lw kb lx ly lz kf ma mb mc ki md me mf kl mg mh mi ko mj bi translated">分区数据是可伸缩的</h1><p id="8562" class="pw-post-body-paragraph is it hh iv b iw kq iy iz ja kr jc jd js ks jg jh jt kt jk jl ju ku jo jp jq ha bi translated">为了跨多个MySQL节点扩展我们的系统，我们必须首先对它进行分区。但是怎么做呢？我们的数据模型是一个带有客户节点和支付边的图。我们的代码在客户和他们的支付之间运行原子交易。它还希望跨这些表进行SQL连接。</p><p id="4f3d" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们的想法是借用消息系统。他们通过复制每条信息来解决问题:一份给发送者，一份给接收者。我们也可以这样做，只要我们能找到一个共享支付状态的解决方案。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lb"><img src="../Images/bf10213d73b14411eb8fd72a7017882d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nK2qS04Lfdrbm5AO4KP0aA@2x.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">3 customers + 6 movements</figcaption></figure><p id="c170" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">现金应用程序中的每笔支付都会转移两次资金:从发送方提取到Square，从Square存入到接收方。我们将付款的一半命名为“运动”,并开始了我们的大规模模式改造。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="7da7" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">对于payments表中的每一行，我们在movements表中创建了两行:一行用于发送方，另一行用于接收方。有很多代码会受到这次迁移的影响！</p><p id="cdc3" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">Cash应用程序在我们与MySQL的大部分交互中使用Hibernate。我们在实体类中使用前缀<code class="du lg lh li lj b">Db</code>，比如<code class="du lg lh li lj b">DbCustomer</code>、<code class="du lg lh li lj b">DbCard</code>和<code class="du lg lh li lj b">DbPayment</code>。除了为我们的新表创建一个<code class="du lg lh li lj b">DbMovement</code>,我们还需要一个抽象来连接两个模型。我把它叫做<code class="du lg lh li lj b">DaPayment</code>，并用一些愚蠢的问题来娱乐我的队友，比如<em class="iu">“da在哪里付款？”当他们问到名字的时候。</em></p><p id="a70d" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">调用<code class="du lg lh li lj b">DaPayment.setState()</code>将更新<code class="du lg lh li lj b">DbPayment</code>，两个<code class="du lg lh li lj b">DbMovement</code>，或者所有的东西，这取决于我们的迁移阶段。迁移有四个阶段。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/c9cb118f37574c98f40a7731c30cbf7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ux0r7aJxgKLU4opbIOXvfg@2x.png"/></div></div></figure><ol class=""><li id="aa43" class="ml mm hh iv b iw ix ja jb js mn jt mo ju mp jq mq mr ms mt bi translated">付款表是我们唯一使用的表。</li><li id="bfce" class="ml mm hh iv b iw mu ja mv js mw jt mx ju my jq mq mr ms mt bi translated"><code class="du lg lh li lj b">READ_PAYMENTS</code>:支付是真理的源泉；将所有写操作回显到动作中。</li><li id="40bc" class="ml mm hh iv b iw mu ja mv js mw jt mx ju my jq mq mr ms mt bi translated"><code class="du lg lh li lj b">READ_MOVEMENTS</code>:运动是真理的源泉；对付款也回显所有写入。</li><li id="5415" class="ml mm hh iv b iw mu ja mv js mw jt mx ju my jq mq mr ms mt bi translated"><code class="du lg lh li lj b">MOVEMENTS_ONLY</code>:movements表是我们唯一使用的表。</li></ol><p id="503d" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">抽象出实体类是好的，但还不够。我们还需要对我们的查询和它们产生的预测进行抽象。访问支付的每一行代码都需要间接在支付或移动之间切换。由于我们的项目主要关注的是付款，这是很多行代码！</p><p id="141b" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们编写了回填工具来为没有支付的支付创建移动行(在阶段2运行)，并编写了另一个工具来删除过时的支付行(在阶段4运行)。</p><p id="8b57" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">拥有一个全面的测试套件对于确保迁移安全至关重要。在迁移的早期，当一些测试在新世界中运行完成时，我们建立了信心。我们注释了这些测试<code class="du lg lh li lj b">@WorksOnMovements</code>，并配置了我们的构建基础设施来运行这些测试两次，一次在阶段1下，另一次在阶段4下。我们通过找到未标注的测试并填充运动代码路径直到它们通过，从而取得了进展。后来，我们用一个<code class="du lg lh li lj b">@DoesNotWorkOnMovements</code> denylist替换了<code class="du lg lh li lj b">@WorksOnMovements</code> allowlist，并开始倒计时到一个完全就绪的系统。一旦所有的测试都成功了，我们就准备好迁移了。</p><p id="abd5" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">2017年春天，我们完成了生产中的分阶段迁移。进入第2阶段压力很大，因为额外的写入增加了数据库的总负载。如果我们的数据库不能处理额外的负载怎么办？我们会被困住吗？我咬着我的指甲，推了过去。</p><p id="6119" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">以下是我们进入第三阶段时对峰值运动的质疑:</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mz"><img src="../Images/fee1dc71f88490c290c44d444f6e45fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9R_Y-E21lPFi81a8mtDesA@2x.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">Movements (blue), Payments (pink) QPS</figcaption></figure><p id="d114" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这是随着我们进入第4阶段，付款记录逐渐减少。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mz"><img src="../Images/3c8120343f2efffadebff4a8b9280e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOGiZPTmgzxKQjbwiyhWIg@2x.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx">Movements (blue), Payments (pink) QPS</figcaption></figure><p id="5a2c" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">咻，成功了。那天晚上我睡得很香！</p><h1 id="46dd" class="lt jw hh bd jx lu lv lw kb lx ly lz kf ma mb mc ki md me mf kl mg mh mi ko mj bi translated">分布式系统是异步的</h1><p id="34c6" class="pw-post-body-paragraph is it hh iv b iw kq iy iz ja kr jc jd js ks jg jh jt kt jk jl ju ku jo jp jq ha bi translated">尽管我们已经用分区友好的移动表替换了抗分区的支付表，但我们仍然没有做好分割的准备。我们仍然需要保持共享的可变字段的同步，比如付款的状态。</p><p id="f4a2" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们建立了一个名为“Twinlock”的机制来保持运动对的一致性和同步性。在任何时候，一个运动持有锁，可以改变两个运动共享的可变字段。孪生数据异步更新，最终保持一致。实际上，“最终”不到一秒钟。</p><p id="98e3" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">TwinLock在两种机芯中都使用了3根立柱:</p><ul class=""><li id="0a59" class="ml mm hh iv b iw ix ja jb js mn jt mo ju mp jq na mr ms mt bi translated"><code class="du lg lh li lj b">lock_state</code>:不是<code class="du lg lh li lj b">DEFINITELY_MINE</code>就是<code class="du lg lh li lj b">PROBABLY_YOURS</code>。</li><li id="4b1f" class="ml mm hh iv b iw mu ja mv js mw jt mx ju my jq na mr ms mt bi translated"><code class="du lg lh li lj b">lock_version</code>:只有锁持有者增加此值。如果一个机芯的<code class="du lg lh li lj b">lock_version</code>比它的孪生机芯低，那么它可能已经被锁定。</li><li id="4178" class="ml mm hh iv b iw mu ja mv js mw jt mx ju my jq na mr ms mt bi translated"><code class="du lg lh li lj b">twin_stale_at</code>:如果twin需要同步其字段，则非空。</li></ul><p id="f407" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">MySQL允许我们在单个事务中用twinlock列自动更新移动。但是由于分区将不同的移动放在不同的数据库中，我们不能在同一个事务中更新多个移动。</p><p id="76f5" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">更改两个移动的编辑需要三个连续的事务:</p><ul class=""><li id="abad" class="ml mm hh iv b iw ix ja jb js mn jt mo ju mp jq na mr ms mt bi translated">更新一个动作，确保我们先锁定。除了数据更改，我们还增加了<code class="du lg lh li lj b">lock_version</code>并将<code class="du lg lh li lj b">twin_stale_at</code>设置为当前时间。这发生在第一笔交易中。</li><li id="78b1" class="ml mm hh iv b iw mu ja mv js mw jt mx ju my jq na mr ms mt bi translated">将变化同步到双机芯。这包括<code class="du lg lh li lj b">lock_version</code>字段。</li><li id="433f" class="ml mm hh iv b iw mu ja mv js mw jt mx ju my jq na mr ms mt bi translated">最后，在原机芯上清除<code class="du lg lh li lj b">twin_stale_at</code>。</li></ul><figure class="kv kw kx ky fd ii er es paragraph-image"><div class="er es nb"><img src="../Images/4afe64bcc33316b8b72e54c2659bb9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*N6emx-tzLZD1GD2SR-WF0A.gif"/></div><figcaption class="lc ld et er es le lf bd b be z dx">Change the sender movement, sync the change, and acknowledge sync success.</figcaption></figure><p id="43e5" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">Twinlock最有趣的特性是它是不对称的:你可以确定你持有锁，但你不能确定你没有！如果两个机芯的锁定状态都是<code class="du lg lh li lj b">PROBABLY_YOURS</code>，那么<em class="iu"/><code class="du lg lh li lj b">lock_version</code>较低的那一个就是实际的锁定架。它应该同步，采用更高的锁定版本，并将其锁定状态更改为<code class="du lg lh li lj b">DEFINITELY_MINE</code>。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div class="er es nb"><img src="../Images/88f45ae4b8b68c78cf12a311be658529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*HieDHLITiR3S2fndjW5VIA.gif"/></div><figcaption class="lc ld et er es le lf bd b be z dx">The sender released the lock so the recipient must acquire it.</figcaption></figure><p id="ccb5" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">当锁持有者释放锁时，它将自己的状态更改为<code class="du lg lh li lj b">PROBABLY_YOURS</code>并递增<code class="du lg lh li lj b">lock_version</code>，因此有一个唯一的最低版本。这种设计允许我们在一个事务中释放锁，并在另一个事务中获取锁。</p><p id="9242" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">如果两个操作试图进行冲突编辑，我们会检测到竞争，并强制竞争的失败者回滚并重试。我们构建了数据库访问API，以确保这些恢复始终是自动和安全的。他们依赖Hibernate神奇的<code class="du lg lh li lj b"><a class="ae jr" href="https://docs.jboss.org/hibernate/orm/5.3/userguide/html_single/Hibernate_User_Guide.html#locking-optimistic" rel="noopener ugc nofollow" target="_blank">@Version</a></code> <a class="ae jr" href="https://docs.jboss.org/hibernate/orm/5.3/userguide/html_single/Hibernate_User_Guide.html#locking-optimistic" rel="noopener ugc nofollow" target="_blank">特性</a>，该特性检测并发编辑，没有竞争或仪式。</p><h1 id="324f" class="lt jw hh bd jx lu lv lw kb lx ly lz kf ma mb mc ki md me mf kl mg mh mi ko mj bi translated">准备好了吗</h1><p id="debf" class="pw-post-body-paragraph is it hh iv b iw kq iy iz ja kr jc jd js ks jg jh jt kt jk jl ju ku jo jp jq ha bi translated">movements表已准备好进行分区，Twinlock正在保持成对的移动一致和最新。我们已经准备好让Vitess将我们的数据库一分为二，然后是四、八、十六，甚至更多！</p><p id="33c4" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这篇文章是Square<a class="ae jr" rel="noopener" href="/square-corner-blog/sharding-cash-10280fa3ef3b">Vitess系列</a>的一部分。</p></div></div>    
</body>
</html>