<html>
<head>
<title>Loading-status in Angular done right</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">装载-角度状态正确</h1>
<blockquote>原文：<a href="https://medium.com/compendium/loading-status-in-angular-done-right-aeed09cfbea6?source=collection_archive---------0-----------------------#2018-04-18">https://medium.com/compendium/loading-status-in-angular-done-right-aeed09cfbea6?source=collection_archive---------0-----------------------#2018-04-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="0199" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">jrn Are hat lelid—前端技术负责人</em></p><h2 id="a3d0" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated"><strong class="ak">在你的web应用程序中拥有一个全局加载状态是有用的，但是不容易正确。</strong></h2><p id="6aec" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">挑战在于捕获所有的HTTP API请求，并在有服务器通信时显示加载栏、微调器或文本状态。</p><p id="c27c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了这篇博文，你还可以在<a class="ae kd" href="https://stackblitz.com/edit/angular-o3my4y" rel="noopener ugc nofollow" target="_blank"> Stackblitz </a>找到一个工作实例。</p><p id="6ede" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae kd" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a> 4+有一个新的<a class="ae kd" href="https://angular.io/api/common/http/HttpClient" rel="noopener ugc nofollow" target="_blank"> HttpClient </a>，它支持<a class="ae kd" href="https://angular.io/api/common/http/HttpInterceptor" rel="noopener ugc nofollow" target="_blank"> HttpInterceptor </a>。</p><p id="325e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这允许您插入每当发出HTTP请求时都会运行的代码。这对于捕捉所有请求非常有用，但是我们还需要一个定制服务来共享我们是否有未决请求的信息。这是因为拦截器本身不应该被共享。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ke"><img src="../Images/f2aec408d5711a02e6a8f98556fd71b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ewKu_9pL6atvmWl-.png"/></div></div></figure><p id="263b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为一个最小的例子，我们应该有:</p><p id="ae45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">HttpInterceptor类“LoaderInterceptor”拦截所有HTTP请求，并告诉“LoaderService”我们是否有挂起的请求:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="3521" class="jd je hh kr b fi kv kw l kx ky">// There are a lot of missing pieces here, so bear with me for now<br/>@Injectable() export class LoaderInterceptor implements HttpInterceptor {<br/>   constructor(private loaderService: LoaderService) { }</span><span id="4f04" class="jd je hh kr b fi kz kw l kx ky">   // This is the code that will run whenever an HttpRequest is made<br/>   intercept(req: HttpRequest, next: HttpHandler): Observable&lt;HttpEvent&gt; {<br/>       this.loaderService.isLoading.next(true);<br/>       return next.handle(req).map(<br/>           () =&gt; this.loaderService.isLoading.next(false)<br/>       );<br/>   }<br/>}</span></pre><p id="b68f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">包含“isLoading”流的“loader service ”, http interceptor可以将状态推送到该流，哪些组件可以订阅该流以获取状态:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="10c9" class="jd je hh kr b fi kv kw l kx ky">@Injectable()<br/>export class LoaderService {<br/>   // A BehaviorSubject is an Observable with a default value<br/>   public isLoading = new BehaviorSubject(false);<br/>   constructor() {}<br/>}</span></pre><p id="2094" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">连接“LoaderService”和模板的组件:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="68d2" class="jd je hh kr b fi kv kw l kx ky">@Component({...})<br/>export class MyComponent {<br/>   constructor(public loaderService: LoaderService) {}<br/>}</span></pre><p id="af8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">显示“正在加载”状态的HTML/Angular模板:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="1a77" class="jd je hh kr b fi kv kw l kx ky">&lt;div *ngIf="loaderService.isLoading | async; else notLoading"&gt;Loading!&lt;/div&gt;<br/>&lt;ng-template #notLoading&gt;Not Loading!&lt;/ng-template&gt;</span></pre><p id="7502" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这看起来很简单，但是有一些陷阱。</p><p id="f278" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，您可能注意到拦截器代码假设一次只有一个HTTP请求。</p><p id="aedf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果有两个请求，我们将在第一个响应返回后立即关闭加载程序。</p><p id="d824" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们通过将所有挂起的请求保存在一个数组中来处理这个问题，并创建一个函数在需要时删除一个请求:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="b4e9" class="jd je hh kr b fi kv kw l kx ky">@Injectable()<br/>export class LoaderInterceptor implements HttpInterceptor {<br/>   // We need to store the pending requests<br/>   private requests: HttpRequest[] = [];<br/>   constructor(private loaderService: LoaderService) { }</span><span id="7d68" class="jd je hh kr b fi kz kw l kx ky">   removeRequest(req: HttpRequest) {<br/>       const i = this.requests.indexOf(req);<br/>       if ( i &gt;= 0) {<br/>          this.requests.splice(i, 1); // This removes the request from our array<br/>       }<br/>       // Let's tell our service of the updated status<br/>       this.loaderService.isLoading.next(this.requests.length &gt; 0);<br/>   }</span><span id="df22" class="jd je hh kr b fi kz kw l kx ky">   intercept(req: HttpRequest, next: HttpHandler): Observable&lt;HttpEvent&gt; {<br/>       this.requests.push(req); // Let's store this request<br/>       this.loaderService.isLoading.next(true);<br/>       next.handle(req).map(() =&gt; { this.removeRequest(req); });<br/>   }<br/>}</span></pre><p id="fa29" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">需要注意的是，HttpRequest的响应是短暂的，在响应、错误或超时后终止。这意味着您不必手动取消订阅。太好了！。</p><p id="4780" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，如果可观察对象在响应返回之前被取消订阅，请求将被取消，两个处理程序都不会被处理。</p><p id="3f77" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，你可能会有一个“悬挂”的加载条，它永远不会消失。</p><p id="4954" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您在应用程序中导航得太快，通常会发生这种情况，这会导致组件被破坏，订阅会自动取消。</p><p id="8b4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决最后一个问题，我们需要创建一个新的可观察对象来附加拆卸逻辑。拆除逻辑是当可观察对象被取消订阅时自动处理的代码。</p><p id="eba4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我们返回这个新的可观测值，而不是原来的可观测值。由于它们没有连接，我们还需要转发事件、错误和关闭状态，这样作为开发人员的您根本不会注意到拦截器的存在。</p><p id="1979" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么，让我们来看看最后的LoaderInterceptor类:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="7afe" class="jd je hh kr b fi kv kw l kx ky">@Injectable()<br/>export class LoaderInterceptor implements HttpInterceptor {<br/> private requests: HttpRequest[] = [];</span><span id="2eb1" class="jd je hh kr b fi kz kw l kx ky"> constructor(private loaderService: LoaderService) { }</span><span id="fa45" class="jd je hh kr b fi kz kw l kx ky"> removeRequest(req: HttpRequest) {<br/>   const i = this.requests.indexOf(req);<br/>   if (i &gt;= 0) {<br/>     this.requests.splice(i, 1);<br/>   }<br/>   this.loaderService.isLoading.next(this.requests.length &gt; 0);<br/> }</span><span id="2131" class="jd je hh kr b fi kz kw l kx ky"> intercept(req: HttpRequest, next: HttpHandler): Observable&lt;HttpEvent&gt; {<br/>   this.requests.push(req);<br/>   this.loaderService.isLoading.next(true);<br/>   // We create a new observable which we return instead of the original<br/>   return Observable.create(observer =&gt; {<br/>     // And subscribe to the original observable to ensure the HttpRequest is made<br/>     const subscription = next.handle(req)<br/>       .subscribe(<br/>       event =&gt; {<br/>         if (event instanceof HttpResponse) {<br/>           this.removeRequest(req);<br/>           observer.next(event);<br/>         }<br/>       },<br/>       err =&gt; { this.removeRequest(req); observer.error(err); },<br/>       () =&gt; { this.removeRequest(req); observer.complete(); });<br/>     // return teardown logic in case of cancelled requests<br/>     return () =&gt; {<br/>       this.removeRequest(req);<br/>       subscription.unsubscribe();<br/>     };<br/>   });<br/> }<br/>}</span></pre><p id="842a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的组件不需要改变。我们使用相同的LoaderService和异步操作符，我们甚至不需要订阅。</p><p id="1ac8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为我们想要使用的源值来自服务，所以它作为可观察对象被共享(BehaviorSubject继承自Observable ),这样它就获得了使用它的渲染范围/区域。如果它只是一个值，它可能不会按照您的要求更新您的GUI。</p><p id="835e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后一步是为应用程序提供服务。我通常在“核心”目录中创建一个单独的模块，然后将它导入到AppModule中:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="64d2" class="jd je hh kr b fi kv kw l kx ky">@NgModule({<br/>   providers: [<br/>     LoaderService,<br/>     { provide: HTTP_INTERCEPTORS,<br/>       useClass: LoaderInterceptor,<br/>       multi: true<br/>     }<br/>   ]<br/>})<br/>export class LoaderModule { }</span></pre><p id="3646" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们已经展示了如何在Angular应用程序中实现加载器状态。如果应用程序需要，还可以将挂起请求的数量推送到LoaderService。</p><p id="7fed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">祝你好运，记得查看一下<a class="ae kd" href="https://stackblitz.com/edit/angular-o3my4y" rel="noopener ugc nofollow" target="_blank"> Stackblitz示例</a>。</p></div><div class="ab cl la lb go lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ha hb hc hd he"><h1 id="7d1e" class="lh je hh bd jf li lj lk jj ll lm ln jn lo lp lq jq lr ls lt jt lu lv lw jw lx bi translated">约恩是哈特利德</h1><p id="9edc" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated"><em class="jc">jrn Are是Computas的前端技术领导者，拥有20多年的网络经验。他使用Angular编码和交付项目已经将近3年了，在此之前是AngularJS。可测试性和代码质量是他最关心的。</em></p></div></div>    
</body>
</html>