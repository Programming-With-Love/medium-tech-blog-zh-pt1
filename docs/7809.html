<html>
<head>
<title>Delivering ReactJS applications at scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大规模交付ReactJS应用</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/delivering-reactjs-applications-at-scale-5cb8a363f99?source=collection_archive---------3-----------------------#2019-08-26">https://medium.com/walmartglobaltech/delivering-reactjs-applications-at-scale-5cb8a363f99?source=collection_archive---------3-----------------------#2019-08-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/2b7dda0fe7dde48f74fa206badd54dad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ICBT-jxfLVgpCO80d897fw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://pixabay.com/photos/business-cellphone-codes-coding-1839876/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/photos/business-cellphone-codes-coding-1839876/</a></figcaption></figure><h1 id="f73b" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="98e8" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">应用程序的可伸缩性是应用程序设计的重要部分。有多种方法可以扩展应用程序。可以通过编写高性能和高效的代码，或者通过添加更多的服务器实例来扩展应用程序。在这篇博客中，我们将探讨如何扩展由不同团队构建的多个应用程序，以及支持这些应用程序的健壮CI/CD。</p><h1 id="f5fb" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">问题陈述</h1><p id="f94c" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">当您必须在单个实体下支持多个应用程序的开发和发布时，需要考虑许多方面，即可伸缩性、发布策略、性能、安全性、SSO、授权等。这些应用程序有独立的团队在独立的发布周期中开发他们的产品路线图。为了解决上述问题，我们构建了一个托管解决方案来帮助开发多个应用程序。让我们来看看解决方案的体系结构。</p><h1 id="d01d" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">体系结构</h1><p id="0826" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">为了支持多个应用程序的开发和发布，我们遵循模块注入方法，其中应用程序作为npm模块构建，并作为依赖项添加到主父应用程序中。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/ea7719c91eb4bf8e0720736c5eb0d5f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFwKfI3iBVaxqXYZCf4OBQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Main application and child applications with different versions</figcaption></figure><p id="66f9" class="pw-post-body-paragraph js jt hh ju b jv kv jx jy jz kw kb kc kd kx kf kg kh ky kj kk kl kz kn ko kp ha bi translated">如上图所示，子应用程序由不同的团队构建，并作为npm模块导出。根据npm的语义版本，应用程序可以是任何版本。</p><h2 id="bbcd" class="la iv hh bd iw lb lc ld ja le lf lg je kd lh li ji kh lj lk jm kl ll lm jq ln bi translated">Monorepos</h2><p id="21ab" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">如果你查看GitHub中许多流行的JavaScript框架/库的源代码，你会发现多个包是使用一个GitHub库开发的。下面是<a class="ae it" href="https://github.com/facebook/react" rel="noopener ugc nofollow" target="_blank"> React GitHub库</a>中packages文件夹的截图。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/f9237c7081bfe614e6da40c90a157c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a3VG1IOQ2X5btNm0-OoqRA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Facebook’s React codebase <a class="ae it" href="https://github.com/facebook/react" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/react</a></figcaption></figure><p id="36fa" class="pw-post-body-paragraph js jt hh ju b jv kv jx jy jz kw kb kc kd kx kf kg kh ky kj kk kl kz kn ko kp ha bi translated">所有这些软件包都是不同版本的npm软件包。如果每个包都有一个单独的GitHub库，那么跟踪多个GitHub库将会很困难。在进行bug修复或特性更新时，单独增加软件包也是一个挑战。通过将所有这些包放在一个存储库中，开发和跟踪这些包变得更加容易。</p><p id="7696" class="pw-post-body-paragraph js jt hh ju b jv kv jx jy jz kw kb kc kd kx kf kg kh ky kj kk kl kz kn ko kp ha bi translated">这个概念被称为Monorepos。在开源仓库中有很多monorepos这样的例子。</p><blockquote class="lo lp lq"><p id="dd80" class="js jt lr ju b jv kv jx jy jz kw kb kc ls kx kf kg lt ky kj kk lu kz kn ko kp ha bi translated">Yarn默认支持在单个存储库中开发包，并具有一个名为“工作区”的特性。如果你使用NPM，那么你可以使用<a class="ae it" href="https://github.com/lerna/lerna" rel="noopener ugc nofollow" target="_blank"> Lerna </a>库来管理软件包。</p></blockquote><h2 id="ed06" class="la iv hh bd iw lb lc ld ja le lf lg je kd lh li ji kh lj lk jm kl ll lm jq ln bi translated">与微前端方法的比较</h2><p id="dd4a" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">以上感觉和micro frontend的做法差不多，但是有细微的区别。在微前端方法中，应用被分成多个应用。这些应用程序都是作为定制元素开发的，通常由独立的scrum团队开发。下面是一个应用程序及其微前端方法的示例。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/1786efe3fb209287d66806ade73aff6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRNAEtLCWF6sAOKD_poLoA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Different sections of “Product” application</figcaption></figure><p id="5f9d" class="pw-post-body-paragraph js jt hh ju b jv kv jx jy jz kw kb kc kd kx kf kg kh ky kj kk kl kz kn ko kp ha bi translated">上面的例子是一个关于产品的应用程序，分为三个独立的应用程序——产品描述、产品过滤器和产品评论。假设这个应用程序是由三个不同的scrum团队开发的——A、B和c。这些团队将开发定制元素，如下图所示。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/2d545e2f0a6fd4e4f42a87e47dd06b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_-v7KspAbS7nQ_5RXNkeQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Custom elements for the “Product” application</figcaption></figure><p id="3588" class="pw-post-body-paragraph js jt hh ju b jv kv jx jy jz kw kb kc kd kx kf kg kh ky kj kk kl kz kn ko kp ha bi translated">微前端方法和npm方法之间的一个区别是，我们在npm方法中的应用程序层次结构中寻找更高的层次。在微前端方法中，应用程序是根据多个独立的应用程序开发的，使用DOM作为数据通道层。</p><p id="752d" class="pw-post-body-paragraph js jt hh ju b jv kv jx jy jz kw kb kc kd kx kf kg kh ky kj kk kl kz kn ko kp ha bi translated">在我们的方法中，我们将应用程序用作npm模块。应用程序可以开发为微前端或单片。它不会影响我们使用应用程序的方式。</p><p id="1d00" class="pw-post-body-paragraph js jt hh ju b jv kv jx jy jz kw kb kc kd kx kf kg kh ky kj kk kl kz kn ko kp ha bi translated">类似地，应用程序团队可以自由选择任何适合他们开发的分支策略——git flow或基于主干的开发。</p><h1 id="7c87" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">使用npm模块的优势</h1><p id="a81c" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">npm模块方法具有内置的依赖性管理和版本控制能力的框架。子应用程序可以根据变更增加它们的版本——bug修复、功能更新或可中断的变更。主应用程序添加子应用程序的npm包作为依赖项，并在更新时获取最新版本。</p><p id="0ad1" class="pw-post-body-paragraph js jt hh ju b jv kv jx jy jz kw kb kc kd kx kf kg kh ky kj kk kl kz kn ko kp ha bi translated">使用npm模块的另一个优点是依赖关系可以在应用程序之间共享。每当用户从一个应用程序转到另一个应用程序时，不需要再次下载公共依赖关系。此外，通过使用公共的依赖关系，例如，所有的应用程序都使用单一版本的UI库，应用程序的外观和感觉都是一致的。</p><h1 id="446b" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">应用程序发布流程</h1><p id="d5bc" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">为了促进包的开发，我们向应用程序团队提供样板文件。这个样板文件内置了代码质量检查，并初始化了Monorepos。开发团队必须复制样板文件，并开始开发他们的应用程序。一旦在本地开发和测试了应用程序，开发人员就向他们的Git存储库发送Pull请求(PR)。这个PR将运行代码质量检查，并对他们编写的delta代码进行测试。一旦PR被审查和合并，代码质量检查和集成测试套件在整个代码基础上运行。应用程序进展到更高的环境(开发、QA、阶段等。)，最后将被构建为一个npm模块。</p><p id="3887" class="pw-post-body-paragraph js jt hh ju b jv kv jx jy jz kw kb kc kd kx kf kg kh ky kj kk kl kz kn ko kp ha bi translated">该npm模块发布到沃尔玛的内部仓库。npm模块的版本将基于应用程序中的变更类型而增加，即针对bug修复的补丁版本更新、针对功能开发的次要版本更新以及针对可中断变更的主要版本更新。</p><p id="bd8f" class="pw-post-body-paragraph js jt hh ju b jv kv jx jy jz kw kb kc kd kx kf kg kh ky kj kk kl kz kn ko kp ha bi translated">一旦npm模块被发布到内部存储库，它将触发主应用程序的构建。这确保子应用程序的最新版本在主应用程序中可用。</p><h1 id="9d5e" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">持续集成和部署</h1><p id="0e91" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">为了支持作为npm包的应用程序的开发，我们需要一个健壮的CI/CD流程。这个CI/CD过程检查代码质量、测试覆盖率，并创建应用程序的npm包。以下是CI/CD流程示例。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/8313451898a22d52c5ee35b22a6cafca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TrnEwsJ0iE6e4rneKuR5Ag.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Sample CI/CD diagram</figcaption></figure><p id="d62a" class="pw-post-body-paragraph js jt hh ju b jv kv jx jy jz kw kb kc kd kx kf kg kh ky kj kk kl kz kn ko kp ha bi translated">这里的应用程序版本是1.0.0。开发人员开始并行开发特性1和特性2。这两个特性都作为pull请求发送到dev服务器，在那里它们被合并。然后，它进入不同的阶段，如QA、Stage和Prod，并最终构建为npm模块。</p><h1 id="688a" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结论</h1><ul class=""><li id="985d" class="lv lw hh ju b jv jw jz ka kd lx kh ly kl lz kp ma mb mc md bi translated"><strong class="ju hi"><em class="lr"/></strong>—代码库是独立的，但是应用程序被托管在一起</li><li id="07d2" class="lv lw hh ju b jv me jz mf kd mg kh mh kl mi kp ma mb mc md bi translated"><strong class="ju hi"> <em class="lr">模块化代码</em> — </strong>我们遵循了基于npm的版本化和依赖性管理方法</li><li id="6342" class="lv lw hh ju b jv me jz mf kd mg kh mh kl mi kp ma mb mc md bi translated"><strong class="ju hi"> <em class="lr">公共依赖</em> </strong> —应用程序之间共享库</li><li id="175b" class="lv lw hh ju b jv me jz mf kd mg kh mh kl mi kp ma mb mc md bi translated"><strong class="ju hi"> <em class="lr"> DevX </em> </strong> —改善开发人员体验，加快上市时间</li></ul></div></div>    
</body>
</html>