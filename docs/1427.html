<html>
<head>
<title>Smooth Scrolling in UITableView and UICollectionView</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在UITableView和UICollectionView中平滑滚动</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/smooth-scrolling-in-uitableview-and-uicollectionview-a012045d77f?source=collection_archive---------0-----------------------#2017-01-25">https://medium.com/capital-one-tech/smooth-scrolling-in-uitableview-and-uicollectionview-a012045d77f?source=collection_archive---------0-----------------------#2017-01-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4a0ad3add9f01a336853874c6d10af1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Bd4ATb5Eqa8HY41Bw56gyQ.gif"/></div></div></figure><p id="ccaa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如大多数iOS开发人员所知，在构建移动应用程序时，显示数据集是一项相当常见的任务。苹果的SDK提供了两个组件来帮助执行这样的任务，而不必从头开始实现一切:一个表格视图(<a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableview" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">ui table view</strong></a><strong class="ir hi">)</strong>和一个集合视图(<a class="ae jn" href="https://developer.apple.com/reference/uikit/uicollectionview" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">UICollectionView</strong></a><strong class="ir hi">)</strong>。</p><p id="63b5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">表视图和集合视图都被设计为支持显示可以滚动的数据集。然而，当显示大量数据时，实现完美平滑的滚动可能非常棘手。这并不理想，因为它会对用户体验产生负面影响。</p><p id="953e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为Capital One移动应用的iOS开发团队的一员，我有机会尝试表格视图和集合视图；这篇文章反映了我在显示大量可滚动数据方面的个人经验。在这篇文章中，我们将回顾优化上述SDK组件性能的最重要技巧。这一步对于实现非常流畅的滚动体验至关重要。请注意，以下几点大部分都适用于<strong class="ir hi"> UITableView </strong>和<strong class="ir hi"> UICollectionView </strong>，因为它们有很多“幕后”行为。有几点是针对<strong class="ir hi"> UICollectionView </strong>、<strong class="ir hi"> </strong>的，因为这个视图将额外的布局细节放在了开发人员的肩上。</p><p id="c497" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们先快速概述一下上述组件。<strong class="ir hi"> <br/> UITableView </strong>经过优化，将视图显示为一系列行。由于布局是预定义的，SDK组件负责大部分布局，并提供主要用于显示单元格内容的委托。另一方面，UICollectionView 提供了最大的灵活性，因为布局是完全可定制的。然而，集合视图中的灵活性是以必须关注关于需要如何执行布局的额外细节为代价的。</p><h1 id="16d2" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">对</strong>通用的提示<strong class="ak"> UITableView和UICollectionView </strong></h1><p id="1860" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated"><strong class="ir hi"> <em class="kr">注:</em> </strong> <em class="kr">我准备用</em><strong class="ir hi"><em class="kr">UITableView</em></strong><em class="kr">来做我的代码片段。但是同样的概念也适用于</em><strong class="ir hi"><em class="kr">ui collection view</em></strong><em class="kr">。</em></p><h2 id="f81f" class="ks jp hh bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated">细胞渲染是一项关键任务</h2><p id="43e2" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated"><strong class="ir hi"> UITableView </strong>和<strong class="ir hi"> UITableViewCell </strong>之间的主要交互可以用以下事件来描述:</p><ul class=""><li id="210a" class="lg lh hh ir b is it iw ix ja li je lj ji lk jm ll lm ln lo bi translated">表格视图正在请求需要显示的单元格(<a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableviewdatasource/1614861-tableview" rel="noopener ugc nofollow" target="_blank">表格视图(_:cellForRowAt:) </a>)。</li><li id="9f0b" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated">表格视图即将显示单元格(<a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableviewdelegate/1614883-tableview" rel="noopener ugc nofollow" target="_blank">表格视图(_:willDisplay:forRowAt:) </a>)。</li><li id="0222" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated">该单元格已从表格视图(<a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableviewdelegate/1614870-tableview" rel="noopener ugc nofollow" target="_blank">表格视图(_:didendisplaying:for rowat:)</a>)中删除。</li></ul><p id="ac40" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于上述所有事件，表视图正在传递发生交互的索引(行)。这里是<strong class="ir hi"> UITableViewCell </strong>生命周期的可视化:</p><figure class="lv lw lx ly fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lu"><img src="../Images/08ee897236a4ab2614c1cc4272aa2289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ctoS0IV59d_JVipYzyApmw.png"/></div></div></figure><p id="8782" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，<a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableviewdatasource/1614861-tableview" rel="noopener ugc nofollow" target="_blank">table view(_:cellForRowAt:)</a>方法应该尽可能快。每次需要显示单元格时，都会调用此方法。它执行得越快，表格视图的滚动就越平滑。</p><p id="545c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了确保尽可能快地渲染单元格，我们可以做一些事情。以下是渲染单元格的基本代码，摘自<a class="ae jn" href="https://developer.apple.com/library/content/referencelibrary/GettingStarted/DevelopiOSAppsSwift/Lesson7.html#//apple_ref/doc/uid/TP40015214-CH8-SW1" rel="noopener ugc nofollow" target="_blank">苹果的文档</a>:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="48cb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在获取将要被重用的单元实例(<a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableview/1614878-dequeuereusablecell" rel="noopener ugc nofollow" target="_blank">dequeueReusableCell(with identifier:for:)</a>)之后，我们需要通过为其属性分配所需的值来配置它。让我们看看如何让我们的代码快速执行。</p><h2 id="c756" class="ks jp hh bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated"><strong class="ak">定义单元格的视图模型</strong></h2><p id="e9cc" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">一种方法是让我们需要展示的所有属性都容易获得，并把它们分配给相应的细胞。为了实现这一点，我们可以利用<a class="ae jn" href="https://www.objc.io/issues/13-architecture/mvvm/" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"/></a>模式。假设我们需要在表格视图中显示一组用户<em class="kr">和</em>。我们可以将<em class="kr">用户</em>的模型定义为:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="e696" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为用户定义一个视图模型很简单:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="e1e5" class="ks jp hh bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated">异步获取数据并缓存视图模型</h2><p id="ad61" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">现在我们已经定义了我们的模型和视图模型，让我们让它们工作吧！我们将通过web服务为<em class="kr">用户</em>获取数据。当然，我们希望尽可能实现最佳的用户体验。因此，我们将注意以下事项:</p><ul class=""><li id="e569" class="lg lh hh ir b is it iw ix ja li je lj ji lk jm ll lm ln lo bi translated"><strong class="ir hi">获取数据时避免阻塞主线程。</strong></li><li id="5835" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated"><strong class="ir hi">在我们获取数据后更新表格视图。</strong></li></ul><p id="be59" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这意味着我们将异步获取数据。我们将通过一个特定的控制器来执行这个任务，以便保持提取逻辑与模型和视图模型分离，如下所示:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="5a55" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们可以检索数据并异步更新表视图，如下面的代码片段所示:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="d729" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以使用上面的代码片段以几种不同的方式获取<em class="kr">用户</em>数据:</p><ul class=""><li id="af22" class="lg lh hh ir b is it iw ix ja li je lj ji lk jm ll lm ln lo bi translated"><strong class="ir hi">只有在第一次加载表格视图时，通过将它放置在</strong><a class="ae jn" href="https://developer.apple.com/reference/uikit/uiviewcontroller/1621495-viewdidload" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">viewDidLoad()</strong></a><strong class="ir hi">中。</strong></li><li id="d23c" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated"><strong class="ir hi">每次显示表格视图时，通过将它放置在</strong> <a class="ae jn" href="https://developer.apple.com/reference/uikit/uiviewcontroller/1621510-viewwillappear" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">视图中就会出现(_:) </strong> </a> <strong class="ir hi">。</strong></li><li id="f834" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated"><strong class="ir hi">根据用户需求(例如通过下拉刷新)，通过将其置于负责刷新数据的方法调用中。</strong></li></ul><p id="4e8f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">选择取决于后端数据的变化频率。如果数据大部分是静态的或者不经常改变，那么第一种选择更好。否则，我们应该选择第二种。</p><h2 id="fd06" class="ks jp hh bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated">异步加载图像并缓存它们</h2><p id="a43a" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">为我们的细胞加载图像是很常见的。因为我们试图获得最好的滚动性能，我们肯定不想阻塞获取图像的主线程。避免这种情况的一个简单方法是通过在<a class="ae jn" href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/" rel="noopener ugc nofollow" target="_blank"> URLSession </a>周围创建一个简单的包装器来异步加载图像:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="1cae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这让我们可以使用后台线程获取每个图像，然后在所需数据可用时更新UI。通过缓存图像，我们可以进一步提高我们的性能。</p><p id="1d68" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们不想——或者负担不起——自己编写自定义的异步图像下载和缓存，我们可以利用像<a class="ae jn" href="https://github.com/rs/SDWebImage" rel="noopener ugc nofollow" target="_blank"> SDWebImage </a>或<a class="ae jn" href="https://github.com/Alamofire/AlamofireImage" rel="noopener ugc nofollow" target="_blank"> AlamofireImage </a>这样的库。这些库提供了我们正在寻找的开箱即用的功能。</p><h2 id="bf37" class="ks jp hh bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated">自定义单元格</h2><p id="639b" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">为了充分利用缓存的视图模型，我们可以通过对<em class="kr">用户</em>单元进行子类化来对其进行定制(对于表视图，从<strong class="ir hi"> UITableViewCell </strong>，对于集合视图，从<strong class="ir hi"> UICollectionViewCell </strong>)。基本方法是为需要显示的模型的每个属性创建一个出口，并从视图模型中初始化它:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="893e" class="ks jp hh bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated">使用不透明图层，避免渐变</h2><p id="f107" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">由于使用透明图层或应用渐变需要大量的计算，如果可能的话，我们应该避免使用它们来提高滚动性能。特别是，我们应该避免改变<em class="kr"> alpha </em>值，最好对单元格及其包含的任何图像使用标准RGB颜色(避免使用<em class="kr"> UIColor.clear </em>):</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="1dbf" class="ks jp hh bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated">将一切放在一起:优化的单元格渲染</h2><p id="506d" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在这一点上，一旦到了渲染的时候，配置单元应该是容易且非常快速的，因为:</p><ul class=""><li id="bc88" class="lg lh hh ir b is it iw ix ja li je lj ji lk jm ll lm ln lo bi translated"><strong class="ir hi">我们正在使用缓存的视图模型数据。</strong></li><li id="121b" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated"><strong class="ir hi">我们正在异步获取图像。</strong></li></ul><p id="3138" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是更新后的代码:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h1 id="f754" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">特定于UITableView的提示</h1><h2 id="9d9f" class="ks jp hh bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated">对可变高度的单元格使用自动调整大小的单元格</h2><p id="05b0" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">如果我们想要在表格视图中显示的单元格具有可变高度，我们可以使用<a class="ae jn" href="http://useyourloaf.com/blog/self-sizing-table-view-cells/" rel="noopener ugc nofollow" target="_blank">自调整大小的单元格</a>。基本上，我们应该创建适当的自动布局约束，以确保具有可变高度的UI组件能够正确伸展。然后我们只需要初始化<a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableview/1614925-estimatedrowheight" rel="noopener ugc nofollow" target="_blank"> estimatedRowHeight </a>和<a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableview/1614852-rowheight" rel="noopener ugc nofollow" target="_blank"> rowHeight </a>属性:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="33a2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="kr">注意:</em> </strong> <em class="kr">在不幸的情况下，我们不能使用自调整大小的单元格(例如，如果仍然需要支持iOS7 ),我们必须实现</em><a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableviewdelegate/1614998-tableview" rel="noopener ugc nofollow" target="_blank"><em class="kr">tableView(_:heightForRowAt:)</em></a><em class="kr">来计算每个单元格的高度。然而，仍然有可能通过以下方式提高滚动性能:</em></p><ul class=""><li id="8097" class="lg lh hh ir b is it iw ix ja li je lj ji lk jm ll lm ln lo bi translated"><strong class="ir hi"> <em class="kr">一次性预计算所有行高。</em>T15】</strong></li><li id="454d" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated"><strong class="ir hi"> <em class="kr">返回调用</em></strong><a class="ae jn" href="https://developer.apple.com/reference/uikit/uitableviewdelegate/1614998-tableview" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"><em class="kr">table view(_:heightForRowAt:)</em></strong></a><strong class="ir hi"><em class="kr">时的缓存值。</em>T29】</strong></li></ul><h1 id="3383" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">特定于UICollectionView的提示</h1><p id="8b43" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">通过实现适当的<a class="ae jn" href="https://developer.apple.com/reference/uikit/uicollectionviewflowlayout" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">uicollectionviewlayoutdelegate</strong></a>协议方法，我们可以轻松地定制我们的大多数集合视图。</p><h2 id="e8ff" class="ks jp hh bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated">计算你的细胞大小</h2><p id="2d54" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们可以通过实现<a class="ae jn" href="https://developer.apple.com/reference/uikit/uicollectionviewdelegateflowlayout/1617708-collectionview" rel="noopener ugc nofollow" target="_blank">collection view(_:layout:sizeForItemAt:)</a>来自定义集合视图单元格的大小:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="1502" class="ks jp hh bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated">处理尺寸等级和方向变化</h2><p id="13e9" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在以下情况下，我们应该确保正确刷新集合视图布局:</p><ul class=""><li id="3dfa" class="lg lh hh ir b is it iw ix ja li je lj ji lk jm ll lm ln lo bi translated"><strong class="ir hi">过渡到不同的尺寸等级。</strong></li><li id="5e51" class="lg lh hh ir b is lp iw lq ja lr je ls ji lt jm ll lm ln lo bi translated"><strong class="ir hi">旋转设备。</strong></li></ul><p id="2df7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这可以通过实现<a class="ae jn" href="https://developer.apple.com/reference/uikit/uicontentcontainer/1621466-viewwilltransition" rel="noopener ugc nofollow" target="_blank">viewlilltransition(to:with:)</a>来实现:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h2 id="b3da" class="ks jp hh bd jq kt ku kv ju kw kx ky jy ja kz la kc je lb lc kg ji ld le kk lf bi translated">动态调整单元格布局</h2><p id="b840" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">如果我们需要动态调整单元格布局，我们应该通过在自定义集合视图单元格(是<strong class="ir hi"> UICollectionViewCell </strong>的子类)中覆盖<a class="ae jn" href="https://developer.apple.com/reference/uikit/uicollectionreusableview/1620139-apply" rel="noopener ugc nofollow" target="_blank"> apply(_:) </a>来解决这个问题:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><p id="2470" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，通常在该方法中执行的一个常见任务是调整多行<strong class="ir hi"> UILabel </strong>的最大宽度，通过编程设置其<a class="ae jn" href="https://developer.apple.com/reference/uikit/uilabel/1620534-preferredmaxlayoutwidth" rel="noopener ugc nofollow" target="_blank">preferredMaxLayoutWidth</a>属性:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><h1 id="94cd" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="140c" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">您可以在此处找到一个小样本，其中包含针对<strong class="ir hi"> UITableView </strong>和<strong class="ir hi"> UICollectionView </strong> <a class="ae jn" href="https://github.com/andrea-prearo/SwiftExamples/tree/master/SmoothScrolling/Client" rel="noopener ugc nofollow" target="_blank">的建议提示。</a></p><p id="90bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我们研究了一些常见的技巧来实现<strong class="ir hi"> UITableView </strong>和<strong class="ir hi"> UICollectionView </strong>的平滑滚动。我们还介绍了一些适用于每种特定集合类型的技巧。根据特定的UI需求，可能有更好或不同的方法来优化您的集合类型。然而，这篇文章中描述的基本原则仍然适用。和往常一样，找出哪些优化效果最好的最好方法是分析你的应用。</p></div><div class="ab cl mb mc go md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ha hb hc hd he"><p id="fc69" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kr">欲了解更多关于Capital One的API、开源、社区活动和开发人员文化的信息，请访问我们的一站式开发人员门户网站DevExchange。</em><a class="ae jn" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><em class="kr">https://developer.capitalone.com/</em></a></p></div></div>    
</body>
</html>