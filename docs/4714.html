<html>
<head>
<title>Familiarity Bias is Holding You Back: It’s Time to Embrace Arrow Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熟悉性偏见阻碍了你:是时候接受箭头功能了</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/familiarity-bias-is-holding-you-back-its-time-to-embrace-arrow-functions-3d37e1a9bb75?source=collection_archive---------0-----------------------#2017-04-20">https://medium.com/javascript-scene/familiarity-bias-is-holding-you-back-its-time-to-embrace-arrow-functions-3d37e1a9bb75?source=collection_archive---------0-----------------------#2017-04-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4583a18b7733e6400c418c6ec99a2333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dwv24VW3sEuGBo4BqrsRQg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">“Anchor” — Actor212 — (CC BY-NC-ND 2.0)</figcaption></figure><p id="c4a6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我以教JavaScript为生。最近，我调整了我的课程，以便更快地教授课程化的arrow函数——在最初的几课中。我把它放在了课程的前面，因为它是一个非常有价值的技能，而且学生们学会用箭头奉承的速度比我想象的要快得多。</p><p id="c8a1" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果他们能早一点理解并利用它，为什么不早一点教呢？</p><blockquote class="jr js jt"><p id="d5be" class="it iu ju iv b iw ix iy iz ja jb jc jd jv jf jg jh jw jj jk jl jx jn jo jp jq ha bi translated">注意:我的课程不是为从未接触过代码的人设计的。大多数学生在花了至少几个月的时间编写代码后加入——自己编写，在训练营编写，或者专业编写。然而，我看到许多经验很少或没有经验的初级开发人员很快就学会了这些话题。</p></blockquote><p id="12a5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我看到一群学生在一个小时的课程中就对curried arrow函数非常熟悉。(如果你是<a class="ae jy" href="https://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank">“跟随Eric Elliott学习JavaScript”</a>的成员，你现在就可以观看55分钟的<a class="ae jy" href="https://ericelliottjs.com/premium-content/es6-curry-composition/" rel="noopener ugc nofollow" target="_blank">ES6 Curry&amp;Composition</a>课程)。</p><p id="dabd" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">看到学生们如此迅速地掌握它，并开始施展他们新发现的咖喱能力，当我在Twitter上发布咖喱箭头功能时，我总是有点惊讶，Twitterverse对将“不可读”的代码强加给需要维护它的人的想法表示愤慨。</p><p id="5a55" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">首先，让我给你举一个我们正在谈论的例子。我第一次注意到这种反弹是Twitter对这个功能的回应:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="2a29" class="ki kj hh ke b fi kk kl l km kn">const secret = msg =&gt; () =&gt; msg;</span></pre><p id="d97c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当Twitter上的人指责我试图混淆视听时，我感到震惊。我写这个函数是为了演示在ES6中表达定制函数是多么容易。这是我在JavaScript中能想到的最简单的闭包的实际应用和表达。(相关:<a class="ae jy" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36">“什么是闭包？”</a>)。</p><p id="451d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">它相当于下面的函数表达式:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="40e3" class="ki kj hh ke b fi kk kl l km kn">const secret = function (msg) {<br/>  return function () {<br/>    return msg;<br/>  };<br/>};</span></pre><p id="3924" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du ko kp kq ke b">secret()</code>是一个接受一个<code class="du ko kp kq ke b">msg</code>并返回一个新函数的函数，该新函数返回一个<code class="du ko kp kq ke b">msg</code>。它利用闭包将<code class="du ko kp kq ke b">msg</code>的值固定为传递给<code class="du ko kp kq ke b">secret()</code>的任何值。</p><p id="f885" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你可以这样使用它:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="7101" class="ki kj hh ke b fi kk kl l km kn">const mySecret = secret('hi');<br/>mySecret(); // 'hi'</span></pre><p id="1400" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">事实证明,“双箭”正是让人困惑的地方。我确信这是一个事实:</p><blockquote class="kr"><p id="0152" class="ks kt hh bd ku kv kw kx ky kz la jq dx translated">众所周知，内嵌箭头函数是用JavaScript表达定制函数的最易读的方式。</p></blockquote><p id="3eba" class="pw-post-body-paragraph it iu hh iv b iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm lf jo jp jq ha bi translated">许多人向我争辩说长格式比短格式更容易阅读。他们部分是对的，但大部分是错的。它更加冗长，更加明确，但是不容易阅读——至少对于熟悉箭头功能的人来说是这样。</p><p id="9c65" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我在Twitter上看到的反对意见与我的学生们正在享受的顺利学习体验并不一致。根据我的经验，学生们喜欢咖喱箭头功能就像鱼喜欢水一样。在学习它们的几天内，它们就和箭融为一体了。他们毫不费力地解决各种各样的编码挑战。</p><p id="67fe" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我看不出任何迹象表明arrow函数对他们来说是“难以”学习、阅读或理解的——一旦他们在几个1小时的课程和研究会议中进行了学习它们的初始投资。</p><p id="fd7c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">他们轻松地阅读他们从未见过的curried arrow函数，并向我解释这是怎么回事。当我向他们提出挑战时，他们自然会写他们自己的。</p><p id="bdf4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">换句话说，一旦他们<strong class="iv hi">熟悉</strong>看到curried arrow函数，他们<strong class="iv hi">就不会有麻烦了</strong>。他们读起来就像你读这句话一样容易——他们的理解反映在更简单、错误更少的代码中。</p><h1 id="fd3d" class="lg kj hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">为什么有些人认为遗留函数表达式看起来“更容易”阅读</h1><p id="9c8f" class="pw-post-body-paragraph it iu hh iv b iw md iy iz ja me jc jd je mf jg jh ji mg jk jl jm mh jo jp jq ha bi translated">熟悉偏差是一种可测量的人类认知偏差，它导致我们做出自我毁灭的决定，尽管我们知道有更好的选择。尽管出于舒适和习惯，我们知道更好的模式，但我们还是继续使用同样的旧模式。</p><p id="33e0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你可以从这本优秀的书<a class="ae jy" href="https://www.amazon.com/Undoing-Project-Friendship-Changed-Minds-ebook/dp/B01GI6S7EK/ref=as_li_ss_tl?ie=UTF8&amp;qid=1492606452&amp;sr=8-1&amp;keywords=the+undoing+project&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=4ebd1476f97023e8acb4bba37ea18b90" rel="noopener ugc nofollow" target="_blank">“撤销项目:改变我们想法的友谊”</a>中学到更多关于熟悉偏见(以及我们愚弄自己的许多其他方式)的知识。这本书应该是每个软件开发人员的必读之作，因为它鼓励你更批判地思考并测试你的假设，以避免陷入各种各样的认知陷阱——这些认知陷阱是如何被发现的故事也非常好。</p><h1 id="7f36" class="lg kj hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">遗留函数表达式可能会导致代码中的错误</h1><p id="af72" class="pw-post-body-paragraph it iu hh iv b iw md iy iz ja me jc jd je mf jg jh ji mg jk jl jm mh jo jp jq ha bi translated">今天我把一个curried arrow函数从ES6重写到ES5，这样我就可以把它作为一个开源模块发布，人们可以在旧的浏览器中使用它，而不需要编译。ES5版本让我震惊。</p><p id="7475" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">ES6版本简单、简短、优雅，只有4行。</p><p id="ea89" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我肯定地认为，<strong class="iv hi">这个</strong>函数将向Twitter证明arrow函数是优越的，并且人们应该像他们的坏习惯一样放弃他们的传统函数。</p><p id="6e2c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">所以我发微博说:</p><figure class="jz ka kb kc fd ii"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="d702" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">以下是这些函数的文本，以防图片对您不起作用:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="f59a" class="ki kj hh ke b fi kk kl l km kn">// curried with arrows<br/>const composeMixins = (...mixins) =&gt; (<br/>  instance = {},<br/>  mix = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x)<br/>) =&gt; mix(...mixins)(instance);</span><span id="ccf7" class="ki kj hh ke b fi mk kl l km kn">// vs ES5-style<br/>var composeMixins = function () {<br/>  var mixins = [].slice.call(arguments);</span><span id="5009" class="ki kj hh ke b fi mk kl l km kn">  return function (instance, mix) {<br/>    if (!instance) instance = {};</span><span id="625c" class="ki kj hh ke b fi mk kl l km kn">    if (!mix) {<br/>      mix = function () {<br/>        var fns = [].slice.call(arguments);</span><span id="fef0" class="ki kj hh ke b fi mk kl l km kn">        return function (x) {<br/>          return fns.reduce(function (acc, fn) {<br/>            return fn(acc);<br/>          }, x);<br/>        };<br/>      };<br/>    }</span><span id="9aee" class="ki kj hh ke b fi mk kl l km kn">    return mix.apply(null, mixins)(instance);<br/>  };<br/>};</span></pre><p id="6a84" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">正在讨论的函数是围绕<code class="du ko kp kq ke b">pipe()</code>的一个简单包装器，这是一个标准的函数式编程实用程序，通常<a class="ae jy" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0">用于组合函数</a>。一个<code class="du ko kp kq ke b">pipe()</code>函数在lodash中以<code class="du ko kp kq ke b">lodash/flow</code>的形式存在，在Ramda中以<code class="du ko kp kq ke b">R.pipe()</code>的形式存在，甚至在几种函数式编程语言中都有自己的运算符。</p><p id="570c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">熟悉<a class="ae jy" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0">函数式编程</a>的人应该都很熟悉。其主要依赖关系也应如此:<a class="ae jy" rel="noopener" href="/javascript-scene/reduce-composing-software-fe22f0c39a1d">减少</a>。</p><p id="f1cf" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这种情况下，它被用来组成功能混合，但这是一个不相关的细节(和一个完整的其他博客帖子)。以下是重要的细节:</p><p id="e33b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">该函数接受任意数量的函数混合，并返回一个函数，该函数在管道中一个接一个地应用它们——就像装配线一样。每个函数mixin都将<code class="du ko kp kq ke b">instance</code>作为输入，并在传递给管道中的下一个函数之前添加一些东西。</p><p id="f13f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您省略了<code class="du ko kp kq ke b">instance</code>，将为您创建一个新对象。</p><p id="a9b8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">有时，我们可能希望以不同的方式编写混音。例如，您可能想通过<code class="du ko kp kq ke b">compose()</code>而不是<code class="du ko kp kq ke b">pipe()</code>来颠倒优先顺序。</p><p id="7000" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您不需要定制行为，您只需保留默认行为，并获得标准的<code class="du ko kp kq ke b">pipe()</code>行为。</p><h1 id="88c9" class="lg kj hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">只是事实</h1><p id="e5b6" class="pw-post-body-paragraph it iu hh iv b iw md iy iz ja me jc jd je mf jg jh ji mg jk jl jm mh jo jp jq ha bi translated">撇开可读性的观点不谈，下面是与这个例子相关的客观事实:</p><ul class=""><li id="3ccd" class="ml mm hh iv b iw ix ja jb je mn ji mo jm mp jq mq mr ms mt bi translated">我在ES5和ES6函数表达式、箭头或其他方面有多年的经验。熟悉度偏差不是这个数据中的一个变量。</li><li id="86da" class="ml mm hh iv b iw mu ja mv je mw ji mx jm my jq mq mr ms mt bi translated">我几秒钟就写出了ES6版本。它没有包含任何错误(据我所知，它通过了所有的单元测试)。</li><li id="6312" class="ml mm hh iv b iw mu ja mv je mw ji mx jm my jq mq mr ms mt bi translated">写ES5版本花了我几分钟时间。至少多一个数量级的时间。分钟对秒钟。我两次失去了在函数缩进中的位置。我写了3个bug，都是我必须调试和修复的。其中两次我不得不求助于<code class="du ko kp kq ke b">console.log()</code>来弄清楚发生了什么。</li><li id="266a" class="ml mm hh iv b iw mu ja mv je mw ji mx jm my jq mq mr ms mt bi translated">ES6版本有4行代码。</li><li id="2e3d" class="ml mm hh iv b iw mu ja mv je mw ji mx jm my jq mq mr ms mt bi translated">ES5版本有21行长(实际上有17行包含代码)。</li><li id="1e9c" class="ml mm hh iv b iw mu ja mv je mw ji mx jm my jq mq mr ms mt bi translated">尽管冗长乏味，ES5版本实际上失去了ES6版本中的一些信息保真度。长了很多，但是<strong class="iv hi">交流少了</strong>，继续看详情。</li><li id="c54f" class="ml mm hh iv b iw mu ja mv je mw ji mx jm my jq mq mr ms mt bi translated">ES6版本包含2个功能参数范围。ES5版本省略了spreads，转而使用了<em class="ju">隐式</em> <code class="du ko kp kq ke b">arguments</code>对象，这伤害了函数签名的可读性(保真度降级1)。</li><li id="2476" class="ml mm hh iv b iw mu ja mv je mw ji mx jm my jq mq mr ms mt bi translated">ES6版本在函数签名中定义了<code class="du ko kp kq ke b">mix</code>的默认值，因此您可以清楚地看到它是一个参数值。ES5版本模糊了这个细节，而是将它隐藏在函数体的深处。(保真度降级2)。</li><li id="356d" class="ml mm hh iv b iw mu ja mv je mw ji mx jm my jq mq mr ms mt bi translated">ES6版本只有两级缩进，这有助于阐明应该如何阅读的结构。ES5版本有6个，嵌套层次模糊了而不是增加了函数结构的可读性(保真度降级3)。</li></ul><p id="b7c0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在ES5版本中，<code class="du ko kp kq ke b">pipe()</code>占据了函数体的大部分——以至于内联定义它有点疯狂。实际上<strong class="iv hi">需要将</strong>分解成一个独立的函数，以使ES5版本可读:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="4020" class="ki kj hh ke b fi kk kl l km kn">var pipe = function () {<br/>  var fns = [].slice.call(arguments);</span><span id="8d36" class="ki kj hh ke b fi mk kl l km kn">  return function (x) {<br/>    return fns.reduce(function (acc, fn) {<br/>      return fn(acc);<br/>    }, x);<br/>  };<br/>};</span><span id="1f1a" class="ki kj hh ke b fi mk kl l km kn">var composeMixins = function () {<br/>  var mixins = [].slice.call(arguments);</span><span id="1254" class="ki kj hh ke b fi mk kl l km kn">  return function (instance, mix) {<br/>    if (!instance) instance = {};<br/>    if (!mix) mix = pipe;</span><span id="a848" class="ki kj hh ke b fi mk kl l km kn">    return mix.apply(null, mixins)(instance);<br/>  };<br/>};</span></pre><p id="7782" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在我看来，这显然更具可读性和可理解性。</p><p id="114d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们看看当我们对ES6版本应用同样的可读性“优化”时会发生什么:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="85c1" class="ki kj hh ke b fi kk kl l km kn">const pipe = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x);</span><span id="0659" class="ki kj hh ke b fi mk kl l km kn">const composeMixins = (...mixins) =&gt; (<br/>  instance = {},<br/>  mix = pipe<br/>) =&gt; mix(...mixins)(instance);</span></pre><p id="fcf5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">像ES5优化一样，这个版本更加冗长(它添加了一个以前没有的新变量)。与ES5版本不同，在抽象出管道的定义后，这个版本的可读性并没有明显提高。毕竟，它已经在函数签名: <code class="du ko kp kq ke b">mix</code>中有一个明确分配给它的变量名<em class="ju">。</em></p><p id="6f2b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du ko kp kq ke b">mix</code>的定义已经包含在它自己的行中，这使得读者不太可能弄不清它在哪里结束，而函数的其余部分继续。</p><p id="e651" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在我们有两个变量代表同样的东西，而不是一个。我们收获很大吗？不是很明显，不是。</p><p id="1fc9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">那么为什么ES5版本<strong class="iv hi">在抽象出相同功能的情况下</strong>明显更好呢？</p><p id="af93" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">因为ES5版本显然更复杂。那种复杂性的来源是这件事的症结所在。我断言复杂性的来源归结于<strong class="iv hi">语法噪声</strong>，并且语法噪声<strong class="iv hi">模糊了函数</strong>的含义，没有帮助。</p><p id="66a6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们换个方式，消除更多的变量。两个例子都用ES6，只比较<em class="ju">箭头函数</em>和<em class="ju">遗留函数表达式:</em></p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="22d6" class="ki kj hh ke b fi kk kl l km kn">var composeMixins = function (...mixins) {<br/>  return function (<br/>    instance = {},</span><span id="48c1" class="ki kj hh ke b fi mk kl l km kn">    mix = function (...fns) {<br/>      return function (x) {<br/>        return fns.reduce(function (acc, fn) {<br/>          return fn(acc);<br/>        }, x);<br/>      };<br/>    }<br/>  ) {<br/>    return mix(...mixins)(instance);<br/>  };<br/>};</span></pre><p id="3f42" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">对我来说，这看起来可读性更强。我们所做的改变是，我们利用了<strong class="iv hi"> rest </strong>和<strong class="iv hi">默认参数</strong>语法。当然，你必须熟悉rest和默认语法，这样这个版本才更易读，但是即使你不熟悉，我认为很明显这个版本还是不那么混乱。</p><p id="0225" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这很有帮助，但对我来说，这个版本仍然很混乱，将<code class="du ko kp kq ke b">pipe()</code>抽象成它自己的函数<strong class="iv hi">显然会有帮助:</strong></p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="cc0d" class="ki kj hh ke b fi kk kl l km kn">const pipe = function (...fns) {<br/>  return function (x) {<br/>    return fns.reduce(function (acc, fn) {<br/>      return fn(acc);<br/>    }, x);<br/>  };<br/>};</span><span id="59ec" class="ki kj hh ke b fi mk kl l km kn">// Legacy function expressions<br/>const composeMixins = function (...mixins) {<br/>  return function (<br/>    instance = {},<br/>    mix = pipe<br/>  ) {<br/>    return mix(...mixins)(instance);<br/>  };<br/>};</span></pre><p id="9796" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">好多了，对吧？既然<code class="du ko kp kq ke b">mix</code>赋值只占用了一行，函数的结构就清晰多了——但是对我来说还是有太多的语法干扰。在<code class="du ko kp kq ke b">composeMixins()</code>中，一个功能的结束和另一个功能的开始对我来说不是一目了然的。</p><p id="eae8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这个<code class="du ko kp kq ke b">function</code>关键字似乎在视觉上与及其周围的标识符融合在一起，而不是调用函数体。我的函数里有函数<strong class="iv hi">隐藏</strong>！参数签名在哪里结束，函数体在哪里开始？我仔细看就能搞清楚，但视觉上对我来说不明显。</p><p id="1da0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果我们可以去掉函数关键字，用一个大的<strong class="iv hi"/><code class="du ko kp kq ke b"><strong class="iv hi">=&gt;</strong></code><strong class="iv hi"/>箭头直观地指向返回值，而不是编写一个与周围标识符融为一体的<code class="du ko kp kq ke b">return</code>关键字，会怎么样？</p><p id="1dc2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">事实证明，我们可以，这看起来是这样的:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="2251" class="ki kj hh ke b fi kk kl l km kn">const composeMixins = (...mixins) =&gt; (<br/>  instance = {},<br/>  mix = pipe<br/>) =&gt; mix(...mixins)(instance);</span></pre><p id="f442" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在应该清楚是怎么回事了。<code class="du ko kp kq ke b">composeMixins()</code>是一个接受任意数量<code class="du ko kp kq ke b">mixins</code>的函数，并返回一个接受两个可选参数<code class="du ko kp kq ke b">instance</code>和<code class="du ko kp kq ke b">mix</code>的函数。它通过组合的<code class="du ko kp kq ke b">mixins</code>返回管道<code class="du ko kp kq ke b">instance</code>的结果。</p><p id="0bbd" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">还有一件事…如果我们对<code class="du ko kp kq ke b">pipe()</code>应用同样的优化，它会神奇地变成一行程序:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="acaf" class="ki kj hh ke b fi kk kl l km kn">const pipe = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x);</span></pre><p id="cfd2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">有了一行的定义，将它抽象成自己的函数的优势就不那么明显了。记住，这个函数作为一个实用程序存在于Lodash、Ramda和许多其他库中，但是它真的值得导入另一个库吗？</p><p id="0e05" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">甚至值得把它拉出来自成一行吗？大概吧。它们实际上是两种不同的功能，将它们分开会使这一点更加清楚。</p><p id="6ddc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">另一方面，当您查看参数签名时，将它内联可以澄清类型和使用预期。下面是我们内联创建它时发生的情况:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="1144" class="ki kj hh ke b fi kk kl l km kn">const composeMixins = (...mixins) =&gt; (<br/>  instance = {},<br/>  mix = (...fns) =&gt; x =&gt; fns.reduce((acc, fn) =&gt; fn(acc), x)<br/>) =&gt; mix(...mixins)(instance);</span></pre><p id="8672" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在我们回到最初的函数。一路上，<strong class="iv hi">我们没有丢弃任何意义。</strong>事实上，通过内联声明我们的参数和默认值，我们<strong class="iv hi">添加了关于如何使用函数的信息</strong>，以及参数值可能是什么样子。</p><p id="74d7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">ES5版本中所有额外的代码都只是噪音。语法噪音。它没有为<strong class="iv hi">提供任何有用的目的</strong>，除了让不熟悉curried arrow功能的人适应一下。</p><p id="eccb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一旦你对curried arrow函数有了足够的了解，很明显原始版本的可读性更好，因为语法更少了。</p><p id="5bae" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">它也不太容易出错，因为有更少的表面区域让虫子藏起来。</p><p id="0774" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我怀疑遗留函数中隐藏着大量的错误，如果你升级到arrow函数，这些错误会被发现并消除。</p><p id="d341" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我还认为，如果您学会接受和喜欢ES6中更多的简洁语法，您的团队将会变得更加高效。</p><p id="9454" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">虽然有时候事情变得清晰会更容易理解，但一般来说，代码越少越好也是事实。</p><p id="56de" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果更少的代码可以完成同样的事情，并且可以在不牺牲任何意义的情况下进行更多的交流，那就<strong class="iv hi">客观上</strong>更好。</p><p id="f1de" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">知道区别的关键是意义。如果更多的代码不能增加更多的意义，那么这些代码就不应该存在。这是一个非常基本的概念，它是自然语言中众所周知的风格指南。</p><p id="021b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">同样的风格指南也适用于源代码。拥抱它，你的代码会更好。</p><p id="9a54" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在一天结束的时候，黑暗中的一盏灯。作为对另一条称ES6版本可读性较差的推文的回应:</p><figure class="jz ka kb kc fd ii"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="9692" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">是时候熟悉ES6、currying和函数组合了。</p><h1 id="54a0" class="lg kj hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">后续步骤</h1><p id="e44a" class="pw-post-body-paragraph it iu hh iv b iw md iy iz ja me jc jd je mf jg jh ji mg jk jl jm mh jo jp jq ha bi translated"><a class="ae jy" href="https://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank">“跟随Eric Elliott学习JavaScript”</a>会员现在就可以观看55分钟的<a class="ae jy" href="https://ericelliottjs.com/premium-content/es6-curry-composition/" rel="noopener ugc nofollow" target="_blank"> ES6库里&amp;作文</a>课。</p><p id="6a7e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果你不是会员，你就错过了！</p><figure class="jz ka kb kc fd ii er es paragraph-image"><a href="https://ericelliottjs.com/product/lifetime-access-pass/"><div class="er es mz"><img src="../Images/ebd7dfc9ae8d8938e30bdbdbe428fd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3njisYUeHOdyLCGZ8czt_w.jpeg"/></div></a></figure></div><div class="ab cl na nb go nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ha hb hc hd he"><p id="5e7e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="ju">埃里克·艾略特</em> </strong> <em class="ju">著有</em> <a class="ae jy" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="ju">【编程JavaScript应用】</em> </a> <em class="ju">(奥赖利)，以及</em> <a class="ae jy" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank"> <em class="ju">【跟埃里克·艾略特学JavaScript】</em></a><em class="ju">。他为Adobe Systems</em><strong class="iv hi"><em class="ju"/></strong><em class="ju"/><strong class="iv hi"><em class="ju">尊巴健身</em></strong><em class="ju"/><strong class="iv hi"><em class="ju">华尔街日报</em></strong><em class="ju"/><strong class="iv hi"><em class="ju">【ESPN</em></strong><em class="ju"/><strong class="iv hi"><em class="ju">BBC</em></strong><em class="ju">等顶级录音师贡献了软件经验</em></p><p id="98ef" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>