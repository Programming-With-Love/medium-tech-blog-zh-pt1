<html>
<head>
<title>Kotlin generic variance modifiers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林通用方差修改器</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/kotlin-generics-variance-modifiers-36b82c7caa39?source=collection_archive---------3-----------------------#2018-01-18">https://blog.kotlin-academy.com/kotlin-generics-variance-modifiers-36b82c7caa39?source=collection_archive---------3-----------------------#2018-01-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ed18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使对于有经验的开发人员来说，泛型有时也令人困惑。最后还是简单明了吧。</p><p id="b466" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有下面的<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e?source=collection_detail----e57b304801ef-----21----------------">泛型类</a>:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="fd6c" class="ks kt in ko b gy ku kv l kw kx">class Cup&lt;T&gt;</span></pre><figure class="kj kk kl km gt kz gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/a39fbe8802f66eed76902644996c2fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/0*ILzj83W4Ibn4dfjv.jpg"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">Cup of T</figcaption></figure><p id="318d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面声明中的<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929?source=collection_detail----e57b304801ef-----26----------------">类型参数</a> <code class="fe lg lh li ko b">T</code>没有任何方差修饰符(<code class="fe lg lh li ko b">out</code>或<code class="fe lg lh li ko b">in</code>)，默认为<strong class="jm io">不变量</strong>。这意味着由这个泛型类生成的任何两个类型之间都没有关系。例如，<code class="fe lg lh li ko b">Cup&lt;Int&gt;</code>和<code class="fe lg lh li ko b">Cup&lt;Number&gt;</code>、<code class="fe lg lh li ko b">Cup&lt;Any&gt;</code>或<code class="fe lg lh li ko b">Cup&lt;Nothing&gt;</code>之间没有关系。</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="8d91" class="ks kt in ko b gy ku kv l kw kx">fun main(args: Array&lt;String&gt;) {<br/>  val anys: <!-- -->Cup<!-- -->&lt;Any&gt; = <!-- -->Cup<!-- -->&lt;Int&gt;() // Error: Type mismatch<br/>  val nothings: <!-- -->Cup<!-- -->&lt;Nothing&gt; = <!-- -->Cup<!-- -->&lt;Int&gt;() // Error: Type mismatch<br/>}</span></pre><p id="b49a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们需要这样的关系，那么我们应该使用方差修饰符:<code class="fe lg lh li ko b">out</code>或<code class="fe lg lh li ko b">in</code>。<code class="fe lg lh li ko b">out</code>使<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929?source=collection_detail----e57b304801ef-----26----------------">型参数</a> <strong class="jm io">协变</strong>。这意味着当<code class="fe lg lh li ko b">A</code>是<code class="fe lg lh li ko b">B</code>的子类型<code class="fe lg lh li ko b">Cup</code>是<strong class="jm io">的协变</strong>时，那么类型<code class="fe lg lh li ko b">Cup&lt;A&gt;</code>就是<code class="fe lg lh li ko b">Cup&lt;B&gt;</code>的子类型:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="1990" class="ks kt in ko b gy ku kv l kw kx">class <!-- -->Cup<!-- -->&lt;out T&gt;</span><span id="0c33" class="ks kt in ko b gy lj kv l kw kx">open class B<br/>class A: B()</span><span id="3906" class="ks kt in ko b gy lj kv l kw kx">fun main(args: Array&lt;String&gt;) {<br/>  val b: <!-- -->Cup<!-- -->&lt;B&gt; = <!-- -->Cup<!-- -->&lt;A&gt;() // OK<br/>  val a: <!-- -->Cup<!-- -->&lt;A&gt; = <!-- -->Cup<!-- -->&lt;B&gt;() // Error: Type mismatch<br/> <br/>  val anys: <!-- -->Cup<!-- -->&lt;Any&gt; = <!-- -->Cup<!-- -->&lt;Int&gt;() // OK<br/>  val nothings: <!-- -->Cup<!-- -->&lt;Nothing&gt; = <!-- -->Cup<!-- -->&lt;Int&gt;() // Error: Type mismatch<br/>}</span></pre><p id="0316" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<code class="fe lg lh li ko b">in</code>修改器可以达到相反的效果，使<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929?source=collection_detail----e57b304801ef-----26----------------">类型参数</a> <strong class="jm io">逆变</strong>。这意味着当<code class="fe lg lh li ko b">A</code>是<code class="fe lg lh li ko b">B</code>的子类型<code class="fe lg lh li ko b">Cup</code>是<strong class="jm io">的逆变</strong>时，那么<code class="fe lg lh li ko b">Cup&lt;A&gt;</code>类型就是<code class="fe lg lh li ko b">Cup&lt;B&gt;</code>的超类型:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="8268" class="ks kt in ko b gy ku kv l kw kx">class <!-- -->Cup<!-- -->&lt;in T&gt;</span><span id="f869" class="ks kt in ko b gy lj kv l kw kx">open class B<br/>class A: B()</span><span id="6530" class="ks kt in ko b gy lj kv l kw kx">fun main(args: Array&lt;String&gt;) {<br/>  val b: <!-- -->Cup<!-- -->&lt;B&gt; = <!-- -->Cup<!-- -->&lt;A&gt;() // Error: Type mismatch<br/>  val a: <!-- -->Cup<!-- -->&lt;A&gt; = <!-- -->Cup<!-- -->&lt;B&gt;() // OK<br/> <br/>  val anys: <!-- -->Cup<!-- -->&lt;Any&gt; = <!-- -->Cup<!-- -->&lt;Int&gt;() // Error: Type mismatch<br/>  val nothings: <!-- -->Cup<!-- -->&lt;Nothing&gt; = <!-- -->Cup<!-- -->&lt;Int&gt;() // OK<br/>}</span></pre><p id="7021" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以看看这3个方差修饰符，就像数学运算一样，当类型为等于、大于等于或小于等于时，允许进行子类型化。但是方差修饰符的含义要深得多，我将使用Java大问题来解释它，这个问题来自于Java数组是协变的，并且它们允许值设置。</p><h2 id="b41f" class="ks kt in bd lk ll lm dn ln lo lp dp lq jv lr ls lt jz lu lv lw kd lx ly lz ma bi translated">数组协方差的Java问题</h2><p id="8a3c" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">在Java中，数组是<strong class="jm io">协变的</strong>。许多资料表明，这一决定背后的原因是为了能够创建函数，如<code class="fe lg lh li ko b">sort</code>，对每种类型的数组进行泛型操作。但是这个决定有一个很大的问题。为了理解它，让我们分析下面的有效操作，它们不产生编译时错误，而是抛出运行时错误:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="daf8" class="ks kt in ko b gy ku kv l kw kx">// Java<br/>Integer[] numbers = {1, 4, 2, 1};<br/>Object[] objects = numbers;<br/>objects[2] = "B"; // Runtime error</span></pre><p id="ae2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果:运行时异常:线程“main”中的异常Java . lang . array store异常:java.lang.String</p><p id="fb9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您所看到的，<code class="fe lg lh li ko b">numbers</code>转换为<code class="fe lg lh li ko b">Object[]</code>并没有改变结构中使用的实际类型(它仍然是<code class="fe lg lh li ko b">Integer</code>，所以当我们试图将类型<code class="fe lg lh li ko b">String</code>的值赋给这个数组时，就会出现错误。这真的很糟糕！编译器应该在编译时防止这种错误。</p><blockquote class="mg"><p id="c360" class="mh mi in bd mj mk ml mm mn mo mp kh dk translated">Kotlin比Java安全多了。Kotlin中的数组具有不变的类型参数。<code class="fe lg lh li ko b">List</code>接口有协变类型参数，因为它是不可变的。可变列表具有不变类型参数。</p></blockquote><h2 id="b976" class="ks kt in bd lk ll mq dn ln lo mr dp lq jv ms ls lt jz mt lv lw kd mu ly lz ma bi translated">协方差问题</h2><p id="a8d3" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">如你所见，<strong class="jm io">协方差</strong>的问题在于向上转换后的可变性。如果你更深入地分析一下，<strong class="jm io">协变的</strong>类型参数——不仅在setter上，而且在位置(公共方法参数或公共属性)的任何<em class="mv">上——是潜在的错误源。这就是Kotlin禁止在位置</em>的<em class="mv">上使用协变类型参数的原因。</em></p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="6692" class="ks kt in ko b gy ku kv l kw kx">class <!-- -->Cup<!-- -->&lt;out T&gt;(<br/>   var elem: T // Error: T not allowed on invariant position<br/>) {<br/>  fun set(new: T) { // Error: T not allowed on in position<br/>    elem = new<br/>  }</span><span id="cb42" class="ks kt in ko b gy lj kv l kw kx">  fun get(): T = elem<br/>}</span></pre><p id="c039" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过只在<em class="mv"> out位置</em>(公共方法返回类型)上使用类型参数，而不在 <em class="mv">位置</em>(公共方法参数)或不变位置(公共属性)上使用类型参数来纠正上述代码:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="6a74" class="ks kt in ko b gy ku kv l kw kx">class <!-- -->Cup<!-- -->&lt;out T&gt;(<br/>  private var elem: T<br/>) {<br/>  fun get(): T = elem<br/>}</span></pre><p id="e81b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，这就是<code class="fe lg lh li ko b">out</code>方差修饰符名称的来源:<strong class="jm io">协变</strong>类型参数允许出现在<em class="mv">输出位置</em>上，它们是使用<code class="fe lg lh li ko b">out</code>方差修饰符生成的。</p><h2 id="7871" class="ks kt in bd lk ll lm dn ln lo lp dp lq jv lr ls lt jz lu lv lw kd lx ly lz ma bi translated">方差问题</h2><p id="5be8" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">想象一下，如果Java设计者决定默认使用数组<strong class="jm io">逆变</strong>会发生什么。我们在设置值方面不会有任何问题:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="a7d1" class="ks kt in ko b gy ku kv l kw kx">// Java<br/>Number[] nums = {1, 1.0, 1F};<br/>Integer[] ints = nums; // 1<br/>ints[2] = 12;</span></pre><ol class=""><li id="679d" class="mw mx in jm b jn jo jr js jv my jz mz kd na kh nb nc nd ne bi translated">这在Java中是不允许的，但在我们想象的场景中会出现</li></ol><p id="fea0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">相反，我们在获取值时会遇到问题，因为即使我们可以获得任何类型的数字，我们也会期望<code class="fe lg lh li ko b">Integer</code>:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="c369" class="ks kt in ko b gy ku kv l kw kx">// Java<br/>Integer i = ints[1]; // Runtime error</span></pre><p id="6a8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">甚至在这个例子之前，你可能已经猜到<strong class="jm io">逆变</strong>参数，是使用Kotlin中的<code class="fe lg lh li ko b">in</code>修改器制作的，只允许在位置的<em class="mv">上使用。如果你这样做了，那么你是完全正确的。这种限制背后的原因是，这是上述问题的唯一解决方案。让我们在实践中看看:</em></p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="d6f0" class="ks kt in ko b gy ku kv l kw kx">class <!-- -->Cup<!-- -->&lt;in T&gt;(<br/>  var elem: T // Error: T not allowed on invariant position<br/>) {<br/>  fun set(new: T) { <br/>    elem = new<br/>  }</span><span id="9dcc" class="ks kt in ko b gy lj kv l kw kx">  fun get(): T = elem // Error: T not allowed on out position<br/>}</span></pre><p id="5479" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过只在位置的<em class="mv">上使用类型参数(公共方法参数)来纠正它，而不在位置</em>的<em class="mv">上使用类型参数(公共方法返回类型)或不变位置(公共属性):</em></p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="76fa" class="ks kt in ko b gy ku kv l kw kx">class <!-- -->Cup<!-- -->&lt;in T&gt;(<br/>  private var elem: T<br/>) {<br/>  fun set(new: T) { <br/>    elem = new<br/>  }<br/>}</span></pre><h2 id="d177" class="ks kt in bd lk ll lm dn ln lo lp dp lq jv lr ls lt jz lu lv lw kd lx ly lz ma bi translated">缺少具有不变性的问题</h2><p id="7765" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">请注意，所有位置都允许使用不变类型参数:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="3dd0" class="ks kt in ko b gy ku kv l kw kx">class <!-- -->Cup<!-- -->&lt;T&gt;(<br/>  var elem: T<br/>) {<br/>  fun set(new: T) {<br/>    elem = new<br/>  }</span><span id="08eb" class="ks kt in ko b gy lj kv l kw kx">  fun get(): T = elem<br/>}</span></pre><h2 id="a48a" class="ks kt in bd lk ll lm dn ln lo lp dp lq jv lr ls lt jz lu lv lw kd lx ly lz ma bi translated">摘要</h2><p id="64e8" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">这些都使得Kotlin variance比Java安全得多。默认情况下，<code class="fe lg lh li ko b">in</code>和<code class="fe lg lh li ko b">out</code>修饰符可能不直观，但是你需要记住的是:</p><ul class=""><li id="d228" class="mw mx in jm b jn jo jr js jv my jz mz kd na kh nf nc nd ne bi translated">类型参数的默认方差行为是<strong class="jm io">不变性</strong>。如果<code class="fe lg lh li ko b">Cup</code>是<strong class="jm io">不变量</strong>并且<code class="fe lg lh li ko b">A</code>是<code class="fe lg lh li ko b">B</code>的子类型，那么 <code class="fe lg lh li ko b"><strong class="jm io">Cup&lt;A&gt;</strong></code> <strong class="jm io">和</strong> <code class="fe lg lh li ko b"><strong class="jm io">Cup&lt;B&gt;</strong></code>之间没有关系。</li><li id="074a" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><code class="fe lg lh li ko b">out</code>使类型参数<strong class="jm io">协变</strong>。如果<code class="fe lg lh li ko b">Cup</code>是<strong class="jm io">协变</strong>并且<code class="fe lg lh li ko b">A</code>是<code class="fe lg lh li ko b">B</code>的子类型，那么<code class="fe lg lh li ko b">Cup&lt;A&gt;</code>是<code class="fe lg lh li ko b">Cup&lt;B&gt;</code>的子类型。<strong class="jm io">协变</strong>型可用在<em class="mv">出位</em>上。</li><li id="2105" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><code class="fe lg lh li ko b">in</code>使类型参数<strong class="jm io">逆变</strong>。如果<code class="fe lg lh li ko b">Cup</code>是<strong class="jm io">逆变</strong>并且<code class="fe lg lh li ko b">A</code>是<code class="fe lg lh li ko b">B</code>的子类型，那么<code class="fe lg lh li ko b">Cup&lt;B&gt;</code>就是<code class="fe lg lh li ko b">Cup&lt;A&gt;</code>的子类型。<strong class="jm io">逆变型</strong>可以用在<em class="mv">的</em>位置。</li></ul><p id="75d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了帮助你学习，我制作了<a class="ae ki" href="https://ankiweb.net/shared/info/551783526" rel="noopener ugc nofollow" target="_blank"> Anki牌抽认卡</a>。</p><p id="caab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的工作室中，我们通过实践练习更深入地挖掘泛型。这是下一个:</p><figure class="kj kk kl km gt kz gh gi paragraph-image"><a href="https://www.kt.academy/#workshops-offer"><div class="gh gi nl"><img src="../Images/018370a2476e1ce49e6d3299428b4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-f1laplrjQQAMlYKfLgHw.png"/></div></a></figure></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="5e28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章是<a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-2cb67fff1fe2" rel="noopener">科特林程序员词典</a>的第十四部分。要了解最新的新部件，只需关注这个媒体或<a class="ae ki" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank">在Twitter上观察我</a>。如果你需要帮助，记得<a class="ae ki" href="https://medium.com/@marcinmoskala/ive-just-opened-up-for-online-consultations-640349aaba55" rel="noopener">我随时准备咨询</a>。</p><p id="3aae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">喜欢的话记得<strong class="jm io">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="kj kk kl km gt kz gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi nt"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="8d02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是《科特林程序员词典》的其他部分:</p><ul class=""><li id="f8a1" class="mw mx in jm b jn jo jr js jv my jz mz kd na kh nf nc nd ne bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">实参对形参，类型实参对类型形参</a></li><li id="5a40" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0" rel="noopener">语句vs表达式</a></li><li id="13fb" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">功能vs方法vs程序</a></li><li id="7623" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">字段对属性</a></li><li id="15f8" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类vs类型vs对象</a></li><li id="4d02" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b">对象表达式vs对象声明</a></li><li id="fb03" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-b085b1620890">接收器</a></li><li id="4dc6" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c">隐式接收者vs显式接收者</a></li><li id="515c" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277">分机接收机vs调度接收机</a></li><li id="21ae" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-type-vs-receiver-object-575d2705ddd9">接收器类型与接收器对象</a></li><li id="f3f7" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">函数类型vs函数文字vs Lambda表达式vs匿名函数</a></li><li id="0ad6" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-higher-order-function-9cadb07df94e">高阶函数</a></li><li id="304d" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-function-literal-with-receiver-vs-function-type-with-receiver-cc21dba0f4ff">带接收方的函数文字与带接收方的函数类型</a></li><li id="4f20" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-event-listener-vs-event-handler-305c667d0e3c">事件监听器vs事件处理器</a></li><li id="24c0" class="mw mx in jm b jn ng jr nh jv ni jz nj kd nk kh nf nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-delegation-vs-composition-3025d9e8ae3d">代表团vs组合</a></li></ul><figure class="kj kk kl km gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nu"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>