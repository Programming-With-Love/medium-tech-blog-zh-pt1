<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/globant/autoscaling-kubernetes-pods-using-keda-c094a14f2f17?source=collection_archive---------4-----------------------#2022-09-05">https://medium.com/globant/autoscaling-kubernetes-pods-using-keda-c094a14f2f17?source=collection_archive---------4-----------------------#2022-09-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><p id="8b8b" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie">使用KEDA自动缩放Kubernetes pods】</strong></p><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es if"><img src="../Images/65f8722f8f68bced77594872faf41c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shZh-qphFepTfYVOO-4nyQ.png"/></div></div></figure><p id="798d" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie">简介:</strong></p><p id="dcd2" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">KEDA是一个基于Kubernetes的事件驱动自动缩放器。使用KEDA，我们可以在Kubernetes中基于外部资源发生的事件来模拟容器的伸缩。借助KEDA，它允许任何Kubernetes工作负载从基于事件驱动的模型/架构中受益。</p><p id="1f7e" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">此外，我们将看到如何利用KEDA和基于Azure服务总线队列长度的伸缩。</p><p id="f3fb" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">该文件包含以下几节:</p><ul class=""><li id="edae" class="ir is hh hi b hj hk hn ho hr it hv iu hz iv id iw ix iy iz bi translated">KEDA的工作</li><li id="3693" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">本文件的简要背景。</li><li id="7846" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">先决条件。</li><li id="f37f" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">假设。</li><li id="c95c" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">与KEDA合作</li></ul><p id="e0cf" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie">KEDA是如何工作的？</strong></p><p id="8350" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">KEDA使用三个组件来完成其任务:</p><ul class=""><li id="db22" class="ir is hh hi b hj hk hn ho hr it hv iu hz iv id iw ix iy iz bi translated">Scaler:连接到外部组件(例如，Azure服务总线队列)并获取指标(例如，消息计数)。</li><li id="2d51" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">控制器(代理):负责“激活”部署并创建水平窗格自动缩放对象。</li><li id="1b48" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">指标适配器:将外部来源的指标呈现给水平Pod自动缩放器。</li></ul><p id="a20a" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie">背景:</strong></p><p id="1a17" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">当我们有多个工作负载来处理我们的请求时，自动伸缩是重要的特性之一。水平Pod自动缩放(HPA)是Kubernetes中已经存在的功能。那么很明显，除此之外，KEDA给我们带来了什么？<br/>因此，HPA负责根据CPU或RAM的使用情况扩展pod，而顾名思义，KEDA可以根据特定事件扩展pod。以前，不可能在特定事件上自动缩放窗格。<br/>例如，如果我们使用azure服务总线队列来推送我们的消息，那么一旦您推送您的请求，那么只有相关的pod将伸缩并执行任务。这也是一个具有成本效益的功能，因为我们没有空闲的吊舱一直在运行。KEDA是一个单一用途的轻量级组件，可以添加到任何Kubernetes集群中。KEDA与标准Kubernetes组件一起工作，如水平Pod自动缩放器，可以扩展功能而无需覆盖或复制。</p><p id="dda2" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie">先决条件:</strong></p><h2 id="35f7" class="jf jg hh bd jh ji jj jk jl jm jn jo jp hr jq jr js hv jt ju jv hz jw jx jy jz bi translated">在这里，我们将使用Azure来解释用法，因此作为先决条件的一部分，我们需要:</h2><ul class=""><li id="f1f5" class="ir is hh hi b hj ka hn kb hr kc hv kd hz ke id iw ix iy iz bi translated">Azure订阅，有权在Azure上创建和更新资源。</li><li id="cb82" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">AKS上的K8s集群和可以创建新部署的命名空间。</li><li id="4887" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">服务总线命名空间和获取该命名空间的连接字符串的访问。</li></ul><h2 id="5287" class="jf jg hh bd jh ji jj jk jl jm jn jo jp hr jq jr js hv jt ju jv hz jw jx jy jz bi translated">假设:</h2><p id="0654" class="pw-post-body-paragraph hf hg hh hi b hj ka hl hm hn kb hp hq hr kf ht hu hv kg hx hy hz kh ib ic id ha bi translated">在开始阅读本文之前，我们假设:</p><ul class=""><li id="dac4" class="ir is hh hi b hj hk hn ho hr it hv iu hz iv id iw ix iy iz bi translated">你很了解Azure和Azure服务。</li><li id="ff7f" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">你很了解Kubernetes及其特点。</li><li id="7259" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">此外，您已经掌握了编写YAML和部署文件的知识。</li></ul><p id="25ce" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie">入门:</strong></p><p id="12b6" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">定标器是KEDA的重要组成部分，负责两个方面:</p><ul class=""><li id="60ad" class="ir is hh hi b hj hk hn ho hr it hv iu hz iv id iw ix iy iz bi translated">监视新的缩放对象。</li><li id="9f59" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">以确保未发生事件的部署缩减为0个副本。一旦事件发生，它还确保从0扩展到n个副本。</li></ul><p id="a725" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">控制器负责将部署从0个副本扩展到1个副本，反之亦然，但从1个副本扩展到n个副本则由Kubernetes HPA完成。由于正在发生的事件，一旦控制器将其扩展到1个复制副本，它将自动创建该复制副本，并且HPA将使用自定义指标服务器来确定是否应该进一步扩展。</p><p id="2f94" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">触发由scalerss完成，scaler在每个ScaledObject中被定义为触发器，即TriggerAuthentication。它们定义应该监控哪些外部资源以及应该观察哪些阈值，并将指标报告回指标服务器，以便HPA可以使用它们。</p><p id="f2b8" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie">安装KEDA </strong></p><p id="d053" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">可以在集群上以多种方式安装和配置KEDA。它可以安装使用舵图表和YAML宣言。</p><p id="f588" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">在这里，我们使用了YAML的方法来安装KEDA。如果您想遵循相同的方法，请执行以下命令:</p><p id="a882" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">kubectl apply-f<a class="ae ki" href="https://github.com/kedacore/keda/releases/download/v2.0.0/keda-2.0.0.yaml" rel="noopener ugc nofollow" target="_blank">https://github . com/keda core/keda/releases/download/v 2 . 0 . 0/keda-2 . 0 . 0 . YAML</a></p><p id="5935" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">一旦上述命令成功执行，您就可以验证安装了。</p><p id="d6ae" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">kubectl get all -n keda</p><figure class="ig ih ii ij fd ik er es paragraph-image"><div role="button" tabindex="0" class="il im di in bf io"><div class="er es if"><img src="../Images/b1a038a7f279663e8a6bb559222d83d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Hax3iQC35vuGRVS1nqEGA.png"/></div></div></figure><p id="28b7" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">现在我们已经安装了KEDA，为了让魔法发生，我们需要创建三个项目:</p><ul class=""><li id="9c57" class="ir is hh hi b hj hk hn ho hr it hv iu hz iv id iw ix iy iz bi translated">秘密:它只不过是Azure服务总线名称空间的一个connectionString。</li><li id="9491" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">TriggerAuthentication:使用秘密进行身份验证并连接到服务总线以及触发伸缩的触发器。</li><li id="d0ce" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">ScaledObject:用于自动缩放窗格的定义和用于自动缩放的监控阈值。</li></ul><p id="f5f1" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie">秘密:</strong></p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="35be" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie">触发认证:</strong></p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="e585" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie"> ScaledObject: </strong></p><figure class="ig ih ii ij fd ik"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="d866" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">请记住，您可以为上述所有代码创建一个单独的文件，或者可以将相同的文件放在您的应用程序部署文件中，这样当您部署应用程序时，KEDA配置就会随之而来。</p><p id="4811" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie">优点:</strong></p><ul class=""><li id="a701" class="ir is hh hi b hj hk hn ho hr it hv iu hz iv id iw ix iy iz bi translated">KEDA使您能够根据外部源上发生的事件自动扩展工作负载，这在以前使用HPA时是不可能的。</li><li id="8108" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">当没有空闲的运行吊舱时，KEDA节省了大量成本。</li><li id="5477" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">与现有的HPA功能配合使用来扩展单元。</li><li id="f28d" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated">根据事件数量增加副本。</li></ul><p id="13a9" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie">结论:</strong></p><p id="b6e5" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">该文档让用户体验了什么是KEDA以及它是如何工作的。这在拥有事件驱动的解决方案时非常有用，因为Kubernetes不需要总是依赖资源消耗作为伸缩指标！</p><p id="fbe6" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated"><strong class="hi ie">参考文献:</strong></p><ul class=""><li id="088d" class="ir is hh hi b hj hk hn ho hr it hv iu hz iv id iw ix iy iz bi translated"><a class="ae ki" href="https://keda.sh/docs/2.6/scalers/azure-service-bus/" rel="noopener ugc nofollow" target="_blank">https://keda.sh/docs/2.6/scalers/azure-service-bus/</a></li><li id="c614" class="ir is hh hi b hj ja hn jb hr jc hv jd hz je id iw ix iy iz bi translated"><a class="ae ki" href="https://github.com/kedacore/keda/blob/main/pkg/scalers/azure_servicebus_scaler.go" rel="noopener ugc nofollow" target="_blank">https://github . com/keda core/keda/blob/main/pkg/scalers/azure _ service bus _ scaler . go</a>/</li></ul></div></div>    
</body>
</html>