<html>
<head>
<title>What is this in Javascript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中这是什么？</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/what-is-this-in-javascript-3cf0a7628798?source=collection_archive---------0-----------------------#2019-10-18">https://medium.com/quick-code/what-is-this-in-javascript-3cf0a7628798?source=collection_archive---------0-----------------------#2019-10-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3eb96d2eaac6225f89fe314b25c87b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwI522-Y2zMFS0YhYEXwZw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming online courses</a></figcaption></figure><p id="fba0" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">Javascript中的这个关键字是一个非常重要的概念，它让初学者和更高级的开发人员都感到困惑。功能很强大，但是不知道怎么用就没那么好用了。</p><p id="e4fd" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在本文中，我将解释这个关键字是什么，以及它在不同情况下的值是什么，并通过代码示例使其更加明显。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="8eec" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">这是什么？</h1><p id="6040" class="pw-post-body-paragraph iv iw hh ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js ha bi translated">让我们首先解释Javascript代码是如何工作的，以便更好地理解这个关键字是什么。每次我们在浏览器中运行Javascript时，引擎都会执行一系列步骤，其中之一就是创建执行上下文。执行上下文可以被理解为Javascript代码运行的环境。每个执行上下文都引用对象，这个对象通常引用这个关键字值。换句话说，我们可以说这个关键字是对调用函数的对象的引用。该关键字的值取决于它的使用位置。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="123a" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">这个单独使用</h1><p id="4845" class="pw-post-body-paragraph iv iw hh ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js ha bi translated">如果这将被单独使用，而不是在任何对象或函数的上下文中，它将引用全局范围。在浏览器的情况下，全局对象名是一个窗口。让我们看一个简单的代码示例:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="7e15" class="lm kb hh li b fi ln lo l lp lq">&lt;script&gt;<br/>var fruit = "apple";<br/>function getFruit() {<br/>   var fruit = "banana";<br/>   console.log("fruit", fruit); // „banana”<br/>   console.log("this.fruit", this.fruit); // „apple”<br/>}<br/>returnFruit();<br/>&lt;/script&gt;</span></pre><p id="23ff" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">让我们通过上面的例子来更好地理解这个单独使用的关键字。getFruit()函数是在全局范围内调用的，第一个Fruit变量也放在全局范围内。如果你将console.log(this)，窗口对象将有getFruit()方法和Fruit属性。</p><p id="55c4" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">此时，当我们在调用this.fruit时，它会返回“apple”，但局部变量fruit会返回“banana”。</p><p id="1387" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我们的this here是窗口对象，所以this.fruit引用全局fruit属性。</p><p id="bd2a" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">值得一提的是，在启用严格模式的情况下，这在全局范围内是未定义的。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="f138" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">这与方法一起使用</h1><p id="942b" class="pw-post-body-paragraph iv iw hh ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js ha bi translated">在从构造函数创建新对象的情况下，我们的this关键字指的是对象的新实例。</p><p id="3c07" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">让我们来看看这个例子:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="24b0" class="lm kb hh li b fi ln lo l lp lq">var firstName = "Peter";<br/>var lastName = "Strong";</span><span id="8771" class="lm kb hh li b fi lr lo l lp lq">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>  this.returnName = function() {<br/>    return this.firstName + ' ' + this.lastName;<br/>  };<br/>}</span><span id="a69d" class="lm kb hh li b fi lr lo l lp lq">let newPerson = new Person("Kate", "Smith");<br/>console.log(newPerson.returnName()); // "Kate Smith"</span></pre><p id="edea" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在调用returnName()方法的情况下，它将引用使用Person构造函数创建的newPerson对象，我们的值将是“Kate Smith ”,而不是“Peter Strong ”,因为我们使用的是newPerson对象属性。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="0d2d" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">这用于函数中</h1><p id="7383" class="pw-post-body-paragraph iv iw hh ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js ha bi translated">在函数中使用这个关键字可能有点棘手。最好记住Javascript中的函数是一个对象。它有自己的属性，其中之一就是这个，它的值取决于它是如何被调用的。如果函数被任何对象调用，那么这个值就是对象。否则，我们这个属性的功能就是一个全局对象——窗口。让我们来看一个代码示例。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="e447" class="lm kb hh li b fi ln lo l lp lq">var catName = "Garfield";<br/>var catColor = "orange";</span><span id="85c8" class="lm kb hh li b fi lr lo l lp lq">function getCat() {<br/>  return this.catName + ' is ' + this.catColor;<br/>}</span><span id="ed43" class="lm kb hh li b fi lr lo l lp lq">var cat = {<br/>  catName = "Jerry",<br/>  catColor = "gray",<br/>  getCat: function() {<br/>    return this.catName + ' is ' + this.catColor;<br/>  }<br/>}</span><span id="6b81" class="lm kb hh li b fi lr lo l lp lq">console.log('Cat in gloabl scope', getCat()); // "Garfield is orage"<br/>console.log('Cat in object scope', cat.getCat()); // "Jerry is gray"</span></pre><p id="553a" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如果我们分析代码，可以看到两个函数，一个是全局作用域函数，一个是cat对象方法。当我们调用全局作用域函数getCat()时，它使用全局作用域变量，因为函数中的这个关键字指的是全局对象。在Cat对象的getCat()方法的情况下，这指的是cat对象属性，这就是我们如何从这样类似的函数中获得两个不同的结果。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="fd87" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">这在事件中使用</h1><p id="2692" class="pw-post-body-paragraph iv iw hh ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js ha bi translated">在事件的情况下，在触发任何事件后，我们调用事件处理程序。这些处理程序是一个调用一些代码的函数。当我们在事件处理程序中使用这个关键字时，它指的是启动这个函数的HTML元素。请记住，DOM模型是一个对象树，因此页面上的每个HTML元素都作为一个对象存储在其中。让我们来看一些示例代码:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="ddde" class="lm kb hh li b fi ln lo l lp lq">&lt;button onclick="this.style.backgroundColor='blue'"&gt;Click here!&lt;/button&gt;</span></pre><p id="81f0" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">现在我们可以看到，使用它，我们可以引用按钮HTML对象并操作它的样式，例如。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="fe4c" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">调用()，应用()和绑定()</h1><p id="ac22" class="pw-post-body-paragraph iv iw hh ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js ha bi translated">Javascript中有三种方法可以帮助我们设置这个值，它们是call()、apply()和bind()。</p><p id="36c7" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">有时我们想从对象中借用一个方法，并在其他上下文中使用它，就会出现错误。让我们看一下代码:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="fb2a" class="lm kb hh li b fi ln lo l lp lq">var boy = {<br/>  greeting = 'Hello',<br/>  sayHi: function() {<br/>    return this.greeting;<br/>  }<br/>}</span><span id="742f" class="lm kb hh li b fi lr lo l lp lq">var spanishBoy = {<br/>  greeting: 'Hola'<br/>} </span><span id="38c2" class="lm kb hh li b fi lr lo l lp lq">boy.sayHi(); // "Hello";</span></pre><p id="f679" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如果我们想使用sayHi()函数，但是带有一个spanishBoy变量问候语，我们该怎么办？这就是call()、apply()和bind()得心应手之处。让我们仔细检查一下，看看有什么不同。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="cd76" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">调用()</h1><p id="003f" class="pw-post-body-paragraph iv iw hh ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js ha bi translated">call()方法允许我们给这个关键字赋新的值。我们可以向call()方法传递多个参数。第一个参数是new this的值，接下来，我们可以传递函数参数。因此，调用带有新this和传递参数的函数。让我们来看看代码:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="c363" class="lm kb hh li b fi ln lo l lp lq">var boy = {<br/>  greeting = 'Hello',<br/>  sayHi: function() {<br/>    return this.greeting;<br/>  }<br/>}</span><span id="c0bd" class="lm kb hh li b fi lr lo l lp lq">var spanishBoy = {<br/>  greeting: 'Hola'<br/>} </span><span id="eb71" class="lm kb hh li b fi lr lo l lp lq">boy.sayHi(); // "Hello";</span><span id="d1d0" class="lm kb hh li b fi lr lo l lp lq">boy.sayHi.call(spanishBoy); // "Hola";</span></pre><p id="abaa" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">这里您可以看到使用call()方法的结果。sayHi()方法是通过spanishBoy上下文立即调用的，我们有可能使用Boy对象方法，而无需为spanishBoy对象创建新方法。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="3591" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">应用()</h1><p id="54fb" class="pw-post-body-paragraph iv iw hh ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js ha bi translated">我们来看看下一个方法，apply()。这个方法与call()非常相似，它也让我们更改这个值，并在函数被使用后立即调用它，但是它们之间有一个小的区别。在向call()方法传递参数时，它看起来像这样:call(newThis，arg1，arg2，arg3)。在apply()函数的情况下，我们可以将它们作为数组传递，而不是分别传递每个参数，就像这样:apply(newThis，[arg1，arg2，arg3])。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="17f2" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">绑定()</h1><p id="ae73" class="pw-post-body-paragraph iv iw hh ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js ha bi translated">bind()方法与call()和apply()略有不同。bind()没有立即调用函数，而是创建并返回一个新的函数，并赋予新的this值。让我们看一下代码示例。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="b287" class="lm kb hh li b fi ln lo l lp lq">var boy = {<br/>  greeting = 'Hello',<br/>  sayHi: function() {<br/>    return this.greeting;<br/>  }<br/>}</span><span id="a772" class="lm kb hh li b fi lr lo l lp lq">var spanishBoy = {<br/>  greeting: 'Hola'<br/>} </span><span id="65cb" class="lm kb hh li b fi lr lo l lp lq">boy.sayHi(); // "Hello";<br/>const sayHola = boy.sayHi.bind(spanishBoy);<br/>sayHola(); // "Hola";</span></pre><p id="749c" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在这个例子中，我们可以看到我们能够创建一个名为sayHola()的新函数，您可以随时调用它。在处理异步代码时，或者如果你想传递一些参数给你的函数，使用bind()方法可能会非常有用。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="e32e" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="977a" class="pw-post-body-paragraph iv iw hh ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js ha bi translated">在本文中，我介绍了这个关键字在Javascript中的定义和用法。我解释了在不同的场景中你可以期望得到什么样的值，并描述了3个重要的方法:call()、apply()和bind()。</p><p id="ba6e" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">考虑到理解这个关键字对正确使用它和避免代码中的大量错误是多么重要，我希望你会发现这篇文章是有用的。此外，记住理解Javascript的基础知识对掌握更高级的概念非常有帮助。</p><p id="5ac3" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">好好编码！</p><figure class="ld le lf lg fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/2bebe9fe48fb99c5d1c4456e97533030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H5SfHeLRaGv3R2TzVAO_yw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><a class="ae iu" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming online courses</a></figcaption></figure><p id="6f6b" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">感谢您的阅读。</p><p id="9c2b" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">这篇文章是我们的队友安娜创作的。</p></div></div>    
</body>
</html>