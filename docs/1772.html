<html>
<head>
<title>Async Processing in Python — Make Data Pipelines Scream</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的异步处理——让数据管道尖叫</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/async-processing-in-python-make-data-pipelines-scream-a1e8467e7919?source=collection_archive---------2-----------------------#2021-01-04">https://medium.com/capital-one-tech/async-processing-in-python-make-data-pipelines-scream-a1e8467e7919?source=collection_archive---------2-----------------------#2021-01-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="71d0" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">轻松控制程序中单个函数的异步执行，而不是并行处理</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/b074f046425ff35ccaefbffaf4787856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pL2TGmWwpTCeap8K.png"/></div></div></figure><h1 id="c5fb" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">序文</h1><p id="a36d" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">“那么，你能不能在这个问题上投入一堆额外的服务器，让这个过程并行运行，让它更快？”Acme Widgets的首席技术官恼怒地问<strong class="kc hi">汤姆</strong>。</p><p id="c30e" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">Acme的数据管理团队开发了多条数据管道，用于将数据传输、转换和交付给各种系统以供使用。管道从各种来源读取数据，如kafka流、队列、磁盘甚至网络套接字，并在将数据发送到目标系统之前对数据执行重要的计算。虽然计算的时间是相当可预测的，但是数据到达的时间与计算相比通常要慢得多；零星且不可预测。如果按顺序执行，整个流程会变慢，导致机会丧失和大量客户不满。</p><p id="f337" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">但是Acme可以访问其云服务上几乎无限数量的虚拟服务器。难道他们就不能让多台服务器以多线程的方式运行这条管道，从而提高速度吗？这是汤姆提出的问题。但是<strong class="kc hi">开发负责人黛布拉</strong>认为将程序从单线程改写成多线程是一个过于复杂的解决方案，不仅昂贵，容易出错，有时甚至是不可能的。肯定会有更好的解决办法。他们都向首席建筑师阿曼达寻求启示。</p><p id="fcc0" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">对阿曼达来说这不是新情况。在加入Acme之前，她在许多组织中担任数据领导者，她必须就数据模式的微妙差异对许多其他技术领导者进行教育，包括精心设计以避免不可信数据的风险。她从过去的经验中知道，用清晰的例子解释什么能做什么不能做通常是证明什么对Acme最有利的最佳方式。</p><p id="fa38" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">阿曼达同意汤姆和黛布拉的观点。“有好消息，”她宣布。<em class="kw">“而且不好。首先，好消息是:有可能以更简单的方式在Python中实现伪多线程功能，从而使流水线更快。不好的一面是:这种方法有细微的差别，而且不是所有的事情都可以很容易地多线程化。但总体来说，应该会更快。”</em></p><p id="ea39" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">大家都催她详细解释。</p><h1 id="5bf3" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">管道</h1><p id="53a3" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">首先，Amanda解释了为什么有些进程很慢，多线程不可能让它们变得更快。她举例说明了该过程的以下部分:</p><ol class=""><li id="5abe" class="lc ld hh kc b kd kx kg ky kj le kn lf kr lg kv lh li lj lk bi translated"><strong class="kc hi">读取</strong>数据。该函数等待从某个地方读取数据，例如kafka流、网络套接字或者甚至从磁盘读取数据。一个例子是获取客户点击网站的次数。</li><li id="2b43" class="lc ld hh kc b kd ll kg lm kj ln kn lo kr lp kv lh li lj lk bi translated"><strong class="kc hi">对数据计算</strong>。该函数对接收到的数据进行计算，例如将特定类型浏览器的所有点击次数相加。</li><li id="3e21" class="lc ld hh kc b kd ll kg lm kj ln kn lo kr lp kv lh li lj lk bi translated"><strong class="kc hi">写入</strong>数据。该函数将结果写入某个存储或发送到队列。</li></ol><p id="78cf" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">它类似于以下循环:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lq"><img src="../Images/257188dfab1e1621f3b0afa3dc008da4.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*2SW1pjykc7Hqv2gztR2VpQ.png"/></div></figure><p id="03f4" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">如果按顺序执行，它类似于这个流程，v形的长度表示该函数所用的时间。Amanda指出，read()函数的执行时间经常不同。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lr"><img src="../Images/9be5169fd4dfece39fcbca981fd334b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*39wC-2e-xTRtr2OJAzjg3A.png"/></div></figure><p id="70bf" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">随着读取操作数量的增加，经过的时间也会增加。Amanda解释说，为了使管道多线程化，我们必须执行compute()函数的多个实例；但是我们需要知道如何划分read()函数的输出，并跟踪谁做了多少。正如黛布拉所说，这使得设计非常复杂，难以维护。雪上加霜的是，在某些情况下，创建compute()的多个实例甚至是不可能的，因为数据可能需要实时处理。</p><p id="0d80" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">Amanda解释说，一个更实际的方法是只并行运行<em class="kw">几个函数</em>，其他的按顺序运行。通常，读取操作很慢，并且具有不可预测的时序；因此，这些可以并行执行。数据状态更重要的计算操作可以按顺序执行，如下图所示。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ls"><img src="../Images/3cc50ec22210fbca000daffc09958d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*8OCQN8rq35gTQw7PHGLRvg.png"/></div></figure><p id="f16a" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">Amanda解释说，在这里，读函数()是并行的。compute()函数按顺序运行，在任何read()函数的第一次输出之后立即开始，而不是等待所有操作完成。然后，它可以在其他read()函数完成时获取它们的结果。这大大缩短了运行时间。以这种方式交错函数会导致更快的总体执行时间。</p><p id="c8c3" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">但是这不是并行处理，黛布拉插嘴说，因为不是所有的组件都并行运行。</p><p id="6434" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated"><em class="kw">“不，不是这样的，”</em>阿曼达回应道，“它有选择地异步运行组件。诀窍是这样只运行一些组件。而且用Python实现也是比较琐碎的任务。”</p><h1 id="6c3a" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">“传统”的方式</h1><p id="b1f3" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">首先，阿曼达考察了传统的编写程序的方式。她展示了一个名为<strong class="kc hi"> sync.py </strong>的示例程序，其中一个名为<strong class="kc hi"> myproc() </strong>的函数做了一件耗时5秒的事情。为了简单起见，她只是让<strong class="kc hi">休眠(5) </strong>来模拟5秒的执行时间。当进行函数调用时，程序打印一行“myproc started …”。同样，当函数完成执行时，它会打印“myproc finished …”。最后，使用时间模块，她记录了经过的时间。</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="88f2" class="ly jj hh lu b fi lz ma l mb mc"># sync.py<br/>import time<br/>def myproc():<br/>   print("myProc started ...")<br/>   t1 = time.perf_counter()<br/>   time.sleep(5)<br/>   t = time.perf_counter() - t1<br/>   print(f"   myProc finished in {t:0.5f} seconds.")<br/>  <br/>def main():<br/>   for _ in range(5):<br/>       myproc()<br/>    <br/>if __name__ == "__main__":<br/>   start_sec = time.perf_counter()<br/>   main()<br/>   elapsed_secs = time.perf_counter() - start_sec<br/>   print(f"Job finished in {elapsed_secs:0.5f} seconds.")</span></pre><p id="5662" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">Amanda用Python执行了这个程序，并显示了输出:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="0a7c" class="ly jj hh lu b fi lz ma l mb mc">myProc started ...<br/>  myProc finished in 5.00262 seconds.<br/>myProc started ...<br/>  myProc finished in 5.00281 seconds.<br/>myProc started ...<br/>  myProc finished in 5.00011 seconds.<br/>myProc started ...<br/>  myProc finished in 5.00042 seconds.<br/>myProc started ...<br/>  myProc finished in 5.00504 seconds.<br/>Job finished in 25.01145 seconds.</span></pre><p id="a0da" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">正如预期的那样，该作业总共花费了25秒，因为函数myproc()的每次运行花费了5秒。依次运行5次，它在25秒内完成了任务。</p><h1 id="08f6" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">异步方式</h1><p id="cef8" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">阿曼达指出，这就是数据管道的传统发展方式。现在，她以异步方式重写程序。下面是修改后的代码，命名为async1.py。她添加了注释(前面有#)来标识修改的部分。</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="b9cc" class="ly jj hh lu b fi lz ma l mb mc"># async1.py<br/>import asyncio # new module <br/>import time<br/>async def myproc(): # async is new<br/>   print("myProc started ...")<br/>   t1 = time.perf_counter()<br/>   await asyncio.sleep(5) # await asyncio is new<br/>   t = time.perf_counter() - t1<br/>   print(f"   myProc finished in {t:0.5f} seconds.")<br/>async def main(): # async is new<br/>   await asyncio.gather( # await asyncio is new<br/>     myproc(),<br/>     myproc(),<br/>     myproc(),<br/>     myproc(),<br/>     myproc()<br/>   )<br/>if __name__ == "__main__":<br/>   start_sec = time.perf_counter()<br/>   asyncio.run(main()) # asyncio.run is new<br/>   elapsed_secs = time.perf_counter() - start_sec<br/>   print(f"Job finished in {elapsed_secs:0.5f} seconds.")</span></pre><p id="70f7" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">以下是她运行代码时的输出:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="2fd9" class="ly jj hh lu b fi lz ma l mb mc">myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>  myProc finished in 5.00337 seconds.<br/>  myProc finished in 5.00347 seconds.<br/>  myProc finished in 5.00349 seconds.<br/>  myProc finished in 5.00351 seconds.<br/>  myProc finished in 5.00353 seconds.<br/>Job finished in 5.00495 seconds.</span></pre><p id="b4ba" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">大家惊呼。整个过程现在只用了5秒钟就完成了(这是函数myproc()的每次运行<em class="kw">所花费的时间)。这怎么可能——他们都问阿曼达。</em></p><h1 id="e4bb" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">异步/等待组合</h1><p id="926a" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">Amanda解释说，诀窍是在代码中包含async和await关键字。这些关键字确保函数以异步方式运行。她指向下面一行:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="ae2e" class="ly jj hh lu b fi lz ma l mb mc">await sleep(5)</span></pre><p id="bcf2" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">await关键字告诉Python不要等待它的完成；而是立即将控制发送回调用者并继续处理。</p><p id="cbc1" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">房间里有一种普遍的混乱感。因此，Amanda重复了这一点，因为这是一个非常强有力的概念，可以让小组成员理解。关键字告诉Python解释器<em class="kw">立即将控制权交还给调用者</em>(在本例中是程序main())，但<em class="kw">继续处理函数中剩余的语句</em>。一旦执行结束，该函数将取回控制权。</p><p id="9c43" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">然后她指向下面一行字:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="454d" class="ly jj hh lu b fi lz ma l mb mc">asyncio.run(main())</span></pre><p id="1728" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">Amanda继续说道，它以一种<em class="kw">异步</em>的方式执行main()函数，即不等待myproc()的完成。但是，看看代码，她注意到main()函数代码中没有其他内容；因此main()函数调用myproc()的下一次迭代，还是像以前一样异步，并且只要遇到await关键字，它就传递控制。</p><p id="7888" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">黛布拉似乎很害怕。myproc()函数应该执行一些有用的操作，比如读取、处理或写入数据。如果控制已经立即返回到main()函数，并且程序忘记了myproc()的结果发生了什么，那么它在管道处理中是如何有用的——她想知道。</p><p id="2983" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">啊哈！这就是魔力所在——阿曼达解释道。就在函数myproc()完成的那一刻(按照设计，大约是5秒钟)，<em class="kw">控件将</em>传递回最初调用它的函数main()。main()函数执行下一行，打印结束行以及经过的时间。</p><p id="ebda" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">函数myproc()用了5秒(如预期)；但是整个程序以一种并行的方式执行所有的函数调用。因此总时间也只有5秒。</p><p id="ea08" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated"><em class="kw">“注意，我称之为并行，”</em> Amanda继续说道。执行实际上不是并行的。她在函数代码中加入了async子句，以告知何时将控制权交还给调用者。它<em class="kw">模仿</em>并行。因此，Tom认为，被调用的函数只是一个非阻塞调用。正是，阿曼达回答道。<em class="kw">“对于那些熟悉unix shell的人来说，这有点类似于同时多次调用带有nohup和后台处理选项(末尾带有一个“&amp;”的命令。”</em></p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="acd0" class="ly jj hh lu b fi lz ma l mb mc">nohup somecommand.sh &amp;<br/>nohup somecommand.sh &amp;<br/>nohup somecommand.sh &amp;<br/>nohup somecommand.sh &amp;<br/>nohup somecommand.sh &amp;</span></pre><p id="1ced" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated"><em class="kw">“它们都将异步运行。但是，"</em>她澄清道，<em class="kw">"与unix shell不同，当内部代码行执行完毕时，我的函数调用会取回控制权。这就是它如此强大的原因。”</em></p><h1 id="01a7" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">我们控制异步部分</h1><p id="b6ca" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">所有的目光都转向黛布拉，以确认这是否会缩短漫长的时间；但她对此表示怀疑。<em class="kw">“我知道你可以以异步方式调用函数，以伪并行方式执行，减少执行时间，”</em>她解释道，<em class="kw">“但并不是所有的函数调用都可以异步。例如，读取数据的函数可以是异步的；但不能转换函数。后面的函数，如果异步调用，会引入数据错误。”</em></p><p id="86d0" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">Amanda承认这是合理的考虑，并解释说有选择地控制函数的异步性是可能的。为了进行说明，她将代码async1.py修改为async2.py，并在注释中显示了这些更改。在这段修改后的代码中，她假设了两个任务，每个任务耗时2.5秒。一部分是异步的，可以并行运行。在现实生活中，这将类似于从磁盘、套接字、队列等读取数据。另一部分，同样需要2.5秒，不能异步。在现实生活中，这将类似于转换。</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="da5a" class="ly jj hh lu b fi lz ma l mb mc"># async2.py<br/>import asyncio<br/>import time<br/>async def myproc():<br/>   print("myProc started ...")<br/>   t1 = time.perf_counter()<br/>   # the following is an async call function that takes 2.5 secs<br/>   await asyncio.sleep(2.5)<br/>   # the following is an sync call function that takes 2.5 secs<br/>   time.sleep(2.5)<br/>   t = time.perf_counter() - t1<br/>   print(f"   myProc finished in {t:0.5f} seconds.")<br/>async def main():<br/>   await asyncio.gather(<br/>     myproc(),<br/>     myproc(),<br/>     myproc(),<br/>     myproc(),<br/>     myproc()<br/>   )<br/>if __name__ == "__main__":<br/>   start_sec = time.perf_counter()<br/>   asyncio.run(main())<br/>   elapsed_secs = time.perf_counter() - start_sec<br/>   print(f"Job finished in {elapsed_secs:0.5f} seconds.")</span></pre><p id="b1c1" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">以下是她运行脚本的结果:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="98bb" class="ly jj hh lu b fi lz ma l mb mc">myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>  myProc finished in 5.00751 seconds.<br/>  myProc finished in 7.50905 seconds.<br/>  myProc finished in 10.01197 seconds.<br/>  myProc finished in 12.51726 seconds.<br/>  myProc finished in 15.02254 seconds.<br/>Job finished in 15.02414 seconds.</span></pre><p id="e1ee" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">所有人都觉得输出很有趣。当然，正如预期的那样，所有的函数调用都立即开始了。然而，黛布拉观察到，现在每次通话花费的时间越来越多，实际上比上一次通话多了2.5秒。这很奇怪，她想知道为什么。</p><p id="3b00" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">黛比解释说，这是因为只有2.5秒的通话是异步的，而不是整个通话。一旦到达异步部分，控制返回到函数myproc()来执行其余的行。紧接着的下一行是第二个sleep()，它不是异步的。这就是为什么函数myproc()没有将控制权返回给调用者——在本例中是模块main (),直到睡眠完成。因此这是一个<strong class="kc hi">阻塞</strong>呼叫。这就是为什么函数调用的第二次迭代必须等待2.5秒睡眠的执行。</p><p id="2f43" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">Amanda举的这个例子让大家意识到为什么这个技术不是真正的并行执行。这仅仅是一个选择性异步(非阻塞)执行，她控制实现伪并行；但是他们都承认这项技术对于许多用例来说已经足够了。</p><h1 id="10bb" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">通话顺序很重要</h1><p id="816b" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">"你在一个函数中调用异步和同步部分的顺序是一样的吗？"汤姆沉思着。</p><p id="7659" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">是的，这是一个需要解决的大问题，阿曼达警告说。为了说明顺序的有用性和重要性，她对程序做了另一个小小的修改，并将其命名为async3.py。在这个例子中，她只是颠倒了调用async和sync sleep命令的顺序，如注释所示:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="d28a" class="ly jj hh lu b fi lz ma l mb mc"># async3.py<br/>import asyncio<br/>import time<br/>async def myproc():<br/>   print("myProc started ...")<br/>   t1 = time.perf_counter()<br/>   # Now it is sync first and then async<br/>   time.sleep(2.5) <br/>   await asyncio.sleep(2.5)<br/>   t = time.perf_counter() - t1<br/>   print(f"   myProc finished in {t:0.5f} seconds.")<br/>async def main():<br/>   await asyncio.gather(<br/>     myproc(),<br/>     myproc(),<br/>     myproc(),<br/>     myproc(),<br/>     myproc()<br/>   )<br/>if __name__ == "__main__":<br/>   start_sec = time.perf_counter()<br/>   asyncio.run(main())<br/>   elapsed_secs = time.perf_counter() - start_sec<br/>   print(f"Job finished in {elapsed_secs:0.5f} seconds.")</span></pre><p id="c1e0" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">她运行程序并得到以下输出:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="9141" class="ly jj hh lu b fi lz ma l mb mc">myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>myProc started ...<br/>  myProc finished in 12.51053 seconds.<br/>  myProc finished in 10.00526 seconds.<br/>  myProc finished in 7.50407 seconds.<br/>  myProc finished in 5.00093 seconds.<br/>  myProc finished in 5.00068 seconds.<br/>Job finished in 15.01211 seconds.</span></pre><p id="f5ad" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">虽然在这个静态截图中看不到，但是函数调用的第一行“myProc started …”现在交错出现，中间间隔2.5秒。早些时候，所有行“myProc started …”同时出现。观众首先对这个有趣的变化感到好奇。</p><p id="284b" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">Amanda将他们的注意力指向了第一个2.5秒的睡眠呼叫，这是同步的；因此，myproc()在将控制发送回主程序之前必须等待那么长时间。main()程序直到那时才能再次调用myproc()。她解释说，这就是为什么这条信息会在2.5秒后出现。</p><p id="d84f" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">观众好奇的第二部分是台词<strong class="kc hi">“my proc完成了……”</strong>，这是执行时间的逆序，不像上次是从最小到最大。</p><p id="3009" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">Amanda解释道:2.5秒后，函数myproc()遇到了<em class="kw">异步</em>睡眠调用。因为它是异步的，所以它立即将控制返回给main()，然后main调用myproc()的第二个实例。同样的事情发生在myproc()的第二个实例中，即它等待了2.5秒。最后，在myproc()函数的第5次迭代之后，main()又回到了myproc()的第一次调用；但那是在所有其他电话打完之后。因此，我们这里有一个有趣的模式，Debra指出:对myproc()的第一次调用是最长的，与前一种情况相反，最后一次调用是最长的。不过，总的时间保持不变。</p><p id="f978" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">黛比警告说，这就是为什么调用函数的同步和异步部分的顺序很重要。它决定了程序将如何从子组件返回值。总时间不会变化。</p><h1 id="7d21" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">秩序法则</h1><p id="16e3" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">但是汤姆不相信。这真的与现实世界相关吗——他想知道。</p><p id="20d6" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">有道理，阿曼达同意并考虑了这个项目中的另一个小任务。她继续说道，假设我们获得了网站的点击量，我们需要计算函数调用的总和。为了简单起见，她只是在每次调用函数时将名为sum的变量加1。她还添加了一些代码来显示函数是如何被一个接一个地调用的。她修改函数代码来接受一个名为<strong class="kc hi"> callid </strong>的参数，这个参数只是一个数字，用来清楚地表示对函数的每个调用。然后她打印出一串<strong class="kc hi">callid</strong>来显示函数的哪一次迭代被调用。</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="6dd0" class="ly jj hh lu b fi lz ma l mb mc">import asyncio<br/>import time<br/>chain = ""<br/>sum = 0<br/>async def myproc(callid):<br/>   global chain<br/>   global sum<br/>   print(f"myProc {callid} started ...")<br/>   t1 = time.perf_counter()<br/>   await asyncio.sleep(2.5)<br/>   chain = chain + "-&gt;" + str(callid)<br/>   sum = sum + 1<br/>   time.sleep(2.5)<br/>   t = time.perf_counter() - t1<br/>   print(f"   myProc {callid} finished in {t:0.5f} seconds. sum = {sum} chain {chain}")<br/>async def main():<br/>   await asyncio.gather(<br/>     myproc(1),<br/>     myproc(2),<br/>     myproc(3),<br/>     myproc(4),<br/>     myproc(5)<br/>   )<br/>if __name__ == "__main__":<br/>   start_sec = time.perf_counter()<br/>   asyncio.run(main())<br/>   elapsed_secs = time.perf_counter() - start_sec<br/>   print(f"Job finished in {elapsed_secs:0.5f} seconds.")</span></pre><p id="af45" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">以下是输出:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="a1ac" class="ly jj hh lu b fi lz ma l mb mc">myProc 1 started ...<br/>myProc 2 started ...<br/>myProc 3 started ...<br/>myProc 4 started ...<br/>myProc 5 started ...<br/>  myProc 1 finished in 5.00606 seconds. sum = 1 chain -&gt;1<br/>  myProc 2 finished in 7.51137 seconds. sum = 2 chain -&gt;1-&gt;2<br/>  myProc 3 finished in 10.01224 seconds. sum = 3 chain -&gt;1-&gt;2-&gt;3<br/>  myProc 4 finished in 12.51499 seconds. sum = 4 chain -&gt;1-&gt;2-&gt;3-&gt;4<br/>  myProc 5 finished in 15.01671 seconds. sum = 5 chain -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5<br/>Job finished in 15.01861 seconds.</span></pre><p id="a298" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">观众注意到这些函数是按照她调用它们的顺序被调用的，如链中所示；但是sum变量在每个函数调用中都是不同的。他们想知道为什么会这样。</p><p id="3636" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">Amanda让他们注意函数myproc()的代码。第一次调用时，遇到了<em class="kw">异步</em>睡眠；所以它立即将控制权返回给main()，然后main()继续第二次myproc()函数调用。然而，当第二个函数调用(callid=2)开始执行同步部分时，第一个函数调用(callid=1)已经开始计算并完成了工作。当时的总和是0；所以它加了1得出1。当第二个函数调用到达代码的计算部分时，总和已经是1；于是就想出了1 + 1 = 2。接下来的电话也是如此。</p><p id="8e38" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">所以，汤姆再次恳求道，这有什么关系呢？</p><p id="451a" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">阿曼达解释道，如果你需要的只是最终的金额，也就是工作结束时的金额，那就没问题了。这个数字无论如何都是正确的。但是，如果您在函数中使用sum <em class="kw">，例如，检查sum是否大于3以执行一些其他操作，那么显然调用1、2和3会失败，但4和5会成功。她警告说，这可能会无意中引入一个漏洞。例如，如果你有不同类型的函数:一个执行一些计算，另一个观察和微调计算函数的执行，重要的是把它们按正确的顺序排列；否则你会陷入一种竞争状态。</em></p><p id="a3e2" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">举例来说，Amanda做了一个小小的改变，她<em class="kw">颠倒了</em>同步和异步调用的顺序。</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="ac8e" class="ly jj hh lu b fi lz ma l mb mc">import asyncio<br/>import time<br/>chain = ""<br/>sum = 0<br/>async def myproc(callid):<br/>   global chain<br/>   global sum<br/>   print(f"myProc {callid} started ...")<br/>   t1 = time.perf_counter()<br/>   time.sleep(2.5)<br/>   chain = chain + "-&gt;" + str(callid)<br/>   sum = sum + 1<br/>   await asyncio.sleep(2.5)<br/>   t = time.perf_counter() - t1<br/>   print(f"   myProc {callid} finished in {t:0.5f} seconds. sum = {sum} chain {chain}")<br/>async def main():<br/>   await asyncio.gather(<br/>     myproc(1),<br/>     myproc(2),<br/>     myproc(3),<br/>     myproc(4),<br/>     myproc(5)<br/>   )<br/>if __name__ == "__main__":<br/>   start_sec = time.perf_counter()<br/>   asyncio.run(main())<br/>   elapsed_secs = time.perf_counter() - start_sec<br/>   print(f"Job finished in {elapsed_secs:0.5f} seconds.")</span></pre><p id="4b24" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">以下是输出:</p><pre class="ix iy iz ja fd lt lu lv lw aw lx bi"><span id="2a6c" class="ly jj hh lu b fi lz ma l mb mc">myProc 1 started ...<br/>myProc 2 started ...<br/>myProc 3 started ...<br/>myProc 4 started ...<br/>myProc 5 started ...<br/>  myProc 1 finished in 12.51241 seconds. sum = 5 chain -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5<br/>  myProc 2 finished in 10.01062 seconds. sum = 5 chain -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5<br/>  myProc 3 finished in 7.51010 seconds. sum = 5 chain -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5<br/>  myProc 4 finished in 5.00613 seconds. sum = 5 chain -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5<br/>  myProc 5 finished in 5.00680 seconds. sum = 5 chain -&gt;1-&gt;2-&gt;3-&gt;4-&gt;5<br/>Job finished in 15.01523 seconds.</span></pre><p id="8d1c" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">Amanda指出，虽然最终结果是相同的，即工作在大约15秒内完成，但函数内部的行为却非常不同。她吸引观众的注意力来展示sum的值是如何相同的，以及在函数调用的所有迭代中链是如何相同的。她解释说，这是因为第一个调用是sync(而不是前面例子中的async ),函数调用一直等到sync调用完成。当sync调用完成时，所有的值都被适当地赋值，并且总和被更新。她观察到，在这种情况下，在任何迭代中检查变量的值都是安全的。</p><p id="98ba" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">Amanda警告说，底线是要密切注意函数调用的哪些部分是同步或异步的，以及在哪里检查函数内部设置的变量值。它可能会在你没有意识到的情况下产生不同的结果。汤姆、黛布拉和所有的观众都非常乐意学习这种技巧和要避免的潜在问题。他们非常感谢阿曼达。</p><h1 id="71f6" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">概括起来</h1><p id="d437" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">让我们重温一下故事开头描述的场景——带有两个示例函数的数据管道:</p><ol class=""><li id="6882" class="lc ld hh kc b kd kx kg ky kj le kn lf kr lg kv lh li lj lk bi translated"><strong class="kc hi"> read(): </strong>等待数据到达的地方</li><li id="f36d" class="lc ld hh kc b kd ll kg lm kj ln kn lo kr lp kv lh li lj lk bi translated"><strong class="kc hi"> compute(): </strong>对收到的数据进行计算</li></ol><p id="8ca0" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated">read()函数很慢，不可预测，是并行化的好选择；compute()函数速度很快，但无法并行化。按顺序调用它们会降低整个管道的速度。您可以交错这些函数，以使管道速度更快，但您必须确保以正确的顺序调用它们。</p><ul class=""><li id="8b1c" class="lc ld hh kc b kd kx kg ky kj le kn lf kr lg kv md li lj lk bi translated">在许多情况下，您可以使用Python中的异步处理来模拟并行处理，只需修改一些语法，而不是进行真正的并行处理，后者通常更难。</li><li id="d6a3" class="lc ld hh kc b kd ll kg lm kj ln kn lo kr lp kv md li lj lk bi translated">但它不是多线程的。您可以控制哪些部分是异步的，哪些不是。</li><li id="5e59" class="lc ld hh kc b kd ll kg lm kj ln kn lo kr lp kv md li lj lk bi translated">两个关键字的组合使之成为可能。async应用于函数定义，告诉Python该函数是一个异步调用。await告诉命令立即将控制传递回调用者，但继续处理其余的语句。</li><li id="1f19" class="lc ld hh kc b kd ll kg lm kj ln kn lo kr lp kv md li lj lk bi translated">注意函数调用内部的逻辑对于同步和异步事件的行为。如果没有在正确的位置访问或更新，变量可能会有错误的值。</li></ul><h1 id="ebd6" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">后续步骤</h1><p id="5cf2" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">关于异步处理的更多信息，请阅读官方Python文档:【https://docs.python.org/3/library/asyncio.html T4】</p></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><p id="1fbb" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated"><em class="kw">gstudioimagen创建的业务向量—</em><a class="ae me" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank"><em class="kw">【www.freepik.com】</em></a></p><p id="4b14" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated"><em class="kw">原载于</em><a class="ae me" href="https://www.capitalone.com/tech/software-engineering/async-processing-in-python-for-faster-data-pipelines/" rel="noopener ugc nofollow" target="_blank"><em class="kw">https://www.capitalone.com</em></a><em class="kw">。</em></p><p id="5f74" class="pw-post-body-paragraph ka kb hh kc b kd kx ii kf kg ky il ki kj kz kl km kn la kp kq kr lb kt ku kv ha bi translated"><em class="kw">披露声明:2021资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>