<html>
<head>
<title>Graphs and Machine Learning for Cybersecurity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网络安全中的图形和机器学习</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/graphs-and-machine-learning-for-cybersecurity-7115b9b544b5?source=collection_archive---------1-----------------------#2021-07-08">https://medium.com/oracledevs/graphs-and-machine-learning-for-cybersecurity-7115b9b544b5?source=collection_archive---------1-----------------------#2021-07-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/087781993428b8c5ef4ce58d0dca63cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jx9XiRmgQaetnw5qQzaTaw.jpeg"/></div></div></figure><p id="5295" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> OPG4Py </strong>是Graph Server的Python客户端，是Oracle数据库的属性图特性的一个组件。<strong class="ir hi"> OML4Py </strong>是<a class="ae jn" href="https://www.oracle.com/database/technologies/datawarehouse-bigdata/machine-learning.html" rel="noopener ugc nofollow" target="_blank"> OML </a> (Oracle机器学习)的Python接口，这是Oracle数据库的另一个特性，可以实现可扩展的机器学习。OML的关键优势在于，所有的机器学习功能都可以在数据库中的数据上运行。这提供了几个优点，从可伸缩性(数据库可以存储大量数据)、性能改进(因为您的数据不需要不断地从数据库中取出并推回)到安全性(您的数据不需要离开数据库的受保护环境)。</p><p id="9a54" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">OPG4Py和OML4Py相互补充，使用户能够开发快速、可伸缩和安全的图形机器学习应用程序。在本帖中，我们将通过入侵检测的例子来演示这一点。</p><p id="70d2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">(原文可以在这里找到<a class="ae jn" href="https://blogs.oracle.com/ai-and-datascience/post/graph-machine-learning-with-pypgx-and-oml4py" rel="noopener ugc nofollow" target="_blank"/>，由甲骨文实验室研究经理Rhicheek Patra编辑。这里的内容是为2021年7月8日的<a class="ae jn" href="https://analyticsanddatasummit.org/techcasts/" rel="noopener ugc nofollow" target="_blank"> TechCasts </a>活动更新的。)</p><p id="4bb8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">入侵检测</strong></p><p id="dbdd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">入侵检测是一个宽泛的术语，用于监控各种系统和公共/私有网络流量。对于我们的用例，我们将入侵检测定义为监控公共网络(例如万维网)流量和检测恶意活动的问题。在我们的例子中，网络流量是所谓的<strong class="ir hi">数据包捕获</strong>，它是IP地址与其他IP地址交互的日志。下表是此类数据包捕获的一个示例:</p><figure class="jp jq jr js fd ii er es paragraph-image"><div class="er es jo"><img src="../Images/4c0dcee0b286a6d677e6c6347f3f3450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/1*9rV5WWjJI1Hf-BTAbiIFQg.png"/></div></figure><p id="9e59" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">前面的表格可以看作是一个图的边列表表示。结果图可能看起来像这样:通过将IP地址视为顶点，并将两个IP地址<strong class="ir hi"> A </strong>和<strong class="ir hi"> B </strong>之间的交互视为两个顶点<strong class="ir hi"> A </strong>和<strong class="ir hi"> B </strong>之间的边，这些数据包捕获自然可以表示为图。</p><figure class="jp jq jr js fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jt"><img src="../Images/8536cfb3e9b0c39316b99f760d66351e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HFiTFiRlpRBz0FgtCu0-8w.png"/></div></div></figure><p id="70c7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此图显示了一个恶意数据包捕获的示例。</p><p id="1ef3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">受害者在网络搜索引擎上搜索一些东西。然后，他点击其中一个属于IP地址<strong class="ir hi"> A </strong>的结果，不幸的是，这个地址已经被泄露。<strong class="ir hi"> A </strong>然后通过几个链接将受害者重定向到IP地址<strong class="ir hi"> B </strong>，让受害者下载一个漏洞。该漏洞试图获得受害者主机的管理员权限，并在成功后向其主人<strong class="ir hi"> C </strong>报告成功渗透。然后<strong class="ir hi"> C </strong>将受害者重定向到服务器<strong class="ir hi"> D </strong>下载进一步的恶意软件(例如，勒索软件将加密您的计算机并要求为其解密付费)。</p><p id="2cf0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于数据包捕获和整个入侵检测问题的更详细的解释，我想让感兴趣的读者看一下这个关于DynaMiner和恶意软件检测的报告。</p><p id="4a1c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">使用OPG4Py和OML4Py解决问题</strong></p><p id="e26f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于我们的例子，我们有许多不同的数据包捕获，我们的目标是训练一个分类器，可以区分恶意数据包捕获和良性数据包捕获。</p><figure class="jp jq jr js fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ju"><img src="../Images/4fea92f44f47fd876ef15647617f2fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMYB8RHcI_H-TtQqH9sW0w.png"/></div></div></figure><p id="1883" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将分三个主要阶段解决这个问题:</p><ol class=""><li id="699a" class="jv jw hh ir b is it iw ix ja jx je jy ji jz jm ka kb kc kd bi translated"><strong class="ir hi">图形创建:</strong>在此阶段，我们将以表格格式将原始数据包捕获数据加载到数据库中。使用PGQL语法，从表中的数据创建图形，并将它们加载到Graph Server中。</li><li id="79a5" class="jv jw hh ir b is ke iw kf ja kg je kh ji ki jm ka kb kc kd bi translated"><strong class="ir hi">特征生成:</strong>第二阶段，使用OPG4Py提供的丰富的图形算法库对图形进行广泛的分析。这些分析的结果最初保存在图表中，然后使用PGQL查询存储到数据库表中。</li><li id="edf0" class="jv jw hh ir b is ke iw kf ja kg je kh ji ki jm ka kb kc kd bi translated"><strong class="ir hi">分类:</strong>在第三阶段，我们使用我们创建的特征表来训练各种不同的分类器，以便达到尽可能高的预测精度。为此，我们还将使用OML的AutoML功能。</li></ol><figure class="jp jq jr js fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kj"><img src="../Images/3e98304248966cb24a639b5068373c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cuoYS_Xg9RMH0dW2rmbzMw.png"/></div></div></figure></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><p id="cbc8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">使用OPG4Py </strong>生成基于图形的特征</p><p id="755f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了使用OPG4Py功能，我们首先需要导入<code class="du kr ks kt ku b">pypgx</code>包，并使用数据库用户名和密码登录到Graph Server。</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="86d0" class="kz la hh ku b fi lb lc l ld le">import pypgx.pg.rdbms.graph_server as graph_server</span><span id="d8c3" class="kz la hh ku b fi lf lc l ld le">base_url = "<a class="ae jn" href="https://localhost:7007" rel="noopener ugc nofollow" target="_blank">https://&lt;host_name&gt;:7007</a>"<br/>username = "graphuser"<br/>password = "&lt;password&gt;"</span><span id="1030" class="kz la hh ku b fi lf lc l ld le">instance = graph_server.get_instance(base_url, username, password)<br/>session = instance.create_session("jupyter")<br/>analyst = session.create_analyst()</span></pre><p id="9f9b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">准备源数据集</strong></p><p id="ca7b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们有两个数据集。一个数据集用于恶意数据包捕获的图形数据，一个数据集用于良性数据包捕获的图形数据。对于这些图中的每一个，我们准备以下两个表，一个用于顶点，另一个用于边。</p><p id="8586" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b">BENIGN_VERTICES</code>表:</p><figure class="jp jq jr js fd ii er es paragraph-image"><div class="er es lg"><img src="../Images/e8a1352846ef444551722087b6efe577.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*W7KtQ1gQ6fDgngrvgtpmgA.png"/></div></figure><p id="a0a6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b">BENIGN_EDGES</code>表:</p><figure class="jp jq jr js fd ii er es paragraph-image"><div class="er es lh"><img src="../Images/a901b0e8b2021248e3e3cebd82129dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*eVfGmlnyhtOVi1ezJcdT1A.png"/></div></figure><p id="1226" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">恶意软件图的对应表(<code class="du kr ks kt ku b">MALWARE_VERTICES</code>表和<code class="du kr ks kt ku b">MALWARE_EDGES</code>表)具有完全相同的模式。</p><p id="f9d2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">将数据集加载到图形中充当图形</strong></p><p id="0a90" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这一步中，我们将使用数据库中的数据集在图形服务器中创建图形。为此，我们首先需要为我们的两个图中的每一个都有一个<code class="du kr ks kt ku b">CREATE PROPERTY GRAPH</code>语句。该语句告诉图形服务器表和图形之间的映射。</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="aef0" class="kz la hh ku b fi lb lc l ld le">statement = '''</span><span id="b720" class="kz la hh ku b fi lf lc l ld le">CREATE PROPERTY GRAPH graphlets_b<br/>  VERTEX TABLES (<br/>    BENIGN_VERTICES AS ip_address<br/>      LABEL ip_address<br/>      PROPERTIES (V_LABEL, TYPE, GRAPH_ID)<br/>  )<br/>  EDGE TABLES (<br/>    BENIGN_EDGES_v<br/>      KEY (e_id)<br/>      SOURCE KEY(src_id) REFERENCES ip_address<br/>      DESTINATION KEY(dst_id) REFERENCES ip_address<br/>      LABEL send<br/>      PROPERTIES (SRC_ID, DST_ID, SRC_TYPE, DST_TYPE)<br/>  )</span><span id="a226" class="kz la hh ku b fi lf lc l ld le">'''</span></pre><p id="0364" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦执行了这条语句，就在内存中创建了图形。</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="1f6e" class="kz la hh ku b fi lb lc l ld le">session.prepare_pgql(statement).execute()</span></pre><p id="0670" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">附加图形并获得一个代理对象。</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="b694" class="kz la hh ku b fi lb lc l ld le">graphlets_b = session.get_graph("GRAPHLETS_B")</span></pre><p id="7687" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">下一步:使用特色表</strong></p><p id="5a7b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们回顾一下我们到目前为止所做的工作。</p><p id="23f3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，我们确认原始数据包捕获数据在数据库表中。然后我们创建了两个分区图:<code class="du kr ks kt ku b">GRAPHLETS_B</code>和<code class="du kr ks kt ku b">GRAPHLETS_M</code> <strong class="ir hi"> <em class="li">。这两个图都是由许多小的子图组成的。每个子图代表一个数据包捕获。</em></strong></p><p id="762a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一步，我们将分析每个小graphlets，并将它们的信息存储在一个大的特性表中。对于每个graphlet，我们将在特性表中存储一行。然后，我们将为每一行附加一个标签，说明该行包含的信息是恶意的还是良性的数据包捕获。</p><figure class="jp jq jr js fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/b0f5dfebce99afe0f4312c8dea70c7b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TD8hxGXEzMUc5V9vPzeNPw.png"/></div></div></figure><p id="2546" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以事不宜迟，让我们继续我们的旅程吧！</p><p id="1d72" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">创建graphlet特征</strong></p><p id="2386" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然我们已经在Graph Server中创建了两个图形，我们将使用各种图形算法来分析它们。我们稍后将使用结果信息来训练不同的分类器。对于每个图，我们将使用Graph Server提供的丰富的图算法集来分析它，以计算许多属性。</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="cf08" class="kz la hh ku b fi lb lc l ld le">def generate_graphlet_features(graphlet):<br/>    analyst.degree_centrality(graphlet)<br/>    analyst.local_clustering_coefficient(graphlet)<br/>    analyst.out_degree_centrality(graphlet)<br/>    analyst.in_degree_centrality(graphlet)<br/>    analyst.vertex_betweenness_centrality(graphlet)<br/>    analyst.pagerank(graphlet)</span><span id="7b09" class="kz la hh ku b fi lf lc l ld le">generate_graphlet_features(graphlets_b)<br/>generate_graphlet_features(graphlets_m)</span></pre><p id="5a96" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">准备分类数据</strong></p><p id="8f9e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请记住，到目前为止，我们每一步都做了两次:第一次是针对存储良性数据包捕获的图，第二次是针对存储恶意数据包捕获的图。现在，我们为每个功能列表添加了一个标签，表示该功能列表属于良性(<code class="du kr ks kt ku b">ml_label = 0</code>)还是恶意(<code class="du kr ks kt ku b">ml_label = 1</code>)数据包捕获。</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="0400" class="kz la hh ku b fi lb lc l ld le">rs = graphlets_b.query_pgql("""</span><span id="f194" class="kz la hh ku b fi lf lc l ld le">SELECT<br/>  v.graph_id<br/>, 0                  AS ml_label<br/>, COUNT(v)           AS cnt_vertex<br/>, SUM(v.degree) / 2  AS cnt_edge<br/>, AVG(v.degree)      AS avg_degree<br/>, AVG(v.lcc)         AS avg_lcc<br/>, AVG(v.out_degree)  AS avg_out_degree<br/>, AVG(v.in_degree)   AS avg_in_degree<br/>, AVG(v.betweenness) AS avg_betweenness<br/>, AVG(v.pagerank)    AS avg_pagerank<br/>, MAX(v.degree)      AS max_degree<br/>, MAX(v.lcc)         AS max_lcc<br/>, MAX(v.out_degree)  AS max_out_degree<br/>, MAX(v.in_degree)   AS max_in_degree<br/>, MAX(v.betweenness) AS max_betweenness<br/>, MAX(v.pagerank)    AS max_pagerank<br/>, MIN(v.degree)      AS min_degree<br/>, MIN(v.lcc)         AS min_lcc<br/>, MIN(v.out_degree)  AS min_out_degree<br/>, MIN(v.in_degree)   AS min_in_degree<br/>, MIN(v.betweenness) AS min_betweenness<br/>, MIN(v.pagerank)    AS min_pagerank<br/>FROM MATCH (v) ON GRAPHLETS_B<br/>GROUP BY v.graph_id<br/>ORDER BY v.graph_id ASC</span><span id="97bd" class="kz la hh ku b fi lf lc l ld le">""")</span></pre><p id="c942" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将查询结果存储到数据库表中。</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="1887" class="kz la hh ku b fi lb lc l ld le">rs.to_frame().write().db().table_name("FEATURES_BENIGN") \<br/>  .overwrite(True).owner("GRAPHUSER").store()</span></pre><p id="b029" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">相同的查询，但是针对具有<code class="du kr ks kt ku b">ml_label = 1</code>的恶意软件图。</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="cdfa" class="kz la hh ku b fi lb lc l ld le">rs = graphlets_m.query_pgql("""</span><span id="06c1" class="kz la hh ku b fi lf lc l ld le">SELECT<br/>  v.graph_id<br/>, 1                  AS ml_label<br/>, COUNT(v)           AS cnt_vertex<br/>, SUM(v.degree) / 2  AS cnt_edge<br/>, AVG(v.degree)      AS avg_degree<br/>, AVG(v.lcc)         AS avg_lcc<br/>, AVG(v.out_degree)  AS avg_out_degree<br/>, AVG(v.in_degree)   AS avg_in_degree<br/>, AVG(v.betweenness) AS avg_betweenness<br/>, AVG(v.pagerank)    AS avg_pagerank<br/>, MAX(v.degree)      AS max_degree<br/>, MAX(v.lcc)         AS max_lcc<br/>, MAX(v.out_degree)  AS max_out_degree<br/>, MAX(v.in_degree)   AS max_in_degree<br/>, MAX(v.betweenness) AS max_betweenness<br/>, MAX(v.pagerank)    AS max_pagerank<br/>, MIN(v.degree)      AS min_degree<br/>, MIN(v.lcc)         AS min_lcc<br/>, MIN(v.out_degree)  AS min_out_degree<br/>, MIN(v.in_degree)   AS min_in_degree<br/>, MIN(v.betweenness) AS min_betweenness<br/>, MIN(v.pagerank)    AS min_pagerank<br/>FROM MATCH (v) ON GRAPHLETS_M<br/>GROUP BY v.graph_id<br/>ORDER BY v.graph_id ASC</span><span id="9920" class="kz la hh ku b fi lf lc l ld le">""")</span></pre><p id="5ee6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将查询结果存储到数据库表中。</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="3723" class="kz la hh ku b fi lb lc l ld le">rs.to_frame().write().db().table_name("FEATURES_MALWARE") \<br/>  .overwrite(True).owner("GRAPHUSER").store()</span></pre><p id="7bf2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，用于训练的基于图形的特征被准备并存储在数据库中。</p></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><p id="a622" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可视化小图</p><p id="2887" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用图形可视化UI，我们可以直观地检查graphlets:涉及多少顶点和边，它们是如何连接的，等等。这种拓扑信息的一部分应该由前一步骤中的图形算法来量化。</p><p id="b1a3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面的PGQL查询用于检索特定graphlet中的所有顶点对和连接边，其中它的<code class="du kr ks kt ku b">GRAPH_ID</code>是1。</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="d4c1" class="kz la hh ku b fi lb lc l ld le">SELECT *<br/>FROM MATCH (v1)-[e]-&gt;(v2)<br/>WHERE v1.graph_id = 1 AND v2.graph_id = 1</span></pre><p id="ba9b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个顶点保存新的属性，如<code class="du kr ks kt ku b">pagerank</code>或<code class="du kr ks kt ku b">betweeeness</code>。在下面的屏幕中，顶点的大小代表了PageRank分数。</p><figure class="jp jq jr js fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/087781993428b8c5ef4ce58d0dca63cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jx9XiRmgQaetnw5qQzaTaw.jpeg"/></div></div></figure></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><p id="d005" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">用OML分类器训练数据</strong></p><p id="874d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请记住，到目前为止，我们每一步都做了两次:第一次是针对存储良性数据包捕获的图，第二次是针对存储恶意数据包捕获的图。我们最终可以将两个特性列表合并到一个表中:</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="3672" class="kz la hh ku b fi lb lc l ld le">import oml</span><span id="b62b" class="kz la hh ku b fi lf lc l ld le">features_oml = oml.sync(query='''</span><span id="5281" class="kz la hh ku b fi lf lc l ld le">SELECT * FROM FEATURES_BENIGN<br/>UNION<br/>SELECT * FROM FEATURES_MALWARE</span><span id="88ec" class="kz la hh ku b fi lf lc l ld le">''')</span></pre><p id="4b96" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在创建了最终表，我们将使用它来训练我们的分类器。为了在这些数据上训练和测试分类器，我们应该将数据分成训练集和测试集。请注意，这样做不需要从数据库中获取数据。OML为此提供了<code class="du kr ks kt ku b">split()</code>函数，它将两个代理对象返回给数据的两个部分:</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="37cd" class="kz la hh ku b fi lb lc l ld le"># Split the data for training and test<br/>train_oml, test_oml = features_oml.split(ratio=(.8, .2), seed=0)</span><span id="22a1" class="kz la hh ku b fi lf lc l ld le"># training data<br/>train_x_oml = train_oml.drop('ml_label')<br/>train_y_oml = train_oml['ml_label']</span><span id="7857" class="kz la hh ku b fi lf lc l ld le"># test data<br/>test_x_oml = test_oml.drop('ml_label')<br/>test_y_oml = test_oml['ml_label']</span></pre><p id="9ba0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">先用OML分类</strong></p><p id="707b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在为分类准备好我们的数据之后，是时候开始训练我们的分类器了！</p><p id="9da8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">先说一个神经网络。OML4Py让你通过<code class="du kr ks kt ku b">oml.nn()</code>构造器创建一个神经网络。为了个性化您的神经网络，您可以向该构造函数提供一大组参数。在下面的代码中，我们用不同数量的节点和不同的激活函数创建了四层。</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="8dde" class="kz la hh ku b fi lb lc l ld le">params = {</span><span id="99a4" class="kz la hh ku b fi lf lc l ld le"># The architecture of the neural network<br/>'nnet_hidden_layers' : 4,<br/>'nnet_nodes_per_layer' : '50, 30, 50, 30',</span><span id="326e" class="kz la hh ku b fi lf lc l ld le"># The differnt activation functions in each layer<br/>'nnet_activations' : "'NNET_ACTIVATIONS_LINEAR', 'NNET_ACTIVATIONS_LINEAR', 'NNET_ACTIVATIONS_LINEAR', 'NNET_ACTIVATIONS_LINEAR'",</span><span id="6c1b" class="kz la hh ku b fi lf lc l ld le"># Info about the number of rounds to use for fitting<br/>'nnet_iterations' : 500,<br/>'nnet_heldaside_max_fail' : 100,</span><span id="e014" class="kz la hh ku b fi lf lc l ld le"># A seed for reproducibility<br/>'odms_random_seed' : 1</span><span id="5c60" class="kz la hh ku b fi lf lc l ld le">}<br/>nn_mod = oml.nn(**params)</span></pre><p id="20ae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">训练和评分神经网络也很容易。OML4Py提供了两个函数，<code class="du kr ks kt ku b">fit()</code>和<code class="du kr ks kt ku b">score()</code> <strong class="ir hi"> <em class="li">，</em> </strong>，每个函数都以OML代理对象为参数。这些代理对象告诉函数应该对哪些数据应用训练和测试。</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="fb4c" class="kz la hh ku b fi lb lc l ld le"># Fit the NN model according to the training data and parameters<br/>nn_mod = nn_mod.fit(train_x_oml, train_y_oml)</span><span id="57ee" class="kz la hh ku b fi lf lc l ld le"># Score the model<br/>nn_mod.score(test_x_oml, test_y_oml)</span><span id="7210" class="kz la hh ku b fi lf lc l ld le">0.985251</span></pre><p id="3e88" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的数据上训练这个模型，然后对它进行评分，得到98.5%的准确率。但是，我们能做得更好吗？</p><p id="0b80" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">AutoML:让oML替你做这件事</p><p id="90f4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">OML提供了大量不同的分类器，从线性分类器上的神经网络到朴素贝叶斯分类器。然而，尝试所有这些不同的分类器来找出哪一个提供最好的结果是很麻烦的，特别是因为每个单独的分类器都有大量可以调整的超参数。但是，OML有一个解决方案:AutoML。<a class="ae jn" href="https://blogs.oracle.com/datascience/how-does-automl-impact-machine-learning" rel="noopener ugc nofollow" target="_blank"> AutoML </a>模型提供了多种功能，您可以使用这些功能让oML为您找到最佳模型/功能/超参数。</p><p id="c9ab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们将自动算法选择应用于我们的数据，以找出哪个模型为我们的数据产生最佳结果:</p><pre class="jp jq jr js fd kv ku kw kx aw ky bi"><span id="9334" class="kz la hh ku b fi lb lc l ld le">alg_selection = oml.automl.AlgorithmSelection(<br/>    mining_function = 'classification',<br/>    score_metric = 'accuracy',<br/>    parallel = 1<br/>)</span><span id="09d8" class="kz la hh ku b fi lf lc l ld le">algo_ranking = alg_selection.select(<br/>    train_x_oml, train_y_oml,<br/>    cv = None, X_valid = test_x_oml, y_valid = test_y_oml, k = 3<br/>)</span><span id="0922" class="kz la hh ku b fi lf lc l ld le">print("The best models are: " + str(algo_ranking))</span><span id="4442" class="kz la hh ku b fi lf lc l ld le">The best models are: [('nb', 0.9970501474926253), ('svm_gaussian', 0.9970501474926253), ('glm_ridge', 0.9941002949852508)]</span></pre><p id="91e6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行上面的代码给我们以下排名:</p><ol class=""><li id="d67f" class="jv jw hh ir b is it iw ix ja jx je jy ji jz jm ka kb kc kd bi translated">朴素贝叶斯(准确率:~99.7%)</li><li id="9c50" class="jv jw hh ir b is ke iw kf ja kg je kh ji ki jm ka kb kc kd bi translated">支持向量机(准确率:~99.7%)</li><li id="f983" class="jv jw hh ir b is ke iw kf ja kg je kh ji ki jm ka kb kc kd bi translated">通用线性化模型(精度:~99.4%)</li></ol></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><p id="7e0d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">图机器学习功能</strong></p><p id="1f96" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇博客文章中，我们讨论了基于图形的功能如何促进标准的机器学习。然而，OPG4Py提供了更复杂的图形机器学习功能，如顶点表示(DeepWalk，图形卷积网络)和子图表示(PG2Vec)。我们将在以后的博客文章中讨论更多。</p></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><p id="93d5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您想分享您的反馈或向社区提问，请点击<a class="ae jn" href="https://join.slack.com/t/andouc/shared_invite/zt-mfbk0un9-E7mgQweUfBnJ6BfRgcTeMQ" rel="noopener ugc nofollow" target="_blank">此处</a>加入AnDOUC(分析和数据Oracle用户社区)Slack workspace，并在<a class="ae jn" href="https://andouc.slack.com/archives/C01BMHU02JX" rel="noopener ugc nofollow" target="_blank"> #graph </a>频道发表您的评论。</p></div></div>    
</body>
</html>