<html>
<head>
<title>Play it your way: POC on GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按您的方式玩:GraphQL上的POC</h1>
<blockquote>原文：<a href="https://medium.com/globant/play-it-your-way-poc-on-graphql-590d2f0e830e?source=collection_archive---------0-----------------------#2021-01-08">https://medium.com/globant/play-it-your-way-poc-on-graphql-590d2f0e830e?source=collection_archive---------0-----------------------#2021-01-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="ba27" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">graph QL+Express+PostgreSQL+MongoDB</h1><p id="ea81" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">GraphQL是API的一种查询语言，也是一种服务器端运行时，通过使用您为数据定义的类型系统来执行查询。GraphQL不依赖于任何特定的数据库或存储引擎，而是由您现有的代码和数据提供支持。</p><p id="c133" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">到目前为止，我们已经在文章<a class="ae kf" rel="noopener" href="/@sagar.barawade/introduction-overview-of-graphql-56ac0285077b"> <strong class="je hi">简介:GraphQL概述</strong> </a>中看到了什么是GraphQL，在文章<a class="ae kf" rel="noopener" href="/@kaustubh.vyas/graphql-the-query-language-3d1b1807a1d1"> <strong class="je hi"> GraphQL:查询语言</strong> </a>中看到了如何使用GraphQL查询语言从GraphQL运行时使用GraphQL用户界面查询数据。</p><p id="ee4e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在本次会议中，我们将使用<strong class="je hi">GraphQL+Express+PostgreSQL+MongoDB</strong>来设置graph QL运行时</p><p id="4eb5" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">为了使用两个不同的数据库连接(即PostgreSQL和MongoDB)建立一个GraphQL服务器，我们将使用Express framework创建一个NodeJs服务器。</p><p id="fce8" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">让我们从安装依赖项开始。</p><h2 id="2028" class="kg if hh bd ig kh ki kj ik kk kl km io jn kn ko is jr kp kq iw jv kr ks ja kt bi translated">安装依赖项:</h2><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="c21e" class="kg if hh kz b fi ld le l lf lg">npm install express express-graphql graphql mongodb pg</span></pre><p id="c173" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi"> express: </strong> NodeJs框架</p><p id="3c59" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi"> express-graphql: </strong>用于与express集成的graphql模块</p><p id="ea53" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">图表语言库</strong></p><p id="4db0" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi"> mongodb: </strong> MongoDB节点模块</p><p id="ea3d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi"> pg: </strong> PostgreSQL节点模块</p></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><h2 id="23f3" class="kg if hh bd ig kh ki kj ik kk kl km io jn kn ko is jr kp kq iw jv kr ks ja kt bi translated">设置GraphQL-Express服务器</h2><p id="b927" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们只需要基本的Express服务器设置:</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="2d50" class="kg if hh kz b fi ld le l lf lg">// ./index.js<br/>const app = require('express')();<br/><strong class="kz hi"><em class="lo">const Schema = require('./schema');<br/></em></strong>const graphqlHTTP = require('express-graphql');<br/>const PORT = process.env.PORT || 3000;</span><span id="30fc" class="kg if hh kz b fi lp le l lf lg">app.use('/graphql', graphqlHTTP({ schema: <strong class="kz hi"><em class="lo">Schema</em></strong>, graphiql: true}));</span><span id="be19" class="kg if hh kz b fi lp le l lf lg">app.listen(PORT, () =&gt; {<br/>     console.log(`Server is listening on port ${PORT}`);<br/>});</span></pre><p id="2681" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">您可能对这里的模式感到疑惑，让我们看看接下来是什么。</p><h2 id="e6ff" class="kg if hh bd ig kh ki kj ik kk kl km io jn kn ko is jr kp kq iw jv kr ks ja kt bi translated">GraphQL模式</h2><p id="46c0" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">GraphQL中基本上有两种类型的API</p><ul class=""><li id="c4f0" class="lq lr hh je b jf ka jj kb jn ls jr lt jv lu jz lv lw lx ly bi translated"><strong class="je hi">查询:</strong>这些是数据获取API。</li><li id="12d1" class="lq lr hh je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly bi translated"><strong class="je hi">突变:</strong>这些是会有副作用的，即修改数据。</li></ul><p id="9326" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">定义和区分这两个API的GraphQL对象是<code class="du me mf mg kz b">GraphQLSchema</code></p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="5750" class="kg if hh kz b fi ld le l lf lg">// ./schema/index.js<br/>const { GraphQLSchema } = require('graphql');<br/>const RootQueryType = require('./rootquerytype');<br/>const RootMutationType= require('./rootmutationtype');</span><span id="a414" class="kg if hh kz b fi lp le l lf lg">module.exports = new GraphQLSchema({<br/> query: RootQueryType,<br/> mutation: RootMutationType<br/>});</span></pre><p id="00dc" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">为了定义<code class="du me mf mg kz b">query</code>和<code class="du me mf mg kz b">mutation</code>API，GraphQL提供了一个助手类<code class="du me mf mg kz b">GraphQLObjectType</code></p><h2 id="b5fa" class="kg if hh bd ig kh ki kj ik kk kl km io jn kn ko is jr kp kq iw jv kr ks ja kt bi translated">GraphQLObjectType</h2><p id="a0fe" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><code class="du me mf mg kz b">GraphQLObjectType</code>详细描述了<code class="du me mf mg kz b">query</code>和<code class="du me mf mg kz b">mutation</code> API的定义。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="3de4" class="kg if hh kz b fi ld le l lf lg">new GraphQLObjectType({<br/>  name: 'TypeName',<br/>  description: 'Type Description',<br/>  fields: {<br/>    hello: {<br/>      type: GraphQLString,<br/>      description: 'API description',<br/>      resolve: () =&gt; 'world'<br/>    }<br/>  }<br/>});</span></pre><p id="9562" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><code class="du me mf mg kz b">name</code>、<code class="du me mf mg kz b">description</code>在GraphiQL接口中公开文档细节，<code class="du me mf mg kz b">fields</code>键保存所有的<code class="du me mf mg kz b">query</code>或<code class="du me mf mg kz b">mutation</code> API路径键。这反过来定义了解析器函数，该函数将有代码返回数据库中的数据<code class="du me mf mg kz b">query</code>或<code class="du me mf mg kz b">mutate</code>。<code class="du me mf mg kz b">type</code>定义了API的返回类型。</p><p id="7629" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在我们编写查询或变异查询之前，让我们创建数据库连接。</p></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><h2 id="0060" class="kg if hh bd ig kh ki kj ik kk kl km io jn kn ko is jr kp kq iw jv kr ks ja kt bi translated">数据库连接</h2><p id="d7e2" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们将演示一个具有多个数据库连接的GraphQL服务器。PostgreSQL和MongoDB。</p><p id="e9b9" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这里，我们将使用PostgreSQL来存储用户数据，使用MongoDB来包含用户计数。</p><p id="d2be" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在PostgreSQL中的数据库和表上创建。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="7bdf" class="kg if hh kz b fi ld le l lf lg">create database graphql_test;<br/># connect to the graphql_test database</span><span id="fca8" class="kg if hh kz b fi lp le l lf lg">create table users(<br/>	id integer generated by default as identity,<br/>	first_name character varying<br/>);<br/>insert into users(first_name) values('test_user_1'); #dummy data</span></pre><p id="013d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">MongoDB将动态创建数据库。</p><p id="4139" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">让我们更新GraphQL-Express来创建和使用PostgreSQL和MongoDB连接。</p><p id="5586" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这里我们考虑两个数据库都运行在您的机器上和它们各自的默认端口上。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="13eb" class="kg if hh kz b fi ld le l lf lg">// ./index.js<br/>const app = require('express')();<br/>const pg = require('pg');<br/>const { MongoClient } = require('mongodb');<br/>const Schema = require('./schema');<br/>const graphqlHTTP = require('express-graphql');<br/>const PORT = process.env.PORT || 3000;</span><span id="8eb9" class="kg if hh kz b fi lp le l lf lg">const pgPool = new pg.Pool({<br/>  user: 'postgres',    <br/>  host: 'localhost',    <br/>  database: 'graphql_test',    <br/>  password: 'xxxxx'<br/>});</span><span id="bfd2" class="kg if hh kz b fi lp le l lf lg">MongoClient.connect('<!-- -->mongodb://localhost:27017/graphqltest<!-- -->', <br/>  (err, mongoClient) =&gt; {<br/>     app.use('/graphql', graphqlHTTP({ <br/>       schema: Schema, <br/>       graphiql: true,<br/>       context: { <br/>         pgPool : pgPool, <br/>	 mongo : mongoClient.db("graphql-training") <br/>       }<br/>     })<br/>  );<br/>  app.listen(PORT, () =&gt; {<br/>    console.log(`Server is listening on port ${PORT}`);<br/>  });<br/>});</span></pre><p id="44be" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们已经将数据库连接传递给了<code class="du me mf mg kz b">context</code>选项，它提供了一种在整个应用程序解析器函数中共享对象的方法。现在，在查询和变异API解析函数中，我们将使用这些连接。</p></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><h2 id="873e" class="kg if hh bd ig kh ki kj ik kk kl km io jn kn ko is jr kp kq iw jv kr ks ja kt bi translated">GraphQL查询API</h2><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="d36d" class="kg if hh kz b fi ld le l lf lg">// ./schema/rootquerytype.js<br/>const { GraphQLString, GraphQLInt, GraphQLList, GraphQLObjectType } = require('graphql');</span><span id="165f" class="kg if hh kz b fi lp le l lf lg">const RootQueryType = new GraphQLObjectType({<br/>  name: 'RootQueryType',<br/>  description: 'This holds all the query APIs',<br/>  fields: {<br/>    users: {<br/>      type: new GraphQLList(UserType),<br/>      description: 'Handler for get users list',<br/>      resolve: async ( obj, args, context) =&gt; {						<br/>        const { pgPool } = context;<br/>	pgPool.query(`select * from users`, [])<br/>          .then(res =&gt; res.rows);<br/>      }<br/>    },<br/>    usersCount: {			<br/>      type: GraphQLInt,<br/>      description: 'Handler for get usersCount',<br/>      resolve: async ( obj, args, context) =&gt; {						<br/>	const { mongo } = context;<br/>	return mongo.collection('metrics').findOne({key : <br/>        'userCount'}).then(res =&gt; res.value);<br/>      }<br/>    }<br/>  }<br/>});<br/>module.exports = RootQueryType;</span><span id="9dad" class="kg if hh kz b fi lp le l lf lg">// ./schema/types/UserType.js</span><span id="652f" class="kg if hh kz b fi lp le l lf lg">const UserType = new GraphQLObjectType({<br/>  name: 'UserType',<br/>  description: 'User object type',<br/>  fields:{<br/>    id: { <br/>      type : GraphQLInt,<br/>      resolve: (obj)=&gt; obj.id	<br/>    },<br/>    firstName:{<br/>      type: GraphQLString,<br/>      resolve: (obj)=&gt; obj.first_name<br/>    }<br/>  }<br/>})</span><span id="32b6" class="kg if hh kz b fi lp le l lf lg">module.exports = UserType;</span></pre><p id="7cf7" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">解析函数接受三个参数:</p><ul class=""><li id="4cfc" class="lq lr hh je b jf ka jj kb jn ls jr lt jv lu jz lv lw lx ly bi translated"><strong class="je hi">对象:</strong>基本对象引用。</li><li id="81ab" class="lq lr hh je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly bi translated"><strong class="je hi">参数:</strong>为查询路径传递的参数。</li><li id="d1e6" class="lq lr hh je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly bi translated"><strong class="je hi">上下文:</strong>保存数据库连接对象的index.js文件传递下来的上下文对象。</li></ul><p id="ef29" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><code class="du me mf mg kz b">RootQueryType</code>中的<code class="du me mf mg kz b">users</code>字段保存带有关键字的对象:</p><ul class=""><li id="fefc" class="lq lr hh je b jf ka jj kb jn ls jr lt jv lu jz lv lw lx ly bi translated"><strong class="je hi">类型:</strong>解析器函数的返回类型。</li><li id="63ad" class="lq lr hh je b jf lz jj ma jn mb jr mc jv md jz lv lw lx ly bi translated"><strong class="je hi">解析:</strong>获取用户列表的解析函数。</li></ul></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><h2 id="9784" class="kg if hh bd ig kh ki kj ik kk kl km io jn kn ko is jr kp kq iw jv kr ks ja kt bi translated">GraphQL突变API</h2><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="360b" class="kg if hh kz b fi ld le l lf lg">// ./schema/rootmutaiontype.js<br/>const { GraphQLString, GraphQLObjectType } = require('graphql');</span><span id="8cf3" class="kg if hh kz b fi lp le l lf lg">const RootMutationType = new GraphQLObjectType({<br/>  name: 'RootMutationType',<br/>  description: 'this holds all the mutation APIs',<br/>  fields: {<br/>    user: {<br/>      type: UserType,<br/>      args: { input:{type : UserArg}},			<br/>      description: 'Handler for create user',<br/>      resolve: async ( obj, {input}, context) =&gt; {						<br/>	const { pgPool, mongo } = context;<br/>	const user= await pgPool.query(`insert into users(fist_name) <br/>          values($1) returning *`,[input.firstname])<br/>        await mongo.collection('metrics')<br/>          .update({ key : 'userCount' },{ $inc: { value: 1 }},{    <br/>           upsert: 1 });<br/>        return user <br/>       }<br/>    }<br/>  }<br/>});<br/>module.exports = RootMutationType;</span><span id="e225" class="kg if hh kz b fi lp le l lf lg">//./schema/types/UserArg.js</span><span id="e6d3" class="kg if hh kz b fi lp le l lf lg">const { GraphQLString, GraphQLInputObjectType } = require("graphql");</span><span id="1842" class="kg if hh kz b fi lp le l lf lg">let UserArg = new GraphQLInputObjectType({<br/>  name: 'UserArg',<br/>  fields:{<br/>    firstname: { type : GraphQLString } <br/>  } <br/>})<br/>module.exports = UserArg;</span></pre><p id="b803" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">与查询API一样，我们需要实现一个解析器函数来添加新用户和更新计数。</p><p id="449e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">为了接受输入参数，我们定义了类型为<code class="du me mf mg kz b">UserArg</code>的<code class="du me mf mg kz b">input</code>，它属于接受类型为<code class="du me mf mg kz b">GraphQLString</code>的<code class="du me mf mg kz b">firstname</code>的<code class="du me mf mg kz b">GraphQLInputObjectType</code>。</p></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><h1 id="2706" class="ie if hh bd ig ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb bi translated">结论</h1><p id="e318" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">就是这样！现在您知道了如何设置具有多个连接的GraphQL服务器并使用它。</p><p id="cec1" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">源代码</strong>:<a class="ae kf" href="https://github.com/rahulpawarglobant/graphql-training" rel="noopener ugc nofollow" target="_blank">https://github.com/rahulpawarglobant/graphql-training</a></p><figure class="ku kv kw kx fd mm"><div class="bz dy l di"><div class="mn mo l"/></div></figure></div></div>    
</body>
</html>