<html>
<head>
<title>The Ember Run Loop and Asynchronous Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ember运行循环和异步测试</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/the-ember-run-loop-and-asynchronous-testing-c03326181623?source=collection_archive---------1-----------------------#2017-09-12">https://medium.com/square-corner-blog/the-ember-run-loop-and-asynchronous-testing-c03326181623?source=collection_archive---------1-----------------------#2017-09-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="24e6" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">你不能逃离跑步圈</h2></div><blockquote class="iw ix iy"><p id="8d6f" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jw" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="6110" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">今年夏天，我在Square Seller Dashboard团队实习，该团队开发一个web应用程序，Square 的商家用它来做各种事情，从检查销售情况到管理他们的工资单，再到注册加入Square Capital 。在某种背景下，我是芝加哥大学一名即将毕业的学生，在今年夏天之前，我从未做过web应用程序。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ka"><img src="../Images/e7c17a6b3b433b05d3b1db28f3e695c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*naPjWMJyCbvArppXyKRB-A.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Image: A screenshot of the Square Seller Dashboard</figcaption></figure><p id="0b16" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">Dashboard是用<a class="ae jw" href="https://www.emberjs.com/" rel="noopener ugc nofollow" target="_blank"> Ember </a>构建的——一个用于单页面web应用程序的开源web框架。在专注于如此大型应用的团队中工作意味着我可以深入了解Ember——整个夏天我一直注意到的一件事是Ember处理异步工作的特殊、强大、有时令人困惑的方式。</p><h1 id="6f7e" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">我的项目</h1><p id="c16f" class="pw-post-body-paragraph iz ja hh jc b jd li ii jf jg lj il ji jx lk jl jm jy ll jp jq jz lm jt ju jv ha bi translated">我参与的一个项目是在商家因不活动而被注销之前显示警告。</p><p id="d6b7" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">这需要在应用程序的整个生命周期中监控不同的状态，并相应地呈现组件。我使用了Ember服务，它允许我根据每250毫秒执行一次的代码来设置应用程序的全局状态。去掉API调用和一些复杂的服务，代码看起来像这样:</p><pre class="kb kc kd ke fd ln lo lp lq aw lr bi"><span id="14b3" class="ls kr hh lo b fi lt lu l lv lw">import Ember from 'ember';</span><span id="5b5c" class="ls kr hh lo b fi lx lu l lv lw">export default Ember.Component.extend({<br/>  millisecondsElapsed: 0,</span><span id="7e05" class="ls kr hh lo b fi lx lu l lv lw">  didInsertElement(...args) {<br/>    this._super(...args);<br/>    this.set('initialTime', Date.now());<br/>    Ember.run.later(() =&gt; this.monitorTimeWithEmberRun(), 250);;<br/>  },<br/>  <br/>  monitorTimeWithEmberRun() {<br/>    const dateNow = Date.now();<br/>    // component renders the millisecondsElapsed<br/>    this.set('millisecondsElapsed', dateNow - <br/>                                   this.get('initialTime')) <br/>   Ember.run.later(() =&gt; this.monitorTimeWithEmberRun(), 250);<br/>  },<br/>});</span></pre><p id="ece4" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">在开发中，它工作得很好。但是当我运行验收测试时，它们会挂起，然后超时，抛出一堆不可预测的错误。通过运行本<a class="ae jw" href="https://ember-twiddle.com/70ad399096b0b3488637824a10a6435d?openFiles=tests.acceptance.my-acceptance-test.js%2C" rel="noopener ugc nofollow" target="_blank"> EmberTwiddle </a>中的测试，您可以看到这一点。</p><p id="87eb" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">即使这应该是项目的简单部分，我也无法完成一个验收测试，更不用说通过了。原来，我的测试失败的原因是因为我使用了<code class="du ly lz ma lo b">Ember.run.later,</code>的方式，它应该在给定的毫秒后运行回调函数。找到问题的解决方案揭示了Ember Run循环有多棒，以及它与异步测试的交互方式。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es mb"><img src="../Images/376c8b949bb78bd2d3ab1718b8ef11a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/1*uyj8pi4jW72-LKBq1AV_pA.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx">Gif: Actress Meryl Streep waving her hand, with the text “Whoa, whoa, whoa, whoa..” (<a class="ae jw" href="https://media.giphy.com/media/CURF5iPO5uY4U/giphy.gif" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><h1 id="0775" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">等等，退后。什么是余烬运行循环？</h1><p id="444e" class="pw-post-body-paragraph iz ja hh jc b jd li ii jf jg lj il ji jx lk jl jm jy ll jp jq jz lm jt ju jv ha bi translated">在Ember世界中工作几乎不可能不提到运行循环，尽管<a class="ae jw" href="https://guides.emberjs.com/v2.14.0/applications/run-loop/" rel="noopener ugc nofollow" target="_blank">文档表明</a>许多开发人员不会直接处理它</p><blockquote class="iw ix iy"><p id="a327" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">“在大多数Ember应用程序中，直接使用[Ember Run]API并不常见，”</p></blockquote><p id="8147" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">无论您是否直接使用Ember Run API，Run循环都是Ember应用程序的基础，并且通常是找出奇怪错误和意外副作用的核心。</p><p id="ff97" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">一般来说，运行循环有效地组织和调度与事件相关的工作。由用户事件(即<code class="du ly lz ma lo b">mouseDown</code>、<code class="du ly lz ma lo b">keyPress,</code>等)触发的工作通常是异步的。在所有的副作用执行之前，Ember可以做其他的工作。Ember Run循环调度这些副作用并组织任何异步工作。这听起来很棒，但需要更多的上下文。</p><p id="f2ad" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">有点用词不当，Ember run循环并不是真正的循环——也不一定只有一个。相反，一个运行“循环”有六个不同的队列来组织由事件触发的工作。所以，Run Loop(大写)更多的是一个概念，一个app会有多个Run Loop同时运行。</p><p id="c0e7" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated"><a class="ae jw" href="https://guides.emberjs.com/v2.14.0/applications/run-loop/" rel="noopener ugc nofollow" target="_blank">文档</a>列出了队列的优先顺序:</p><pre class="kb kc kd ke fd ln lo lp lq aw lr bi"><span id="17ff" class="ls kr hh lo b fi lt lu l lv lw">Ember.run.queues<br/>// =&gt; [“sync”, “actions”, “routerTransitions”, “render”, “afterRender”, “destroy”]</span></pre><p id="5023" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated"><a class="ae jw" href="https://guides.emberjs.com/v2.14.0/applications/run-loop/" rel="noopener ugc nofollow" target="_blank">文档</a>也给出了每个队列的简短说明</p><blockquote class="iw ix iy"><p id="5bd0" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="jc hi">同步队列</strong>包含绑定同步作业</p><p id="0f9a" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="jc hi">动作队列</strong>是通用工作队列，通常包含预定任务，如承诺</p><p id="1687" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="jc hi"> routerTransitions </strong> <strong class="jc hi">队列</strong>包含路由器中的转换作业</p><p id="fa5f" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="jc hi">渲染队列</strong>包含用于渲染的任务，这些任务通常会更新DOM</p><p id="b0a8" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="jc hi"> afterRender队列</strong>包含所有先前计划的渲染任务完成后要运行的作业。这对于第三方DOM操作库来说通常是好的，只有在更新了整个DOM树之后才能运行</p><p id="afaf" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">销毁队列包含完成其他作业计划销毁的对象的拆卸的作业</p></blockquote><p id="d772" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">我对作业调度“算法”的简短解释是，Run循环基于队列首先执行优先级最高的作业。这些作业可能会将工作添加到其他队列中，运行循环将返回到优先级最高的作业，直到所有作业都完成。</p><p id="fbb5" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">我真的很喜欢凯瑟琳·托恩沃尔对余烬运行循环的解释！它对每个队列都有精彩的深入解释，我使用了她的一些描述和例子来帮助说明这个运行循环。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es mc"><img src="../Images/98ea25647ab0624a7154bd3f77a03766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6iXQwX2UqynD3yDFH2uCwA.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Flowchart: The Ember Run Loop, Illustrated. <a class="ae jw" href="https://gist.githubusercontent.com/arieljackson/295a09a02678d2c8502f04fc57dfa9bc/raw/ffd704668f7037bbdd494461a4d2b8163017cffe/ember_run_loop_flowchart.txt" rel="noopener ugc nofollow" target="_blank">Link to plaintext version of chart.</a></figcaption></figure><p id="156f" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">每个队列的内部细节很有趣，但最重要的细节是事件触发了一个运行循环，并可能将各种异步工作放到不同的队列中。例如，<code class="du ly lz ma lo b">mouseDown</code>事件可以启动一个运行循环，与之相关的其他工作将被放在适当的队列中。Ember确保与数据同步相关的工作发生在任何渲染之前。如果数据同步发生在呈现之后，它可能会更改绑定到该数据的模板的呈现。那么，将需要更昂贵的重新渲染！</p><p id="0d32" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">对于交互式演示，查看Machty的<a class="ae jw" href="https://machty.s3.amazonaws.com/ember-run-loop-visual/index.html" rel="noopener ugc nofollow" target="_blank">运行循环可视化</a>或Ember文档中的<a class="ae jw" href="https://guides.emberjs.com/v2.14.0/applications/run-loop/#toc_an-example-of-the-internals" rel="noopener ugc nofollow" target="_blank">简单示例。</a></p><p id="038b" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated"><strong class="jc hi"> Ember.run.later </strong></p><p id="0025" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">我的服务利用运行循环的方式是<code class="du ly lz ma lo b">Ember.run.later</code>众多Ember.run API中的一个。</p><blockquote class="iw ix iy"><p id="873d" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="jc hi"> Ember.run.later() : </strong>在指定的时间段后调用传递的目标/方法和可选参数。此方法的最后一个参数必须始终是毫秒数。</p><p id="8795" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">每当您需要在一段时间后运行某个操作时，都应该使用此方法，而不是使用setTimeout()。这种方法将确保在同一个脚本执行周期中到期的项目都一起执行，这通常比使用真正的setTimeout更有效。</p></blockquote><p id="6719" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated"><code class="du ly lz ma lo b">Ember.run.later</code>确实比<code class="du ly lz ma lo b">setTimeout</code>或其他替代计时器有优势——它生活在“余烬世界”，所以它可以利用所有运行循环提供的优势(效率、组织)。<code class="du ly lz ma lo b">Ember.run.later </code>也尊重Ember内部的定时器队列(正常的javascript定时器就不能说<a class="ae jw" href="https://johnresig.com/blog/how-javascript-timers-work/" rel="noopener ugc nofollow" target="_blank">)。</a></p><p id="737c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">如果我们回头看看我的组件，我们会看到我在其中一个方法中递归地调用了<code class="du ly lz ma lo b">Ember.run.later</code>:</p><pre class="kb kc kd ke fd ln lo lp lq aw lr bi"><span id="9f17" class="ls kr hh lo b fi lt lu l lv lw">...<br/>monitorTimeWithEmberRun() {<br/>   const dateNow = Date.now();<br/>   // component renders the millisecondsElapsed<br/>   this.set('millisecondsElapsed', dateNow - <br/>                                   this.get('initialTime')) <br/>  Ember.run.later(() =&gt; this.monitorTimeWithEmberRun(), 250);<br/>  },<br/>...</span></pre><p id="e138" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">最终，正如我后来发现的，正是这些对<code class="du ly lz ma lo b">Ember.run.later </code>的递归调用导致了测试超时。</p><h1 id="d883" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">那为什么我的测试被搁置了？</h1><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es md"><img src="../Images/d5a365f791c5fc60e1316e15f47da557.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*Dt5uQuJKj_Bf1wbM9Qc8nw.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx">Gif: A monkey puppet looking wide-eyed and confused (<a class="ae jw" href="https://media.giphy.com/media/KrLqtbe8PGEDe/giphy.gif" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="ec3c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">我有预感是<code class="du ly lz ma lo b">Ember.run.later</code>导致了我的问题，因为用<code class="du ly lz ma lo b">setTimeout</code>替换它阻止了测试挂起(稍后会有更多关于它的缺点)。当我在周围搜索<a class="ae jw" href="https://discuss.emberjs.com/t/proper-way-to-handler-timers-w-ember-testing/4693" rel="noopener ugc nofollow" target="_blank">时，我意识到我的测试失败的原因与Ember.run.later令人敬畏的原因相同——因为总是有工作安排在未来的运行循环中。</a></p><p id="e8c0" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">我怎么知道的？一开始我不确定是什么问题，所以在四处搜索了一番后，我查看了源代码。<a class="ae jw" href="https://github.com/emberjs/ember.js/blob/9654d2a5c8588dff5edb553d53873bbc11831ba4/packages/ember-testing/lib/helpers/wait.js#L52" rel="noopener ugc nofollow" target="_blank">在源代码</a>中，我们可以看到<code class="du ly lz ma lo b">wait()</code>测试助手检查以确保所有的运行循环都已完成，并且没有排队的计时器。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es me"><img src="../Images/369186ea967baed28eb79fa61f2e4dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtK_XBrj78ELErXmJBsplg.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Image: Screenshot of source code where wait() checks for run loops or scheduled timers. (<a class="ae jw" href="https://github.com/emberjs/ember.js/blob/9654d2a5c8588dff5edb553d53873bbc11831ba4/packages/ember-testing/lib/helpers/wait.js#L52" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="1536" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">但是为什么呢？最初，它似乎不方便。事实证明，Ember测试希望确保所有异步工作在完成之前完成。在内部，这意味着<a class="ae jw" href="https://www.emberjs.com/api/ember/2.14/classes/Ember.Test/methods/wait?anchor=wait" rel="noopener ugc nofollow" target="_blank">Ember</a><code class="du ly lz ma lo b"><a class="ae jw" href="https://www.emberjs.com/api/ember/2.14/classes/Ember.Test/methods/wait?anchor=wait" rel="noopener ugc nofollow" target="_blank">wait()</a></code><a class="ae jw" href="https://www.emberjs.com/api/ember/2.14/classes/Ember.Test/methods/wait?anchor=wait" rel="noopener ugc nofollow" target="_blank">helper</a>检查以确保所有的运行循环都已完成，并且不再有排队的计时器——如果检查失败，显然还有工作要做。</p><p id="6ff8" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">因为我递归地调用了<code class="du ly lz ma lo b">Ember.run.later</code>，所以在运行循环中总是有<em class="jb">或者</em>一个任务或者一个预定的定时器，所以测试永远不会结束。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es mf"><img src="../Images/d4f25c591575b64cdfd03a35c2bbca29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Dz655G8LBY3idTG5qUqag.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Flowchart: Recursive Ember.run.later. <a class="ae jw" href="https://gist.githubusercontent.com/arieljackson/eed02ddc57294b9f5e43d45965274ab8/raw/9e6cc42a088e4bf20275b4d3ff0bfc839b3505ec/recursive_ember_run_later_flowchart.txt" rel="noopener ugc nofollow" target="_blank">Link to plaintext version of chart.</a></figcaption></figure><h1 id="140e" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">一个特性，而不是一个Bug。</h1><p id="aec8" class="pw-post-body-paragraph iz ja hh jc b jd li ii jf jg lj il ji jx lk jl jm jy ll jp jq jz lm jt ju jv ha bi translated">等待所有工作完成是Ember测试异步代码的基本方式。当然，这不是测试异步代码的唯一方法。例如，<a class="ae jw" href="https://robots.thoughtbot.com/write-reliable-asynchronous-integration-tests-with-capybara" rel="noopener ugc nofollow" target="_blank"> capybara对异步调用使用最大等待时间</a>，并在该时间过去后自动结束测试。</p><p id="cf7e" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">这可能会导致自身的问题。例如，假设我们点击关闭一个模态，想要断言这个模态是关闭的。在水豚中，当时间用完时，如果关闭模态的异步工作发生在时间限制之后，测试将结束并失败。另一方面，Ember可以确保与关闭模态相关的异步工作在调用assert之前完成。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es mg"><img src="../Images/f8568a667292cb51583ac886868003fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*5GUhGtQRLuReQqO7Ccnwfw.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx">Gif: Actor Tom Hanks frowning with his hand over his mouth (<a class="ae jw" href="https://media.giphy.com/media/3o7TKTDn976rzVgky4/giphy.gif" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><h1 id="a4e5" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">接下来呢？又一个错误</h1><p id="1fda" class="pw-post-body-paragraph iz ja hh jc b jd li ii jf jg lj il ji jx lk jl jm jy ll jp jq jz lm jt ju jv ha bi translated">既然我理解了这个错误，我需要找出一个解决方案。我反复思考了一些想法，尤其是在开始的时候。即使我想使用<code class="du ly lz ma lo b">Ember.run.later</code>，我的第一反应是尝试使用<code class="du ly lz ma lo b">setTimeout</code></p><pre class="kb kc kd ke fd ln lo lp lq aw lr bi"><span id="c89f" class="ls kr hh lo b fi lt lu l lv lw">...</span><span id="5db5" class="ls kr hh lo b fi lx lu l lv lw">monitorTimeWithSetTimeout() {<br/>   const dateNow = Date.now();<br/>   // component renders the millisecondsElapsed<br/>   this.set('millisecondsElapsed', dateNow - <br/>                        this.get('initialTime')) ;<br/>   setTimeout(() =&gt; this.setTimeout(), 250);<br/>},</span><span id="f4ac" class="ls kr hh lo b fi lx lu l lv lw">...</span></pre><p id="957e" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">再次运行验收测试，我得到了这个臭名昭著的错误:</p><p id="727a" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated"><code class="du ly lz ma lo b">Assertion failed: You have turned on testing mode, which disabled the run-loop’s autorun. You will need to wrap any code with asynchronous side-effects in an Ember.run</code></p><p id="3f71" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">为什么会这样？嗯，我认为在你的Ember应用程序中有两个世界:Ember世界和Ember之外的世界。Ember世界使用run循环，Ember之外世界的异步工作，像websockets，ajax调用，也要包装在一个<code class="du ly lz ma lo b">Ember.run</code>中，这样run循环才能正确处理副作用。</p><p id="7ef5" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">事实上，实际上有很多事情会产生异步副作用，甚至在绑定到模板的属性上调用“Ember.object.set”。Ember聪明地将你的代码包装在一个“自动运行”中，基本上是一个<code class="du ly lz ma lo b">Ember.run</code>，它在开发和生产中运行，所以副作用发生在运行循环中。</p><p id="38e4" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">但是，在测试中自动运行被禁用。成员文件列出了几个原因:</p><blockquote class="iw ix iy"><p id="6d3d" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">如果您在计划回调之前忘记打开运行循环，自动运行是不会在生产中惩罚您的一种方式。虽然这在生产中很有用，但是这些情况仍然应该在测试中揭示出来，以帮助您找到并修复它们。</p><p id="0ee6" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">Ember的一些测试助手承诺在解析之前等待运行循环清空。如果你的应用程序有在runloop之外运行的代码，这些将会过早地解决，并给出难以发现的错误的测试失败。禁用自动运行有助于您识别这些场景，并有助于您的测试和应用程序！</p></blockquote><p id="5a99" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">这意味着如果你试图使用<code class="du ly lz ma lo b">setTimeout</code>，进行ajax调用，或者甚至设置具有异步副作用的属性，你将在测试中得到一个错误。这样，您可以在潜在的不可预测的副作用发生在生产中之前捕捉到它们。</p><h1 id="e5fc" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated"><strong class="ak">有什么解决办法？</strong></h1><p id="c438" class="pw-post-body-paragraph iz ja hh jc b jd li ii jf jg lj il ji jx lk jl jm jy ll jp jq jz lm jt ju jv ha bi translated"><a class="ae jw" href="https://discuss.emberjs.com/t/proper-way-to-handler-timers-w-ember-testing/4693" rel="noopener ugc nofollow" target="_blank">一位评论者</a>称递归<code class="du ly lz ma lo b">Ember.run.later</code>的问题是一个“有害的问题”，我明白为什么。这个问题没有完美、优雅、简洁的解决方案。正确的解决方案需要深入思考您自己的应用程序和测试。</p><p id="a7fe" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">Ember论坛上经常出现的一个建议是将回调包装在Ember中。</p><pre class="kb kc kd ke fd ln lo lp lq aw lr bi"><span id="1ca3" class="ls kr hh lo b fi lt lu l lv lw">monitorTimeWithSetTimeoutInRun() {<br/>   const dateNow = Date.now();<br/>   // component renders the millisecondsElapsed<br/>   this.set('millisecondsElapsed', dateNow - <br/>                        this.get('initialTime')) ;<br/>   setTimeout(Ember.run(() =&gt;       <br/>              this.monitorTimeWithSetTimeoutInRun()), 250);<br/>},</span></pre><p id="a2da" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">这种解决方案的优点是，在测试中，计时器的工作方式与生产中相同。</p><p id="ce78" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">这个解决方案的缺点是<code class="du ly lz ma lo b">setTimeout</code>仍然生活在Ember之外的世界，并且如前所述，不尊重内部定时器队列。在我的项目中，我发现这比我希望的更加不可预测。有时，由于run循环的执行，下一个<code class="du ly lz ma lo b">setTimeout()</code>会在本该停止它的元素被销毁后执行。如果你在做类似<code class="du ly lz ma lo b">if (!this.get(‘isDestroyed)</code>的事情，你可能会遇到这样的错误。</p><h2 id="480a" class="ls kr hh bd ks mh mi mj kw mk ml mm la jx mn mo lc jy mp mq le jz mr ms lg mt bi translated">更好的解决方案</h2><p id="1de0" class="pw-post-body-paragraph iz ja hh jc b jd li ii jf jg lj il ji jx lk jl jm jy ll jp jq jz lm jt ju jv ha bi translated">由于我的代码处理大量应用程序范围的状态，我真的想利用Ember Run循环。</p><p id="a73c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">我转到Square #ember Slack频道，立刻有人建议我看看rwjblue的<a class="ae jw" href="https://github.com/rwjblue/ember-lifeline" rel="noopener ugc nofollow" target="_blank"> Ember Lifeline </a>。谢谢，slack频道英雄。Ember Lifeline在<code class="du ly lz ma lo b">pollTask</code>功能中有一个创新的方法——而不是杂乱地合并<code class="du ly lz ma lo b">setTimeout</code> , <code class="du ly lz ma lo b">pollTask</code>在测试和开发/生产中处理工作的方式不同。在开发/生产中，<code class="du ly lz ma lo b">Ember.run.later</code>被递归调用。但是在测试中，下一个异步<code class="du ly lz ma lo b">run</code>被保存，您可以手动<code class="du ly lz ma lo b">tick</code>转发轮询器。</p><p id="6019" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">由于我在一个尚不支持使用Ember插件的应用程序中工作，并且我不需要整个Ember Lifeline库，我只是将一些关键的想法融入到我自己的应用程序中。我可以手动启动计时器，准确控制我正在做的工作。我的测试最终没有挂起，没有出现任何问题，并且我为我所有的错误找到了一个令人满意的解决方案。</p><pre class="kb kc kd ke fd ln lo lp lq aw lr bi"><span id="4cbb" class="ls kr hh lo b fi lt lu l lv lw">import Ember from 'ember';</span><span id="74cb" class="ls kr hh lo b fi lx lu l lv lw">// Used for testing<br/>let _asyncTaskToDo = null;</span><span id="333f" class="ls kr hh lo b fi lx lu l lv lw">export function runNextAsyncTask() {<br/>  // Used in testing<br/>  // to manually call next recursive call<br/>  _asyncTaskToDo();<br/>}</span><span id="e9df" class="ls kr hh lo b fi lx lu l lv lw">export default Ember.Component.extend({<br/>  millisecondsElapsed: 0,<br/>  <br/>  didInsertElement(...args) {<br/>    this._super(...args);<br/>    this.set('initialTime', Date.now());<br/>   Ember.run.later(() =&gt; this.monitorTimeWithEmberRun(), 250);;<br/>  },<br/>  <br/>  monitorTimeAndSaveCalls() {<br/>   const dateNow = Date.now();<br/>   // component renders the millisecondsElapsed<br/>   this.set('millisecondsElapsed', dateNow - <br/>                        this.get('initialTime')) ;<br/>   this.queueAsyncTask(() =&gt; {<br/>      Ember.run.later(() =&gt;   <br/>                      this.monitorTimeAndSaveCalls(), 250);<br/>   });<br/>    <br/>  },<br/>  <br/>  queueAsyncTask(taskToDo) {<br/>    // if testing, save next work to do<br/>    // so that we don't block the run loop<br/>    if (Ember.testing) {<br/>      _asyncTaskToDo = taskToDo;<br/>    } else {<br/>      taskToDo();<br/>    }<br/>  },<br/>});</span></pre><p id="e5ce" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">对我来说，计时器在我的测试中没有“实际”运行并不重要。我更关心的是在每个时钟周期执行的函数是否被正确监控，并以正确的频率进行API调用。这有一个额外的好处，那就是我的计时器不会在其他人测试的背景下运行。在测试中运行不同于生产中的代码，这种犹豫是可以理解的。但是关于依赖时间的项目，测试几乎不可能和生产一样。即使你在使用<code class="du ly lz ma lo b">setTimeout</code>，你也会经常使用<a class="ae jw" href="http://sinonjs.org/releases/v1.17.7/fake-timers/" rel="noopener ugc nofollow" target="_blank"> Sinon的假定时器</a>——所以你的代码已经不会像在生产中那样精确地执行了。编写简洁的、可测试的、实际上不依赖于任何时间的代码意味着更高的测试覆盖率，并使时间不再是问题。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es md"><img src="../Images/8255dd094bf7732d346cd969bf385721.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*1h6luzlmD8Mu28uUeVNe3w.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx">Gif: Four people dancing on stage in celebration. (<a class="ae jw" href="https://media2.giphy.com/media/Hd3GXtH7xs1CU/giphy.gif" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="bb38" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">我花了一段时间为我的项目找到正确的解决方案，虽然它对我有用，但它可能不是每个人的正确选择。我很想看看Ember社区在未来处理这个问题时会提出什么样的不同解决方案！</p><h1 id="0188" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">外卖食品</h1><p id="3005" class="pw-post-body-paragraph iz ja hh jc b jd li ii jf jg lj il ji jx lk jl jm jy ll jp jq jz lm jt ju jv ha bi translated">这个夏天我学到了很多关于Ember的知识，也学到了如何解决一般问题。我不能用几个要点概括我学到的所有东西，但我要说的是:</p><h2 id="5737" class="ls kr hh bd ks mh mi mj kw mk ml mm la jx mn mo lc jy mp mq le jz mr ms lg mt bi translated">余烬的想法:</h2><ol class=""><li id="4ae7" class="mu mv hh jc b jd li jg lj jx mw jy mx jz my jv mz na nb nc bi translated">将您的异步代码包装在<code class="du ly lz ma lo b">Ember.run</code>中。你将省去许多奇怪的、不可预测的测试失败。</li><li id="79dc" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv mz na nb nc bi translated">即使您认为不会直接与Run循环交互，这也是值得了解的。我认为在现实世界的应用程序中，你不可能没有一些存在于Ember世界之外的异步工作。</li><li id="afa7" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv mz na nb nc bi translated">如果你允许的话，Ember可以非常强大和高效。充分利用它所提供的一切。</li></ol><h2 id="70e6" class="ls kr hh bd ks mh mi mj kw mk ml mm la jx mn mo lc jy mp mq le jz mr ms lg mt bi translated">其他想法:</h2><ol class=""><li id="a76f" class="mu mv hh jc b jd li jg lj jx mw jy mx jz my jv mz na nb nc bi translated">你可以看看其他项目的源代码来获得灵感，即使你不能直接使用它。即使我不能使用Ember Lifeline，它也帮助我为一个丑陋的问题找到了一个优雅的解决方案。</li><li id="47dd" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv mz na nb nc bi translated">就这一点而言，源代码可能是事实的最终来源。很多时候，对运行循环的其他解释已经过时或者含糊不清。阅读<a class="ae jw" href="https://github.com/BackburnerJS/backburner.js?files=1" rel="noopener ugc nofollow" target="_blank"> backburner.js </a>改变了游戏规则。学习阅读和理解源代码是这个夏天的一大教训。</li><li id="037b" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv mz na nb nc bi translated">你在网上读到的解决方案并不总是最好的选择。我读过很多关于投票者的例子，他们有复杂的投票对象或者使用了<code class="du ly lz ma lo b">setTimeout()</code>或者<code class="du ly lz ma lo b">setInterval()</code>。虽然这些选项对一些人有用，但更简单、更有余烬风格的对我来说更好。为我的项目写点特别的东西是值得的。</li><li id="5e0c" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv mz na nb nc bi translated">了解其他人是如何学习的。看着其他团队成员解决问题教会了我很多东西:不同的开发、调试、搜索、使用键盘快捷键的方式——甚至以1.5倍的速度观看视频以更快地完成它们。</li><li id="9f89" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv mz na nb nc bi translated">但是即使是你团队中最聪明的人也不会什么都知道，也不能回答你所有的问题。因此，如果你真的花时间深入研究一个问题，一定要分享这些知识——无论是在演示文稿、电子邮件还是博客文章中(10/10推荐)。</li></ol><h1 id="d6a9" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">荣誉</h1><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es ni"><img src="../Images/1154dcd6bef70724380c49e7e704c5f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*W9WVG7guCXBoiBLOfPn-uQ.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx">Gif: Dwight Schrute from the Office tearfully looking up mouthing “Thank you”, with text “Thank you” (<a class="ae jw" href="https://media.giphy.com/media/IcGkqdUmYLFGE/giphy.gif" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><p id="7899" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">这个夏天太棒了。非常感谢我的团队在我的工作和这篇博文中对我的鼓励和支持。还要特别感谢乔治，他总是提醒我这个项目有多重要。玛丽·查特菲尔德(Marie Chatfield)，导师、灵感、余烬女王。还有Lenny，他令人难以置信的知识只有在他分享知识的能力面前才显得黯然失色，他和我一起坐了无数个小时调试，通读backburner.js，讨论我午夜的slack rants。总之，感谢Square是一个如此美好、包容、聪明的地方。</p><h1 id="e41d" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">进一步阅读和来源</h1><ul class=""><li id="35f1" class="mu mv hh jc b jd li jg lj jx mw jy mx jz my jv nl na nb nc bi translated"><a class="ae jw" href="https://github.com/BackburnerJS/backburner.js?files=1" rel="noopener ugc nofollow" target="_blank">背景燃烧者. js </a></li><li id="0ab1" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv nl na nb nc bi translated"><a class="ae jw" href="https://github.com/emberjs/ember.js/blob/9654d2a5c8588dff5edb553d53873bbc11831ba4/packages/ember-testing/lib/helpers/wait.js" rel="noopener ugc nofollow" target="_blank">余烬测试源代码— wait() </a></li><li id="072e" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv nl na nb nc bi translated"><a class="ae jw" href="https://discuss.emberjs.com/t/proper-way-to-handler-timers-w-ember-testing/4693" rel="noopener ugc nofollow" target="_blank">灰烬论坛:处理计时器的正确方法</a></li><li id="1dad" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv nl na nb nc bi translated"><a class="ae jw" href="https://github.com/emberjs/ember.js/issues/3008" rel="noopener ugc nofollow" target="_blank"> Github问题:用余烬计时器进行余烬测试失败</a></li><li id="db88" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv nl na nb nc bi translated"><a class="ae jw" href="https://github.com/eoinkelly/ember-runloop-handbook" rel="noopener ugc nofollow" target="_blank">余烬运行循环手册</a></li><li id="4610" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv nl na nb nc bi translated"><a class="ae jw" href="https://emberjs.com/api/ember/2.15.0/namespaces/Ember.run" rel="noopener ugc nofollow" target="_blank">会员运行API </a></li><li id="c116" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv nl na nb nc bi translated"><a class="ae jw" href="https://guides.emberjs.com/v2.14.0/applications/run-loop/" rel="noopener ugc nofollow" target="_blank">成员运行循环文件</a></li><li id="4c29" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv nl na nb nc bi translated"><a class="ae jw" href="https://www.youtube.com/watch?v=G4DdNMLubgQ" rel="noopener ugc nofollow" target="_blank">杰森·麦德森在盐湖城Ember Meetup上的Ember Run Loop</a></li><li id="72d2" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv nl na nb nc bi translated"><a class="ae jw" href="https://www.youtube.com/watch?v=LSCislCKMBw" rel="noopener ugc nofollow" target="_blank">Rizwan Reza的ember . js Run Loop</a></li><li id="b86f" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv nl na nb nc bi translated"><a class="ae jw" href="https://stackoverflow.com/questions/13597869/what-is-ember-runloop-and-how-does-it-work" rel="noopener ugc nofollow" target="_blank">堆栈溢出:什么是Ember RunLoop，它是如何工作的？</a></li><li id="991c" class="mu mv hh jc b jd nd jg ne jx nf jy ng jz nh jv nl na nb nc bi translated"><a class="ae jw" href="https://teamgaslight.com/blog/a-beginners-guide-to-the-ember-run-loop" rel="noopener ugc nofollow" target="_blank">Ember Run Loop初学者指南</a></li></ul></div></div>    
</body>
</html>