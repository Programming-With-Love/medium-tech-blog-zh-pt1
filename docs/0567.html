<html>
<head>
<title>Delegating Delegates to Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将代表委派给Kotlin</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/delegating-delegates-to-kotlin-ee0a0b21c52b?source=collection_archive---------0-----------------------#2020-10-07">https://medium.com/androiddevelopers/delegating-delegates-to-kotlin-ee0a0b21c52b?source=collection_archive---------0-----------------------#2020-10-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/fc82c9fa6e27477c74910d831194b1ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9peGthDF8Psx-2nO"/></div></div></figure><div class=""/><p id="4bf6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">代表们</p><p id="3339" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">完成某些工作的一个方法是将工作委托给另一方。不，我不是说把你的工作委托给你的朋友，而是把工作从一个对象委托给另一个对象。</p><p id="8118" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你猜怎么着，委托对软件来说并不陌生。<a class="ae jn" href="https://en.wikipedia.org/wiki/Delegation_pattern" rel="noopener ugc nofollow" target="_blank">委托</a>是一种设计模式，其中一个对象通过委托给一个助手对象来处理请求，称为<em class="jo">委托</em>。委托负责代表原始对象处理请求，并将结果提供给原始对象。</p><p id="4d4c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Kotlin通过提供对类和属性委托的支持，甚至包含一些自己的内置委托，使委托变得更加容易。</p><h1 id="5895" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">班级代表</h1><p id="8d7c" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">假设您有一个<code class="du ks kt ku kv b">ArrayList</code>用例，它可以恢复最后一个被移除的项目。基本上，您所需要的就是相同的<code class="du ks kt ku kv b">ArrayList</code>功能，并引用最后一个删除的项目。</p><p id="9ee0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一种方法是扩展<code class="du ks kt ku kv b">ArrayList</code>类。因为这个新类是扩展具体的<code class="du ks kt ku kv b">ArrayList</code>而不是实现<code class="du ks kt ku kv b">MutableList</code>接口，所以它与具体的<code class="du ks kt ku kv b">ArrayList</code>实现高度耦合。</p><p id="3260" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您可以覆盖<code class="du ks kt ku kv b">remove()</code>函数来保留被删除项的引用，并将<code class="du ks kt ku kv b">MutableList</code>的其余空实现委托给其他对象，那就不好了。Kotlin通过将大部分工作委托给一个内部<code class="du ks kt ku kv b">ArrayList</code>实例并定制其行为，提供了一种实现这一点的方法。为此，Kotlin引入了一个新的关键词:<code class="du ks kt ku kv b">by</code>。</p><p id="1c2a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看班级委托是如何工作的。当您使用<code class="du ks kt ku kv b">by</code>关键字时，Kotlin会自动生成代码，将<code class="du ks kt ku kv b">innerList</code>实例用作委托。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="f496" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关键字<code class="du ks kt ku kv b">by</code>告诉Kotlin将功能从<code class="du ks kt ku kv b">MutableList</code>接口委托给名为innerList的内部<code class="du ks kt ku kv b">ArrayList</code>实例。<code class="du ks kt ku kv b">ListWithTrash</code>通过向内部<code class="du ks kt ku kv b">ArrayList</code>对象提供直接的桥接方法，仍然支持<code class="du ks kt ku kv b">MutableList</code>接口中的所有功能。另外，现在您有能力添加自己的行为。</p><h1 id="bfa6" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">在后台</h1><p id="13c1" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">让我们看看这是如何工作的。如果您看一看从<code class="du ks kt ku kv b">ListWithTrash</code>字节代码反编译的Java代码，您会看到Kotlin编译器实际上创建了包装器函数，这些函数调用内部<code class="du ks kt ku kv b">ArrayList</code>对象上的相应函数。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div></figure><blockquote class="lc ld le"><p id="48d1" class="ip iq jo ir b is it iu iv iw ix iy iz lf jb jc jd lg jf jg jh lh jj jk jl jm ha bi translated">注意:Kotlin编译器使用另一种称为<a class="ae jn" href="https://en.wikipedia.org/wiki/Decorator_pattern" rel="noopener ugc nofollow" target="_blank">装饰模式</a>的设计模式来支持生成代码中的类委托。在装饰器模式中，装饰器类与要装饰的类共享同一个接口。decorator类保留目标类的内部引用，并包装或修饰接口提供的所有公共方法。</p></blockquote><p id="52df" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您不能从特定的类继承时，委托尤其有用。使用类委托，您的类不属于任何类层次结构。相反，它共享相同的接口并修饰原始类型的内部对象。这意味着您可以在不破坏公共API的情况下轻松切换实现。</p><h1 id="e23b" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">委托属性</h1><p id="e13c" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">除了类委托，你还可以使用<code class="du ks kt ku kv b">by</code>关键字来委托属性。通过属性委托，委托人负责处理对属性的<code class="du ks kt ku kv b">get</code>和<code class="du ks kt ku kv b">set</code>函数的调用。如果您需要跨其他对象重用getter/setter逻辑，这将非常有用，并且可以让您轻松地将功能扩展到简单的支持字段之外。</p><p id="4ec6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设您有一个这样定义的<code class="du ks kt ku kv b">Person</code>类:</p><p id="4cca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du ks kt ku kv b"><strong class="ir ht">class </strong>Person(<strong class="ir ht">var</strong> name: String, <strong class="ir ht">var lastname</strong>: String)</code></p><p id="c7b2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个类的<code class="du ks kt ku kv b">name</code>属性有一些格式要求。当设置了<code class="du ks kt ku kv b">name</code>时，您希望确保第一个字母是大写的，而其余的是小写的。此外，在更新名称时，您希望自动增加更新计数属性。</p><p id="cc77" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您<em class="jo">可以</em>实现此功能，如下所示:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="b5d5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然这是可行的，但是如果需求发生了变化，并且每次<code class="du ks kt ku kv b">lastname</code>发生变化时，您都想增加<code class="du ks kt ku kv b">updateCount</code>的值，那该怎么办呢？您可以复制/粘贴逻辑来编写自定义的setter，但是突然您会发现自己为每个属性编写了完全相同的setter:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="3c1b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">两个setter方法几乎相同，告诉你其中一个不应该存在。使用属性委托，我们可以通过将getters和setters委托给属性来重用代码。</p><p id="0dff" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就像类委托一样，您可以使用<code class="du ks kt ku kv b">by</code>来委托属性，当您使用属性语法时，Kotlin将生成代码来使用委托。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="6e22" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过这一更改，您已经将<code class="du ks kt ku kv b">name</code>和<code class="du ks kt ku kv b">lastname</code>属性委托给了<code class="du ks kt ku kv b">FormatDelegate</code>类。现在让我们看看<code class="du ks kt ku kv b">FormatDelegate</code>的代码。如果您只需要委托getter，delegate类需要实现<code class="du ks kt ku kv b">ReadProperty&lt;Any?, String&gt;</code>，或者如果您需要委托getter和setter，则需要实现<code class="du ks kt ku kv b">ReadWriteProperty&lt;Any?, String&gt;</code>。在我们的例子中，<code class="du ks kt ku kv b">FormatDelegate</code>需要实现<code class="du ks kt ku kv b">ReadWriteProperty&lt;Any?, String&gt;</code>，因为您希望在调用setter时执行格式化。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="26f2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可能已经注意到getter和setter函数中有两个额外的参数。第一个参数是<code class="du ks kt ku kv b">thisRef</code>，表示包含属性的对象。<code class="du ks kt ku kv b">thisRef</code>可用于访问对象本身，如检查其他属性或调用其他类函数。第二个参数是<code class="du ks kt ku kv b">KProperty&lt;*&gt;</code>，可以用来访问委托属性的元数据。</p><p id="b70f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">回头看看需求，让我们使用<code class="du ks kt ku kv b">thisRef</code>来访问并递增<code class="du ks kt ku kv b">updateCount</code>属性。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div></figure><h1 id="42ee" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">在后台</h1><p id="49cb" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">为了理解这是如何工作的，让我们看一下反编译的Java代码。Kotlin编译器生成代码来保存对<code class="du ks kt ku kv b">name</code>和<code class="du ks kt ku kv b">lastname</code>属性的<code class="du ks kt ku kv b">FormatDelegate</code>对象的私有引用，以及包含您添加的逻辑的getter/setter。</p><p id="d904" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编译器还创建了一个<code class="du ks kt ku kv b">KProperty[]</code>来存储委托的属性。如果您看一下为<code class="du ks kt ku kv b">name</code>属性生成的getters和setters，实例存储在索引0处，而<code class="du ks kt ku kv b">lastname</code>属性存储在索引1处。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="e48d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了这个技巧，任何调用者都可以用常规的属性语法访问委托属性。</p><p id="b127" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du ks kt ku kv b">person.lastname = “Smith” // calls generated setter, increments count</code></p><p id="b34f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du ks kt ku kv b"><em class="jo">println</em>(<strong class="ir ht">“Update count is $</strong>person.count<strong class="ir ht">”</strong>)</code></p><p id="ef99" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Kotlin不仅支持委托，还在Kotlin标准库中提供了内置委托，我们将在另一篇文章中看到更详细的内容。</p><p id="3028" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">委托可以帮助您将任务委托给其他对象，并提供更好的代码重用。Kotlin编译器创建代码让您无缝地使用委托。Kotlin使用带有关键字<code class="du ks kt ku kv b">by</code>的简单语法来委托属性或类。在幕后，Kotlin编译器生成所有必要的代码来支持委托，而不暴露任何对公共API的更改。简单地说，Kotlin为委托生成并维护所有需要的样板代码，或者换句话说，您可以将您的委托委托给Kotlin。</p></div></div>    
</body>
</html>