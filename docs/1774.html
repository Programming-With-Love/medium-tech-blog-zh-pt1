<html>
<head>
<title>How to Use Java Streams, Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Java流，解释</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/how-to-use-java-streams-explained-a2836e3a75f2?source=collection_archive---------1-----------------------#2021-01-21">https://medium.com/capital-one-tech/how-to-use-java-streams-explained-a2836e3a75f2?source=collection_archive---------1-----------------------#2021-01-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="7705" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">让流、中间操作和终端操作在Java中工作</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/aa44f97f90a16222592c3ef6e9f6280e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uUpqeN5rEYcyc9JX.png"/></div></div></figure><p id="7318" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">流是Java集成函数式编程和面向对象风格的方式。在Java中使用流有很多好处，比如能够在更抽象的层次上编写函数，这可以减少代码错误，将函数压缩到更少更易读的代码行中，以及它们为并行化提供的便利。Java流是众所周知的，但是并不是每个人都知道如何充分利用它们的优点，包括创建流、中间操作和终端操作的优点。在这篇博客中，我们将使用一个简单的例子来解释Java流是如何工作的，这将导致更少的冗长、更直观和更少的易错代码。</p><h1 id="b502" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">Java流如何工作的一个例子</h1><p id="979c" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">考虑Java流最简单的方式，也是对我帮助最大的方式，是想象一个彼此不相连的对象列表，一次一个地进入管道。您可以控制进入管道的对象数量、在管道内对这些对象做什么，以及在这些对象退出管道时如何捕捉它们。</p><p id="f8b0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">先看大图，然后再分解，学习Streams要容易得多。为此，让我们编写一个程序，取一定数量的4的倍数，对每个倍数求平方，然后取所有不能被10整除的平方的和:</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="87e9" class="lg kf hh lc b fi lh li l lj lk">protected static int example1(int numberOfMultiples){<br/>    return Stream.<em class="ll">iterate</em>(4, multipleOfFour -&gt; multipleOfFour + 4)<br/>            .limit(numberOfMultiples)<br/>            .map(multipleOfFour -&gt; multipleOfFour * multipleOfFour)<br/>            .filter(multipleOfFourSquared -&gt; multipleOfFourSquared % 10 == 0)<br/>            .reduce(0, Integer::<em class="ll">sum</em>);<br/>}</span></pre><p id="bcab" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">即使你不知道流在Java中是如何工作的，你也很有可能能够很快弄清楚上面的代码在做什么。除了第一行<em class="ll"> ( </em> <code class="du lm ln lo lc b"><em class="ll">Stream.iterate(4, multipleOfFour -&gt; multipleOfFour + 4)</em></code> <em class="ll"> ) </em>，其余代码读起来几乎就像一组指令。</p><p id="bef3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们一次一件来。</p><h1 id="478a" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">λ表达式</h1><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="b171" class="lg kf hh lc b fi lh li l lj lk">multipleOfFour -&gt; multipleOfFour + 4</span></pre><p id="68b9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这就是Java 中定义<a class="ae lp" href="https://www.w3schools.com/java/java_lambda.asp" rel="noopener ugc nofollow" target="_blank"> Lambda表达式的方式。Lambda表达式提供了一种更加紧凑和简化的方法来定义函数。本质上，你可以想象左边的multipleOfFour是输入，- &gt;是Lambda，右边的<code class="du lm ln lo lc b">multipleOfFour + 4</code>是返回值。想象一下这个读数为“给我一个输入(multipleOfFour)，我将返回给你那个输入+ 4。”注意，如果Java中的一个Lambda表达式需要多行，那么需要用花括号“<code class="du lm ln lo lc b">{}</code>”将右边(Lambda - &gt;之后)括起来，并添加一个return语句。</a></p><h1 id="6a44" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">流创建</h1><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="5801" class="lg kf hh lc b fi lh li l lj lk">Stream.<em class="ll">iterate</em>(4, multipleOfFour -&gt; multipleOfFour + 4)</span></pre><p id="f16d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><code class="du lm ln lo lc b"><a class="ae lp" href="https://mkyong.com/java8/java-8-stream-iterate-examples/" rel="noopener ugc nofollow" target="_blank">Stream.iterate()</a></code>是一个函数，它通过获取一个种子(起点)和一个一元运算符(可以为其传入一个Lambda表达式)来创建一个无限流。从4开始，这个特定的迭代将返回一个流:4，8，12，16，20，24，28，…</p><h1 id="8ddc" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">限制</h1><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="5a3d" class="lg kf hh lc b fi lh li l lj lk">.limit(numberOfMultiples)</span></pre><p id="3cca" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是流管道的下一部分，它<a class="ae lp" href="https://howtodoinjava.com/java8/java-stream-limit-method-example/" rel="noopener ugc nofollow" target="_blank">将</a>前一个流限制为限制中指定的数量(在本例中为<code class="du lm ln lo lc b">numberOfMultiples</code>)。因此，我们的流不再是无限流，现在只包含第一个<code class="du lm ln lo lc b">numberOfMultiples</code>，在这种情况下，它是4的倍数。</p><h1 id="7387" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">高阶函数</h1><p id="6654" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated"><a class="ae lp" href="https://en.wikipedia.org/wiki/Higher-order_function" rel="noopener ugc nofollow" target="_blank">高阶函数</a>是以函数为自变量，或者作用于给定函数或者返回函数的函数。当使用Java的函数接口时，高阶函数非常有用，因为它们允许开发者达到更高的抽象层次。</p><h1 id="fbef" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">地图</h1><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="ac10" class="lg kf hh lc b fi lh li l lj lk">.map(multipleOfFour -&gt; multipleOfFour * multipleOfFour)</span></pre><p id="46c8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><code class="du lm ln lo lc b"><a class="ae lp" href="https://en.wikipedia.org/wiki/Map_(higher-order_function)" rel="noopener ugc nofollow" target="_blank">Map</a></code> <a class="ae lp" href="https://en.wikipedia.org/wiki/Map_(higher-order_function)" rel="noopener ugc nofollow" target="_blank">是高阶函数</a>。它接受一个Lambda表达式，转换它所作用的流中的每个值，并将其写入Lambda中指定的不同流中。在这种情况下，它取原始流中的每一个4的倍数，并创建一个包含所有这些4的平方的倍数的新流。虽然在这种情况下，我们要去<code class="du lm ln lo lc b">Stream&lt;Integer&gt; -&gt; Stream&lt;Integer&gt;</code>，你可以使用地图完全转换你的流到一个不同类型的流！</p><p id="d053" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">例如，如果我运行:</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="bc99" class="lg kf hh lc b fi lh li l lj lk">.map(multipleOfFour -&gt; String.<em class="ll">valueOf</em>(multipleOfFour * multipleOfFour))</span></pre><p id="7d84" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">它会转换我的<em class="ll"> </em> <code class="du lm ln lo lc b"><em class="ll">Stream&lt;Integer&gt; -&gt; Stream&lt;String&gt;</em></code>。这是非常强大的，如果你要实现像这种面向对象的风格，代码将不会直接和优雅。您还需要不必要地创建有限范围的变量和对象。这是面向对象的版本:</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="eec3" class="lg kf hh lc b fi lh li l lj lk">List&lt;String&gt; multiplesOfFourStrings = new ArrayList&lt;&gt;();<br/>for (Integer multipleOfFour : multiplesOfFour){<br/>    multiplesOfFourStrings.add(String.<em class="ll">valueOf</em>(multipleOfFour * multipleOfFour));<br/>}</span></pre><h1 id="1998" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">过滤器</h1><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="dc4f" class="lg kf hh lc b fi lh li l lj lk">.filter(multipleOfFourSquared -&gt; multipleOfFourSquared % 10 == 0)</span></pre><p id="76c1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">与map类似，<code class="du lm ln lo lc b"><a class="ae lp" href="https://en.wikipedia.org/wiki/Filter_(higher-order_function)" rel="noopener ugc nofollow" target="_blank">filter</a></code> <a class="ae lp" href="https://en.wikipedia.org/wiki/Filter_(higher-order_function)" rel="noopener ugc nofollow" target="_blank">是另一个高阶函数</a>。Filter <a class="ae lp" href="https://www.baeldung.com/java-predicate-chain" rel="noopener ugc nofollow" target="_blank">接受一个谓词</a>，这是lambda表达式的一种表达方式，它在某些条件下返回true，在其他条件下返回false。它过滤流，这样流中只剩下那些导致谓词返回true的对象。我阅读这样一个过滤器的方式是<em class="ll">“过滤我的流中4的平方的倍数，这样只有那些4的平方的倍数% 10 == 0的对象。”</em></p><h1 id="19a0" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">减少</h1><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="b9e4" class="lg kf hh lc b fi lh li l lj lk">.reduce(0, Integer::<em class="ll">sum</em>);</span></pre><p id="843a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">到目前为止，map和filter是我们称之为<a class="ae lp" href="https://dzone.com/articles/become-a-master-of-java-streams-part-2-intermediat" rel="noopener ugc nofollow" target="_blank">的中间操作</a>——它们接受一个流并返回一个新的流。<code class="du lm ln lo lc b"><a class="ae lp" href="http://zetcode.com/java/streamreduce/#:~:text=Java%20Stream%20reduction,the%20elements%20of%20a%20stream." rel="noopener ugc nofollow" target="_blank">Reduce</a></code> <a class="ae lp" href="http://zetcode.com/java/streamreduce/#:~:text=Java%20Stream%20reduction,the%20elements%20of%20a%20stream." rel="noopener ugc nofollow" target="_blank">是一个终端操作</a>的例子，顾名思义，它终止流并返回其他东西，不管是集合还是值。Reduce有两个参数:一个identity(通常称为“accumulator”)和一个BinaryOperator，用于简化为一个值。理解这个特定reduce函数的方法是<em class="ll">“从数字0开始，对流中的所有整数求和，并返回这个和。”</em></p><h1 id="1281" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">创建Java流的示例</h1><p id="8658" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">直接从系列制作流:</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="307e" class="lg kf hh lc b fi lh li l lj lk">List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(Arrays.<em class="ll">asList</em>(1,2,3));<br/>Stream&lt;Integer&gt; intStream = arrayList.stream();</span><span id="bbc1" class="lg kf hh lc b fi lq li l lj lk">Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(){{<br/>    put(1,1);<br/>    put(2,2);<br/>    put(3,3);<br/>}};<br/>Stream&lt;Map.Entry&lt;Integer,Integer&gt;&gt; mapStream = map.entrySet().stream();</span></pre><h1 id="a2a3" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">Java流中的中间操作示例</h1><p id="b936" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated"><code class="du lm ln lo lc b">.sorted()</code>:用给定的比较器对你的流进行排序:</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="9d8e" class="lg kf hh lc b fi lh li l lj lk">List&lt;int[]&gt; list = new ArrayList&lt;int[]&gt;(){{<br/>    add(new int[] {1,20});<br/>    add(new int[] {5,15});<br/>    add(new int[] {7,18});<br/>    add(new int[] {3,25});<br/>}};<br/>list = list.stream()<br/>        .sorted(Comparator.<em class="ll">comparingInt</em>(i -&gt; i[1]))<br/>        .collect(Collectors.<em class="ll">toList</em>());</span></pre><p id="6212" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><code class="du lm ln lo lc b"><em class="ll">Comparator.comparingInt()</em></code>在给定函数的情况下比较流中的项目，该函数比较这些项目的整数部分——这与您使用<code class="du lm ln lo lc b"><em class="ll">.sorted((i,j) -&gt; Integer.compare(i[1], j[1]))</em></code>的效果相同。这个函数按照两个数数组中的第二个值对创建的数组流进行排序。至于collect，这将在下面的其他终端操作示例中介绍。</p><h1 id="ed55" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">Java流中终端操作的两个例子</h1><p id="3c0a" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated"><strong class="jk hi">终端操作示例1 <br/> </strong> <code class="du lm ln lo lc b">.collect()</code>:将你的流中的项目收集到某个集合中:</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="506c" class="lg kf hh lc b fi lh li l lj lk">List&lt;int[]&gt; list = new ArrayList&lt;int[]&gt;(){{<br/>    add(new int[] {1,20});<br/>    add(new int[] {5,15});<br/>    add(new int[] {7,18});<br/>    add(new int[] {3,25});<br/>}};<br/>list = list.stream()<br/>        .sorted(Comparator.<em class="ll">comparingInt</em>(i -&gt; i[1]))<br/>        .collect(Collectors.<em class="ll">toList</em>());</span></pre><p id="ef00" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在前一个例子的基础上，<code class="du lm ln lo lc b"><em class="ll">collect()</em></code>是Java流中另一个非常重要的终端操作。根据您指定的收集器，流中的项目将被收集到该集合中。上面的例子将流中的项目收集到一个列表中。运行之后，list现在包含了我们添加的数组列表，按照每个数组中的第二个项目进行升序排序。还可以通过指定集合工厂，将流中的项目收集到映射、集合、并发映射或任何其他集合中。</p><p id="3ba2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这里还有一个例子，我们以前在同一个列表上使用collect，但是这次我们将整数数组列表收集到一个映射中，其中每个数组中的第一项是键，第二项是每个<code class="du lm ln lo lc b">&lt;key,value&gt; </code>对的值！</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="3f8a" class="lg kf hh lc b fi lh li l lj lk">List&lt;int[]&gt; list = new ArrayList&lt;int[]&gt;(){{<br/>    add(new int[] {1,20});<br/>    add(new int[] {5,15});<br/>    add(new int[] {7,18});<br/>    add(new int[] {3,25});<br/>}};<br/>Map&lt;Integer, Integer&gt; map = list.stream()<br/>        .collect(Collectors.<em class="ll">toMap</em>(i -&gt; i[0], i -&gt; i[1]));</span></pre><h1 id="6803" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">终端操作示例2</h1><p id="249b" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated"><strong class="jk hi">终端操作示例2 <br/> </strong> <code class="du lm ln lo lc b">.forEach()</code>:对您的流中的每个项目执行一个操作</p><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="3c67" class="lg kf hh lc b fi lh li l lj lk">List&lt;int[]&gt; list = new ArrayList&lt;int[]&gt;(){{<br/>    add(new int[] {1,20});<br/>    add(new int[] {5,15});<br/>    add(new int[] {7,18});<br/>    add(new int[] {3,25});<br/>}};<br/>list.stream().forEach(i -&gt; i[0] += 10);</span></pre><p id="7e22" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">是的，流也有一个<code class="du lm ln lo lc b">forEach()</code>实现，而且是一个终端操作！与java中典型的for-each循环一样，For each将遍历流并对每个项目执行一个操作。重要的是要注意有一个<code class="du lm ln lo lc b">collection.stream.forEach()</code>实现和一个<code class="du lm ln lo lc b">collection.forEach() </code>实现。它们非常相似，区别在于流中每个项目的处理顺序不是在流版本中定义的，而是在集合版本中定义的，因为它是为特定集合实现的。</p><h1 id="53f0" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">那么我为什么要使用Java流呢？</h1><p id="f23e" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">现在我们已经很好地理解了流是如何工作的，让我们回到最初的例子。除了这一次，让我们将它与我们在不使用Java流的情况下实现相同功能所编写的代码进行比较。</p><h1 id="9eb8" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">使用Java流的代码:</h1><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="4e35" class="lg kf hh lc b fi lh li l lj lk">protected static int example1(int numberOfMultiples){<br/>    return Stream.<em class="ll">iterate</em>(4, multipleOfFour -&gt; multipleOfFour + 4)<br/>            .limit(numberOfMultiples)<br/>            .map(multipleOfFour -&gt; multipleOfFour * multipleOfFour)<br/>            .filter(multipleOfFourSquared -&gt; multipleOfFourSquared % 10 == 0)<br/>            .reduce(0, Integer::<em class="ll">sum</em>);<br/>}</span></pre><h1 id="3cb0" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">不使用Java流的代码:</h1><pre class="ix iy iz ja fd lb lc ld le aw lf bi"><span id="9368" class="lg kf hh lc b fi lh li l lj lk">protected static int example2(int numberOfMultiples){<br/>    int sum = 0;<br/>    for (int multipleOfFour = 4; multipleOfFour &lt;= numberOfMultiples * 4; multipleOfFour += 4){<br/>        int multipleOfFourSquared = multipleOfFour * multipleOfFour;<br/>        if (multipleOfFourSquared % 10 == 0){<br/>            sum += multipleOfFourSquared;<br/>        }<br/>    }<br/>    return sum;<br/>}</span></pre><p id="5fbb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这只是一个很小的例子，但是它已经显示了流的许多优点。这包括不太冗长的代码、更直观的代码和不太容易出错的代码。</p><h1 id="f179" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">Java流的优势——代码更少</h1><p id="2b64" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">对于这个例子来说，使用streams减少了两行代码。根据我的经验，streams能够将一个15–20行的函数压缩成一个易于理解的3–4行代码并不罕见。</p><p id="ffb0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">你还会注意到，由于我们使用的所有lambda表达式，我们没有创建只存在于函数范围内的不必要的新变量。为了使没有流的代码可读，我们必须为整个For循环的运行总和创建一个新的整数，在for循环的声明中为4的倍数创建一个新的整数，并为4的平方的倍数创建一个整数。</p><h1 id="0e52" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">Java流的优势——更直观的代码</h1><p id="8663" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">使用流的另一个好处是代码最终更直观，需要更少的思考来理解正在发生的事情。您可以注意到，使用streams的代码看起来就像是计算过程中的一系列步骤。在没有流的示例中，您需要考虑for循环声明中的变量是什么，为什么我们要将它递增4，然后有时在递增之间，我们检查它的平方是否能被10整除，如果能，我们追加总和。我们开始将不同的功能混合在一起，而不是一步一步地进行计算，随着您使用的功能变得越来越复杂，这变得越来越难以推理。</p><h1 id="bc8c" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">Java流的优势——代码更少出错</h1><p id="d174" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">这方面的一个例子可以在&lt;= in the for-loop in the second example. It is very common to have for-loops that are exclusive in their comparison check, so a developer working on a function like this has a real chance of setting that comparison as </p><h1 id="eb6d" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">Wrapping It Up</h1><p id="5a45" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">To recap, in this article we went over:</p><ul class=""><li id="bf4f" class="lr ls hh jk b jl jm jo jp jr lt jv lu jz lv kd lw lx ly lz bi translated">Streams</li><li id="dc6f" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd lw lx ly lz bi translated">Lambda Expressions</li><li id="81a0" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd lw lx ly lz bi translated">Stream Creation</li><li id="d6f7" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd lw lx ly lz bi translated">Map, Filter, Reduce, and other examples of intermediate and terminal operations</li><li id="7ce5" class="lr ls hh jk b jl ma jo mb jr mc jv md jz me kd lw lx ly lz bi translated">Some of the pros of using streams</li></ul><p id="9c70" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Another important characteristic of streams is that intermediate operations are lazy, which means that a processing based on an intermediate operation will only be done if it is needed, which can be a significant optimization with streams. <a class="ae lp" href="https://stackify.com/streams-guide-java-8/" rel="noopener ugc nofollow" target="_blank">中看到，这篇文章有一个很棒的部分是关于java流中惰性求值是如何工作的</a>。</p><p id="fe17" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果您有兴趣深入研究，一个很好的起点是<a class="ae lp" href="https://javaconceptoftheday.com/java-8-stream-intermediate-and-terminal-operations/" rel="noopener ugc nofollow" target="_blank">学习更多的中级和终端操作</a>，并练习使用streams！如果你也想学习并行化，<a class="ae lp" href="https://www.youtube.com/watch?v=x5akmCWgGY0" rel="noopener ugc nofollow" target="_blank">肯尼斯·寇森的这个演讲</a>是关于并行流和可完成未来如何工作的一个很好且容易理解的解释。</p><p id="a489" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用Java中的流，您可以编写更优雅、无错误的Java代码，随着您使用流的技能的提高，您会发现某些操作变得更容易实现！</p></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><p id="f221" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ll">披露声明:2021首创一号。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p><p id="2751" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ll">原载于</em><a class="ae lp" href="https://www.capitalone.com/tech/software-engineering/java-streams-explained-simple-example/" rel="noopener ugc nofollow" target="_blank"><em class="ll">https://www.capitalone.com</em></a><em class="ll">。</em></p></div></div>    
</body>
</html>