<html>
<head>
<title>Optimizing Mendix when handling large volumes of data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理大量数据时优化Mendix</h1>
<blockquote>原文：<a href="https://medium.com/mendix/optimising-mendix-when-handling-large-volumes-of-data-5e4eb1a690d7?source=collection_archive---------0-----------------------#2020-04-29">https://medium.com/mendix/optimising-mendix-when-handling-large-volumes-of-data-5e4eb1a690d7?source=collection_archive---------0-----------------------#2020-04-29</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><div class=""/><figure class="fi fk is it iu iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ir"><img src="../Images/f97128665d30cf341416c3ca7aa00fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5imt3E9_BDpUZtK4RnF8g.png"/></div></div></figure><p id="07b0" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">通常在Mendix开发过程中，开发人员会遇到一个对数据库的查询，这个查询优化得很差。这通常是由复杂的业务需求和时间限制造成的。下面将讨论一个优化不好的查询的例子，以及如何解决这些问题以确保执行时间是最优的。</p><p id="2d64" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">一个项目的业务需求是创建一个自定义搜索，该搜索将返回满足给定标准的合同对象列表。这种定制搜索的第一次实现非常简单，并且完成了工作，但是当使用真实数量的数据对搜索进行彻底测试时，查询时间太长了——长达100秒！如果让这个查询在后台运行，它不会有问题，但是由于这是用户单击按钮的结果，挂起时间会对用户体验产生负面影响。搜索按钮必须重构。</p><p id="05ab" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">下面我们来看看在运行大量数据时，搜索时间是如何从100秒缩短到平均2-5秒的。</p><p id="9c13" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">这是正在使用的领域模型的简化版本:</p><figure class="ka kb kc kd fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff jz"><img src="../Images/0266d899ee40b400c4231373137cc164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uDU-P5f_rc3wS8r9.png"/></div></div></figure><p id="6cc0" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">该搜索有三个过滤器:</p><ul class=""><li id="1f61" class="ke kf hu bd b je jf ji jj jm kg jq kh ju ki jy kj kk kl km dt translated">运输</li><li id="76f3" class="ke kf hu bd b je kn ji ko jm kp jq kq ju kr jy kj kk kl km dt translated">材料</li><li id="1700" class="ke kf hu bd b je kn ji ko jm kp jq kq ju kr jy kj kk kl km dt translated">区域模板</li></ul><p id="e104" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">运输和材料是搜索的直接下拉列表，因为它们与数据库中已经存在的数据相关。区域模板筛选器面临挑战；用户必须能够添加一个特定的邮政编码区与该地区内选定的部门(基于英国的邮政编码区，区，和部门系统)。不止一个地区可以添加到搜索中，因为一个地区有10-100个邮政编码区，几个地区模板将导致搜索的总区数迅速增加。</p><p id="7e32" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ks">初始Mendix实施</strong></p><figure class="ka kb kc kd fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kt"><img src="../Images/35494de7e98ba3b253787e204258cbf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YCnqJSZC-1-Kz_K0.png"/></div></div></figure><p id="71cf" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ks"> 1。</strong>检索所有选中的区域模板。<br/>2<strong class="bd ks">。每个区域模板将检索他们的邮政编码区域。<br/> <strong class="bd ks"> 3。然后，每个邮政编码区检索其所有扇区。<br/> <strong class="bd ks"> 4。</strong>在每个扇区上迭代，将应用以下XPath约束:</strong></strong></p><figure class="ka kb kc kd fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ku"><img src="../Images/16baf90d573a0dd3930084247e1a6d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lBikKHkCLoYyuHSp.png"/></div></div></figure><p id="1795" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ks"> 5。</strong>迭代完每个区段后，返回合同行列表。</p><p id="6773" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">上面的XPath约束有八个约束，它们都是返回正确的合同行对象列表所必需的。前四个约束的问题是，它们都必须检查ContractLine_Contract与Contract对象上的属性的关联。此外，当有多个区域模板选择了10个扇区时，必须在每个区域模板和扇区上循环花费相当多的时间。</p><p id="d83b" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">应用以下变化来优化微流:</p><ul class=""><li id="ae39" class="ke kf hu bd b je jf ji jj jm kg jq kh ju ki jy kj kk kl km dt translated">将合同数据反规范化为合同行。反规范化是通过添加数据的冗余副本或对数据进行分组，以损失一些写入性能为代价，尝试提高数据库读取性能的过程。在这种情况下，将合同数据向下移动到合同行。</li><li id="46fc" class="ke kf hu bd b je kn ji ko jm kp jq kq ju kr jy kj kk kl km dt translated">AreaTemplate _ PostcodeSector关联已添加。这将用于避免每次都必须进行初始邮政编码区域检索。</li><li id="cc34" class="ke kf hu bd b je kn ji ko jm kp jq kq ju kr jy kj kk kl km dt translated">移除其中一个环。如Mendix最佳实践中所述，应避免嵌套循环，此处删除了服务区区域循环。现在可以使用上面添加的新关联来检索邮政编码部门。</li><li id="d80a" class="ke kf hu bd b je kn ji ko jm kp jq kq ju kr jy kj kk kl km dt translated">添加了ContractLine _ PostcodeSector关联。这将删除作为XPath一部分的contains(ServiceAddressPostcode，$ post desector/sector code)查询。</li></ul><p id="6e21" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ks">非规范化数据和应用关联</strong></p><p id="c50b" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">下面是经过上述更改的更新后的域模型:</p><figure class="ka kb kc kd fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kv"><img src="../Images/e789a2b04f27bf553b084f8c74509f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0tsN-eSl4-yhppem.png"/></div></div></figure><p id="9325" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">基于这些变化，一个全新的微流程诞生了:</p><figure class="ka kb kc kd fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kw"><img src="../Images/58d8714679da3220d794e221eafa8910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_PEx2oclzvE4YFD8.png"/></div></div></figure><p id="a20b" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ks"> 1。</strong>添加了一些日志，用于调试目的。<strong class="bd ks">2<br/>。</strong>现在，使用在区域模板和邮政编码部门之间添加的新关联，从一开始就可以检索邮政编码部门。</p><figure class="ka kb kc kd fq iv fe ff paragraph-image"><div class="fe ff kx"><img src="../Images/2a3b05e02bbf9d85b1dc334b296c6be8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/0*Hhb9JCF6KNJBW1Pf.png"/></div></figure><p id="4897" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ks"> 3。</strong>运输和物料在微流程开始时检索一次，并在数据库检索中引用，而不是每次都必须进行检索。</p><p id="ad92" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">使用反规格化数据检索更新的数据库:</p><figure class="ka kb kc kd fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff ky"><img src="../Images/a18b4b8317084e64f5e08dfac2230905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OwSEec6jHeM3L9Le.png"/></div></div></figure><p id="1f06" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">通过对数据进行反规范化并将包含内容移动到一个新的关联中，查询时间减少到了大约15-18秒。考虑到最初100秒的等待时间，这是一个巨大的改进，但是从用户体验的角度来看，15秒的等待时间仍然是相当长的时间。花费如此长时间的原因是因为邮政编码区的循环——每个地区10-100个区意味着这只会变得更糟；当前的解决方案不可扩展。</p><p id="db70" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated"><strong class="bd ks">进一步反规范化和Java动作内存过滤</strong>很明显，邮政编码扇区的数量是影响查询长度的因素，因此解决方案的最后一部分是消除邮政编码扇区上的循环。为了补救这一点，实现一些在邮政编码扇区上使用内存过滤的Java代码似乎是一个可行的选择；在此之前，还需要对域模型进行一些修改。</p><figure class="ka kb kc kd fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff kz"><img src="../Images/d439aa81c2bc4f69c6bf292b381117c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ut0Ci0ywX9XaR1-v.png"/></div></div></figure><p id="7501" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">在邮政编码区域和合同行之间添加了一个新的关联，并且邮政编码部门ID被非规范化为合同行。这个新的ID使合同行能够根据内存中的邮政编码部门列表进行过滤，在Java操作中使用以下代码:</p><figure class="ka kb kc kd fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff la"><img src="../Images/b7590bf7057df975b5324b9031c87883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Oywq_GCtkXRghz66.png"/></div></div></figure><p id="e102" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">Java操作需要传入一个邮政编码部门和合同行的列表，然后根据邮政编码部门列表中的对象ID过滤合同行ID，最后，它将返回一个符合所有先前选择的搜索标准的合同行列表。</p><figure class="ka kb kc kd fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lb"><img src="../Images/d3b7c883b0b8e956243d8d441a1d5585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jjydNzwRsd0MdL1U.png"/></div></div></figure><p id="94c2" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">这是微流的最终迭代，确保丢失邮政编码扇区循环。它也已经移回到原始微流的原始区域模板循环中。从业务使用的角度来看，需要选择一到五个区域，所以五次迭代在查询时间上不会太差。循环中仍有一些必要的检索，但这些都是合同行数据库检索和内存过滤java操作中所需要的:</p><figure class="ka kb kc kd fq iv fe ff paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="fe ff lc"><img src="../Images/cd50c7076bbca1d23c7911c9b4b52e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IuUIQRnVw5AujSJc.png"/></div></div></figure><p id="2ed0" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">最终的微流将查询时间减少到每个查询大约两秒钟。在产品负责人看来，这是一个巨大的成功，他们对优化的结果很满意。</p><p id="1bc5" class="pw-post-body-paragraph jc jd hu bd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hn dt translated">首先想到的是减少数据库调用的次数。这是成功的，但是由于要处理的数据量太大，必须向解决方案中添加另一部分。通常在创建应用程序时，最好避免使用非规范化的数据。如图所示，必须聚合大量数据会影响这种情况，作为可行解决方案的一部分，必须对数据进行反规范化。此外，由于Mendix中的检索是根据关联进行优化的，因此很好地使用实体之间的关联可以大大降低检索的过程强度。尽管如此，即使在非规范化之后，在用户体验方面仍然存在问题。这一部分的进一步优化是通过使用两个列表应用内存过滤来完成的，以消除对其中一个列表对象进行迭代的需要。</p></div></div>    
</body>
</html>