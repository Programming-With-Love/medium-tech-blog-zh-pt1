<html>
<head>
<title>Add the new ViewModel to your MVVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将新的视图模型添加到您的MVVM中</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/add-the-new-viewmodel-to-your-mvvm-36bfea86b159?source=collection_archive---------0-----------------------#2017-05-26">https://medium.com/google-developer-experts/add-the-new-viewmodel-to-your-mvvm-36bfea86b159?source=collection_archive---------0-----------------------#2017-05-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="er es hf"><img src="../Images/f7d72b3babf36b3cf91a013ab6618b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*NVNg3ln_GtXv0yhhgVPpzA.jpeg"/></div><figcaption class="hm hn et er es ho hp bd b be z dx"><a class="ae hq" href="https://www.flickr.com/photos/75487768@N04/16741949632" rel="noopener ugc nofollow" target="_blank">https://www.flickr.com/photos/75487768@N04/16741949632</a></figcaption></figure><div class=""/><p id="4f12" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">Google在I/O上宣布了一组<a class="ae hq" href="https://developer.android.com/topic/libraries/architecture/index.html" rel="noopener ugc nofollow" target="_blank">架构组件</a>。其中包括一个<code class="du jo jp jq jr b"><a class="ae hq" href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" rel="noopener ugc nofollow" target="_blank">ViewModel</a></code>，一个视图将绑定到的类，这样视图模型包含的数据将在屏幕旋转后继续存在。对于使用MVVM的开发者来说，这听起来棒极了。获得我们无论如何都需要的视图模型，并且能够经受住方向变化，这听起来好得不像是真的。</p><p id="048e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">但是，它能被轻松地应用到真实的word应用程序中吗？</p><p id="84b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我把我们在维亚康姆的Playplex应用程序带到了我们的shows screen，一个电视节目列表，它是Comedy Central等成功应用程序的基础。该实现已经基于MVVM，片段有一个ShowsViewModel，每个RecyclerView项有另一个视图模型。</p><h2 id="daff" class="js jt ht bd ju jv jw jx jy jz ka kb kc jb kd ke kf jf kg kh ki jj kj kk kl km bi translated">台阶</h2><p id="847e" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">我们需要做什么？<br/>如果您需要应用程序上下文，首先通过<code class="du jo jp jq jr b">ViewModel</code>或<code class="du jo jp jq jr b">AndroidViewModel</code>扩展您现有的视图模型类。</p><pre class="ks kt ku kv fd kw jr kx ky aw kz bi"><span id="28bb" class="js jt ht jr b fi la lb l lc ld">public class ShowsViewModel <strong class="jr hu">extends ViewModel</strong> {</span></pre><p id="6cb5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">接下来找到创建视图模型的地方，可能是在<code class="du jo jp jq jr b">Fragment</code>或<code class="du jo jp jq jr b">Activity</code>中，用对<code class="du jo jp jq jr b">ViewModelProviders</code>的方法调用替换模式的<code class="du jo jp jq jr b">new</code></p><pre class="ks kt ku kv fd kw jr kx ky aw kz bi"><span id="5176" class="js jt ht jr b fi la lb l lc ld">ShowsViewModel createViewModel() {<br/>    <strong class="jr hu">return </strong>ViewModelProviders.<em class="le">of</em>(<strong class="jr hu">this</strong>).get(ShowsViewModel.<strong class="jr hu">class</strong>);<br/>}</span></pre><p id="e0e5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这将为您创建一个或重用一个现有的。</p><h2 id="e26e" class="js jt ht bd ju jv jw jx jy jz ka kb kc jb kd ke kf jf kg kh ki jj kj kk kl km bi translated">但是如果…</h2><p id="dd19" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">但是您的构造函数可能不为空:</p><pre class="ks kt ku kv fd kw jr kx ky aw kz bi"><span id="bd05" class="js jt ht jr b fi la lb l lc ld">ShowsViewModel(ShowsUseCase useCase) {<br/>   this.useCase = useCase;<br/>}</span></pre><p id="5b32" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">怎么办？<br/>您可以实现一个知道如何创建视图模型的提供者工厂。这个人甚至可以使用依赖注入来获得你需要的一切。通过这种方式，您将创建视图模型的责任转移到一个单独的类中，这已经使您的代码变得更好了(<a class="ae hq" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>)。</p><pre class="ks kt ku kv fd kw jr kx ky aw kz bi"><span id="11d5" class="js jt ht jr b fi la lb l lc ld">class ShowsViewModelFactory <strong class="jr hu">implements ViewModelProvider.Factory</strong> {<br/><br/>    private final ShowsUseCase useCase;<br/><br/>    @Inject<br/>    public ShowsViewModelFactory(ShowsUseCase useCase) {<br/>       this.useCase = useCase;<br/>    }<br/><br/>   <strong class="jr hu"> @Override<br/>    public ShowsViewModel create(Class modelClass) {<br/>       </strong> return new ShowsViewModel(useCase);<strong class="jr hu"><br/>    }</strong><br/>}</span></pre><p id="1cbf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">并采用对<code class="du jo jp jq jr b">ViewModelProviders</code>的调用</p><pre class="ks kt ku kv fd kw jr kx ky aw kz bi"><span id="b134" class="js jt ht jr b fi la lb l lc ld">@Inject <strong class="jr hu">ShowsViewModelFactory factory;</strong><br/>...<br/>ShowsViewModel createViewModel() {<br/>    return<strong class="jr hu"> </strong>ViewModelProviders.<em class="le">of</em>(this<strong class="jr hu">,factory</strong>)<br/>                             .get(ShowsViewModel.class);<br/>}</span></pre><p id="cb5e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">就这样，你基本完成了！</p><h2 id="60b5" class="js jt ht bd ju jv jw jx jy jz ka kb kc jb kd ke kf jf kg kh ki jj kj kk kl km bi translated">不再有生命周期转发</h2><p id="ed48" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">但是可能你有一些清理的方法。如果您将生命周期事件从片段或活动转发到视图模型，这些可能会被删除。整个想法是，您不再关心这些，因为视图模型不会在配置更改时被破坏。</p><p id="37ce" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">不要担心，当活动被完全破坏时，您仍然有可能释放资源。简单地覆盖<code class="du jo jp jq jr b">onCleared()</code>来取消长时间运行的操作，例如:</p><pre class="ks kt ku kv fd kw jr kx ky aw kz bi"><span id="2af1" class="js jt ht jr b fi la lb l lc ld">@Override<br/>protected void onCleared() {<br/>    super.onCleared();<br/>    cleanupSubscriptions();<br/>}</span></pre><h2 id="4537" class="js jt ht bd ju jv jw jx jy jz ka kb kc jb kd ke kf jf kg kh ki jj kj kk kl km bi translated">保持流向正确</h2><p id="a1d1" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">我希望您从未将任何<code class="du jo jp jq jr b">View</code>或<code class="du jo jp jq jr b">Activity</code>传递到您的视图模型中。这会导致泄露，所以在任何情况下都要尽量避免，因为这也不是MVVM应该做的！</p><h2 id="e57f" class="js jt ht bd ju jv jw jx jy jz ka kb kc jb kd ke kf jf kg kh ki jj kj kk kl km bi translated">数据绑定</h2><p id="7cfc" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">那么用安卓数据绑定呢？有用吗？<br/>的确如此，来自Google 的<a class="ae hq" href="https://github.com/googlesamples/android-architecture-components/tree/master/BasicSample" rel="noopener ugc nofollow" target="_blank">基本样本已经建立在它的基础上。<br/>在数据绑定中，您有不同的实现方式来通知视图它所绑定到的项目的变化。<br/>您要么公开<code class="du jo jp jq jr b">ObservableField</code>的公共实例，要么将您的视图绑定到方法而不是字段，并手动使用<code class="du jo jp jq jr b">notifyPropertyChanged</code>来通知变更。如果你使用第一种方法，你不需要改变什么。第二种方法有点问题。这里你的类已经为通知代码扩展了<code class="du jo jp jq jr b">BaseObservable</code>一个很好的便利类。因为Java不允许多重继承，所以你不能同时拥有<code class="du jo jp jq jr b">ViewModel</code>和<code class="du jo jp jq jr b">BaseObservable</code>。但是不要担心，</a><a class="lf lg ge" href="https://medium.com/u/3c04ed009476?source=post_page-----36bfea86b159--------------------------------" rel="noopener" target="_blank"> Eric Richardson </a>在这里提出了一个(不那么)好的解决方法:</p><p id="e4bc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">从<code class="du jo jp jq jr b">BaseObservable</code>复制代码，让您的版本扩展<code class="du jo jp jq jr b">ViewModel</code>:</p><pre class="ks kt ku kv fd kw jr kx ky aw kz bi"><span id="1905" class="js jt ht jr b fi la lb l lc ld">public class BaseObservableViewModel <strong class="jr hu">extends ViewModel implements Observable</strong> {<br/><br/>    private transient PropertyChangeRegistry callbacks;<br/><br/>    public BaseObservableViewModel() {<br/>    }<br/><br/>   ...<br/>}</span></pre><p id="bd39" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这样你就得到两个世界。这就是你需要的所有变化。(<a class="lf lg ge" href="https://medium.com/u/e0a4c9469bb5?source=post_page-----36bfea86b159--------------------------------" rel="noopener" target="_blank"> Jose Alcérreca </a>承诺将来会修复它，所以把它看作是临时的解决方法)</p><h2 id="a1e9" class="js jt ht bd ju jv jw jx jy jz ka kb kc jb kd ke kf jf kg kh ki jj kj kk kl km bi translated">所有的事情？</h2><p id="97e6" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">那么您现在必须将所有的视图模型转移到新的类结构中吗？其实不是。让我们假设您在<code class="du jo jp jq jr b">RecyclerView</code>中为每个项目使用视图模型。这些可能没有保存单独的数据，但有一个更广泛的收集。这些小视图模型可以保持原样，只要它们没有被绑定到活动或片段的生命周期中。所以在这里要小心。</p><h2 id="0039" class="js jt ht bd ju jv jw jx jy jz ka kb kc jb kd ke kf jf kg kh ki jj kj kk kl km bi translated">结论</h2><p id="76a5" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">视图模型是我们MVVM实现中缺少的一环吗？我认为是这样的，迁移到it非常简单。</p></div></div>    
</body>
</html>