<html>
<head>
<title>Coroutines and RxJava — An Asynchronicity Comparison (Part 3): Transferring Stream of Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协程和rx Java——异步性比较(第3部分):传递价值流</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/coroutines-and-rxjava-an-asynchronicity-comparison-part-3-transferring-stream-of-values-e858f4233791?source=collection_archive---------0-----------------------#2018-04-19">https://medium.com/capital-one-tech/coroutines-and-rxjava-an-asynchronicity-comparison-part-3-transferring-stream-of-values-e858f4233791?source=collection_archive---------0-----------------------#2018-04-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/13b3174ae3db05277b80f85c13fbe15c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCYRO8cNTkIlAD7U7qpnHg.png"/></div></div></figure><div class=""/><h1 id="e06d" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="8ba2" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在这个博客系列中，我将比较<a class="ae kl" href="https://kotlinlang.org/docs/reference/coroutines.html" rel="noopener ugc nofollow" target="_blank"> Kotlin协同程序</a>和<a class="ae kl" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>，因为它们都试图解决Android开发中的一个常见问题:异步编程。</p><p id="6525" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">在<a class="ae kl" rel="noopener" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-1-asynchronous-programming-e726a925342a"> Part 1 </a>和<a class="ae kl" rel="noopener" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-2-cancelling-execution-199485cdf068"> Part 2 </a>中，我们学习了如何在后台执行重计算任务，以及如何取消它们。</p><p id="ba04" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">第3部分是关于<strong class="jp ht">转移价值流。</strong></p><p id="1984" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如果你想了解更多关于<strong class="jp ht"> <em class="kr">频道，题材，演员，broadcast Channels</em></strong><em class="kr">…</em>继续阅读！</p><h1 id="aedd" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">RxJava中的可观察对象</h1><p id="3f1b" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们可以用一个<a class="ae kl" href="http://reactivex.io/RxJava/javadoc/io/reactivex/Observable.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ht">可观测的</strong> </a>来传递价值流。在下面的例子中，我们可以看到如何向观察者(可观察对象的订阅者)发送五个项目。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2e10" class="lb iq hs kx b fi lc ld l le lf">Observable.create&lt;Int&gt; <strong class="kx ht">{ </strong>emitter <strong class="kx ht">-&gt;<br/>    </strong>for (i in 1..5) {<br/>        <strong class="kx ht">emitter.onNext(i)</strong><br/>    }<br/>    <strong class="kx ht">emitter.onComplete()<br/></strong>}</span></pre><p id="aed5" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们刚刚创建了一个信息源，它将向订阅它的观察者(订阅者)发出五个条目。</p><p id="be56" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们传递一个元素的方式是用<code class="du lg lh li kx b"><strong class="jp ht">emitter.onNext(i)</strong></code>。我们使用<code class="du lg lh li kx b"><strong class="jp ht">emitter.onComplete()</strong></code>来通知观察者我们已经完成了物品的发射。</p><p id="3dc4" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">记住，每次用户呼叫<code class="du lg lh li kx b">.subscribe()</code>时，<code class="du lg lh li kx b">Observable.create</code>代码将被再次执行。每个观察者都会收到不同的物体。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lj"><img src="../Images/d12ff844d1739039672dd1d6ff288e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jr1dv0NUVvCsO0Vhha29JA.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Observers subscribing at different times to the same Observable</figcaption></figure><p id="6d67" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们可以看到不同的观察者将如何得到五个不同的物体加上完成信号。我们如何用协程做同样的事情呢？我们要介绍<strong class="jp ht">渠道</strong>。</p><h1 id="e762" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">频道</h1><p id="6eea" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-channel/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ht">通道</strong> </a>是我们如何在协程中传输值流。</p><p id="5230" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">信道的类型为<em class="kr"> E，</em>，这是可以在信道中传输的元素类型。通道<strong class="jp ht">可以在不同的协程</strong>之间共享 <strong class="jp ht">，默认情况下，它们的<strong class="jp ht">容量为1 </strong>。</strong></p><p id="cdcd" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">通道实现了<a class="ae kl" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/core/kotlinx-coroutines-core/src/main/kotlin/kotlinx/coroutines/experimental/channels/Channel.kt" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ht">发送通道和</strong> </a>接收通道接口。让我们来看看他们的一些方法:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="9639" class="lb iq hs kx b fi lc ld l le lf">public interface <strong class="kx ht">SendChannel</strong>&lt;in E&gt; {<br/>    public suspend fun send(element: E)<br/>    public fun offer(element: E)<br/>    public fun close(cause: Throwable? = null): Boolean<br/>}</span><span id="c594" class="lb iq hs kx b fi lo ld l le lf">public interface <strong class="kx ht">ReceiveChannel</strong>&lt;out E&gt; {<br/>    public suspend fun receive(): E<br/>    public fun close(cause: Throwable? = null): Boolean<br/>}</span></pre><p id="4979" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">它们都公开了关闭通道的方法<code class="du lg lh li kx b"><strong class="jp ht">close(cause: Throwable? = null): Boolean</strong></code>。</p><blockquote class="lp"><p id="6cf3" class="lq lr hs bd ls lt lu lv lw lx ly kk dx translated">可以关闭一个通道。当这种情况发生时，您不能发送或接收来自它的元素。</p></blockquote><p id="b5bf" class="pw-post-body-paragraph jn jo hs jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ha bi translated">您可以使用方法<code class="du lg lh li kx b"><strong class="jp ht">send(element: E)</strong></code>向通道发送项目，并使用<code class="du lg lh li kx b"><strong class="jp ht">receive(): E</strong></code>从通道接收项目。正如你所注意到的，它们被标上了suspend修饰符。这意味着那些方法是<strong class="jp ht"> <em class="kr">挂起函数:</em> </strong>它们需要在一个协程内被调用(你可以用一个协程构建器来创建，就像我们在本系列的<a class="ae kl" rel="noopener" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-1-asynchronous-programming-e726a925342a">第1部分</a>中看到的那样)。</p><blockquote class="me mf mg"><p id="39a8" class="jn jo kr jp b jq km js jt ju kn jw jx mh ko ka kb mi kp ke kf mj kq ki kj kk ha bi translated"><strong class="jp ht">阻塞和暂停的区别</strong>？你可以<a class="ae kl" href="https://kotlinlang.org/docs/reference/coroutines.html#blocking-vs-suspending" rel="noopener ugc nofollow" target="_blank">阅读Kotlin文档的这一部分</a>来了解更多。</p></blockquote><p id="5621" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如果您试图从一个空通道调用<code class="du lg lh li kx b">receive</code>，调用该方法的协程将暂停执行，直到通道中有一个元素。同样，如果你在一个已满的通道上调用<code class="du lg lh li kx b">send</code>，调用该方法的协程将暂停，直到通道未满。</p><p id="edee" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如果您想向通道发送一个元素，并且在通道已满时不被挂起，您可以使用<code class="du lg lh li kx b"><strong class="jp ht">offer(element: E)</strong></code>。如你所见，这个方法不是一个挂起函数，所以<strong class="jp ht">没有必要在协程</strong>中调用这个方法。</p><blockquote class="me mf mg"><p id="b691" class="jn jo kr jp b jq km js jt ju kn jw jx mh ko ka kb mi kp ke kf mj kq ki kj kk ha bi translated">使用<code class="du lg lh li kx b">offer</code>的警告是，它不能保证元素会被添加到通道中。频道满了就不加了。</p></blockquote><p id="d236" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们来展示一些代码吧！如何创建一个渠道？</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="36ef" class="lb iq hs kx b fi lc ld l le lf">val channel = <em class="kr">Channel</em>&lt;Int&gt;()</span></pre><h2 id="4877" class="lb iq hs bd ir mk ml mm iv mn mo mp iz jy mq mr jd kc ms mt jh kg mu mv jl mw bi translated">发送对象</h2><p id="925e" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们刚刚创建了Int类型的<strong class="jp ht"> <em class="kr">通道</em> </strong>。它将能够传输整数流。我们如何发送一个值？</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="89b6" class="lb iq hs kx b fi lc ld l le lf"><em class="kr">launch </em>{<strong class="kx ht"><br/>    channel.send(</strong>1<strong class="kx ht">)<br/></strong>}</span></pre><p id="2764" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">在上面的例子中，我们用Coroutine builder<em class="kr">launch</em>创建了一个Coroutine，并向通道发送了一个元素。这是它的视觉表现:</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mx"><img src="../Images/1c6d05c6c316ad1871880bb5e98ff89b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xi5SZ35l_aNg5pNN7YmE3A.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Visual representation of a Channel with an element</figcaption></figure><p id="18c6" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">怎样才能消费这种元素？具有<code class="du lg lh li kx b">receive</code>功能。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="fa22" class="lb iq hs kx b fi lc ld l le lf"><em class="kr">launch </em>{<strong class="kx ht"><br/>    val value = channel.receive()<br/></strong>}</span></pre><p id="47b0" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们创建了另一个协程，并使用了之前创建的通道中的元素。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es my"><img src="../Images/b1a4e9fe7a4012deddbed40f72838acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBFjZu-cNSol0oMgRpxq6g.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Visual representation of a Channel with a consumed element</figcaption></figure><h2 id="a9ed" class="lb iq hs bd ir mk ml mm iv mn mo mp iz jy mq mr jd kc ms mt jh kg mu mv jl mw bi translated">发送多个对象</h2><p id="8552" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">如果我们想寄两件东西呢？</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2121" class="lb iq hs kx b fi lc ld l le lf">val channel = <em class="kr">Channel</em>&lt;Int&gt;()</span><span id="fd1e" class="lb iq hs kx b fi lo ld l le lf"><em class="kr">launch </em>{<strong class="kx ht"><br/>    channel.send(</strong>1<strong class="kx ht">)<br/>    channel.send(</strong>2<strong class="kx ht">)<br/></strong>}</span></pre><p id="009d" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">正如我们所料，协程将开始执行代码，对象1将被发送到通道。当它试图执行第二行时，<strong class="jp ht">它将暂停，直到对象1被消耗掉</strong>。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mz"><img src="../Images/d08cfa57e2afbd7b3e1b31c7667eaae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AIUOdjHw54V6Wm7GcQgwTg.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Coroutine suspended when Channel capacity is 0</figcaption></figure><p id="37fa" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如果我们创建另一个协程并使用该值，那么第一个协程将继续执行并发送第二个元素。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es na"><img src="../Images/da3583026e7ccbc35d5709bc5e3162a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BmKoCwkFkhYizHf-lXVPg.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">First coroutine has resumed execution and sent the second object to the Channel</figcaption></figure><h2 id="7ce8" class="lb iq hs bd ir mk ml mm iv mn mo mp iz jy mq mr jd kc ms mt jh kg mu mv jl mw bi translated">前一个RxJava示例使用了一个通道</h2><p id="38aa" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们怎样才能实现类似于我们在文章开头看到的RxJava例子的东西呢？</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2810" class="lb iq hs kx b fi lc ld l le lf">val channel = <em class="kr">Channel</em>&lt;Int&gt;()</span><span id="c8fc" class="lb iq hs kx b fi lo ld l le lf"><em class="kr">launch </em><strong class="kx ht">{<br/>    for</strong> (i in 1..5) {<br/>        <strong class="kx ht">channel.send(i)<br/>    </strong>}<br/><strong class="kx ht">}</strong></span></pre><p id="698d" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这是一个协程，它将通过一个简单的<code class="du lg lh li kx b">for</code>循环向通道发送五个元素。您可以通过以下方式使用这些元素:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f046" class="lb iq hs kx b fi lc ld l le lf"><em class="kr">launch </em>{<strong class="kx ht"><br/>    for (value in channel)</strong> {<br/>        consumeValue(value)<br/>    }<br/>}</span></pre><p id="7d78" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这个for循环将隐式调用<code class="du lg lh li kx b">channel.receive()</code>。</p><p id="b2f5" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这里发生了什么？由于信道容量为一…</p><ul class=""><li id="f25d" class="nb nc hs jp b jq km ju kn jy nd kc ne kg nf kk ng nh ni nj bi translated">第一个协程将发送第一个元素(<code class="du lg lh li kx b">channel.send(1)</code>)，并在试图执行<code class="du lg lh li kx b">channel.send(2)</code>时暂停，直到第二个协程(因为通道中没有元素而暂停)恢复执行并消耗第一个元素。</li><li id="c380" class="nb nc hs jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">一旦通道中有一个元素，第二个协程将恢复执行并使用该值。然后，它会暂停，直到通道中出现另一个元素。</li><li id="161b" class="nb nc hs jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">既然第二个协程已经使用了这个值，通道中就有了容量:第一个协程将再次继续发送第二个整数。</li></ul><blockquote class="me mf mg"><p id="b6fa" class="jn jo kr jp b jq km js jt ju kn jw jx mh ko ka kb mi kp ke kf mj kq ki kj kk ha bi translated">这两个协程将间歇地恢复和暂停，直到另一个协程进入并消耗/发送该值。</p></blockquote><p id="d551" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">当两个协程都执行完它们的暂停lambda时，这五个对象已经被消耗掉了。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es np"><img src="../Images/82addcf48d37568a428e7c9056d3677c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mAOyaefawYMErEQe4o9cFA.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Channel with 5 objects consumed</figcaption></figure><p id="97cc" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如果我们启动另一个协程，并希望使用通道中的元素，该怎么办？</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f7ec" class="lb iq hs kx b fi lc ld l le lf"><em class="kr">launch </em>{<strong class="kx ht"><br/>    consumeValue(channel.receive())<br/></strong>}</span></pre><p id="9cd8" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">该协程将被挂起，因为通道中没有元素。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nq"><img src="../Images/2590e209c632686fff643f5fb59ead93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bTd3j0IbVvkCs81wDytzjA.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Coroutine suspended since there are no elements in the channel</figcaption></figure><h2 id="749b" class="lb iq hs bd ir mk ml mm iv mn mo mp iz jy mq mr jd kc ms mt jh kg mu mv jl mw bi translated">与可观察值的差异</h2><p id="da1d" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">RxJava Observables有什么区别？RxJava Observables将在您每次订阅时执行<code class="du lg lh li kx b">Observable.create</code>中的代码。渠道不会发生这种情况。</p><blockquote class="lp"><p id="b1ba" class="lq lr hs bd ls lt lu lv lw lx ly kk dx translated">当您从通道中使用一个对象时，没有其他协程能够获得相同的对象</p></blockquote><h2 id="df4a" class="lb iq hs bd ir mk nr mm iv mn ns mp iz jy nt mr jd kc nu mt jh kg nv mv jl mw bi translated">缓冲通道</h2><p id="ac78" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">如前所述，默认情况下，通道的容量为1。您可以创建缓冲通道，使<strong class="jp ht">允许发送者在挂起</strong>之前发送多个元素。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="3b8d" class="lb iq hs kx b fi lc ld l le lf">val channel = <em class="kr">Channel</em>&lt;Int&gt;(<strong class="kx ht">3</strong>) // <strong class="kx ht">Channel of capacity 3</strong></span></pre><p id="37f1" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">您可以在构造函数中将容量指定为参数。这就是我们如何创建容量为三的通道。</p><h2 id="70a6" class="lb iq hs bd ir mk ml mm iv mn mo mp iz jy mq mr jd kc ms mt jh kg mu mv jl mw bi translated">转移元素的另一种方式:生产</h2><p id="5235" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">你可以使用<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/produce.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ht">协同生成器<em class="kr">产生</em> </strong> </a>来传输元素流。<strong class="jp ht"> <em class="kr">产生</em>创建一个带有内置通道的协程</strong>。</p><blockquote class="lp"><p id="5a9f" class="lq lr hs bd ls lt lu lv lw lx ly kk dx translated">Produce =协同程序+通道</p></blockquote><p id="f814" class="pw-post-body-paragraph jn jo hs jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ha bi translated">怎样才能用<strong class="jp ht"> <em class="kr">产生</em> </strong>？</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e81e" class="lb iq hs kx b fi lc ld l le lf">val publisher = <strong class="kx ht"><em class="kr">produce</em></strong>(capacity = 2)<em class="kr"> </em><strong class="kx ht">{<br/>    </strong>for (i in 1..5) <strong class="kx ht">send(i)</strong><br/><strong class="kx ht">}</strong></span></pre><p id="82b4" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><strong class="jp ht">用<em class="kr">生产</em>有什么好处？</strong></p><p id="1f46" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><strong class="jp ht">只有<em class="kr"> produce </em>内部的代码可以向通道</strong>发送元素，因此它可以防止其他协程在该通道上调用<code class="du lg lh li kx b">send</code>。这是因为produce只实现了<code class="du lg lh li kx b">ReceiveChannel&lt;E&gt;</code>接口:它限制了可以向通道发送元素的协程。<strong class="jp ht">这比创建一个通道对象</strong>更“安全”。</p><blockquote class="lp"><p id="4fcf" class="lq lr hs bd ls lt lu lv lw lx ly kk dx translated">生成是创建自定义操作符的一种非常有用的方式。</p></blockquote><p id="aa01" class="pw-post-body-paragraph jn jo hs jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ha bi translated">您可以像这样使用该通道中的值:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="74fd" class="lb iq hs kx b fi lc ld l le lf"><em class="kr">launch </em>{<strong class="kx ht"><br/>    </strong>publisher.<strong class="kx ht"><em class="kr">consumeEach</em></strong><em class="kr"> </em>{<strong class="kx ht"><br/>        </strong>consumeValue(<strong class="kx ht">it</strong>)<br/>    }<br/>}</span></pre><blockquote class="me mf mg"><p id="8ea2" class="jn jo kr jp b jq km js jt ju kn jw jx mh ko ka kb mi kp ke kf mj kq ki kj kk ha bi translated"><strong class="jp ht">当produce CoroutineBuilder执行完它的暂停lambda，并且通道中的元素被使用完之后，通道将自动关闭</strong></p></blockquote><h2 id="0861" class="lb iq hs bd ir mk ml mm iv mn mo mp iz jy mq mr jd kc ms mt jh kg mu mv jl mw bi translated">演员</h2><p id="50d3" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/actor.html" rel="noopener ugc nofollow" target="_blank">一个<strong class="jp ht"> <em class="kr">演员</em> </strong> </a>也会创建一个内置通道的协程。<strong class="jp ht"> <em class="kr">与</em> </strong>有什么区别？<em class="kr"> produce </em>实现了<code class="du lg lh li kx b">ReceiveChannel&lt;E&gt;</code>接口，而<em class="kr"> actor </em>实现了<code class="du lg lh li kx b">SendChannel&lt;E&gt;</code>接口。</p><blockquote class="lp"><p id="6c70" class="lq lr hs bd ls lt lu lv lw lx ly kk dx translated">只有由actor创建的协程可以使用通道中的元素。</p></blockquote><p id="508a" class="pw-post-body-paragraph jn jo hs jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ha bi translated"><strong class="jp ht">你可以把<em class="kr"> actor </em>想象成一个接收和处理元素</strong>的邮箱。因为协程中的代码是顺序执行的，所以一次只能处理一个元素。你怎么能创造一个呢？</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a267" class="lb iq hs kx b fi lc ld l le lf">val actor = <strong class="kx ht"><em class="kr">actor</em></strong>&lt;Int&gt;(CommonPool) {<br/>    for (<strong class="kx ht">int in channel</strong>) {<br/>        // iterate over received Integers<br/>    }<br/>}</span></pre><p id="072d" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">正如我们之前所说的，这个actor一次只会处理一个整数。<strong class="jp ht">怎样才能给演员送一个元素？</strong></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2ede" class="lb iq hs kx b fi lc ld l le lf"><em class="kr">launch </em>{<strong class="kx ht"><br/>    actor.send(2)</strong><br/>}</span></pre><h2 id="2135" class="lb iq hs bd ir mk ml mm iv mn mo mp iz jy mq mr jd kc ms mt jh kg mu mv jl mw bi translated">频道中的竞争条件</h2><p id="2b65" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">到目前为止，我们已经展示了简单的例子，只有一个发送者和一个消费者，不会给我们带来任何问题。如果有多个消费者和一个发送者，会发生什么？</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b1d1" class="lb iq hs kx b fi lc ld l le lf">val channel = <em class="kr">Channel</em>&lt;Int&gt;()</span><span id="5014" class="lb iq hs kx b fi lo ld l le lf"><em class="kr">launch </em><strong class="kx ht">{<br/>    </strong>val value1 = <strong class="kx ht">channel.receive()<br/>}</strong></span><span id="4c2c" class="lb iq hs kx b fi lo ld l le lf"><em class="kr">launch </em><strong class="kx ht">{<br/>    </strong>val value2 = <strong class="kx ht">channel.receive()<br/>}</strong></span><span id="f4f0" class="lb iq hs kx b fi lo ld l le lf"><em class="kr">launch </em><strong class="kx ht">{<br/>    channel.send(1)<br/>}</strong></span></pre><p id="7781" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">在上面的例子中…什么变量将包含值1？第一协程的<em class="kr">值1 </em>还是第二协程的<em class="kr">值2 </em>？我们不可能得到一致的结果。一个<strong class="jp ht">竞态条件</strong>即将发生。</p><p id="09ee" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如果你想把同一个对象发送给多个观察者，你需要一个<strong class="jp ht"> BroadcastChannel </strong>。</p><p id="c150" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们来看看RxJava做广播的方式:<strong class="jp ht">科目</strong>。</p><h1 id="5257" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">学科</h1><p id="112a" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">可以用RxJava做<strong class="jp ht">广播，主题</strong>。当您创建一个主题并发送一个元素时，所有订阅者将同时获得相同的对象。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0642" class="lb iq hs kx b fi lc ld l le lf">val subject: PublishSubject&lt;Int&gt; = PublishSubject.create()</span><span id="120a" class="lb iq hs kx b fi lo ld l le lf">subject.subscribe <strong class="kx ht">{<br/>    </strong>consumeValue(it)<br/><strong class="kx ht">}</strong></span><span id="9615" class="lb iq hs kx b fi lo ld l le lf">subject.subscribe <strong class="kx ht">{<br/>    </strong><em class="kr">println</em>(it)<br/><strong class="kx ht">}</strong></span></pre><p id="e119" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们创建了一个主题，并通过两个不同的观察者订阅了它。当我们发送一个带有<code class="du lg lh li kx b">subject.onNext(1)</code>的元素时，两个观察者会得到相同的对象。</p><p id="6ca7" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们如何对协程做同样的事情呢？</p><h1 id="77f0" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">广播频道</h1><p id="700b" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们可以用<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-broadcast-channel/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ht">broadcast channels</strong></a>实现同样的行为。它们向使用<strong class="jp ht"><em class="kr">open subscription</em></strong>方法监听元素的多个消费者发出相同的对象。</p><p id="4067" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">让我们创建一个广播频道。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7fd4" class="lb iq hs kx b fi lc ld l le lf">val channel = <em class="kr">BroadcastChannel</em>&lt;Int&gt;(2)</span></pre><p id="b423" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们如何消费发送到通道的元素？我们可以使用<strong class="jp ht"> openSubscription </strong>方法和扩展函数<strong class="jp ht"> <em class="kr">使用</em> </strong>来为我们处理订阅。当<strong class="jp ht"> <em class="kr">使用</em> </strong>中的暂停功能结束时，订阅将被关闭。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="95c8" class="lb iq hs kx b fi lc ld l le lf">val observer1Job = <em class="kr">launch </em>{<strong class="kx ht"><br/>    channel.openSubscription().<em class="kr">use</em></strong><em class="kr"> </em><strong class="kx ht">{ </strong>channel <strong class="kx ht">-&gt;<br/>        </strong>for (value in channel) {<br/>            consumeValue(value)<br/>        } <br/>        // subscription will be closed<br/>    }<br/>}</span></pre><p id="7a9b" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们可以从通道消费的另一种方式是使用扩展函数<strong class="jp ht"> consumeEach </strong>:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c063" class="lb iq hs kx b fi lc ld l le lf">val observer2Job = <em class="kr">launch </em>{<strong class="kx ht"><br/>    channel.<em class="kr">consumeEach</em></strong><em class="kr"> </em><strong class="kx ht">{ </strong>value <strong class="kx ht">-&gt;<br/>        </strong>consumeValue(value)<br/>    }<br/>}</span></pre><p id="604b" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><strong class="jp ht"> <em class="kr"> ConsumeEach </em> </strong>会打开一个订阅，消费通道发出的所有元素。</p><h2 id="84d6" class="lb iq hs bd ir mk ml mm iv mn mo mp iz jy mq mr jd kc ms mt jh kg mu mv jl mw bi translated"><strong class="ak">合并广播频道</strong></h2><p id="9352" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">合并是一种特殊的能力。<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental.channels/-conflated-broadcast-channel/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ht">合并的BroadcastChannel </strong> </a>的行为方式与<strong class="jp ht"> RxJava行为主体</strong>类似。那是什么意思？</p><p id="1d0d" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">观察者将收到信息源在订阅后发出的所有元素，还会收到观察者订阅前信息源发出的最后一项。</p><p id="188f" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">让我们来看一个例子:</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nw"><img src="../Images/6e0acc14b6f66fbf0cc99bcaab641526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKXEZwbYNyVWsxT-hf2l9w.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Resubscribing to a ConflatedBroadcastChannel</figcaption></figure><p id="151c" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">假设我们有一个合并的BroadcastChannel，其中一个观察者已经接收到两个对象。如果观察者关闭了订阅，当它再次订阅同一个频道时，<strong class="jp ht">它将接收到由频道</strong>发出的最后一个对象。</p><p id="f58a" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这种行为不仅发生在重新订阅的观察者身上，也发生在新的观察者身上。如果通道已经发出了一个项目，那么它们都将获得通道发出的最后一个项目。</p><h1 id="31d6" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">RxJava反压呢？</h1><p id="89db" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们还没有在协程部分讨论背压。在RxJava中，<strong class="jp ht">当信息源发送元素的速度快于观察者消耗元素的速度时，就会产生反压力</strong>。在协程中是如何处理的？</p><blockquote class="lp"><p id="8500" class="lq lr hs bd ls lt lu lv lw lx ly kk dx translated">缺省情况下，协程处理背压。</p></blockquote><p id="b4d9" class="pw-post-body-paragraph jn jo hs jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ha bi translated"><strong class="jp ht">我们不必担心协程中的背压</strong>。由于<code class="du lg lh li kx b">receive</code>和<code class="du lg lh li kx b">send</code>是暂停函数，当我们处于反压场景时，发送方将暂停，直到通道中有容量。</p><p id="1c33" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们可以说协程的行为类似于RxJava中的<code class="du lg lh li kx b">BackpressureStrategy.BUFFER</code>。</p><h1 id="387e" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">协程和RxJava比较</h1><p id="0a86" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们可以比较在本系列的这一部分中看到的不同术语。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nx"><img src="../Images/ff0bb0f18c5d4aecc3b1f2c8752b23e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EbB4TrR8l4r4AiuyvBL-Aw.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Coroutines and RxJava Sources of information comparison</figcaption></figure><p id="a48f" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">我们可以说一个可观察的是<strong class="jp ht">冷的</strong>，其余的项是<strong class="jp ht">热的</strong>。</p><blockquote class="lp"><p id="980a" class="lq lr hs bd ls lt lu lv lw lx ly kk dx translated">即使没有观察者监听事件，热点信息源也可以发送信息。</p></blockquote><p id="bd37" class="pw-post-body-paragraph jn jo hs jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ha bi translated">一个可观察物是冷的，因为只有当观察者订阅它时，它才会开始发射物品。</p><p id="9a28" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><strong class="jp ht">可观测量和信道是单播的</strong>,因为只有一个观测者将接收已发送的对象。但是，对于主题或广播频道，您可以将同一对象发送给多个观察者。</p><h2 id="f139" class="lb iq hs bd ir mk ml mm iv mn mo mp iz jy mq mr jd kc ms mt jh kg mu mv jl mw bi translated">协程的冷可观察行为？</h2><p id="3cbe" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">如何用协程得到一个冷可观察的行为？您还记得coroutine builder<em class="kr">produce</em>创建了一个内置通道的coroutine吗？</p><p id="109d" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">您可以使用<a class="ae kl" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-reactive/kotlinx.coroutines.experimental.reactive/publish.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ht"> <em class="kr">发布</em> </strong> </a> <strong class="jp ht"> </strong>并像使用<em class="kr">产生</em>一样使用它。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="fed6" class="lb iq hs kx b fi lc ld l le lf">val publisher = <strong class="kx ht"><em class="kr">publish</em></strong><em class="kr"> </em><strong class="kx ht">{<br/>    </strong>for (i in 1..5) <strong class="kx ht">send(i)</strong><br/><strong class="kx ht">}</strong></span></pre><p id="213c" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">不同的是<strong class="jp ht">每次你想从频道中消费元素，你会看到不同的对象</strong>。</p><p id="1367" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">但是这里有一个警告，<em class="kr"> publish </em>不是标准协程库的一部分。你必须导入<a class="ae kl" href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-rx2" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ht">协程和RxJava互操作库</strong> </a>。</p><p id="c5c7" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">想了解这个互操作库的更多信息吗？您必须等待下周发布的本系列的第4部分。</p></div><div class="ab cl ny nz go oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ha hb hc hd he"><h1 id="97a7" class="ip iq hs bd ir is of iu iv iw og iy iz ja oh jc jd je oi jg jh ji oj jk jl jm bi translated">接下来会发生什么？</h1><p id="5958" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在本系列的第四部分中，我们将看到如何手动使用RxJava和协程。协程和RxJava互操作库将允许我们在同一个项目中连接和使用它们。</p></div><div class="ab cl ny nz go oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ha hb hc hd he"><h1 id="c1cd" class="ip iq hs bd ir is of iu iv iw og iy iz ja oh jc jd je oi jg jh ji oj jk jl jm bi translated">更多教育</h1><p id="2fe6" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">你错过了<strong class="jp ht">第一部分</strong>还是<strong class="jp ht">第二部分</strong>？</p><div class="hg hh ez fb hi ok"><a rel="noopener follow" target="_blank" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-1-asynchronous-programming-e726a925342a"><div class="ol ab dw"><div class="om ab on cl cj oo"><h2 class="bd ht fi z dy op ea eb oq ed ef hr bi translated">协程和rx Java——异步比较(第1部分):异步编程</h2><div class="or l"><h3 class="bd b fi z dy op ea eb oq ed ef dx translated">第1部分—异步编程</h3></div><div class="os l"><p class="bd b fp z dy op ea eb oq ed ef dx translated">medium.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ho ok"/></div></div></a></div><div class="hg hh ez fb hi ok"><a rel="noopener follow" target="_blank" href="/@manuelvicnt/coroutines-and-rxjava-an-asynchronicity-comparison-part-2-cancelling-execution-199485cdf068"><div class="ol ab dw"><div class="om ab on cl cj oo"><h2 class="bd ht fi z dy op ea eb oq ed ef hr bi translated">协程和rx Java——异步比较(第2部分):取消执行</h2><div class="or l"><h3 class="bd b fi z dy op ea eb oq ed ef dx translated">第2部分—取消执行</h3></div><div class="os l"><p class="bd b fp z dy op ea eb oq ed ef dx translated">medium.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy ho ok"/></div></div></a></div><p id="455b" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如果您想了解更多关于RxJava的知识，请查阅这篇文章。</p><div class="hg hh ez fb hi ok"><a rel="noopener follow" target="_blank" href="/capital-one-developers/rxjava2-android-mvvm-lifecycle-app-structure-with-retrofit-2-cf903849f49e"><div class="ol ab dw"><div class="om ab on cl cj oo"><h2 class="bd ht fi z dy op ea eb oq ed ef hr bi translated">RxJava 2: Android MVVM生命周期应用程序结构与改进2</h2><div class="or l"><h3 class="bd b fi z dy op ea eb oq ed ef dx translated">自从我写了关于MVVM、RxJava和翻新的文章已经两年多了。我们来更新一下。</h3></div><div class="os l"><p class="bd b fp z dy op ea eb oq ed ef dx translated">medium.com</p></div></div><div class="ot l"><div class="pa l ov ow ox ot oy ho ok"/></div></div></a></div><p id="7c2e" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">感谢阅读，</p><p id="d7e0" class="pw-post-body-paragraph jn jo hs jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">曼努埃尔·维森特Vivo</p></div></div>    
</body>
</html>