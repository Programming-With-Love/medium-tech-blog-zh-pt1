<html>
<head>
<title>League of Legends Optimizer using Oracle Cloud Infrastructure: Real-Time predictions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Oracle云基础设施的英雄联盟优化器:实时预测</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/league-of-legends-optimizer-using-oracle-cloud-infrastructure-real-time-predictions-58aa36127db6?source=collection_archive---------0-----------------------#2022-03-29">https://medium.com/oracledevs/league-of-legends-optimizer-using-oracle-cloud-infrastructure-real-time-predictions-58aa36127db6?source=collection_archive---------0-----------------------#2022-03-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="c22d" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">回顾和介绍</h1><p id="090f" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">欢迎来到英雄联盟优化器系列第五篇！</p><p id="fe43" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在本文中，我们将测试我们在本系列文章中所做的所有工作。我们将看到我们创建的这些模型如何做出有意义的预测。简而言之，我们将在我的一个游戏中有一个英雄联盟伙伴，我们将能够看到该模型如何反映游戏在任一点的状态，并能够预测游戏的结果(无论是赢还是输)。所以，事不宜迟，让我们开始吧。</p><h1 id="a9e4" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">连接到实时客户端数据API</h1><p id="a855" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">为了提取实时游戏信息，我们需要从Riot Games访问实时客户端数据API。</p><p id="10ff" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">联盟客户端API包含一组协议，CEF (Chromium Embedded Framework)使用这些协议在英雄联盟进程和C++库之间进行通信。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/3edc7d7713fc5b8e678439a3c5289cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*Zg5IxOS9GSfeQn0A"/></div></figure><p id="91c5" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">CEF和这个C++库之间的通信发生在本地，所以我们必须使用localhost作为我们的连接端点。您可以在此处找到关于此通信<a class="ae kn" href="https://developer.riotgames.com/docs/lol" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p><p id="153e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">您也可以参考第4篇文章，在那里我解释了我们在使用Live Client Data API时遇到的最有趣的端点。</p><p id="79fa" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">对于本文，我们将使用以下端点:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="c86b" class="kt if hh kp b fi ku kv l kw kx"># GET https://127.0.0.1:2999/liveclientdata/allgamedata<br/># Sample output can be found in the following URL, if interested. https://static.developer.riotgames.com/docs/lol/liveclientdata_sample.json<br/># This endpoint encapsulates all other endpoints into one.</span></pre><p id="babe" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">当我们加入一个英雄联盟游戏时，联盟进程打开端口2999。我们将利用这一点，我们将反复请求localhost:2999提取实时比赛信息，并将其合并到我们的ML管道中。我们的ML模型的结果将告诉我们是否可能赢或输。</p><h1 id="8b17" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">体系结构</h1><p id="bc8d" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">为了正确地发出请求，我们需要访问localhost作为调用端点。然而，我们可能不希望访问我们正在玩的本地计算机上的数据(因为计算机资源应该被用来获得最大的游戏性能)。为此，我创建了一个使用<strong class="je hi">消息队列</strong>的架构，允许我们从互联网上的任何机器发出请求。</p><p id="248b" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">对于这个架构提案，我已经创建了两个文件，您可以在本系列文章的<a class="ae kn" href="https://github.com/oracle-devrel/leagueoflegends-optimizer" rel="noopener ugc nofollow" target="_blank">官方资源库的src/ section下找到它们:live_client_producer.py和live_client_receiver.py</a></p><h1 id="5283" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">生产者</h1><p id="fb21" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">生产者负责向本地主机发出请求并存储它们，而自己不做任何预测。这背后的想法是让我们玩联赛的计算机尽可能地卸载并专注于比赛，而不增加由进行ML预测引起的额外复杂性(这可能占用相当多的资源)。</p><p id="f1ec" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">因此，我们这样声明我们的生产者的主要部分:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="ba81" class="kt if hh kp b fi ku kv l kw kx">while True:<br/>    try:<br/>        # We access the endpoint we mentioned above in the article<br/>        response = requests.get('https://127.0.0.1:2999/liveclientdata/allgamedata', verify=False)<br/>    except requests.exceptions.ConnectionError:<br/>        # Try again every 5 seconds<br/>        print('{} | Currently not in game'.format(datetime.datetime.now()))<br/>        time.sleep(5)<br/>        continue</span><span id="6de9" class="kt if hh kp b fi ky kv l kw kx">    # Send to RabbitMQ queue.<br/>    if response.status_code != 404:<br/>        to_send = build_object(response.content)<br/>        send_message('live_client', to_send)<br/>    time.sleep(30) # wait 30 seconds before making another request</span></pre><p id="17df" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们需要考虑到，如果我们不在游戏中，我们会得到一个ConnectionError异常。为了避免这种硬件中断，我们捕捉异常并不断向端点发出请求，直到有用的东西出现。</p><p id="ee3e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">为此，我选择了<strong class="je hi"> RabbitMQ消息队列</strong>，这是一个非常简单有效的解决方案，可以将我们的结果存储到一个队列中。这确保了以下几点:</p><ul class=""><li id="694c" class="kz la hh je b jf ka jj kb jn lb jr lc jv ld jz le lf lg lh bi translated">从任何IP地址访问和使用队列中的数据，而不仅仅是本地主机</li><li id="bd1c" class="kz la hh je b jf li jj lj jn lk jr ll jv lm jz le lf lg lh bi translated">如果我们需要对我们的预测进行时间序列可视化，消息顺序是有保证的。因此，我们声明我们的消息队列。</li></ul><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="806d" class="kt if hh kp b fi ku kv l kw kx">_MQ_NAME = 'live_client'</span><span id="8bd1" class="kt if hh kp b fi ky kv l kw kx">credentials = PlainCredentials('league', 'league')<br/>connection = pika.BlockingConnection(<br/>pika.ConnectionParameters(<br/>    '{}'.format(args.ip),<br/>    5672,<br/>    '/',<br/>    credentials))</span><span id="7487" class="kt if hh kp b fi ky kv l kw kx">channel = connection.channel()<br/>channel.queue_declare(queue=_MQ_NAME)</span></pre><p id="d240" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">注意，在上面的代码片段中，我们需要创建一个<strong class="je hi"> PlainCredentials </strong>对象，否则从公共网络到生产者所在的IP地址的认证将会失败。<a class="ae kn" href="https://programmerall.com/article/92801023802/" rel="noopener ugc nofollow" target="_blank">查看这篇文章</a>，了解如何为我们新创建的用户设置虚拟主机、认证和权限。</p><p id="deca" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">此外，每个传入的对象都需要被处理并“转换”成ML管道所期望的相同结构:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="3b23" class="kt if hh kp b fi ku kv l kw kx"># We remove useless data like items (which also cause quotation marks issues in JSON deserialization)<br/>def build_object(content):<br/>    # We convert to JSON format<br/>    content = response.json()<br/>    for x in content['allPlayers']:<br/>        del x['items'] # delete items to avoid quotation marks<br/>    built_obj = {<br/>        'activePlayer': content['activePlayer'],<br/>        'allPlayers': content['allPlayers']<br/>    }<br/>    content = json.dumps(content)<br/>    content = content.replace("'", "\"") # for security, but most times it's redundant.<br/>    print(content)<br/>    return content # content will be a string due to json.dumps()</span></pre><p id="0766" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">最后，我们声明一个函数，该函数以字符串格式接收<strong class="je hi">消息</strong>，并将其插入消息队列，以备使用。</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="5cbe" class="kt if hh kp b fi ku kv l kw kx">def send_message(queue_name, message):<br/>    channel.basic_publish(exchange='', routing_key=queue_name, body='{}'.format(message))<br/>    print('{} | MQ {} OK'.format(datetime.datetime.now(), message))</span></pre><p id="5052" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">由于我们已经构建了消息队列生成器，如果我们在游戏中运行它，我们不断增长的消息队列将存储消息，即使没有人决定“消费”它们并进行预测。现在，我们需要通过<strong class="je hi">消费者</strong>来完成这项工作。</p><h1 id="069e" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">消费者</h1><p id="5069" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在消费者中，我们将连接到RabbitMQ服务器。这个服务器不一定需要位于我们运行生产者模块的地方。它可以在任何地方，就像Apache web服务器一样。只是要确保生产者和消费者中的连接都指向RabbitMQ的同一个服务器IP地址。我们将使用我们在第4篇文章中训练的轻型模型(使用来自原始数据集的50.000行进行训练，因为使用更大的模型会产生更高的预测时间)进行预测:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="86ca" class="kt if hh kp b fi ku kv l kw kx"># We load the AutoGluon model.<br/>save_path = args.path  # specifies folder to store trained models<br/>_PREDICTOR = TabularPredictor.load(save_path)</span><span id="31b8" class="kt if hh kp b fi ky kv l kw kx">def main():<br/>    try:<br/>        # localhost if the rabbitmq server is located in the same machine as the receiver.<br/>        connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost', heartbeat=600, blocked_connection_timeout=300))<br/>        channel = connection.channel()</span><span id="18e0" class="kt if hh kp b fi ky kv l kw kx">        # declare queue, in case the receiver is initialized before the producer.<br/>        channel.queue_declare(queue='live_client')</span><span id="17d9" class="kt if hh kp b fi ky kv l kw kx">        def callback(ch, method, properties, body):<br/>            print('{} | MQ Received packet'.format(datetime.datetime.now()))<br/>            process_and_predict(body.decode())</span><span id="2817" class="kt if hh kp b fi ky kv l kw kx">        # consume queue<br/>        channel.basic_consume(queue='live_client', on_message_callback=callback, auto_ack=True)</span><span id="6ec3" class="kt if hh kp b fi ky kv l kw kx">        print(' [*] Waiting for messages. To exit press CTRL+C')<br/>        channel.start_consuming() # we listen 24/7 for new messages in the live_client queue<br/>    except pika.exceptions.StreamLostError:<br/>        connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost', heartbeat=600, blocked_connection_timeout=300))</span></pre><p id="a1b3" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">注意:如果您遇到“连接重置”错误，<a class="ae kn" href="https://pika.readthedocs.io/en/stable/examples/heartbeat_and_blocked_timeouts.html" rel="noopener ugc nofollow" target="_blank">请查看pika </a>上的这篇文档，它向pika ConnectionParameters对象添加了一些参数，以确保良好的连接。</p><p id="7518" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">每当我们使用队列中的一条消息时，我们通过调用<strong class="je hi"> process_and_predict </strong>使用我们的自动引导模型来预测结果:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="c71e" class="kt if hh kp b fi ku kv l kw kx">def process_and_predict(input):</span><span id="e32e" class="kt if hh kp b fi ky kv l kw kx">    json_obj = json.loads(input)<br/>    team_color = str()<br/>    for x in json_obj['allPlayers']:<br/>        if x['team'] == 'ORDER':<br/>            team_color = 'blue'<br/>        else:<br/>            team_color = 'red'</span><span id="91a4" class="kt if hh kp b fi ky kv l kw kx">        print('Team {}: {}'.format(team_color, x['championName']))</span><span id="976f" class="kt if hh kp b fi ky kv l kw kx">    # Timestamp given by the Live Client API is in thousands of a second from the starting point.</span><span id="a472" class="kt if hh kp b fi ky kv l kw kx">    timestamp = int(json_obj['gameData']['gameTime'] * 1000)<br/>    data = [<br/>        json_obj['activePlayer']['championStats']['magicResist'],<br/>        json_obj['activePlayer']['championStats']['healthRegenRate'],<br/>        json_obj['activePlayer']['championStats']['spellVamp'],<br/>        timestamp,<br/>        json_obj['activePlayer']['championStats']['maxHealth'],<br/>        json_obj['activePlayer']['championStats']['moveSpeed'],<br/>        json_obj['activePlayer']['championStats']['attackDamage'],<br/>        json_obj['activePlayer']['championStats']['armorPenetrationPercent'],<br/>        json_obj['activePlayer']['championStats']['lifeSteal'],<br/>        json_obj['activePlayer']['championStats']['abilityPower'],<br/>        json_obj['activePlayer']['championStats']['resourceValue'],<br/>        json_obj['activePlayer']['championStats']['magicPenetrationFlat'],<br/>        json_obj['activePlayer']['championStats']['attackSpeed'],<br/>        json_obj['activePlayer']['championStats']['currentHealth'],<br/>        json_obj['activePlayer']['championStats']['armor'],<br/>        json_obj['activePlayer']['championStats']['magicPenetrationPercent'],<br/>        json_obj['activePlayer']['championStats']['resourceMax'],<br/>        json_obj['activePlayer']['championStats']['resourceRegenRate']<br/>    ]</span><span id="1f6a" class="kt if hh kp b fi ky kv l kw kx">    # We build the structure as our ML pipeline expects it (column names, and order).<br/>    sample_df = pd.DataFrame([data], columns=['magicResist', 'healthRegenRate', 'spellVamp', 'timestamp', 'maxHealth',<br/>        'moveSpeed', 'attackDamage', 'armorPenetrationPercent', 'lifesteal', 'abilityPower', 'resourceValue', 'magicPenetrationFlat',<br/>        'attackSpeed', 'currentHealth', 'armor', 'magicPenetrationPercent', 'resourceMax', 'resourceRegenRate'])<br/>    prediction = _PREDICTOR.predict(sample_df)<br/>    pred_probs = _PREDICTOR.predict_proba(sample_df)</span><span id="270e" class="kt if hh kp b fi ky kv l kw kx">    expected_result = prediction.get(0)<br/>    if expected_result == 0:<br/>        print('Expected LOSS, {}% probable'.format(pred_probs.iloc[0][0] * 100))<br/>    else:<br/>        print('Expected WIN, {}% probable'.format(pred_probs.iloc[0][1] * 100))</span><span id="c8b4" class="kt if hh kp b fi ky kv l kw kx">    print('Win/loss probability: {}%/{}%'.format(<br/>        pred_probs.iloc[0][1] * 100,<br/>        pred_probs.iloc[0][0] * 100<br/>    ))</span></pre><p id="f18f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这是让一切正常工作所需的最后一段代码。现在，我们可以进入一个游戏，运行我们的生产者代码(在我们玩联赛的机器上)和消费者代码(同时，虽然不是必须的)来获得游戏的实时预测。</p><h1 id="5608" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">设置</h1><p id="ccb0" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们初始化生产者和消费者流程:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="4b57" class="kt if hh kp b fi ku kv l kw kx"># producer must be run in the same server as where we're playing League<br/>python live_client_producer.py --ip="RABBITMQ_IP_ADDRESS"<br/># in this case, receiver is running in localhost (in the same server as the rabbitmq server).<br/>python live_client_receiver.py --ip="RABBITMQ_IP_ADDRESS" -p="MODEL_PATH"</span></pre><h1 id="c84b" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">游戏！</h1><p id="217d" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">由于我使用轻量级模型来进行预测，并且训练数据只有50000行，所以我预计结果会大致不准确。因此，为了让事情变得明显并展示其功能，我选择在练习工具中与一个AI机器人进行一场联赛。这将允许我快速升级，并从练习工具中购买黄金物品，这将花费我大约30到35分钟的时间。</p><p id="a3da" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我选择了Ezreal，买了一个标准的混合AD-AP版本，这在游戏后期特别好，因为冷却时间的减少会让你变成一个怪物，敌人很难用我的e来抓住我。</p><p id="0498" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">从生产者的角度来看，我们每30秒发出一次请求，并期待一次预测。这是我们存储的数据类型，然后从我们的消息队列中使用:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es ln"><img src="../Images/39ec6fb78ac8801936c5c41b0b249b46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bDk5ou5Va7_XxeFz"/></div></div></figure><p id="b960" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">当我们开始游戏时，我们得到一个非常平均的60/40的胜率概率。这是因为如果我们保持距离，Ezreal通常在早期游戏中优于Miss Fortune。由于训练数据来自真正的大师+玩家，通常游戏开始时非常安静，玩家直到游戏中期都表现得非常安全。所以Ezreal以更大的胜率概率开局是有道理的。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ls"><img src="../Images/72a34db83b1ec4fbc47af91078ef4eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/0*cIHQF2WtfIIP_B3A"/></div></figure><p id="1a6f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在开始游戏后，因为我们在练习工具中，我选择了完全构建并从商店购买所有物品(标准的AD-AP构建)。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lt"><img src="../Images/852fdd67feaf42bc7940f10a82242054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AMLSaqR9AZ0zoVUP"/></div></div></figure><p id="746a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在下一个请求之后，HTTP请求立即向模型提供我的当前统计数据，这些数据在游戏开始时严重不足。如果我们回顾一下我们的模型所考虑的统计数据，它们是:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="9e50" class="kt if hh kp b fi ku kv l kw kx"># Code from where we built the model<br/>sample_df = pd.DataFrame([data], columns=['magicResist', 'healthRegenRate', 'spellVamp', 'timestamp', 'maxHealth',<br/>        'moveSpeed', 'attackDamage', 'armorPenetrationPercent', 'lifesteal', 'abilityPower', 'resourceValue', 'magicPenetrationFlat',<br/>        'attackSpeed', 'currentHealth', 'armor', 'magicPenetrationPercent', 'resourceMax', 'resourceRegenRate'])</span></pre><p id="368a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">因此，对于特定时间戳，任何被视为四分位范围异常值的统计数据都会导致模型将其视为异常，并最终返回一个有利于获胜的预测。在我的建造中，我故意增加我的移动速度，攻击伤害，护甲穿透，生命，能力，攻击速度，最大法力值和魔法穿透百分比。为了让这一点更清楚，我还在我的匹配等级上增加了17级，这反过来增加了我的魔法抗性，护甲和最大生命值。这将“欺骗”我的模型，让它看到在我玩游戏的过程中，我所有的值都远远高于平均水平。</p><p id="e788" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">因此，预测的胜率飙升至70%左右，并在比赛的剩余时间里保持不变:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lu"><img src="../Images/00b12a08b933263d284a51ce39d284fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/0*a0oo3sKhfDUO7qXx"/></div></figure><p id="25cd" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">由于我只考虑玩家统计，杀死我的人工智能对手并没有给我任何额外的获胜概率，如杀死，助攻，死亡，视觉得分等。在这个模型中没有被考虑。还要注意，进行预测的模型仅使用50，000行进行训练，而不是我们的<strong class="je hi">更大的</strong>模型中的数千万行。当然，如果我们使用更大的模型，预测会产生更好的结果；我们在本文中没有这样做，因为预测时间会显著增加。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="er es lv"><img src="../Images/56b778e5fb627d3badf8950511e8f253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zfEILPgOKyZtZQVi"/></div></div></figure><p id="fc99" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我把这个任务(有了这个系列文章的<a class="ae kn" href="https://github.com/oracle-devrel/leagueoflegends-optimizer" rel="noopener ugc nofollow" target="_blank">官方知识库中的所有可用数据，这个任务应该会很有趣)留给你:尝试通过添加更多变量来改进当前的模型，比如:</a></p><ul class=""><li id="aef3" class="kz la hh je b jf ka jj kb jn lb jr lc jv ld jz le lf lg lh bi translated">杀死</li><li id="81f4" class="kz la hh je b jf li jj lj jn lk jr ll jv lm jz le lf lg lh bi translated">死亡</li><li id="fb2e" class="kz la hh je b jf li jj lj jn lk jr ll jv lm jz le lf lg lh bi translated">助攻</li><li id="4af8" class="kz la hh je b jf li jj lj jn lk jr ll jv lm jz le lf lg lh bi translated">视力评分</li><li id="a3f7" class="kz la hh je b jf li jj lj jn lk jr ll jv lm jz le lf lg lh bi translated">人群控制得分</li><li id="3089" class="kz la hh je b jf li jj lj jn lk jr ll jv lm jz le lf lg lh bi translated">玩家级别</li></ul><p id="87dc" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">欢迎您对资源库做出开源贡献！通过Developer Relations @ Oracle与我们一起进入开源世界永远都不晚。</p><p id="e5e9" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我真的希望你喜欢阅读和学习这个系列的英雄联盟。我们在几个月内从零开始构建了一些真正令人惊叹的东西。</p><h1 id="1223" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">我如何开始学习OCI？</h1><p id="e969" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">请记住，你可以随时免费注册OCI！您的Oracle Cloud帐户提供多项始终免费的服务和价值300美元的免费试用，可用于所有符合条件的OCI服务，最长30天。这些永远免费的服务在<strong class="je hi">无限期</strong>内有效。免费试用服务可能会一直使用到您的300美元免费点数用完或30天到期，以先到者为准。你可以<a class="ae kn" href="https://signup.cloud.oracle.com/?language=en&amp;sourceType=:ow:de:te::::&amp;intcmp=:ow:de:te::::" rel="noopener ugc nofollow" target="_blank">在这里免费注册</a>。</p><h1 id="648b" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">加入对话！</h1><p id="451d" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">如果你对Oracle开发人员在他们的自然环境中发生的事情感到好奇，请加入我们的公共休闲频道！我们不介意成为你的鱼缸🐠</p><h1 id="a2c7" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">许可证</h1><p id="d7c7" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">由<a class="ae kn" href="https://www.linkedin.com/in/ignacio-g-martinez/" rel="noopener ugc nofollow" target="_blank">伊格纳西奥·吉尔勒莫·马丁内兹</a><a class="ae kn" href="https://github.com/jasperan" rel="noopener ugc nofollow" target="_blank">@贾斯珀兰</a>撰写，由<a class="ae kn" href="https://www.linkedin.com/in/dawsontech/" rel="noopener ugc nofollow" target="_blank">艾琳·道森</a>编辑</p><p id="8042" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">版权所有2021 Oracle和/或其附属公司。</p><p id="8831" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">根据通用许可许可证(UPL)1.0版进行许可。</p><p id="c89d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">详见<a class="ae kn" href="https://github.com/oracle-devrel/leagueoflegends-optimizer/blob/main/LICENSE" rel="noopener ugc nofollow" target="_blank">许可证</a>。</p></div></div>    
</body>
</html>