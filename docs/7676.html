<html>
<head>
<title>Modding JJWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正在修改JJWT</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/modding-jjwt-562ae8b444e2?source=collection_archive---------2-----------------------#2017-04-28">https://medium.com/walmartglobaltech/modding-jjwt-562ae8b444e2?source=collection_archive---------2-----------------------#2017-04-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/a23562f56f52f6f7cd0bd08092bec451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*_vuJZVJReJb03fslQIaIJg.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">Credit : <a class="ae ip" href="https://pixabay.com/en/computer-security-padlock-hacker-1591018/" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="9f59" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi"> JSON Web令牌:</strong></p><p id="b084" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">根据<em class="jo"> RFC#7519 </em>的说法，JSON Web Token (JWT)是一种简洁的、URL安全的方式来表示在双方之间传输的声明。JWT中的声明被编码为JSON对象，该对象被用作JSON Web签名(JWS)结构的有效载荷，或者被用作JSON Web加密(JWE)结构的明文，从而能够对声明进行数字签名或使用消息认证码(MAC)进行完整性保护和/或加密。</p><p id="ce87" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">JWT包含三个部分，以特定的顺序附加。</p><p id="5bd6" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">1.标头—包含有关令牌本身的元数据，例如:令牌类型、使用的签名算法(未签名时为<em class="jo">【无】</em>)</p><p id="b0cf" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">2.声明集/有效负载—JWT声明集代表一个JSON对象，其成员是由JWT传达的声明。</p><p id="53e1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">3.签名—包含使用标题中提到的算法的标题和声明集的签名。</p><p id="3bd0" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">建筑:</p><p id="c547" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><em class="jo"> H </em> : urlBase64(表头)</p><p id="3f96" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">P  : urlBase64(有效载荷)</p><p id="7a8c" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><em class="jo"> S </em> : urlBase64(签名(H ||。|| P)) (||意味着连接)</p><p id="c2f8" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">Token : <em class="jo"> H ||。|| P ||。|| S </em></p><p id="b410" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">令牌的签名部分是可选的，但它需要有3个由“句号”连接的部分。</p><p id="182a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">基于令牌的认证</strong></p><p id="63b4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">对于无状态服务，认证是通过使用令牌来完成的。这些令牌必须包含足够的信息来验证请求发送者的身份。由于这些是代币，我们还需要验证发行者的真实性。令牌必须是这样的，即没有人能够伪造它们，并且只有预定方能够验证它。</p><p id="76b5" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">令牌可以包含权限字段，以确定对网页或应用程序上的资源的访问。可能是“用户”或“管理员”。这些令牌并不意味着存储任何敏感信息，因为它们只是base64编码的JSONs。(尽管它们可以选择性地使用JWE标准加密)。因此很容易创建有效载荷。但是，一个人不能伪造一个有效载荷。这由令牌的签名部分负责。</p><p id="413e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">要获得令牌，用户首先需要提供其用户凭据。经过验证后，服务返回一个令牌，在使用其非对称密钥签名的有效负载中包含相应的身份验证和授权信息。这些令牌通常包含发行者的标识和它所针对的受众的标识。建议这些令牌是短期的。</p><p id="0043" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">用例:</strong></p><p id="dc0a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">开发RESTful服务是为了以加密实体的形式存储敏感信息。它支持实体的持久性，可由授权用户检索/修改。为了处理授权，需要在请求中提供由非对称密钥签名的JWT令牌，该非对称密钥由客户端提供或者由服务在注册时生成。该令牌被验证为对请求进行身份验证的一种方式。</p><p id="55ed" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">问题:</strong></p><p id="713e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为了构建JWT令牌，我们使用了规范的java实现——JJWT。我们构建一个令牌如下:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="e73e" class="jy jz hh ju b fi ka kb l kc kd">String compactJws = Jwts.builder()</span><span id="792f" class="jy jz hh ju b fi ke kb l kc kd">    .setSubject(“Joe”)</span><span id="0b26" class="jy jz hh ju b fi ke kb l kc kd">    .signWith(SignatureAlgorithm.HS512, key)</span><span id="b7b6" class="jy jz hh ju b fi ke kb l kc kd">    .compact();</span></pre><p id="5cff" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">验证令牌<code class="du kf kg kh ju b">compactJws</code>如下:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="7275" class="jy jz hh ju b fi ka kb l kc kd">try {</span><span id="30c8" class="jy jz hh ju b fi ke kb l kc kd">    Claims claims = Jwts.parser()</span><span id="97ce" class="jy jz hh ju b fi ke kb l kc kd">        .setSigningKey(key)</span><span id="942d" class="jy jz hh ju b fi ke kb l kc kd">        .parseClaimsJws(compactJws)</span><span id="438b" class="jy jz hh ju b fi ke kb l kc kd">        .getBody();</span><span id="2bb6" class="jy jz hh ju b fi ke kb l kc kd">        //OK, we can trust this JWT</span><span id="c859" class="jy jz hh ju b fi ke kb l kc kd">} catch (SignatureException e) {</span><span id="84f3" class="jy jz hh ju b fi ke kb l kc kd">    //don't trust the JWT!</span><span id="0e79" class="jy jz hh ju b fi ke kb l kc kd">}</span></pre><p id="8403" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">该构建器界面提供了一个<code class="du kf kg kh ju b">signWith(Algorithm, key)</code>函数，该函数从库中定义的一组预定义和支持的算法中接受一个算法，并提供一个<strong class="is hi">清除</strong>键进行签名。PCI DSS 3.0指南指出:</p><blockquote class="ki kj kk"><p id="8476" class="iq ir jo is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn ha bi translated">3.5.1:“将对密钥的访问权限限制在最少数量的必要保管人”</p><p id="041a" class="iq ir jo is b it iu iv iw ix iy iz ja kl jc jd je km jg jh ji kn jk jl jm jn ha bi translated">3 . 5 . 4:“<strong class="is hi">将密钥存储在尽可能少的位置</strong></p></blockquote><p id="7073" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">此外，该应用程序旨在将角色分离到不同的层中。因此，我们应该拥有的只是提供令牌的业务逻辑中实际密钥的句柄。加密任务应该被隔离到一个加密层中，即业务逻辑不能与密钥本身有关。</p><p id="b426" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">类似地，为了验证，它提供了<code class="du kf kg kh ju b">setSigningKey(Key)</code>从头部提取算法并进行验证。同样，这把钥匙也需要弄清楚。</p><p id="a1e4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当前的问题是，我们如何使用JJWT仅仅用实际密钥的句柄签名，因为JJWT库有自己的提供者，使用JCE接口进行加密任务，并有特定的接口来接受输入。</p><p id="60a1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在开发时，该库不支持将加密委托给不同服务的算法和提供程序的自定义实现，并且没有时间表，该库必须修改。</p><h2 id="f88a" class="jy jz hh bd ko kp kq kr ks kt ku kv kw jb kx ky kz jf la lb lc jj ld le lf lg bi translated">解决方案:</h2><p id="0b62" class="pw-post-body-paragraph iq ir hh is b it lh iv iw ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn ha bi translated">构建器和解析器接口需要修改。两个界面都引入了新的方法。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="1e96" class="jy jz hh ju b fi ka kb l kc kd">JwtBuilder setCryptoProvider(CryptoProvider cryptoProvider);</span><span id="0429" class="jy jz hh ju b fi ke kb l kc kd">JwtBuilder setConfigParams(Map&lt;String, Object&gt; config);</span></pre><p id="6f13" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">第一个方法允许库接受用户特定的自定义加密提供程序，并且可以包含任何逻辑，直到它实现库中添加的加密提供程序接口。</p><p id="5f1e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><code class="du kf kg kh ju b">cryptoProvider</code>界面–</p><p id="254b" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">它包含两种用于令牌构建和验证的基本方法。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="bb1b" class="jy jz hh ju b fi ka kb l kc kd">/**</span><span id="7f02" class="jy jz hh ju b fi ke kb l kc kd">*</span><span id="8e61" class="jy jz hh ju b fi ke kb l kc kd">* <strong class="ju hi">@param</strong> plain the string that needs to be signed</span><span id="2bc0" class="jy jz hh ju b fi ke kb l kc kd">* <strong class="ju hi">@param</strong> config configuration hashmap that requires exclusive information required for sign</span><span id="4a42" class="jy jz hh ju b fi ke kb l kc kd">* This config map can be implementation specific as the user will have to implement the CryptoProvider and provide</span><span id="32b5" class="jy jz hh ju b fi ke kb l kc kd">* an instance for using jjwt.</span><span id="4ac1" class="jy jz hh ju b fi ke kb l kc kd">* <strong class="ju hi">@return</strong> String the signed value as a String</span><span id="7b66" class="jy jz hh ju b fi ke kb l kc kd">*</span><span id="55f2" class="jy jz hh ju b fi ke kb l kc kd">* Parsing of the config map is left for the implementation</span><span id="8b25" class="jy jz hh ju b fi ke kb l kc kd">*/</span><span id="cde6" class="jy jz hh ju b fi ke kb l kc kd"><strong class="ju hi">public</strong> String sign(String plain, Map&lt;String, Object&gt; config)</span><span id="5e01" class="jy jz hh ju b fi ke kb l kc kd"><strong class="ju hi">throws</strong> SignatureException;</span><span id="26d9" class="jy jz hh ju b fi ke kb l kc kd">/**</span><span id="234a" class="jy jz hh ju b fi ke kb l kc kd">*</span><span id="1194" class="jy jz hh ju b fi ke kb l kc kd">* <strong class="ju hi">@param</strong> plain the string that has been signed</span><span id="8103" class="jy jz hh ju b fi ke kb l kc kd">* <strong class="ju hi">@param</strong> sign the sign that is to be verified for the given plain text</span><span id="ff0b" class="jy jz hh ju b fi ke kb l kc kd">* <strong class="ju hi">@param</strong> config configuration hashmap that requires exclusive information required for verify</span><span id="d8d6" class="jy jz hh ju b fi ke kb l kc kd">* This config map can be implementation specific as the user will have to implement the CryptoProvider and provide</span><span id="31ae" class="jy jz hh ju b fi ke kb l kc kd">* an instance for using jjwt.</span><span id="34a9" class="jy jz hh ju b fi ke kb l kc kd">* <strong class="ju hi">@return</strong> Boolean value identifying if the sign is valid or not</span><span id="ce1e" class="jy jz hh ju b fi ke kb l kc kd">*/</span><span id="df9c" class="jy jz hh ju b fi ke kb l kc kd"><strong class="ju hi">public</strong> Boolean verify(String plain, String sign,</span><span id="abbc" class="jy jz hh ju b fi ke kb l kc kd">Map&lt;String, Object&gt; config) <strong class="ju hi">throws</strong> SignatureException;</span></pre><p id="2b52" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在添加到接口的第二个方法中传递的配置参数包含用户特定的信息。这是为了支持加密函数的用户特定实现。因此，它对库是不透明的。这些配置图可以盲目的传递给<code class="du kf kg kh ju b">cryptoProvider</code>的实现。如何使用它取决于实现类。它可以实现自己的令牌签名协议，将其委托给另一个服务或HSM。所有需要的元数据都可以存储在配置映射中。</p><p id="5ecb" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为了实际使用这些添加的函数，必须在库中更改代码，以便在<code class="du kf kg kh ju b">cryptoProvider</code>和配置都被显式设置时覆盖库的签名/验证调用。</p><p id="e101" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">因此，通过提供CryptoProvider实现和相关配置，默认行为可以委托给应用程序自己的实现，覆盖JJWT的JCE实现。</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="3a37" class="jy jz hh ju b fi ka kb l kc kd">String token = Jwts.<em class="jo">builder</em>().setId(ID)</span><span id="d7f5" class="jy jz hh ju b fi ke kb l kc kd">    .setIssuedAt(now)</span><span id="ade7" class="jy jz hh ju b fi ke kb l kc kd">    .setExpiration(exipration)</span><span id="483f" class="jy jz hh ju b fi ke kb l kc kd">    .setCryptoProvider(cryptoProvider)</span><span id="4865" class="jy jz hh ju b fi ke kb l kc kd">    .setConfigParams(config).compact();</span></pre><p id="cff2" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">config是一个<code class="du kf kg kh ju b">Map&lt;String, Object&gt;()</code>和<code class="du kf kg kh ju b">cryptoProvider</code>是一个从库中实现<code class="du kf kg kh ju b">CryptoProvider</code>接口的类的实例。</p><p id="4437" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">类似的验证工作如下:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="45af" class="jy jz hh ju b fi ka kb l kc kd">claims = Jwts.<em class="jo">parser</em>()</span><span id="f670" class="jy jz hh ju b fi ke kb l kc kd">    .setCryptoProvider(cryptoProvider)</span><span id="c5e0" class="jy jz hh ju b fi ke kb l kc kd">    .setConfigParams(config)</span><span id="a154" class="jy jz hh ju b fi ke kb l kc kd">    .parseClaimsJws(token).getBody();</span></pre><p id="3cf8" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">通过这种设计变更，可以抽象出加密责任，而不会影响向后兼容性。</p><p id="590c" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">链接:<a class="ae ip" href="https://github.com/jwtk/jjwt" rel="noopener ugc nofollow" target="_blank">https://github.com/jwtk/jjwt</a></p><p id="d8bc" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">修改版本:<a class="ae ip" href="https://github.com/prateeknischal/jjwt" rel="noopener ugc nofollow" target="_blank">https://github.com/prateeknischal/jjwt</a></p></div></div>    
</body>
</html>