<html>
<head>
<title>Making the most of the APK analyzer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">充分利用APK分析仪</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/making-the-most-of-the-apk-analyzer-c066cb871ea2?source=collection_archive---------1-----------------------#2016-11-23">https://medium.com/androiddevelopers/making-the-most-of-the-apk-analyzer-c066cb871ea2?source=collection_archive---------1-----------------------#2016-11-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex ie if ig ih"><div class="bz dy l di"><div class="ii ij l"/></div></figure><p id="0e51" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">Android Studio中我最喜欢的新增功能之一是APK分析器，你可以在顶部菜单的<strong class="im hi">构建</strong> → <strong class="im hi">分析APK </strong>下找到它。</p><figure class="jj jk jl jm fd ih er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ji"><img src="../Images/9a2ab1cc7c21d117bf1344018823c25f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RiXOWhjkTw8ELX7M."/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Pro-tip: you can also drag and drop APK files into the editor to open them</figcaption></figure><p id="9df7" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">APK分析器允许您打开并检查您计算机上的任何APK文件的内容，无论是从您的本地Android Studio项目构建的，还是从您的构建服务器或其他工件存储库中获取的。它不必从你在Android Studio中打开的任何项目中构建，你也不需要那个特定APK的源代码。</p><blockquote class="jx jy jz"><p id="3919" class="ik il ka im b in io ip iq ir is it iu kb iw ix iy kc ja jb jc kd je jf jg jh ha bi translated"><strong class="im hi">注意:</strong> APK分析器最适合发布版本。如果您需要分析应用程序的调试版本，请确保您使用的APK不是为即时运行而设计的。要获得它，您可以使用<strong class="im hi">构建</strong> → <strong class="im hi">构建APK </strong>命令。您可以通过检查归档文件中是否存在instant-run.zip文件来查看是否打开了Instant-Run instrumented APK。</p></blockquote><p id="5a9b" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">使用APK分析器是一种很好的方式，可以浏览APK文件，了解它们的结构，在发布之前验证文件内容，或者调试一些常见的问题，包括APK大小和索引问题。</p><h1 id="09db" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">使用APK分析器减少应用程序大小</h1><p id="5977" class="pw-post-body-paragraph ik il hh im b in ld ip iq ir le it iu iv lf ix iy iz lg jb jc jd lh jf jg jh ha bi translated">APK分析器可以为您提供许多关于应用程序大小的有用、可操作的信息。在屏幕顶部，您可以看到<strong class="im hi">原始文件大小</strong>，这正是APK磁盘上的大小。<strong class="im hi">下载大小</strong>显示了考虑到Play Store应用的压缩后，下载您的应用程序所需的估计数据量。</p><p id="88a3" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">文件和文件夹列表按总大小降序排列。这使得它非常适合识别APK规模优化的低挂果实。每次深入到一个文件夹时，您都可以看到在APK中占用空间最多的资源和其他实体。</p><figure class="jj jk jl jm fd ih er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es li"><img src="../Images/6b3cec0ead4604d17de5ea76094302f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DRt5aMTeoIKdwYG1."/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Resources sorted in descending order according to size</figcaption></figure><p id="de0b" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">在这个例子中，当检查一个APK的可能尺寸减少时，我能够立即注意到一个3帧的PNG动画是我们可绘制资源中最大的一个，重1.5MB，而且这只是针对<em class="ka"> xxhdpi </em>密度！</p><p id="e4ba" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">由于这些图像看起来很适合存储为矢量，我们找到了艺术作品的源文件，并使用Android Studio 2.2中矢量资源导入工具中新的<a class="ae ke" href="https://developer.android.com/studio/write/vector-asset-studio.html" rel="noopener ugc nofollow" target="_blank"> PSD支持将它们导入为VectorDrawables。</a></p><p id="0da3" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">通过对其他剩余动画(<em class="ka"> instruction_touch_*)进行相同的过程。png) </em>通过删除所有密度的png文件，我们可以节省超过5MB的空间。为了保持向后兼容性，我们使用了支持库中的<a class="ae ke" rel="noopener" href="/@chrisbanes/appcompat-v23-2-age-of-the-vectors-91cbafa87c88"><em class="ka">VectorDrawableCompat</em></a>。</p><p id="870f" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">查看其他资源文件夹，很容易发现一些未压缩的<em class="ka"> WAV </em>文件，它们可以转换成<em class="ka"> OGG </em>，这意味着甚至不用动一行代码就可以节省更多。</p><figure class="jj jk jl jm fd ih er es paragraph-image"><div class="er es lj"><img src="../Images/ea6165d7efeaafada0d637a3ee138fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/0*AcjFk-xj6PKOXRWe."/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Browsing other folders in the APK</figcaption></figure><p id="e260" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">接下来要检查的是<em class="ka"> lib/ </em>文件夹，它包含我们支持的三个ABI的本地库。</p><p id="3b20" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">我们决定在Gradle build中使用<a class="ae ke" href="https://developer.android.com/studio/build/configure-apk-splits.html" rel="noopener ugc nofollow" target="_blank"> APK拆分支持</a>，为每个ABI创建单独的应用版本。</p><p id="499d" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">接下来我快速浏览了一下AndroidManifest.xml，注意到<em class="ka"> &lt;应用程序&gt; </em>缺少了<a class="ae ke" href="https://developer.android.com/reference/android/R.attr.html#extractNativeLibs" rel="noopener ugc nofollow" target="_blank"><em class="ka">Android:extractNativeLibs</em></a>属性。将该属性设置为<em class="ka"> false </em>可以节省设备上的一些空间，因为它可以防止将本地库从APK复制到文件系统。唯一的要求是文件是页面对齐的，并以未压缩的形式存储在APK中，Android Gradle plugin版本2.2.0+中的<a class="ae ke" href="http://android-developers.blogspot.com/2016/11/understanding-apk-packaging-in-android-studio-2-2.html" rel="noopener ugc nofollow" target="_blank">新打包器</a>支持这一点。</p><figure class="jj jk jl jm fd ih er es paragraph-image"><div class="er es lk"><img src="../Images/b1d50fef0ba725b77dc7cd0a5bda97fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/0*VgknN7SJh9z7hOya."/></div><figcaption class="jt ju et er es jv jw bd b be z dx">The full AndroidManifest.xml as viewed in APK Analyzer</figcaption></figure><p id="9bab" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">在我做了这些修改后，我很好奇这个应用程序的新版本与之前的版本相比如何。为此，我从我开始使用的git commit中检查了源代码，编译了APK并将其保存在另一个文件夹中。然后我使用<strong class="im hi"> Compare with… </strong>特性来查看新旧版本之间的大小差异。</p><figure class="jj jk jl jm fd ih er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ll"><img src="../Images/ce675ae9f237b6cc267f4b3ea981e05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W_ZzJpAzon5xAHpc."/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">APK comparison — access it through the button on the top-right</figcaption></figure><p id="fc53" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">我们在资源和原生库方面取得了很大进展，在应用程序几乎没有变化的情况下，总共节省了17MB。然而，我可以看到我们的DEX大小在倒退，class 2 . DEX增长了400KB。</p><h1 id="8618" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">调试DEX问题</h1><p id="087e" class="pw-post-body-paragraph ik il hh im b in ld ip iq ir le it iu iv lf ix iy iz lg jb jc jd lh jf jg jh ha bi translated">在这种情况下，差异来自于将我们的依赖项升级到较新的版本和添加新的库。Proguard 和<a class="ae ke" href="https://developer.android.com/studio/build/multidex.html" rel="noopener ugc nofollow" target="_blank"> Multidex </a>已经在我们的构建中启用，所以对于我们的dex大小已经没有什么可做的了。尽管如此，APK分析仪是一个伟大的工具来调试任何问题，与此设置，尤其是当你启用多指数或Proguard为您的项目第一次。</p><figure class="jj jk jl jm fd ih er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lm"><img src="../Images/1ea892f6afd9b2142f3cd5ffd071fb05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bOKK2M9iFTXVfUrs."/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Exploring the contents of classes.dex</figcaption></figure><p id="e51d" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">当你点击任何一个DEX文件时，你会看到它定义了多少个类和方法的摘要，以及它包含了多少个引用(在一个单独的DEX文件中，这些引用被计入了<a class="ae ke" href="https://developer.android.com/studio/build/multidex.html#about" rel="noopener ugc nofollow" target="_blank"> 64K限制</a>)。在这个示例截图中，该应用程序即将达到极限，这意味着在不久的将来，它将需要MultiDex来将这些类分成单独的文件。</p><p id="788f" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">您可以深入到包中，查看哪些包用完了所有的引用。在这种情况下，我们可以看到支持库和Google Play服务是造成这种情况的主要原因:</p><figure class="jj jk jl jm fd ih er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ll"><img src="../Images/9b409b12a31d44d19bf752c27908b46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_X6y5PXnNG_e_QK-."/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Reference counts per package</figcaption></figure><p id="b73f" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">启用MultiDex并编译应用程序后，您会注意到第二个classes2.dex文件(可能还有classes3.dex，以此类推)。Android gradle插件中的MultiDex解决方案会计算出启动应用程序需要哪些类，并将它们放入primary classes.dex文件中，但在极少数情况下，当它不起作用时，您会得到一个ClassNotFoundException，您可以使用APK分析器来检查Dex文件，然后<a class="ae ke" href="http://google.github.io/android-gradle-dsl/2.2/com.android.build.gradle.internal.dsl.ProductFlavor.html#com.android.build.gradle.internal.dsl.ProductFlavor:multiDexKeepFile" rel="noopener ugc nofollow" target="_blank">强制将缺失的类放入primary DEX文件</a>。</p><p id="dd87" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">当启用Proguard并通过反射或从XML布局使用类或方法时，您会遇到类似的问题。APK分析器可以帮助您验证您的Proguard配置是正确的，通过让您轻松地检查您需要的方法和类是否存在于APK中，以及它们是否被重命名(混淆)。您还可以确保您想要删除的类确实被删除了，并且不会占用您宝贵的引用方法计数。</p><p id="cfab" class="pw-post-body-paragraph ik il hh im b in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ha bi translated">我们很想知道APK分析仪的其他用途，以及您希望在该工具中集成的其他功能。</p></div></div>    
</body>
</html>