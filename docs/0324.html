<html>
<head>
<title>Playing with Paths</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">玩路径</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/playing-with-paths-3fbc679a6f77?source=collection_archive---------2-----------------------#2017-12-18">https://medium.com/androiddevelopers/playing-with-paths-3fbc679a6f77?source=collection_archive---------2-----------------------#2017-12-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="36cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我最近在一个应用程序中帮助制作了一个英雄动画——不幸的是我还不能分享这个动画……但是我想分享我在制作它时学到的东西。在本帖中，我将介绍由<a class="ae jc" href="https://beesandbombs.tumblr.com/" rel="noopener ugc nofollow" target="_blank">戴夫“蜜蜂炸弹”威特</a>制作的这个令人着迷的动画，它展示了许多相同的技术:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/42213224b110389027cb516c6d61d226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*uHGhUwxAvufuD_THa7sjAg.gif"/></div><figcaption class="jl jm et er es jn jo bd b be z dx"><a class="ae jc" href="https://beesandbombs.tumblr.com/post/161295765794/polygon-laps" rel="noopener ugc nofollow" target="_blank"><em class="jp">Polygon Laps</em></a><em class="jp"> by beesandbombs 🐝💣</em></figcaption></figure><p id="248e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我看到这个的时候，我的第一个想法(对于任何了解我的工作的人来说，这可能并不奇怪)是伸手去拿一个<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable.html" rel="noopener ugc nofollow" target="_blank">AnimatedVectorDrawable</a></code>(此后称为<code class="du jq jr js jt b">AVD</code>)。<code class="du jq jr js jt b">AVD</code> s很棒，但并不适合所有情况——具体来说，我们有以下要求:</p><ul class=""><li id="68a6" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated">我知道我们需要画一个多边形，但是我们还没有决定具体的形状。<code class="du jq jr js jt b">AVD</code>是“预先烘焙”的动画，因此改变形状需要重新制作动画。</li><li id="275d" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">“进度跟踪”方面的一部分，我们想只画多边形的一部分。<code class="du jq jr js jt b">AVD</code>它们是‘一劳永逸’的，也就是说，你不能把它们一笔勾销。</li><li id="8581" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">我们想围绕多边形移动另一个对象。这绝对可以用<code class="du jq jr js jt b">AVD</code> s实现…但是同样需要大量的前期工作来预先计算构图。</li><li id="4f69" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">我们希望控制对象在多边形周围移动的进度，与显示的多边形部分分开。</li></ul><p id="1d2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">相反，我选择将它实现为由<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/Path.html" rel="noopener ugc nofollow" target="_blank">Path</a></code>对象组成的自定义<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/drawable/Drawable.html" rel="noopener ugc nofollow" target="_blank">Drawable</a></code>。<code class="du jq jr js jt b">Path</code> s是一个形状的基本代表(在引擎盖下使用！)和Android的<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/Canvas.html" rel="noopener ugc nofollow" target="_blank">Canvas</a></code>API为创建有趣的效果提供了丰富的支持。在浏览这些之前，我想对罗曼·盖伊的这篇出色的文章大声欢呼，这篇文章展示了我在这篇文章中运用的许多技巧:</p><div class="kk kl ez fb km kn"><a href="http://www.curious-creature.com/2013/12/21/android-recipe-4-path-tracing/" rel="noopener  ugc nofollow" target="_blank"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hi fi z dy ks ea eb kt ed ef hg bi translated">Android配方#4，路径跟踪</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">几个月前我离开了Android团队，但我仍然有许多视觉效果和演示想写…</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">www.curious-creature.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb jj kn"/></div></div></a></div><h2 id="f18f" class="lc ld hh bd le lf lg lh li lj lk ll lm ip ln lo lp it lq lr ls ix lt lu lv lw bi translated">极坐标</h2><p id="6ed6" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">通常当定义2d形状时，我们在(x，y)坐标中工作，技术上称为笛卡尔坐标。它们通过沿x轴和y轴距离原点的距离来指定点，从而定义形状。另一种方法是极坐标系统，该系统通过原点的角度(θ)和半径(r)来定义点。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es mc"><img src="../Images/7759cd247ce390990ded8eba24ca18d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i620xgMH8TKxMtP3."/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx"><em class="jp">Cartesian coordinates (left) vs polar coordinates (right)</em></figcaption></figure><p id="2f71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以使用以下公式在极坐标和笛卡尔坐标之间进行转换:</p><pre class="je jf jg jh fd mh jt mi mj aw mk bi"><span id="f786" class="lc ld hh jt b fi ml mm l mn mo">val x = radius * Math.cos(angle);<br/>val y = radius * Math.sin(angle);</span></pre><p id="6f98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我强烈推荐这篇文章来学习更多关于极坐标的知识:</p><div class="kk kl ez fb km kn"><a href="http://varun.ca/polar-coords/" rel="noopener  ugc nofollow" target="_blank"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hi fi z dy ks ea eb kt ed ef hg bi translated">极坐标🌀</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">寻找迷惑自己的新方法</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">瓦伦. ca</p></div></div></div></a></div><p id="fdb3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要生成正多边形(即每个内角都相同)，极坐标非常有用。您可以计算产生所需边数所需的角度(因为内角总共为360°)，然后使用半径相同的该角度的倍数来描述每个点。然后，您可以将这些点转换成图形API工作的笛卡尔坐标。这里有一个函数创建一个描述给定边数和半径的多边形的<code class="du jq jr js jt b">Path</code>:</p><pre class="je jf jg jh fd mh jt mi mj aw mk bi"><span id="963f" class="lc ld hh jt b fi ml mm l mn mo">fun createPath(sides: Int, radius: Float): Path {<br/>  val path = Path()<br/>  val angle = 2.0 * Math.PI / sides<br/>  path.moveTo(<br/>      cx + (radius * Math.cos(0.0)).toFloat(),<br/>      cy + (radius * Math.sin(0.0)).toFloat())<br/>  for (i in 1 until sides) {<br/>    path.lineTo(<br/>        cx + (radius * Math.cos(angle * i)).toFloat(),<br/>        cy + (radius * Math.sin(angle * i)).toFloat())<br/>    }<br/>  path.close()<br/>  return path<br/>}</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mp"><img src="../Images/91009d4735889d51125a9c63e1497c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/0*gfEjYsmdKv2AF-ZV."/></div></figure><p id="e554" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，为了重新创建我们的目标组合，我们可以创建一个具有不同边数、半径和颜色的多边形列表。<code class="du jq jr js jt b">Polygon</code>是一个简单的类，它保存这些信息并计算<code class="du jq jr js jt b">Path</code>:</p><pre class="je jf jg jh fd mh jt mi mj aw mk bi"><span id="fa22" class="lc ld hh jt b fi ml mm l mn mo">private val polygons = listOf(<br/>  Polygon(sides = 3, radius = 45f, color = 0xffe84c65.toInt()),<br/>  Polygon(sides = 4, radius = 53f, color = 0xffe79442.toInt()),<br/>  Polygon(sides = 5, radius = 64f, color = 0xffefefbb.toInt()),<br/>  ...<br/>)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mq"><img src="../Images/e356048cb74cf18a5cc1c39cf8717144.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*w913bdMCd1gvcQJdkRC-gQ.png"/></div></figure><h2 id="8271" class="lc ld hh bd le lf lg lh li lj lk ll lm ip ln lo lp it lq lr ls ix lt lu lv lw bi translated">有效路径绘画</h2><p id="c719" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">使用<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/Canvas.html#drawPath(android.graphics.Path,%20android.graphics.Paint)" rel="noopener ugc nofollow" target="_blank">Canvas.drawPath(path, paint)</a></code>绘制路径很简单，但是<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/Paint.html" rel="noopener ugc nofollow" target="_blank">Paint</a></code>参数<a class="ae jc" href="https://developer.android.com/reference/android/graphics/Paint.html#setPathEffect(android.graphics.PathEffect)" rel="noopener ugc nofollow" target="_blank">支持</a>一个<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/PathEffect.html" rel="noopener ugc nofollow" target="_blank">PathEffect</a></code>，我们可以用它来改变<em class="mr">如何</em>绘制路径。例如，我们可以用一个<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/CornerPathEffect.html" rel="noopener ugc nofollow" target="_blank">CornerPathEffect</a></code>来圆化我们多边形的角，或者用一个<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/DashPathEffect.html" rel="noopener ugc nofollow" target="_blank">DashPathEffect</a></code>来只画出<code class="du jq jr js jt b">Path</code>的一部分(参见前面提到的<a class="ae jc" href="http://www.curious-creature.com/2013/12/21/android-recipe-4-path-tracing/" rel="noopener ugc nofollow" target="_blank">帖子</a>的“路径追踪”部分，了解更多关于这种技术的细节):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mp"><img src="../Images/594b003175d891ecbb25deeea36ac64e.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/0*YYIS8QVIZWMvkZU6."/></div></figure><blockquote class="ms mt mu"><p id="22e7" class="ie if mr ig b ih ii ij ik il im in io mv iq ir is mw iu iv iw mx iy iz ja jb ha bi translated">另一种绘制路径分段的技术是使用<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/PathMeasure.html#getSegment(float%2C%20float%2C%20android.graphics.Path%2C%20boolean)" rel="noopener ugc nofollow" target="_blank">PathMeasure#getSegment</a></code>，它将一部分复制到一个新的<code class="du jq jr js jt b">Path</code>对象中。我使用破折号技术来制作<code class="du jq jr js jt b">interval</code>和<code class="du jq jr js jt b">phase</code>参数的动画，以实现有趣的可能性。</p></blockquote><p id="87f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过将控制这些效果的参数公开为我们的drawable的属性，我们可以轻松地将它们制作成动画:</p><pre class="je jf jg jh fd mh jt mi mj aw mk bi"><span id="d951" class="lc ld hh jt b fi ml mm l mn mo">object PROGRESS : FloatProperty&lt;PolygonLapsDrawable&gt;("progress") {<br/>  override fun setValue(pld: PolygonLapsDrawable, progress: Float) {<br/>    pld.progress = progress<br/>  }<br/>  override fun get(pld: PolygonLapsDrawable) = pld.progress<br/>}</span><span id="046a" class="lc ld hh jt b fi my mm l mn mo">...</span><span id="cee8" class="lc ld hh jt b fi my mm l mn mo">ObjectAnimator.ofFloat(polygonLaps, PROGRESS, 0f, 1f).apply {<br/>  duration = 4000L<br/>  interpolator = LinearInterpolator()<br/>  repeatCount = INFINITE<br/>  repeatMode = RESTART<br/>}.start()</span></pre><p id="b26a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，以下是制作同心多边形路径进度动画的不同方式:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mz"><img src="../Images/b9430f33583f66d51633d46cb8df212e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/0*YRIGAx02Jyocd7G4."/></div></figure><h2 id="f666" class="lc ld hh bd le lf lg lh li lj lk ll lm ip ln lo lp it lq lr ls ix lt lu lv lw bi translated">坚持走这条路</h2><p id="e9a9" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">为了沿着路径绘制对象，我们可以使用一个<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/PathDashPathEffect.html" rel="noopener ugc nofollow" target="_blank">PathDashPathEffect</a></code>。这沿着一条路径“压印”另一个<code class="du jq jr js jt b">Path</code>,所以例如沿着一个多边形压印蓝色的圆可能看起来像这样:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mq"><img src="../Images/982b628250d61e06649be27534df9532.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*tKje69sTkg8-Wvwnkcj-IQ.png"/></div></figure><p id="680f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jq jr js jt b">PathDashPathEffect</code>接受<code class="du jq jr js jt b">advance</code>和<code class="du jq jr js jt b">phase</code>参数——即印记之间的间隙和在第一个印记之前沿路径移动的距离。通过将推进设置为整个路径的长度(通过<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/PathMeasure.html#getLength()" rel="noopener ugc nofollow" target="_blank">PathMeasure#getLength</a></code>获得)，我们可以绘制一个单独的图章。通过制作阶段动画(这里由一个<code class="du jq jr js jt b">dotProgress</code>参数[0，1]控制)，我们可以让这个单独的图章沿着路径移动。</p><pre class="je jf jg jh fd mh jt mi mj aw mk bi"><span id="ba8f" class="lc ld hh jt b fi ml mm l mn mo">val phase = dotProgress * polygon.length<br/>dotPaint.pathEffect = PathDashPathEffect(pathDot, polygon.length,<br/>    phase, TRANSLATE)<br/>canvas.drawPath(polygon.path, dotPaint)</span></pre><p id="244b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们现在已经有了创作作品的所有材料。通过向每个多边形添加另一个参数，即每个点在每个动画循环中应该完成的“圈数”,我们得出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/9905e8cd0cb2abfec993a416ddbf1ae0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*vCysqKE1ek9WjJXVrqqUqQ.gif"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">A re-creation of the original gif as an Android drawable</figcaption></figure><p id="d84a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以在此处找到此绘图的来源:</p><p id="33be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://gist.github.com/nickbutcher/b41da75b8b1fc115171af86c63796c5b#file-polygonlapsdrawable-kt" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/nick butcher/b 41 da 75 b 8 B1 fc 115171 af 86 c 63796 c5b # file-polygonapsdrawable-kt</a></p><h2 id="bb92" class="lc ld hh bd le lf lg lh li lj lk ll lm ip ln lo lp it lq lr ls ix lt lu lv lw bi translated">展示一些风格</h2><p id="ecb1" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">眼尖的你们可能已经注意到了<code class="du jq jr js jt b">PathDashPathEffect</code> : <code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/PathDashPathEffect.Style.html" rel="noopener ugc nofollow" target="_blank">Style</a></code>的最终参数。此枚举控制如何在绘制的每个位置变换图章。为了说明该参数的工作原理，下面的示例使用了一个三角形图章而不是圆形图章，并显示了<code class="du jq jr js jt b">translate</code>和<code class="du jq jr js jt b">rotate</code>样式:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="er es na"><img src="../Images/8870639c816ce942f66ff5ada358b57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QpO_ClLfUcmbzHKC."/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx"><em class="jp">Comparing </em><code class="du jq jr js jt b"><em class="jp">translate</em></code><em class="jp"> style (left) with </em><code class="du jq jr js jt b"><em class="jp">rotate</em></code><em class="jp"> (right)</em></figcaption></figure><p id="f3b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，使用<code class="du jq jr js jt b">translate</code>时，三角形图章总是在同一方向(指向左边)，而使用<code class="du jq jr js jt b">rotate</code>样式时，三角形旋转以保持与路径相切。</p><p id="eb24" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还有一个最后的<code class="du jq jr js jt b">style</code>叫做<code class="du jq jr js jt b">morph</code>，它实际上是<em class="mr">转换</em>图章。为了说明这种行为，我将图章改为下面的一行。注意线<em class="mr">在穿过拐角时如何弯曲</em>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nb"><img src="../Images/d71af5ec3f02060ab8fab45a124be340.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*Wc2bErgxb68pCBrODWD8Ag.gif"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Demonstrating <code class="du jq jr js jt b">PathDashPathEffect.Style.MORPH</code></figcaption></figure><p id="561e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个有趣的效果，但似乎在某些情况下很难实现，比如在道路的起点或急转弯处。</p><blockquote class="ms mt mu"><p id="6508" class="ie if mr ig b ih ii ij ik il im in io mv iq ir is mw iu iv iw mx iy iz ja jb ha bi translated">请注意，您可以使用一个<code class="du jq jr js jt b">ComposePathEffect</code>来组合<code class="du jq jr js jt b">PathEffect</code> s，这就是路径戳如何通过组合一个<code class="du jq jr js jt b">PathDashPathEffect</code>和一个<code class="du jq jr js jt b">CornerPathEffect</code>来跟随圆角的。</p></blockquote><h2 id="716d" class="lc ld hh bd le lf lg lh li lj lk ll lm ip ln lo lp it lq lr ls ix lt lu lv lw bi translated">说得离题了</h2><p id="1052" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">虽然以上是我们重新创建多边形重叠部分所需的全部内容，但我最初的挑战实际上需要更多的工作。使用<code class="du jq jr js jt b">PathDashPathEffect</code>的缺点是邮票只能是单一的形状和颜色。我正在创作的作品需要更复杂的标记，所以我不得不超越路径标记技术。取而代之的是，我使用一个<code class="du jq jr js jt b">Drawable</code>来计算对于一个给定的进度，它需要沿着<code class="du jq jr js jt b">Path</code>画在哪里。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nb"><img src="../Images/8d8e6a6b6b718f552d4264df8a8655d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*New-800sQntmGpmk6griDg.gif"/></div><figcaption class="jl jm et er es jn jo bd b be z dx"><em class="jp">Moving a </em><code class="du jq jr js jt b"><em class="jp">VectorDrawable</em></code><em class="jp"> along a path</em></figcaption></figure><p id="6225" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了实现这一点，我再次使用了<code class="du jq jr js jt b">PathMeasure</code>类，它提供了一个<code class="du jq jr js jt b"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/PathMeasure.html#getPosTan(float%2C%20float%5B%5D%2C%20float%5B%5D)" rel="noopener ugc nofollow" target="_blank">getPosTan</a></code>方法来获得位置坐标和沿<code class="du jq jr js jt b">Path</code>的给定距离的切线。有了这些信息(和一些数学知识)，我们可以平移和旋转画布，在正确的位置和方向绘制我们的<code class="du jq jr js jt b">marker</code>:</p><pre class="je jf jg jh fd mh jt mi mj aw mk bi"><span id="54bf" class="lc ld hh jt b fi ml mm l mn mo">pathMeasure.setPath(polygon.path, false)<br/>pathMeasure.getPosTan(markerProgress * polygon.length, pos, tan)<br/>canvas.translate(pos[0], pos[1])<br/>val angle = Math.atan2(tan[1].toDouble(), tan[0].toDouble())<br/>canvas.rotate(Math.toDegrees(angle).toFloat())<br/>marker.draw(canvas)</span></pre><h2 id="46aa" class="lc ld hh bd le lf lg lh li lj lk ll lm ip ln lo lp it lq lr ls ix lt lu lv lw bi translated">找到你的路</h2><p id="b86f" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">希望这篇文章展示了使用路径创建和操作的自定义drawable如何有助于构建有趣的图形效果。创建一个自定义的drawable可以让你最终控制改变和动画的不同组成部分独立。这种方法还允许您动态地提供值，而不必准备预先录制的动画。Android的<code class="du jq jr js jt b">Path</code>API和内置效果给我留下了非常深刻的印象，所有这些都是从API 1开始提供的。</p></div></div>    
</body>
</html>