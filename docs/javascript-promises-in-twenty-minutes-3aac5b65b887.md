# JavaScript 承诺在 16 分钟内

> 原文：<https://medium.com/quick-code/javascript-promises-in-twenty-minutes-3aac5b65b887?source=collection_archive---------2----------------------->

(初学者指南)

**简介**

我认为大多数好故事都是从一个老生常谈开始的，所以让我们开始吧。最好的程序员都很懒。他们非常喜欢偷懒，以至于他们会熬夜发明一种新的、更有效的偷懒方式，并与两万名最好的朋友展开激烈的辩论，讨论哪种形式的懒惰实际上是最懒的(因此也是最好的)。

更严重的是，找出让**做更少**的方法是让应用程序可读、可维护且高效的关键部分。你会发现在编码中，我们所做的很少是“为其本身而做”——我们使用的每一个工具(希望)都使我们需要做的事情变得更容易。

承诺也不例外。当你抽象地思考它们的时候，很难准确地理解它们是什么以及如何使用它们。在我看来，首先从概念上理解它们*是一个傻瓜的游戏。很自然地，当你构建一个应用程序的时候，你会看着你的代码说，“哦，糟糕。我在这里真正需要做的是，确保我的程序不会试图使用我发送给它的东西，直到它实际上离开并得到它。”我很乐意跟你们所有人赌一美元，那就是承诺会突然出现的时刻。*

*不管怎样，让我们看看我是否能帮你到达那里。为了讨论承诺的作用，我们需要一点关于我们为什么需要承诺的信息。让我们来谈谈当你告诉 node 或 V8 运行一个文件时会发生什么。这将有助于我们理解管理异步动作的问题是什么，它们是如何产生的，以及为什么承诺是解决这些问题的一个如此棒的、可用的解决方案。在这样做的时候，我们可能会涉及一些非常熟悉的领域。然而，这篇文章的目的不仅仅是给你一些非正式的承诺文档，而是将它们放入我们如何构建应用程序的叙述中。所以，如果开始感觉有点…基础，请原谅我。*

***第一部分:承诺之前的土地***

*![](img/a7937d470fc54aeeed791941bfd66880.png)*

*A Dark Time*

*我们的代码通常是如何执行的？每个表达式运行，然后移动到下一个。它是单向的，对吗？这很好，因为它是可预测的。当我们在第 50 行调用一个函数时，我们希望它能够访问在第 40 行建立的任何信息。没有惊喜。如果我们所做的只是运行包含在一个空间中的代码，并以正常速度执行，这就是它的工作方式。*

*但有时，我们不得不做如此庞大或复杂的事情，以至于即使我们的超高速计算机也做得很慢——按照计算标准——可能需要数百毫秒。比如与数据库对话，或者读取文件。*

*JavaScript 是单线程语言，这意味着它一次只能做一件事。这是可预测的，并且易于管理。但如果这确实是真的——在第一件事情结束之前，我们永远无法继续第二件事情——那么我们就不可能在我们的应用程序中获得所有流畅的互动体验，在 2018 年，这些体验似乎完全是日常的，并且是我们绝对依赖的。如果我们不得不在改变页面或应用程序的任何其他内容之前等待一两秒钟来获取一段数据，我们甚至不能拥有非常简单的 web 页面行为，比如在发生任何其他事情的同时改变文本颜色来响应鼠标悬停。由于其敏捷的本质，学习 JavaScript 既简单又容易。*

*幸运的是，事情没那么简单。我们的调用栈并不是唯一管理我们代码的东西。除此之外，我们还有一系列 API(Web 或 C++，取决于我们是在前端还是后端)，帮助我们处理异步操作。*

*所以，如果我们这样做:*

*![](img/fc1862d68056b84f96c512495327ed39.png)*

*which, i mean, *don’t do this**

*那个 fs。ReadFile 将运行，并直接离开我们的调用堆栈，让我们可以在第二十行运行 console.log 语句。很好，对吧？除了我们有一个非常严重的问题:console.log 不会包含我们非常重要的文件——第 20 行将在 fs 之前很久执行。ReadFile 会返回数据来填充我们的内容。我们的代码仍然是单向执行的:我们不能在方便的时候 DC·阿尔·柯达就回到变量声明。那我们该怎么办？*

*我们可以做的一件事是给那个异步函数(fs。ReadFile)一个回调函数，并把我们需要用数据做的任何事情放在那里。当异步函数接受回调时，该参数将在异步操作完成时运行，对吗？不完全是。*

*![](img/ea72de93c81f4639eea63c79f28bf162.png)*

*A very simplified and delicious diagram*

*我们不知道任何给定的异步操作需要多长时间才能完成。可能是十分之一秒，也可能是两秒，谁知道呢？如果我们能以某种方式触发一个 async 的回调函数，让它在恰好完成的时候运行，理论上它可以在其他函数的中间执行，这将是很奇怪的，可能会破坏东西。这会完全剥夺我们所依赖的可预测性。幸运的是，它不是这样工作的。*

*当一个异步动作完成它的工作时，回调函数被推到任务队列中，但是它不在那里运行。回调运行的唯一地方是在调用栈中，就像其他函数一样。以及它如何从队列到达堆栈是由事件循环处理的。*

*事件循环只有一个任务:不断监视调用堆栈。当调用堆栈为空时，事件循环检查任务队列，并获取队列中等待放入堆栈的第一个操作。这实际上意味着，我们的回调函数将在异步操作完成后的第一个点运行，即调用堆栈变得清晰。这不是完全可以预测的，但听起来比我们一分钟前的情况好多了，对吗？*

*因此，在这一点上，我们的代码将看起来像这样:*

*![](img/a653137f7a404fcf1251edc3864fc964.png)*

*Baby’s First Vanilla Async Callback!*

*这看起来并不可怕，是吗？在这一点上，它并不比使用任何旧的数组方法更糟糕——array . map()并不是我们认为会真正搞乱代码的东西。但是，如果我们不只是记录这些信息，而是真的需要做一些更实质性的事情呢？比方说，如果我们依靠 veryImportantFile.txt 中的一些数据来指引我们到下一个要读的文件，会怎么样？这将是另一个异步操作，不是吗？它有自己的回调函数，一旦这两件事都完成了，调用栈至少清空了两次，回调函数就会运行。如果*那个*文件是我们实际上需要异步处理的东西呢…*

*哦，在我忘记之前:我有没有提到我们实际上跳过了一个步骤。如果，当我们的程序去获取我们非常重要的文件时，出了问题怎么办？也许是名字打错了，也许是文件损坏了，也许是我们没有预料到的其他问题。然后呢？为了让我们的回调函数有任何用途，它大概依赖于我们一直在等待的结果，所以如果我们得到的是一堆错误消息，那么运行相同的函数就没有意义。*

*普通的异步回调实际上采用两个函数作为参数——一个用于处理成功的情况，一个用于处理失败的情况。它们实际上是“错误优先”(如，第一个函数参数将被视为错误情况回调)——只是为了让事情更不直观，更容易被人解析。在我们的代码看起来像这样之前，我们的应用程序需求根本不需要变得非常复杂:*

*![](img/03574eb99b9fd263b97896aa113366cc.png)*

*CALLBACK HELL*

*你可能会说，“好吧，这是一个痛苦的屁股，但它的工作，不是吗？为什么不忍气吞声编码呢？我们的运行时环境并不关心我们的代码是好看还是难看，不是吗？为什么要呢？”*

*我们应该关心。这种设置意味着我们的代码是不可移植的——当我们请求数据时，我们必须在一个回调函数中管理所有我们想做的事情。建立一个相互依赖的任务链并不容易，管理操作的顺序也不容易。*

*所有这些混乱、粗糙的嵌套意味着我们的代码将很难调试。如果你屏住呼吸，小心翼翼地编写一次应用程序，然后继续做下一件事，再也不回来，这可能不是世界末日。但是编程的现实几乎从来不是这样。我很痛苦地告诉你，但是在某些时候，你可能会在你的代码中犯错误(虽然，当你犯错误时，你可以随时查看我的[基本调试指南](/@steinerleigh/the-console-frogger-javascript-debugging-101-7f2268662777))，我并不羡慕那个可怜的笨蛋，他不得不在无尽的回调地狱中跋涉，试图找到一个孤独的挂架或错误分配的变量。而且也不能保证进行调试的人就是最初编写代码的人——很少有真正的开发者任务是由孤独的 JavaScript 牛仔从头到尾管理的。因此，当您进行大规模的 bug 搜索时，您可能甚至不记得最初是如何设置代码的。更不用说，迟早，您或其他人会想要重构这些代码，以便为新的或更新的功能让路。*

*这种丑陋不仅仅是表面的。它对你的代码工作得有多好，以及你和你的团队能够把它放在一起并维护它有多好，有着真实的负面影响。如果这是我们所有的，我们会凑合，但是…如果有更好的方法呢？*

***第二部:之前没有承诺的土地***

*![](img/a51f3d0f725cd15b4d8bc0fc672a1412.png)*

*Paradisiacal, isn’t it?*

*剧透预警:有。那么，什么是承诺，它将如何让我们摆脱我们一直以来制造的混乱？*

*A+规范是这样定义承诺的:*承诺代表异步操作的最终结果。与承诺交互的主要方式是通过它的 then 方法，该方法注册回调以接收承诺的最终值或承诺无法实现的原因。**

*这对你有意义吗？别担心，就像我说的，这是个傻瓜的游戏。相反，我们来谈谈承诺的作用。承诺基本上是一个异步动作的容器——这告诉我们，至少，承诺必须提供普通异步回调提供给我们的所有功能，因为承诺是将普通异步回调转化为实际实现起来不那么令人讨厌的格式。否则，它们就没有存在的意义——还记得我们之前说过的，这一切都是为了简化我们的工作吗？*

*承诺将把我们从筑巢中完全解放出来。承诺将会给我们一个非常容易遵循的相互依赖的行动的痕迹。Promises 将会给我们提供多种处理错误的选择，或者是可定制的，所有的格式都比我们现在拥有的更容易跟踪。承诺将使我们编写的异步、非阻塞代码像我们习惯编写的同步、“快速”阻塞代码一样可预测和单向。这很酷。我们如何做到这一点？*

*糟糕的是，除了基本的 JavaScript，承诺不依赖任何东西。Javascript 现在在其代码中本地支持承诺(从 ES6 开始)——您可以随时实例化一个新的承诺。但是你不需要那样做。在 JavaScript 中出现 promise 之前，许多勇敢的 JavaScript 作者编写了自己的 promise 库，您可以将它们安装在您的代码库中。您可能仍然想要使用它们，因为它们中的一些比 JS promise 更有效，一些可能具有对您有用的附加特性。这里有一个非常可靠的列表，来自 A+个满足其规范的库。*

*所以。**什么是承诺？诺言实际上只是一个普通的旧物件。***

*![](img/9874708a3a875fc28476b4aae0f0c499.png)*

*see, told you so.*

*这与您自己制作的任何对象没有任何不同(查看该列表，看看有多少其他编码人员已经这样做了)。它是一个由构造函数创建的对象，上面有很多有用的属性和方法。从本质上讲，有四件事让承诺成为现实:*

*1.一个承诺需要一个*执行者*。事情就是这样。我们真正需要做的事情。执行器是我们正在使用的某种函数，我们需要异步控制它的返回结果。*

*2.承诺有一个内部状态(我们不能直接访问或改变)。每个承诺开始都有一个“待定”的状态。只有一次，在它的整个“寿命”内，它可以改变。它可以从待定变为已完成(耶！)，或者从待定到拒绝(boo！).一旦我们的承诺状态转换了，它就不能再变成待定状态了。它也不能从实现到拒绝，或者从拒绝到实现。我们只有一次机会改变每个承诺。这是一件好事！承诺的状态将决定我们运行哪组回调函数(如果有的话)(那些我们标记为错误情况的，或者那些我们标记为成功情况的)。一旦一个承诺有了一个非挂起状态，这就是我们可以在未来的整个代码中依赖的事实。*

*3.承诺是有价值的。成功案例中的这个值将是我们想要的数据，如果事情出错，则是一个错误(或“原因”)。承诺的内部状态将总是与错误或数据一起解决，作为承诺的值，一旦状态改变，不仅状态不可改变，而且承诺的值也不可改变。价值一旦得到就不能改变(至少，相对于承诺本身)。这也是一种令人满意的状态——我们不希望事情在我们脚下发生变化。*

*4.最后，一个承诺要成为一个承诺，它必须能够访问一个“then”方法(稍后我们将更深入地讨论这个问题)。这将取代嵌套回调——我们将在这里处理异步操作的结果。*

***第三部分:许下承诺***

*我们在野外遇到承诺的方式主要有两种。在 JavaScript 中，我们可以访问 promise 构造函数，所以我们可以实例化一个新的 Promise，并传递给我们的 executor 和回调函数。这有点奇怪，但仍然比 vanilla sync 容易得多，因为它现在是，而且将继续是扁平的，不管我们从中链接了多少东西，任何奇怪之处都是相当前装的。这也意味着我们的代码是可移植的——我们可以在一个地方做出承诺，并在代码中的任何其他地方附加一个处理程序(我们甚至可以在同一个承诺上附加多个非链式处理程序)。*

*![](img/aa3b520cb8b5a76f5dec36a65f47fe0f.png)*

*making promises, willy-nilly*

*然而，更常见的是，我们会看到承诺得到支持，并被嵌入到我们的应用程序使用的其他库中。例如，Sequelize 帮助我们建立数据库模式，并把我们从编写自己的 SQL 查询的可怕任务中解救出来，它用其数据库动作支持承诺，因此我们可以把这些动作当作代表承诺的变量(因为它们就是)。这很好。*

*![](img/9eb668bacc22a7d0b5a5766bed162d3b.png)*

*look at how neat and pretty this is!*

*我们才刚刚接触到承诺的真正魔力。每个承诺都有一个方法，叫做“然后”用非常简单的英语术语来理解接下来做什么是最容易的。如果你有一个承诺，它将结算(即解决或拒绝)，然后运行作为回调传递给 THEN 函数的代码。更方便的是，我们传递给的函数会自动接收结果数据或错误作为参数。*

*但不止于此！只有一个对我们来说是不好的。我们之前讨论过不同的操作是如何相互依赖的，因此，为了让承诺真正有帮助，它们需要相互链接。一个 then 函数*的返回值本身就是一个新的承诺*，所以下面的 then 将接收来自*的那个*上游承诺的解析或错误作为它的自变量。*

*![](img/83792b3b25586dbd169e206153715103.png)*

*Bam!*

*突然之间，我们可以控制两个函数何时运行(或者至少，我们可以保证 reliantNewPromise 不会运行，直到某个 Promise 解析并传递它的值，我们可以在解析的*之前运行这个 AllDayPromise，等等),并保证每个函数都拥有有效运行所需的信息。再说一次——这对眼睛很好，不是吗？**

***第四部分:我们都会犯错。或者至少是错误。***

*关于我们的老朋友，香草异步回调，最令人讨厌的事情之一是 PITA 错误优先格式。带有承诺的错误管理要简单得多。首先，承诺有一个成功第一的格式。因此，在承诺链中处理错误的一种方法是传递我们的第二个函数参数，这样我们的程序就知道在任何可能的结果中该做什么。*

*![](img/f93d9b8e673af9b88c1ee9c5dd32ef0a.png)*

*A perfectly fine way to handle errors that pop up in your promise chain*

*但是承诺给了我们异步回调所没有的东西——它们给了我们冒泡。如果一个承诺拒绝，并且它当前所在的 then 没有错误情况回调，它将移动到下一个 then，以此类推，直到它找到第一个有错误情况回调的 then。因此，另一种更容易理解的管理承诺中的错误的方法是使用两个独立的 then，在成功处理 then 之后进行错误处理，我们只需将“null”作为第一个参数。*

*![](img/4c7a3c701e2b72d56fb9ecbaa9269c53.png)*

*A better, but still a bit clunky way of handling promise chain errors*

*但是…还有更好的！当抛出错误时，我们想做的事情通常是相当有限的，对吗？(比如，将它们记录到控制台，或者发送到浏览器，告诉我们的客户他们搞砸了一些事情。)如果我们可以在一个地方处理所有这些错误，那不是更好吗？由于这种冒泡能力，我们实际上可以使我们所有的 thens 只成功，并让任何错误直接滑向这个超级有用的 promise 方法“catch”这有点像 JavaScript 的 try/catch 设置——任何向上游抛出的错误都将被我们的 catch 块“捕获”,并在其回调中处理，从而避免了阻塞代码的任何其他错误处理的需要。当然，我们需要实施的地方越少，出错的机会就越少。*

*![](img/661929759b5bd65c852dbeab8d6938f9.png)*

*Ta-Da! In most cases, this will be the best way to set up your error handling*

*明确一点——承诺根据其内部状态“决定”运行哪个案例。当状态为“pending”(永远，如果承诺由于某种原因永远不会解决)，任何类型的回调都不会运行。一旦状态稳定下来，要么成功处理程序将被触发，要么错误处理程序将被触发。这里没有中间地带，没有成功和错误处理程序都执行的情况。这就是为什么承诺状态只能改变一次如此重要，而且只能以某种可预测的方式改变。对于 JavaScript 初学者来说，[最佳 JavaScript 框架](https://blog.coursesity.com/popular-javascript-frameworks/)是超越他人的最佳途径。*

***第五部分:底线***

*如果你看看这些例子中的链，你会发现承诺让我们更有效地控制我们的代码，并允许我们像在同步上下文中那样成功和错误冒泡。更好的是，管理和了解我们何时可以访问哪些数据变得更加容易。我们不仅仅局限于这种无法穿越的气泡管道，在这里我们得到一条数据，然后以一种要么用掉要么丢掉的方式进入下一条。我们也有像 Promise.all()这样的方法，我们可以聚合多个承诺的结果，并一起处理它们返回的所有数据——这意味着，如果我们愿意，我们可以一次访问它们。*

*让我们来看一个简单的例子:*

*![](img/d9d555eaef2cd66210476675392685ac.png)*

*Promise.all(yourPromisesAtOnce);*

*这里我们有一系列的承诺，包含在一个数组中。他们不依赖于彼此的成功，但我们希望他们一起成功或失败。通过将该数组传递给 JavaScript Promise 的 all 方法，我们将返回一个**单个承诺**，该承诺要么在每个承诺都已解析时解析，要么以数组中第一个拒绝的值为由拒绝。如果像我们希望的那样，我们的承诺数组完全解析，那么得到的值将是一个值数组，其结果按照原始数组中承诺的顺序进行排序— **，而不管哪个承诺首先解析。坦率地说，这不是很棒吗？***

*让我们打个漂亮的蝴蝶结。承诺给了我们简单的链接来代替无尽的嵌套——我们的代码又变成了线性的，就像我们喜欢的那样。它们为我们提供了简单、统一的错误处理。它们使我们的异步操作变得可移植——我们可以在一个地方设置它们，当它们在另一个地方完成时管理做什么，它们的时间是矛盾的，所以我们甚至可以附加更多的处理程序(或处理程序链！)时，仍然相信每个适当的成功或错误处理函数都将运行。*

*如果看起来承诺的内容比构建的过程更快，如果承诺看起来没有使用普通异步回调那么重要，那么这很好！这是成功的标志，因为从用户的角度来看，它们更简单。这就是为什么我们通常希望尽可能使用它们来代替普通的异步。*

*不幸的是，承诺不能解决我们所有的问题。他们仍然将我们缓慢获得的数据保存在我们程序中这种独立的漏斗中。我们没有一种简单的方法使来自已解决的承诺的信息在我们的应用程序中全局可用，或者保证承诺链中的代码*而不是*不会在解决之前尝试使用我们的 promise-y 数据。为此，您必须等到我开始写一篇关于 async await 的文章！*