<html>
<head>
<title>Unifying Infrastructure and Application Deployments with Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform统一基础架构和应用部署</h1>
<blockquote>原文：<a href="https://medium.com/version-1/unifying-infrastructure-and-application-deployments-with-terraform-9c8e251d68ea?source=collection_archive---------1-----------------------#2022-05-04">https://medium.com/version-1/unifying-infrastructure-and-application-deployments-with-terraform-9c8e251d68ea?source=collection_archive---------1-----------------------#2022-05-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="ca29" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">选择正确的工具</h1><p id="f3af" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">有这么多DevOps工具争夺您的注意力，要确定最适合您需求的正确工具可能会非常困难。在过去的4、5年里，我一直与Terraform合作，在多个云提供商(主要是AWS和Azure)之间部署和管理基础设施。最近，我与许多客户合作，在云中部署和成熟他们的Kubernetes托管的应用程序。我想探索是否有更简单的方法来管理与每个DevOps领域(即IaC部署和k8s应用程序版本)的发布生命周期相关的复杂性。</p><p id="5193" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">Terraform通过<em class="kf">提供商为大多数(如果不是全部)公共云提供支持；</em>便于与每个公共云的API集成的插件。由于Terraform还提供了对管理Kubernetes和Helm资源的支持，因此在管理Kubernetes和/或Helm Chart版本时利用这些提供者是有意义的；同时实现在Terraform中采用单一统一工具的优势。从版本1的角度来看，Terraform是一个很好理解的工具(特别是从云集成的角度来看)，因此当将范围扩大到Kubernetes或Helm这样的新提供商时，进入的障碍很低。同样，通过采用单一工具，我们有助于减少与管理和支持大型云资产相关的运营开销。</p><p id="a826" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这篇文章的目的是展示如何利用Terraform和Azure DevOps来管理底层Kubernetes基础设施部署和应用程序版本的Helm Charts的生命周期。</p><h1 id="cc62" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">假设</h1><p id="50ed" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">为了举例说明这种方法在现实场景中是如何实现的，我做了以下假设:</p><ul class=""><li id="33d6" class="kg kh hh je b jf ka jj kb jn ki jr kj jv kk jz kl km kn ko bi translated">开发团队负责管理应用程序的源代码和每个应用程序的容器映像的生命周期。例如，当使用新功能更新源代码时，会触发构建管道，并将新图像推送到Azure Container Registry。</li><li id="7243" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">然后这个Azure Continuer注册表就可以让我们的Helm Chart下拉图片了</li></ul><h1 id="7955" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">知识库结构</h1><p id="989f" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">为了与最佳实践保持一致，并在我们的云基础架构部署中提供可预测性和一致性，我们始终鼓励使用Terraform模块来提供向后兼容性和安全配置。在这个例子中，我创建了三个Terraform <em class="kf">根</em>模块(下面将详细描述)，每个模块实例化一个或多个Terraform <em class="kf">子模块</em>(更多关于子模块和根模块<a class="ae ku" href="https://www.terraform.io/language/modules/syntax" rel="noopener ugc nofollow" target="_blank">的区别，这里是</a>)。</p><p id="c9d6" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">所有模块——无论是根模块还是子模块——都对应于一个专用的Azure DevOps存储库和一个专用的Azure DevOps管道。有许多例子表明Terraform模块被嵌入到存储库的本地目录中，但是这种方法不被推荐，因为它降低了可伸缩性。</p><p id="698f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">Terraform根模块及其管理的资源如下所述。为了说明每个模块的内容，我还包含了一个目录结构的<em class="kf">树</em>。</p><p id="f72e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><em class="kf">订阅-基线-模块</em></p><p id="7062" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这个Terraform模块负责<em class="kf">启动/初始化</em>Azure订阅。当使用新的订阅时，这是应该调用的第一个模块。至少，它应该配置为部署Azure策略和订阅范围的密钥库。Azure Policy service允许我们在任何工作负载部署之前对订阅实施组织和治理控制，因此降低了影子IT的可能性。例如，在这里，我们将定义允许我们部署到的Azure区域，我们的虚拟机应该符合多大的SKU规模，等等。作为该模块的一部分部署的密钥库提供了一个秘密存储，后续的Terraform模块/管道将利用该秘密存储来创建/检索秘密、密钥等。</p><blockquote class="kv kw kx"><p id="0546" class="jc jd kf je b jf ka jh ji jj kb jl jm ky kc jp jq kz kd jt ju la ke jx jy jz ha bi translated"><em class="hh">TF-az-root-su B- baseline/<br/>├──az-policy . TF<br/>├──config<br/>│├──dev . TF vars<br/>│├──prd . TF vars<br/>│└──UAT . TF vars<br/>├──key-vault . TF<br/>└──vars . TF<br/>1个目录，6个文件</em></p></blockquote><p id="1de2" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><em class="kf">k8s-基础模块</em></p><p id="bf8c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">该模块将部署托管Azure Kubernetes服务(AKS)集群所需的底层基础设施。作为该模块的一部分部署的资源包括虚拟网络(包括子网、路由表、网络安全组—所有这些都在虚拟网络<em class="kf">子</em>模块中抽象)、AKS集群本身、PaaS SQL数据库(用于持久存储数据)和跳转虚拟机(用于在部署后访问集群的Ubuntu VM)。</p><p id="968c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">可以想象，这里部署的许多资源都需要一个秘密存储来托管或检索敏感数据。例如，SQL数据库需要用户名和密码。为此，我们将利用作为上述<em class="kf">订阅-基线-模块</em>的一部分而创建的密钥库。</p><blockquote class="kv kw kx"><p id="d1e6" class="jc jd kf je b jf ka jh ji jj kb jl jm ky kc jp jq kz kd jt ju la ke jx jy jz ha bi translated"><em class="hh">TF-az-root-k8s-infra/<br/>├──aks . TF<br/>├──config<br/>│├──dev . TF vars<br/>│├──prd . TF vars<br/>│└──UAT . TF vars<br/>├──SQL . TF<br/>├──vars . TF<br/>└──vnet . TF<br/>1目录，7个文件</em></p></blockquote><p id="f7aa" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">舵释放模块</p><p id="3b7d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">本模块将通过掌舵图的方式部署和管理应用程序版本。请参见下面的代码片段，它展示了这个存储库的目录结构。请注意，舵图位于存储库的本地。</p><blockquote class="kv kw kx"><p id="98ce" class="jc jd kf je b jf ka jh ji jj kb jl jm ky kc jp jq kz kd jt ju la ke jx jy jz ha bi translated"><em class="hh">TF-az-root-helm-release/<br/>├──配置<br/>│├──dev . TF vars<br/>│├──prd . TF vars<br/>│└──UAT . TF vars<br/>├──helm-chart<br/>│├──dev-values . YAML<br/>│├──prd-values . YAML<br/>│├──模板<br/>│├──deployments . YAML<br/>│├──ingress-controller。</em></p></blockquote><h1 id="ee7f" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">部署顺序和依赖关系</h1><p id="281c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">对于初始部署，上述根模块应按照其布局顺序进行部署，即首先部署<em class="kf">订阅-基线-模块</em>，然后部署</p><p id="6a99" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><em class="kf">k8s-红外模块</em>，随后是<em class="kf">舵释放模块</em>。通常，订阅基线模块将是相对静态的，并且仅在需要新的Azure策略或需要新的订阅范围的资源时更新。</p><p id="f067" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在向AKS集群部署资源之前，<em class="kf">舵释放模块</em>需要对AKS集群进行认证。我们不是将Terraform指向一个本地<em class="kf"> kubeconfig </em>文件来针对集群进行身份验证，而是通过使用<em class="kf"> terraform_remote_state </em>数据源来检索必要的凭证。该数据源将允许我们从作为<em class="kf"> k8s-infra-module </em>的一部分部署的资源中检索详细信息。下面举例说明了如何使用该数据源。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lb"><img src="../Images/6e111b3ffaf54e2cd72f0d1b89082fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lEBS_000aPhnago1NlrjsA.jpeg"/></div></div></figure><p id="bd5f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在配置Helm provider时，我们可以安全地检索必要的凭证，而不必硬编码或手动输入任何机密。下面的片段说明了这是如何实现的。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ln"><img src="../Images/9f94825be9bd624d88f51c7feccc2f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gALbAwJBiQenPF6h6cVzBA.jpeg"/></div></div></figure><p id="4871" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">出于这个例子的目的，我使用了一个位于<em class="kf"> helm-release-module </em>库的本地Helm图表。使用这种方法，我们需要配置我们的Terraform代码，以指向图表的位置，即路径。类似地，我们需要配置特定于环境的值文件的路径，该文件应该根据我们要部署到的环境来调用。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lo"><img src="../Images/9543bbf1cc98872d26336626c9b08801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EIU1hubBeeekljXdYaOuug.jpeg"/></div></div></figure><h1 id="3329" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论</h1><p id="7831" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">本练习的目的是验证Terraform头盔供应商的能力。由于只掌握了Helm CLI工具的补救知识，我想评估将提供者与更常见的Terraform提供者(即azurerm提供者)集成所需的工作量。这个过程非常简单。</p><p id="449c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">使用Terraform管道以声明方式部署Helm图表的好处显然超过了创建单独的Helm CLI管道的替代选项。后者引入了一种新工具，需要进一步的培训，并增加了解决方案整体管理的复杂性。诚然，当涉及到对<em class="kf"> helm_resource的问题进行故障诊断和评估时，</em>我建议需要具备Helm CLI的中级知识。</p><h1 id="ee90" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">进一步的考虑</h1><ul class=""><li id="7e02" class="kg kh hh je b jf jg jj jk jn lp jr lq jv lr jz kl km kn ko bi translated">在这种情况下，正在部署的订阅将为特定产品(<em class="kf"> myapp </em>)托管一个环境，因此一个产品/DevOps团队负责部署/发布到该环境。如果这是一个共享订阅，其中多个产品由多个产品/开发运维团队部署，我们通常会将虚拟网络和AKS组件拆分为独立的根模块，以减少与每个应用版本相关的爆炸半径，并限制这些核心组件的暴露。</li><li id="4d85" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">在版本1中，我们开发了成熟的持续集成和持续部署模式，以受控和治理的方式管理所有Terraform部署，例如通过在部署前引入各种林挺、验证、安全检查和测试。上面没有详细介绍这些内容。</li><li id="7c85" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">这篇文章没有说明如何管理多个环境，以及如何以一种受治理的方式控制部署，例如，通过配置对拉请求的批准，禁止推送到主/发布分支，等等</li><li id="1893" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">为了移动到更成熟的GitOps模型，<em class="kf">舵释放模块</em>可以被配置为在每次新舵图表被推送到ACR时触发。</li><li id="8d20" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">除了使用Key Vault，创建Azure DevOps变量组在运行时将秘密注入管道也是一个可行的选择。然而，这意味着您现在有两个地方来管理对敏感数据的访问和权限。用于所有Terraform管道的单个订阅范围的密钥库极大地减少了这种管理开销。</li><li id="2f5f" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">最好的做法是在一个独立的人工制品中对你的舵图进行版本控制，类似于容器的版本控制，而不是将舵图存放在一个标准的Git存储库中。Azure Container Registry现在支持托管头盔图表作为OCI人工制品，这将允许我们在运行Terraform时下拉特定的图表版本，并消除本地托管图表的需要。</li></ul><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ls"><img src="../Images/ff96d4d74e69088e201179535bfb3ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-EXRh62Vv1wF6hGc8enkg.jpeg"/></div></div></figure><p id="30a4" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">关于作者:<br/> </strong>马克·凯利是这里版本1的云架构师。</p></div></div>    
</body>
</html>