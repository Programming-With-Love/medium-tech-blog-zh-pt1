<html>
<head>
<title>WorkManager — Kotlin APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工作管理器—kot Lin API</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/workmanager-kotlin-apis-a0fb9dfbfeb6?source=collection_archive---------0-----------------------#2021-01-07">https://medium.com/androiddevelopers/workmanager-kotlin-apis-a0fb9dfbfeb6?source=collection_archive---------0-----------------------#2021-01-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f54d5257763f1249e0482b52c4b4c9b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D2aKnfPkmj71LZWVghXjcQ.png"/></div></div></figure><div class=""/><p id="682c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/workmanager" rel="noopener ugc nofollow" target="_blank"> WorkManager </a>提供了一组API，可以轻松调度异步任务，以便立即或延迟执行，即使应用程序关闭或设备重启，这些任务也有望运行。对于Kotlin用户，WorkManager为协程提供了一流的支持。在这篇文章中，我将通过构建<a class="ae jn" href="https://developer.android.com/codelabs/android-workmanager#0" rel="noopener ugc nofollow" target="_blank">工作管理器代码实验室</a>向你展示带有协程的工作管理器的基础知识。所以让我们开始吧！</p><h1 id="897a" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">工作管理器的基础知识</h1><p id="8ce7" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">WorkManager库是任何应该继续运行的任务的推荐选择，即使用户导航离开特定屏幕、用户将应用程序置于后台或设备重启。常见任务可能是:</p><ul class=""><li id="25ac" class="kr ks hs ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated">上传日志或报告数据</li><li id="8638" class="kr ks hs ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">将滤镜应用于图像并保存图像</li><li id="3056" class="kr ks hs ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">定期将本地数据与网络同步</li></ul><p id="c7e0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果当用户离开某个范围(比如屏幕)时，您的即时任务会结束，我们建议您直接使用Kotlin协程。</p><p id="fea0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">WorkManager codelab会模糊图像并将结果保存在磁盘上。让我们看看需要什么来实现这一点。</p><p id="58ec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们添加了<code class="du lf lg lh li b">work-runtime-ktx</code>依赖项。</p><pre class="lj lk ll lm fd ln li lo lp aw lq bi"><span id="e708" class="lr jp hs li b fi ls lt l lu lv">implementation "androidx.work:work-runtime-ktx:$work_version"</span></pre><p id="053d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们从实现自己的工人类开始。这是我们为您希望在后台执行的实际工作放置代码的地方。您将扩展Worker类并覆盖doWork()方法。因为这是最重要的一门课，我们稍后会详细讲解。下面是初始实现的样子。</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="4a2f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我们构建我们的工作请求，在我们的例子中，我们希望只执行一次工作，所以我们使用一个<code class="du lf lg lh li b"><a class="ae jn" href="https://developer.android.com/reference/androidx/work/OneTimeWorkRequest.Builder" rel="noopener ugc nofollow" target="_blank">OneTimeWorkRequest.Builder</a></code>。作为输入，我们设置我们想要模糊的图像的<code class="du lf lg lh li b">Uri</code>。</p><p id="453a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Kotlin提示:要创建输入数据，我们可以使用创建数据构建器的<code class="du lf lg lh li b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/work/package-summary#workdataof" rel="noopener ugc nofollow" target="_blank">workDataOf</a></code>函数，放置键-值对并为我们创建数据。</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="c553" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了调度工作并使其运行，我们使用WorkManager类。我们可以提供要完成的任务以及对这些任务的约束。</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><h1 id="0b02" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">让工人做这项工作</h1><p id="3bcb" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">当你使用一个<code class="du lf lg lh li b"><a class="ae jn" href="https://developer.android.com/reference/androidx/work/Worker?hl=en" rel="noopener ugc nofollow" target="_blank">Worker</a></code>时，WorkManager会自动在后台线程上调用<code class="du lf lg lh li b">Worker.doWork()</code>。从<code class="du lf lg lh li b">doWork()</code>返回的<code class="du lf lg lh li b">Result</code>通知工作管理器服务工作是否成功，如果失败，是否应该重试工作。</p><p id="0972" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lf lg lh li b">Worker.doWork()</code>是一个同步调用——你应该以一种阻塞的方式完成所有的后台工作，并在方法退出时完成。如果您在doWork()中调用异步API并返回结果，您的回调可能无法正常运行。</p><h1 id="e68b" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">但是如果我们想做异步工作呢？</h1><p id="6148" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">让我们把我们的例子复杂化，假设我们想保存数据库中所有模糊文件的uri。</p><p id="c604" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为此我创造了:</p><ul class=""><li id="c75a" class="kr ks hs ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated">一个简单的模糊图像实体</li><li id="8c86" class="kr ks hs ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">用于插入和获取图像的dao类</li><li id="fa5e" class="kr ks hs ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">数据库</li></ul><p id="2865" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">点击查看实现<a class="ae jn" href="https://github.com/googlecodelabs/android-workmanager/pull/213" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e6b2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你必须做异步工作，比如在数据库中保存数据或者做网络请求，在Kotlin中，我们推荐使用<code class="du lf lg lh li b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/work/CoroutineWorker" rel="noopener ugc nofollow" target="_blank">CoroutineWorker</a></code>。</p><p id="44e7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">协同工作器允许我们使用Kotlin协同程序进行异步工作。</p><p id="991e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lf lg lh li b">doWork()</code>方法是一种<code class="du lf lg lh li b">suspend</code>方法。这意味着我们可以很容易地在这里调用我们的悬浮道。</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="5783" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">默认情况下<code class="du lf lg lh li b">doWork()</code>使用<code class="du lf lg lh li b">Dispatchers.Default</code>。您可以用您需要的调度程序覆盖它。在我们的例子中，我们不需要这样做，因为Room已经将插入工作转移到了不同的调度程序上。查看Kotlin APIs发布的房间以了解更多细节。</p></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><p id="890f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">开始使用<code class="du lf lg lh li b">CoroutineWorker</code>执行即使用户关闭你的应用也需要完成的异步工作。</p><p id="4b70" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您想了解更多关于WorkManager的知识，请继续关注未来的系列文章，专门深入探讨它。在此之前，请查看我们的代码实验室和文档:</p><ul class=""><li id="c65f" class="kr ks hs ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated"><a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/workmanager/" rel="noopener ugc nofollow" target="_blank">工作管理器文档</a></li><li id="fedf" class="kr ks hs ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated"><a class="ae jn" href="https://developer.android.com/codelabs/android-workmanager#0" rel="noopener ugc nofollow" target="_blank">使用工作管理器</a> codelab</li><li id="3118" class="kr ks hs ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated"><a class="ae jn" href="https://developer.android.com/codelabs/android-adv-workmanager#0" rel="noopener ugc nofollow" target="_blank">高级工作管理器</a>代码实验室</li></ul></div></div>    
</body>
</html>