<html>
<head>
<title>Secure Docker Containers Require Secure Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安全Docker容器需要安全的应用程序</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/secure-docker-containers-require-secure-applications-75eb358abef9?source=collection_archive---------0-----------------------#2019-05-13">https://medium.com/capital-one-tech/secure-docker-containers-require-secure-applications-75eb358abef9?source=collection_archive---------0-----------------------#2019-05-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="f534" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">理解容器如何工作是理解如何保护它们的第一步</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/8c36ebbaf2baceb14d6d5021071d1ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0R4usCukTEYkS2vS-nHD4w.jpeg"/></div></div></figure><p id="0335" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">应用程序容器是出现并重塑整个行业的伟大技术之一。从历史上看，这种中断很少见；实时见证像Docker这样的产品如何从一个想法的种子发展成为当今数字领域的必备主干是非常了不起的。我自己作为技术人员的职业生涯与Docker及其更大的容器生态系统的发展和成熟是并行的。随着容器和容器平台的发展，它们周围的社区也在增长，基于容器的产品已经渗透到我们的技术堆栈中。然而，尽管如此，容器实际上是如何工作的，以及它们给运行在其中的应用程序带来的安全隐患，仍然有些神秘。这是我今天想尝试解决的话题。</p><p id="c5d9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">注意:虽然我知道有许多容器运行时和方案(</em> <a class="ae kf" href="https://linuxcontainers.org/" rel="noopener ugc nofollow" target="_blank"> <em class="ke"> lxc </em> </a> <em class="ke">，</em> <a class="ae kf" href="https://coreos.com/rkt/" rel="noopener ugc nofollow" target="_blank"> <em class="ke"> rkt </em> </a> <em class="ke">，</em><a class="ae kf" href="https://docker.io" rel="noopener ugc nofollow" target="_blank"><em class="ke">Docker</em></a><em class="ke">等)。)我将特别关注Docker，因为它无疑是最受欢迎的。</em></p><h1 id="ef2a" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">打开Docker图像包装</h1><p id="e11b" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">首先，我们需要了解什么是<a class="ae kf" href="https://docs.docker.com/glossary/?term=image" rel="noopener ugc nofollow" target="_blank">码头工人形象</a>。从广义上讲，图像就像容器模板，既可以独立运行，也可以在其上创建新的图像。从更专业的角度来说，图像只是。包含文件系统的tar存档。就是这样！</p><p id="594b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一旦从映像库(如<a class="ae kf" href="http://hub.docker.com" rel="noopener ugc nofollow" target="_blank">hub.docker.com</a>)下载了映像，它们就会被解压缩并存储在主机的文件系统中。我们实际上可以通过导航到映像路径来检查文件系统上的这些映像(对于使用overlay2存储驱动程序的主机，<code class="du ld le lf lg b">/var/lib/docker/overlay2</code>)。每个图像层都以sha256哈希命名；这是官方阿尔卑斯山图片的基础图层:</p><pre class="ix iy iz ja fd lh lg li lj aw lk bi"><span id="c752" class="ll kh hh lg b fi lm ln l lo lp"><br/>root@ip-XXXXXXXXXXX:/var/lib/docker/overlay2/56abedeb5085c1ad962f3dec89d1e9bc6b584ee06d9bed0897221417bb496c56/diff# ls -la<br/>total 72<br/>drwxr-xr-x 18 root root 4096 Jan 24 16:41 .<br/>drwx------  3 root root 4096 Jan 24 16:41 ..<br/>drwxr-xr-x  2 root root 4096 Dec 20 22:25 bin<br/>drwxr-xr-x  2 root root 4096 Dec 20 22:25 dev<br/>drwxr-xr-x 15 root root 4096 Dec 20 22:25 etc<br/>drwxr-xr-x  2 root root 4096 Dec 20 22:25 home<br/>drwxr-xr-x  5 root root 4096 Dec 20 22:25 lib<br/>drwxr-xr-x  5 root root 4096 Dec 20 22:25 media<br/>drwxr-xr-x  2 root root 4096 Dec 20 22:25 mnt<br/>dr-xr-xr-x  2 root root 4096 Dec 20 22:25 proc<br/>drwx------  2 root root 4096 Dec 20 22:25 root<br/>drwxr-xr-x  2 root root 4096 Dec 20 22:25 run<br/>drwxr-xr-x  2 root root 4096 Dec 20 22:25 sbin<br/>drwxr-xr-x  2 root root 4096 Dec 20 22:25 srv<br/>drwxr-xr-x  2 root root 4096 Dec 20 22:25 sys<br/>drwxrwxrwt  2 root root 4096 Dec 20 22:25 tmp<br/>drwxr-xr-x  7 root root 4096 Dec 20 22:25 usr<br/>drwxr-xr-x 11 root root 4096 Dec 20 22:25 var<br/>root@ip-XXXXXXXXXXX:/var/lib/docker/overlay2/56abedeb5085c1ad962f3dec89d1e9bc6b584ee06d9bed0897221417bb496c56/diff#</span></pre><p id="7880" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">正如我们所看到的，它实际上只是一个保存文件系统的目录。那么，文件系统如何变成一个运行的容器呢？</p><h1 id="ff51" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">参见cgroup。请参见群组运行</h1><p id="ba22" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">现在，我们来谈谈Linux cgroups。<a class="ae kf" href="http://manpages.ubuntu.com/manpages/cosmic/man7/cgroups.7.html" rel="noopener ugc nofollow" target="_blank"> Cgroups </a>或“控制组”，是Linux内核的一个功能，它允许将进程组与机器的其余部分隔离开来。使用cgroups，一个进程可以拥有一个“虚拟”文件系统、资源限制、防火墙网络和许多其他特性。如果这听起来像Docker容器，那你就对了！Docker利用cgroups来运行它的容器。</p><p id="eed4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了运行一个容器，Docker守护进程采取以下步骤(大致):</p><ul class=""><li id="46de" class="lq lr hh jk b jl jm jo jp jr ls jv lt jz lu kd lv lw lx ly bi translated">从每个图像层编译虚拟文件系统。</li><li id="c337" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">创建新的cgroup。</li><li id="2aa8" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">将虚拟文件系统挂载到cgroup。</li><li id="4c5e" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">将cgroup限制设置为由映像元数据(存储在本地数据库中)定义的限制。</li><li id="4d18" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">设置组网络。</li><li id="65fb" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated">启动图像文件<code class="du ld le lf lg b"><strong class="jk hi">CMD</strong></code>或<code class="du ld le lf lg b"> <strong class="jk hi">ENTRYPOINT</strong></code>中定义的过程。</li></ul><p id="3e47" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">恭喜你！现在，您有了一个正在运行的Docker容器。事实上，如果你想检查正在运行的容器，你可以使用ps找到它的进程:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es me"><img src="../Images/6c21b86bbcb74f208c242d08f0e4e658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f32ZbmwkS4LidLCBC2WHtA.png"/></div></div></figure><h1 id="8bf0" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">探索如何构建安全的容器</h1><p id="3a26" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">当你深入了解Docker的工作原理时，你会发现它本身并没有什么革命性的东西。它只是利用已经支持的内核原语，如cgroups，并将它们打包成一个更简单、更易于使用的产品。但是由于Docker并没有在实际的内核机制上构建太多东西，所以它处理的容器和它托管的应用程序只和内核本身一样安全。这意味着Docker守护进程、它的映像和它的容器没有自己真正的内置安全特性，这些特性允许嵌入的秘密保持秘密或防止未经授权的第三方访问它们的进程和文件系统。我们可以通过探索一些在容器映像中隐藏秘密的更流行的方法来测试这一点:在映像构建时注入秘密，在容器运行时将秘密放入环境变量中。</p><h2 id="a4d7" class="ll kh hh bd ki mf mg mh km mi mj mk kq jr ml mm ks jv mn mo ku jz mp mq kw mr bi translated"><strong class="ak">测试#1在构建时将秘密注入容器</strong></h2><p id="f6e4" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">让我们创建一个新的Docker容器。实际上，这很简单。我们需要的只是一个Docker文件(假设您已经安装了一个Docker)。</p><pre class="ix iy iz ja fd lh lg li lj aw lk bi"><span id="2025" class="ll kh hh lg b fi lm ln l lo lp">FROM alpine:latest<br/>ADD super.secret /super.secret<br/>CMD /bin/sh</span></pre><p id="d6e2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们将创建一个名为super.secret的文件来注入容器:</p><pre class="ix iy iz ja fd lh lg li lj aw lk bi"><span id="52de" class="ll kh hh lg b fi lm ln l lo lp">$&gt; echo "this is a secret" &gt; super.secret</span></pre><p id="7e66" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在我们可以建立图像。</p><pre class="ix iy iz ja fd lh lg li lj aw lk bi"><span id="0866" class="ll kh hh lg b fi lm ln l lo lp">root@ip-XXXXXXXXXXX:~/docker# docker build -t secret:test .<br/>Sending build context to Docker daemon  3.072kB<br/>Step 1/3 : FROM alpine:latest<br/>---&gt; 3f53bb00af94<br/>Step 2/3 : ADD super.secret /super.secret<br/>---&gt; 61ea9104ee5d<br/>Step 3/3 : CMD /bin/sh<br/>---&gt; Running in 2a1b90e4b209<br/>Removing intermediate container 2a1b90e4b209<br/>---&gt; c3713649d32e<br/>Successfully built c3713649d32e<br/>Successfully tagged secret:test<br/>root@ip-XXXXXXXXXXX:~/docker#</span></pre><p id="2513" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">太好了！我们有一个图像，现在包含了我们的秘密(密码，证书，任何你想保密的东西)。那么，如果我们在文件系统中搜索这个秘密文件，会发生什么呢？</p><pre class="ix iy iz ja fd lh lg li lj aw lk bi"><span id="e81f" class="ll kh hh lg b fi lm ln l lo lp">root@ip-XXXXXXXXXXX:~/docker# find / | grep super.secret<br/>/root/docker/super.secret<br/>/var/lib/docker/overlay2/11567f3bcc1b8e844e22ba37cfef2432ea319247e403707497022edebfd7a7ce/diff/super.secret<br/>root@ip-XXXXXXXXXXX:~/docker#</span></pre><p id="3a83" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这可不好。我们不仅找到了文件，而且还可以读回那个文件。</p><pre class="ix iy iz ja fd lh lg li lj aw lk bi"><span id="66b9" class="ll kh hh lg b fi lm ln l lo lp">root@ip-XXXXXXXXXXX:~/docker# cat /var/lib/docker/overlay2/11567f3bcc1b8e844e22ba37cfef2432ea319247e403707497022edebfd7a7ce/diff/super.secret<br/>this is a secret<br/>root@ip-XXXXXXXXXXX:~/docker#</span></pre><p id="1fc0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这是因为，正如我们前面所探讨的，Docker映像只是存在于Docker主机上的文件系统。现在，在这种情况下，我们显然没有暴露任何东西，因为a)秘密是<code class="du ld le lf lg b"><em class="ke">“this is a secret”</em></code>和b)图像从未离开我们的本地主机。但是，为了便于讨论，假设我们将我们的图像推送到Docker Hub，或者像Artifactory这样的内部企业存储库。现在，任何对该图像拥有“拉”权限的人都可以访问我们的秘密，这意味着该秘密不再是真正的秘密了。</p><p id="bd06" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">那么环境变量呢？那些肯定更安全吗？</p><h2 id="b281" class="ll kh hh bd ki mf mg mh km mi mj mk kq jr ml mm ks jv mn mo ku jz mp mq kw mr bi translated"><strong class="ak">测试#2在环境变量中注入秘密</strong></h2><p id="6605" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">让我们回过头来修改Dockerfile，添加一个名为<code class="du ld le lf lg b">SECRET</code>的环境变量。</p><pre class="ix iy iz ja fd lh lg li lj aw lk bi"><span id="d268" class="ll kh hh lg b fi lm ln l lo lp">FROM alpine:latest<br/>ENV SECRET="" # blank secret that we'll over-write at run-time.<br/>CMD /bin/sh</span></pre><p id="64ee" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在我们可以建立这个新的形象。</p><pre class="ix iy iz ja fd lh lg li lj aw lk bi"><span id="3b4f" class="ll kh hh lg b fi lm ln l lo lp">root@ip-XXXXXXXXXXX:~/docker# docker build -t secret:testenv .<br/>Sending build context to Docker daemon  3.072kB<br/>Step 1/3 : FROM alpine:latest<br/>---&gt; 3f53bb00af94<br/>Step 2/3 : ENV SECRET=""<br/>---&gt; Running in a1872c8078c3<br/>Removing intermediate container a1872c8078c3<br/>---&gt; 178c24f06c44<br/>Step 3/3 : CMD /bin/sh<br/>---&gt; Running in bccf052509b7<br/>Removing intermediate container bccf052509b7<br/>---&gt; cca1f3bd8248<br/>Successfully built cca1f3bd8248<br/>Successfully tagged secret:testenv<br/>root@ip-XXXXXXXXXXX:~/docker#</span></pre><p id="620a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因此，现在我们所做的就是将漏洞从文件系统转移到流程环境。虽然这种改变消除了通过图像存储库传播的秘密，但是这种方法仍然不能防止其他容器或用户访问正在运行的容器中的秘密。让我们来探索如何。</p><p id="ec6a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">首先，我们需要运行我们的新容器。由于它默认运行/bin/sh并需要用户输入，我们可以用sleep命令覆盖它，使它在后台运行。</p><pre class="ix iy iz ja fd lh lg li lj aw lk bi"><span id="1080" class="ll kh hh lg b fi lm ln l lo lp">root@ip-XXXXXXXXXXX:~/docker# docker run -d -e SECRET="this is a secret" secret:testenv sleep 300</span></pre><p id="6d91" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这将使容器在退出前运行五分钟。</p><p id="730d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，就像我们用Nginx做的那样，我们可以用ps找到在容器中运行的睡眠进程:</p><pre class="ix iy iz ja fd lh lg li lj aw lk bi"><span id="026e" class="ll kh hh lg b fi lm ln l lo lp">root@ip-XXXXXXXXXXX:~/docker# clear<br/>root@ip-XXXXXXXXXXX:~/docker# ps aux | grep sleep<br/>root     12184  0.0  0.0   1516     4 ?        Ss   17:06   0:00 <br/>sleep 300<br/>root     12342  0.0  0.0  12944   940 pts/1    S+   17:06   0:00 grep --color=auto sleep<br/>root@ip-XXXXXXXXXXX:~/docker#</span></pre><p id="f854" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">记下PID ( <code class="du ld le lf lg b">12184</code>)，然后我们可以通过导航到/proc/9944并查看environ文件来检查流程环境:</p><pre class="ix iy iz ja fd lh lg li lj aw lk bi"><span id="7399" class="ll kh hh lg b fi lm ln l lo lp">root@ip-XXXXXXXXXXX:~/docker# cat /proc/12184/environ<br/>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=6ddf6d9e588dSECRET=this is a secret HOME=/root<br/>root@ip-XXXXXXXXXXX:~/docker#</span></pre><p id="9dd0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然比前一种方法稍微安全一点(而且肯定更加模糊)，但它仍然没有我们希望的那么安全。</p><h1 id="4849" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">安全容器需要安全的应用程序</h1><p id="c4cd" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">图像和容器不应该被认为是本质安全的——在一个安全的环境中，容器的安全和可接受的使用来自于在应用程序栈的每一层正确地实现安全性。因此，安全性应该在<em class="ke">应用层</em>实现。为了正确地做到这一点，我们需要考虑一些常见的陷阱。</p><h2 id="69f2" class="ll kh hh bd ki mf mg mh km mi mj mk kq jr ml mm ks jv mn mo ku jz mp mq kw mr bi translated">陷阱1:将秘密硬编码到应用程序中</h2><p id="536c" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">尤其是在一个发布周期更快的项目中，将所有秘密都放入源代码的诱惑是巨大的。尤其是当您可以在部署新版本时轮换机密时。然而，这带来了一些问题。其中最主要的是，你必须把这些秘密放进代码里。</p><p id="14fe" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">无论代码在哪里，你的秘密也在哪里。假设每个人都使用某种版本控制系统(VCS ),比如GitHub、Bitbucket或GitLab，那么在项目的生命周期中，你的秘密将在那个VCS中。更糟糕的是，这些秘密将继续存在于该项目的提交历史中。即使您定期轮换您的机密，提交历史也为任何愿意做这项工作的人提供了这些机密是如何生成的模式，一旦他们理解了该模式，他们就可以尝试预测下一个将会是什么。</p><p id="44ce" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">将秘密放入VCS还确保他们的视野(秘密可以从需要知道它们的人那里传播多远)相当大，组织中的每个人都可以对该组织的VCS系统进行只读访问。</p><h2 id="b300" class="ll kh hh bd ki mf mg mh km mi mj mk kq jr ml mm ks jv mn mo ku jz mp mq kw mr bi translated">陷阱2:将环境变量用于秘密</h2><p id="ae9e" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">正如我们之前已经讨论过的，你不应该把秘密放入环境变量中。说够了。</p><h2 id="a6dc" class="ll kh hh bd ki mf mg mh km mi mj mk kq jr ml mm ks jv mn mo ku jz mp mq kw mr bi translated">陷阱3:没有为每个应用程序和环境使用唯一的秘密。</h2><p id="984a" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">拥有多个帐户、应用程序、API、网络和其他系统的一个问题是跟踪他们最终需要的秘密。帐户有密码，应用程序有加密密钥和证书，API有API密钥，网络有数据包标志或MAC地址，这样的列表还有很多——现在需要跟踪这个列表。</p><p id="50ce" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">有一种非常真实的诱惑，那就是简单地对所有事情使用同一个秘密，这样你就只需要记住或跟踪一件事情，而不是几件。这不仅仅是消费者领域的问题，在消费者领域，人们<a class="ae kf" href="http://time.com/5071176/worst-passwords-2017/" rel="noopener ugc nofollow" target="_blank">一遍又一遍地使用同一个密码</a>，在他们的银行、购物、纳税申报单、DMV门户网站等之间共享他们唯一的秘密。这对开发人员和企业IT来说也是一个问题。跨应用程序重用像证书或API密钥这样的秘密会产生一连串的漏洞:如果一个应用程序的秘密被识别，但它们被另一个应用程序共享，那么第二个应用程序也容易受到攻击。秘密的重复使用也增加了它们的寿命，而时间是秘密的敌人。秘密使用的时间越长，泄露秘密的可能性就越大。</p><h2 id="ad49" class="ll kh hh bd ki mf mg mh km mi mj mk kq jr ml mm ks jv mn mo ku jz mp mq kw mr bi translated">陷阱4:在不安全的地方存储秘密</h2><p id="b0c1" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">这与第一个陷阱有关，那就是你永远不应该把你的秘密存放在不安全的地方。这包括共享存储、未加密文件、版本控制系统、电子邮件、聊天应用程序、发展规划应用程序、短信、信鸽、12世纪羊皮纸、数据库和手写笔记本。仅举几个例子。正如我们最近看到的，一种意外暴露数据的常见方法是通过亚马逊S3服务上的用户错误，尽管这不是亚马逊的错。使用S3作为一个安全的储存库是一个坏主意，因为像<a class="ae kf" href="https://arstechnica.com/information-technology/2017/05/defense-contractor-stored-intelligence-data-in-amazon-cloud-unprotected/" rel="noopener ugc nofollow" target="_blank"> Booz-Allen Hamilton这样的公司最近发现</a>他们通过一个配置非常差的S3桶意外泄露了地理空间情报图像，威瑞森和埃森哲也有自己的灾难。虽然第四个缺陷可以说是四个缺陷中最不严重的，但是有一些方法可以正确地保护机密，并且可以在所有类型的应用程序中使用。</p><h2 id="eff9" class="ll kh hh bd ki mf mg mh km mi mj mk kq jr ml mm ks jv mn mo ku jz mp mq kw mr bi translated">解决办法</h2><p id="3332" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">这里的解决方案是实现某种秘密管理，要么通过云提供商(如AWS的<a class="ae kf" href="https://aws.amazon.com/secrets-manager/?hp=tile&amp;so-exp=below" rel="noopener ugc nofollow" target="_blank">秘密管理器</a>和<a class="ae kf" href="https://aws.amazon.com/kms/?hp=tile&amp;so-exp=below" rel="noopener ugc nofollow" target="_blank"> KMS </a>)、定制应用程序，要么通过第三方应用程序，如<a class="ae kf" href="https://www.vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> Hashicorp Vault </a>、<a class="ae kf" href="https://www.cyberark.com/" rel="noopener ugc nofollow" target="_blank"> CyberArk </a>、<a class="ae kf" href="https://docs.saltstack.com/en/latest/topics/pillar/" rel="noopener ugc nofollow" target="_blank"> Salt </a>或类似的应用程序。最终的结果应该是一个没有秘密概念的容器基础结构、根据需要动态获取秘密的应用程序，以及与基础结构的其余部分分开管理和轮换的秘密。</p><p id="fe8a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">应该注意的是，严格遵循<a class="ae kf" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank">“12因素应用”</a>思想的应用如果<a class="ae kf" href="https://12factor.net/config" rel="noopener ugc nofollow" target="_blank">使用环境变量进行所有的配置</a>，将是不安全的。虽然12因素应用程序提出的想法是一个很好的起点(Capital One自己的吉米·雷(Jimmy Ray)在12因素应用程序和微服务(T5)上有一篇<a class="ae kf" rel="noopener" href="/capital-one-tech/container-ready-applications-with-twelve-factor-app-and-microservices-architecture-16af683a767f">的优秀文章)，但开发者永远不应该在没有对规则进行批判性评估的情况下遵守一套规则——这就是其中之一。也许应该增加第十三个因素来讨论秘密管理？</a></p><h1 id="2644" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">信任的生态圈</h1><p id="646e" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">真正的应用程序安全应该在应用程序级别处理，而不是在基础结构级别。当在需要机密的环境中运行应用程序时，开发人员应该努力利用机密管理系统来确保这些机密不会超出他们的预期范围。</p><p id="6623" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">作为开发人员和工程师，我们应该努力编写自己想要使用的应用程序。我们的角色要求我们与其他开发人员和他们的工作共存时，我们存在于一个信任的生态环境中。我们编写我们的同行将使用的软件，这些软件将管理我们同行的数据，并且在某些情况下，对人们的生活具有真正的权力。信任生态圈的一部分是理解我们编写的软件是安全的，不会不必要地暴露数据。如果这些应用程序在容器中运行，我们有责任确保这些应用程序尽可能安全。</p><p id="7e0d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">但是有一个好消息:这并不难！与DevOps/SRE世界中的许多事情不同，一旦你理解了它们是如何工作的，保护容器就变得非常简单。我希望这篇博文有助于你揭开其中的神秘面纱。</p><p id="02b6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">编码快乐！</p></div><div class="ab cl ms mt go mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ha hb hc hd he"><h2 id="4660" class="ll kh hh bd ki mf mg mh km mi mj mk kq jr ml mm ks jv mn mo ku jz mp mq kw mr bi translated">相关:</h2><ul class=""><li id="1b4f" class="lq lr hh jk b jl ky jo kz jr mz jv na jz nb kd lv lw lx ly bi translated"><a class="ae kf" rel="noopener" href="/capital-one-tech/multi-stage-builds-and-dockerfile-b5866d9e2f84">使用多阶段构建来简化和标准化构建流程</a></li><li id="ebeb" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated"><a class="ae kf" rel="noopener" href="/capital-one-tech/the-whale-in-the-refrigerator-80f659fea1a4">冰箱里的鲸鱼Docker简介</a></li><li id="1894" class="lq lr hh jk b jl lz jo ma jr mb jv mc jz md kd lv lw lx ly bi translated"><a class="ae kf" rel="noopener" href="/capital-one-tech/whale-in-the-grocery-store-an-introduction-to-docker-and-docker-images-311319688692">杂货店中的鲸鱼Docker文件和Docker图像介绍</a></li></ul></div><div class="ab cl ms mt go mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ha hb hc hd he"><p id="a18c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="ke">披露声明:以上观点为作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2019首都一。</em>T3】</strong></p></div></div>    
</body>
</html>