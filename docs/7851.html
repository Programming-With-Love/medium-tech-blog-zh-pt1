<html>
<head>
<title>Ultron: ML Inferencing Platform @Walmart Labs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">奥创:ML推理平台@沃尔玛实验室</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/ultron-ml-inferencing-platform-walmart-labs-7e01c5be9da2?source=collection_archive---------1-----------------------#2020-01-30">https://medium.com/walmartglobaltech/ultron-ml-inferencing-platform-walmart-labs-7e01c5be9da2?source=collection_archive---------1-----------------------#2020-01-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="a76a" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated"><em class="je">作者</em> <a class="ie if ge" href="https://medium.com/u/80374e5fed84?source=post_page-----7e01c5be9da2--------------------------------" rel="noopener" target="_blank"> <em class="je">拉维查图维迪</em> </a> <em class="je"> &amp; </em> <a class="ie if ge" href="https://medium.com/u/43161a4794b3?source=post_page-----7e01c5be9da2--------------------------------" rel="noopener" target="_blank"> <em class="je">克利须那</em></a><em class="je">—2020年1月。</em></p><h1 id="5499" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated"><strong class="ak">简介</strong></h1><p id="685c" class="pw-post-body-paragraph ig ih hh ii b ij kd il im in ke ip iq ir kf it iu iv kg ix iy iz kh jb jc jd ha bi translated">沃尔玛电子商务在很大程度上依赖机器学习来支持业务的各个方面，从目录管理和商品属性的自动化到通过个性化和搜索发现商品来增强最终用户体验。沃尔玛数据科学家每周在各业务部门建立和部署数百个ML模型，并接受目录、卖家和用户数据方面的培训。这些模型是使用Scikit、Pytorch和TensorFlow等框架构建的，并包含自定义依赖项。</p><p id="274a" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">在生产环境中，ML模型必须以实时和批处理模式提供预测，并根据业务环境采用不同的SLA。因此，有必要设计并实现一个ML推理平台，它可以让数据科学家轻松地定制部署他们训练过的ML模型并创建服务端点。此外，部署的定制必须包括计算目标和其他设置的规范，以实现其使用情形所需的SLA。</p><h1 id="1ada" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated"><strong class="ak">平台要求</strong></h1><p id="7cfc" class="pw-post-body-paragraph ig ih hh ii b ij kd il im in ke ip iq ir kf it iu iv kg ix iy iz kh jb jc jd ha bi translated">从工程角度来看，推理平台需要满足以下功能/非功能标准，以支持沃尔玛实验室用例的多样性:</p><ul class=""><li id="fb1f" class="ki kj hh ii b ij ik in io ir kk iv kl iz km jd kn ko kp kq bi translated"><em class="je">简单:</em>轻松搭载新模型并将其部署到生产中，同时支持各种ML模型配置，包括使用Scikit、Pytorch和Tensorflow以及任何其他未来框架构建的模型。</li><li id="345f" class="ki kj hh ii b ij kr in ks ir kt iv ku iz kv jd kn ko kp kq bi translated"><em class="je">可扩展性:</em>扩展单个模型的实例，并支持越来越多的新模型部署。</li><li id="63a3" class="ki kj hh ii b ij kr in ks ir kt iv ku iz kv jd kn ko kp kq bi translated"><em class="je">可用性:</em>可在HA配置中部署，以容错方式支持实时流量。</li><li id="61cc" class="ki kj hh ii b ij kr in ks ir kt iv ku iz kv jd kn ko kp kq bi translated"><em class="je">预测延迟:</em>在可预测的响应时间内提供模型预测。</li><li id="3fbd" class="ki kj hh ii b ij kr in ks ir kt iv ku iz kv jd kn ko kp kq bi translated"><em class="je">资源优化:</em>为实时/批处理/流用例运行优化的模型执行。</li></ul><h1 id="3650" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">探测</h1><p id="a98c" class="pw-post-body-paragraph ig ih hh ii b ij kd il im in ke ip iq ir kf it iu iv kg ix iy iz kh jb jc jd ha bi translated">我们探索了现有的开源/云平台，以了解它们是否能够满足我们的需求。</p><p id="4c33" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">我们从Tensorflow-serving开始，它可以加载通过Tensorflow训练的模型二进制文件，并在规模上提供服务。然而，这将限制数据科学家使用TF来训练和部署模型。</p><p id="d771" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">虽然Google Cloud、Azure和AWS Sagemaker提供了推理解决方案，但它们没有提供足够的定制能力来处理不同的SLA和部署场景。</p><p id="124e" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">因此，我们想出了内部推理平台<em class="je">奥创</em>，沃尔玛内部的许多团队现在都用它来托管他们的模型。奥创推理平台整合了集群容器化和容器编排的最佳实践，并通过后端优化来减少延迟和提高吞吐量。</p><h1 id="d349" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated"><strong class="ak">平台设计</strong></h1><p id="07b5" class="pw-post-body-paragraph ig ih hh ii b ij kd il im in ke ip iq ir kf it iu iv kg ix iy iz kh jb jc jd ha bi translated">机器学习模型可以被认为是<strong class="ii hi">无状态计算密集型幂等工作负载</strong>，它基于一组学习到的参数接受输入并输出响应。</p><p id="6269" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">这种抽象表示允许我们通过适当的重试来构建弹性基础设施，因为它不会通过在先前的后端不可用的情况下将请求分派到不同的后端来影响结果。</p><p id="6062" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">所有现有的ML服务运行时都要处理一个有趣的权衡，因为它们要么支持<strong class="ii hi">实时</strong>预测的模型实现，要么支持<strong class="ii hi">批处理</strong>预测的模型实现，这需要数据科学家为每个用例编写两个不同的实现。因此，我们希望通过单个实施支持实时和批量预测用例，这将大大简化新模型的实施工作，并可以统一两种用例的基础架构。</p><p id="25c2" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">为了解决统一性的挑战，我们的想法是让模型适配器实现一个单一的方法API，它具有以下概要和特征:</p><blockquote class="kw"><p id="b671" class="kx ky hh bd kz la lb lc ld le lf jd dx translated">def predict_all(self，inputs: List[str]) -&gt; List[str]</p></blockquote><p id="dd93" class="pw-post-body-paragraph ig ih hh ii b ij lg il im in lh ip iq ir li it iu iv lj ix iy iz lk jb jc jd ha bi translated">要装载的模型需要实现用于预测的单个方法适配器，获取输入字符串列表并返回输出字符串列表，通过模型适配器实现提供对输入/输出格式的完全控制。输入中的每一项都是对该模型序列化为字符串的请求，类似地，输出中的每一项都是序列化为字符串的预测响应。输出列表预测的顺序应该与输入列表一致。因为模型输入/输出只需要可序列化为一个字符串，允许基础设施完全不知道单独的模型输入/输出格式。</p><p id="ffcc" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">由于我们为模型提供了一组输入字符串，这为模型适配器实现提供了一个优化执行的机会，即通过单个线性代数计算在单个调用中计算所有输入的预测，与循环所有输入进行预测的方法相比，这将确保优化执行。</p><p id="0c41" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">这种抽象还提供了适当的灵活性，通过适当调整实时微批处理，将延迟/吞吐量优化的选择委托给基础架构级别，实时微批处理整理一堆并发到达的同步实时请求，并将其分派到单个后端。提供以下选项来配置行为:<br/> <em class="je">微批量</em>，限制发送到后端的整理请求的最大数量。<br/> <em class="je">最大等待时间</em>，在将当前整理的请求分派到后端之前，新请求的最大等待时间。</p><p id="2ee4" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">可调实时微批处理可以显著提高有效处理速率，尤其是在计算目标是GPU的情况下。这反过来可以减少平均延迟，并允许更快地处理工作负载。默认情况下，我们将微批处理大小保持为4，等待时间保持为20毫秒，提供了准实时行为。但是，它可以调整为更大/更小的批处理大小/等待时间，以支持不同的吞吐量/延迟特征。</p><p id="cfeb" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">如果模型适配器已经通过对一组输入进行单一计算实现了优化预测，那么我们将自动获得优化执行的好处。因此，在实践中，实时微批处理能够通过用较少数量的模型实例减少排队延迟来减少平均请求延迟。如果有效载荷的到达是突发性和随机的，这种减少会变得更加明显。</p><p id="7631" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">这种抽象的一个有趣的角度是，模型实现现在可以在其实现中编写相当复杂的预处理和后处理步骤。例如，当图像缓存基础设施在数据中心内就位时，输入标准化、输出格式化、在适配器上下载图像URL要快得多。</p><p id="43cd" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">该基础设施可以提供基于HTTP和GRPC的一致接口，以统一访问部署在该基础设施上的任何模型。</p><p id="2f9e" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">因此，我们提出了基于Kubernetes构建的以下平台架构，使其完全可移植，可以在任何内部/云提供商上运行。</p><figure class="lm ln lo lp fd lq er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es ll"><img src="../Images/2c69bc994832a520393f817a2b8f1d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CBcL7_N3CGMln5OWOHOd5A.png"/></div></div><figcaption class="lx ly et er es lz ma bd b be z dx"><strong class="bd jh">Ultron: Inferencing Platform Architecture</strong></figcaption></figure><h2 id="b1b9" class="mb jg hh bd jh mc md me jl mf mg mh jp ir mi mj jt iv mk ml jx iz mm mn kb mo bi translated"><strong class="ak">组件</strong></h2><ul class=""><li id="81fc" class="ki kj hh ii b ij kd in ke ir mp iv mq iz mr jd kn ko kp kq bi translated"><strong class="ii hi">奥创API: </strong>支持各种模型实现和相关框架的核心接口，以支持任何具有相应依赖关系的模型适配器实现。</li><li id="4e55" class="ki kj hh ii b ij kr in ks ir kt iv ku iz kv jd kn ko kp kq bi translated"><strong class="ii hi">模型服务:</strong>加载并服务遵循奥创API的模型，该模型被包装在docker化的包装中，以提供具有依赖性的不可变运行时，在docker映像构建阶段安装。它在单线程上为请求提供服务，因此多个请求不会相互碰撞计算资源，从而为模型请求提供确定的计算时间。此外，我们还确保为用于限制线程数量的库设置了正确的环境变量/配置，因为默认情况下，这些计算库使用系统中所有可用的内核。</li><li id="12f6" class="ki kj hh ii b ij kr in ks ir kt iv ku iz kv jd kn ko kp kq bi translated"><strong class="ii hi">模型代理:</strong>将传入请求代理到后端模型实例，支持<strong class="ii hi"> <em class="je">实时微批处理</em> </strong>通过调整微批处理大小/等待时间，在基础架构级别卸载吞吐量/延迟优化，这有助于支持具有所需SLA的实时和批处理预测。</li><li id="9e54" class="ki kj hh ii b ij kr in ks ir kt iv ku iz kv jd kn ko kp kq bi translated"><strong class="ii hi">模型网关:</strong>使用集群内重试将传入的GRPC请求代理到后端模型代理实例(提供集群内容错/弹性)。使用确定性算法来选择下游模型代理实例，以便在适当的位置进行有效的实时微批处理，因为我们可以整理更多的请求。它提供GRPC接口，通过GRPC路由的K8s入口上的上游注册与模型进行交互。</li><li id="6f01" class="ki kj hh ii b ij kr in ks ir kt iv ku iz kv jd kn ko kp kq bi translated"><strong class="ii hi">模型HTTP网关:</strong>将传入的HTTP请求代理到后端模型网关。它提供了HTTP接口，通过在K8s入口上注册HTTP路由来与模型进行交互。可选部署，仅当我们需要对模型进行HTTP访问时才需要。</li><li id="cc5b" class="ki kj hh ii b ij kr in ks ir kt iv ku iz kv jd kn ko kp kq bi translated"><strong class="ii hi"> K8s入口:</strong>为HTTP提供基于<strong class="ii hi">路径</strong>的路由，为GRPC请求提供基于<strong class="ii hi">主机</strong>的路由，并确保<strong class="ii hi">单个</strong> <strong class="ii hi">端口</strong>访问所有已部署模型的整个集群。路由层将HTTP/GRPC流量路由到适当的模型目的地。</li><li id="9b4d" class="ki kj hh ii b ij kr in ks ir kt iv ku iz kv jd kn ko kp kq bi translated"><strong class="ii hi">奥创客户端:</strong> Java库，用于客户端通过单一持久TCP连接实时访问平台上的所有模型，动态执行透明复用/解复用，同时保持同步/异步使用的简单模型预测接口。</li></ul><h1 id="7546" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated"><strong class="ak">平台行为</strong></h1><p id="ce92" class="pw-post-body-paragraph ig ih hh ii b ij kd il im in ke ip iq ir kf it iu iv kg ix iy iz kh jb jc jd ha bi translated"><strong class="ii hi"> <em class="je">简单性</em> </strong> <br/>由模型适配器实现的单一方法API，该适配器可以自由选择其相应的依赖项，因为在构建阶段，所有东西都被烘焙到不可变的docker映像中。此外，还有一种通过HTTP端点或平台提供的Java客户端访问模型的简化方法。我们能够在一个季度内搭载60种不同的型号，从而展示了设计的内在简单性。</p><p id="a82e" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated"><strong class="ii hi"> <em class="je">可扩展性</em> </strong> <br/>基础设施支持两种方式的扩展。</p><ul class=""><li id="b3dc" class="ki kj hh ii b ij ik in io ir kk iv kl iz km jd kn ko kp kq bi translated">扩展单个模型的pod数量，它在上游模型代理层作为负载平衡池实时更新。在P95延迟为50毫秒的情况下，仅使用16个模型实例，每个实例具有2个CPU和2 GB内存，能够实现每秒1000多个请求的深度学习模型。它还在90多个模型实例上运行一些模型来支持工作负载。</li><li id="f17a" class="ki kj hh ii b ij kr in ks ir kt iv ku iz kv jd kn ko kp kq bi translated">扩展以部署新模型，这将在Kubernetes内创建新的基础架构/模型单元，在K8s入口只有一个路由条目用于该模型实例。</li></ul><p id="30f4" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">目前，我们有一个Kubernetes集群托管具有以下规格的体系结构，支持我们期望的规模，并具有固有的设计来支持每个季度部署大量新型号:</p><p id="8d18" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">型号:~ 60<br/>K8s pod:~ 600+<br/>内核:~1000+ <br/>内存:~2TB+</p><p id="0eee" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated"><strong class="ii hi"> <em class="je">可用性</em> </strong> <br/>如果部署在HA配置中，每个组件至少有两个实例，则没有一个组件会出现单点故障。基础设施将自动开始利用额外部署的组件，因为每个组件都会监视可用的下游实例。由于上游层会进行必要的重试以将请求分派给健康的实例，因此基础架构可确保在组件出现故障的情况下成功预测请求。</p><p id="5539" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated"><strong class="ii hi"> <em class="je">预测延迟</em> </strong> <br/>由于我们在整个基础设施中维护持久连接，因此我们能够实现作为模型响应时间+恒定开销的函数的可预测延迟。通过将请求分派到已经建立的到相应下游的连接，我们确保唯一的开销是TCP上的数据传输，考虑到数据中心内每跳4毫秒的延迟，这在实践中是相当快的。</p><p id="dd7b" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated"><strong class="ii hi"> <em class="je">资源优化</em> </strong> <br/>实时微批处理就绪后，我们可以通过在基础架构级别选择相应的批处理大小/等待时间参数来调整延迟/吞吐量特征。这可以针对实时/批处理/准实时模式进行调整，以支持不同的用例。</p><h1 id="0b85" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated"><strong class="ak">平台用途</strong></h1><p id="e117" class="pw-post-body-paragraph ig ih hh ii b ij kd il im in ke ip iq ir kf it iu iv kg ix iy iz kh jb jc jd ha bi translated">目录数据科学团队和其他小组已经使用奥创推理平台在2004财年部署了60多个机器学习模型，以满足实时和批处理需求。部署的模型从使用Scikit Learn构建的ML模型到深度学习模型，如基于BERT的模型，这些模型是内存和计算密集型的。这些模型每天处理超过2亿件商品，丰富了沃尔玛的商品目录，推动了商品的发现和摆放。沃尔玛越来越多地采用该平台，因为它允许用户定制他们的部署配置，以满足他们的可扩展性和可用性需求。</p><h1 id="a3fd" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated"><strong class="ak">结束语</strong></h1><p id="369d" class="pw-post-body-paragraph ig ih hh ii b ij kd il im in ke ip iq ir kf it iu iv kg ix iy iz kh jb jc jd ha bi translated">我们希望这篇博客提供了一个体面的概述，介绍了我们如何应对在沃尔玛实验室将人工智能投入生产的挑战，以及一些有助于克服这些挑战的设计/实施考虑因素。我们很幸运有一个伟大的工程师和数据科学家团队，作为目录数据科学团队的一部分，在这个有趣的项目上进行合作。</p><p id="dc55" class="pw-post-body-paragraph ig ih hh ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd ha bi translated">特别感谢@ <a class="ae ms" rel="noopener" href="/@karthik.d"> Karthik Deivasigamani </a>鼓励我写这篇博客。</p></div></div>    
</body>
</html>