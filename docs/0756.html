<html>
<head>
<title>Effective state management for TextField in Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Compose中文本字段的有效状态管理</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/effective-state-management-for-textfield-in-compose-d6e5b070fbe5?source=collection_archive---------0-----------------------#2022-09-14">https://medium.com/androiddevelopers/effective-state-management-for-textfield-in-compose-d6e5b070fbe5?source=collection_archive---------0-----------------------#2022-09-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/0b270f5d89d11fd902ba9e3fba0ae66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YlOsUT4nMzIxu0O9TpU8zw.png"/></div></div></figure><div class=""/><p id="cd78" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"><em class="jn">TL；</em>博士</strong></p><ul class=""><li id="786f" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><em class="jn">防止同步问题和意外行为:<br/></em>–<em class="jn">避免键入和更新</em> <code class="du jx jy jz ka b"><em class="jn">TextField</em></code> <em class="jn">状态之间的延迟/异步行为。<br/></em>—<em class="jn">void保持</em> <code class="du jx jy jz ka b"><em class="jn">TextField</em></code> <em class="jn">状态使用一个反应流(例如从</em> <code class="du jx jy jz ka b"><em class="jn">StateFlow</em></code> <em class="jn">收集使用默认调度器)<br/></em>—<em class="jn">定义</em> <code class="du jx jy jz ka b"><em class="jn">TextField</em></code> <em class="jn">状态变量用像</em> <code class="du jx jy jz ka b"><em class="jn">MutableState&lt;String&gt;</em></code> <em class="jn">这样的API进行组合。</em></li><li id="3feb" class="jo jp hs ir b is kb iw kc ja kd je ke ji kf jm jt ju jv jw bi translated"><em class="jn">需要时将</em> <code class="du jx jy jz ka b"><em class="jn">TextField</em></code> <em class="jn">状态提升到</em> <code class="du jx jy jz ka b"><em class="jn">ViewModel</em></code> <em class="jn">状态，例如对</em> <code class="du jx jy jz ka b"><em class="jn">TextField</em></code> <em class="jn">内容进行业务验证。</em></li><li id="be18" class="jo jp hs ir b is kb iw kc ja kd je ke ji kf jm jt ju jv jw bi translated"><em class="jn">我们正在努力提高</em> <code class="du jx jy jz ka b"><em class="jn">TextField</em></code> <em class="jn">的能力。检查</em><a class="ae kg" href="http://goo.gle/compose-roadmap" rel="noopener ugc nofollow" target="_blank"><em class="jn">goo.gle/compose-roadmap</em></a><em class="jn">并期待未来的版本。</em></li></ul><p id="717e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设我们必须在Jetpack Compose应用程序中实现一个注册屏幕，我们收到了以下设计:</p><figure class="ki kj kk kl fd hj er es paragraph-image"><div class="er es kh"><img src="../Images/eebcf6ff2ea5dc193fab6794d76fe5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*5Rqy6kFsXL-5uWY1khTAxQ.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx"><em class="kq">Implementing a sign up screen with two TextFields</em></figcaption></figure><p id="1fe5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们有两个<code class="du jx jy jz ka b"><a class="ae kg" href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#TextField(kotlin.String,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors)" rel="noopener ugc nofollow" target="_blank">TextField</a></code>组件和一个<code class="du jx jy jz ka b"><a class="ae kg" href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#button" rel="noopener ugc nofollow" target="_blank">Button</a></code>。<br/>让我们从顶部的<code class="du jx jy jz ka b">TextField</code>开始，这是用户名字段。<br/>要在Compose中实现一个<code class="du jx jy jz ka b">TextField</code>，我们需要定义一个状态变量:</p><ol class=""><li id="4791" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm kr ju jv jw bi translated">存储显示的当前值，并传递给<code class="du jx jy jz ka b">TextField</code>值参数。</li><li id="4b44" class="jo jp hs ir b is kb iw kc ja kd je ke ji kf jm kr ju jv jw bi translated">每当用户在<code class="du jx jy jz ka b">TextField</code>的<code class="du jx jy jz ka b">onValueChange</code>回调中输入新文本时，就会得到更新。</li></ol><figure class="ki kj kk kl fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="d3ba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当处理状态时，一个重要的事情是决定在哪里放置状态变量。在我们的例子中，我们希望对用户名执行一些业务逻辑验证，因此我们将状态提升到<code class="du jx jy jz ka b">ViewModel</code>，而不是保存在可组合函数中。有关这一点以及如何组织你的应用架构的更多信息，你可以阅读我们的<a class="ae kg" href="http://d.android.com/topic/architecture" rel="noopener ugc nofollow" target="_blank">架构指南</a>。<br/>通过将我们的状态置于<code class="du jx jy jz ka b">ViewModel</code>中，<code class="du jx jy jz ka b">TextField</code>值将免费保存在<a class="ae kg" href="https://developer.android.com/topic/libraries/architecture/saving-states" rel="noopener ugc nofollow" target="_blank">配置更改</a>中。</p><p id="3594" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">考虑到这些需求，我们创建了一个可组合的注册屏幕，包含一个类似于下面的<code class="du jx jy jz ka b">OutlinedTextField</code>:</p><figure class="ki kj kk kl fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="6614" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，在<code class="du jx jy jz ka b">ViewModel</code>中，我们将定义状态变量并执行业务逻辑。</p><p id="3e57" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">目前不建议用无功流来定义</strong> <code class="du jx jy jz ka b"><strong class="ir ht">TextField</strong></code> <strong class="ir ht">的状态变量。我们将在接下来的章节中探究原因并深入探究这些和其他陷阱，但是现在，假设我们犯了这个错误。我们错误地定义了一个类型为<code class="du jx jy jz ka b"><a class="ae kg" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow/" rel="noopener ugc nofollow" target="_blank">MutableStateFlow</a></code>的变量<code class="du jx jy jz ka b">_username</code>来存储<code class="du jx jy jz ka b">TextField</code>状态，并通过定义不可变的后台变量<code class="du jx jy jz ka b">username</code>来公开它。</strong></p><p id="94cc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每当用户在<code class="du jx jy jz ka b">TextField</code>上键入一个新字符时，异步方法<code class="du jx jy jz ka b">updateUsername</code>将调用一个服务来验证用户名是否可用(例如以前没有使用过)。如果验证失败，它将显示一条错误消息，要求选择不同的用户名。</p><figure class="ki kj kk kl fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><h1 id="c75e" class="ku kv hs bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">问题</h1><p id="9641" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">我们已经完成了用户名字段的实现。如果我们现在运行应用程序，我们应该能够测试它:</p><figure class="ki kj kk kl fd hj er es paragraph-image"><div class="er es lx"><img src="../Images/b232d7408f291113a197f68c628b2c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*h_x8IXOGD6NVURgy"/></div><figcaption class="km kn et er es ko kp bd b be z dx"><code class="du jx jy jz ka b"><em class="kq">TextField</em></code><em class="kq"> incorrect behavior as we try to edit username </em><a class="ae kg" href="mailto:jane@mail.com" rel="noopener ugc nofollow" target="_blank"><em class="kq">jane@mail.com</em></a><em class="kq"> into </em><a class="ae kg" href="mailto:jane.surname@mail.com" rel="noopener ugc nofollow" target="_blank"><em class="kq">jane.surname@mail.com</em></a></figcaption></figure><p id="e286" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们打字时，我们很快注意到不正确的行为:一些字母在我们打字时被跳过，一些以错误的顺序添加到输入中，整个位被复制，光标来回跳动。所有编辑操作都失败，包括删除和选择要替换的文本。显然有错误。</p><p id="7476" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">发生了什么，我们如何解决？</p><h1 id="12d5" class="ku kv hs bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">TextField的内部</h1><p id="8a05" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在编写时(使用Compose UI <a class="ae kg" href="https://developer.android.com/jetpack/androidx/releases/compose-ui#1.3.0-beta01" rel="noopener ugc nofollow" target="_blank"> 1.3.0-beta01 </a>)，a <code class="du jx jy jz ka b">TextField</code>的实现涉及持有3份状态副本:</p><ul class=""><li id="4632" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><em class="jn"> IME(输入法编辑器):</em>为了能够执行智能操作，如建议下一个单词或替换单词的表情符号，键盘需要有当前显示文本的副本。</li><li id="b283" class="jo jp hs ir b is kb iw kc ja kd je ke ji kf jm jt ju jv jw bi translated"><em class="jn">状态保持器</em>由用户定义和更新，在上例中是一个<code class="du jx jy jz ka b">MutableStateFlow</code>变量。</li><li id="0969" class="jo jp hs ir b is kb iw kc ja kd je ke ji kf jm jt ju jv jw bi translated"><em class="jn">内部状态</em>作为控制器，保持其他两个状态同步，因此您不必手动与IME交互。</li></ul><blockquote class="ly lz ma"><p id="b513" class="ip iq jn ir b is it iu iv iw ix iy iz mb jb jc jd mc jf jg jh md jj jk jl jm ha bi translated">即使每个<code class="du jx jy jz ka b">TextField</code>一直有3个状态副本，开发人员也只管理其中一个(状态持有者),其他的都是内部的。</p></blockquote><p id="63e3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这三种状态在幕后是如何相互作用的？简而言之，从键盘键入的每个字符或添加的每个单词都会触发一系列步骤，这些步骤构成一个反馈循环，如下所示:</p><figure class="ki kj kk kl fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es me"><img src="../Images/0de14b0cf51416e103b8a793a963438f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SA4wm6ge14w1SwzR"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx"><em class="kq">Interactions between TextField states</em></figcaption></figure><ol class=""><li id="f0ef" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm kr ju jv jw bi translated">一个事件从键盘输入(输入单词“<em class="jn"> hello </em>”)，并被转发到内部控制器。</li><li id="5783" class="jo jp hs ir b is kb iw kc ja kd je ke ji kf jm kr ju jv jw bi translated">内部控制器接收这个更新“hello ”,转发给状态保持器。</li><li id="667d" class="jo jp hs ir b is kb iw kc ja kd je ke ji kf jm kr ju jv jw bi translated">用“hello”内容更新状态保持器，这更新了UI，并通知内部控制器它已经接收到更新。</li><li id="d4c1" class="jo jp hs ir b is kb iw kc ja kd je ke ji kf jm kr ju jv jw bi translated">内部控制器通知键盘。</li><li id="f019" class="jo jp hs ir b is kb iw kc ja kd je ke ji kf jm kr ju jv jw bi translated">键盘得到通知，因此它可以为下一个输入事件做准备，例如，建议下一个单词。</li></ol><p id="ffac" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">只要这些状态副本保持同步，<code class="du jx jy jz ka b">TextField</code>就会按预期工作。</p><p id="1959" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"> <em class="jn">然而，通过在打字过程中引入异步行为和竞争条件，这些副本可能会失去同步，无法恢复。错误的严重程度取决于各种因素，如引入的延迟量、键盘语言、文本内容和长度以及IME实现。</em> </strong></p><p id="f39a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您使用的是 <a class="ae kg" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html" rel="noopener ugc nofollow" target="_blank"> <em class="jn">默认调度器</em> </a>，即使只是使用反应流来表示您的状态(例如<code class="du jx jy jz ka b">StateFlow</code>)而没有延迟也可能会导致问题，因为更新事件调度不是立即的<em class="jn">。</em></p><p id="8bd9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当你开始输入时，让我们试着看看在这种情况下会发生什么。一个新的事件“hello”来自键盘，在我们更新状态和UI之前，我们生成了一个异步调用。然后另一个事件“世界”来自键盘。</p><p id="d7c8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一个异步事件恢复，循环完成。当<code class="du jx jy jz ka b">TextField</code>内部状态收到异步“hello”时，它会丢弃之前收到的最新“hello world”。</p><figure class="ki kj kk kl fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es me"><img src="../Images/195bb0b8946adbad6170e5c1309c845d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VpDh-8TUtR6uHx0B"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx"><em class="kq">TextField internal state is overridden to be ‘hello’ instead of ‘hello world’</em></figcaption></figure><p id="be1c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是在某个时候,“hello world”异步事件也会恢复。现在<code class="du jx jy jz ka b">TextField</code>持有一个无效状态，其中3个状态不匹配。</p><figure class="ki kj kk kl fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es me"><img src="../Images/fff1095b73d46c73114e536f80c5447d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eTTkErU9upS5Ty7k"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx"><em class="kq">TextField inconsistencies after each asynchronous process resumes</em></figcaption></figure><p id="03aa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些意想不到的异步调用与IME的处理、快速打字、定时条件和操作(如替换整个文本块的删除)相结合，错误只会变得更加明显。</p><p id="ffca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们对动态有了更多的了解，让我们看看如何解决和避免这些问题。</p><h1 id="f294" class="ku kv hs bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">处理TextField状态的最佳实践</h1><h2 id="3eba" class="mf kv hs bd kw mg mh mi la mj mk ml le ja mm mn li je mo mp lm ji mq mr lq ms bi translated">避免更新状态的延迟</h2><p id="352f" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">当<code class="du jx jy jz ka b">onValueChange</code>被调用时，立即同步更新你的<code class="du jx jy jz ka b">TextField</code>。</p><figure class="ki kj kk kl fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="0378" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可能仍然需要以某种方式过滤或修剪你的文本。同步操作可以很好地执行。例如，如果您的同步操作将输入转换为不同的字符集，请考虑使用<code class="du jx jy jz ka b"><a class="ae kg" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/VisualTransformation" rel="noopener ugc nofollow" target="_blank">visualTransformation</a></code>。您应该避免异步操作，因为它们会导致上面显示的问题。</p><h2 id="4e4e" class="mf kv hs bd kw mg mh mi la mj mk ml le ja mm mn li je mo mp lm ji mq mr lq ms bi translated">使用MutableState表示TextField状态</h2><p id="1413" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">避免使用反应流(如<code class="du jx jy jz ka b">StateFlow</code>)来表示你的<code class="du jx jy jz ka b">TextField</code>状态，因为这些结构会引入异步延迟。更喜欢用<code class="du jx jy jz ka b"><a class="ae kg" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState" rel="noopener ugc nofollow" target="_blank">MutableState</a></code>来代替:</p><figure class="ki kj kk kl fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><blockquote class="ly lz ma"><p id="5b2e" class="ip iq jn ir b is it iu iv iw ix iy iz mb jb jc jd mc jf jg jh md jj jk jl jm ha bi translated">如果您仍然希望使用<code class="du jx jy jz ka b">StateFlow</code>来存储状态，请确保您使用<a class="ae kg" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-main-coroutine-dispatcher/immediate.html" rel="noopener ugc nofollow" target="_blank">即时调度器</a>而不是<a class="ae kg" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html" rel="noopener ugc nofollow" target="_blank">默认调度器</a>从流中收集状态。</p><p id="96f4" class="ip iq jn ir b is it iu iv iw ix iy iz mb jb jc jd mc jf jg jh md jj jk jl jm ha bi translated">这个解决方案需要更深入的协程知识，可能会导致问题:<br/> *因为收集是同步的，所以当它发生时，UI可能处于未准备好运行的状态。<br/> *干扰Compose的线程和渲染阶段，因为它假设重组发生在主线程上。</p></blockquote><h2 id="f42c" class="mf kv hs bd kw mg mh mi la mj mk ml le ja mm mn li je mo mp lm ji mq mr lq ms bi translated">在哪里定义状态</h2><p id="24b4" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">如果您输入时您的<code class="du jx jy jz ka b">TextField</code>状态需要业务逻辑验证，那么将状态提升到您的<code class="du jx jy jz ka b">ViewModel</code>是正确的。如果没有，您可以使用Composables或state holder类作为事实的来源。</p><p id="0026" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一般来说，你应该把你的状态放在尽可能低的地方，同时仍然被适当地拥有，这通常意味着更接近它被使用的地方。有关撰写状态的更多信息，可以查看我们的<a class="ae kg" href="https://developer.android.com/jetpack/compose/state#managing-state" rel="noopener ugc nofollow" target="_blank">指南</a> <strong class="ir ht">。</strong></p><p id="68e4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在解决这个问题时，在哪里提升状态并不重要，重要的是如何存储状态。</p><h1 id="4499" class="ku kv hs bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在应用中应用最佳实践</h1><p id="aa7f" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">考虑到这些最佳实践，让我们对我们的<code class="du jx jy jz ka b">TextField</code>状态实现同步和异步验证。</p><p id="6da9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从异步验证开始，如果用户名无效，我们希望在<code class="du jx jy jz ka b">TextField</code>下方显示一条错误消息，并且该验证是在服务器端执行的。在我们的用户界面中，它将是这样的:</p><figure class="ki kj kk kl fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mt"><img src="../Images/a770f6c35c40795a79896d8d229d19af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kZn4Q80O0j9BdNCn"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx">Displays an error because “<em class="kq">username1</em>” is already in use</figcaption></figure><p id="4f1a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当<code class="du jx jy jz ka b">onValueChange</code>被调用时，我们将通过调用update方法立即更新<code class="du jx jy jz ka b">TextField</code>。然后，<code class="du jx jy jz ka b">ViewModel</code>将基于刚刚更改的值安排一个异步检查。</p><p id="7f1a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du jx jy jz ka b">ViewModel</code>中，我们定义了两个状态变量:<em class="jn"> </em> <code class="du jx jy jz ka b">TextField</code>状态的username变量为<code class="du jx jy jz ka b">MutableState</code>，userNameHasError为<code class="du jx jy jz ka b">StateFlow</code>，每当用户名更新时都会被动计算。</p><p id="06a8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jx jy jz ka b"><a class="ae kg" href="https://developer.android.com/jetpack/compose/side-effects#snapshotFlow" rel="noopener ugc nofollow" target="_blank">snapshotFlow</a></code> API将Compose <code class="du jx jy jz ka b"><a class="ae kg" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/State" rel="noopener ugc nofollow" target="_blank">State</a></code>转换成一个流，这样我们就可以对每个值执行异步(挂起)操作。</p><p id="e12b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为输入可能比获得异步调用结果更快，所以我们按顺序处理事件，并使用<code class="du jx jy jz ka b"><a class="ae kg" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map-latest.html" rel="noopener ugc nofollow" target="_blank">mapLatest</a></code>(实验性的)在新事件到来时取消未完成的调用，以避免浪费资源或显示不正确的状态。出于同样的原因，我们还可以添加一个反跳方法(异步调用之间的延迟)。</p><figure class="ki kj kk kl fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><blockquote class="ly lz ma"><p id="aad2" class="ip iq jn ir b is it iu iv iw ix iy iz mb jb jc jd mc jf jg jh md jj jk jl jm ha bi translated"><em class="hs">请注意，我们正在使用实验性的</em> <code class="du jx jy jz ka b"><a class="ae kg" href="https://developer.android.com/jetpack/androidx/releases/lifecycle#2.6.0-alpha01" rel="noopener ugc nofollow" target="_blank"><em class="hs">collectAsStateWithLifecycle</em></a></code> <em class="hs"> API收集错误验证流，这是在Android Compose中收集流的推荐方法。要阅读更多关于这个API的内容，你可以查看Jetpack Compose  <em class="hs">博客文章中的</em> <a class="ae kg" rel="noopener" href="/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3">安全消费流。</a></em></p></blockquote><p id="33e5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们想添加一个同步验证来检查输入是否包含无效字符。我们可以使用<code class="du jx jy jz ka b"><a class="ae kg" href="https://developer.android.com/jetpack/compose/side-effects#derivedstateof" rel="noopener ugc nofollow" target="_blank">derivedStateOf()</a></code> API，它是同步的，每次用户名改变时都会触发lambda验证。</p><figure class="ki kj kk kl fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="aea6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jx jy jz ka b">derivedStateOf()</code>创建一个新的<code class="du jx jy jz ka b">State</code>，当这个值在<code class="du jx jy jz ka b">true</code>和<code class="du jx jy jz ka b">false</code>之间变化时，读取<code class="du jx jy jz ka b">userNameHasLocalError</code>的composables将重新组合。<br/>我们带验证的完整用户名实现字段如下所示:</p><figure class="ki kj kk kl fd hj er es paragraph-image"><div class="er es lx"><img src="../Images/27e96847e9706265839dbde5e36d00e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*4Cd58JD8YRNA_uaoew4Dfw.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx">Username field implementation with a sync and async error</figcaption></figure><h1 id="b7d0" class="ku kv hs bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">规划文本字段</h1><p id="54f0" class="pw-post-body-paragraph ip iq hs ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">目前，我们正在努力改进<code class="du jx jy jz ka b">TextField</code> API，它仍然是我们的优先任务之一。</p><p id="a6fd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">撰写<a class="ae kg" href="http://goo.gle/compose-roadmap" rel="noopener ugc nofollow" target="_blank">路线图</a>反映了团队在多个方面正在做的工作，在这种情况下<em class="jn">文本编辑改进</em>和<em class="jn">键盘输入</em>是与这些API相关的工作。因此，请密切关注它以及Compose未来版本中的发行说明。</p></div><div class="ab cl mu mv go mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ha hb hc hd he"><p id="705e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">感谢Jetpack撰写文本团队的</em> <a class="ae kg" href="https://twitter.com/objcode" rel="noopener ugc nofollow" target="_blank"> <em class="jn">肖恩·麦克奎蓝</em> </a> <em class="jn">和</em> <a class="ae kg" href="https://twitter.com/zachklipp" rel="noopener ugc nofollow" target="_blank"> <em class="jn">扎克·克利普斯坦</em> </a> <em class="jn">和DevRel团队的</em> <a class="ae kg" href="https://twitter.com/manuelvicnt" rel="noopener ugc nofollow" target="_blank"> <em class="jn">曼努埃尔·维森特·Vivo</em></a><em class="jn"/><a class="ae kg" href="https://twitter.com/FMuntenescu" rel="noopener ugc nofollow" target="_blank"><em class="jn">弗洛里纳·芒特内斯库</em> </a> <em class="jn">的建议和透彻的评论。</em></p></div></div>    
</body>
</html>