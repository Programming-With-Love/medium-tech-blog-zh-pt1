<html>
<head>
<title>The Road to an Envoy Service Mesh</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通向特使服务网之路</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/the-road-to-an-envoy-service-mesh-d1a51cbd31dd?source=collection_archive---------0-----------------------#2019-03-29">https://medium.com/square-corner-blog/the-road-to-an-envoy-service-mesh-d1a51cbd31dd?source=collection_archive---------0-----------------------#2019-03-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/f820b71296cf849ac7fbe2a7c6c85923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4luLoo60y6qNKD0O1Fnd8Q.jpeg"/></div></div></figure><blockquote class="ip iq ir"><p id="7822" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jr" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="721d" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">在Square，我们多年来一直在运行微服务架构，主要使用三种不同的语言:Java、Ruby和Go。运行如此多样化的堆栈会使不同语言/框架之间的互操作性变得具有挑战性，在这篇文章中，我将谈论Square在过去是如何处理这一问题的，以及我们今天所处的位置——积极地向全服务网格迁移。</p><h2 id="f2a0" class="jv jw hh bd jx jy jz ka kb kc kd ke kf js kg kh ki jt kj kk kl ju km kn ko kp bi translated"><strong class="ak">旧世界</strong></h2><p id="8557" class="pw-post-body-paragraph is it hh iv b iw kq iy iz ja kr jc jd js ks jg jh jt kt jk jl ju ku jo jp jq ha bi translated">像许多其他公司一样，Square一开始只是运行一个大型的整体。对于Square来说，这是一个巨大的Ruby on Rails服务，处理Square所做的一切。monolith使得服务对服务的通信变得完全没有必要:所有的东西都在一个数据库上的相同代码库中运行，所以所有的东西都可以在不进行任何出站网络调用的情况下实现(除了对Square之外的第三方)。</p><p id="a7e9" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">过了一段时间，Square决定更多地转向面向服务的架构，以减少对单个大型应用程序的依赖。为了做到这一点，Square受Google Stubby的启发，决定构建自己的基于Protobuf的RPC框架。这是gRPC创建之前的几年，所以当时没有任何开源选项。这个名为Sake的RPC框架是为Java和Go实现的，因为这些语言用于更高可用性的服务，而常规的REST HTTP用于不理解Sake的服务之间。(顺便提一下，<a class="ae jr" rel="noopener" href="/square-corner-blog/grpc-reaches-1-0-85728518393b">清酒成为gRPC DNA的一部分</a>)</p><p id="5127" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">随着时间的推移，这个框架变得相当复杂，具有许多通常不可用的特性:</p><ul class=""><li id="cd13" class="kv kw hh iv b iw ix ja jb js kx jt ky ju kz jq la lb lc ld bi translated">自动故障转移的智能重试</li><li id="ef23" class="kv kw hh iv b iw le ja lf js lg jt lh ju li jq la lb lc ld bi translated">基于上游健康状况的优先路由</li><li id="48f7" class="kv kw hh iv b iw le ja lf js lg jt lh ju li jq la lb lc ld bi translated">流量整形和服务发现</li></ul><p id="4702" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这最终工作得很好，但是依赖于胖客户端/服务器库，所以很难扩展对其他语言的支持。人们试图以各种方式实现语言之间的功能对等:</p><ul class=""><li id="a32f" class="kv kw hh iv b iw ix ja jb js kx jt ky ju kz jq la lb lc ld bi translated">连接HTTP和Sake的Sidecar进程</li><li id="b808" class="kv kw hh iv b iw le ja lf js lg jt lh ju li jq la lb lc ld bi translated">集中式L4代理与L7功能的智能客户端库相结合</li></ul><p id="2606" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这两种方法都没有完全解决问题，虽然都缩小了功能差距，但它们并不完全匹配。在调试问题时，应用程序所有者仍然被迫知道使用了哪种机制，这导致了很多混乱。</p><p id="8c43" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">试图从Sake迁移到gRPC，但是事实证明，Sake提供的大量特性集对于迁移到gRPC是一个挑战，需要实现定制的负载平衡和名称解析器来与<code class="du lj lk ll lm b">grpc-go</code>和<code class="du lj lk ll lm b">grpc-java</code>一起工作。在部分实现了必要的功能后，由于各种原因，迁移被搁置，部分原因是因为作为Sake的替代产品意味着应用程序所有者没有什么动力进行迁移。</p><p id="71f2" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">除此之外，我们还利用内部硬件负载平衡器对服务呼叫进行负载平衡。虽然我们在Sake中对客户端负载平衡提供了部分支持，但是大量的Sake流量和所有的HTTP流量仍然依赖于这些负载平衡器。随着公司的不断发展，硬件负载平衡器的负载量也在增加。</p><p id="8408" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><strong class="iv hi">反思服务到服务</strong></p><p id="06dd" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">在我们的硬件负载平衡器出现一系列问题后，我们决定需要改进我们的服务设置。我们现有的服务对服务设置需要在硬件负载平衡器上为每个新服务创建新的虚拟IP，因此随着服务数量的增长，负载只会增加，因此我们必须添加更多的硬件负载平衡器或迁移到可扩展性更强的基础架构。</p><p id="26dc" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这被证明是一个简化的好机会:我们不再运行Sake和许多其他基础设施，而是集中在一个单一的服务到服务机制上。这为应用程序所有者简化了事情，带来了额外的好处:他们不再需要担心多个负载平衡器、连接池等。他们可以专注于理解单个实现的语义，使得从日常操作到灾难恢复的所有事情都更容易推理。</p><p id="8e52" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">环顾四周，特使脱颖而出，作为一个伟大的候选人，由于</p><ul class=""><li id="7df7" class="kv kw hh iv b iw ix ja jb js kx jt ky ju kz jq la lb lc ld bi translated">特使负载平衡器数据结构和Sake数据结构之间的相似性</li><li id="51d4" class="kv kw hh iv b iw le ja lf js lg jt lh ju li jq la lb lc ld bi translated">流式配置API</li><li id="8699" class="kv kw hh iv b iw le ja lf js lg jt lh ju li jq la lb lc ld bi translated">对gRPC的一流支持</li><li id="f68f" class="kv kw hh iv b iw le ja lf js lg jt lh ju li jq la lb lc ld bi translated">进程外架构</li></ul><p id="813e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">回想起来，在我们能够协调Sake和Envoy之前，映射负载平衡器实现需要相当多的额外上游工作(<a class="ae jr" href="https://github.com/envoyproxy/envoy/issues/3958" rel="noopener ugc nofollow" target="_blank">智能重试</a>、<a class="ae jr" href="https://github.com/envoyproxy/envoy/issues/5063" rel="noopener ugc nofollow" target="_blank">降级健康检查</a>和<a class="ae jr" href="https://github.com/envoyproxy/envoy/issues/4903" rel="noopener ugc nofollow" target="_blank">每次尝试超时</a>等等)。值得庆幸的是，特使维护者非常乐于助人，并乐于接受新的功能，允许我们构建我们需要的一切。</p><p id="3501" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">配置API意味着我们可以轻松地在现有的基于Zookeeper的服务发现系统上构建它:一个集中的控制平面将侦听Zookeeper的更改，并使用配置API将这些更改推送给Envoy。</p><p id="6cb7" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">对gRPC的支持意味着我们可以接手已经部分铺开的gRPC工作，但是依赖于Envoy的负载平衡器逻辑。对我们来说更重要的是，这意味着我们可以对RPC和HTTP流量使用完全相同的负载平衡器。这也是进程外架构如此伟大的原因:无论什么应用程序使用它，实现都是相同的，因为在任何地方都使用相同的二进制文件。</p><p id="f10e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><strong class="iv hi">构建服务网格</strong></p><p id="8e96" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">为了迁移到Envoy，我们最终构建了一个基于https://github.com/envoyproxy/java-control-plane<a class="ae jr" href="https://github.com/envoyproxy/java-control-plane" rel="noopener ugc nofollow" target="_blank">的控制平面，它与我们现有的服务发现基础设施相集成。这让我们可以使用用于形成清酒流量的相同数据，让应用程序所有者不必担心流量来自哪里。</a></p><p id="9155" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">Envoy进程部署在每个应用程序旁边，并且为每种语言提供了一个非常瘦的客户端库，以便通过unix套接字与该进程进行通信。该库有意保持精简，以确保我们将尽可能多的逻辑集中在控制平面或特使中，因为这确保了不同语言之间的行为一致。</p><p id="2568" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们决定使用unix套接字，因为我们的应用程序部署在多租户机器上，对TLS证书的访问受到文件权限的保护。使用unix套接字允许我们使用类似的权限来限制对给定应用程序的特使实例的访问，这使我们可以使用普通HTTP，而无需向同一主机上的所有其他应用程序开放对机密的访问。此外，这提供了不必多次加密和解密流量的性能优化。路由的主要形式仅仅依赖于主机头，主机头指示请求应该被路由到哪个服务。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ln"><img src="../Images/e541096d614602480da0508a635301ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lZMibbQnakNatVsR"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">How Envoy selects a backend host based on the Host header</figcaption></figure><p id="da9f" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">因为我们保持客户端非常瘦，所以任何人构建一个特使客户端都变得非常容易。如果没有别的，一个简单的curl命令就可以给你同样的流量整形、重试行为等。一个“完整”的客户端实现将:</p><pre class="lo lp lq lr fd lw lm lx ly aw lz bi"><span id="26f6" class="jv jw hh lm b fi ma mb l mc md">curl --unix-socket egress.sock production.web.gns.square</span></pre><p id="14ba" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这使得开发人员可以在几分钟内，而不是几个月内，在Square上以一种与我们的服务网格集成的方式开发新语言的原型。</p><p id="8823" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><strong class="iv hi">迁徙</strong></p><p id="b572" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">一旦这些都设置好了，迁移工作就可以开始了。我们的主要关注点是摆脱服务基础设施的替代服务，弃用应用程序并将其从其他代理服务器上移走。这是一个非常缓慢的过程，因为它依赖于与各个团队协调配置更改和应用程序部署。这在很大程度上是由于我们的客户手动路由到Envoy:不像Istio这样的系统可以控制网络并充当透明代理，我们必须更改代码才能使客户路由到Envoy。不幸的是，由于应用程序多租户和缺乏网络名称空间，这种透明代理使用的方法不是我们的选择。</p><p id="d45a" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">为了帮助促进迁移，我们发布了一个名为<code class="du lj lk ll lm b">tcli</code>(traffic CLI的缩写)的内部CLI工具，以简化应用程序切换到Envoy所需的操作。</p><p id="17b7" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">对于一个希望通过Envoy转移其客户端调用的应用程序，步骤如下所示:</p><p id="18be" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">要分配端口，将Envoy添加到部署中，并请求访问现有的服务对服务的依赖关系，请从开发人员笔记本电脑上运行一条命令:</p><pre class="lo lp lq lr fd lw lm lx ly aw lz bi"><span id="f207" class="jv jw hh lm b fi ma mb l mc md">tcli add-envoy -a &lt;app&gt; -d &lt;datacenter&gt; -e &lt;environment&gt;</span></pre><p id="cae0" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">一旦访问请求被批准，更新Git中的客户端配置以使用Envoy:</p><pre class="lo lp lq lr fd lw lm lx ly aw lz bi"><span id="c92d" class="jv jw hh lm b fi ma mb l mc md">userService:<br/>  url: user.global.square # CNAME to a hardware load balancer VIP</span></pre><p id="e26b" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">将需要更改为</p><pre class="lo lp lq lr fd lw lm lx ly aw lz bi"><span id="007b" class="jv jw hh lm b fi ma mb l mc md">userService:<br/>  envoy: { app: user }</span></pre><p id="3dd0" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">通过这两个简单的更改，流量将开始通过特使边车路由。让应用程序所有者尽可能简单是推动推广的关键:大多数应用程序所有者通常对处理迁移的细节不感兴趣，因此将其抽象化并使其自助化非常有帮助。</p><p id="60a4" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated"><strong class="iv hi">现状</strong></p><p id="eb06" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">推广还远未完成，但总的来说非常顺利，大多数问题源于Envoy与传统系统在工作方式上的细微差异。我们很高兴继续致力于在Square上推出Envoy，希望在2019年完全放弃Sake，支持gRPC而不是Envoy。</p><p id="3ac9" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们也期待着探索将Envoy用于我们流量堆栈的其他部分，并利用Envoy在我们服务网络中不断增加的存在来提高Square的安全性，或使Square应用程序所有者的工作更容易。</p></div></div>    
</body>
</html>