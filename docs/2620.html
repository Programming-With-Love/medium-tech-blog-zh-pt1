<html>
<head>
<title>My September Flutter Notes — 1.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的九月飘动笔记— 1。</h1>
<blockquote>原文：<a href="https://medium.easyread.co/my-september-flutter-notes-700907827c7f?source=collection_archive---------0-----------------------#2022-09-30">https://medium.easyread.co/my-september-flutter-notes-700907827c7f?source=collection_archive---------0-----------------------#2022-09-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e2aa" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">您可能已经错过的一些flutter开发技巧、特性和解决方法</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/16b85e3342428d708d9db458c8ef6784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2V9TdOs8EraY_AEZ"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@esteejanssens?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Estée Janssens</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4fb1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我这一个月所学内容的总结。当我面临这个月早些时候解决的问题时，我才意识到要开始写笔记。然后我花了太多时间在我的几千行代码中寻找解决方案。在<a class="ae ks" href="https://stackoverflow.com/users/12838877/pmatatias" rel="noopener ugc nofollow" target="_blank"> Stackoverflow </a>上也从别人的问题中学到了一些新的东西。</p><p id="05b7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这篇笔记包含了一个技巧、技巧、特性的列表，或者任何我在2022年9月刚刚发现的关于flutter框架和dart语言的东西。好了，我们开始吧:</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="e83d" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak"> -如何在flutter上制作简单的页脚</strong>。</h2><p id="f450" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">脚手架提供财产<code class="fe mu mv mw mx b">persistentFooterButtons:[]</code>。该属性中的所有小部件都将呈现在BottomNavBar(如果存在)和主体之间。ThingsBoard移动应用程序就是一个例子。我们可以看到底部的文本“<strong class="kv io">由Thingsboard v.3.4.1 </strong>供电”堆叠在屏幕底部。我认为我们可以通过用<code class="fe mu mv mw mx b">Alignment.right</code>包装<code class="fe mu mv mw mx b">Text</code>小部件，用<code class="fe mu mv mw mx b">persistentFooterButton</code>创建一个类似的特性</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi my"><img src="../Images/8638e3f2f224341c3d3cf5eaee9b6f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*K2t3fnZIIdGRL727RuKVZg.jpeg"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screenshoot of Thingsboard app</figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="392d" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak"> -以编程方式从下一个屏幕或对话框获取返回值的简单方法。</strong></h2><p id="8edc" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">—如果我们想导航到下一个屏幕，我们可以使用一种方法<code class="fe mu mv mw mx b">Navigator.push()</code>。然后通过<code class="fe mu mv mw mx b">Navigator.pop()</code> <br/>得到返回值——这也可以应用于showDialog或showBottomSheet。弹出对话框后，我们就可以得到值了。因为showDialog也是一个未来函数。<br/>例:我们使用方法<code class="fe mu mv mw mx b">push()</code>导航到屏幕A</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bdc9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">字符串“<strong class="kv io">这是从一个</strong>的主屏幕上接收到的。</p><p id="5ea6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">—但是如果我们通过“back button”返回到home，值将会是<code class="fe mu mv mw mx b">Null</code> its，因为我们没有给方法pop设置任何值。对于这种情况，我们可以用<code class="fe mu mv mw mx b">WillpopScope</code>小部件包装<code class="fe mu mv mw mx b">Scaffold</code>。这将在用户按下AppBar中的back按钮时执行该功能。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="283d" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak"> -将小部件分离到另一个类将避免重建不必要的项目</strong>。</h2><p id="2917" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">我从一开始学习颤振就知道这一点。但是我从来没有意识到它是如何影响应用程序的，直到我构建了一个复杂的表单。所以我有一个包含多个字段的表单来创建库存信息。在我的库存表单中，我创建了带有一些动画的产品卡片小部件。卡片会显示一些物品的信息。在另一个领域，我也有一些复选框仍然在同一个屏幕上。为了更新复选框的值，我需要调用一个方法<code class="fe mu mv mw mx b">setState((){}) </code>。这将通过从当前类重新执行<strong class="kv io"> build </strong>方法来重建部件树。<br/> —以前，我看不出由类和方法分隔的小部件之间的区别。因为过程非常快，所以一切看起来都很顺利。</p><p id="3e8a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">—然后，在我创建了带有动画的自定义卡片小部件后，这真的影响了我的应用程序。正如你在下图中看到的，每次我选中我的复选框，三件商品卡片就会变成动画。因为他们都是从头开始重建的。即使“参考”字段和“项目”字段是两种不同的方法。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/a8c367603d8579b90ffc192799babefe.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/1*-ntBmAHMc985mNUovJSVPQ.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Widget is rebuilt every setState</figcaption></figure><p id="d1ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我解决这个问题的方法是将item字段拆分成一个新的<code class="fe mu mv mw mx b">StatefullWidget </code>，并将其作为一个组件小部件导入到我的表单中。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="a43e" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak"> -如何在flutter widget中限制列表</strong></h2><p id="edc2" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">当列表中有几十个小部件，但你只想显示其中的3或5个时，你可以用<code class="fe mu mv mw mx b">List.take()</code>来实现，也可以结合<code class="fe mu mv mw mx b">List.skip()</code>进行高级索引。我们也可以使用<code class="fe mu mv mw mx b">getRange()</code>，但是如果索引超出范围，它会抛出一个错误。使用<code class="fe mu mv mw mx b">take()</code>的好处是返回尽可能多的可用数据，而不会抛出任何错误。例如:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f93b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">—这是一个我用来在UI中渲染的例子。这只会在列中呈现最多3个小部件文本。如果列表长度超过3，<code class="fe mu mv mw mx b">TextButton</code>将呈现小部件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="0b07" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak"> -当弹出键盘在屏幕上时，自动滚动并聚焦文本字段。</strong></h2><p id="7041" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">这是我在弹出键盘屏幕上方渲染UI时发现的。这通常发生在我们有一些小部件列表，并且我们需要显示键盘时，小部件被堆叠在键盘后面。详细说明见本文档<a class="ae ks" href="https://api.flutter.dev/flutter/widgets/MediaQueryData/viewInsets.html" rel="noopener ugc nofollow" target="_blank">链接</a>。这里有一个例子。你可以在下图中看到，我有一个包含一些文本字段的底部工作表。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/880e8c704bd8d3ed218dba27dcc887c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/1*QtzKt-cwFaKms0H0weQ_Ag.gif"/></div></figure><p id="839c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我想填写“<em class="nc"> UM </em>字段时，键盘会弹出，列表也会滚动。我们不必担心键盘是否覆盖了Textfield。并且用户在输入表单之前不需要向下滚动。您可以通过用填充来包装父listview来实现这一点，如下面的代码片段:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="6dbb" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak"> -如何使用多个FutureBuilder </strong> ( <a class="ae ks" href="https://stackoverflow.com/a/50627153/12838877" rel="noopener ugc nofollow" target="_blank">引用</a>)</h2><p id="30ac" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">“Future builder是一个小部件，它基于与一个<a class="ae ks" href="https://api.flutter.dev/flutter/dart-async/Future-class.html" rel="noopener ugc nofollow" target="_blank">未来</a>交互的最新快照来构建自己”。它有一个建设者的未来。</p><p id="4f5e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你是否曾经想在一个卡片小部件中显示一些信息，但是后端工程师提供了不止一个API来完成你的卡片信息？您需要创建额外的模型数据来组合两个对象，以便可以轻松地显示信息。看起来有点麻烦。你试过<code class="fe mu mv mw mx b">Future.wait </code>吗？</p><p id="faec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您需要获取多个对象，<code class="fe mu mv mw mx b">Future.wait()</code>是最佳解决方案。它会将所有未来的函数打包到一个列表中。是的，我刚刚意识到，我们可以在数组未来通过索引访问每个返回值。我们不需要创建新的模型来包装所有返回的对象。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="623f" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak"> -使用监听器而不是手势检测器更快速地捕捉回调事件。</strong></h2><p id="9ff5" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">我在创建一个通过点击或点击屏幕上的任何地方来隐藏键盘的功能时遇到了一个问题。基于人们的建议是通过使用<strong class="kv io">手势检测器</strong>和调用<code class="fe mu mv mw mx b">FocusManager.instance.primaryFocus?.unfocus(); </code>。使用这种方法，我们将改变文本字段的焦点，键盘将被隐藏。但是我一试，GestureDetector的反应就有问题。关于更详细的行为，我在StackOverflow 上提出了一个<a class="ae ks" href="https://stackoverflow.com/questions/73632909/gesturedetector-with-hittestbehavior-opaque-not-work-properly-to-hide-keyboard-s" rel="noopener ugc nofollow" target="_blank">问题。这是打印的控制台日志。见第2行和第4行，我已经点击屏幕超过1次，但隐藏键盘的功能没有被调用，因为我点击屏幕的次数。在<strong class="kv io">手势检测器</strong>上有一个延迟来捕捉事件。仅供参考，我也在<strong class="kv io">手势检测器</strong>中使用了<strong class="kv io">on down</strong>属性，但是没有成功。</a></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2ee2e1a53463794db3cd7545089d1a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*n5WBCfBV8s1z315iHj3NPg.png"/></div></figure><p id="bd12" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">手势检测器</strong>正在监听更高级别的手势。这就是为什么它反应较慢。我推荐使用<strong class="kv io">监听器</strong>，因为它监听原始指针事件。行为上的差异非常明显。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="2b6f" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak"> -结论</strong></h2><p id="0a3a" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">1.我们可以使用Scaffold中的<code class="fe mu mv mw mx b">persistentFooterButtons</code>属性在flutter应用程序中创建一个页脚。<br/> 2。从对话框或新屏幕传递数据的另一种方法是绕过Navigator.pop参数的值。<br/> 3。用不同的类分离窗口小部件，以避免重新构建不必要的窗口小部件功能。<br/> 4。用<code class="fe mu mv mw mx b">viewInsets.bottom </code>添加填充，当屏幕键盘出现时自动滚动。<br/> 5。使用Future.wait，我们可以从API调用中获取多个对象数据，并在Future.builder <br/> 6中使用。如果我们想捕获原始事件，使用Listener而不是GestureDetector，因为它响应更快，延迟最小。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="7530" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个月我学到了很多。这些只是其中一些简单有趣的分享。如果你有不同的理解或问题，请留下你的评论。我很乐意打开下面的讨论。</p></div></div>    
</body>
</html>