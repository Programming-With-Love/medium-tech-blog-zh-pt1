<html>
<head>
<title>Principles and Patterns with AWS CDK Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS CDK管道的原理和模式</h1>
<blockquote>原文：<a href="https://medium.com/version-1/principles-and-patterns-with-aws-cdk-pipelines-20d39da05bc3?source=collection_archive---------2-----------------------#2022-06-13">https://medium.com/version-1/principles-and-patterns-with-aws-cdk-pipelines-20d39da05bc3?source=collection_archive---------2-----------------------#2022-06-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="b0d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在论文<em class="jc">设计原则和设计模式</em>中，罗伯特·C·马丁讨论了“腐烂设计”的症状。他强调说，糟糕设计的一个主要症状是僵化；<em class="jc">‘软件趋向于</em><strong class="ig hi"><em class="jc"/></strong><em class="jc">’</em>。</p><p id="d1e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇博客中，我们将探讨如何利用原则和编程模式来创建灵活且可维护的AWS CDK管道应用程序。</p><h1 id="2f79" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">紧密耦合的实现</h1><p id="f519" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">让我们从下面的片段开始，它取自一个使用上下文参数envType的管道应用程序。</p><ul class=""><li id="c1cd" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">当使用值“dev”传递envType时，将创建一个管道模板，该模板将部署到单个AWS帐户和区域。</li><li id="1773" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">当envType的值为“release”时，将使用两个管道阶段来部署到多个AWS帐户和区域。</li></ul><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx">Dynamic pipelines for different environments</figcaption></figure><p id="6446" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这可能看起来很简单，但是，请考虑进一步开发这些代码的含义。例如:</p><ul class=""><li id="e3d3" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">在开发和发布的同时增加更多的管道变化。</li><li id="7555" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">每个CicdStage发布不同版本的应用程序堆栈。</li><li id="4ea8" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">对每个管道使用不同的synth步骤</li></ul><p id="c0e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于开发和发布阶段的实现与管道紧密耦合，应用程序已经是<strong class="ig hi">刚性的；</strong>进一步的开发变成了附加更多if/else逻辑的练习，以满足管道、阶段和应用程序堆栈的所有组合。</p><p id="a64f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实现这些变化的结果是，代码逐渐变得混乱和脆弱，开发任务花费更长时间，变得不必要的复杂。</p><blockquote class="lf lg lh"><p id="15db" class="ie if jc ig b ih ii ij ik il im in io li iq ir is lj iu iv iw lk iy iz ja jb ha bi translated">“随着时间的推移，随着腐烂的继续，丑陋的溃烂疮和疖子积累起来，直到它们主宰了应用程序的设计。程序变成了一大堆代码，开发人员发现越来越难以维护</p></blockquote><h1 id="9ecc" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">依赖性倒置</h1><p id="7fd7" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">依赖倒置原则(<a class="ae ll" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank"> SOLID </a>)声明应用程序应该建立在抽象之上，这样实现就可以被交换，使得应用程序更加灵活<strong class="ig hi"/>。</p><p id="615d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们重温一下示例管道应用程序代码，并从一个基类开始抽象我们的管道实现。</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx">A base class to be extended by multiple pipeline types</figcaption></figure><p id="4ee3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，为开发和发布管道类型创建基类的子类。例如:</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx">Sample extension of MyPipelineBase</figcaption></figure><p id="f8a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们扩展基类时，我们必须实现抽象方法<code class="du lm ln lo lp b">addStages()</code></p><h1 id="41bf" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">模板模式</h1><p id="7064" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">当在CDK中创建代码管道时，基本上有两个关键步骤，synth和添加阶段。</p><p id="e1a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，在基类中，我们在<code class="du lm ln lo lp b">generatePipeline()</code>方法中声明了这些步骤，这被称为模板模式；指定子类要遵循的一组步骤，但允许通过重写方法来改变行为。</p><p id="f732" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以从基类的开发或测试实现中调用<code class="du lm ln lo lp b">generatePipeline()</code>，它们将共享相同的synth方法，但是执行它们各自被覆盖的<code class="du lm ln lo lp b">addStages</code>方法。</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="d3ea" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">传递接口</h1><p id="9623" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">接下来，我们来介绍一个界面。</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="92a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并更改PipelineDev和PipelineTest以实现PipelineInterface。</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="c8d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种微妙的变化使我们能够引用接口而不是实现；因此，任何实现接口的东西都可以用在它的位置上。</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="ce16" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">工厂模式</h1><p id="8a67" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">工厂模式用于根据提供的值创建对象实例。我们可以通过引入工厂模式来获得管道类型，从而扩展上面的工作。</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="ad89" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">完成抽象</h1><p id="389d" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">为了通过PipelineFactory创建pipeline实例，我们现在使用以下代码:</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="0996" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">任何对管道实现的引用都被抽象掉了</strong>。我们可以使用<strong class="ig hi">任何PipelineInterface实现</strong>来换入和使用<strong class="ig hi">，而无需更改任何底层管道代码</strong>。</p><h1 id="f65f" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">创建新的管道变化</h1><p id="31f7" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">既然我们所有的管道实现都是从管道本身抽象出来的，我们就能够交换管道实现了。让我们回顾一下这篇博客开始时要求的代码更改。</p><p id="986f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">我们如何在开发和发布的同时增加另一个管道变化？<br/> </strong>只需扩展MyPipelineBase类，根据需要实现addStages()。根据需要修改PipelineFactory以创建实例。</p><p id="8ffc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">我们如何在每个CicdStage中实现不同版本的应用程序堆栈？将本博客中讨论的相同模式应用到您的管道阶段，使用工厂模式来确定使用哪个实现。</strong></p><p id="2ed5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">我们如何使用不同的synth实现？简单地用自己的方法覆盖synth的基类实现。</strong></p><h1 id="9673" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="4586" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在这篇博客中，我们研究了如何应用原则和模式来使脆弱和僵化的CDK管道应用程序变得灵活和更易于维护。</p><p id="78bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">无论项目有多简单，考虑应用程序架构和维护永远不会太早。腐烂的设计是一个渐进过程的结果，不处理的时间越长，就越难修复。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lq"><img src="../Images/3201a2a89d9110e6df1f758293360182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6mCdv1OaLNYFIgSzPeA2w.jpeg"/></div></div></figure><p id="76b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">关于作者:<br/> </strong> Paul Harwood是这里的高级AWS DevOps工程师。</p></div></div>    
</body>
</html>