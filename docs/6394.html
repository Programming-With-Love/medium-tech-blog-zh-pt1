<html>
<head>
<title>Service Workers in JS and offline reading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS和线下阅读的服务人员</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/service-workers-in-js-and-offline-reading-7bac9d4980ea?source=collection_archive---------2-----------------------#2018-01-29">https://medium.com/quick-code/service-workers-in-js-and-offline-reading-7bac9d4980ea?source=collection_archive---------2-----------------------#2018-01-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/bf302fba5531c920d49160c92bc0c8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kX8nlVNNw7Ht56pAihp8Aw.jpeg"/></div></div></figure><p id="caee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗨！首先:新年快乐！我希望2018年是个好年，不会因为一个金发总统而导致第三次世界大战。</p><p id="f1c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我们开始更有趣的话题。让我们想象一下，你是一个谈论政治新闻的网站的所有者，有非常长的文章，非常棒。作为一个用户，如果我从我的智能手机上下载一些我想在你的网站上阅读的文章，关闭我的智能手机，几天后当我在纽约地铁上没有任何连接的情况下回到那里，仍然可以打开Firefox阅读你的文章，这不是很酷吗？</p><p id="3ff5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">多亏了服务人员，这才成为可能，而且很容易实现。</p><p id="905d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从前，有一个API叫做<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Using_the_application_cache" rel="noopener ugc nofollow" target="_blank"> AppCache </a>。这个API允许人们将页面存储在缓存中，以便在离线时在客户端浏览器中进一步使用。但是它有一个<a class="ae jn" href="https://alistapart.com/article/application-cache-is-a-douchebag&lt;Paste&gt;" rel="noopener ugc nofollow" target="_blank">几个问题</a>。而W3C让这个API <a class="ae jn" href="https://html.spec.whatwg.org/multipage/offline.html#offline" rel="noopener ugc nofollow" target="_blank">弃用了</a>。“但是现在我们该怎么办”Devs问道？嗯，我们有了一个新的强大的API，允许我们离线存储资产:服务工作者。</p><p id="a5f1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个Web世界上的新家伙是一个闪亮的API，表面上很自豪，因为它的功能允许每个人做他/她想做的任何事情，即使在AppCache不高兴和做自己的事情的情况下。</p><h1 id="880d" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">服务人员</h1><p id="da51" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">服务工作者基本上是一个JavaScript文件，它将由浏览器在不同于web页面的普通脚本的上下文中运行。它:</p><ul class=""><li id="5373" class="kr ks hh ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated">正在独立的执行线程上运行</li><li id="d645" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">没有访问DOM的权限</li><li id="19f8" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">“安装”在用户的电脑/智能手机上。</li><li id="fff2" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">只在HTTPS域上运行(对于火狐浏览器，Chrome不在乎它是否在不安全的页面上)</li></ul><p id="485f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后你可以说:“耶，太酷了。但是现在呢？我们可以用这个JavaScript做什么？如果它不能访问DOM……”</p><p id="6d23" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗯，这是因为服务工作者的目的不是处理DOM，而是处理对服务器的<strong class="ir hi">请求。它有几个步骤，为了说明这一点，我将向您展示一张来自<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Browser_compatibility" rel="noopener ugc nofollow" target="_blank"> MDN </a>的精美图片:</strong></p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es lf"><img src="../Images/3f24e68282831892144414f59e53e7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/0*9qrR26RjH3nS1skZ.png"/></div></figure><h1 id="be10" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">注册服务人员</h1><p id="2d76" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在安装服务工作者之前，您需要从您的主JavaScript文件中注册一个。这可以通过下面的方法<code class="du lk ll lm ln b">navigator.serviceWorker.register</code>实现:</p><pre class="lg lh li lj fd lo ln lp lq aw lr bi"><span id="6069" class="ls jp hh ln b fi lt lu l lv lw">if ('serviceWorker' in navigator) {<br/>navigator.serviceWorker.register('/serviceWorkerArticles.js', { scope: '/' }):<br/>}</span></pre><p id="5bd3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个方法有两个参数:</p><ul class=""><li id="dde6" class="kr ks hh ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated">javascript文件的<strong class="ir hi">名</strong>，相对于你的域的根</li><li id="723f" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated">(可选)范围<strong class="ir hi">范围</strong>给出服务人员有权工作的特定范围。基本上，它是控制资产的文件夹，默认值是域的根。</li></ul><p id="4520" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意</strong>:该函数返回一个<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>。</p><blockquote class="lx"><p id="ba6e" class="ly lz hh bd ma mb mc md me mf mg jm dx translated">找到关于各种编程语言的<a class="ae jn" href="http://www.quickcode.co/" rel="noopener ugc nofollow" target="_blank">快速代码</a>的免费课程。获取<a class="ae jn" href="https://www.messenger.com/t/1493528657352302" rel="noopener ugc nofollow" target="_blank"> Messenger </a>的新更新。</p></blockquote><h1 id="1172" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz mh kb kc kd mi kf kg kh mj kj kk kl bi translated">安装和使用维修工人</h1><p id="d39b" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">现在，我们从“serviceWorker.js”注册了一个服务工作者，让我们填写这个文件，这样，如果您的用户以前已经访问过所需的文章，您的关于政治文章的网站就可以脱机阅读它的文章。</p><p id="e357" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于大多数操作，你只需要做一些<code class="du lk ll lm ln b">addEventListener</code>，因为服务人员已经有很多有用的事件要听了！</p><pre class="lg lh li lj fd lo ln lp lq aw lr bi"><span id="1b9d" class="ls jp hh ln b fi lt lu l lv lw">self.addEventListener('install', cach =&gt; {<br/>    event.waitUntil(<br/>        caches.open('v1').then(cache =&gt; {<br/>            return cache.addAll([<br/>              '/',<br/>              '/style.css',<br/>              '/app.js',<br/>              '/favicon.ico',<br/>              '/frontPageCover.jpg',<br/>            ]);<br/>          })<br/>        );<br/>    });</span></pre><p id="e3a9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们这里有3个有趣的方法！让我们快速浏览一下所有这些内容:</p><ul class=""><li id="d145" class="kr ks hh ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated"><code class="du lk ll lm ln b">event.waitUntil</code>:这个方法用于一个事件中，让它等待一个承诺被解决，在我们的例子中，我们必须在服务工作者被认为<em class="mk">已安装</em>之前从缓存中计算东西</li><li id="2d82" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated"><code class="du lk ll lm ln b">caches.open</code>:这个方法来自于<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage" rel="noopener ugc nofollow" target="_blank"> CacheStorage API </a>，它返回一个包含你在给定参数中请求的缓存的承诺。</li><li id="cf65" class="kr ks hh ir b is la iw lb ja lc je ld ji le jm kw kx ky kz bi translated"><code class="du lk ll lm ln b">cache.addAll</code>:该方法来自<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" rel="noopener ugc nofollow" target="_blank">缓存API </a>(不要和CacheStorage混淆，缓存API是由<code class="du lk ll lm ln b">caches.open</code>返回的对象)。该方法接受一个URL数组，并尝试对每个URL进行检索，然后将其存储在Cache对象中。</li></ul><p id="3481" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以有了这个代码，你的服务人员现在是<strong class="ir hi">注册的</strong>、<strong class="ir hi">安装的</strong>，以及<strong class="ir hi">活动的</strong>。如果你进入你网站的主页，并在离线模式下重新加载，你应该能像以前一样看到你的页面！</p><h1 id="571d" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">更进一步</h1><p id="e8e3" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在本文中，我们只讨论了服务工作者API的一些部分，但是您可以做许多其他事情，例如删除旧的缓存，动态添加新的URL以加载到您的服务工作者中，等等…</p><p id="c2d6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想深入了解这一点，我建议你看看这个关于服务人员的<a class="ae jn" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Browser_compatibility" rel="noopener ugc nofollow" target="_blank"> MDN页面，这是我今天这篇文章的大部分灵感。</a></p></div><div class="ab cl ml mm go mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ha hb hc hd he"><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="bc22" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请点击👏按钮下面几下，以示支持！⬇⬇</p><p id="589c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">谢谢！别忘了<strong class="ir hi">关注下面的</strong>快速码。</p></div></div>    
</body>
</html>