<html>
<head>
<title>Unit Testing React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试反应组件</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/unit-testing-react-components-aeda9a44aae2?source=collection_archive---------0-----------------------#2019-03-07">https://medium.com/javascript-scene/unit-testing-react-components-aeda9a44aae2?source=collection_archive---------0-----------------------#2019-03-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4654bb4dd135baf31fcb83a7c02921b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzR_S8UJeDn0b_sEQa2V8Q.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo of a first attempt to test a React component by clement127 (CC BY-NC-ND 2.0)</figcaption></figure><p id="45f8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">单元测试是一门伟大的学科，它可以导致错误密度降低40%-80%。单元测试还有其他几个重要的好处:</p><ul class=""><li id="9e5a" class="js jt hh iv b iw ix ja jb je ju ji jv jm jw jq jx jy jz ka bi translated">改进您的应用程序架构和可维护性。</li><li id="370c" class="js jt hh iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">通过让开发人员在实现细节之前关注开发人员体验(API ),带来更好的API和可组合性。</li><li id="ac38" class="js jt hh iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">提供关于文件保存的快速反馈，告诉您更改是否有效。这可以代替<code class="du kg kh ki kj b">console.log()</code>和在UI中点击来测试变化。单元测试的新手可能会在测试驱动开发(TDD)过程上花费额外的15% - 30%，因为他们知道如何测试各种组件，但是有经验的TDD实践者可能会体验到使用TDD节省实现时间。</li><li id="ff0e" class="js jt hh iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated">提供了一个很好的安全网，可以增强您在添加功能或重构现有功能时的信心。</li></ul><p id="4021" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但是有些东西比其他东西更容易进行单元测试。具体来说，单元测试对于<a class="ae jr" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">纯函数</a>非常有效:给定相同输入的函数，总是返回相同的输出，并且没有副作用。</p><p id="abea" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">通常，UI组件不属于易于单元测试的那一类，这使得坚持TDD的原则更加困难:首先编写测试。</p><p id="deaa" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">首先编写测试对于实现我列出的一些好处是必要的:架构改进，更好的开发者体验设计，以及开发应用时更快的反馈。训练自己使用TDD需要纪律和实践。许多开发人员喜欢在编写测试之前进行修补，但是如果你不首先编写测试，你就剥夺了单元测试的许多最佳特性。</p><p id="aabb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">不过，这值得练习和训练。带有单元测试的TDD可以训练你编写更简单、更容易维护、更容易与其他组件组合和重用的UI组件。</p><p id="6e89" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我的测试领域最近的一项创新是开发了<a class="ae jr" rel="noopener" href="/javascript-scene/rethinking-unit-test-assertions-55f59358253f"> RITEway单元测试框架</a>，它是一个包裹在<a class="ae jr" href="https://github.com/substack/tape" rel="noopener ugc nofollow" target="_blank">带</a>周围的小包装，帮助你编写更简单、更易维护的测试。</p><p id="9aee" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">无论你使用什么样的框架，下面的技巧将帮助你编写更好的、更易测试的、更易阅读的、更易组合的UI组件:</p><ul class=""><li id="526a" class="js jt hh iv b iw ix ja jb je ju ji jv jm jw jq jx jy jz ka bi translated"><strong class="iv hi">UI代码偏向纯组件:</strong>给定相同的道具，总是渲染相同的组件。如果您需要来自应用程序的状态，您可以用管理状态和副作用的容器组件包装这些纯组件。</li><li id="b069" class="js jt hh iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hi">将应用逻辑/业务规则</strong>隔离在纯粹的reducer功能中。</li><li id="2638" class="js jt hh iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hi">使用容器组件隔离副作用</strong>。</li></ul><h1 id="bb42" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">偏爱纯成分</h1><p id="6d51" class="pw-post-body-paragraph it iu hh iv b iw li iy iz ja lj jc jd je lk jg jh ji ll jk jl jm lm jo jp jq ha bi translated">纯组件是这样一种组件，给定相同的属性，它总是呈现相同的UI，并且没有副作用。例如，</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="263e" class="lv kl hh kj b fi lw lx l ly lz">import React from 'react';</span><span id="e55e" class="lv kl hh kj b fi ma lx l ly lz">const Hello = ({ userName }) =&gt; (<br/>  &lt;div className="greeting"&gt;Hello, {userName}!&lt;/div&gt;<br/>);</span><span id="7b07" class="lv kl hh kj b fi ma lx l ly lz">export default Hello;</span></pre><p id="f41a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这些类型的组件通常很容易测试。您需要一种选择组件的方法(在本例中，我们通过<code class="du kg kh ki kj b">greeting</code> <code class="du kg kh ki kj b">className</code>进行选择)，并且您需要知道预期的输出。为了编写纯组件测试，我使用来自<code class="du kg kh ki kj b">RITEway</code>的<code class="du kg kh ki kj b">render-component</code>。</p><p id="0fd2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要开始，请安装RITEway:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="d2ff" class="lv kl hh kj b fi lw lx l ly lz">npm install --save-dev riteway</span></pre><p id="0bd0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在内部，RITEway使用<code class="du kg kh ki kj b">react-dom/server</code>T5，并将输出包装在一个<a class="ae jr" href="https://github.com/cheeriojs/cheerio" rel="noopener ugc nofollow" target="_blank"> Cheerio </a>对象中，以便于选择。如果没有使用RITEway，可以手动创建自己的函数，将React组件呈现为可以用Cheerio查询的静态标记。</p><p id="4b5a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一旦有了从标记中生成Cheerio对象的呈现函数，就可以编写这样的组件测试:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="83ca" class="lv kl hh kj b fi lw lx l ly lz">import React from 'react';<br/>import { describe } from 'riteway';<br/>import render from 'riteway/render-component';<br/>import match from 'riteway/match';</span><span id="4a21" class="lv kl hh kj b fi ma lx l ly lz">import Hello from '../hello';</span><span id="3b6c" class="lv kl hh kj b fi ma lx l ly lz">describe('Hello component', async assert =&gt; {<br/>  const userName = 'Spiderman';<br/>  const $ = render(&lt;Hello userName={userName} /&gt;);<br/>  const contains = match($('.greeting').html());</span><span id="30af" class="lv kl hh kj b fi ma lx l ly lz">  assert({<br/>    given: 'a username',<br/>    should: 'Render a greeting to the correct username.',<br/>    actual: contains(userName),<br/>    expected: `Hello, ${userName}!`<br/>  });<br/>});</span></pre><p id="767c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但那不是很有趣。如果你需要测试一个有状态的组件，或者一个有副作用的组件呢？这就是TDD对React组件真正感兴趣的地方，因为这个问题的答案与另一个重要问题的答案是一样的:“我如何使我的React组件更易于维护和调试？”</p><p id="eac1" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">答案是:将您的状态和副作用从您的表示组件中分离出来。您可以通过将您的状态和副作用管理封装在一个容器组件中，然后通过props将状态传递到一个纯组件中来实现。</p><p id="341f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但是hooks API不就是为了让我们拥有扁平的组件层次结构，并且忘记所有的组件嵌套吗？不完全是。将您的代码放在三个不同的存储桶中，并使这些存储桶相互隔离，这仍然是一个好主意:</p><ul class=""><li id="a534" class="js jt hh iv b iw ix ja jb je ju ji jv jm jw jq jx jy jz ka bi translated"><strong class="iv hi">显示/用户界面组件</strong></li><li id="f3ad" class="js jt hh iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hi">程序逻辑/业务规则</strong>——处理你正在为用户解决的问题的东西。</li><li id="27dd" class="js jt hh iv b iw kb ja kc je kd ji ke jm kf jq jx jy jz ka bi translated"><strong class="iv hi">副作用</strong> (I/O、网络、磁盘等。)</li></ul><p id="71c7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">根据我的经验，如果你将显示/UI问题与程序逻辑和副作用分开，你的生活会轻松很多。这条经验法则一直适用于我，在我使用过的每一种语言和每一个框架中，包括用钩子做出反应。</p><p id="d3ed" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们通过构建一个点击计数器来演示有状态组件。首先，我们将构建UI组件。它应该显示类似“Clicks: 13”的信息，告诉你一个按钮被点击了多少次。按钮只会显示“点击”。</p><p id="ea48" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">显示组件的单元测试非常简单。我们实际上只需要测试按钮是否被渲染(我们不关心标签上写了什么——它可能用不同的语言写了不同的东西，这取决于用户的区域设置)。我们<em class="mb">确实</em>想要确保显示正确的点击次数。让我们编写两个测试:一个用于按钮显示，一个用于正确呈现的点击次数。</p><p id="ea0d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当使用TDD时，我经常使用两种不同的断言来确保我已经编写了组件，以便从props中提取正确的值。可以编写一个测试，这样就可以硬编码函数中的值。为了防止这种情况，您可以编写两个测试，每个测试一个不同的值。</p><p id="baa8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这种情况下，我们将创建一个名为<code class="du kg kh ki kj b">&lt;ClickCounter&gt;</code>的组件，该组件将有一个用于点击计数的道具，名为<code class="du kg kh ki kj b">clicks</code>。要使用它，只需渲染组件并将<code class="du kg kh ki kj b">clicks</code>属性设置为您希望它显示的点击次数。</p><p id="b553" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们来看两个单元测试，它们可以确保我们从props中获取点击量。让我们创建一个新文件，<code class="du kg kh ki kj b">click-counter/click-counter-component.test.js</code>:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="b0f9" class="lv kl hh kj b fi lw lx l ly lz">import { describe } from 'riteway';<br/>import render from 'riteway/render-component';<br/>import React from 'react';</span><span id="54ba" class="lv kl hh kj b fi ma lx l ly lz">import ClickCounter from '../click-counter/click-counter-component';</span><span id="de38" class="lv kl hh kj b fi ma lx l ly lz">describe('ClickCounter component', async assert =&gt; {<br/>  const createCounter = clickCount =&gt;<br/>    render(&lt;ClickCounter clicks={ clickCount } /&gt;)<br/>  ;</span><span id="a57d" class="lv kl hh kj b fi ma lx l ly lz">  {<br/>    const count = 3;<br/>    const $ = createCounter(count);</span><span id="5f08" class="lv kl hh kj b fi ma lx l ly lz">    assert({<br/>      given: 'a click count',<br/>      should: 'render the correct number of clicks.',<br/>      actual: parseInt($('.clicks-count').html().trim(), 10),<br/>      expected: count<br/>    });<br/>  }</span><span id="afa4" class="lv kl hh kj b fi ma lx l ly lz">  {<br/>    const count = 5;<br/>    const $ = createCounter(count);</span><span id="bab1" class="lv kl hh kj b fi ma lx l ly lz">    assert({<br/>      given: 'a click count',<br/>      should: 'render the correct number of clicks.',<br/>      actual: parseInt($('.clicks-count').html().trim(), 10),<br/>      expected: count<br/>    });<br/>  }<br/>});</span></pre><p id="d676" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我喜欢创建小的工厂函数，使编写测试更容易。在这种情况下，<code class="du kg kh ki kj b">createCounter</code>将进行多次点击来注入，并使用该点击次数返回一个呈现的组件:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="60cd" class="lv kl hh kj b fi lw lx l ly lz">const createCounter = clickCount =&gt;<br/>  render(&lt;ClickCounter clicks={ clickCount } /&gt;)<br/>;</span></pre><p id="3b71" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">写完测试之后，是时候创建我们的<code class="du kg kh ki kj b">ClickCounter</code>显示组件了。我将我的文件和我的测试文件放在同一个文件夹中，文件名为<code class="du kg kh ki kj b">click-counter-component.js</code>。首先，让我们编写一个组件片段，看着我们的测试失败:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="63e3" class="lv kl hh kj b fi lw lx l ly lz">import React, { Fragment } from 'react';</span><span id="5c82" class="lv kl hh kj b fi ma lx l ly lz">export default () =&gt;<br/>  &lt;Fragment&gt;<br/>  &lt;/Fragment&gt;<br/>;</span></pre><p id="bd28" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果我们保存并运行我们的测试，我们将得到一个<code class="du kg kh ki kj b">TypeError</code>，它当前触发了Node的<code class="du kg kh ki kj b">UnhandledPromiseRejectionWarning</code>——最终，Node将停止发出带有额外段落<code class="du kg kh ki kj b">DeprecationWarning</code>的恼人警告，而只是抛出一个<code class="du kg kh ki kj b">UnhandledPromiseRejectionError</code>。我们得到了<code class="du kg kh ki kj b">TypeError</code>,因为我们的选择返回了<code class="du kg kh ki kj b">null</code>,我们试图对它运行<code class="du kg kh ki kj b">.trim()</code>。让我们通过呈现预期的选择器来解决这个问题:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="3c55" class="lv kl hh kj b fi lw lx l ly lz">import React, { Fragment } from 'react';</span><span id="b2dd" class="lv kl hh kj b fi ma lx l ly lz">export default () =&gt;<br/>  &lt;Fragment&gt;<br/>    &lt;span className="clicks-count"&gt;3&lt;/span&gt;<br/>  &lt;/Fragment&gt;<br/>;</span></pre><p id="cd7a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">太好了。现在我们应该有一个通过的测试和一个失败的测试:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="7fb1" class="lv kl hh kj b fi lw lx l ly lz"># ClickCounter component<br/>ok 2 Given a click count: should render the correct number of clicks.<br/>not ok 3 Given a click count: should render the correct number of clicks.<br/>  ---<br/>    operator: deepEqual<br/>    expected: 5<br/>    actual:   3<br/>    at: assert (/home/eric/dev/react-pure-component-starter/node_modules/riteway/source/riteway.js:15:10)<br/>...</span></pre><p id="442b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要修复它，请将计数作为一个道具，并使用JSX中的活动道具值:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="d86b" class="lv kl hh kj b fi lw lx l ly lz">import React, { Fragment } from 'react';</span><span id="f2b9" class="lv kl hh kj b fi ma lx l ly lz">export default ({ clicks }) =&gt;<br/>  &lt;Fragment&gt;<br/>    &lt;span className="clicks-count"&gt;{ clicks }&lt;/span&gt;<br/>  &lt;/Fragment&gt;<br/>;</span></pre><p id="2855" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在我们的整个测试套件都通过了:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="4565" class="lv kl hh kj b fi lw lx l ly lz">TAP version 13<br/># Hello component<br/>ok 1 Given a username: should Render a greeting to the correct username.<br/># ClickCounter component<br/>ok 2 Given a click count: should render the correct number of clicks.<br/>ok 3 Given a click count: should render the correct number of clicks.</span><span id="fc7a" class="lv kl hh kj b fi ma lx l ly lz">1..3<br/># tests 3<br/># pass  3</span><span id="8bac" class="lv kl hh kj b fi ma lx l ly lz"># ok</span></pre><p id="aa61" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">测试按钮的时间到了。首先，添加测试并看着它失败(TDD风格):</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="f32c" class="lv kl hh kj b fi lw lx l ly lz">{<br/>  const $ = createCounter(0);</span><span id="5fdd" class="lv kl hh kj b fi ma lx l ly lz">  assert({<br/>    given: 'expected props',<br/>    should: 'render the click button.',<br/>    actual: $('.click-button').length,<br/>    expected: 1<br/>  });<br/>}</span></pre><p id="78f3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这会产生一个失败的测试:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="ecdb" class="lv kl hh kj b fi lw lx l ly lz">not ok 4 Given expected props: should render the click button<br/>  ---<br/>    operator: deepEqual<br/>    expected: 1<br/>    actual:   0<br/>...</span></pre><p id="9fb4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在我们将实现点击按钮:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="5ec5" class="lv kl hh kj b fi lw lx l ly lz">export default ({ clicks }) =&gt;<br/>  &lt;Fragment&gt;<br/>    &lt;span className="clicks-count"&gt;{ clicks }&lt;/span&gt;<br/>    &lt;button className="click-button"&gt;Click&lt;/button&gt;<br/>  &lt;/Fragment&gt;<br/>;</span></pre><p id="3e7c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">并且测试通过:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="0f93" class="lv kl hh kj b fi lw lx l ly lz">TAP version 13<br/># Hello component<br/>ok 1 Given a username: should Render a greeting to the correct username.<br/># ClickCounter component<br/>ok 2 Given a click count: should render the correct number of clicks.<br/>ok 3 Given a click count: should render the correct number of clicks.<br/>ok 4 Given expected props: should render the click button.</span><span id="aaff" class="lv kl hh kj b fi ma lx l ly lz">1..4<br/># tests 4<br/># pass  4</span><span id="e146" class="lv kl hh kj b fi ma lx l ly lz"># ok</span></pre><p id="b0c8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在我们只需要实现状态逻辑并连接事件处理程序。</p><h1 id="f8c2" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">单元测试有状态组件</h1><p id="7554" class="pw-post-body-paragraph it iu hh iv b iw li iy iz ja lj jc jd je lk jg jh ji ll jk jl jm lm jo jp jq ha bi translated">我将要向你展示的方法对于点击计数器来说可能有点过了，但是大多数应用程序都比点击计数器复杂得多。状态通常保存在数据库中或在组件之间共享。React社区中流行的说法是从本地组件状态开始，然后根据需要提升到父组件或全局应用程序状态。</p><p id="a343" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">事实证明，如果您用纯函数开始本地组件状态管理，那么这个过程以后更容易管理。出于这个和其他原因(比如React生命周期混乱、状态一致性、避免常见错误)，我喜欢使用纯reducer函数来实现我的状态管理。对于本地组件状态，您可以导入它们并应用<code class="du kg kh ki kj b">useReducer</code> React钩子。</p><p id="c67d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您需要将状态提升到由Redux这样的状态管理器来管理，那么在开始之前，您已经完成了一半的工作:单元测试等等。</p><p id="73dc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">首先，我将为状态缩减器创建一个新的测试文件。我将把它放在同一个文件夹中，但使用不同的文件。我把这个叫做<code class="du kg kh ki kj b">click-counter/click-counter-reducer.test.js</code>:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="d5ab" class="lv kl hh kj b fi lw lx l ly lz">import { describe } from 'riteway';</span><span id="e88d" class="lv kl hh kj b fi ma lx l ly lz">import { reducer, click } from '../click-counter/click-counter-reducer';</span><span id="e0ac" class="lv kl hh kj b fi ma lx l ly lz">describe('click counter reducer', async assert =&gt; {<br/>  assert({<br/>    given: 'no arguments',<br/>    should: 'return the valid initial state',<br/>    actual: reducer(),<br/>    expected: 0<br/>  });<br/>});</span></pre><p id="0151" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我总是从断言开始，以确保缩减器将产生有效的初始状态。如果您后来决定使用Redux，它将调用每个没有状态的reducer，以便为存储产生初始状态。这也使得创建一个有效的初始状态变得非常容易，只要你需要一个初始状态来进行单元测试，或者初始化你的组件状态。</p><p id="494a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当然，我们需要创建一个相应的reducer文件。我把它叫做<code class="du kg kh ki kj b">click-counter/click-counter-reducer.js</code>:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="215b" class="lv kl hh kj b fi lw lx l ly lz">const click = () =&gt; {};</span><span id="6d6e" class="lv kl hh kj b fi ma lx l ly lz">const reducer = () =&gt; {};</span><span id="7118" class="lv kl hh kj b fi ma lx l ly lz">export { reducer, click };</span></pre><p id="b02a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我从简单地导出一个空的reducer和action creator开始。要了解更多关于动作创建器和选择器的重要作用，请阅读<a class="ae jr" rel="noopener" href="/javascript-scene/10-tips-for-better-redux-architecture-69250425af44">“10个更好的Redux架构技巧”</a>。我们现在不打算深入React/Redux架构模式，但是对这个主题的理解将有助于理解我们在这里做什么，即使您不打算使用Redux库。</p><p id="3a68" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">首先，我们将看到测试失败:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="257a" class="lv kl hh kj b fi lw lx l ly lz"># click counter reducer<br/>not ok 5 Given no arguments: should return the valid initial state<br/>  ---<br/>    operator: deepEqual<br/>    expected: 0<br/>    actual:   undefined</span></pre><p id="d54e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在让我们通过测试:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="0f0c" class="lv kl hh kj b fi lw lx l ly lz">const reducer = () =&gt; 0;</span></pre><p id="73c0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">初始值测试现在将通过，但是是时候添加更有意义的测试了:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="5c5c" class="lv kl hh kj b fi lw lx l ly lz">  assert({<br/>    given: 'initial state and a click action',<br/>    should: 'add a click to the count',<br/>    actual: reducer(undefined, click()),<br/>    expected: 1<br/>  });</span><span id="c583" class="lv kl hh kj b fi ma lx l ly lz">  assert({<br/>    given: 'a click count and a click action',<br/>    should: 'add a click to the count',<br/>    actual: reducer(3, click()),<br/>    expected: 4<br/>  });</span></pre><p id="12ec" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">观察测试失败(当它们应该分别返回<code class="du kg kh ki kj b">1</code>和<code class="du kg kh ki kj b">4</code>时，它们都返回<code class="du kg kh ki kj b">0</code>)。然后实施修复。</p><p id="ab42" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注意，我使用了<code class="du kg kh ki kj b">click()</code> action creator作为reducer的公共API。在我看来，您应该把reducer看作是您的应用程序不直接与之交互的东西。相反，它使用动作创建器和选择器作为缩减器的公共API。</p><p id="69f3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我也不为动作创建者和选择器编写单独的单元测试。我总是结合减速器来测试它们。测试reducer就是测试动作创建者和选择器，反之亦然。如果您遵循这个经验法则，您将需要更少的测试，但是仍然可以获得与您独立测试时相同的测试和案例覆盖率。</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="34dc" class="lv kl hh kj b fi lw lx l ly lz">const click = () =&gt; ({<br/>  type: 'click-counter/click',<br/>});</span><span id="b561" class="lv kl hh kj b fi ma lx l ly lz">const reducer = (state = 0, { type } = {}) =&gt; {<br/>  switch (type) {<br/>    case click().type: return state + 1;<br/>    default: return state;<br/>  }<br/>};</span><span id="86ff" class="lv kl hh kj b fi ma lx l ly lz">export { reducer, click };</span></pre><p id="1c44" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在所有的单元测试都将通过:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="88af" class="lv kl hh kj b fi lw lx l ly lz">TAP version 13<br/># Hello component<br/>ok 1 Given a username: should Render a greeting to the correct username.<br/># ClickCounter component<br/>ok 2 Given a click count: should render the correct number of clicks.<br/>ok 3 Given a click count: should render the correct number of clicks.<br/>ok 4 Given expected props: should render the click button.<br/># click counter reducer<br/>ok 5 Given no arguments: should return the valid initial state<br/>ok 6 Given initial state and a click action: should add a click to the count<br/>ok 7 Given a click count and a click action: should add a click to the count</span><span id="4d28" class="lv kl hh kj b fi ma lx l ly lz">1..7<br/># tests 7<br/># pass  7</span><span id="c639" class="lv kl hh kj b fi ma lx l ly lz"># ok</span></pre><p id="1c8c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">只差一步:将我们的行为连接到我们的组件。我们可以用容器组件来实现。我称之为<code class="du kg kh ki kj b">index.js</code>,并将它与其他文件放在一起。它应该是这样的:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="cf31" class="lv kl hh kj b fi lw lx l ly lz">import React, { useReducer } from 'react';</span><span id="843b" class="lv kl hh kj b fi ma lx l ly lz">import Counter from './click-counter-component';<br/>import { reducer, click } from './click-counter-reducer';</span><span id="4576" class="lv kl hh kj b fi ma lx l ly lz">export default () =&gt; {<br/>  const [clicks, dispatch] = useReducer(reducer, reducer());<br/>  return &lt;Counter<br/>    clicks={ clicks }<br/>    onClick={() =&gt; dispatch(click())}<br/>  /&gt;;<br/>};</span></pre><p id="4c5d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">就是这样。该组件唯一的工作是连接我们的状态管理，并将状态作为道具传递给我们经过单元测试的pure组件。要测试它，请在浏览器中加载应用程序，然后单击“点击”按钮。</p><p id="bcc6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">到目前为止，我们还没有看到浏览器中的组件，也没有做任何样式。为了澄清我们正在计数的内容，我将为<code class="du kg kh ki kj b">ClickCounter</code>组件添加一个标签和一些空间。我还会挂上<code class="du kg kh ki kj b">onClick</code>功能。现在代码看起来像这样:</p><pre class="ln lo lp lq fd lr kj ls lt aw lu bi"><span id="dc1e" class="lv kl hh kj b fi lw lx l ly lz">import React, { Fragment } from 'react';</span><span id="eb2a" class="lv kl hh kj b fi ma lx l ly lz">export default ({ clicks, onClick }) =&gt;<br/>  &lt;Fragment&gt;<br/>    Clicks: &lt;span className="clicks-count"&gt;{ clicks }&lt;/span&gt;&amp;nbsp;<br/>    &lt;button className="click-button" onClick={onClick}&gt;Click&lt;/button&gt;<br/>  &lt;/Fragment&gt;<br/>;</span></pre><p id="e6ad" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">并且所有的单元测试仍然通过。</p><p id="5dde" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">容器组件的测试呢？我不对容器组件进行单元测试。相反，我使用功能测试，在浏览器中运行，模拟用户与实际UI的交互，端到端运行。在您的应用程序中，您需要两种类型的测试(单元测试和功能测试)，对您的容器组件(主要是连接/连接组件，就像上面连接我们的reducer的组件)进行单元测试对我来说是多余的，并且不太容易正确地进行单元测试。通常，您必须模拟各种容器组件依赖关系才能让它们工作。</p><p id="8810" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">与此同时，我们已经对所有不依赖于副作用的重要单元进行了单元测试:我们正在测试数据是否得到了正确的呈现，状态是否得到了正确的管理。您还应该在浏览器中加载组件，并亲自查看按钮是否工作以及UI是否响应。</p><p id="4962" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为React实现功能/e2e测试与为任何其他框架实现它们是一样的。查看<a class="ae jr" rel="noopener" href="/javascript-scene/behavior-driven-development-bdd-and-functional-testing-62084ad7f1f2">“行为驱动开发(BDD)和功能测试”</a>了解详情。</p><h1 id="6316" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">后续步骤</h1><p id="24ab" class="pw-post-body-paragraph it iu hh iv b iw li iy iz ja lj jc jd je lk jg jh ji ll jk jl jm lm jo jp jq ha bi translated">TDD日是一个5小时的视频记录，带有关于测试驱动开发的所有方面的交互式课程。它被设计成一个很棒的全天速成课程，来提升你的整个团队的TDD技能。不管你目前的TDD经验如何，你都会学到很多。适用于<a class="ae jr" href="https://ericelliottjs.com/premium-content" rel="noopener ugc nofollow" target="_blank">EricElliottJS.com</a>的成员。</p></div><div class="ab cl mc md go me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ha hb hc hd he"><p id="294e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="mb"> Eric Elliott </em> </strong> <em class="mb">是分布式系统专家，著有书籍</em> <a class="ae jr" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="mb">【排版软件】</em></a><em class="mb"/><a class="ae jr" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"><em class="mb">【编程JavaScript应用】</em> </a> <em class="mb">。作为</em><a class="ae jr" href="https://devanywhere.io" rel="noopener ugc nofollow" target="_blank"><em class="mb">devanywhere . io</em></a><em class="mb">的联合创始人，他向开发人员传授远程工作和实现工作/生活平衡所需的技能。他为加密项目组建开发团队并提供建议，为Adobe Systems、</em> <strong class="iv hi"> <em class="mb">、Zumba Fitness、</em> </strong> <em class="mb"> </em> <strong class="iv hi"> <em class="mb">【华尔街日报、</em></strong><em class="mb"/><strong class="iv hi"><em class="mb">【ESPN、</em></strong><em class="mb"/><strong class="iv hi"><em class="mb">BBC、</em> </strong> <em class="mb">以及包括</em> <strong class="iv hi"> <em class="mb">亚瑟、弗兰克·奥申、金属乐队在内的顶级录音艺术家提供软件体验</em></strong></p><p id="0b51" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>