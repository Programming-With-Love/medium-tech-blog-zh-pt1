<html>
<head>
<title>Kotlin Programmer Dictionary: Field vs Property</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林程序员词典:字段与属性</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531?source=collection_archive---------2-----------------------#2017-11-02">https://blog.kotlin-academy.com/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531?source=collection_archive---------2-----------------------#2017-11-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/8596f1db3340a1eb875182b10a682947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Gt0kLEYJv7BlQ2EB.png"/></div></figure><p id="0bd5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是一个Java <strong class="jt io">字段</strong>的例子:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="61dd" class="ky kz in ku b gy la lb l lc ld"><strong class="ku io">public </strong>String <strong class="ku io">name </strong>= <strong class="ku io">"Marcin"</strong>;</span></pre><p id="6be3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">下面是一个Kotlin <strong class="jt io">属性</strong>的例子:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="b92e" class="ky kz in ku b gy la lb l lc ld"><strong class="ku io">var </strong><em class="le">name</em>: String = <strong class="ku io">"Marcin"</strong></span></pre><p id="5ef9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">两者看起来很像，但这是两个不同的概念。上述Kotlin <strong class="jt io">属性</strong>的直接Java等效项如下:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="77bc" class="ky kz in ku b gy la lb l lc ld"><strong class="ku io">private </strong>String <strong class="ku io">name </strong>= <strong class="ku io">"Marcin"</strong>;</span><span id="252d" class="ky kz in ku b gy lf lb l lc ld"><strong class="ku io">public </strong>String getName() {<br/>    <strong class="ku io">return name</strong>;<br/>}</span><span id="3456" class="ky kz in ku b gy lf lb l lc ld"><strong class="ku io">public void </strong>setName(String name) {<br/>    <strong class="ku io">this</strong>.<strong class="ku io">name </strong>= name;<br/>}</span></pre><p id="e474" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Kotlin <strong class="jt io">属性</strong>的默认实现包括<strong class="jt io">字段</strong>和访问器(getter用于<code class="fe lg lh li ku b">val</code>，getter和setter用于<code class="fe lg lh li ku b">var</code>)。由于这一点，我们总是可以用自定义的访问器来替换默认的实现。例如，如果我们只想接受非空值，那么我们可以定义下面的setter:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="496d" class="ky kz in ku b gy la lb l lc ld"><strong class="ku io">var </strong><em class="le">name</em>: String = <strong class="ku io">"Marcin"<br/>    set</strong>(value) {<br/>        <strong class="ku io">if </strong>(value.<em class="le">isNotBlank</em>())<br/>            <strong class="ku io">field </strong>= value<br/>    }</span><span id="eff3" class="ky kz in ku b gy lf lb l lc ld"><em class="le">name </em>= <strong class="ku io">"Marcin"<br/></strong><em class="le">name </em>= <strong class="ku io">""<br/></strong><em class="le">print</em>(<em class="le">name</em>) <em class="le">// Prints: Marcin</em></span></pre><p id="7fdb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们想确保返回的属性值是大写的，我们可以定义一个自定义的getter来大写它:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="1d07" class="ky kz in ku b gy la lb l lc ld"><strong class="ku io">var </strong><em class="le">name</em>: String = <strong class="ku io">"Marcin"<br/>    get</strong>() = <strong class="ku io">field</strong>.<em class="le">capitalize</em>()</span><span id="ba32" class="ky kz in ku b gy lf lb l lc ld"><em class="le">name </em>= <strong class="ku io">"marcin"<br/></strong><em class="le">print</em>(<em class="le">name</em>) <em class="le">// Prints: Marcin</em></span></pre><p id="9e97" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">关于<strong class="jt io">属性</strong>的关键事实是它们实际上是由它们的访问器定义的。一个<strong class="jt io">属性</strong>根本不需要包含任何字段。当我们定义不使用任何<strong class="jt io">字段</strong>的自定义访问器时，则不会生成<strong class="jt io">字段</strong>:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="f9c6" class="ky kz in ku b gy la lb l lc ld"><strong class="ku io">var </strong><em class="le">name</em>: String<strong class="ku io"><br/>    get</strong>() = <strong class="ku io">"Marcin"</strong></span></pre><p id="06cf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这就是为什么我们可以使用<em class="le">属性委托</em>。请参见下面的属性委托示例:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="0028" class="ky kz in ku b gy la lb l lc ld"><strong class="ku io">var</strong> name: String <strong class="ku io">by</strong> NameDelegate()</span></pre><p id="541b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">上面的代码被编译成以下实现:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="9a96" class="ky kz in ku b gy la lb l lc ld"><strong class="ku io">val</strong> name$delegate = NameDelegate()<br/><strong class="ku io">var</strong> name: String<br/>    get() = name$delegate.getValue(this, this::name)<br/>    set(value) { name$delegate.setValue(this, this::name, value) }</span></pre><p id="3d1c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">此外，虽然属性是由其访问器定义的，但我们可以在接口中指定它:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="4867" class="ky kz in ku b gy la lb l lc ld"><strong class="ku io">interface</strong> Person {<br/>    <strong class="ku io">val</strong> name: String<br/>}</span></pre><p id="21d9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这样的声明意味着在实现接口<code class="fe lg lh li ku b">Person</code>的<a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类</a>中必须定义一个getter。</p><p id="5218" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你可以清楚地看到，Kotlin <strong class="jt io">属性</strong>比Java <strong class="jt io">字段</strong>给了开发者更大的可能性。然而，它们看起来几乎一样，Kotlin属性可以像Java字段一样使用。这是一个很好的例子，Kotlin如何将复杂性隐藏在地毯下，并为我们提供了可能性，即使一些开发人员仍然没有意识到这一点。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><p id="822d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这篇帖子是<a class="ae lj" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-2cb67fff1fe2" rel="noopener">科特林程序员词典</a>的第四部分。要了解最新的新部件，只需关注此媒体或<a class="ae lj" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank">在Twitter上观察我</a>。</p><p id="8dd5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你需要一些帮助，那么请记住<a class="ae lj" href="https://medium.com/@marcinmoskala/ive-just-opened-up-for-online-consultations-640349aaba55" rel="noopener">我愿意接受咨询</a>。</p><p id="43b9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">喜欢的话记得<strong class="jt io">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="kp kq kr ks gt jo gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi lr"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="8d02" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">以下是《科特林程序员词典》的其他部分:</p><ul class=""><li id="f8a1" class="ls lt in jt b ju jv jy jz kc lu kg lv kk lw ko lx ly lz ma bi translated"><a class="ae lj" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">形参vs实参，类型形参vs类型实参</a></li><li id="1953" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0" rel="noopener">语句vs表情</a></li><li id="2a4f" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">函数vs方法vs过程</a></li><li id="b060" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类vs类型vs对象</a></li><li id="4d02" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b">对象表达式vs对象声明</a></li><li id="10a5" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-b085b1620890">接收器</a></li><li id="d78f" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c">隐式接收者vs显式接收者</a></li><li id="1f8e" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277">分机接收机vs调度接收机</a></li><li id="4d7a" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-type-vs-receiver-object-575d2705ddd9">接收方类型与接收方对象</a></li><li id="61b7" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">函数类型vs函数字面vs Lambda表达式vs匿名函数</a></li><li id="0d2f" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-higher-order-function-9cadb07df94e">高阶函数</a></li><li id="42af" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-function-literal-with-receiver-vs-function-type-with-receiver-cc21dba0f4ff">带接收方的函数文字与带接收方的函数类型</a></li><li id="6113" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/kotlin-generics-variance-modifiers-36b82c7caa39">不变性vs协方差vs逆变</a></li><li id="7eed" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-event-listener-vs-event-handler-305c667d0e3c">事件监听器vs事件处理器</a></li><li id="5bbc" class="ls lt in jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-delegation-vs-composition-3025d9e8ae3d">代表团vs组合</a></li></ul><figure class="kp kq kr ks gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>