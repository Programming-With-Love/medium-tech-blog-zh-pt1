<html>
<head>
<title>Protecting infrastructure secrets with Keywhiz</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Keywhiz保护基础设施机密</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/protecting-infrastructure-secrets-with-keywhiz-af674410832f?source=collection_archive---------0-----------------------#2015-04-14">https://medium.com/square-corner-blog/protecting-infrastructure-secrets-with-keywhiz-af674410832f?source=collection_archive---------0-----------------------#2015-04-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="14d2" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">我们新开放的秘密管理和分发服务</h2></div><blockquote class="iw"><p id="d4b0" class="ix iy hh bd iz ja jb jc jd je jf jg dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jh" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="dc60" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc jg ha bi translated"><em class="kd"/><a class="ae jh" href="https://twitter.com/justincummins" rel="noopener ugc nofollow" target="_blank"><em class="kd">贾斯汀</em> </a> <em class="kd">撰写。</em></p><p id="040a" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">在Square，我们的首要任务是安全。我们需要一些东西来保护秘密，特别是当我们采用面向服务的微服务架构时，秘密的数量增加了。虽然保护基础设施的秘密是一种普遍的需要，但是我们无法找到一个合适的秘密管理系统。(更多信息请参见<a class="ae jh" href="https://corner.squareup.com/2015/04/keywhiz.html#existing-practices" rel="noopener ugc nofollow" target="_blank">“现有实践”。)</a>)所以，我们打造了Keywhiz。</p><p id="84ec" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">Keywhiz是一个秘密管理和分发服务，现在每个人都可以使用。Keywhiz帮助我们了解基础设施秘密，包括TLS证书和密钥、GPG密匙环、对称密钥、数据库凭证、API令牌和用于外部服务的SSH密钥——甚至包括一些非秘密，如TLS信任存储。Keywhiz的自动化允许我们无缝地为我们的服务分发和生成必要的秘密，这提供了一个一致和安全的环境，并最终帮助我们更快地发货。</p><h1 id="5f81" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">关于秘密的假设</h1><p id="db84" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc jg ha bi translated">为了更好地理解我们的秘密管理解决方案，阐述我们对系统的要求是有帮助的。</p><ul class=""><li id="7ccf" class="lg lh hh jk b jl ke jo kf jr li jv lj jz lk jg ll lm ln lo bi translated"><em class="kd">秘密内容不应该被广泛访问</em>——无论是在开发系统上还是签入公共GitHub库。</li><li id="9fea" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt jg ll lm ln lo bi translated"><em class="kd">服务需要对秘密的原始访问。</em>我们的观点是服务应该能够访问它们所使用的秘密。例如，内部正方形系统广泛使用TLS。运行web服务器的内部服务应该直接协商TLS，而不是使用众多的代理服务器。直接秘密访问的替代方法是帮助代理代表服务使用秘密——但是为每个用例、平台和语言编写代理既不可行也不简单。</li><li id="d573" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt jg ll lm ln lo bi translated">在一些情况下，我们的服务没有直接的秘密访问权限。例如，认证机构使用硬件安全模块(即为此目的设计的外部硬件)。在这种情况下，Keywhiz仍然向证书颁发机构服务提供使用硬件安全模块所需的秘密。</li><li id="0cb4" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt jg ll lm ln lo bi translated"><em class="kd">集中管理是防止</em><a class="ae jh" href="https://33.media.tumblr.com/tumblr_lgb02mCfLm1qe0eclo1_r5_500.gif" rel="noopener ugc nofollow" target="_blank"><em class="kd"/></a><em class="kd">过多秘密的必要手段</em>微服务架构迅速增加秘密的数量。如果没有一个集中的系统，秘密文件可能会随着时间的推移被放错地方、复制和/或遗忘，这使得这些文件更容易被泄露。一个集中的系统也让我们更容易分析秘密。例如，我们可以监控弱密钥和即将到来的证书过期。</li><li id="bbed" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt jg ll lm ln lo bi translated"><em class="kd">对秘密的访问应该是可审计的。可能有必要追查秘密是何时被谁获取的。秘密管理系统应该提供每次访问的日志，以及在什么上下文中访问了秘密。将机密作为文件放在服务器上不提供审计功能。(<a class="ae jh" href="https://people.redhat.com/sgrubb/audit/" rel="noopener ugc nofollow" target="_blank"> Auditd </a>可以有所帮助，但是需要额外的工程工作。)</em></li><li id="b3d9" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt jg ll lm ln lo bi translated"><em class="kd">系统需要支持多种服务。</em>自成立以来，Keywhiz已经为Square的众多服务和工具提供了秘密。仅举几个例子:Rails、Jetty、Netty、Nginx、GPG、curl和MySQL。</li><li id="bd6f" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt jg ll lm ln lo bi translated"><em class="kd">系统必须可靠。我们最重要的服务离不开它们的秘密。传递机密的系统必须可靠且高度可用。</em></li><li id="7820" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt jg ll lm ln lo bi translated">该系统应该便于消费者使用。管理秘密的系统必须易于使用；否则，人们会被诱惑去寻找捷径。</li><li id="f157" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt jg ll lm ln lo bi translated"><em class="kd">密钥轮换必须与软件部署分离。</em>密钥轮换是加密系统的一项要求，但没有通用的解决方案。例如，一些密钥必须在到期前轮换，这可能不适合软件部署的时间或频率。我们需要将自动密钥轮换从软件部署中分离出来的能力。</li></ul><h1 id="4c2e" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">现有做法</h1><p id="ed70" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc jg ha bi translated">我们发现存储基础设施机密有一些常见的模式，包括在源代码中存储机密、手动部署到服务器以及使用配置管理。</p><p id="b7e8" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">在源代码中存储秘密是一种流行的安全反模式。源代码必须在开发、修订控制、测试和持续集成系统上可访问——这些系统都不是为了安全地存储或分发机密信息而设计的。此外，更新秘密内容不应该与修改代码联系在一起；仅仅转动钥匙不会引起系统变化。</p><p id="d6d9" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">在小范围内，手动将机密部署到服务器是一种合理的方法。然而，如果没有秘密管理系统，这种方法很快就会变得难以处理，因为不可避免地会有更多的秘密在更多的系统中被创建、替换和复制。这种方法容易将秘密留在主目录、临时文件夹和备份副本中。一些秘密不可避免地没有被更新或以不正确的权限存储。审计对秘密的访问或对它们进行全面的推理，就像确定即将到来的证书过期时间一样，变得很困难。如果从加密存储进行部署，可能需要一个主密钥来解密所有内容，或者需要一个复杂的映射来确定应该在哪里部署什么。旧的、放错位置的或不正确擦除的磁盘会导致机密泄露。</p><p id="a4fa" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">基于配置管理系统的秘密管理方案具有与将秘密存储在源代码中和服务器磁盘上相同的缺点。尽管配置管理系统具有能够将秘密变更从代码变更中分离出来的优势，但是它们应该是广泛可见和可复制的，并且保留变更历史——所有这些都与秘密管理相反。许多<a class="ae jh" href="https://docs.ansible.com/playbooks_vault.html" rel="noopener ugc nofollow" target="_blank">项目</a> <a class="ae jh" href="https://puppetlabs.com/blog/encrypt-your-data-using-hiera-eyaml" rel="noopener ugc nofollow" target="_blank">已经</a> <a class="ae jh" href="https://github.com/Nordstrom/chef-vault" rel="noopener ugc nofollow" target="_blank">被</a> <a class="ae jh" href="https://github.com/StackExchange/blackbox" rel="noopener ugc nofollow" target="_blank">制作</a>以在将秘密放入配置管理系统之前对其进行加密，通常使用GPG或自行开发的AES。然后，受信任的个人在部署时输入密钥，明文秘密被部署到服务器磁盘上。决定性地删除一个秘密是困难的(几乎不可能)。配置管理系统中的密钥轮换必须具有对配置进行更改的自主权限，并且有时必须能够访问解密密钥。此外，将秘密管理和配置管理结合起来使得将来很难迁移到另一个系统。</p><h1 id="8cf8" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">键盘高手</h1><p id="4f28" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc jg ha bi translated">Keywhiz系统主要由Keywhiz服务器和一个名为<a class="ae jh" href="https://github.com/square/keywhiz-fs" rel="noopener ugc nofollow" target="_blank"> KeywhizFs </a>的<a class="ae jh" href="http://fuse.sourceforge.net/" rel="noopener ugc nofollow" target="_blank"> FUSE </a>文件系统客户端组成。FUSE使程序能够公开一个虚拟文件系统，而无需在磁盘上实际存储任何东西。Keywhiz服务器的管理是通过web app、CLI或automation REST API来完成的。服务器、KeywhizFs和自动化客户端之间的通信使用TLS的相互身份验证来保护。</p><p id="229c" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">在Keywhiz中，访问控制是根据客户机、组和秘密来定义的。每个验证机密的证书称为客户端。客户端被分配到任意数量的组的成员资格。要允许客户端访问机密，必须至少将机密授予客户端所在的一个组。在实践中，我们为特定服务器上的每项服务创建一个组，为每项服务创建一个组，并为每个人创建一个组。这三组涵盖了大多数用例。</p><p id="2802" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">为了保护存储在服务器端的机密，每个机密在存储到数据库之前都用唯一的密钥进行AES-GCM加密。这个唯一的密钥是使用HKDF生成的。Square使用硬件安全模块来包含派生密钥。</p><p id="26dc" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">服务通过KeywhizFs获取秘密。在Square，每台主机上的每个服务都有一个目录，其中安装了KeywhizFs文件系统。服务只需打开该目录中的一个只读“文件”就可以访问机密。执行目录列表显示哪些秘密是可访问的。本地访问控制很简单；传统的Unix文件权限用于机密“文件”基于文件表示的优势在于<strong class="jk hi">几乎所有的软件都兼容从文件</strong>中读取秘密。</p><p id="2d58" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">KeywhizFs使用UNIX权限来提供本地访问控制和分离。KeywhizFs客户端证书、进程和虚拟目录由一个特殊的KeywhizFs用户拥有，该用户不同于服务使用的用户。假设服务用户没有特权，KeywhizFs挂载点(由KeywhizFs用户拥有)是唯一的接口。为了使服务可以访问机密，KeywhizFs挂载点被分配给服务用户组，并且所有机密都是组可读的。这在大多数情况下是可行的，但是偶尔会有软件包对文件所有权或许可有严格的要求。在这种情况下，额外的元数据与秘密一起存储在keywhizs服务器上，并指示keywhizs提供特殊的所有权或权限。</p><p id="1368" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">KeywhizFs实际上不是将文件复制到远程服务器，而是向KeywhizFs服务器查询信息，并将数据缓存在KeywhizFs进程内存中。在网络中断或Keywhiz服务器故障的情况下，KeywhizFs将继续提供以前访问过的授权机密。机密永远不会写入磁盘，而是缓存在内存中。这是在群集Keywhiz服务器之上的一个额外的安全机制，以确保不会出现根本性的中断。如果服务器关机，则不会有数据保存到磁盘。</p><p id="9fe0" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">KeywhizFs比实际文件有更多的好处。例如，每个秘密访问都会被记录，包括其背后的用户。其他想法——如客户端加密和揭露旧版本的秘密——正在考虑中。</p><h1 id="1176" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">广场部署</h1><p id="6cbd" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc jg ha bi translated">Keywhiz使用许多TLS证书，每个服务器和每个KeywhizFs挂载点一个。这是部署到每台服务器上的每项服务的证书。这假定了一个用于创建可信证书的PKI系统和一个确定软件应该在哪里运行的部署系统。</p><p id="523c" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">公司设计了各种PKI系统——从特殊硬件上的内部认证机构到使用公共认证机构的门户。Keywhiz只需要带有特定公共名称字段的TLS证书，因此它与大多数PKI系统兼容。如果您没有现有的PKI，那么<a class="ae jh" href="https://github.com/square/certstrap" rel="noopener ugc nofollow" target="_blank"> certstrap </a>是一个简单的起点。</p><p id="7fab" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">Square的部署系统对于什么软件在哪里运行是权威的。当一个服务第一次被部署到服务器上时，部署系统将通过Keywhiz的自动化API插入秘密并授权一个新的客户机。我们的证书颁发机构为KeywhizFs生成一个新的证书，编写一个fstab条目，KeywhizFs安装在一个标准目录中，供服务读取。在随后的部署中，一些秘密会自动更新，包括KeywhizFs使用的证书。当服务退役时，相关的访问被移除，机密被删除。</p><p id="3ff5" class="pw-post-body-paragraph ji jj hh jk b jl ke ii jn jo kf il jq jr kg jt ju jv kh jx jy jz ki kb kc jg ha bi translated">Keywhiz对Square非常有用。它支持内部广泛使用的加密技术和动态微服务架构。最初，Keywhiz use将许多配置合并从秘密内容中分离出来，这使得秘密更安全，配置更容易访问。随着时间的推移，改进导致工程师们甚至没有意识到Keywhiz的存在。它只是工作。<a class="ae jh" href="https://square.github.io/keywhiz" rel="noopener ugc nofollow" target="_blank">请检查一下。</a></p></div><div class="ab cl lu lv go lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ha hb hc hd he"><div class="mb mc md me fd mf"><a href="https://twitter.com/justincummins" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hi fi z dy mk ea eb ml ed ef hg bi translated">贾斯汀·卡明斯(@justincummins) |推特</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">贾斯汀·康明斯的最新推文(@justincummins)。信息安全与马戏团。加利福尼亚州旧金山</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">twitter.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt mu mf"/></div></div></a></div></div></div>    
</body>
</html>