<html>
<head>
<title>Understanding Jetpack Compose — part 1 of 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Jetpack撰写—第1部分，共2部分</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/understanding-jetpack-compose-part-1-of-2-ca316fe39050?source=collection_archive---------0-----------------------#2020-08-28">https://medium.com/androiddevelopers/understanding-jetpack-compose-part-1-of-2-ca316fe39050?source=collection_archive---------0-----------------------#2020-08-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f099cac8efcda87a50c6d6276917c55c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*doXBtK__GhkOuJxFIdNecQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="8f4e" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">使用Compose构建更好的UI</h2></div><p id="64b3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对UI开发的期望越来越高。今天，如果没有包括动画和运动在内的经过打磨的用户界面，我们就无法构建一个app并满足用户的需求。这些需求在当前UI工具包创建时并不存在。为了解决快速高效地创建完美UI的技术挑战，我们引入了Jetpack Compose，这是一个现代化的UI工具包，可以帮助应用程序开发人员在这个新领域取得成功。</p><p id="e1f0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在接下来的两篇文章中，我们将解释Compose的好处，并看看它是如何工作的。首先，在这篇文章中，我讨论了Compose解决的挑战，我们一些设计决策背后的原因，以及这些如何帮助应用程序开发人员。此外，我将讨论Compose的心理模型，您应该如何考虑您在Compose中编写的代码，以及您应该如何塑造您的API。</p><h1 id="d576" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">【Compose解决了哪些挑战？</h1><p id="8798" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">关注点分离是一个众所周知的软件设计原则。这是我们作为应用程序开发人员学到的基本知识之一。尽管众所周知，但通常很难掌握这一原则在实践中是否得到遵守。从“耦合”和“内聚”的角度来考虑这个原则可能会有所帮助。</p><p id="1319" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当我们写代码时，我们创建由多个单元组成的模块。<em class="la">耦合</em>是不同模块中单元之间的依赖关系，反映了一个模块的部分影响其他模块的部分的方式。<em class="la">内聚</em>是一个模块中单元之间的关系，它表明模块中单元的分组有多好。</p><p id="86d2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在编写可维护的软件时，我们的目标是<em class="la">最小化耦合</em>和<em class="la">最大化内聚</em>。</p><figure class="lc ld le lf fd hj er es paragraph-image"><div class="er es lb"><img src="../Images/5ac672465a89ffafc6ce02aa42844d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*fW9xf6fwPtxxNOIntoWBeA.png"/></div></figure><p id="d5f3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当我们拥有高度耦合的模块时，在一个地方对代码进行更改意味着必须对其他模块进行许多其他更改。更糟糕的是，耦合经常是隐式的，这样，由于看起来完全不相关的变化，意外的事情就发生了。</p><p id="c135" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">关注点分离是指将尽可能多的相关代码组合在一起，以便我们的代码可以随着应用程序的增长而轻松维护和扩展。</p><p id="62b7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">让我们在今天的Android开发环境中更实际地看待这个问题，并以视图模型和XML布局为例。</p><figure class="lc ld le lf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lg"><img src="../Images/8564df317eebc559e3131604d87a02e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9-wSKwybvM--kRRU"/></div></div></figure><p id="a30a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">视图模型为布局提供数据。事实证明，这里隐藏了很多依赖关系:视图模型和布局之间存在很多耦合。您可以看到这个清单的一个更熟悉的方式是通过API，它需要一些关于XML布局本身的形状和内容的知识，比如<code class="du lh li lj lk b">findViewByID</code>。</p><p id="de2c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">使用这些API需要了解如何定义XML布局，并在两者之间建立耦合。随着我们的应用程序不断增长，我们必须确保这些依赖关系不会过时。</p><p id="d812" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">大多数现代应用程序动态显示用户界面，并在执行过程中不断发展。因此，我们不仅需要静态地验证布局XML是否满足这些依赖关系，还需要验证它们在程序的生命周期中是否也能满足。如果一个元素在运行时离开了视图层次结构，其中一些依赖关系可能会被破坏，并可能导致类似<code class="du lh li lj lk b">NulReferenceExceptions</code>的问题。</p><figure class="lc ld le lf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lg"><img src="../Images/ee83058130478795b75e5317fd363472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KqhjlWMPRossggev"/></div></div></figure><p id="475d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">通常，视图模型是用诸如Kotlin之类的编程语言定义的，而布局是用XML定义的。由于这种语言上的差异，尽管视图模型和布局XML有时可能密切相关，但还是有一条强制的分界线。换句话说，它们耦合得非常紧密。</p><p id="44ab" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这就引出了一个问题:如果我们开始用同一种语言定义UI的布局和结构，会怎么样？如果我们选择科特林呢？</p><figure class="lc ld le lf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lg"><img src="../Images/a0d0e524ff57bd09aa5ebff92f996ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GbpMSwboxEBZNUW_"/></div></div></figure><p id="a53a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因为我们将使用同一种语言工作，一些以前隐含的依赖关系可能开始变得更加明显。我们也可以重构代码，把事情移到减少耦合和增加内聚力的地方。</p><figure class="lc ld le lf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lg"><img src="../Images/88f125f7916e71c0cc5a22048cdd8337.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7_EPL77Xe0OJNEuA"/></div></div></figure><p id="05d8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，你可能认为这是在暗示你把逻辑和UI混合在一起。现实情况是，无论应用程序的结构如何，都有与UI相关的逻辑。框架本身无法改变这一点。</p><p id="1693" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">但是框架所能做的是为你提供工具来使分离更容易:这个工具就是可组合函数。函数是您可能已经使用了很长时间来分隔代码中其他地方的关注点的东西。您已经获得了进行这种类型的重构和编写可靠、可维护、干净的代码的技能——这些技能同样适用于可组合的函数。</p><h1 id="4f66" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated"><strong class="ak">可组合函数的剖析</strong></h1><p id="d294" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">这是一个可组合函数的例子。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="5ac2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这种情况下，它从appData类接收数据作为参数。理想情况下，这些数据是不可变的数据，可组合函数不会改变这些数据:可组合函数应该是这些数据的转换函数。因此，我们可以使用任何Kotlin代码来获取数据，并使用它来描述我们的层次结构，例如<code class="du lh li lj lk b">Header()</code>和<code class="du lh li lj lk b">Body()</code>调用。</p><p id="5136" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这意味着我们调用其他可组合的函数，这些调用代表我们层次结构中的UI。我们能够使用Kotlin动态处理事情的所有语言原语。我们可以在控制流中包含if语句和for循环来处理更复杂的UI逻辑。</p><p id="ee7d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">可组合函数经常使用Kotlin的尾随lambda语法，所以<code class="du lh li lj lk b">Body()</code>是一个可组合函数，它有一个可组合lambda作为参数。这意味着一个层次或结构，所以<code class="du lh li lj lk b">Body()</code>在这里包装了一组项目。</p><h1 id="db32" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated"><strong class="ak">声明式UI </strong></h1><p id="d811" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">声明性是一个时髦的词，但是一个重要的词。当我们谈论声明式编程时，我们是在谈论与<em class="la">命令式</em>编程相反的编程。让我们看一个例子。</p><p id="a375" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">考虑一个带有未读邮件图标的电子邮件应用程序。如果没有消息，应用程序会呈现一个空白信封。如果有一些消息，我们在信封里渲染一些纸，如果有100条消息，我们渲染图标就好像它着火了一样..</p><figure class="lc ld le lf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lg"><img src="../Images/9f375f33a35e4768a27c53cc25b0a700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hO3MFRyY7RNM_jb7"/></div></div></figure><p id="d09e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对于命令式接口，我们可能需要编写一个更新计数函数，如下所示:</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="0eaf" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这段代码中，我们接收新的计数，并且必须弄清楚如何更新当前UI来反映该状态。这里有很多极限情况，这个逻辑并不简单，尽管它是一个相对简单的例子。</p><p id="4b46" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">或者，在声明性接口中编写这个逻辑可能会产生类似下面这样的结果。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="44d3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这里我们说:</p><ul class=""><li id="62c8" class="ln lo hs jj b jk jl jn jo jq lp ju lq jy lr kc ls lt lu lv bi translated">如果数量超过99，就开火。</li><li id="881d" class="ln lo hs jj b jk lw jn lx jq ly ju lz jy ma kc ls lt lu lv bi translated">如果计数超过0，请出示纸张，</li><li id="1d2e" class="ln lo hs jj b jk lw jn lx jq ly ju lz jy ma kc ls lt lu lv bi translated">如果计数超过0，渲染计数徽章。</li></ul><p id="4e8c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这就是声明式API的含义。我们编写的代码描述了我们想要的UI，但没有描述如何转换到那个状态。这里的关键是，当编写这样的声明性代码时，您不再需要担心您的UI以前的状态是什么，您只需要指定您的<em class="la">当前的</em>状态应该是什么。框架控制着如何从一种状态进入另一种状态，所以我们不再需要考虑它。</p><h1 id="e00b" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated"><strong class="ak">构成vs继承</strong></h1><p id="6b6c" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">在软件开发中，组合是多个简单代码单元如何组合在一起形成一个更复杂的代码单元。在面向对象的编程模型中，最常见的组合形式之一是基于类的继承。在Jetpack Compose的世界中，因为我们只使用函数而不是类，所以合成的方法非常不同，但比继承有很多优点。让我们看一个例子。</p><p id="fa4b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">假设我们有一个视图，我们想添加一个输入。在继承模型中，我们的代码可能如下所示:</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="db9a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">视图是基类。<code class="du lh li lj lk b">ValidatedInput</code>使用输入的子类。为了验证日期，DateInput使用了一个子类<code class="du lh li lj lk b">ValidatedInput</code>。但是接下来有一个挑战:我们想要创建一个日期范围输入，这意味着根据两个日期进行验证——开始和结束日期。你可以子类化<code class="du lh li lj lk b">DateInput</code>，但是需要做两次，你不能这样做。这是继承的一个限制:我们必须有一个可以继承的单亲。</p><p id="9e80" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在作曲中，这不是一个挑战。假设我们从基本输入可组合开始:</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="f6e4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当我们创建我们的<code class="du lh li lj lk b">ValidatedInput</code>时，我们只是在函数体中调用<code class="du lh li lj lk b">Input</code>。然后我们可以用一些东西来装饰它，以进行验证。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="112f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">那么对于数据输入，我们可以直接调用<code class="du lh li lj lk b">ValidatedInput</code>。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="dc22" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，当我们遇到日期范围输入时，我们不再有挑战:它只是两个调用而不是一个。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="55ae" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在compose的合成模型中，没有我们合成到的单个父元素，这解决了我们在继承模型中遇到的挑战。</p><p id="413a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">另一种类型的构图问题是抽象一种类型的装饰。为了说明这一点，请考虑下面的继承示例:</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="52cd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du lh li lj lk b">FancyBox </code>是修饰其他视图的视图，在本例中是<code class="du lh li lj lk b">Story</code>和<code class="du lh li lj lk b">EditForm</code>。我们想编码一个<code class="du lh li lj lk b">FancyStory</code>和一个<code class="du lh li lj lk b">FancyEditForm</code>，但是如何编码呢？我们是继承了<code class="du lh li lj lk b">FancyBox</code>还是继承了Story？这还不清楚，因为，同样，我们需要一个继承链的父母。</p><p id="61bb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">相比之下，Compose处理得非常好。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="b597" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们有一个可组合的lambda作为孩子，使我们能够定义包装另一个东西的东西。所以现在，当我们想要创建<code class="du lh li lj lk b">FancyStory</code>时，我们在<code class="du lh li lj lk b">FancyBox</code>的子元素内部调用<code class="du lh li lj lk b">Story</code>，也可以用<code class="du lh li lj lk b">FancyEditForm</code>做同样的事情。这是Compose的合成模型。</p><h1 id="ef80" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated"><strong class="ak">封装</strong></h1><p id="fc06" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">Compose做得好的另一件事是封装。这是您在创建可组合函数的公共API时应该考虑的问题:可组合函数的公共API是它接收的一组参数，因此它不能控制这些参数。另一方面，可组合组件可以管理和创建状态，然后将该状态以及它接收到的任何数据作为参数传递给其他可组合组件。</p><p id="b77e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，因为它正在管理那个状态，所以如果你想改变状态，你可以让你的子组件使用回调来发出改变的信号。</p><h1 id="86e8" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated"><strong class="ak">重组</strong></h1><p id="e66f" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">这是我们的说法，任何可组合的函数都可以在任何时候被重新调用。如果您有一个非常大的可组合层次结构，当层次结构的一部分发生变化时，您不希望重新计算整个层次结构。所以可组合的函数是可重启的，你可以用它来做一些强大的事情。</p><p id="4321" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">例如，这里有一个绑定函数，这是你今天在Android开发中会看到的。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="ea0f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们有一个想要订阅视图的<code class="du lh li lj lk b">LiveData</code>。为此，我们调用带有生命周期所有者的observe方法，然后传入一个lambda。每次<code class="du lh li lj lk b">LiveData</code>更新时，lambda都会被调用，当这种情况发生时，我们希望更新视图。</p><p id="5c77" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">使用Compose，我们可以颠倒这种关系。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="d61e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">有一个类似的Messages Composable，它接收<code class="du lh li lj lk b">LiveData</code>和对Compose的<code class="du lh li lj lk b">observeAsState</code>方法的调用。<code class="du lh li lj lk b">observeAsState</code>方法将把<code class="du lh li lj lk b">LiveData&lt;T&gt;</code>映射到<code class="du lh li lj lk b">State&lt;T&gt;</code>。这意味着你可以在函数体中使用这个值。State实例订阅了<code class="du lh li lj lk b">LiveData</code>实例，这意味着只要<code class="du lh li lj lk b">LiveData</code>更新，它就会更新。这也意味着无论在哪里读取<code class="du lh li lj lk b">State</code>实例，读取它的周围可组合函数将自动订阅这些更改。最终结果是不再需要指定一个<code class="du lh li lj lk b">LifecycleOwner</code>或一个更新回调，因为可组合对象可以隐式地充当两者。</p><h1 id="940a" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated"><strong class="ak">最终想法</strong></h1><p id="6d5a" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">Compose提供了一种定义UI的现代方法，使您能够有效地分离关注点。因为可组合函数与普通的kotlin函数非常相似，所以您用来编写和重构它们的工具将非常适合您的Android开发技能。</p><p id="8acb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在下一篇文章中，我将把重点转移到Compose及其编译器的一些实现细节上。有关Compose的其他资源，请点击此处了解更多<a class="ae mb" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>