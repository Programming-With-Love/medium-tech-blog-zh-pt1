<html>
<head>
<title>Demystifying Kotlin sealed classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘科特林密封类</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/demystifying-kotlin-sealed-classes-e90f52610d78?source=collection_archive---------0-----------------------#2022-12-30">https://blog.kotlin-academy.com/demystifying-kotlin-sealed-classes-e90f52610d78?source=collection_archive---------0-----------------------#2022-12-30</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><figure class="gm go jm jn jo jp gi gj paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gi gj jl"><img src="../Images/b8a0e13da39809e9b04a1def2d5b8761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a4B3XdC4PeG6U8qz"/></div></div><figcaption class="jw jx gk gi gj jy jz bd b be z dk">Photo by <a class="ae ka" href="https://unsplash.com/@mreichelt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marc Reichelt</a> on <a class="ae ka" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e770" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">有时在编程时，我们希望以一种清晰而有用的方式定义一些常量。也许我们也想把他们分组，使他们受到限制。你可能听说过enums。这些都很棒，允许我们拥有常数。像这样:</p><pre class="kz la lb lc gu ld le lf bn lg lh bi"><span id="a40e" class="li lj io le b be lk ll l lm ln">enum class Vehicle() {<br/>    Car,<br/>    Bicycle,<br/>    Truck<br/>}</span></pre><p id="ccac" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">看起来棒极了！</p><p id="fb91" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">但是，如果我们想在车辆枚举中添加更多的信息呢？比如轮子的数量？我们可以这样做:</p><pre class="kz la lb lc gu ld le lf bn lg lh bi"><span id="8e02" class="li lj io le b be lk ll l lm ln">enum class Vehicle(val wheels: Int) {<br/>    Car(wheels = 4),<br/>    Bicycle(wheels = 2),<br/>    Truck(wheels = 4),<br/>}</span></pre><p id="9993" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">现在我们有了一个车轮计数，可以很容易地从enum中获得:</p><pre class="kz la lb lc gu ld le lf bn lg lh bi"><span id="faec" class="li lj io le b be lk ll l lm ln">val wheels = Car.wheels // 4</span></pre><p id="7eed" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">但是您已经可以看到这种方法有一个限制。我们可以定义所有常量对象共有的属性。你可以添加速度、颜色或任何你喜欢的东西。这显然适用于大多数情况，但有时你想给一个对象添加更多的东西。不适用于其他人的东西。然后，您可能还想添加一个特定于对象的函数来处理其中的数据。这将是有用的，对不对？科特林密封类来了:</p><pre class="kz la lb lc gu ld le lf bn lg lh bi"><span id="bff0" class="li lj io le b be lk ll l lm ln">sealed class Vehicle(val wheels: Int) {<br/><br/>    object Car : Vehicle(wheels = 4) {}<br/><br/>    object Bicycle : Vehicle(wheels = 2) {}<br/><br/>    object Truck : Vehicle(wheels = 4) {}<br/><br/>}</span></pre><p id="18f3" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">上面的代码片段直接翻译成带有枚举的示例。但是我们不想要功能相同的东西，我们想要能让我们做更多事情的东西。我们有不同的工具，每一个在现实生活中可以做不同的事情，我们想以某种方式定义它。Enums不允许我们这么做，但是密封类允许。</p><pre class="kz la lb lc gu ld le lf bn lg lh bi"><span id="a2d5" class="li lj io le b be lk ll l lm ln">sealed class Vehicle(val wheels: Int) {<br/><br/>    object Car : Vehicle(wheels = 4) {<br/><br/>        fun getHorseSpeed(): String {<br/>            return "100hp"<br/>        }<br/><br/>    }<br/><br/>    object Bicycle : Vehicle(wheels = 2) {<br/><br/>        fun getType(): Int {<br/>            return 1<br/>        }<br/><br/>    }<br/><br/>    object Truck : Vehicle(wheels = 4) {<br/><br/>        fun getMaxLoad(): Int {<br/>            return 3000<br/>        }<br/><br/>    }<br/><br/>}</span></pre><p id="eaf1" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">你看到了吗？现在我们在不同的类中有不同的函数，这些函数返回不同车辆的信息。整洁！</p><p id="cbc6" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">但是如果我们把这个再扩大一点呢？我们在这里和班级一起工作，对吗？当然啦！假设我们有一个未知的车辆，并希望它几乎像一个未来的模板，所以从扩展。您可以将开放类定义为密封类的一部分。像这样:</p><pre class="kz la lb lc gu ld le lf bn lg lh bi"><span id="ab5f" class="li lj io le b be lk ll l lm ln">sealed class Vehicle(val wheels: Int) {<br/><br/>    object Car : Vehicle(wheels = 4) {<br/><br/>        fun getHorseSpeed(): String {<br/>            return "100hp"<br/>        }<br/><br/>    }<br/><br/>    object Bicycle : Vehicle(wheels = 2) {<br/><br/>        fun getType(): Int {<br/>            return 1<br/>        }<br/><br/>    }<br/><br/>    object Truck : Vehicle(wheels = 4) {<br/><br/>        fun getMaxLoad(): Int {<br/>            return 3000<br/>        }<br/><br/>    }<br/><br/>    open class UnknownVehicle(wheels: Int) : Vehicle(wheels) {}<br/>}</span></pre><p id="1641" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">请记住，你只能在同一个文件中定义子类，并且只能在知道密封类的范围内定义。</p><p id="9116" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">我们可以定义一个抽象函数来强制子类实现它吗？我们当然可以！</p><pre class="kz la lb lc gu ld le lf bn lg lh bi"><span id="f24d" class="li lj io le b be lk ll l lm ln">sealed class Vehicle(val wheels: Int) {<br/><br/>    object Car : Vehicle(wheels = 4) {<br/><br/>        fun getHorseSpeed(): String {<br/>            return "100hp"<br/>        }<br/><br/>        override fun getParkingSpotNumber(): Int {<br/>            return 2<br/>        }<br/>    }<br/><br/>    object Bicycle : Vehicle(wheels = 2) {<br/><br/>        fun getType(): Int {<br/>            return 1<br/>        }<br/><br/>        override fun getParkingSpotNumber(): Int {<br/>            return 5<br/>        }<br/>    }<br/><br/>    object Truck : Vehicle(wheels = 4) {<br/><br/>        fun getMaxLoad(): Int {<br/>            return 3000<br/>        }<br/><br/>        override fun getParkingSpotNumber(): Int {<br/>            return 45<br/>        }<br/>    }<br/><br/>    open class UnknownVehicle(wheels: Int) : Vehicle(wheels) {<br/>        override fun getParkingSpotNumber(): Int? {<br/>            return null<br/>        }<br/>    }<br/><br/>    abstract fun getParkingSpotNumber(): Int?<br/>}</span></pre><p id="186f" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">这里它以一种普通的方式工作，我们有一个抽象函数，就像一个蓝图，它必须在从拥有它的类中扩展的类/对象中实现。</p><p id="9fcd" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">当我们在when语句中使用密封类时，它们的真正魅力就显现出来了。密封类中的每个类型充当一个案例，如果它被定义为一个对象，你甚至不需要使用"<em class="lo"> is" </em>关键字。同样，根据定义，密封类是受限制的，这就是为什么在定义所有情况时可以省略<em class="lo"> else </em>分支。像这样:</p><pre class="kz la lb lc gu ld le lf bn lg lh bi"><span id="9a7a" class="li lj io le b be lk ll l lm ln">fun getParkingSpot(vehicle: Vehicle): Int? {<br/>    return when (vehicle) {<br/>        Vehicle.Bicycle -&gt; vehicle.getParkingSpotNumber()<br/>        Vehicle.Car -&gt; vehicle.getParkingSpotNumber()<br/>        Vehicle.Truck -&gt; vehicle.getParkingSpotNumber()<br/>        is Vehicle.UnknownVehicle -&gt; vehicle.getParkingSpotNumber()<br/>    }<br/>}</span></pre><p id="ee8e" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">使用密封类时要考虑的一些事情:</p><ul class=""><li id="1c40" class="lp lq io kd b ke kf ki kj km lr kq ls ku lt ky lu lv lw lx bi translated">密封类没有公共构造函数，但是它们有私有构造函数</li><li id="d9fd" class="lp lq io kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated">密封类可以有子类，但是这些子类要么嵌套在定义中，要么在同一个文件中</li><li id="1b93" class="lp lq io kd b ke ly ki lz km ma kq mb ku mc ky lu lv lw lx bi translated">密封类不能直接实例化</li></ul><p id="dd94" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated">我希望密封类对你来说比我第一次看到它们时清楚得多。欢迎在评论中提出意见和/或建议。</p><p id="9e78" class="pw-post-body-paragraph kb kc io kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ih bi translated"><em class="lo">节日快乐！</em></p></div><div class="ab cl md me hs mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ih ii ij ik il"><figure class="kz la lb lc gu jp gi gj paragraph-image"><a href="https://kt.academy/article"><div class="gi gj mk"><img src="../Images/d2e94b1350bc466b5f7351da59a2a1eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rUWK29Cak4eFcduVGu06QQ.jpeg"/></div></a></figure></div></div>    
</body>
</html>