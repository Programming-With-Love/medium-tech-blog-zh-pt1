<html>
<head>
<title>The best features of the latest Javascript version since ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自ES6以来最新Javascript版本的最佳特性</h1>
<blockquote>原文：<a href="https://medium.com/duomly-blockchain-online-courses/the-best-features-of-the-latest-javascript-version-since-es6-a46b7138c69a?source=collection_archive---------4-----------------------#2019-07-22">https://medium.com/duomly-blockchain-online-courses/the-best-features-of-the-latest-javascript-version-since-es6-a46b7138c69a?source=collection_archive---------4-----------------------#2019-07-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/9f95effe341cc60bdb0a7eba910fdf48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDc2yXDuTSbM9EXZv5lC4A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming online courses</a></figcaption></figure><p id="fdb2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文最初发布于:<a class="ae it" href="https://www.blog.duomly.com/the-most-useful-features-in-the-latest-javascript-since-es6/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/the-most-used-features-in-the-latest-JavaScript-since-es6/</a></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="6928" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2015年6月，在中断六年后，Javascript有了重大更新，带来了许多新功能。从那时起，我们每年都推出一个新版本，增加了一系列新功能，旨在帮助开发人员，提高我们的工作效率。为了帮助您跟踪Javascript版本，我将列出按版本分组的最有用的特性，并添加一些代码示例以便更好地了解。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h2 id="db1c" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jf kk kl km jj kn ko kp jn kq kr ks kt bi translated">ES6 (ECMAScript 2015)</h2><p id="4cdb" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated"><strong class="iw hi"> 1。箭头功能(= &gt; ) </strong></p><p id="2372" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">箭头函数是函数语法(= &gt;)的简写。它为开发者带来了两个主要的开发工具。首先箭头函数帮助我们避免使用。bind()或其他用于应用适当this的方法，因为arrow函数与其周围的函数共享相同的词法this。使用箭头函数的另一个好处是我们的代码看起来更好，它不像常规函数那样冗长。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e2f8" class="jz ka hh le b fi li lj l lk ll">// traditional function expression<br/>var numbers = [2, 6, 40];<br/>var twiceNum = numbers.map(function(number) { return number*2 })</span><span id="6b0b" class="jz ka hh le b fi lm lj l lk ll">// arrow functional<br/>var numbers = [2, 6, 40];<br/>var twiceNum = numbers.map((number) =&gt; number*2);</span><span id="248c" class="jz ka hh le b fi lm lj l lk ll">// lexical this<br/>var greenBtn = document.getElementById(‘greenBtn’);<br/>greenButton.addEventListener(‘click’, function() {<br/> this.style.backgroundColor = “red”; // no more binding<br/>})</span></pre><p id="a760" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 2。类别</strong></p><p id="9ec5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">尽管面向对象编程很有趣，但类可能是一个非常有用的特性。他们使得基于类模式编写代码变得非常容易。类支持原型继承、构造函数、超级调用以及实例和静态方法。让我们看看现在创建这个类有多容易:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="0ecd" class="jz ka hh le b fi li lj l lk ll">// Class<br/>class Person {<br/> constructor(firstName, lastName, age) {<br/>   this.firstName = firstName;<br/>   this.lastName = lastName;<br/>   this.age = age;<br/> }</span><span id="f2b9" class="jz ka hh le b fi lm lj l lk ll">sayHi() {<br/>   return ‘Hi, my name is ${firstName}. Nice to meet you.’;<br/> }<br/>}</span></pre><p id="4e1a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 3。模板字符串</strong></p><p id="888f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可能在上面的例子中，你意识到我没有使用加号来给字符串添加变量。ES6实现了一个非常有用的特性，叫做模板字符串。它允许我们在不中止变量的情况下，在字符串中实现变量。把变量放在花括号里，在is前面放$ sign就够了。将字符串放入“`”中也很重要。在构造API请求时，这可能非常有用。让我们看一下代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5e5b" class="jz ka hh le b fi li lj l lk ll">var name = ‘Peter’, city = ‘London’;<br/>// Before ES6<br/>var greeting = ‘Hello, my name is ‘ + name + ‘. I am from ‘ + city + ‘.’;</span><span id="a213" class="jz ka hh le b fi lm lj l lk ll">// After ES6 <br/>var greeting = `Hello, my name is ${name}. I’m from ${city}.`</span></pre><p id="a3c5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">聪明又简单，对吧？</p><p id="7d2a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 4。假设和常数</strong></p><p id="6a0d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">ES6实现了两个新的关键字:const和let。两者都是用来声明变量的。Let的工作方式与var非常相似，但是变量有块范围，所以它只在声明的代码块中可用。Const用于声明常数。它的工作方式类似于let，但是您需要在声明const的同时赋值。让我们来看看代码示例:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="8c0c" class="jz ka hh le b fi li lj l lk ll">// Let — variable is available only in the block of code<br/>function calculate(x) {<br/> var y = 0;<br/> if (x &gt; 10) { // let y is only available in this block of code<br/>   let y = 30;<br/>   return y;<br/> }<br/> return y;<br/>}</span></pre><p id="da3f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 5。承诺</strong></p><p id="148e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">ECMAScript 2015 creators还为我们提供了标准化的Promise实现，这非常有用，尽管我们现在经常使用异步编程。我们再也不用担心回调地狱了。承诺总是处于三种状态之一:待定、履行或拒绝。你也有。then()方法在承诺被解析或。catch()方法来检查它被拒绝的原因。让我们看一下代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e0fc" class="jz ka hh le b fi li lj l lk ll">const checkResult = () =&gt; new Promise(resolve, reject) =&gt; {<br/>setTimeout(resolve, 500)} <br/>checkResult()<br/> .then((result) =&gt; { console.log(result); }) <br/> .catch((error) =&gt; { console.log(error); })</span></pre></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h2 id="5a0a" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jf kk kl km jj kn ko kp jn kq kr ks kt bi translated">ES7 (ECMAScript 2016)</h2><p id="71c0" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated"><strong class="iw hi"> 1。Array.prototype.includes </strong></p><p id="d4de" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在ES7中出现了一个新的数组方法。。includes()方法使得检查某个值是否在数组中变得更加容易。以前开发人员使用indexOf，必须创建一个额外的函数来检查这一点，现在我们可以使用。包括()，如果数组有特定的元素，它将返回true，否则返回false。让我们来看一个代码示例:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="8179" class="jz ka hh le b fi li lj l lk ll">var fruits = [‘banana’, ‘apple’, ‘grape’, ‘nut’, ‘orange’];<br/>var favoriteFruit = ‘banana’;</span><span id="6f73" class="jz ka hh le b fi lm lj l lk ll">// Before ES7<br/>function isFruit(fruit) {<br/> if (fruits.indexOf(fruit) !== -1) {<br/>   return true;<br/> } else {<br/>   return false;<br/> }<br/>}<br/>isFruit(favoriteFruit); // returns true</span><span id="bdec" class="jz ka hh le b fi lm lj l lk ll">// After ES7<br/>fruits.includes(favoriteFruit); // returns true</span></pre><p id="d351" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 2。求幂运算符</strong></p><p id="5ebd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这对于从事更高级数学运算、3D、VR或数据可视化的开发人员来说最为重要。以前，这可以通过loop、Math.pow()或递归函数来完成，现在这种方式简单多了。让我们来看看一些代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e3cd" class="jz ka hh le b fi li lj l lk ll">// Before ES7 (loop case) <br/>function calculate(num, exponent) { <br/>   var res = 1; <br/>   for (var i = 0; i &lt; exponent; i++) { <br/>     res *= num; <br/>   } <br/>   return res;<br/>}</span><span id="7dc3" class="jz ka hh le b fi lm lj l lk ll">// After ES7<br/>const calculate = (num, exponent) =&gt; num ** exponent;</span></pre><p id="9304" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">很简单，对吧？</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h2 id="0cbd" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jf kk kl km jj kn ko kp jn kq kr ks kt bi translated">ES8 (ECMAScript 2017)</h2><p id="b4a0" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated"><strong class="iw hi"> 1。Object.values()和Object.entries() </strong></p><p id="e5d5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">ECMAScript2017中实现的Object.values()方法允许我们获取对象的所有值，并将它们作为数组返回。ES8中关于Object的另一个有用的特性是Object.entries()方法。它允许我们获取所有条目，并将它们显示为数组的数组。让我们来看看一些代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5efc" class="jz ka hh le b fi li lj l lk ll">var person = {<br/> name: ‘Jenny’,<br/> age: 24,<br/> country: ‘UK’,<br/> city: ‘London’,<br/>}</span><span id="1cf6" class="jz ka hh le b fi lm lj l lk ll">// Object.values()<br/>var arrJenny = Object.values(person); // returns [‘Jenny’, 24, ‘UK’, ‘London’];</span><span id="77a9" class="jz ka hh le b fi lm lj l lk ll">// Object.entries()<br/>var arrJennyEntries = Object.entries(person); // returns [[‘name’, ‘Jenny’], [‘age’, 24], [‘country’, ‘UK’], [‘city’, ‘London’]];</span></pre><p id="15af" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 2。String.prototype.padEnd()和String.prototype.padStart() </strong></p><p id="9839" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">ES8中也有一些新的字符串。当您的字符串没有足够的长度时，您可以使用其中一种新方法来添加一些字符，直到它达到所需的长度。padEnd()将在字符串的末尾添加选定的字符(默认情况下是空格)，并在开头添加padStart()。让我们来看看它在示例中是如何工作的:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6737" class="jz ka hh le b fi li lj l lk ll">var string = ‘Alice’; <br/>// padStart() — we assume our string needs to have 10 characters <br/>string.padStart(10, ‘o’); // returns ‘oooooAlice’</span><span id="6660" class="jz ka hh le b fi lm lj l lk ll">// padEnd() <br/>string.padEnd(10, ‘o’); // returns ‘Aliceooooo’;</span></pre><p id="3622" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 3。异步功能(异步/等待)</strong></p><p id="e9ef" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在ES8中，creators为我们提供了另一种替代回调和异步编程的方法，那就是async/await函数。异步函数定义了一个异步函数，它返回一个将被解析或拒绝的承诺。还有就是。await()运算符，在异步函数中使用，它等待一个承诺。异步函数为我们提供了更友好的语法。让我们来看看一些代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="39f9" class="jz ka hh le b fi li lj l lk ll">function delayResult() {<br/> return new Promise(resolve =&gt; {<br/>   setTimeout(() =&gt; {<br/>     resolve(‘Done’);<br/>   }, 5000)<br/> })<br/>}</span><span id="07ce" class="jz ka hh le b fi lm lj l lk ll">async function getResult() {<br/> var result = await delayResult();<br/> return result;<br/>}</span><span id="b5af" class="jz ka hh le b fi lm lj l lk ll">getResult();</span></pre></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h2 id="6be3" class="jz ka hh bd kb kc kd ke kf kg kh ki kj jf kk kl km jj kn ko kp jn kq kr ks kt bi translated">ES9 (ECMAScript 2018)</h2><p id="c27f" class="pw-post-body-paragraph iu iv hh iw b ix ku iz ja jb kv jd je jf kw jh ji jj kx jl jm jn ky jp jq jr ha bi translated"><strong class="iw hi"> 1。异步迭代</strong></p><p id="db3a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">随着ES9 creators增加了异步迭代，这意味着您可以通过使用await来声明异步循环。但它可能只在数据来自同步源的情况下使用，所以我们不能从https fetch异步迭代数据。让我们看一下代码示例:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="eeb6" class="jz ka hh le b fi li lj l lk ll">for await (let book of books) { <br/> console.log(book) <br/>};</span></pre><p id="37d1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 2。休息操作员</strong></p><p id="2711" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">ECMAScript2019还为rest操作符带来了新的行为。现在，它可以将对象文本中没有提到的剩余对象键值对复制到操作数中。rest运算符应该用在末尾；否则，会导致错误。此外，也可以在函数中使用它并获得所需的属性。让我们看一个例子来更好地理解它:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6e0e" class="jz ka hh le b fi li lj l lk ll">const fruits = { orange: 1, apple: 10, banana: 4, } <br/>const { orange, …rest } = fruits; <br/>console.log(rest); // { apple: 10, banana: 4 };</span><span id="bf0c" class="jz ka hh le b fi lm lj l lk ll">// in the function<br/>function getFruits(apple, …rest) { <br/> return rest.banana;<br/>}</span></pre><p id="48c9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 3。无极.原型.最终</strong></p><p id="f0cb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">ES9附带的另一个有用的特性是。最后()，对Promise的另一个回调，无论是否。然后()或。catch()被调用。如果你需要在承诺之后采取行动，不管成功与否，这可能是有用的。让我们看一下代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="f5d7" class="jz ka hh le b fi li lj l lk ll">const checkResult = () =&gt; new Promise(resolve, reject) =&gt; {setTimeout(resolve, 500)}</span><span id="cdd1" class="jz ka hh le b fi lm lj l lk ll">checkResult() <br/> .then((result) =&gt; { console.log(result); }) <br/> .catch((error) =&gt; { console.log(error); }) <br/> .finally(() =&gt; { console.log(‘Promise finished!’) })</span></pre><p id="a105" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">结论</strong></p><p id="9937" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">自2015年ES6以来，我们经历了Javascript最有用的更新，而不是每一次。有很多变化你可能今天才知道。请记住，使用它来更新您的编程知识并使您的代码更智能、更短、更干净是非常重要的。另外，加入<a class="ae it" href="https://www.duomly.com/course/javascript-course" rel="noopener ugc nofollow" target="_blank"> Javascript课程</a>来掌握你的知识。</p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/14050edb3dd7375abbe70aa365c6a7a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKddjCbEXWrnBWTZ_25CHw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming online courses</a></figcaption></figure><p id="d5c1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的阅读。</p><p id="16d4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这篇文章是由我们的队友安娜创作的。</p></div></div>    
</body>
</html>