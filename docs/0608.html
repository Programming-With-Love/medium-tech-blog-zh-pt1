<html>
<head>
<title>Android Nesting Intents</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android嵌套意图</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-nesting-intents-e472fafc1933?source=collection_archive---------4-----------------------#2021-02-05">https://medium.com/androiddevelopers/android-nesting-intents-e472fafc1933?source=collection_archive---------4-----------------------#2021-02-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/74154bd75aa48609f3a8dd8281cc2d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*csWzYUmYq_1HQsqBWk3OTA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx">Illustration by <a class="ae iu" href="https://dribbble.com/Molly_Hensley" rel="noopener ugc nofollow" target="_blank">Molly Hensley</a></figcaption></figure><p id="9a69" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">你的应用程序是否提供了一个服务，当某个动作发生时，它会启动另一个应用程序的<code class="du jt ju jv jw b">Activity</code>作为回调？例如，它是否接受一个<code class="du jt ju jv jw b">Intent</code>作为另一个<code class="du jt ju jv jw b">Intent</code>的额外参数，该参数用作一个<code class="du jt ju jv jw b">startActivity()</code>调用的参数？</p><p id="e12e" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">您知道这会让您的应用程序易受攻击吗？</p><p id="6bad" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在这篇文章的其余部分，我将解释使用这种方法的问题，并提供一个解决方案，让您的应用程序更安全地提供相同的功能。</p><h1 id="6b1f" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">问题是</h1><p id="f6f7" class="pw-post-body-paragraph iv iw hh ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">我们期望这种类型的交互的工作方式是这样的:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/787bfbaeb1420f5037b26bb54418dc41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IEWopqfWI0gFMsnk"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><em class="ie">Flowchart showing how an Intent to start a callback activity is added as an extra to an Intent to start a service, which then uses it to start the provided Activity.</em></figcaption></figure><p id="d7df" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在这里，客户端应用程序为其<code class="du jt ju jv jw b">ClientCallbackActivity</code>创建一个<code class="du jt ju jv jw b">Intent</code>，并将其作为额外项添加到<code class="du jt ju jv jw b">Intent</code>中，它将使用该额外项来启动提供者应用程序的<code class="du jt ju jv jw b">ApiService</code>。处理完请求后，提供商应用程序使用客户端应用程序提供的<code class="du jt ju jv jw b">Intent</code>来启动<code class="du jt ju jv jw b">ClientCallbackActivity</code>。</p><p id="111b" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">❗️The这里需要注意的是，提供者应用程序在自己的应用程序<code class="du jt ju jv jw b">Context</code>中调用<code class="du jt ju jv jw b">startActivity()</code>。这有两个后果，都不是最理想的:</p><ul class=""><li id="95b2" class="lf lg hh ix b iy iz jc jd jg lh jk li jo lj js lk ll lm ln bi translated">由于<code class="du jt ju jv jw b">ClientCallbackActivity</code>正由提供商应用程序启动，因此必须将其标记为<code class="du jt ju jv jw b">exported</code>，这不仅允许提供商应用程序启动它，还允许设备上的任何其他应用程序启动它。</li><li id="39fe" class="lf lg hh ix b iy lo jc lp jg lq jk lr jo ls js lk ll lm ln bi translated">传递给ApiService的嵌套的<code class="du jt ju jv jw b">Intent</code>可用于启动任何属于提供商应用程序的<code class="du jt ju jv jw b">Activity</code>。这包括私人的、潜在敏感的、不可出口的活动！</li></ul><p id="67cb" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">为了演示，考虑如果调用应用程序没有为它自己的活动提供一个<code class="du jt ju jv jw b">Intent</code>，即:<code class="du jt ju jv jw b">ClientCallbackActivity</code>，而是放入一个<code class="du jt ju jv jw b">Intent</code>来启动提供者应用程序内的私有活动，会发生什么。</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/d35802c78ad766dc851be673a4779224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iof2-14vTyoDX-h5"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><em class="ie">Flowchart showing how a carefully constructed Intent can be used to start ApiSensitiveActivity in Provider App, even though it isn’t exported and shouldn’t be able to be started by other apps.</em></figcaption></figure><p id="5f9c" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">因为使用了嵌套的<code class="du jt ju jv jw b">Intent</code>，提供商应用很难防范针对私人的、潜在敏感活动的<code class="du jt ju jv jw b">Intent</code>。因为提供者应用程序直接在意向上调用<code class="du jt ju jv jw b">startActivity()</code>，所以即使它没有被导出，它也能够启动<code class="du jt ju jv jw b">ApiSensitiveActivity</code>。</p><h1 id="2d9b" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">解决方案:挂起内容</h1><p id="dd5d" class="pw-post-body-paragraph iv iw hh ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">解决方案很简单:提供商应用程序可以接受一个<code class="du jt ju jv jw b"><a class="ae iu" href="https://developer.android.com/reference/kotlin/android/app/PendingIntent" rel="noopener ugc nofollow" target="_blank">PendingIntent</a></code>，而不是接受一个<code class="du jt ju jv jw b">Intent</code>。</p><p id="5ee8" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">一个<code class="du jt ju jv jw b">Intent</code>和一个<code class="du jt ju jv jw b">PendingIntent</code>的区别在于一个<code class="du jt ju jv jw b">PendingIntent</code>总是用它被创建时的身份来处理:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es la"><img src="../Images/c62474c416570862ad9fedfb29fe3c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J1fPWozrWb-__b7u"/></div></div><figcaption class="iq ir et er es is it bd b be z dx"><em class="ie">Flowchart showing how accepting a PendingIntent is processed as the identity of the app that created it, preventing it from calling non-exported activities in Provider App.</em></figcaption></figure><p id="0d1d" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">因为回调是作为<code class="du jt ju jv jw b">PendingIntent</code>提供的，所以当提供者应用程序对其调用<code class="du jt ju jv jw b">send()</code>时，<code class="du jt ju jv jw b">startActivity()</code>会像攻击者应用程序调用它一样进行，并且由于攻击者应用程序没有启动<code class="du jt ju jv jw b">ApiSensitiveActivity</code>的权限，所以系统会阻止活动启动。</p><p id="43ab" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">这对提供商应用程序来说当然是一个好处，但我们的应用程序，客户端应用程序呢？好吧，既然我们已经提供了一个<code class="du jt ju jv jw b">PendingIntent</code>，那么<code class="du jt ju jv jw b">ClientCallbackActivity</code>现在有可能成为一个私有的、非导出的活动。这一改变让两个应用程序都有了更好的安全性！</p><p id="65e5" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如果你熟悉通知或警报管理器API，你会注意到它们使用<code class="du jt ju jv jw b">PendingIntent</code>来激活动作并向应用发出警报。这就是系统使用<code class="du jt ju jv jw b">PendingIntent</code>的原因，它们是作为创建它们的应用程序来处理的，而不是普通的意图。</p><h1 id="a94e" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">摘要</h1><p id="a7d4" class="pw-post-body-paragraph iv iw hh ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js ha bi translated">使用<code class="du jt ju jv jw b">Intent</code>作为一种机制来实现对<code class="du jt ju jv jw b">Activity</code>的回调会导致提供者和客户端应用程序中的漏洞。这是因为<code class="du jt ju jv jw b">Intents</code>总是在调用它们的应用程序的<code class="du jt ju jv jw b">Context</code>中处理。这个<code class="du jt ju jv jw b">Context</code>提供了在提供者应用程序中启动任何未导出活动的可能性，并强制客户端应用程序导出应该接收回调的活动。</p><p id="86f1" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">相比之下，<code class="du jt ju jv jw b">PendingIntents</code>总是在创建它们的<code class="du jt ju jv jw b">Context</code>中被处理。这不仅允许提供者应用自由地使用它们，而不暴露未导出的活动，而且允许客户端指定任何活动(包括未导出的活动)来接收回调。</p><p id="1dc8" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">了解更多关于Android 12如何帮助保护应用程序免受嵌套意图的不安全启动。</p></div></div>    
</body>
</html>