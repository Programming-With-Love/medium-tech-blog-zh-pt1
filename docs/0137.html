<html>
<head>
<title>Better Android Testing at Airbnb — Part 7: Test Generation and CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Airbnb更好的Android测试——第7部分:测试生成和CI</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/better-android-testing-at-airbnb-eacec3a8a72f?source=collection_archive---------0-----------------------#2020-01-11">https://medium.com/airbnb-engineering/better-android-testing-at-airbnb-eacec3a8a72f?source=collection_archive---------0-----------------------#2020-01-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d695" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们Airbnb Android测试系列的第七部分，也是最后一部分，我们将深入探讨我们的CI设置，并分享我们下一步的发展思路。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/d63a3a110d88e8b52150a62fa5238993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yTTTckVTF2iP5kJmrzLhw.jpeg"/></div></div></figure><p id="fbd7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在以前的文章中，我们已经研究了Airbnb的产品架构，我们为其构建的模拟系统，以及这个生态系统如何使我们能够对我们的功能进行自动化测试。然而，一个值得注意的缺失部分是关于如何以及何时运行这些测试的讨论。</p><p id="8071" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们将看看将我们所有的测试基础设施联系在一起的工具，以及我们如何设计它来为我们的工程师带来愉快的体验。</p><h1 id="ce93" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">生成测试文件</h1><p id="94a0" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">正如本系列前面提到的，我们为片段定义了模拟数据，但是不需要我们的工程师编写普通的测试来测试这些模拟。相反，会生成测试文件。在这里，我们将仔细看看这在实践中意味着什么。</p><p id="1e04" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们使用Kotlin脚本来解析我们的应用程序目录，并提取所有MvRx片段的名称。</p><ul class=""><li id="6d79" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">该脚本利用Kotlin编译器生成每个Kotlin文件的AST，以便更容易检测片段类</li><li id="c2c3" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">通过lint规则，我们对片段实施了命名约定，这使得检测片段类变得更加容易</li><li id="ac81" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">为了简单起见，我们收集了所有片段类的名称。如果一个片段不是MvRx片段，它将在测试运行时被跳过。</li></ul><p id="ff8e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦我们有了片段类名，脚本使用<a class="ae lg" href="https://github.com/square/kotlinpoet" rel="noopener ugc nofollow" target="_blank"> KotlinPoet </a>将一个JUnit测试文件写到我们的测试源目录，在AndroidTest文件夹中，这样一个测试构建将包括那些测试。最终生成的文件如下所示:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="bb1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个测试的名称都是基于片段的完全限定名，每个测试函数只是通过提供一个片段名来开始测试。运行测试的所有代码都存在于基类中，因此不需要包含在生成的文件中。有关这个基类和运行测试的活动的详细信息，请参阅上一篇文章。</p><p id="cbe1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种代码生成方法有几个优点:</p><ul class=""><li id="79a2" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">消除了为每个片段手动创建和维护测试的开销</li><li id="8d68" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">使得将我们的测试工作分割成脚本能够分割的任何块变得很简单——这对于支持测试分片和确保测试的可伸缩性非常重要。一种简单的方法是在不可扩展的单一测试中运行所有的片段</li><li id="ba9a" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">使得添加新的测试类型变得很简单。当我们在截图测试之外添加交互测试时，我们所要做的就是在脚本中添加几行代码，为每个片段生成一个额外的函数</li></ul><p id="1945" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样值得注意的是我们做出的一些设计决策:</p><ul class=""><li id="f7a0" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">因为我们的模拟框架使用定制的DSL，所以脚本检测每个片段的所有模拟变体名称会更加复杂。相反，我们只是收集片段的名称。这意味着每个测试函数必须运行一个片段的所有模拟，而不是能够将每个模拟分割成它自己的测试。这通常是好的，但是对于具有许多模拟变体的片段来说，可能会导致更长的测试时间。为了解决这个问题，我们实现了一个基本的系统，用于将mocks分成不同的组，这个系统被设计成易于通过脚本进行解析。</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><ul class=""><li id="e12f" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">该脚本对每个Kotlin文件的AST表示是有限的——它孤立地查看每个文件，不能遵循引用链。例如，如果一个属性是在另一个文件中定义的，我们就不容易看到它的类型。这意味着脚本需要做出一些可能容易出错的最佳猜测。在理想情况下，我们可以编译和运行整个应用程序，并以编程方式访问我们需要的任何信息——这将允许我们以有保证的方式收集所有MvRx片段和声明的模拟的详细信息(类似于MvRx启动器的工作方式)。然而，这将大大增加流程的复杂性和运行时间，而这两者都是我们努力减少的。实际上，Kotlin脚本方法很好地满足了我们的需求，只需几秒钟就能运行。</li><li id="d83e" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">JUnit支持参数化测试，可以在运行时以编程方式声明这些测试。这几乎是我们生成测试的Kotlin脚本方法的完美替代，然而，参数化测试不能与测试分片一起工作，所以它会妨碍我们轻松扩展测试的能力。</li><li id="7988" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">类似地，一种简单的方法可以用来手动定义对片段进行分组的测试，比如从字母表的每个字母开始对所有片段进行测试。这在某种程度上是可行的，但是也不容易扩展，并且不能在分片之间均匀地分布测试。</li><li id="3f33" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">可以构建一个定制的注释处理系统，其中用在编译时检测到的注释来注释片段，并用于生成测试文件。这种方法的准确性非常好，但是它也有一些缺点:1)需要样板文件来注释每个片段，而不是允许自动检测。2)注释处理器增加了编译时间。3)测试文件不能静态生成，它们依赖于编译</li></ul><p id="401c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个测试生成脚本在我们的CI测试作业开始时运行，因此在我们构建项目之前，测试源文件就存在于项目目录中。有关配置项配置的更多详细信息，请参见下面关于我们的配置项作业的部分。</p><p id="905d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总的来说，我们的脚本方法实现了以下目标:</p><ul class=""><li id="8d6d" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">以可接受的粒度和精确度，以编程方式检测片段及其模拟数据</li><li id="9013" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">支持测试的有效扩展，以及跨测试碎片的测试时间的公平分配</li><li id="6008" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">配置测试运行时，不会给CI作业增加太多时间</li><li id="76d6" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">使我们能够轻松地添加新的测试类型</li><li id="d5eb" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">不会增加项目的复杂性</li><li id="6f84" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">允许开发人员在为片段创建模拟时的最小开销</li><li id="4730" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">使我们能够只在受变更影响的片段上运行测试</li></ul><h1 id="cec8" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">集成测试的CI基础设施</h1><p id="96b3" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我们的测试套件运行在每个Github对我们的应用程序库的Pull请求上。我们使用Buildkite来运行CI，这使得我们可以很容易地为不同的测试类型添加尽可能多的独立管道——例如，单元测试和集成测试在不同的管道作业中运行，因此它们可以并行操作。因为本系列文章关注的是集成测试，所以我们只看一下管道是如何工作的。</p><p id="8e12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在获取我们的应用程序库之后，我们首先运行上面解释的测试生成脚本。这将解析我们的项目以找到应该在测试中使用的片段和模拟，并在我们的androidTest目录中生成一个JUnit测试源文件。之前没有提到的是，这个脚本在测试中包含哪些片段方面也很聪明。</p><h1 id="5f5f" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">检测更改的片段</h1><p id="93a1" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我们的管道将PR分支与它被合并到的分支进行比较，并检查哪些文件已经改变。然后，使用已更改的文件来确定哪些模块受到了更改的影响。我们的测试生成脚本使用这个来排除那些没有被变更影响的模块中的片段，允许我们只对那些行为已经被变更的片段运行变更。这使我们能够更快地运行测试，并节省Firebase成本。</p><p id="faba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果采用这种方法，需要注意一些棘手的事情:</p><ul class=""><li id="1a58" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">必须考虑模块依赖性。如果模块A包含一个被修改的文件，而模块B依赖于模块A，那么我们必须确保模块B也包含在我们的测试中。这需要使用模块依赖图来确定变化。</li><li id="07e5" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">外部依赖关系的改变也会影响模块。如果您更改了正在使用的库的版本，那么依赖于该库的所有模块都应该进行测试。为了简单起见，我们有一个单独的文件，其中声明了我们所有的依赖版本，如果对该文件有任何更改，我们就运行所有的测试。</li></ul><h1 id="58b6" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">处理Firebase停机</h1><p id="56b6" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">此时，我们已经生成了一个带有Espresso入口点的测试文件，用于测试受PR更改影响的片段。下一步是运行命令来构建应用程序apk并测试apk，但是在继续之前，我们要进行健全性检查，以确保Firebase没有关闭。</p><p id="c25f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的集成测试都在Firebase上运行，如果它因为某个事件而宕机，测试可能会失败。这对开发人员的生产力有一些负面影响:</p><ul class=""><li id="a173" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">开发人员对失败的原因和他们应该做什么感到困惑</li><li id="606b" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">对我们团队的大量求助请求</li></ul><p id="880c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不幸的是，Firebase经常不稳定，这对我们来说是一个问题，所以我们有一个自动化的方法来处理它。我们的管道使用<a class="ae lg" href="https://status.firebase.google.com/incidents.json" rel="noopener ugc nofollow" target="_blank">fire base status API</a>来检查Firebase Test Lab正在发生的事件，如果检测到事件，就向PR回发一条评论。该评论包括一个指向该事件的链接以及关于开发人员应该如何处理该事件的说明。</p><h1 id="f651" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">带侧翼的分片</h1><p id="7f90" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">现在，我们已经生成了测试文件，构建了APK，我们已经准备好在Firebase上运行我们的测试了。有了Firebase的gcloud命令行支持，这相当简单，但这将在单个测试矩阵中连续运行所有测试。如果您有许多测试，这可能会花费很长时间，并且随着时间的推移不能很好地扩展。</p><p id="837c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">令人欣慰的是，一个名为<a class="ae lg" href="https://github.com/TestArmada/flank" rel="noopener ugc nofollow" target="_blank"> Flank </a>的伟大开源库可以帮助我们将测试分成碎片，在多个Firebase测试矩阵上并行运行。我们的完整测试套件需要大约两个小时的总测试时间，但是分割后只需要几分钟就可以运行(不包括安装和拆卸时间)。</p><p id="ae23" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Flank的文档相当简单，所以我不会详细介绍我们的设置。我们的管道只是使用一个脚本来生成一个包含我们想要的配置的flank.yml文件，其余的由flank来处理。</p><p id="5930" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">需要注意的一点是，您选择的测试设备会对测试时间产生很大影响。对我们来说，仿真器比物理设备慢很多，所以我们只在物理设备上测试，以减少测试时间。此外，设备类型会极大地影响测试时间。我们最初使用谷歌Pixel进行测试，没有多想。后来对Pixel 3的实验表明，它的运行速度是我们测试的两倍。回想起来，这并不奇怪，但这是一个很好的提醒，提醒你要注意你使用的测试设备。</p><h1 id="7827" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">处理结果</h1><p id="5246" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">一旦测试运行，我们在管道中的最后一个责任是将结果反馈给PR。</p><h2 id="1c58" class="lj jq hh bd jr lk ll lm jv ln lo lp jz ip lq lr kd it ls lt kh ix lu lv kl lw bi translated">失败</h2><p id="5512" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在测试失败时，一种简单的方法是，如果Flank出现任何错误，就让CI作业失败。然而，这使得最终开发人员很难了解失败的原因，然后他们不得不花时间深入CI日志，以找到正确的Firebase测试矩阵的链接——对于分片测试来说，这甚至更困难，因为不一定清楚哪些分片失败了。</p><p id="c097" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">自动化工具在这方面也有帮助，因此我们可以尽可能地减少开发人员的摩擦。我们的管道脚本执行以下操作:</p><ul class=""><li id="9f6f" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">将Flank的所有输出文件作为Buildkite工件上传，以便调试时可以轻松访问它们</li><li id="0d75" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">解析Flank的JUnit报告，收集包含故障的测试矩阵列表</li><li id="b788" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">向PR回帖评论，并提供失败矩阵的链接</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/7ca4b38eaab56880214c7ca4e913a728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*POl1XqUD17jC2mKC"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">A PR comment links to Firebase Test Lab matrices that had test failures</figcaption></figure><p id="86f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这允许开发者直接从PR容易地访问Firebase故障。它还允许我们包含关于开发人员应该如何处理故障以及如何使用Firebase的文档链接，这在我们的贡献者数量持续增长时非常重要。</p><h2 id="91aa" class="lj jq hh bd jr lk ll lm jv ln lo lp jz ip lq lr kd it ls lt kh ix lu lv kl lw bi translated">生成Happo报告</h2><p id="90e2" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">以前的文章深入讨论了我们使用Happo为截图和交互细节生成diff报告。这个Happo集成是作为我们CI工作的最后一个步骤完成的——脚本将测试中刚刚生成的Happo报告与主分支上的最新报告进行比较。如果有任何差异，我们会将评论和详细信息发回给PR。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mc"><img src="../Images/03a68d06f460706a40530cd837dc6bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HsOWG6dyAaBtLe6i"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx">A Happo PR comment calls out visual changes that were detected</figcaption></figure><p id="884a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">开发人员必须按照链接来检查diff结果，并在合并PR之前确认这些更改是有意的(有关这种批准测试方法的更多详细信息，请参见本系列的前几篇文章)。</p><p id="ee71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">值得一提的是，Happo可以很好地处理分片测试。每个碎片上传自己的报告，Happo将所有这些部分报告合并成一个代表所有碎片的最终报告。然而，一个复杂的问题是，当我们的测试只包括受变更影响的片段时，最终的报告将是不完整的。测试中不包括未更改的片段，因此Happo报告中没有这些片段，最终的diff会显示它们已被删除。</p><p id="f723" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们这里的解决方案是一个脚本，它从master获取最新的Happo报告，并使用未更改片段的列表将这些屏幕的详细信息复制到新报告中。这样做很好，但是有一个问题:我们必须确保主报告已经完全创建。如果PR最近被重新调整，那么为最近提交生成新的主报告的CI作业可能仍在运行，为了避免这种竞争情况，我们将这一步留到最后。</p><h2 id="60ac" class="lj jq hh bd jr lk ll lm jv ln lo lp jz ip lq lr kd it ls lt kh ix lu lv kl lw bi translated">代码覆盖率报告</h2><p id="5e16" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">集成测试管道的最后一个职责是提取代码覆盖数据，并为PR计算代码覆盖报告。我们使用标准的Jacoco工具，它可以直接与Flank和Firebase集成。然而，由于我们在单独的管道中运行集成测试和单元测试，并且需要组合这些报告来获得绝对的覆盖数据，所以出现了一些复杂性。</p><p id="7151" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一份覆盖报告被发回给PR，以提高开发人员的意识。我们仍然处于构建代码覆盖工具的早期阶段，并希望随着时间的推移改进我们的功能。</p><h2 id="c82a" class="lj jq hh bd jr lk ll lm jv ln lo lp jz ip lq lr kd it ls lt kh ix lu lv kl lw bi translated">公关评论</h2><p id="505b" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我在几个地方提到过，我们的CI渠道将评论反馈给PR，以便向开发人员清楚地展示信息。这是通过我们构建的一个工具来完成的，这个工具可以让任何管道通过一个简单的API来发布评论。如果我们想要改变注释的内容，它处理更新注释，或者如果注释不再适用，它处理删除注释，这两者在推送新的提交和重新运行作业时都很重要。</p><p id="52b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个工具建立在Github的API之上，用来创建和删除评论，并抽象出需要直接使用那个API的细节。此外，Github没有提供一个简单的方法来更新评论，所以当我们想要“更新”它时，我们需要删除以前的评论并添加一个新的。为此，我们的工具要求每条消息都与一个字符串键相关联，并且它将Github注释id与AWS数据库中的这个字符串键相关联。这样，它可以查找该键可能已经存在的注释，并获得删除它所需的id。</p><p id="72f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个管理评论的工具对我们非常有帮助。它使我们的CI管道以一种清晰的方式向用户呈现信息变得简单，同时降低了管道本身的复杂性。</p><h1 id="58fb" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结束语</h1><p id="79c4" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">到现在为止，希望你已经很好地理解了我们测试Android代码的哲学，以及我们如何构建系统来使测试更容易和更全面。这些系统中的大多数都是在过去的一年中构建的，虽然我们对自己的进展非常满意，但我们始终关注着下一步。</p><h2 id="0c69" class="lj jq hh bd jr lk ll lm jv ln lo lp jz ip lq lr kd it ls lt kh ix lu lv kl lw bi translated">未来的改进</h2><p id="1633" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我们现有的测试套件覆盖了很高比例的代码路径，但并不完美。我们正在计划改进它可以测试的用例的方法。幸运的是，我们的模拟架构使得在其上构建新的测试系统变得容易。</p><p id="6b8a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们想探索的一些领域是:</p><ul class=""><li id="ce42" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">深度链接处理的自动化测试</li><li id="0f2a" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">贯穿多个屏幕并触及生产API的端到端测试</li><li id="50e1" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">支持利用模拟框架的手动定制Espresso测试</li><li id="c23f" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">通过新的<a class="ae lg" href="https://developer.android.com/jetpack/androidx/releases/benchmark" rel="noopener ugc nofollow" target="_blank"> Jetpack基准库</a>实现自动化性能基准测试</li><li id="f4c2" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">对测试其他公共代码路径的自动化支持，例如EditText输入和onActivityResult实现</li><li id="c176" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">测试优化的构建(R8/Proguard ),以捕捉只在生产中出现的问题</li></ul><h2 id="54bd" class="lj jq hh bd jr lk ll lm jv ln lo lp jz ip lq lr kd it ls lt kh ix lu lv kl lw bi translated">开源计划</h2><p id="8c9f" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我们为我们所做的测试工作感到自豪，并很高兴与大家分享！它被设计成与MvRx集成，因此是对开源库的自然扩展。我们正在发布这些测试框架，作为对MvRx ( <a class="ae lg" href="https://github.com/airbnb/MvRx/releases/tag/2.0.0-alpha1" rel="noopener ugc nofollow" target="_blank">从2.0.0 alpha版本</a>开始)的补充，并期待来自社区的反馈和贡献。</p><h2 id="46fa" class="lj jq hh bd jr lk ll lm jv ln lo lp jz ip lq lr kd it ls lt kh ix lu lv kl lw bi translated">系列索引</h2><p id="18cd" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">这是关于Airbnb测试的七篇系列文章。</p><p id="c733" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一部分— <a class="ae lg" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-3f5b90b9c40a">测试哲学和模拟系统</a></p><p id="f371" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第2部分— <a class="ae lg" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-a77ac9531cab">使用MvRx和Happo进行截图测试</a></p><p id="8464" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第3部分— <a class="ae lg" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-1d1e91e489b4">自动化交互测试</a></p><p id="2a4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第4部分— <a class="ae lg" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-part-4-testing-viewmodels-550d929126c8">单元测试框架视图模型</a></p><p id="0572" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第5部分— <a class="ae lg" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b">我们自动化测试框架的架构</a></p><p id="2343" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第6部分— <a class="ae lg" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-a11f6832773f">一致嘲讽的障碍</a></p><p id="461f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第7部分(本文)</strong> — <a class="ae lg" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-eacec3a8a72f">测试生成和CI配置</a></p><h2 id="827a" class="lj jq hh bd jr lk ll lm jv ln lo lp jz ip lq lr kd it ls lt kh ix lu lv kl lw bi translated">我们在招人！</h2><p id="8c88" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">想和我们一起在这些和其他大规模的Android项目上合作吗？Airbnb正在全公司招聘几个Android工程师职位！有关当前空缺，请参见<a class="ae lg" href="https://careers.airbnb.com/" rel="noopener ugc nofollow" target="_blank">https://careers.airbnb.com</a>。</p></div></div>    
</body>
</html>