<html>
<head>
<title>Lets build a Command line app in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们在Swift中构建一个命令行应用程序</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/lets-build-a-command-line-app-in-swift-328ce274f1cc?source=collection_archive---------0-----------------------#2018-01-11">https://medium.com/quick-code/lets-build-a-command-line-app-in-swift-328ce274f1cc?source=collection_archive---------0-----------------------#2018-01-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/14f2bd5c0afebea96a0e0e2e21f297bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrlifOiMRjhMoJzVQcUZMQ.jpeg"/></div></div></figure><p id="7e2d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着swift的开源和服务器端swift获得越来越多的关注，使用Swift构建的命令行应用程序对于服务器端应用程序来说非常强大。已经有一些库可以帮助构建有用的命令行应用程序，今天我们将探索几个库并构建一个简单的命令行应用程序。</p><p id="bdbc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将构建一个命令行工具来对特定类型的文件进行分组，并将它们移动到子目录中。例如，将文件夹中的所有png文件移动到该文件夹中的子目录中。我们将在GitHub   <em class="jo">上探索来自<a class="ae jn" href="https://github.com/vsouza/awesome-ios#command-line" rel="noopener ugc nofollow" target="_blank"> <em class="jo"> awesomeiOS列表的三个包。</em></a></em></p><h1 id="98b2" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">正在设置事物…</h1><ol class=""><li id="7689" class="kn ko hh ir b is kp iw kq ja kr je ks ji kt jm ku kv kw kx bi translated">确保您安装了最新版本的Swift(4 ),并且您可以使用如下所示的命令<code class="du ky kz la lb b">swift --version</code>来检查它。</li></ol><pre class="lc ld le lf fd lg lb lh li aw lj bi"><span id="3bbb" class="lk jq hh lb b fi ll lm l ln lo">mac:~ username$ swift --version</span><span id="7327" class="lk jq hh lb b fi lp lm l ln lo">Apple Swift version 4.0.3 (swiftlang-900.0.74.1 clang-900.0.39.2)</span><span id="5620" class="lk jq hh lb b fi lp lm l ln lo">Target: x86_64-apple-macosx10.9</span></pre><p id="8910" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.现在我们需要使用命令<code class="du ky kz la lb b">swift package init --type executable</code>建立一个基本的包结构。请注意，该命令将创建一个与当前工作目录同名的包。如图1所示，该命令创建了一个目录结构。</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/45d00e2906cb09329ecea65c51d64982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8CX1eSQHg7onuQKDI6rUmQ.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx">Fig 1. Creating a new Package</figcaption></figure><p id="d19c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">其中一个创建的文件是<strong class="ir hi"><em class="jo">package . swift</em></strong>，它包含了包的3个重要方面</p><ul class=""><li id="83ca" class="kn ko hh ir b is it iw ix ja lv je lw ji lx jm ly kv kw kx bi translated"><strong class="ir hi"> <em class="jo">产品</em> </strong>:作为软件包最终产品的可执行文件和库</li><li id="c321" class="kn ko hh ir b is lz iw ma ja mb je mc ji md jm ly kv kw kx bi translated"><strong class="ir hi"> <em class="jo">依赖:</em> </strong>我们将在这个包中使用的所有其他库</li><li id="11dd" class="kn ko hh ir b is lz iw ma ja mb je mc ji md jm ly kv kw kx bi translated"><strong class="ir hi"> <em class="jo">目标:</em> </strong>这些是测试套件或者主模块之类的包的基本块，可以相互依赖。像测试套件指的是主要的源模块。</li></ul><p id="64c3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">转到源文件，Swift在源文件中有一个简单的hello world样板代码。一看<code class="du ky kz la lb b">main.swift</code>如下图</p><pre class="lc ld le lf fd lg lb lh li aw lj bi"><span id="58bf" class="lk jq hh lb b fi ll lm l ln lo">print("Hello, world!")</span></pre><p id="55e3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在可以构建包并确保没有问题。<code class="du ky kz la lb b">swift build </code>命令将编译所有模块，并处理Package.swift文件中的依赖关系。</p><pre class="lc ld le lf fd lg lb lh li aw lj bi"><span id="4c34" class="lk jq hh lb b fi ll lm l ln lo">mac:FileOrganizer sandeepjoshi$ swift build<br/>Compile Swift Module 'FileOrganizer' (1 sources)<br/>Linking ./.build/x86_64-apple-macosx10.10/debug/FileOrganizer</span></pre><p id="8511" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，在调试目录中运行可执行文件FileOrganizer应该会打印Hello World</p><pre class="lc ld le lf fd lg lb lh li aw lj bi"><span id="a1ef" class="lk jq hh lb b fi ll lm l ln lo">mac:FileOrganizer sandeepjoshi$ .build/debug/FileOrganizer<br/>Hello, world!</span></pre><p id="4665" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Swift初学者将从<a class="ae jn" href="https://blog.coursesity.com/best-swift-tutorials/" rel="noopener ugc nofollow" target="_blank">最佳Swift教程</a>中受益匪浅。现在我们有了基本的包设置，让我们使用一些库并构建工具。</p><h1 id="4386" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">添加依赖关系</h1><p id="08aa" class="pw-post-body-paragraph ip iq hh ir b is kp iu iv iw kq iy iz ja me jc jd je mf jg jh ji mg jk jl jm ha bi translated">对于这个项目，我们将使用GitHub   <em class="jo">上的<a class="ae jn" href="https://github.com/vsouza/awesome-ios#command-line" rel="noopener ugc nofollow" target="_blank"> <em class="jo"> awesomeiOS列表中的三个命令行库/包。</em>要添加一个包，我们需要编辑清单文件<strong class="ir hi"><em class="jo">package . swift</em></strong>，如图2所示，然后<code class="du ky kz la lb b">swift build</code>命令将获取、克隆并解析添加的包，如图3所示。</a></em></p><p id="3c19" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编辑<strong class="ir hi"><em class="jo">package . swift</em></strong>文件，如下图</p><figure class="lc ld le lf fd ii"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="lr ls et er es lt lu bd b be z dx">Package.swift file</figcaption></figure><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mj"><img src="../Images/9ff41003a4179508b7c527e61b8e24d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g48xDwhthTZcWzS6ac-viA.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx">Fig 2. Adding packages to manifest file</figcaption></figure><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/43c890c7e469888ad7f39b2fe2a2622d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-uNvnL-jp9V2Tu1xnsDVEQ.png"/></div></div><figcaption class="lr ls et er es lt lu bd b be z dx">Fig 3. Downloading all the packages</figcaption></figure><blockquote class="ml mm mn"><p id="bdae" class="ip iq jo ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>在<strong class="ir hi"><em class="hh">package . swift</em></strong>中添加一个包对于<strong class="ir hi"> <em class="hh"> </em> </strong>旧版swift的语法略有不同，这将不起作用。</p></blockquote><h1 id="eb76" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">构建工具</h1><p id="d219" class="pw-post-body-paragraph ip iq hh ir b is kp iu iv iw kq iy iz ja me jc jd je mf jg jh ji mg jk jl jm ha bi translated">包CommandLineKit用作基本包来创建命令，并带有以字符串形式获取输入的选项。以下代码将目录路径作为指定选项的输入</p><pre class="lc ld le lf fd lg lb lh li aw lj bi"><span id="2b59" class="lk jq hh lb b fi ll lm l ln lo">import Foundation<br/>import Swiftline<br/>import ColorizeSwift<br/>import CommandLineKit</span><span id="0b51" class="lk jq hh lb b fi lp lm l ln lo">let cli = CommandLineKit.CommandLine()<br/>let dirPath = StringOption(shortFlag: “t”, longFlag: “filetypes”, helpMessage: “List all the types of files in current directory”)</span><span id="fda4" class="lk jq hh lb b fi lp lm l ln lo">cli.addOptions(dirPath)</span><span id="c40c" class="lk jq hh lb b fi lp lm l ln lo">do {<br/>  try cli.parse()<br/>} catch {<br/>  cli.printUsage(error)<br/>}</span><span id="dc40" class="lk jq hh lb b fi lp lm l ln lo">print(dirPath.value!)</span></pre><p id="14df" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们构建并运行这段代码，您应该会得到类似下面这样的输出。</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mr"><img src="../Images/f26443ec90c9f3d46981703533ab8fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yap8thN0mqRJxOgc0ZFADw.png"/></div></div></figure><p id="c01a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此<strong class="ir hi"> CommandLineKit </strong>包给出了一个类<strong class="ir hi"> <em class="jo"> Commandline </em> </strong>，它类似于任何bash命令，并且<strong class="ir hi"><em class="jo">string option</em></strong><em class="jo"/>的一个实例类似于一个典型命令的选项。所以我们实例化字符串选项，并将其添加到<strong class="ir hi"> <em class="jo">命令行</em> </strong>实例的选项列表中。</p><p id="c195" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们在该目录中查找所有可用的文件类型。我们将使用<code class="du ky kz la lb b">FileManager</code>来获取目录中所有文件的fileUrls并获取文件的扩展名。最后，创建一个数组来存储唯一的文件类型/扩展名。下面的代码就是这样做的。从上面的代码中删除print语句，然后粘贴下面的代码。</p><pre class="lc ld le lf fd lg lb lh li aw lj bi"><span id="f663" class="lk jq hh lb b fi ll lm l ln lo">var extensions = [String]() // Array to hold types of files present in the given directory<br/>let fileManager = FileManager.default<br/>let dirURL = URL(fileURLWithPath: dirPath.value!)<br/>do {<br/>   // fileURLs contains urls of all the files in the given directory<br/>   let fileURLs = try fileManager.contentsOfDirectory(at: dirURL,       includingPropertiesForKeys: nil)</span><span id="3b12" class="lk jq hh lb b fi lp lm l ln lo">  // Getting the unique file types<br/>  for file in fileURLs {<br/>     if !extensions.contains(file.pathExtension) {<br/>        extensions.append(file.pathExtension)<br/>     }<br/>  }<br/> // To remove a empty string at the begining<br/> extensions.remove(at: 0) <br/><br/> print(“\n”)<br/> print(“Found \(extensions.count) types of files:”.bold().blue())<br/> print(“\n”)<br/> print(extensions.joined(separator: “ “).bold())<br/>} catch {<br/>     print("Error while enumerating files \(error.localizedDescription)")<br/> }</span></pre><p id="1858" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">构建和运行代码后，现在应该会产生类似于下面的输出——</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mr"><img src="../Images/fd735132382f954a2c36c21ae0825ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yjOJkVjRUxp8-X5i1KMLw.png"/></div></div></figure><p id="9850" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在使用<strong class="ir hi"> SwiftLine </strong>包，我们可以询问用户应该将哪种类型的文件分组并移动到子文件夹中。<code class="du ky kz la lb b">ask</code>是SwiftLine提供的一种方法，它给出提示并接受输入的字符串。</p><pre class="lc ld le lf fd lg lb lh li aw lj bi"><span id="2c8a" class="lk jq hh lb b fi ll lm l ln lo">let fileType = ask(“Choose the file type to be grouped into a folder…”.bold().green())</span></pre><p id="2131" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">再次使用SwiftLine的另一种方法<code class="du ky kz la lb b">agree</code>，我们可以确认用户是否真的想要对输入类型的文件进行分组。</p><pre class="lc ld le lf fd lg lb lh li aw lj bi"><span id="0425" class="lk jq hh lb b fi ll lm l ln lo">let choice = agree(“Are you sure you want to group files of type: \(fileType)?”.bold().white().onRed())</span></pre><p id="957e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们只需检查用户的选择，并向用户询问子目录的名称，然后将该类型的文件移动到新创建的子目录中。综合以上两个代码片段，下面是打印文件类型/扩展名后需要添加的代码。</p><pre class="lc ld le lf fd lg lb lh li aw lj bi"><span id="c1e7" class="lk jq hh lb b fi ll lm l ln lo">.<br/>.<br/>print(extensions.joined(separator: “ “).bold())</span><span id="a4bb" class="lk jq hh lb b fi lp lm l ln lo">let fileType = ask("Choose the file type to be grouped into a folder...".bold().green())<br/>    print("\n")<br/>    let choice = agree("Are you sure you want to group files of type: \(fileType)?".bold().white().onRed())<br/>    if(choice == true) {<br/>      print("\n")<br/>      let dirName = ask("Choose the folder name to store files of type: \(fileType)".bold().blue())<br/>      print("\n")<br/>      print("Grouping files by chosen filetype".bold().green())<br/>      let baseDirPath = dirPath.value!<br/>      let newDirPath = baseDirPath + dirName + "/"<br/>      let _ = run("mkdir" ,args: newDirPath)</span><span id="f5ca" class="lk jq hh lb b fi lp lm l ln lo">var noOfFilesMoved = 0<br/>      for file in fileURLs {<br/>        if (file.pathExtension == fileType) {<br/>          do {<br/>              try fileManager.moveItem(atPath:file.path, toPath: newDirPath+file.lastPathComponent)<br/>              noOfFilesMoved = noOfFilesMoved + 1<br/>              }<br/>              catch let error as NSError {<br/>              print("Ooops! Couldn't move the file: \(file.lastPathComponent) because of error: \(error)")<br/>              }<br/>          }<br/>      }<br/>      print("\n")<br/>      print("Successfully moved \(noOfFilesMoved) no of files!".underline().bold().green())</span><span id="121d" class="lk jq hh lb b fi lp lm l ln lo">}</span></pre><p id="00c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">完整的<strong class="ir hi"> <em class="jo"> main.swift </em> </strong>是这样的——</p><figure class="lc ld le lf fd ii"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="e77e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在构建和运行它之后，输出应该类似于下面这样..</p><pre class="lc ld le lf fd lg lb lh li aw lj bi"><span id="c84f" class="lk jq hh lb b fi ll lm l ln lo">mac:FileOrganizer sandeepjoshi$ swift build<br/>Compile Swift Module ‘FileOrganizer’ (1 sources)<br/>Linking ./.build/x86_64-apple-macosx10.10/debug/FileOrganizer</span></pre><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mj"><img src="../Images/cb9835fe67cc57c995a400a15604e325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GxeGobpcnrgog2jUs5dDiw.png"/></div></div></figure><blockquote class="ml mm mn"><p id="684a" class="ip iq jo ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>如你所见，提示和输出是有风格的。我已经使用了<strong class="ir hi"> <em class="hh"> ColorizeSwift </em> </strong>包来设计字符串的样式，这非常简单明了，就像在字符串上调用方法一样简单。有关这方面的更多信息，请查看下面的参考资料。</p></blockquote><p id="111a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">显然，这个工具还可以有大量的改进。这应该是在Swift中构建命令行应用程序的良好起点。</p><p id="a751" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">资源:</strong></p><ul class=""><li id="974c" class="kn ko hh ir b is it iw ix ja lv je lw ji lx jm ly kv kw kx bi translated"><a class="ae jn" href="https://swift.org/getting-started/#using-the-package-manager" rel="noopener ugc nofollow" target="_blank"> <em class="jo">关于在Swift.org上安装&amp;调试Swift和使用Swift pm</em></a><em class="jo"/><strong class="ir hi">的更多信息</strong></li><li id="7a46" class="kn ko hh ir b is lz iw ma ja mb je mc ji md jm ly kv kw kx bi translated"><a class="ae jn" href="https://github.com/jatoben/CommandLine" rel="noopener ugc nofollow" target="_blank"> <em class="jo">命令行工具包</em> </a></li><li id="f846" class="kn ko hh ir b is lz iw ma ja mb je mc ji md jm ly kv kw kx bi translated"><a class="ae jn" href="https://github.com/nsomar/Swiftline" rel="noopener ugc nofollow" target="_blank"> <em class="jo"> SwiftLine包</em> </a></li><li id="dac8" class="kn ko hh ir b is lz iw ma ja mb je mc ji md jm ly kv kw kx bi translated"><a class="ae jn" href="https://github.com/mtynior/ColorizeSwift" rel="noopener ugc nofollow" target="_blank"> <em class="jo">彩色Swift包</em> </a></li></ul></div><div class="ab cl ms mt go mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ha hb hc hd he"><figure class="lc ld le lf fd ii"><div class="bz dy l di"><div class="mz mi l"/></div></figure><p id="c93d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">请点击👏按钮下面几下，以示支持！⬇⬇谢谢！不要忘记遵循下面的快速代码。</strong></p><blockquote class="na"><p id="c11c" class="nb nc hh bd nd ne nf ng nh ni nj jm dx translated">在<a class="ae jn" href="http://www.quickcode.co/" rel="noopener ugc nofollow" target="_blank">快速代码</a>上找到各种编程语言的免费课程。获取<a class="ae jn" href="https://www.messenger.com/t/1493528657352302" rel="noopener ugc nofollow" target="_blank"> Messenger </a>的新更新。</p></blockquote></div></div>    
</body>
</html>