<html>
<head>
<title>Fragment Transitions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">片段转换</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/fragment-transitions-ea2726c3f36f?source=collection_archive---------1-----------------------#2018-02-18">https://medium.com/androiddevelopers/fragment-transitions-ea2726c3f36f?source=collection_archive---------1-----------------------#2018-02-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="2e5c" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">让他们工作</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/723201cf1bc384e55827018ed799db03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XwZ9uL5BAY5qovrhIjBTuA.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx"><a class="ae jm" href="https://flic.kr/p/dmmUwS" rel="noopener ugc nofollow" target="_blank">Natures Glory</a> by Dirkus</figcaption></figure><p id="d1f8" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这是我探索如何让片段很好地过渡的一个小系列的第一篇文章。这篇文章就是要让他们跑起来。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="1d94" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">几个月前，我展示了我正在开发的名为Tivi的应用程序的网格到网格的转换。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="8e3b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">然而，在我设法做到这一点之前，我一直在为工作做任何过渡。在应用程序中，我对非边界变化使用片段变化，所以像扩展数据集和底部导航事件这样的事情。当数据类型发生重大变化时(例如，深入到单个项目的细节)，我开始一项活动。</p><p id="ed64" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">你在上面看到的变化是一个片段替换。片段A是概览屏幕，然后当用户点击“更多”按钮时，它被片段B替换，片段B包含项目的完整网格。</p><p id="ab18" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我现有的片段事务代码如下所示:</p><pre class="ix iy iz ja fd kt ku kv kw aw kx bi"><span id="150f" class="ky kz hh ku b fi la lb l lc ld">supportFragmentManager.beginTransaction()<br/>    .replace(R.id.home_content, fragment)<br/>    .addToBackStack(tag)<br/>    .commit()</span></pre><p id="69c1" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">还没什么令人兴奋的。</p><p id="ac15" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">所以我查阅了转换API并添加了一些共享元素。在这种情况下，共享元素是包含海报的正方形图像:</p><pre class="ix iy iz ja fd kt ku kv kw aw kx bi"><span id="67fe" class="ky kz hh ku b fi la lb l lc ld">supportFragmentManager.beginTransaction() <br/>    .replace(R.id.home_content, fragment)<br/>    .addToBackStack(tag)<br/>    .apply {<br/>      for (view in sharedElementViews) {<br/>        <strong class="ku hi">addSharedElement(view)</strong><br/>      }<br/>    }<br/>    .commit()</span></pre><p id="d99e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">然后我在进入的片段(片段B)上设置了一个共享元素转换。在这种情况下，我使用了一个<a class="ae jm" href="https://developer.android.com/reference/android/support/transition/ChangeBounds.html" rel="noopener ugc nofollow" target="_blank"> ChangedBounds </a>来开始，因为视图刚刚从点a移动到➡️ B，并且改变了大小。</p><pre class="ix iy iz ja fd kt ku kv kw aw kx bi"><span id="ebc9" class="ky kz hh ku b fi la lb l lc ld">class GridFragment : Fragment() {<br/>  override fun onCreate(savedInstanceState: Bundle?) { <br/>    super.onCreate(savedInstanceState)<br/>    <strong class="ku hi">sharedElementEnterTransition = ChangeBounds()</strong><br/>  }<br/>}</span></pre><p id="2001" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在这一点上，我乐观地期望它只是工作，但我实际上得到这个:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es le"><img src="../Images/5690f4cf81b469fa509a2910f44c0d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*4VT06bjAfclbGEb3p6wsBw.gif"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">The enter transition doesn’t work, but the return does</figcaption></figure><p id="791f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">因此，它在进入时根本不起作用，但在返回过渡时工作得很好。这是一个开始。</p><h1 id="edd1" class="lf kz hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">延缓</h1><p id="9104" class="pw-post-body-paragraph jn jo hh jp b jq lw ii js jt lx il jv jw ly jy jz ka lz kc kd ke ma kg kh ki ha bi translated">在这一点上，我想起了我的同事<a class="ae jm" href="https://twitter.com/crafty" rel="noopener ugc nofollow" target="_blank">尼克·布彻</a>以前在为<a class="ae jm" href="https://github.com/nickbutcher/plaid" rel="noopener ugc nofollow" target="_blank">格纹</a>写过渡时向我提起过的一些事情。特别是在视图准备好(布局、数据加载等)之前，不得不推迟转换。</p><p id="f87c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">所以我走了，在我的片段中加入了推迟和开始:</p><pre class="ix iy iz ja fd kt ku kv kw aw kx bi"><span id="cf5b" class="ky kz hh ku b fi la lb l lc ld">override fun onViewCreated(view: View, icicle: Bundle?) {<br/>  // View is created so postpone the transition for now<br/>  <strong class="ku hi">postponeEnterTransition()</strong><br/><br/>  viewModel.liveList.observe(this) {<br/>    controller.setList(it)</span><span id="7293" class="ky kz hh ku b fi mb lb l lc ld">    // Data is loaded so we’re ready to start our transition<br/>    <strong class="ku hi">startPostponedEnterTransition()</strong><br/>  }<br/>}</span></pre><p id="47a1" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们必须对进入和退出的片段都这样做，以便进入(单击)和退出(后退按钮)都能按预期工作。</p><p id="c7f0" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">但是仍然没有进入跃迁。🤦</p><h1 id="6724" class="lf kz hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">再订购</h1><p id="6c6a" class="pw-post-body-paragraph jn jo hh jp b jq lw ii js jt lx il jv jw ly jy jz ka lz kc kd ke ma kg kh ki ha bi translated">我在这里做了一点手脚，并联系了Android团队的活动片段转换先生<a class="ae jm" href="https://twitter.com/georgemount1" rel="noopener ugc nofollow" target="_blank">乔治·芒特</a>。他指出了我需要做什么来让它工作:<em class="ks">重新排序</em>。</p><p id="88fb" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">事实证明，您必须为推迟的片段转换启用重新排序片段事务才能工作。幸运的是，这很容易做到(但很容易忘记):</p><pre class="ix iy iz ja fd kt ku kv kw aw kx bi"><span id="82d8" class="ky kz hh ku b fi la lb l lc ld">supportFragmentManager.beginTransaction() <br/>  <strong class="ku hi">.setReorderingAllowed(true)</strong><br/>  .replace(R.id.home_content, fragment)<br/>  .addToBackStack(tag)<br/>  .apply { <br/>    for (view in sharedElementViews) {<br/>      addSharedElement(view)<br/>    }<br/>  }<br/>  .commit()</span></pre><p id="4263" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在那之后，输入过渡偶尔会工作，但大多数时候我只是得到一个交叉渐变。不过，至少现在过渡还在进行。</p><h1 id="39a0" class="lf kz hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">等待你的父母</h1><p id="4f19" class="pw-post-body-paragraph jn jo hh jp b jq lw ii js jt lx il jv jw ly jy jz ka lz kc kd ke ma kg kh ki ha bi translated">在我的转换至少有时在运行的事实的激励下，我开始调试。我推断，在过渡运行的时候，视图已经被布置好(<code class="du mc md me ku b">isLaidOut == true</code>)并且已经被绘制好了。</p><p id="d2e6" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">所以这里的最后一块拼图是……<em class="ks">等待</em>。</p><p id="43f9" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">如果您回顾我们的推迟调用，我们实际上是在数据加载后立即开始推迟的转换。我们需要给视图一个更新、布局的机会，更重要的是，在我们开始转换之前绘制视图。</p><p id="8543" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">所以我们新的延期电话变成了:</p><pre class="ix iy iz ja fd kt ku kv kw aw kx bi"><span id="4357" class="ky kz hh ku b fi la lb l lc ld">override fun onViewCreated(view: View, icicle: Bundle?) {<br/>  // View is created so postpone the transition <br/>  postponeEnterTransition()</span><span id="a95b" class="ky kz hh ku b fi mb lb l lc ld">  viewModel.liveList.observe(this) {<br/>    controller.setList(it)<br/>    // Data is loaded so lets wait for our parent to be drawn <br/>    <strong class="ku hi">(view?.parent as? ViewGroup)?.doOnPreDraw {</strong><br/>      // Parent has been drawn. Start transitioning! <br/>      startPostponedEnterTransition()<br/>    }<br/>  }<br/>}</span></pre><p id="5bf5" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">您可能想知道为什么我们在父视图上设置<code class="du mc md me ku b">OnPreDrawListener</code>,而不是视图本身。那是因为你的视图可能实际上没有被画出来，因此听者永远不会发火，交易会永远推迟。为了解决这个问题，我们将侦听器设置在父节点上，这将(可能)被绘制出来。</p><p id="5ada" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">瞧，我们有一个工作过渡:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es le"><img src="../Images/d3cef3793afaf4d1c64ae6c10726f910.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*Cuk2d1ZQbZq_zspbevObVg.gif"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">It works!</figcaption></figure><p id="4ead" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">你可能想知道为什么这看起来不像我上面的推文。我将在以后的文章中讨论这个问题。✨⚡.下一篇文章将着眼于获得窗口插入和片段转换。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="c0bd" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">如果你想知道<code class="du mc md me ku b">doOnPreDraw</code>方法来自哪里，它来自于<a class="ae jm" href="https://github.com/android/android-ktx" rel="noopener ugc nofollow" target="_blank"> android-ktx </a>。如果你在你的应用中使用Kotlin，一定要检查一下。</p></div></div>    
</body>
</html>