# 适用于 Android 开发人员的 Reactive Programming — Part I

> 原文：<https://medium.com/google-developer-experts/reactive-programming-para-desenvolvedores-android-part-i-53788a4fbc9f?source=collection_archive---------0----------------------->

让我如此喜欢软件开发领域的一件事,特别是在谈论 Android 应用程序开发时,是事物变化的速度带来了新的有趣的工具和技术。

近年来,函数式响应式编程(特别是适用于 Java 和 Android 的 RX Java 库)一直是 Android 开发社区中讨论最多的话题之一。
在过去的一年中,我有机会深入了解和实施,我想在一系列帖子中分享,首先谈谈这个主题的动机和基本解释。

# 什么是 Functional Reactive Programming?

这是一个非常热门的话题,但许多人发现很难理解的原因之一是,在将这些概念转化为代码之前,命名法产生了很多混乱,因为名称的“功能”部分将我们引导到另一个更古老的概念,与我将在本系列文章中讨论的内容无关。

## 函数式编程 — 真正的意义(最古老的)

函数式编程本质上是一个范式,它假定函数(或方法)应该被编写为执行特定的函数而没有副作用(纯函数)。
这意味着一个函数不依赖于或操纵超出其作用域的变量。(因为函数式编程是一个有趣的主题,而且本身就很长,所以如果你有兴趣阅读更多关于这个主题的内容,我建议你阅读更详细的帖子 [这里](https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming) )

考虑到*functional programming 的原始定义,让我们来看看*functional reactive programming*的定义,以便我们能够理解这两个名称之间的*functional*部分的差异。*

> 功能反应式编程是使用异步数据流进行编程,可以使用一组函数将其转换为新数据流。T10 此数据流由一个元素发出,并且在接收数据流时可能存在或可能不存在另一个元素。

查看上面的定义,而较旧的术语指的是纯函数的创建,较新的术语指的是函数部分,它是一组允许修改数据流的函数,我们将在下面看到。

因此,我相信从现在开始,我们可以同意,当我们想谈论*功能性反应性编程*时,我将使用术语*反应性编程*,以避免疑问和混淆。

## 观察者模式 The Observer Pattern

响应式编程(T1)基于*观察者模式(T3),它假定存在两个组件,其中第一个组件被命名为**观察者(T5),负责发送数据流,第二个组件被命名为**观察者(T7),负责监听和接收数据流,如下图所示:*****

![](img/a167a58cd17c45153a4f30cc42614850.png)

## **Reactive Programming [The Observer Pattern++]**

反过来,响应式编程可以被认为是对*观察者模式*的升级,其中我们继续有两个元素,其中一个发出数据流,另一个接收并响应该数据流,并添加一个强大的中间组件,由不同的函数组成,允许操作数据或流作为一个整体,如下图所示。

![](img/18d6f85055266a4938b56925a7847a18.png)

## **为什么要以反应式的方式思考?(T13 )**

反应性思维的想法源于当我们以相反的反应性思维(**而不是*反应性思维)时,我们必须做的问题和工作。(T17) (T17)***

思维方式**非反应式**是思维方式**命令式,**和思维方式**命令式**通常是从我们开始学习编程时开始的,我们在单线程中查看要执行的代码,并使用回调逻辑,我们希望它在原始线程上执行,一旦另一个线程完成了某些工作。

以连接到 API 以读取数据的基本(Web,Android)应用程序为例,在实现中,必须有一个组件负责启动 API 调用并定义一个回调方法,该方法将在 API 发送响应时立即被调用。

在此之前,这种解决方案一直是最好的,因此许多系统都是以这种方式开发的。然而,问题是,随着系统的增长,在处理多个线程时使用回调方法管理这些接口变得非常昂贵,并使代码变得非常难以维护。

为了进一步强调前面的例子中专门为 Android 实现的强制性思维的限制,这意味着 API 调用将用于在片段或活动中呈现信息,因为我们不知道这项工作何时会结束,并且调用的方式不知道启动它的组件, 如果用户退出应用程序,我们可能会遇到严重的问题,因为任务继续运行,并且在 Activity 或 Fragment 中对字段进行 *set* 时,这些组件将不再存在。

具体来说,对于 Android,整个系统可以被认为是异步的,因为在上面的例子中,诸如读取内部数据库,用户通过点击事件发送的输入等操作是异步的,并且必须思考,尽管它工作总是会随着应用程序的增长而增加更多的工作。

鉴于上述情况,现在最大的疑问应该是如何被动地思考。

反应性思维很简单(**一个谎言,让你读到下一个帖子,这在**系列结束时成为现实),我们应该简单地看看正在开发的系统,就其中的数据流而言,也就是说,思考一个给定的组件将如何自动响应系统中另一个组件的变化,该组件准备听取其更改。

例如,如果在命令形式中存在一个变量**a**,并且该变量被定义为变量**b + c**的总和,除非我们再次将**a**的定义操作作为**b+c**的总和,否则{T10} a 的值将永远不会改变。

在反应性形式中, **a** *将被订阅(* 我将在整个 *系列中经常使用的术语)* a **b** 和 **c 【T25] 并且在 **b** 和 **c** 改变时,其值将被更新,而无需执行两个变量的求和赋值操作。**

在理论上理解这一切一开始是非常复杂的,但我可以向你保证,在下一篇文章中,我将详细介绍如何使用适用于 Java 和 Android 的 RX Java 库将这种思维方式转化为代码。

如果你喜欢这篇文章的内容,请点击下面的心脏留下一个喜欢,并与你认为你也想了解更多关于这个主题的朋友分享。

吃下一篇文章,

dm=)