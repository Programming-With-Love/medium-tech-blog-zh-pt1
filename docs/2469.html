<html>
<head>
<title>Daemonless Container Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无门集装箱发动机</h1>
<blockquote>原文：<a href="https://medium.easyread.co/daemonless-container-engine-5364394b80ec?source=collection_archive---------0-----------------------#2020-04-19">https://medium.easyread.co/daemonless-container-engine-5364394b80ec?source=collection_archive---------0-----------------------#2020-04-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="62a2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">波德曼对码头工人</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e2738f7e6a549de952b5dde6611ceb32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y61_COOOit5V92Y5pTTFEw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture by <a class="ae ks" href="https://developers.redhat.com/blog/2018/08/29/intro-to-podman/" rel="noopener ugc nofollow" target="_blank">https://developers.redhat.com/blog/2018/08/29/intro-to-podman/</a></figcaption></figure><blockquote class="kt ku kv"><p id="5af6" class="kw kx ky kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">本文将讨论<a class="ae ks" href="https://www.docker.com/get-started" rel="noopener ugc nofollow" target="_blank">码头工人</a>和<a class="ae ks" href="https://podman.io/getting-started/" rel="noopener ugc nofollow" target="_blank">搬运工</a>的比较。</p></blockquote><p id="d877" class="pw-post-body-paragraph kw kx in kz b la lb jo lc ld le jr lf lt lh li lj lu ll lm ln lv lp lq lr ls ig bi translated">许多人使用容器来开发、测试甚至运行他们的应用程序。目前，我们可以看到<a class="ae ks" href="https://www.docker.com/get-started" rel="noopener ugc nofollow" target="_blank">码头</a>是最适用的集装箱化。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lw"><img src="../Images/b07ca8d4904524217fbe13e15eb96ec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oe8sssbxxKudE3cAd07jGQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture by <a class="ae ks" href="https://www.cloudmanagementinsider.com/containerization-vs-virtualization/" rel="noopener ugc nofollow" target="_blank">https://www.cloudmanagementinsider.com/containerization-vs-virtualization/</a></figcaption></figure><h1 id="7c40" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">那么，Docker是什么？</h1><blockquote class="kt ku kv"><p id="4d3d" class="kw kx ky kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><a class="ae ks" href="https://www.docker.com/get-started" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io"> Docker </strong> </a>是一个通过容器化来开发、运输和运行应用程序(及其库和依赖项)的开源平台。</p></blockquote><h2 id="410d" class="mp ly in bd lz mq mr dn md ms mt dp mh lt mu mv mj lu mw mx ml lv my mz mn na bi translated"><strong class="ak">以下是Docker如何处理他们的容器:</strong></h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/b116c681d49431d9cb0f04f29c46e3d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*cbwgCz4hHJvWGlc3eBfEVQ.gif"/></div></figure><ul class=""><li id="647c" class="nc nd in kz b la lb ld le lt ne lu nf lv ng ls nh ni nj nk bi translated">Docker CLI使用Docker Rest API通过脚本或直接CLI命令来控制Docker守护进程或与之交互。</li><li id="d8f6" class="nc nd in kz b la nl ld nm lt nn lu no lv np ls nh ni nj nk bi translated">该守护程序创建并管理Docker对象，如图像、容器、网络和卷。</li><li id="844c" class="nc nd in kz b la nl ld nm lt nn lu no lv np ls nh ni nj nk bi translated">因此，当Docker CLI向Docker守护程序发送命令(管理映像)时，Docker守护程序会从注册表中推送/提取映像。</li><li id="02aa" class="nc nd in kz b la nl ld nm lt nn lu no lv np ls nh ni nj nk bi translated">守护进程在本地容器中制作图像的副本并维护它。</li></ul><h2 id="8245" class="mp ly in bd lz mq mr dn md ms mt dp mh lt mu mv mj lu mw mx ml lv my mz mn na bi translated"><strong class="ak">docker有什么问题:</strong></h2><ul class=""><li id="a9bf" class="nc nd in kz b la nq ld nr lt ns lu nt lv nu ls nh ni nj nk bi translated">如果Docker守护进程出现故障，那么每个子进程都会丢失其踪迹。<br/> <strong class="kz io"> - &gt; </strong>单个流程可能是单点故障。<br/> <strong class="kz io"> - &gt; </strong>该流程拥有所有子流程(运行容器)。</li><li id="f219" class="nc nd in kz b la nl ld nm lt nn lu no lv np ls nh ni nj nk bi translated">所有Docker操作都必须由一个(或多个)具有相同完全根访问权限的用户来执行。</li></ul></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="48bc" class="lx ly in bd lz ma oc mc md me od mg mh jt oe ju mj jw of jx ml jz og ka mn mo bi translated">还有，波德曼是什么？</h1><blockquote class="kt ku kv"><p id="a777" class="kw kx ky kz b la lb jo lc ld le jr lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated"><a class="ae ks" href="https://podman.io/getting-started/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io"> Podman </strong> </a>是作为libpod库的一部分提供的实用程序。它可用于创建和维护容器。而且最重要的是，波德曼里没有叫守护进程的概念。Podman通过runC容器运行时进程(不是守护进程)直接与映像注册表、容器和映像存储进行交互。</p></blockquote><h2 id="5d70" class="mp ly in bd lz mq mr dn md ms mt dp mh lt mu mv mj lu mw mx ml lv my mz mn na bi translated">以下是波德曼如何处理他们的容器:</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/8bf596831d14788d7a3cdb627add3055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/1*ZMeCGWySbvtCxcFzU65wrw.gif"/></div></figure><ul class=""><li id="cdde" class="nc nd in kz b la lb ld le lt ne lu nf lv ng ls nh ni nj nk bi translated">使用与我们在Docker CLI中使用的命令行相同的命令行</li><li id="ed94" class="nc nd in kz b la nl ld nm lt nn lu no lv np ls nh ni nj nk bi translated">可以使用image和dockerfile(如Docker所用)。</li><li id="3d79" class="nc nd in kz b la nl ld nm lt nn lu no lv np ls nh ni nj nk bi translated">如果您想要执行或维护多容器，请使用podman-compose。</li></ul></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="a366" class="lx ly in bd lz ma oc mc md me od mg mh jt oe ju mj jw of jx ml jz og ka mn mo bi translated">所以，这就是波德曼和码头工人的区别:</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/93cc1caeb195c091ead3129a06ec8794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RxghbPa6v6QkV1RwiSEWYQ.png"/></div></div></figure></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="396f" class="lx ly in bd lz ma oc mc md me od mg mh jt oe ju mj jw of jx ml jz og ka mn mo bi translated">参考</h1><ol class=""><li id="86ba" class="nc nd in kz b la nq ld nr lt ns lu nt lv nu ls oi ni nj nk bi translated"><a class="ae ks" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io">码头工人概述</strong> </a></li><li id="52e1" class="nc nd in kz b la nl ld nm lt nn lu no lv np ls oi ni nj nk bi translated"><a class="ae ks" href="https://podman.io/getting-started/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io">波德曼入门</strong> </a></li><li id="e61c" class="nc nd in kz b la nl ld nm lt nn lu no lv np ls oi ni nj nk bi translated"><a class="ae ks" href="https://www.docker.com/blog/runc/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io">介绍runC:一个轻量级通用容器运行时</strong> </a></li><li id="bed7" class="nc nd in kz b la nl ld nm lt nn lu no lv np ls oi ni nj nk bi translated"><a class="ae ks" href="https://developers.redhat.com/blog/2019/01/15/podman-managing-containers-pods/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io"> Podman:在本地容器运行时管理pod和容器</strong> </a></li><li id="d72c" class="nc nd in kz b la nl ld nm lt nn lu no lv np ls oi ni nj nk bi translated"><a class="ae ks" href="https://mkdev.me/en/posts/dockerless-part-3-moving-development-environment-to-containers-with-podman" rel="noopener ugc nofollow" target="_blank"><strong class="kz io">【Dockerless，第3部分:使用Podman </strong> </a>将开发环境迁移到容器中】</li><li id="92d9" class="nc nd in kz b la nl ld nm lt nn lu no lv np ls oi ni nj nk bi translated"><a class="ae ks" href="https://cloudnweb.dev/2019/06/replacing-docker-with-podman-power-of-podman/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io">用搬运工代替码头工——搬运工的权力</strong> </a></li><li id="5f99" class="nc nd in kz b la nl ld nm lt nn lu no lv np ls oi ni nj nk bi translated"><a class="ae ks" href="https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz io">集装箱术语实用介绍</strong> </a></li></ol></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oj ok l"/></div></figure></div></div>    
</body>
</html>