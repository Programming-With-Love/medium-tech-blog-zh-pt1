<html>
<head>
<title>Linux shell under the hood !</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引擎盖下的Linux外壳！</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/linux-shell-under-the-hood-e1e9ca6d39f?source=collection_archive---------7-----------------------#2019-08-26">https://medium.com/quick-code/linux-shell-under-the-hood-e1e9ca6d39f?source=collection_archive---------7-----------------------#2019-08-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/fb5ce0c53092e005eac14f3c9ca70ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2VVAhCa2ndJvRb5i"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Photo by <a class="ae hu" href="https://unsplash.com/@_imkiran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sai Kiran Anagani</a> on <a class="ae hu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="5d51" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">什么是linux shell？</h2></div><p id="11eb" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">一个<strong class="jo hy"> Shell </strong>是一个命令行解释器。它以交互和非交互的方式工作(以后不用再担心这个了)。</p><p id="f726" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">一个<strong class="jo hy">外壳</strong>为你提供了一个到Unix系统的接口。它收集你的输入，并根据输入执行程序。当一个程序完成执行时，它显示该程序的输出。</p><p id="6211" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Shell是一个我们可以运行命令、程序和shell脚本的环境。有不同风格的外壳，就像有不同风格的操作系统一样。每种风格的shell都有自己的一套可识别的命令和函数。</p><h2 id="35ce" class="ki kj hx bd kk kl km kn ko kp kq kr ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">Shell提示符</h2><p id="adc4" class="pw-post-body-paragraph jm jn hx jo b jp ld iy jr js le jb ju jv lf jx jy jz lg kb kc kd lh kf kg kh ha bi translated">提示符(<strong class="jo hy">$)</strong>称为<strong class="jo hy">命令提示符</strong>，由shell生成。当提示符显示时，您可以键入命令。</p><p id="5076" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在你按下<strong class="jo hy">回车</strong>后，Shell读取你的输入。它通过查看您输入的第一个单词来确定您想要执行的命令。单词是一组完整的字符。空格和制表符分隔单词。</p><h1 id="ed57" class="li kj hx bd kk lj lk ll ko lm ln lo ks jd lp je kv jg lq jh ky jj lr jk lb ls bi translated">但是怎么做呢？</h1><h2 id="1237" class="ki kj hx bd kk kl km kn ko kp kq kr ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">注意:</h2><ul class=""><li id="59bf" class="lt lu hx jo b jp ld js le jv lv jz lw kd lx kh ly lz ma mb bi translated">在这篇博客中，我们将使用自己的UNIX shell，运行在ubuntu的terminator上。</li><li id="7781" class="lt lu hx jo b jp mc js md jv me jz mf kd mg kh ly lz ma mb bi translated">你可以在这里找到关于如何使用我们的shell的详细信息:<a class="ae hu" href="https://github.com/thomasmontoya123/simple_shell" rel="noopener ugc nofollow" target="_blank">https://github.com/thomasmontoya123/simple_shell</a>。</li></ul><h1 id="18a5" class="li kj hx bd kk lj lk ll ko lm ln lo ks jd lp je kv jg lq jh ky jj lr jk lb ls bi translated">背后的算法:</h1><p id="b6bf" class="pw-post-body-paragraph jm jn hx jo b jp ld iy jr js le jb ju jv lf jx jy jz lg kb kc kd lh kf kg kh ha bi translated">左边是交互模式，右边是非交互模式。</p><figure class="mi mj mk ml fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mh"><img src="../Images/ce5fea4253d02fd783cafcd721613044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1m2Q4bMzqlCLPayM"/></div></div></figure><h2 id="f3b2" class="ki kj hx bd kk kl km kn ko kp kq kr ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">1.检查shell应该在交互模式还是非交互模式下工作:</h2><p id="df10" class="pw-post-body-paragraph jm jn hx jo b jp ld iy jr js le jb ju jv lf jx jy jz lg kb kc kd lh kf kg kh ha bi translated">为此，我们使用了<strong class="jo hy"> isatty() </strong>函数。<strong class="jo hy"> isatty() </strong>测试<strong class="jo hy"> <em class="mm"> fd </em> </strong> <em class="mm">(文件描述符)</em>是否为引用终端的打开文件描述符。<strong class="jo hy"> isatty() </strong>如果<em class="mm"> fd </em>是引用终端的打开文件描述符，则返回1；否则，返回0，并且设置<em class="mm"> errno </em>以指示错误。</p><h2 id="dbaf" class="ki kj hx bd kk kl km kn ko kp kq kr ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">2.如果外壳应该在交互模式下工作:</h2><p id="ede1" class="pw-post-body-paragraph jm jn hx jo b jp ld iy jr js le jb ju jv lf jx jy jz lg kb kc kd lh kf kg kh ha bi translated">显示提示<strong class="jo hy"> ($ ) </strong>并等待用户输入。</p><h2 id="8554" class="ki kj hx bd kk kl km kn ko kp kq kr ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">3.用户输入后:</h2><p id="10b2" class="pw-post-body-paragraph jm jn hx jo b jp ld iy jr js le jb ju jv lf jx jy jz lg kb kc kd lh kf kg kh ha bi translated">在用户写了一些东西(<strong class="jo hy"> ls -l </strong>)之后，我们需要将输入存储在某个地方，为此我们使用了_getline()函数，它是getline()函数的实现。</p><p id="a42e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">getline()从流中读取一整行，将包含文本的缓冲区地址存储到*lineptr中。缓冲区以空终止，如果找到换行符，则包含换行符。</p><p id="14f8" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果*lineptr为NULL，那么getline()将分配一个缓冲区来存储该行，该缓冲区应该由用户程序释放。(在这种情况下，忽略*n中的值)</p><h2 id="39d6" class="ki kj hx bd kk kl km kn ko kp kq kr ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">4.多于一个单词的输入:</h2><p id="a915" class="pw-post-body-paragraph jm jn hx jo b jp ld iy jr js le jb ju jv lf jx jy jz lg kb kc kd lh kf kg kh ha bi translated">您可能知道，通常shell命令和内置命令都有标志，这些标志是该命令或内置命令的选项。本例中为(<strong class="jo hy"> -l </strong>)，表示长格式。用户也可以写下他们想要执行动作的路径。让我们来看一个例子:某个文件夹(<strong class="jo hy"> /home/thomas </strong> ) <strong class="jo hy">中长格式(<strong class="jo hy"> -l </strong>)的list ( <strong class="jo hy"> ls </strong>)。</strong></p><figure class="mi mj mk ml fd hj er es paragraph-image"><div class="er es mn"><img src="../Images/9195232c8ddb6140e5959a70cdc105e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/0*7P8XMRKUwvOxwsNT"/></div></figure><p id="65f4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> 5。拆分输入:</strong></p><p id="28c8" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了检查这些选项，我们需要将所有输入拆分成单个单词，因此我们实现了自己的<strong class="jo hy"> strtok() </strong>函数。</p><p id="7044" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> strtok() </strong>根据分隔符将整个字符串分割成子字符串(更多内容在逐步过程中)。</p><p id="71c2" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">函数的作用是:将一个字符串解析成一系列的符号。在第一次调用<strong class="jo hy"> strtok </strong>()时，要解析的字符串应该在<em class="mm"> str </em>中指定。在应该解析相同字符串的每个后续调用中，<em class="mm"> str </em>应该为空。</p><p id="edbb" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><em class="mm"> delim </em>参数(在本例中为空格)指定了一组字节，用于在解析后的字符串中分隔标记。调用者可以在解析相同字符串的连续调用中在<em class="mm"> delim </em>中指定不同的字符串。所以每次<strong class="jo hy"> strtok() </strong>找到一个分隔符(空格)，字符串就被分割。</p><p id="c446" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">用<strong class="jo hy"> _getline() </strong>我们只得到一个字符串(<strong class="jo hy"> ls -l </strong>)。在<strong class="jo hy"> strtok() </strong>之后，我们得到:</p><ul class=""><li id="945f" class="lt lu hx jo b jp jq js jt jv mo jz mp kd mq kh ly lz ma mb bi translated">字符串1 = ls。</li><li id="4e9b" class="lt lu hx jo b jp mc js md jv me jz mf kd mg kh ly lz ma mb bi translated">字符串2 = -l。</li></ul><p id="5a31" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> 6。分析第一个字符串。</strong></p><p id="66f1" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们需要检查第一个子串是命令还是内置的，在这种情况下，我们的第一个子串或标记是(<strong class="jo hy"> ls </strong> ) <strong class="jo hy"> </strong>命令。</p><p id="57ec" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy">内置</strong>是一个命令或函数，从外壳调用，直接在外壳中执行，而不是外壳加载和执行的外部可执行程序(更多内容请参见本文的“关于进程”一节):</p><p id="364a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> env </strong>内置示例:</p><figure class="mi mj mk ml fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mr"><img src="../Images/1309e18892e2360651adb8b4cafef2eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s3lVR5oYzYdu79IdWbuuJg.png"/></div></div></figure><p id="aab1" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们将第一个字符串与我们的内置函数进行比较，我们的内置函数是:</p><ul class=""><li id="200b" class="lt lu hx jo b jp jq js jt jv mo jz mp kd mq kh ly lz ma mb bi translated"><strong class="jo hy"> cd - </strong>更改目录。</li><li id="1ade" class="lt lu hx jo b jp mc js md jv me jz mf kd mg kh ly lz ma mb bi translated"><strong class="jo hy">帮助- </strong>打印外壳帮助。</li><li id="ef1b" class="lt lu hx jo b jp mc js md jv me jz mf kd mg kh ly lz ma mb bi translated"><strong class="jo hy">退出- </strong>从外壳中退出。</li><li id="123a" class="lt lu hx jo b jp mc js md jv me jz mf kd mg kh ly lz ma mb bi translated">打印环境变量。</li></ul><p id="c52e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">正如你看到的<strong class="jo hy"> ls </strong>不是内置的，现在我们必须找出它是否是一个命令。我们不知道那个命令在哪里(它驻留在<strong class="jo hy"> /bin/ls，</strong> ok我们知道但是计算机不知道)所以我们需要找到它，为此我们构建了路径管理。路径管理在计算机中搜索该命令。</p><p id="09c8" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">没有路径管理:</p><figure class="mi mj mk ml fd hj er es paragraph-image"><div class="er es ms"><img src="../Images/d86a6f4beb6fb907fae6eb5f7bd1dcc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/0*J6LSZkWLKBzbZjw1"/></div></figure><p id="5065" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">而且我们不想每次都写命令驻留在哪里，因为这很费事！</p><p id="5daf" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">使用路径管理:</p><figure class="mi mj mk ml fd hj er es paragraph-image"><div class="er es mt"><img src="../Images/59fba54a334135fe2eb5a64d486960e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*Z4w5_m84ryWG8HomJGF8Wg.png"/></div></figure><p id="10ae" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> 7。关于过程。</strong></p><p id="0649" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">现在我们准备运行命令…..但是我们不能在同一个shell <strong class="jo hy">进程</strong>中运行它，所以我们使用<strong class="jo hy"> fork() </strong>函数创建了一个子进程。</p><p id="f230" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">fork() 通过复制调用进程(本例中是shell)来创建一个新进程。新流程被称为<strong class="jo hy">子流程</strong>(其中<strong class="jo hy"> ls </strong>将被执行)。调用进程被称为父进程。</p><p id="c405" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">子进程和父进程在不同的内存空间中运行。在fork()时，两个内存空间具有相同的内容。其中一个进程执行的内存写入、文件映射和取消映射不会影响另一个进程。子进程是父进程的精确副本。</p><p id="0602" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">成功时，父进程返回子进程的<strong class="jo hy"> PID </strong>(进程ID)，子进程返回<strong class="jo hy"> 0 </strong>。失败时，父进程返回-1，不创建子进程，并适当设置errno。</p><p id="892d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> 8。执行命令。</strong></p><p id="f4c2" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">现在我们有了子进程(此时是shell的副本)。计算机有运行命令的绿灯。为此，我们使用了<strong class="jo hy"> execve() </strong>函数。执行()执行<em class="mm">文件名</em>指向的程序。<em class="mm">文件名</em>必须是二进制可执行文件。</p><p id="4dbc" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> execve </strong>()不返回成功，调用进程的文本、数据、bss和堆栈被加载的程序覆盖(现在子进程不再是shell的副本，命令<strong class="jo hy"> ls -l </strong>已经被执行到子进程中)</p><p id="8392" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Tadaa到目前为止，该命令已经成功执行，您应该在屏幕上看到如下内容:</p><figure class="mi mj mk ml fd hj er es paragraph-image"><div class="er es mt"><img src="../Images/59fba54a334135fe2eb5a64d486960e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*Z4w5_m84ryWG8HomJGF8Wg.png"/></div></figure><p id="bf91" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> 9。清洁一切</strong></p><p id="919c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">还记得<strong class="jo hy"> getline() </strong>和<strong class="jo hy"> strtok() </strong>函数<strong class="jo hy">吗？我们占用了一些我们不再需要的内存。所以我们必须使用<strong class="jo hy"> free() </strong>来释放它，系统可以在其他地方使用这些资源<strong class="jo hy">。</strong></strong></p><p id="26fa" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> 10。重新开始。</strong></p><p id="7ef6" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果命令不是<strong class="jo hy"> exit，</strong>并且我们在交互模式下工作，我们再次显示提示，过程重新开始。</p><figure class="mi mj mk ml fd hj er es paragraph-image"><div class="er es mu"><img src="../Images/595669b79eb61aa4cab39ca20f418caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*eDFyFBTzpWQXeriF79LBdQ.png"/></div></figure></div></div>    
</body>
</html>