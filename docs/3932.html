<html>
<head>
<title>SwiftUI | Drawing | Tic-Tac-Toe Game</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI |绘图|井字游戏</h1>
<blockquote>原文：<a href="https://medium.com/globant/swiftui-drawing-tic-tac-toe-game-71fae0d46381?source=collection_archive---------0-----------------------#2022-07-28">https://medium.com/globant/swiftui-drawing-tic-tac-toe-game-71fae0d46381?source=collection_archive---------0-----------------------#2022-07-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="34a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是井字游戏<a class="ae jc" rel="noopener" href="/globant/swiftui-complete-guide-with-tic-tac-toe-game-ae2fea4f980e">系列</a>的第5部分。在本教程中，我们将学习SwiftUI绘图，并为我们的游戏创建一个棋盘。</p><p id="3753" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">SwiftUI有一个形状协议，我们需要在绘制自定义路径时确认该协议。形状协议有一个path(in:)方法，该方法接受CGRect并返回路径。使用形状协议，我们可以绘制SwiftUI内置的形状，如矩形，圆形等。幸运的是，我们也可以在SwiftUI中使用CGPath或UIBezierPath重用我们以前绘制的路径。</p><p id="43a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将使用自定义路径绘制X标记。为此，我们将创建一个新的SwiftUI文件，并将其命名为XMarkView。请注意，视图接受形状类型，这就是为什么我们将进行如下更改:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/4b2e366d9ac830fd98007f9af246de7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4jI8uVvcRGtyAcDinPrBg.png"/></div></div></figure><p id="c726" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我们需要实现一个强制方法，path(in rect: CGRect) -&gt; Path。创建并初始化一个路径变量，并从该方法返回它来解决这个构建时错误。</p><p id="6753" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要画X，我们需要两条对角线的线/路径。让我们把第一条线画成:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="b01a" class="ju jv hh jq b fi jw jx l jy jz">path.move(to: CGPoint(x: rect.minX, y: rect.minY))<br/>path.addLine(to: CGPoint(x: rect.width, y: rect.maxY))</span></pre><p id="cfa2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">移动到左上角，然后会从左上角到右下角画一条线</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="c392" class="ju jv hh jq b fi jw jx l jy jz">path.move(to: CGPoint(x: rect.width, y: rect.minY))<br/>path.addLine(to: CGPoint(x: rect.minX, y: rect.height))</span></pre><p id="79b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要移动到新的点，右上角，因为我们的线不是连续的。之后会从右上到左下划一条新的线。</p><p id="560e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">预览时什么也看不到，因为我们需要给笔画或铅笔颜色以及绑定的细节，否则它将占据整个屏幕/父视图的尺寸。最终的外观将是这样的:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ka"><img src="../Images/3ec318ddba38ac4bf1a0f3903e74c161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9fBiWxsncZg6SAm99jUK2A.png"/></div></div></figure><p id="8fce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦绘制完成，我们将在返回新计算的形状之前添加closeSubpath()，这样图形将开始绘制新的路径，而不需要调用<em class="kb"> move(to:) </em>。</p><blockquote class="kc kd ke"><p id="f1e0" class="ie if kb ig b ih ii ij ik il im in io kf iq ir is kg iu iv iw kh iy iz ja jb ha bi translated">对于O，使用SwiftUI内置圆形。</p></blockquote><p id="314e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的X和O标记准备好了。接下来，我们需要使用Path设计一个棋盘。</p><p id="bed6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个新的SwiftUI文件，将其命名为Shape类型的MatrixBorder，就像我们对XMarkView所做的那样。下面的例子说明了棋盘是如何绘制的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ki"><img src="../Images/bba1d36fe4d732e26f26defe74e53ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wr3VhoA8aP2v4K5rGSj9ZQ.png"/></div></div></figure><p id="3215" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦随机选择一个玩家开始游戏，我们将展示这个棋盘。返回GameScreen并创建一个状态变量shoudAddCheckerboard，该变量最初为false，一旦接力棒动画完成并选择了一个玩家，该变量将被设置为true:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="49df" class="ju jv hh jq b fi jw jx l jy jz">DispatchQueue.main.asyncAfter(deadline: .now() + 12) {<br/>   self.shoudAddCheckerboard = true<br/>}</span></pre><p id="9ec3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将有条件地在游戏画面<em class="kb">主体中添加矩阵边界。</em></p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="7c26" class="ju jv hh jq b fi jw jx l jy jz">if shoudAddCheckerboard {<br/>   MatrixBorder()<br/>      .stroke(Color.red, lineWidth: 3)<br/>      .frame(width: 150, height: 150)<br/>}</span></pre><p id="c93f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在更多的改动之后，我们将能够在游戏屏幕上看到这一点。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kj"><img src="../Images/d5ea109067d2b2da41f61e31211aec0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*aJgi_nahw2uxM2XjRJhxiw.gif"/></div></figure><p id="ad4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的棋盘UI已经准备好了，但是它没有执行任何点击操作。因为棋盘只是一个包含4条路径/线的形状。为了使玩家的行动变得棘手，我们需要添加一个3*3块的网格，每个块将根据玩家的回合画出X或O。</p><p id="9293" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过命名MatrixBlock创建一个结构。这个视图会和玩家互动。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="01b7" class="ju jv hh jq b fi jw jx l jy jz">struct MatrixBlock: View {<br/>   var body: some View {<br/>      Rectangle()<br/>         .frame(width: 40.0, height: 40.0)<br/>         .foregroundColor(.white)<br/>   }<br/>}</span></pre><p id="55e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是玩家将点击的格子，X或O将按照玩家的回合被抽取。为了存储网格细节，例如谁选择了该网格以及该网格是否已经被选择，我们需要一个对象模型:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="ae1a" class="ju jv hh jq b fi jw jx l jy jz">class GridDetail: ObservableObject {<br/>   @Published var isSelected = false<br/>   var player = 0<br/>}</span></pre><p id="4ce0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在矩形上添加一个页面，用于在玩家点击时更新网格细节。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="a77d" class="ju jv hh jq b fi jw jx l jy jz">if self.gridDetail.isSelected == false {<br/>   self.gridDetail.isSelected = true<br/>   self.gridDetail.player = self.settings.currentPlayer<br/>}</span></pre><p id="15ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，检查这个特定的网格是否已经被选中。如果没有，那么选择它，并设置哪个玩家在上面玩过。要了解当前玩家的详细信息，我们将使用环境对象游戏设置。</p><blockquote class="kc kd ke"><p id="50cb" class="ie if kb ig b ih ii ij ik il im in io kf iq ir is kg iu iv iw kh iy iz ja jb ha bi translated">settings是一个环境对象，因此我们不需要再次初始化它来访问数据。</p></blockquote><p id="58ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">网格细节已更新，但没有反映在设置中。第一次更新当前玩家详细信息:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="dba3" class="ju jv hh jq b fi jw jx l jy jz">if self.gridDetail.player == 2 {<br/>   self.settings.currentPlayer = 1<br/>} else {<br/>   self.settings.currentPlayer = 2<br/>}</span></pre><p id="0dfa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦数据被更新，如果被玩家1选中，将会画出圆圈，否则将会画出X。并添加以下代码:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="916d" class="ju jv hh jq b fi jw jx l jy jz">if self.gridDetail.isSelected == true {<br/>   if self.gridDetail.player == 1 {<br/>      Circle()<br/>         .stroke(PlayerInfo.player1.getPlayerColor(), lineWidth: 5)<br/>         .frame(width: 20, height: 20, alignment: .center)<br/>   } else {<br/>      XMarkView()<br/>         .stroke(PlayerInfo.player2.getPlayerColor(), lineWidth: 5)<br/>         .frame(width: 20, height: 20, alignment: .center)<br/>   }<br/>}</span></pre><p id="5518" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">到目前为止，我们已经设计了我们自己的网格，但我们需要3*3个网格，所以让我们将它安排在MatrixGrids结构中，如下所示:</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="a329" class="ju jv hh jq b fi jw jx l jy jz">struct MatrixGrids: View {<br/>   var body: some View {<br/>      VStack {<br/>         ForEach(0..&lt;3) { _ in<br/>            HStack {<br/>               ForEach(0..&lt;3) { _ in<br/>                  MatrixBlock()<br/>               }<br/>            }<br/>         }<br/>      }<br/>   }<br/>}</span></pre><p id="6013" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">内部for循环将水平排列3个网格，然后外部for循环将绘制包含它们的3个垂直网格。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="5a1d" class="ju jv hh jq b fi jw jx l jy jz">struct Checkerboard: View {<br/>   var body: some View {<br/>      MatrixGrids()<br/>         .foregroundColor(.red)<br/>   }<br/>}</span></pre><p id="71e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">只需添加这些代码并调用Checkerboard而不是MatrixBorder。</p><pre class="je jf jg jh fd jp jq jr js aw jt bi"><span id="e10f" class="ju jv hh jq b fi jw jx l jy jz">...<br/>if shoudAddCheckerboard {</span><span id="9ec7" class="ju jv hh jq b fi kk jx l jy jz">   Checkerboard()<br/>...</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kj"><img src="../Images/73454397604f1442ff85e7526da758ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*VfWgNBhbEojzP5RstgeK7Q.gif"/></div></figure><p id="0a53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，我们有红色的网格和白色的棋盘边界，但我们希望它以另一种方式。要实现它，使用我们的MatrixBorder并将其添加为MatrixGrids上的覆盖图。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kl"><img src="../Images/6e15ca5bd7ae408ae0349766ddc37323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vfkJ7gBGxKcJtvx3_n2aQ.png"/></div></div></figure><p id="8fd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们已经绘制了自己的功能性井字游戏，这难道不令人惊讶吗？但是等等，我们仍然需要添加一些规则来结束游戏并选择获胜者。</p><p id="6d3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请务必查看我在这个系列中的其他文章:</p><p id="13c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-text-view-styling-lets-play-tic-tac-toe-game-7987909584fb">文本视图样式</a></p><p id="6bfc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-tic-tac-toe-game-button-154a35997bc">按钮</a></p><p id="184b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-navigation-tic-tac-toe-game-d05d52cf4636">导航</a></p><p id="e58f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-shapes-tic-tac-toe-game-376073b11102">形状</a></p><p id="e60d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-data-flow-tic-tac-toe-game-bace4fbeb3ac">数据流</a></p><p id="98ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-list-tic-tac-toe-game-8ad7aaa4050">列表</a></p><p id="a6a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" rel="noopener" href="/@roy11manisha/swiftui-animation-tic-tac-toe-game-4ffe37aba0b8">动画</a></p><blockquote class="kc kd ke"><p id="cfea" class="ie if kb ig b ih ii ij ik il im in io kf iq ir is kg iu iv iw kh iy iz ja jb ha bi translated">如果你喜欢这篇文章，请用掌声和评论来欣赏它。这会鼓励我多写！！！！</p></blockquote></div></div>    
</body>
</html>