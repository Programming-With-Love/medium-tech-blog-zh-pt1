# 面向企业 Bee 的高级 FP:Traverse

> 原文：<https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-traverse-b5e4e8b7b8e4?source=collection_archive---------2----------------------->

![](img/8f1878e1727e20bfb57c44ec61c4c972.png)

Honey Bees in Hive

# 介绍

本文是我们通过 Kotlin 介绍高级 FP 概念的系列文章的第一篇。目标受众是像我这样的企业开发人员，我们行业的工蜂。

我打算把重点放在实际应用上(不管它们有多简陋)，把理论推迟到必要的时候。后期评价毕竟很 FP…

在这篇文章中，我想为这个系列做个铺垫，然后从介绍*遍历*开始。所有显示的代码都可以通过这个公共库在[获得。](https://bitbucket.org/instilco/advanced-fp-gde/src/master/)

# 搭建舞台

马拉松跑步、音乐、武术和编程有什么共同点？它们都有大量参与者退出的“退出点”。典型的退出点出现在一个有意义的目标已经达到，但是到下一个目标的距离令人生畏的时候。

例如，许多人开始跑步健身，但一旦达到特定水平就放弃了。我相信你知道有人跑完一场马拉松后就把运动鞋挂了起来。

在编码中，退出点存在于个别语言中，比如 [Scala 的《疯狂的悬崖》](http://blog.fogus.me/2011/09/02/scala-is-for-drivers/)。但是它们也适用于一般的编程风格。Lambda Conf 发布了一个函数式编程的[阶梯](https://pbs.twimg.com/media/CydL5EYUsAAI-61.jpg:large)来记录 FP 的实现水平。这既吓人又能增长见识，所以我建议多加几个梯级，让攀登不那么令人担忧。

就我个人而言，我将 FP 中的学习水平分类如下:

1.  Lambdas 和核心运算符(*过滤器*、*映射*和 *forEach* )
2.  标准 FP 工具包( *flatMap* 、 *reduce* 、 *partition* 等)
3.  自定义高阶函数、currying 和部分调用
4.  功能类型和组成(*选项*、*任一*、*验证*等)
5.  这里有龙…

许多人(相当正确地)在了解了当前项目所需的一切后就停止了。我将假设你在 3 级或 4 级左右，并且有兴趣学习更多。但是你是一个实用的程序员，不愿意容忍理论的海啸。所以我们从一个你可能没听说过的非常有用的操作符开始。

# 引入导线

假设你有一个同事，他最近参加了一个 Kotlin 课程，导师[咳咳]技术高超且友好。作为其中的一部分，他们接触到了箭头框架及其功能数据类型。有一天你在代码库中发现了这个:

显然，你的同事为了提供帮助，已经包装了 *getProperty* 方法，以便它返回一个*或者*。如果属性存在，我们得到一个包含结果的右的*，否则是一个包含错误消息的左*。**

今天的工作要求您获取三个属性的值，因此您编写了一个 Spike 来进行测试:

以下是您得到的结果:

```
[Right(test1.txt), Right(test2.txt), Right(test3.txt)]
[Right(test1.txt), Left(No JVM property: false), Right(test3.txt)]
```

很明显*列表*或者*列表*都是一件烦人的事情。有一些操作符，如*所有*、*任何*、*过滤器*和*分区*，可以用来处理*左*和*右*值。但它仍然是粗糙的代码。

你会想到这与你所需要的正好相反。理想情况下，您会希望有一个函数能为您提供以下功能之一:

*   一个*右侧*包含一个结果列表
*   包含错误信息的*左侧*

这是*遍历*提供的服务。

# 运行中的遍历

这是一个我们想要的实现:

我们获取一个属性名列表，然后*遍历*，而不是*映射*。这具有转换类型的效果。**如果一切正常，返回的将是一个*右<列表>* 而不是一个*列表<右>* 。**

因为调用的结果现在是一个*或者*我们可以*折叠*在它上面。我们传入两个 lambdas 或函数，第一个在失败时被调用，第二个在成功时被调用。记住这一点的简单方法是**右**输入处理**右**结果。

让我们尝试一下，以确保:

这是结果输出。如您所见，这正是我们所需要的:

```
Results are:
 test1.txt
 test2.txt
 test3.txt
No JVM property: false
No JVM property: false
No JVM property: false
```

# 调查我们的成功

万岁。所以*遍历*的目的是反转我们正在处理的类型。

我们在以下情况下使用导线:

*   我们正在迭代一个值列表
*   我们需要对每个值应用一个动作
*   该动作返回一个 *Foo* 容器
*   我们想要一个*Foo<List>，而不是一个*List<Foo>**

在这种情况下，动作是 *propertyViaJVM* ，容器是*或者*。调用*映射*会给我们一个*列表<或者>* ，而调用*遍历*会给我们*的(更有用的)反转<列表>* 。

如果你更仔细地看代码，你会发现有两个神奇的方面。正如所承诺的，我们关注的是应用而不是理论，所以现在我们只能说:

*   作为第一个参数传递给*遍历*的*应用*使其能够反转类型。每种类型都需要有特定的*适用*。
*   对 *fix* 的调用是执行类型转换所必需的。在幕后，Arrow 正在模仿一种叫做*的更高级的种类*。

本系列的下两篇文章将详细讨论这些主题。但是我们已经知道的足够多了，可以继续看更复杂的例子。

# 遍历和文件

假设我们的函数朋友也负责从属性文件中检索值的代码:

这里我们使用 Java Streams API 从给定的文件中读取适当的值。这又是一个被返回的*或*。如果一切顺利的话，这将是持有房产价值的权利。如果文件不能被读取，或者属性不存在，它将是一个包含错误信息的*左*。

我们再次需要读取三个属性的值。现在我们知道了秘密，我们可以直接跳到*遍历*。

注意，代码几乎和以前一样。我们只需要管理一个文件名。让我们检查它的工作情况:

以下是输出结果:

```
Results are:
 test1.txt
 test2.txt
 test3.txt
No property called false
No property called false
No property called false
No file called false.properties
```

遍历又一次让我们的生活变得更简单，让我们能够优雅地处理错误。

# 进入单子

因为*或者*是一个*单子*，我们可以以一种非常简洁的方式将调用组合在一起。

假设我们的任务有四个相互依赖的步骤，如下所示:

1.  我们需要访问三个 JVM 属性的值
2.  这些属性的值本身就是属性文件中使用的一个键
3.  属性文件中保存的值是包含数据的文本文件的名称
4.  我们想读取并输出所有的数据

这听起来工作量很大。但是根据我们目前所做的，这并不太难。首先，我们需要一个函数来尝试读取文件中的所有行:

然后，我们可以将迄今为止所做的一切整合在一起:

这次我们使用*或者*函数将 *findViaJVM* 、 *findViaFile* 和 *readEverything* 连接在一起。在底层，挂起函数被用来实现一元合成，但那是另一篇文章的主题。就目前而言，它能起作用就足够了。

为了证明这一点，这里有一个示例 *main* 方法。请注意，因为*或者*正在挂起*去代理*和*主*也需要被挂起。

这些名字是对 1970 年警匪片的致敬。下面是属性文件的内容:

```
cagney.lacy=test1.txt
starsky.hutch=test2.txt
hart.hart=test3.txt
```

当我们运行 *main* 时，它成功地找到了正在打印出来的文件内容。

我们已经走了相当长的一段距离了！值得花点时间喝一杯含咖啡因的饮料，庆祝我们的了不起…

# 切换到已验证

到目前为止，在我们所有的代码中，我们一直使用*或者*类型来表示结果或者错误消息。这是完全合理的，但是*验证的*类型正是为了这个目的。所以我们可以重写现有的代码来使用它。

例如，下面是我们重构的 *propertyViaJVM* 方法:

*demoTraverse* 方法几乎没有变化。但是请注意，当我们创建*应用*时，我们还必须为字符串传递一个*半群*。这是因为*验证的*类型将提供额外的服务，将我们遇到的所有错误消息连接起来。

更广泛的一点是，我们可以使用任何一元类型的*遍历*。另一个很好的例子是执行几个网络操作，并获得一个*未来<列表>* 而不是一个*列表<未来>* 。由于目前似乎没有人同意 HTTP 客户端，我把它作为读者的可怕练习…

# 结论

希望这篇文章已经将*遍历*添加到你的 FP 武库中，并且满足你的胃口，让你知道 FP 还能如何简化你的代码。这就是我打算涵盖的内容。但在此之前，我们需要巩固迄今取得的成就。

在本文中，我们使用了*应用*、*半群*和*更高级的类型、*，但没有正确定义它们是什么。本系列接下来的几篇文章将分别讨论这些问题。但是如果你想继续阅读[，箭头注释](https://arrow-kt.io/docs/patterns/glossary/)是一个很好的起点。下次见…