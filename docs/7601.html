<html>
<head>
<title>Terraform in Real Life: Writing Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现实生活中的地形:编写模块</h1>
<blockquote>原文：<a href="https://medium.com/version-1/terraform-in-real-life-writing-modules-c0b6b5335218?source=collection_archive---------0-----------------------#2022-09-22">https://medium.com/version-1/terraform-in-real-life-writing-modules-c0b6b5335218?source=collection_archive---------0-----------------------#2022-09-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2b65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我在<a class="ae jc" rel="noopener" href="/version-1/terraform-in-real-life-lessons-learned-2469e3fe74e6">的第一篇博客</a>的后续。在这篇文章中，我想谈谈我编写Terraform模块的经历以及这些年来我收集的一些技巧。</p><h1 id="0bbb" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">什么是模块？</h1><blockquote class="kb kc kd"><p id="a9a9" class="ie if ke ig b ih ii ij ik il im in io kf iq ir is kg iu iv iw kh iy iz ja jb ha bi translated">模块是一起使用的多个资源的容器。</p><p id="e90c" class="ie if ke ig b ih ii ij ik il im in io kf iq ir is kg iu iv iw kh iy iz ja jb ha bi translated">每个Terraform配置至少有一个模块，称为其<em class="hh">根模块</em>，由主工作目录中的<code class="du ki kj kk kl b"><em class="hh">.tf</em></code>文件中定义的资源组成。</p></blockquote><p id="1a0f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">什么是模块？上面来自terraform文档的描述解释了基本上每个Terraform配置你可以<code class="du ki kj kk kl b">init</code>和<code class="du ki kj kk kl b">apply</code>是一个模块。然而，当我们谈论模块时，我们通常指的是可重复的Terraform代码块，我们可以对其进行测试、版本控制和重用以减少重复。例如，在更传统的编程语言如Java中，Terraform模块等同于类或方法。模块是Terraform的一个非常有用的特性，绝对应该加以利用。然而，它们确实给你的开发过程带来了额外的考虑。</p><p id="35e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">terraform文档中的上述语句表明，任何包含Terraform代码的目录本质上都是一个模块。然而，通常，当我们谈论Terraform模块时，我们不是在谈论根模块，而是“子”模块——通常称为“模块”。这些是Terraform代码片段，可以用作构建块，拼凑在一起以定义工作负载和环境。想想乐高。</p><p id="e047" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Terraform模块只是一个包含一个或多个<code class="du ki kj kk kl b">.tf</code>文件的目录。正确使用时，它可以成为一个强大的工具，提供许多好处，包括:</p><ul class=""><li id="8157" class="km kn hh ig b ih ii il im ip ko it kp ix kq jb kr ks kt ku bi translated">版本控制</li><li id="10e0" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">减小爆炸半径</li><li id="d747" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">保持地形代码<a class="ae jc" href="https://www.educative.io/blog/coding-best-practices#DRY" rel="noopener ugc nofollow" target="_blank">干燥</a>(尽可能)</li><li id="8e2e" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">确保跨环境和项目的可预测性和一致性</li><li id="eb8d" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">支持开发运维团队之间的协作</li></ul><h2 id="5cbd" class="la je hh bd jf lb lc ld jj le lf lg jn ip lh li jr it lj lk jv ix ll lm jz ln bi translated">模块类型</h2><p id="852b" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">在您的代码中可以通过两种方式引用子模块—本地和远程。本地模块存储在根模块旁边的目录中，允许您将代码的相关部分分组并重用它们。这方面的一个例子可能是您希望在您的环境中多次部署的默认S3存储桶模板。本地模块易于管理，因为它们只是您的(根)Terraform repo的另一部分。</p><p id="c0fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一方面，远程子模块存储在远程位置(例如，一个单独的git存储库)。远程模块的主要优势在于，它们可以在多个地形项目中重复使用，这意味着它们可能具有相当大的爆炸半径，因此需要进行一致的管理。</p><p id="588f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下图说明了如何使用远程模块来构建多个环境。</p><figure class="lu lv lw lx fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es lt"><img src="../Images/9c44d739a672ace8cedfae2e78bc1048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vHZV4BwyyplUgxAajLFgg.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx">Overview of how modules can be defined in Terraform</figcaption></figure><h2 id="5b52" class="la je hh bd jf lb lc ld jj le lf lg jn ip lh li jr it lj lk jv ix ll lm jz ln bi translated"><strong class="ak">从哪里开始？</strong></h2><p id="8052" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">在很多情况下，你会在<a class="ae jc" href="https://registry.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform注册表</a>中找到你需要的东西。有时你可以直接从注册表中使用模块，或者克隆它们并根据你的需要添加一些调整。在版本1中，我们为客户实现了我们的Terraform标准，因此我们编写了自己的标准。下面的技巧是针对其他正在编写自己的远程模块的Terraform用户的。</p><h1 id="0307" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">我的建议</h1><p id="e74c" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">以下建议是过去6年在真实客户项目中使用Terraform时收集到的。这不是一个详尽的指南，而是我学到的一些经验，希望对其他人有用。我在这里关注的是远程“子”模块，它们存储在自己的git存储库中。</p><h2 id="726e" class="la je hh bd jf lb lc ld jj le lf lg jn ip lh li jr it lj lk jv ix ll lm jz ln bi translated">需要模块吗？</h2><p id="efbf" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">这是你应该问自己的第一个问题。规划模块会让你的生活轻松很多。虽然模块提供了许多优势，但它们确实增加了维护代码库的额外开销。因此，您必须决定远程模块是否适合您的需求——我通过提出以下问题来做出决定:</p><figure class="lu lv lw lx fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mj"><img src="../Images/201ffaf604d2e90fe3f94bf21831103f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X4HoLLQ-zFhS6kE60jAvBQ.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx">Module decision Flow</figcaption></figure><h2 id="0211" class="la je hh bd jf lb lc ld jj le lf lg jn ip lh li jr it lj lk jv ix ll lm jz ln bi translated">强制执行标准</h2><p id="30f1" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">当您决定需要一个远程子模块时，您应该有一个合适的结构——当开发其他团队使用的模块时，一致性和标准是必不可少的。使用一些可用的Terraform工具可以极大地帮助执行标准(参见我的<a class="ae jc" rel="noopener" href="/version-1/terraform-in-real-life-lessons-learned-2469e3fe74e6">以前的博客</a>中的例子)。在版本1中，我们为模块建立了以下标准:</p><ul class=""><li id="b9c6" class="km kn hh ig b ih ii il im ip ko it kp ix kq jb kr ks kt ku bi translated">一致的回购结构</li><li id="2619" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">优质读物</li><li id="db97" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">命名约定— tf- <provider> - <module-name/></provider></li><li id="2975" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">语义版本化(<a class="ae jc" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank"> semver </a>)</li><li id="bb9b" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">自动化模块测试</li><li id="3950" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">主/主要分支的保护</li><li id="9ad0" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">完整的工作示例</li></ul><p id="eb99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个完整模块回购的示例:</p><figure class="lu lv lw lx fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mk"><img src="../Images/d7965be901e7fcd154b8351c4f907e38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9NRxHfKYkDN3KB6agFANw.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx">Example of a module repo in GitLab</figcaption></figure><p id="3527" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:在上面的例子中，工作示例包含在Terratest目录中，该目录用于测试模块和演示如何使用它。</p><h2 id="d0ef" class="la je hh bd jf lb lc ld jj le lf lg jn ip lh li jr it lj lk jv ix ll lm jz ln bi translated">Pin提供商和Terraform版本</h2><p id="51de" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">正如哈希公司的<a class="ae jc" href="https://learn.hashicorp.com/tutorials/terraform/provider-versioning?in=terraform/configuration-language" rel="noopener ugc nofollow" target="_blank">所推荐的</a>，向Terraform和provider版本添加约束是一个最佳实践。这在<code class="du ki kj kk kl b">required_providers</code>块中很容易做到，并减少以后的麻烦。</p><p id="8751" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，根据经验，我发现固定提供者会使维护模块变得更加复杂——特别是当它们是嵌套的时候(见下一节)。我的偏好是在一个“子”模块中设置一个最低的提供者版本，然后在根模块中收紧约束。</p><pre class="lu lv lw lx fd ml kl mm mn aw mo bi"><span id="cbb3" class="la je hh kl b fi mp mq l mr ms"># module</span><span id="b1ae" class="la je hh kl b fi mt mq l mr ms">terraform {<br/>  required_version = "&gt;= 1.0.0"<br/>  required_providers {<br/>    aws = {<br/>      source  = "hashicorp/aws"<br/>      version = "~&gt; 3.0"<br/>    }<br/>  }<br/>}</span></pre><p id="6b80" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的代码片段中，我们设置了一个最小的Terraform版本，以便为模块的用户提供灵活性。我们对AWS提供者更加严格，Tilda允许用户使用所有次要版本(3。x)但不是不同的主要版本，如4.1。</p><pre class="lu lv lw lx fd ml kl mm mn aw mo bi"><span id="5cf1" class="la je hh kl b fi mp mq l mr ms"># root module</span><span id="3243" class="la je hh kl b fi mt mq l mr ms">terraform {<br/>  required_version = "~&gt; 1.1.0"<br/>  required_providers {<br/>    aws = {<br/>      source  = "hashicorp/aws"<br/>      version = "=3.20"<br/>    }<br/>  }<br/>}</span></pre><p id="6c1b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个根模块的例子(例如，我们的模块被消费的地方)。这里我们更加严格，因为它不是一个构建模块，而是一个环境蓝图。因此，我们通常不想要相同级别的灵活性，相反，我们希望控制配置更改。</p><h2 id="475d" class="la je hh bd jf lb lc ld jj le lf lg jn ip lh li jr it lj lk jv ix ll lm jz ln bi translated">子模块中包含什么？</h2><p id="9f65" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">考虑什么进入子模块以及在哪里划线是很重要的。作为一个简单的经验法则，我会问“这些资源总是一起创建的吗？”。</p><p id="7d46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，为AWS应用程序负载平衡器(ALB)创建模块时，可以添加以下资源:</p><ul class=""><li id="248d" class="km kn hh ig b ih ii il im ip ko it kp ix kq jb kr ks kt ku bi translated">负载平衡器</li><li id="d7bf" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">HTTPS听众</li><li id="0a6b" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">默认目标群体</li><li id="4727" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">53号公路别名记录</li></ul><p id="e1e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后输入以下内容，因为这些内容可能是作为另一个网络共享模块的一部分创建的:</p><ul class=""><li id="26c2" class="km kn hh ig b ih ii il im ip ko it kp ix kq jb kr ks kt ku bi translated">伐木用S3铲斗</li><li id="9e9f" class="km kn hh ig b ih kv il kw ip kx it ky ix kz jb kr ks kt ku bi translated">53号公路托管区</li></ul><p id="f791" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以上只是一个例子，将取决于你的模块和项目的整体结构。关键是，我们不希望在一个子模块中包含所有可能相关的资源。</p><h2 id="fc5a" class="la je hh bd jf lb lc ld jj le lf lg jn ip lh li jr it lj lk jv ix ll lm jz ln bi translated">不要窝来窝去</h2><p id="8242" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">重申我的第一点，如果你计划好你的模块，它会让你的生活变得容易得多。Terraform允许模块嵌套，这意味着一组基本模块可以组合起来创建一个更复杂的模式(我们称之为“核心模块”)。例如，由较小的ALB、EC2和RDS模块组成的应用程序模块。这是一个很好的模块嵌套用例，但是我建议嵌套不要超过2层。再多一点就会导致俄罗斯玩偶场景，维护起来很痛苦——最小模块中单个属性的更新需要在嵌套的每一层进行更改。在我看来，这比它的价值要大得多。</p><h2 id="b340" class="la je hh bd jf lb lc ld jj le lf lg jn ip lh li jr it lj lk jv ix ll lm jz ln bi translated">不要使输入复杂化</h2><p id="80d6" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">通过创建少量具有许多值的变量(如<code class="du ki kj kk kl b">var.account_config</code>)来简化模块的输入似乎是一个好主意，这些变量可能包含诸如<code class="du ki kj kk kl b">region</code>、<code class="du ki kj kk kl b">vpc_id</code>、<code class="du ki kj kk kl b">hosted_zone_name</code>和<code class="du ki kj kk kl b">subnets</code>的值。</p><p id="b6b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这可以用在如下模块中:</p><pre class="lu lv lw lx fd ml kl mm mn aw mo bi"><span id="f73c" class="la je hh kl b fi mp mq l mr ms"># variables.tf -----------------------</span><span id="5068" class="la je hh kl b fi mt mq l mr ms">variable "account_config" {<br/>  type = any<br/>  description = "A really useful object, with all my account details"<br/>  }</span><span id="0654" class="la je hh kl b fi mt mq l mr ms">variable "instance_config" { <br/>  type = any<br/>  description = "A really useful object, with all my instance details"<br/>}</span><span id="4cf5" class="la je hh kl b fi mt mq l mr ms"><br/># main.tf ----------------------------</span><span id="ed5a" class="la je hh kl b fi mt mq l mr ms">resource "aws_instance" "example" {<br/>  <br/>  key_name         = var.account_config.key_pair_name<br/>  subnet_id        = var.account_config.subnet_id</span><span id="1b84" class="la je hh kl b fi mt mq l mr ms">  ami              = var.instance_config.ami_id<br/>  instance_type    = var.instance_config.instance_type</span><span id="f89a" class="la je hh kl b fi mt mq l mr ms">  ...<br/>}</span><span id="1a9c" class="la je hh kl b fi mt mq l mr ms">data "aws_route53_zone" "domain" {<br/>  name         = var.account_config.hosted_zone_name<br/>  private_zone = true<br/>}</span><span id="e10e" class="la je hh kl b fi mt mq l mr ms">resource "aws_route53_record" "ec2_private_dns" {<br/> <br/>  zone_id = data.aws_route53_zone.domain.zone_id</span><span id="2836" class="la je hh kl b fi mt mq l mr ms">  name = var.instance_config.name</span><span id="33ff" class="la je hh kl b fi mt mq l mr ms">  type    = "A"<br/>  ttl     = "300"<br/>  records = [aws_instance.example.private_ip]<br/>}</span></pre><p id="acdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的例子中，<code class="du ki kj kk kl b">variables.tf </code>文件很好也很干净——它只有两个输入，填充了我们需要的所有内容。虽然这可能是一个诱人的方法，但这是一个坏主意…相信我，我也经历过。这种方法使得模块的消费者更难理解所需的输入和使用模块。这也使得为输入设置默认值变得更加复杂，并且使一些变量成为可选的。</p><pre class="lu lv lw lx fd ml kl mm mn aw mo bi"><span id="8094" class="la je hh kl b fi mp mq l mr ms"># variables.tf -----------------------</span><span id="482b" class="la je hh kl b fi mt mq l mr ms">variable "key_pair_name" {<br/>  type        = string<br/>  description = "The name of the EC2 keypair to use for the ec2_user SSH key."<br/>  }</span><span id="4ee7" class="la je hh kl b fi mt mq l mr ms">variable "subnet_id" {<br/>  type        = string<br/>  description = "The ID of the subnet to create your instance in."<br/> }</span><span id="71b2" class="la je hh kl b fi mt mq l mr ms">variable "ami_id" { <br/>  type        = string<br/>  description = "ID of the AMI to use for your instance."<br/>}</span><span id="e527" class="la je hh kl b fi mt mq l mr ms">variable "instance_type" {<br/>  type        = string<br/>  description = "The type of instance you want to create."<br/>  default     = "t3.medium" # this makes it optional<br/>}</span><span id="1df0" class="la je hh kl b fi mt mq l mr ms">variable "instance_name" {<br/>  type        = string<br/>  description = "The name of the instance you want to create."<br/>  default     = "my_ec2_instance" # this makes it optional<br/>}</span><span id="0a68" class="la je hh kl b fi mt mq l mr ms">variable "hosted_zone_name" {<br/>  type        = string<br/>  description = "The name of an existing Route 53 Hosted Zone you want to create a record for your instance in."<br/>}</span><span id="bc30" class="la je hh kl b fi mt mq l mr ms"># main.tf ----------------------------</span><span id="29d0" class="la je hh kl b fi mt mq l mr ms">resource "aws_instance" "example" {<br/>  <br/>  key_name         = var.key_pair_name<br/>  subnet_id        = var.subnet_id</span><span id="a3d2" class="la je hh kl b fi mt mq l mr ms">  ami              = var.ami_id<br/>  instance_type    = var.instance_type</span><span id="64d9" class="la je hh kl b fi mt mq l mr ms">...<br/>}</span><span id="dd2c" class="la je hh kl b fi mt mq l mr ms">data "aws_route53_zone" "domain" {<br/>  name         = var.hosted_zone_name<br/>  private_zone = true<br/>}</span><span id="03f1" class="la je hh kl b fi mt mq l mr ms">resource "aws_route53_record" "ec2_private_dns" {<br/> <br/>  zone_id = data.aws_route53_zone.domain.zone_id</span><span id="cb58" class="la je hh kl b fi mt mq l mr ms">  name = var.instance_name </span><span id="e1b5" class="la je hh kl b fi mt mq l mr ms">  type    = "A"<br/>  ttl     = "300"<br/>  records = [aws_instance.example.private_ip]<br/>}</span></pre><p id="dce2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更好的解决方案是使用简单的输入，如下所示。虽然这使得变量文件变得更大，但它使得模块更少固执己见，更容易使用。这也意味着您可以轻松地使用<a class="ae jc" href="https://github.com/terraform-docs/terraform-docs" rel="noopener ugc nofollow" target="_blank"> terraform-doc </a> s为您的模块生成描述性的readmes。</p><p id="9454" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个非常好的关于Terraform变量最佳实践的博客可以在<a class="ae jc" href="https://lachlanwhite.com/posts/terraform/10-11-2021-terraform-variables-a-standard/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="a46c" class="la je hh bd jf lb lc ld jj le lf lg jn ip lh li jr it lj lk jv ix ll lm jz ln bi translated">设置逻辑默认值</h2><p id="8e83" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">正如前面提到的，创建大量输入为模块的使用者提供了灵活性。通过为它们设置默认值，它们变成可选的。将这些默认值与您组织的标准保持一致非常重要。例如，将<code class="du ki kj kk kl b">instance_type</code>的默认值设置为合理的大小:</p><pre class="lu lv lw lx fd ml kl mm mn aw mo bi"><span id="89f7" class="la je hh kl b fi mp mq l mr ms">variable "instance_type" {<br/>  type        = string<br/>  description = "The type of instance you want to create."<br/>  default     = "t3.medium" # this makes it optional<br/>}</span></pre><p id="b10c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您的组织有严格的实施要求(通常与安全性有关)，您可以完全省略输入var，并在模块中硬编码该值。这意味着消费者没有覆盖默认设置的选项:</p><pre class="lu lv lw lx fd ml kl mm mn aw mo bi"><span id="f4b3" class="la je hh kl b fi mp mq l mr ms">resource "aws_ebs_volume" "example" {<br/>  ...</span><span id="5fb9" class="la je hh kl b fi mt mq l mr ms">  encrypted  = true # always will be encrypted<br/>  kms_key_id = var.kms_key_id # consumer must provide their KMS key as an input<br/>}</span></pre><h2 id="6da4" class="la je hh bd jf lb lc ld jj le lf lg jn ip lh li jr it lj lk jv ix ll lm jz ln bi translated">提供(许多)描述性输出</h2><p id="4a45" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">模块旨在用作构建块，这意味着它们经常需要向根模块和其他模块提供信息。这些信息是通过使用模块的输出来提供的。Terraform一直允许您输出资源的属性，而Terraform的最新版本允许您输出完整的资源。我更喜欢从模块中输出属性，但是这两种方法都是有效的，关键是要在你的模块中保持一致。</p><pre class="lu lv lw lx fd ml kl mm mn aw mo bi"><span id="9667" class="la je hh kl b fi mp mq l mr ms"># ec2 module - outputs.tf</span><span id="65ea" class="la je hh kl b fi mt mq l mr ms">output "iam_role_name" {<br/>   description = "Name of EC2 instance IAM Role"<br/>   value = aws_iam_role.main.name</span><span id="4b53" class="la je hh kl b fi mt mq l mr ms">}</span><span id="27ed" class="la je hh kl b fi mt mq l mr ms">output "instance_id" {<br/>   description = "ID of EC2 instance"<br/>   value = aws_instance.main.id</span><span id="a814" class="la je hh kl b fi mt mq l mr ms">}</span><span id="e5ca" class="la je hh kl b fi mt mq l mr ms"># root module - main.tf</span><span id="2c6e" class="la je hh kl b fi mt mq l mr ms">module "ec2" {<br/>   ...<br/>}</span><span id="4f0b" class="la je hh kl b fi mt mq l mr ms">output "ec2_iam_role" {<br/>   description = "IAM Role associated with EC2 Instance"<br/>   value       = module.ec2.iam_role_name<br/>}</span><span id="50b9" class="la je hh kl b fi mt mq l mr ms">output "ec2_instance_id" {<br/>   description = "EC2 Instance ID"<br/>   value       = module.ec2.instance_id<br/>}</span></pre><p id="22f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种方法的好处是，模块的消费者很清楚他们可以获得什么样的输出，并且很容易用terraform docs这样的工具进行记录。</p><pre class="lu lv lw lx fd ml kl mm mn aw mo bi"><span id="6c68" class="la je hh kl b fi mp mq l mr ms"># ec2 module - outputs.tf</span><span id="8b15" class="la je hh kl b fi mt mq l mr ms">output "iam_role" {<br/>   description = "EC2 instance IAM Role resource"<br/>   value = aws_iam_role.main</span><span id="fd00" class="la je hh kl b fi mt mq l mr ms">}</span><span id="3a4b" class="la je hh kl b fi mt mq l mr ms">output "instance" {<br/>   description = "EC2 instance resource"<br/>   value = aws_instance.main.id</span><span id="c35f" class="la je hh kl b fi mt mq l mr ms">}</span><span id="b1d9" class="la je hh kl b fi mt mq l mr ms"># root module - main.tf</span><span id="6985" class="la je hh kl b fi mt mq l mr ms">module "ec2" {<br/>   ...<br/>}</span><span id="1c98" class="la je hh kl b fi mt mq l mr ms">output "ec2_iam_role" {<br/>   description = "IAM Role associated with EC2 Instance"<br/>   value       = module.ec2.iam_role.name<br/>}</span><span id="6e8a" class="la je hh kl b fi mt mq l mr ms">output "ec2_instance_id" {<br/>   description = "EC2 Instance ID"<br/>   value       = module.ec2.instance.id<br/>}</span></pre><p id="81de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是另一种输出全部资源的方法。不太清楚什么输出是可用的，但是，这确实意味着消费者可以使用输出的资源的任何属性——他们可能只需要查找提供者文档来找到它们。</p><p id="a1a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如前所述，我更喜欢第一种方法，它符合简单输入的建议。同样，您可以使用<a class="ae jc" href="https://github.com/terraform-docs/terraform-docs" rel="noopener ugc nofollow" target="_blank"> terraform-doc </a> s来填充您的模块的自述文件的输出部分。如果您选择这条路线，我建议您输出您认为可能相关的每个属性——否则您将花费大量时间更新您的模块，只是为了在需要时添加输出。</p><h2 id="bce5" class="la je hh bd jf lb lc ld jj le lf lg jn ip lh li jr it lj lk jv ix ll lm jz ln bi translated">使用标签</h2><p id="e7e9" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">这并不总是能满足您的需求，但是将标签作为模块的输入会很有用。如果您的模块都使用一个<code class="du ki kj kk kl b">var.label</code>作为资源名称的前缀，那么在调用多个模块的根模块中实现您的命名约定就很容易了。</p><p id="20f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如:</p><p id="8678" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> S3模块</strong></p><pre class="lu lv lw lx fd ml kl mm mn aw mo bi"><span id="395b" class="la je hh kl b fi mp mq l mr ms"># S3 module</span><span id="e3b2" class="la je hh kl b fi mt mq l mr ms">resource "aws_s3_bucket" "my_bucket" {<br/>  bucket = "${var.label}-bucket"<br/>  acl    = "private"</span><span id="4199" class="la je hh kl b fi mt mq l mr ms">  ...<br/>}</span></pre><p id="6284" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> VPC模块</strong></p><pre class="lu lv lw lx fd ml kl mm mn aw mo bi"><span id="235c" class="la je hh kl b fi mp mq l mr ms">resource "aws_vpc" "my_vpc" {<br/>  cidr_block = "172.16.0.0/16"</span><span id="ef9c" class="la je hh kl b fi mt mq l mr ms">  tags = {<br/>    Name = "${var.label}-vpc"<br/>  }<br/>}</span><span id="e22b" class="la je hh kl b fi mt mq l mr ms">resource "aws_subnet" "my_subnet" {<br/>  vpc_id            = aws_vpc.my_vpc.id<br/>  cidr_block        = "172.16.10.0/24"<br/>  availability_zone = "us-west-2a"</span><span id="02fb" class="la je hh kl b fi mt mq l mr ms">  tags = {<br/>    Name = "${var.label}-subnet"<br/>  }<br/>}</span></pre><p id="37a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">根模块</strong></p><pre class="lu lv lw lx fd ml kl mm mn aw mo bi"><span id="c4d6" class="la je hh kl b fi mp mq l mr ms"># dev.tfvars</span><span id="61fe" class="la je hh kl b fi mt mq l mr ms">label = "project-app-dev"</span><span id="6604" class="la je hh kl b fi mt mq l mr ms"># test.tfvars</span><span id="6077" class="la je hh kl b fi mt mq l mr ms">label = "project-app-test"</span><span id="8c22" class="la je hh kl b fi mt mq l mr ms"># main.tf</span><span id="0101" class="la je hh kl b fi mt mq l mr ms">module "s3" {<br/>  source = "git::&lt;my-repo&gt;/tf-aws-mod-s3.git"<br/>  label = var.label</span><span id="cc0c" class="la je hh kl b fi mt mq l mr ms">...<br/>}</span><span id="bbee" class="la je hh kl b fi mt mq l mr ms">module "vpc" {<br/>  source = "git::&lt;my-repo&gt;/tf-aws-mod-vpc.git"<br/>  label = var.label</span><span id="b944" class="la je hh kl b fi mt mq l mr ms">...<br/>}</span></pre><h2 id="0e40" class="la je hh bd jf lb lc ld jj le lf lg jn ip lh li jr it lj lk jv ix ll lm jz ln bi translated">HACK —本地更新(远程)模块</h2><p id="4b5d" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">因为模块是用来解耦你的代码的，所以它们在本质上是分布式的。这意味着在多个地方更新和测试代码是非常耗时的。想想下面的设置——你的根模块调用模块<code class="du ki kj kk kl b">tf-aws-ec2</code>，模块又调用模块<code class="du ki kj kk kl b">tf-aws-iam-profile</code>。在这种情况下，要为您的环境更改IAM概要文件模板，您需要更新两个远程模块，更新它们的标记，在根模块中引用新的模块标记，最后测试更新是否按预期工作。</p><p id="a074" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">测试这些更改的快捷方式可以在本地机器上的<code class="du ki kj kk kl b">.terraform</code>目录中找到。当您运行<code class="du ki kj kk kl b">terraform init</code>或<code class="du ki kj kk kl b">terraform get</code>时，您的配置中所有模块的副本都被拉入本地<code class="du ki kj kk kl b">.terraform/modules</code>目录。这使您能够在本地对模块(<code class="du ki kj kk kl b">tf-aws-iam-profile</code>)进行更新，并通过在您的配置上运行<code class="du ki kj kk kl b">terraform plan</code>来测试更改。一旦您对更新确信无疑，您就可以将这些更改复制到远程模块repos并更新版本标签。</p><figure class="lu lv lw lx fd ly er es paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="er es mu"><img src="../Images/f62f31e03f1632eb4c1d1340546702cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_TF41GE3B9jE_O9qKeqzdw.jpeg"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx">Photo by <a class="ae jc" href="https://unsplash.com/@cgower?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Christopher Gower</a> on <a class="ae jc" href="https://unsplash.com/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl mv mw go mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ha hb hc hd he"><p id="72ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">编写模块是使用Terraform管理企业环境的重要部分。在这里，我根据多年的经验总结了一些建议。我希望它对正在编写自己的模块的其他人有用，并期待听到您从自己的经历中获得的任何提示。</p><h1 id="96a5" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">关于作者:</h1><p id="3f40" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">Shane Mitchell是版本1的高级AWS DevOps工程师。</p></div></div>    
</body>
</html>