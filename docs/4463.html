<html>
<head>
<title>Five Inconvenient Truths about REST: 5 — Hierarchical URIs Will Kill You in the End</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于休息的五个难以忽视的事实:5——等级森严的URIs最终会杀了你</h1>
<blockquote>原文：<a href="https://medium.com/compendium/five-inconvenient-truths-about-rest-5-hierarchical-uris-will-kill-you-in-the-end-67df5284740f?source=collection_archive---------2-----------------------#2018-05-28">https://medium.com/compendium/five-inconvenient-truths-about-rest-5-hierarchical-uris-will-kill-you-in-the-end-67df5284740f?source=collection_archive---------2-----------------------#2018-05-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="ed8d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">RESTful webservices的一个关键概念是资源的使用，特别是资源URIs应该是什么样子。人们不应该低估给域对象起一个好名字并以适当的方式构造它们的标识符的价值。在很多情况下，这自然会导致资源的等级划分。事实上，一个领域模型通常由一组相当有限的关键根对象组成，其他对象似乎依赖于它们。然而，除非依赖的内容对象真的不能存在于它们的容器对象之外，甚至不能从一个容器对象切换到另一个容器对象，否则它们应该被建模为URI层次结构中的根对象。</p><p id="9373" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看一个简单的例子。假设我们想要创建一个RESTful应用程序来创建和管理演示。演示文稿有标题、日期和一组幻灯片，它们属于用户。这是我们为自己的资源写下URIs的第一次尝试:</p><ul class=""><li id="5363" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated"><em class="jl"> /users </em> —应用程序中所有用户的资源</li><li id="a704" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated"><em class="jl"> /users/{userId} </em> —包含应用程序中单个用户信息的资源</li><li id="fc39" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated"><em class="jl">/users/{ userId }/presentations</em>—包含用户所有演示文稿的资源</li><li id="60ab" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated"><em class="jl">/users/{ userId }/presentations/{ presentation id }</em>—特定演示文稿的资源</li><li id="f4a4" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated"><em class="jl">/users/{ userId }/presentations/{ presentation id }/slides</em>—包含特定演示文稿中所有幻灯片的资源</li><li id="73c2" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated"><em class="jl">/users/{ userId }/presentations/{ presentation id }/slides/{ slideId }</em>—特定幻灯片的资源</li></ul><p id="ad0d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">分层资源的第一个问题是:树底部对象的URIs开始变得很长。这对计算机来说不是——或者不应该是——问题，但很明显，在树中越往下，URIs就越不容易被人类读懂。</p><p id="9f54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一个问题是URI验证。对于像<em class="jl">/users/734975456/presentations/13464654/slides/59267932</em>这样的URI，仅仅检查幻灯片#59267932是否存在是不够的:系统还必须检查演示#13464654是否存在，用户#734975456是否存在，以及幻灯片#59267932是否属于演示#13464654，以及所有这些检查都必须实施，并经过彻底的测试。</p><p id="a981" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个更微妙的问题是，这种层次化的URI对于授权和保密性意味着什么。假设用户#734975456想要与其他人共享幻灯片#59267932，那么其他用户是否也应该访问演示#13464654和存储在用户#734975456上的信息，即使是以过滤的形式？并且是否应该通知其他用户存在由用户#734975456创建的演示#13464654？在某些情况下，这本身可能已经是一个安全问题。</p><p id="cece" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是如果一张幻灯片可以从一个演示文稿移到另一个演示文稿呢？它会因此改变URI吗？如果在新版本的应用程序中，用户应该被允许在多个演示文稿中重用同一张幻灯片，那该怎么办呢？突然间，容器对象演示与其内容对象幻灯片之间的组合模式被打破，所有幻灯片都必须从URI模式<em class="jl">/users/{ userId }/presentations/{ presentation id }/slides/{ slideId }</em>重新定位到新的URI模式<em class="jl">/users/{ userId }/slides/{ slideId }</em>。希望幻灯片id在应用程序中是唯一的，而不仅仅是在每个演示文稿中。但是，当你在做的时候，幻灯片可以被不止一个用户拥有吗，或者这是待办事项中的一个特性吗？这样的话，幻灯片的URI模式真的应该是<em class="jl"> /slides/{slideId} </em>。如果这同样适用于演示，他们应该得到URI模式<em class="jl">/presentations/{ presentation id }</em>。</p><p id="246e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么，这一切给我们留下了什么？基本上，我们所有的资源都变成了根对象，它们的URIs现在看起来像这样:</p><ul class=""><li id="815a" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated"><em class="jl"> /users </em> —系统中所有用户的资源</li><li id="e31a" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated"><em class="jl"> /users/{userId} </em> —包含系统中单个用户信息的资源</li><li id="8122" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated"><em class="jl">/演示文稿</em> —包含系统中所有演示文稿的资源</li><li id="f2d5" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated"><em class="jl">/presentations/{ presentation id }</em>—特定演示文稿的资源</li><li id="e674" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated"><em class="jl">/幻灯片</em> —包含演示文稿所有幻灯片的资源</li><li id="8c4d" class="jc jd hh ig b ih jm il jn ip jo it jp ix jq jb jh ji jj jk bi translated"><em class="jl"> /slides/{slideId} </em> —特定幻灯片的资源</li></ul><p id="4831" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在幻灯片可以存在于演示之外，演示也可以存在于用户之外。URIs变得更短了，URI验证也更简单了。访问控制和保密性也得到解决:访问单个幻灯片并不意味着访问某个演示文稿(的一些信息)，甚至不会显示幻灯片出现在哪个(哪些)演示文稿中——除非该信息作为超媒体链接包含在内。此外，我们还获得了两个全局资源，可用于搜索所有用户的演示文稿和幻灯片，同时还可以通过参数由特定用户和/或演示文稿进行筛选。</p><p id="a586" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">偶尔，也有分层URIs的用途，但这些年来我对它们越来越怀疑。我主要将它们视为未来的变更请求，当我在早期设计中看到它们时，我会尽可能地挑战它们。</p></div></div>    
</body>
</html>