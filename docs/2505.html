<html>
<head>
<title>TIL: Becareful on Postgres Query, for Less than Or Equal on Timestamp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TIL:小心Postgres查询，因为时间戳小于或等于</h1>
<blockquote>原文：<a href="https://medium.easyread.co/til-becareful-on-postgres-query-for-less-than-or-equal-on-timestamp-9e486b657fc?source=collection_archive---------1-----------------------#2020-05-26">https://medium.easyread.co/til-becareful-on-postgres-query-for-less-than-or-equal-on-timestamp-9e486b657fc?source=collection_archive---------1-----------------------#2020-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ec20" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我今天学到的一个关于在Postgres中查询时间戳值的小故事</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/62860cf04f28fda8d17222112ad760ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-9RkFzLnxCdtsFwt"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@jonasjacobsson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jonas Jacobsson</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c747" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以一周前，我在Postgres上做了一些关于分页的实验，结合了UUID和时间戳。我在这里遇到了一个有趣的问题，当我在同一个时间戳上查询我创建的时间戳时发生了这个问题。</p><h1 id="130a" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">语境</h1><p id="72f0" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">为了给出一些上下文，我有一个这样的数据库模式。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">My Payment schema</figcaption></figure><p id="189b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">出于好奇，我正在对我的应用程序进行负载测试，有许多并发用户并发插入多达100次。这导致我的数据库中有许多行具有相同的时间戳。例如可以在下面看到。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="117d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，所有记录的created_time是相同的(可能多达100条记录)。</p><h1 id="f358" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">问题</h1><p id="fcc5" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">所以，当我基于创建的时间进行查询时，出现了奇怪的行为，我认为这是一个bug或什么。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="36dc" class="mt lq in mp b gy mu mv l mw mx">SELECT * FROM payment_with_uuid <br/>WHERE <br/>created_time <strong class="mp io">&lt;= '2020-05-24 21:27:10'</strong><br/>ORDER BY created_time DESC LIMIT 10;</span></pre><p id="9088" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，从这个查询中，我想要实现的是，我想要选择具有给定时间戳的created_time <code class="fe my mz na mp b"><strong class="kv io">less than or equal to (&lt;=)</strong></code>的所有记录。</p><p id="8a22" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是我得到的只是所有小于被过滤的创建时间戳的时间戳。不过滤具有相同值的时间戳。</p><p id="c546" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以在下面的例子中，</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="10ba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我得到的结果只有<code class="fe my mz na mp b"><strong class="kv io">Kane</strong></code>而<code class="fe my mz na mp b"><strong class="kv io">Allistair</strong></code>和<code class="fe my mz na mp b"><strong class="kv io">James</strong></code>没有被过滤。</p><p id="4884" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另一件不可思议的事情是，如果我反转查询，比如使用<code class="fe my mz na mp b"><strong class="kv io">greater than equal to (&gt;=)</strong></code>语法，我可以获取其他的，比如<code class="fe my mz na mp b"><strong class="kv io">Allistair</strong></code>和<code class="fe my mz na mp b"><strong class="kv io">James</strong></code>，但是<code class="fe my mz na mp b"><strong class="kv io">Kane</strong></code>显然会乱序。</p><h1 id="f495" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">我刚刚学到的解决方案和事情</h1><h2 id="2535" class="mt lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">时间戳是一个整数UNIX时间戳</h2><p id="d8d8" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">所以，在搜索了整个互联网，Stackoverflow很明显，甚至问了我的朋友，我得到了答案，基本上，存储在数据库中的时间戳是UNIX下的时间戳。</p><p id="f4ee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，如果您看到上面示例中的数据库记录，存储的时间戳是这样的。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="b63e" class="mt lq in mp b gy mu mv l mw mx"><strong class="mp io">2020-05-24 21:27:10</strong></span></pre><p id="cd50" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">实际上这不是真正的值，因为Postgres实际上存储的是这些行的UNIX时间戳版本。它可能有毫微秒或微秒，所以它不只是停在秒版本上。</p><p id="1523" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它可能看起来像这样，</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="ad8c" class="mt lq in mp b gy mu mv l mw mx"><strong class="mp io">2020-05-24 21:27:10</strong><strong class="mp io">.37091</strong></span></pre><p id="65f3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们不知道。因为为了格式化，Postgres只将其四舍五入到第二个值。</p><p id="fd44" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我将我的查询改为更具体的，包括毫微秒或微秒，看起来像这样，这是可行的。</p><pre class="kd ke kf kg gt mo mp mq mr aw ms bi"><span id="7995" class="mt lq in mp b gy mu mv l mw mx">SELECT * FROM payment_with_uuid <br/>WHERE <br/>created_time <strong class="mp io">&lt;= '2020-05-24 21:27:10</strong><strong class="mp io">.37091</strong><strong class="mp io">'</strong><br/>ORDER BY created_time DESC LIMIT 10;</span></pre><p id="3f41" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是接下来，有一个问题，如何从应用层面做到这一点。但是对于我来说，由于我使用的是Golang，所以非常简单。</p><h2 id="29ea" class="mt lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">在Golang上使用RFC3339Nano</h2><p id="e4ad" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">因为我的应用程序构建在Golang之上，所以为了处理精度问题，我使用了Golang中的<code class="fe my mz na mp b"><strong class="kv io">time</strong></code>包中的<code class="fe my mz na mp b"><strong class="kv io">time.RFC3339Nano</strong></code>。它的格式看起来像这样，<code class="fe my mz na mp b"><strong class="kv io">"2006–01–02T15:04:05.999999999Z07:00"</strong></code>。或者你可以在这里看到详细的<a class="ae ks" href="https://golang.org/pkg/time/#pkg-constants" rel="noopener ugc nofollow" target="_blank"/></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/b0ab8cad3c327d414b5871a0c8393580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gSd1st48nYVav5TKkkWaxA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">time format in Golang package</figcaption></figure><p id="0c92" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我不知道在其他编程语言中如何做到这一点，但关键是要包括时间戳查询的精度。</p><p id="97ca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，在执行接受来自最终用户的时间戳的查询的情况下，我们需要首先使用RFC3339Nano对其进行格式化，并将其发送到数据库。所以这个查询仍然有效。</p><p id="c8ba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是为什么我需要使用格式，如果我可以不用格式使用它？因为如果我们不格式化它，时间数据结构也将包含毫秒和纳秒？因此，给背景，为什么我需要这个，特别是在我的情况下。</p><p id="a91f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，我将使用用于分页的<code class="fe my mz na mp b"><strong class="kv io">created_time</strong></code>来获取下一页作为光标，我将获取时间戳，并将其转换为字符串。并且该字符串将被用户用来获取新页面作为光标。</p><p id="c1da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我的应用程序中，我将把该字符串转换回时间戳，并在查询中使用它。正因为如此，我们需要小心行事。因为在Golang中，当我们将时间戳转换为字符串时，它可能不包括我们从Postgres中获得的精度。所以我需要用time.RFC3339Nano来格式化。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">This is how my cursor encoded by using the time</figcaption></figure><p id="cb79" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我仍然保持精度，即使我把它转换成字符串，再转换回时间戳。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h1 id="ec73" class="lp lq in bd lr ls nu lu lv lw nv ly lz jt nw ju mb jw nx jx md jz ny ka mf mg bi translated">参考</h1><ol class=""><li id="41c2" class="nz oa in kv b kw mh kz mi lc ob lg oc lk od lo oe of og oh bi translated"><a class="ae ks" href="https://stackoverflow.com/questions/39119783/postgres-using-timestamps-for-pagination" rel="noopener ugc nofollow" target="_blank"> Postgres:使用时间戳进行分页</a> — Stackoverflow(在注释的线程上)</li></ol></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oi mn l"/></div></figure></div></div>    
</body>
</html>