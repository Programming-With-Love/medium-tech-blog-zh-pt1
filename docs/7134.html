<html>
<head>
<title>A Short Guide to Kernel Debugging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内核调试简明指南</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/a-short-guide-to-kernel-debugging-e6fdbe7bfcdf?source=collection_archive---------0-----------------------#2015-10-27">https://medium.com/square-corner-blog/a-short-guide-to-kernel-debugging-e6fdbe7bfcdf?source=collection_archive---------0-----------------------#2015-10-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="6b4e" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">一个关于在生产系统上发现内核错误的故事</h2></div><p id="a659" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本杰明·韦斯特写的。</p><blockquote class="jt"><p id="749d" class="ju jv hh bd jw jx jy jz ka kb kc jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们在https://developer.squareup.com/blog<a class="ae kd" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">的新家</a></p></blockquote><p id="4a68" class="pw-post-body-paragraph iw ix hh iy b iz ke ii jb jc kf il je jf kg jh ji jj kh jl jm jn ki jp jq jr ha bi translated"><em class="js">这篇文章最初是一封内部邮件，描述了在Square的生产主机上发现的一个问题。这篇文章是作为调试Linux内核的工具和实践的介绍而写的，尽管它假设读者对C程序是如何构造的相当熟悉。</em></p><p id="de9f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我在我们的部署基础设施上待命时，一个问题出现了:一个服务的最新版本没有正确部署。日志文件告诉我有一台主机似乎卡住了。登录机器后环顾四周，似乎有些事情很不对劲:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="d720" class="ks kt hh ko b fi ku kv l kw kx">$ date<br/>Thu Sep 10 16:04:00 UTC 2015<br/>$ ps -fC cleanup_old.sh<br/>UID    PID PPID  C STIME TTY      TIME CMD<br/>root  5085 5081  0 Aug27 ?    00:00:10 /bin/sh ./cleanup_old.sh myapp<br/>$ ps -fC rm<br/>UID    PID PPID  C STIME TTY      TIME CMD<br/>root  5109 5099  0 Aug27 ?    00:00:01 rm -rf /opt/myapp-1.0.4<br/>$ sudo kill -9 5085 5109<br/>$ ps -fC cleanup_old.sh<br/>UID    PID PPID  C STIME TTY      TIME CMD<br/>$ ps -fC rm<br/>UID    PID PPID  C STIME TTY      TIME CMD<br/>root  5109 5099  0 Aug27 ?    00:00:01 rm -rf /opt/myapp-1.0.4</span></pre><p id="934a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">杀死一个管理脚本会打乱部署过程，但会留下一个孤立的、几周前的、不可杀死的rm。我眼前的问题得到了缓解，但显然还有一个更深层次的问题。发生了什么事？</p><p id="18d9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我知道这个进程没有在用户空间中旋转——在我试图杀死它之前，这个进程没有在top的输出中显示为一个重度CPU用户，之后它也没有死亡——所以它一定是在对内核的系统调用中被阻塞了。通常，只要知道阻塞的是哪个函数，就可以快速诊断出阻塞的进程。为了寻找一个快速的解决方案，我查看了该进程的内核调用堆栈:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="e8db" class="ks kt hh ko b fi ku kv l kw kx">$ sudo cat /proc/5109/stack<br/>[&lt;ffffffff811979bc&gt;] vfs_unlink+0x5c/0xf0<br/>[&lt;ffffffff8119aac3&gt;] do_unlinkat+0x163/0x260<br/>[&lt;ffffffff8119adf2&gt;] sys_unlinkat+0x22/0x40<br/>[&lt;ffffffff8100b072&gt;] system_call_fastpath+0x16/0x1b<br/>[&lt;ffffffffffffffff&gt;] 0xffffffffffffffff</span></pre><p id="9b5a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当然，rm被阻止解除文件链接；它没有做太多其他的事情。解除链接的哪一部分被阻止了？它要删除哪个文件？那个文件有什么特别的？这些答案依赖于这个进程的内核调用堆栈中的数据，而不仅仅是它的函数列表。我需要查看内核的内存。</p><p id="8734" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这一点上，很明显简单的诊断不能揭示问题。重启会很快“修复”它，但不会阻止这种情况再次发生。我叹了口气，留出一天的剩余时间去寻找根本原因。</p><p id="0fb7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">调试Linux内核比调试普通进程更复杂。以一个要解决的有趣问题为例，让我们来看看一些有助于理解内核内部的工具、技术和数据结构。希望下次您自己的问题离开用户空间时，这个讨论可以成为一个起点。</p><p id="a0fc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们来调试内核吧！</p><h1 id="e1c0" class="ky kt hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">设置内核调试环境</h1><p id="0bd2" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">检查进程状态的一个典型方法是给它附加一个调试器，比如gdb。内核也没什么不同。就像用户空间进程一样，必须构建二进制文件来支持调试。我们正在调试的机器运行RedHat 6.5，幸运的是，RedHat使用一些调试选项集构建了它的内核。为了节省空间，调试符号与主内核二进制文件是分开的，所以我们需要安装它们。</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="57c2" class="ks kt hh ko b fi ku kv l kw kx">$ uname -r<br/>2.6.32-431.23.3.el6.x86_64<br/>$ sudo yum --enablerepo=debug install kernel-debuginfo-2.6.32-431.23.3.el6 kernel-debuginfo-common-x86_64-2.6.32-431.23.3.el6</span></pre><p id="ad7c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们想了解我们所看到的，我们必须安装内核的源代码。调试包已经在/usr/src/debug/…中安装了源代码。如果您想要不带调试包的源代码(可能在另一台机器上)，它可以从源RPM生成。<a class="ae kd" href="https://corner.squareup.com/2015/10/short-guide-to-kernel-debugging.html#correction-1-text" rel="noopener ugc nofollow" target="_blank"> (1) </a></p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="6648" class="ks kt hh ko b fi ku kv l kw kx">$ curl -LO ftp://ftp.redhat.com/.../kernel-2.6.32-431.23.3.el6.src.rpm<br/>$ rpm -Uvh kernel-2.6.32-431.23.3.el6.src.rpm<br/>$ sudo yum install rpm-build yum-utils<br/>$ sudo yum-builddep rpmbuild/SPECS/kernel.spec<br/>$ <a class="ae kd" href="http://www.rpm.org/max-rpm-snapshot/rpmbuild.8.html" rel="noopener ugc nofollow" target="_blank">rpmbuild</a> -pb rpmbuild/SPECS/kernel.spec</span></pre><p id="ec09" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们如何连接gdb？根据机器的稳定性、是否可以暂停/重启以及是否在虚拟机中运行，可以使用许多方法。这是一台裸机，我不想拆卸，所以我们将使用RedHat的<a class="ae kd" href="http://people.redhat.com/anderson/crash_whitepaper/" rel="noopener ugc nofollow" target="_blank">崩溃</a>工具。Crash是围绕gdb的一个包装器，它为理解内核数据结构增加了一些通用函数。它还能够在不干扰内核的情况下调试正在运行的内核:这正是我们所需要的。</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="490e" class="ks kt hh ko b fi ku kv l kw kx">$ sudo crash<br/>  KERNEL: /usr/lib/debug/lib/modules/2.6.32-431.23.3.el6.x86_64/vmlinux<br/>DUMPFILE: /dev/crash<br/>    DATE: Thu Sep 10 17:35:01 2015<br/> RELEASE: 2.6.32-431.23.3.el6.x86_64<br/> VERSION: #1 SMP Thu Jul 31 17:20:51 UTC 2014<br/> MACHINE: x86_64<br/>     PID: 3943<br/> COMMAND: "crash"<br/>    TASK: ffff880494dd6080  [THREAD_INFO: ffff88094a1ea000]<br/>     CPU: 7<br/>   STATE: TASK_RUNNING (ACTIVE)</span><span id="1fe2" class="ks kt hh ko b fi lu kv l kw kx">crash&gt;</span></pre><h1 id="70a5" class="ky kt hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">了解内核数据和x86 ASM</h1><p id="9c59" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">让我们从一个简单的任务开始:我们将验证程序的堆栈仍然和以前一样:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="bdb7" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; <a class="ae kd" href="http://people.redhat.com/anderson/crash_whitepaper/help_pages/set.html" rel="noopener ugc nofollow" target="_blank">set</a> 5109<br/>    PID: 5109<br/>COMMAND: "rm"<br/>   TASK: ffff8802d0e5a080  [THREAD_INFO: ffff88057f85a000]<br/>    CPU: 18<br/>  STATE: TASK_UNINTERRUPTIBLE<br/>crash&gt; <a class="ae kd" href="http://people.redhat.com/anderson/crash_whitepaper/help_pages/bt.html" rel="noopener ugc nofollow" target="_blank">bt</a><br/>PID: 5109  TASK: ffff8802d0e5a080  CPU: 18  COMMAND: "rm"<br/> #0 [ffff88057f85bce8] schedule at ffffffff81528bc0<br/> #1 [ffff88057f85bdb0] __mutex_lock_slowpath at ffffffff8152a36e<br/> #2 [ffff88057f85be20] mutex_lock at ffffffff8152a20b<br/> #3 [ffff88057f85be40] vfs_unlink at ffffffff811979bc<br/> #4 [ffff88057f85be70] do_unlinkat at ffffffff8119aac3<br/> #5 [ffff88057f85bf70] sys_unlinkat at ffffffff8119adf2<br/> #6 [ffff88057f85bf80] system_call_fastpath at ffffffff8100b072<br/>    RIP: 00000033b36dc68d  RSP: 00007ffff7f1ec48  RFLAGS: 00010202<br/>    RAX: 0000000000000107  RBX: ffffffff8100b072  RCX: 0000000000000032<br/>    RDX: 0000000000000000  RSI: 0000000001982a70  RDI: 0000000000000006<br/>    RBP: 00007ffff7f1efa0   R8: 0000000000000003   R9: 0000000000000000<br/>    R10: 0000000000000100  R11: 0000000000000246  R12: ffffffff8119adf2<br/>    R13: ffff88057f85bf78  R14: 0000000000000000  R15: 0000000001979060<br/>    ORIG_RAX: 0000000000000107  CS: 0033  SS: 002b</span></pre><p id="c133" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当一个进程进行系统调用时，它所有的寄存器都保存在其栈底；这就是我们在这里看到的。我们可以用这个来使用<a class="ae kd" href="http://lxr.free-electrons.com/source/arch/x86/kernel/entry_64.S?v=2.6.32#L431" rel="noopener ugc nofollow" target="_blank"> amd64系统调用约定</a>重构系统调用参数。我们还可以看到进程的<a class="ae kd" href="http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.32#L1217" rel="noopener ugc nofollow" target="_blank"> struct task_struct </a>和<a class="ae kd" href="http://lxr.free-electrons.com/source/arch/x86/include/asm/thread_info.h?v=2.6.32#L26" rel="noopener ugc nofollow" target="_blank"> struct thread_info </a>指针。这两个结构是内核用来跟踪系统中每个进程/线程的。(在Linux中，“线程”只是碰巧共享相同地址空间、异常处理程序、文件表等的另一个进程..)</p><p id="d943" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">查看整个堆栈，可以清楚地看到进程正在等待获取一个互斥体(mutex_lock()调用)。现在有行号了:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="2d6c" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; bt -l<br/>PID: 5109  TASK: ffff8802d0e5a080  CPU: 18  COMMAND: "rm"<br/>...<br/> #2 [ffff88057f85be20] mutex_lock at ffffffff8152a20b<br/>    /arch/x86/include/asm/thread_info.h: 216<br/> #3 [ffff88057f85be40] vfs_unlink at ffffffff811979bc<br/>    /fs/namei.c: 2810<br/>...</span></pre><p id="9e07" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们查看“/fs/namei.c”来找出它阻塞了哪个mutex_lock()调用:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="46f5" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; l fs/namei.c:2810<br/>...<br/>2809            mutex_lock(&amp;dentry-&gt;d_inode-&gt;i_mutex);<br/>2810            if (d_mountpoint(dentry))<br/>...</span></pre><p id="c26c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2810线堵？不，回溯显示返回地址在2810行。互斥调用在那之前，在第2809行。</p><p id="5a18" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个<a class="ae kd" href="http://lxr.free-electrons.com/source/include/linux/dcache.h?v=2.6.32#L89" rel="noopener ugc nofollow" target="_blank"> struct dentry </a>是Linux用来跟踪和缓存文件系统名称的数据结构。它将某个目录中的名称与保存数据的实际文件<a class="ae kd" href="http://lxr.free-electrons.com/source/include/linux/fs.h#L584" rel="noopener ugc nofollow" target="_blank"> struct inode </a>相关联。通常，文件在文件系统中只有一个名称(和一个对应的条目)。硬链接为单个文件创建附加名称；删除一个打开的文件允许文件没有名字(直到文件句柄关闭，它才真正被删除)。</p><p id="6052" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以我们的进程阻止获取一个inode的互斥体。哪个inode？我们可以从sys_unlinkat()的参数中提取文件名，但这不会将我们引向inode数据结构。让我们看看能否从调用堆栈中访问一些函数参数。</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="b62c" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; up<br/>up = $1 =<br/> {void (struct semaphore *)} 0xffffffff810a0f30 &lt;up&gt;<br/>crash&gt; gdb up<br/>crash: prohibited gdb command: up</span></pre><p id="dd3f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Crash不支持gdb的标准“up”命令来遍历调用栈。相反，我们可以打印一个包含堆栈内存的“完整”回溯。</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="f2da" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; bt -f<br/>PID: 5109  TASK: ffff8802d0e5a080  CPU: 18  COMMAND: "rm"<br/> #0 [ffff88057f85bce8] schedule at ffffffff81528bc0<br/>    ffff88057f85bcf0: 0000000000000086 0000000000000000<br/>    ffff88057f85bd00: ffffffffa0230da4 ffff88057f85bd18<br/>...</span></pre><p id="130f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通常情况下，gdb会为我们解释内存。二进制的<a class="ae kd" href="http://www.dwarfstd.org/" rel="noopener ugc nofollow" target="_blank">调试信息</a>告诉gdb如何从任何指令中找到任何保存的变量或寄存器的位置。然而，crash没有公开这个功能，迫使我们在寻找有用的上下文时手动展开调用堆栈。</p><p id="4342" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">根据<a class="ae kd" href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI" rel="noopener ugc nofollow" target="_blank"> amd64调用约定</a>，大多数函数参数都是通过寄存器传递的，而不会显式保存在其他任何地方。我们可以访问任务的堆栈，但是不能获得中间寄存器状态。我们恢复上下文的最大希望是在调用堆栈中寻找一个函数，这个函数碰巧将一个重要的变量保存到堆栈中。</p><p id="d814" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在查看了几个反汇编的函数之后，我们发现do_unlinkat()调用vfs_unlink():</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="dc5a" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; <a class="ae kd" href="http://people.redhat.com/anderson/crash_whitepaper/help_pages/dis.html" rel="noopener ugc nofollow" target="_blank">dis</a> do_unlinkat<br/>...<br/>0xffffffff8119aaa2 &lt;do_unlinkat+322&gt;:   mov    -0xc8(%rbp),%rax<br/>0xffffffff8119aaa9 &lt;do_unlinkat+329&gt;:   <strong class="ko hi">mov    %rdx,%rsi</strong><br/>0xffffffff8119aaac &lt;do_unlinkat+332&gt;:   mov    0x10(%rax),%rdi<br/>0xffffffff8119aab0 &lt;do_unlinkat+336&gt;:   mov    %rcx,-0xe8(%rbp)<br/>0xffffffff8119aab7 &lt;do_unlinkat+343&gt;:   <strong class="ko hi">mov    %rdx,-0xe0(%rbp)</strong><br/>0xffffffff8119aabe &lt;do_unlinkat+350&gt;:   callq  0xffffffff81197960 &lt;vfs_unlink&gt;<br/>0xffffffff8119aac3 &lt;do_unlinkat+355&gt;:   mov    -0xe0(%rbp),%rdx<br/>...</span></pre><p id="11be" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个程序集块对应于下面的代码段。</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="b942" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; <a class="ae kd" href="http://people.redhat.com/anderson/crash_whitepaper/help_pages/sym.html" rel="noopener ugc nofollow" target="_blank">sym</a> 0xffffffff8119aaa2<br/>ffffffff8119aaa2 (t) do_unlinkat+322 fs/namei.c: 2869<br/>crash&gt; l fs/namei.c:2869<br/>2869:         error = vfs_unlink(nd.path.dentry-&gt;d_inode, <strong class="ko hi">dentry</strong>);<br/>2870: exit2:<br/>2871:         dput(dentry);</span></pre><p id="fede" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">vfs_unlink()的第二个参数是一个dentry指针，它可以告诉我们哪个文件正在被删除。我们从调用约定中知道，第二个参数是在%rsi寄存器中传递的。它的值来自%rdx，在函数调用之前保存到堆栈中，我们可以在那里恢复它。<a class="ae kd" href="https://corner.squareup.com/2015/10/short-guide-to-kernel-debugging.html#correction-2-text" rel="noopener ugc nofollow" target="_blank"> (2) </a></p><p id="5eea" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们可以查看任务堆栈的完整内存转储，提取帧指针(FP ),并检索dentry:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="1153" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; bt -f<br/>PID: 5109  TASK: ffff8802d0e5a080  CPU: 18  COMMAND: "rm"<br/>...<br/>    ffff88057f85be68: <strong class="ko hi">ffff88057f85bf68</strong> ffffffff8119aac3 &lt;- last frame's FP<br/> #4 [ffff88057f85be70] do_unlinkat at ffffffff8119aac3<br/>    ffff88057f85be78: ffff88004b3d2248 ffff8808a3dbf588<br/>    ffff88057f85be88: <strong class="ko hi">ffff8809c6c82a40</strong> ffff880b92bd4000 &lt;- FP - 0xe0<br/>...</span></pre><p id="8aea" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们可以转储相关的文件系统数据结构:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="5bd9" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; <a class="ae kd" href="http://people.redhat.com/anderson/crash_whitepaper/help_pages/struct.html" rel="noopener ugc nofollow" target="_blank">struct</a> dentry.d_name,d_parent,d_inode <strong class="ko hi">ffff8809c6c82a40</strong><br/>  d_name = {<br/>    len = 7,<br/>    name = 0xffff8809c6c82ae0 "fire.js"<br/>  }<br/>  d_parent = <strong class="ko hi">0xffff8809c6c82b00</strong><br/>  d_inode = <strong class="ko hi">0xffff8808a3dbf588</strong><br/>crash&gt; struct dentry.d_name <strong class="ko hi">0xffff8809c6c82b00</strong><br/>  d_name = {<br/>    len = 2,<br/>    name = 0xffff8809c6c82ba0 "js"<br/>  }<br/>crash&gt; struct inode.i_mutex <strong class="ko hi">0xffff8808a3dbf588</strong><br/>  i_mutex = {<br/>    count = {<br/>      counter = -1<br/>    },<br/>    wait_lock = {<br/>      raw_lock = {<br/>        slock = 196611<br/>      }<br/>    },<br/>    wait_list = {<br/>      next = 0xffff880749a05c48,<br/>      prev = 0xffff88057f85bdc8<br/>    },<br/>    owner = <strong class="ko hi">0xffff88076b78c000</strong><br/>  }</span></pre><p id="ccfd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以文件是“js”目录下的“fire.js”。很高兴知道这一点。现在，让我们看看哪个进程拥有互斥体:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="a077" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; struct thread_info.task <strong class="ko hi">0xffff88076b78c000</strong><br/>  task = 0xffff8807ef98aae0<br/>crash&gt; <a class="ae kd" href="http://people.redhat.com/anderson/crash_whitepaper/help_pages/ps.html" rel="noopener ugc nofollow" target="_blank">ps</a> 0xffff8807ef98aae0<br/>   PID  PPID  CPU       TASK        ST  %MEM     VSZ    RSS  COMM<br/>  4723  4087   2  ffff8807ef98aae0  UN   0.3  641736 137204  ruby</span></pre><h1 id="431e" class="ky kt hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">向前一步，向后一步</h1><p id="1f3c" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">所以，我们现在知道哪个进程有互斥。它现在在做什么？</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="e930" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; bt 4723<br/>PID: 4723  TASK: ffff8807ef98aae0  CPU: 2   COMMAND: "ruby"<br/> #0 [ffff88076b78da08] schedule at ffffffff81528bc0<br/> #1 [ffff88076b78dad0] rwsem_down_failed_common at ffffffff8152b275<br/> #2 [ffff88076b78db30] rwsem_down_write_failed at ffffffff8152b3d3<br/> #3 [ffff88076b78db70] call_rwsem_down_write_failed at ffffffff8128f383<br/> #4 [ffff88076b78dbd0] xfs_ilock at ffffffffa02006fc [xfs]<br/> #5 [ffff88076b78dc00] xfs_setattr at ffffffffa021fdcd [xfs]<br/> #6 [ffff88076b78dcc0] xfs_vn_setattr at ffffffffa022c00b [xfs]<br/> #7 [ffff88076b78dcd0] notify_change at ffffffff811a7cf8<br/> #8 [ffff88076b78dd40] do_truncate at ffffffff81186f74<br/> #9 [ffff88076b78ddb0] do_filp_open at ffffffff8119c051<br/>#10 [ffff88076b78df20] do_sys_open at ffffffff81185c39<br/>#11 [ffff88076b78df70] sys_open at ffffffff81185d50<br/>...</span></pre><p id="3859" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它正在等待获取读写信号量的写锁。哪一个？使用上面的相同方法，我们可以恢复框架#4的第一个参数:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="7b4a" class="ks kt hh ko b fi ku kv l kw kx">xfs_ilock(struct xfs_inode *ip = <strong class="ko hi">0xffff8808a3dbf400</strong>, ??)</span></pre><p id="4109" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，一个内核可以处理许多不同的文件系统，有一个主虚拟文件系统层(VFS)可以理解的通用结构inode，但是每个不同的文件系统也有自己特定的inode数据结构。XFS使用一个<a class="ae kd" href="http://lxr.free-electrons.com/source/fs/xfs/xfs_inode.h?v=2.6.32#L238" rel="noopener ugc nofollow" target="_blank">结构xfs_inode </a>，如果它的字段是嵌入式通用inode，则使用一个。对于低级同步，它包含一个二进制信号量i_iolock，这个进程在试图获取该信号量时被阻塞。</p><p id="a225" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">事实证明，我们以前见过这个inode:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="c9dd" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; struct -ox xfs_inode.i_vnode <strong class="ko hi">0xffff8808a3dbf400</strong><br/>struct xfs_inode {<br/>  [<strong class="ko hi">ffff8808a3dbf588</strong>] struct inode i_vnode;<br/>}</span></pre><p id="ec92" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它是“fire.js”索引节点，其i_mutex锁已经被这个进程持有。它现在在同一个inode上获取一个特定于XFS的信号量。</p><p id="8467" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不幸的是，信号量不像互斥体那样携带“所有者”字段(在这种配置中)。那我们怎么找到它的主人呢？在这种情况下，我们可以幸运地首先假设我们正在调查一个死锁(尽管我们还没有完全找到它)，其次假设这个进程是那个死锁的一个关键部分。如果我们是对的，另一个有趣的进程可能正在等待这个进程的互斥体。</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="0073" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; struct -ox inode.i_mutex <strong class="ko hi">0xffff8808a3dbf588</strong><br/>struct inode {<br/>  [ffff8808a3dbf640] struct mutex i_mutex;<br/>}<br/>crash&gt; struct -ox mutex.wait_list ffff8808a3dbf640<br/>struct mutex {<br/>  [ffff8808a3dbf648] struct list_head wait_list;<br/>}<br/>crash&gt; <a class="ae kd" href="http://people.redhat.com/anderson/crash_whitepaper/help_pages/list.html" rel="noopener ugc nofollow" target="_blank">list</a> -s mutex_waiter.task -H ffff8808a3dbf648<br/>ffff880749a05c48<br/>  task = 0xffff88076dfe2040<br/>ffff88057f85bdc8<br/>  task = 0xffff8802d0e5a080<br/>crash&gt; ps 0xffff88076dfe2040 0xffff8802d0e5a080<br/>   PID  PPID  CPU       TASK        ST  %MEM     VSZ    RSS  COMM<br/>  4724     1   6  ffff88076dfe2040  UN   0.3  468676 138156  ruby<br/>  5109  5099  18  ffff8802d0e5a080  UN   0.0    4144    696  rm</span></pre><p id="8d0c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们从进程5109开始我们的会话，但是另一个进程4724是什么？</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="efff" class="ks kt hh ko b fi ku kv l kw kx">crash&gt; bt 4724<br/>PID: 4724  TASK: ffff88076dfe2040  CPU: 6   COMMAND: "ruby"<br/> #0 [ffff880749a05b68] schedule at ffffffff81528bc0<br/> #1 [ffff880749a05c30] __mutex_lock_slowpath at ffffffff8152a36e<br/> #2 [ffff880749a05ca0] mutex_lock at ffffffff8152a20b<br/> #3 [ffff880749a05cc0] generic_file_splice_write at ffffffff811b8c7a<br/> #4 [ffff880749a05d50] xfs_file_splice_write at ffffffffa02277b0 [xfs]<br/> #5 [ffff880749a05dc0] do_splice_from at ffffffff811b873e<br/> #6 [ffff880749a05e00] direct_splice_actor at ffffffff811b8790<br/> #7 [ffff880749a05e10] splice_direct_to_actor at ffffffff811b8a66<br/> #8 [ffff880749a05e80] do_splice_direct at ffffffff811b8bad<br/> #9 [ffff880749a05ed0] do_sendfile at ffffffff8118936c<br/>#10 [ffff880749a05f30] sys_sendfile64 at ffffffff81189404<br/>#11 [ffff880749a05f80] system_call_fastpath at ffffffff8100b072<br/>...</span></pre><p id="2bf3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">嗯，我看到XFS特有的代码回调到通用的VFS代码。实际上，查看<a class="ae kd" href="http://lxr.free-electrons.com/source/fs/xfs/linux-2.6/xfs_lrw.c?v=2.6.32#L308" rel="noopener ugc nofollow" target="_blank"> xfs_file_splice_write() </a>，您可以看到它在哪里抓取XFS i_iolock，然后调用generic_file_splice_write()，后者然后抓取泛型i_mutex。</p><h1 id="0a01" class="ky kt hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">结论</h1><p id="2210" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">现在有足够的数据来拼凑出一幅完整的画面。大多数XFS写操作首先获取文件的i_mutex，然后获取i_iolock。sys_open()调用就是这种排序的一个例子。然而，拼接写操作的编码不同。它获取i_iolock，然后获取i_mutex。我们在sys_sendfile64()调用中看到了这一点。因此，每当两个进程并发写入并拼接到同一个inode时，每个进程都会获得一个锁，然后阻塞另一个锁，使它们在不可中断的睡眠中死锁，并使inode中毒。</p><p id="960b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们发现了一个XFS病毒。</p><p id="09f0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">搜索“xfs splice deadlock ”,会出现一个2011年的电子邮件线程,描述了这个问题。然而，平分内核源代码库表明，直到2014年4月(<a class="ae kd" href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8d0207652cbe27d1f962050737848e5ad4671958" rel="noopener ugc nofollow" target="_blank"> 8d02076 </a>)在Linux 3.16中发布，这个错误才真正得到解决。</p><p id="2b7d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">那么，为什么我们只是花了这么多时间来调试一个长期已知且已修复的问题呢？RedHat在他们的企业Linux产品中没有使用最新版本的内核。当您的目标是长期稳定性时，使用旧的、久经沙场的版本是一件好事。然而，错误仍然会被发现，它们必须被移植到稳定版本中。RedHat只是还没有包括这个特定的修复。Square正在与他们合作，以达成解决方案。在此之前，RHEL/CentOS 6和CentOS 7的所有当前版本都容易受到此错误的影响。<em class="js">2016年9月2日更新:RedHat现在已经发布了更新的内核，其中包含对该死锁的修复:RHEL 6的版本2 . 6 . 32–642和RHEL 7的版本3 . 10 . 0–327 . 22 . 2</em>。</p><p id="861d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">至于启动这个死锁的进程，它是一个普通的MRI Ruby 2.2.2解释器。它的核心I/O功能已经过优化，尽可能使用零拷贝操作。自2014年初在Linux上，从标准库中调用FileUtils.copy_file()将使用sendfile64()。因此，有一个相当紧凑的触发器:</p><pre class="kj kk kl km fd kn ko kp kq aw kr bi"><span id="182d" class="ks kt hh ko b fi ku kv l kw kx">ruby -rfileutils -e'FN=ARGV.shift; Thread.new { loop { FileUtils.copy_file "/etc/issue", FN } }; loop {File.new FN, File::CREAT|File::TRUNC|File::RDWR }' /xfs/somefile</span></pre><p id="41c0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我怀疑Square也看到过Java进程以这种方式死锁。这些程序正在尝试做正确的事情，我希望随着更多的库和运行时的成熟，它们也会尝试通过采用零拷贝操作来优化它们的I/O行为。</p><p id="889a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">更正:</em> <a class="ae kd" href="https://corner.squareup.com/2015/10/short-guide-to-kernel-debugging.html#correction-1" rel="noopener ugc nofollow" target="_blank"> <em class="js"> (1) </em> </a> <em class="js">:增加了说明你是随kernel-debuginfo-common包一起获得内核源代码的。</em><a class="ae kd" href="https://corner.squareup.com/2015/10/short-guide-to-kernel-debugging.html#correction-2" rel="noopener ugc nofollow" target="_blank"><em class="js">(2)</em></a><em class="js">:第二个参数以%rsi传递，而不是%rdx。</em></p></div></div>    
</body>
</html>