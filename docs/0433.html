<html>
<head>
<title>Gesture Navigation: handling gesture conflicts (III)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">手势导航:处理手势冲突(三)</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/gesture-navigation-handling-gesture-conflicts-8ee9c2665c69?source=collection_archive---------0-----------------------#2019-10-17">https://medium.com/androiddevelopers/gesture-navigation-handling-gesture-conflicts-8ee9c2665c69?source=collection_archive---------0-----------------------#2019-10-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/36988ac0698938a0e39ca9b2582a1d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HA3ZtpNRcwzxvVjSKtfEtQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Cover image by <a class="ae hu" rel="noopener" href="/@VPoltrack">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="e3fd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是我们手势导航系列的第三篇文章。如果你想跳到另一篇文章，你可以在下面找到它们:</p><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/androiddevelopers/gesture-navigation-going-edge-to-edge-812f62e4e83e"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">手势导航:从边缘到边缘(一)</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">Android Q增加了一个新的系统导航模式，允许用户导航回主屏幕…</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg ho js"/></div></div></a></div><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/androiddevelopers/gesture-navigation-handling-visual-overlaps-4aed565c134c"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">手势导航:处理视觉重叠(二)</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">这是我的手势导航系列的第二篇文章。如果你错过了，这是目前其他的:</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg ho js"/></div></div></a></div><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/androiddevelopers/gesture-navigation-immersive-modes-43f2d37a925d"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">手势导航:沉浸式模式(四)</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">在这个关于手势导航的博客系列的第三篇文章中，我们讨论了如何处理手势冲突…</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="kc l kd ke kf kb kg ho js"/></div></div></a></div></div><div class="ab cl kh ki go kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="ha hb hc hd he"><p id="5dac" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">前一篇文章标志着我们关于画到边缘的讨论的结束。在第三篇文章中，我们将介绍如何处理你的应用程序和<a class="ae hu" href="https://www.android.com/android-10/" rel="noopener ugc nofollow" target="_blank"> Android 10 </a>中新的<a class="ae hu" href="https://developer.android.com/guide/navigation/gesturenav" rel="noopener ugc nofollow" target="_blank">系统手势</a>之间的任何手势冲突。</p><p id="d769" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们所说的手势冲突是什么意思？让我们看一个例子。这里我们有一个音乐播放器应用程序，它允许用户通过拖动<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBar</a></code>来拖动当前歌曲。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/055a860272cbc00e2bf55b4d1dfe2f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W0TglpWA5n8MdvJn"/></div></div></figure><p id="0916" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不幸的是，<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBar</a></code>太靠近主手势区域，导致系统快速切换手势接管并混淆用户。</p><p id="da1a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样的事情也可能发生在任何带有手势区域的屏幕边缘。有很多常见的例子会引起冲突，比如:<a class="ae hu" href="https://material.io/design/components/navigation-drawer.html" rel="noopener ugc nofollow" target="_blank">导航抽屉</a> ( <code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/androidx/drawerlayout/widget/DrawerLayout.html" rel="noopener ugc nofollow" target="_blank">DrawerLayout</a></code>)、旋转木马<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/androidx/viewpager2/widget/ViewPager2.html" rel="noopener ugc nofollow" target="_blank">ViewPager</a></code>、<a class="ae hu" href="https://material.io/design/components/sliders.html" rel="noopener ugc nofollow" target="_blank">滑块</a> ( <code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBar</a></code>)、列表上的<a class="ae hu" href="https://material.io/design/components/lists.html#behavior" rel="noopener ugc nofollow" target="_blank">滑动动作</a>。</p><p id="a82e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这让我们想到了一个问题，“我们如何解决这个问题？”。为了帮助回答这个问题，我们创建了一个流程图来帮助指导其中一个解决方案。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kx"><img src="../Images/30d4e42e51d30d338dbf916a1661853f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1LTnVmibrtCnZpdxdAa-w.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">You can find a printable PDF version of the flow chart <a class="ae hu" href="http://bit.ly/gesture-conflict-handling-print" rel="noopener ugc nofollow" target="_blank"><strong class="bd ky">here</strong></a>.</figcaption></figure><p id="86e5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">希望这些问题是不言自明的，但如果你对其中任何一个都不确定，让我们来解释一下:</p><h2 id="7b19" class="kz la hx bd ky lb lc ld le lf lg lh li jf lj lk ll jj lm ln lo jn lp lq lr ls bi translated">1.隐藏导航条和状态栏需要什么应用？</h2><p id="e5ef" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">第一个问题是问你的应用程序的主要用例是否需要<strong class="iw hy">隐藏</strong>导航条和/或状态栏。我们所说的隐藏是指那些系统栏根本看不见。这并不<em class="ly">而不是</em>意味着你已经让你的应用达到了边缘到边缘，或者类似的效果。</p><p id="214e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对此问题回答“是”的可能原因如下:</p><ul class=""><li id="5e1f" class="lz ma hx iw b ix iy jb jc jf mb jj mc jn md jr me mf mg mh bi translated">您使用<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_FULLSCREEN" rel="noopener ugc nofollow" target="_blank">FLAG_FULLSCREEN</a></code> WindowManager标志。注意，这也可以通过<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowManager.LayoutParams.html#FLAG_FULLSCREEN" rel="noopener ugc nofollow" target="_blank">android:windowFullscreen</a></code>主题属性来实现，或者从<code class="du ko kp kq kr b">Theme.XXX.Fullscreen</code>主题的一个变体扩展而来。</li><li id="5896" class="lz ma hx iw b ix mi jb mj jf mk jj ml jn mm jr me mf mg mh bi translated">您使用了<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.html#SYSTEM_UI_FLAG_FULLSCREEN" rel="noopener ugc nofollow" target="_blank">SYSTEM_UI_FLAG_FULLSCREEN</a></code>系统用户界面可见性标志。</li><li id="ead5" class="lz ma hx iw b ix mi jb mj jf mk jj ml jn mm jr me mf mg mh bi translated">您使用沉浸式模式系统ui可见性标志之一:<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.html#SYSTEM_UI_FLAG_IMMERSIVE" rel="noopener ugc nofollow" target="_blank">SYSTEM_UI_FLAG_IMMERSIVE</a></code>或<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.html#SYSTEM_UI_FLAG_IMMERSIVE_STICKY" rel="noopener ugc nofollow" target="_blank">SYSTEM_UI_FLAG_IMMERSIVE_STICKY</a></code>。</li></ul><p id="c396" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">回答“是”的应用程序的一些常见例子有游戏、视频播放器、照片浏览器、绘图应用程序。</p><h2 id="3cbc" class="kz la hx bd ky lb lc ld le lf lg lh li jf lj lk ll jj lm ln lo jn lp lq lr ls bi translated"><strong class="ak"> 2。主要UI用例需要在手势区域内或附近滑动？</strong></h2><p id="4165" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">这个问题是问用户界面是否包含任何需要用户滑动的手势区域(back和home)中/附近的元素。</p><p id="e012" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">游戏通常会回答“是”,原因如下:</p><ul class=""><li id="b444" class="lz ma hx iw b ix iy jb jc jf mb jj mc jn md jr me mf mg mh bi translated">屏幕上的控件倾向于靠近屏幕的左/右边缘和底部。</li><li id="3e3d" class="lz ma hx iw b ix mi jb mj jf mk jj ml jn mm jr me mf mg mh bi translated">一些游戏需要在屏幕元素上滑动，这些元素可以在屏幕上的任何地方，例如棋盘游戏应用程序。</li></ul><p id="a60b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在游戏之外，常见的用户界面示例在这里会给出肯定的答案:</p><ul class=""><li id="7bf5" class="lz ma hx iw b ix iy jb jc jf mb jj mc jn md jr me mf mg mh bi translated">照片裁剪UI，其中拖动手柄靠近屏幕的左/右边缘。</li><li id="b91a" class="lz ma hx iw b ix mi jb mj jf mk jj ml jn mm jr me mf mg mh bi translated">绘图应用程序，用户可以在覆盖屏幕的画布上绘图。</li></ul><h2 id="f021" class="kz la hx bd ky lb lc ld le lf lg lh li jf lj lk ll jj lm ln lo jn lp lq lr ls bi translated"><strong class="ak"> 3。手势区域内/附近的常用视图？</strong></h2><p id="63ca" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">一个简单的问题。这也包括覆盖手势区域的视图，然后扩展到屏幕的更多部分，比如一个<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/androidx/drawerlayout/widget/DrawerLayout.html" rel="noopener ugc nofollow" target="_blank">DrawerLayout</a></code>或大的<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/androidx/viewpager2/widget/ViewPager2.html" rel="noopener ugc nofollow" target="_blank">ViewPager</a></code>。</p><h2 id="ea74" class="kz la hx bd ky lb lc ld le lf lg lh li jf lj lk ll jj lm ln lo jn lp lq lr ls bi translated"><strong class="ak"> 4。视图需要用户滑动/拖动？</strong></h2><p id="aac1" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">我们在这里稍微改变一下策略，开始关注个人观点。对于第三个答案为“是”的视图，是否需要用户在上面滑动/拖动？</p><p id="0c6c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里有很多你会回答是的例子:<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBars</a></code>、<a class="ae hu" href="https://developer.android.com/reference/com/google/android/material/bottomsheet/BottomSheetBehavior.html" rel="noopener ugc nofollow" target="_blank">、底纸</a>，甚至还有一个<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/androidx/appcompat/widget/PopupMenu" rel="noopener ugc nofollow" target="_blank">PopupMenu</a></code>(可以拖开)。</p><h2 id="19cb" class="kz la hx bd ky lb lc ld le lf lg lh li jf lj lk ll jj lm ln lo jn lp lq lr ls bi translated"><strong class="ak"> 5。视图完全/大部分位于手势区域下？</strong></h2><p id="f88b" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">继问题4之后，我们现在要问的是视图是全部还是大部分位于手势区域之下。</p><p id="3412" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你的视图在一个可滚动的容器中，比如一个<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.html" rel="noopener ugc nofollow" target="_blank">RecyclerView</a></code>，稍微换个角度思考这个问题:<em class="ly">视图是否在所有滚动位置的手势区域下全部/大部分被布局？</em>如果用户可以将视图滚动到手势区域之外，你就什么都不用做了。</p><p id="c79d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可能已经看过上面的图表，并看到了全宽传送带(<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/androidx/viewpager2/widget/ViewPager2.html" rel="noopener ugc nofollow" target="_blank">ViewPager</a></code>)的例子，在这里回答“否”，并想知道为什么它导致没有处理。这是因为与视图的宽度相比，左/右手势区域的宽度相对较小(默认:<code class="du ko kp kq kr b">20dp</code>)。你典型的<a class="ae hu" href="https://material.io/resources/devices/" rel="noopener ugc nofollow" target="_blank">手机屏幕宽度</a>在纵向是大约360dp，留下大约320dp宽的可视屏幕，用户的滑动不受阻碍(也就是说<em class="ly">接近</em> <strong class="iw hy"> 90% </strong>)。即使有内部填充/边距，用户仍然可以正常滑动转盘。</p><h2 id="77b6" class="kz la hx bd ky lb lc ld le lf lg lh li jf lj lk ll jj lm ln lo jn lp lq lr ls bi translated">6.视图边界与任何强制手势区域重叠？</h2><p id="7652" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">最后一个问题询问视图是否被布置在任何强制手势区域下。如果你回想一下我们之前的博文<a class="ae hu" rel="noopener" href="/androiddevelopers/gesture-navigation-handling-visual-overlaps-4aed565c134c">，你会记得<strong class="iw hy">强制</strong>系统手势区域是屏幕上系统手势<em class="ly">总是</em>优先的区域。</a></p><p id="457a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android 10只有一个强制手势区，位于屏幕底部，允许用户回家或调出他们最近的应用程序。这可能会在未来的平台版本中有所改变，但现在我们只需要考虑屏幕底部的视图。</p><p id="4310" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里常见的例子有:</p><ul class=""><li id="8752" class="lz ma hx iw b ix iy jb jc jf mb jj mc jn md jr me mf mg mh bi translated">非模态<a class="ae hu" href="https://material.io/components/sheets-bottom/" rel="noopener ugc nofollow" target="_blank">底部表单</a>，因为它们倾向于在屏幕底部折叠成小的可拖动视图。</li><li id="d0f4" class="lz ma hx iw b ix mi jb mj jf mk jj ml jn mm jr me mf mg mh bi translated">屏幕底部的水平滚动的转盘，如贴纸包UI。</li></ul></div><div class="ab cl kh ki go kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="ha hb hc hd he"><p id="479d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">既然我们已经讨论了这些问题，希望您已经找到了其中一个解决方案，那么让我们更详细地讨论一下每个问题。</p><h1 id="6172" class="mn la hx bd ky mo mp mq le mr ms mt li mu mv mw ll mx my mz lo na nb nc lr nd bi translated">没有要处理的冲突</h1><p id="8221" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">让我们从最简单的“解决方案”开始，简单地做… <em class="ly">什么也不做</em>！🙌</p><p id="7ecc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可能还有你<em class="ly">可以</em>进行的优化(见下一节)，但希望在启用手势导航模式的情况下使用你的应用时不会出现大问题。</p><p id="f852" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果图表带你来到这里，但你仍然觉得有问题，请<a class="ae hu" href="http://issuetracker.google.com" rel="noopener ugc nofollow" target="_blank">让我们知道</a>。我们可能漏掉了什么。</p></div><div class="ab cl kh ki go kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="ha hb hc hd he"><h1 id="c3c4" class="mn la hx bd ky mo ne mq le mr nf mt li mu ng mw ll mx nh mz lo na ni nc lr nd bi translated">将视图移出手势区域</h1><p id="5ebb" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">正如我们在<a class="ae hu" rel="noopener" href="/androiddevelopers/gesture-navigation-handling-visual-overlaps-4aed565c134c">之前的博客文章</a>中了解到的，insets被分派来告诉你的应用程序系统手势区域在屏幕上的位置。我们可以用来解决手势冲突的一种方法是将任何冲突的视图移出手势区域。这对于靠近屏幕底部的视图尤其重要，因为该区域是强制手势区，应用程序不能使用那里的排除API。</p><p id="7502" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看一个例子。这里我们有一个上面展示过的<a class="ae hu" href="https://github.com/android/uamp" rel="noopener ugc nofollow" target="_blank">音乐播放器UI </a>。它包含一个位于屏幕底部的<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBar</a></code>，允许用户擦除歌曲。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nj"><img src="../Images/3912b709e2aed6c380cdf04b81712730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-oBtZtn56PAteQCQ8ahyw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Music player UI with a SeekBar at the bottom of the screen</figcaption></figure><p id="ef52" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是当用户尝试擦除歌曲时，会出现这种情况:</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/2fe7404997f2d98948b0c78a0271fe08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t2tkHD1P_CbSBbvn"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Recording of the system gesture conflicting with the SeekBar</figcaption></figure><p id="937f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是因为底部手势区域与SeekBar重叠，因此home手势优先。以下是直观的手势区域:</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nk"><img src="../Images/a888f4689596f2beac45ee78bc60f528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ukYJIZbPJl1bPF2k"/></div></div></figure><h2 id="a509" class="kz la hx bd ky lb lc ld le lf lg lh li jf lj lk ll jj lm ln lo jn lp lq lr ls bi translated">简单溶体</h2><p id="f44b" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">这里最简单的解决方案是添加额外的空白/填充，以便SeekBar被向上推出手势区域。大概是这样的:</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nk"><img src="../Images/c0697e990a641649514eb4492b0653e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0DbZoXi3umaHSwC3"/></div></div></figure><p id="d55c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们用这个例子拖动SeekBar，你会看到我们不再触发home手势:</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/361d68ec56a14357454f7b17eb545985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4b3dhQD1u0Gl7vnJ"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Demo showing the SeekBar no longer conflicting with the bottom system gesture</figcaption></figure><p id="eaaa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了实现这一点，我们需要使用新的<a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html#getSystemGestureInsets()" rel="noopener ugc nofollow" target="_blank">系统手势insets </a>，可在API 29和Jetpack <a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/core" rel="noopener ugc nofollow" target="_blank">核心库</a> v1.2.0中获得(目前在<em class="ly"> alpha </em>中)。在示例中，我们增加了<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBar</a></code>的底部填充，以匹配底部<a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat.html#getSystemGestureInsets()" rel="noopener ugc nofollow" target="_blank">手势插入</a>值:</p><figure class="kt ku kv kw fd hj"><div class="bz dy l di"><div class="nl nm l"/></div></figure></div><div class="ab cl kh ki go kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="ha hb hc hd he"><p id="46b0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可能有兴趣阅读我们发表的另一篇博文，这篇博文探索了一些让<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsets.html" rel="noopener ugc nofollow" target="_blank">WindowInsets</a></code>更容易使用的方法:</p><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/androiddevelopers/windowinsets-listeners-to-layouts-8f9ccc8fa4d1"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">WindowInsets —布局的监听器</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">将我们处理插入的地方移到我们的视图所在的地方，布局文件</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="nn l kd ke kf kb kg ho js"/></div></div></a></div><h2 id="0709" class="kz la hx bd ky lb lc ld le lf lg lh li jf lj lk ll jj lm ln lo jn lp lq lr ls bi translated">更进一步</h2><p id="55a0" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在这一点上，你可能会想:“工作完成了”，对于某些布局来说，这可能是最终的解决方案。但是在我们的例子中，UI在视觉上已经退化了，在<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBar</a></code>下面浪费了很多空间。因此，我们可以改变布局，避免浪费空间，而不是简单地填充视图:</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/73d623f0c19c5df247dc9487bc587b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vou2ocPhP529u_P8"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Demo showing the SeekBar moved to the top of the playback bar</figcaption></figure><p id="1158" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这里，我们将<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBar</a></code>移到了播放栏的顶部，完全脱离了手势区域。这意味着我们不再需要垫/增加酒吧的高度来容纳<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBar</a></code>。</p><p id="8c3e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="ly">然而，我们应该通过系统栏的高度来填充/增加栏的高度，这样文本就不会明显模糊。这在我们的第二篇博文“</em> <a class="ae hu" rel="noopener" href="/androiddevelopers/gesture-navigation-handling-visual-overlaps-4aed565c134c"> <em class="ly">处理视觉重叠</em> </a> <em class="ly">”中有所涉及。</em></p></div><div class="ab cl kh ki go kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="ha hb hc hd he"><h1 id="a8ad" class="mn la hx bd ky mo ne mq le mr nf mt li mu ng mw ll mx nh mz lo na ni nc lr nd bi translated">使用手势排除API</h1><p id="0738" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在我们之前的<a class="ae hu" rel="noopener" href="/androiddevelopers/gesture-navigation-handling-visual-overlaps-4aed565c134c">博客文章</a>中，我们提到“<em class="ly">应用能够排除屏幕</em>某些部分的系统手势”。应用程序这样做的方式是通过系统手势排除API，这是Android 10中的新功能。</p><p id="1b04" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">系统提供了两种不同的功能来排除区域:<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.html#setSystemGestureExclusionRects(java.util.List%3Candroid.graphics.Rect%3E)" rel="noopener ugc nofollow" target="_blank">View.setSystemGestureExclusionRects()</a></code>和<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/Window.html#setSystemGestureExclusionRects(java.util.List%3Candroid.graphics.Rect%3E)" rel="noopener ugc nofollow" target="_blank">Window.setSystemGestureExclusionRects()</a></code>。你使用哪个取决于你的应用:如果你使用Android <code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.html" rel="noopener ugc nofollow" target="_blank">View</a></code>，系统更喜欢view API，否则使用<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/Window.html" rel="noopener ugc nofollow" target="_blank">Window</a></code> API。</p><p id="7619" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这两个API之间的关键区别在于<a class="ae hu" href="https://developer.android.com/reference/android/view/Window.html#setSystemGestureExclusionRects(java.util.List%3Candroid.graphics.Rect%3E)" rel="noopener ugc nofollow" target="_blank">窗口API </a>期望任何矩形都在窗口坐标空间中。如果使用视图，通常会在视图的坐标空间中工作。<a class="ae hu" href="https://developer.android.com/reference/android/view/View.html#setSystemGestureExclusionRects(java.util.List%3Candroid.graphics.Rect%3E)" rel="noopener ugc nofollow" target="_blank">视图API </a>负责坐标空间之间的转换，这意味着您只需要考虑视图内容。</p><p id="c91a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看一个例子。我们将再次使用我们的音乐播放器的例子，它是<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBar</a></code>横跨整个屏幕宽度。在上一节中，我们修复了触发home手势的<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBar</a></code>，但是我们仍然需要考虑左右手势区域。</p><p id="933d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们来看看当用户试图在<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBar</a></code>‘thumb’(圆形拖拽器)位于其中一个边缘附近时拖动歌曲会发生什么:</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/56b908534e1a83ba59e777ae48ea3c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n_Y8frWX0FKBrGDx"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Demo showing the SeekBar conflicting with the back gesture area</figcaption></figure><p id="6b2f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于拇指在右手势区下方，系统认为用户是在打手势后退，所以显示后退箭头。这对用户来说是令人困惑的，因为他们可能并不打算真的回去。我们可以通过使用上面提到的手势排除API来排除拇指的边界，从而解决这个问题。</p><p id="81d5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">手势排除API通常从两个地方调用:<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.html#onLayout(boolean,%20int,%20int,%20int,%20int)" rel="noopener ugc nofollow" target="_blank">onLayout()</a></code>当您的视图被布局时，和<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.html#onDraw(android.graphics.Canvas)" rel="noopener ugc nofollow" target="_blank">onDraw()</a></code>当您的视图被绘制时。您的视图传入一个<code class="du ko kp kq kr b">List&lt;Rect&gt;</code>，包含所有应该被排除的矩形。如前所述，这些矩形需要在视图自己的坐标系中。</p><p id="dbb8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通常你会创建一个类似的函数，从<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.html#onLayout(boolean,%20int,%20int,%20int,%20int)" rel="noopener ugc nofollow" target="_blank">onLayout()</a></code>和/或<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.html#onDraw(android.graphics.Canvas)" rel="noopener ugc nofollow" target="_blank">onDraw()</a></code>中调用:</p><figure class="kt ku kv kw fd hj"><div class="bz dy l di"><div class="nl nm l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">A full example can be found <a class="ae hu" href="https://gist.github.com/chrisbanes/4e613a76ebc6a2d3e64d3eee911e1e7d" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure><p id="57a0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦我们添加了这个，边缘附近的擦洗工作预期:</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/e3cd22443f89f443c4029a768691bac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5hV-t28gRMtz6fJt"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Demo showing the SeekBar working with the back gesture area</figcaption></figure><blockquote class="no np nq"><p id="2e24" class="iu iv ly iw b ix iy iz ja jb jc jd je nr jg jh ji ns jk jl jm nt jo jp jq jr ha bi translated">请注意上面的例子。<code class="du ko kp kq kr b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/SeekBar.html" rel="noopener ugc nofollow" target="_blank">SeekBar</a></code>实际上在Android 10中已经自动为你做到了这一点，所以没有必要自己去做。这只是作为一个例子，向您展示大致的模式。</p></blockquote><h2 id="5c91" class="kz la hx bd ky lb lc ld le lf lg lh li jf lj lk ll jj lm ln lo jn lp lq lr ls bi translated">限制</h2><p id="2f8d" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">虽然手势排除API似乎是解决所有手势冲突的完美解决方案，但实际上并非如此。通过使用手势排除API，您声明您的应用程序手势比返回的系统动作更重要。这是一个强有力的声明，这就是为什么这个API意味着当你不能做任何其他事情时的逃生出口。</p><blockquote class="nu"><p id="e084" class="nv nw hx bd nx ny nz oa ob oc od jr dx translated">通过使用手势排除API，您声明您的应用程序手势比返回的系统动作更重要</p></blockquote><p id="d394" class="pw-post-body-paragraph iu iv hx iw b ix oe iz ja jb of jd je jf og jh ji jj oh jl jm jn oi jp jq jr ha bi translated">由于API支持的行为对用户来说是破坏性的，系统限制了它的使用方式:应用程序每条边最多只能排除<strong class="iw hy"> 200dp </strong>。</p><p id="b3d7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当开发人员听到这个问题时，他们通常会问:</p><p id="9eb3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">为什么有限制？希望上面的解释能给你一点提示。我们认为用户能够持续地从边缘滑动返回是非常重要的。在整个设备上保持一致，而不仅仅是一个应用程序。这个限制可能看起来很严格，但只需要一个应用程序就可以排除屏幕的整个边缘来迷惑用户，导致应用程序卸载或更激烈的事情。</strong></p><p id="0dce" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">换句话说，系统导航需要始终一致和可用。</p><p id="11cf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">为什么是200dp？200dp背后的想法非常简单。正如我们前面提到的，手势排除API旨在作为一个出口，因此限制是作为重要触摸目标的倍数来计算的。触摸目标的最小建议尺寸为<code class="du ko kp kq kr b">48dp</code>。4触摸目标× <code class="du ko kp kq kr b">48dp</code> = <code class="du ko kp kq kr b">192dp</code>。添加一些填充，我们得到了我们的值<code class="du ko kp kq kr b"><strong class="iw hy">200dp</strong></code>。</strong></p><p id="389a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">如果我请求排除超过200dp的边缘怎么办？</strong>系统将只接受您请求的最下面的200dp。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es oj"><img src="../Images/0b6c1428865a7757ba60440e5cb312b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0izXbV-0kXdQpFK9GavanA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">The system honors requests totalling 200dp in height, counted from the bottom edge</figcaption></figure><p id="abf3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">我的视图不在屏幕上，这算不算限制？</strong>否，系统只计算屏幕边界内排除的矩形。类似地，如果视图部分在屏幕上，则只计算所请求矩形的可见部分。</p></div><div class="ab cl kh ki go kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="ha hb hc hd he"><h1 id="f378" class="mn la hx bd ky mo ne mq le mr nf mt li mu ng mw ll mx nh mz lo na ni nc lr nd bi translated">沉浸在下一篇文章中</h1><p id="7ab8" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">您可能已经到了这里，并且想知道为什么我们没有覆盖流程图的右侧🤔。这些解决方案专门针对需要在整个屏幕上绘制的应用程序。我们将在下一篇博文中讨论这些问题，这篇博文已经发布了👇</p><div class="hg hh ez fb hi js"><a rel="noopener follow" target="_blank" href="/androiddevelopers/gesture-navigation-immersive-modes-43f2d37a925d"><div class="jt ab dw"><div class="ju ab jv cl cj jw"><h2 class="bd hy fi z dy jx ea eb jy ed ef hw bi translated">手势导航:沉浸式模式</h2><div class="jz l"><h3 class="bd b fi z dy jx ea eb jy ed ef dx translated">在这个关于手势导航的博客系列的第三篇文章中，我们讨论了如何处理手势冲突…</h3></div><div class="ka l"><p class="bd b fp z dy jx ea eb jy ed ef dx translated">medium.com</p></div></div><div class="kb l"><div class="ok l kd ke kf kb kg ho js"/></div></div></a></div></div></div>    
</body>
</html>