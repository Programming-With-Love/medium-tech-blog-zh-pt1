<html>
<head>
<title>Angular — Testing Guide (v4+)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度—测试指南(v4+)</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/angular-2-testing-guide-a485b6cb1ef0?source=collection_archive---------0-----------------------#2016-12-05">https://medium.com/google-developer-experts/angular-2-testing-guide-a485b6cb1ef0?source=collection_archive---------0-----------------------#2016-12-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="493a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用TestBed、fixtures、async和fakeAsync/tick的九个易于理解的示例。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/a777f90602e08b2079df40dc60d20dd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQbjiuda3WR25tWt1omj_Q.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx"><a class="ae js" href="http://www.syedrezaali.com/#/fluidscapes/" rel="noopener ugc nofollow" target="_blank">Fluidscapes</a> (Reza Ali)</figcaption></figure><p id="5ac4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我们想涵盖最常见的单元测试，如:组件、服务、Http和管道；还包括一些不太为人所知的领域，如:指令、路由器或可观察对象。我们将提供设计的示例，以便您可以使用它们作为快速参考。不要错过<a class="ae js" href="#8ea4" rel="noopener ugc nofollow"> <strong class="ig hi">测试清单</strong> </a>来帮助你创建你自己的测试。</p><p id="9b35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从RC到final，测试已经改进了很多，在迁移到NgModule之后甚至更多。Angular核心团队努力减少样板文件，不仅能够使用Jasmine，还能够使用其他测试框架，如Mocha。</p><p id="84c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了从测试中获得最佳效果，您应该了解一些新的API。我们将涵盖:</p><ul class=""><li id="b77d" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated"><strong class="ig hi">茉莉</strong>简介:<a class="ae js" href="#b343" rel="noopener ugc nofollow">套件</a>、<a class="ae js" href="#b343" rel="noopener ugc nofollow">规格</a>、<a class="ae js" href="#b343" rel="noopener ugc nofollow">期望</a>和<a class="ae js" href="#b343" rel="noopener ugc nofollow">匹配器</a>。</li><li id="1452" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">角度测试</strong> : <a class="ae js" href="#e122" rel="noopener ugc nofollow">设置</a>、<a class="ae js" href="#4625" rel="noopener ugc nofollow">依赖注入</a>和<a class="ae js" href="#8ea4" rel="noopener ugc nofollow">测试检查表</a>。</li><li id="1383" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">测试实用程序</strong> : <a class="ae js" href="#4625" rel="noopener ugc nofollow">测试床</a>，<a class="ae js" href="#4625" rel="noopener ugc nofollow">注入</a>，<a class="ae js" href="#8d61" rel="noopener ugc nofollow">夹具</a>，<a class="ae js" href="#4625" rel="noopener ugc nofollow">异步</a>，<a class="ae js" href="#6134" rel="noopener ugc nofollow"> fakeAsync/tick </a>和jasmine.done。</li><li id="8ce2" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">测试实例</strong> : <a class="ae js" href="#8d61" rel="noopener ugc nofollow">组件</a>，<a class="ae js" href="#d889" rel="noopener ugc nofollow">服务</a>，<a class="ae js" href="#b1fc" rel="noopener ugc nofollow"> Http </a>和<a class="ae js" href="#f7c7" rel="noopener ugc nofollow"> MockBackend </a>，<a class="ae js" href="#6134" rel="noopener ugc nofollow"> Directives </a>，<a class="ae js" href="#2626" rel="noopener ugc nofollow"> Pipes </a>，<a class="ae js" href="#97c2" rel="noopener ugc nofollow"> Routes </a>，<a class="ae js" href="#9fa4" rel="noopener ugc nofollow"> Observables </a>和<a class="ae js" href="#3882" rel="noopener ugc nofollow"> EventEmitter </a>。</li></ul><p id="6a70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要测试所有的<strong class="ig hi"> 26规格</strong>或更改代码，可以使用这个<a class="ae js" href="https://plnkr.co/edit/jm6T17qPbzM8abmRMckw?p=preview" rel="noopener ugc nofollow" target="_blank"> Plunker </a>。</p><div class="kh ki ez fb kj kk"><a href="http://slides.com/gerardsans/ng-stockholm-testing-recipes" rel="noopener  ugc nofollow" target="_blank"><div class="kl ab dw"><div class="km ab kn cl cj ko"><h2 class="bd hi fi z dy kp ea eb kq ed ef hg bi translated">Gerard Sans的角度测试方法和最佳实践(v2+)</h2><div class="kr l"><h3 class="bd b fi z dy kp ea eb kq ed ef dx translated">在本次演讲中，我们将介绍开发坚如磐石的角度应用时最常见的测试场景…</h3></div><div class="ks l"><p class="bd b fp z dy kp ea eb kq ed ef dx translated">slides.com</p></div></div><div class="kt l"><div class="ku l kv kw kx kt ky jm kk"/></div></div></a></div><p id="6bc7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<a class="ae js" href="https://twitter.com/intent/user?screen_name=gerardsans" rel="noopener ugc nofollow" target="_blank"> @gerardsans </a>的我的订阅中找到最新的角度内容。</p><blockquote class="kz"><p id="8ba7" class="la lb hh bd lc ld le lf lg lh li jb dx translated">我们使用了<a class="ae js" href="http://jasmine.github.io/" rel="noopener ugc nofollow" target="_blank">茉莉</a>，但是既然Angular final你也可以使用其他测试框架，比如<a class="ae js" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>。</p></blockquote><h1 id="b343" class="lj lk hh bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">茉莉简介</h1><p id="5645" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated">Jasmine是来自<a class="ae js" href="http://pivotal.io/labs" rel="noopener ugc nofollow" target="_blank"> Pivotal Labs </a>的开源测试框架，它使用行为驱动的符号，带来流畅和改进的测试体验。</p><h2 id="e924" class="mm lk hh bd ll mn mo mp lp mq mr ms lt ip mt mu lx it mv mw mb ix mx my mf mz bi translated">主要概念</h2><ul class=""><li id="dba7" class="jt ju hh ig b ih mh il mi ip na it nb ix nc jb jy jz ka kb bi translated">Suites — <strong class="ig hi"> <em class="nd"> describe(string，function)</em></strong><em class="nd"/>functions，取一个标题和一个包含一个或多个规格的函数。</li><li id="5187" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">Specs — <strong class="ig hi"> <em class="nd"> it(string，function) </em> </strong> functions，取一个标题和一个包含一个或多个期望的函数。</li><li id="d5f0" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">期望——是评估为<em class="nd">真</em>或<em class="nd">假</em>的断言。基本语法为<strong class="ig hi"> <em class="nd"> expect(实际)。</em> </strong></li><li id="6b0c" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">匹配器—是通用断言的预定义助手。例如:<strong class="ig hi"> <em class="nd"> toBe(预期)</em></strong><strong class="ig hi"><em class="nd">to equal(预期)</em> </strong>。点击查看完整列表<a class="ae js" href="https://github.com/JamieMason/Jasmine-Matchers" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><blockquote class="ne nf ng"><p id="a274" class="ie if nd ig b ih ii ij ik il im in io nh iq ir is ni iu iv iw nj iy iz ja jb ha bi translated">注意<strong class="ig hi">。toEqual() </strong>做深度比较而<strong class="ig hi">。toBe() </strong>只是一个引用等式。</p></blockquote><h2 id="51fb" class="mm lk hh bd ll mn mo mp lp mq mr ms lt ip mt mu lx it mv mw mb ix mx my mf mz bi translated">安装和拆卸</h2><p id="7ca2" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated">Jasmine提供了四个处理程序来添加我们的安装和拆卸代码:每个 之前的<strong class="ig hi"><em class="nd">；每个规格执行一次的</em> </strong>之后的<strong class="ig hi">；每个套件执行一次的<strong class="ig hi"> <em class="nd">之前的</em> </strong>、<strong class="ig hi"> <em class="nd">之后的</em> </strong>。</strong></p><blockquote class="ne nf ng"><p id="a9b0" class="ie if nd ig b ih ii ij ik il im in io nh iq ir is ni iu iv iw nj iy iz ja jb ha bi translated">使用beforeEach和afterEach在每个规范之前和之后进行更改</p></blockquote><p id="e5f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的规范中避免代码重复的一个好方法是在设置中重构重复的代码。</p><h1 id="6458" class="lj lk hh bd ll lm ln lo lp lq lr ls lt lu nk lw lx ly nl ma mb mc nm me mf mg bi translated">角度测试</h1><h2 id="e122" class="mm lk hh bd ll mn mo mp lp mq mr ms lt ip mt mu lx it mv mw mb ix mx my mf mz bi translated">测试设置</h2><p id="f231" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated">设置环境的选项很少。你可以使用来自<a class="ae js" href="https://github.com/pivotal/jasmine/releases" rel="noopener ugc nofollow" target="_blank">独立发行版</a>的Jasmine<em class="nd">SpecRunner.html</em>来开始或创建你自己的。你也可以把它和一个类似<a class="ae js" href="https://karma-runner.github.io" rel="noopener ugc nofollow" target="_blank"> Karma </a>的测试者整合在一起。我们不会涵盖所有组合，因为我们对实际测试更感兴趣。</p><blockquote class="ne nf ng"><p id="d14e" class="ie if nd ig b ih ii ij ik il im in io nh iq ir is ni iu iv iw nj iy iz ja jb ha bi translated">此设置仅供参考，仅适用于Plunker。</p></blockquote><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="138e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们加载Jasmine依赖项，后面是Angular依赖项。我们正在使用一个<strong class="ig hi"> System.js </strong>和<strong class="ig hi"> TypeScript </strong>设置。我们使用<em class="nd"> Promise.all() </em>一次性加载我们的规范，一旦所有规范都可用，我们通过调用<strong class="ig hi"> onload </strong>手动触发Jasmine测试运行程序。</p><h2 id="4625" class="mm lk hh bd ll mn mo mp lp mq mr ms lt ip mt mu lx it mv mw mb ix mx my mf mz bi translated">依赖注入</h2><p id="c34a" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated"><strong class="ig hi"> TestBed </strong>，类似于@NgModule帮助我们建立测试的依赖关系。我们调用<strong class="ig hi">testbed . configuretestingmodule</strong>传递我们的配置。此信息将用于解决任何依赖关系。下面我们可以看到一个例子:</p><pre class="jd je jf jg fd np nq nr ns aw nt bi"><span id="b882" class="mm lk hh nq b fi nu nv l nw nx">@NgModule({<br/>  declarations: [ <strong class="nq hi">ComponentToTest</strong> ] <br/>  providers: [ <strong class="nq hi">MyService</strong> ]<br/>}) <br/>class AppModule { }</span><span id="6f9e" class="mm lk hh nq b fi ny nv l nw nx">TestBed.configureTestingModule({<br/>  declarations: [ <strong class="nq hi">ComponentToTest</strong> ],<br/>  providers: [ <strong class="nq hi">MyService</strong> ]  <br/>});</span><span id="2ceb" class="mm lk hh nq b fi ny nv l nw nx">//get instance from TestBed (root injector)<br/>let service = TestBed.get(<strong class="nq hi">MyService</strong>);</span></pre><p id="760a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注入</strong>，允许我们在测试层获得依赖关系。</p><pre class="jd je jf jg fd np nq nr ns aw nt bi"><span id="eda9" class="mm lk hh nq b fi nu nv l nw nx">it('should return ...', <strong class="nq hi">inject</strong>([MyService], service =&gt; { <br/>  service.foo();<br/>}));</span></pre><p id="d6c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">组件注入器</strong>，允许我们在组件级别得到一个依赖。</p><pre class="jd je jf jg fd np nq nr ns aw nt bi"><span id="8f15" class="mm lk hh nq b fi nu nv l nw nx">@Component({ <br/>  providers: [ <strong class="nq hi">MyService</strong> ] <br/>}) <br/>class <strong class="nq hi">ComponentToTest</strong> { }</span><span id="5e2f" class="mm lk hh nq b fi ny nv l nw nx">let fixture = TestBed.createComponent(<strong class="nq hi">ComponentToTest</strong>);<br/>let service = fixture.debugElement.injector.get(<strong class="nq hi">MyService</strong>);</span></pre><p id="c5f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于在组件级定义的依赖关系，我们需要使用如上所示的组件注入器。TestBed.get或inject不起作用。</p><p id="bd95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看如何将<strong class="ig hi"> TestBed </strong>与<em class="nd">languageservice</em>组件一起使用:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="5d1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们用<strong class="ig hi">testbed . configuretestingmodule</strong>加载测试所需的依赖项。然后在我们的规范中，我们使用<a class="ae js" href="https://angular.io/docs/ts/latest/api/testing/inject-function.html" rel="noopener ugc nofollow" target="_blank"> <em class="nd">注入</em> </a>来自动实例化每个依赖项。</p><p id="c3de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们现在可以重构<em class="nd">注入</em>，这样我们就不会为每个规范重复它。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="76d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看两个实例化组件的例子。第一个例子是同步的，它创建了一个fixture，包含一个实例<strong class="ig hi"> MyTestComponent </strong>。</p><pre class="jd je jf jg fd np nq nr ns aw nt bi"><span id="ff53" class="mm lk hh nq b fi nu nv l nw nx">// synchronous<br/>  beforeEach(() =&gt; {<br/>    fixture = TestBed.createComponent(<strong class="nq hi">MyTestComponent</strong>);<br/>  });</span></pre><p id="5b75" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个例子是异步的<strong class="ig hi">，</strong>因为使用外部模板和css，需要XHR调用。</p><pre class="jd je jf jg fd np nq nr ns aw nt bi"><span id="acca" class="mm lk hh nq b fi nu nv l nw nx">// asynchronous <br/>  beforeEach(<strong class="nq hi">async</strong>(() =&gt; {<br/>    TestBed.configureTestingModule({<br/>      declarations: [ <strong class="nq hi">MyTestComponent</strong> ],<br/>    }).<strong class="nq hi">compileComponents</strong>(); // compile external templates and css<br/>  }));</span></pre><p id="e113" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当依赖关系涉及异步处理时，我们可以使用<a class="ae js" href="https://angular.io/docs/ts/latest/api/core/testing/index/async-function.html" rel="noopener ugc nofollow" target="_blank"><em class="nd">async</em></a><em class="nd"/>。这将在内部创建一个区域，并处理任何异步处理。</p><blockquote class="ne nf ng"><p id="34bc" class="ie if nd ig b ih ii ij ik il im in io nh iq ir is ni iu iv iw nj iy iz ja jb ha bi translated">根据您的构建设置，您的模板和css可能都是内联的，因此您可以安全地使用同步方法</p></blockquote><h2 id="8ea4" class="mm lk hh bd ll mn mo mp lp mq mr ms lt ip mt mu lx it mv mw mb ix mx my mf mz bi translated">测试清单</h2><ul class=""><li id="47b3" class="jt ju hh ig b ih mh il mi ip na it nb ix nc jb jy jz ka kb bi translated"><strong class="ig hi">哪种测试</strong>？<a class="ae js" href="https://angular.io/docs/ts/latest/guide/testing.html#!#isolated-unit-tests" rel="noopener ugc nofollow" target="_blank">孤立</a>、<a class="ae js" href="https://angular.io/docs/ts/latest/guide/testing.html#!#shallow-component-test" rel="noopener ugc nofollow" target="_blank">浅</a>或<a class="ae js" href="https://vsavkin.com/three-ways-to-test-angular-2-components-dcea8e90bd8d" rel="noopener ugc nofollow" target="_blank">综合测试</a>。</li><li id="6b2b" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">我可以使用模拟、存根或间谍吗？依赖关系应该被他们自己的测试所覆盖。使用它们可以提高你的测试，而不会失去效力。</li><li id="e8d6" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">同步还是异步</strong>？你的测试进行异步调用了吗？使用XHR、承诺、可观测量等。组件使用的是TemplateUrl还是styleUrls还是inline？确保您使用的是相应的API。</li></ul><p id="7e41" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看如何测试应用程序的不同构件。为了简洁起见，我们将跳过所有必需的<strong class="ig hi"> <em class="nd">导入</em> </strong>。我们在必要时添加了注释。他们可以在这里找到<a class="ae js" href="https://plnkr.co/edit/jm6T17qPbzM8abmRMckw?p=preview" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="35bc" class="lj lk hh bd ll lm ln lo lp lq lr ls lt lu nk lw lx ly nl ma mb mc nm me mf mg bi translated">测试示例</h1><h2 id="8d61" class="mm lk hh bd ll mn mo mp lp mq mr ms lt ip mt mu lx it mv mw mb ix mx my mf mz bi translated">测试组件</h2><p id="8e15" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated">让我们来看一个简单的组件，它使用一个<a class="ae js" href="https://angular.io/docs/ts/latest/api/core/Input-var.html" rel="noopener ugc nofollow" target="_blank"> @ <em class="nd"> Input() </em> </a>属性来呈现一个<em class="nd">问候</em>消息。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="7d31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了测试该组件，我们将使用一个通用设置，该设置使用<em class="nd">试验台</em>。</p><blockquote class="kz"><p id="f04e" class="la lb hh bd lc ld le lf lg lh li jb dx translated">使用TestBed加载相应的依赖项，以便它们在测试期间可用</p></blockquote><p id="6e08" class="pw-post-body-paragraph ie if hh ig b ih nz ij ik il oa in io ip ob ir is it oc iv iw ix od iz ja jb ha bi translated">通常的做法是在每个之前使用<em class="nd">来重构我们的测试。通过这样做，我们避免了为每个测试<em class="nd">重复一些代码，比如<em class="nd">注入</em>。这也将简化我们的规格。</em></em></p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="50d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用<em class="nd">testbed . create component</em>来创建我们的<em class="nd"> Greeter </em>组件的一个实例。组件实例可在<a class="ae js" href="https://github.com/angular/angular/blob/a7e9bc97f6a19a2b47b962bd021cb91346a44baa/modules/angular2/src/testing/test_component_builder.ts#L31" rel="noopener ugc nofollow" target="_blank">夹具</a>中访问。这是它的主要API:</p><pre class="jd je jf jg fd np nq nr ns aw nt bi"><span id="9ecc" class="mm lk hh nq b fi nu nv l nw nx">abstract class <a class="ae js" href="https://github.com/angular/angular/blob/a7e9bc97f6a19a2b47b962bd021cb91346a44baa/modules/angular2/src/testing/test_component_builder.ts#L31" rel="noopener ugc nofollow" target="_blank">ComponentFixture</a> {<br/>  debugElement;       // test helper <br/>  componentInstance;  // to access properties and methods<br/>  nativeElement;      // to access DOM element<br/>  detectChanges();    // trigger component change detection<br/>}</span></pre><p id="3698" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用<em class="nd"> name </em>属性设置一个值，使用<strong class="ig hi"> detectChanges </strong>触发变化检测，并使用<strong class="ig hi"> whenStable </strong>检查所有异步调用结束时的预期结果。为了访问呈现的文本，我们使用了两种不同的API，通过CSS选择器进行过滤(第22–23行)。</p><blockquote class="kz"><p id="bedc" class="la lb hh bd lc ld le lf lg lh li jb dx translated">debugElement的其他查询有:query(by . all())query(by . directive(my directive))</p></blockquote><h2 id="d889" class="mm lk hh bd ll mn oe mp lp mq of ms lt ip og mu lx it oh mw mb ix oi my mf mz bi translated">测试服务</h2><p id="6a90" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated"><em class="nd"> LanguagesService </em>只有一个方法返回应用程序可用语言的数组。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="1258" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">类似于我们之前的例子，我们使用<em class="nd"> beforeEach实例化服务。</em>正如我们所说，这是<em class="nd"> </em>即使我们只有一个规格，这也是一个很好的实践。在这种情况下，我们正在检查每种语言和总计数。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><h2 id="b1fc" class="mm lk hh bd ll mn mo mp lp mq mr ms lt ip mt mu lx it mv mw mb ix mx my mf mz bi translated">使用Http进行测试</h2><p id="3e34" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated">我们通常不希望在测试过程中进行HTTP调用，但是我们将显示它作为参考。我们已经将最初的服务<em class="nd"> LanguageService </em>替换为<em class="nd"> LanguageServiceHttp。</em></p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="c552" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，它使用<em class="nd"> http.get() </em>来读取一个JSON文件。然后我们使用<a class="ae js" href="https://github.com/ReactiveX/RxJS/blob/master/src/operator/map.ts" rel="noopener ugc nofollow" target="_blank"><em class="nd">observable . map()</em></a><em class="nd"/>使用<em class="nd"> json()将响应转换成最终结果。</em></p><p id="a62c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的测试看起来与前一个非常相似。主要的区别是由于订阅，我们使用了异步测试，就像我们对组件所做的那样。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><blockquote class="ne nf ng"><p id="63e0" class="ie if nd ig b ih ii ij ik il im in io nh iq ir is ni iu iv iw nj iy iz ja jb ha bi translated">注意，如果涉及XHR呼叫，您不能使用<em class="hh"> fakeAsync </em>。这是由<a class="ae js" href="https://github.com/angular/angular/issues/8280" rel="noopener ugc nofollow" target="_blank">设计的</a>。</p></blockquote><p id="a4e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">返回一个我们可以订阅的可观察值。我们将在后面更详细地讨论可观察到的现象。</p><h2 id="f7c7" class="mm lk hh bd ll mn mo mp lp mq mr ms lt ip mt mu lx it mv mw mb ix mx my mf mz bi translated">使用模拟后端进行测试</h2><p id="e2f3" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated">更明智的方法是用一个<em class="nd"> MockBackend </em>代替HTTP调用。为了做到这一点，我们可以使用<em class="nd">提供</em>(第10行)<em class="nd">。这个<em class="nd"/></em></p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="a609" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的测试中，我们构建了模拟响应(第23–25行),所以当我们最终调用我们的服务时，它会得到预期的结果。</p><blockquote class="ne nf ng"><p id="f4a9" class="ie if nd ig b ih ii ij ik il im in io nh iq ir is ni iu iv iw nj iy iz ja jb ha bi translated">注意:我们不需要异步，因为MockBackend的行为是同步的。感谢<a class="oj ok ge" href="https://medium.com/u/32a0d1331713?source=post_page-----a485b6cb1ef0--------------------------------" rel="noopener" target="_blank">帕斯卡·普雷希特·ʕ•̫͡•ʔ</a>指出这一点。</p></blockquote><h2 id="6134" class="mm lk hh bd ll mn mo mp lp mq mr ms lt ip mt mu lx it mv mw mb ix mx my mf mz bi translated">测试指令</h2><p id="e733" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated">Angular中的指令是一种特殊类型的组件，通常没有附带视图。我们将使用一个<a class="ae js" href="https://angular.io/docs/ts/latest/guide/attribute-directives.html" rel="noopener ugc nofollow" target="_blank">属性指令</a>、<em class="nd"> logClicks、</em>来记录我们在<strong class="ig hi">、<em class="nd">主机元素</em>、</strong>上点击了多少次，这样您就可以理解了。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="8f5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了测试这个指令，我们决定创建一个<em class="nd">容器</em>组件。我们将对它进行设置，使它充当我们的主机，再现由我们的指令发出的事件。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="9e23" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在每个之前使用<em class="nd">来将创建组件的逻辑与测试分开。该器件现在可用于所有规格。</em></p><p id="40ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了触发容器上的<strong class="ig hi">点击</strong>，我们使用了DOM API(推荐)。我们也可以使用<em class="nd">fixture . debug element . triggereventhandler(' click ')。</em></p><p id="b658" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个测试中，我们使用了<strong class="ig hi"> fakeAsync </strong>和<strong class="ig hi"> tick </strong>。使用<strong class="ig hi"> fakeAsync </strong>所有的异步处理将被暂停，直到我们调用<strong class="ig hi"> tick </strong>。这给了我们更大的控制权，并避免了不得不求助于嵌套的承诺或可观察的块。</p><blockquote class="kz"><p id="a383" class="la lb hh bd lc ld le lf lg lh li jb dx translated">使用fakeAsync/tick我们可以更好地控制异步代码，尽管它不能用于XHR。</p></blockquote><h2 id="2626" class="mm lk hh bd ll mn oe mp lp mq of ms lt ip og mu lx it oh mw mb ix oi my mf mz bi translated">测试管道</h2><p id="44ac" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated">管道是可以将输入数据转换成用户可读格式的函数。我们将使用标准的<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase" rel="noopener ugc nofollow" target="_blank"><em class="nd">string . toupper case</em></a><em class="nd">()</em>来编写一个自定义的大写管道<em class="nd"/>。这只是为了简单起见作为有角的有自己的<a class="ae js" href="https://angular.io/docs/ts/latest/api/common/UpperCasePipe-class.html" rel="noopener ugc nofollow" target="_blank"><em class="nd"/></a><em class="nd"/>实现。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="dc58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">管道只是可以被注入的普通类，所以我们可以使用<em class="nd"> inject </em>非常容易地设置我们的规范。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="e0ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了测试我们的管道，我们检查了常见的情况:它应该与空字符串一起工作，它应该大写，最后，当不与字符串一起使用时，它抛出。</p><blockquote class="ne nf ng"><p id="76c9" class="ie if nd ig b ih ii ij ik il im in io nh iq ir is ni iu iv iw nj iy iz ja jb ha bi translated">注意:我们使用了一个箭头函数来捕获<em class="hh"> expect </em>中的异常</p></blockquote><h2 id="97c2" class="mm lk hh bd ll mn mo mp lp mq mr ms lt ip mt mu lx it mv mw mb ix mx my mf mz bi translated">测试路线</h2><p id="ff80" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated">路线有时会被遗漏，但这通常被视为复式簿记的良好做法。在我们的示例中，我们将使用一个简单的路由配置，其中只有几条路由和一条指向home的路由。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="5467" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果没有提供重定向到归属的初始路由，则第一个路由定义捕获初始路由(第14行)。第二个实例化了<strong class="ig hi"> Home </strong>组件(第15行)；最后一个捕获所有剩余的路由，并将它们重定向到home(第16行)。我们的测试将使用这些路线来检验我们的期望。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="fe70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们导入了<strong class="ig hi">routertestingmodule . with routes(routes)</strong>，用我们测试的路由初始化<strong class="ig hi"> Router </strong>实例(第6行)。在上面我们测试的代码中，我们可以使用<strong class="ig hi"> async </strong>、<strong class="ig hi"> asyncFake/tick </strong>和<strong class="ig hi"> done </strong>导航到home。注意我们如何使用<strong class="ig hi"> asyncFake </strong>编写更好的测试，因为我们不必嵌套承诺处理。</p><blockquote class="kz"><p id="2047" class="la lb hh bd lc ld le lf lg lh li jb dx translated">fakeAsync/tick非常适合不涉及XHR的复杂异步测试</p></blockquote><h2 id="9fa4" class="mm lk hh bd ll mn oe mp lp mq of ms lt ip og mu lx it oh mw mb ix oi my mf mz bi translated">测试可观测量</h2><p id="d28a" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated">可观测量非常适合处理异步任务。它们被用在Angular中的几个地方，像<em class="nd"> Http </em>，表单控件，验证或者在<em class="nd"> EventEmitter </em>后面。我们将使用下面的<em class="nd">观察值</em>来展示我们如何测试它们的行为。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="cdc7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们创建了一个<em class="nd">可观察的</em>，它发出1，2，3并完成。为了测试它，我们在subscribe上设置了next、error和complete回调。由于下一次回调将被调用几次，我们必须动态地设置我们的期望。</p><h2 id="3882" class="mm lk hh bd ll mn mo mp lp mq mr ms lt ip mt mu lx it mv mw mb ix mx my mf mz bi translated">测试事件发射器</h2><p id="b827" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated"><strong class="ig hi">事件发射器</strong>用于Angular组件之间的事件通信。我们创建了一个计数器组件，<strong class="ig hi"> Counter </strong>，<em class="nd"> </em>，它允许我们增加或减少初始值0。每次我们这样做的时候，新的值将会使用一个<em class="nd"> EventEmitter </em>在<em class="nd">改变</em>时被公开。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="f8c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">设置将非常类似于Observables。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="nn no l"/></div></figure><p id="4fe2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，我们检查是否可以使用<em class="nd"> EventEmitter </em>上的subscribe<strong class="ig hi">增加</strong>或<strong class="ig hi">减少</strong>，因为它公开了一个<em class="nd">可观察对象</em>。我们通过调用change方法触发不同的值，并在下一次回调中检查我们的期望。</p><p id="771c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在这篇文章中找到所有的测试，更多的测试可以在演示中找到。</p><p id="7ebc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我只有这些了！感谢阅读！有什么问题吗？在<a class="ae js" href="https://twitter.com/intent/user?screen_name=gerardsans" rel="noopener ugc nofollow" target="_blank"> @gerardsans </a>给我发短信</p><h2 id="0f11" class="mm lk hh bd ll mn mo mp lp mq mr ms lt ip mt mu lx it mv mw mb ix mx my mf mz bi translated">想要更多吗？</h2><p id="e872" class="pw-post-body-paragraph ie if hh ig b ih mh ij ik il mi in io ip mj ir is it mk iv iw ix ml iz ja jb ha bi translated">如果您需要更多示例，请随时通过Gerard _ dot _ sans _ at _ Gmail _ dot _ com联系我，或者前往GitHub中的<a class="ae js" href="https://github.com/angular/angular/tree/e748adda2e7a1f6e302628d0d76b5c3d1e3fc196/modules/angular2/test" rel="noopener ugc nofollow" target="_blank">角度单元测试</a>！</p><div class="kh ki ez fb kj kk"><a href="http://www.meetup.com/AngularZone/" rel="noopener  ugc nofollow" target="_blank"><div class="kl ab dw"><div class="km ab kn cl cj ko"><h2 class="bd hi fi z dy kp ea eb kq ed ef hg bi translated">安古拉宗社区</h2><div class="kr l"><h3 class="bd b fi z dy kp ea eb kq ed ef dx translated">欢迎来到我们的社区。我们的激情是有棱角的。加入我们吧！🚀</h3></div></div><div class="kt l"><div class="ol l kv kw kx kt ky jm kk"/></div></div></a></div><h1 id="96fe" class="lj lk hh bd ll lm ln lo lp lq lr ls lt lu nk lw lx ly nl ma mb mc nm me mf mg bi translated">进一步阅读</h1><ul class=""><li id="6ad3" class="jt ju hh ig b ih mh il mi ip na it nb ix nc jb jy jz ka kb bi translated"><a class="ae js" href="https://angular.io/docs/ts/latest/guide/testing.html" rel="noopener ugc nofollow" target="_blank">测试</a>(正式文件)</li><li id="c518" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">角度应用的单元测试由<strong class="ig hi">vik ram subra manian</strong>(<a class="ae js" href="https://twitter.com/vikerman" rel="noopener ugc nofollow" target="_blank">@ viker man)</a>在<a class="ae js" href="https://ngeurope.org/" rel="noopener ugc nofollow" target="_blank"> ng-Europe </a>演讲。<a class="ae js" href="https://www.youtube.com/watch?v=dVtDnvTLaIo" rel="noopener ugc nofollow" target="_blank">视频</a> | <a class="ae js" href="https://docs.google.com/presentation/d/1fFxQvx2WHFPqR4piq0oWgKBuSMvrCwc1vfYggHlYEbQ/edit?usp=sharing" rel="noopener ugc nofollow" target="_blank">幻灯片</a></li><li id="c21e" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><a class="ae js" href="https://vsavkin.com/three-ways-to-test-angular-2-components-dcea8e90bd8d" rel="noopener ugc nofollow" target="_blank">三种测试角度组件的方法</a>作者<strong class="ig hi">维克托·萨维金</strong>(<a class="ae js" href="https://twitter.com/victorsavkin" rel="noopener ugc nofollow" target="_blank">@维克托·萨维金</a>)</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><a href="https://twitter.com/intent/user?screen_name=gerardsans"><div class="er es om"><img src="../Images/abefda0aa7864742686ec7f7fdffe2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1tQhWBuVOdzR7OAGvyd8Q.png"/></div></a></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es on"><img src="../Images/e7feb1af735b3fcdd1c800bfa8958065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNy0WABkeIpG8qsD3igD3w.png"/></div></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es oo"><img src="../Images/67b37e5d672384f0953563450fca0029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uNeEFxYiwJq8RfiDCsI-Xg.gif"/></div></div></figure></div></div>    
</body>
</html>