<html>
<head>
<title>Five Inconvenient Truths about REST: 3 — HTTP Response Codes ≠ “REST Response Codes”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于REST的五个不方便的真相:3 — HTTP响应代码≦“REST响应代码”</h1>
<blockquote>原文：<a href="https://medium.com/compendium/five-inconvenient-truths-about-rest-3-http-response-codes-rest-response-codes-9d48e4e1f1e6?source=collection_archive---------3-----------------------#2018-05-28">https://medium.com/compendium/five-inconvenient-truths-about-rest-3-http-response-codes-rest-response-codes-9d48e4e1f1e6?source=collection_archive---------3-----------------------#2018-05-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="9f92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我的上一篇文章中，我讨论了将HTTP动词作为REST动词重用的利弊。这样做的好处是，当你想学习REST的时候，你不必学习一套新的动词。缺点是HTTP动词并不总是符合REST服务的需求。HTTP响应代码也是如此:重用它们使您不必学习一组新的响应代码，但是缺点是不匹配，您必须在REST API中进行补偿。</p><p id="fb90" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们从最常见的HTTP响应代码开始。当你用浏览器上网时，你最常遇到的响应代码可能是<a class="ae jc" href="https://httpstatuses.com/200" rel="noopener ugc nofollow" target="_blank"> 200 OK </a>。通常你看不到它，因为它表明一切正常(就像你加载这个页面时一样)，因此它被你的浏览器隐藏了。人们可能更熟悉的一个响应代码是<a class="ae jc" href="https://httpstatuses.com/404" rel="noopener ugc nofollow" target="_blank"> 404 Not Found </a>，当你试图打开一个不存在的页面时(例如，因为你打错了它的URL)。在许多情况下，浏览器只是显示一个标准的消息，但是一些网站以创建一个带有一些艺术的特殊页面为荣，例如<a class="ae jc" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>的<a class="ae jc" href="https://github.com/404" rel="noopener ugc nofollow" target="_blank">页面没有找到</a>页面。</p><p id="d5eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当你看到HTTP响应代码的<a class="ae jc" href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" rel="noopener ugc nofollow" target="_blank">列表时，很容易变得不知所措。幸运的是，并不是所有的都经常使用，其中一个其实只是一个</a><a class="ae jc" href="https://httpstatuses.com/418" rel="noopener ugc nofollow" target="_blank">笑话</a>。但是如果您仔细看看这个列表，您会注意到许多HTTP响应代码根本与REST无关。以<a class="ae jc" href="https://httpstatuses.com/417" rel="noopener ugc nofollow" target="_blank"> 417 Expectation Failed </a>为例:我很难想象一个REST webservice应该用那个响应代码主动响应的情况。</p><p id="cffe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，REST webservices显式使用的响应代码集相当短。我会说，前面提到的200 OK和404 Not Found，以及<a class="ae jc" href="https://httpstatuses.com/401" rel="noopener ugc nofollow" target="_blank"> 401 Unauthorized </a>和<a class="ae jc" href="https://httpstatuses.com/403" rel="noopener ugc nofollow" target="_blank"> 403 Forbidden </a>将是最常见的。<a class="ae jc" href="https://httpstatuses.com/201" rel="noopener ugc nofollow" target="_blank"> 201 Created </a>应该在创建新资源时返回，但是初学者经常会犯错误，返回一个200 OK。同样的情况经常发生在<a class="ae jc" href="https://httpstatuses.com/202" rel="noopener ugc nofollow" target="_blank"> 202接受了</a>，而<a class="ae jc" href="https://httpstatuses.com/204" rel="noopener ugc nofollow" target="_blank"> 204没有内容</a>的情况下。</p><p id="5eaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当REST调用的有效载荷不符合XSD时，例如，由于语法问题，应该用<a class="ae jc" href="https://httpstatuses.com/400" rel="noopener ugc nofollow" target="_blank"> 400错误请求</a>响应拒绝该调用。通常，如果您选择了一个好的REST webservices框架或平台，这已经由基础设施解决了。但是如果有效载荷有语义问题呢？并不是对调用内容的所有约束都可以用XSD来表达，因此由REST接口中的XML验证来处理。</p><p id="f547" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设您有一个REST服务来创建一个Foo类型的新资源，在调用内容的某个地方，应该有一个对已经存在的Bar类型资源的引用。很明显，这个约束不能嵌入到XSD中，因为这样的话，每次创建或删除Bar资源时，它都必须被更新并传播到所有客户端。那么，当对Bar资源的引用存在且格式良好，但没有指向实际存在的Bar资源时，响应代码是什么呢？用400 Bad请求来响应是不正确的，因为消息的语法是好的。有人可能会认为404 Not Found可能是合适的，因为找不到Bar资源。然而，当找不到<em class="jd">请求的</em>资源，而不是有效载荷中引用的资源<em class="jd">之一时，应该使用404 Not Found。一个<a class="ae jc" href="https://httpstatuses.com/500" rel="noopener ugc nofollow" target="_blank"> 500内部服务器错误</a>也是不正确的，因为我们不是在处理一个内部服务器错误——我们实际上是在防止一个错误在以后发生。</em></p><p id="2d2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我所知道的最好的解决方案是使用响应代码<a class="ae jc" href="https://httpstatuses.com/422" rel="noopener ugc nofollow" target="_blank"> 422不可处理的实体</a>，用一个错误消息解释问题的原因。维基百科对响应代码的解释是，当“请求格式良好，但由于语义错误而无法执行”时，应该使用响应代码，这很好地概括了我们的情况。我使用422不可处理实体的其他情况包括无法或不应该在XSD中编码的非法值导致的错误(例如，不正确的邮政编码)，选择或资源的无效组合(例如，试图与两次相同的人注册婚姻)，或任何其他没有意义的事情(例如，试图将一个男人注册为孩子的亲生母亲)。</p><p id="2112" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦您开始使用REST webservices，您将很快发现应用程序业务逻辑的许多异常部分将在您的REST API中解析为422不可处理的实体。这有点讽刺，因为您最常处理的HTTP响应代码之一甚至不是最初的HTTP响应代码集的一部分，而是后来由HTTP的扩展<a class="ae jc" href="https://en.wikipedia.org/wiki/WebDAV" rel="noopener ugc nofollow" target="_blank"> WebDAV </a>添加的。但是更严重的是，您需要创建一个错误消息类型来解释到底哪里出错了。客户端必须检查该错误消息，以便决定下一步做什么。但是等一下，使用HTTP响应代码不是应该避免我们这样做吗，即创建我们自己的一组异常代码，并将它们作为响应的有效载荷发送给客户端？</p></div></div>    
</body>
</html>