<html>
<head>
<title>Demystifying Reactive Programming — The Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开反应式编程的神秘面纱——概述</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/demystifying-reactive-programming-the-overview-21c8173f7842?source=collection_archive---------0-----------------------#2021-08-10">https://medium.com/walmartglobaltech/demystifying-reactive-programming-the-overview-21c8173f7842?source=collection_archive---------0-----------------------#2021-08-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="6c36" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">回答什么、为什么、何时和如何？</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/a5d247c50f2e2dc00cb31fcb017bdee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*023H3qPcgPc47PgW3KkV6w.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Photo by <a class="ae jm" href="https://unsplash.com/@marvelous?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Marvin Meyer</a> on <a class="ae jm" href="https://unsplash.com/s/photos/technology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="8abf" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">“<strong class="ak">作为一家<strong class="ak">公司，</strong>的目标是拥有</strong>不仅是最好的，而且是传奇的客户服务。”—萨姆·沃尔顿</h2><p id="fe21" class="pw-post-body-paragraph kl km hh kn b ko kp ii kq kr ks il kt jy ku kv kw kc kx ky kz kg la lb lc ld ha bi translated">我们沃尔玛一直致力于提高服务质量，增强顾客体验。随着我们不断增长的客户群，为<strong class="kn hi">更好的性能</strong>和<strong class="kn hi">改进的UX </strong>构建快速和健壮的应用程序势在必行。这就是反应式编程发挥作用的地方。</p><p id="f96e" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated">让我们从回答这个问题开始——</p><h1 id="bd27" class="lj jo hh bd jp lk ll lm jt ln lo lp jx in lq io kb iq lr ir kf it ls iu kj lt bi translated">“什么是反应式编程”？</h1><blockquote class="lu lv lw"><p id="2923" class="kl km lx kn b ko le ii kq kr lf il kt ly lg kv kw lz lh ky kz ma li lb lc ld ha bi translated"><strong class="kn hi">反应式编程</strong>是一种声明式编程范例，关注异步数据流和变化的传播。</p></blockquote><p id="3b61" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated">嗯，这是一个充满术语的声明。让我们到引擎盖下了解更多。</p><h2 id="541e" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">异步</strong></h2><p id="f923" class="pw-post-body-paragraph kl km hh kn b ko kp ii kq kr ks il kt jy ku kv kw kc kx ky kz kg la lb lc ld ha bi translated">假设您的应用程序变得没有响应，因为您的主线程发出了一个对数据库的调用，现在在客户等待时被阻塞了。接下来呢？你的客户向你的竞争对手妥协并完成他们的工作。使用反应式方法，数据库调用不会阻塞调用线程，而是立即返回。该程序的结构是一个异步的事件流。简而言之，在开始一些后台工作来处理前一个任务之后，你立即转移到下一个任务。那就是被<strong class="kn hi">异步</strong>！</p><h2 id="35de" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">数据流</strong></h2><p id="f1d0" class="pw-post-body-paragraph kl km hh kn b ko kp ii kq kr ks il kt jy ku kv kw kc kx ky kz kg la lb lc ld ha bi translated">流对于反应式编程就像钱德勒·宾对于朋友一样。没错——<strong class="kn hi">主心骨！</strong>现在考虑一个水箱和一个连接的管道。这个容器保存数据(水)，因此与数据结构产生共鸣。然而，管道不是盛水而是输送水。<strong class="kn hi">数据流</strong>更像是一个应用于数据的方法管道。</p><h2 id="1d15" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">变化的传播</h2><p id="1329" class="pw-post-body-paragraph kl km hh kn b ko kp ii kq kr ks il kt jy ku kv kw kc kx ky kz kg la lb lc ld ha bi translated">重新考虑上面的例子。管道的另一端连接到什么？你——消费者。类似地，流式数据必须传播给<strong class="kn hi">消费者</strong>。这里的“更改”指的是通过流传递的数据的转换。这种改变或转换的数据由<strong class="kn hi">观察者</strong>消费，观察者<strong class="kn hi">订阅</strong>这种改变。</p><p id="f3ec" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated">反应式方法涉及4个接口:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mb"><img src="../Images/7658dfecb491f6b9c2b97921c7e6cc16.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*mkrjYJLXYfKVXoA_Jkp_gA.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Publisher-Subscriber Communication</figcaption></figure><p id="eb9a" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated"><strong class="kn hi">发布者:</strong> It <strong class="kn hi"> </strong>是数据发射者，也被称为<strong class="kn hi">可观测者</strong>。</p><p id="002b" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated"><strong class="kn hi">订阅者:</strong>订阅可观察对象来消费数据，可以识别所有发出的事件包括错误！如果订阅者很慢，它很容易被生产者超越。为了解决这个问题，订户或<strong class="kn hi">观察者</strong>可以利用一种叫做<strong class="kn hi">背压</strong>的强大机制来控制可观察对象的节流。</p><p id="10a9" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated"><strong class="kn hi">订阅:</strong>这是发射器和订户之间的会话，当不再需要数据时可以取消。</p><p id="d922" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated"><strong class="kn hi">处理器:</strong>这些<strong class="kn hi">消耗来自发布者的</strong>数据，应用一些操作(例如，映射、过滤等)并<strong class="kn hi">产生</strong>给订阅者。因此，它们可以被认为是两者的结合——发布者和订阅者。</p><p id="69dc" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated">值得注意的是，这种端到端的系统是懒惰的，也就是说，它直到被消费者订阅后才会实现。</p><h1 id="070c" class="lj jo hh bd jp lk ll lm jt ln lo lp jx in lq io kb iq lr ir kf it ls iu kj lt bi translated">为什么要进行反应式编程？</h1><p id="5e9f" class="pw-post-body-paragraph kl km hh kn b ko kp ii kq kr ks il kt jy ku kv kw kc kx ky kz kg la lb lc ld ha bi translated">随着所处理数据的指数级增长和并发用户数量的增加，软件需要满足新的规范才能具有竞争力。这些要求可以用<a class="ae jm" href="https://www.reactivemanifesto.org" rel="noopener ugc nofollow" target="_blank">反应宣言</a>的四个原则来概括，该宣言指出<strong class="kn hi">反应系统是:</strong></p><h2 id="526f" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">消息驱动</h2><p id="9315" class="pw-post-body-paragraph kl km hh kn b ko kp ii kq kr ks il kt jy ku kv kw kc kx ky kz kg la lb lc ld ha bi translated">随着应用程序越来越复杂，开发人员已经从传统的单片方法转向微服务架构。这些松散耦合的服务相互交互，并以消息的形式交换数据。反应式系统使用组件间的异步消息通信(T21)来代表数据和故障。</p><h2 id="c898" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">应答的</h2><p id="4ee0" class="pw-post-body-paragraph kl km hh kn b ko kp ii kq kr ks il kt jy ku kv kw kc kx ky kz kg la lb lc ld ha bi translated">具有阻塞IO操作的CRUD应用程序不仅会导致系统资源的低效利用，还会导致更高的延迟和较差的性能。因此，浪费了您的资金和客户的时间，这是组织最不希望看到的！用户期望眨眼之间就能得到结果。为了满足这一要求，反应式系统专注于提供<strong class="kn hi">快速</strong>和<strong class="kn hi">一致的响应时间</strong>。</p><h2 id="734c" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">弹性的</h2><p id="0f2e" class="pw-post-body-paragraph kl km hh kn b ko kp ii kq kr ks il kt jy ku kv kw kc kx ky kz kg la lb lc ld ha bi translated">对于一个系统来说，能够在不同的工作负载下<strong class="kn hi">扩展</strong>是绝对重要的。<strong class="kn hi">弹性</strong>是根据负载增加或减少分配给服务的资源以保持响应的能力。</p><h2 id="7393" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">弹回的</h2><p id="db20" class="pw-post-body-paragraph kl km hh kn b ko kp ii kq kr ks il kt jy ku kv kw kc kx ky kz kg la lb lc ld ha bi translated">失败是必然的。重要的是你如何从中恢复过来。因为一个模块停机而影响整个应用程序是不体面的。即使面对故障，系统也需要保持响应。<strong class="kn hi">韧性</strong>无非是<strong class="kn hi">优雅地失败</strong>。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mc"><img src="../Images/3c092c83d011cee1d4f0b69106ffcd05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EyZIxx4NEkGfDB6MdsC9uQ.gif"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx"><a class="ae jm" href="https://www.pinterest.com/pin/291819250861444856/" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="497f" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated">反应式编程使您能够构建<strong class="kn hi">反应式微服务</strong>。值得注意的是，<strong class="kn hi">反应式编程</strong>并不等同于<strong class="kn hi">反应式系统</strong>。使用反应式编程来构建反应式系统并不是强制性的。然而，这是一个好主意，也是遵守反应宣言的最简单的方法之一。</p><h1 id="9499" class="lj jo hh bd jp lk ll lm jt ln lo lp jx in lq io kb iq lr ir kf it ls iu kj lt bi translated">何时使用反应式编程？</h1><p id="17bb" class="pw-post-body-paragraph kl km hh kn b ko kp ii kq kr ks il kt jy ku kv kw kc kx ky kz kg la lb lc ld ha bi translated">在多用户环境中或者处理海量数据时，反应式编程通常是更好的解决方案。这时，您需要异步处理来提高应用程序的响应速度。当它可以被无缝地集成为一个需要“反应性”的组件，而不是改变整个应用程序的编码风格时，完全坚持这种范式是没有价值的。当用更简单的方法可以实现相同的性能时，就没有必要引入额外的复杂性。</p><p id="3711" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated">作为行业领导者，沃尔玛被期望保持其服务在任何时候都无缝运行。为了提高可伸缩性和性能，我们采用了现代事件驱动架构，这种架构可以处理更多的并发流程和最终用户，而不需要额外的计算能力。</p><p id="32b5" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated">一些现实生活中的解决方案在零售和电子商务中变得被动:</p><ol class=""><li id="ba7f" class="md me hh kn b ko le kr lf jy mf kc mg kg mh ld mi mj mk ml bi translated"><strong class="kn hi">目录视图</strong>——假设你在某电商网站搜索“牛仔裤”；页面立即被结果填满。你无限向下滚动，却发现没有更多的数据。很快，页面就会被更多的数据填满。为什么？因为这些数据只有在需要的时候才会提前提供。结果，我们在交付<strong class="kn hi">高度交互式UI </strong>的同时，避免了不必要的服务器负载。</li><li id="70cb" class="md me hh kn b ko mm kr mn jy mo kc mp kg mq ld mi mj mk ml bi translated"><strong class="kn hi">产品列表</strong>——考虑一个想要在电子商务网站上出售其库存的卖家。他们一次上传并列出一个项目。项目列表是一个延迟受限的事件，它是异步执行的。因此，卖家不会被阻止设置下一个项目。<strong class="kn hi">卖家体验++；</strong></li><li id="7110" class="md me hh kn b ko mm kr mn jy mo kc mp kg mq ld mi mj mk ml bi translated"><strong class="kn hi">货物跟踪</strong> -流数据的一个经典例子是来自随时间变化的GPS信号的数据。下游的观察者可能会窒息，从而产生瓶颈。这就是我们可以采用<strong class="kn hi">背压</strong>策略进行流量控制的地方。</li></ol><h1 id="31cb" class="lj jo hh bd jp lk ll lm jt ln lo lp jx in lq io kb iq lr ir kf it ls iu kj lt bi translated">在Java中如何去反应？</h1><p id="e21e" class="pw-post-body-paragraph kl km hh kn b ko kp ii kq kr ks il kt jy ku kv kw kc kx ky kz kg la lb lc ld ha bi translated">Java中有许多反应式编程的实现。</p><ol class=""><li id="7e31" class="md me hh kn b ko le kr lf jy mf kc mg kg mh ld mi mj mk ml bi translated"><a class="ae jm" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> <strong class="kn hi"> RxJava </strong> </a> —使用可观察序列编写异步和基于事件的程序的库。</li><li id="20fa" class="md me hh kn b ko mm kr mn jy mo kc mp kg mq ld mi mj mk ml bi translated"><a class="ae jm" href="https://projectreactor.io" rel="noopener ugc nofollow" target="_blank"> <strong class="kn hi">项目反应器</strong> </a> —反应库，基于<a class="ae jm" href="https://github.com/reactive-streams/reactive-streams-jvm" rel="noopener ugc nofollow" target="_blank">反应流</a> <br/>规范，用于在JVM上构建非阻塞应用。</li><li id="8edc" class="md me hh kn b ko mm kr mn jy mo kc mp kg mq ld mi mj mk ml bi translated"><a class="ae jm" href="https://www.reactive-streams.org" rel="noopener ugc nofollow" target="_blank"><strong class="kn hi">Reactive Streams API</strong></a>—在Java 9中引入，这是一项为具有非阻塞背压的异步流处理提供标准的倡议。</li></ol><p id="9a41" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated">在习惯这种编码范式之前，需要大量的经验和时间。让我们使用<a class="ae jm" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kn hi">反应器</strong> </a> <strong class="kn hi"> </strong>作为反应式编程库，通过一个简单的实现来体验一下。</p><p id="b93b" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated"><em class="lx">考虑一个每秒发出整数的普通发布者和一个消耗两倍发出的偶数整数的订阅者。</em></p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mr ms l"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Reactor Example</figcaption></figure><p id="3579" class="pw-post-body-paragraph kl km hh kn b ko le ii kq kr lf il kt jy lg kv kw kc lh ky kz kg li lb lc ld ha bi translated"><em class="lx">在主线程超时之前，上面的代码产生以下输出:</em></p><pre class="ix iy iz ja fd mt mu mv mw aw mx bi"><span id="19f0" class="jn jo hh mu b fi my mz l na nb">Received: 0<br/>Received: 4<br/>Received: 8</span></pre><h1 id="f49a" class="lj jo hh bd jp lk ll lm jt ln lo lp jx in lq io kb iq lr ir kf it ls iu kj lt bi translated">症结所在</h1><p id="83ce" class="pw-post-body-paragraph kl km hh kn b ko kp ii kq kr ks il kt jy ku kv kw kc kx ky kz kg la lb lc ld ha bi translated">综上所述，反应式编程是一种涉及异步数据流的编码风格。它为以分布式异步非阻塞方式工作提供了更简单的方法。那么反应式编程是未来吗？虽然这是一个强有力的声明，但很明显，我们已经分支进入了<strong class="kn hi">异步编程</strong>的世界，以构建<strong class="kn hi">快速</strong>和<strong class="kn hi">容错</strong>系统。</p><h1 id="aad4" class="lj jo hh bd jp lk ll lm jt ln lo lp jx in lq io kb iq lr ir kf it ls iu kj lt bi translated">参考</h1><div class="nc nd ez fb ne nf"><a href="https://www.reactivemanifesto.org" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hi fi z dy nk ea eb nl ed ef hg bi translated">反动宣言</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">在不同领域工作的组织正在独立地发现构建看起来…</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">www.reactivemanifesto.org</p></div></div><div class="no l"><div class="np l nq nr ns no nt jg nf"/></div></div></a></div><div class="nc nd ez fb ne nf"><a href="https://www.scnsoft.com/blog/java-reactive-programming" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hi fi z dy nk ea eb nl ed ef hg bi translated">Java中的反应式编程:你应该想知道答案的10个问题</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">对于应用程序开发来说，反应式编程(RP)并不是什么新的前沿技术。机会是…</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">www.scnsoft.com</p></div></div><div class="no l"><div class="nu l nq nr ns no nt jg nf"/></div></div></a></div><div class="nc nd ez fb ne nf"><a href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hi fi z dy nk ea eb nl ed ef hg bi translated">反应式编程-维基百科</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">在计算中，反应式编程是一种声明式编程范式，它关注数据流和数据流之间的关系。</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">en.wikipedia.org</p></div></div><div class="no l"><div class="nv l nq nr ns no nt jg nf"/></div></div></a></div><div class="nc nd ez fb ne nf"><a rel="noopener follow" target="_blank" href="/@hharans7889/reactive-programming-as-simple-badb80392baf"><div class="ng ab dw"><div class="nh ab ni cl cj nj"><h2 class="bd hi fi z dy nk ea eb nl ed ef hg bi translated">简单的反应式编程</h2><div class="nm l"><h3 class="bd b fi z dy nk ea eb nl ed ef dx translated">反应式编程背后的动机。</h3></div><div class="nn l"><p class="bd b fp z dy nk ea eb nl ed ef dx translated">medium.com</p></div></div><div class="no l"><div class="nw l nq nr ns no nt jg nf"/></div></div></a></div></div></div>    
</body>
</html>