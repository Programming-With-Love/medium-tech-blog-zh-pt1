<html>
<head>
<title>Implementing SSO in Mendix Native Mobile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Mendix Native Mobile中实现单点登录</h1>
<blockquote>原文：<a href="https://medium.com/mendix/mendix-native-mobile-with-sso-3b86b962a899?source=collection_archive---------0-----------------------#2020-09-21">https://medium.com/mendix/mendix-native-mobile-with-sso-3b86b962a899?source=collection_archive---------0-----------------------#2020-09-21</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/1e3e98d8d21e0c7a140d01210acb1ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TaR6CtaRTikUvkuibI5r3w.png"/></div></div></figure><div class=""/><div class=""><h2 id="78d9" class="pw-subtitle-paragraph jc ie if bd b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ek translated">最近，我被要求帮助一个项目，在一个本地移动Mendix应用程序上实现单点登录。我喜欢这些问题。他们允许我花一些时间学习新东西，帮助客户解决特定的技术挑战。</h2></div><p id="e42a" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">由于没有太多关于这个话题的信息，我决定写这个(相当技术性的)博客，分享我的旅程和学习。</p><p id="a0b4" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">该客户所需的单点登录需要使用OAuth2协议在Azure Active Directory上实现。</p><p id="bf09" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">这种SSO实现的主要挑战是我们要处理两种技术栈。一个是原生移动应用，使用React native，另一个是web环境，处理Azure上的登录过程。</p><p id="683f" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">该项目最初是在Mendix 8.5.0中开发的，后来迁移到了Mendix 8.9.0。随着Mendix 8.9.0的推出，React本地库出现了一些突破性的变化，这些库已经升级到最新的0.61版本。这次升级是一个非常好的改进，需要一些改变，但更多的在后面。</p></div><div class="ab cl kp kq hb kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h1 id="74bc" class="kw kx if bd ky kz la lb lc ld le lf lg jl lh jm li jo lj jp lk jr ll js lm ln dt translated">第一章:开始</h1><p id="9e2c" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">那么，从哪里开始呢？Mendix善意地指出，该解决方案可能需要一个定制的小部件来登录，使用React本地应用内浏览器组件。这个应用内浏览器可以处理IdentityProvider (IdP，在我们的例子中是Azure)上的初始登录。登录后，返回的信息应该在Mendix本地移动应用程序中以某种方式获得，并用于完成登录过程。这种方法与使用SSO的Mendix混合离线移动应用程序非常相似。</p><p id="8548" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">在这里阅读更多信息:<a class="ae lt" href="https://docs.mendix.com/howto/mobile/implement-sso-on-a-hybrid-app-with-mendix-and-saml" rel="noopener ugc nofollow" target="_blank">在一个混合应用程序上使用Mendix &amp; SAML </a>实现SSO。</p><p id="9a15" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">这些信息为我开始自己的旅程提供了一个很好的起点。</p><h1 id="01b2" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">OAuth2</h1><p id="3713" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">重要的事情先来。让我们在Mendix中设置一个到Azure的连接，以允许用户使用OAuth2用他们的Azure帐户登录。</p><p id="8ad1" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">一旦你知道如何在Azure中使用OAuth2协议，实现起来并不困难。在微软网站、<a class="ae lt" href="https://docs.microsoft.com/en-us/azure/active-directory/azuread-dev/v1-protocols-oauth-code" rel="noopener ugc nofollow" target="_blank"> OAuth2和Active Directory </a>上有一篇关于这个主题的精彩文章。</p><p id="25a9" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">简单来说，OAuth2流程的工作方式如下。首先，在/oauth2/authorize路径上浏览或重定向到<a class="ae lt" href="https://login.microsoftonline.com" rel="noopener ugc nofollow" target="_blank">https://login.microsoftonline.com</a>以请求授权码，并提供oauth2设置细节，包括回调url。登录Azure后，Azure使用授权码重定向到回调url。接下来，在接收服务器端，使用授权代码从/oauth2/token url请求访问(和刷新)令牌。返回的令牌(id_token)是一个JSON Web令牌(JWT ),它包含签名用户的信息。JWT还包含访问和刷新令牌，该令牌可以用作其他OAuth2使能服务的承载令牌。</p><h1 id="00e6" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">门迪克斯的OAuth2</h1><p id="ebe1" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">Mendix应用商店提供了一个Oauth2模块，由FlowFabric开发，可以在这里找到:<a class="ae lt" href="https://appstore.home.mendix.com/link/app/1414/" rel="noopener ugc nofollow" target="_blank">开放认证模块</a>。该模块处理Mendix中的OAuh2流。</p><p id="dddd" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">它在Mendix "/sigin "中使用一个定制的requesthandler来设置OAuth2到Azure的流程。requesthandler向Azure的/oauth2/authorize url返回HTTP重定向响应，以便浏览器重定向到Azure，用户能够登录。</p><p id="6847" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">登录后，Azure使用提供的回调url将浏览器重定向回Mendix。回调url由自定义request handler“/callback”获取。该处理程序使用包含的授权代码从Azure获取JWT，并将其传递给微流中的自定义签名，以验证用户并设置正确的角色。</p><p id="5673" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">最后，创建一个Mendix用户会话，由requesthandler返回给浏览器，以授予对应用程序的访问权限。</p><h1 id="e886" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">继续前进</h1><p id="aa3d" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">因此，在OAuth2设置完成后，旅程的下一步将是从Mendix本地移动应用程序重定向到Azure OAuth2 url，以开始登录。</p><p id="72b0" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">React本地移动应用程序不是在浏览器中运行的web应用程序。因此，不可能立即重定向到Azure进行登录。Mendix提供了一个应用内浏览器小工具来解决这个问题，并允许我们连接到网络。</p><p id="6f5c" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">然而，当OAuth2流完成时，我们在应用内浏览器中结束了一个登录会话，但不是在本地应用本身中。</p><p id="925e" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">注销时也存在类似的问题。注销将首先在Azure上处理。注销后，用户还必须在本机应用程序中注销。</p><p id="f1a1" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">总而言之，下一个挑战是在登录后在本地应用程序中创建一个Mendix会话。为了克服这个挑战，我决定编写一个定制的小部件，实现一个定制的应用内浏览器。</p></div><div class="ab cl kp kq hb kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h1 id="59e0" class="kw kx if bd ky kz la lb lc ld le lf lg jl lh jm li jo lj jp lk jr ll js lm ln dt translated">第2章:小部件(8.5.0)</h1><p id="c805" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">我首先考虑的是找出我可以将哪个React本地组件用作应用内浏览器，并将其包装在一个定制的小部件中。该组件应该能够拦截网址，最好有能力在浏览器的网页中执行JavaScript。</p><h1 id="4594" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">React-native-webview</h1><p id="b17e" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">在互联网上快速搜索了解到，来自React-native-community(<a class="ae lt" href="https://github.com/react-native-community" rel="noopener ugc nofollow" target="_blank">React native community</a>)的React-native-webview(<a class="ae lt" href="https://github.com/react-native-community/react-native-webview" rel="noopener ugc nofollow" target="_blank">React-native-webview</a>)将是最合适的组件。</p><p id="b396" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">它提供了各种有趣的属性和方法，例如:</p><ul class=""><li id="ca46" class="lz ma if bd b jw jx jz ka kc mb kg mc kk md ko me mf mg mh dt translated"><em class="mi"> injectJavaScript </em> —很棒的特性，例如从加载在浏览器组件中的网站获取信息</li><li id="c2e9" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated"><em class="mi">停止加载</em> —对于停止加载过程非常有用，这可能会阻止脚本执行、重定向等</li><li id="5172" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated"><em class="mi">onNavigationStateChange</em>—允许拦截URL加载的事件。非常方便的拦截重定向。正是我们需要的。</li><li id="f1a2" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated"><em class="mi"> onLoadEnd，onError </em> —用于内务处理的事件，可以通知小部件加载操作完成或发生了错误。</li></ul><h1 id="8744" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">小部件设置</h1><p id="9822" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">使用Mendix小部件设置指令(<a class="ae lt" href="https://docs.mendix.com/howto/extensibility/create-a-pluggable-widget-one" rel="noopener ugc nofollow" target="_blank">构建可插拔web小部件</a>)，可以很容易地使用CLI命令启动新的本地移动可插拔小部件项目:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="c64c" class="mx kx if mt b fv my mz l na nb">yo @mendix/widget</span></pre><p id="5bb8" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">注意:使用“TypeScript”作为编程语言，使用“For native mobile apps”作为小部件类型(显然)</p><p id="8c17" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">生成的小部件项目带有一个<em class="mi"> package.json </em>文件。这个文件包含一个有趣的部分“devDependencies”，它为依赖库提供了各自的版本。特别注意:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="035e" class="mx kx if mt b fv my mz l na nb">"@mendix/pluggable-widgets-tools": "8.7.0"<br/>"@types/react-native": "0.57.56"</span></pre><p id="79bc" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">因为当我们在第4章稍后切换到Mendix 8.9时，这些需要升级。</p><p id="a366" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">接下来，使用CLI命令向我们的项目添加react-native-webview组件:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="0898" class="mx kx if mt b fv my mz l na nb">npm install react-native-webview --save</span></pre><h1 id="8db7" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">小部件功能</h1><p id="2547" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">小部件实现本身非常简单。它可以拦截url更改，并使用url上的正则表达式来确定是否应该调用onCallback操作。注意，该动作只能是纳流；本机移动设备不支持微流。</p><p id="5c6c" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">onLoadEnd事件也有类似的实现，当加载的url与某个正则表达式匹配时，就会调用onLoad操作。这对注销过程很有用，因为它可以检测用户何时完成在Azure上的注销。</p><p id="3673" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">完整的小部件源代码可以在这里找到:<a class="ae lt" href="https://github.com/FlowFabric/SSONativeReact-890/" rel="noopener ugc nofollow" target="_blank"> SSO原生React小部件</a>。注意，这已经是Mendix 8.9.0的升级版了。</p><h1 id="b9c2" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">怪癖</h1><p id="2cc5" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">在我们的小部件中使用react-native-webview组件变得很棘手。最初，WebView组件通过以下TypeScript import语句加载到我们的小部件源代码中:</p><figure class="mo mp mq mr fq hw fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/e61086c3538a8b520245aa1cdd600104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*VwrSwwLOWYQtDNHf7NW_xQ.png"/></div></figure><p id="4a0e" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">因为我们在项目中安装了这个组件，而没有明确的版本，所以添加了最新的版本，代码可以很好地编译所有的特性。</p><p id="f832" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">不幸的是，应用程序在使用小部件时产生了一个错误。经过一些检查，发现Mendix已经打包了这个组件的一个旧版本(5.12.1 ),它没有提供所有想要的特性。</p><p id="d3f1" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">这个问题的解决方案是从安装新版本的项目路径中显式引用组件。这将强制在我们的小部件中加载新版本。</p><figure class="mo mp mq mr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nd"><img src="../Images/d8119213af5d8cdaac4d93be92a140a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygwhYzuyl7syfio9x7Algw.png"/></div></div></figure><h1 id="81f6" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">小部件使用</h1><p id="cc27" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">现在我们已经编写了小部件，让我们看看如何在Mendix项目中使用它。</p><figure class="mo mp mq mr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ne"><img src="../Images/409ab16907cf8eb2977721b9bf0ed550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H-hvyfZdIFp5GOte"/></div></div></figure><p id="b3d7" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">在这个屏幕截图中，小部件被放置在一个带有SigninHelper对象的DataView内的页面上。</p><p id="4be0" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">该小部件提供了以下附加自定义属性:</p><ul class=""><li id="c0fb" class="lz ma if bd b jw jx jz ka kc mb kg mc kk md ko me mf mg mh dt translated"><em class="mi">回调</em>:包含被拦截url的属性</li><li id="7adc" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated"><em class="mi">加载时</em>:当加载的url与“Onload Regex include”中的正则表达式模式匹配时，触发此事件</li><li id="a59b" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated"><em class="mi"> On error </em>:该事件在组件产生错误时触发。</li><li id="4f55" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated"><em class="mi">回调时</em>:当拦截的url与“回调正则表达式包含”和“回调正则表达式排除”中的正则表达式模式匹配时，触发此事件</li><li id="e6e0" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated"><em class="mi"> URL </em>:这是一个文本模板，包含小部件启动时加载的初始URL。</li><li id="6156" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated"><em class="mi">回调正则表达式包含</em>:在拦截的url上匹配的正则表达式。拦截的url必须与此模式匹配</li><li id="cac0" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated"><em class="mi">回调Regex exclude </em>:在拦截的url上匹配的正则表达式。拦截的url不能与此模式匹配</li><li id="1958" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated"><em class="mi"> Onload Regex include </em>:在加载的url上匹配的正则表达式。加载的url必须与此模式匹配</li></ul><p id="cd05" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">在上面的截图中，小部件是为用户登录而设置的。</p><p id="6276" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">SigninHelper对象提供回调属性，该属性由回调属性中的小部件使用。</p><p id="7bdf" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">小部件的URL属性包含“<mendix server="">/sign in”URL。这将启动Mendix中的OAuth2流，用户将被重定向到Azure站点进行登录。</mendix></p><p id="1aff" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">小部件的回调拦截设置为只拦截从Azure返回Mendix的重定向。更详细地，当检测到url改变并且url包含“callback”而不包含“oauth2”时，调用纳流:NF_CallbackReceived_Signin。nanoflow在回调属性中接收带有截取的url的SigninHelper对象。</p><p id="b2aa" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">当nanoflow被执行时，我们已经到达了一个交接点，来自小部件的信息(即带有经过验证的Azure登录和来自回调url的验证码的webbrowser)流回移动应用程序。</p><p id="3032" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">这使我们进入下一步，最后的布线。</p></div><div class="ab cl kp kq hb kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h1 id="9e34" class="kw kx if bd ky kz la lb lc ld le lf lg jl lh jm li jo lj jp lk jr ll js lm ln dt translated">第3章:最终布线</h1><p id="b133" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">因此，我们已经成功地在Azure中登录了用户，并拦截了来自Azure的带有验证码的回调url。所有这些都可以在我们的Mendix本地移动应用程序中找到。移动应用程序现在需要一个Mendix会话和一个由Mendix提供的身份验证令牌才能正常工作。</p><h2 id="8be9" class="mx kx if bd ky nf ng nh lc ni nj nk lg kc nl nm li kg nn no lk kk np nq lm nr dt translated">认证令牌？</h2><p id="d53c" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">认证令牌，它到底是什么？简单地说，这个令牌被移动应用程序存储和使用，作为一种长期的身份验证机制。一旦本地存在有效的令牌，用户就不需要每次启动应用程序时都登录。</p><h2 id="fc30" class="mx kx if bd ky nf ng nh lc ni nj nk lg kc nl nm li kg nn no lk kk np nq lm nr dt translated">认证步骤</h2><p id="7fb3" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">在Mendix服务器端需要采取以下步骤:</p><ul class=""><li id="1519" class="lz ma if bd b jw jx jz ka kc mb kg mc kk md ko me mf mg mh dt translated">使用回调url中提供的身份验证代码从Azure获取访问令牌</li><li id="f136" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">在Mendix中验证并查找来自Azure的已登录用户</li><li id="84f3" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">将用户角色分配给Mendix用户</li><li id="73dd" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">为Mendix用户创建Mendix会话</li><li id="0b9c" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">创建要在移动应用程序中使用的身份验证令牌。向移动应用发送Mendix会话和认证令牌</li></ul><p id="4b3b" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">最后，在Mendix本地移动应用中:</p><ul class=""><li id="adb9" class="lz ma if bd b jw jx jz ka kc mb kg mc kk md ko me mf mg mh dt translated">将移动应用程序重定向到主页，这将为登录用户加载主页。</li></ul><p id="0dff" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">请记住，我们使用的是Mendix 8.5.0，它还不具备从纳流中调用微流的能力(可从Mendix 8.8和更高版本中获得)。这意味着nanoflow不能直接调用服务器端逻辑。因此，我决定编写一个自定义请求处理程序，可以从移动应用程序中的自定义JavaScript操作调用它。</p><h1 id="9336" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">自定义请求处理程序</h1><p id="d8b3" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">定制请求处理器将执行上述所有服务器端步骤:</p><ul class=""><li id="4282" class="lz ma if bd b jw jx jz ka kc mb kg mc kk md ko me mf mg mh dt translated">从Azure获取访问令牌</li><li id="9b54" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">使用微流程在Mendix中查找/验证用户并分配用户角色</li><li id="98ed" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">为Mendix用户创建Mendix会话</li><li id="01f9" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">生成身份验证令牌。</li><li id="fe61" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">返回Mendix会话(作为cookie)和身份验证令牌(JSON)</li></ul><h1 id="cb7a" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">认证令牌研究</h1><p id="01ca" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">由于Mendix文档中没有描述如何生成令牌以及如何在移动应用程序中处理它，所以我做了一些研究。</p><p id="3152" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">我首先想到的是当Mendix处理一个普通的登录请求时，从Mendix发送回移动应用程序的JSON。看起来是这样的:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="7fbf" class="mx kx if mt b fv my mz l na nb">{<br/>   csrftoken: &lt;csrftoken&gt;,<br/>   authtoken: &lt;authtoken&gt;<br/>}</span></pre><p id="1a27" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">authtoken是下一个研究课题。我创建了下面的Java代码，它以与Mendix相同的方式生成令牌。</p><figure class="mo mp mq mr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ns"><img src="../Images/1aa302307a1aa25014308dc096cb994f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o3Ssbi1dkZTOezlVowQulA.png"/></div></div></figure><h1 id="a686" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">Requesthandler结果</h1><p id="65f5" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">下面的Java代码片段很好地总结了请求处理程序的任务。</p><figure class="mo mp mq mr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nt"><img src="../Images/42faf3a67708327341a9071e575056a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EaPFsbUxWyvXos_12vABjA.png"/></div></div></figure><ul class=""><li id="0942" class="lz ma if bd b jw jx jz ka kc mb kg mc kk md ko me mf mg mh dt translated">OAuthCallbackResolver类从请求处理程序url获取验证码，调用Azure的oauth2/token url来接收访问令牌，并通过调用包含解析用户的逻辑的微流和为用户分配角色来解析Mendix中的用户。</li><li id="017b" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">为解析的用户初始化会话</li><li id="c337" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">会话被写入会话cookie，该cookie将在请求处理程序响应中发回</li><li id="74b7" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">生成认证令牌</li><li id="fca9" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">JSON对象是用创建的会话中的csrf令牌和生成的身份验证令牌构建的</li><li id="4a4d" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">JSON在请求处理程序的响应体中返回</li></ul><h1 id="da88" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">调用请求处理程序</h1><p id="4a57" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">让我们回到Mendix本地移动应用程序。在前一章中，我们结束了从Azure接收回调url的nano flow NF _ callback received _ sign in。</p><p id="bf73" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">为了从我们的nanoflow调用请求处理程序，将使用一个JavaScript动作，它还处理来自请求处理程序的JSON响应。</p><p id="eb40" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">JavaScript动作的输入是来自Azure的回调url。</p><figure class="mo mp mq mr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nu"><img src="../Images/5ca65a9b66799e421b880e36c08576d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TgLYCTooWzPi2Ylg"/></div></div></figure><p id="026f" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">JavaScript动作将从收到的url中提取Azure身份验证代码，并使用该代码调用请求处理程序。然后处理来自请求处理程序的结果JSON。</p><h1 id="c993" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">并且authtoken将被授予…</h1><p id="be05" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">在移动应用程序中本地处理authtoken是另一个研究课题。通过检查Mendix为本地移动应用程序生成的捆绑javascript文件，我发现接收到的authtoken是按如下方式处理的:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="c2af" class="mx kx if mt b fv my mz l na nb">window.mx.session.sessionStore.remove();<br/>window.mx.session.tokenStore.set(data.authtoken);<br/>window.mx.reload();</span></pre><p id="c3a7" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">reload()语句将导致应用程序重新加载并返回到主页。因为此时有一个有效的会话cookie可用，所以用户被重定向到他们配置的主页。</p><h1 id="e9c8" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">产生的JavaScript动作</h1><figure class="mo mp mq mr fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff nv"><img src="../Images/5562f07be233f4a8bb932031d42e3f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mskhurFVWpyWPpoCYBI9rA.png"/></div></div></figure></div><div class="ab cl kp kq hb kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="hn ho hp hq hr"><h1 id="4285" class="kw kx if bd ky kz la lb lc ld le lf lg jl lh jm li jo lj jp lk jr ll js lm ln dt translated">第4章:Mendix 8.9.0</h1><p id="b395" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">在完成这个SSO解决方案后不久，项目转移到了Mendix 8.9.0。这在原生手机上引起了一些突破性的变化，如下所述:<a class="ae lt" href="https://docs.mendix.com/releasenotes/studio-pro/8.9#890" rel="noopener ugc nofollow" target="_blank">发布说明Studio Pro 8.9 </a>。</p><h1 id="2334" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">自定义小部件更改</h1><p id="8a00" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">还记得我在第二章小部件设置部分的<em class="mi"> package.json </em>文件中提到的两个感兴趣的库吗？</p><p id="76fc" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">React Native 0.61的升级意味着这些库需要升级到更高的版本。我们如何做到这一点？</p><p id="cb5b" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">当然不是在文件本身，而是用npm。在CLI中运行以下命令:</p><pre class="mo mp mq mr fq ms mt mu mv aw mw dt"><span id="757e" class="mx kx if mt b fv my mz l na nb">npm install @types/react-native@0.61.23 --save-dev<br/>npm install @mendix/pluggable-widgets-tools@8.9.0 --save-dev</span></pre><p id="d99b" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">注意:以管理员身份运行CLI以防止出错…</p><p id="d627" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">那么，现在这个小部件运行在Mendix 8.9上，它完成了吗？几乎..当应用程序启动并加载我们的自定义小部件时，旧的错误再次出现。</p><figure class="mo mp mq mr fq hw fe ff paragraph-image"><div class="fe ff nw"><img src="../Images/b69e92e322987fec57a8c06763079c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*b_qHcLJBbCL0F4aGFP6cLA.png"/></div></figure><p id="3290" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">为什么？在Mendix 8.9.0中，打包的依赖react-native-webview库也升级到较新的版本8.1.2。我们对这个库的import语句不再指向特定的项目文件夹，而是需要替换为:</p><figure class="mo mp mq mr fq hw fe ff paragraph-image"><div class="fe ff nc"><img src="../Images/e61086c3538a8b520245aa1cdd600104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*VwrSwwLOWYQtDNHf7NW_xQ.png"/></div></figure><h1 id="acc7" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">这是一个总结</h1><p id="73d3" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">我在这段旅程中获得了很多乐趣，一路上学到了新的东西。很高兴看到许多主题和技术融合在一个单一的顺利工作的解决方案。这就是我认为与Mendix合作的伟大之处，一切皆有可能！</p><p id="2ccd" class="pw-post-body-paragraph ju jv if bd b jw jx jg jy jz ka jj kb kc kd ke kf kg kh ki kj kk kl km kn ko hn dt translated">去做吧！</p><h1 id="f765" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">还有一点..</h1><p id="efb9" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">在自定义小部件中，我使用了字符串属性的文本模板(参见:<a class="ae lt" href="https://docs.mendix.com/apidocs-mxsdk/apidocs/property-types-pluggable-widgets#texttemplate" rel="noopener ugc nofollow" target="_blank">可插拔小部件TextTemplate属性</a>)。这些都很棒，因为它们既可以包含静态文本，也可以包含属性中的动态文本。需要记住的一点是，这些是特定于语言的。是的，你猜对了，最初使用的语言是你的移动设备上设置的语言。如果你想知道为什么应用程序在某个设备上运行良好，而在另一个设备上却不能运行…记住文本模板语言依赖。</p><h1 id="d2a2" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">进一步阅读</h1><p id="c275" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">这篇文章简要地涵盖了许多主题。如果您想了解更多信息，以下链接可能会有所帮助。</p><ul class=""><li id="a5d0" class="lz ma if bd b jw jx jz ka kc mb kg mc kk md ko me mf mg mh dt translated">点击这里了解更多关于在混合移动应用上实现单点登录的信息:<a class="ae lt" href="https://docs.mendix.com/howto/mobile/implement-sso-on-a-hybrid-app-with-mendix-and-saml" rel="noopener ugc nofollow" target="_blank">https://docs . mendix . com/how to/mobile/implement-SSO-on-a-hybrid-app-with-mendix-and-SAML</a></li><li id="8ca8" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">在这里了解更多关于OAuth2和Active Directory的信息:<a class="ae lt" href="https://docs.microsoft.com/en-us/azure/active-directory/azuread-dev/v1-protocols-oauth-code" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/azure/Active-Directory/azuread-dev/v1-protocols-oauth-code</a></li><li id="f5f4" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">查看Mendix应用商店中的OAuth2模块:<a class="ae lt" href="https://appstore.home.mendix.com/link/app/1414/" rel="noopener ugc nofollow" target="_blank">https://appstore.home.mendix.com/link/app/1414/</a></li><li id="0848" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">了解React native React-native-webview组件的更多信息:<a class="ae lt" href="https://github.com/react-native-community/react-native-webview" rel="noopener ugc nofollow" target="_blank">https://github . com/React-native-community/React-native-webview</a></li><li id="9518" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">了解更多关于React土著社区的信息:<a class="ae lt" href="https://github.com/react-native-community" rel="noopener ugc nofollow" target="_blank">https://github.com/react-native-community</a></li><li id="bbd1" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">在这里了解更多关于创建自定义本机小部件的信息:<a class="ae lt" href="https://docs.mendix.com/howto/extensibility/build-native-widget" rel="noopener ugc nofollow" target="_blank">https://docs . mendix . com/how to/extensibility/build-Native-widget</a></li><li id="2b15" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">在这里了解更多关于可插拔部件的信息:<a class="ae lt" href="https://docs.mendix.com/howto/extensibility/pluggable-widgets" rel="noopener ugc nofollow" target="_blank">https://docs . mendix . com/how to/extensibility/pluggable-widgets</a></li><li id="9bc6" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">自定义小部件的源代码:<a class="ae lt" href="https://github.com/FlowFabric/SSONativeReact-890/" rel="noopener ugc nofollow" target="_blank">https://github.com/FlowFabric/SSONativeReact-890/</a></li><li id="7ac2" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">在这里了解更多关于Mendix 8.9的信息:【https://docs.mendix.com/releasenotes/studio-pro/8.9#890 T2】</li><li id="ea4d" class="lz ma if bd b jw mj jz mk kc ml kg mm kk mn ko me mf mg mh dt translated">了解更多可插拔小部件TextTemplate属性:<a class="ae lt" href="https://docs.mendix.com/apidocs-mxsdk/apidocs/property-types-pluggable-widgets#texttemplate" rel="noopener ugc nofollow" target="_blank">https://docs . mendix . com/API docs-mxsdk/API docs/property-types-Pluggable-widgets # text template</a></li></ul><h1 id="805e" class="kw kx if bd ky kz lu lb lc ld lv lf lg jl lw jm li jo lx jp lk jr ly js lm ln dt translated">关于我</h1><p id="216e" class="pw-post-body-paragraph ju jv if bd b jw lo jg jy jz lp jj kb kc lq ke kf kg lr ki kj kk ls km kn ko hn dt translated">我是一名经验丰富的顾问，拥有超过7年的Mendix经验和超过25年的软件开发经验。目前，我在Flowfabric/ Mansystems担任Mendix架构师和首席开发人员。</p></div></div>    
</body>
</html>