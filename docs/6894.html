<html>
<head>
<title>Basics of MySQL — for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MySQL基础——面向初学者</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/basics-of-mysql-73c91d8a9c33?source=collection_archive---------1-----------------------#2020-08-17">https://medium.com/quick-code/basics-of-mysql-73c91d8a9c33?source=collection_archive---------1-----------------------#2020-08-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/190af608f72543a3750ba6164b2707de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhdXM-8cRUFtDYaCyIbB_w.jpeg"/></div></div></figure><p id="a90e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我们将讨论一些在使用MySql以获得更好性能时应该记住的事情。</p><h1 id="e150" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">设计模式时要记住的事项:</h1><p id="2ea5" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">MySql支持多种数据类型，但是你应该总是选择更适合你的需求的类型，而不是仅仅对每个域xP使用<strong class="ir hi"> VARCHAR </strong>或<strong class="ir hi"> TEXT </strong></p><p id="f145" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">整数:</strong>存储整数值有多种类型，每种类型都有自己的取值范围，可以存储在int中。</p><ul class=""><li id="f33d" class="kq kr hh ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated">TINYINT:8位</li><li id="aa3d" class="kq kr hh ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">SMALLINT:16位</li><li id="17cc" class="kq kr hh ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">中等:24位</li><li id="9465" class="kq kr hh ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">INT:32位</li><li id="1c21" class="kq kr hh ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">BIGINT:64位</li></ul><p id="17e3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每种类型都可以存储从<strong class="ir hi"> -2^(n-1到2^(n-1) -1 </strong>的值，所以最好明智地选择，因为每种类型都需要不同的空间来存储值。</p><p id="e1ce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你对没有负值很有信心，那么你实际上可以使用UNSIGNED来增加两倍的范围，从0到2 * (2^n-1) 。</p><blockquote class="le lf lg"><p id="cc8b" class="ip iq lh ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated"><strong class="ir hi">有趣的事实</strong> : MySql也允许我们定义小于8位的int的大小，就像这个<strong class="ir hi"> int(1) </strong>但是在内部它仍然把空间当作普通的int而不是<strong class="ir hi"> 1位，</strong>这是MySql客户端级检查。</p></blockquote><p id="5600" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">实数(FLOAT vs DECIMAL): </strong>你应该尽可能使用FLOAT来存储小数值，直到你真的需要精确的小数值，因为FLOAT占用32位空间，DECIMAL占用64位空间。</p><p id="116d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当你真正关心精确的分数时，你应该使用小数。</p><p id="dae5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">字符串:MySql中主要有两种数据类型，它们看起来非常相似，但是有很多不同之处</p><ul class=""><li id="0d06" class="kq kr hh ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated"><strong class="ir hi"> VARCHAR: </strong>就空间而言，VARCHAR比固定长度类型更有效，因为它只在需要的时候使用空间，就像如果你定义了<strong class="ir hi"> VARCHAR(20) </strong>这并不意味着它总是为每行占用20个字节，它根据行中存储的值使用空间，就像如果你存储一个长度为10的字符串，那么它将占用10个字节的空间，所以很明显，20是一个字符串可以拥有的最大长度。</li></ul><p id="e1aa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">VARCHAR实际上提高了空间方面的性能，因为空间是可变的，但是当我们更新的值比先前存储的值长时，有时会导致碎片问题，所以MySQL必须将空间重新分配给那一行，这可能会导致碎片。</p><ul class=""><li id="641b" class="kq kr hh ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated">CHAR: 只有当你对存储在其中的值有足够的把握时，你才应该使用CHAR，它有固定的长度或几乎相似的长度，因为CHAR总是占用固定的空间，不像VARCHAR。</li></ul><p id="46f3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">比如，如果你定义了CHAR(20 ),那么不管你要存储的字符串有多长，每行都要占用20字节的空间。</p><blockquote class="le lf lg"><p id="0b53" class="ip iq lh ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated"><strong class="ir hi">有趣的事实:</strong> VARCHAR实际上需要几个额外的字节来存储字符串的长度，而不是模式创建时定义的大小，就像如果你定义了VARCHAR(100 ),那么它将需要1个额外的字节，VARCHAR(1000)需要2个字节来存储字符串的长度，而CHAR总是需要精确的空间量，就像CHAR(100)需要精确的100字节没有额外的空间。</p></blockquote><p id="7f76" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> BINARY vs VARBINARY: </strong>当你存储二进制字符串时，你应该使用BINARY或VARBINARY，而不是VARCHAR，因为所有东西都在内存中，所以二进制比较比字符比较快。</p><p id="b0ea" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> BLOB vs TEXT: </strong>只有当你真的必须分别存储大量的二进制字符串或字符串时，才应该使用它们。</p><p id="b4de" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">日期时间vs时间戳:</strong>你应该尽可能多地使用时间戳，因为时间戳占用4个字节，而日期时间占用8个字节的空间。DATETIME可以保存从1001年到9999年的值，而TIMESTAMP可以保存从1970年到2038年的值。</p><blockquote class="le lf lg"><p id="7edc" class="ip iq lh ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated"><strong class="ir hi">有趣的事实:</strong></p><p id="8176" class="ip iq lh ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">如果在插入时没有指定时间戳列的值，它将自动设置为当前时间戳。</p><p id="465c" class="ip iq lh ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">如果将0存储到定义为时间戳的列中，存储的值将类似于1969–12–31 19:00:00</p></blockquote><h1 id="e76e" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">MySql索引</h1><p id="1a7e" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">索引用于改进MySQL查询的查找，以便尽可能快地从大量数据中找到数据，MySQL有各种类型的索引，每种索引都有自己的属性，决定何时使用哪种索引。</p><p id="fca9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lh"> B树索引</em> : </strong> B树索引是MySql中最常见的索引，B树实际上是按照顺序存储信息的，这就是为什么在创建B树索引时必须仔细选择列的顺序。因为信息是按顺序存储的，这使得搜索非常快，而大多数查询都是按同样的顺序获取数据的。</p><p id="2f44" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以这样理解，就像我们有下表一样:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="ee02" class="lu jo hh lq b fi lv lw l lx ly"><strong class="lq hi">CREATE TABLE People ( name varchar(50) not null, dob date not null, gender enum(‘m’, ‘f’)not null, key(name));</strong></span></pre><p id="aa76" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以现在所有的记录者都按照姓名列排序，所以搜索姓名以亚历克斯开始的人非常快。</p><p id="5639" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">何时使用:</strong></p><ul class=""><li id="42c7" class="kq kr hh ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated"><strong class="ir hi">前缀匹配:</strong>因为记录是按顺序存储的，所以搜索前缀是很有效的，就像所有人的<strong class="ir hi">名字</strong>都是以给定的前缀开头一样。</li><li id="5c81" class="kq kr hh ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated"><strong class="ir hi">范围值:</strong>当你要搜索范围内的记录时，比如从<strong class="ir hi"> Alex </strong>到<strong class="ir hi"> Kim的所有人。</strong></li><li id="7578" class="kq kr hh ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated"><strong class="ir hi"> Order By: </strong>当您的查询主要使用<strong class="ir hi"> ORDER BY </strong>时，索引会使它更有效，因为记录已经按顺序存储了。</li></ul><p id="53b5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">创作时要记住的事情:</strong></p><ul class=""><li id="2d80" class="kq kr hh ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated"><strong class="ir hi">列顺序:</strong>列顺序对于B树索引非常重要，因为数据是按顺序存储的，所以让support用<strong class="ir hi">键(名字，姓氏)</strong>创建了一个索引，如果您搜索所有<strong class="ir hi">姓氏</strong>以<strong class="ir hi">约翰</strong>开头的人，该索引将不会帮助您，因为您跳过了<strong class="ir hi">名字</strong>列，所以只有当您以与索引相同的顺序搜索信息时，才会使用该索引。</li></ul><p id="bf5d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"/></p><p id="9a63" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">何时使用:</strong></p><ul class=""><li id="12ec" class="kq kr hh ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated"><strong class="ir hi">精确匹配:</strong>散列索引只有在您有精确查找查询时才有帮助。</li></ul><p id="3f12" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">要记住的事情:</strong></p><ul class=""><li id="c4d9" class="kq kr hh ir b is it iw ix ja ks je kt ji ku jm kv kw kx ky bi translated">哈希索引对范围查询没有帮助。</li><li id="f674" class="kq kr hh ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">哈希索引不适用于部分键匹配。</li></ul><blockquote class="le lf lg"><p id="e007" class="ip iq lh ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated"><strong class="ir hi">有趣的事实:</strong></p><p id="0e7e" class="ip iq lh ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">如果在查询的WHERE子句中有一个表达式，那么它不会使用index，所以请确保不要在WHERE子句中使用表达式。</p><p id="e233" class="ip iq lh ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">SELECT * FROM id+1 = 3的用户；</p><p id="10cf" class="ip iq lh ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">当你需要创建一个包含很长字符串的索引时，你可以在创建索引时使用字符串的前缀而不是整个字符串，以使你的索引在空间和时间上更有效。</p></blockquote><h1 id="6b69" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">查询优化:</strong></h1><ul class=""><li id="371d" class="kq kr hh ir b is kl iw km ja lz je ma ji mb jm kv kw kx ky bi translated">始终确保只检索您需要的行，并在选择列时尽可能避免<strong class="ir hi"> * </strong>。</li><li id="c2dd" class="kq kr hh ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">不要运行一个大规模的查询，而是运行一些短的查询，这样就不会长时间锁定这么多行。</li><li id="9b35" class="kq kr hh ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">尽可能使用中的<strong class="ir hi">而不是<strong class="ir hi"> JOIN </strong>，因为</strong>中的<strong class="ir hi">比<strong class="ir hi"> JOIN更高效。</strong></strong></li><li id="b548" class="kq kr hh ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">尽可能使用索引。</li></ul><blockquote class="le lf lg"><p id="2234" class="ip iq lh ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated"><strong class="ir hi">有趣的事实:</strong></p><p id="93d3" class="ip iq lh ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">在InnoDB引擎中，在子句的<strong class="ir hi">中搜索需要log(n)。</strong></p><p id="b541" class="ip iq lh ir b is it iu iv iw ix iy iz li jb jc jd lj jf jg jh lk jj jk jl jm ha bi translated">MySql客户端和数据库之间的连接是半双工的。因此，当一方发送数据时，另一方在响应之前必须接收整个消息。</p></blockquote></div></div>    
</body>
</html>