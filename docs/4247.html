<html>
<head>
<title>Exploring in-app updates on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Android上的应用内更新</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/exploring-in-app-updates-on-android-57f1aee011cb?source=collection_archive---------0-----------------------#2019-05-15">https://medium.com/google-developer-experts/exploring-in-app-updates-on-android-57f1aee011cb?source=collection_archive---------0-----------------------#2019-05-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7dda2cec22a62c6971ed01a2857c3a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HR-LMAhcj9T9t8mX.png"/></div></div></figure><blockquote class="ip iq ir"><p id="a28f" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这最初发布在joebirch.co上:</p></blockquote><div class="jr js ez fb jt ju"><a href="https://joebirch.co/2019/05/07/exploring-in-app-updates-on-android/" rel="noopener  ugc nofollow" target="_blank"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hi fi z dy jz ea eb ka ed ef hg bi translated">探索Android上的应用内更新</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">我敢肯定，你经常需要发送某种形式的紧急应用程序更新，也许…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">joebirch.co</p></div></div><div class="kd l"><div class="ke l kf kg kh kd ki in ju"/></div></div></a></div></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="70b0" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">我相信经常会有这样的时候，你需要发送某种形式的紧急应用程序更新——可能存在安全问题或一些错误，给用户带来了很多问题。以前，我们需要在Google play商店推出新的更新，并等待我们的用户收到更新。如果他们没有安装自动更新，我们依靠用户访问play store来更新我们的应用程序。在本周的Google I/O大会上，我们看到了Play核心库的应用内更新。在这篇文章中，我们将学习更多关于这个附加的东西，以及如何在我们的应用中使用它。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="8180" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">Play Core库支持API级别21及以上，现在允许我们向用户提供应用内更新，这意味着当用户在我们的应用环境中时，我们可以显示应用更新可用。Play Core库为我们提供了两种不同的方式来提示我们的用户有可用的更新——或者使用灵活的方法或立即的方法。</p><figure class="ku kv kw kx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kt"><img src="../Images/576094cf8b26cf2d076f35c35c1ffb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z_XCYoRSTNqM3VBX.png"/></div></div></figure><p id="c97e" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated"><strong class="iv hi">灵活的</strong>方法向用户显示升级对话框，但在后台执行更新的下载。这意味着用户可以在下载更新的同时继续使用我们的应用程序。对于更重要的应用程序更新，我们可以利用<strong class="iv hi">即时</strong>流程——这是一个阻塞UI，用于提示用户更新应用程序，不允许继续使用，直到应用程序更新并重启。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="92cd" class="ky kz hh bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">检查更新是否可用</h1><p id="8fa7" class="pw-post-body-paragraph is it hh iv b iw lw iy iz ja lx jc jd kq ly jg jh kr lz jk jl ks ma jo jp jq ha bi translated">在我们开始之前，我们将首先检查是否有来自play store的更新。执行此操作的代码如下所示:</p><pre class="ku kv kw kx fd mb mc md me aw mf bi"><span id="a79b" class="mg kz hh mc b fi mh mi l mj mk">val updateManager = AppUpdateManagerFactory.create(this)<br/>updateManager.appUpdateInfo.addOnSuccessListener {<br/>    if (it.updateAvailability() == UpdateAvailability.UPDATE_AVAILABLE &amp;&amp;<br/>        it.isUpdateTypeAllowed(AppUpdateType.IMMEDIATE)) {</span><span id="3fe0" class="mg kz hh mc b fi ml mi l mj mk">    }<br/>}</span></pre><p id="a0fc" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">我们首先创建一个<a class="ae mm" href="https://developer.android.com/reference/com/google/android/play/core/appupdate/AppUpdateManager.html" rel="noopener ugc nofollow" target="_blank"> AppUpdateManager </a>类的实例——它将负责处理我们的应用程序信息。使用它，我们将获取一个<a class="ae mm" href="https://developer.android.com/reference/com/google/android/play/core/appupdate/AppUpdateInfo.html" rel="noopener ugc nofollow" target="_blank"> AppUpdateInfo </a>实例——这需要发出一个远程请求来这样做，这就是为什么你可以看到我们访问上面的<strong class="iv hi">结果</strong>属性。这个<a class="ae mm" href="https://developer.android.com/reference/com/google/android/play/core/appupdate/AppUpdateInfo.html" rel="noopener ugc nofollow" target="_blank"> AppUpdateInfo </a>包含一个数据集合，可以用来决定我们是否应该触发更新流。</p><p id="e574" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">首先，它有一个方法<a class="ae mm" href="https://developer.android.com/reference/com/google/android/play/core/appupdate/AppUpdateInfo.html#availableVersionCode()" rel="noopener ugc nofollow" target="_blank"> availableVersionCode() </a> —如果有一个更新当前可用或者正在更新，它将返回那个版本值。除此之外，还有一个<a class="ae mm" href="https://developer.android.com/reference/com/google/android/play/core/appupdate/AppUpdateInfo.html#updateAvailability()" rel="noopener ugc nofollow" target="_blank"> updateAvailability() </a>方法，它返回一个表示更新状态的值。这可以是:</p><ul class=""><li id="8f8d" class="mn mo hh iv b iw ix ja jb kq mp kr mq ks mr jq ms mt mu mv bi translated">未知的</li><li id="8bcd" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">更新_可用</li><li id="178a" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">更新进行中</li><li id="77fc" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">开发者_触发_更新_进行中</li></ul><p id="6c69" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">我们首先要检查它是否等于<strong class="iv hi"> UPDATE_AVAILABLE，</strong>，然后通过使用<a class="ae mm" href="https://developer.android.com/reference/com/google/android/play/core/appupdate/AppUpdateInfo.html#isUpdateTypeAllowed(int)" rel="noopener ugc nofollow" target="_blank"> isUpdateTypeAllowed() </a>函数来确保所需的更新类型受到支持——传入AppUpdateType类型(即时或灵活)以确保我们想要使用的更新类型受到支持。</p><p id="c572" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">现在我们已经有了确定应用程序更新是否可用所需的信息，我们将想要触发更新流程。我们可以通过使用<a class="ae mm" href="https://developer.android.com/reference/com/google/android/play/core/appupdate/AppUpdateManager.html" rel="noopener ugc nofollow" target="_blank"> AppUpdateManager </a>类附带的startUpdateFlowForResult()方法来做到这一点。当我们调用这个函数时，我们只需要传递:</p><ul class=""><li id="875e" class="mn mo hh iv b iw ix ja jb kq mp kr mq ks mr jq ms mt mu mv bi translated">我们之前检索的AppUpdateInfo实例</li><li id="aa03" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">我们想要触发的AppUpdateType(即时或灵活)</li><li id="4689" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">当前组件的上下文</li><li id="32cc" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">请求代码，以便可以在调用组件中捕获取消/失败</li></ul><pre class="ku kv kw kx fd mb mc md me aw mf bi"><span id="038a" class="mg kz hh mc b fi mh mi l mj mk">updateManager.startUpdateFlowForResult(<br/>    appUpdateInfo,<br/>    AppUpdateType.IMMEDIATE,<br/>    this,<br/>    REQUEST_CODE_UPDATE)</span></pre><p id="b5c4" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">调用此<strong class="iv hi">startUpdateFlowForResult()</strong>方法将触发startActivityForResult()调用，并启动应用程序更新流程。在某些情况下，请求应用程序更新可能会被用户取消(ActivityResult。<strong class="iv hi"> RESULT_CANCELLED </strong>)，甚至失败(ActivityResult。<strong class="iv hi">结果_输入_应用_更新_失败</strong>。在这些情况下，我们可以在活动/片段的onActivityResult()中捕获结果，并相应地处理结果。</p><pre class="ku kv kw kx fd mb mc md me aw mf bi"><span id="896a" class="mg kz hh mc b fi mh mi l mj mk">override fun onActivityResult(<br/>    requestCode: Int, <br/>    resultCode: Int, <br/>    data: Intent<br/>) {<br/>    if (requestCode === REQUEST_CODE_UPDATE) {<br/>        if (requestCode != RESULT_OK) {<br/>        <br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="5f0e" class="ky kz hh bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">即时应用内更新</h1><p id="18f2" class="pw-post-body-paragraph is it hh iv b iw lw iy iz ja lx jc jd kq ly jg jh kr lz jk jl ks ma jo jp jq ha bi translated">使用AppUpdateType可以触发即时应用内更新。即时价值——如前所述，这将为用户触发一个阻塞的UI流，直到他们更新了应用程序。这意味着该用户界面将在应用程序下载和安装的整个过程中显示，直到整个更新过程完成。当用户在更新过程中离开你的应用时，更新将继续下载，然后在后台安装。但是，如果用户在更新过程完成之前离开并返回到您的应用，您需要确保我们继续更新过程。</p><figure class="ku kv kw kx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nb"><img src="../Images/71ae32cf2cb353ba17e89235a9acd53d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YQy94cwIZaLJveky.png"/></div></div></figure><p id="614b" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">为此，我们需要检查updateAvailability()是否返回了<strong class="iv hi">DEVELOPER _ trigged _ UPDATE _ IN _ PROGRESS</strong>状态。如果是这样，那么我们需要触发更新流，以便更新过程可以继续。如果您不实现流程的这一部分，那么用户将能够继续使用您的应用程序，而不会立即更新生效。</p><pre class="ku kv kw kx fd mb mc md me aw mf bi"><span id="1869" class="mg kz hh mc b fi mh mi l mj mk">override fun onResume() {<br/>    super.onResume()<br/>    val updateManager = AppUpdateManagerFactory.create(this)<br/>    updateManager.appUpdateInfo<br/>        .addOnSuccessListener {<br/>            if (it.updateAvailability() == <br/>                UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS) {<br/>                updateManager.startUpdateFlowForResult(<br/>                    it,<br/>                    IMMEDIATE,<br/>                    this,<br/>                    REQUEST_CODE_UPDATE)<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="100b" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">对于即时更新，我们不需要做任何进一步的工作。一旦下载了更新，实现将自动重启我们的应用程序，这样就可以安装更新。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="7fb1" class="ky kz hh bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">灵活的应用内更新</h1><p id="70d0" class="pw-post-body-paragraph is it hh iv b iw lw iy iz ja lx jc jd kq ly jg jh kr lz jk jl ks ma jo jp jq ha bi translated">使用AppUpdateType可以触发灵活的应用内更新。灵活的价值—如前所述，这将触发一个流程，向用户显示一个升级弹出窗口，并在后台执行更新的下载/安装，同时用户可以继续使用该应用程序。</p><figure class="ku kv kw kx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nc"><img src="../Images/5d4d1dab8ae50c88ff9f0e32f146ece2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G7aNLk1Eh4HflMSr.png"/></div></div></figure><p id="f74a" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">为此，我们首先启动一个<strong class="iv hi">灵活</strong>更新的应用更新流程:</p><pre class="ku kv kw kx fd mb mc md me aw mf bi"><span id="5858" class="mg kz hh mc b fi mh mi l mj mk">updateManager.startUpdateFlowForResult(<br/>    appUpdateInfo, <br/>    AppUpdateType.FLEXIBLE, <br/>    this, <br/>    REQUEST_CODE_UPDATE)</span></pre><p id="49a7" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">因为这都是在后台发生的，而不是像即时更新那样创建一个阻塞的UI，我们需要添加一些监控，以便我们可以检查更新安装的状态。为此，我们将使用<a class="ae mm" href="https://developer.android.com/reference/com/google/android/play/core/install/InstallStateUpdatedListener.html" rel="noopener ugc nofollow" target="_blank">InstallStateUpdatedListener</a>，它将在灵活安装的状态改变时接收回调。这包含一个回调onStateUpdated()，它将传递给我们一个InstallState类的实例。由此我们可以利用:</p><p id="7f72" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated"><strong class="iv hi"> installStatus() </strong> —返回一个代表当前更新状态的<strong class="iv hi"> InstallStatus </strong>值。这可以是以下之一:</p><ul class=""><li id="2268" class="mn mo hh iv b iw ix ja jb kq mp kr mq ks mr jq ms mt mu mv bi translated">未知的</li><li id="0749" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">要求_UI_INTENT</li><li id="f710" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">悬而未决的</li><li id="63ba" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">下载</li><li id="3808" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">下载</li><li id="fbd8" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">安装</li><li id="a5cd" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">安装</li><li id="11d1" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">不成功的</li><li id="fb5b" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">取消</li></ul><p id="9d98" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated"><strong class="iv hi"> installErrorCode() </strong> —返回一个代表安装错误状态的<strong class="iv hi"> InstallErrorCode </strong></p><ul class=""><li id="aea6" class="mn mo hh iv b iw ix ja jb kq mp kr mq ks mr jq ms mt mu mv bi translated">无错误</li><li id="324f" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">无错误部分允许</li><li id="85fd" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">错误_未知</li><li id="a9f2" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">错误_ API _不可用</li><li id="1a4a" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">错误无效请求</li><li id="a3f3" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">错误安装不可用</li><li id="768c" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">错误_安装_不允许</li><li id="5f1d" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">错误_下载_不存在</li><li id="9c28" class="mn mo hh iv b iw mw ja mx kq my kr mz ks na jq ms mt mu mv bi translated">错误_内部错误</li></ul><p id="01a2" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated"><strong class="iv hi"> packageName() </strong> —返回安装状态适用的软件包名称</p><p id="0cc8" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">虽然这里有很多关于安装状态和安装错误代码的选项，但在处理状态时，这给了我们很大的灵活性。例如，如果我们向用户显示一些特定的UI来通知他们当前的状态，那么我们可以根据当前的状态定制其中的内容。</p><pre class="ku kv kw kx fd mb mc md me aw mf bi"><span id="eb2a" class="mg kz hh mc b fi mh mi l mj mk">val listener = InstallStateUpdatedListener {<br/>    // Handle install state<br/>}</span></pre><p id="8434" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">我们也可以让我们的活动实现这个接口，这样回调就可以在活动本身中被覆盖。</p><p id="35c5" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">现在我们有了侦听器，我们可以使用<strong class="iv hi"> registerListener() </strong>方法用out <strong class="iv hi"> AppUpdateManager </strong>实例注册它。使用完listener后，我们需要确保使用unregisterListener()方法来删除任何不再需要时触发的回调。</p><pre class="ku kv kw kx fd mb mc md me aw mf bi"><span id="89e2" class="mg kz hh mc b fi mh mi l mj mk">val updateManager = AppUpdateManagerFactory.create(this)<br/>updateManager.registerListener(listener)</span><span id="04fc" class="mg kz hh mc b fi ml mi l mj mk">...</span><span id="3479" class="mg kz hh mc b fi ml mi l mj mk">updateManager.unregisterListener(listener)</span></pre><p id="9e1b" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">一旦我们检测到InstallStatus代表下载状态，我们需要重新启动应用程序，以便可以安装更新。虽然即时更新方法为您处理这一点，但在灵活更新的情况下，我们需要手动触发这一点。为了手动触发此更新，我们需要使用AppUpdateManager实例中的<strong class="iv hi"> completeUpdate() </strong>方法。调用此函数时，将从play core库中显示一个全屏UI，应用程序将在后台重新启动，以便可以安装更新。然后，应用程序将重启，并应用更新。</p><pre class="ku kv kw kx fd mb mc md me aw mf bi"><span id="e430" class="mg kz hh mc b fi mh mi l mj mk">appUpdateManager.completeUpdate()</span></pre><p id="74ae" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">当从后台调用时，应用程序仍将被更新，但不会显示全屏UI，并且一旦更新完成，应用程序也不会重新启动。</p><p id="dd99" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">但是，如果更新是在应用程序处于前台时进行的，那么用户有可能会在更新下载和安装之前离开并返回我们的应用程序。在这种情况下，当我们的activity点击onResume()时，我们将需要从AppUpdateManager中检查状态，以便我们可以确定是否需要完成更新过程。我们可以通过检查InstallStatus是否处于下载状态来确定这一点。如果是这样，我们可以继续调用completeUpdate()方法来完成更新过程。</p><pre class="ku kv kw kx fd mb mc md me aw mf bi"><span id="816a" class="mg kz hh mc b fi mh mi l mj mk">updateManager.appUpdateInfo<br/>    .addOnSuccessListener {appUpdateInfo -&gt;<br/>        if (appUpdateInfo.installStatus() == InstallStatus.DOWNLOADED) {<br/>            updateManager.completeUpdate()<br/>        }<br/>    }</span></pre></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="e9a4" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">从这篇文章中，我们了解了play核心库提供的应用内更新的新方法。我很高兴在我工作的应用程序中使用它，我真的相信这将极大地改善我们的用户和开发者在android应用程序开发方面的一系列体验。如果您对play核心库或应用内更新有任何疑问，请联系我们。</p><p id="1672" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">在我的下一篇文章中，我将讨论Android上的CameraX Jetpack库。请在Twitter上关注我，以便随时了解这款游戏何时发布！</p><div class="jr js ez fb jt ju"><a href="https://twitter.com/hitherejoe" rel="noopener  ugc nofollow" target="_blank"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hi fi z dy jz ea eb ka ed ef hg bi translated">乔·伯奇(@hitherejoe) |推特</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">乔伯奇的最新推文(@hitherejoe)。Android Lead @Buffer。GDE为@Android、@actionsongoogle、@FlutterIO &amp;…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">twitter.com</p></div></div><div class="kd l"><div class="nd l kf kg kh kd ki in ju"/></div></div></a></div></div></div>    
</body>
</html>