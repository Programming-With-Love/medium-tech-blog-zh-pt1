<html>
<head>
<title>Faster Jetpack Compose  View interop with App Startup and baseline profile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更快的Jetpack撰写视图与应用程序启动和基线配置文件的互操作</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/faster-jetpack-compose-view-interop-with-app-startup-and-baseline-profile-8a615e061d14?source=collection_archive---------3-----------------------#2022-11-18">https://medium.com/androiddevelopers/faster-jetpack-compose-view-interop-with-app-startup-and-baseline-profile-8a615e061d14?source=collection_archive---------3-----------------------#2022-11-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b04b87b465e8196d6b4e20e4579ef390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwQ-gLX4-1X3T2Cf_LhgGQ.png"/></div></div></figure><p id="29e9" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">Jetpack Compose旨在与现有的基于视图的应用程序互操作。这使你能够采取一种<a class="ae jo" href="https://developer.android.com/jetpack/compose/interop/migration-strategy" rel="noopener ugc nofollow" target="_blank">渐进的方法来迁移</a>你现有的应用程序的用户界面进行合成。</p><p id="c05a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当你的应用在迁移过程中，而<strong class="is hi">还没有在主屏幕或登陆屏幕上安装</strong>组件时，用户可能会在导航到由Compose构建的屏幕时注意到jank。这是因为<strong class="is hi">Compose库只有在第一次使用的时候才会被加载</strong>。有一种变通方法，就是在主页/登录屏幕上添加一个可组合的像素。这种解决方法可以确保合成组件在使用前预热。我们不建议采用这种方法，因为在你的应用程序中实施这种方法会产生对你的功能实现没有帮助的代码，并可能导致不可预见的错误。相反，我们建议结合使用<a class="ae jo" href="https://developer.android.com/topic/libraries/app-startup" rel="noopener ugc nofollow" target="_blank">应用启动库</a>和定制基线配置文件来解决jank问题。我们将对这种组合如何帮助提高应用程序的性能进行基准测试和可视化。</p><h1 id="7002" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用基线配置文件</h1><p id="bd3a" class="pw-post-body-paragraph iq ir hh is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated"><a class="ae jo" href="https://developer.android.com/studio/profile/baselineprofiles" rel="noopener ugc nofollow" target="_blank">基准配置文件</a>有助于改善Android应用的应用启动和运行时性能。基线配置文件是APK中包含的类和方法的列表。Android Runtime (ART)在应用程序安装期间使用它们将关键路径预编译为机器代码。这是一种profile-guided optimization (PGO)形式，通过减少必须实时(JIT)编译的代码量，让应用程序优化启动、减少jank并提高最终用户的性能。</p><p id="5095" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">Jetpack Compose作为一个库分发。这使得频繁的更新组合和向后兼容旧的Android版本。但是作为一个非捆绑的库分发是有成本的；程序库需要在应用启动时加载，并在需要功能时及时解释(要了解更多细节，请查看<a class="ae jo" rel="noopener" href="/androiddevelopers/why-should-you-always-test-compose-performance-in-release-4168dd0f2c71">为什么你总是要在发布时测试编写性能？</a>)。每当应用首次使用库功能时，这可能会导致更长的应用启动时间或jank。为了解决这个问题，Compose提供了一个基线配置文件，以便在安装应用程序时提前编译Compose。在大多数情况下，Compose提供的默认基线配置文件足以提供出色的性能。但是，基于应用程序的常见用户交互来定制个人资料通常会产生更好的结果。</p><h1 id="00e6" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">技术性能分析</h1><p id="678e" class="pw-post-body-paragraph iq ir hh is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">为了分析这种性能提升，我们编写了一些<a class="ae jo" href="https://developer.android.com/topic/performance/benchmarking/macrobenchmark-overview" rel="noopener ugc nofollow" target="_blank">宏基准</a>测试，并在<a class="ae jo" href="https://github.com/android/sunflower" rel="noopener ugc nofollow" target="_blank">向日葵</a>示例应用上测量了性能。该应用程序部分迁移到Compose，在登录/主屏幕上没有任何可组合的内容。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/61ce8cc2435a9c30ecb96ab9457cbbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Yt_yDBZt4I2Gsci3"/></div></div></figure><p id="cf6a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在本次性能分析中，我们将与应用中的三个屏幕进行互动:</p><ul class=""><li id="2571" class="kx ky hh is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">使用基于视图的设计构建的<strong class="is hi">主页</strong>屏幕<strong class="is hi"> </strong>，其中没有任何组件。</li><li id="bffc" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated"><strong class="is hi">工厂列表</strong>屏幕由RecyclerView构建，视图内的每个项目由Compose构建。它使用<a class="ae jo" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView" rel="noopener ugc nofollow" target="_blank"> ComposeView </a>视图来托管撰写内容。</li><li id="f903" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">用Compose构建的<strong class="is hi"> Plant details </strong>屏幕使用<a class="ae jo" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/viewinterop/package-summary#AndroidViewBinding(kotlin.Function3,%20androidx.compose.ui.Modifier,%20kotlin.Function1)" rel="noopener ugc nofollow" target="_blank"> AndroidViewBinding </a>创建Android布局资源并与之交互。</li></ul><p id="8a37" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">Sunflower应用程序代码有一个<a class="ae jo" href="https://github.com/android/sunflower/blob/23872b15c7cfd07c3a24701264057c8fce38c30b/macrobenchmark/src/main/java/com/google/samples/apps/sunflower/macrobenchmark/BaselineProfileGenerator.kt" rel="noopener ugc nofollow" target="_blank"> BaselineProfileGenerator </a>类，用于创建基线概要文件。我们执行了测试，并针对这些关键用户旅程(CUJs)创建了一个定制的基线配置文件。这个概要文件可以在<strong class="is hi">主</strong>源集下的<a class="ae jo" href="https://github.com/android/sunflower/blob/main/app/src/main/baseline-prof.txt" rel="noopener ugc nofollow" target="_blank"><strong class="is hi">baseline-prof . txt</strong></a>文件中找到。与Compose提供的默认基线配置文件相比，自定义基线配置文件确实显示了性能改进。让我们来看看几个场景的测试结果:</p><ul class=""><li id="961c" class="kx ky hh is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated"><strong class="is hi">【场景1】</strong>从主屏幕，用户导航至部分内置在Compose中的工厂列表屏幕。基准测试在<a class="ae jo" href="https://github.com/android/sunflower/blob/4144f97f4fd687af5f1693d1955f01a05e83a005/macrobenchmark/src/main/java/com/google/samples/apps/sunflower/macrobenchmark/PlantListBenchmarks.kt" rel="noopener ugc nofollow" target="_blank"> PlantListBenchmarks </a>类中可用。</li></ul><p id="d7f9" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">Macrobenchmark多次运行您的测试，并以统计分布的形式输出结果。分布以百分位数<strong class="is hi"> P50 </strong> — <strong class="is hi"> P99 </strong>表示。以下是我们运行基准测试时的结果:</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/6d16e9119bdd5fae1731692dc5d28f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PvEcNbJh7rFvR10eYh2OhA.png"/></div></div></figure><blockquote class="lm ln lo"><p id="f2ea" class="iq ir lp is b it iu iv iw ix iy iz ja lq jc jd je lr jg jh ji ls jk jl jm jn ha bi translated">对于上表所示的数据，<strong class="is hi"> P50 </strong>为编译模式。无表示50%的帧渲染速度超过7.1毫秒。</p></blockquote><ul class=""><li id="41fa" class="kx ky hh is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated"><strong class="is hi">【场景2】</strong>用户导航到完全由Compose构建的屏幕，并使用AndroidViewBinding与TextView交互。基准测试在PlantDetailBenchmarks类中可用。以下是我们运行基准测试时的结果:</li></ul><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/01da9894352673f199bf62a06e5b778c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fSC9w90LrK8UPuJ-nbigA.png"/></div></div></figure><p id="9002" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi"> <em class="lp">注:</em> </strong> <em class="lp">基准测试是在三星Galaxy Fold上执行的，您的基准测试结果可能会显示不同的数字，但总体性能影响应该是相似的。</em></p><p id="206c" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当你仔细观察P99的数字时，你会注意到显著的改进。这些异常值通常是导致jank的原因。</p><p id="87d1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为了进一步提高应用程序性能，我们可以使用应用程序启动库在实际使用之前预热组合组件。让我们试一试，看看我们会有什么发现。</p><h1 id="d7ab" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用应用程序启动库预热合成库</h1><p id="1408" class="pw-post-body-paragraph iq ir hh is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated"><a class="ae jo" href="https://developer.android.com/topic/libraries/app-startup" rel="noopener ugc nofollow" target="_blank">应用启动库</a>提供了一种在应用启动时初始化组件的结构化方法。使用应用程序启动库，您可以在应用程序启动期间预热编写库。</p><p id="5dd4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">按照以下步骤使用应用程序启动库添加合成初始值设定项:</p><ul class=""><li id="9b44" class="kx ky hh is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">要在应用中使用Jetpack启动，请在应用的<strong class="is hi"> build.gradle </strong>文件中添加对startup-runtime的依赖。</li></ul><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="2680" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为了预热Compose组件，创建一个新的<code class="du lw lx ly lz b">ComposeInitializer</code>类，如下面的代码片段所示。</p><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lu lv l"/></div><figcaption class="ma mb et er es mc md bd b be z dx">​​ProcessLifecycleInitializer<em class="ie"> ensures that the Compose library is warmed up only when at least one activity is going to be visible.</em></figcaption></figure><blockquote class="lm ln lo"><p id="5369" class="iq ir lp is b it iu iv iw ix iy iz ja lq jc jd je lr jg jh ji ls jk jl jm jn ha bi translated">以这种方式初始化ComposeView不会将内容添加到视图层次结构中，但是它仍然有助于初始化撰写组件。</p></blockquote><ul class=""><li id="11be" class="kx ky hh is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">要使ComposeInitializer可被应用程序启动发现，请导航到项目中的<strong class="is hi"> AndroidManifest.xml </strong>文件。在<code class="du lw lx ly lz b">InitializationProvider</code>清单条目下添加一个<code class="du lw lx ly lz b">&lt;meta-data&gt;</code>条目，如下面的代码所示:</li></ul><figure class="kt ku kv kw fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="2afa" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><code class="du lw lx ly lz b">InitializationProvider</code>是一个特殊的内容提供者，帮助发现和调用您刚刚定义的组件初始化器。</p><ul class=""><li id="0b9a" class="kx ky hh is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated">重新生成并更新基线配置文件，以考虑启动时的更改。基线配置文件生成器是macrobenchmark模块的一部分。你只需要从<code class="du lw lx ly lz b">BaselineProfileGenerator</code>类执行<code class="du lw lx ly lz b">startPlantListPlantDetail</code>测试。</li><li id="4437" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">从<code class="du lw lx ly lz b">PlantListBenchmarks</code>和<code class="du lw lx ly lz b">PlantDetailBenchmarks</code>类重新运行宏基准测试。</li></ul><p id="9b66" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">以下是我们对之前每个场景的发现:</p><ul class=""><li id="fa0b" class="kx ky hh is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated"><strong class="is hi">【场景1】</strong>从主屏幕，用户导航至工厂列表屏幕。</li></ul><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/31482036274b15ccaf6b696da73276e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gGPDMSeGSJBTLoMKgoY9w.png"/></div></div></figure><p id="32f7" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">仔细一看，对于部分用Compose构建的屏幕，离群值似乎有了<strong class="is hi"> ~21% </strong>的提升。通常是异常帧导致了jank。</p><ul class=""><li id="3cb7" class="kx ky hh is b it iu ix iy jb kz jf la jj lb jn lc ld le lf bi translated"><strong class="is hi">【场景2】</strong>用户导航至工厂详情屏幕。</li></ul><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/9173cde3024436bed4c3f361e390cf8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8EziAii03kepkVD3sNJ5w.png"/></div></div></figure><p id="2b55" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">异常值有<strong class="is hi"> ~27% </strong>的百分比改善。</p><p id="5249" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在这两种情况下，添加应用程序启动初始化器提高了性能，特别是对于P99中的异常值。</p><p id="26f9" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><a class="ae jo" href="https://github.com/android/sunflower" rel="noopener ugc nofollow" target="_blank">这里的</a>是访问GitHub上代码的链接。</p></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><p id="7db3" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在的问题是，你应该总是为这样的场景添加应用启动库吗？它适用于你所有的项目吗？在您做出这样的决定之前，我们强烈建议您:</p><ol class=""><li id="6201" class="kx ky hh is b it iu ix iy jb kz jf la jj lb jn mn ld le lf bi translated">编写基准测试并衡量应用程序的性能。</li><li id="d8b4" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn mn ld le lf bi translated">实施变革</li><li id="1c09" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn mn ld le lf bi translated">重新运行您的测试来验证性能是否真的提高了。</li></ol><p id="8cad" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">从长远来看，这种实现方法将帮助您评估这些建议是否真的适用于您的应用程序。让统计数据驱动您的实施选择，以提高性能。</p><h1 id="ea57" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><ul class=""><li id="d557" class="kx ky hh is b it kn ix ko jb mo jf mp jj mq jn lc ld le lf bi translated">无论是否需要应用启动库，都要添加基线配置文件。</li><li id="d966" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">当您的应用在主页/登录屏幕上没有任何组件，并且用户导航到部分或全部由Compose构建的屏幕时，自定义基线配置文件和应用启动库的组合会带来更好的性能结果。</li><li id="6328" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">你可以使用应用程序启动库来预热Compose组件，而不是为了性能(而不是因为设计选择)而在home/landing屏幕上添加Compose。</li><li id="99f5" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated">仅仅因为有人建议并不意味着你必须遵循那个建议。编写宏基准测试来检查应用启动库是否真的提高了应用的性能。让统计数据驱动您的实施选择，以确保它们能够带来性能改进。</li></ul><p id="f35c" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">感谢本·特伦格罗夫、弗洛里纳·芒特内斯库、本·韦斯、瑞安·门特利和拉胡尔·拉维库马尔对评论的帮助。</p><h1 id="0b7e" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">参考资料:</h1><ul class=""><li id="367f" class="kx ky hh is b it kn ix ko jb mo jf mp jj mq jn lc ld le lf bi translated"><a class="ae jo" href="https://developer.android.com/topic/libraries/app-startup" rel="noopener ugc nofollow" target="_blank"> App启动</a></li><li id="dce7" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated"><a class="ae jo" href="https://developer.android.com/codelabs/android-macrobenchmark-inspect#0" rel="noopener ugc nofollow" target="_blank">用Macrobenchmark检查app性能</a></li><li id="bfa4" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated"><a class="ae jo" href="https://developer.android.com/codelabs/android-baseline-profiles-improve#0" rel="noopener ugc nofollow" target="_blank">通过基准配置文件提高应用性能</a></li><li id="8839" class="kx ky hh is b it lg ix lh jb li jf lj jj lk jn lc ld le lf bi translated"><a class="ae jo" href="https://developer.android.com/topic/performance" rel="noopener ugc nofollow" target="_blank">应用性能指南</a></li></ul></div></div>    
</body>
</html>