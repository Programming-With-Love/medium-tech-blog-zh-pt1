<html>
<head>
<title>Terraform in Real Life: Lessons Learned</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现实生活中的地形:经验教训</h1>
<blockquote>原文：<a href="https://medium.com/version-1/terraform-in-real-life-lessons-learned-2469e3fe74e6?source=collection_archive---------0-----------------------#2021-09-21">https://medium.com/version-1/terraform-in-real-life-lessons-learned-2469e3fe74e6?source=collection_archive---------0-----------------------#2021-09-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/fcf7de3ec23f9623701dc82f8a0f48fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ci8beRICk0Q3k8cQ9fyQw.png"/></div></div></figure><p id="01f7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为<a class="ae jn" href="https://www.version1.com/" rel="noopener ugc nofollow" target="_blank">第一版</a>的<a class="ae jn" href="https://www.version1.com/about-us/our-technology-partnerships/amazon-web-services/" rel="noopener ugc nofollow" target="_blank"> AWS顾问</a>，基础设施作为代码在我的工作中扮演了重要角色。由于我们是一个云计算合作伙伴，我们选择的IaC工具是Terraform。除了支持许多提供商(包括所有主要的云)，Terraform还为平台工程师提供了许多好处，包括集中式状态管理、版本可控模块和一些高级语言功能。</p><p id="6a15" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我已经为AWS和Azure使用Hashicorp工具超过4年了，并且是一名认证的Terraform助理。我想用这篇文章来概述我经历过的一些错误/陷阱/最佳实践。</p><p id="f0d3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下不是全面的最佳实践指南。哈希公司提供了<a class="ae jn" href="https://learn.hashicorp.com/terraform" rel="noopener ugc nofollow" target="_blank">关于如何使用Terraform的很棒的材料</a>和他们推荐的做法，如果你还没有的话，值得去看看。以下是我根据自己的经验总结的一些小技巧。</p><h1 id="e1ba" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">非常熟悉提供商文档(和变更日志)</h1><p id="1f81" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">如果你是Terraform的新手，并计划更多地使用它，你绝对需要知道如何浏览<a class="ae jn" href="https://registry.terraform.io/namespaces/hashicorp" rel="noopener ugc nofollow" target="_blank"> terraform提供商文档</a>。例如，如果你打算在AWS中构建，你将在这里花费大量的时间<a class="ae jn" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs" rel="noopener ugc nofollow" target="_blank"/>。在撰写本文时，Terraform支持140种AWS服务——每种服务都有一个或多个具有许多属性的资源。而这只是针对AWS。</p><p id="64a5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然没有人会使用每一种资源，但你无疑需要知道你使用的资源有哪些选择。在这方面，提供商文档是您的圣经。每当更新提供商时，文档都会作为版本的一部分进行更新，因此它们也会反映最新的可用资源和属性。</p><p id="2255" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一个方便的信息来源是提供者变更日志。同样，每个提供程序版本都会更新这些信息。它们是检查资源最近变化的有用方法，这些变化有时会导致代码中不必要的变化，甚至破坏您的Terraform计划。这可以通过固定您的提供商版本来缓解(见下文)，但有时您需要使用最新的提供商来利用您最喜欢的云的新版本。例如，这里有一个<a class="ae jn" href="https://github.com/hashicorp/terraform-provider-aws/blob/main/CHANGELOG.md" rel="noopener ugc nofollow" target="_blank"> AWS提供商变更日志</a>，我发现在这个页面上搜索特定的资源(例如“aws_ec2_transit_gateway”)来查找任何最近的变更非常方便。</p><h1 id="75b9" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">版本化您的Terraform(和提供商)</h1><p id="aba5" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">正如Hashicorp推荐的<a class="ae jn" href="https://learn.hashicorp.com/tutorials/terraform/provider-versioning?in=terraform/configuration-language" rel="noopener ugc nofollow" target="_blank">,向Terraform和provider版本添加约束是最佳实践。虽然您的配置中使用的Terraform和每个提供程序的版本都应该被固定(约束)，但它们会以不同的方式影响您的代码:</a></p><p id="49e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> Terraform版本</strong> : <code class="du kr ks kt ku b">terraform</code>命令(<code class="du kr ks kt ku b">init|plan|apply</code>等)使用安装在其运行的主机上的Terraform版本。因此版本不会改变，除非你重新安装Terraform(或使用<code class="du kr ks kt ku b">tfswitch</code>——见下文)。但是，当您开始与其他工程师一起处理更大的项目时，跨桌面一致性的要求就很明显了。通过在配置中设置所需的Terraform版本，所有使用该配置的开发人员必须在其计算机上安装正确版本的Terraform。</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="df31" class="ld jp hh ku b fi le lf l lg lh">terraform {<br/>  required_version = "~&gt; 1.0.5" # &gt;= 1.0.5, &lt; 1.1.0<br/>}</span></pre><p id="5dbb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的例子中，你可以看到我使用了一个<code class="du kr ks kt ku b">~</code> (tilda)作为版本约束的一部分，tilda允许在一个特定的次要版本中发布新的补丁，所以在这种情况下，我们可以使用1.0.5到下一个主要版本(1.1.0)之间的任何版本。</p><p id="0c10" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">提供者:</strong>与已经安装在主机上的Terraform不同，提供者在<code class="du kr ks kt ku b">terraform init</code>期间被拉取。默认行为是在您的代码中获取每个提供程序的最新版本。如上所述，最新的并不总是您想要的，因为它会对您已经构建的现有资源带来变化。</p><p id="bcbd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Terraform提供了两种管理提供程序版本的简单方法，传统方法是在terraform块中使用约束，即设置Terraform版本的位置:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="230c" class="ld jp hh ku b fi le lf l lg lh">terraform {<br/>  required_version = "~&gt; 1.0.5" # &gt;= 1.0.5, &lt; 1.1.0<br/>  required_providers {<br/>    aws = {<br/>      source  = "hashicorp/aws"<br/>      version = "~&gt; 3.0" # &gt;= 3.0 &lt; 4.0<br/>    }<br/>  }<br/>}</span></pre><h1 id="e91a" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用for_each代替count</h1><p id="4fe1" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在Terraform 12中引入<code class="du kr ks kt ku b">for_each</code>之前，<code class="du kr ks kt ku b">count</code>是从单个资源块创建多个相似对象的唯一方法。使用<code class="du kr ks kt ku b">count</code>的缺点是它创建了一个难以修改的资源列表。举以下例子:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="0c4e" class="ld jp hh ku b fi le lf l lg lh">variable "subnets" {<br/>  default = ["10.1.11.0/24", "10.1.12.0/24"]<br/>}</span><span id="a6d9" class="ld jp hh ku b fi li lf l lg lh">resource "aws_subnet" "this" {<br/>  count      = length(var.subnets)<br/>  cidr_block = var.subnets[count.index]<br/>  vpc_id     = var.vpc_id<br/>}</span></pre><p id="e08d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面的代码将创建两个子网—列表中的每个cidr一个子网:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="9188" class="ld jp hh ku b fi le lf l lg lh">Terraform will perform the following actions:</span><span id="c9c7" class="ld jp hh ku b fi li lf l lg lh"># aws_subnet.main[0] will be created<br/>  + resource "aws_subnet" "main" {<br/>      ...<br/>      + cidr_block                      = "10.1.11.0/24"<br/>      + tags                            = {<br/>          + "Name" = "subnet-10.1.11.0/24"<br/>        }<br/>      ...<br/>    }</span><span id="3bd5" class="ld jp hh ku b fi li lf l lg lh"># aws_subnet.main[1] will be created<br/>  + resource "aws_subnet" "main" {<br/>      ...<br/>      + cidr_block                      = "10.1.12.0/24"<br/>      + tags                            = {<br/>          + "Name" = "subnet-10.1.12.0/24"<br/>        }<br/>      ...<br/>    }</span><span id="6654" class="ld jp hh ku b fi li lf l lg lh">Plan: 2 to add, 0 to change, 0 to destroy.</span></pre><p id="d8f6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，如果我们要添加第三个子网，在其他子网之前添加cidr块，子网变量如下所示:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="9382" class="ld jp hh ku b fi le lf l lg lh">variable "subnets" {<br/>  default = ["10.1.10.0/24","10.1.11.0/24", "10.1.12.0/24"]<br/>}</span></pre><p id="464d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将导致以下计划:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="1691" class="ld jp hh ku b fi le lf l lg lh">Plan: 3 to add, 0 to change, 2 to destroy.</span></pre><p id="2281" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们从该计划中看到的，我们的2个原始子网将被<strong class="ir hi">销毁</strong>并重新创建。这是使用<code class="du kr ks kt ku b">count</code>创建资源列表的局限性。解决方法是使用Terraform的<code class="du kr ks kt ku b">for_each</code>来代替:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="d837" class="ld jp hh ku b fi le lf l lg lh">variable "subnets" {<br/>  default = ["10.1.11.0/24", "10.1.12.0/24"]<br/>}</span><span id="6978" class="ld jp hh ku b fi li lf l lg lh">resource "aws_subnet" "main" {<br/>  for_each = toset(var.subnets) # toset converts var.subnets to a set, which is required when using for_each on a list</span><span id="812f" class="ld jp hh ku b fi li lf l lg lh">  vpc_id     = var.vpc_id<br/>  cidr_block = each.value</span><span id="7e24" class="ld jp hh ku b fi li lf l lg lh">  tags = {<br/>    Name = "subnet-${each.value}"<br/>  }<br/>}</span></pre><p id="de42" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当使用for_each并将一个条目添加到列表的开头或结尾时，我们的计划中只有一个变化，这就是我们想要的:</p><pre class="kv kw kx ky fd kz ku la lb aw lc bi"><span id="0000" class="ld jp hh ku b fi le lf l lg lh">variable "subnets" {<br/>  default = ["10.1.10.0/24","10.1.11.0/24", "10.1.12.0/24"]<br/>}</span><span id="e587" class="ld jp hh ku b fi li lf l lg lh">...</span><span id="6eea" class="ld jp hh ku b fi li lf l lg lh">Plan: 1 to add, 0 to change, 0 to destroy.</span></pre><p id="8442" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面的例子强调了使用<code class="du kr ks kt ku b">count</code>在更新资源时会带来复杂性。因此，将<code class="du kr ks kt ku b">for_each</code>用于资源列表，将<code class="du kr ks kt ku b">count</code>用于简单的组是一个很好的实践:</p><blockquote class="lj lk ll"><p id="720f" class="ip iq lm ir b is it iu iv iw ix iy iz ln jb jc jd lo jf jg jh lp jj jk jl jm ha bi translated">如果你的实例几乎相同，<code class="du kr ks kt ku b">count</code>是合适的。如果他们的一些参数需要不同的值，而这些值不能直接从整数中导出，那么使用<code class="du kr ks kt ku b">for_each</code>会更安全。</p></blockquote><h1 id="5361" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用(并保护)远程状态</h1><p id="e091" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">与其他IaC工具相比，Terraform的一个关键特性是它的状态管理。Terraform使用状态文件来记住它所管理的资源的预期状态。这使我们能够维护和更新环境。</p><blockquote class="lj lk ll"><p id="425b" class="ip iq lm ir b is it iu iv iw ix iy iz ln jb jc jd lo jf jg jh lp jj jk jl jm ha bi translated">Terraform使用此状态将真实世界的资源映射到您的配置，跟踪元数据，并提高大型基础架构的性能。</p></blockquote><p id="95b5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">默认情况下，Terraform将状态存储在一个名为<code class="du kr ks kt ku b">terraform.tfstate</code>的本地文件中。虽然这对于快速的演示/POC部署来说很好，但是不推荐用于生产构建，尤其是那些由团队管理的构建。每个开发人员都需要访问statefile的最新版本，以避免对现有资源的意外更新。</p><p id="5474" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Terraform提供远程后端，用于存储集中式状态文件，以支持协作和版本控制。例如，在AWS中，远程状态可以存储在S3或运行在RDS上的Postgres数据库中。与S3相比，使用Postgres数据库的一个优点是它提供了<strong class="ir hi">状态锁定</strong>，防止并发更新状态文件(例如，来自多个开发人员或管道)。</p><p id="3019" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在状态文件中需要注意的重要一点是，它们包含资源的所有属性，并且可能包含秘密和其他敏感数据。因此，像保护数据库或其他敏感数据存储一样保护您的远程后端是一个很好的做法。例如，对于S3，我们建议使用SSE加密静态数据，并使用IAM和存储桶策略限制用户和网络访问。此外，我建议启用bucket versioning来允许在状态文件损坏或删除的情况下进行恢复。</p><h1 id="2930" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">全押在Terraform上</h1><p id="0034" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">如前一节所述，Terraform是有状态的——它跟踪对您的基础设施所做的更改，不管它是否做了这些更改。</p><p id="1047" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，如果Terraform创建了一个带有一些标记的安全组，然后系统管理员通过控制台手动更改这些标记…下次Terraform应用时，它会将标记更新为原始值。虽然这个场景听起来并不是灾难性的，但它强调了在其他地方对由Terraform管理的资源进行更改将会出现的问题。</p><p id="7cd7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果sysadmin没有修改标签，而是修改了一些更重要的东西，比如将<code class="du kr ks kt ku b">instance_type</code>修改为一个更大的实例，然后Terraform在下一次应用时恢复它，这会给应用程序带来重大问题。因此，建议在Terraform上全押，避免将IaC与手动更改结合使用。</p><p id="4d55" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Terraform确实提供了修改其状态的命令(<code class="du kr ks kt ku b">rm | import | taint</code>)，可以利用这些命令使Terraform“忘记”或“发现”资源。但是，根据经验，我发现这些过程可能会很复杂和混乱，应该作为最后的手段使用。我的建议是——如果你用Terraform创建它——用Terraform管理它。</p><h1 id="50f2" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Terraform不能做所有的事情…或者至少不应该做</h1><p id="e728" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">虽然Terraform是构建基础设施的绝佳工具，但它并不适合所有情况。将所有东西都放在您的<code class="du kr ks kt ku b">.tf</code>文件中，并使用像<code class="du kr ks kt ku b">aws_cloudformation_stack</code>这样的资源，像<code class="du kr ks kt ku b">local-exec</code>和<code class="du kr ks kt ku b">remote-exec</code>这样的供应器，以及其他运行非本地脚本的方式，这很有诱惑力。沿着这条路线走下去，你会很容易发现自己处于“方钉圆孔”的领地。</p><p id="bdd8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通常，当您扩展Terraform的边界时，您就开始损害它提供的好处，例如更新现有资源。我并不是说不要在Terraform中使用trigger other脚本，这在某些情况下是有意义的，比如当你已经在CFN定义了一个完整的栈，但是其他的都是用Terraform部署的。根据经验，我建议尽可能使用原生Terraform资源，并考虑使用其他他们擅长的工具，例如Ansible，用于配置实例和部署应用程序的管道。</p><h1 id="16ec" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用工具</h1><p id="b253" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">这篇文章的最后一个技巧是利用现有的地形工具。随着Terraform越来越受欢迎，越来越多的开源助手工具变得可用。正如在上面的模块中提到的，随着你的Terraform足迹的增长，加强标准化是必要的。这些工具中的许多将有助于实施最佳实践，尤其是当包含在您的CI流程中时。以下是我最喜欢的一些，但绝不是详尽的列表:</p><ul class=""><li id="b7a3" class="lq lr hh ir b is it iw ix ja ls je lt ji lu jm lv lw lx ly bi translated"><code class="du kr ks kt ku b">terraform fmt</code>:内置<a class="ae jn" href="https://www.terraform.io/docs/cli/commands/fmt.html" rel="noopener ugc nofollow" target="_blank">地形命令</a>应用推荐的编码约定</li><li id="7677" class="lq lr hh ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated">tfswitch :在你的工作站上管理和切换地形版本的便捷工具</li><li id="58a4" class="lq lr hh ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated">tflint :用于实施最佳实践的插件(比如命名约定)</li><li id="981b" class="lq lr hh ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated">tfsec :对您的terraform模板进行静态分析，以发现潜在的安全问题(比如硬编码的密码)</li><li id="2165" class="lq lr hh ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated"><a class="ae jn" href="https://github.com/gruntwork-io/terratest" rel="noopener ugc nofollow" target="_blank"> terratest </a>:自动化测试库，通过发出HTTP请求、API调用、SSH连接等来验证基础设施在该环境中是否正常工作。</li><li id="b548" class="lq lr hh ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated"><a class="ae jn" href="https://github.com/terraform-docs/terraform-docs" rel="noopener ugc nofollow" target="_blank"> terraform_docs </a>:用于生成terraform模块文档的包</li><li id="8942" class="lq lr hh ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated"><a class="ae jn" href="https://www.checkov.io/4.Integrations/Terraform%20Scanning.html" rel="noopener ugc nofollow" target="_blank">checkov</a>:IaC工具的静态代码分析，它提供了AWS和Azure的<a class="ae jn" href="https://www.checkov.io/5.Policy%20Index/terraform.html" rel="noopener ugc nofollow" target="_blank">最佳实践检查</a>以及对定制规则的支持</li><li id="ea45" class="lq lr hh ir b is lz iw ma ja mb je mc ji md jm lv lw lx ly bi translated"><a class="ae jn" href="https://github.com/antonbabenko/pre-commit-terraform" rel="noopener ugc nofollow" target="_blank">预提交</a>:在推送Terraform代码之前，强制/提醒开发人员执行某些操作(如fmt、lint、docs)的git挂钩集合</li></ul><figure class="kv kw kx ky fd ii er es paragraph-image"><div class="er es me"><img src="../Images/76f336d4ca141598cc43a3ed89cb6423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuMaHUPv21sLk7vxL6iU2Q.png"/></div></figure></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><p id="6a5b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lm">希望你发现了一些对你自己的Terraform冒险有帮助的提示。有许多话题我没有在这篇博客中涉及，包括模块和CI/CD。我希望在以后的文章中涵盖这些内容。如果你有任何问题，或者你自己的建议，或者工具推荐分享，请在评论中发表。</em></p></div></div>    
</body>
</html>