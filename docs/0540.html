<html>
<head>
<title>Animating your keyboard (part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">制作键盘动画(第1部分)</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/animating-your-keyboard-fb776a8fb66d?source=collection_archive---------0-----------------------#2020-08-24">https://medium.com/androiddevelopers/animating-your-keyboard-fb776a8fb66d?source=collection_archive---------0-----------------------#2020-08-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/accbb959ec31fb6ba5f2a7223b1d6d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hIMlje5SoWGOpSm-BGEZQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/_kiranpuri" rel="noopener ugc nofollow" target="_blank">Kiran Puri</a></figcaption></figure><div class=""/><div class=""><h2 id="2ee8" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">新的WindowInsets APIs用于检查键盘(IME)的可见性和大小</h2></div><p id="1199" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在<a class="ae hu" href="https://developer.android.com/android11" rel="noopener ugc nofollow" target="_blank"> Android 11 </a>中的新功能是应用程序能够在屏幕键盘打开和关闭之间创建无缝过渡，这一切都是由对<a class="ae hu" href="https://developer.android.com/android11" rel="noopener ugc nofollow" target="_blank"> Android 11 </a>中的<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/android/view/WindowInsets" rel="noopener ugc nofollow" target="_blank">WindowInsets</a></code>API的大量改进推动的。</p><p id="45bd" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">下面是它在Android 11上运行的两个例子。它已被集成到<a class="ae hu" href="https://play.google.com/store/apps/details?id=com.google.android.googlequicksearchbox&amp;hl=en_GB" rel="noopener ugc nofollow" target="_blank">谷歌搜索</a>应用程序，以及<a class="ae hu" href="https://play.google.com/store/apps/details?id=com.google.android.apps.messaging" rel="noopener ugc nofollow" target="_blank">消息</a>应用程序中:</p><figure class="kn ko kp kq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es km"><img src="../Images/b2ce6ec6c65ab5fdebe6485c9b5c632f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yc4QV2vZiA7ve3PVSrsW4w.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Two examples of keyboard animations in Android 11: Google Search app (left), Messages (right)</figcaption></figure><p id="2a98" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因此，让我们看看如何将这种体验添加到您的应用程序中。有三个步骤:</p><ol class=""><li id="a915" class="kr ks hx jo b jp jq js jt jv kt jz ku kd kv kh kw kx ky kz bi translated">首先，我们需要边对边。</li><li id="2e2f" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh kw kx ky kz bi translated">第二步是应用程序开始对插入动画做出反应。</li><li id="eeff" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh kw kx ky kz bi translated">第三步是应用程序控制和驱动插入动画，如果这对你的应用程序有意义的话。</li></ol><p id="1876" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这些步骤一个接一个，所以我们将在单独的博客文章中讨论每个步骤。在这篇<strong class="jo hy">第一篇</strong>文章中，我们将讨论边缘到边缘，以及Android 11中相关的API变化。</p><h1 id="1c78" class="lf lg hx bd lh li lj lk ll lm ln lo lp jd lq je lr jg ls jh lt jj lu jk lv lw bi translated">边缘对边缘</h1><p id="8096" class="pw-post-body-paragraph jm jn hx jo b jp lx iy jr js ly jb ju jv lz jx jy jz ma kb kc kd mb kf kg kh ha bi translated">去年，我们引入了边缘到边缘的概念，作为应用程序充分利用Android 10中新的手势导航的一种方式:</p><div class="hg hh ez fb hi mc"><a rel="noopener follow" target="_blank" href="/androiddevelopers/gesture-navigation-going-edge-to-edge-812f62e4e83e"><div class="md ab dw"><div class="me ab mf cl cj mg"><h2 class="bd hy fi z dy mh ea eb mi ed ef hw bi translated">手势导航:从边缘到边缘(一)</h2><div class="mj l"><h3 class="bd b fi z dy mh ea eb mi ed ef dx translated">Android Q增加了一个新的系统导航模式，允许用户导航回主屏幕…</h3></div><div class="mk l"><p class="bd b fp z dy mh ea eb mi ed ef dx translated">medium.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq ho mc"/></div></div></a></div></div><div class="ab cl mr ms go mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ha hb hc hd he"><figure class="kn ko kp kq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es my"><img src="../Images/d89e49ba95b1e481f00689f5a586a606.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*g8oz_UWkJ_1cFXNnEBGjNA.gif"/></div></div></figure><p id="3c4a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">作为一个快速的重新封顶，从边到边会导致你的应用在系统栏后面绘制，就像你在左边看到的。</p><p id="754a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">引用我去年的话:</p><blockquote class="mz"><p id="ee90" class="na nb hx bd nc nd ne nf ng nh ni kh dx translated"><em class="nj">通过边缘到边缘，应用程序将被放置在系统栏的后面。这是为了让你的应用程序内容闪闪发光，为你的用户创造一个更加身临其境的体验。</em></p></blockquote><h2 id="c5bf" class="nk lg hx bd lh nl nm nn ll no np nq lp jv nr ns lr jz nt nu lt kd nv nw lv nx bi translated"><strong class="ak">那么，边到边和键盘有什么关系呢？</strong></h2><p id="b789" class="pw-post-body-paragraph jm jn hx jo b jp lx iy jr js ly jb ju jv lz jx jy jz ma kb kc kd mb kf kg kh ha bi translated">实际上，从边缘到边缘不仅仅是在状态栏和导航栏后面绘图。应用程序负责处理那些可能与应用程序重叠的系统用户界面。</p><p id="118f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">两个明显的例子是我们前面提到的状态栏和导航栏。然后我们有了屏幕键盘，或者有时被称为IME；这只是另一个需要注意的系统UI。</p><h1 id="07b1" class="lf lg hx bd lh li lj lk ll lm ln lo lp jd lq je lr jg ls jh lt jj lu jk lv lw bi translated">应用如何走向边缘？</h1><p id="6162" class="pw-post-body-paragraph jm jn hx jo b jp lx iy jr js ly jb ju jv lz jx jy jz ma kb kc kd mb kf kg kh ha bi translated">如果我们回顾一下去年的指南,“走向边缘”由3项任务组成:</p><ol class=""><li id="33a9" class="kr ks hx jo b jp jq js jt jv kt jz ku kd kv kh kw kx ky kz bi translated">更改系统栏颜色</li><li id="d8ff" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh kw kx ky kz bi translated">请求全屏显示</li><li id="4af8" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh kw kx ky kz bi translated">处理视觉冲突</li></ol><p id="ce7e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们将跳过第一个任务，因为自去年以来没有任何变化。Android 11中更新了第2步和第3步的指导，并做了一些更改。让我们来看看。</p><h2 id="cf62" class="nk lg hx bd lh nl ny nn ll no nz nq lp jv oa ns lr jz ob nu lt kd oc nw lv nx bi translated">#2:要求全屏显示</h2><p id="cba4" class="pw-post-body-paragraph jm jn hx jo b jp lx iy jr js ly jb ju jv lz jx jy jz ma kb kc kd mb kf kg kh ha bi translated">第二步，应用程序需要使用带有一堆标志的<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.html#setSystemUiVisibility(int)" rel="noopener ugc nofollow" target="_blank">systemUiVisibility</a></code> API，请求全屏显示:</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="od oe l"/></div></figure><p id="03ce" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果您正在使用这个API，并且已经将您的编译SDK版本更新到了<strong class="jo hy"> 30 </strong>，您将会看到所有这些API现在都被否决了。</p><p id="1926" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">它们已经被Window上的一个名为<code class="du ki kj kk kl b">setDecorFitsSystemWindows()</code>的功能所取代:</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="od oe l"/></div></figure><p id="8e8c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果应用程序想要处理任何系统窗口的调整(从而全屏显示)，你现在可以传入一个布尔值:<code class="du ki kj kk kl b">false</code>。</p><p id="afda" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们在<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/core/view/WindowCompat" rel="noopener ugc nofollow" target="_blank">WindowCompat</a></code>中也有该功能的Jetpack版本，这是最近在androidx.core <code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/core#1.5.0-alpha02" rel="noopener ugc nofollow" target="_blank">v1.5.0-alpha02</a></code>中发布的。</p><p id="3d54" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这是更新的第二步。</p><h2 id="bba8" class="nk lg hx bd lh nl ny nn ll no nz nq lp jv oa ns lr jz ob nu lt kd oc nw lv nx bi translated">#3:处理视觉冲突</h2><p id="593b" class="pw-post-body-paragraph jm jn hx jo b jp lx iy jr js ly jb ju jv lz jx jy jz ma kb kc kd mb kf kg kh ha bi translated">现在让我们看看第三步:避免与系统UI重叠，这可以概括为使用窗口insets来知道将内容移动到哪里，以避免与系统UI冲突。在Android上，insets由<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/android/view/WindowInsets" rel="noopener ugc nofollow" target="_blank">WindowInsets</a></code>类表示，在AndroidX上由<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/core/view/WindowInsetsCompat" rel="noopener ugc nofollow" target="_blank">WindowInsetsCompat</a></code>表示</p><p id="17d1" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果我们在API 30更新之前看一下<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/android/view/WindowInsets" rel="noopener ugc nofollow" target="_blank">WindowInsets</a></code>，最常用的插入类型是系统窗口插入。这些覆盖了状态栏和导航栏，以及打开时的键盘。</p><p id="3a43" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">要使用<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/android/view/WindowInsets" rel="noopener ugc nofollow" target="_blank">WindowInsets</a></code>，您通常会向视图添加一个<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/OnApplyWindowInsetsListener" rel="noopener ugc nofollow" target="_blank">OnApplyWindowInsetsListener</a></code>，并处理传递给它的任何insets:</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="od oe l"/></div></figure><p id="2416" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这里我们获取<a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/core/view/WindowInsetsCompat#getsystemwindowinsets" rel="noopener ugc nofollow" target="_blank">系统窗口插入</a>，然后更新视图的填充以匹配，这是一个非常常见的用例。</p><p id="7720" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">还有许多其他的插入类型，包括最近从Android 10添加的手势插入:</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="od oe l"/></div></figure><p id="3e80" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">类似于<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.html#setSystemUiVisibility(int)" rel="noopener ugc nofollow" target="_blank">systemUiVisibility</a></code> API，许多<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/core/view/WindowInsetsCompat" rel="noopener ugc nofollow" target="_blank">WindowInsets</a></code>API已经被弃用，取而代之的是查询不同类型插入的新函数:</p><ul class=""><li id="bfdd" class="kr ks hx jo b jp jq js jt jv kt jz ku kd kv kh of kx ky kz bi translated"><code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsets#getInsets(int)&#10;" rel="noopener ugc nofollow" target="_blank">getInsets(type: Int)</a></code>它将返回给定类型的可见insets。</li><li id="7eb8" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh of kx ky kz bi translated"><code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsets#getInsetsIgnoringVisibility(int)" rel="noopener ugc nofollow" target="_blank">getInsetsIgnoringVisibility(type: Int)</a></code>返回插图，不管它们是否可见。</li><li id="0d20" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh of kx ky kz bi translated"><code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsets#isVisible(int)" rel="noopener ugc nofollow" target="_blank">isVisible(type: Int)</a></code>如果给定的类型可见，则返回<code class="du ki kj kk kl b">true</code>。</li></ul><p id="6bcc" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们刚刚在那里提到了很多“类型”。这些在<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/android/view/WindowInsets.Type" rel="noopener ugc nofollow" target="_blank">WindowInsets.<strong class="jo hy">Type</strong></a></code>类中被定义为函数，每个函数返回一个整数标志。您可以组合多种类型，使用按位<code class="du ki kj kk kl b">OR</code>来查询组合类型，我们马上就会看到。</p><p id="d722" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">所有这些API都已经被反向移植到<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/core" rel="noopener ugc nofollow" target="_blank"> AndroidX核心</a>中的<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/WindowInsetsCompat" rel="noopener ugc nofollow" target="_blank">WindowInsetsCompat</a></code>，所以你可以安全地将它们使用回API 14(更多信息请参见<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/core#1.5.0-alpha02" rel="noopener ugc nofollow" target="_blank">发布说明</a>)。</p><p id="33a5" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因此，如果我们回到之前的示例，将其更新为新的API，它们就变成了:</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="od oe l"/></div></figure><h1 id="fb3a" class="lf lg hx bd lh li lj lk ll lm ln lo lp jd lq je lr jg ls jh lt jj lu jk lv lw bi translated">输入法类型⌨️</h1><p id="73b6" class="pw-post-body-paragraph jm jn hx jo b jp lx iy jr js ly jb ju jv lz jx jy jz ma kb kc kd mb kf kg kh ha bi translated">现在敏锐的眼睛👀可能一直在看这个类型列表，并且一直在看一个特别的类型:<a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsets.Type#ime()" rel="noopener ugc nofollow" target="_blank"> <strong class="jo hy"> IME类型</strong> </a>。</p><p id="ece4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">好了，我们终于可以回答这个<a class="ae hu" href="https://stackoverflow.com/questions/2150078/how-to-check-visibility-of-software-keyboard-in-android" rel="noopener ugc nofollow" target="_blank"> StackOverflow问题</a>了，这个问题来自10多年前(流行的迟到)，关于如何检查键盘的可见性。🎉</p><div class="hg hh ez fb hi mc"><a href="https://stackoverflow.com/questions/2150078/how-to-check-visibility-of-software-keyboard-in-android" rel="noopener  ugc nofollow" target="_blank"><div class="md ab dw"><div class="me ab mf cl cj mg"><h2 class="bd hy fi z dy mh ea eb mi ed ef hw bi translated">如何在Android中检查软件键盘的可见性？</h2><div class="mk l"><p class="bd b fp z dy mh ea eb mi ed ef dx translated">stackoverflow.com</p></div></div><div class="ml l"><div class="og l mn mo mp ml mq ho mc"/></div></div></a></div><p id="e851" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了获得当前的键盘可见性，我们可以获取根窗口insets，然后调用<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/android/view/WindowInsets#isvisible" rel="noopener ugc nofollow" target="_blank">isVisible()</a></code>函数，传入<a class="ae hu" href="https://developer.android.com/reference/kotlin/android/view/WindowInsets.Type#ime()" rel="noopener ugc nofollow" target="_blank"> IME </a>类型。</p><p id="fa4f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">同样，如果我们想知道高度，我们也可以这样做:</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="od oe l"/></div></figure><p id="26a5" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果我们需要监听键盘的变化，我们可以使用普通的<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/OnApplyWindowInsetsListener" rel="noopener ugc nofollow" target="_blank">OnApplyWindowInsetsListener</a></code>，并使用相同的功能:</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="od oe l"/></div></figure><h1 id="f994" class="lf lg hx bd lh li lj lk ll lm ln lo lp jd lq je lr jg ls jh lt jj lu jk lv lw bi translated">隐藏/显示键盘</h1><p id="1e6d" class="pw-post-body-paragraph jm jn hx jo b jp lx iy jr js ly jb ju jv lz jx jy jz ma kb kc kd mb kf kg kh ha bi translated">既然我们有一大堆回答StackOverflow的问题，那么这个11年前的关于如何合上键盘的问题怎么样？</p><div class="hg hh ez fb hi mc"><a href="https://stackoverflow.com/questions/1109022/how-do-you-close-hide-the-android-soft-keyboard-using-java" rel="noopener  ugc nofollow" target="_blank"><div class="md ab dw"><div class="me ab mf cl cj mg"><h2 class="bd hy fi z dy mh ea eb mi ed ef hw bi translated">如何关闭/隐藏安卓软键盘？</h2><div class="mk l"><p class="bd b fp z dy mh ea eb mi ed ef dx translated">stackoverflow.com</p></div></div><div class="ml l"><div class="oh l mn mo mp ml mq ho mc"/></div></div></a></div><p id="af89" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这里我们要介绍的是Android 11中的另一个新API，叫做<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController" rel="noopener ugc nofollow" target="_blank"><strong class="jo hy">WindowInsetsController</strong></a></code>。</p><p id="d182" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">应用程序可以从任何角度访问控制器，然后通过调用<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController#show(int)" rel="noopener ugc nofollow" target="_blank">show()</a></code>或<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController#hide(int)" rel="noopener ugc nofollow" target="_blank">hide()</a></code>，传入IME类型来显示或隐藏键盘:</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="od oe l"/></div></figure><p id="8c34" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是隐藏和显示键盘并不是控制器能做的全部…</p><h1 id="6a48" class="lf lg hx bd lh li lj lk ll lm ln lo lp jd lq je lr jg ls jh lt jj lu jk lv lw bi translated">WindowInsetsController</h1><p id="8f1b" class="pw-post-body-paragraph jm jn hx jo b jp lx iy jr js ly jb ju jv lz jx jy jz ma kb kc kd mb kf kg kh ha bi translated">之前我们说过一些<code class="du ki kj kk kl b">View.SYSTEM_UI_*</code>标志在Android 11中已经被弃用，取而代之的是新的API。还有许多其他的<code class="du ki kj kk kl b">View.SYSTEM_UI</code>标志可用，与改变系统UI外观或可见性有关，包括:</p><ul class=""><li id="b502" class="kr ks hx jo b jp jq js jt jv kt jz ku kd kv kh of kx ky kz bi translated"><code class="du ki kj kk kl b">View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION</code></li><li id="54f4" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh of kx ky kz bi translated"><code class="du ki kj kk kl b">View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN</code></li><li id="9dda" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh of kx ky kz bi translated"><code class="du ki kj kk kl b">View.SYSTEM_UI_FLAG_LAYOUT_STABLE</code></li><li id="360f" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh of kx ky kz bi translated"><code class="du ki kj kk kl b">View.SYSTEM_UI_FLAG_LOW_PROFILE</code></li><li id="b9cb" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh of kx ky kz bi translated"><code class="du ki kj kk kl b">View.SYSTEM_UI_FLAG_FULLSCREEN</code></li><li id="6510" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh of kx ky kz bi translated"><code class="du ki kj kk kl b">View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</code></li><li id="a7f0" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh of kx ky kz bi translated"><code class="du ki kj kk kl b">View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY</code></li><li id="f096" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh of kx ky kz bi translated"><code class="du ki kj kk kl b">View.SYSTEM_UI_FLAG_IMMERSIVE</code></li><li id="9bd6" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh of kx ky kz bi translated"><code class="du ki kj kk kl b">View.SYSTEM_UI_FLAG_VISIBLE</code></li><li id="b947" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh of kx ky kz bi translated"><code class="du ki kj kk kl b">View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR</code></li><li id="6804" class="kr ks hx jo b jp la js lb jv lc jz ld kd le kh of kx ky kz bi translated"><code class="du ki kj kk kl b">View.SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR</code></li></ul><p id="c4e3" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">与其他类似，这些在API 30中也已被弃用，在<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController" rel="noopener ugc nofollow" target="_blank">WindowInsetsController</a></code>中被API取代。</p><p id="e713" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们不讨论所有这些标志的迁移，而是讨论一些常见的场景，看看如何更新它们:</p><h2 id="fd04" class="nk lg hx bd lh nl ny nn ll no nz nq lp jv oa ns lr jz ob nu lt kd oc nw lv nx bi translated">沉浸式模式</h2><p id="d205" class="pw-post-body-paragraph jm jn hx jo b jp lx iy jr js ly jb ju jv lz jx jy jz ma kb kc kd mb kf kg kh ha bi translated">在这里，您可以看到一个绘图应用程序，它隐藏了系统用户界面，以最大限度地增加绘图空间:</p><figure class="kn ko kp kq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es km"><img src="../Images/e1384dcfc98171f5f584b2b4f2f456fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Yvt16ghD3hIf1LF77SJ83w.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Markers app, demonstrating hiding the system UI</figcaption></figure><p id="80cb" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了使用<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController" rel="noopener ugc nofollow" target="_blank">WindowInsetsController</a></code>实现它，我们像以前一样使用<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController#hide(int)" rel="noopener ugc nofollow" target="_blank">hide()</a></code>和<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController#show(int)" rel="noopener ugc nofollow" target="_blank">show()</a></code>函数，但是这次我们传入系统栏类型:</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="od oe l"/></div></figure><p id="e2d3" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">该应用还使用<a class="ae hu" href="https://developer.android.com/training/system-ui/immersive#immersive" rel="noopener ugc nofollow" target="_blank">沉浸式模式</a>，允许用户将隐藏的系统栏扫回。为了使用<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController" rel="noopener ugc nofollow" target="_blank">WindowInsetsController</a></code>实现这一点，我们将<a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController#setSystemBarsBehavior(int)" rel="noopener ugc nofollow" target="_blank">隐藏和显示行为</a>改为<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController#BEHAVIOR_SHOW_BARS_BY_SWIPE" rel="noopener ugc nofollow" target="_blank">BEHAVIOR_SHOW_BARS_BY_SWIPE</a></code>:</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="od oe l"/></div></figure><p id="8d89" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">类似地，如果您使用的是粘性<a class="ae hu" href="https://developer.android.com/training/system-ui/immersive#sticky-immersive" rel="noopener ugc nofollow" target="_blank">沉浸式模式</a>，则使用<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController#BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE" rel="noopener ugc nofollow" target="_blank">BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE</a></code>来实现:</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="od oe l"/></div></figure><h2 id="0adb" class="nk lg hx bd lh nl ny nn ll no nz nq lp jv oa ns lr jz ob nu lt kd oc nw lv nx bi translated">状态栏内容颜色</h2><p id="d9bb" class="pw-post-body-paragraph jm jn hx jo b jp lx iy jr js ly jb ju jv lz jx jy jz ma kb kc kd mb kf kg kh ha bi translated">下一个场景是关于状态栏内容颜色的。这里您可以看到两个应用程序:</p><figure class="kn ko kp kq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es oi"><img src="../Images/79e3777aff15a608929974e41e66ced8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TaeLKEFEIerlPz3aWcD4DQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Two apps, on the left an using a dark status bar background, and on the right using a light background</figcaption></figure><p id="ac3e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在左边，应用程序有一个深色的状态栏背景，浅色的内容，如时间和图标。但是如果我们想要一个浅色的状态栏背景和深色的内容，比如右边，我们也可以使用<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController" rel="noopener ugc nofollow" target="_blank">WindowInsetsController</a></code>。</p><p id="4457" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为此，我们可以使用<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController#setSystemBarsAppearance(int,%20int)" rel="noopener ugc nofollow" target="_blank">setSystemBarsAppearance()</a></code>函数，传入<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController#APPEARANCE_LIGHT_STATUS_BARS" rel="noopener ugc nofollow" target="_blank">APPEARANCE_LIGHT_STATUS_BARS</a></code>值:</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="od oe l"/></div></figure><p id="b87a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你想设置一个暗的状态栏，通过传入<code class="du ki kj kk kl b">0</code>来清除这个值。</p><blockquote class="oj ok ol"><p id="a27d" class="jm jn om jo b jp jq iy jr js jt jb ju on jw jx jy oo ka kb kc op ke kf kg kh ha bi translated">注意:您可以通过设置<code class="du ki kj kk kl b">android:windowLightStatusBar </code>属性在您的主题中实现这一点。如果您知道值不会改变，这可能更好。</p></blockquote><p id="1a09" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">类似地，<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/android/view/WindowInsetsController#APPEARANCE_LIGHT_NAVIGATION_BARS" rel="noopener ugc nofollow" target="_blank">APPEARANCE_LIGHT_NAVIGATION_BARS</a></code>标志也是可用的，它为导航栏提供了相同的功能。</p><h2 id="d1ff" class="nk lg hx bd lh nl ny nn ll no nz nq lp jv oa ns lr jz ob nu lt kd oc nw lv nx bi translated">AndroidX中的WindowInsetsController？</h2><p id="9b51" class="pw-post-body-paragraph jm jn hx jo b jp lx iy jr js ly jb ju jv lz jx jy jz ma kb kc kd mb kf kg kh ha bi translated">不幸的是，这个API的Jetpack版本还不存在，但我们正在努力。敬请关注。</p></div><div class="ab cl mr ms go mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ha hb hc hd he"><h1 id="7d87" class="lf lg hx bd lh li oq lk ll lm or lo lp jd os je lr jg ot jh lt jj ou jk lv lw bi translated">走向边缘:✔️</h1><p id="35b1" class="pw-post-body-paragraph jm jn hx jo b jp lx iy jr js ly jb ju jv lz jx jy jz ma kb kc kd mb kf kg kh ha bi translated">这是完成的第一步。在下一篇博文中，我们将研究第二步:应用程序对嵌入动画的反应。</p><div class="hg hh ez fb hi mc"><a rel="noopener follow" target="_blank" href="/androiddevelopers/animating-your-keyboard-reacting-to-inset-animations-839be3d4c31b"><div class="md ab dw"><div class="me ab mf cl cj mg"><h2 class="bd hy fi z dy mh ea eb mi ed ef hw bi translated">制作键盘动画:对插入动画做出反应</h2><div class="mj l"><h3 class="bd b fi z dy mh ea eb mi ed ef dx translated">对插入动画做出反应</h3></div><div class="mk l"><p class="bd b fp z dy mh ea eb mi ed ef dx translated">对插图animationsmedium.com的反应</p></div></div><div class="ml l"><div class="ov l mn mo mp ml mq ho mc"/></div></div></a></div></div></div>    
</body>
</html>