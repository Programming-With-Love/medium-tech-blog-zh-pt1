# 无处不在的心态——容器意象理论探讨

> 原文：<https://medium.com/capital-one-tech/the-run-anywhere-mindset-a-discussion-of-container-image-theory-a3edcbd9c4be?source=collection_archive---------1----------------------->

## 为什么应该构建容器，以便它们可以在底层容器引擎可以运行的任何地方运行

![](img/837f177c6dac9040043feae32243428f.png)

如果你读过我以前关于容器的文章——冰箱里的鲸鱼和杂货店里的鲸鱼，你会知道我是一个容器爱好者(我希望这些文章能帮助你了解和激发容器给计算和开发带来的潜力)。在那些文章中，我讨论了 Docker 是什么，浏览了一些基本的 Docker 命令，然后展示了如何构建自己的 Docker 映像。

这篇文章将与之前的文章有所不同。在这里，我将讨论构建有效和有用的容器映像背后的一些理论，这些映像可以很容易地部署到任何环境中——也就是说，它们可以“在任何地方运行”这将包括 Docker 自己推荐的一些最佳实践，以及我在大大小小的公司的许多环境中使用容器的经验中获得的一些知识。这篇文章基于[我在 2018 年 DFW 发展日的演讲](https://www.youtube.com/watch?v=DzxfNSV-ATY)，你可以在 YouTube 上查看。

# 关于语言的简要说明

由于这更多的是一个理论讨论，而不是专门关于 Docker，我将使用更通用的术语*容器*(运行实例)、*容器映像*(容器的基础)和*容器引擎*(或容器运行时，例如 Docker)，而不是引用 Docker 映像和 Docker 引擎。您可以在这里随意插入单词“Docker ”,但是要注意，除了 Docker 之外，市场上还有其他容器引擎，并且这个理论的大部分也适用于这些引擎。事实上，Docker 实际上已经以 [containerd](https://containerd.io/) 的形式开源了他们的引擎，如果你对容器感兴趣，你应该对 containerd 有所了解。

那么，现在我们已经解决了所有的问题，让我们开始吧。

# 哪里是哪里？

任何一个*机构*在这里应该问的第一个问题是，“你所说的‘到处跑*是什么意思？”*

我的意思是你的容器应该以这样一种方式构建，它们可以在底层容器引擎可以运行的任何地方运行。本质上，包含电池的容器和给定最小参数集的适当配置它们自己的智能。这个想法来自于我作为 DevOps 工程师的工作。我能够让我的团队相信这个想法的价值，即一旦构建，我们的代码应该能够在任何地方运行，这成为我们团队的一个强大的使能器。

那么，哪里是“任何地方？”在这个上下文中，任何地方意味着*任何*环境，可以在其中部署一个运行的、有用的容器引擎或容器编制器。这包括但不限于以下类型的环境:

*   本地工作站/笔记本电脑(在 Windows、MacOS 或 Linux 上)
*   内部部署的服务器(如您办公桌下的服务器)
*   数据中心服务器
*   虚拟机(本地工作站、内部部署或云)
*   协调的集群(Kubernetes、DC/OS、Docker Swarm)

需要指出的是，所有这些环境都与硬件、操作系统、*和*云平台无关。如果您可以将容器引擎部署到上述任何环境中，那么您就可以运行您的容器化代码。

构建一个可以在所有这些不同环境中运行的容器映像不仅是可能的，而且比您想象的要容易得多。也就是说，实现“随处运行”肯定需要一些规划。我在这里的目标是提供一些指导方针和模式，使您能够用自己的容器图像实现这一点。

# 任何地方的优势

所以现在你会说，“好吧，这是个好主意，但是为什么呢？”这正是在这里要问的问题，所以让我们花一点时间来探索在任何地方跑步背后的“为什么”。

## 成本节约

先从节约成本说起。可以在任何地方运行的容器有可能为组织节省大量资金。这些成本节约来自两个方面，*人工时间使用*和*计算使用*。

**人的时间使用量**

成本节约的人力方面可能无法立即量化，因为这比其他任何方面都更节省时间。例如，如果您的生态系统中的所有应用程序都实现了这种随处运行的思维模式，那么您的开发人员和 DevOps 工程师可以花更多的时间来编写新功能和修复 bug，因为许多以前使他们变慢的瓶颈已经得到缓解。

**计算使用量**

计算机使用节省是另一回事。转移到构建良好的容器可以让您的应用程序部署更加“致密化”;也就是说，您可以在一个给定的服务器上运行多个应用程序，因为这些应用程序进程通过容器引擎完全相互保护。这样做的好处是，您现在可以避免或至少减轻虚拟机的“过度配置”。当您转移到编排集群时，您会真正开始看到这一点，在编排集群中，几个不同应用程序的容器将在集群中的任何给定服务器上运行，并且未使用的节点可以自动关闭。

## 开发周期

现在让我们谈谈软件发布周期的开发部分。正如我上面所说的，随处运行理论认为任何容器映像都应该能够在任何容器引擎上运行——这包括开发人员的工作站。

如今，软件开发很少在真空中完成，正在开发的软件通常依赖于其他一些服务。如果那些其他的服务已经在构建时考虑了在任何地方运行，那么开发人员应该能够提取那些服务的容器映像，并在开发工作站上运行它们，甚至可能以某种“开发”模式运行。然后，开发人员可以针对这些本地服务进行编码、测试和迭代，而不必将代码部署到某种共享测试环境中。这既节省了开发人员的时间，也节省了计算资源。此外，开发人员对他们编码的服务的*版本*拥有完全的控制权。这使得更快的错误报告和团队间的协作成为可能，从而加速您的开发周期。

另一个优势是短暂的基础设施。例如，假设您选择使用 PostgreSQL 作为后端数据库来开发一个应用程序。过去，开发人员要么需要在本地系统上安装 PostgreSQL 并对其进行配置(然后在完成开发后卸载它，留下一堆配置文件)，要么向数据中心的某人寻求运行 PostgreSQL 的服务器。有了 Run Anywhere，开发人员只需拉一个 PostgreSQL 容器并运行它，然后就可以开始开发了。这种模式在 QA 和测试周期中也很方便。完成后，删除容器将删除 PostgreSQL 数据库，而不必清理任何延迟的配置、数据库或日志文件。

除了开发加速之外，还可以节省成本，因为不必创建云计算基础架构或裸机基础架构来运行、测试和迭代代码。这仅仅是在任何地方跑步可以带来的成本节约的开始，我们将在继续讨论这种思维模式的优势时探讨这一点。

**质量保证和整合**

一旦开发完成，代码就被推送到某种风格的源代码管理系统中，并创建某种“发布”(想想 git 中的“标签”)。如果你有像 Jenkins、CircleCI 或 Bamboo 这样的自动化构建系统(即持续集成),代码将被提取、构建和测试。

DevOps 实践和持续集成/持续部署(CI/CD)的基本原则之一是，任何通过所有测试并成功构建的工件都应该是可部署的。当然，我们都知道我们构建的一些工件不应该被允许靠近生产环境，但是这里的基本思想是合理的。在这种情况下，基于随处运行的思想构建的容器映像可以实现这一点。

考虑一个通用 CI/CD 管道。提取代码，运行单元测试(以及任何其他预构建测试)，如果所有测试都通过，则构建代码。此时，代码通常被部署到某种 QA 环境中进行集成或验证测试。由于您构建容器映像时考虑了在任何地方运行，通过一些动态配置更改(或良好的服务发现)，您的代码应该“正常工作”您不需要维护多个配置文件，因为代码或配置足够智能，能够找出它在哪里，并将其自身附加到启动它的环境中所需的服务。

此外，如果您需要其他后端基础设施来进行测试，可以像开发人员获取和运行任何必要的开发依赖项一样获取和运行它。例如，如果您正在使用 PostgreSQL 后端，您可以提取并运行该映像，然后创建一些测试数据并将其填充到数据库中。一旦完成，您就可以对数据库运行自动化测试。当你完成后，只需销毁容器，你已经清理完毕。

所以现在你已经进入了 QA/集成阶段，你可以运行所有你需要运行的验证测试，如果它们都通过了，你的容器映像就会被提升为发布候选。

**生产**

您的代码刚刚通过了所有的单元测试和集成测试，并且已经被提升为发布候选。假设你有好的测试(我们都有好的测试，对吧？)您现在已经准备好进行无所畏惧的生产部署，并且全部使用与我们开始时完全相同的编译代码。**这个的价值不能被夸大！**在开发和 QA 环境中存活下来的经过良好测试的代码应该给开发人员和 DevOps 工程师很大的信心，他们的代码已经可以投入生产了。

也就是说，由于这样或那样的原因，生产中似乎总是有一些在较低环境中不存在的怪癖，这通常是因为生产中安全性的提高。随处运行的思维模式允许的一件事是让产品代码尽可能地接近 QA、测试和/或试运行。这使得这些环境尽可能地一致，允许在开发周期的早期发现问题，并防止严重事故的发生。

然而，即使具备了所有这些条件，bug 仍然可以进入生产环境。它发生了。随处运行的心态为这种可能性做好了准备，因为只需一点点计划，它就允许非常简单的代码回滚。如果您在容器映像上使用某种形式的版本控制，那么希望您已经备份了最后一个已知的工作代码。如果您部署了一个新的版本，并且它破坏了一些东西，那么恢复到旧的代码就像杀死新的容器并启动旧的容器一样简单(或者如果必要的话重新启动它)。

**基础设施**

随处运行的另一个优点是它允许服务器安装的标准化。如果一切都在容器中，那么基本服务器/实例上唯一需要的软件就是容器引擎或 orchestrator。如果您使用类似于 [Chef](https://www.chef.io/) 、 [Puppet](https://puppet.com/) 、 [Ansible](https://www.ansible.com/) 、 [AWS Cloudformation](https://aws.amazon.com/cloudformation/) 、 [Azure ARM Templates](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview) 或 [Hashicorp Terraform](https://www.terraform.io/) (或它们的某种组合)的工具进行部署，这意味着您可以最大限度地减少需要维护的配置数量。即使在基础设施即代码的思维模式中，这也有助于最大限度地减少人为错误，并确保跨服务器和环境的平等性。

# 实现随处运行

如果您还在阅读，我会假设我已经说服您容器映像应该能够在任何地方运行。现在你应该问，“但是怎么做呢？”先说怎么做。

由于每个人的需求和环境不同，我很难列出一堆你必须遵循的步骤。相反，我将解决一些已知的障碍，以构建能够在任何地方运行的健壮而有用的容器。

## 集装箱，集装箱，集装箱

如果你的应用程序没有容器化，那么你必须首先容器化它。也就是说，我不会建议你简单地“举起、移动和包装”你的应用程序；也就是说，不要只是把它塞进一个容器映像，然后说“完成”花点时间让你的应用云和容器知道。如果你有足够的带宽，我强烈建议将任何单片分割成微服务，或者至少分割成更小的块。大型容器映像是有问题的，因为它们需要更长的启动时间，而且通过网络传输也需要更长的时间。

## CI/CD

在您编写任何代码或修复任何 bug 之前，您绝对应该为您的自动化测试应用程序建立一个端到端的持续集成和交付管道。CI/CD 的优势在 DevOps 社区中已经得到了[的高度赞扬](https://www.google.com/search?q=advantages+of+CI+CD&oq=advantages+of+CI+CD&aqs=chrome..69i57.3745j0j4&sourceid=chrome&ie=UTF-8)，所以我认为我没有必要花太多时间来告诉你为什么你需要它。

相反，我将提到一些你应该考虑添加到 CI/CD 渠道中的经常被忽视的部分。

*   创建脚本化管道。这种“作为代码的管道”可以被检查到您的源代码管理中，CI/CD 平台可以动态地提取它。
*   为经常重复的管道语句创建管道库。
*   删除任何不必要的步骤，即没有添加任何值的步骤，或者因为代码继续运行而被弃用的步骤。这包括测试！删除任何不再提供价值的测试。没关系，我允许你这么做。
*   添加自动化测试
*   对每个版本进行版本控制(下面会有更多相关内容)。
*   参数化您的部署，即一个部署作业应该能够部署到任何已建立的环境中(在任何地方部署！)
*   尽可能消除非生产部署中的摩擦。
*   添加部署元数据，例如给定环境中部署的每个组件的版本(即环境清单)。

## 偿还技术债务

为了让你的“随处跑”之旅更上一层楼，你必须还清科技债务。科技债务就像是套在你脖子上的磨盘，会让你慢下来，挫败你实现无处不在的努力。

以下是我遇到的一些技术债的例子。你的里程可能不同，但你应该看到这里的主题是纠正某些坏习惯。

**快照构建**

如果您正在使用快照构建，您应该从它们中迁移出来，并转移到动态版本控制，以便每个构建都有一个唯一的版本号。这样做的好处是，它为您提供了构建的历史记录，并使您能够在部署失败的情况下快速轻松地回滚——这一点的价值怎么强调都不过分。我成功地将构建日期和时间戳与提交的短 git 散列结合起来作为一个独特的版本。这种方法可以让您轻松地找到给定构建的起点。

**更新或删除依赖关系**

花一些时间来更新您的应用程序所依赖的子模块。这一点很重要，因为您的依赖项可能存在已更新或启用新功能的漏洞，其中一些可能有助于您实现随处运行。大多数情况下，这只是需要更新构建自动化系统中的版本号，例如 package.json、pom.xml 或 Pipfile。有时，您会遇到不赞成使用或被替换的依赖项，这将需要您花时间来重构任何使用这些模块的代码。

如果在你努力的过程中，你发现你不再需要某种依赖，那就去掉它。没有理由将您甚至不再使用的代码引入到您的项目中。

**添加健康检查**

这是那些你真的需要放在容器里的小东西之一。只是一个快速端点，它可以告诉外部参与者这个容器运行正常、健康。最基本的版本只是一个返回“200:OK”的端点，但是您应该考虑返回一些更详细的信息，比如您的容器是否可以到达它的上游数据源。

## 外部化您的配置

下一步是具体化您的配置。这将需要一点规划，因为您需要能够从环境中动态配置应用程序，即使用环境变量或外部键/值存储。您应该从环境变量开始，因为这个特性没有外部依赖性。这将允许您动态地设置任何会根据环境而改变的配置参数，例如上游数据源、日志记录级别等，并且这些参数可以很容易地传递到容器中。您最终会希望通过某种键/值存储来支持配置，例如 [etcd](https://etcd.io/) 或[hashi corp consult](https://www.consul.io/)，但这不应该成为您旅途中的障碍。

## 添加服务发现

这与 etcd，Consul，或者甚至是网飞尤里卡(T1)密切相关。如果您有任何可用的工具，请使用它们将自动服务发现添加到您的应用程序中。

简而言之，服务发现允许您的应用程序自动找到并连接到它所依赖的服务。这可以通过这样的方式设置，如果应用程序*没有*找到它需要配置自己的环境变量，它会搜索服务发现服务并从那里配置自己。

# 后续步骤

你已经容器化了，你已经偿还了你的技术债务，你已经外部化了你的配置，你的容器真的可以在任何地方运行。现在怎么办？

## 不要重新架构(马上)

既然您的容器可以在任何地方运行，那么您就可以灵活地部署它们了。所以，现在我要告诉你一些你应该*而不是*做的事情。不要马上改变您的生产部署架构——尤其是如果您不熟悉容器的话。即使您不熟悉容器，您也只是为部署应用程序增加了一层潜在的复杂性。相反，我建议更改底层服务器以支持容器引擎，并在容器中运行应用程序，而不是直接在操作系统上运行(即使用 docker run 或 docker-compose)。稍后，一旦您熟悉了容器及其特性，并且已经掌握了支持容器的技能，就可以开始探索编排引擎。

## 编排(当你准备好的时候)

一旦通过容器部署了应用程序，并且熟悉了容器的特性，您的最终目标应该是迁移到一个编排好的容器环境。容器编排器是跨服务器集群管理容器的软件套件。管理的一部分包括监控容器的健康状况，并自动替换任何变得不健康的容器——这就是它们自我修复的方式。Orchestrator 还处理负载平衡、网络入口和出口，并将为您的应用程序提供服务发现。

部署和管理容器编排集群并不困难，但是需要学习一些新技能。也就是说，如果您想体验一下容器编排，而不担心管理集群，所有主要的云提供商都有许多支持不同容器编排技术的托管服务。其中包括 [AWS Fargate](https://aws.amazon.com/fargate/) 、[AWS Elastic Kubernetes Service(EKS)](https://aws.amazon.com/eks/)、[Azure Kubernetes Service(AKS)](https://azure.microsoft.com/en-us/services/kubernetes-service/)、[Google Kubernetes Engine(GKE)](https://cloud.google.com/kubernetes-engine/)。如果这些都不能满足您的需求，另一个选择是通过虚拟机创建和管理您自己的流程编排集群。一个不基于 Kubernetes 的选项是 [Mesosphere 的 DC/OS](https://mesosphere.com/product) ，它提供了与 Kubernetes 相似的功能。

我强烈建议您做一些研究，选择最适合您的应用程序的选项，或者构建一些集群并进行试验。

## 密实化

我在上面的“成本节约”部分提到了这一点，但这是所有努力工作都有回报的地方。现在，您的应用程序被分解成更小的块，并在编排好的集群上运行，集群管理软件将把运行的容器放在集群中的各个节点上。这意味着你可以在一个给定的节点上运行任意数量的容器，这是一个非常复杂的俄罗斯方块游戏的计算机世界版本！

以下是编排平台持续执行的几项任务:

*   跟踪所有容器在集群中的部署位置
*   根据需要推出新容器
*   监视不正常的节点(服务器)，从集群中删除这些节点，并重新部署部署到这些节点的任何容器
*   如果集群是云自动扩展组的一部分，那些不健康的节点应该由云平台销毁并重新创建
*   监控不健康的容器并重新部署它们
*   重新部署后清理不健康的容器
*   根据需要设置和破坏每个容器的网络入口和出口

最终结果是，如果应用程序与服务器的比例为 1:1，那么许多容器运行在更少的服务器上。也就是说，每个计算资源(即服务器/实例)的软件部署更加密集，网络计算资源更少，计算资源利用率更高。这就是成本节约的来源，而且可能是巨大的。最终结果是，如果应用程序与服务器的比例为 1:1，那么许多容器运行在更少的服务器上。也就是说，您在每台服务器上部署了更密集的软件，这就是成本节约的来源。

如果您担心在一台主机上运行的所有这些不同的应用程序容器可能会相互干扰，请不要担心！这是容器的主要优点之一，即每个容器都与运行在同一主机上的任何其他容器相隔离。此外，编排框架足够智能，不会因为在给定主机上运行太多容器而使其负担过重。

# 包扎

本文的目的是为您提供一个路线图，让您创建可以在任何地方运行的精心制作的容器。在这个过程中，您将获得更好的实践，更少的技术债务，更少的应用程序错误，并且有希望获得更容易的部署路径。

# 资源

*   [DFW 2018 年 DevOps Days:随处跑的心态](https://www.youtube.com/watch?v=DzxfNSV-ATY)(原话)
*   [冰箱里的鲸鱼](/capital-one-tech/the-whale-in-the-refrigerator-80f659fea1a4?source=friends_link&sk=bd667409ea5490e5468301e723f22a5e)
*   [杂货店里的鲸鱼](/capital-one-tech/whale-in-the-grocery-store-an-introduction-to-docker-and-docker-images-311319688692?source=friends_link&sk=054f65712d4cebf9f0abe15d4c60e4c7)
*   [Docker 文档](https://docs.docker.com/)
*   [码头集装箱隔离](https://docs.docker.com/engine/security/security/)
*   [企业码头](https://www.docker.com/products/docker-enterprise)
*   [哈希公司地形](https://www.terraform.io/)
*   [Cloudbees 詹金斯](https://www.cloudbees.com/jenkins)
*   [Etcd](https://etcd.io/)
*   [哈希公司领事](https://www.consul.io/)
*   [网飞尤里卡](https://github.com/Netflix/eureka)
*   [AWS Fargate](https://aws.amazon.com/fargate/)
*   托管 Kubernetes 解决方案
*   [AWS 弹性库本内特服务(EKS)](https://aws.amazon.com/eks/)
*   [蔚蓝库伯内特服务(AKS)](https://azure.microsoft.com/en-us/services/kubernetes-service/)
*   [谷歌 Kubernetes 引擎(GKE)](https://cloud.google.com/kubernetes-engine/)
*   [中间层的 DC/操作系统](https://mesosphere.com/product)

*披露声明:2020 资本一。观点是作者个人的观点。除非本帖中另有说明，否则 Capital One 不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。*