<html>
<head>
<title>Using the Kotlin standard library from Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Java使用Kotlin标准库</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/using-the-kotlin-standard-library-in-java-ea0766deac10?source=collection_archive---------2-----------------------#2021-06-14">https://medium.com/google-developer-experts/using-the-kotlin-standard-library-in-java-ea0766deac10?source=collection_archive---------2-----------------------#2021-06-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/7ffba6e63f9c8f8097a16fc0a1be435a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*EdIWoW0eBz8cYdyi.gif"/></div><figcaption class="il im et er es in io bd b be z dx">giphy.com</figcaption></figure><p id="6eae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你每天都在使用Kotlin，你可能会喜欢这种语言，不想回到Java。然而，我们中的许多人工作的代码库并不纯粹是Kotlin。我们在<a class="ae jn" href="https://soundcloud.com/" rel="noopener ugc nofollow" target="_blank"> SoundCloud </a>的Android代码库仍然有相当数量的Java代码。随着时间的推移，这一比例越来越小，但现在并不迫切需要大规模迁移遗骸。</p><p id="10c1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以，每隔一段时间，我就发现自己，在改Java文件。在这种情况下，我想念一些我习惯的Kotlin函数；我很容易想到字符串操作或处理集合作为例子。当然，Java有强大的实用程序库，如<a class="ae jn" href="https://github.com/google/guava" rel="noopener ugc nofollow" target="_blank"> Googles Guava </a>或<a class="ae jn" href="https://commons.apache.org/proper/commons-collections/" rel="noopener ugc nofollow" target="_blank"> Apache Commons </a>，在Kotlin出现之前，我们曾经使用过这些库。</p><p id="e254" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是当整天写Kotlin代码时，记住那些“老”API有时很难。这是一个完整的上下文切换。使用我们在科特林使用的东西会容易得多。你应该这么做！让我给你看看！</p><p id="fa05" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设我们想要创建一个项目列表。在科特林，我们会写:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="119c" class="jx jy hh jt b fi jz ka l kb kc">val<strong class="jt hi"> </strong>items<em class="kd"> </em>= <strong class="jt hi"><em class="kd">listOf</em>(<br/>    items1, item2, item3<br/>)</strong></span></pre><p id="9a2c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Java中，我会把它写成:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="51f2" class="jx jy hh jt b fi jz ka l kb kc">List&lt;Item&gt; items = <strong class="jt hi">Arrays.<em class="kd">asList</em></strong>(item1, item2, items3);</span></pre><p id="d366" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用法是非常相似的，但是你仍然需要记住函数的名字。使用以下代码不是更简单吗:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="5f06" class="jx jy hh jt b fi jz ka l kb kc">List&lt;Item&gt; items = <strong class="jt hi">listOf(</strong>item1, item2, items3);</span></pre><p id="847b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">是的，你可以！</strong></p><p id="5996" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你所需要做的就是<code class="du ke kf kg jt b">static import</code>这个函数！这就像<code class="du ke kf kg jt b">listOf</code>一样，就像我们日常使用的许多Kotlin实用函数一样，都是可以从Java中使用的简单静态函数。</p><p id="27cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">更好的是，由于您的项目已经使用了Kotlin，您已经包含了那些依赖项，不需要额外的库。</p><h1 id="76f4" class="kh jy hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">近距离观察</h1><p id="c8f7" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">如果您点击Kotlin中的<code class="du ke kf kg jt b">listOf</code> <strong class="ir hi"> </strong>的详细信息，您会看到一个名为<code class="du ke kf kg jt b">Collections.kt</code>的文件，其定义如下:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="cff1" class="jx jy hh jt b fi jz ka l kb kc">public <strong class="jt hi">fun</strong> &lt;T&gt; <strong class="jt hi">listOf</strong>(vararg elements: T)<strong class="jt hi">: List&lt;T&gt;</strong></span></pre><p id="9b9a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它是一个自由函数，不绑定任何类。但是从Java的角度来看，这看起来像这样:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="4bf5" class="jx jy hh jt b fi jz ka l kb kc">public final <strong class="jt hi">class CollectionsKt</strong> {<br/>   @NotNull<br/>   <strong class="jt hi">public static</strong> final List&lt;T&gt; <strong class="jt hi">listOf</strong>(@NotNull T... elements) {<br/>   ...<br/>} </span></pre><p id="6c8a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个阶层来自哪里？注意，没有绑定到Kotlin中的类的函数仍然必须放入字节码中的类中。在这种情况下，来自文件<code class="du ke kf kg jt b">Collections.kt</code>的函数将简单地在一个名为<code class="du ke kf kg jt b">CollectionsKt</code>的类中结束。<br/>还有疑问，如果你想知道你需要在Java中静态导入的类名，只需转到你的Kotlin函数的声明并检查文件名。</p><h1 id="7c04" class="kh jy hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">扩展功能</h1><p id="2422" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">扩展函数呢？在我看来，这些是Kotlin提供的最强大的工具之一。从Java的角度来看，扩展函数也只是静态函数，接收者成为第一个参数。让我们看一个例子:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="457f" class="jx jy hh jt b fi jz ka l kb kc">validItems<em class="kd"> = </em>items<strong class="jt hi">.filterNotNull()</strong></span></pre><p id="9ad0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du ke kf kg jt b">filterNotNull</code>是一个扩展函数，我们可以在声明中看到:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="f2a7" class="jx jy hh jt b fi jz ka l kb kc">public fun<strong class="jt hi"> </strong>&lt;T : Any&gt; <strong class="jt hi">Iterable&lt;T?&gt;.filterNotNull</strong>(): List&lt;T&gt;</span></pre><p id="5c32" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Java中，这看起来像这样:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="3a6a" class="jx jy hh jt b fi jz ka l kb kc"><strong class="jt hi">public static </strong>final<strong class="jt hi"> </strong>List&lt;T&gt; <strong class="jt hi">filterNotNull</strong>(@NotNull Iterable&lt;T&gt; $this$filterNotNull)</span></pre><p id="f1ab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用法如下所示:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0520" class="jx jy hh jt b fi jz ka l kb kc"><em class="kd">validItems = filterNotNull</em>(items);</span></pre><p id="88be" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那不是太糟糕，是吗？</p><p id="0a4d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Java中使用扩展函数的唯一缺点是不能像在Kotlin中那样将调用与其他扩展函数连接起来:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="c6af" class="jx jy hh jt b fi jz ka l kb kc">items.filterNotNull().find{...}.map{...}</span></pre><p id="9a2a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们所了解的，这在Java中是行不通的:接收者成为第一个参数，所以我们需要将它重写为多行代码。但是每个功能都可以使用。</p><h1 id="4446" class="kh jy hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">边注</h1><p id="7279" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">如果您进一步研究这个例子，您可能会注意到<code class="du ke kf kg jt b">filterNotNull</code>函数位于一个名为<code class="du ke kf kg jt b">_Collections.kt</code>而不是<code class="du ke kf kg jt b">Collections.kt</code>的文件中。尽管如此，我们还是导入了类<code class="du ke kf kg jt b">CollectionsKt</code>，与上面我们使用的名字相同。这是因为作者通过注释明确定义了目标类名:<code class="du ke kf kg jt b">@file:kotlin.jvm.JvmName(“CollectionsKt”)</code></p><h1 id="5906" class="kh jy hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">费用</h1><p id="69d1" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">您可能会问，在Java中使用这些Kotlin库时，是否有任何隐藏的成本。答案很简单:不会！像所有用Java编写的库一样，Kotlin库也是字节码。在普通的Java库中，您可能找不到的惟一东西就是空检查。与转移到Kotlin时类似，在不期望的地方传递null时要注意突然的异常。</p><h1 id="9033" class="kh jy hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">摘要</h1><p id="1807" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">Kotlin中的许多函数都是作为扩展函数实现的，可以很容易地通过静态导入从Java中使用。您可能无法使用Kotlin的所有功能，尤其是考虑到像协程这样的功能。虽然调用标准函数不是问题，但应该经常使用。你甚至可以去掉一些只用于Java的第三方库。</p><p id="3aec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当在混合代码库上工作时，使用相同的功能减少了团队的认知负荷。这对于开发人员直接从Kotlin开始而没有长期Java背景的人来说更有价值，我们会越来越多地看到这种情况。</p><p id="e61d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是让我提醒您，这个技巧是针对您的代码库还没有完全Kotlin时的中间状态的。如果你有一个Java项目，并打算长期使用Java，那么使用Kotlin库不应该是你的策略。</p></div></div>    
</body>
</html>