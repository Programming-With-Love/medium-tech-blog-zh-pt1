<html>
<head>
<title>Why We Need Idempotency Mechanism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们需要幂等机制</h1>
<blockquote>原文：<a href="https://medium.easyread.co/why-we-need-idempotency-mechanism-c61f3d108474?source=collection_archive---------3-----------------------#2019-08-11">https://medium.easyread.co/why-we-need-idempotency-mechanism-c61f3d108474?source=collection_archive---------3-----------------------#2019-08-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="13e9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一次就够了…</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/351975d866ca550cf096ece256232bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gntcjInh4YNk08Ci"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@photos_by_lanty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Photos by Lanty</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6745" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">幂等性是一种策略，它确保一个事件执行多次会得到相同的结果。例如，HTTP请求上的<code class="fe lp lq lr ls b">GET</code>方法。如果用<code class="fe lp lq lr ls b">GET</code>方法调用端点，会得到相同的结果。但是<code class="fe lp lq lr ls b">POST</code>方法不是等幂的，因为每次用<code class="fe lp lq lr ls b">POST</code>方法调用一个端点都会在数据库上创建一条新记录(数据库状态改变)。</p><h1 id="3660" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">当我们需要的时候。</h1><p id="4fab" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">想象一下这个场景。我们的支付后端有一个端点在<code class="fe lp lq lr ls b">transactions</code>表上添加一条新记录，这是它使用的<code class="fe lp lq lr ls b">POST</code>方法。我们的前端应用程序—具有重试机制—调用端点来进行新的事务。我们的后端接收请求，进行新的交易，并减少用户的余额。</p><p id="dab2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但不知何故，网络故障发生了，前端应用程序没有收到响应。由于时间限制，前端应用程序会重试发送相同的请求。我们的后端接收请求，进行新的交易，并减少用户的余额。</p><p id="788a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你知道实际发生了什么吗？用户的余额减少了两倍。我们不希望我们的客户因为这次失败而生气。我们如何解决这个问题？</p><h1 id="c32f" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">使请求幂等</h1><p id="caec" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">为了使请求幂等，我们需要为每个请求创建一个惟一的标识符。每次前端应用程序创建一个新的请求，它会生成一个唯一的标识符，发送到后端。我们可以把它放在请求头或请求体上。我不知道把它放在哪里是最好的做法，但关键是我们的前端将为每个请求发送一个唯一的标识符。</p><p id="944b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每次后端收到来自前端应用程序的请求时，它都会检查请求的唯一标识符是否存在。后端应该有一个存储唯一标识符的机制。也许我们可以用<a class="ae ks" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>暂时存储。</p><p id="1f7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果请求的唯一标识符不存在，这意味着它是一个新的请求，该请求将被处理。请求的唯一标识符和响应主体将被存储到我们的缓存中。如果请求的唯一标识符存在——意味着请求以前曾经被处理过，后端将返回缓存的响应体，而不再次处理请求。</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><p id="315b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我们实现等幂的方法之一。我还是不知道有没有另一种方法可以实现幂等。幂等性对于确保一个请求——使状态改变——不会被执行多次非常有用。</p><p id="6304" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">~宣传💻 ☕️</p></div></div>    
</body>
</html>