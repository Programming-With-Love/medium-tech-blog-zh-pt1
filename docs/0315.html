<html>
<head>
<title>Navigation patterns with PIP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带画中画的导航模式</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/navigation-patterns-with-pip-2c5b6a446ba0?source=collection_archive---------1-----------------------#2017-11-07">https://medium.com/androiddevelopers/navigation-patterns-with-pip-2c5b6a446ba0?source=collection_archive---------1-----------------------#2017-11-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="d889" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">处理后堆栈</h2></div><p id="dc06" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文研究了从画中画(PIP)窗口恢复到全屏时如何处理导航模式。关于PIP的概述以及如何在你的应用中实现它，请查看我的<a class="ae js" rel="noopener" href="/google-developers/making-magic-moments-with-picture-in-picture-e02964bf75ae">上一篇文章</a>。</p><div class="jt ju ez fb jv jw"><a rel="noopener follow" target="_blank" href="/google-developers/making-magic-moments-with-picture-in-picture-e02964bf75ae"><div class="jx ab dw"><div class="jy ab jz cl cj ka"><h2 class="bd hi fi z dy kb ea eb kc ed ef hg bi translated">用画中画创造神奇时刻</h2><div class="kd l"><h3 class="bd b fi z dy kb ea eb kc ed ef dx translated">匹普，匹普，万岁</h3></div><div class="ke l"><p class="bd b fp z dy kb ea eb kc ed ef dx translated">medium.com</p></div></div><div class="kf l"><div class="kg l kh ki kj kf kk kl jw"/></div></div></a></div></div><div class="ab cl km kn go ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ha hb hc hd he"><p id="25fe" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">从一个活动进入</strong> PIP模式很容易；就<strong class="iy hi">叫</strong> <code class="du kt ku kv kw b">enterPictureInPicture</code>。根据应用的架构，让用户在进入PIP后回到你的应用可能是一个挑战。</p><h1 id="d950" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">问题是</h1><p id="c9bd" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">假设用户想要观看视频，并且在观看视频的同时，他们想要查看他们的日历。很容易进入视频画中画模式，使用户可以多任务。当他们检查完日历并将视频恢复到全屏时，可能会出现问题。</p><blockquote class="lu lv lw"><p id="3446" class="iw ix lx iy b iz ja ii jb jc jd il je ly jg jh ji lz jk jl jm ma jo jp jq jr ha bi translated">当用户点击从恢复的全屏视频返回到应用程序时，应用程序可能会意外退出。</p></blockquote><h1 id="9cc5" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">为什么会这样？</h1><p id="fc17" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">进入PIP模式后，Android只将PIP活动转移到新任务中。如果用户在将画中画窗口恢复到全屏并轻按“返回”后仍留在您的应用程序中，这可能会是一个问题。为了实现这一点，应用程序必须重新创建后台堆栈。我们将在后面的小节中研究如何知道何时重新创建后台堆栈。</p><p id="d1c5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">比如你想在一个app里看一个视频。你打开应用程序，查看HomeActivity。在主页活动中，您可以查看视频的详细信息，然后转到详细信息活动。在决定观看视频后，您开始启动PlayerActivity的视频。现在筹码已经有三倍深了。你按下home键，回到Android的启动器，启动另一个应用程序，这样你就可以在视频继续播放的同时进行多任务处理。你完成你的多任务并关闭另一个应用程序。当您将PIP窗口恢复为全屏时，back-stack将会丢失。如果你点击返回，你会看到另一个应用程序。下图描述了该示例的时间线。</p><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mb"><img src="../Images/7b633c2eca2ca7b2a9353fc4344c2c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIKOEQ_QDHCwYuNSTsDM_Q.png"/></div></div></figure><p id="ae3f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果应用程序提供了一个进入画中画模式的按钮，那么DetailsActivity将保持在前台。</p><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mm"><img src="../Images/fa0b77ef8fefb2cb416452b836a6273b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cILLIxHCWQhImjq5Ev8Vtg.png"/></div></div></figure><p id="602e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为PIP活动被移动到它自己的任务中，所以你将能够在视频播放的同时留在应用程序中继续浏览。</p><figure class="mc md me mf fd mg er es paragraph-image"><div class="er es mn"><img src="../Images/08a09678f0fd74c90d56984ca2fb3440.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*3c_fQOe16jdU3gDR540ocA.png"/></div></figure><p id="861f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这解释了为什么在最近的应用程序中有两个你的应用程序的实例。</p><figure class="mc md me mf fd mg er es paragraph-image"><div class="er es mn"><img src="../Images/de569241d6c3b069506fb53b03e4e3db.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*NqVeHPHSC7UnOgkvHUuNvg.png"/></div></figure><p id="596c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果只有一个活动，那么它将留在当前任务中。</p><p id="3071" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看前面的例子，但不是每个函数的活动，而是每个函数的片段。由于片段管理器在应用内部处理后台堆栈，我们将有不同的行为。随着你深入应用程序，更多的片段被添加，但它只是一个活动。该活动将被移动到一个新的任务中，但是由于片段包含在活动中，所以导航被保留。</p><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mo"><img src="../Images/9e2a80b269b26a378db09d42b5bda730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VGffkKf-VdAFFas_WnUd_A.png"/></div></div></figure><h1 id="b489" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">你能做什么？</h1><p id="ec73" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">根据应用程序的架构，可能会自动重新创建后台堆栈。例如，如果你的应用是用片段构建的，片段管理器管理后台栈，而不是框架。由于框架是在活动层分裂出来的，所以片段管理器和你的片段是<strong class="iy hi"> <em class="lx">而不是</em> </strong>丢失的。</p><p id="b07e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你的应用程序对每个函数都有一个活动，那么你需要跟踪后台栈何时丢失，并在用户离开你的活动时重新创建后台栈。</p><p id="5e7a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以覆盖<code class="du kt ku kv kw b">onPictureInPictureModeChanged()</code>来找出后备栈何时丢失。</p><pre class="mc md me mf fd mp kw mq mr aw ms bi"><span id="0199" class="mt ky hh kw b fi mu mv l mw mx">boolean mBackstackLost = false;</span><span id="4bd4" class="mt ky hh kw b fi my mv l mw mx">@Override<br/>public void onPictureInPictureModeChanged (<br/>        boolean isInPictureInPictureMode, Configuration newConfig) {<br/>    if (! isInPictureInPictureMode) {<br/>        mBackstackLost = true;<br/>        // Restore the full-screen UI.<br/>        ...<br/>    }<br/>}</span></pre><p id="aaab" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦捕获到后备栈丢失，您可以在离开活动时覆盖<code class="du kt ku kv kw b">finish()</code>来重新创建后备栈。</p><pre class="mc md me mf fd mp kw mq mr aw ms bi"><span id="8d05" class="mt ky hh kw b fi mu mv l mw mx">@Override<br/>public void finish () {<br/>    if( mBackstackLost ){<br/>        finishAndRemoveTask();<br/>        startActivity(<br/>            Intent.makeRestartActivityTask(<br/>                new ComponentName(this, MockHomeActivity.class)));<br/>    } else {<br/>        super.finish();<br/>    }<br/>}</span></pre><p id="3fd3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果PIP活动有多个入口点，那么重新创建back-stack可能会很棘手。例如，用户可以从您的家庭活动开始观看视频，或者他们可以在观看之前搜索和查看详细信息。那么，当他们点击返回时，他们应该在哪里结束呢？家庭活动？细节活动？</p><figure class="mc md me mf fd mg er es paragraph-image"><div class="er es mz"><img src="../Images/08104f9865efc8972c9e19f428c4fa06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*7BHKM2QJ0TWOUk5-NKmM-A.png"/></div><figcaption class="na nb et er es nc nd bd b be z dx"><em class="ne">Potential flows for an application to watch a video.</em></figcaption></figure><p id="a516" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你的应用程序目前没有跟踪用户的路径，那么你可以强迫用户登陆一个特定的活动，不管他们来自哪里。例如，Google Play电影会将用户返回到home活动，而不管用户是如何找到watcher活动的。</p><h1 id="a87d" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">谢谢你</h1><p id="e2c8" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">我要感谢Ryan Johnstone提出这个问题。希望这篇文章能帮助你和其他人构建更好的应用。</p><figure class="mc md me mf fd mg er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es nf"><img src="../Images/61493593c46553e585629a2fc675fe65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOBO8an9P3pmsY-fblnahw.png"/></div></div></figure><h1 id="f4b1" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">测试行为</h1><p id="4b82" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">我编写了一个示例，演示了一个具有深度后台堆栈的应用程序在进入PIP模式时的不同行为。可以在github 上下载<a class="ae js" href="https://github.com/benbaxter/pip-navigation" rel="noopener ugc nofollow" target="_blank">源码自己玩。</a></p><p id="d36e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们希望听到您的反馈！如果您想继续讨论，请在<a class="ae js" href="https://twitter.com/benjamintravels" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上留下您的回复或与我交谈。</p></div></div>    
</body>
</html>