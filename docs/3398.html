<html>
<head>
<title>Generic type in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的通用类型</h1>
<blockquote>原文：<a href="https://medium.com/globant/generic-type-in-swift-c37c993080e3?source=collection_archive---------0-----------------------#2020-03-13">https://medium.com/globant/generic-type-in-swift-c37c993080e3?source=collection_archive---------0-----------------------#2020-03-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/baef93888b956b99e10c83bfffbf2430.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*CciNaq3IY6tUVeIJrgqEGg.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">If you are also thinking same let’s demystify the usage of generic type.</figcaption></figure><p id="c860" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">泛型代码使您的代码具有灵活性和可重用性，可以处理任何类型的代码。它避免了重复和抽象的表达方式。</p><p id="7b61" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是我们将在本教程中涉及的主题:</p><ul class=""><li id="7d4a" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">类函数</li><li id="4404" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">泛型类、结构</li><li id="765e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">通用枚举</li><li id="a028" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">带约束的类属</li><li id="9a18" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">作为关联类型的协议</li><li id="bee5" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">关联类型的where子句</li></ul><h2 id="1936" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated"><strong class="ak">通用函数:</strong></h2><p id="8311" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">显示所有类型的多态性的函数。</p><figure class="lb lc ld le fd ii"><div class="bz dy l di"><div class="lf lg l"/></div></figure><ul class=""><li id="cd25" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">您可以通过在尖括号<t>中提供一个类型占位符来定义通用函数。</t></li><li id="f638" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">你可以用任何东西来代替T，例如:类型、数据类型等等。无论你想要什么。例如<strong class="ir hi">func</strong>print array&lt;Type&gt;(集合:[类型])</li></ul><p id="1529" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">看看<a class="ae lh" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html" rel="noopener ugc nofollow" target="_blank">苹果文档</a>中给出的注释👇</p><blockquote class="li lj lk"><p id="0b1a" class="ip iq ll ir b is it iu iv iw ix iy iz lm jb jc jd ln jf jg jh lo jj jk jl jm ha bi translated">注意:<br/>总是给类型参数大写字母名称(比如T和MyTypeParameter ),以表明它们是一个<em class="hh">类型</em>的占位符，而不是值。</p></blockquote><ul class=""><li id="b4e9" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">您可以使用类型T来指示在调用该方法时将传入该方法的参数的类型。</li><li id="a5d6" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi"> printArray </strong>方法通过对<strong class="ir hi"> int </strong>数组和<strong class="ir hi"> string </strong>数组的类型推断来识别类型。</li></ul><p id="373a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以声明多个泛型类型，这些类型在调用时可以不同，如下所示:</p><figure class="lb lc ld le fd ii"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h2 id="7fe6" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated"><strong class="ak">泛型类，结构:</strong></h2><p id="9bb6" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">泛型类或结构可以用泛型类型定义，泛型类型可以是一种属性类型。</p><p id="b0ae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如:<br/>你可以定义泛型<strong class="ir hi">公司</strong>通过在用尖括号括起来的结构或类名后面添加泛型类型作为&lt;行业&gt;。</p><figure class="lb lc ld le fd ii"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h2 id="325a" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated"><strong class="ak">通用枚举</strong></h2><p id="ca41" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">就像struct或class enum可以定义为泛型一样。请检查下面的示例<strong class="ir hi">模型</strong>通用类型如何与<strong class="ir hi">响应</strong>案例相关联</p><figure class="lb lc ld le fd ii"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="c771" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的例子中，您可以看到泛型代码的强大之处，其中一个代码库作为<strong class="ir hi">serveresponsetype</strong>enum为所有的<strong class="ir hi"> Model </strong>类型工作，这些类型作为。定义的响应案例。</p><h2 id="4892" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated"><strong class="ak">带约束的类属:</strong></h2><p id="7cc1" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">我们可以在函数、类、结构或枚举中定义泛型类型的任何地方添加约束。</p><p id="ae7f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下面👇是用约束声明泛型占位符的语法:</p><p id="8b8c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">通用占位符:约束</strong> //约束可以是任何<strong class="ir hi">类</strong>或<strong class="ir hi">协议</strong></p><p id="6f01" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如<strong class="ir hi">T:has shable</strong></p><p id="188b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个声明意味着，泛型类型参数继承自一个特定的类或者符合一个协议或者协议组合。</p><p id="41a8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">协议组合的示例如下:</p><ol class=""><li id="37b3" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lp jt ju jv bi translated">可比较的，</li><li id="5ff1" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lp jt ju jv bi translated">文件处理协议:文件读取协议，文件写入协议</li></ol><p id="f54e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以我们可以像下面这样使用这些成分:</p><p id="527b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> T:可比较的&amp;可比的</strong></p><p id="4ee1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> T:文件处理协议</strong></p><p id="0c1e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看下面的例子1，我们正在添加约束条件，以便<strong class="ir hi">公司</strong>可以与必须确认<strong class="ir hi">行业身份</strong>协议的<strong class="ir hi">行业</strong>类型相关联。</p><p id="6f2e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例1:</p><figure class="lb lc ld le fd ii"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="9e8a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">示例2:</p><p id="ea26" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下面的例子中，我们向服务器响应添加了一个约束，使其必须具有<strong class="ir hi"> id </strong>。</p><blockquote class="li lj lk"><p id="721e" class="ip iq ll ir b is it iu iv iw ix iy iz lm jb jc jd ln jf jg jh lo jj jk jl jm ha bi translated">注:可识别是swift中预定义的协议，此处仅作为示例，以便有一个清晰的理解。</p></blockquote><figure class="lb lc ld le fd ii"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="6c4b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于<strong class="ir hi">服务</strong>没有确认<strong class="ir hi">可识别的</strong>协议，所以在将它作为值传递给<strong class="ir hi">服务器响应类型</strong>时。<strong class="ir hi">响应</strong>会提示如下编译时错误:</p><blockquote class="li lj lk"><p id="53da" class="ip iq ll ir b is it iu iv iw ix iy iz lm jb jc jd ln jf jg jh lo jj jk jl jm ha bi translated"><strong class="ir hi">编译时错误:</strong>通用枚举“服务器响应类型”要求“服务”符合“可识别”</p></blockquote><h2 id="d938" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated"><strong class="ak">作为关联类型的协议</strong></h2><p id="971c" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">我们不能像在函数、类、结构或枚举中声明一样，在协议中直接定义泛型类型占位符。还有另一种方法将泛型类型定义为协议的占位符，即<strong class="ir hi">关联类型。</strong></p><p id="cb6c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">语法:</p><figure class="lb lc ld le fd ii"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="8401" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里<strong class="ir hi"> GenericPlaceholder </strong>可以是我们喜欢的任何东西，只要把它指定为泛型类型。并且<strong class="ir hi"> GenericPlaceholder </strong>可以在协议中的任何方法、属性或下标声明中作为参数类型使用。</p><p id="94b9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> GenericPlaceholder </strong>也可以添加约束。</p><p id="167e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如<strong class="ir hi">关联类型</strong>通用占位符:<strong class="ir hi">可比</strong></p><p id="eefb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下面的示例协议<strong class="ir hi">中，可识别的</strong>用通用类型<strong class="ir hi"> IDType </strong>声明变量id，其中id将是类型<strong class="ir hi"> IDType </strong>。</p><figure class="lb lc ld le fd ii"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="a549" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以通过以下任何一种方式进行确认:</p><figure class="lb lc ld le fd ii"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="50cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在第一段代码中，编译器根据类型推断自动识别出<strong class="ir hi"> id </strong>的类型，并将<strong class="ir hi"> IDType </strong>视为结构产品的<strong class="ir hi"> Int </strong>。</p><p id="ddf7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在第二个代码片段中，更多的是为了可读性，并指示编译器处理这种类型的相关方法、属性、下标等。你可以用编译器的自动修正功能来测试它。</p><h2 id="a36e" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated"><strong class="ak">关联类型的Where子句</strong></h2><p id="4f7b" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">为了对关联类型添加更多要求，我们可以使用where子句。它的语法是</p><figure class="lb lc ld le fd ii"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="9e64" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们来看看这个例子:<br/>让我们假设在不同的城市有一个不同的仓库的需求，每个仓库可以包含某种类型的产品，并且每个仓库知道这个特定产品的所有分支。所以让我们借助泛型找到这个问题的解决方案。</p><figure class="lb lc ld le fd ii"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h2 id="8669" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated">何去何从:</h2><p id="79a7" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">如果你更好奇的话，可以去查一下我在本教程中没有提到的Generic的下列高级用法。你可以通过苹果的文档丰富的网站<a class="ae lh" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html" rel="noopener ugc nofollow" target="_blank"> Swift编程语言指南</a>来学习它们。</p><ul class=""><li id="e729" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><a class="ae lh" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID185" rel="noopener ugc nofollow" target="_blank">扩展一个通用类型</a></li><li id="7220" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><a class="ae lh" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID192" rel="noopener ugc nofollow" target="_blank">具有通用函数的where子句</a></li><li id="cb23" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><a class="ae lh" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID553" rel="noopener ugc nofollow" target="_blank">带有通用Where子句的扩展</a></li><li id="57d1" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><a class="ae lh" href="https://docs.swift.org/swift-book/LanguageGuide/Generics.html#ID558" rel="noopener ugc nofollow" target="_blank">通用下标</a></li></ul></div></div>    
</body>
</html>