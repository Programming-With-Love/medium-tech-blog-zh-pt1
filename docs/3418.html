<html>
<head>
<title>GO: Method Receiver - Pointer v/s Value</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GO:方法接收器指针v/s值</h1>
<blockquote>原文：<a href="https://medium.com/globant/go-method-receiver-pointer-vs-value-ffc5ab7acdb?source=collection_archive---------0-----------------------#2020-06-22">https://medium.com/globant/go-method-receiver-pointer-vs-value-ffc5ab7acdb?source=collection_archive---------0-----------------------#2020-06-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/f2869fe772af8be4a522bafd3330ac3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ifpd_HtDiK9u6h68SZgNuA.png"/></div></div></figure><p id="b728" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您是新手，那么您一定已经接触过方法和函数的概念。让我们找出两者的区别-</p><p id="f211" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">通过指定参数、返回值和函数体的类型来声明函数</strong>。</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="4f64" class="jw jx hh js b fi jy jz l ka kb">type Person struct {<br/>    Name string<br/>    Age  int<br/>}</span><span id="1a5f" class="jw jx hh js b fi kc jz l ka kb">func NewPerson(name string, age int) *Person {<br/>  return &amp;Person{<br/>     Name: name,<br/>     Age:  age,<br/>  }<br/>}</span></pre><p id="c137" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">方法</strong>只是一个带有接收方参数的函数。它是用相同的语法声明的，只是增加了<strong class="ir hi">接收器</strong>。</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="6343" class="jw jx hh js b fi jy jz l ka kb">func (p *Person) isAdult bool {<br/>  return p.Age &gt; 18<br/>}</span></pre><p id="046b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的方法声明中，我们在<code class="du kd ke kf js b">*Person</code>类型上声明了<code class="du kd ke kf js b">isAdult</code>方法。</p><p id="8909" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们将看到<strong class="ir hi">值接收器</strong>和<strong class="ir hi">指针接收器<em class="kg">之间的区别。</em>T13】</strong></p><p id="b1d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">值接收器</strong>复制一份类型，并将其传递给函数。函数堆栈现在保存一个相等的对象，但是在内存的不同位置。这意味着对传递的对象所做的任何更改都将保留在该方法的本地。原始对象将保持不变。</p><p id="deaf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">指针接收器</strong>将类型的地址传递给函数。函数堆栈有一个对原始对象的引用。所以对传递的对象的任何修改都会修改原始对象。</p><p id="e874" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们用例子来理解这一点-</p><pre class="jn jo jp jq fd jr js jt ju aw jv bi"><span id="4e44" class="jw jx hh js b fi jy jz l ka kb">package main</span><span id="c99d" class="jw jx hh js b fi kc jz l ka kb">import (<br/>  "fmt"<br/>)</span><span id="5085" class="jw jx hh js b fi kc jz l ka kb">type Person struct {<br/>    Name string<br/>    Age  int<br/>}</span><span id="78ab" class="jw jx hh js b fi kc jz l ka kb">func ValueReceiver(p Person) {<br/>    p.Name = "John"<br/>    fmt.Println("Inside ValueReceiver : ", p.Name)<br/>}</span><span id="05ed" class="jw jx hh js b fi kc jz l ka kb">func PointerReceiver(p *Person) {<br/>    p.Age = 24<br/>    fmt.Println("Inside PointerReceiver model: ", p.Age)<br/>}</span><span id="e0bc" class="jw jx hh js b fi kc jz l ka kb">func main() {<br/>    p := Person{"Tom", 28}<br/>    p1:= &amp;Person{"Patric", 68}</span><span id="e88a" class="jw jx hh js b fi kc jz l ka kb">    ValueReceiver(p)<br/>fmt.Println("Inside Main after value receiver : ", p.Name)<br/>    PointerReceiver(p1)<br/>fmt.Println("Inside Main after value receiver : ", p1.Age)<br/>}</span><span id="fe3d" class="jw jx hh js b fi kc jz l ka kb">O/P-<br/>Inside ValueReceiver :  John<br/>Inside Main after value receiver :  Tom<br/>Inside PointerReceiver :  24<br/>Inside Main after pointer receiver :  24</span></pre><p id="5d23" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这表明带有值接收者的方法修改了对象的副本，而原始对象保持不变。通过ValueReceiver方法将一个人的Like- Name从Tom更改为John，但是这种更改没有反映在main方法中。另一方面，带有指针接收器的方法修改实际的对象。通过指针接收器方法，人的年龄从68岁变为24岁，同样的变化也反映在主方法中。您可以通过打印出指针或值接收器操作前后的对象地址来检查事实。</p><p id="0a49" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">那么如何在指针与值接收器之间选择呢？</strong></p><p id="9f6b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想在一个方法中改变接收器的状态，操纵它的值，<strong class="ir hi">使用指针接收器</strong>。这对于按值复制的值接收者来说是不可能的。对值接收者的任何修改都是对该副本的本地修改。如果不需要操纵接收器值，<strong class="ir hi">使用一个值接收器</strong>。</p><p id="e4fb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">指针接收器避免在每次方法调用时复制值。如果接收器是一个大的结构，</p><p id="6b48" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">值接收器是并发安全的，而指针接收器不是并发安全的。因此，程序员需要照顾它。</p><p id="32e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意事项</strong>—</p><ol class=""><li id="57a0" class="kh ki hh ir b is it iw ix ja kj je kk ji kl jm km kn ko kp bi translated">尽可能对所有方法使用相同的接收器类型。</li><li id="ccde" class="kh ki hh ir b is kq iw kr ja ks je kt ji ku jm km kn ko kp bi translated">如果需要状态修改，使用指针接收器，如果不使用值接收器。</li></ol><div class="kv kw ez fb kx ky"><a href="https://tour.golang.org/methods/8" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hi fi z dy ld ea eb le ed ef hg bi translated">围棋之旅</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">编辑描述</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">tour.golang.org</p></div></div></div></a></div></div></div>    
</body>
</html>