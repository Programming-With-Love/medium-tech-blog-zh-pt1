<html>
<head>
<title>Implementing linkedPurchaseToken correctly to prevent duplicate subscriptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正确实现linkedPurchaseToken以防止重复订阅</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/implementing-linkedpurchasetoken-correctly-to-prevent-duplicate-subscriptions-82dfbf7167da?source=collection_archive---------4-----------------------#2018-08-23">https://medium.com/androiddevelopers/implementing-linkedpurchasetoken-correctly-to-prevent-duplicate-subscriptions-82dfbf7167da?source=collection_archive---------4-----------------------#2018-08-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6c31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你使用Google Play订阅吗？确保您的后端服务器正确地实现了它们。</p><p id="67e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">订阅REST APIs是管理用户订阅的真实来源。<a class="ae jc" href="https://developers.google.com/android-publisher/api-ref/purchases/subscriptions#resource" rel="noopener ugc nofollow" target="_blank">purchases . subscriptions API</a>响应包含一个名为<strong class="ig hi"> linkedPurchaseToken的重要字段。</strong>正确处理该字段对于确保正确的用户访问您的内容至关重要。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/bf7f3f6aa6bca096a9e170c46c7d5f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akzNIZFqfp7xMmv2DYSlVA.jpeg"/></div></div></figure><h1 id="895f" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">它是如何工作的？</h1><p id="597a" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">正如在<a class="ae jc" href="https://developer.android.com/google/play/billing/billing_subscriptions#Allow-upgrade" rel="noopener ugc nofollow" target="_blank">订阅文档</a>中所概述的，每一个新的Google Play购买流程——初始购买、升级、降级和<a class="ae jc" href="#eb81" rel="noopener ugc nofollow">重新注册</a>——都会生成一个新的购买令牌。<strong class="ig hi"> linkedPurchaseToken </strong>字段可以识别多个购买令牌何时属于同一个订阅。</p><p id="098d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="ks">【更新，2021年3月。</em> </strong> <em class="ks">注意:随着Google Play计费中</em> <a class="ae jc" href="https://developer.android.com/google/play/billing/subscriptions#restore" rel="noopener ugc nofollow" target="_blank"> <em class="ks">重新订阅</em> </a> <em class="ks">功能的推出，所有用户都可以使用“重新订阅”操作。linkedPurchaseToken对于“升级”和“降级”流仍然很重要。</em><strong class="ig hi"><em class="ks"/></strong></p><p id="baa3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，用户购买订阅并收到购买令牌a。由于购买令牌属于全新的订阅，因此不会在API响应中设置<strong class="ig hi"> linkedPurchaseToken </strong>字段(灰色圆圈)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/1546aeb39d07f2b3ed44fec7aacb13da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRrs01R-tlUNxzDGnQqGSw.png"/></div></div></figure><p id="3aa6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果用户升级他们的订阅，将生成新的购买令牌B。由于升级将替换购买令牌A中的订阅，令牌B的<strong class="ig hi"> linkedPurchaseToken </strong>字段(显示在灰色圆圈中)将被设置为指向令牌A。请注意，它在时间上向后指向原始购买令牌。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/a923f039751f43a4d10567c88cf1779b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TeEsm7UtgRWQbgDizGEIjQ.png"/></div></div></figure><p id="cfd6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">购买令牌B将是唯一更新的令牌。购买令牌A不应用于授权用户访问您的内容。</p><p id="b59d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注意:</strong>在升级时，如果您查询Google Play计费服务器，购买令牌A和B都会显示它们处于活动状态。我们将在下一节的<a class="ae jc" href="#14e4" rel="noopener ugc nofollow">中详细讨论这一点。</a></p><p id="ec96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们假设一个不同的用户执行以下操作:订阅、升级、降级。原始订阅将创建购买令牌C，升级将创建购买令牌D，降级将创建购买令牌e。每个新令牌将向后链接到前一个令牌。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/c0ac735ff2b2e7e4cde34153b4640e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_m70ZdZp_PINQW4WFGmow.png"/></div></div></figure><p id="def2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们向示例中添加第三个用户。这个用户一直在改变主意。在初次订阅后，用户连续三次取消并重新订阅(做一个<a class="ae jc" href="#eb81" rel="noopener ugc nofollow">重签</a>)。初始订阅将创建购买令牌F，重新订阅将创建G、H和I。购买令牌I是最新的令牌。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ku"><img src="../Images/92cdc933acdf910e0cb39d834d9bfa4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXSvlU_mV6F3DbZmm2Pb_w.png"/></div></div></figure><p id="be3a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最新的令牌B、E和I分别代表用户1、2和3有权获得并支付的订阅。只有这些最新的令牌对权利有效。然而，就Google Play而言，如果初始到期日期尚未过去，链中的所有令牌都是“有效的”。</p><p id="383a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">换句话说，如果您在<a class="ae jc" href="https://developers.google.com/android-publisher/api-ref/purchases/subscriptions/get#response" rel="noopener ugc nofollow" target="_blank">订阅获取API </a>中查询任何令牌，包括上图中的A、C、D、F、G或H，您将获得一个<a class="ae jc" href="https://developers.google.com/android-publisher/api-ref/purchases/subscriptions#resource" rel="noopener ugc nofollow" target="_blank">订阅资源响应</a>，表明订阅尚未过期且已收到付款，尽管您应该只授予最新令牌的权利。</p><p id="7b2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">乍一看，这似乎很奇怪:为什么原始令牌在升级后看起来仍然有效？简而言之，这种实现在向用户提供内容和服务时为开发者提供了更大的灵活性，并有助于Google保护用户隐私。然而，它确实需要您在后端服务器上做一些重要的簿记工作。</p><h1 id="14e4" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">处理linkedPurchaseToken</h1><p id="0bc4" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">每次验证订阅时，您的后端都应该检查是否设置了<strong class="ig hi"> linkedPurchaseToken </strong>字段。如果是，则该字段中的值表示现在已被替换的前一个令牌。您应该立即将以前的令牌标记为无效，这样用户就无法使用它来访问您的内容。</p><p id="6cd7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，对于上面示例中的用户1，当后端接收到初始购买的购买令牌A，并且带有一个空的<strong class="ig hi"> linkedPurchaseToken </strong>字段时，它会启用该令牌的授权。稍后，当后端在升级后接收到新的购买令牌B时，它检查<strong class="ig hi"> linkedPurchaseToken </strong>字段，看到它被设置为A，并禁用购买令牌A的权利。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kv"><img src="../Images/f10bfdd5b10ed6b7d1383d90121cb840.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AelIWEUip7r0BfdTrYwnMQ.png"/></div></div></figure><p id="c112" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过这种方式，后端数据库始终保持最新，其中购买令牌对权利有效。在用户3的情况下，数据库的状态将演变如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kw"><img src="../Images/238cde57745f125d7bd391a5894055df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZnPLMmL6oAeLtYX-OBtEgw.png"/></div></div></figure><p id="c49f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用于检查<strong class="ig hi"> linkedPurchaseToken </strong>的伪代码:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="b7b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在<a class="ae jc" href="https://github.com/android/play-billing-samples/tree/master/ClassyTaxiAppKotlin" rel="noopener ugc nofollow" target="_blank"> Classy Taxi </a>的Firebase后端看到这样的例子，这是一个开源的端到端订阅应用程序。具体参见<a class="ae jc" href="https://github.com/googlesamples/android-play-billing/blob/5415f5563d5aeaf3f0e7e4457f826de9bf12a590/ClassyTaxi/firebase/server/src/play-billing/PurchasesManager.ts#L163" rel="noopener ugc nofollow" target="_blank">purchase manager . ts</a>中的<strong class="ig hi">disableReplacedSubscription</strong>方法。</p><h1 id="8f1f" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">清理现有数据库</h1><p id="a902" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">现在，您的后端将保持最新的新的、传入的购买令牌，您将检查每个新购买的<strong class="ig hi"> linkedPurchaseToken </strong>字段，并且对应于被替换订阅的任何令牌将被正确禁用。厉害！</p><p id="cd2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，如果您有一个现有的订阅数据库，它没有考虑到<strong class="ig hi"> linkedPurchaseToken </strong>字段，该怎么办呢？您需要在现有数据库上运行一次性清理算法。</p><p id="073f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在许多情况下，清理数据库时最重要的事情是给定的令牌是否有权使用内容/服务。换句话说:可能没有必要为每个订阅重新创建升级/降级/重签购买历史，只需确定每个单独令牌的正确权利。对数据库进行一次性清理将使事情变得有条不紊，接下来，只需按照上一节所述处理新的订阅即可。</p><p id="1c36" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设我们上面三个用户的购买令牌存储在一个数据库中。这些购买可能随着时间的推移而发生，并且可能以任何顺序出现。如果清理功能做得正确，令牌B、E和I应该最终被标记为对授权有效，并且所有其他令牌应该被禁用。</p><p id="dde9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">遍历数据库一次，检查每个元素。如果设置了<strong class="ig hi"> linkedPurchaseToken </strong>字段，则禁用该字段中包含的令牌。对于下图，我们从上到下依次进行:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kz"><img src="../Images/bea4a817bad26c100dcafc1c02931873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vl8exBJCC-F-dKcE9hSmFg.png"/></div></div></figure><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="a093" class="lf jq hh lb b fi lg lh l li lj">Element A: linkedPurchaseToken not set, move to next<br/>Element D: linkedPurchaseToken == C, disable C<br/>Element G: linkedPurchaseToken == F, disable F<br/>Element E: linkedPurchaseToken == D, disable D<br/>Element F: linkedPurchaseToken not set, move to next<br/>Etc.</span></pre><p id="fb50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用于清理现有数据库的伪代码:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="8f12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在运行这个一次性清理之后，所有旧的令牌都将被禁用，您的数据库将准备就绪。</p><h1 id="c906" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">额外保险</h1><p id="80ab" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">为了进一步帮助防范可疑活动，使用BillingFlowParams设置应用程序中的<strong class="ig hi"> accountId </strong>字段也是一个好主意。构建器的<a class="ae jc" href="https://developer.android.com/reference/com/android/billingclient/api/BillingFlowParams.Builder#setAccountId(java.lang.String)" rel="noopener ugc nofollow" target="_blank"> setAccountId </a>方法。您应该将其设置为一个可查询的值，该值对于每个用户都是唯一的，但是会混淆任何用户数据，比如用户帐户名的单向安全散列。</p><h1 id="2b72" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">简单但重要</h1><p id="7fb5" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">既然您已经理解了<strong class="ig hi"> linkedPurchaseToken </strong>字段是如何工作的，那么请确保在您的后端正确处理它。每个订阅的应用程序都应该检查这个字段。正确跟踪授权对于确保正确的用户在正确的时间获得正确的授权至关重要。</p><h1 id="9a37" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">资源</h1><ul class=""><li id="3164" class="lk ll hh ig b ih kn il ko ip lm it ln ix lo jb lp lq lr ls bi translated">谷歌<a class="ae jc" href="https://developer.android.com/google/play/billing/billing_library_overview" rel="noopener ugc nofollow" target="_blank">播放计费库</a></li><li id="d6c3" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">订阅<a class="ae jc" href="https://developer.android.com/google/play/billing/billing_subscriptions#Allow-upgrade" rel="noopener ugc nofollow" target="_blank">升级和降级</a></li><li id="dea6" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated"><a class="ae jc" href="https://developers.google.com/android-publisher/api-ref/purchases/subscriptions#resource" rel="noopener ugc nofollow" target="_blank">订阅API </a></li><li id="dc94" class="lk ll hh ig b ih lt il lu ip lv it lw ix lx jb lp lq lr ls bi translated">端到端订阅示例应用程序</li></ul><p id="eb81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="#895f" rel="noopener ugc nofollow"><strong class="ig hi"><em class="ks">sign up</em></strong></a><em class="ks">是指当用户订阅后，取消其订阅，然后在原订阅到期前重新订阅。尽管他们没有失去权利，新的订购将与以前的相同，但他们将经历另一个购买流程，因为他们承诺未来付款。他们将收到一个新的购买令牌，并将设置linkedPurchaseToken字段，就像升级或降级的情况一样。更新:请注意，这仅发生在应用程序内的辞职。如果用户从谷歌Play商店订阅中心重新订阅，将不会颁发新的购买令牌，也不会设置此字段，将使用原始令牌。</em></p><blockquote class="ly lz ma"><p id="458e" class="ie if ks ig b ih ii ij ik il im in io mb iq ir is mc iu iv iw md iy iz ja jb ha bi translated"><em class="hh">这里找到的所有代码都是在</em> <a class="ae jc" href="https://www.apache.org/licenses/LICENSE-2.0" rel="noopener ugc nofollow" target="_blank"> <em class="hh"> Apache 2.0许可</em> </a> <em class="hh">下授权的。这里没有任何内容是谷歌官方产品的一部分，仅供参考。</em></p><p id="5cff" class="ie if ks ig b ih ii ij ik il im in io mb iq ir is mc iu iv iw md iy iz ja jb ha bi translated">文章开头的令牌图像是从<a class="ae jc" href="https://commons.wikimedia.org/wiki/File:French_revolutionary_shop_token_(FindID_530752).jpg" rel="noopener ugc nofollow" target="_blank">这个url </a>复制的。归因:可移动古物计划/大英博物馆受托人。根据<a class="ae jc" href="https://en.wikipedia.org/wiki/en:Creative_Commons" rel="noopener ugc nofollow" target="_blank">知识共享</a> <a class="ae jc" href="https://creativecommons.org/licenses/by-sa/2.0/deed.en" rel="noopener ugc nofollow" target="_blank">署名-共享2.0通用</a>许可协议进行许可。</p></blockquote></div></div>    
</body>
</html>