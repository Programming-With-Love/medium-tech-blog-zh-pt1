<html>
<head>
<title>How To Make Swagger Codegen Work For Your Team</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让Swagger Codegen为您的团队工作</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/how-to-make-swagger-codegen-work-for-your-team-32194f7d97e4?source=collection_archive---------1-----------------------#2018-08-20">https://medium.com/capital-one-tech/how-to-make-swagger-codegen-work-for-your-team-32194f7d97e4?source=collection_archive---------1-----------------------#2018-08-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/04031ad655beaa3a191221a9afb11c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*40QoFCG4BS_RvaV7mgT4_Q.png"/></div></div></figure><p id="599d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Swagger Codegen，开源API客户端代码生成器，对于您的团队来说是一个非常强大、省时的协作工具。像大多数功能强大的工具一样，它可能并不完全符合您开箱即用的需求。为了让Swagger Codegen真正为您和您的团队工作，理解Swagger Codegen是如何工作的是很有帮助的。但是，首先你可能会问，为什么？</p><h1 id="b7c6" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">“懒惰”的美德</h1><blockquote class="kl"><p id="2d5c" class="km kn hh bd ko kp kq kr ks kt ku jm dx translated">“我们将鼓励你培养程序员的三大美德:<strong class="ak">懒惰、急躁和傲慢。”</strong> — <a class="ae kv" href="http://wiki.c2.com/?LarryWall" rel="noopener ugc nofollow" target="_blank">拉里·沃尔</a>、<a class="ae kv" href="http://wiki.c2.com/?ProgrammingPerl" rel="noopener ugc nofollow" target="_blank">程序员</a>(第一版)、<a class="ae kv" href="https://www.oreilly.com/" rel="noopener ugc nofollow" target="_blank">奥赖利及其合伙人</a></p></blockquote><p id="475c" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">在讨论代码生成工具的时候，如果不提到拉里·沃尔的“程序员的三大美德”，那我就失职了在这三种美德中，斯瓦格·科德根可能有充分的理由，但我认为最有力的理由是懒惰。</p><p id="8f04" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种情况下，拉里·沃尔在他的名著《Perl编程》的词汇表中对懒惰的解释是，“使你尽最大努力降低整体能量消耗的品质。它让你写一些省力的程序，其他人会觉得有用…”</p><p id="1df5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，当拉里·沃尔称赞程序员懒惰的优点时，他并不是指抄近路和做懒惰的事情，比如不写单元测试。拉里·沃尔对懒惰的定义绝不应该被看作是对普遍懒惰的辩护。但是，如果你在“懒惰”方面做得很好，并且希望在阅读完这篇文章后你会这样做，那么使用Swagger Codegen不仅意味着减少你自己的能量消耗，还意味着减少团队所有成员的能量消耗。</p><p id="0a14" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您不需要编写、维护或担心自动生成的代码的一致性！你可以节省你的劳动和精力来完成像写关于代码生成的博客这样的任务。😇</p><p id="dc9b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是等等，在我们开始凭空生成代码之前，我们必须讨论一下作为一个团队我们需要做些什么。</p><h1 id="a1cc" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">OpenAPI规范</h1><p id="5bd2" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated"><a class="ae kv" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI规范</a>(以前称为Swagger规范)是一个<em class="lb">“RESTful API的语言无关接口</em>，它使精通不同编程语言的各种开发人员能够以每个人都能理解的方式讨论REST APIs。该规范允许开发人员在任何人编写一行代码之前创建一个定义API如何工作以及它应该做什么的契约。这允许创建和维护API的开发人员和他们的客户就一个非常具体的契约达成一致，并且<em class="lb">说“如果我将这个带有这些头的主体发布到这个端点，那么我希望得到这种格式的响应。”</em></p><p id="cded" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">举个具体的例子，我邀请你看看这个<a class="ae kv" href="https://github.com/OAI/OpenAPI-Specification/blob/master/examples/v2.0/yaml/petstore.yaml" rel="noopener ugc nofollow" target="_blank">宠物店应用</a>的OpenAPI规范。随着您对OpenAPI规范的了解越来越多，Pet Store示例将会变得非常熟悉。这是每个开发人员在为每种新语言实现代码生成规则时使用的参考点。集成测试总是根据OpenAPI倡议的Github Repo中的OpenAPI规范来执行。</p><p id="74c7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在简要回顾了<code class="du lh li lj lk b">`petstore.yaml`</code>之后，我们可以看到一个简单但完整的API已经被定义了。基于该规范中定义的需求，我们可以实现一个后端服务，该服务返回数据库中所有宠物的列表，或者向数据库中写入一个新的宠物，并将其发布到API。在前端，我们可以构建我们需要与API交互的模型，并实现我们可以用来调用端点来获取新宠物或发布新宠物的正确服务。</p><p id="169d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们<em class="lb">可以</em>做所有这些…但是作为“懒惰”的程序员，我们可以使用Swagger Codegen来代替！</p><h1 id="b86d" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">Swagger Codegen入门</h1><p id="eec9" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated">在使用Swagger Codegen之前，您需要在本地安装它。有许多不同的方式安装和使用Swagger Codegen。为了最大限度地控制修改项目以满足我们的需求，也为了跟上这篇博客，获得Swagger Codegen的最好方法是克隆整个repo:<a class="ae kv" href="https://github.com/swagger-api/swagger-codegen" rel="noopener ugc nofollow" target="_blank">https://github.com/swagger-api/swagger-codegen</a>。一旦本地有了项目，就需要运行<code class="du lh li lj lk b">mvn clean package</code>。如果成功完成，您将看到在目录<code class="du lh li lj lk b">modules/swagger-codegen-cli/target/</code>中创建的<code class="du lh li lj lk b">swagger-codegen-cli.jar</code>。</p><p id="c2d3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lb">注意—如果您的环境中没有“mvn”命令行工具，您可以在此处</em>  <em class="lb">找到下载和安装Maven </em> <a class="ae kv" href="https://maven.apache.org/" rel="noopener ugc nofollow" target="_blank"> <em class="lb">的说明。</em></a></p><p id="d0d2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个。jar文件是一个命令行工具，它提供了在您准备好生成代码后使用Swagger Codegen所需的唯一界面。让我们举一个简单的例子，生成Swift客户端模型，用于与我们之前看到的宠物商店API进行交互。</p><p id="18a6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们为我们的实验创建一个干净的工作目录:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="ff8f" class="lt jo hh lk b fi lu lv l lw lx">mkdir ~/PetStoreApp; cd ~/PetStoreApp; open .;</span></pre><p id="41b8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将swagger-codegen-cli.jar文件复制到PetStoreApp文件夹中，并将<a class="ae kv" href="https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/examples/v2.0/yaml/petstore.yaml" rel="noopener ugc nofollow" target="_blank"> petstore.yaml文件</a>下载到同一文件夹中(在浏览器中右击网页&gt;另存为…)</p><p id="e82c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，PetStoreApp文件夹中应该有两个文件。</p><figure class="ll lm ln lo fd ii er es paragraph-image"><div class="er es ly"><img src="../Images/643806b79932356609b579f1302cd073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*3jU2Ls7Bq3LQlfrkdXdz7Q.png"/></div></figure><h1 id="7716" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">生成代码</h1><p id="4d98" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated">在您的终端中，确保您位于/PetStoreApp目录中，并运行以下命令:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="37d9" class="lt jo hh lk b fi lu lv l lw lx"><br/>java -jar swagger-codegen-cli.jar generate -i petstore.yaml -l swift4 -Dmodels<br/></span></pre><p id="71a7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以在这里找到所有你可以用来生成代码的选项的完整分类。您也可以使用<code class="du lh li lj lk b">`help generate`</code>命令。jar文件，以了解有关该命令的更多详细信息。但是现在，让我们分解上面的简单命令:</p><p id="6fce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lh li lj lk b"><strong class="ir hi"><em class="lb">java -jar swagger-codegen-cli.jar</em></strong></code></p><p id="78e5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">java命令行工具允许我们传递一个Java归档(JAR)文件，并在命令行中执行它。这样我们就可以运行Swagger Codegen命令行工具。</p><p id="5912" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lh li lj lk b"><strong class="ir hi"><em class="lb">generate</em></strong></code></p><p id="0e67" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Generate是传递给Swagger Codegen CLI工具的命令。这是调用该工具的主要方式，传递给CLI工具的其他内容都是修改生成命令执行的选项。</p><p id="09ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lh li lj lk b"><strong class="ir hi"><em class="lb">-i petstore.yaml</em></strong></code></p><p id="b1cc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是输入规范文件。在这个例子中，我们已经传入了宠物商店API yaml文件。Swagger Codegen将使用这个规范文件来生成我们的代码。</p><p id="b53c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lh li lj lk b"><strong class="ir hi"><em class="lb">-l swift4</em></strong></code></p><p id="6d2f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，我们指定我们希望Swagger Codegen为我们的应用程序生成客户端Swift代码。我们指定了Swift 4，但是Swagger Codegen也支持Swift 2和Swift 3。</p><p id="f4bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lh li lj lk b"><strong class="ir hi"><em class="lb">-Dmodels</em></strong></code></p><p id="3bfc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后一个选项指定我们只想为我们的API生成模型文件。这包括在规范底部的OpenAPI规范的“定义”部分中定义的模型。Swagger Codegen可以在客户端为您生成网络代码的模拟实现。为了使这篇博客简单，我将把我们的讨论限制在生成的模型上，把生成的网络代码留给另一篇博客。可能😀</p><p id="188c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从PetStoreApp目录运行上述命令后，您应该会看到以下内容:</p><figure class="ll lm ln lo fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/e91b5014a2b951751306c289fc50cc96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HO7k1e5IkIN0h8g0UZEKQA.png"/></div></div></figure><p id="3672" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，Swagger Codegen这次为我们生成的唯一文件是模型文件。这些是我们在用来生成这些模型的生成命令中引用的<code class="du lh li lj lk b">`petstore.yaml</code>文件的<code class="du lh li lj lk b">`definitions`</code>部分中定义的模型文件。如上所述，我们使用的<code class="du lh li lj lk b">`-Dmodels`</code>标志向Swagger Codegen工具发出信号，表明我们只希望生成模型。单独生成模型是Swagger Codegen的一个非常强大的特性，因为它允许我们做一些事情。</p><ol class=""><li id="1062" class="ma mb hh ir b is it iw ix ja mc je md ji me jm mf mg mh mi bi translated">它允许我们在应用程序中自由使用任何网络库。Swagger Codegen支持为RXSwift、Alamofire和PromiseKit构建所有网络请求管理代码。</li><li id="538f" class="ma mb hh ir b is mj iw mk ja ml je mm ji mn jm mf mg mh mi bi translated">生成模型减少了在服务的后端和前端定义共享模型时可能出现的人为错误。即使你拼错了一个属性名，你也可以保证它在网络请求的两端以完全相同的方式拼错！</li><li id="4738" class="ma mb hh ir b is mj iw mk ja ml je mm ji mn jm mf mg mh mi bi translated">如果您的应用程序使用许多不同的模型与您的后端服务进行通信，或者如果这些模型经常更改，您可以显著减少维护或从头编写这些模型所需的时间和精力。如果您的前端和后端服务是用不同的语言实现的，这一点尤其正确。</li></ol><h1 id="db14" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">YAML到斯威夫特</h1><p id="b26c" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated">Swagger Codegen基于我们作为输入规范传入的petstore.yaml文件为我们创建了三个新文件。让我们仔细看看Pet.swift文件。</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="bf10" class="lt jo hh lk b fi lu lv l lw lx">public struct Pet: Codable {<br/>  public var _id: Int64<br/>  public var name: String<br/>  public var tag: String?</span><span id="b6d6" class="lt jo hh lk b fi mo lv l lw lx">  public init(_id: Int64, name: String, tag: String?){<br/>    self._id = _id<br/>    self.name = name<br/>    self.tag = tag<br/>}</span><span id="cf8d" class="lt jo hh lk b fi mo lv l lw lx">   public enum CodingKeys: String, CodingKey {<br/>     case _id = “id”<br/>     case name<br/>     case tag<br/>   }<br/>}</span></pre><p id="7daf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们将这个生成的Swift模型与OpenAPI规范中的原始定义进行比较时，我们会清楚地看到这种关系。该对象的原始OpenAPI规范如下所示:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="9970" class="lt jo hh lk b fi lu lv l lw lx">  Pet:<br/>   required:<br/>     - id<br/>     - name<br/>   properties:<br/>    id:<br/>    type: integer<br/>    format: int64<br/>   name:<br/>    type: string<br/>   tag:<br/>    type: string</span></pre><p id="8afc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管数据的格式略有不同，但我们构建Swift对象(或任何其他语言的对象)所需的所有信息都存在于OpenAPI规范中。然而，OpenAPI规范并不是最终生成Swift对象的数据。在用特定语言创建对象之前，Swagger Codegen会根据OpenAPI规范生成一个中间状态。</p><h1 id="042e" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">中间代表</h1><p id="aa9b" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated">仍然在/PetStoreApp目录中，我们可以运行一个类似于刚才运行的命令，但是这一次我们将传递一个命令来显示中间状态。</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="158f" class="lt jo hh lk b fi lu lv l lw lx">java -jar swagger-codegen-cli.jar generate -i petstore.yaml -l swift4 -DdebugModels</span></pre><p id="7442" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">传递-DdebugModels标志会将大量数据转储到终端。为了使你自己居中，你可以在终端<code class="du lh li lj lk b">”importPath” : “/Models.Pet”</code>中搜索这个字符串</p><p id="211e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是为表示上述OpenAPI规范中的Pet模型而生成的中间数据对象。您会注意到这与OpenAPI规范具有相同的信息，但是格式略有不同。这些数据已经被格式化，我们可以很容易地用来生成一个Swift类。例如，您将看到这个数据对象的属性之一是一个变量数组。这些变量中的每一个都是我们的Pet类的属性，这个对象给了我们很多关于这些变量的非常具体的信息。下面是我们可以看到的仅关于id属性的数据:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="cce6" class="lt jo hh lk b fi lu lv l lw lx">…<br/>“vars” : [ {<br/>   “baseName” : “id”,<br/>   “getter” : “getId”,<br/>   “setter” : “setId”,<br/>   “datatype” : “Int64”,<br/>   “datatypeWithEnum” : “Int64”,<br/>   “dataFormat” : “int64”,<br/>   “name” : “_id”,<br/>   “defaultValueWithParam” : “ = data.id;”,<br/>   “baseType” : “Int64”,<br/>   “jsonSchema” : “{\n \”type\” : \”integer\”,\n \”format\” : \”int64\”\n}”,<br/>   “exclusiveMinimum” : false,<br/>   “exclusiveMaximum” : false,<br/>   “hasMore” : true,<br/>   “required” : true,<br/>   “secondaryParam” : false,<br/>   “hasMoreNonReadOnly” : true,<br/>   “isPrimitiveType” : true,<br/>   “isContainer” : false,<br/>   “isNotContainer” : true,<br/>   “isString” : false,<br/>   “isNumeric” : true,<br/>   “isInteger” : false,<br/>   “isLong” : true,<br/>   “isNumber” : false,<br/>   “isFloat” : false,<br/>   “isDouble” : false,<br/>   “isByteArray” : false,<br/>   “isBinary” : false,<br/>   “isFile” : false,<br/>   “isBoolean” : false,<br/>   “isDate” : false,<br/>   “isDateTime” : false,<br/>   “isUuid” : false,<br/>   “isListContainer” : false,<br/>   “isMapContainer” : false,<br/>   “isEnum” : false,<br/>   “isReadOnly” : false,<br/>   “vendorExtensions” : {<br/>    “x-swift-optional-scalar” : true,<br/>     “x-codegen-escaped-property-name” : true<br/>    },<br/>    “hasValidation” : false,<br/>    “isInherited” : false,<br/>    “nameInCamelCase” : “Id”<br/>    “isXmlAttribute” : false,<br/>    “isXmlWrapped” : false<br/>   }<br/>…</span></pre><p id="d7df" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一些非常有用的Swift开发人员为我们创造了一些神奇的东西。一个特别的例子是“名称”属性。你会注意到<code class="du lh li lj lk b">“name”</code>是<code class="du lh li lj lk b">“_id”</code>，但是<code class="du lh li lj lk b">“baseName”</code>是<code class="du lh li lj lk b">“id”</code>。这很有帮助，因为id是Obj-C中的保留关键字。</p><p id="7fa8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了使生成的代码更好地与Obj-C互操作，如果您向上滚动，您会注意到，即使我们的Pet模型被定义为具有属性名<code class="du lh li lj lk b">“id”</code>，这种情况已经在生成的Swift类中得到安全处理。这样，当我们在客户端使用对象时，我们将引用属性为<code class="du lh li lj lk b">“_id”</code>。但是，每当对象被序列化为JSON并发送给服务器时，都会使用正确的“id”属性名。</p><p id="5583" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是这里似乎仍然缺少一些东西…我们如何从一个OpenAPI规范，到这个庞大而笨拙的JSON blob，再到一个完美呈现的Swift类？答案是<a class="ae kv" href="https://mustache.github.io/" rel="noopener ugc nofollow" target="_blank">小胡子模板</a>！</p><h1 id="5d47" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">胡子模板</h1><p id="9082" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated">mustache模板系统用于将变量值插入到静态文本模板中。在来自<a class="ae kv" href="https://mustache.github.io/mustache.5.html" rel="noopener ugc nofollow" target="_blank"> Mustache文档</a>的最简单的例子中，很清楚Mustache模板系统是如何得名的。无数看起来像小胡子的花括号被用来标识应该被替换的变量值。</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="add1" class="lt jo hh lk b fi lu lv l lw lx">Template:</span><span id="fb43" class="lt jo hh lk b fi mo lv l lw lx">{{#person?}}<br/>  Hi {{name}}!<br/>{{/person?}}</span><span id="0483" class="lt jo hh lk b fi mo lv l lw lx">Hash:</span><span id="7284" class="lt jo hh lk b fi mo lv l lw lx">{<br/> “person?”: { “name”: “Jon” }<br/>}</span><span id="c891" class="lt jo hh lk b fi mo lv l lw lx">Output:</span><span id="26f3" class="lt jo hh lk b fi mo lv l lw lx">Hi Jon!</span></pre><p id="4f25" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用这个相同的系统，我们不仅可以为用Swift编写的移动应用生成<em class="lb">模型</em>，还可以为<a class="ae kv" href="https://github.com/swagger-api/swagger-codegen/tree/master/modules/swagger-codegen/src/main/resources" rel="noopener ugc nofollow" target="_blank">我们可能想要的每种语言生成<em class="lb">代码</em></a>。继续讨论Swift的例子，让我们研究一下如何使用mustache模板系统为Swift对象创建一个模板。</p><h1 id="16df" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">你自己试试！</h1><p id="739a" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated">Swift 4模型对象的Swagger Codegen实现可以在<a class="ae kv" href="https://github.com/swagger-api/swagger-codegen/blob/master/modules/swagger-codegen/src/main/resources/swift4/modelObject.mustache" rel="noopener ugc nofollow" target="_blank">这里</a>找到。但是让我们做一个简单的版本来说明一些基本情况:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="1503" class="lt jo hh lk b fi lu lv l lw lx">Template:</span><span id="c065" class="lt jo hh lk b fi mo lv l lw lx">import Foundation</span><span id="1b27" class="lt jo hh lk b fi mo lv l lw lx">public class {{classname}}: Codable {<br/>{{#vars}}<br/>public var {{name}}: {{{datatype}}}{{^required}}?{{/required}}{{#defaultValue}} = {{{defaultValue}}}{{/defaultValue}}<br/>{{/vars}}</span><span id="5a04" class="lt jo hh lk b fi mo lv l lw lx">init({{#vars}}{{name}}: {{{datatype}}}{{^required}}?{{/required}}{{^isFinal}},{{/isFinal}} {{/vars}}) {<br/>    {{#vars}}<br/>    self.{{name}} = {{name}}<br/>    {{/vars}}<br/>  }<br/>}</span><span id="313b" class="lt jo hh lk b fi mo lv l lw lx">Hash:</span><span id="0663" class="lt jo hh lk b fi mo lv l lw lx">{<br/>“classname”: “Pet”,<br/> “vars”: [<br/>  {<br/>   “name”: “_id”,<br/>   “datatype”: “Int64”,<br/>   “required”: true,<br/>   “defaultValue”: 1<br/>  },<br/>  {<br/>   “name”: “name”,<br/>   “datatype”: “String”,<br/>   “required”: false,<br/>   “isFinal”: true<br/>  }<br/> ]<br/>}</span><span id="764e" class="lt jo hh lk b fi mo lv l lw lx">Output:</span><span id="f55c" class="lt jo hh lk b fi mo lv l lw lx">import Foundation</span><span id="1e5b" class="lt jo hh lk b fi mo lv l lw lx">public class Pet: Codable {<br/>public var _id: Int64 = 1public var name: String?</span><span id="cae2" class="lt jo hh lk b fi mo lv l lw lx">init(id: Int64, name: String? ) {<br/>       self._id = _id<br/>       self.name = name<br/>       }<br/>}</span></pre><p id="8022" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我建议取上面的模板和JSON hash，插入到简单的<a class="ae kv" href="https://mustache.github.io/#demo" rel="noopener ugc nofollow" target="_blank"> Mustache演示app </a>中。在这里，您可以修改hash值或修改mustache模板，看看是否可以改进或创建新的功能。您如何重新创建在本博客开头的Swift对象中看到的编码密钥枚举？如何修改mustache模板，以便用该模板创建的所有数据模型都符合等价或散列协议？如果你能回答这些问题，那么你就已经是那种“懒惰”的程序员了，可能再也不需要编写或更新另一个数据模型了！</p><h1 id="c8f0" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">标准Swagger Codegen定制</h1><p id="5cfd" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated">Swagger Codegen的大多数用户从来不需要修改Swagger Codegen库本身的mustache模板，因为每种语言的mustache模板的默认实现已经涵盖了大多数用例。然而，还有其他方法可以修改Swagger Codegen的输出，而不需要修改mustache模板。修改不同语言模板行为的默认方式是传入一个配置对象。</p><p id="07ad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用以下命令找出每种语言支持的配置属性:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="4442" class="lt jo hh lk b fi lu lv l lw lx"> java -jar swagger-codegen-cli.jar config-help -l &lt;language (e.g. swift4, kotlin)&gt;</span></pre><p id="50c2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以选择使用库来管理响应。目前PromiseKit，RxSwift都有。</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="3a83" class="lt jo hh lk b fi lu lv l lw lx">    responseAs<br/>      Optionally use libraries to manage response. Currently PromiseKit, RxSwift are available.</span><span id="deca" class="lt jo hh lk b fi mo lv l lw lx">    unwrapRequired<br/>      Treat ‘required’ properties in response as non-optional (which would crash the app if API returns null as opposed to required option specified in json schema<br/> ```</span></pre><p id="9afc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要使用这些属性，您需要创建一个新文件，您可以在其中创建一个JSON对象，作为新参数传递给Swagger Codegen CLI工具。仍然在您之前创建的PetStoreApp文件夹中，您可以运行以下命令来创建一个JSON对象，该对象将RxSwift指定为用于处理HTTP响应的库:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="d158" class="lt jo hh lk b fi lu lv l lw lx">echo {“responseAs”:”RxSwift”} &gt; config.json</span></pre><p id="585c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，您可以将这个config.json文件传递到原始CLI命令中来生成我们的代码，同时删除指令-Dmodels并允许Swagger Codegen生成除数据模型之外的所有文件:</p><pre class="ll lm ln lo fd lp lk lq lr aw ls bi"><span id="d5ff" class="lt jo hh lk b fi lu lv l lw lx">java -jar swagger-codegen-cli.jar generate -i petstore.yaml -l swift4 -c config.json</span></pre><h1 id="23d3" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="d075" class="pw-post-body-paragraph ip iq hh ir b is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji lg jk jl jm ha bi translated">现在你不仅应该对Swagger Codegen工具能做什么有了很好的理解，而且应该对如何使用它们来体现“懒惰”的优点有了很好的理解。然而，我们仍然只是刚刚触及了Swagger Codegen这一惊人的强大工具的表面，以及它如何帮助您减少总体能源消耗，阿拉拉里·沃尔。</p><p id="efcd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Swagger Codegen正处于非常活跃的开发阶段，并且有一个相关的社区，所以一定要查看他们的Github页面,了解关于Swagger Codegen的最新消息。此外，除了Swagger codegen之外，还有一些其他优秀的Codegen工具。我很想听听你喜欢的其他工具或者你使用它们的经历。如有任何问题或评论，请随时在Twitter上联系我。</p><figure class="ll lm ln lo fd ii er es paragraph-image"><a href="https://medium.com/capital-one-tech/api/home"><div class="er es mp"><img src="../Images/c6c5bb1f3967049ba012aebf5757e08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*x8RfN3y_bm7aDVs1vHMfkg.jpeg"/></div></a></figure></div><div class="ab cl mq mr go ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ha hb hc hd he"><p id="5148" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lb">声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>