<html>
<head>
<title>Adding a Cross Instance, Cross Restarts and Cross Application Cache to Node.js Apps on Oracle Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向Oracle Cloud上的Node.js应用程序添加跨实例、跨重启和跨应用程序缓存</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/adding-a-cross-instance-cross-restarts-and-cross-application-cache-to-node-applications-on-oracle-53e4078632fb?source=collection_archive---------0-----------------------#2017-08-12">https://medium.com/oracledevs/adding-a-cross-instance-cross-restarts-and-cross-application-cache-to-node-applications-on-oracle-53e4078632fb?source=collection_archive---------0-----------------------#2017-08-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3538" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在之前的帖子中，我描述了如何在简单的节点应用程序上从Oracle开发人员云到Oracle应用程序容器云进行持续集成和交付:<a class="ae jc" href="https://technology.amis.nl/2017/08/11/automating-build-and-deployment-of-node-application-in-oracle-developer-cloud-to-application-container-cloud/" rel="noopener ugc nofollow" target="_blank">在Oracle开发人员云中自动构建和部署节点应用程序到应用程序容器云</a>。在这篇文章中，我将扩展这个非常简单的应用程序，使其具有统计请求的功能。对于应用程序的每个HTTP请求，计数器都会递增，并且在响应中返回当前的计数器值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/7d60ed57fda9d27f8f55c2251d936905.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/0*2WV3jlbNYm_TjeIj."/></div></figure><p id="9643" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最初的实现非常简单:节点应用程序包含一个全局变量，该变量随着处理的每个请求而增加。这很天真，因为:</p><ul class=""><li id="006d" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">多个实例同时运行，每个实例都有自己的计数；由于负载平衡，后续的请求由不同的实例处理，响应将显示出稍微不规则的请求计数器模式；请求总数未知:每个实例都是该实例的小计</li><li id="37ca" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">当应用程序重启时——甚至是重启或添加单个实例时——每个相关实例的请求计数器都会被重置</li></ul><p id="7f45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，请求计数值在节点应用程序之外不可用，只能通过调用应用程序来检索，这反过来会增加计数。</p><p id="ea82" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个更好的实现是使用缓存，由应用程序实例共享，并且在应用程序(实例)重启后仍然存在。如果我们允许的话，这也有可能使请求计数值对其他可以访问相同缓存的微服务可用。</p><p id="f8e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇文章演示了如何在应用容器云服务上设置应用缓存，以及如何从节点应用中利用它。它表明请求计数器将跨实例共享，并且在重新部署和重新启动后仍然存在。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/8a21b4e386709f6a7955ab6a30d88d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_708IP6FCGVpXv0j."/></div></div></figure><p id="af85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:在这个简单的例子中，仍然有一些小的竞争条件没有解决，因为读、更新和写不是作为原子操作执行的，也没有实现锁定。</p><p id="3e9e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些步骤是:</p><ul class=""><li id="718d" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">为<em class="ke">问候</em>微服务增加请求计数功能</li><li id="c23f" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">展示多个请求(由多个实例处理)和实例重启的缺点</li><li id="f5c9" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">实现应用程序缓存</li><li id="f0ef" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">为开发者云服务中的<em class="ke">问候</em>添加应用缓存服务绑定到ACCS部署配置文件</li><li id="0357" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">在<em class="ke">问候</em>微服务中利用应用缓存</li><li id="8384" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">重新部署<em class="ke">问候</em>微服务，并演示请求计数器是共享和保留的</li></ul><p id="28b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文来源于GitHub:<a class="ae jc" href="https://github.com/lucasjellema/greeting" rel="noopener ugc nofollow" target="_blank">https://github.com/lucasjellema/greeting</a>。</p><h1 id="008e" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">向问候微服务添加请求计数功能</h1><p id="add9" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">这个非常简单的HTTP请求处理程序用一个全局变量<em class="ke"> requestCounter </em>进行了扩展，该变量为每个请求显示并递增:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/1dc0d3edde01f1e6d9a9e71a76a7fec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HsMT05ruEuduOYGS."/></div></div></figure><p id="f54e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不难证明多个请求(由多个实例处理)的缺点:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es li"><img src="../Images/04e0a36721c471a94d10597ecede8351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/0*j_uReBr-2wFAG9rG."/></div></figure><p id="d42b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我们可以看到两个不同的实例(显然)是如何处理后续请求的，每个实例都有自己独立增加的计数。</p><p id="9ff8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">应用程序重新启动后，计数回到开始。</p><h1 id="0ce6" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">配置应用程序缓存</h1><p id="b0dd" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">要配置应用程序缓存，我们需要从Oracle应用程序容器云服务控制台进行操作。</p><div class="je jf jg jh fd ab cb"><figure class="lj ji lk ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><img src="../Images/78174a4f83d9d5fff26461e9bd267d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/0*7xNwxACG00riugnn."/></div></figure><figure class="lj ji lp ll lm ln lo paragraph-image"><img src="../Images/12f4583bc43073ab2a1e3348be117f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/0*U21hYsvZ0DntgFDf."/></figure></div><p id="75ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">指定详细信息—名称和可能的大小:</p><div class="je jf jg jh fd ab cb"><figure class="lj ji lq ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><img src="../Images/41076d777fc8efe407f3157cea4f4c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/0*QKPzvsQs9DIWD8cW."/></div></figure><figure class="lj ji lr ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><img src="../Images/41719aac28c9ccc9315e7a4b5ddeff53.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/0*RjvcEoI-vMGxGVFJ."/></div></figure></div><p id="1440" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">按“创建”,将创建缓存:</p><div class="je jf jg jh fd ab cb"><figure class="lj ji ls ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><img src="../Images/03062f6b0bcbedb88902fd6b84c90e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/0*4OCoH-zZ8o6EEEKC."/></div></figure><figure class="lj ji lt ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><img src="../Images/d2558661cd54dcb18a48b07b64417c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/0*yme8iNScoGuyFu9M."/></div><figcaption class="lu lv et er es lw lx bd b be z dx ly di lz ma">I got notified about its completion by email (picture on the right).</figcaption></figure></div><h1 id="7ea8" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">将应用程序缓存服务绑定添加到ACCS部署配置文件，以便在开发人员云服务中使用问候语</h1><p id="2aa0" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">为了能够从ACCS上的应用程序内部访问缓存，应用程序需要绑定到缓存服务的服务。这可以在控制台中(手动)配置，也可以通过REST API、psm cli和Developer Cloud Service中部署配置中的部署描述符来配置。</p><p id="dc59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过web用户界面进行的手动配置如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es mb"><img src="../Images/6fc36da3a4c377a3ddacfd83e45ba7ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/0*DBUgDhOKngByZx-l."/></div></div></figure><h2 id="79ad" class="mc kg hh bd kh md me mf kl mg mh mi kp ip mj mk kt it ml mm kx ix mn mo lb mp bi translated">或者通过服务绑定:</h2><div class="je jf jg jh fd ab cb"><figure class="lj ji mq ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><img src="../Images/dd831d94091196b8b8ee5b9260e3b40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/0*uuo_4BHF617N7Jep."/></div></figure><figure class="lj ji mr ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><img src="../Images/c1a95630fabb7cc87f177b23cb5ac57c.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/0*p6KBITWHEJBq-ijJ."/></div></figure><figure class="lj ji ms ll lm ln lo paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><img src="../Images/fd32baa5efcde2fca3b49c78dd8ac1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/0*UKsruemlbxSIvVMz."/></div></figure></div><p id="861d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我可以利用psm命令行界面来检查ACCS上的应用程序实例的JSON定义，从而了解如何使用应用程序缓存的服务绑定来编辑deployment.json文件。首先<strong class="ig hi">设置psm </strong>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mt"><img src="../Images/3d848dc2f631911e31f7ead438fcbc86.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/0*00D0Nnk8S1tz4UpA."/></div></figure><p id="e8ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并检查问候语应用程序:</p><blockquote class="mu mv mw"><p id="2729" class="ie if ke ig b ih ii ij ik il im in io mx iq ir is my iu iv iw mz iy iz ja jb ha bi translated">psm accs app -n问候语-o详细-的json</p></blockquote><p id="1d42" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要了解服务绑定的JSON定义:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es na"><img src="../Images/b085af9a4d32b99e28927c3f80fc5b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/0*RluZNwmEnOCnLZbr."/></div></figure><p id="1bd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我知道了如何在开发人员云服务的部署配置中更新部署描述符:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/103b04b5fdc56ce5f881e02095546903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZhCwqjplfHUTCpFE."/></div></div></figure><p id="a2d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下次执行此部署时，将配置绑定到应用程序缓存的服务。</p><p id="fdeb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:必须提供访问应用程序缓存的凭证，是的，虽然听起来很可怕，但密码是明文的！</p><p id="3ff2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">似乎不需要凭据。password的值现在是BogusPassword——这不是我的密码的真实值——并且仍然可以访问缓存。假设应用程序在正确的网络域内运行的事实使其有资格访问缓存。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/71f221b2f011bb6af2c3573a7d4194b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BLtUPmJ0eCLVzeBE."/></div></div></figure><p id="a46d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">服务绑定使应用程序可以使用以下环境变量——由ACCS平台在运行时填充:</p><h1 id="6c9a" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">在问候微服务中利用应用缓存</h1><p id="a2c2" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">这里演示了利用服务绑定的环境变量的最简单方法(注意，这还没有实际使用缓存):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/ba69be3023018f39edfbe5b792add281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q45z3kpJEjqKu2TA."/></div></div></figure><p id="4619" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以及对请求的影响:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/0cfb7714fa26848d5a6f72f7b61d8e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rZzZ-7ICBkrlFcFu."/></div></div></figure><p id="78c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，通过REST调用与缓存进行实际交互，如下所述:<a class="ae jc" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/cloud/apaas/node/node-accs-caching-basic/node-accs-caching-basic.html" rel="noopener ugc nofollow" target="_blank">http://www . Oracle . com/web folder/tech network/tutorials/OBE/cloud/apaas/node/node-accs-caching-basic/node-accs-caching-basic . html</a>，我们将使用一个节点模块node-rest-client。使用以下命令将该模块添加到应用程序</p><p id="33ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">npm安装节点-rest-客户端-保存</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nb"><img src="../Images/8e763c222d2e29ca264d8b27d710ef7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/0*wTwN-oAyxvMB46xI."/></div></figure><p id="d452" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:这条指令将更新package.json并下载模块代码。只有更改后的package.json被提交给git存储库。当应用程序下一次构建在开发人员云服务中时，它将在将节点应用程序压缩到单个归档文件之前执行<em class="ke"> npm安装</em>。<em class="ke"> npm install </em>的动作确保node-rest-client的源代码被下载，并将被添加到部署到ACCS的greeting.zip文件中。</p><p id="f895" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用这个模块，app.js文件被扩展为从应用程序缓存中读取和向应用程序缓存中写入。看到这里改变了代码<a class="ae jc" href="https://github.com/lucasjellema/greeting/blob/master/app.js" rel="noopener ugc nofollow" target="_blank">https://github.com/lucasjellema/greeting/blob/master/app.js</a>:</p><h1 id="5108" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">重新部署问候微服务，并演示请求计数器是共享和保留的</h1><p id="a423" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">当我们多次调用问候语服务时，我们看到一系列不断增加的计数值:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nc"><img src="../Images/5c69c4ea4e8c103b801ec553395aa9f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/0*kWzv49rNB1iJx3cq."/></div></figure><p id="f56c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">即使应用程序重新启动或重新部署，请求计数也会保留，当应用程序再次可用时，我们只需继续计数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/0a33928550b653ce06f595aaa7af6640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lcu73ZaPqIiZ-Fye."/></div></div></figure><p id="1620" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">来自两个ACCS应用程序实例的日志提供了对所发生情况的洞察——负载平衡如何使这些实例间歇地处理请求——以及它们如何从缓存中读取彼此的结果。</p><h1 id="433c" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated"><strong class="ak">资源</strong></h1><p id="8ba3" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">本文来源于GitHub:<a class="ae jc" href="https://github.com/lucasjellema/greeting" rel="noopener ugc nofollow" target="_blank">https://github.com/lucasjellema/greeting</a>。</p><p id="f969" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Mike Lehmann的博客文章，宣布了ACCS的缓存特性:<a class="ae jc" href="https://blogs.oracle.com/developers/caching-with-oracle-application-container-cloud" rel="noopener ugc nofollow" target="_blank">https://blogs . Oracle . com/developers/caching-with-Oracle-application-container-cloud</a></p><p id="bd02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于ACCS缓存的文档:<a class="ae jc" href="https://docs.oracle.com/en/cloud/paas/app-container-cloud/cache/getting-started-caches.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/en/cloud/PAAs/app-container-cloud/cache/getting-started-Caches . html</a></p><p id="cbed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于缓存支持ACCS上各种基于技术的应用的教程:<a class="ae jc" href="https://docs.oracle.com/en/cloud/paas/app-container-cloud/create-sample-caching-applications.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/en/cloud/PAAs/app-container-cloud/create-sample-caching-applications . html</a></p><p id="b184" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用Oracle应用容器云服务中的缓存REST API创建Node.js应用的教程<a class="ae jc" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/cloud/apaas/node/node-accs-caching-basic/node-accs-caching-basic.html" rel="noopener ugc nofollow" target="_blank">http://www . Oracle . com/web folder/tech network/tutorials/OBE/Cloud/apaas/node/node-accs-Caching-basic/node-accs-Caching-basic . html # section 4</a></p><p id="1b78" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">缓存服务的公共API文档—<a class="ae jc" href="https://apicatalog.oraclecloud.com/ui/views/apicollection/oracle-public/cache-app/v1" rel="noopener ugc nofollow" target="_blank">https://API catalog . Oracle cloud . com/ui/views/API collection/Oracle-public/Cache-app/v1</a></p><p id="27d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用psm检索ACCS应用程序的部署详细信息:<a class="ae jc" href="https://docs.oracle.com/en/cloud/paas/java-cloud/pscli/accs-app.html" rel="noopener ugc nofollow" target="_blank">https://docs . Oracle . com/en/cloud/PAAs/Java-cloud/PS CLI/accs-app . html</a>(了解如何定义应用程序缓存引用)</p><p id="966c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ke">原载于2017年8月12日</em><a class="ae jc" href="https://technology.amis.nl/2017/08/12/adding-a-cross-instance-cross-restarts-and-cross-application-cache-to-node-applications-on-oracle-application-container-cloud/" rel="noopener ugc nofollow" target="_blank"><em class="ke">technology . amis . nl</em></a><em class="ke">。</em></p></div></div>    
</body>
</html>