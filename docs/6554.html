<html>
<head>
<title>Kotlin/Native iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林/原生iOS</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/kotlin-native-ios-a1a73d7390fe?source=collection_archive---------1-----------------------#2018-12-28">https://medium.com/quick-code/kotlin-native-ios-a1a73d7390fe?source=collection_archive---------1-----------------------#2018-12-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="108b" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">3.协程和K/N的不变性</h2></div><h1 id="7ab5" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">协同程序</h1><p id="be63" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">什么是协程？这个<a class="ae kk" href="https://kotlinlang.org/docs/reference/coroutines/coroutines-guide.html" rel="noopener ugc nofollow" target="_blank">官方指南</a>对于理解什么是协程以及如何使用协程非常有帮助。</p><p id="8705" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">本章的主题是在K/N中使用协程及其当前状态。</p><h1 id="016f" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">更新梯度</h1><p id="5e3d" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">要使用K/N中的协同程序，请更新<code class="du kq kr ks kt b">sharedNative/build.gradle</code>中的依赖关系。</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="277a" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated"><code class="du kq kr ks kt b">kolinx-coroutines-core-common</code>和<code class="du kq kr ks kt b">kotlinx-coroutines-core-native</code>是新的。一更，在<code class="du kq kr ks kt b">settings.gradle</code> <a class="ae kk" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/native/README.md" rel="noopener ugc nofollow" target="_blank">加一行</a> <code class="du kq kr ks kt b">enableFeaturePreview('GRADLE_METADATA')</code>。</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="3272" class="lf ix hh kt b fi lg lh l li lj">include ':app'<br/>include ':sharedNative'<br/><br/>enableFeaturePreview('GRADLE_METADATA')</span></pre><p id="426c" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">然后，<code class="du kq kr ks kt b">Sync Now</code>。</p><h1 id="aa97" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">使用iOS中的协程</h1><p id="1f00" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">现在，您可以在公共模块中使用协程API。在<code class="du kq kr ks kt b">actual.kt</code>中，定义这个<code class="du kq kr ks kt b">CoroutineDispatcher</code>。</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="abe1" class="lf ix hh kt b fi lg lh l li lj">private class MainDispatcher: CoroutineDispatcher() {<br/>    override fun dispatch(context: CoroutineContext, block: Runnable) {<br/>        <em class="lk">dispatch_async</em>(<em class="lk">dispatch_get_main_queue</em>()) <strong class="kt hi">{ </strong>block.run() <strong class="kt hi">}<br/>    </strong>}<br/>}</span></pre><p id="c441" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">协程调度程序确定相应的协程使用什么线程来执行。</p><p id="86d4" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">接下来，定义<code class="du kq kr ks kt b">CoroutineScope</code>。我们需要一个运行在iOS事件循环上的作用域。</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="1190" class="lf ix hh kt b fi lg lh l li lj">internal class MainScope: CoroutineScope {<br/>    private val dispatcher = MainDispatcher()<br/>    private val job = <em class="lk">Job</em>()<br/><br/>    override val coroutineContext: CoroutineContext<br/>        get() = dispatcher + job<br/>}</span></pre><p id="d056" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">作用域用于生成协程。我不想让它在iOS中可见，所以用<code class="du kq kr ks kt b">internal</code>定义了<code class="du kq kr ks kt b">MainScope</code>类。但是访问级别取决于您。</p><blockquote class="ll lm ln"><p id="d446" class="jo jp lk jq b jr kl ii jt ju km il jw lo kn jz ka lp ko kd ke lq kp kh ki kj ha bi translated">协程作用域是新协程的作用域。这意味着每个协程构建器都继承了作用域的<code class="du kq kr ks kt b">coroutineContext</code>。由于这个原因，上下文元素和<strong class="jq hi">取消</strong>都被自动传播。例如，作用域的取消调用作用域内启动的协程的取消。</p></blockquote><p id="2324" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">让我们试着调用协程。在<code class="du kq kr ks kt b">actual.kt</code>中定义<code class="du kq kr ks kt b">showHelloCoroutine</code>功能，在<code class="du kq kr ks kt b">common.kt</code>中定义<code class="du kq kr ks kt b">helloCoroutine</code>暂停功能。<code class="du kq kr ks kt b">launch</code>函数是<code class="du kq kr ks kt b">CoroutineScope</code>类的扩展函数。这是一个协同程序生成器。</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="cb0e" class="lf ix hh kt b fi lg lh l li lj">fun showHelloCoroutine() {<br/>    MainScope().launch {<br/>        helloCoroutine()<br/>    }<br/>}</span><span id="b91f" class="lf ix hh kt b fi lr lh l li lj">---above: actual.kt--------below: common.kt------</span><span id="efc0" class="lf ix hh kt b fi lr lh l li lj">internal suspend fun helloCoroutine() {<br/>    println("Hello Coroutines!")<br/>}</span></pre><p id="ed53" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">我们可以这样称呼它。</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="09ae" class="lf ix hh kt b fi lg lh l li lj">ActualKt.showHelloCoroutine()</span><span id="68e4" class="lf ix hh kt b fi lr lh l li lj">// Hello Coroutines!</span></pre><p id="7d7a" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">这里我分成两个函数。一个类似于协程包装函数，另一个是挂起函数。</p><p id="b7a3" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">在大多数情况下，挂起函数有业务逻辑，我们希望共享它们。所以在这里，我在<code class="du kq kr ks kt b">common.kt</code>中定义了<code class="du kq kr ks kt b">helloCoroutine</code>暂停功能，以便在Android中使用。</p><p id="4038" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">另一方面，挂起函数还不能直接从iOS中使用，所以我为挂起函数准备了smth，就像一个包装函数。</p><blockquote class="ll lm ln"><p id="c817" class="jo jp lk jq b jr kl ii jt ju km il jw lo kn jz ka lp ko kd ke lq kp kh ki kj ha bi translated">暂停功能此时不会导出到框架中。但是关于这个有一个<a class="ae kk" href="https://github.com/JetBrains/kotlin-native/issues/2438" rel="noopener ugc nofollow" target="_blank">问题</a>。</p></blockquote><h1 id="bbfa" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">Ktor客户端的HTTP请求。</h1><p id="f1a2" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">上面的例子有点无聊，只是在控制台上打印。我们将在这里用<a class="ae kk" href="https://github.com/ktorio/ktor" rel="noopener ugc nofollow" target="_blank"> Ktor </a>实现HTTP请求。</p><h2 id="2ee2" class="lf ix hh bd iy ls lt lu jc lv lw lx jg jx ly lz ji kb ma mb jk kf mc md jm me bi translated">更新梯度</h2><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="b0ab" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">(2019年1月16日更新)</p><h2 id="1f5c" class="lf ix hh bd iy ls lt lu jc lv lw lx jg jx ly lz ji kb ma mb jk kf mc md jm me bi translated">简单的请求</h2><p id="09aa" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">在<code class="du kq kr ks kt b">common.kt</code>中创建一个API类</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="9245" class="lf ix hh kt b fi lg lh l li lj">class Api {<br/>    private val client = HttpClient()<br/><br/>    internal suspend fun request(urlString: String): String {<br/>        val result: String = client.<em class="lk">call</em>(urlString) <strong class="kt hi">{<br/>            </strong>method = HttpMethod.Get<br/>        <strong class="kt hi">}</strong>.response.<em class="lk">readText</em>()<br/>        return result<br/>    }<br/>}</span></pre><p id="a433" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">HttpClient类包含在Ktor库中。请求挂起函数用<code class="du kq kr ks kt b">Get</code> http方法调用<code class="du kq kr ks kt b">client.call</code>。</p><p id="8036" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">接下来，为这个suspend函数定义一个包装函数，作为<code class="du kq kr ks kt b">actual.kt</code>中Api类的扩展函数。</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="721a" class="lf ix hh kt b fi lg lh l li lj">fun Api.request(completion: (String) -&gt; Unit) {<br/>    MainScope().<em class="lk">launch </em><strong class="kt hi">{<br/>        </strong>val result = request("https://tools.ietf.org/rfc/rfc8216.txt")<br/>        completion(result)<br/>    <strong class="kt hi">}<br/></strong>}</span></pre><p id="9a1a" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">这将https://tools.ietf.org/rfc/rfc8216.txt作为一个参数传递。RFC8216注册了什么？你很快就会看到。</p><p id="9807" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">让我们尝试在ViewController.swift中调用它</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="0079" class="lf ix hh kt b fi lg lh l li lj">Api().request {<br/>    print($0)<br/>    return .init()<br/>}</span></pre><p id="2d48" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">Kotlin lambda返回单元是作为闭包导出的，返回<code class="du kq kr ks kt b">KotlinUnit</code>，不是Void。因此需要最后一次返回。</p><p id="e348" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">无论如何，这将异步执行并打印HTTP实时流文档。我们可以使用来自iOS的http请求🎉</p><blockquote class="ll lm ln"><p id="0d25" class="jo jp lk jq b jr kl ii jt ju km il jw lo kn jz ka lp ko kd ke lq kp kh ki kj ha bi translated">目前，协程仅支持<strong class="jq hi">主线程</strong>。但是，支持<strong class="jq hi">的多线程</strong>协程是<a class="ae kk" href="https://github.com/Kotlin/kotlinx.coroutines/issues/462" rel="noopener ugc nofollow" target="_blank">发布的</a>。</p></blockquote><h1 id="d781" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">K/N不变性</h1><h2 id="570f" class="lf ix hh bd iy ls lt lu jc lv lw lx jg jx ly lz ji kb ma mb jk kf mc md jm me bi translated">冰冻的</h2><p id="72cf" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">在K/N中，<em class="lk">不变性</em>是一个运行时属性。这可以通过使用<code class="du kq kr ks kt b">kotlin.native.concurrent</code>中的<code class="du kq kr ks kt b">freeze()</code>功能来实现。我们可以使用<code class="du kq kr ks kt b">isFrozen</code>检查冻结状态。</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="2326" class="lf ix hh kt b fi lg lh l li lj">package kotlin.native.concurrent<br/><br/>public val kotlin.Any?.<em class="lk">isFrozen</em>: kotlin.Boolean /* compiled code */</span></pre><p id="5d72" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">这是<code class="du kq kr ks kt b">kotlin.native.concurrent</code>套装的一部分。<code class="du kq kr ks kt b">isFrozen</code>属性在这里定义。<code class="du kq kr ks kt b">Any?</code>类型显然具有<code class="du kq kr ks kt b">isFrozen</code>属性。</p><p id="b642" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">K/N保证了重要的不变量，<code class="du kq kr ks kt b"><strong class="jq hi">mutable XOR global</strong></code>。这意味着对象要么是不可变的，要么可以从单线程访问。</p><p id="409e" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">有些对象在默认情况下是冻结的，例如</p><ul class=""><li id="d27b" class="mf mg hh jq b jr kl ju km jx mh kb mi kf mj kj mk ml mm mn bi translated">科特林等原始类型。弦乐，kotlin.Int</li><li id="6f4c" class="mf mg hh jq b jr mo ju mp jx mq kb mr kf ms kj mk ml mm mn bi translated"><code class="du kq kr ks kt b">object</code>单胎</li><li id="b5dd" class="mf mg hh jq b jr mo ju mp jx mq kb mr kf ms kj mk ml mm mn bi translated">枚举类</li></ul><p id="24d9" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">这些状态很容易检查，如下所示。在<code class="du kq kr ks kt b">actual.kt</code>中，</p><figure class="ku kv kw kx fd ky"><div class="bz dy l di"><div class="kz la l"/></div></figure><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="e07c" class="lf ix hh kt b fi lg lh l li lj"><strong class="kt hi">primitive int              isFrozen: true<br/>primitive string           isFrozen: true<br/>class object               isFrozen: false<br/>class object with freeze() isFrozen: true<br/>object singleton           isFrozen: true<br/>enum class                 isFrozen: true</strong></span></pre><p id="61d9" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">如果一个突变操作被应用到一个冻结的物体上，<code class="du kq kr ks kt b">InvalidMutabilityException</code>被抛出。</p><h2 id="033f" class="lf ix hh bd iy ls lt lu jc lv lw lx jg jx ly lz ji kb ma mb jk kf mc md jm me bi translated"><strong class="ak">不正确的引用异常</strong></h2><p id="ae1d" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">默认情况下，类对象不被冻结。并且K/N保证<code class="du kq kr ks kt b">mutable XOR global</code>。</p><p id="fb00" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">如果我们访问一个没有冻结的对象会发生什么？试试这个，在<code class="du kq kr ks kt b">actual.kt</code>中定义下面的函数。</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="cdbb" class="lf ix hh kt b fi lg lh l li lj">fun passNotFrozenObject(completion: (Hello) -&gt; Unit) {<br/>    val hello = Hello()<br/>    completion(hello)<br/>}</span></pre><p id="bee0" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">在<code class="du kq kr ks kt b">ViewController.swift</code>中。</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="2be3" class="lf ix hh kt b fi lg lh l li lj">ActualKt.passNotFrozenObject { hello in<br/>    DispatchQueue.global(qos: .background).async {<br/>        print(hello)<br/>    }<br/>    return .init()<br/>}</span></pre><p id="0b13" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">这段代码崩溃了</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="ddeb" class="lf ix hh kt b fi lg lh l li lj"><strong class="kt hi">Uncaught Kotlin exception: kotlin.native.IncorrectDereferenceException: illegal attempt to access non-shared org.kotlin.mpp.mobile.Hello@19f3d08 from other thread</strong></span></pre><p id="7d7e" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">从另一个线程访问对象时抛出。</p><p id="d43a" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">通过freeze()修复此崩溃，例如</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="c7cb" class="lf ix hh kt b fi lg lh l li lj">fun passNotFrozenObject(completion: (Hello) -&gt; Unit) {<br/>    val hello = Hello().freeze()<br/>    completion(hello)<br/>}</span></pre><p id="ad17" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">这将起作用，控制台上将显示以下内容</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="1b9d" class="lf ix hh kt b fi lg lh l li lj"><strong class="kt hi">org.kotlin.mpp.mobile.Hello@1e470c8</strong></span></pre><p id="6cfc" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">这些参考资料可能有助于我们理解</p><ul class=""><li id="0f45" class="mf mg hh jq b jr kl ju km jx mh kb mi kf mj kj mk ml mm mn bi translated"><a class="ae kk" href="https://github.com/JetBrains/kotlin-native/blob/cfe2d2b7ce4aef41b45747d7c4d2d6238fd1808d/runtime/src/main/cpp/Memory.cpp#L467" rel="noopener ugc nofollow" target="_blank">https://github . com/JetBrains/kot Lin-native/blob/cfe 2d 7 ce 4 AEF 41 b 45747d 7 C4 d2d 6238 FD 1808d/runtime/src/main/CPP/memory . CPP # L467</a></li><li id="f588" class="mf mg hh jq b jr mo ju mp jx mq kb mr kf ms kj mk ml mm mn bi translated"><a class="ae kk" href="https://github.com/JetBrains/kotlin-native/blob/328413337b9dcab1dba6dd4d3cf5975d617e60d1/runtime/src/main/cpp/Memory.h#L30" rel="noopener ugc nofollow" target="_blank">https://github . com/JetBrains/kot Lin-native/blob/328413337 b 9 dcab 1 DBA 6 DD 4d 3 cf 5975d 617 e 60d 1/runtime/src/main/CPP/memory . h # L30</a></li></ul><h2 id="a534" class="lf ix hh bd iy ls lt lu jc lv lw lx jg jx ly lz ji kb ma mb jk kf mc md jm me bi translated">@ThreadLocal和@ SharedImmutable</h2><p id="2ef7" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">当您使用非原始类型的顶级全局变量时，ThreadLocal或SharedImmutable注释有时可能会有所帮助。</p><p id="fffb" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">试举一个简单的例子。在<code class="du kq kr ks kt b">actual.kt</code>中定义这个顶层变量。</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="1a87" class="lf ix hh kt b fi lg lh l li lj">val hello = Hello()</span></pre><p id="eefe" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">并从ViewController.swift中的不同线程访问它。</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="edc5" class="lf ix hh kt b fi lg lh l li lj">print(Thread.current)<br/>print(ActualKt.hello)<br/>DispatchQueue.global(qos: .background).async {<br/>    print(Thread.current)<br/>    print(ActualKt.hello)<br/>}</span><span id="a26f" class="lf ix hh kt b fi lr lh l li lj">// output on console<br/><strong class="kt hi">&lt;NSThread: 0x600002e9e8c0&gt;{number = 1, name = main}<br/>org.kotlin.mpp.mobile.Hello@3ba2e28<br/>&lt;NSThread: 0x600002e16640&gt;{number = 3, name = (null)}<br/>Uncaught Kotlin exception: kotlin.native.IncorrectDereferenceException:</strong></span></pre><p id="4d6b" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">一个类对象没有被冻结，所以会抛出异常。用这个怎么样？</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="f7bc" class="lf ix hh kt b fi lg lh l li lj">val hello = Hello().freeze()</span></pre><p id="51e2" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">即使这个<code class="du kq kr ks kt b">hello</code>对象被冻结也没有变化！！</p><p id="0ede" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">事实上，对于顶级变量，需要使用<code class="du kq kr ks kt b">@SharedImmutable</code>或<code class="du kq kr ks kt b">@ThreadLocal</code>注释。</p><ul class=""><li id="f16e" class="mf mg hh jq b jr kl ju km jx mh kb mi kf mj kj mk ml mm mn bi translated">SharedImmutable:使对象冻结(不可变)并可从另一个线程访问</li><li id="a8a7" class="mf mg hh jq b jr mo ju mp jx mq kb mr kf ms kj mk ml mm mn bi translated">ThreadLocal:使对象状态成为线程本地的和可变的(改变后的状态不会反映到其他线程)。</li></ul><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="c022" class="lf ix hh kt b fi lg lh l li lj">@SharedImmutable<br/>val hello = Hello()</span></pre><p id="4f58" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">然后，控制台上成功显示以下行。</p><pre class="ku kv kw kx fd lb kt lc ld aw le bi"><span id="6189" class="lf ix hh kt b fi lg lh l li lj"><strong class="kt hi">&lt;NSThread: 0x600002c468c0&gt;{number = 1, name = main}<br/>org.kotlin.mpp.mobile.Hello@39032e8<br/>&lt;NSThread: 0x600002c92080&gt;{number = 3, name = (null)}<br/>org.kotlin.mpp.mobile.Hello@39032e8</strong></span></pre><blockquote class="ll lm ln"><p id="a209" class="jo jp lk jq b jr kl ii jt ju km il jw lo kn jz ka lp ko kd ke lq kp kh ki kj ha bi translated">这些注释可能会在未来版本中消失。</p></blockquote><h1 id="7006" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">摘要</h1><p id="e610" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">我介绍了协程和K/N的不变性。</p><p id="dc37" class="pw-post-body-paragraph jo jp hh jq b jr kl ii jt ju km il jw jx kn jz ka kb ko kd ke kf kp kh ki kj ha bi translated">我想在下一章展示一个使用反应式编程和架构框架的例子。(<em class="lk">即将推出</em>)</p><h1 id="ed8e" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">参考</h1><ul class=""><li id="b175" class="mf mg hh jq b jr js ju jv jx mt kb mu kf mv kj mk ml mm mn bi translated"><a class="ae kk" href="https://kotlinlang.org/docs/reference/coroutines/coroutine-context-and-dispatchers.html" rel="noopener ugc nofollow" target="_blank">https://kot linlang . org/docs/reference/coroutines/coroutine-context-and-dispatchers . html</a></li><li id="2000" class="mf mg hh jq b jr mo ju mp jx mq kb mr kf ms kj mk ml mm mn bi translated">https://ktor.io/quickstart/quickstart/gradle.html<a class="ae kk" href="https://ktor.io/quickstart/quickstart/gradle.html" rel="noopener ugc nofollow" target="_blank"/></li><li id="4ccc" class="mf mg hh jq b jr mo ju mp jx mq kb mr kf ms kj mk ml mm mn bi translated"><a class="ae kk" href="https://kotlinlang.org/docs/reference/native/immutability.html" rel="noopener ugc nofollow" target="_blank">https://kot linlang . org/docs/reference/native/immut ability . html</a></li></ul></div></div>    
</body>
</html>