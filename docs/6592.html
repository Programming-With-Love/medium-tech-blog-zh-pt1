<html>
<head>
<title>How to Skin a Cat: FizzBuzz in Five Languages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何剥一只猫的皮:FizzBuzz五种语言</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/how-to-skin-a-cat-fizzbuzz-5-ways-dc4ec811bfcb?source=collection_archive---------4-----------------------#2019-02-22">https://medium.com/quick-code/how-to-skin-a-cat-fizzbuzz-5-ways-dc4ec811bfcb?source=collection_archive---------4-----------------------#2019-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7c24513e526ccfaad39f9d1f7cd75e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHQ-D0vPP4eiGuItt5yEHg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">SKINAWHUTNOW?</figcaption></figure><p id="5fb7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> —更新</strong> : <em class="jr">由于评论中一些有用的建议，我已经修改了我发表的这篇文章的原始版本，所以如果你第二次看到这篇文章，如果它读起来略有不同，不要感到惊讶。这也是我把名字从“FizzBuzz 5种方式”改成“FizzBuzz五种语言”的原因，因为这里的代码示例比我之前的要多得多。还有，更多猫的笑话和引用，就这样了。</em></p><p id="653b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">FizzBuzz是我们许多人面临的第一年计算问题。规则非常简单:给定一个整数，如果该整数是3的倍数，则返回“Fizz”，如果该整数是5的倍数，则返回“Buzz”，如果是3和5的倍数，则返回“FizzBuzz”，如果不是两者的倍数，则返回一个空字符串。大多数人在这种情况下的做法是拿出一个简单的<code class="du js jt ju jv b">if/else</code>条件，但老实说，这是小孩子的东西。为了增加难度，今天，我们将尝试使用尽可能少的条件语句来完成这个看似简单的任务。让事情变得更加困难的是，我们将用五种非常不同的语言来做这件事(这就是这篇文章的名字的由来…“剥一只猫的皮的方法不止一种…明白了吗？)</p><blockquote class="jw jx jy"><p id="f451" class="it iu jr iv b iw ix iy iz ja jb jc jd jz jf jg jh ka jj jk jl kb jn jo jp jq ha bi translated">埃迪，你是个疯子，那是胡说八道！<br/> ~你。</p></blockquote><p id="8cc1" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们走着瞧。</p><h1 id="516d" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> Javascript </strong></h1><p id="4d1b" class="pw-post-body-paragraph it iu hh iv b iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm le jo jp jq ha bi translated">我们将开始使用的第一种语言是大多数初学者都熟悉的语言:Javascript。如今，Javascript在软件开发领域无处不在，以至于如果有人说“我是一名程序员”，他们很可能写的是JS而不是其他语言。过去被“真正的程序员”嘲笑为“脚本语言”的流行程度的激增可以归因于node.js及其npm库生态系统的出现。如今，你很难找到一种不能用Javascript编写的程序。虽然在过去，JS仅限于制作低劣的动画和网页上的简单交互，但现在可以用来编写整个UI框架、网络服务器、实时聊天应用程序，甚至自动化和/或机器人控制器，如用<a class="ae lf" href="https://www.raspberrypi.org/" rel="noopener ugc nofollow" target="_blank"> Raspberry pi </a>创建的那些。</p><p id="aac7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在你说任何事情之前，我会故意省略类型检查和错误处理，以防你们中的任何人在学校里认为这篇文章是作弊的好方法。</p><p id="dfea" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">用JS实现FizzBuzz的最基本代码是这样的:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Simple, right?</figcaption></figure><p id="0daf" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">先来几个解释:<br/> 1。如果你刚刚开始，你可能想知道那个<code class="du js jt ju jv b">%</code>操作符在做什么……那实际上并不意味着“百分比”。<code class="du js jt ju jv b">%</code>是模数运算符，模数是我们将在本文中大量使用的函数。模数是一个函数，用于计算一个数除以另一个数的余数。在这种情况下，我们希望检查数字是否能被3、5或两者整除，因此我们检查数字mod 3或5是否等于零。</p><p id="8ffb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">2.不，你没有看到三，那些三等于号是我们在JS中检查等价性的方法。大多数语言使用双等号检查等价性，使用单等号进行变量赋值(例如:<code class="du js jt ju jv b">let x = "foo"</code>)。在JS中，double-equals也被使用，但不像<code class="du js jt ju jv b">==</code>操作符那样允许类型转换；换句话说，一个字符串值<code class="du js jt ju jv b">'1'</code>将被评估为等同于一个数字值<code class="du js jt ju jv b">1</code>。如果您要将标签的innerHTML与脚本中的数字进行比较，这是很有用的，但通常是不明智的。<code class="du js jt ju jv b">===</code>操作符是一个严格的等价比较，意味着<code class="du js jt ju jv b">'1' === 1</code>的计算结果是<code class="du js jt ju jv b">false</code>。</p><p id="22c5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">3.第三个条件分支中的双&amp;符号(<code class="du js jt ju jv b">&amp;&amp;</code>)是一个逻辑符号<code class="du js jt ju jv b">AND</code>，但是在本文的剩余部分我们不会再使用它，所以这将是我最后一次提到它。</p><p id="15b3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这段代码会运行得相当好，并做它应该做的事情。但是，也可以这样写:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Fun fact… the guy who introduced me to Immediately Invoked Function Expressions (IIFEs) refers to the parens at the end as ‘donkey balls’. Note how the whole thing is wrapped in parens, then is followed by two empty parens… this makes the JS interpreter view the whole thing as a function that’s immediately executed when loaded, as the name implies.</figcaption></figure><p id="da9c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这个代码片段中，代码看起来更加简洁。不幸的是，因为我们需要实例化Object两次，所以它的运行速度比第一个例子慢82%。如果它很慢，你可能会问，我为什么要给你看呢？好吧，性能不是这次演示的重点，但既然你问了，考虑一下来自<a class="ae lf" href="https://jsperf.com/switch-case-vs-if-else/13" rel="noopener ugc nofollow" target="_blank">的这个测试</a>的结果，在这个测试中，我比较了使用对象映射与if/else、case/switch的结果(我使用的是Chrome——在Chrome、Edge和Opera之间，它们都使用‘Blink’渲染引擎，你在浏览器市场中占有压倒性的份额——处理对象映射比条件慢的浏览器(Firefox、Safari和IE)加起来只占市场的四分之一多一点，相比之下)。在您需要比较静态结果的情况下，表格发生了变化，对象映射现在比if/else快80%,甚至比switch/case还要快。为什么要翻转？在这种情况下，if/else是每次运行操作时都需要运行比较的对象，而该对象被用作二叉查找树…它只取和并在其结构中查找键。这就是为什么有时利用这种类型的结构比迭代加载条件要快得多。</p><p id="630f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> —编辑:</strong> <em class="jr">当我写这篇文章的时候，我知道一定有更好的方法，评论者Paul B .好心地指出有一个更简单、更优雅的解决方案——字符串插值:</em></p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Yes, it’s different than Paul B.’s example in the comments. This is because, while he was quick to point out that most versions of FizzBuzz ask you to return the number instead of Fizz, Buzz or FizzBuzz if the number is neither a multiple of 3 or 5, 1) I’m asking for an empty string, not the number, to set mine apart from most coding tests that use FizzBuzz, and 2) His solution didn’t quite check out, for one reason… He’s using type coercion under the hood to take any number returned from the modulus to be ‘true’ and zero returned by the modulus to eval as ‘false’, which is why his returns are flipped in his example. If you fail to give a param in his version, (or give it a string) the modulus statements will return ‘undefined’… which JS will eval to ‘false’. This means that if you give no param or an incorrect param for the function, it will still give you ‘FizzBuzz’, rather than an empty string, (or, in his case, ‘FizzBuzz, instead of the param itself). That’s me breaking my own rules there, as I said I wasn’t including error checking, again to set it apart from coding tests, but I thought it was worth mentioning. Still, string interpolation was a REALLY good suggestion, as you can see by the js-perf results here: <a class="ae lf" href="https://jsperf.com/fizzbuzz-if-else-vs-object2" rel="noopener ugc nofollow" target="_blank">https://jsperf.com/fizzbuzz-if-else-vs-object2</a></figcaption></figure><p id="1dc1" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这个例子中，我们使用一个字符串文字将模数计算的结果直接插入到字符串中，从而将运算精简到最基本的程度，并完全去掉对象。该功能是作为ES2015的一部分引入的，同时还有我在示例中使用的“胖箭头”功能符号。的确，它仍然依赖于条件，这违背了本文的初衷，但是，这比对象映射方法和if/else都要快，也更简洁。</p><p id="5ca4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">看不出有条件吗？靠近一点看…</p><p id="c2f5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你能发现它吗？是这样的:</p><pre class="lg lh li lj fd lm jv ln lo aw lp bi"><span id="8837" class="lq kd hh jv b fi lr ls l lt lu">num % 3 === 0 ? 'Fizz' : '';</span></pre><p id="3c66" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">那是一个<strong class="iv hi">三元运算符</strong>。大多数现代语言都支持它们。这里发生的事情是，如果问号之前的条件评估为' true ',我们将返回' Fizz ',否则返回一个空字符串。这个问题是<code class="du js jt ju jv b">if</code>的简写，冒号代表<code class="du js jt ju jv b">else</code>。这就是商业界所谓的“语法糖”。</p><h1 id="9429" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> Python </strong></h1><p id="a02a" class="pw-post-body-paragraph it iu hh iv b iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm le jo jp jq ha bi translated">回到键/值对方法，让我们在Python中尝试一下:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Ooh, that’s short and sweet!</figcaption></figure><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es lv"><img src="../Images/e706bb5d0b6d1a1e91f53e63a2c29438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*TmwjhHeBOr1TNde_UbVMFQ.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Python is kinda fun. (Image courtesy of <a class="ae lf" href="https://www.xkcd.com/353/" rel="noopener ugc nofollow" target="_blank">https://www.xkcd.com/353/</a>)</figcaption></figure><p id="0a18" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在Python中，我们看到我们可以再次使用reduce函数，许多部分几乎可以从我们之前看到的JS版本中识别出来，尽管语法已经发生了很大的变化。这里，我们使用lambda列表理解将键简化为一个字符串。此外，在Python中，空格很重要…这就是为什么我使用四个空格来缩进我的代码，而不是两个，就像在我的其余示例中一样——在许多其他语言中，空格是一个好东西，但把它搞砸了，这没什么大不了的。在Python中却不是这样，如果你的格式稍有偏差，就会给你的代码带来大问题。(正如评论者nleamba指出的，在Python中，技术上可以使用两个空格而不是四个，但是他们自己的<a class="ae lf" href="https://www.python.org/dev/peps/pep-0008/#indentation" rel="noopener ugc nofollow" target="_blank"> API文档</a>推荐的间距是四个。)</p><p id="adc2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我的Python例子比JS版本的代码少，但是我不能不使用那个<code class="du js jt ju jv b">if</code>语句，即使它是在一个guard子句中，而不是在一个标准的条件语句中。还要注意在我们的模数检查器中用于确定等价性的双等号——<code class="du js jt ju jv b">===</code>在Python中并不存在，但这是规范，而JS实际上是个例外，正如我们将在其余的例子中看到的……</p><p id="dba5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Paul B的建议让我开始思考…我能不能使用字符串插值从我的代码高尔夫游戏中去掉一些笔画，以用于我的其余示例？从Python 3.6开始，我们可以通过<code class="du js jt ju jv b">f</code>函数做到。然而，Python的三元组被定义为一个保护子句，而不是使用我们在JS中看到的<code class="du js jt ju jv b">x ? y :z</code>格式，这意味着我们依靠if/else语句:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Whoa! One line? NICE</figcaption></figure><p id="d6e5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Python确实给了我们一个简化的三元组，我们可以用它来避免if/else:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Shorter, but kinda hard to tell what’s going on in this version.</figcaption></figure><p id="4570" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">…然而，大多数pythony爱好者并不推荐速记版本，因为它不像大多数人希望的那样“pythony”。简而言之，我们使用元组(一种用于定义变量对的Python数据类型)来定义结果，并将条件放在返回值后面的括号中。这有点像薛定谔的猫……元组是你的回归，以真假并存的状态存在，直到被背后的条件性观察到。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es lw"><img src="../Images/5d967a3405326f79c9ed873becb6c86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*4IcXrTH0iAibEJDccqjmKg.jpeg"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Hooray! Sciency cat joke!</figcaption></figure><p id="694c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">首先定义三元速记元组中的“false”返回，这有点令人困惑，因为大多数人倾向于按照“true或false”而不是“false或true”来思考。此外，简写版本对元组中的两个值运行评估，这意味着无论如何条件都将运行两次。if/else结构的三元组遵循标准的if/else逻辑，不会遇到同样的问题。(更多详情，请参见此处的<a class="ae lf" href="http://book.pythontips.com/en/latest/ternary_operators.html" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="21ec" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">C++</h1><p id="fa79" class="pw-post-body-paragraph it iu hh iv b iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm le jo jp jq ha bi translated">还记得在我们的第一个Python例子中，我们是如何导入reduce语句的吗？这让我想起了C++……事实上，让我们考虑一下c++:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">AAAAAAAAAAIIIIIIIIIIIIGGGGGGGGHHHHHHH!!!!!!</figcaption></figure><p id="8f4d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">胡说八道，太多代码了！</p><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/759a14e5dd6cf8ac56619b744cb57113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*gzcMTYu8No4Q-1av5H4rag.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Wouldn’t it be more thematic to say, ‘HOLY CATS!’?</figcaption></figure><p id="d16c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当然，我不得不添加一个带有操作的入口点(<code class="du js jt ju jv b">int main()</code>)来接受输入和输出结果，(<code class="du js jt ju jv b">cin</code>和<code class="du js jt ju jv b">cout</code>)，因为C++是一种编译语言。JS和Python是解释型语言，可以在运行时调用它们的函数，而无需任何准备，但是因为我需要能够将C++代码作为shell脚本运行，所以要么这样做，要么以从命令行获取number param的方式编写脚本(对不起，我只是不喜欢这样做，如果不这样做的话，已经很长时间了)。您会注意到，尽管语法看起来类似于JS，用括号将参数和方法括起来，但我们需要在C++中做些别的事情，那就是定义类型，不仅为我们使用的每个变量，而且为每个方法的返回值。我们也没有找到定义键/值对列表的最简单的方法，这里称为<code class="du js jt ju jv b">map</code>。在C++中，一个<code class="du js jt ju jv b">vector</code>代替了一个数组，我们需要在定义它的时候设置向量的最大大小。这是因为C++迫使你更加关注你的程序所使用的内存。这也是我们需要在文件顶部包含程序中要使用的每种数据类型的库的原因，因为C++只包含编译所需的最少的库。我们还声明了一个名称空间:<code class="du js jt ju jv b">std</code>。这是因为我们包含的所有库都来自“标准”库，如果我们不声明名称空间，我们最终会在使用这些类型的变量的每个声明前写出<code class="du js jt ju jv b">std.</code>。如果我们愿意，我们可能已经用C++写了同样的程序，使用了和我们第一个JS例子中相同的算法，它看起来会非常相似，但是仍然需要更多的设置和代码。JS和Python都是动态类型的，这意味着它们从赋给变量的数据中推断出变量的类型。另一方面，如果你试图将一个字符串赋给一个已经定义为int的变量，C++会抛出一个错误。最后一点要注意的是，尽管我很努力，我还是无法摆脱至少一个条件语句，即我在JS部分提到的三元运算符。</p><p id="3971" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但是C++能插值吗，兄弟？</p><p id="e9e6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">简答？号码</p><p id="260f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然而，我不打算让这阻止我想出比我最初写的Lovecraftian庞然大物更好的东西，所以我做了一些挖掘。你可以添加一些库到C++中，比如<a class="ae lf" href="https://www.boost.org/" rel="noopener ugc nofollow" target="_blank"> Boost </a>，它包含了字符串格式，但是据我所知，包含Boost的库会降低你的编译速度，我不想这样。我宁愿想出一种使用标准库的方法，最终，我找到了一种方法…</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Still YUGE by comparison with the others, but way better than the original, right?</figcaption></figure><p id="da78" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这个例子中，我包含了<code class="du js jt ju jv b">sstream</code>头，它允许我们使用一个基本的stringstream来构建我们想要返回的字符串。这样做，我们可以减少大约一半的代码行。仍然没有我们的其他语言漂亮，但嘿，它比以前好。</p><p id="4a2b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">好了，现在关于C++已经说得够多了，我需要一个味觉清洁剂。让我们继续讨论Clojure。</p><h1 id="4dce" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Clojure</h1><p id="39ff" class="pw-post-body-paragraph it iu hh iv b iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm le jo jp jq ha bi translated">Clojure是一种函数式语言，是可以在JVM中运行的Common Lisp的一种方言，并且可以利用Java库。我们现在不会涉及任何Java的东西，因为在这个例子中我们真的不需要它。不过，请做好准备，尽管Clojure为我们提供了这个列表中最短的例子，也是看起来最奇怪的例子之一:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">WHOA.</figcaption></figure><p id="5ba5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">是的，除去函数名，整个方法只有两行代码，但是到底发生了什么？<br/>第一件事是整个事情被包装在一组括号中，(Clojure读作‘closure’，毕竟……)，我们的函数声明以一个<code class="du js jt ju jv b">defn</code>语句开始。还要注意，我们将要输入的参数(<code class="du js jt ju jv b">num</code>)是用括号括起来的，而不是括号。您应该注意的另一件事是我们的<code class="du js jt ju jv b">tbl</code> var是用一个<code class="du js jt ju jv b">def</code>语句定义的，没有冒号将键和值分开。那些价值观呢？在Clojure中，我们不是使用<code class="du js jt ju jv b">%</code>操作符，而是使用<code class="du js jt ju jv b">mod</code>函数来获取模数，它出现在两个参数之前……不是写<code class="du js jt ju jv b">num % 3 == 0</code>，而是写<code class="du js jt ju jv b">mod num 3</code>，这将导致0。为什么我们的做法与其他例子不同？嗯，在我们用来过滤值的list comprehension中，你会看到我们正在使用<code class="du js jt ju jv b">comp</code>(比较)函数将值与零进行比较。如果你仔细看，这个函数会让你想起Python例子的最后一行……语法可能不同，但是这一行的结构非常相似。</p><p id="845e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为了与我的其他修订保持一致，这里有一个Clojure中的示例，它只使用一行代码来构建一个字符串:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Neat, huh?</figcaption></figure><p id="af46" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这里，我们利用Clojures的<code class="du js jt ju jv b">str</code>函数来构建一个字符串，以及<code class="du js jt ju jv b">when</code>条件，只有满足条件时才会返回值。</p><h1 id="475f" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">红宝石</h1><p id="a689" class="pw-post-body-paragraph it iu hh iv b iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm le jo jp jq ha bi translated">我最后的例子来自Ruby。Ruby让我微笑，因为它让我们可以做一些真正聪明的事情。看看你是否能发现它。</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">See it yet?</figcaption></figure><p id="4d4c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">嘿，你可能会说，这看起来没什么特别的…它比这个方法的C++版本都长，但在其他方面看起来和JS版本没什么不同…等等，什么？那个类定义在那里做什么？你的<code class="du js jt ju jv b">num</code>情人呢？那叫什么<code class="du js jt ju jv b">self</code>？你做了什么？？？！！！</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es ly"><img src="../Images/cdd8e8b41fca60ce162c34b1a6d8e951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*HCpV0h9_-Xug4IJl0Sk4pw.jpeg"/></div><figcaption class="ip iq et er es ir is bd b be z dx">I iz skurd.</figcaption></figure><p id="3a39" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Ruby虽然也是一种解释型的动态类型语言，如JS和Python，也是面向对象的，如C++，但它给了我们一些在其他语言中无法轻易实现的自由。其中之一是能够重新打开任何类并向其定义中添加方法。在这个例子中，我已经重新打开了Integer类，并直接向它添加了<code class="du js jt ju jv b">fizzbuzziness</code>方法。这允许直接在我们想要得到‘fizzbuzzity’的数字上调用方法，而不是用数字作为参数调用方法(例如:<code class="du js jt ju jv b">5.fizzbuzziness</code>而不是<code class="du js jt ju jv b">fizzbuzziness(5)</code>)。以上帝的名义，你为什么要重新打开一个语言的核心类并给它添加方法呢？那不是很危险吗？算是吧。你真的不应该经常这样做，因为你添加的方法可能会与后来添加到标准Ruby库中的方法发生冲突，这可能会导致你的应用程序出现大量的代码中断。还有一种可能是，您可能会覆盖类中的任何方法，最终得到完全无意义的东西，就像这样:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">If you do, I don’t know you, you never got this from me.</figcaption></figure><p id="25be" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">正是因为这个原因，即使通过用Javascript修改一个类的原型也有可能实现类似的行为，但是他们在API文档中用大而全大写的字母告诉你，永远不要用标准的库类来做这件事。然而……在Ruby中，如果你有一个像我这样的不太可能被添加到标准库中的方法，它也会非常有用，因为它有助于你的应用程序以一种更符合Ruby编程习惯的方式坚持“<a class="ae lf" href="https://www.martinfowler.com/bliki/TellDontAsk.html" rel="noopener ugc nofollow" target="_blank">告诉，不要问</a>”的原则。</p><p id="491f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们也可以用字符串插值和三元运算符来实现，就像这样:</p><figure class="lg lh li lj fd ii"><div class="bz dy l di"><div class="lk ll l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">I love Ruby, so much.</figcaption></figure><p id="087c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">所以，哦，我的天啊，我们到了文章的结尾。不同的编程语言，不同的方法，相同的结果。一个第一年的编码问题，在它生命的一英寸之内用肉嫩化剂敲打，并在显微镜下检查。您可能不像我一样喜欢钻研不同的语言来比较它们是如何工作的，但是我希望您在阅读这篇文章时和我在研究和撰写这篇文章时一样开心。下次见！</p></div></div>    
</body>
</html>