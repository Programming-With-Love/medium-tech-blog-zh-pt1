<html>
<head>
<title>JavaScript Pipelining using Asynchronous Generators to implement Running Aggregates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用异步生成器实现运行聚合的JavaScript管道</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/javascript-pipelining-using-asynchronous-generators-to-implement-running-aggregates-4c848fbdf5e1?source=collection_archive---------1-----------------------#2019-04-30">https://medium.com/oracledevs/javascript-pipelining-using-asynchronous-generators-to-implement-running-aggregates-4c848fbdf5e1?source=collection_archive---------1-----------------------#2019-04-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/4cc11c7e2d3d7d13274c32f12e839748.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/0*4mmh_Gj7lfrdkqBf.png"/></div></figure><p id="4f25" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">截至ES 2018(近期浏览器或Node 10)，JavaScript支持异步生成器。生成器是返回一组值的函数，一次返回一个值。这些值一旦可用，就可以在调用生成器的代码中进行处理。不需要先等待整个结果集被合成。在结果集很大甚至没有结尾的情况下，这非常方便。一个生成器函数的结果可以输入到另一个也可以是生成器函数的函数中。诸如此类。这使得流水线操作成为可能:一系列的功能一起工作(或多或少是并行的),通过一系列的处理步骤得到每个结果。</p><p id="4ec7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">随着最近异步生成器的加入，生成结果集的生成器函数可能是异步的——依赖于收集其值的承诺示例。</p><p id="dfc6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这篇文章中，我想展示这一切的美妙之处。我将分享一个简单的ES 2018/Node应用程序，它使用承诺异步产生值—由超时触发。三个承诺代表三个温度传感器；在这种情况下，只是简单地生成值。然而，这些承诺也可以从外部源读取值或使用传入事件。每一个承诺，当解决时，产生一个传感器读数。该承诺被包装在一个承诺中，该承诺将“传感器值”写入临时存储(<em class="jj"> latestValue </em>)并将其自身从传感器池中移除——承诺集函数sensorValues()正在等待使用Promise.race([…sensorPool])</p><figure class="jl jm jn jo fd ii er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jk"><img src="../Images/4b0a5c5cea52348707a172e0a8307024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ohNti0m5vXyfXMNI.png"/></div></div></figure><p id="bd13" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在异步生成器函数sensorValues()中，我们在无限循环中等待一个或多个sensorPromises进行解析(Promise.race解析为要解析的承诺集的第一个)。当这种情况发生时，产生<em class="jj">最新值</em>——当传感器承诺解决时写入。</p><p id="584d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">另一个异步发电机功能——runningSensorAverages——由来自<em class="jj">传感器值</em>的产量触发(在await(传感器读数的传感器读数)的循环<em class="jj">中)。生成的值添加到传感器图中当前传感器的值集合中。<em class="jj">刻度</em>的值增加；<em class="jj"> ticks </em>统计自上次运行聚合计算以来收到的值的数量。如果<em class="jj">滴答</em>的值等于<em class="jj">周期</em>的值(该参数指定在多少个值之后应该计算新的集合)，则使用当前传感器的值集合中的最后<em class="jj">窗口大小</em>值计算新的集合。产生计算的值(并重置刻度)。</em></p><p id="80e3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">函数doIt()接收生成的运行聚合。该函数将生成的值写入控制台——从另一个<em class="jj"> for await </em>循环。</p><p id="9f6c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">结果看起来像这样:</p><figure class="jl jm jn jo fd ii er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jt"><img src="../Images/d573030bea92acd5731c5b9d62ad69d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Sq3nzTHgtYBrQ0_I.png"/></div></div></figure><figure class="jl jm jn jo fd ii"><div class="bz dy l di"><div class="ju jv l"/></div></figure><p id="d8f4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">该应用程序的流水线特性可以通过下面一行得到最好的体现:</p><pre class="jl jm jn jo fd jw jx jy jz aw ka bi"><span id="eea4" class="kb kc hh jx b fi kd ke l kf kg">for await (runningAverage of runningSensorAverages(filterOutliersFromSensorReadings( sensorValues()), 15, 10)) {..}</span></pre><p id="7c20" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">来自sensorValues()的流结果通过管道(一次一个读数)传递给过滤函数，该函数的输出传递给runningSensorAverages，后者的输出作为for await循环中的后续值出现。</p><h1 id="c425" class="kh kc hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">添加时间窗口聚合</h1><p id="18db" class="pw-post-body-paragraph il im hh in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">现在，让我们添加时间窗口聚合:每X秒产生的平均值。</p><p id="66f7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">实现是使用缓存完成的，缓存是由runningSensorAverages()写入的传感器读数的临时存储。函数timeWindowedAggregates()由参数<em class="jj"> timeWindow </em>指定的一段时间后的超时触发。当函数“醒来”时，它从缓存中读取当前内容，计算并得出平均值。</p><figure class="jl jm jn jo fd ii er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es lj"><img src="../Images/859da99ed386dae7b07b99c6e41de552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IJePVckuPG9G54fF.png"/></div></div></figure><p id="de48" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">函数doIt2()包含一个在生成器timeWindowedAggregates()上的循环:await for(timeWindowedAggregates的timedWindowAggregate(6000))将平均值打印到控制台。</p><p id="67af" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">组合输出如下所示:</p><figure class="jl jm jn jo fd ii er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jt"><img src="../Images/177a0a423d3b344000a6ec9b601e604c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rj8wTN7K5AOXRw6h.png"/></div></div></figure><p id="f1fe" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">请注意，所有定时窗口平均值都是同时生成的(在传感器之间不同数量的读数上)，而运行总量是在不同时间生成的(在相同数量的读数上)。</p><p id="43f1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">扩展代码库:</p><figure class="jl jm jn jo fd ii"><div class="bz dy l di"><div class="ju jv l"/></div></figure><h1 id="5a4e" class="kh kc hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">资源</h1><p id="4ddb" class="pw-post-body-paragraph il im hh in b io le iq ir is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji ha bi translated">迭代Promise.all的部分结果—【https://agentcooper.io/iterate-promise-all/ T4】</p><p id="bbb8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">JavaScript数组-查找最小值、最大值、总和以及平均值-<a class="ae lk" href="https://codeburst.io/javascript-arrays-finding-the-minimum-maximum-sum-average-values-f02f1b0ce332" rel="noopener" target="_blank">https://code burst . io/JavaScript-Arrays-Finding-The-Minimum-Maximum-Sum-Average-Values-f 02 f1 b 0ce 332</a></p><p id="5a69" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">移动平均线(维基百科)——<a class="ae lk" href="https://en.wikipedia.org/wiki/Moving_average" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Moving_average</a></p><p id="964f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如何让你的JavaScript函数休眠—<a class="ae lk" href="https://flaviocopes.com/javascript-sleep/" rel="noopener ugc nofollow" target="_blank">https://flaviocopes.com/javascript-sleep/</a></p><p id="af8a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">JavaScript-Generator-Yield/Next &amp; Async-Await—<a class="ae lk" href="https://codeburst.io/javascript-generator-yield-next-async-await-e428b0cb52e4" rel="noopener" target="_blank">https://code burst . io/JavaScript-Generator-Yield-Next-Async-Await-e 428 b 0 CB 52 e 4</a></p><p id="bc4c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">JavaScript中的异步生成器和管道—<a class="ae lk" href="https://dev.to/nestedsoftware/asynchronous-generators-and-pipelines-in-javascript--1h62" rel="noopener ugc nofollow" target="_blank">https://dev . to/nested software/asynchronous-Generators-and-Pipelines-in-JavaScript-1h 62</a></p><p id="bce6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们在JavaScript-<a class="ae lk" href="https://medium.freecodecamp.org/lets-experiment-with-functional-generators-and-the-pipeline-operator-in-javascript-520364f97448" rel="noopener ugc nofollow" target="_blank">https://medium . freecodecamp . org/let-experiment-with-functional-generators-and-the-pipeline-operator-in-JavaScript-520364 f 97448</a>中试验函数生成器和管道操作符</p></div><div class="ab cl ll lm go ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ha hb hc hd he"><p id="3a91" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jj">原载于2019年4月30日</em><a class="ae lk" href="https://technology.amis.nl/2019/04/30/javascript-pipelining-using-asynchronous-generators-to-implement-running-aggregates/" rel="noopener ugc nofollow" target="_blank"><em class="jj">https://technology . amis . nl</em></a><em class="jj">。</em></p></div></div>    
</body>
</html>