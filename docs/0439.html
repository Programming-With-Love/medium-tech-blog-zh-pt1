<html>
<head>
<title>Database relations with Room</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库与房间的关系</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/database-relations-with-room-544ab95e4542?source=collection_archive---------0-----------------------#2019-11-21">https://medium.com/androiddevelopers/database-relations-with-room-544ab95e4542?source=collection_archive---------0-----------------------#2019-11-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/be15fd80ca3c5a572494c6a9f3d1f1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_cHB209ZFaz_xKRzJy1_ew.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Database relations: one-to-one, one-to-many, many-to-many</figcaption></figure><div class=""/><p id="4050" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">设计关系数据库的一个重要部分是将数据拆分到相关的表中，并以有意义的方式将数据放在一起。从<a class="ae jr" href="https://developer.android.com/jetpack/androidx/releases/room#version_220_3" rel="noopener ugc nofollow" target="_blank"> Room 2.2 </a>(现在稳定)开始，我们支持表之间所有可能的关系:一对一、一对多和多对多，只有一个注释:<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/android/arch/persistence/room/Relation" rel="noopener ugc nofollow" target="_blank">@Relation</a></code>。</p><figure class="jx jy jz ka fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jw"><img src="../Images/71462f9f9dac3efe1527ba0a727f06e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5SACWiK-9zA1-yBQ"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">One-to-one relations</figcaption></figure><h1 id="6185" class="kb kc hw bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">一对一的关系</h1><p id="af92" class="pw-post-body-paragraph it iu hw iv b iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ld jo jp jq ha bi translated">假设我们生活在一个(可悲的)世界里，一个人只能拥有一只狗，一只狗只能有一个主人。这是一对一的关系。为了在关系数据库中建模，我们创建了两个表:<code class="du js jt ju jv b">Dog</code>和<code class="du js jt ju jv b">Owner</code>，其中<code class="du js jt ju jv b">Dog</code>表引用了主人id，或者<code class="du js jt ju jv b">Owner</code>表引用了狗id。在房间中，我们创建两个实体:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="b5e2" class="li kc hw jv b fi lj lk l ll lm">@Entity<br/>data class Dog(<br/>    @PrimaryKey val dogId: Long,<br/>    val dogOwnerId: Long,<br/>    val name: String,<br/>    val cuteness: Int,<br/>    val barkVolume: Int,<br/>    val breed: String<br/>)</span><span id="23dc" class="li kc hw jv b fi ln lk l ll lm">@Entity<br/>data class Owner(@PrimaryKey val ownerId: Long, val name: String)</span></pre><p id="fffb" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">假设我们想在屏幕上显示所有狗及其主人的列表。为此，我们将创建一个<code class="du js jt ju jv b">DogAndOwner</code>数据类:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="ea2e" class="li kc hw jv b fi lj lk l ll lm">data class DogAndOwner(<br/>    val owner: Owner,<br/>    val dog: Dog<br/>)</span></pre><p id="20c5" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要使用SQLite进行查询，我们需要1)运行两个查询:一个获取所有主人，另一个基于主人id获取所有狗，然后2)处理对象映射。</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="210d" class="li kc hw jv b fi lj lk l ll lm">SELECT * FROM Owner</span><span id="5aa6" class="li kc hw jv b fi ln lk l ll lm">SELECT * FROM Dog<br/>    WHERE dogOwnerId IN (ownerId1, ownerId2, …)</span></pre><p id="9cd1" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为了获得一个<code class="du js jt ju jv b">List&lt;DogAndOwner&gt;</code>使用空间，我们不需要自己实现两个查询并处理对象映射，而是使用<code class="du js jt ju jv b">@Relation</code>注释。</p><p id="da7e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在我们的示例中，由于<code class="du js jt ju jv b">Dog</code>有所有者的信息，我们将<code class="du js jt ju jv b">@Relation</code>注释添加到dog变量中，指定父变量(即<code class="du js jt ju jv b">Owner</code>实体)上的<code class="du js jt ju jv b">ownerId</code>列对应于<code class="du js jt ju jv b">dogOwnerId</code>:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="6e03" class="li kc hw jv b fi lj lk l ll lm">data class DogAndOwner(<br/>    @Embedded val owner: Owner,<br/>    @Relation(<br/>         parentColumn = "ownerId",<br/>         entityColumn = "dogOwnerId"<br/>    )<br/>    val dog: Dog<br/>)</span></pre><p id="30d4" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们的<a class="ae jr" href="https://developer.android.com/reference/android/arch/persistence/room/Dao" rel="noopener ugc nofollow" target="_blank">刀</a>现在简化为:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="7aa5" class="li kc hw jv b fi lj lk l ll lm">@Transaction<br/>@Query("SELECT * FROM Owner")<br/>fun getDogsAndOwners(): List&lt;DogAndOwner&gt;</span></pre><p id="dc17" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注意:因为Room在幕后为我们运行这两个查询，所以添加了<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/android/arch/persistence/room/Transaction" rel="noopener ugc nofollow" target="_blank">@Transaction</a></code>注释，以确保这是自动发生的。</p><figure class="jx jy jz ka fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jw"><img src="../Images/b522c5ae36c5b38de7ee42aa470687b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0Tq1wjjPYFQLSkkF"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">One-to-many relations</figcaption></figure><h1 id="2681" class="kb kc hw bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">一对多关系</h1><p id="97e4" class="pw-post-body-paragraph it iu hw iv b iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ld jo jp jq ha bi translated">假设一个主人可以养多只狗(耶！);我们在<code class="du js jt ju jv b">Dog</code>和<code class="du js jt ju jv b">Owner</code>之间有一个一对多的关系。我们之前定义的数据库模式没有改变——我们仍然有相同的表，因为相关的键已经在关系的“多”表中。</p><p id="d2c7" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在，为了显示主人及其狗的列表，我们需要创建一个新的数据类来对此进行建模:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="f856" class="li kc hw jv b fi lj lk l ll lm">data class OwnerWithDogs(<br/>    val owner: Owner,<br/>    val dogs: List&lt;Dog&gt;<br/>)</span></pre><p id="d876" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为了避免运行两个独立的查询，我们可以在<code class="du js jt ju jv b">Dog</code>和<code class="du js jt ju jv b">Owner</code>之间定义一个一对多的关系，方法是像前面一样用<code class="du js jt ju jv b">@Relation</code>来注释<code class="du js jt ju jv b">List&lt;Dog&gt;</code>:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="dbc5" class="li kc hw jv b fi lj lk l ll lm">data class OwnerWithDogs(<br/>     @Embedded val owner: Owner,<br/>     @Relation(<br/>          parentColumn = "ownerId",<br/>          entityColumn = "dogOwnerId"<br/>     )<br/>     val dogs: <strong class="jv hx">List</strong>&lt;Dog&gt;<br/>)</span></pre><p id="3055" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">道就变成了:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="9372" class="li kc hw jv b fi lj lk l ll lm">@Transaction<br/>@Query("SELECT * FROM Owner")<br/>fun getDogsAndOwners(): List&lt;OwnerWithDogs&gt;</span></pre><figure class="jx jy jz ka fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jw"><img src="../Images/490e99208811c8fd449c4b1e7621043e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t0kcnrKHrjaBGm3u"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Many-to-many relations</figcaption></figure><h1 id="5434" class="kb kc hw bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">多对多关系</h1><p id="d62b" class="pw-post-body-paragraph it iu hw iv b iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ld jo jp jq ha bi translated">现在假设我们生活在一个完美的世界里，一个主人可以有多只狗，一只狗可以有多个主人。为了对这个模式建模，我们的<code class="du js jt ju jv b">Dog</code>和<code class="du js jt ju jv b">Owner</code>表是不够的。因为一只狗可以有多个主人，所以我们需要相同狗id的多个条目，匹配不同的主人id。因为<code class="du js jt ju jv b">dogId</code>是<code class="du js jt ju jv b">Dog</code>中的主键，所以我们不能插入多个id相同的狗。为了克服这一点，我们需要创建一个<a class="ae jr" href="https://en.wikipedia.org/wiki/Associative_entity" rel="noopener ugc nofollow" target="_blank">关联</a>表(也称为交叉引用表),用于保存<code class="du js jt ju jv b">(dogId,ownerId)</code>对:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="6fbe" class="li kc hw jv b fi lj lk l ll lm">@Entity(primaryKeys = ["dogId", "ownerId"])<br/>data class DogOwnerCrossRef(<br/>    val dogId: Long,<br/>    val ownerId: Long<br/>)</span></pre><p id="170a" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果我们现在想要获得所有拥有狗的主人的列表:<code class="du js jt ju jv b">List&lt;OwnerWithDogs&gt;</code>，仅使用SQLite查询，我们需要编写两个查询:一个获取所有主人，另一个连接<code class="du js jt ju jv b">Dog</code>和<code class="du js jt ju jv b">DogOwnerCrossRef</code>表:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="1d80" class="li kc hw jv b fi lj lk l ll lm">SELECT * FROM Owner</span><span id="b467" class="li kc hw jv b fi ln lk l ll lm">SELECT<br/>     Dog.dogId AS dogId,<br/>     Dog.dogOwnerId AS dogOwnerId,<br/>     Dog.name AS name,<br/>     _junction.ownerId<br/>FROM<br/>     DogOwnerCrossRef AS _junction<br/>INNER JOIN Dog ON (_junction.dogId = Dog.dogId)<br/>WHERE _junction.ownerId IN (ownerId1, ownerId2, …)</span></pre><p id="c4e0" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为了在Room中实现这一点，我们需要更新我们的<code class="du js jt ju jv b">OwnerWithDogs</code>数据类，并告诉Room为了获得<code class="du js jt ju jv b">Dogs</code>，它需要使用<code class="du js jt ju jv b">DogOwnerCrossRef</code>关联表。我们通过使用<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/androidx/room/Junction" rel="noopener ugc nofollow" target="_blank">Junction</a></code>来引用该表:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="78f2" class="li kc hw jv b fi lj lk l ll lm">data class OwnerWithDogs(<br/>    @Embedded val owner: Owner,<br/>    @Relation(<br/>         parentColumn = "ownerId",<br/>         entityColumn = "dogId",<br/>         <strong class="jv hx">associateBy = Junction(DogOwnerCrossRef::class)<br/>    </strong>)<br/>    val dogs: List&lt;Dog&gt;<br/>)</span></pre><p id="2da9" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在我们的Dao中，我们需要从所有者中选择并返回正确的数据类:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="d65d" class="li kc hw jv b fi lj lk l ll lm">@Transaction<br/>@Query("SELECT * FROM Owner")<br/>fun getOwnersWithDogs(): List&lt;OwnerWithDogs&gt;</span></pre><h1 id="9991" class="kb kc hw bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">高级关系用例</h1><p id="114a" class="pw-post-body-paragraph it iu hw iv b iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm ld jo jp jq ha bi translated">当使用<code class="du js jt ju jv b">@Relation</code>注释时，默认情况下，Room从注释属性的类型中推断出要使用的实体。例如，到目前为止，我们用<code class="du js jt ju jv b">@Relation</code>注释了一个<code class="du js jt ju jv b">Dog</code>(或者一个<code class="du js jt ju jv b">List&lt;Dog&gt;</code>)，告诉Room如何对类建模以及要查询哪些列</p><p id="e909" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果我们想要返回一个不同的对象，例如一个<code class="du js jt ju jv b">Pup</code>，它不是一个实体，但是包含一些字段，我们可以在<code class="du js jt ju jv b">@Relation</code>注释中指定要使用的实体:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="d91d" class="li kc hw jv b fi lj lk l ll lm">data class Pup(<br/>     val name: String,<br/>     val cuteness: Int = 11<br/>)</span><span id="ab18" class="li kc hw jv b fi ln lk l ll lm">data class OwnerWithPups(<br/>     @Embedded val owner: Owner,<br/>     @Relation(<br/>          parentColumn = "ownerId",<br/>          entity = Dog::class,<br/>          entityColumn = "dogOwnerId"<br/>     )<br/>     val dogs: List&lt;Pup&gt;<br/>)</span></pre><p id="dd0f" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果我们只想从一个实体返回特定的列，你需要通过在<code class="du js jt ju jv b">@Relation</code>的projection属性中定义它们来告诉Room这些是什么。例如，假设我们只想获得我们的<code class="du js jt ju jv b">OwnerWithDogs</code>数据类中所有狗的名字。由于我们需要一个<code class="du js jt ju jv b">List&lt;String&gt;</code>，Room无法推导出那些字符串是对应于名字还是对应于品种，所以我们需要在投影中指定列:</p><pre class="jx jy jz ka fd le jv lf lg aw lh bi"><span id="58e8" class="li kc hw jv b fi lj lk l ll lm">data class OwnerWithDogs(<br/>     @Embedded val owner: Owner,<br/>     @Relation(<br/>           parentColumn = "ownerId",<br/>           entity = Dog::class,<br/>           entityColumn = "dogOwnerId",<br/>           projection = ["name"]<br/>     )<br/>     val dogNames: List&lt;String&gt;<br/>)</span></pre><p id="5976" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您想在<code class="du js jt ju jv b">dogOwnerId</code>和<code class="du js jt ju jv b">ownerId</code>之间定义一个更严格的关系，不管您正在创建哪种关系，在字段之间使用一个<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/android/arch/persistence/room/ForeignKey" rel="noopener ugc nofollow" target="_blank">ForeignKey</a></code>约束。请记住，<a class="ae jr" href="https://sqlite.org/foreignkeys.html" rel="noopener ugc nofollow" target="_blank"> SQLite外键</a>定义了索引，并且可以拥有级联触发器来更新或删除表中的条目。因此，根据您是否想在数据库中使用这种功能来决定是否要使用外键。</p></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><p id="01c3" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">无论您需要一对一、一对多还是多对多的支持，Room都为您(和您的狗狗)提供了一个注解:<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/android/arch/persistence/room/Relation" rel="noopener ugc nofollow" target="_blank">@Relation</a></code>。从我们的Android Dev Summit’19演讲中了解更多关于<a class="ae jr" href="https://developer.android.com/jetpack/androidx/releases/room#version_220_3" rel="noopener ugc nofollow" target="_blank"> Room 2.2特性的信息</a>:</p><figure class="jx jy jz ka fd hj"><div class="bz dy l di"><div class="lv lw l"/></div></figure></div></div>    
</body>
</html>