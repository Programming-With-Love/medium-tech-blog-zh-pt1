<html>
<head>
<title>LiveData with SnackBar, Navigation and other events (the SingleLiveEvent case)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有SnackBar、导航和其他事件的LiveData(单个LiveEvent案例)</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150?source=collection_archive---------0-----------------------#2018-04-27">https://medium.com/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150?source=collection_archive---------0-----------------------#2018-04-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="35a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2021年更新:该指南被<em class="jc">弃用</em>，取而代之的是</strong> <a class="ae jd" href="https://developer.android.com/jetpack/guide/ui-layer/events" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">官方指南</strong> </a> <strong class="ig hi">。</strong></p><p id="5f65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">视图(活动或片段)与视图模型通信的一种便捷方式是使用<code class="du je jf jg jh b"><a class="ae jd" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank">LiveData</a></code> observables。视图订阅LiveData中的更改并对其做出反应。这对于连续显示在屏幕上的数据非常有用。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es ji"><img src="../Images/12d59ab4ef75f76b7980d6c9a3052d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*vbhP6Sw61MAK335gEubwHA.png"/></div></figure><p id="c53b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">但是，有些数据应该只使用一次，</strong>比如Snackbar消息、导航事件或对话框触发器。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es ji"><img src="../Images/ae671afb1141d4d2a71320d2b615e792.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*WwhYg9sscdYQgLvC3xks4g.png"/></div></figure><p id="fbde" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">与其试图用库或架构组件的扩展来解决这个问题，不如把它当作一个设计问题来面对。<strong class="ig hi">我们建议你将自己的活动视为状态的一部分</strong>。在本文中，我们展示了一些常见的错误和推荐的方法。</p><h1 id="740b" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">❌坏:1。将LiveData用于事件</h1><p id="269e" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">这种方法将Snackbar消息或导航信号直接保存在LiveData对象中。尽管原则上看起来常规的LiveData对象可以用于此目的，但它存在一些问题。</p><p id="97c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在列表/详细信息应用程序中，列表的视图模型如下:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="0f0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在视图(活动或片段)中:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="a1b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种方法的问题是<code class="du je jf jg jh b">_navigateToDetails</code>中的值长时间保持为真，不可能回到第一个屏幕。循序渐进:</p><ol class=""><li id="f999" class="kv kw hh ig b ih ii il im ip kx it ky ix kz jb la lb lc ld bi translated">用户单击按钮，细节活动开始</li><li id="35af" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">用户按back，返回到列表活动</li><li id="3ba2" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">观察器在活动处于后台堆栈时处于非活动状态，之后再次变为活动状态</li><li id="4218" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">值仍然是<code class="du je jf jg jh b">true</code>,所以Details活动再次错误地启动</li></ol><p id="d38b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一种解决方案是从ViewModel启动导航，并立即将标志设置为false:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="4289" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，要记住的一件重要事情是，LiveData保存值，但不保证发出它接收的每一个值。例如:可以在没有观察器处于活动状态时设置一个值，因此一个新的值将会替换它。此外，从不同的线程设置值可能会导致竞争情况，这种情况只会生成一个对观察器的调用。</p><p id="a928" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是这种方法的主要问题是<strong class="ig hi">很难理解，而且很难看</strong>。我们如何确保在导航事件发生后重置该值？</p><h1 id="8816" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak"> ❌更好:2。将LiveData用于事件，重置观察者中的事件值</strong></h1><p id="148d" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">使用这种方法，您可以添加一种方式，从视图中表明您已经处理了该事件，并且应该对其进行重置。</p><h2 id="baac" class="lj jr hh bd js lk ll lm jw ln lo lp ka ip lq lr ke it ls lt ki ix lu lv km lw bi translated">使用</h2><p id="4924" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">对我们的观察者做一个小小的改变，我们可能会有一个解决方案:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="c84d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在视图模型中添加新方法，如下所示:</p><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="kt ku l"/></div></figure><h2 id="3363" class="lj jr hh bd js lk ll lm jw ln lo lp ka ip lq lr ke it ls lt ki ix lu lv km lw bi translated">问题</h2><p id="0b20" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">这种方法的问题是有一些样板文件(在每个事件的视图模型中有一个新方法),并且容易出错；很容易忘记观察者对视图模型的调用。</p><h1 id="847c" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak"> ✔️ OK:使用singliveevent</strong></h1><p id="2339" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated"><a class="ae jd" href="https://github.com/googlesamples/android-architecture/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java" rel="noopener ugc nofollow" target="_blank"> SingleLiveEvent </a>类是为一个示例创建的，作为适用于特定场景的解决方案。它是一个只发送一次更新的LiveData。</p><h2 id="866c" class="lj jr hh bd js lk ll lm jw ln lo lp ka ip lq lr ke it ls lt ki ix lu lv km lw bi translated">使用</h2><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="kt ku l"/></div></figure><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="kt ku l"/></div></figure><h2 id="7a2c" class="lj jr hh bd js lk ll lm jw ln lo lp ka ip lq lr ke it ls lt ki ix lu lv km lw bi translated">问题</h2><p id="e48d" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">SingleLiveEvent的问题是它仅限于一个观察者。如果您无意中添加了多个，那么只会调用一个，并且不能保证是哪个。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es ji"><img src="../Images/53131c2faf79bf9913b33e3971be66d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*TLeVFNJwRpXCeS7NaF1EaA.png"/></div></figure><h1 id="0e87" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">✔️建议:使用事件包装器</h1><p id="6465" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">在这种方法中，您可以明确地管理事件是否已被处理，从而减少错误。</p><h2 id="5b44" class="lj jr hh bd js lk ll lm jw ln lo lp ka ip lq lr ke it ls lt ki ix lu lv km lw bi translated">使用</h2><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="kt ku l"/></div></figure><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="kt ku l"/></div></figure><figure class="jj jk jl jm fd jn"><div class="bz dy l di"><div class="kt ku l"/></div></figure><p id="254b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种方法的优点是用户需要通过使用<code class="du je jf jg jh b">getContentIfNotHandled()</code>或<code class="du je jf jg jh b">peekContent()</code>来指定意图。这种方法将事件建模为状态的一部分:它们现在只是一条已经被消费或没有被消费的消息。</p><figure class="jj jk jl jm fd jn er es paragraph-image"><div class="er es ji"><img src="../Images/4cbf6e1eaac96d5214c274d517d77a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*b0z9Flj04zVW_UGsDPQyOA.png"/></div><figcaption class="lx ly et er es lz ma bd b be z dx">With an Event wrapper, you can add multiple observers to a single-use event</figcaption></figure></div><div class="ab cl mb mc go md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ha hb hc hd he"><p id="8afe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总之:<strong class="ig hi">设计事件作为你状态的一部分</strong>。在LiveData observables中使用您自己的<a class="ae jd" href="https://gist.github.com/JoseAlcerreca/5b661f1800e1e654f07cc54fe87441af" rel="noopener ugc nofollow" target="_blank">事件</a>包装器，并根据您的需求进行定制。</p><p id="11cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">奖金！如果你有很多事件，使用这个<a class="ae jd" href="https://gist.github.com/JoseAlcerreca/e0bba240d9b3cffa258777f12e5c0ae9" rel="noopener ugc nofollow" target="_blank"> EventObserver </a>删除一些重复的代码。</p></div></div>    
</body>
</html>