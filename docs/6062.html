<html>
<head>
<title>Sharding Pinterest: How we scaled our MySQL fleet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sharding Pinterest:我们如何扩展我们的MySQL车队</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/sharding-pinterest-how-we-scaled-our-mysql-fleet-3f341e96ca6f?source=collection_archive---------0-----------------------#2015-08-17">https://medium.com/pinterest-engineering/sharding-pinterest-how-we-scaled-our-mysql-fleet-3f341e96ca6f?source=collection_archive---------0-----------------------#2015-08-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8f30" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Marty Weiner | Pinterest工程师，BlackOps</p><blockquote class="jc jd je"><p id="e7dd" class="ie if jf ig b ih ii ij ik il im in io jg iq ir is jh iu iv iw ji iy iz ja jb ha bi translated">“夏德。或者不要碎片。没有尝试。”<br/> —尤达</p></blockquote><p id="19e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是对我们如何在许多MySQL服务器上分割数据的技术探讨。我们在2012年初完成了这种分片方法的发布，它仍然是我们今天用来存储核心数据的系统。</p><p id="579c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在讨论如何拆分数据之前，让我们先熟悉一下我们的数据。情调照明，草莓巧克力，星际迷航语录…</p><p id="5426" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pinterest是你感兴趣的一切的发现引擎。从数据角度来看，Pinterest是世界上最大的人类策划兴趣图。有超过500亿个引脚被Pinners保存到10亿块板上。人们repin和like其他pin(粗略地复制)，关注其他pin ner，董事会和兴趣，并查看他们关注的所有pin ner，董事会和兴趣的主页。太好了！现在把它放大！</p><h2 id="a46e" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated">发育期痛</h2><p id="d26a" class="pw-post-body-paragraph ie if hh ig b ih ke ij ik il kf in io ip kg ir is it kh iv iw ix ki iz ja jb ha bi translated">2011年，我们达到了牵引力。<a class="ae kj" href="http://www.zdnet.com/article/sap-netbase-pinterest-is-fastest-growing-social-site-ever/" rel="noopener ugc nofollow" target="_blank">按</a> <a class="ae kj" href="http://techcrunch.com/2011/11/26/pinterest-viral/" rel="noopener ugc nofollow" target="_blank">某种</a> <a class="ae kj" href="http://www.businessinsider.com/holy-smoke-pinterest-is-the-fastest-growing-site-ever-2012-2" rel="noopener ugc nofollow" target="_blank">的估计</a>，我们的增长速度比以往任何一家初创公司都要快。大约在2011年9月，我们的所有基础设施都超负荷了。我们有几项NoSQL技术，最终都灾难性地崩溃了。我们也有一船的MySQL奴隶用于读取，这产生了许多恼人的错误，特别是缓存。我们重新设计了整个数据存储模型。为了有效，我们仔细地制定了我们的需求。</p><h2 id="92c8" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated">要求</h2><ul class=""><li id="fbd2" class="kk kl hh ig b ih ke il kf ip km it kn ix ko jb kp kq kr ks bi translated">我们的整个系统需要非常稳定，易于操作，并能适应月球。我们希望支持随着站点的增长，将数据存储从最初的一小组机器扩展到许多机器。</li><li id="0f0b" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">所有Pinner生成的内容必须随时可供网站访问。</li><li id="be02" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">支持以确定的顺序(如反向创建时间或用户指定的顺序)请求电路板中的N个引脚。对于Pinner到likes、Pinner到Pins等也是如此。</li><li id="34ff" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">为简单起见，更新通常是最大努力。为了获得最终的一致性，你需要一些额外的东西，比如一个分布式的<a class="ae kj" href="https://en.wikipedia.org/wiki/Transaction_log" rel="noopener ugc nofollow" target="_blank">事务日志</a>。很有趣，也(不太)容易！</li></ul><h2 id="b3d8" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated">设计理念和注意事项</h2><p id="6564" class="pw-post-body-paragraph ie if hh ig b ih ke ij ik il kf in io ip kg ir is it kh iv iw ix ki iz ja jb ha bi translated">因为我们希望这些数据跨越多个数据库，所以我们不能使用数据库的连接、外键或索引来收集所有数据，尽管它们可以用于不跨越数据库的子查询。</p><p id="1a72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还需要支持数据的负载平衡。我们讨厌移动数据，尤其是一项一项地移动，因为这很容易出错，并使系统变得不必要的复杂。如果我们必须移动数据，最好将整个虚拟节点移动到不同的物理节点。</p><p id="a4e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了让我们的实现快速成熟，我们需要最简单的可用解决方案和非常稳定的分布式数据平台节点。</p><p id="65f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所有数据都需要复制到从机进行备份，并具有高可用性，转储到S3进行MapReduce。我们只在制作中与大师互动。在生产过程中，你永远不要读/写奴隶。奴隶滞后，导致奇怪的bug。一旦你被分割，在生产中与奴隶互动通常没有优势。</p><p id="b433" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们需要一种好的方法来为我们所有的对象生成通用的唯一id(UUID)。</p><h2 id="c264" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated">我们是如何分开的</h2><p id="108b" class="pw-post-body-paragraph ie if hh ig b ih ke ij ik il kf in io ip kg ir is it kh iv iw ix ki iz ja jb ha bi translated">无论我们要建造什么，都需要满足我们的需求，并且稳定、性能好、可修复。换句话说，它不能太糟糕，所以<a class="ae kj" href="https://engineering.pinterest.com/blog/learn-stop-using-shiny-new-things-and-love-mysql" rel="noopener ugc nofollow" target="_blank">我们选择了一项成熟的技术</a>作为我们的基础，MySQL。我们有意避开自动扩展的新技术，如MongoDB、Cassandra和Membase，因为它们的成熟度还不够(它们正以惊人的方式向我们袭来！).</p><p id="5336" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jf">除此之外:我仍然建议创业公司避免花哨的新东西——尽全力只使用MySQL。相信我。我有伤疤可以证明。</em></p><p id="4353" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MySQL是成熟的，稳定的，它只是工作。我们不仅使用它，而且它还被许多其他公司用来推动更大的规模。MySQL支持我们对数据请求排序、选择特定范围的数据和行级事务的需求。它有更多的功能，但我们并不需要或使用它们。但是，MySQL是一个单一的解决方案，因此需要对我们的数据进行分片。这是我们的解决方案:</p><p id="b68e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们从八台EC2服务器开始，每台服务器运行一个MySQL实例:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es ky"><img src="../Images/8f37e574a7aa05e0e293f2e1b98bcbdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/0*pImQYoxO9l9J3LG8.png"/></div></figure><p id="4517" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每台MySQL服务器都是主-主复制到备份主机上，以防主服务器出现故障。<strong class="ig hi">我们的生产服务器只能读写主服务器。我建议你也这样做。它简化了一切，避免了滞后的复制错误。</strong></p><p id="11f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个MySQL实例可以有多个数据库:</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es lg"><img src="../Images/78fe2ac14150a8501d76e0043ec53feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/0*dB5aSiZrInFvbefe.png"/></div></figure><p id="7269" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意每个数据库是如何被唯一地命名为db00000、db00001到dbNNNNN的。每个数据库都是我们数据的一部分。我们做了一个设计决定，一旦一个数据进入一个碎片，它就永远不会移动到那个碎片之外。然而，您可以通过将碎片移动到其他机器来获得更多的容量(我们将在后面讨论)。</p><p id="f68a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们维护了一个配置表，其中显示了这些碎片位于哪些机器上:</p><pre class="kz la lb lc fd lh li lj lk aw ll bi"><span id="cac5" class="jj jk hh li b fi lm ln l lo lp">[{“range”:     (0,511), “master”: “MySQL001A”, “slave”: “MySQL001B”},<br/> {“range”: (512, 1023), “master”: “MySQL002A”, “slave”: “MySQL002B”},<br/>    ...<br/> {“range”: (3584, 4095), “master”: “MySQL008A”, “slave”: “MySQL008B”}]</span></pre><p id="4279" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">只有当我们需要移动碎片或更换主机时，才会更改此配置。如果主人死了，我们可以提升奴隶，然后培养一个新的奴隶。这个配置存在于<a class="ae kj" href="https://engineering.pinterest.com/blog/serving-configuration-data-scale-high-availability" rel="noopener ugc nofollow" target="_blank"> ZooKeeper </a>中，并在更新时被发送给维护MySQL碎片的服务。</p><p id="ddc7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个shard包含相同的一组表:pin、boards、users_has_pins、users_likes_pins、pin_liked_by_user等。一会儿我会详细说明这一点。</p><p id="c7cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么我们如何将数据分配给这些碎片呢？</p><p id="983c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们创建了一个64位的ID，它包含碎片ID、包含数据的类型以及数据在表中的位置(本地ID)。碎片ID是16位，类型ID是10位，本地ID是36位。精明的加法学专家会注意到，只增加了62位。我在编译器和芯片设计方面的经历告诉我，保留位的价值与黄金相当。所以我们有两个(设置为零)。</p><pre class="kz la lb lc fd lh li lj lk aw ll bi"><span id="4f2d" class="jj jk hh li b fi lm ln l lo lp">ID = (shard ID &lt;&lt; 46) | (type ID &lt;&lt; 36) | (local ID&lt;&lt;0)</span></pre><p id="7d38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">给定这个Pin:【https://www.pinterest.com/pin/241294492511762325/】T2，我们来分解Pin ID 241294492511762325:</p><pre class="kz la lb lc fd lh li lj lk aw ll bi"><span id="33d8" class="jj jk hh li b fi lm ln l lo lp">Shard ID = (241294492511762325 &gt;&gt; 46) &amp; 0xFFFF = 3429<br/>Type ID  = (241294492511762325 &gt;&gt; 36) &amp; 0x3FF = 1<br/>Local ID = (241294492511762325 &gt;&gt;  0) &amp; 0xFFFFFFFFF = 7075733</span></pre><p id="7943" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以这个Pin对象存在于碎片3429上。它的类型是1(即‘Pin’)，在pins表的第7075733行。举个例子，我们假设这个碎片在MySQL012A上。我们可以这样来理解它:</p><pre class="kz la lb lc fd lh li lj lk aw ll bi"><span id="7b0d" class="jj jk hh li b fi lm ln l lo lp">conn = MySQLdb.connect(host=”MySQL012A”)<br/>conn.execute(“SELECT data FROM db03429.pins where local_id=7075733”)</span></pre><p id="8ef2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有两种类型的数据:对象和映射。对象包含详细信息，如Pin数据。</p><h2 id="b9d6" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated">对象表！</h2><p id="8547" class="pw-post-body-paragraph ie if hh ig b ih ke ij ik il kf in io ip kg ir is it kh iv iw ix ki iz ja jb ha bi translated">对象表，比如pin、users、boards和comments，有一个ID(本地ID，一个自动递增的主键)和一个blob数据，其中包含一个JSON和所有对象的数据。</p><pre class="kz la lb lc fd lh li lj lk aw ll bi"><span id="e1a2" class="jj jk hh li b fi lm ln l lo lp">CREATE TABLE pins (<br/>  local_id INT PRIMARY KEY AUTO_INCREMENT,<br/>  data TEXT,<br/>  ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP<br/>) ENGINE=InnoDB;</span></pre><p id="6446" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，一个大头针对象看起来像这样:</p><pre class="kz la lb lc fd lh li lj lk aw ll bi"><span id="7827" class="jj jk hh li b fi lm ln l lo lp">{“details”: “New Star Wars character”, “link”: “http://webpage.com/asdf”, “user_id”: 241294629943640797, “board_id”: 241294561224164665, …}</span></pre><p id="6658" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了创建新的Pin，我们收集所有数据并创建一个JSON blob。然后，我们决定一个碎片ID(我们更喜欢选择与它所插入的板相同的碎片ID，但这不是必须的)。Pin的类型为1。我们连接到数据库，并将JSON插入到pins表中。MySQL将返回自动增加的本地ID。现在我们有了碎片、类型和新的本地ID，所以我们可以组成完整的64位ID了！</p><p id="2ade" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了编辑Pin，我们在一个<a class="ae kj" href="http://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" rel="noopener ugc nofollow" target="_blank"> MySQL事务</a>下读-修改-写JSON:</p><pre class="kz la lb lc fd lh li lj lk aw ll bi"><span id="3b8c" class="jj jk hh li b fi lm ln l lo lp">&gt; BEGIN<br/>&gt; SELECT blob FROM db03429.pins WHERE local_id=7075733 FOR UPDATE<br/>[Modify the json blob]<br/>&gt; UPDATE db03429.pins SET blob=’&lt;modified blob&gt;’ WHERE local_id=7075733<br/>&gt; COMMIT</span></pre><p id="e9f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要删除一个Pin，您可以在MySQL中删除它所在的行。不过，更好的办法是添加一个名为“active”的JSON字段，并将其设置为“false”，然后在客户端过滤出结果。</p><h2 id="08cc" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated">映射表！</h2><p id="8997" class="pw-post-body-paragraph ie if hh ig b ih ke ij ik il kf in io ip kg ir is it kh iv iw ix ki iz ja jb ha bi translated">映射表将一个对象链接到另一个对象，例如电路板到其上的引脚。用于映射的MySQL表包含三列:一个64位的“from”ID、一个64位的“to”ID和一个序列ID。(from，to，sequence)三元组上有索引键，它们位于“from”ID的分片上。</p><pre class="kz la lb lc fd lh li lj lk aw ll bi"><span id="6b4d" class="jj jk hh li b fi lm ln l lo lp">CREATE TABLE board_has_pins (<br/>  board_id INT,<br/>  pin_id INT,<br/>  sequence INT,<br/>  INDEX(board_id, pin_id, sequence)<br/>) ENGINE=InnoDB;</span></pre><p id="4ef0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">映射表是单向的，例如board_has_pins表。如果你需要相反的方向，你需要一个单独的pin_owned_by_board表。序列ID给出了一个排序(我们的ID不能跨分片进行比较，因为新的本地ID偏移量不同)。我们通常用序列ID = unix时间戳将新的管脚插入到新板中。序列可以是任何数字，但是unix时间戳是一种方便的方法，可以强制新的内容总是更高，因为时间单调增加。您可以像这样在映射表中查找内容:</p><pre class="kz la lb lc fd lh li lj lk aw ll bi"><span id="a8a5" class="jj jk hh li b fi lm ln l lo lp">SELECT pin_id FROM board_has_pins <br/>WHERE board_id=241294561224164665 ORDER BY sequence <br/>LIMIT 50 OFFSET 150</span></pre><p id="aa9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将为您提供多达50个pin _ ids，然后您可以使用它们来查找pin对象。</p><p id="6bdb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们刚刚做的是一个应用层连接(board_id -&gt; pin_ids -&gt; pin objects)。应用层连接的一个令人惊叹的特性是，您可以将映射与对象分开缓存。我们在memcache集群中保存pin_id -&gt; pin对象缓存，但是在redis集群中保存board _ id-&gt; pin _ id。这允许我们选择正确的技术来最好地匹配被缓存的对象。</p><h2 id="690b" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated">增加更多容量</h2><p id="fbf8" class="pw-post-body-paragraph ie if hh ig b ih ke ij ik il kf in io ip kg ir is it kh iv iw ix ki iz ja jb ha bi translated">在我们的系统中，增加容量有三种主要方式。最简单的是升级机器(更大的空间，更快的硬盘，更多的内存，不管你的瓶颈是什么)。</p><p id="3175" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">增加容量的下一个方法是开辟新的范围。最初，我们只创建了4，096个碎片，尽管我们的碎片ID是16位(总共64k个碎片)。新对象只能在这些最初的4k碎片中创建。在某个时候，我们决定用4096到8191个碎片创建新的MySQL服务器，并开始填充这些服务器。</p><p id="8398" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们增加容量的最后一种方法是将一些碎片转移到新的机器上。如果我们想给MySQL001A(它有0到511个碎片)增加更多的容量，我们用下一个最大的名字(比如MySQL009A和B)创建一个新的主-主对，并开始从MySQL001A复制。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lq"><img src="../Images/3aeddffe0b535d07bc86847fd69bae56.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/0*0Wdd85S6GlNfYuyQ.png"/></div></div></figure><p id="fb2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">复制完成后，我们更改配置，使MySQL001A只有0到255个碎片，MySQL009A只有256到511个碎片。现在每台服务器只需处理以前一半的碎片。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lv"><img src="../Images/489022371a94f1c8b520d5691fa9d1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/0*cs_hcwAgbS6JUvIj.png"/></div></div></figure><h2 id="3b40" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated">一些不错的属性</h2><p id="1c4d" class="pw-post-body-paragraph ie if hh ig b ih ke ij ik il kf in io ip kg ir is it kh iv iw ix ki iz ja jb ha bi translated">对于那些必须构建系统来生成新的UUIDs的人来说，你会发现我们在这个系统中可以免费获得它们！当您创建一个新对象并将其插入到对象表中时，它会返回一个新的本地ID。该本地ID与碎片ID和类型ID相结合，为您提供了一个UUID。</p><p id="00f5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于那些已经执行了向MySQL表添加更多列的修改的人来说，你会知道它们可能非常慢，并且是一大痛苦。我们的方法不需要任何MySQL级别的改变。在Pinterest，我们可能在过去三年里进行了一次改变。要向对象添加新字段，只需告诉您的服务您的JSON模式有几个新字段。您可以有一个默认值，这样当您从一个没有新字段的对象中反序列化JSON时，就会得到一个默认值。如果您需要一个映射表，那么创建新的映射表，并随时开始填充它。完成后，运送您的产品！</p><h2 id="6f0f" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated">Mod碎片</h2><p id="d2b5" class="pw-post-body-paragraph ie if hh ig b ih ke ij ik il kf in io ip kg ir is it kh iv iw ix ki iz ja jb ha bi translated">就像<a class="ae kj" href="http://www.imdb.com/title/tt0062589/" rel="noopener ugc nofollow" target="_blank"> Mod小队</a>，只是完全不同。</p><p id="2653" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有些对象需要通过非ID来查找。例如，如果一个Pinner用他们的脸书账户登录，我们需要一个从脸书id到Pinterest IDs的映射。脸书id对我们来说只是比特，所以我们把它们存储在一个独立的碎片系统中，叫做mod shard。其他示例包括IP地址、用户名和电子邮件。</p><p id="63a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">mod shard很像上一节描述的shard系统，但是您可以使用任意输入来查找数据。根据系统中存在的碎片总数对该输入进行散列和修改。结果是数据将存在/已经存在的碎片。例如:</p><pre class="kz la lb lc fd lh li lj lk aw ll bi"><span id="2628" class="jj jk hh li b fi lm ln l lo lp">shard = md5(“1.2.3.4") % 4096</span></pre><p id="2a2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jf">碎片</em>在这种情况下会是1524年。我们维护一个类似于ID shard的配置文件:</p><pre class="kz la lb lc fd lh li lj lk aw ll bi"><span id="eaf8" class="jj jk hh li b fi lm ln l lo lp">[{“range”:    (0,  511), “master”: “msdb001a”, “slave”: “msdb001b”},<br/>  {“range”:  (512, 1023), “master”: “msdb002a”, “slave”: “msdb002b”},<br/>  {“range”: (1024, 1535), “master”: “msdb003a”, “slave”: “msdb003b”},<br/>…]</span></pre><p id="1897" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，要查找有关IP地址1.2.3.4的数据，我们可以这样做:</p><pre class="kz la lb lc fd lh li lj lk aw ll bi"><span id="1b87" class="jj jk hh li b fi lm ln l lo lp">conn = MySQLdb.connect(host=”msdb003a”)<br/>conn.execute(“SELECT data FROM msdb001a.ip_data WHERE ip='1.2.3.4'”)</span></pre><p id="c4c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您失去了ID碎片的一些好的属性，比如空间局部性。你必须从一开始制作的所有碎片开始，自己制作钥匙(它不会为你制作一个)。用不可变的id来表示系统中的对象总是最好的。这样，当用户更改用户名时，你就不必更新大量的引用。</p><h2 id="b8a6" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated">最后的想法</h2><p id="f175" class="pw-post-body-paragraph ie if hh ig b ih ke ij ik il kf in io ip kg ir is it kh iv iw ix ki iz ja jb ha bi translated">这个系统已经在Pinterest上生产了3.5年，并且可能会永远存在下去。实现它相对简单，但打开它并从旧机器上转移所有数据却非常困难。如果你是一家面临成长烦恼的初创公司，并且刚刚构建了新的碎片，那么考虑构建一个后台处理机器集群(使用<a class="ae kj" href="https://github.com/binarydud/pyres" rel="noopener ugc nofollow" target="_blank"> pyres </a>)来编写将数据从旧数据库移动到新碎片的脚本。我保证无论你怎么努力数据都会丢失(系统里的小妖精，我发誓)，所以一遍又一遍的重复数据传输，直到写入新系统的新东西很微小或者为零。</p><p id="3781" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个系统是最大的努力。它不会在所有情况下都给你原子性、孤立性或一致性。哇！听起来很糟糕！但是不用担心。没有这些保证，你可能也很好。如果需要的话，你可以在其他流程/系统中构建这些层，但是我会告诉你你可以免费得到什么:这个东西就是工作。简单性带来了良好的可靠性，而且速度非常快。如果你担心A，I和C，给我写信。我可以帮你想清楚这些问题。</p><p id="1b6e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是故障转移呢？我们构建了一个维护MySQL碎片的服务。我们在ZooKeeper中存储了shard配置表。当主服务器死亡时，我们有脚本来提升从服务器，然后启动一台替换机器(并使其保持最新)。即使在今天，我们也不使用自动故障转移。</p><p id="ec88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jf">鸣谢:Yash Nelapati、Ryan Probasco、Ryan Park和我在来自</em><a class="ae kj" href="https://twitter.com/evanpriestley" rel="noopener ugc nofollow" target="_blank"><em class="jf">Evan priest ley</em></a><em class="jf">的爱心指导下构建了Pinterest切分系统。红牛和咖啡让它跑起来。</em></p></div></div>    
</body>
</html>