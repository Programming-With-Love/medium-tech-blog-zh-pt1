# JavaScript 工厂函数 vs 构造函数 vs 类

> 原文：<https://medium.com/javascript-scene/javascript-factory-functions-vs-constructor-functions-vs-classes-2f22ceddf33e?source=collection_archive---------0----------------------->

![](img/f22bf29c1c209dd089920e6e78bdad35.png)

Shaolin — larique (CC BY-NC-ND 2.0)

在 ES6 之前，人们对 JavaScript 中工厂函数和构造函数的区别有很多困惑。由于 ES6 有了 *`class`* 关键字，很多人似乎认为这解决了构造函数的许多问题。它没有。让我们探讨一下您仍然需要了解的主要区别。

首先，让我们来看看每一个例子:

这些策略中的每一个都将方法存储在一个共享的原型上，并通过构造函数闭包可选地支持私有数据。换句话说，它们具有几乎相同的特性，并且可以互换使用。

> 在 JavaScript 中，任何函数都可以返回一个新对象。当它不是构造函数或类时，它被称为工厂函数。

ES6 类与构造函数无关，因此关于构造函数的所有内容也适用于 ES6 类:

```
class Foo {}console.log(typeof Foo); // function
```

# 工厂和建造师有什么区别？

构造函数强制调用方使用`new`关键字。工厂没有。就是这样，但这有一些相关的副作用。

那么`new`关键字是做什么的呢？

> 注意:我们将使用`instance`来引用新创建的实例，使用`Constructor`来引用创建该实例的构造函数或类。

1.  实例化一个新的实例对象，并在构造函数中将`this`绑定到它。
2.  将`instance.__proto__`绑定到`Constructor.prototype`。
3.  作为 2 的副作用，将`instance.__proto__.constructor`绑定到`Constructor`。
4.  隐式返回`this`，引用`instance`。

# 构造函数的好处& `class '

*   大多数书教你使用类或构造函数。
*   `this`指新对象。
*   有些人喜欢`myFoo = new Foo()`的阅读方式。
*   微优化可能会带来性能上的好处，但是您不应该担心这一点，除非您已经分析了您的代码并证明这对您来说是一个问题。

# 构造函数的缺点& `class

## 1.必需的“新”。

在 ES6 之前，忘记`new`是一个很常见的 bug。为了对抗它，许多人使用样板文件来执行它:

```
function Foo() {
  if (!(this instanceof Foo)) { return new Foo(); }
}
```

在 ES6+ (ES2015)中，如果你试图在没有`new`的情况下调用一个类构造函数，它总是会抛出一个错误。如果不将类包装在工厂函数中，就不可能避免对调用者施加`new`要求。

## 2.实例化的细节泄露到调用 API 中(通过“新”需求)。

所有调用方都与构造函数实现紧密耦合。如果你需要工厂的额外灵活性，重构是一个突破性的变化。类到工厂的重构非常普遍，以至于它们出现在开创性的重构书《重构:改进现有代码的设计》中，作者是 Martin Fowler、Kent Beck、John Brant、William Opdyke 和 Don Roberts。

## 3.构造函数打破了开放/封闭原则

由于`new`需求，构造函数违反了**打开/关闭**原则:一个 API 应该**打开**进行扩展，而**关闭**进行修改。

我认为类到工厂的重构非常普遍，应该被认为是所有构造函数的标准扩展:从类到工厂的升级不应该破坏东西，但在 JavaScript 中却是这样。

如果您开始导出一个构造函数或类，而用户开始使用该构造函数，那么接下来您会意识到您需要工厂的灵活性(例如，切换实现以使用对象池，或者跨执行上下文实例化，或者使用替代原型获得更大的继承灵活性)，如果不对调用者强制进行重构，您将很难做到这一点。

不幸的是，在 JavaScript 中，从构造函数或类切换到工厂是一个突破性的变化:

在上面的例子中，我们从一个类开始，但是我们想增加提供不同种类的汽车捆绑包的能力。为此，工厂为不同的汽车套件使用替代原型。我使用这种技术存储了媒体播放器界面的各种实现，根据播放器需要控制的媒体类型选择正确的原型。

## 4.使用构造函数会导致欺骗性的“instanceof”

构造函数到工厂重构的突破性变化之一是`instanceof` *。有时候，人们很想在他们的代码中使用`instanceof`作为类型检查保护。这可能会很成问题。我建议你避开`instanceof` *。**

> 谎言的实例。

`instanceof`不像在强类型语言中那样进行类型检查。相反，它通过比较对象的`__proto__`对象和`Constructor.prototype`属性来进行身份检查。

它不能跨不同的内存领域工作，比如 iframes(第三方 JavaScript 嵌入中常见的错误来源)。如果你的`Constructor.prototype`被替换，它也不起作用。

如果您从一个类或构造函数(它返回`this`，链接到`Constructor.prototype`)开始，然后切换到导出一个任意对象(不链接到`Constructor.prototype`)，这也会失败，当您从构造函数更改为工厂时就会发生这种情况。

简而言之，`instanceof`是另一种方式，从建筑商到工厂的转换是一种**突破性的变化**。

# 使用类的好处

*   方便、独立的语法。
*   在 JavaScript 中模拟类的单一、规范的方式。在 ES6 之前，流行的库中有几个竞争的实现。
*   来自基于类的语言背景的人更熟悉。

# 使用类的缺点

所有构造函数的缺点，加上:

*   诱惑用户使用`extends`关键字创建有问题的类层次结构。

在面向对象设计中，类层次导致了一系列众所周知的问题，包括**脆弱基类问题、大猩猩香蕉问题、必然复制问题、**等等。不幸的是，阶级提供延伸就像球提供投掷和椅子提供坐着。更多信息，请阅读[“JavaScript 的两大支柱:原型 OO”](/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3)和[“开发团队死亡螺旋内部”](/javascript-scene/inside-the-dev-team-death-spiral-6a7ea255467b)。

值得注意的是，构造函数和工厂都可以用来创建有问题的继承层次结构，但是使用 *`extends`* 关键字，class 会创建一个启示，把你引向错误的道路。换句话说，它鼓励你去思考不灵活的(而且经常是错误的)关系，而不是更灵活的组合关系。

> *一个* ***启示*** *是提供执行某个动作的机会的特征。例如，旋钮提供扭转，杠杆提供拉动，按钮提供按压，等等……*

# 使用工厂的好处

工厂比构造函数或类灵活得多，而且它们不会用关键字 *`extends`* 和深层继承层次来引诱人们误入歧途。比起类继承，有许多更安全的代码重用机制，包括函数和模块。

## 1.返回任意对象并使用任意原型

例如，您可以轻松创建实现相同 API 的各种类型的对象，例如，可以实例化使用不同 API 的多种类型视频内容的播放器的媒体播放器，或者可以发出 DOM 事件或 web 套接字事件的事件库。

工厂还可以跨执行上下文实例化对象，利用对象池，并允许更灵活的原型继承模型。

## 2.没有重构的烦恼

您永远不需要从工厂转换到构造函数，因此重构永远不会成为问题。

## 3.否*`新`*

使用`new`没有歧义。不要。(会让`this`表现不好，见下一点)。

## 4.标准 *`this`* 行为

`this`像平常一样工作，所以你可以用它来访问父对象。例如，在`player.create()`中，`this`指的是玩家，就像其他方法调用一样。`call()`和`apply()`也按预期重新分配`this`。

## 5.没有欺骗性 *`instanceof`*

## 6.有些人喜欢“myFoo = createFoo()”的读法

# 工厂的弊端

*   没有创建从实例到`Factory.prototype`*——*的链接，但这实际上是一件好事，因为你不会得到欺骗性的`instanceof` *。*相反，`instanceof`总会失败。见福利。
*   `this`不是指工厂内部的新对象。见福利。
*   在微优化基准测试中，它的执行速度可能比构造函数慢。慢速路径仍然非常快——在旧计算机上每秒数百万次运算。与应用程序代码相比，这更可能是库或框架代码中的一个问题。在使用微优化之前，始终从用户角度进行基准测试。

# 结论

在我看来，`class`可能有一个方便的语法，但这不能弥补它引诱粗心的用户撞上类继承的岩石这一事实。这也是有风险的，因为在将来，你可能想要升级到一个工厂，但是你所有的调用者都将紧密耦合到构造函数，因为关键字`new`和从类到工厂的移动是一个突破性的改变。

您可能认为您可以重构调用点，但是在大型团队中，或者如果您正在使用的类是公共 API 的一部分，您可能会破坏不受您控制的代码。换句话说，你不能总是假设重构调用者是一种选择。

工厂的酷之处在于，它们不仅更强大、更灵活，而且是鼓励整个团队和整个 API 用户群使用简单、灵活、安全的模式的最简单的方式。

# 通过实时 1:1 辅导提升您的技能

DevAnywhere 是达到高级 JavaScript 技能的最快方法:

*   现场课程
*   弹性工时
*   一对一指导
*   构建真正的生产应用

[![](img/03504ae5b049cdb99861a7b575be3a08.png)](https://devanywhere.io/)

[https://devanywhere.io/](https://devanywhere.io/)

***埃里克·艾略特*** *是一位科技产品和平台顾问，《 [*【作曲软件】*](https://leanpub.com/composingsoftware)*[*【EricElliottJS.com】*](https://ericelliottjs.com)*[*devanywhere . io*](https://devanywhere.io)*的联合创始人，以及 dev 团队导师。他曾为 Adobe Systems、* ***、Zumba Fitness、*** ***【华尔街日报、*******【ESPN、*******【BBC】****等顶级录音艺人和包括* ***Usher、【Metallica】********

*他和世界上最美丽的女人享受着与世隔绝的生活方式。*