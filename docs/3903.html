<html>
<head>
<title>SwiftUI: Property wrappers explained in simplest way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI:用最简单的方式解释属性包装器</h1>
<blockquote>原文：<a href="https://medium.com/globant/swiftui-property-wrappers-explained-in-simplest-way-28cb580c6408?source=collection_archive---------0-----------------------#2022-06-29">https://medium.com/globant/swiftui-property-wrappers-explained-in-simplest-way-28cb580c6408?source=collection_archive---------0-----------------------#2022-06-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/32c6be89d3e534f18442dd1881382acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*2YHG8F9ZTgwl2HG-vAl8oQ.gif"/></div></figure><blockquote class="il im in"><p id="6864" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注</strong>:请查看<a class="ae jn" rel="noopener" href="/globant/dive-into-amazing-world-of-swiftui-f35a25c5e9ce">这篇</a>文章，了解SwiftUI简介</p></blockquote><p id="76d9" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">引入属性包装器的主要目的是用逻辑包装属性，这些逻辑可以提取到独立的结构或类中，以便在整个代码库中重用它。我们知道我们所有的视图都是结构，这意味着它们不能被改变，但是因为属性包装器是由SwiftUI管理的，每当属性包装器值改变时，视图就使其外观无效并重新计算主体。</p><p id="18dd" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">SwiftUI为我们提供了大量的属性包装器，其中一些是State、Binding、ObservedObject、EnvironmentObject和Environment Property Wrappers。所以让我们试着去理解它们之间的区别，以及什么时候，为什么，我们必须使用哪一个。</p><h2 id="5620" class="jr js hh bd jt ju jv jw jx jy jz ka kb jo kc kd ke jp kf kg kh jq ki kj kk kl bi translated"><strong class="ak">@状态</strong></h2><ul class=""><li id="5261" class="km kn hh ir b is ko iw kp jo kq jp kr jq ks jm kt ku kv kw bi translated">@State对于属于特定视图的简单属性非常有用，并且永远不会在该视图之外使用，因此将这些属性标记为私有非常重要，以强调这种状态是专门设计的，永远不会脱离它的视图。</li><li id="9523" class="km kn hh ir b is kx iw ky jo kz jp la jq lb jm kt ku kv kw bi translated">当我们使用@State来声明一个属性时，我们将对它的控制权交给SwiftUI，这样只要视图存在，它就会在内存中保持持久。</li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="1054" class="jr js hh lh b fi ll lm l ln lo">struct StateEgView: View {<br/>   var propertyToUpdate: Int = 0<br/>   var body: some View {<br/>      VStack {<br/>         Text(“StateEgView”)<br/>         Text(“parentUpdate is \(self.propertyToUpdate)”)<br/>         .onTapGesture {<br/>            self.propertyToUpdate += 1<br/>         }<br/>      }<br/>   }<br/>}</span></pre><p id="8455" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">我们希望在一些点击手势上更新propertyToUpdate属性，但这里我们将得到错误“变异操作符的左边不是可变的:‘self’是不可变的”</p><p id="21a8" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">为了使它可变，我们需要在这里使用<em class="iq"> SwiftUI属性包装器</em>。因为propertyToUpdate需要在它的所有者视图中更新，所以我们可以像这样使用@State属性包装器，一切都会像预期的那样工作。</p><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="fdc8" class="jr js hh lh b fi ll lm l ln lo"><em class="iq">@State </em><strong class="lh hi"><em class="iq">var</em></strong><em class="iq"> propertyToUpdate: Int = 0</em></span></pre><blockquote class="il im in"><p id="c360" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们将propertyToUpdate传递给子节点，那么接收属性将自动调整状态行为。</p></blockquote><h2 id="f5c4" class="jr js hh bd jt ju jv jw jx jy jz ka kb jo kc kd ke jp kf kg kh jq ki kj kk kl bi translated"><strong class="ak">@绑定</strong></h2><ul class=""><li id="a455" class="km kn hh ir b is ko iw kp jo kq jp kr jq ks jm kt ku kv kw bi translated">@Binding为值类型提供了类似访问的引用。有时我们需要使视图的状态对其子视图是可访问的。但我们不能简单地传递该值，因为它是值类型，Swift将传递该值的副本。这就是我们可以使用@Binding属性包装器的地方。</li><li id="165f" class="km kn hh ir b is kx iw ky jo kz jp la jq lb jm kt ku kv kw bi translated">我们还使用$来传递绑定引用，因为没有$ Swift将传递值的副本，而不是传递可绑定的引用</li></ul><blockquote class="il im in"><p id="0fec" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">绑定不支持声明时的值。</p></blockquote><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="9990" class="jr js hh lh b fi ll lm l ln lo"><strong class="lh hi"><em class="iq">struct</em></strong><em class="iq"> ParentView: View {<br/>   @State </em><strong class="lh hi"><em class="iq">var</em></strong><em class="iq"> propertyToUpdate: Int = 0<br/>   </em><strong class="lh hi"><em class="iq">var</em></strong><em class="iq"> body: </em><strong class="lh hi"><em class="iq">some</em></strong><em class="iq"> View {<br/>      VStack {<br/>         Text(“StateEgView”)<br/>         Text(“parentUpdate is \(</em><strong class="lh hi"><em class="iq">self</em></strong><em class="iq">.propertyToUpdate)”)<br/>         Spacer()<br/>         BindingEgView(childUpdate: $propertyToUpdate)<br/>      }<br/>   }<br/>}</em></span><span id="f7c4" class="jr js hh lh b fi lp lm l ln lo"><strong class="lh hi"><em class="iq">struct</em></strong><em class="iq"> BindingEgView: View {<br/>   @Binding </em><strong class="lh hi"><em class="iq">var</em></strong><em class="iq"> childUpdate: Int<br/>      </em><strong class="lh hi"><em class="iq">var</em></strong><em class="iq"> body: </em><strong class="lh hi"><em class="iq">some</em></strong><em class="iq"> View {<br/>         VStack {<br/>            Text(“BindingEgView”)<br/>            Text(“childUpdate is \(</em><strong class="lh hi"><em class="iq">self</em></strong><em class="iq">.childUpdate)”)<br/>            .onTapGesture {<br/>               </em><strong class="lh hi"><em class="iq">self</em></strong><em class="iq">.childUpdate += 1<br/>             }<br/>         }<br/>     }<br/>}</em></span></pre><p id="ce0e" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">此处，propertyToUpdate在ParentView中声明为State，并初始化为0，同时BindingEgView将childUpdate属性作为绑定。现在，当BindingEgView作为ParentView的子视图添加时，它需要在构造函数中传递值，因此我们传递$ propertyToUpdate。现在，我们已经建立了这样的关系，每当childUpdate被修改时，它都会向父视图发送确认，因此父视图也会更新它的外观。</p><h2 id="c6f3" class="jr js hh bd jt ju jv jw jx jy jz ka kb jo kc kd ke jp kf kg kh jq ki kj kk kl bi translated"><strong class="ak"> @ObservedObject </strong></h2><ul class=""><li id="796c" class="km kn hh ir b is ko iw kp jo kq jp kr jq ks jm kt ku kv kw bi translated">ObservedObject类似于State，但是当您想要使用可能具有多个属性和方法的自定义类型，或者可能在多个视图之间共享时，您应该使用@ObservedObject。</li><li id="5fae" class="km kn hh ir b is kx iw ky jo kz jp la jq lb jm kt ku kv kw bi translated">无论您在@ObservedObject中使用什么类型，都应该符合ObservableObject协议。当你在可观察对象上创建属性时，你可以决定对每个属性的修改是否应该强制视图刷新。通常会，但这不是必需的。</li><li id="f811" class="km kn hh ir b is kx iw ky jo kz jp la jq lb jm kt ku kv kw bi translated">被观察对象有几种方法通知视图重要数据已经更改，但是最简单的方法是使用@Published属性包装器。</li></ul><blockquote class="il im in"><p id="e7be" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">ObservedObject只能与类一起使用，因为ObservableObject协议只支持类</p></blockquote><figure class="lc ld le lf fd ii er es paragraph-image"><div class="er es ie"><img src="../Images/b5b227edb127421da4e68f3be7f9aaa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*twFgaz_jSGohuCxsrMHhdg.gif"/></div></figure><p id="9fe6" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">在这里，我们可以看到CountObserver有两个已发布的属性包装器<em class="iq"> parentUpdate </em>和<em class="iq"> childUpdate </em>，它们将在值发生变化时更新视图(<strong class="ir hi">自动动作</strong>)，而<em class="iq"> total </em>是一个普通属性。<em class="iq"> calculateTotal() </em>在计算用户执行的总点击的按钮动作上被调用。现在这个函数有了<em class="iq">objectwillchange . send()</em>，它向视图发送手动信号，指示已经计算了<em class="iq">总计</em>，它们可以更新视图。</p><h2 id="a78b" class="jr js hh bd jt ju jv jw jx jy jz ka kb jo kc kd ke jp kf kg kh jq ki kj kk kl bi translated"><strong class="ak"> @StateObject </strong></h2><ul class=""><li id="ced2" class="km kn hh ir b is ko iw kp jo kq jp kr jq ks jm kt ku kv kw bi translated">StateObject属性包装器的工作方式类似于ObservedObject，但它们的生命周期不同。让我们首先通过像这样修改上面的eg来理解相似性</li></ul><pre class="lc ld le lf fd lg lh li lj aw lk bi"><span id="f294" class="jr js hh lh b fi ll lm l ln lo">struct StateObjectEgView: View {<br/>   @State var grandParentUpdate: Int = 0<br/>   var body: some View {<br/>      VStack {<br/>         Text(“grandParentUpdate is \(self.grandParentUpdate)”)<br/>         .onTapGesture {<br/>             self.grandParentUpdate += 1<br/>         }.padding(30)<br/>         ObservedObjectEgView()<br/>      }<br/>   }<br/>}</span><span id="9b4c" class="jr js hh lh b fi lp lm l ln lo">struct ObservedObjectEgView: View {<br/>   @ObservedObject var counter = CountObserver()<br/>   var body: some View {<br/>……</span></pre><ul class=""><li id="ba45" class="km kn hh ir b is it iw ix jo lq jp lr jq ls jm kt ku kv kw bi translated">在这里，我们将ObservedObjectEgView作为StateObjectEgView的子视图，因此每当StateObjectEgView的属性强制视图更新其外观时，计数器<em class="iq">就会复位。</em></li></ul><p id="fa07" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">ObservedObject属性在包含它们的视图结构重绘后被销毁，而StateObject不会被销毁。只需查看下面的代码片段，其中我们只将ObservedObject替换为StateObject，并且<em class="iq">计数器</em>不会被重置。</p><figure class="lc ld le lf fd ii er es paragraph-image"><div class="er es ie"><img src="../Images/aa540567163da0f28a35532fb8c2ea79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*tszTYuj8JVvTbjA7zAm8pg.gif"/></div></figure><h2 id="abf5" class="jr js hh bd jt ju jv jw jx jy jz ka kb jo kc kd ke jp kf kg kh jq ki kj kk kl bi translated"><strong class="ak">@环境对象</strong></h2><ul class=""><li id="4e28" class="km kn hh ir b is ko iw kp jo kq jp kr jq ks jm kt ku kv kw bi translated">假设有多个层次视图，因为lowerView是middleView的子视图，middle view是topView的子视图。如果我们希望每当从topView更新propertyA时更新lowerView，反之亦然。这可以通过State和ObservedObject来实现，但唯一的问题是我们必须将propertyA声明为topView，并将其绑定到两个较低的视图，然后在它们的构造函数中发送propertyA。即使middleView不访问propertyA，它也必须拥有它。为了解决这个问题，我们有了下一个属性包装器，即EnvironmentObject。</li><li id="fc77" class="km kn hh ir b is kx iw ky jo kz jp la jq lb jm kt ku kv kw bi translated">EnvironmentObject在应用程序级别创建和存储。这是共享数据，每个视图都可以读/写</li><li id="12da" class="km kn hh ir b is kx iw ky jo kz jp la jq lb jm kt ku kv kw bi translated">由于所有视图都指向同一个模型，如果一个视图改变了模型，所有视图都会立即更新——不会有应用程序的不同部分不同步的风险。</li></ul><h2 id="6efe" class="jr js hh bd jt ju jv jw jx jy jz ka kb jo kc kd ke jp kf kg kh jq ki kj kk kl bi translated"><strong class="ak">@环境</strong></h2><ul class=""><li id="7e21" class="km kn hh ir b is ko iw kp jo kq jp kr jq ks jm kt ku kv kw bi translated">通过用@Environment属性包装器标记我们的属性，我们可以访问和订阅系统范围设置的更改</li><li id="88e3" class="km kn hh ir b is kx iw ky jo kz jp la jq lb jm kt ku kv kw bi translated">@Environment非常适合于读取诸如核心数据管理对象上下文、设备是处于黑暗模式还是明亮模式、视图呈现的大小级别等信息——来自系统的固定属性</li></ul><p id="4460" class="pw-post-body-paragraph io ip hh ir b is it iu iv iw ix iy iz jo jb jc jd jp jf jg jh jq jj jk jl jm ha bi translated">很难在这里列出所有的属性包装器并使它们保持最新。找到它们的最好方法是进入 <a class="ae jn" href="https://developer.apple.com/documentation/swiftui/state-and-data-flow" rel="noopener ugc nofollow" target="_blank"> <em class="iq">文档主题。</em> </a></p><blockquote class="il im in"><p id="549a" class="io ip iq ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你喜欢这篇文章，请用掌声和评论来欣赏它。这真的会鼓励我多写！！！！</p></blockquote></div></div>    
</body>
</html>