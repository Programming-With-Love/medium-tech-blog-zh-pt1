<html>
<head>
<title>Avoid pitfalls in scaling your Cassandra cluster: lessons and remedies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免扩展Cassandra集群时的陷阱:教训和补救措施</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/avoid-pitfalls-in-scaling-your-cassandra-cluster-lessons-and-remedies-a71ca01f8c04?source=collection_archive---------0-----------------------#2017-10-25">https://medium.com/walmartglobaltech/avoid-pitfalls-in-scaling-your-cassandra-cluster-lessons-and-remedies-a71ca01f8c04?source=collection_archive---------0-----------------------#2017-10-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/07fb68984b46f64e878bdac696140a52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mksBdp0E4y28HApgtkcnvg.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Photo credit: <a class="ae hu" href="https://pixabay.com/en/blur-close-up-cobweb-dew-halloween-1868997/" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><div class=""/><div class=""><h2 id="643a" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">介绍</h2></div><p id="53d6" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">沃尔玛的几个团队大量使用Cassandra作为他们的主要数据源之一。除了出色的性能之外，他们中的许多人还依赖Cassandra提供的高可用性和可调一致性保证。我们已经在生产环境中部署了几个基于Cassandra的应用程序，读写操作始终保持在每秒10次甚至100次的水平。</p><p id="f177" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">达到这种状态并不容易。我们不得不“取消学习”RDBMS世界的许多技巧，创建看起来“怪异”但结果证明更具性能的模式，并考虑各种策略来“删除”数据。在本文中，我们将讨论我们在扩展Cassandra集群时观察到的一些陷阱，以及我们如何避免它们。</p><h2 id="54a7" class="ki kj hx bd kk kl km kn ko kp kq kr ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">陷阱1:正确划分分区</h2><p id="5f2b" class="pw-post-body-paragraph jm jn hx jo b jp ld iy jr js le jb ju jv lf jx jy jz lg kb kc kd lh kf kg kh ha bi translated">在交付了几个基于Cassandra的成功项目后，有一个模式总是很突出</p><blockquote class="li lj lk"><p id="c78b" class="jm jn ll jo b jp jq iy jr js jt jb ju lm jw jx jy ln ka kb kc lo ke kf kg kh ha bi translated">在所有可以应用于Cassandra以提高性能的调整、策略和技巧中，设计最佳模式对集群的延迟、稳定性和可用性的影响最大。</p></blockquote><p id="ad29" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">不均匀的分区是不确定的读/写性能和查询超时的最大原因之一。它还会导致压缩周期的压力不均匀，因为有些分区可能很大，可能需要很长时间才能压缩，而较小的分区可能会很快压缩。</p><p id="0254" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在我们的一个用例中，我们需要维护亲子关系。维护parent键作为分区键，child键作为聚集键似乎是合理的，这样所有的child都可以和parent在一起。设计上的一个问题是孩子的数量变化很大；有些父母只有一个孩子，而其他人可以有一百万！这导致了分区热点、大量丢弃的突变，以及集群中某些节点的总体压力过大。</p><figure class="lq lr ls lt fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lp"><img src="../Images/29fd6d6f889bf4cc1e9cf44814abd899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*upWWOZoMQ4jQAa4DA5RDHQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Fig 1 — Uneven partitions in a parent child relation</figcaption></figure><p id="017a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了解决这个问题，我们应用了分片的概念。我们切分了父项，并引入了切分键作为分区键的一部分。碎片大小保持在<em class="ll"> 1000 </em>的固定大小，这样整体分区大小可以保持在<em class="ll"> 10 MB </em>以下。(每行有~ <em class="ll"> 10 KB </em>的数据)。</p><figure class="lq lr ls lt fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lu"><img src="../Images/7d38065df8b1467927898788589bde16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_sgCKZH8VILAkYckFbFRZQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Fig2 — Almost even sized partitions</figcaption></figure><p id="ea44" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这导致了几乎相等大小的分区，并且集群上的负载也得到了分布。作为奖励，我们在读取查询期间免费获得了数据分页！每个分片都很好地映射到一个数据页，现在可以用一个简单的分片查询获取第n页，如下所示</p><pre class="lq lr ls lt fd lv lw lx ly aw lz bi"><span id="238f" class="ki kj hx lw b fi ma mb l mc md">SELECT * FROM table WHERE parent_key = 'p1' AND shard_key = n</span></pre><h2 id="edb0" class="ki kj hx bd kk kl km kn ko kp kq kr ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">陷阱2:确保概念的分离</h2><p id="28bc" class="pw-post-body-paragraph jm jn hx jo b jp ld iy jr js le jb ju jv lf jx jy jz lg kb kc kd lh kf kg kh ha bi translated">Cassandra对二级索引的支持有限。在我们的一个项目中，我们需要创建许多二级索引，并决定使用Solr和Cassandra来卸载索引管理，同时保持数据局部性。</p><p id="5759" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">随着数据量的增长，集群开始出现稳定性问题。随着集群负载的增加，我们开始看到很多超时。深入研究后，我们发现一个主要原因是，对于Cassandra行上的每一个突变，Solr都会获取内存中的整个分区进行索引。由于每个分区都承载了<em class="ll"> MB的</em>数据，这导致了大量的内存数据读取。</p><figure class="lq lr ls lt fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lp"><img src="../Images/d448c9498dd1b9f93343879e49f18d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yy2e7sRavT6rrb-4_fZKWQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Fig 3 — Cassandra + Solr nodes ring — bad performance for wide rows</figcaption></figure><p id="1cf0" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们把Cassandra和Solr集群分开，开始通过一个卡夫卡的话题给Solr写信。虽然纯Cassandra集群的延迟显著改善(几乎没有超时)，但Cassandra + Solr集群的表现仍然很差。我们最终用<a class="ae hu" href="https://lucene.apache.org/solr/guide/6_6/solrcloud.html" rel="noopener ugc nofollow" target="_blank"> SolrCloud </a>替换了Cassandra + Solr组合，切换后性能非常出色，吞吐量显著提高！</p><figure class="lq lr ls lt fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es me"><img src="../Images/cabee38f5b0cce501c581f1b0c228031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKqPwEjfZhnzqee2YGpXJg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Fig 4 — Separate Cassandra and Solr rings — better performance for wide rows</figcaption></figure><h2 id="0b06" class="ki kj hx bd kk kl km kn ko kp kq kr ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">陷阱3:避免完全读/写</h2><p id="87dc" class="pw-post-body-paragraph jm jn hx jo b jp ld iy jr js le jb ju jv lf jx jy jz lg kb kc kd lh kf kg kh ha bi translated">卡珊德拉通过使用“最后写入获胜”策略解决了<em class="ll">突变冲突</em>。如果稍后将相同的数据写回一列，即使数据没有改变 <em class="ll">，也认为是<em class="ll">突变</em> <strong class="jo hy">。</strong></em>突变在读取时会产生沉重的代价，因为读取必须参考多个<em class="ll">表</em>以确保总是返回最新的更新。在压缩过程中，突变被压缩/丢弃，但是，如果实际内容没有变化，这会给集群带来很大的负载。</p><p id="a5df" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">几乎所有用于Cassandra的Java对象映射器框架都提供了基于代理的机制来跟踪变更(即哪些属性/列需要写回)，这是最应该使用的。然而，读语义有点不太好理解。通常，每次触发读取查询时，都会读取整个<strong class="jo hy">行(参见下面的代码<em class="ll">，这增加了读取的成本。更好的方法是尽可能有选择地阅读。</em></strong></p><pre class="lq lr ls lt fd lv lw lx ly aw lz bi"><span id="bbe5" class="ki kj hx lw b fi ma mb l mc md">//writes: <br/>connection.proxyForUpdate(MyBean.class) // the proxy would keep track of which fields were changed<br/>connection.save(myBeanObject) // only changed fields would be written</span><span id="b994" class="ki kj hx lw b fi mf mb l mc md">// reads:<br/>MyBean myBeanObject = connection.find(MyBean.class, myBeanId) <br/>/* <br/>this would typically read all the columns, which is cheaper for row-oriented data bases, but costlier for Cassandra<br/>*/</span></pre><h2 id="74f9" class="ki kj hx bd kk kl km kn ko kp kq kr ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">陷阱4:小心收藏</h2><p id="673f" class="pw-post-body-paragraph jm jn hx jo b jp ld iy jr js le jb ju jv lf jx jy jz lg kb kc kd lh kf kg kh ha bi translated">Cassandra支持集合、映射和列表集合作为列类型。一个常见的错误是读取应用程序中的集合，修改它，然后写回它，如下面的代码所示</p><pre class="lq lr ls lt fd lv lw lx ly aw lz bi"><span id="f112" class="ki kj hx lw b fi ma mb l mc md">List&lt;Object&gt; c = cassandraDO.getList();<br/>c.delete(obj1);<br/>c.add(obj2);<br/>cassandraDO.setList(c); // BAD: re-writes the entire list.<br/>cassandraDO.save();</span></pre><p id="81b0" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这将导致重新编写整个集合，从而产生大量的墓碑并影响性能。此外，集合应该优先于列表，因为集合(和映射)避免了更新和删除的<em class="ll">写前读</em>模式。列表中的更新或删除可能会再次读取内存(服务器端)中的整个列表，因为没有'<em class="ll">数据唯一性'。</em></p><p id="193c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">集合的另一个问题是集合是整体读取的，不支持选择性读取。例如，如果一个映射集合有10，000个条目，而一个查询想要读取5个键的值，那么所有10，000个条目都将被Cassandra读取。这是不必要的，多余的。</p><h2 id="1387" class="ki kj hx bd kk kl km kn ko kp kq kr ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">陷阱5:驱动程序调整</h2><p id="4186" class="pw-post-body-paragraph jm jn hx jo b jp ld iy jr js le jb ju jv lf jx jy jz lg kb kc kd lh kf kg kh ha bi translated">驱动程序调优对查询的执行方式有很大影响。我们在这里找到了一篇由DataStax <a class="ae hu" href="http://docs.datastax.com/en/developer/java-driver/2.1/manual/pooling/" rel="noopener ugc nofollow" target="_blank">撰写的优秀文章，它描述了许多导致更好的整体性能和更少超时的设置。因为我们只使用本地数据中心，所以我们将远程主机连接设置为0。此外，将<em class="ll"> shuffleAmongReplica </em>设置为true给了我们更好的负载分配(缺点是更多的本地读取修复发生在服务器端)</a></p><h2 id="8171" class="ki kj hx bd kk kl km kn ko kp kq kr ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">摘要</h2><p id="f738" class="pw-post-body-paragraph jm jn hx jo b jp ld iy jr js le jb ju jv lf jx jy jz lg kb kc kd lh kf kg kh ha bi translated">如果使用得当，卡桑德拉是一个伟大的系统。影响查询性能的一些关键因素包括正确的数据分区、避免热点、避免完全读/写，以及针对预期的查询负载适当地调优驱动程序。通过改变我们面向<em class="ll"> RDBMS的思维方式</em>，我们学到了很多东西，我们很高兴在过去几年里在沃尔玛使用Cassandra作为主要数据源之一。</p></div></div>    
</body>
</html>