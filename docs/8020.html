<html>
<head>
<title>Building a Notification Framework for Microservice-based Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为基于微服务的应用构建通知框架</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/building-a-notification-framework-for-microservice-based-application-6fe5ac9dfcee?source=collection_archive---------0-----------------------#2021-06-08">https://medium.com/walmartglobaltech/building-a-notification-framework-for-microservice-based-application-6fe5ac9dfcee?source=collection_archive---------0-----------------------#2021-06-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="97e1" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">带有<a class="iw ix ge" href="https://medium.com/u/e91e0ab67926?source=post_page-----6fe5ac9dfcee--------------------------------" rel="noopener" target="_blank"> Vatsalya序列号</a></h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/f81758419f0bb15d032bafdc2acf961b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dUcnysi9c921tjF3"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Photo by <a class="ae jo" href="https://unsplash.com/@liamtruong?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Liam Truong</a> on <a class="ae jo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f8c1" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><a class="ae jo" href="https://microservices.io/" rel="noopener ugc nofollow" target="_blank">微服务</a>是一种流行的设计模式，在这种模式下，大型应用程序被分解成多个独立的、松散耦合的服务，这些服务通过预定义的接口相互通信。沃尔玛的ML平台是使用相同的原理构建的——部署在Kubernetes集群中的独立服务通过REST API进行通信。作为一个平台特性，为用户提供针对事件的通知是一个优先需求。为此，我们开发了一个模型框架，任何对通知服务感兴趣的基于微服务的应用程序都可以使用它。</p><h1 id="4789" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">高层设计</h1><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es ld"><img src="../Images/95410bf107bfc473dc06e811ae597850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*L5MQtY-YaHnZgtPlmKd3RQ.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">High-Level Design for serving notifications</figcaption></figure><p id="39fa" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在高层次上，系统应该能够根据以下规则生成和处理通知。</p><ol class=""><li id="1fad" class="le lf hh jr b js jt jv jw jy lg kc lh kg li kk lj lk ll lm bi translated">每个服务可以独立地生成针对一个用户或一组用户的通知。</li><li id="dc05" class="le lf hh jr b js ln jv lo jy lp kc lq kg lr kk lj lk ll lm bi translated">所有以用户为目标的通知都将存储在通知存储中</li><li id="9f74" class="le lf hh jr b js ln jv lo jy lp kc lq kg lr kk lj lk ll lm bi translated">对于在线用户，通知消息应该立即在UI中弹出。对于离线用户，一旦他们登录，通知应该在通知托盘中可用。</li><li id="b0b9" class="le lf hh jr b js ln jv lo jy lp kc lq kg lr kk lj lk ll lm bi translated">用户可以将通知标记为已读或删除旧通知。</li><li id="3474" class="le lf hh jr b js ln jv lo jy lp kc lq kg lr kk lj lk ll lm bi translated">如果需要，系统还可以选择清除旧的通知。</li></ol><p id="f5ba" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">除了所需的规则，我们还为系统添加了一些所需的功能:</p><ol class=""><li id="a6e2" class="le lf hh jr b js jt jv jw jy lg kc lh kg li kk lj lk ll lm bi translated">该系统不应该给微服务带来很大的负担。</li><li id="5409" class="le lf hh jr b js ln jv lo jy lp kc lq kg lr kk lj lk ll lm bi translated">该系统应该是快速且相当稳定的。</li><li id="1338" class="le lf hh jr b js ln jv lo jy lp kc lq kg lr kk lj lk ll lm bi translated">虽然不希望丢失通知，但是稍微延迟发送通知是可以的。</li></ol><p id="6be0" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们将整个系统设计成一个基于Java的库，可以导入到任何有兴趣发送通知的微服务中。对于通知存储，Redis是选项，服务器发送事件(SSE)用于将通知发送到UI客户端(用户的浏览器)。我们将在随后的章节中分别介绍每个系统，然后将它们放在一起，看看它们是如何组合起来完成这个特性的。</p></div><div class="ab cl ls lt go lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ha hb hc hd he"><h1 id="7384" class="kl km hh bd kn ko lz kq kr ks ma ku kv in mb io kx iq mc ir kz it md iu lb lc bi translated">后端实现</h1><h2 id="f801" class="me km hh bd kn mf mg mh kr mi mj mk kv jy ml mm kx kc mn mo kz kg mp mq lb mr bi translated">模拟通知</h2><p id="c973" class="pw-post-body-paragraph jp jq hh jr b js ms ii ju jv mt il jx jy mu ka kb kc mv ke kf kg mw ki kj kk ha bi translated">一个非常简单的通知结构设计需要两个字段——目标用户和消息。这是我们最初使用的结构，随着功能的成熟，我们添加了更多的字段来增强界面，并将更多的信息捆绑到数据结构中。最后，我们正式确定了通知的结构。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="mx my l"/></div></figure><h2 id="98c9" class="me km hh bd kn mf mg mh kr mi mj mk kv jy ml mm kx kc mn mo kz kg mp mq lb mr bi translated">存储通知</h2><p id="0606" class="pw-post-body-paragraph jp jq hh jr b js ms ii ju jv mt il jx jy mu ka kb kc mv ke kf kg mw ki kj kk ha bi translated">在通知存储中存储通知有两个要点需要考虑:</p><ul class=""><li id="1390" class="le lf hh jr b js jt jv jw jy lg kc lh kg li kk mz lk ll lm bi translated">给定一个通知，应该很容易把它推进商店</li><li id="191f" class="le lf hh jr b js ln jv lo jy lp kc lq kg lr kk mz lk ll lm bi translated">给定一个用户，应该很容易从商店获得他们的通知。</li></ul><p id="1566" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Redis作为一个键值存储，以毫秒级的延迟完成了这两项任务。此外，Redis已被证明具有故障恢复能力和高度可伸缩性。因此，选择它作为通知的后备存储。</p><p id="6a6a" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">此外，Redis内置了对列表和地图等更高级ADT的支持。我们利用映射(即Redis中的散列)来存储通知。对于每个用户，存储通知JSON的通知id的相应散列。每个惟一的用户id充当Redis中的一个键。这种结构确保系统支持两个用户，每个用户有两个潜在的通知。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es na"><img src="../Images/34b32d269659d2024e76786f57a1af0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*fr4qdJJJL-e4GHNpZ4Ct5g.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Storage structure inside Redis</figcaption></figure><p id="3040" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Redis可以以线程安全的方式支持高度并发的工作负载。它还可以通过Redis Sentinels提供生产级支持，以实现高可用性，并通过AOF文件备份提供持久性。关于如何设置运行生产级Redis集群，有很好的文档(参见<a class="ae jo" href="https://redis.io/topics/sentinel" rel="noopener ugc nofollow" target="_blank"> Redis Sentinel </a>和<a class="ae jo" href="https://redis.io/topics/persistence" rel="noopener ugc nofollow" target="_blank"> Redis Persistence </a>)。</p><h2 id="fae5" class="me km hh bd kn mf mg mh kr mi mj mk kv jy ml mm kx kc mn mo kz kg mp mq lb mr bi translated">将通知推送到商店</h2><p id="b679" class="pw-post-body-paragraph jp jq hh jr b js ms ii ju jv mt il jx jy mu ka kb kc mv ke kf kg mw ki kj kk ha bi translated">通知库公开了具有<code class="du nb nc nd ne b">notifyUsers</code>和<code class="du nb nc nd ne b">notifyGroup</code>方法的<code class="du nb nc nd ne b">NotifierClient</code>接口。为了触发通知，微服务将调用带有一个<code class="du nb nc nd ne b">Notification</code>对象和用户id列表的<code class="du nb nc nd ne b">notifyUsers</code>方法来发送通知。该库还允许创建可用于将相似用户(例如，特定项目的所有用户、使用GPU的所有用户等)聚集在一起的组。)和微服务可以选择使用<code class="du nb nc nd ne b">notifyGroup</code>方法向整个组发送通知。</p><p id="043f" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><a class="ae jo" href="https://github.com/redis/jedis" rel="noopener ugc nofollow" target="_blank"> Jedis </a>是Java中最知名的与Redis通信的库，也就是我们在库中用来读写通知的库。Jedis支持Sentinel支持和连接池等高级特性，这也使它成为生产服务器的理想选择。</p><p id="470e" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">为了防止读写偶尔中断，对Redis的调用通过<a class="ae jo" href="https://resilience4j.readme.io/docs/getting-started" rel="noopener ugc nofollow" target="_blank"> Resilience4J </a>包装，确保在临时故障的情况下进行正确的重试和错误处理。</p></div><div class="ab cl ls lt go lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ha hb hc hd he"><h1 id="f2ca" class="kl km hh bd kn ko lz kq kr ks ma ku kv in mb io kx iq mc ir kz it md iu lb lc bi translated">前端实现</h1><p id="ab06" class="pw-post-body-paragraph jp jq hh jr b js ms ii ju jv mt il jx jy mu ka kb kc mv ke kf kg mw ki kj kk ha bi translated">为了启用前端，我们使用一个Express server作为用户浏览器和后端微服务之间的中间件，来执行身份验证和会话管理。我们利用这个服务器从Redis读取通知，并将它们推送给用户。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es nf"><img src="../Images/258372fa340018742a862ddfda1c1109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*MBpXxun9uWbJHeoUmmAl5A.png"/></div></figure><h2 id="22d6" class="me km hh bd kn mf mg mh kr mi mj mk kv jy ml mm kx kc mn mo kz kg mp mq lb mr bi translated">将通知推送到浏览器</h2><p id="46f0" class="pw-post-body-paragraph jp jq hh jr b js ms ii ju jv mt il jx jy mu ka kb kc mv ke kf kg mw ki kj kk ha bi translated">服务器发送事件(SSE)是建立在HTTP之上的一项技术。对于登录到系统的每个用户，我们在用户会话期间建立一个持久的HTTP连接。SSE的协议规范规定JSON数据被转换成一个字符串，每个事件以两个换行符结束。你可以查看<a class="ae jo" href="https://javascript.info/server-sent-events" rel="noopener ugc nofollow" target="_blank">本教程</a>来阅读更多关于如何使用Javascript使用SSE的内容。</p><p id="01a9" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">一旦建立了连接，我们就利用Node.js事件模型，在Redis中有新的通知可用时，将数据推送到客户机。我们发出一个通知事件，该事件被附加到HTTP SSE处理程序范围内的事件侦听器上。我们使用登录用户的惟一id将来自Redis的消息与用户的连接进行匹配。</p><p id="bec3" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这个<a class="ae jo" href="https://github.com/daichi-m/notification4J/blob/main/ui/send-to-browser.js" rel="noopener ugc nofollow" target="_blank"> GitHub代码片段</a>描述了它是如何完成的。</p><h2 id="01bb" class="me km hh bd kn mf mg mh kr mi mj mk kv jy ml mm kx kc mn mo kz kg mp mq lb mr bi translated">在浏览器中接收通知</h2><p id="f1db" class="pw-post-body-paragraph jp jq hh jr b js ms ii ju jv mt il jx jy mu ka kb kc mv ke kf kg mw ki kj kk ha bi translated">在客户端，SSE提供了一个EventSource API，允许我们连接到服务器并从服务器接收更新。SSE有一个限制，即它一次只能支持六个并发连接。由于我们在每个浏览器选项卡中打开一个新的连接，这就限制了我们的用户一次只能打开六个选项卡。为了规避这个限制，我们使用了<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" rel="noopener ugc nofollow" target="_blank">共享工作者</a>。这使我们能够在SharedWorker中创建一个持久连接，并跨不同的浏览器选项卡和iframes访问它。shared workers的一个缺点是Safari和IE不支持它，但由于我们的大部分用户都使用Chrome和Firefox，这被认为是一个可以接受的解决方案。如果用户正在使用IE或Safari，我们就退回到SSE模型，那里只允许6个标签。</p><p id="1fff" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">当用户第一次登录时，一个新的共享工作者实例被实例化，然后被附加到窗口实例。然后可以在所有浏览器上下文中访问它。然后，Web页面可以使用MessagePort对象与共享工作器通信，并附加一个事件处理程序，每次共享工作器推送消息时都会调用该事件处理程序。</p><p id="f38c" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">github 中的<a class="ae jo" href="https://github.com/daichi-m/notification4J/blob/main/ui/recv-in-browser.js" rel="noopener ugc nofollow" target="_blank">代码片段包含了在浏览器中接收通知的代码。</a></p><h2 id="5021" class="me km hh bd kn mf mg mh kr mi mj mk kv jy ml mm kx kc mn mo kz kg mp mq lb mr bi translated">向用户显示通知</h2><p id="fd24" class="pw-post-body-paragraph jp jq hh jr b js ms ii ju jv mt il jx jy mu ka kb kc mv ke kf kg mw ki kj kk ha bi translated">每次打开新标签或浏览器窗口时，共享工作器都会为每个新标签分配一个端口号。这些端口号为每个用户保存在一个数组中。每当生成新通知时，它会被推送到所有端口，以使其在选项卡之间保持一致。在关闭选项卡时，会触发一个<code class="du nb nc nd ne b">beforeUnload</code>事件，在该事件中，我们会从阵列中删除相应的端口。</p><p id="34ec" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">为了只在用户在选项卡上活动时显示通知，我们处理由<a class="ae jo" href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" rel="noopener ugc nofollow" target="_blank">页面可见性API </a>公开的<code class="du nb nc nd ne b">visibilitychange</code>事件。处理程序将页面标记为非隐藏，然后用来自后端的通知刷新redux存储。这将触发对UI的呈现，并且通知将显示在snackbar中。</p></div><div class="ab cl ls lt go lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ha hb hc hd he"><h1 id="323d" class="kl km hh bd kn ko lz kq kr ks ma ku kv in mb io kx iq mc ir kz it md iu lb lc bi translated">连接后端和前端</h1><p id="ca3b" class="pw-post-body-paragraph jp jq hh jr b js ms ii ju jv mt il jx jy mu ka kb kc mv ke kf kg mw ki kj kk ha bi translated">该系统有两个部分协同工作来提供整个通知系统:</p><ol class=""><li id="8db2" class="le lf hh jr b js jt jv jw jy lg kc lh kg li kk lj lk ll lm bi translated">一组后端服务—生成通知并将它们保存到Redis</li><li id="66b8" class="le lf hh jr b js ln jv lo jy lp kc lq kg lr kk lj lk ll lm bi translated">UI负责向用户显示通知，或者在用户在线时实时显示，或者在用户在线时显示为错过的通知列表。</li></ol><h2 id="8d47" class="me km hh bd kn mf mg mh kr mi mj mk kv jy ml mm kx kc mn mo kz kg mp mq lb mr bi translated">后端到前端—通过Redis发布订阅</h2><p id="9637" class="pw-post-body-paragraph jp jq hh jr b js ms ii ju jv mt il jx jy mu ka kb kc mv ke kf kg mw ki kj kk ha bi translated">对于实时场景，UI需要在新的通知生成后立即得到提示。我们使用Redis PubSub创建从后端服务到UI服务器的反馈通道，然后通过HTML5 SSE与UI客户机(或用户的浏览器)通信，如前所述。</p><p id="4492" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">当生成通知并将通知写入用户的密钥时，库还会在特定的通道上生成一条PubSub消息，其中包含被修改的相应的user-id。UI服务器订阅给定的PubSub通道，并在接收到user-id时在其内存中构建一个通知映射。如果用户在线，UI服务器会在用户的SSE套接字上发送整个通知JSON映射，以便在浏览器中呈现。</p><p id="1cc5" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">下面给出了一个简单的序列图，展示了通知实例从在后端服务中生成到显示给用户的流程。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es ng"><img src="../Images/ab5cdd2919e805ea775e048b23823c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKQ7jFtPbDfx9n8wH-Jm_g.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Crude Sequence Diagram for the flow of Notifications</figcaption></figure><h2 id="cdf6" class="me km hh bd kn mf mg mh kr mi mj mk kv jy ml mm kx kc mn mo kz kg mp mq lb mr bi translated">前端到后端—通过REST</h2><p id="8b65" class="pw-post-body-paragraph jp jq hh jr b js ms ii ju jv mt il jx jy mu ka kb kc mv ke kf kg mw ki kj kk ha bi translated">一旦用户对通知做出响应(阅读、点击或删除)，信息就必须流向后端存储。我们将其实现为REST端点。</p><p id="2bf2" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这个库本身公开了一个Java API，它可以接受一个惟一的通知id、一个用户id和要更新的状态，并且它会用更新后的状态修补Redis中的通知。然后可以使用服务将这个API与REST或任何其他类似的(例如gRPC)端点包装在一起。</p><h1 id="9107" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">清理</h1><p id="a607" class="pw-post-body-paragraph jp jq hh jr b js ms ii ju jv mt il jx jy mu ka kb kc mv ke kf kg mw ki kj kk ha bi translated">为了清除Redis中过期和删除的通知，在库中使用了<a class="ae jo" href="http://www.quartz-scheduler.org/documentation/quartz-2.3.0/" rel="noopener ugc nofollow" target="_blank"> Quartz </a>调度程序。为了确保一次只有一个清理器实例运行，使用了<a class="ae jo" href="https://redis.io/topics/distlock" rel="noopener ugc nofollow" target="_blank">红锁算法</a>来创建分布式锁定机制。</p><h1 id="9b3a" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">把所有的放在一起</h1><p id="439a" class="pw-post-body-paragraph jp jq hh jr b js ms ii ju jv mt il jx jy mu ka kb kc mv ke kf kg mw ki kj kk ha bi translated">整个框架可以在https://github.com/daichi-m/notification4J<a class="ae jo" href="https://github.com/daichi-m/notification4J" rel="noopener ugc nofollow" target="_blank">的图书馆里找到。</a></p></div></div>    
</body>
</html>