<html>
<head>
<title>Android Studio Project Marble: Lint performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android Studio项目Marble: Lint性能</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-studio-project-marble-lint-performance-8baedbff2521?source=collection_archive---------4-----------------------#2019-04-12">https://medium.com/androiddevelopers/android-studio-project-marble-lint-performance-8baedbff2521?source=collection_archive---------4-----------------------#2019-04-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/84228505b5f0e96f504e878264c04ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSVp5F25p80BKCv0KPZVPQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://www.linkedin.com/in/potnisakshay" rel="noopener ugc nofollow" target="_blank">Akshay Potnis</a></figcaption></figure><div class=""/><div class=""><h2 id="5955" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">关于最近Lint性能修复的详细信息，以及我们制作的用于查明瓶颈的工具。</h2></div><p id="8ad1" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这是Android工作室团队深入了解大理石项目幕后细节的系列博客文章的第四篇。从发布<a class="ae hu" href="https://android-developers.googleblog.com/2019/01/android-studio-33.html" rel="noopener ugc nofollow" target="_blank"><em class="ki">Android Studio 3.3</em></a><em class="ki">开始，Project Marble是一个多版本，专注于打造IDE坚如磐石的基本功能。如果你错过了，我们已经在项目大理石上发布了以下博客:</em></p><ul class=""><li id="474b" class="kj kk hx jo b jp jq js jt jv kl jz km kd kn kh ko kp kq kr bi translated"><a class="ae hu" rel="noopener" href="/androiddevelopers/android-studio-project-marble-apply-changes-e3048662e8cd">项目大理石:应用更改</a></li><li id="8f63" class="kj kk hx jo b jp ks js kt jv ku jz kv kd kw kh ko kp kq kr bi translated"><a class="ae hu" rel="noopener" href="/androiddevelopers/improving-build-speed-in-android-studio-3e1425274837">提高Android Studio的构建速度</a></li><li id="ac17" class="kj kk hx jo b jp ks js kt jv ku jz kv kd kw kh ko kp kq kr bi translated"><a class="ae hu" rel="noopener" href="/androiddevelopers/android-emulator-project-marble-improvements-1175a934941e"> Android模拟器:Marble项目改进</a></li></ul><p id="bdfb" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><em class="ki">这篇博文是由从事Android Lint工作的工程师Matthew Gharrity撰写的。</em></p><p id="bcd3" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><a class="ae hu" href="https://developer.android.com/studio/write/lint" rel="noopener ugc nofollow" target="_blank"> Android Lint </a>是我们用于发现潜在代码问题的静态分析框架。您在IDE编辑器中看到的许多警告来自Lint，开发人员通常将Lint设置为在持续集成服务器上运行，以便在每次新代码更改时强制执行这些警告。Lint现在已经发展到数百个检测器，每个检测器都在寻找不同的潜在问题。</p><p id="dd8f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是，我们收到了强烈的反馈，Lint可能会很慢——尤其是在CI服务器上分析大型代码库的时候。因此，本着“大理石计划”的精神，我们对Lint的性能以及如何改进进行了调查。在这篇博文中，我们将解释我们如何修复一些顶级性能问题的技术细节——在Studio 3.3中实现了大约2倍的加速——我们甚至会提供一个开源工具，您可以使用它来查明您自己构建中的Lint性能瓶颈。</p><h1 id="3089" class="kx ky hx bd kz la lb lc ld le lf lg lh jd li je lj jg lk jh ll jj lm jk ln lo bi translated">低垂的果实</h1><p id="8204" class="pw-post-body-paragraph jm jn hx jo b jp lp iy jr js lq jb ju jv lr jx jy jz ls kb kc kd lt kf kg kh ha bi translated">首先，Studio 3.3的一些性能修复是普通挖掘CPU配置文件和堆转储的结果。我们要感谢Twitter上的<a class="ae hu" href="https://twitter.com/cesardielo" rel="noopener ugc nofollow" target="_blank">塞萨尔·普尔塔</a>提供了Lint经历极端减速的可再现实例，并让我们在现场用一个剖析器进行挖掘。这种协作导致了一些关键的修正:</p><ul class=""><li id="2fb0" class="kj kk hx jo b jp jq js jt jv kl jz km kd kn kh ko kp kq kr bi translated">我们修复了一个Lint检查中的内存泄漏，其中一个匿名内部类意外捕获了对一些Lint数据结构的引用。</li><li id="fdd3" class="kj kk hx jo b jp ks js kt jv ku jz kv kd kw kh ko kp kq kr bi translated">我们修复了从Gradle运行Lint时的内存泄漏，其中用于运行Lint的自定义类加载器通过线程局部变量和JNI全局引用保留。</li><li id="fa45" class="kj kk hx jo b jp ks js kt jv ku jz kv kd kw kh ko kp kq kr bi translated">我们修复了Lint在同一个Gradle守护进程中多次运行时造成的额外类加载。</li></ul><p id="4b2f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">仅这些修复就让我们在内部Lint性能基准测试中获得了3倍的速度提升，在Twitter的代码库上获得了大约2倍的速度提升。添加内存泄漏回归测试是为了防止将来出现类似的错误。</p><h1 id="79ad" class="kx ky hx bd kz la lb lc ld le lf lg lh jd li je lj jg lk jh ll jj lm jk ln lo bi translated">查明瓶颈的工具</h1><p id="9d36" class="pw-post-body-paragraph jm jn hx jo b jp lp iy jr js lq jb ju jv lr jx jy jz ls kb kc kd lt kf kg kh ha bi translated">接下来，我们开始寻找单个棉绒检测器中的瓶颈。有一些挑战。</p><ul class=""><li id="450c" class="kj kk hx jo b jp jq js jt jv kl jz km kd kn kh ko kp kq kr bi translated">Lint中没有每个检测器的性能属性——添加这个属性可能会很棘手。例如，Lint在单次通过每个源文件时，在数百个不同的检测器之间进行多路复用。将所有可能的调用路径包装到检测器代码中可能容易出错，并且会污染我们的源代码。</li><li id="ae41" class="kj kk hx jo b jp ks js kt jv ku jz kv kd kw kh ko kp kq kr bi translated">在Lint上使用传统的分析器工作得很好，但是挖掘结果非常耗时并且难以自动化。工程时间是有限的，所以实际上这限制了我们可以测试的样本项目的数量。然而，对各种各样的样本项目进行测试是至关重要的，因为一些性能瓶颈只出现在特定的项目拓扑上。</li><li id="87f2" class="kj kk hx jo b jp ks js kt jv ku jz kv kd kw kh ko kp kq kr bi translated">即使有时间来挖掘分析器结果，CPU跟踪也会有开销问题，甚至<a class="ae hu" href="http://jeremymanson.blogspot.com/2010/07/why-many-profilers-have-serious.html" rel="noopener ugc nofollow" target="_blank">安全点偏差</a>也与CPU采样有关。</li><li id="de1c" class="kj kk hx jo b jp ks js kt jv ku jz kv kd kw kh ko kp kq kr bi translated">开发人员可以编写他们自己的定制Lint检查，因此任何在我们的内部检查中寻找瓶颈的手工工作对于在第三方检查中寻找瓶颈都没有帮助。</li></ul><p id="7995" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">考虑到这些因素，我们创建了一个工具来帮助自动查明各个Lint检查中的性能问题。该工具依靠Java字节码插装在感兴趣的方法之前和之后注入代码。这个想法很简单:我们使用一个正则表达式来查找与Lint检测器相关联的所有方法，只检测那些方法来收集计时信息，然后将计时信息返回给相关联的Lint检测器。然后可以将结果打印到控制台。</p><p id="b67c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了插装Java字节码，我们使用了<a class="ae hu" href="https://www.yourkit.com/docs/java/help/probe_class.jsp" rel="noopener ugc nofollow" target="_blank"> YourKit探测器</a>，尽管也可能使用其他插装代理。</p><p id="52d4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">应用这个工具就像给Gradle添加一个JVM标志一样简单，所以我们能够非常快速地在大量项目中使用这个工具。大多数项目的结果看起来都很正常。然而，一个值得注意的例外是一个名为<a class="ae hu" href="https://github.com/kageiit/android-studio-gradle-test" rel="noopener ugc nofollow" target="_blank">Android-studio-grad le-test</a>的开源压力测试项目。以下是原始结果:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="032f" class="md ky hx lz b fi me mf l mg mh">Number of probe hits: 4720354<br/>Total time in LintDriver.analyze(): 221482ms<br/>Total time inside detectors: 177446ms</span><span id="a5cf" class="md ky hx lz b fi mi mf l mg mh">            InvalidPackageDetector 176853ms<br/>               MergeMarkerDetector 363ms<br/>                    GradleDetector 38ms<br/>                PrivateKeyDetector 27ms<br/>  TrustAllX509TrustManagerDetector 25ms<br/>            CordovaVersionDetector 18ms<br/>            UnusedResourceDetector 13ms<br/>                  ManifestDetector 12ms<br/>              MissingClassDetector 10ms<br/>                             [...]</span></pre><p id="4cde" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这个项目中，<code class="du mj mk ml lz b">InvalidPackageDetector</code>占用了皮棉分析的绝大部分时间！对于上下文，该检测器检查对Android不支持的Java语言API的调用。经过进一步的调查，我们发现在某些情况下<code class="du mj mk ml lz b">InvalidPackageDetector</code>会多次扫描jar文件，这可能会成为有许多模块和二进制依赖项的项目的瓶颈。修复很简单，这个项目的速度提高了4倍。在Twitter的代码库上，这个修复导致了16%的速度提升。</p><p id="6840" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这个瓶颈在传统的分析器中也是显而易见的。然而，如果没有自动化工具的帮助，我们可能永远不会有时间去调查足够多的项目来找到一个使瓶颈变得明显的项目。</p><h2 id="b191" class="md ky hx bd kz mm mn mo ld mp mq mr lh jv ms mt lj jz mu mv ll kd mw mx ln my bi translated">剖析内存分配以查找冗余计算</h2><p id="9040" class="pw-post-body-paragraph jm jn hx jo b jp lp iy jr js lq jb ju jv lr jx jy jz ls kb kc kd lt kf kg kh ha bi translated">性能调试就是收集数据并寻找令人惊讶的结果。在我们的例子中，收集的数据是每个检测器的时间信息，令人惊讶的是一些检测器花费的时间比预期的要多。然而，另一个很好的跟踪指标是内存分配。如果检测器分配的内存比预期的多，这可能是检测器正在进行冗余计算的信号——即使检测器碰巧运行得相对较快。</p><p id="c016" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因此，我们将YourKit探针与<a class="ae hu" href="https://github.com/google/allocation-instrumenter" rel="noopener ugc nofollow" target="_blank">内存分配工具</a>结合起来，以便将内存分配归属于各个Lint检测器。下面是在上面的同一个测试项目中这样做的原始结果。</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="4c98" class="md ky hx lz b fi me mf l mg mh">Total allocations within detectors: 262 MB<br/>  MergeMarkerDetector 240 MB<br/>   PrivateKeyDetector 7 MB<br/>       GradleDetector 6 MB<br/>    AndroidTvDetector 2 MB<br/>                [...]</span></pre><p id="f86f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">结果立刻使<code class="du mj mk ml lz b">MergeMarkerDetector</code>产生了怀疑。对于上下文，该检测器寻找git风格的合并标记，例如意外遗留在源代码中的<code class="du mj mk ml lz b">&lt;&lt;&lt;&lt;&lt;&lt;</code>。经过进一步调查，我们发现<code class="du mj mk ml lz b">MergeMarkerDetector</code>偶尔也会查看非源文件，对于某些项目来说，这可能包括任意大的二进制文件。修复很简单，最好的部分是我们不需要找到这个bug成为明显的性能问题的项目——分配信息足以让我们走上正确的道路。</p><h2 id="a718" class="md ky hx bd kz mm mn mo ld mp mq mr lh jv ms mt lj jz mu mv ll kd mw mx ln my bi translated">关于YourKit探针的详细信息</h2><p id="d34a" class="pw-post-body-paragraph jm jn hx jo b jp lp iy jr js lq jb ju jv lr jx jy jz ls kb kc kd lt kf kg kh ha bi translated">我们写的YourKit探测器是在GitHub 上<a class="ae hu" href="https://github.com/google/android-lint-performance-probe" rel="noopener ugc nofollow" target="_blank">开源的；请随意使用它，并为您自己的自定义皮棉检查添加覆盖范围！<code class="du mj mk ml lz b">README</code>解释了如何指向您的本地YourKit安装，如何生成检测Lint调用所需的JVM参数，以及如何解释工具打印出的结果。</a></p><p id="4ca8" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">请注意，探测器在查找Lint性能问题时存在一些限制:</p><ul class=""><li id="1a7b" class="kj kk hx jo b jp jq js jt jv kl jz km kd kn kh ko kp kq kr bi translated">该探针目前依赖于与您的工具包捆绑在一起的Java byte code instrumentation代理，它不是一个免费的分析器(尽管有一个免费的试用版)。原则上，该工具可以适用于使用替代的工具代理。</li><li id="bc56" class="kj kk hx jo b jp ks js kt jv ku jz kv kd kw kh ko kp kq kr bi translated">有相当大量的前期计算，例如解析和类型属性，这不能归因于任何单独的Lint检测器。如果在这个预计算阶段存在性能问题，探测器将无法找到它。</li><li id="e556" class="kj kk hx jo b jp ks js kt jv ku jz kv kd kw kh ko kp kq kr bi translated">缓存效应可能会扭曲单个检测器的性能数据。例如，第一次运行Lint检查可能会导致在第一次解析调用时发生的初始缓存未命中。</li></ul><h1 id="e58b" class="kx ky hx bd kz la lb lc ld le lf lg lh jd li je lj jg lk jh ll jj lm jk ln lo bi translated">包扎</h1><p id="92d5" class="pw-post-body-paragraph jm jn hx jo b jp lp iy jr js lq jb ju jv lr jx jy jz ls kb kc kd lt kf kg kh ha bi translated">上面描述的Lint性能改进已经在Studio 3.3中实现，我们将继续监控Lint性能以捕捉回归。如果您在自己的项目中运行Lint时遇到了重大的性能问题，请先查看我们的Lint <a class="ae hu" href="https://groups.google.com/d/msg/lint-dev/RGTvK_uHQGQ/FjJA12aGBAAJ" rel="noopener ugc nofollow" target="_blank">性能提示</a>。如果这没有帮助，请随意<a class="ae hu" href="https://issuetracker.google.com/issues/new?component=192718&amp;template=842813" rel="noopener ugc nofollow" target="_blank">提交一个bug </a>，并考虑用我们的YourKit探针附上运行Lint的结果。如果您对Lint有一般性的问题或建议，我们还有<a class="ae hu" href="https://groups.google.com/d/forum/lint-dev" rel="noopener ugc nofollow" target="_blank"> lint-dev邮件列表</a>。</p></div></div>    
</body>
</html>