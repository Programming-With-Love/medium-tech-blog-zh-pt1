<html>
<head>
<title>The Hidden Power of ES6 Generators: Observable Async Flow Control</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES6发电机的隐藏能量:可观测的异步流量控制</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/the-hidden-power-of-es6-generators-observable-async-flow-control-cfa4c7f31435?source=collection_archive---------1-----------------------#2016-05-21">https://medium.com/javascript-scene/the-hidden-power-of-es6-generators-observable-async-flow-control-cfa4c7f31435?source=collection_archive---------1-----------------------#2016-05-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d8fc260306f356c37b4d313c39be49f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PTRbkX1BYeEAovhPC7-bCg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The turbine room of the Volga Hydroelectric Station — Kent Kanouse (CC BY-NC 2.0)</figcaption></figure><p id="68b9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在<a class="ae jr" rel="noopener" href="/javascript-scene/7-surprising-things-i-learned-writing-a-fibonacci-generator-4886a5c87710"> 7用JavaScript </a>编写斐波那契生成器时我学到的令人惊讶的事情中，我介绍了ES6生成器函数的一个明显的用例:一次生成一个值的可迭代序列。如果你还没有读过，你应该读一读。Iterables是ES6+中许多东西的基础，理解它们是如何工作的对你来说很重要。</p><p id="64c6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但是在那篇文章中，我有意回避了生成器的另一个主要用例。可以说，主要用例:异步流控制。</p><h2 id="eead" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">异步/等待</h2><p id="910a" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">您可能听说过尚未正式成为JavaScript标准的async/await提案。</p><p id="39ac" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">它没有进入ES6。它不会进入ES2016。它<em class="ks">可能</em>在ES2017中成为标准，然后我们需要等待所有的JS引擎实现落地，然后才能使用它。<em class="ks">(注意:现在在巴别塔也能工作，但不能保证。尾部调用优化在Babel中工作了几个月，但随后被删除)。</em></p><p id="65c8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">尽管有等待，你仍然会找到一堆关于async/await的文章。为什么？</p><p id="7f80" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">它可以把代码变成这样:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="73b7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">变成这样的代码:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="03a7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注意，在第一个版本中，我们的基于承诺的函数有一个额外的嵌套层。async/await版本看起来像常规的同步代码，但它不是。它产生承诺并退出函数，释放JS引擎去做其他事情，并且当来自<em class="ks"> `fetchSomething()` </em>的承诺解析时，函数恢复，并且将解析的承诺值赋给<em class="ks"> `result`。</em></p><p id="b38a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="ks">看起来和感觉上同步的是异步代码。对于每天进行大量异步编程的JavaScript程序员来说，这基本上是一个圣杯:异步代码的所有性能优势，而没有认知开销。</em></p><p id="e417" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我想深入探讨的是async / await如何在幕后使用生成器……以及如何在不等待async / await到来的情况下，现在就将它们用于同步风格的流控制。</p><h2 id="b9dc" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">发电机评论</h2><p id="753f" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">生成器函数是ES6中的一个新特性，它允许函数通过返回一个对象来<em class="ks">随时间生成许多值</em>，该对象可以用一个<em class="ks"> `.next()` </em>方法迭代iterable，该方法返回这样的对象:</p><pre class="kt ku kv kw fd kz la lb lc aw ld bi"><span id="ab08" class="js jt hh la b fi le lf l lg lh">{<br/>  value: Any,<br/>  done: Boolean<br/>}</span></pre><p id="030f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="ks"> `done` </em>属性表示生成器是否已经生成了它的最后一个值。</p><p id="cb50" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">JavaScript中的很多东西都使用迭代器协议，包括新的<em class="ks"> `for…of` </em>循环、数组rest/spread操作符等等。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="kx ky l"/></div></figure><h2 id="d226" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">与发电机对话</h2><p id="d73c" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">这就是事情变得真正有趣的地方。与发电机的通信可以双向进行。除了从生成器接收值之外，还可以将值注入到生成器函数中。迭代器<em class="ks"> `.next()` </em>方法可以接受要赋值的值。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="kx ky l"/></div></figure><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="li ky l"/></div></figure><p id="2f75" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">还有一些其他方法可以与发电机通信。你可以向他们抛出错误。除了调用next，您还可以调用<em class="ks"> `iter.throw(error)`，(例如，</em>)来通知为生成器获取数据时出错。还可以用<em class="ks"> `iter.return()` </em>强制生成器返回。</p><p id="bd3b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这两者都可以方便地将错误处理添加到流控制代码中。</p><h2 id="83b1" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">发电机+承诺=圣杯</h2><p id="183b" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">如果有一个函数包装生成器，可以检测您何时做出承诺，等待它解析，然后通过后续的<em class="ks"> `.next()` </em>调用将解析的值传递回生成器，会怎么样？</p><p id="101e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然后，您可以像这样编写异步/等待样式的代码:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="3de7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">事实证明，这样的图书馆已经存在。叫<a class="ae jr" href="https://github.com/tj/co" rel="noopener ugc nofollow" target="_blank"> <strong class="iv hi"> Co.js </strong> </a>。但是，与其教你如何使用Co，不如让我们试着想出如何自己写这样的东西。看看上面的<em class="ks"> `crossBridge()` </em>例子，看起来应该很简单。</p><p id="2471" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们将从一个简单的<em class="ks"> `isPromise()` </em>函数开始:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="c011" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">接下来，我们需要一种方法来迭代生成器的<em class="ks"> `.next()` </em>调用，解开承诺，并等待它们解决，然后再次调用<em class="ks"> `.next()` </em>。这里有一个没有错误处理的简单方法。这只是一个想法的演示。您不希望在生产中使用它—您的错误会被掩盖，并且很难调试正在发生的事情:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="47cd" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如您所见，我们正在传递一个回调函数来返回最终值。我们通过将先前的值传递到函数顶部的<em class="ks"> `.next()` </em>调用中来与生成器通信。这使我们能够将前面的<em class="ks"> `yield` </em>调用的结果分配给标识符:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="c1aa" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当然，这些都没有用，直到你把它全部踢开——那么真正返回最终值的承诺呢？</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="5152" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们一起来看看所有的内容…除了使用示例，整个内容大约有22行代码:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="b4e6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在，如果你想在你的代码中开始使用这种技术，一定要使用<a class="ae jr" href="https://github.com/tj/co" rel="noopener ugc nofollow" target="_blank"> Co.js </a>来代替。它有您需要的错误处理功能(我只是跳过了这一步，以避免混淆示例)，它经过了生产测试，并且它还有其他一些不错的特性。</p><h2 id="ff59" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">从承诺到观察</h2><p id="791b" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">上面的例子很有趣，Co.js对于简化异步流控制确实很有用。只有一个问题:它返回一个承诺。正如你可能意识到的，<strong class="iv hi"> <em class="ks">一个承诺只能发出一个值或者拒绝……</em></strong></p><p id="42a8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">随着时间的推移，发生器能够发出<strong class="iv hi"> <em class="ks">多种值。随着时间的推移，我们还知道什么可以产生许多值？一个<strong class="iv hi">可观测的</strong>。你可能还记得我在用JavaScript编写斐波那契生成器时学到的7件令人惊讶的事情:</em></strong></p><blockquote class="lj lk ll"><p id="2f5e" class="it iu ks iv b iw ix iy iz ja jb jc jd lm jf jg jh ln jj jk jl lo jn jo jp jq ha bi translated">最初，我对生成器非常感兴趣，但是现在我已经和它们一起生活了一段时间，在我真正的应用程序代码中，我还没有发现很多好的生成器用例。对于我可能使用生成器的大多数用例，我选择了RxJS，因为它有更丰富的API。</p></blockquote><p id="72eb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">因为<em class="ks">(不像生成器函数)</em>一个承诺只能发出一个值，而<em class="ks">(像生成器函数)</em>一个可观察对象可以发出多个值，我个人认为可观察API比承诺更适合异步函数。</p><p id="cff4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">什么是可观察的？</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lp"><img src="../Images/173f0fba77a0bde187c1782d6c1d215b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ZdFWFlA9dSRCv2naCjihA.png"/></div></div></figure><p id="1d22" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">上表来自克里斯·科瓦尔的《GTOR:反应性的一般理论》。它在空间和时间上把事情分解得很清楚。可以同步拉取的值会占用空间(内存中的值)，但与时间无关。分别是<strong class="iv hi"> <em class="ks">拉API</em></strong>。</p><p id="7759" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">依赖于某个时间事件的值不能被同步消耗。在消费这些价值之前，您必须等待它们产生出来。这样的值就是<strong class="iv hi"> <em class="ks">推送API</em></strong>，并且总是有某种订阅或者通知机制。在JavaScript中，这通常采用回调函数的形式。</p><p id="dda7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在处理未来值时，您需要在值可用时得到通知。就是这个<strong class="iv hi"> <em class="ks">推</em> </strong>。</p><p id="2a88" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">承诺是一种推送机制，它在承诺被解析或用单个值拒绝后调用一些代码。</p><p id="8d4c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一个可观察值就像一个承诺，但是每当一个新值变得可用时它就调用一些代码，并且随着时间的推移<em class="ks">可以发出许多值</em>。</p><p id="9be0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">可观察对象的核心特性是一个<em class="ks"> `.subscribe()` </em>方法，它采用三个值:</p><ul class=""><li id="9d43" class="lq lr hh iv b iw ix ja jb je ls ji lt jm lu jq lv lw lx ly bi translated"><strong class="iv hi">上一次</strong> —每次被观察对象发出一个值时调用。</li><li id="4bc7" class="lq lr hh iv b iw lz ja ma je mb ji mc jm md jq lv lw lx ly bi translated"><strong class="iv hi"> onError </strong> —当可观察对象遇到错误或无法生成要发出的数据时调用。出错后，将不会发出更多的值，也不会调用<em class="ks"> `onCompleted` </em>。</li><li id="c4bf" class="lq lr hh iv b iw lz ja ma je mb ji mc jm md jq lv lw lx ly bi translated"><strong class="iv hi"> onCompleted </strong> —在最后一次调用<em class="ks"> `onNext` </em>之后调用，但前提是没有遇到错误。</li></ul><p id="474c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">因此，如果我们想为同步风格的异步函数实现一个可观察的API，我们只需要一种传入这些参数的方法。让我们试一试，把<em class="ks"> `onError` </em>留到以后:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="8b06" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我真的很喜欢这个版本，因为它给我的感觉是多功能的。事实上，我非常喜欢它，我对它进行了一些充实，将其重命名为Ogen，添加了错误处理和一个真正的Rx Observable对象(这意味着您可以随心所欲地使用<em class="ks"> `.map()` </em>、<em class="ks"> `.filter()` </em>和<em class="ks"> `.skip()` </em>)。<a class="ae jr" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/main/rx.md#observable-instance-methods" rel="noopener ugc nofollow" target="_blank">除了别的事情之外</a>。</p><p id="d7d4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在GitHub 上查看<a class="ae jr" href="https://github.com/ericelliott/ogen" rel="noopener ugc nofollow" target="_blank"> Ogen。</a></p><p id="8fc7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">observables有很多方法可以改进您的异步流控制，这可能是我很少使用生成器的主要原因，但是现在我可以用Ogen无缝地混合和匹配同步风格的代码和observables，也许我会开始更多地使用生成器。</p></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><h1 id="d4a1" class="ml jt hh bd ju mm mn mo jy mp mq mr kc ms mt mu kf mv mw mx ki my mz na kl nb bi translated">与埃里克·艾略特一起学习JavaScript】</h1></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><p id="fbf9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="ks">埃里克·埃利奥特</em> </strong> <em class="ks">著有</em> <a class="ae jr" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="ks">【编程JavaScript应用】</em> </a> <em class="ks">(奥赖利)，以及</em> <a class="ae jr" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank"> <em class="ks">【跟埃里克·埃利奥特学JavaScript】</em></a><em class="ks">。他曾为</em><strong class="iv hi"><em class="ks">Adobe Systems</em></strong><em class="ks"/><strong class="iv hi"><em class="ks">Zumba Fitness</em></strong><em class="ks"/><strong class="iv hi"><em class="ks">华尔街日报、</em></strong><em class="ks"/><strong class="iv hi"><em class="ks">BBC</em></strong><em class="ks">等顶级录音师和Usher</em><strong class="iv hi"><em class="ks"/></strong></p><p id="61a2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>