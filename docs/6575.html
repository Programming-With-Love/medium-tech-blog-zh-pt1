<html>
<head>
<title>Unclosuring closures and introducing Dependency Injection in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中打开闭包并引入依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/unclosuring-closures-and-introducing-dependency-injection-in-javascript-3b6673d21862?source=collection_archive---------3-----------------------#2019-02-18">https://medium.com/quick-code/unclosuring-closures-and-introducing-dependency-injection-in-javascript-3b6673d21862?source=collection_archive---------3-----------------------#2019-02-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/f17c40cfec081fa7bbbe66177768d210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7c2jxtacI7Ywnb3I3QS2CQ.png"/></div></div></figure><p id="4a61" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我们将考虑如何使用依赖注入编程模式，以函数风格编写清晰且易于测试的代码。作为奖励，我们还实现了100%的单元测试覆盖率。</p><h1 id="14a2" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">术语</h1><p id="e019" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">这篇文章的作者将准确地记住以下术语的这种解释，理解这不是最终的真理，其他解释也是可能的。</p><p id="b0c4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">- <strong class="ir hi">依赖注入</strong> <br/>这是一种编程模式，假设函数和对象工厂的外部依赖来自外部，以这些函数的参数的形式。依赖注入是使用来自全局上下文的依赖的替代方法。</p><p id="f1dd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">- <strong class="ir hi">纯函数</strong> <br/>这是一个结果只取决于其自变量的函数。此外，该功能不应有副作用。<br/>马上我要说一句，我们所考虑的副作用的功能是没有的，但是它们仍然可以有通过依赖注入来到我们身边的功能。所以文章中函数的纯粹性是有条件的。</p><p id="a991" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">- <strong class="ir hi">单元测试</strong> <br/>对函数的测试，检查该函数内的所有分支是否完全按照代码作者的意图工作。在这种情况下，不调用任何其他函数，而是使用模拟调用。</p><h1 id="2054" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">实践</h1><p id="be6d" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">让我们看一个活生生的例子——计数器工厂。计数器随着每一次滴答而递增，并且可以通过<code class="du kq kr ks kt b">cancel</code>函数调用来停止。当滴答发生时，调用<code class="du kq kr ks kt b">onTick</code>回调。</p><pre class="ku kv kw kx fd ky kt kz la aw lb bi"><span id="1c5b" class="lc jo hh kt b fi ld le l lf lg">const createCounter = ({ ticks, onTick }) =&gt; {<br/>  const state = {<br/>    currentTick: 1,<br/>    timer: null,<br/>    canceled: false<br/>  }</span><span id="97ac" class="lc jo hh kt b fi lh le l lf lg">  const cancel = () =&gt; {<br/>    if (state.canceled) {<br/>      throw new Error(‘“Counter” already canceled’)<br/>    }<br/>    clearInterval(state.timer)<br/>  }</span><span id="1cce" class="lc jo hh kt b fi lh le l lf lg">  const onInterval = () =&gt; {<br/>    onTick(state.currentTick++)<br/>    if (state.currentTick &gt; ticks) {<br/>      cancel()<br/>    }<br/>  }</span><span id="4077" class="lc jo hh kt b fi lh le l lf lg">  state.timer = setInterval(onInterval, 200)</span><span id="3df5" class="lc jo hh kt b fi lh le l lf lg">  const instance = {<br/>    cancel<br/>  }</span><span id="ed95" class="lc jo hh kt b fi lh le l lf lg">  return instance<br/>}</span><span id="822f" class="lc jo hh kt b fi lh le l lf lg">export default createCounter</span></pre><p id="67af" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们看到人类可读、可理解的代码。但是有一个问题——你不能对它编写普通的单元测试。让我们看看是什么阻止了你？</p><p id="819a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1)内部函数<code class="du kq kr ks kt b">cancel</code>和<code class="du kq kr ks kt b">onInterval</code>不能从要独立测试的单元测试中访问</p><p id="db0a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2)函数<code class="du kq kr ks kt b">onInterval</code>不能独立于“取消”进行测试，因为第一个函数直接引用第二个函数</p><p id="f073" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3)函数<code class="du kq kr ks kt b">setInterval</code>和<code class="du kq kr ks kt b">clearInterval</code>中使用了外部相关性</p><p id="9d46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">4)由于直接引用的存在，函数<code class="du kq kr ks kt b">createCounter</code>不能独立测试</p><p id="d4e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们通过从闭包中提取<code class="du kq kr ks kt b">cancel</code>和<code class="du kq kr ks kt b">onInterval</code>函数来解决第一个和第二个问题，并通过引入额外的对象<code class="du kq kr ks kt b">pool</code>来分解直接引用。</p><pre class="ku kv kw kx fd ky kt kz la aw lb bi"><span id="a87f" class="lc jo hh kt b fi ld le l lf lg">// index.js<br/>export const cancel = pool =&gt; {<br/>  if (pool.state.canceled) {<br/>    throw new Error(‘“Counter” already canceled’)<br/>  }<br/>  clearInterval(pool.state.timer)<br/>}</span><span id="150f" class="lc jo hh kt b fi lh le l lf lg">export const onInterval = pool =&gt; {<br/>  pool.config.onTick(pool.state.currentTick++)<br/>  if (pool.state.currentTick &gt; pool.config.ticks) {<br/>    pool.cancel()<br/>  }<br/>}</span><span id="1ee7" class="lc jo hh kt b fi lh le l lf lg">const createCounter = config =&gt; {<br/>  const pool = {<br/>    config,<br/>    state: {<br/>      currentTick: 1,<br/>      timer: null,<br/>      canceled: false<br/>    }<br/>  }</span><span id="49b3" class="lc jo hh kt b fi lh le l lf lg">  pool.cancel = cancel.bind(null, pool)<br/>  pool.onInterval = onInterval.bind(null, pool)</span><span id="8517" class="lc jo hh kt b fi lh le l lf lg">  pool.state.timer = setInterval(pool.onInterval, 200)</span><span id="2e13" class="lc jo hh kt b fi lh le l lf lg">  const instance = {<br/>    cancel: pool.cancel<br/>  }</span><span id="9ece" class="lc jo hh kt b fi lh le l lf lg">  return instance<br/>}</span><span id="e5b6" class="lc jo hh kt b fi lh le l lf lg">export default createCounter</span></pre><p id="78d8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们解决第三个问题。通过使用依赖注入模式，外部依赖<code class="du kq kr ks kt b">setInterval</code>和<code class="du kq kr ks kt b">clearInterval</code>也可以在对象<code class="du kq kr ks kt b">pool</code>中移动。</p><pre class="ku kv kw kx fd ky kt kz la aw lb bi"><span id="f2c8" class="lc jo hh kt b fi ld le l lf lg">// index.js<br/>export const cancel = pool =&gt; {<br/>  const { clearInterval } = pool<br/>  if (pool.state.canceled) {<br/>    throw new Error(‘“Counter” already canceled’)<br/>  }<br/>  clearInterval(pool.state.timer)<br/>}</span><span id="9fc0" class="lc jo hh kt b fi lh le l lf lg">export const onInterval = pool =&gt; {<br/>  pool.config.onTick(pool.state.currentTick++)<br/>  if (pool.state.currentTick &gt; pool.config.ticks) {<br/>    pool.cancel()<br/>  }<br/>}</span><span id="2f3e" class="lc jo hh kt b fi lh le l lf lg">const createCounter = (dependencies, config) =&gt; {<br/>  const pool = {<br/>    ...dependencies,<br/>    config,<br/>    state: {<br/>      currentTick: 1,<br/>      timer: null,<br/>      canceled: false<br/>    }<br/>  }<br/>  pool.cancel = cancel.bind(null, pool)<br/>  pool.onInterval = onInterval.bind(null, pool)</span><span id="6c16" class="lc jo hh kt b fi lh le l lf lg">  const { setInterval } = pool</span><span id="6b7a" class="lc jo hh kt b fi lh le l lf lg">  pool.state.timer = setInterval(pool.onInterval, 200)</span><span id="9779" class="lc jo hh kt b fi lh le l lf lg">  const instance = {<br/>    cancel: pool.cancel<br/>  }</span><span id="5646" class="lc jo hh kt b fi lh le l lf lg">  return instance<br/>}</span><span id="35cf" class="lc jo hh kt b fi lh le l lf lg">export default createCounter.bind(null, {<br/>  setInterval,<br/>  clearInterval<br/>})</span></pre><p id="20ac" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，几乎一切都好了，但是还有第四个问题。在最后一步中，我们将对我们的每个函数应用依赖注入，并通过“pool”对象打破它们之间的其余引用。同时，我们将一个大文件分割成许多文件，这样以后编写单元测试就更容易了。</p><pre class="ku kv kw kx fd ky kt kz la aw lb bi"><span id="e7bf" class="lc jo hh kt b fi ld le l lf lg">// index.js<br/>import { createCounter } from ‘./create-counter’<br/>import { cancel } from ‘./cancel’<br/>import { onInterval } from ‘./on-interval’</span><span id="f0a6" class="lc jo hh kt b fi lh le l lf lg">export default createCounter.bind(null, {<br/>  cancel,<br/>  onInterval,<br/>  setInterval,<br/>  clearInterval<br/>})</span><span id="6d6b" class="lc jo hh kt b fi lh le l lf lg"><br/>// create-counter.js<br/>export const createCounter = (dependencies, config) =&gt; {<br/>  const pool = {<br/>    ...dependencies,<br/>    config,<br/>    state: {<br/>      currentTick: 1,<br/>      timer: null,<br/>      canceled: false<br/>    }<br/>  }</span><span id="08c5" class="lc jo hh kt b fi lh le l lf lg">  pool.cancel = dependencies.cancel.bind(null, pool)<br/>  pool.onInterval = dependencies.onInterval.bind(null, pool)</span><span id="9a53" class="lc jo hh kt b fi lh le l lf lg">  const { setInterval } = pool</span><span id="5312" class="lc jo hh kt b fi lh le l lf lg">  pool.state.timer = setInterval(pool.onInterval, 200)</span><span id="be61" class="lc jo hh kt b fi lh le l lf lg">  const instance = {<br/>    cancel: pool.cancel<br/>  }</span><span id="6d22" class="lc jo hh kt b fi lh le l lf lg">  return instance<br/>}</span><span id="442c" class="lc jo hh kt b fi lh le l lf lg"><br/>// on-interval.js<br/>export const onInterval = pool =&gt; {<br/>  pool.config.onTick(pool.state.currentTick++)<br/>  if (pool.state.currentTick &gt; pool.config.ticks) {<br/>    pool.cancel()<br/>  }<br/>}</span><span id="15f7" class="lc jo hh kt b fi lh le l lf lg"><br/>// cancel.js<br/>export const cancel = pool =&gt; {<br/>  const { clearInterval } = pool</span><span id="e0b7" class="lc jo hh kt b fi lh le l lf lg">  if (pool.state.canceled) {<br/>    throw new Error(‘“Counter” already canceled’)<br/>  }<br/>  clearInterval(pool.state.timer)<br/>}</span></pre><h1 id="4951" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="62a2" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">结论是什么？一堆文件，每个文件包含一个清理函数。代码的简单性和清晰性略有下降，但是这被单元测试中100%的覆盖率所抵消。</p><figure class="ku kv kw kx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es li"><img src="../Images/c5a8020dcfb7412cc207f7675361dc77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*8n2_Qq8E6hOGVSEkBUjdpA.png"/></div></div></figure><p id="48ba" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我还想指出的是，我们不需要用“require”做任何操作，也不需要模仿Node.js文件系统来编写单元测试。</p><h1 id="916f" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">单元测试</h1><pre class="ku kv kw kx fd ky kt kz la aw lb bi"><span id="0c44" class="lc jo hh kt b fi ld le l lf lg">// cancel.test.js<br/>import { cancel } from ‘../src/cancel’</span><span id="81c6" class="lc jo hh kt b fi lh le l lf lg">describe(‘method “cancel”’, () =&gt; {<br/>  test(‘should stop the counter’, () =&gt; {<br/>    const state = {<br/>      canceled: false,<br/>      timer: 42<br/>    }<br/>    const clearInterval = jest.fn()<br/>    const pool = {<br/>      state,<br/>      clearInterval<br/>    }</span><span id="ef09" class="lc jo hh kt b fi lh le l lf lg">    cancel(pool)</span><span id="5b21" class="lc jo hh kt b fi lh le l lf lg">    expect(clearInterval).toHaveBeenCalledWith(pool.state.timer)<br/>  })</span><span id="d187" class="lc jo hh kt b fi lh le l lf lg">  test(‘should throw error: “Counter” already canceled’, () =&gt; {<br/>    const state = {<br/>      canceled: true,<br/>      timer: 42<br/>    }<br/>    const clearInterval = jest.fn()<br/>    const pool = {<br/>      state,<br/>      clearInterval<br/>    }</span><span id="f88b" class="lc jo hh kt b fi lh le l lf lg">    expect(() =&gt; cancel(pool)).toThrow(‘“Counter” already canceled’)</span><span id="307b" class="lc jo hh kt b fi lh le l lf lg">    expect(clearInterval).not.toHaveBeenCalled()<br/>  })<br/>})<br/></span><span id="8a57" class="lc jo hh kt b fi lh le l lf lg">// create-counter.test.js<br/>import { createCounter } from ‘../src/create-counter’</span><span id="0921" class="lc jo hh kt b fi lh le l lf lg">describe(‘method “createCounter”’, () =&gt; {<br/>  test(‘should create a counter’, () =&gt; {<br/>    const boundCancel = jest.fn()<br/>    const boundOnInterval = jest.fn()<br/>    const timer = 42<br/>    const cancel = {<br/>      bind: jest.fn().mockReturnValue(boundCancel)<br/>    }<br/>    const onInterval = {<br/>      bind: jest.fn().mockReturnValue(boundOnInterval)<br/>    }<br/>    const setInterval = jest.fn().mockReturnValue(timer)</span><span id="7b57" class="lc jo hh kt b fi lh le l lf lg">    const dependencies = {<br/>      cancel,<br/>      onInterval,<br/>      setInterval<br/>    }<br/>    const config = { ticks: 42 }</span><span id="3d54" class="lc jo hh kt b fi lh le l lf lg">    const counter = createCounter(dependencies, config)</span><span id="fdc3" class="lc jo hh kt b fi lh le l lf lg">    expect(cancel.bind).toHaveBeenCalled()<br/>    expect(onInterval.bind).toHaveBeenCalled()<br/>    expect(setInterval).toHaveBeenCalledWith(<br/>      boundOnInterval,<br/>      200<br/>    )<br/>    expect(counter).toHaveProperty(‘cancel’)<br/>  })<br/>})</span><span id="80bc" class="lc jo hh kt b fi lh le l lf lg"><br/>// on-interval.test.js<br/>import { onInterval } from ‘../src/on-interval’</span><span id="0fed" class="lc jo hh kt b fi lh le l lf lg">describe(‘method “onInterval”’, () =&gt; {<br/>  test(‘should call “onTick”’, () =&gt; {<br/>    const onTick = jest.fn()<br/>    const cancel = jest.fn()<br/>    const state = {<br/>      currentTick: 1<br/>    }<br/>    const config = {<br/>      ticks: 5,<br/>      onTick<br/>    }<br/>    const pool = {<br/>      onTick,<br/>      cancel,<br/>      state,<br/>      config<br/>    }</span><span id="9ba8" class="lc jo hh kt b fi lh le l lf lg">    onInterval(pool)</span><span id="cfb0" class="lc jo hh kt b fi lh le l lf lg">    expect(onTick).toHaveBeenCalledWith(1)<br/>    expect(pool.state.currentTick).toEqual(2)<br/>    expect(cancel).not.toHaveBeenCalled()<br/>  }) </span><span id="8bbd" class="lc jo hh kt b fi lh le l lf lg">  test(‘should call “onTick” and “cancel”’, () =&gt; {<br/>    const onTick = jest.fn()<br/>    const cancel = jest.fn()<br/>    const state = {<br/>      currentTick: 5<br/>    }<br/>    const config = {<br/>      ticks: 5,<br/>      onTick<br/>    }<br/>    const pool = {<br/>      onTick,<br/>      cancel,<br/>      state,<br/>      config<br/>    }</span><span id="e9c6" class="lc jo hh kt b fi lh le l lf lg">    onInterval(pool)</span><span id="3a5e" class="lc jo hh kt b fi lh le l lf lg">    expect(onTick).toHaveBeenCalledWith(5)<br/>    expect(pool.state.currentTick).toEqual(6)<br/>    expect(cancel).toHaveBeenCalledWith()<br/>  })<br/>})</span></pre><blockquote class="lj"><p id="bf7a" class="lk ll hh bd lm ln lo lp lq lr ls jm dx translated"><strong class="ak">只有将所有功能开放到底，我们才能获得自由。</strong></p></blockquote></div></div>    
</body>
</html>