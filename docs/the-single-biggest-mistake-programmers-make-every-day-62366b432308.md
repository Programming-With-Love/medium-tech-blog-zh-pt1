# 程序员每天犯的最大错误

> 原文：<https://medium.com/javascript-scene/the-single-biggest-mistake-programmers-make-every-day-62366b432308?source=collection_archive---------2----------------------->

![](img/258c0ea01501dd4ca3fc0930d6a7e7cc.png)

Oops — Craig Sunter (CC BY-ND 2.0)

我最近在一个会议上教了一个大师班。这一天的前半天，我站在全班面前，谈论 JavaScript 的两大支柱:[原型 OO](/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3#.nofip7b3x) 和[函数式编程](/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4#.8d1nquob2)。

在后半部分，我让学生们组队合作开发一个应用程序项目。作业是记住课程中的几个要点:

*   **不要导出任何类。如果你需要实例化任何东西，使用工厂函数。**
*   尽可能使用纯函数。一个纯函数不会改变自身以外的任何东西。纯函数不会产生副作用。给定相同的输入，纯函数将总是返回相同的输出。
*   注意有多少程序状态可以用**事物列表来表示。**

在开始练习任务后，我花了一天的时间在房间里走来走去，帮助团队进步。我注意到一个一致的主题，这启发了我在 Twitter 上提出的一个问题:

我得到了一些很好的回应。以下是一些我最喜欢的:

我个人最喜欢的是:

布伦丹·艾希似乎也很喜欢:

![](img/32430d599f91e6aca92c85e6df5e2aca.png)

我相信每个程序员时常犯的最大的错误就是**把事情变得过于复杂**。

## 保持简单愚蠢

有一个共同的设计原则(根据维基百科)起源于美国海军:

> [**K**](https://en.wikipedia.org/wiki/KISS_principle)**ISS—K**eep**I**t**S**imple， **S** tupid

我认为这还不够，所以我说“保持它**愚蠢简单】**。

我的意思是，你应该想出最简单的方法来实现目标，然后让它变得更简单。

> “完美不是在没有更多可以增加的时候，而是在没有更多可以减少的时候。”
> ~安东尼·德·圣埃克苏佩里

## 什么是简单代码？

简单，源自拉丁语 *simplus，*最初指由一种成分制成的药物，尤指由一种植物制成的药物。我这里指的意思是“不复杂，不复合；单身。”简单 vs 复杂可以简洁地总结为:**一件事** vs **很多事。**

**有一点**就是*简单。*

**很多事情**都是*复杂的。*

当我说你应该保持代码尽可能简单时，我的意思是什么？我相信所有的代码都应该是简单的(如 *easy* ):

*   **简单易懂。**
*   **使用简单。**
*   **简单重复使用。**
*   **简单延伸。**

让事情*变得简单*的最好方法是让你的代码**简单，**就像**做一件事情**(点)。

## 该过程

我第一次在教室里走动时，注意到学生们被困在兔子洞里。一个团队被困在创建构建过程中。另一个人被所有的数据结构困住了。另一个是在有任何功能让数据流通过之前，试图找出如何将功能数据流应用于问题。

所有的团队都会从 Kent Beck 的建议中受益，他是[“测试驱动的开发实例”](http://amzn.to/1Ok0rjY)的作者:

1.  让它发挥作用。
2.  做正确的事。
3.  动作快点。

第一步应该是让它发挥作用。最好的方法就是简化。现在就做最简单的事情，这会让你朝着目标前进。

## “让它工作”是什么意思？

因为我喜欢即时反馈，所以我总是从一些简单的单元测试开始，当我有一个可行的解决方案时，这些测试会立即提醒我。在单元测试期间，我决定我所说的“让它工作”是什么意思。该解决方案需要满足的最低要求是什么？

练习作业是一个简单的 scrum 签入应用程序。我有意选择这个应用程序，因为它可以让学生练习一些简单的函数式编程，[避免在开发人员通常依赖类和类继承的情况下使用*` class `*](/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3):UI 代码。

在敏捷开发中，我们努力实现最小有效量的过程，以实现[高速开发](/javascript-scene/how-to-build-a-high-velocity-development-team-4b2360d34021)。

scrum 会议是这个最小过程的一个常见元素。它的目的是允许团队成员互相检查。在每个工作日，每个小团队都要回答三个问题:

*   上个工作日你做了什么？
*   你今天要做什么？
*   有什么阻挡你吗？

checkin 应用程序让你不用开会就可以进行 scrum 签入。

我们从第一步开始:用户必须能够识别自己。为此，我们可能需要某种类型的登录屏幕。

在这个应用程序的情况下，我鼓励学生使用 React，我提供了 [React 纯组件启动器](https://github.com/ericelliott/react-pure-component-starter)作为应用程序的起点。

在此基础上，第一步是创建一个 React 组件，该组件显示用户名的文本字段和一个“登录”按钮。

我相信你应该总是首先从测试开始，这一信念得到了微软和 IBM 研究的支持。你可以在我的博客[“每个单元测试必须回答的五个问题”](/javascript-scene/what-every-unit-test-needs-f6cd34d9836d)中了解更多。

你应该从能回答这个问题的测试开始，“它有用吗？”

我总是从简单的、人类可读的需求描述开始我的单元测试。在这种情况下，这些可能看起来像这样:

```
`should display a text input field for the user's name.`
`should display a "Sign In" button.`
```

一旦按钮被按下，我们应该创建一些代表当前登录用户的应用程序状态:

```
`should save current logged-in user in client state.`
```

现在，对于我们的一个应用视图,“让它工作”意味着什么，我们已经有了一个很好的定义。在进入应用程序的其余部分之前，我们应该通过这些测试。

课程:

*   **了解问题。**知道“让它工作”是什么意思。
*   **从头开始。如果任务是识别当前用户正在做什么，第一步可能是识别当前用户是谁。**
*   一次做一件事。不要试图把所有的 app 需求都挤进你写的第一个模块里。你完成的应用程序可能会包含许多模块。保持每个模块小而集中，一次专注于一个模块。
*   **从小做起，迭代。**写一个测试。让它过去。重构。让它工作。做正确的事。动作快点。一步一步来。继续采取这些步骤，直到工作完成。

# 简单易懂

**每行做一件事。**

**每个功能做一件事。**例如，如果您需要使用查询参数的值，您应该使用一个函数从 URL 中提取查询参数的值，而不是将该逻辑与使用该值的函数混合。

**用一个变量只代表一件事。**有时，创建一个变量来表示一些数据，然后使用该变量作为一个临时位置来存储从一种表示到另一种表示的转换值，这很有吸引力。例如，您可能需要一个查询字符串参数值，并从存储整个 URL 开始，然后只存储查询字符串，然后是值。最好为 URL 使用一个变量，为查询字符串使用另一个变量，最后使用一个变量来存储值。

这就是为什么在 ES6 中我更喜欢 *`const`* 而不是 *`let`* 。在 JavaScript 中， *`const`* 意味着变量不能被重新赋值。(不要与不可变的值混淆。不像那些由 Immutable.js 和 Mori 产生的真正的不可变数据类型，一个 *`const`* 对象可以有变异的属性。)

*`const`* 是变量不会被重新分配的信号。 *`let '，*是变量*可能被重新分配*的信号，如循环中的计数器，或算法中的值交换。如果我不需要重新赋值， *`const`* 是我的默认选择，而不是 *`let`* ，因为我希望代码中的用法尽可能清晰。我在 ES6 里不用 *`var`* 。循环在块范围内是有价值的，但是我想不出有什么情况比 *`let`* 更喜欢【T20 . ` var`。

有时，一个函数可能会表现出隐藏的复杂性，这意味着它做的不止一件事，但它并不是立即显而易见的。一个函数可以通过多种方式产生副作用，或者产生一系列复杂的可能结果。让我们来探索如何简化函数的效果。

## 避免副作用

任何程序的本质都是取一些数据作为输入，产生一些数据作为输出。

这是程序最简单的地方。

函数的本质是取一些数据作为输入，产生一些数据作为输出。

因此，最简单的实现可能是函数。

如果一个函数符合这个定义，就很容易理解:

```
foo(...inputs) => output
```

根据上面的签名，函数 *`foo()`* 接受任意数量的参数作为输入，并返回一些输出。这很容易理解:

```
const result = foo(a, b, c);
```

在这种情况下，自变量 *`a`* 、 *`b`* 、 *`c`* 进去，出来的是 *`result`* 。但是如果事情不只是这样呢？如果 *`a`* 是一个数组，而 *`foo()`* 要对它进行变异，那会怎么样？那么 *`foo()`* 的效果就不能单纯看它的函数签名来理解了。为了理解 *`foo()`* 的影响，你还必须追溯 *`a`* 的完整一生。

在 JavaScript 中，数组和对象是通过引用传递的，所以如果您改变数组或对象参数，它不仅仅影响函数内部的变量。它还会影响使用对同一变量的引用的任何其他函数。

在编程行话中， *`a`* 的变异被称为**副作用。副作用并不明显可见，所以当它们引起一个 bug 时，可能很难追踪到根本原因。**

因此，最简单的功能不会引起**副作用。**

副作用包括在函数外部可见的任何状态变化。这包括记录消息、在屏幕上显示内容以及抛出异常。

如果一个函数有可能抛出异常，那么这个事实应该清楚地记录下来。如果有可能避免一个异常，并且**仍然使得函数可以安全地使用**，那么你应该选择这个过程而不是抛出。这允许您的函数遵守健壮性原则:

> "接受的要开明，送出的要保守。"

我的解释更笼统一些:

> “做最坏的打算。好好表现。”

简而言之，如果发生了任何没有被函数签名传达的变化，这就是副作用。

只要有可能，我们应该**避免副作用。**

## 支持一致性

如果你用相同的输入多次调用同一个函数，而它返回不同的输出，原因并不总是显而易见的。一些函数依赖于随机输入，或者根据它被调用的时间，或者函数签名中没有指定的一些外部变量的值，输出有所不同。

这样的函数很难调试。只要有可能，确保您的函数在相同的输入下总是返回相同的输出。

这个特征意味着这样的函数是**幂等的**。也就是多次调用函数的结果和调用一次函数是一样的。

没有副作用的幂等函数有一个特性叫做**引用透明**。这意味着如果你有一个函数调用:

```
const foo = f(a);
```

你可以用 *`f(a)`* 的结果替换那个函数调用，而不改变程序的含义。因此，例如，如果 *`f(a)`* 的结果是 *`42`,* 您可以将上面的代码改为:

```
const foo = 42;
```

你的程序仍然会像预期的那样工作。

## 纯函数是最简单的函数

没有副作用并表现出参照透明性的函数称为**纯函数。**

**一个纯函数:**

*   给定相同的输入，将总是返回相同的输出(不依赖于共享的可变状态或熵)。
*   不会产生副作用。

最简单的函数是纯函数。如果一个问题可以用纯函数来解决，那么纯函数很有可能是这个问题最简单的解决方案。

# 简单易用

简单易用意味着代码应该有一个清晰和集中的 API。代码做**一件事**，它有一个简单的接口来完成那件事。

## 避免特别的多态性

在 JavaScript 中可以使用**特别多态**来创建一个做许多不同事情的函数。例如，jQuery 接受许多不同类型的 jQuery 函数输入。

如果你传递一个函数，它会在页面就绪时被触发。如果传递一个字符串，它会被解释为 DOM 选择器，依此类推。

jQuery 在这里应该有一点余地，因为它是在 JavaScript 有一个好的模块格式之前编写的，但是现在，如果您可以这样做，不是更清楚吗？

```
import { pageReady, $ } from 'jQuery';pageReady(() => {
  $('.your-selector').on('click', () => {
    doStuff();
  });
});
```

当然，有经验的 jQuery 开发者都知道*` $(fn)；`*表示 *`$(文档)。就绪(fn)；`*，但是新开发者呢？难道你不应该能够浏览一些代码，并根据事物的名称猜测其含义吗？

即席多态性意味着在函数内部，您查看输入，并根据它们的类型或值，遵循条件逻辑的不同分支。特殊多态性增加了函数的复杂性，迫使您编写不必要的条件逻辑，并使您无法为希望函数扮演的每个不同角色编写语义名称。

我们的新标准模块意味着创建和使用更小、更集中的模块比将一堆松散相关的任务组合成一个功能更容易。

## 封装私有数据

我认为从一个模块中导出的对象也应该作为该模块的文档。换句话说，它应该公开支持的接口，并且**只公开支持的接口。**

关于私有实现细节的事情是，它们比公共 API 更有可能有突破性的改变，如果可以避免的话，应该避免突破性的改变。

在 JavaScript 中，有一个常见的约定是在私有属性前面加上下划线:

```
const foo = () => {
  return {
    _secret: ‘yeah, nobody could possibly find this…’,
    getSecret () {
      return this._secret;
    }
  };
};const bar = foo();console.log(bar._secret); // yeah, nobody could possibly find this…
```

**私有下划线约定有缺陷，原因有两个:**

*   **新手不知道下划线是什么意思，就忽略了。**
*   **有经验的开发者认为对他们不适用。“我知道我在做什么。这个警告只是针对新手的。”所以他们也忽略了。承认吧，有经验的开发者。你以前做过这个。我也是。向你们三个比我们其他人更守纪律的人道歉。；)**

与常见的误解相反，JavaScript 支持真正的封装。

像对象一样，闭包也是一种包含状态的机制。在 JavaScript 中，每当函数访问在直接函数作用域之外定义的变量时，就会使用闭包。使用闭包很容易:只需在另一个函数中定义一个函数，然后通过返回或者传递给另一个函数来公开内部函数。内部函数使用的变量将对它可用，即使在外部函数已经完成运行之后。

您可以使用闭包通过工厂函数在 JavaScript 中创建数据隐私:

```
const counter = function counter() {
  let count = 0;
  return {
    getCount() {
      return count;
    },
    increment() {
      count += 1;
      return this;
    }
  };
};const myCounter = counter();
console.log(typeof myCounter.count); // undefined -- private!myCounter.increment().increment().increment();
console.log(myCounter.getCount()); // 3
```

这在构造函数中也适用，但是[工厂更好](/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3)。

## 纯函数>函数>工厂>类

请注意，当您从左向右移动时，这些东西的复杂性会增加。从左侧开始，仅在需要时向右移动**。**

> **“有时候，优雅的实现只是一个函数。不是方法。不是一个班。不是框架。只是一个功能。”~约翰·卡马克**

**这句话值得再读两遍。将它铭刻在你的脑海中，这样你每次实现新功能时都会想起它。**

**对于模块接口，我更喜欢纯函数而不是有状态或副作用的函数，常规函数而不是工厂，我[从不导出一个 *`class`*](/javascript-scene/inside-the-dev-team-death-spiral-6a7ea255467b) 。**

****注意:** [*你永远不需要在 JavaScript 中导出一个‘类’。*](/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a)**

# ****简单复用****

**易于重用意味着您应该能够将代码提取到它自己的模块中，将其导入到其他地方，并且在使用它时不会破坏一堆东西或进行耗时的重构。理想情况下，这应该是一个剪切、一个粘贴和几个 *`import`* 语句。**

**如果一个函数依赖于任何外部状态，那就没那么简单了。您需要更改函数签名，找到所有调用点，并传入所有需要的参数。**

**如果函数有副作用，并且依赖于时间(相对于时钟时间，或者相对于其他操作或函数调用的运行时间)，那就更成问题，更难解决。**

**由于它们独立于共享状态、定时和类似的因素，纯函数显然比不纯函数更容易重用。**

# **易于扩展**

**为了稳定性，API 应该对突破性的改变关闭，但对扩展开放。对于函数来说，这可能意味着将命名的选项传递给函数，而不是传递一系列参数，这样就可以避免传递一堆在函数调用点可能是也可能不是语义命名的值。**

**使用 options 对象还允许您避免为可选参数传递 *`null`* 。**

**什么读起来更好？**

```
// Individual arguments
const item = createFilmItem(title, null, null, recommendedPrice);// Options object
const item = createFilmItem({ title, recommendedPrice });
```

**第一个例子使用了函数 signature: *`(title: String，releaseDate？:日期，运行时间？:Number，recommendedPrice: Number) = >电影`***

**使用单独的参数而不是 options 对象迫使您传递不需要传递(或不能传递，因为信息不可用)的可选值的 *`null`* 值占位符。**

**对比第二个函数签名:*` createfilmitem({ title:String，releaseDate？:日期，运行时间？:Number，recommendedPrice: Number }) = >电影`***

**使用 options 对象为将来的 API 扩展留下了很大的灵活性。**

***读取函数签名有困难吗？查看* [*Rtype:读取函数签名*](https://github.com/ericelliott/rtype#reading-function-signatures) *中的文档以获得解释。***

## **导出工厂而不是类**

**正如我在之前提到过[很多次](/javascript-scene/inside-the-dev-team-death-spiral-6a7ea255467b)[， *`class`* 提供 *`extends`* 就像球可以扔，椅子可以坐，但是 *`extends`* 将粗心的开发人员引向**脆弱的基类问题**，**大猩猩香蕉问题**等等…](/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3)**

**不要引诱你的用户撞上糟糕的 OO 设计的岩石(如果有足够的时间和进化，**所有的类分类设计对于新的用例来说都是错误的**)。**

**相反，通过导出一些易于扩展或组合成新对象的东西来为它们的成功做准备。如果不需要实例状态，导出一个纯函数或普通函数。如果你确实需要实例状态，尝试一个 stamp:参见 Stamp 规范。**

****在 JavaScript 中，任何函数都可以实例化并返回对象。**当你在没有构造函数(例如 ES6 *`class`* )的情况下这样做时，它被称为**工厂函数。** ` *级*`无法与工厂的力量和灵活性竞争——特别是邮票。**

**由于工厂增加了灵活性，从类实现到工厂实现的重构通常是可取的。例如，添加多态性([示例](https://gist.github.com/ericelliott/e994ee541d0ed365f5fd))，或者切换到对象池以[避免垃圾收集器](https://www.youtube.com/watch?v=RWmzxyMf2cE)。**

**但是因为 ES6 类抛出错误，如果你省略 *`new，*并且你控制之外的代码可能使用构造函数使能的特性，比如 *`instanceof，* **从一个类切换到一个工厂是一个突破性的改变**。**

**省点事吧。**一开始就出口工厂。****

**[带有图章的工厂组成](https://github.com/stampit-org/stamp-specification#stamp-specification-composables)为 API 扩展提供了极大的灵活性；比*` class`*-甚至比实验性的特征如职业装饰者还要多。**

# **结论**

**简化您的代码。从最简单的实现开始，只有当问题需要时，才朝着更复杂的解决方案前进。**

## **请记住:**

*   ****保持愚蠢简单(吻)****
*   **让它工作，让它正确，让它快速。**
*   ****理解问题。(**知道“让它工作”是什么意思。)**
*   ****从头开始。****
*   ****从测试开始。****
*   ****做一件事(DOT)。****
*   ****从小做起，迭代。****
*   ****纯功能>功能>工厂>类****

**一周中的每一天，简单胜过聪明。**

# **[跟随埃里克·埃利奥特学习 JavaScript】](https://ericelliottjs.com/)**

*   **在线课程+定期网络广播**
*   **软件测试**
*   **JavaScript 的两大支柱(原型 OO +函数式编程)**
*   **通用 JavaScript**
*   **结节**
*   **反应**

*****Eric Elliott****著有* [*【编程 JavaScript 应用】*](http://pjabook.com) *(O'Reilly)，以及* [*【学习 JavaScript 通用 App 开发用 Node，ES6，&【React】*](https://leanpub.com/learn-javascript-react-nodejs-es6/)*。他曾参与的软件项目有****Adobe Systems*******Zumba Fitness*******华尔街日报*******ESPN*******BBC*********

****他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。****