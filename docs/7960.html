<html>
<head>
<title>Offline Hustle with Service Worker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务人员的线下拥挤</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/offline-hustle-with-service-worker-ebf64d0add35?source=collection_archive---------0-----------------------#2020-12-23">https://medium.com/walmartglobaltech/offline-hustle-with-service-worker-ebf64d0add35?source=collection_archive---------0-----------------------#2020-12-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/41719823cc84bc64aec5c606a48bf60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*p2-WSJPssShIIejtQJ79dQ.gif"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">THE OFFLINE GAME (Source: <a class="ae it" href="https://gifer.com/" rel="noopener ugc nofollow" target="_blank">https://gifer.com/</a>)</figcaption></figure><p id="aa14" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们面临网络连接问题时，我们都喜欢玩Dino游戏来打发时间。但是作为一个MNC/创业公司的软件工程师，我们不希望我们的客户花时间玩这个游戏。相反，我们希望我们的客户在这种情况下也能连接到我们的web应用程序。</p><p id="eda4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们未能在所有这些情况下为客户提供服务，可能会导致客户不满，公司可能会失去客户。因此，作为开发人员，我们应该结合现代技术解决方案，在各种情况下为客户提供更好的体验。</p><p id="3876" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">服务人员可以帮助我们克服这个问题。</p><p id="a804" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在开始演示之前，我建议您浏览一下本系列的上一篇博客<a class="ae it" rel="noopener" href="/walmartglobaltech/service-worker-lifecycle-20333ccd570a">服务人员生命周期</a>，以便对本博客将要讨论的概念有一个基本的了解。</p><p id="f083" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇博客中，我们将看到如何让我们的web应用程序利用服务人员的特性，并使其更加可靠。我们开始吧！</p><h1 id="3712" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">项目概述</h1><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/b6c141540c2dc0211c8326ed6d724dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QDA1XyLFWGvUwZw6kImgQ.png"/></div></div></figure><p id="1d32" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是项目的目录结构。注意服务工作者脚本(<strong class="iw hi"> <em class="kv"> serviceWorker.js </em> </strong>)在根目录下，让HTML页面、资产、JS/CSS文件归入其范围。我们的JS脚本(<strong class="iw hi"> <em class="kv"> main.js </em> </strong>)注册我们的服务工作者，生命周期事件在我们的服务工作者脚本中处理。</p><h2 id="20f7" class="kw jt hh bd ju kx ky kz jy la lb lc kc jf ld le kg jj lf lg kk jn lh li ko lj bi translated">快速视频演示</h2><p id="29ba" class="pw-post-body-paragraph iu iv hh iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">这里有一个简短的视频，将向您展示具有有效服务人员脚本的web应用程序如何拦截网络请求并提供更好的离线体验，如何安装web应用程序，以及我们如何向客户发送通知。</p><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lp lq l"/></div></figure><h2 id="b9f7" class="kw jt hh bd ju kx ky kz jy la lb lc kc jf ld le kg jj lf lg kk jn lh li ko lj bi translated">线下体验</h2><p id="57f5" class="pw-post-body-paragraph iu iv hh iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">通过使用服务人员，我们可以让我们的客户使用我们的web应用程序(浏览静态页面，阅读文本内容),即使他们处于离线状态。Web开发人员可以使用Service Worker并缓存静态网页、图片、视频、gif等资产。这些文件需要缓存在Install事件中。这些文件将存储在浏览器缓存中，并用于拦截获取请求。</p><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lr lq l"/></div></figure><p id="9f2f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码中，通过<strong class="iw hi"> <em class="kv"> caches.open(cacheName)使用给定的<strong class="iw hi"><em class="kv">cacheName</em></strong><em class="kv"/>创建了一个新的缓存。</em> </strong> <em class="kv"> </em>缓存对象创建后，我们可以添加需要缓存的文件，用<strong class="iw hi"><em class="kv">cache . addall(filesToCache)</em>。</strong></p><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lr lq l"/></div></figure><p id="9a23" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当服务工作者获得fetch事件时，它将通过<strong class="iw hi"><em class="kv">caches . match(e . request)</em></strong>在缓存中检查请求的内容，如果内容在缓存中可用，它将作为响应返回。因此，客户现在可以离线访问某些资源，并与我们的web应用程序保持连接:)</p><h2 id="80e6" class="kw jt hh bd ju kx ky kz jy la lb lc kc jf ld le kg jj lf lg kk jn lh li ko lj bi translated">添加到主屏幕/安装应用程序</h2><p id="dbab" class="pw-post-body-paragraph iu iv hh iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">使用服务工作者，我们可以让我们的web应用程序像本地应用程序一样运行，使其成为一个<a class="ae it" href="https://developers.google.com/web/updates/2015/12/getting-started-pwa" rel="noopener ugc nofollow" target="_blank">渐进式Web应用程序(PWA) </a>。让我们的web应用程序成为PWA可以提供类似本机的体验，并帮助开发人员使用推送通知等其他功能。<br/>为了让用户能够选择安装/添加到主屏幕，我们需要一个Web应用清单(manifest.json)文件，它必须链接到我们的应用程序。</p><pre class="kr ks kt ku fd ls lt lu lv aw lw bi"><span id="282d" class="kw jt hh lt b fi lx ly l lz ma">&lt;link rel="manifest" href="manifest.json" /&gt;</span></pre><p id="6915" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">除了拥有有效的清单文件，我们还需要我们的应用程序:</p><ul class=""><li id="cbe3" class="mb mc hh iw b ix iy jb jc jf md jj me jn mf jr mg mh mi mj bi translated">注册一名有效的服务人员</li><li id="5053" class="mb mc hh iw b ix mk jb ml jf mm jj mn jn mo jr mg mh mi mj bi translated">接受HTTPS服务(TLS加密)</li></ul><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lr lq l"/></div></figure><p id="ebcd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">清单文件是一个JSON文件，其中包含关于应用程序必须如何加载到用户设备上的元数据。作为开发人员，我们可以修改这些属性来控制应用程序如何显示给用户。</p><p id="e0ec" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，<strong class="iw hi"> <em class="kv"> name </em> </strong>属性表示应用程序在设备上安装时必须使用的名称。<strong class="iw hi"> <em class="kv"> start_url </em> </strong>属性用于指定用户每次打开app时要打开的登陆页面。<strong class="iw hi"> <em class="kv"> display </em> </strong>属性让我们决定应用程序必须如何显示(是否有地址栏、全屏还是像标准浏览器一样)。这里，<strong class="iw hi"> <em class="kv">单机</em> </strong>告诉应用程序将在自己的窗口中打开，没有地址栏和导航控件。<strong class="iw hi"> <em class="kv">图标</em> </strong>属性定义了在主屏幕上安装或添加我们的web应用程序时要使用的徽标/图标。你可以在这里阅读更多关于这些属性的信息。</p><h2 id="be7d" class="kw jt hh bd ju kx ky kz jy la lb lc kc jf ld le kg jj lf lg kk jn lh li ko lj bi translated">推送通知</h2><p id="0ff7" class="pw-post-body-paragraph iu iv hh iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">通知是与用户交互的一种很好的方式。我们可以使用通知功能通知用户最近的更新、新文章和添加的功能。<a class="ae it" href="https://developers.google.com/web/ilt/pwa/introduction-to-push-notifications" rel="noopener ugc nofollow" target="_blank">推送通知</a>是在服务人员的帮助下可用的功能。</p><blockquote class="mp mq mr"><p id="b846" class="iu iv kv iw b ix iy iz ja jb jc jd je ms jg jh ji mt jk jl jm mu jo jp jq jr ha bi translated">我已经在我们的NodeJS项目中使用了<a class="ae it" href="https://github.com/web-push-libs/web-push" rel="noopener ugc nofollow" target="_blank"> web-push </a> npm包来实现推送通知。</p></blockquote><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lr lq l"/></div></figure><p id="3455" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码中，我创建了一个Express服务器，并创建了一个路由(<strong class="iw hi"> <em class="kv"> /subscribe </em> </strong>)，通过<strong class="iw hi"><em class="kv">web push . send notification()</em></strong>发送通知。我们需要客户端脚本(main.js)发送的<strong class="iw hi"> <em class="kv">订阅</em> </strong>对象。<strong class="iw hi"> <em class="kv">有效载荷</em> </strong>是可选参数，必须是字符串。在这里，我使用<strong class="iw hi"><em class="kv">JSON . stringify()</em></strong>方法将一个javascript对象转换成一个字符串，然后将它作为有效载荷发送出去。</p><p id="d609" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在客户端，我们为推送服务注册我们的客户端，并获得订阅对象。这是由<strong class="iw hi"><em class="kv">register . pushmanager . subscribe()完成的。</em> </strong>推送通知通过向<strong class="iw hi"> <em class="kv"> /subscribe发送请求来发送。</em> </strong>订阅对象作为请求体发送，在服务器端访问。</p><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lr lq l"/></div></figure><blockquote class="mp mq mr"><p id="3a0e" class="iu iv kv iw b ix iy iz ja jb jc jd je ms jg jh ji mt jk jl jm mu jo jp jq jr ha bi translated">这里的<strong class="iw hi"> regObject </strong>是在我们的服务工作者脚本注册之后获得的服务工作者注册对象。</p></blockquote><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lr lq l"/></div></figure><p id="47af" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，我们的服务人员会监听推送事件。这里，我们使用<a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API" rel="noopener ugc nofollow" target="_blank">通知API </a>的<strong class="iw hi"><em class="kv">show Notification()</em></strong>方法向我们的用户显示通知。showNotification方法有两个参数<strong class="iw hi"> <em class="kv"> title </em> </strong>和一个<strong class="iw hi"> <em class="kv"> options </em> </strong>对象(具有body、icon等属性)。</p><figure class="kr ks kt ku fd ii"><div class="bz dy l di"><div class="lr lq l"/></div></figure><h2 id="07e3" class="kw jt hh bd ju kx ky kz jy la lb lc kc jf ld le kg jj lf lg kk jn lh li ko lj bi translated">后台同步</h2><p id="1118" class="pw-post-body-paragraph iu iv hh iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">我们可以使用Service Worker来保持用户活动的同步，即使用户在脱机状态下执行了一些操作，如发送消息、加载网页。<a class="ae it" href="https://developers.google.com/web/updates/2015/12/background-sync" rel="noopener ugc nofollow" target="_blank">后台同步API </a>可用于在后台处理同步操作。</p><h1 id="d008" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="df49" class="pw-post-body-paragraph iu iv hh iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">通过例子学习一个主题有助于更好地理解。在这篇博客中，我用一些代码片段讨论了web开发人员如何使用Service Worker为我们的客户提供更好的体验。开发人员可以添加PWA功能，如安装应用程序、推送通知，以使他们的web应用程序更具交互性，并让它像本机应用程序一样运行。</p><p id="0388" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个博客的完整代码可以在这个<a class="ae it" href="https://github.com/swapnil8424/Service-Worker-Demo/tree/main" rel="noopener ugc nofollow" target="_blank"> GitHub </a> repo获得。</p><h1 id="e458" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">下一步是什么？</h1><p id="8db8" class="pw-post-body-paragraph iu iv hh iw b ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">如果您的公司有跨来源的网站/网络应用程序(如google.co.in和谷歌公司)，我们想使用服务工作者，使我们的网络应用程序的PWA。下一篇博客将帮助你理解如何跨跨源网站/web应用实现服务工人。</p></div></div>    
</body>
</html>