<html>
<head>
<title>Android Testing 4 — Configuração do ambiente para testes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android Testing 4 - 设置测试环境</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/android-testing-4-configura%C3%A7%C3%A3o-do-ambiente-para-testes-9e37330afd7c?source=collection_archive---------3-----------------------#2017-01-03">https://medium.com/google-developer-experts/android-testing-4-configura%C3%A7%C3%A3o-do-ambiente-para-testes-9e37330afd7c?source=collection_archive---------3-----------------------#2017-01-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/6d83bcb2d2784caff0a4c80c33a3e255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mO7c65FETtiiL2nZfMduyQ.png"/></div></div></figure><div class=""/><p id="ca81" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我个人万岁,首先祝你新年快乐,祝你作为Android开发人员在职业生涯中取得了许多成就和进步。<br/>在解释了依赖注入以及如何构建一个模型,使我们能够在前面的<a class="ae jn" rel="noopener" href="/google-developer-experts/android-testing-part-3-mvp-model-e-dependency-injection-32a9036d18d6#.iiceogq9e">帖子</a>中进行测试并获得更清晰和可读的代码之后,我们将继续这个系列,在本文中,我将向您展示如何创建一个允许在Android上编写和运行单元测试的环境所需的设置。</p><p id="1a84" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Android上编写测试已经成为一项非常简单的任务,因为创建了“Android测试支持库”,其中包含执行单元测试(Unit Tests)和仪器测试(Instrumented Tests)等所需的所有API。</p><p id="78ee" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要开始使用此库在应用中编写和运行测试,只需按照以下步骤操作:</p><h1 id="17d3" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">通过 Gradle 添加库</h1><p id="fcbb" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">因为在本文中,我将只关注单元测试,所以使用支持库 API 的第一步是将“app”模块的 build.gradle 文件中所需的依赖项应用到项目中。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="18e4" class="la jp hs kw b fi lb lc l ld le">dependencies {<br/>    testCompile 'junit:junit:4.12'<br/>    testCompile 'org.mockito:mockito-core:1.10.19'<br/>}</span></pre><p id="af58" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一个不可或缺的库是JUnit测试框架,它可以轻松创建代码以实现测试自动化和结果呈现。<br/>通过<a class="ae jn" href="http://junit.org/junit4/" rel="noopener ugc nofollow" target="_blank">JUnit</a>,可以使用一组测试结果的方法来测试一个函数(方法)是否按预期工作。</p><p id="020a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第二个库,但不是创建基本单元测试所必需的,是 <a class="ae jn" href="https://github.com/mockito/mockito" rel="noopener ugc nofollow" target="_blank"> Mockito </a> 框架,简而言之,它允许使用单元测试依赖的某些 Android 组件的“开放”版本。(Mockito只能在下一篇文章中正确使用和解释)</p><p id="c5d3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过将库正确添加到项目中,下一步是创建一个密封环境,该环境包括简单地创建一个测试环境,在该环境中,这些环境与任何类型的依赖项隔离运行。</p><p id="c249" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">示例:</strong>对于本项目,显示事件列表取决于后端、Internet 连接以及可能影响此任务的其他因素。</p><p id="cc66" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此,创建一个密封的环境将允许我们创建这些必要组件的虚假实现,并使用依赖注入(T1)的概念将这些实现注入到我们想要测试的组件中。<br/>为了实现这一目标,我们可以使用依赖注入库,如<a class="ae jn" href="http://square.github.io/dagger/" rel="noopener ugc nofollow" target="_blank">Dagger</a>,或者本文中介绍的最简单的方法是使用 Gradle 插件中提供的<em class="lf">build flavours</em>功能。</p><h2 id="f60a" class="la jp hs bd jq lg lh li ju lj lk ll jy ja lm ln kc je lo lp kg ji lq lr kk ls bi translated">创建 flavours</h2><p id="3503" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">Build flavours是Gradle插件中提供的一项功能,它允许我们创建具有常见基本功能的不同版本的应用程序,并根据创建版本的目的创建更多不同的功能。</p><p id="70a2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个非常经典的例子是付费和免费版本的应用程序,其中两者具有共同的功能,但付费版本通常具有比免费版本更多的功能。</p><p id="d497" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">创建 build flavours 非常简单,第一步是在 gradle 中定义版本,如下面的脚本所示。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="0ac1" class="la jp hs kw b fi lb lc l ld le">android{</span><span id="fc26" class="la jp hs kw b fi lt lc l ld le">  //outras configuracoes<br/>  productFlavors {<br/>    mock {<br/>        applicationId <strong class="kw ht">"co.app.evently.mock"<br/>        </strong>versionName <strong class="kw ht">"1.0.0"<br/>    </strong>}<br/>    prod{<br/>        applicationId <strong class="kw ht">"co.app.evently"<br/>        </strong>versionName <strong class="kw ht">"1.0.0"<br/>    </strong>}<br/>  }<br/>}</span></pre><p id="d50c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来,您需要同步项目并添加目录,如下图所示。<br/><strong class="ir ht"> 注意:</strong>在创建项目时,必须自动生成<strong class="ir ht">main </strong>、<strong class="ir ht">androidTest</strong>目录。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="680f" class="la jp hs kw b fi lb lc l ld le">app(<strong class="kw ht">module</strong>)<br/>--&gt;<strong class="kw ht">src</strong><br/>   --&gt;androidTest(<strong class="kw ht">contém código dos testes unitários de integração)<br/>   --&gt;main (contem código comum entre a versão de testes e produção. Ex: EventListFragment</strong>)<br/>   --&gt;mock (<strong class="kw ht">contém código da versão exclusivamente para testes</strong>)<br/>   --&gt;prod (<strong class="kw ht">contém código da versão de produção</strong>)<br/>   --&gt;test (<strong class="kw ht">contém código dos testes unitários)</strong></span></pre><p id="2e41" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您一次只能在一个版本上工作,只需更改设置,如下图所示。<br/>当选择其中一个版本时,项目将只能看到相应目录中的现有文件,以及与所选版本无关的普通主目录中的文件。</p><figure class="kr ks kt ku fd hj er es paragraph-image"><div class="er es lu"><img src="../Images/e18887bb35a206c4df36a53651cd2bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*iBPLNn2D2QDTWo-I1bTdUw.png"/></div></figure><p id="2521" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用此功能,您可以在每个版本中创建一个类<strong class="ir ht"> Injection</strong>,该类将根据所选版本提供不同的存储库版本(在上一篇文章中解释过),也就是说,在mock版本中,类<strong class="ir ht"> Injection</strong>将具有方法<strong class="ir ht"> provvedEventListRepository() </strong>,该方法将返回一个带有错误数据的实现(仅用于测试),并且在生产版本中,将使用相应的存储库实现从服务器加载数据,如下一篇文章中所述,当为该项目的演示者编写测试时。</p><p id="8677" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在,我将通过编写一个简单的单元测试来测试环境是否正确配置。</p><p id="a553" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一步是在 <strong class="ir ht"> tests(如上所述)目录中创建一个类,所有测试都将被写入其中。</strong></p><p id="c5e7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要编写测试函数,只需在创建的类中编写该函数,并在方法签名上添加 @Test 注释,以便 JUnitRunner 将此方法识别为要运行的测试。<br/>此函数的主体由要测试的逻辑和JUnit API中提供的一组方法组成,这些方法允许您检查执行的操作的结果是否与预期的结果相同。</p><p id="58eb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">检查逻辑是否正确的一些方法是:</p><p id="ce1e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">assertEquals(期望的Object,当前Object):</strong>检查两个对象是否相同,如果对象不同,测试失败。</p><p id="9fc4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"> assertTrue(boolean expression): </strong> 检查作为参数传递的表达式是否为真。如果表达式为 false,测试将失败。</p><p id="49b2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"> assertNotNull(Object object): 检查传入的对象是否为非 null。如果对象为 null,测试将失败。</strong></p><p id="190d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用这些方法,可以编写单元测试,如下面的测试,以检查求和方法是否正常工作。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8318" class="la jp hs kw b fi lb lc l ld le">public class BasicTest{<br/>     <br/>     public int sum(int a, int b){<br/>        return a+b;<br/>     }<br/>     <br/>     @Test<br/>     public void testSum(){<br/>       int a = 5;<br/>       int b = 4;<br/>       int result = sum(a,b);<br/>       assertTrue(result == 9);<br/>     }<br/>}</span></pre><p id="adaf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要运行此测试,只需右键单击文件上方,选择选项 “运行啊...<nome da="" class="">在几秒钟内,a<em class="lf">ndroid studio</em>将在<em class="lf">Run</em>选项卡上显示结果,如下图所示。</nome></p><figure class="kr ks kt ku fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/3969869ece009f5e80b0d79e30015690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ybuj3Gxa84Hy7DT67jRRwA.png"/></div></div></figure><p id="71a5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过这种方式,我们结束了另一篇文章,其中可以设置测试环境,编写和运行基本的单元测试。</p><p id="acc2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将在下一篇文章中继续编写presenter测试,并将本文中提出的一些概念与编写更复杂的测试相关联。</p><p id="f46f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你喜欢这篇文章,请点击下面的心脏点击,并与你认为他们也可能会发现有趣的朋友分享。</p><p id="bde6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您有任何疑问或建议,请让她在下面的部分中写下评论。</p><p id="7475" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">吃下一个!</p><p id="b947" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">dm=)</p></div></div>    
</body>
</html>