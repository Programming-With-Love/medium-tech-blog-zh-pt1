<html>
<head>
<title>Understanding Micro Frontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解微前端</h1>
<blockquote>原文：<a href="https://medium.com/globant/understanding-micro-frontend-8b0264e88a45?source=collection_archive---------0-----------------------#2022-08-11">https://medium.com/globant/understanding-micro-frontend-8b0264e88a45?source=collection_archive---------0-----------------------#2022-08-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="bebc" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">使用模块联合插件</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/b0604958fce37e01472f1c508504343f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wcz8bAOjRdV6D0wTJQSBWg.jpeg"/></div></div></figure></div><div class="ab cl ji jj go jk" role="separator"><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn jo"/><span class="jl bw bk jm jn"/></div><div class="ha hb hc hd he"><p id="14db" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><strong class="jr hi">简介:</strong></p><blockquote class="kl km kn"><p id="5ecd" class="jp jq ko jr b js jt ii ju jv jw il jx kp jz ka kb kq kd ke kf kr kh ki kj kk ha bi translated"><strong class="jr hi">“一种架构风格，将可独立交付的前端应用程序组合成一个更大的整体”。</strong></p></blockquote><p id="bb0d" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">微前端将<a class="ae ks" href="https://en.wikipedia.org/wiki/Monolithic_application#:~:text=In%20software%20engineering%2C%20a%20monolithic,independent%20from%20other%20computing%20applications." rel="noopener ugc nofollow" target="_blank">单片</a>应用程序分成多个更小的应用程序，每个更小的应用程序负责产品的一个独特功能。</p><p id="a4b2" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">为了理解微前端架构，让我们考虑两个不同的应用:<strong class="jr hi">产品列表</strong>和<strong class="jr hi">购物车。</strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es kt"><img src="../Images/5116f452ddc5ae190e3475ca99ea7a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1PdBTCisSuGvoevNGuEncQ.png"/></div></div></figure><p id="6de3" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">每个应用程序都是一个单独的独立应用程序(这是micro frontend的主要优势之一)，开发这些独立应用程序的团队可以做出自己的技术决策，如选择技术(如Angular、React或Vue)。</p><p id="8a37" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在这里，我们试图阻止这两个不同的应用程序之间的任何直接通信。</p><p id="a93c" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">相反，我们的产品应用程序可能会发出某种API请求来管理购物车应用程序中的所有数据，每当我们的购物车应用程序被加载以查看添加的产品时，购物车应用程序都会发出相同的API请求，并获取购物车中的产品列表。因此，这两个应用程序之间没有直接通信。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ku"><img src="../Images/6ab9563cd763f7bcfa6554f245622561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptPjUILleVKDqzAcv4DsCg.png"/></div></div></figure><p id="ee4c" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">因此，为了在屏幕上显示每个应用程序，我们需要创建一个<strong class="jr hi">容器</strong>微前端应用程序，并有3个小项目。</p><h2 id="c695" class="kv kw hh bd kx ky kz la lb lc ld le lf jy lg lh li kc lj lk ll kg lm ln lo lp bi translated"><strong class="ak">在本文中，我们将只创建一个产品和容器应用程序，同样，我们可以创建我们的购物车应用程序。</strong></h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lq"><img src="../Images/7d4b8799e500a30f22ab89f276ba24ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMESZlHGn4rmhet_K6_QQw.png"/></div></div></figure><p id="e2f4" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这是我们构建每个应用程序的方式。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lr"><img src="../Images/2b09088adede443d7351c3f37f55fae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0fl7tuyPz0njqm4feVSe4A.png"/></div></div></figure><p id="5188" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">让我们首先创建产品应用程序。</p><p id="3133" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们可以使用下面的命令安装依赖项。</p><pre class="ix iy iz ja fd ls lt lu lv aw lw bi"><span id="584c" class="kv kw hh lt b fi lx ly l lz ma">npm install webpack@5.68.0 webpack-cli@4.9.2 webpack-dev-server@4.7.4 faker@5.1.0 html-webpack-plugin@5.5.0</span></pre><p id="7e68" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在产品<em class="ko"> index.js </em>中，我们使用<a class="ae ks" href="https://www.npmjs.com/package/faker" rel="noopener ugc nofollow" target="_blank">faker</a>库为产品列表生成一些假数据。下面是示例代码。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="aa13" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们将使用Webpack依赖来运行这段代码。</p><p id="f069" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Webpack的一点背景:</p><p id="5765" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><strong class="jr hi">这是一个工具，可以让你将你的JavaScript应用与所有的依赖项捆绑在一起。</strong></p><p id="69d7" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">要运行我们的应用程序，请将脚本更改为产品应用程序中的<em class="ko"> package.json </em>文件内的Webpack。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="83cb" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">然后创建一个<em class="ko"> webpack.config.js </em>文件，并添加一个Webpack dev服务器，该服务器从webpack进程获取输出，并使其在浏览器中可用，并为其提供端口8081。</p><p id="0b4e" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们使用的是<a class="ae ks" href="https://www.npmjs.com/package/html-webpack-plugin" rel="noopener ugc nofollow" target="_blank"><strong class="jr hi">HtmlWebpackPlugin</strong></a>，它查看来自Webpack的不同文件，并自动更新HTML文档(我们在公共文件夹中有我们的index.html文件)。</p><p id="7bd1" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><em class="ko">product/web pack . config . js</em></p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="373e" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><em class="ko">product/public/index . html</em></p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="51bc" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">现在，让我们创建容器应用程序，并弄清楚如何创建两个微前端应用程序(产品和容器)。</p><p id="7464" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">安装所有的依赖项，我们将为容器<em class="ko"> src &gt;索引创建文件夹。js，公开&gt;索引。HTML </em>和<em class="ko"> webpack.config.js </em></p><p id="9f9b" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><strong class="jr hi">实现模块联合:</strong></p><p id="5505" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">为了集成<strong class="jr hi">产品和容器应用程序，我们需要在webpack.config.js中添加<a class="ae ks" href="https://www.npmjs.com/package/module-federation-plugin" rel="noopener ugc nofollow" target="_blank"> ModuleFederationPlugin </a>。</strong></p><p id="953e" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们的主机(容器)需要决定我们想要从远程设备(产品)获取哪个文件，在我们的主机中唯一可以访问的文件是来自产品的index.js文件。为此，我们要求在我们产品的webpack.config.js文件中有<strong class="jr hi"> ModuleFederationPlugin </strong>。</p><p id="7455" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><em class="ko">product/web pack . config . js</em></p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="3636" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><em class="ko">container/web pack . config . js</em></p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="37c0" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">现在在主机(容器)内部，我们将反射入口点以异步加载product index.js文件，因此我们在容器src目录中创建一个bootstrap.js文件。</p><p id="add4" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">容器内部<em class="ko"> src/bootstrap.js </em></p><pre class="ix iy iz ja fd ls lt lu lv aw lw bi"><span id="8042" class="kv kw hh lt b fi lx ly l lz ma">import ‘products/ProductsIndex’;</span><span id="d904" class="kv kw hh lt b fi md ly l lz ma">console.log(‘Container!’);</span></pre><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="d90e" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">容器内部<em class="ko"> src/index.js </em></p><p id="b65c" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们将使用导入功能来异步加载文件。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="57cd" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">因为我们在容器应用程序中运行产品应用程序的代码，所以我们需要在容器的index.html中添加“dev-products<em class="ko">”</em>id<em class="ko"/>，并尝试使用npm run start在<strong class="jr hi"> localhost:8080 </strong>运行我们的容器应用程序。</p><p id="31f7" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">下面是我们的容器应用程序的样子:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es me"><img src="../Images/3e355e470dd7c52fbe1ca14b5e720af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wa3lVOdAAwjYqLVKj8Qhag.png"/></div></div></figure><blockquote class="kl km kn"><p id="68ea" class="jp jq ko jr b js jt ii ju jv jw il jx kp jz ka kb kq kd ke kf kr kh ki kj kk ha bi translated"><strong class="jr hi">了解</strong> <strong class="jr hi">模块联盟插件:</strong></p></blockquote><p id="96d2" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">a)产品<em class="ko"> webpack.config.js </em>文件内的模块联合插件:</p><p id="0382" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">模块联盟插件会给我们</p><ol class=""><li id="9aa0" class="mf mg hh jr b js jt jv jw jy mh kc mi kg mj kk mk ml mm mn bi translated"><em class="ko"> remoteEntry.js </em>文件，这是一个清单文件，它列出了由模块联合插件发出的所有文件，还提供了如何使用它们的说明。</li><li id="c2f0" class="mf mg hh jr b js mo jv mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><em class="ko"> src/index.js </em>文件是<em class="ko"> src/index.js </em>的版本，可以安全的加载到浏览器中。</li><li id="9c58" class="mf mg hh jr b js mo jv mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><em class="ko"> faker.js </em>文件，可以安全加载到浏览器的faker版本。</li></ol><p id="9ae4" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">b)容器<em class="ko"> wbpack.config.js </em>文件内的模块联合插件:</p><p id="267c" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们在集成过程中创建了一个<em class="ko"> bootstrap.js </em>文件和一个<em class="ko"> index.js </em>(这里我们使用了异步导入函数)文件，让Webpack意识到在执行<em class="ko"> bootstap.js </em>文件(容器文件)之前，我们必须从产品应用程序中获取一些代码。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mt"><img src="../Images/14b1c0d7720c5ceb67d443a8beb192f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vk3bzuwsuOM3_cJbweppqQ.png"/></div></div></figure><blockquote class="kl km kn"><p id="58a0" class="jp jq ko jr b js jt ii ju jv jw il jx kp jz ka kb kq kd ke kf kr kh ki kj kk ha bi translated"><strong class="jr hi">了解配置选项:</strong></p></blockquote><p id="d8f2" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这对理解模块联合插件选项很重要。</p><ol class=""><li id="686d" class="mf mg hh jr b js jt jv jw jy mh kc mi kg mj kk mk ml mm mn bi translated">对于容器应用</li></ol><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mu"><img src="../Images/69742526ce05d957bd5a57314d6875b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdxF0KFrfCdM64qug3L3xg.png"/></div></div></figure><p id="f4a8" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">所以，第一个选项是“名字”。当我们创建一个主机模块的时候，名字<em class="ko">不会被使用，但是记住我们的容器是主机，它试图从远程(产品应用)使用代码。通常的惯例是无论如何都要加上它。</em></p><p id="ed30" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">第二个选项是远程。远程控制Webpack如何决定是否加载那个<em class="ko"> remoteEntry.js </em>文件。正如我们在容器<em class="ko"> bootstarp.js </em>中看到的，我们有import products/ProductsIndex。</p><blockquote class="kl km kn"><p id="4564" class="jp jq ko jr b js jt ii ju jv jw il jx kp jz ka kb kq kd ke kf kr kh ki kj kk ha bi translated">因此，当我们构建我们的产品并且它被Webpack编译时，Webpack将会看到我们正在尝试导入一个以单词“products”开头的模块。</p></blockquote><p id="ab58" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">如果Webpack在我们的节点模块目录中找不到产品的依赖项，它将查看ModuleFederationPlugin，特别是<strong class="jr hi"> remotes </strong>对象，并查看其中是否有带有单词“products”的键。因此单词“products”(表单<em class="ko"> bootstrap.js </em>)将与“products”(远程对象内的键)匹配，然后Webpack将加载列在products内的<em class="ko"> remoteEntry.js </em>文件。</p><p id="cf4b" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">2.对于产品应用</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mv"><img src="../Images/64100da96da422dea709dbb170e691d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iSZR8es2wuNuBqAobJQrkQ.png"/></div></div></figure><p id="4a80" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这里，名称字符串必须与容器的名称字符串相同。除此之外，我们还有一个文件名来控制<em class="ko"> remoteEntry.js </em>文件的名称。</p><p id="f7de" class="pw-post-body-paragraph jp jq hh jr b js jt ii ju jv jw il jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">最后，我们揭露了。Exposes object控制我们的产品应用程序中的哪些模块或文件将向外界公开(在我们的例子中是容器)。这里我们公开了模块产品索引，如果有人试图导入产品索引，我们会给他们src/index文件。</p><blockquote class="kl km kn"><p id="9d23" class="jp jq ko jr b js jt ii ju jv jw il jx kp jz ka kb kq kd ke kf kr kh ki kj kk ha bi translated"><strong class="jr hi">结论:</strong></p><p id="e981" class="jp jq ko jr b js jt ii ju jv jw il jx kp jz ka kb kq kd ke kf kr kh ki kj kk ha bi translated">微前端的基本思想是将您的前端分成一系列可独立部署和松散耦合的前端应用程序(称为微前端)。这些微<a class="ae ks" href="https://savansharma22.medium.com/d997a5bbd410#14db" rel="noopener">前端</a>然后被合并/捆绑以创建单个前端应用。</p><p id="b114" class="jp jq ko jr b js jt ii ju jv jw il jx kp jz ka kb kq kd ke kf kr kh ki kj kk ha bi translated">Module Federation plugin为开发人员提供了一种创建多个独立版本的方法，这些版本构成了一个应用程序。任何与Webpack 5.0或更高版本捆绑在一起的JavaScript应用程序都可以在运行时动态加载或与任何其他应用程序共享代码和依赖关系。</p></blockquote></div></div>    
</body>
</html>