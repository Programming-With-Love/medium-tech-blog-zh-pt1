<html>
<head>
<title>Jetpack WindowManager Updates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack WindowManager更新</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/jetpack-windowmanager-updates-8bee061aa2fb?source=collection_archive---------5-----------------------#2021-02-16">https://medium.com/androiddevelopers/jetpack-windowmanager-updates-8bee061aa2fb?source=collection_archive---------5-----------------------#2021-02-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/8e1a363e9f8a31cb895ac08db942c66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zy5IG2inEQSqeWyPJ7vo-g.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Image by <a class="ae hu" href="http://guswinkelman.com/" rel="noopener ugc nofollow" target="_blank">Gus Winkelman</a></figcaption></figure><div class=""/><p id="9a00" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由肯尼斯·福特和皮埃特罗·马吉发布</p><p id="4613" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们很高兴地宣布Jetpack WindowManager库的alpha02版本。Jetpack WindowManager库可以帮助您构建能够识别折叠和铰链等新设备功能的应用程序，因此您可以利用以前不存在的新可能性。当我们开发这个库的时候，我们已经考虑到了你的反馈，并且我们在alpha中继续迭代API来提供一个更干净和更完整的API表面。我们也一直在关注WindowManager空间中可以提供更多功能的不同领域，我们很高兴地宣布，我们正在引入WindowMetrics，以允许您从Android 4.1 (API级别16)开始使用这些<a class="ae hu" href="https://developer.android.com/reference/kotlin/android/view/WindowMetrics" rel="noopener ugc nofollow" target="_blank">新的Android 11 API</a>。</p><p id="4b2d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在初始版本发布后，我们花了很多时间来审查您的反馈，并且在此版本中我们做了许多更改。请继续阅读，了解有关这些更新的更多信息！</p><h2 id="fc05" class="js jt hx bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">创建窗口管理器</h2><p id="97f9" class="pw-post-body-paragraph iu iv hx iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">现在有一个简单的构造函数，它带有一个指向可视实体上下文的参数(就像当前的活动一样):</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="4a60" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最初的<a class="ae hu" href="https://developer.android.com/reference/androidx/window/WindowManager#WindowManager(android.content.Context,%20androidx.window.WindowBackend)" rel="noopener ugc nofollow" target="_blank">构造函数</a>仍然可用，但是现在已经废弃了。</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="1102" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您想要使用自定义WindowBackend在常规设备或仿真器上模拟可折叠设备时，可以在您的测试中使用这个原始构造函数。您可以在<a class="ae hu" href="https://github.com/android/user-interface-samples/tree/main/WindowManager" rel="noopener ugc nofollow" target="_blank">更新示例</a>中找到参考实现。</p><p id="b429" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然在这个版本中，您的应用程序仍然可以传递一个空引用作为WindowBackend，但我们计划在将来使WindowBackend引用成为一个必需的参数，从而消除了这种反对意见，以促进它用于测试目的。</p><h2 id="5215" class="js jt hx bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">添加了显示功能，DeviceState已弃用</h2><p id="ff5b" class="pw-post-body-paragraph iu iv hx iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">另一个主要变化是弃用了<code class="du ky kz la lb b">DeviceState</code>类以及用它来通知应用程序的回调。这种弃用是为了转向更通用的API，允许系统返回关于所有可用于您的应用程序的<code class="du ky kz la lb b">DisplayFeature</code>实例的信息，而不是定义一个整体的设备状态。我们计划在这个库的未来版本中移除<code class="du ky kz la lb b">DeviceState</code>类。</p><p id="2891" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">alpha02版本引入了一个新的<code class="du ky kz la lb b">DisplayFeature</code>类，它有一个更新的回调契约，在<code class="du ky kz la lb b">DisplayFeature</code>发生变化时通知您的应用程序。您可以使用以下方法注册/取消注册回调:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="26fd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du ky kz la lb b">WindowLayoutInfo</code>包含位于窗口内的<code class="du ky kz la lb b"><a class="ae hu" href="https://developer.android.com/reference/androidx/window/DisplayFeature" rel="noopener ugc nofollow" target="_blank">DisplayFeature</a></code>的实例列表。</p><p id="6bcc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du ky kz la lb b">FoldingFeature</code>类实现了<code class="du ky kz la lb b">DisplayFeature</code>接口，它包含了关于这些类型特性的信息:</p><pre class="ks kt ku kv fd lc lb ld le aw lf bi"><span id="3320" class="js jt hx lb b fi lg lh l li lj">TYPE_FOLD</span><span id="5d3d" class="js jt hx lb b fi lk lh l li lj">TYPE_HINGE</span></pre><p id="61aa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以及它们可能的折叠状态:</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ll"><img src="../Images/f03252eff4fabaa03df939a9cc740019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIugFInqzzpGOubfrU01wA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">The possible Display Feature states: Flat, Half-opened, and Flipped respectively</figcaption></figure><p id="272f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意<code class="du ky kz la lb b">DeviceState</code>姿势<code class="du ky kz la lb b">POSTURE_UNKNOWN</code>和<code class="du ky kz la lb b">POSTURE_CLOSED</code>没有等效状态。</p><p id="a9be" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要访问新状态，您可以使用返回给注册回调的<code class="du ky kz la lb b">FoldingFeature</code>信息:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="c560" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以在<a class="ae hu" href="https://github.com/android/user-interface-samples/tree/main/WindowManager" rel="noopener ugc nofollow" target="_blank">示例</a>中找到如何使用该信息的示例。</p><h2 id="a2aa" class="js jt hx bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">更好的回拨注册</h2><p id="4eec" class="pw-post-body-paragraph iu iv hx iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">我们还改进了上面显示的回调API的健壮性。在以前版本的库中，如果应用程序在窗口可用之前注册了一个回调，这个操作会抛出一个异常。</p><p id="7f04" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Alpha02中，我们改变了这种行为。只要对您的架构有意义，您就可以注册这些回调；当窗口变为可用时，库将发送初始的<code class="du ky kz la lb b">WindowLayoutInfo</code>。</p><h2 id="ea28" class="js jt hx bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">R8规则</h2><p id="e27a" class="pw-post-body-paragraph iu iv hx iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">我们向库R8配置中添加了“保持”规则，以维护由于内部模块组织结构而可能被剥离的方法和类。这些规则会自动合并到最终的应用程序R8配置中，以避免alpha01出现的崩溃。</p><h1 id="0ea5" class="lm jt hx bd ju ln lo lp jy lq lr ls kc lt lu lv kf lw lx ly ki lz ma mb kl mc bi translated">窗口度量</h1><p id="58bd" class="pw-post-body-paragraph iu iv hx iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">由于历史上的命名惯例和不同的窗口管理器状态，很难在Android中获得当前窗口大小的信息。Android 11中一些方法的弃用，如<code class="du ky kz la lb b">Display#getSize</code>和<code class="du ky kz la lb b">Display#getMetrics</code>，以及新API中窗口大小的使用，凸显了在可折叠设备上从全屏转向多窗口和自适应界面的上升趋势。为了缓解这种过渡，我们在Android 11中添加了<a class="ae hu" href="https://developer.android.com/reference/android/view/WindowMetrics" rel="noopener ugc nofollow" target="_blank">window metrics API</a>。</p><p id="32cb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du ky kz la lb b">WindowMetrics</code>让您轻松查询有关当前窗口状态和当前系统状态下最大窗口大小的信息，所有这些都在第一次布局之前完成。例如，像Surface Duo这样的设备有一个默认配置，应用程序在一个屏幕上启动，但可以通过铰链扩展到两个屏幕。在默认状态下，“getMaximumWindowMetrics”会报告应用程序所在屏幕的边界。当应用程序移动到跨越状态时，API返回反映新状态的边界。在onCreate期间尽早提供这一点，它提供了您的活动可能需要的信息，以便尽早执行计算或做出决策，这样您就可以在第一时间选择正确的布局。</p><p id="2e6a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">API结果不包括关于系统插件的信息，如状态栏或导航栏，因为在我们支持的所有Android版本的第一次布局通过之前，这些值不可用。Chris Banes的博客文章是关于使用<a class="ae hu" href="https://developer.android.com/reference/androidx/core/view/ViewCompat" rel="noopener ugc nofollow" target="_blank"> ViewCompat </a>获取系统插件信息的很好的资源。这些边界也不会对布局膨胀时可能发生的布局参数的任何变化做出反应。</p><p id="9154" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如前所述，要访问这些API，您需要获得WindowManager对象的一个实例。</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="340b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从这里，您现在可以访问<a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/window/WindowMetrics" rel="noopener ugc nofollow" target="_blank">window metrics API</a>，并且可以轻松访问当前窗口大小以及最大值的信息。</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="41fe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在通货膨胀之前，这些信息可以用来做出布局选择的一个例子是，如果你的应用程序在手机和平板电脑上有非常不同的布局或导航模式。如果你认为你的用户可能会被一个不和谐的改变弄糊涂，你可能会希望选择那些部分是不变的，而不管当前的窗口大小。在选择要展开的布局之前，您可以在这里使用最大窗口度量。</p><p id="518a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然Android 11平台API包括一个在onCreate期间获取insets的API，但我们没有将它带到Jetpack WindowManager库中，因为我们希望了解开发人员在这一领域会发现什么有用。在第一次布局之前，请让我们知道您是否有想要的值，或者使编程布局更容易的抽象。</p><p id="dddf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们希望，让这些API对旧版本的Android可用，可以让你构建能够响应窗口大小变化的应用，并帮助你从上面提到的一些过时的API中迁移出来。</p><h1 id="004f" class="lm jt hx bd ju ln lo lp jy lq lr ls kc lt lu lv kf lw lx ly ki lz ma mb kl mc bi translated">保持联络</h1><p id="4cb1" class="pw-post-body-paragraph iu iv hx iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">我们希望您能对这些API提出反馈，尤其是您认为缺少的或者会让您的开发工作变得更容易的东西。我们知道有一些我们可能没有想到的用例，所以请在<a class="ae hu" href="https://issuetracker.google.com/issues/new?component=840395&amp;template=1412556" rel="noopener ugc nofollow" target="_blank">公共跟踪器</a>上提交错误或功能请求。</p></div></div>    
</body>
</html>