<html>
<head>
<title>GraphQL at the REST-aurant</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">休息时的graph QL-aurant</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/graphql-at-the-rest-aurant-f4091054e82a?source=collection_archive---------1-----------------------#2018-02-02">https://medium.com/javascript-scene/graphql-at-the-rest-aurant-f4091054e82a?source=collection_archive---------1-----------------------#2018-02-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="25b1" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">GraphQL的有趣介绍</h2></div><figure class="iw ix iy iz fd ja"><div class="bz dy l di"><div class="jb jc l"/></div><figcaption class="jd je et er es jf jg bd b be z dx">A screencast version with of this post</figcaption></figure><p id="a2e8" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是周三晚上，另一个很棒的聚会在我最喜欢的活动场所举办:the REST-aurant。</p><p id="2f3d" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">讲座结束后，与会者可以在不同的“路线”上获得不同的食物。</p><figure class="iw ix iy iz fd ja er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kd"><img src="../Images/ae5a895fc03665d39f79bcfebc487b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wivPzYUhsMhELouh_BvsyA.png"/></div></div><figcaption class="jd je et er es jf jg bd b be z dx">Different routes to get salads or burgers at the REST-aurant.</figcaption></figure><p id="6e54" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">他们通常有同样的两种选择:鳄梨沙拉和虾汉堡。鳄梨<em class="kk">沙拉</em>，还有<em class="kk">虾</em>汉堡。但是我真正渴望的是<em class="kk">虾沙拉</em>！但遗憾的是，没有<code class="du kl km kn ko b">GET /salads?with=shrimps</code>路线。那么我能做什么呢？</p><p id="89f7" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我当然是从汉堡里拿虾了！</p><p id="fcb6" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">所以我去了<code class="du kl km kn ko b">GET /salads</code>路线，然后排队从<code class="du kl km kn ko b">GET /burgers</code>买了3个汉堡。我走到餐桌旁的一个空座位上，从汉堡里挑出虾，然后扔掉其余的。男孩，我很高兴有我的虾沙拉。</p><h1 id="e41e" class="kp kq hh bd kr ks kt ku kv kw kx ky kz in la io lb iq lc ir ld it le iu lf lg bi translated">提取不足和提取过多</h1><p id="22e7" class="pw-post-body-paragraph jh ji hh jj b jk lh ii jm jn li il jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">吃完虾沙拉后，我有点难过。我不仅浪费时间排队两次，而不是和我的朋友出去玩，我还不得不扔掉许多食物。</p><p id="3224" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">但至少我现在有一个很好的例子来解释蚀刻不足和蚀刻过度的概念。来做点编码吧！</p><p id="1300" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><em class="kk">(您可以在</em><a class="ae lm" href="https://github.com/gr2m/restaurant-graphql" rel="noopener ugc nofollow" target="_blank"><em class="kk">github.com/gr2m/restaurant-graphql</em></a><em class="kk">找到所有代码示例)</em></p><p id="469f" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是一个用<a class="ae lm" href="https://expressjs.com" rel="noopener ugc nofollow" target="_blank"> express </a>构建的简单Node.js服务器，它公开了沙拉和汉堡的两条路径。默认情况下，两者都分别返回一个沙拉/汉堡，并接受一个可选的<code class="du kl km kn ko b">?count</code>查询参数，通过一个请求获取多个沙拉/汉堡</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="15a3" class="lr kq hh ko b fi ls lt l lu lv">const express = require(“express”);<br/>const app = express();</span><span id="0f8a" class="lr kq hh ko b fi lw lt l lu lv">// define a salad and a burger<br/>const salad = { avocado: 1, mango: 1, tomato: 0.2, arugula: true, onion: true };<br/>const burger = { buns: 2, shrimp: 1, egg: 1, lettuce: 2.5, mayo: true };</span><span id="1484" class="lr kq hh ko b fi lw lt l lu lv">// define arrays of 100 each<br/>const salads = new Array(100).fill(salad);<br/>const burgers = new Array(100).fill(burger);</span><span id="e67f" class="lr kq hh ko b fi lw lt l lu lv">// define the routes with the optional count query parameter<br/>app.get(“/salads”, ({ query: { count } }, res) =&gt; res.json(get(salads, count)));<br/>app.get(“/burgers”, ({ query: { count } }, res) =&gt;<br/> res.json(get(burgers, count))<br/>);</span><span id="f45f" class="lr kq hh ko b fi lw lt l lu lv">// helper method to get a slice of the array based on count<br/>const get = (what, count) =&gt; what.splice(0, parseInt(count) || 1);</span><span id="801e" class="lr kq hh ko b fi lw lt l lu lv">// start the server at localhost:4000<br/>app.listen(4000);</span></pre><p id="fcfe" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">打开<a class="ae lm" href="http://localhost:4000/salads" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/salads</a>会是这样的</p><figure class="iw ix iy iz fd ja er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es lx"><img src="../Images/05115778e984ca29b17f45be88da57b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kHxLJQkbF6-f9XJ9XSnl5w.png"/></div></div><figcaption class="jd je et er es jf jg bd b be z dx">Firefox renders JSON responses nicely by default</figcaption></figure><p id="9bd3" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">切换到客户端。</p><p id="1e74" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><em class="kk">(注意:如果你在浏览器中遇到错误，请在Chrome中尝试，因为它对async/await有最好的支持，这使得代码示例更简单)</em></p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="9cf9" class="lr kq hh ko b fi ls lt l lu lv">// helper function to send a GET request to given route<br/>function get(path) {<br/>  return (await fetch(`${location.protocol}//${location.host}${path}`)).json()<br/>}<br/>let [salad] = await get("/salads");<br/>// salad: {"avocado":1,"mango":1,"tomato":0.2,"arugula":true,"onion":true}<br/>delete salad.tomato;<br/>// TODO: Tell the team to list tomato in the salds route menu!<br/>let burgers = await get("/burgers?count=3");<br/>// burgers: [<br/>// {"buns":2,"shrimp":1,"egg":1,"lettuce":2.5,"mayo":true},<br/>// {"buns":2,"shrimp":1,"egg":1,"lettuce":2.5,"mayo":true},<br/>// {"buns":2,"shrimp":1,"egg":1,"lettuce":2.5,"mayo":true}]<br/>Object.assign(salad, {<br/>  shrimps: burgers.reduce(<br/>    (numShrimps, burger) =&gt; numShrimps + burger.shrimp,<br/>    0<br/>  )<br/>});<br/>// salad: {"avocado":1,"mango":1,"arugula":true,"onion":true, shrimp: 3}</span></pre><p id="e5cb" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我通过取<code class="du kl km kn ko b">GET /salads</code>路线得到一份沙拉。在第一次请求后，我仍然缺少配料，所以我必须发送另一个请求。这就是所谓的<strong class="jj hi">欠取</strong>。</p><p id="4bf0" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然后我从<code class="du kl km kn ko b">GET /burgers?count=3</code>拿了3个汉堡。之后，我把汉堡减少到虾的总数。我的虾沙拉需要3只虾，但我收到的却是3个汉堡，配料齐全。这就是所谓的<strong class="jj hi">超取</strong>。</p><p id="edc7" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">概括起来</p><ol class=""><li id="497d" class="ly lz hh jj b jk jl jn jo jq ma ju mb jy mc kc md me mf mg bi translated">给我拿了沙拉，但是没有虾</li><li id="7d14" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc md me mf mg bi translated"><strong class="jj hi">给我买了虾，但我不得不扔掉剩下的汉堡。</strong></li></ol><h1 id="e929" class="kp kq hh bd kr ks kt ku kv kw kx ky kz in la io lb iq lc ir ld it le iu lf lg bi translated">GraphQL简介</h1><p id="d03a" class="pw-post-body-paragraph jh ji hh jj b jk lh ii jm jn li il jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">REST-aurant团队是非常善良和有环保意识的人。他们不想看到食物被浪费，经过一些研究后，他们发现GraphQL似乎完美地解决了这个问题。</p><p id="45b4" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对于下一次聚会，团队设置了第三条路线:<code class="du kl km kn ko b">POST /graphql</code>。</p><p id="570a" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">GraphQL不需要书面菜单，相反，他们设置了一个嵌入文档的终端，与会者可以使用它来编写和发布他们的查询。他们称之为GraphQL Query-aitor 3000！</p><figure class="iw ix iy iz fd ja er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es mm"><img src="../Images/fc748c037f18f382a7a7e33b5da36380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HMc5LqbWs3d8qhSY7kiMmQ.png"/></div></div></figure><p id="6bd4" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">GraphQL Query-aitor 3000只是GraphQL的一个别出心裁的名字(注意<em class="kk"> i </em>)，这是一个简单的web表单，用于发送带有内置自动完成功能的GraphQL查询。如果你不知道GraphiQL，它的发音有点难，所以人们给它起了不同的名字，比如GitHub的explorer。顺便说一下，它的发音像“图形:)</p><figure class="iw ix iy iz fd ja er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es lx"><img src="../Images/26a6d9347a5748aa8ea2981bdaad0a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nZ31ms3EbxevexAMP5kgag.png"/></div></div><figcaption class="jd je et er es jf jg bd b be z dx">The GraphiQL web application</figcaption></figure><p id="907e" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Graphiql会在您键入时显示所有可用选项。不再需要猜测，不再需要查找属性名，最重要的是，不再需要不同步的文档，因为文档是从服务器和客户机使用的相同模式中生成的。例如，您可以在GraphiQL的自动完成下拉列表中看到“tomato ”,而在<code class="du kl km kn ko b">GET /salads</code>路线的菜单中却找不到它。</p><p id="0b28" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">除了一份沙拉中的番茄和三个汉堡中的虾之外，请求所有配料的完整查询如下所示</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="cf3a" class="lr kq hh ko b fi ls lt l lu lv">{<br/>  salads {<br/>    avocado<br/>    arugula<br/>    mango<br/>    onion<br/>  }<br/>  burgers(count:3) {<br/>    shrimp<br/>  }<br/>}</span></pre><p id="a2cb" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">来自服务器的响应遵循我的查询的树结构，并且它完全包括我所要求的，不多也不少。</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="05bd" class="lr kq hh ko b fi ls lt l lu lv">{<br/>  "data": {<br/>    "salads": [{"avocado":1,"arugula":true,"mango":1,"onion":true}],<br/>    "burgers": [{"shrimp":1},{"shrimp":1},{"shrimp":1}]<br/>  }<br/>}</span></pre><h1 id="1a1d" class="kp kq hh bd kr ks kt ku kv kw kx ky kz in la io lb iq lc ir ld it le iu lf lg bi translated">GraphQL:你需要的就是你得到的。</h1><p id="3068" class="pw-post-body-paragraph jh ji hh jj b jk lh ii jm jn li il jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">以下是一些关于GraphQL的事实:</p><ul class=""><li id="8975" class="ly lz hh jj b jk jl jn jo jq ma ju mb jy mc kc mn me mf mg bi translated">就像REST一样，GraphQL是一个<strong class="jj hi">规范，而不是一个工具</strong>。</li><li id="6b04" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">对于服务器和客户端来说，它是<strong class="jj hi">语言不可知的</strong></li><li id="78b4" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">GraphQL API是围绕一个模式构建的<strong class="jj hi"/></li><li id="96ca" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">模式是一个简单的文本文档，用作客户机和服务器之间的契约。</li></ul><p id="f771" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们一会儿将深入研究我们的示例应用程序的GraphQL模式。但我想强调的是，GraphQL是语言不可知的，因为它通常与React和Node.js一起出现。原因是React和GraphQL都是脸书的项目。React是一个实际的JavaScript库，而GraphQL只是一个规范，在许多编程语言中已经有了实现。</p><p id="8ad3" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，让我们创建一个名为<code class="du kl km kn ko b">schema.graphql</code>的简单文本文件。GraphQL模式必须遵循所述GraphQL规范的语法。对于我们的示例应用程序，整个模式只有20行:</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="4fd4" class="lr kq hh ko b fi ls lt l lu lv">type Query {<br/>  burgers(count: Int = 1): [Burger]<br/>  salads(count: Int = 1): [Salad]<br/>}</span><span id="e36d" class="lr kq hh ko b fi lw lt l lu lv">type Burger {<br/>  buns: Int!<br/>  shrimp: Float!<br/>  egg: Float!<br/>  lettuce: Boolean!<br/>  mayo: Boolean!<br/>}</span><span id="ef36" class="lr kq hh ko b fi lw lt l lu lv">type Salad {<br/>  avocado: Float!<br/>  mango: Float!<br/>  tomato: Float!<br/>  arugula: Boolean!<br/>  onion: Boolean!<br/>}</span></pre><p id="85a3" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du kl km kn ko b">Query</code>类型定义了可以在根请求什么，在这个例子中是沙拉和汉堡。可以传递一个可选的<code class="du kl km kn ko b">count</code>整数。它默认为1。您可以在上面显示的GraphQL查询中看到这一点。</p><p id="63f0" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du kl km kn ko b">salads</code>返回一个包含沙拉类型项目的数组。沙拉的类型决定了它所有的配料。例如，avocado是一个允许小数点的浮点数。芒果、黄瓜和西红柿也一样。洋葱是一个布尔值，它可以是<code class="du kl km kn ko b">true</code>或<code class="du kl km kn ko b">false</code>。</p><p id="2b8c" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">汉堡包子是<code class="du kl km kn ko b">Int</code>型的，因为谁要半个包子的汉堡？虾和蛋是浮动的，莴苣和蛋黄酱是布尔的。</p><p id="45e8" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在服务器上，添加的代码如下。</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="9747" class="lr kq hh ko b fi ls lt l lu lv">const { readFileSync } = require("fs");<br/>const bodyParser = require("body-parser");<br/>const { graphqlExpress, graphiqlExpress } = require("apollo-server-express");<br/>const { makeExecutableSchema } = require("graphql-tools");</span><span id="16b3" class="lr kq hh ko b fi lw lt l lu lv">const schema = makeExecutableSchema({<br/>  typeDefs: readFileSync("schema.graphql", "utf8"),<br/>  resolvers: {<br/>    Query: {<br/>      salads: (_, { count }) =&gt; get(salads, count),<br/>      burgers: (_, { count }) =&gt; get(burgers, count)<br/>    }<br/>  }<br/>});</span><span id="3a7c" class="lr kq hh ko b fi lw lt l lu lv">app.use("/graphql", bodyParser.json(), graphqlExpress({ schema }));<br/>app.use("/graphiql", graphiqlExpress({ endpointURL: "/graphql" }));</span></pre><p id="f9f5" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">你可以在github.com/gr2m/restaurant-graphql/tree/master/02-graphql看到完整的代码。</p><p id="ec74" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">大部分工作由我们需要首先安装的两个npm模块完成:<a class="ae lm" href="https://npmjs.com/package/apollo-server-express" rel="noopener ugc nofollow" target="_blank"> apollo-server-express </a>和<a class="ae lm" href="https://npmjs.com/package/graphql-tools" rel="noopener ugc nofollow" target="_blank"> graphql-tool </a>。</p><p id="ce3d" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">需要将<code class="du kl km kn ko b">schema.graphql</code>转换成JavaScript表示，这样就可以在<code class="du kl km kn ko b">/graphql</code>路由处理程序中处理它。我读出原始文件，并将其作为<code class="du kl km kn ko b">typeDefs</code>属性传递给<code class="du kl km kn ko b">makeExecutableSchema</code>函数。</p><p id="a5a0" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">另一个属性<code class="du kl km kn ko b">resolvers</code>定义了类似于路由处理程序的查询解析。我重用了本文开头第一个<code class="du kl km kn ko b">server.js</code>代码中显示的<code class="du kl km kn ko b">get</code>助手，根据可选的count参数分别返回沙拉或汉堡数组的切片。</p><p id="6aee" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">最后，我定义了GraphQL中间件，它公开了<code class="du kl km kn ko b">POST /graphql</code>路由以及<code class="du kl km kn ko b">/graphiql</code>的GraphiQL web应用程序。</p><p id="555e" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">将查询发送到JSON对象的“query”键中的“/graphql”端点。</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="46f4" class="lr kq hh ko b fi ls lt l lu lv">// helper function to send a POST request to given route<br/>async function post(path, data) {<br/>  return (await fetch(`${location.protocol}//${location.host}${path}`, {<br/>    method: 'post',<br/>    body: JSON.stringify(data),<br/>    headers: {<br/>      'Content-Type': 'application/json'<br/>    }<br/>  })).json()<br/>}</span><span id="6b14" class="lr kq hh ko b fi lw lt l lu lv">let {data: {salads: [salad], burgers}} = await post('/graphql', {<br/>  query: `{<br/>    burgers(count:3) {<br/>      shrimp<br/>    }<br/>    salads {<br/>      avocado<br/>      arugula<br/>      mango<br/>      onion<br/>    }<br/>  }`<br/>})<br/>// salad: {"avocado":1,"mango":1,"arugula":true,"onion":true}<br/>// burgers: [{"shrimp":1},{"shrimp":1},{"shrimp":1}]</span><span id="25fc" class="lr kq hh ko b fi lw lt l lu lv">Object.assign(salad, {<br/>  shrimps: burgers.reduce((numShrimps, burger) =&gt; numShrimps + burger.shrimp, 0)<br/>})<br/>// salad: {"avocado":1,"mango":1,"arugula":true,"onion":true, shrimp: 3}</span></pre><p id="b640" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">响应返回的正是我需要的配料，我只需要将汉堡减少到3只虾，并将其分配给沙拉对象。</p><p id="25fb" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">概括起来</p><ul class=""><li id="35ec" class="ly lz hh jj b jk jl jn jo jq ma ju mb jy mc kc mn me mf mg bi translated">GraphQL API通常只是另一个REST端点，例如<code class="du kl km kn ko b">POST /graphql</code></li><li id="3118" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">一个查询提取一个数据树来得到确切需要的东西</li><li id="bedf" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">服务器响应匹配查询的树结构</li></ul><p id="425b" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">耶！我现在可以心安理得地享用我的鳄梨虾沙拉了。</p><h1 id="2b62" class="kp kq hh bd kr ks kt ku kv kw kx ky kz in la io lb iq lc ir ld it le iu lf lg bi translated">持久化查询</h1><p id="fe91" class="pw-post-body-paragraph jh ji hh jj b jk lh ii jm jn li il jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">在下一次聚会上，每个人都想试用GraphQL Query-aitor 3000。结果是一条很长的线</p><figure class="iw ix iy iz fd ja er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kd"><img src="../Images/842d61cefef391a74e2e51dfd310eb45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eHd-b3EaKI98RJ3VzF6ZVA.png"/></div></div><figcaption class="jd je et er es jf jg bd b be z dx">Long lines at the GraphQL terminal</figcaption></figure><p id="d9e3" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">准确地得到我们想要的很好，但是每次输入查询比从<code class="du kl km kn ko b">GET /burgers</code>获取一个汉堡要花费更长的时间。并且在发送了<code class="du kl km kn ko b">POST /graphql</code>请求之后，服务器必须当场处理新订单。</p><p id="67fe" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">REST-aurant团队再次聚在一起，考虑一个解决方案，使GraphQL查询的发布和处理更加高效。他们提出了一个解决方案:记住查询！每当有人发布一个查询，他们会被问及是否希望下次记住它，并收到一个参考ID作为回报。</p><p id="b3df" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">该团队还在下一次活动之前发送电子邮件，要求与会者预先注册他们的问题。有了这些预先的信息，团队就可以准备一些食物，这也减少了加工时间。</p><p id="4da6" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">持久化查询是用唯一ID存储在键/值存储中的查询字符串。在我们的服务器示例中，我将创建一个<code class="du kl km kn ko b">persisted-queries.js</code>，它定义了一个id为<code class="du kl km kn ko b">1</code>的查询:</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="7d2b" class="lr kq hh ko b fi ls lt l lu lv">module.exports = {<br/>  1: `{<br/>  burgers(count:3) {<br/>    shrimp<br/>  }<br/>  salads {<br/>    avocado<br/>    arugula<br/>    mango<br/>    onion<br/>  }<br/>}`<br/>};</span></pre><p id="ad3d" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在服务器上，我必须添加几行代码来加载<code class="du kl km kn ko b">persisted-queries.js</code>文件，并添加中间件来检查是否发布了<code class="du kl km kn ko b">id</code>属性</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="ef81" class="lr kq hh ko b fi ls lt l lu lv">const persistedQueries = require("./persisted-queries");</span><span id="ebb4" class="lr kq hh ko b fi lw lt l lu lv">app.use("/graphql", bodyParser.json(), (req, res, next) =&gt; {<br/>  if (persistedQueries[req.body.id]) {<br/>    req.body.query = persistedQueries[req.body.id];<br/>  }<br/>  next();<br/>});</span></pre><p id="4755" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果已经发布了一个<code class="du kl km kn ko b">id</code>,并且存在一个具有所传递的ID的持久化查询，则从持久化查询存储中为该ID设置查询，并像以前一样继续查询处理。</p><p id="0a33" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我不再需要发布查询，取而代之的是我只发布我的id，这是一个。为了在浏览器中获得如上所示的相同结果，我不再需要发送完整的查询:</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="a287" class="lr kq hh ko b fi ls lt l lu lv">let {data: {salads: [salad], burgers}} = await post(‘/graphql’, {<br/>  id: 1<br/>})</span></pre><p id="2933" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">结果和以前一样，但是相比之下，请求的大小是最小的。这会对性能产生很大的影响，因为GraphQL查询会变得非常复杂，因此请求也会变大。并且上游连接通常也比下游连接差得多。</p><p id="53ad" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对于REST-aurant团队来说，提前知道查询是非常好的。查询可以预先编译，数据可以更好地缓存。一些GraphQL APIs甚至完全禁用非持久化查询，以提高安全性和最大化效率。</p><p id="d1bc" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">概括起来</p><ul class=""><li id="0279" class="ly lz hh jj b jk jl jn jo jq ma ju mb jy mc kc mn me mf mg bi translated">持久化查询不是GraphQL规范的一部分，而是一个常见的实现细节</li><li id="ada6" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">持久化查询存储在服务器上，客户端只发送查询id</li><li id="f6f0" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">只发送一个ID而不是一个复杂的查询可以减少请求的大小</li><li id="ae9c" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">持久化查询可以在服务器上预先编译</li><li id="194c" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">为了提高安全性，可以完全禁用非持久化查询</li></ul><h1 id="fca2" class="kp kq hh bd kr ks kt ku kv kw kx ky kz in la io lb iq lc ir ld it le iu lf lg bi translated">突变</h1><p id="c196" class="pw-post-body-paragraph jh ji hh jj b jk lh ii jm jn li il jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">REST-aurant越来越受欢迎，通常情况下，在每个人都可以吃一口之前，活动的食物就用完了。到目前为止，100份沙拉和100个汉堡由一家餐饮公司提供，但该团队决定他们将雇用一个烹饪团队，可以制作更多的汉堡和沙拉来满足不断增长的需求。</p><p id="6e3b" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">突变是GraphQL规范的一部分，必须在GraphQL模式中定义<br/>。只有4条附加线路</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="e745" class="lr kq hh ko b fi ls lt l lu lv">type Mutation {<br/>  addBurgers(count: Int = 1): Int<br/>  addSalads(count: Int = 1): Int<br/>}</span></pre><p id="8272" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">首先，我添加一个突变来添加沙拉。变异接受一个可选的count参数，默认为1。该突变将返回一个整数，即可用沙拉的总量。汉堡也一样。</p><p id="68bc" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">添加一份沙拉和三个汉堡的GraphQL查询如下所示:</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="6317" class="lr kq hh ko b fi ls lt l lu lv">mutation {<br/>  addSalads<br/>  addBurgers(count: 3)<br/>}</span></pre><p id="0d2a" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">变异必须从关键字<code class="du kl km kn ko b">mutation</code>开始。您可以在一个请求中发送多个突变，这是REST APIs的另一个优点。您不能将变异与查询结合起来，但是如果您愿意，可以定义变异响应。</p><p id="c62d" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对于上面的查询，响应将如下所示</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="9076" class="lr kq hh ko b fi ls lt l lu lv">{<br/>  "data": {<br/>    "addSalads": 1,<br/>    "addBurgers": 3<br/>  }<br/>}</span></pre><p id="6994" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在服务器代码中，我们现在将<code class="du kl km kn ko b">salads</code>和<code class="du kl km kn ko b">burgers</code>设置为空数组，并用<code class="du kl km kn ko b">Mutation</code>属性修改<code class="du kl km kn ko b">resolvers</code>对象:</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="1a46" class="lr kq hh ko b fi ls lt l lu lv">// start with empty salad &amp; burger arrays now<br/>const salads = [];<br/>const burgers = [];</span><span id="e8b3" class="lr kq hh ko b fi lw lt l lu lv">// add mutation resolvers<br/>const schema = makeExecutableSchema({<br/>  typeDefs: readFileSync("schema.graphql", "utf8"),<br/>  resolvers: {<br/>    Query: {<br/>      salads: (_, { count }) =&gt; get(salads, count),<br/>      burgers: (_, { count }) =&gt; get(burgers, count)<br/>    },<br/>    Mutation: {<br/>      addSalads: (_, { count }) =&gt; {<br/>        salads.push(...new Array(count).fill(salad));<br/>        return salads.length;<br/>      },<br/>      addBurgers: (_, { count }) =&gt; {<br/>        burgers.push(...new Array(count).fill(burger));<br/>        return burgers.length;<br/>      }<br/>    }<br/>  }<br/>});</span></pre><p id="19a1" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">调用<code class="du kl km kn ko b">addSalads</code>和<code class="du kl km kn ko b">addBurgers</code>函数时，count参数默认为模式中定义的<code class="du kl km kn ko b">1</code>。基于<code class="du kl km kn ko b">count</code>参数添加一个或多个沙拉/汉堡。然后这两个函数返回各自数组的长度。</p><p id="c5ab" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">从浏览器发送变异与发送查询非常相似:</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="5a65" class="lr kq hh ko b fi ls lt l lu lv">await post('/graphql', {<br/>  query: `mutation {<br/>    addSalads<br/>    addBurgers(count: 3)<br/>  }`<br/>})</span></pre><p id="423d" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">概括起来</p><ul class=""><li id="c8d2" class="ly lz hh jj b jk jl jn jo jq ma ju mb jy mc kc mn me mf mg bi translated">突变用于<strong class="jj hi">创建、更新或删除数据</strong>。</li><li id="f3bb" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated"><strong class="jj hi">多个突变</strong>可通过单个请求发送。它们按顺序被<strong class="jj hi">处理。</strong></li><li id="1a84" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">变异不能与查询结合，但是变异响应可以被过滤</li></ul><h1 id="da02" class="kp kq hh bd kr ks kt ku kv kw kx ky kz in la io lb iq lc ir ld it le iu lf lg bi translated">GraphQL订阅</h1><p id="f3d9" class="pw-post-body-paragraph jh ji hh jj b jk lh ii jm jn li il jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">当剩下的沙拉或汉堡卖完了，排在队伍前面反复问:“可以吃我的沙拉了吗？”。相反，我希望服务器告诉我什么时候有足够的食物来满足我的查询。这是订阅的一个常见用例。</p><p id="29bd" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">订阅是GraphQL的第三种操作类型。GraphiQL对websockets上的订阅有内置的<br/>支持，它们可以像<br/>查询和突变一样提交。提交后，服务器会回复，一旦有更改，数据就会出现。所以让我们做出改变吧！</p><figure class="iw ix iy iz fd ja er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es mo"><img src="../Images/b8b51096b5ff73576512b2ad24516276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JBY5drgDm3MjPbvDFMdPCQ.gif"/></div></div><figcaption class="jd je et er es jf jg bd b be z dx">Subscription on the left shows updates from mutations on the right.</figcaption></figure><p id="a4c1" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我在一个浏览器中保留订阅，而在另一个浏览器中发布变化。在我发布突变后，第一个窗口上的数字也随之改变。</p><p id="ef08" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">让我们看看实现是什么样子的。</p><p id="7460" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对<code class="du kl km kn ko b">schema.graphql</code>的添加也相当简单:</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="c2fb" class="lr kq hh ko b fi ls lt l lu lv">type Subscription {<br/>  foodAdded: Stats<br/>}</span><span id="b7cb" class="lr kq hh ko b fi lw lt l lu lv">type Stats {<br/>  burgers: Int<br/>  salads: Int<br/>}</span></pre><p id="3f3d" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">将使用类型<code class="du kl km kn ko b">Stats</code>调用<code class="du kl km kn ko b">foodAdded</code>订阅，该类型具有可用沙拉和汉堡总数的整数属性</p><p id="9716" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对服务器的添加稍微复杂一些:</p><pre class="iw ix iy iz fd ln ko lo lp aw lq bi"><span id="6c51" class="lr kq hh ko b fi ls lt l lu lv">// load additional libraries needed for subscriptions<br/>const { execute, subscribe } = require("graphql");<br/>const { SubscriptionServer } = require("subscriptions-transport-ws");<br/>const { PubSub } = require("graphql-subscriptions");<br/>const pubsub = new PubSub();</span><span id="3b0c" class="lr kq hh ko b fi lw lt l lu lv">const getStats = () =&gt; ({ salads: salads.length, burgers: burgers.length });</span><span id="74e6" class="lr kq hh ko b fi lw lt l lu lv">const schema = makeExecutableSchema({<br/>  typeDefs: readFileSync("schema.graphql", "utf8"),<br/>  resolvers: {<br/>    Query: {<br/>      salads: (_, { count }) =&gt; get(salads, count),<br/>      burgers: (_, { count }) =&gt; get(burgers, count)<br/>    },<br/>    Mutation: {<br/>      addSalads: (_, { count }) =&gt; {<br/>        salads.push(...new Array(count).fill(salad));<br/>        // publish the foodAdded and pass the stats<br/>        pubsub.publish("foodAdded", { foodAdded: getStats() });<br/>        return salads.length;<br/>      },<br/>      addBurgers: (_, { count }) =&gt; {<br/>        burgers.push(...new Array(count).fill(burger));<br/>        // publish the foodAdded and pass the stats<br/>        pubsub.publish("foodAdded", { foodAdded: getStats() });<br/>        return burgers.length;<br/>      }<br/>    },<br/>    // add the Subscription property to schema resolvers<br/>    Subscription: {<br/>      foodAdded: {<br/>        subscribe: () =&gt; pubsub.asyncIterator("foodAdded")<br/>      }<br/>    }<br/>  }<br/>});</span><span id="6a8d" class="lr kq hh ko b fi lw lt l lu lv">// add the subscriptionsEndpoint to the /graphiql middleware<br/>app.use(<br/>  "/graphiql",<br/>  graphiqlExpress({<br/>    endpointURL: "/graphql",<br/>    subscriptionsEndpoint: "ws://localhost:4000/subscriptions"<br/>  })<br/>);</span><span id="e96f" class="lr kq hh ko b fi lw lt l lu lv">// instead of app.listen(4000), create a new server instance<br/>const server = createServer(app);<br/>server.listen(4000);</span><span id="47ed" class="lr kq hh ko b fi lw lt l lu lv">// ... which can be passed to the SubscriptionServer constructor<br/>new SubscriptionServer(<br/>  { schema, execute, subscribe },<br/>  { path: "/subscriptions", server }<br/>);</span></pre><p id="2294" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">可以在<a class="ae lm" href="https://github.com/gr2m/restaurant-graphql/tree/master/05-graphql" rel="noopener ugc nofollow" target="_blank">https://github . com/gr2m/restaurant-graph QL/tree/master/05-graph QL</a>看到完整代码。</p><p id="795c" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">一旦发生更改，GraphQL订阅就会将数据推送到客户端，而不是客户端根据等待更改发生的时间间隔来拉取数据。我们实现的核心是模块<a class="ae lm" href="https://npmjs.com/package/subscriptions-transport-ws" rel="noopener ugc nofollow" target="_blank">订阅-传输-ws </a>和<a class="ae lm" href="https://npmjs.com/package/graphql-subscriptions" rel="noopener ugc nofollow" target="_blank">图表QL-订阅</a>。后者给了我们<code class="du kl km kn ko b">PubSub</code>，我们用它来发布我们两个突变中的<code class="du kl km kn ko b">foodAdded</code>事件。然后在订阅解析器中，我们返回一个异步迭代器，它通过开放的web套接字连接将传递的数据推送到<code class="du kl km kn ko b">foodAdded</code>事件。我们将编译后的模式传递给实现web套接字路由的新的<code class="du kl km kn ko b">SubscriptionServer</code>。</p><p id="17e6" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我知道这很难接受，但一旦它开始工作，也很酷:)</p><p id="5638" class="pw-post-body-paragraph jh ji hh jj b jk jl ii jm jn jo il jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">概括起来</p><ul class=""><li id="5c60" class="ly lz hh jj b jk jl jn jo jq ma ju mb jy mc kc mn me mf mg bi translated">当等待更改时，不是基于时间间隔请求数据，而是使用<code class="du kl km kn ko b">subscribe to a data stream</code>。</li><li id="564e" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">一旦<code class="du kl km kn ko b">server publishes data</code>上市。</li></ul><h1 id="3044" class="kp kq hh bd kr ks kt ku kv kw kx ky kz in la io lb iq lc ir ld it le iu lf lg bi translated">饿吗？</h1><ul class=""><li id="8af0" class="ly lz hh jj b jk lh jn li jq mp ju mq jy mr kc mn me mf mg bi translated">🎮<a class="ae lm" href="https://restaurant-graphql.glitch.me/" rel="noopener ugc nofollow" target="_blank">查看&amp;重新混合关于小故障的示例应用</a></li><li id="09e7" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">🎥<a class="ae lm" href="https://youtu.be/801P6PZvF5c" rel="noopener ugc nofollow" target="_blank">观看此帖子的截屏视频，并进行现场编码</a></li><li id="4ff8" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">👓<a class="ae lm" href="https://github.com/gr2m/restaurant-graphql" rel="noopener ugc nofollow" target="_blank">探索源代码</a></li><li id="9aa0" class="ly lz hh jj b jk mh jn mi jq mj ju mk jy ml kc mn me mf mg bi translated">💬<a class="ae lm" href="https://twitter.com/gr2m" rel="noopener ugc nofollow" target="_blank">在twitter上关注我，获取更多GraphQL的好东西</a></li></ul></div></div>    
</body>
</html>