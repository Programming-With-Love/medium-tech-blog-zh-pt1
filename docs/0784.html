<html>
<head>
<title>Android HDR | Migrating from TextureView to SurfaceView (Part #1) — How to Migrate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android HDR |从TextureView迁移到SurfaceView(第一部分)——如何迁移</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-hdr-migrating-from-textureview-to-surfaceview-part-1-how-to-migrate-6bfd7f4b970e?source=collection_archive---------2-----------------------#2022-12-16">https://medium.com/androiddevelopers/android-hdr-migrating-from-textureview-to-surfaceview-part-1-how-to-migrate-6bfd7f4b970e?source=collection_archive---------2-----------------------#2022-12-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/5f711ce090147262b78f1f9476da0ec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WHUHTAFLiGpBzkoZpdMTg.png"/></div></div></figure><div class=""/><p id="380c" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">关于如何从TextureView迁移到更受欢迎的SurfaceView以在支持的设备上播放HDR的技术指南的第1部分。</p><h1 id="6d5e" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">介绍</h1><p id="6102" class="pw-post-body-paragraph iq ir hs is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">用户每天都在创建和消费更多的内容，尤其是视频内容。无论是社交媒体、视频通话，还是点播观看您最喜爱的电影，我们都知道用户希望获得最高质量的内容。</p><p id="a34b" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这就是为什么在Android上，我们致力于支持应用程序开发人员采用10位HDR(高动态范围)。</p><p id="4a9e" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">最近在Android开发者峰会上，我们谈到了使用Android Camera提高您的社交体验质量。在这次演讲中，我们描述了如何让HDR视频捕捉在Android 13中工作，以及HDR如何通过10位颜色支持带来更明亮和更高对比度的视频。</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div><figcaption class="ky kz et er es la lb bd b be z dx">Mozart Louis @ ADS 22 talking about HDR Video Capture with Android 13</figcaption></figure><p id="584c" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我的同事Ray也谈到了HDR 10位捕获、回放和共享的全部内容。</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="kw kx l"/></div><figcaption class="ky kz et er es la lb bd b be z dx">Raymond Tiong @ ADS 22 talking about HDR Capture, Playback and Sharing</figcaption></figure><p id="345f" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为了支持HDR 10位，你需要使用SurfaceView，要么使用<a class="ae lc" href="https://developer.android.com/guide/topics/media/exoplayer" rel="noopener ugc nofollow" target="_blank"> ExoPlayer </a>(我们推荐)，要么使用你自己定制的支持10位的解码器。</p><p id="13a9" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">许多开发人员选择使用TextureView而不是SurfaceView来绘制屏幕外的内容，但这是以使用SurfaceView带来的几个好处为代价的。</p><p id="4d8d" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">本系列旨在帮助开发人员从TextureView迁移出来，充分利用SurfaceView来显示所有内容。我们将深入探讨SurfaceView的内部工作原理，以及如何用TextureView替换部分(如果不是全部)现有功能。</p><p id="e693" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">让我们从如何从TextureView迁移到SurfaceView开始这个系列。这里有很多内容要介绍，所以系好安全带，准备好进入安卓HDR的土地吧！</p><h1 id="6c41" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">近距离观察SurfaceView</h1><p id="d76a" class="pw-post-body-paragraph iq ir hs is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated"><a class="ae lc" href="https://developer.android.com/reference/android/view/SurfaceView" rel="noopener ugc nofollow" target="_blank"> SurfaceView </a>从API 1的Android开始就有了。根据定义，它提供了一个嵌入在视图层次结构内部的专用绘图表面。这意味着SurfaceView的每个实例都存在于自己的平面上。事实上，当显示SurfaceView时，它实际上是在屏幕上切出一个洞来直接显示内容。这是一个直观的例子:</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ld"><img src="../Images/d1b55b8e6e1c88c3b7e644038373ab83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*euFnmZKZxE-zwBzM8OCvbQ.gif"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">Here you can imagine your app being the “App Surface.” SurfaceView cuts a hole within your app’s surface and displays content from the underlying surface directly to your screen.</figcaption></figure><p id="e385" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">驱动表面视图的基础表面被分配硬件覆盖。这意味着内容可直接用于显示控制器进行扫描输出，而无需复制到应用程序UI中。这带来了以下好处:</p><ul class=""><li id="8831" class="le lf hs is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">更高的能效。</li><li id="2f6f" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">10位HDR支持(取决于设备显示屏的支持)。</li><li id="9bb6" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">DRM播放支持。</li></ul><p id="e672" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">有了所有这些惊人的好处，以及它从Android开始就存在的事实，为什么开发人员还要使用TextureView呢？</p><h1 id="5150" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">为什么开发人员使用TextureView？</h1><p id="5fda" class="pw-post-body-paragraph iq ir hs is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated"><a class="ae lc" href="https://developer.android.com/reference/android/view/TextureView" rel="noopener ugc nofollow" target="_blank"> <strong class="is ht"> TextureView </strong> </a>在API 14中引入。一般的想法是，因为TextureView是较新的API，所以TextureView在各方面都应该比SurfaceView好。TextureView确实比SurfaceView有一些优势，例如，与surface view不同，TextureView不创建单独的窗口，而是像常规视图一样工作。这一关键差异允许TextureView具有半透明性、任意旋转和复杂的裁剪。</p><p id="f834" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">例如，您可以通过调用以下命令使TextureView半透明:</p><pre class="ks kt ku kv fd ls lt lu bn lv lw bi"><span id="3fe1" class="lx jq hs lt b be ly lz l ma mb">myView.setAlpha(0.5f)</span></pre><p id="5409" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">虽然这在某些情况下非常有用，但它会带来性能损失和额外的电池消耗(<a class="ae lc" href="https://exoplayer.dev/battery-consumption.html#video-playback" rel="noopener ugc nofollow" target="_blank">我们这里有一些数字</a>)。这是因为TextureView内容必须从底层表面内部复制到显示这些内容的视图中。这种复制操作使TextureView的效率低于SurfaceView，后者将其内容直接显示在屏幕上。</p><p id="3da2" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">开发人员使用TextureView的另一个原因是，直到API 24，SurfaceView渲染才与视图动画正确同步。在早期版本中，当一个SurfaceView被放入一个滚动容器中时，或者当它被动画化时，这可能会导致不必要的效果。这样的效果包括视图的内容看起来稍微滞后于它应该显示的地方，以及当经历动画时视图变黑。</p><p id="a078" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为了在API 24之前实现流畅的动画或视频滚动，因此有必要使用TextureView而不是SurfaceView。</p><p id="9fc6" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">尽管如此，我们仍然建议在大多数情况下使用SurfaceView。在以下情况下使用TextureView:</p><ul class=""><li id="08ad" class="le lf hs is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated">你需要半透明，任意旋转和复杂的剪辑。</li><li id="aeb4" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">你需要支持API 23及以下，但是使用API 24+的SurfaceView。</li></ul><p id="e1ca" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">如果可能的话，开发人员应该使用<a class="ae lc" href="https://developer.android.com/guide/topics/media/exoplayer" rel="noopener ugc nofollow" target="_blank"> ExoPlayer </a>，因为它减少了决定TextureView或SurfaceView的需要，并处理HDR显示的所有复杂性。</p><h1 id="a835" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">从TextureView移到SurfaceView</h1><p id="24fb" class="pw-post-body-paragraph iq ir hs is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">在本节中，我们将介绍如何从TextureView过渡到SurfaceView，并给出相关指导。当TextureView中可用的内容在SurfaceView中不可用时，我们将提供代码和总体建议。下面是我们将要学习的一些例子:</p><ul class=""><li id="105a" class="le lf hs is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated"><strong class="is ht">使用</strong><a class="ae lc" href="https://developer.android.com/reference/android/media/MediaPlayer" rel="noopener ugc nofollow" target="_blank"><strong class="is ht">media player</strong></a><strong class="is ht">在TextureView或SurfaceView上显示本地视频。</strong></li><li id="8a9f" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated">使用MediaFormat和MediaCodec创建一个简单的解码器来解码和显示10位HLG HEVC视频内容。</li><li id="062d" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated"><strong class="is ht">识别在TextureView上显示10位内容时的色彩质量问题以及如何解决它(第二部分)。</strong></li><li id="9fdb" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated"><strong class="is ht">展示SurfaceView如何处理转换的HDR垂直视频轮播实现(第三部分)。</strong></li></ul><p id="028e" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在这些例子中，我们将注意到TextureView和SurfaceView之间的差异。所有代码样本都在Kotlin中，可以在我们的<a class="ae lc" href="https://github.com/android/graphics-samples/tree/main/TextureViewtoSurfaceView" rel="noopener ugc nofollow" target="_blank"> <strong class="is ht">图形样本</strong> </a>库中找到！下载资源库，跟随我们深入了解TextureView和SurfaceView之间的过渡步骤</p><h1 id="30d1" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated"><strong class="ak">先决条件# 1——让我们创建一些定制的、固定的方面视图</strong></h1><p id="f4ac" class="pw-post-body-paragraph iq ir hs is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">TextureView和SurfaceView不会根据显示内容的长宽比自动调整它们的框架大小。这可能会导致视图失真。因此，我们需要创建一个<strong class="is ht">fixedaspectextureview</strong>和<strong class="is ht"> FixedAspectSurfaceView </strong>。</p><p id="fcbf" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这些只是辅助类，它们将覆盖<strong class="is ht"> onMeasure() </strong>函数，以允许我们设置特定的纵横比，如<strong class="is ht"> 16乘9 </strong>。我们将通过创建一个<strong class="is ht"> setAspectRatio() </strong>函数来设置它。</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="mc kx l"/></div><figcaption class="ky kz et er es la lb bd b be z dx">caYou can view the full implementation for <a class="ae lc" href="https://github.com/android/graphics-samples/blob/main/TextureViewtoSurfaceView/app/src/main/java/com/android/textureview_surfaceview/views/FixedAspectTextureView.kt" rel="noopener ugc nofollow" target="_blank"><strong class="ak">FixedAspectTextureView.kt</strong></a> &amp; <a class="ae lc" href="https://github.com/android/graphics-samples/blob/main/TextureViewtoSurfaceView/app/src/main/java/com/android/textureview_surfaceview/views/FixedAspectSurfaceView.kt" rel="noopener ugc nofollow" target="_blank"><strong class="ak">FixedAspectSurfaceView.kt</strong></a> files within our Graphics samples.</figcaption></figure><h1 id="3bb1" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">先决条件#2 —我们需要一些样本内容！</h1><p id="ddbe" class="pw-post-body-paragraph iq ir hs is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">我们需要一些HDR的内容，试图显示在屏幕上。目前并非所有设备都支持HDR视频捕捉，在我们的<a class="ae lc" href="https://github.com/android/graphics-samples" rel="noopener ugc nofollow" target="_blank">图形样本</a>中，我们已经包含了样本文件。这些都是在Pixel 7 Pro上拍摄的，有些有HDR，有些没有。这将是了解差异的一个很好的起点，尤其是在显示10位HDR内容时。</p><p id="4d1d" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">您也可以随时使用自己的内容。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es md"><img src="../Images/47751f3e44ca2f6accdbbc3002942cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0PbVApg_MgyPSQctl2LdA.png"/></div></div></figure><p id="1e8c" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">并从一个<a class="ae lc" href="https://github.com/android/graphics-samples/blob/main/TextureViewtoSurfaceView/app/src/main/java/com/android/textureview_surfaceview/Constants.kt" rel="noopener ugc nofollow" target="_blank"> <strong class="is ht"> Constants.kt </strong> </a>类中引用它们(必要时更改):</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="mc kx l"/></div></figure><p id="a0a1" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">好了，一切都结束了，让我们进入逻辑！</p><h1 id="8fcd" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">在TextureView和SurfaceView上播放本地视频</h1><p id="0e89" class="pw-post-body-paragraph iq ir hs is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">我们将使用MediaPlayer播放我们的非HDR视频，以展示TextureView和SurfaceView在实现上的差异。MediaPlayer会将媒体渲染到给定的任何表面上，因此这将同时适用于TextureView和SurfaceView。如前所述，如果您正在使用ExoPlayer进行视频播放，这将全部由库为您处理。要了解如何开始使用ExoPlayer，请参见<a class="ae lc" href="https://exoplayer.dev/" rel="noopener ugc nofollow" target="_blank"> ExoPlayer文档</a>。</p><p id="108d" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">让我们创建<a class="ae lc" href="https://github.com/android/graphics-samples/blob/main/TextureViewtoSurfaceView/app/src/main/java/com/android/textureview_surfaceview/examples/single/TextureViewVideoPlayer.kt" rel="noopener ugc nofollow" target="_blank"><strong class="is ht">texture view video player . kt</strong></a>。我们在这里使用视图绑定来绑定到我们的<a class="ae lc" href="https://github.com/android/graphics-samples/blob/main/TextureViewtoSurfaceView/app/src/main/res/layout/texture_view_player.xml" rel="noopener ugc nofollow" target="_blank"><strong class="is ht">texture _ view _ player . XML</strong></a><strong class="is ht">:</strong></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="mc kx l"/></div></figure><p id="fb25" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这里要指出的重点是，我们的类实现了<a class="ae lc" href="https://developer.android.com/reference/android/view/TextureView.SurfaceTextureListener" rel="noopener ugc nofollow" target="_blank"><strong class="is ht">surfaceturistener</strong></a><strong class="is ht">，</strong>这是一个我们需要获取TextureView操作的重要回调的接口。SurfaceView也有类似的回调函数，我们将在后面进行比较。</p><p id="a6ea" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">从API 33开始，<strong class="is ht"> SurfaceTextureListener </strong>要求您实现4个回调:</p><ul class=""><li id="efe7" class="le lf hs is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated"><strong class="is ht">onsurfaceetextureavailable()—</strong>当TextureView的表面纹理准备就绪时调用。</li><li id="74a8" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated"><strong class="is ht">onSurfaceTextureSizeChanged()—</strong>当表面纹理的缓冲区大小改变时调用。</li><li id="13d5" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated"><strong class="is ht">onsurfaceetexturedestroyed()—</strong>当指定的表面纹理将要被破坏时调用。</li><li id="9a28" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated"><strong class="is ht">onSurfaceTextureUpdated()—</strong>通过SurfaceTexture.updateTexImage()更新指定的表面纹理时调用。如果需要，您可以在这里进行逐帧突变。</li></ul><p id="978e" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我们可以使用这些回调，将我们的MediaPlayer连接到SurfaceTexture，并提供媒体播放。它的实现如下所示:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="mc kx l"/></div></figure><p id="3127" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">实现后，您应该会得到这样的结果！</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div class="er es me"><img src="../Images/42d15d55715ca4851b996c17d84ac2a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*z59_cDXPJyXQ5DN4SznzQw.png"/></div></figure><p id="1657" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在，让我们使用SurfaceView而不是TextureView创建一个完全相同的场景。<a class="ae lc" href="https://github.com/android/graphics-samples/blob/main/TextureViewtoSurfaceView/app/src/main/java/com/android/textureview_surfaceview/examples/single/TextureViewVideoPlayer.kt" rel="noopener ugc nofollow" target="_blank"><strong class="is ht">surfaceviewvideoplayer . kt</strong></a><strong class="is ht">，:</strong></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="mc kx l"/></div></figure><p id="b4aa" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这本质上是相同的交易，但你可以看到，我们没有使用<strong class="is ht">表面纹理绘制器</strong>，而是使用<a class="ae lc" href="https://developer.android.com/reference/android/view/SurfaceHolder.Callback" rel="noopener ugc nofollow" target="_blank">表面夹具<strong class="is ht">。回调</strong> </a>。该接口接收关于表面变化的信息。每个SurfaceView都会有一个这样的界面，可以通过<a class="ae lc" href="https://developer.android.com/reference/android/view/SurfaceView#getHolder()" rel="noopener ugc nofollow" target="_blank"> Surfaceview.getHolder() </a>访问。所以我们可以调用<strong class="is ht">binding . surfaceviewvideoplayerview . holder . add callback(this)</strong>，实现SurfaceHolder回调。截至API33，可用的回调包括:</p><ul class=""><li id="de05" class="le lf hs is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated"><strong class="is ht"> surfaceCreated() — </strong>在表面创建后立即调用。</li><li id="e14b" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated"><strong class="is ht"> surfaceChanged() — </strong>在对表面进行任何结构更改(格式或大小)后，立即调用该函数。</li><li id="8776" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated"><strong class="is ht"> surfaceDestroyed() — </strong>在一个表面即将被销毁之前调用。</li></ul><p id="51c6" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我们可以使用<strong class="is ht"> SurfaceHolder </strong>回调来实现我们的MediaPlayer，就像我们使用<strong class="is ht">surface texture listener:</strong>一样</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="mc kx l"/></div></figure><p id="1487" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">实现后，我们应该会看到与TextureView完全相同的行为。好像什么都没变！</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div class="er es me"><img src="../Images/a69a1341dbea954190b0a08635d106e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*ZmWwNsyfvc-IN-Xyvyj6_g.png"/></div></figure><h1 id="9706" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">SurfaceTextureListener和SurfaceHolder的异同。回收</h1><p id="14f0" class="pw-post-body-paragraph iq ir hs is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">你已经看到了TextureView的callback(surface texture listener)和SurfaceView的callback (SurfaceHolder。回调)在功能上几乎是相同的。本质上，</p><ul class=""><li id="686f" class="le lf hs is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm bi translated"><strong class="is ht">onsurfaceetextureavailable()</strong>= =<strong class="is ht">surface created()</strong></li><li id="0caf" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated"><strong class="is ht">onsurfaceetexturedestroyed()</strong>= =<strong class="is ht">surface destroyed()</strong></li><li id="4ea1" class="le lf hs is b it ln ix lo jb lp jf lq jj lr jn lj lk ll lm bi translated"><strong class="is ht">onsurfaceetexturesizechanged()</strong>类似于<strong class="is ht"> surfaceChanged() </strong></li></ul><p id="f78c" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这使得我们可以轻松地将SurfaceView与MediaPlayer配合使用，而无需做太多更改。</p><p id="6ad6" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">你会发现两者的不同之处在于<strong class="is ht">表面固定器。回调</strong>在<strong class="is ht"> SurfaceTextureListener </strong>中没有与<strong class="is ht">onSurfaceTextureUpdated()</strong>等价的。在这种情况下，每次有新的视频帧时都会调用onSurfaceTextureUpdated()，这对于按帧处理和所需的分析非常有用。根据你的工作，这可能是至关重要的。</p><p id="8b5d" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">使用SurfaceView，您必须在MediaCodec和SurfaceView之间截取帧，以获得相同的功能。</p><h1 id="f262" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">TextureView和SurfaceView的生命周期差异</h1><p id="a305" class="pw-post-body-paragraph iq ir hs is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">这两个视图之间的另一个关键区别是底层的<a class="ae lc" href="https://developer.android.com/reference/android/view/Surface" rel="noopener ugc nofollow" target="_blank">表面</a>生命周期是如何处理的。当表面视图不可见时，基础表面将被破坏。对于TextureView来说，情况并非如此。TextureView的表面纹理依赖于与窗口的连接和分离，而不是可见性事件。</p><p id="20bf" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这意味着，根据您的使用情况，您可能会遇到表面视图变成空白或黑色的情况，因为其表面已被破坏。当我们实现我们的垂直HDR视频传送带时，我们将在第3部分对此做更多的介绍。</p><h1 id="30fc" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用MediaCodec在SurfaceView上播放HDR内容</h1><p id="efdf" class="pw-post-body-paragraph iq ir hs is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">播放HDR内容需要使用<a class="ae lc" href="https://developer.android.com/reference/android/media/MediaCodec" rel="noopener ugc nofollow" target="_blank"> MediaCodec </a>类。此类提供对低级媒体编解码器(即编码器/解码器组件)的访问。它是Android低级多媒体支持基础设施的一部分。</p><p id="f97b" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">创建一个优化的解码器不属于本指南的范围，但是我们在我们的图形示例中创建了一个简单的<a class="ae lc" href="https://github.com/android/graphics-samples/blob/main/TextureViewtoSurfaceView/app/src/main/java/com/android/textureview_surfaceview/decoder/CustomVideoDecoder.kt" rel="noopener ugc nofollow" target="_blank"> CustomVideoDecoder.kt </a>，它能够解码我们的HDR文件。重要的是要注意，这个解码器只意味着解码视频和跳过音频。</p><p id="96ed" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在<a class="ae lc" href="https://github.com/android/graphics-samples/blob/main/TextureViewtoSurfaceView/app/src/main/java/com/android/textureview_surfaceview/decoder/CustomVideoDecoder.kt" rel="noopener ugc nofollow" target="_blank"> CustomVideoDecoder.kt </a>中，我们不需要为我们的<strong class="is ht"> MediaFormat </strong>实例显式地将<strong class="is ht"> KEY_PROFILE </strong>设置为<strong class="is ht"> HEVCProfileMain10 </strong>，因为<strong class="is ht"> MediaExtractor </strong>在内部为我们处理了那部分。</p><p id="017b" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">如果您希望手动设置格式，请在您的<strong class="is ht"> MediaFormat </strong>实例上使用<strong class="is ht"> setInteger() </strong>方法，如下所示:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="mc kx l"/></div></figure><p id="c62d" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在<strong class="is ht">进程</strong>方法的顶部，我们调用<strong class="is ht"> setUpDecoder() </strong>方法，该方法将使用我们的MediaFormat MIME类型为文件中的<strong class="is ht">hevcprofimain 10</strong>创建一个解码器。</p><p id="f785" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">根据您使用的编解码器类型，设备可能支持也可能不支持。</p><p id="db56" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">您可以通过调用<strong class="is ht">mediacodeclist . finddecoderforformat():</strong>提前检查代码是否受支持</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="mc kx l"/></div></figure><p id="74f9" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在，随着解码器的创建，我们可以实现另一个<strong class="is ht"> SurfaceViewVideoPlayer </strong>，但取而代之的是，使用我们的自定义解码器而不是MediaPlayer。让我们称这个为<a class="ae lc" href="https://github.com/android/graphics-samples/blob/main/TextureViewtoSurfaceView/app/src/main/java/com/android/textureview_surfaceview/examples/single/SurfaceViewVideoPlayerHDR.kt" rel="noopener ugc nofollow" target="_blank"><strong class="is ht">surfaceviewvideoplayerdr . kt</strong></a><strong class="is ht"/>并覆盖我们的开放基类<a class="ae lc" href="https://github.com/android/graphics-samples/blob/main/TextureViewtoSurfaceView/app/src/main/java/com/android/textureview_surfaceview/examples/single/SurfaceViewVideoPlayer.kt" rel="noopener ugc nofollow" target="_blank"><strong class="is ht">surfaceviewvideoplayer . kt</strong></a><strong class="is ht">:</strong></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="mc kx l"/></div></figure><p id="ed9a" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为了连接我们的自定义解码器，我们只需要覆盖<strong class="is ht"> surfaceCreated() </strong>和<strong class="is ht"> surfaceDestroyed() </strong>方法，并在那里初始化我们的解码器。</p><p id="c799" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这样，你现在应该可以在屏幕上看到正在播放的10位HLG·HDR文件了。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div class="er es me"><img src="../Images/9c286469892275e3c46897800b6206bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*jYNgIZZPn4Nicpg8A6Tnbw.png"/></div></figure><h1 id="add5" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">继续第2部分——处理颜色冲蚀</h1><p id="5f78" class="pw-post-body-paragraph iq ir hs is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ha bi translated">有了上面的一切，你应该能够得到一些HDR内容的回放，并看到TextureView和SurfaceView在实现上的区别！</p><p id="2467" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">提醒一下，在我们的<a class="ae lc" href="https://github.com/android/graphics-samples" rel="noopener ugc nofollow" target="_blank">图形示例</a>中有一个完整的示例应用程序，可以用来查看运行中的代码。</p><p id="a7c4" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在<a class="ae lc" rel="noopener" href="/androiddevelopers/android-hdr-migrating-from-textureview-to-surfaceview-part-2-dealing-with-color-washout-60d57d0ab129">第二部分</a>中，我们将讨论如何处理“颜色冲刷”，当你试图在8位TextureView上显示10位内容时会发生这种情况，以及如何解决这个问题。</p></div></div>    
</body>
</html>