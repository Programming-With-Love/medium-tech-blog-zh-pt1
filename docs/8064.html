<html>
<head>
<title>Better Applications Using Dynamic Configuration Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用动态配置管理实现更好的应用</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/better-applications-using-dynamic-configuration-management-26c4bee5be3c?source=collection_archive---------1-----------------------#2021-09-30">https://medium.com/walmartglobaltech/better-applications-using-dynamic-configuration-management-26c4bee5be3c?source=collection_archive---------1-----------------------#2021-09-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/0948a4c55c016fd88aa2ca953c81bf5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aw1tUMx4y6T7exoMnKF3mA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Image credits: <a class="ae it" href="https://pixy.org/4864454/" rel="noopener ugc nofollow" target="_blank">https://pixy.org/4864454/</a></figcaption></figure><h1 id="fff6" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="4d15" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">开发应用程序时，它通常包含一个配置文件。在发布应用程序的竞争中，这些配置文件成为应用程序构建包的一部分。团队面临的最常见的问题是——一个配置属性的简单更改需要一个新的构建。开发人员说“这是一个简单的属性更改，我们不必为此运行整个回归套件”。QA不同意，工程经理流汗，产品经理翻白眼。最后，团队再次运行整个回归套件，然后将构建提升到环境中。只为一个简单的属性改变。</p><p id="be3c" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">让我们想象一个世界，其中应用程序配置的改变不需要新的构建，也不需要应用程序重启。在这样的世界里，存在着一个叫做“配置服务器”的组件。</p><h1 id="dbc1" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">什么是配置管理系统？</h1><p id="0317" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">配置管理系统是负责管理应用程序配置的软件组件。生态系统中的应用程序使用这些配置来执行它们的职责。简单地说，任何配置管理系统的存在理由都是为其他服务提供存储和检索配置的能力。</p><p id="3c37" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">在较高层次上，下图代表了一个配置管理系统。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kw"><img src="../Images/5cfb53ac44adf33cb005716e632f75dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t5UX_uUmS5347NfTDzSqGA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Role of a configuration management system</figcaption></figure><p id="4242" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">软件生态系统中的多个应用程序与配置系统通信以检索配置。通信模式因系统而异。一些系统可能会公开RESTful APIs，另一些系统可能会使用特定的协议进行全双工通信，还有一些系统甚至使用消息传递系统来广播配置更改事件。在组织内部开发配置管理系统是相当常见的。所以在你寻找开源解决方案之前，一定要弄清楚你的组织是否已经有了一个。</p><p id="4c20" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">跨环境的配置系统应该是单一的。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lb"><img src="../Images/799f8d60d8aaa7b8aabf4fde8b9af109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Xf6hUV75fjKaB_7Dowp6g.png"/></div></div></figure><p id="d8ac" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">所有环境(如开发、QA、试运行、UAT、生产)都应该使用相同的配置管理系统部署来存储它们的配置。团队应该避免配置管理系统的特定环境部署，以避免从一个环境到另一个环境的配置升级的开销。单一部署也降低了基础设施成本。</p><h1 id="be66" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">如何存储配置？</h1><p id="2124" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">没有存储配置的行业标准。通常，配置存储为键值对，其中键是字符串，值的范围可以从简单的字符串到复杂的对象，如JSON或YAML。将值的解释留给消费应用程序是一个好主意。配置系统应该足够灵活，可以接受任何给它的键值对。</p><h1 id="d935" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">如何储存秘密？</h1><p id="f0e8" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">有时候团队可能不得不存储秘密信息，比如密码、API密匙、秘密等。配置管理系统不是存储机密的正确选择。相反，它们应该存储在“秘密管理工具”中。好的秘密管理工具的几个值得注意的例子是HashiCorp Vault、Azure Key Vault、AWS密钥管理服务和Google Cloud的Secret Manager。</p><p id="4827" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">在极少数情况下，团队在其生态系统中没有秘密管理工具，秘密可以被高度加密并存储在配置管理系统中。在这种情况下，应该注意不要将加密密钥存储在配置管理系统中。然而，这种方法是非常不鼓励的。</p><h1 id="8e86" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">要查找的功能</h1><p id="be70" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated"><strong class="ju hi">配置的动态更新</strong></p><p id="a167" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">配置管理系统应该能够在没有任何停机时间或服务中断的情况下对配置执行CRUD操作。</p><p id="02f1" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">变更的实时传播</strong></p><p id="1632" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">配置系统应该能够确保对配置的任何更新都应该随时可供应用程序使用。这可以通过多种方式实现。</p><p id="8481" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">一种方法是开发一个可以捆绑在每个客户端应用程序中的客户端库。这个客户端库应该公开一个从配置系统获取给定配置的最新值的接口。然而，这种方法带来了配置系统服务器上更高负载的额外成本。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kw"><img src="../Images/74ffe21e048b265f9afe14240e79ae1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byynLuwVfkNwpkKh9ioRQA.png"/></div></div></figure><p id="46fb" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">另一种方法是使用消息系统，如Kafka、RabbitMQ等。在这种情况下，一旦配置更新，服务器就负责在消息传递系统上广播更新。客户端使用广播的消息将其本地缓存的值更新为最新值。这种方法的缺点是增加了消息传递系统的基础设施成本，客户端应用程序中需要更多的代码来使用更新。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/6f5585cd8760a60f1e269f4641351b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_J34N1zMls-DRVoUMxZnDw.png"/></div></div></figure><p id="8b28" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">基于环境的定义</strong></p><p id="2f83" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">配置系统应该能够基于环境直观地表示值。这允许按环境更好地划分值，并减少更新中的人为错误。例如:feature-flag在生产中被打开，而它应该在Stage中被打开(这种情况会发生！).</p><p id="b4a8" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">领袖选举和失败恢复</strong></p><p id="1f62" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">配置系统应该对故障有弹性。因此，选择分布式配置系统，而不是容易成为SPOF(单点故障)的系统。例如:Zookeeper和Redis等系统可以轻松扩展到数千个节点，并足够智能地处理领导人选举和裂脑网络等接触问题。</p><p id="e7f8" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">版本控制</strong></p><p id="a1b2" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">通过版本化来跟踪配置值有助于恢复配置值。如果配置更改导致现有功能中断，DevOps团队可以快速将配置恢复到早期版本。在没有这个特性的情况下，团队到处寻找以前的值是很常见的，这个特性就是用这个值工作的。</p><p id="0054" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">审计</strong></p><p id="133c" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">当由于配置更改而出现问题时，跟踪四个W(什么、什么时候、谁、为什么)的能力就派上了用场。在法规遵从性至关重要的系统中，这也很方便。</p></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><h1 id="0880" class="iu iv hh bd iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn lo jp jq jr bi translated">选择</h1><p id="efd8" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">如果您需要设置配置管理系统，以下解决方案是一些流行且经过实战检验的可用选项。</p><ol class=""><li id="c4f4" class="lp lq hh ju b jv kq jz kr kd lr kh ls kl lt kp lu lv lw lx bi translated"><a class="ae it" href="https://zookeeper.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇动物园管理员</a></li><li id="1400" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp lu lv lw lx bi translated"><a class="ae it" href="https://www.consul.io/" rel="noopener ugc nofollow" target="_blank"> Hashicorp领事</a></li><li id="3988" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp lu lv lw lx bi translated"><a class="ae it" href="https://etcd.io/" rel="noopener ugc nofollow" target="_blank"> etcd </a></li><li id="0a3c" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp lu lv lw lx bi translated"><a class="ae it" href="https://redislabs.com/ebook/part-2-core-concepts/chapter-5-using-redis-for-application-support/5-4-service-discovery-and-configuration/5-4-1-using-redis-to-store-configuration-information/" rel="noopener ugc nofollow" target="_blank"> Redis </a></li><li id="49e1" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp lu lv lw lx bi translated"><a class="ae it" href="https://cloud.spring.io/spring-cloud-config/reference/html/" rel="noopener ugc nofollow" target="_blank"> Spring Cloud配置服务器</a></li><li id="875b" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp lu lv lw lx bi translated">公司专有解决方案</li></ol><h1 id="9381" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">参考架构:动物园管理员</h1><p id="574d" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">让我们把Apache ZooKeeper作为一个参考系统。我们将首先浏览ZooKeeper的架构和核心概念，然后继续看它作为配置管理系统的应用。</p><p id="eea8" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">动物园管理员架构</strong></p><p id="5908" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">ZooKeeper运行在一个名为<strong class="ju hi"> <em class="kv"> ensemble </em> </strong>的服务器集群上，这些服务器共享你的数据状态。无论何时进行更改，在写入集合中服务器的法定数量(至少一半)之前，都不会被认为是成功的。ZooKeeper<strong class="ju hi"><em class="kv">quorum</em></strong>是ZooKeeper集群运行所需的最小节点数。建议集合<a class="ae it" href="https://stackoverflow.com/questions/58823341/why-is-it-recommended-to-create-clusters-with-odd-number-of-nodes" rel="noopener ugc nofollow" target="_blank">由奇数个节点</a>组成。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es md"><img src="../Images/571590d8f79bdef49b0d235b1246b447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*cwz3tDq04G8yB4md30oxYw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">A simple Zookeeper ensemble</figcaption></figure><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es me"><img src="../Images/c46f1a0e1060d5ee3c8d3d20ea668f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQFhOddNWNEy2WjPApAHqA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">A more realistic <em class="mf">ensemble which avoids the ‘split brain’ issue</em></figcaption></figure><p id="6d14" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">一个<strong class="ju hi"> <em class="kv">首领</em> </strong>在合奏团内被选举产生。来自客户端的所有写请求都被转发到一台服务器，称为leader。其余的ZooKeeper服务器称为<strong class="ju hi"> <em class="kv">追随者</em> </strong> <em class="kv">。</em></p><p id="4d10" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">所有对ZooKeeper的写请求都被转发给leader。领导者处理写请求，将它们转发给所有追随者，并等待追随者的ack响应。如果至少有一半的追随者回答，写作被认为是成功的。ZooKeeper还保证来自同一个客户端的写操作将按照客户端发送的顺序进行处理。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mg"><img src="../Images/947048f0ed163958dde2b874607e4b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hWb3gxjb4P9sna9W7Gu5zw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">ZooKeeper writes and replication</figcaption></figure><p id="0cd1" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">数据模型和分层命名空间</strong></p><p id="b514" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">ZooKeeper允许分布式进程通过一个共享的层次名称空间相互协调，该名称空间的组织方式类似于标准文件系统。名称空间由数据寄存器组成——在ZooKeeper的说法中称为<strong class="ju hi"><em class="kv">z节点</em></strong>——这些类似于文件和目录。与为存储而设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟。“znodes”由以“/”分隔的Unicode字符串的唯一绝对路径标识。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es mh"><img src="../Images/d587dad2b3ebe2f30e75374cc2b4c52b.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*SyOYW6sQGUZ237Qcp8pGZA.jpeg"/></div></figure><p id="d670" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">与标准文件系统不同，ZooKeeper名称空间中的每个节点都可以有与其相关联的数据以及子节点。这就像有一个文件系统，允许一个文件也是一个目录。Znodes维护一个数据结构，其中包括数据更改的版本号、ACL更改和时间戳，以允许缓存验证和协调更新。每次znode的数据发生变化，版本号就会增加。例如，每当客户端检索数据时，它也会收到数据的版本。存储在名称空间中每个znode上的数据是以原子方式读写的。读取获取与znode相关的所有数据字节，写入替换所有数据。每个节点都有一个访问控制列表(ACL ),限制谁可以做什么。</p><h2 id="688f" class="mi iv hh bd iw mj mk ml ja mm mn mo je kd mp mq ji kh mr ms jm kl mt mu jq mv bi translated">担保</h2><p id="c8db" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">ZooKeeper非常快，非常简单。但是，由于它的目标是为构建更复杂的服务(如同步)提供基础，所以它提供了一组保证。这些是:</p><ul class=""><li id="ba45" class="lp lq hh ju b jv kq jz kr kd lr kh ls kl lt kp mw lv lw lx bi translated">顺序一致性—来自客户端的更新将按发送顺序应用。</li><li id="f065" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp mw lv lw lx bi translated">原子性—更新要么成功，要么失败。没有部分结果。</li><li id="a79a" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp mw lv lw lx bi translated">单一系统映像—无论客户端连接到哪个服务器，它都会看到相同的服务视图。</li><li id="2fd6" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp mw lv lw lx bi translated">可靠性—一旦应用了更新，它将从那时起持续存在，直到客户端覆盖更新。</li><li id="5492" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp mw lv lw lx bi translated">及时性——保证系统的客户视图在一定的时间范围内是最新的。</li></ul><h1 id="174a" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">作为配置管理系统的ZooKeeper</h1><h2 id="7d4f" class="mi iv hh bd iw mj mk ml ja mm mn mo je kd mp mq ji kh mr ms jm kl mt mu jq mv bi translated"><strong class="ak">结构化数据</strong></h2><p id="13a5" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">比方说，我们有一个名为“myapp”的应用程序，它的配置在一个属性文件中定义如下。</p><pre class="kx ky kz la fd mx my mz na aw nb bi"><span id="dbe5" class="mi iv hh my b fi nc nd l ne nf">myapp.api.retry.enabled=true<br/>myapp.api.retry.maxcount=3<br/>myapp.api.retry.fallback=linear</span></pre><p id="9335" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">要将这个配置移动到ZooKeeper，我们需要将属性表示为znodes，如下图所示。可以使用ZooKeeper命令行界面添加和更新这些属性。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es ng"><img src="../Images/8a034d5df928431272f82a8ee27d8d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*BUFEAS06dreDnk9Py1UZ3Q.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Properties denoted as ZooKeeper znodes</figcaption></figure><p id="a7b5" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">一旦在ZooKeeper中创建了znodes，所有感兴趣的客户端都需要查询以下属性(又名znodes)。</p><pre class="kx ky kz la fd mx my mz na aw nb bi"><span id="c06c" class="mi iv hh my b fi nc nd l ne nf">/myapp/api/retry/enabled<br/>/myapp/api/retry/maxcount<br/>/myapp/api/retry/fallback</span></pre><p id="1b80" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">环境特定配置</strong></p><p id="792d" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">扩展到环境感知，我们可以将环境名作为叶子节点添加到znode树中(如下图所示)。这允许我们重用整个配置树，并在最后添加特定于环境的值。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nh"><img src="../Images/27b13236f358517e2229e1d886fcc9fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rBxmjVkvvuQDhq65p2SbNA.png"/></div></div></figure><p id="65af" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">上面显示的znodes转换为以下属性</p><pre class="kx ky kz la fd mx my mz na aw nb bi"><span id="b959" class="mi iv hh my b fi nc nd l ne nf">/myapp/api/retry/enabled/dev<br/>/myapp/api/retry/enabled/qa<br/>/myapp/api/retry/enabled/prd</span><span id="c3d7" class="mi iv hh my b fi ni nd l ne nf">/myapp/api/retry/maxcount/dev<br/>/myapp/api/retry/maxcount/qa<br/>/myapp/api/retry/maxcount/prd</span><span id="392c" class="mi iv hh my b fi ni nd l ne nf">/myapp/api/retry/fallback/dev<br/>/myapp/api/retry/fallback/qa<br/>/myapp/api/retry/fallback/prd</span></pre><p id="d2d3" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">在应用程序中查询配置</strong></p><p id="587f" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">ZooKeeper支持大多数编程语言的<a class="ae it" href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/ZKClientBindings" rel="noopener ugc nofollow" target="_blank">集成库</a>(又名客户端绑定)。ZooKeeper附带了C、Java、Perl和Python客户端绑定。支持C#、Node.js、Scala、Go等。可从社区获得。</p><p id="947b" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">客户端使用特定语言绑定与ZooKeeper通信。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es nj"><img src="../Images/f0ea34f7e412770df33378aaaaeccc20.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*5JpOARbTP5KNLv8bKEm1Hw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Application — ZooKeeper integration using supported client libraries</figcaption></figure><ol class=""><li id="6af5" class="lp lq hh ju b jv kq jz kr kd lr kh ls kl lt kp lu lv lw lx bi translated">每个应用程序都应该包含绑定库，并且知道ZooKeeper服务器的列表。</li><li id="b255" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp lu lv lw lx bi translated">当应用程序需要获取配置时，它们应该调用ZooKeeper库中的<code class="du nk nl nm my b">GET</code>方法。</li><li id="5488" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp lu lv lw lx bi translated">然后，zookeeper库调用一个ZooKeeper服务器。如果目标服务器不可用，库将尝试下一个服务器。</li><li id="0ff8" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp lu lv lw lx bi translated">一旦收到响应，应用程序就可以使用响应值。</li><li id="45ae" class="lp lq hh ju b jv ly jz lz kd ma kh mb kl mc kp lu lv lw lx bi translated">当ZooKeeper中某个特定的配置值被更新或删除时，应用程序也可以利用ZooKeeper <code class="du nk nl nm my b">watch</code>接收更新。这可以通过客户端的持续轮询来减少ZooKeeper服务器上的负载。</li></ol><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nn"><img src="../Images/864f10f13db234176663877d0435ce83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9auFy5POF7O1DNRElHCpg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Application — ZooKeeper integration leveraging ‘znode watch’ feature</figcaption></figure><h1 id="5f1c" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结论</h1><p id="22d2" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">配置管理是管理应用程序的一个重要方面，特别是在现代、快节奏、面向客户的应用程序中。将配置从代码中分离出来是很重要的，这种分离可以确保配置可以用来控制生产中的代码行为。它甚至可以通过配置控制行为(例如用于服务请求的功能标志和引擎)来最小化在生产中推出新功能的风险。选择正确的配置管理系统可以为应用程序的发布周期增加显著的价值。</p></div></div>    
</body>
</html>