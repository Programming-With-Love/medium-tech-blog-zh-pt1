<html>
<head>
<title>ViewModels with Saved State, Jetpack Navigation, Data Binding and Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有保存状态、Jetpack导航、数据绑定和协同例程的视图模型</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/viewmodels-with-saved-state-jetpack-navigation-data-binding-and-coroutines-df476b78144e?source=collection_archive---------1-----------------------#2019-06-24">https://medium.com/androiddevelopers/viewmodels-with-saved-state-jetpack-navigation-data-binding-and-coroutines-df476b78144e?source=collection_archive---------1-----------------------#2019-06-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/1b797cc302db5d821f729ea740d1d74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdoOylW75rlCRF12xIE1Bw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="b65f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">自从推出以来，<a class="ae hu" rel="noopener" href="/androiddevelopers/viewmodels-a-simple-example-ed5ac416317e"> ViewModel </a>已经成为最“核心”的Android Jetpack库之一。根据我们2019年的开发者基准测试数据，超过40%的Android开发者在他们的应用中添加了视图模型。如果您不熟悉视图模型，可能不清楚为什么会这样:视图模型通过将数据从UI中分离出来，促进了更好的体系结构，使处理UI生命周期变得容易，同时也提高了可测试性。完整的解释请查看<a class="ae hu" rel="noopener" href="/androiddevelopers/viewmodels-a-simple-example-ed5ac416317e">视图模型:一个简单的例子</a>和<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="e9eb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为视图模型是如此的基础，所以在过去的几年中已经做了大量的工作来使它们更容易使用，更容易与其他库集成。在本文中，我将介绍四个集成:</p><ol class=""><li id="3ee3" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hy">ViewModels中保存的状态</strong> —后台进程重启后仍存在的ViewModel数据</li><li id="5fbd" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hy">带视图模型的导航图</strong> —视图模型和导航库集成</li><li id="4676" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hy">在数据绑定中使用视图模型</strong> —使用视图模型和LiveData轻松进行数据绑定</li><li id="4445" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hy"> viewModelScope </strong> — Kotlin协程和ViewModels集成</li></ol></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="eff5" class="kn ko hx bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">ViewModels中保存的状态:后台进程重启后仍然存在的ViewModel数据</h1><p id="cc63" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">在<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/lifecycle#viewmodel-savedstate-1.0.0-alpha01" rel="noopener ugc nofollow" target="_blank">生命周期-视图模型-保存状态:1.0.0-alpha01 </a> <br/>中增加了Java和Kotlin</p><h2 id="61f1" class="lq ko hx bd kp lr ls lt kt lu lv lw kx jf lx ly lb jj lz ma lf jn mb mc lj md bi translated"><code class="du me mf mg mh b">onSaveInstanceState</code>的挑战</h2><p id="3142" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">当ViewModels最初启动时，有一个令人困惑的问题涉及到<code class="du me mf mg mh b">onSaveInstanceState</code>。活动和片段可以通过三种方式销毁:</p><p id="a9b6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">1.<strong class="iw hy">你的意思是永久导航离开:</strong>用户导航离开或者明确关闭活动——比如按下后退按钮或者触发一些调用<code class="du me mf mg mh b">finish()</code>的代码。这项活动已经永远消失了。</p><p id="c9c8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2.<strong class="iw hy">存在配置改变:</strong>用户旋转设备或进行一些其他配置改变。该活动需要立即重建。</p><p id="788c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">3.<strong class="iw hy">应用程序被置于后台，其进程被终止:</strong>当设备内存不足，需要快速释放一些内存时，会出现这种情况。<em class="mi">当用户导航回你的应用程序时，需要重建活动。</em></p><p id="fbf7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在情况2和3中，您想要重建活动。视图模型总是帮助您处理第二种情况，因为视图模型不会在配置更改时被破坏；但是在情况3中，ViewModel也被破坏了，所以您实际上需要在活动中使用<code class="du me mf mg mh b">onSaveInstanceState</code>回调来保存和恢复数据。我在<a class="ae hu" rel="noopener" href="/androiddevelopers/viewmodels-persistence-onsaveinstancestate-restoring-ui-state-and-loaders-fc7cc4a6c090">视图模型:持久性、onSaveInstanceState()、恢复UI状态和加载器</a>中更详细地讨论了这个微妙的区别。</p><h2 id="ea2a" class="lq ko hx bd kp lr ls lt kt lu lv lw kx jf lx ly lb jj lz ma lf jn mb mc lj md bi translated">保存状态模块</h2><p id="0fd7" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate" rel="noopener ugc nofollow" target="_blank"> ViewModel保存状态模块</a>帮助您处理第三种情况:进程死亡。ViewModel不再需要向活动发送状态和从活动接收状态。相反，您现在可以在ViewModel中处理保存和恢复数据。ViewModel现在可以真正地处理和保存它自己的所有数据。</p><p id="c62f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是使用一个<a class="ae hu" href="https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle.html" rel="noopener ugc nofollow" target="_blank"> SavedStateHandle </a>来完成的，它非常类似于一个<a class="ae hu" href="https://developer.android.com/reference/android/os/Bundle" rel="noopener ugc nofollow" target="_blank">包</a>；这是数据的键值映射。这个SavedStateHandle“包”在视图模型中，它在后台进程死亡后仍然存在。您之前必须保存在<code class="du me mf mg mh b">onSaveInstanceState</code>中的任何数据现在都可以保存在SavedStateHandle中。例如，用户的id可能存储在SavedStateHandle中。</p><h2 id="f670" class="lq ko hx bd kp lr ls lt kt lu lv lw kx jf lx ly lb jj lz ma lf jn mb mc lj md bi translated">设置保存状态模块</h2><p id="1650" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">让我们看看如何使用新模块。请注意，下面显示的代码与生命周期代码实验室的<a class="ae hu" href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#6" rel="noopener ugc nofollow" target="_blank">步骤6中的代码</a>非常相似。那段代码是Java的，下面的代码是Kotlin的。</p><p id="69f7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">第一步:添加依赖关系</strong></p><p id="917f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">SavedStateHandle目前在alpha中(这意味着API可能会改变，我们正在寻找<a class="ae hu" href="https://issuetracker.google.com/issues/new?component=413132&amp;template=1096619" rel="noopener ugc nofollow" target="_blank">反馈</a>)，它是一个单独的库。要添加的依赖项是:</p><pre class="mj mk ml mm fd mn mh mo mp aw mq bi"><span id="f237" class="lq ko hx mh b fi mr ms l mt mu">implementation ‘androidx.lifecycle:lifecycle-viewmodel-savedstate:1.0.0-alpha01’</span></pre><p id="33fb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意，如果你想跟上库中发生的变化，请查看<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/lifecycle#viewmodel-savedstate-1.0.0-alpha01" rel="noopener ugc nofollow" target="_blank">生命周期发布说明</a>页面。</p><p id="b02d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">步骤2:更新对ViewModelProvider的调用</strong></p><p id="4095" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，您想要创建一种具有SavedStateHandle的视图模型。在活动或片段的<code class="du me mf mg mh b">onCreate</code>中，将对ViewModelProvider的调用更新为:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="2c0b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">创建ViewModel的类是一个<a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/ViewModelProvider.Factory.html" rel="noopener ugc nofollow" target="_blank"> ViewModel工厂</a>，有一个ViewModel工厂使用SavedStateHandles创建ViewModel，称为<a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/SavedStateVMFactory" rel="noopener ugc nofollow" target="_blank"> SavedStateVMFactory </a>。创建的ViewModel现在将有一个SavedStateHandle，与传入的活动/片段相关联。</p><p id="5815" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">注意:</strong>Android x<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/activity" rel="noopener ugc nofollow" target="_blank">activity</a>和<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/fragment" rel="noopener ugc nofollow" target="_blank"> fragment </a>库即将发布的alpha版本将于7月发布。在这些版本中(如这里的<a class="ae hu" href="https://issuetracker.google.com/issues/135716331" rel="noopener ugc nofollow" target="_blank">所示</a>，SavedStateVMFactory将成为默认的ViewModelProvider。当您在活动或片段中创建视图模型时。这意味着如果你正在使用最新的alpha版本的Androidx <a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/activity" rel="noopener ugc nofollow" target="_blank"> activity </a>或者<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/fragment" rel="noopener ugc nofollow" target="_blank"> fragment </a>，你将不需要添加lifecycle-viewmodel-savedstate依赖或者显式地使用SavedStateVMFactory。简而言之，当这种变化发生时，如果你使用的是新的alpha版本，你可以跳过第1步和第2步，直接跳到下面的第3步。</p><p id="5c5b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">第三步:在ViewModel中使用SaveStateHandle</strong></p><p id="6616" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦完成了这些，就可以在视图模型中使用SavedStateHandle了。下面是一个在SavedStateHandle中保存用户id的示例:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><ol class=""><li id="20fe" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hy">构造:</strong> <code class="du me mf mg mh b">MyViewModel</code>接受SavedStateHandle作为构造函数参数。</li><li id="d927" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hy">Save:</strong><code class="du me mf mg mh b">saveNewUser</code>方法展示了一个在SavedStateHandle中保存数据的例子。你保存<code class="du me mf mg mh b">USER_KEY</code>的键值对，然后保存当前的<code class="du me mf mg mh b">userId</code>。当ViewModel中的数据更新时，它应该保存在SavedStateHandle中。</li><li id="24d7" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hy"> Retrieve: </strong> <code class="du me mf mg mh b">savedStateHandle.get(USER_KEY)</code>是一个获取保存在SaveStateHandle中的当前值的例子。</li></ol><p id="85b1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，如果活动由于循环<strong class="iw hy">或</strong>被破坏，由于操作系统杀死你的进程来释放内存，你可以确保SavedStateHandle将拥有你的数据。</p><p id="12a3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通常您会在视图模型中使用LiveData。为此你可以使用<code class="du me mf mg mh b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/SavedStateHandle.html#getlivedata" rel="noopener ugc nofollow" target="_blank">SavedStateHandle.getLiveData()</a></code>方法。这里有一个用LiveData替换<code class="du me mf mg mh b">getCurrentUser</code>的例子，它允许观察:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="67bd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要了解更多信息，请查看生命周期代码实验室的<a class="ae hu" href="https://codelabs.developers.google.com/codelabs/android-lifecycles/#6" rel="noopener ugc nofollow" target="_blank">步骤6和</a><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/viewmodel-savedstate" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="d2bd" class="kn ko hx bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">ViewModel和Jetpack导航:带有ViewModel的导航图</h1><p id="c231" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">在<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/navigation#2.1.0-alpha02" rel="noopener ugc nofollow" target="_blank">导航2.1.0-alpha02 </a> <br/>中增加了Java和Kotlin</p><h2 id="8866" class="lq ko hx bd kp lr ls lt kt lu lv lw kx jf lx ly lb jj lz ma lf jn mb mc lj md bi translated">视图模型共享的挑战</h2><p id="8a43" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated"><a class="ae hu" href="https://developer.android.com/guide/navigation" rel="noopener ugc nofollow" target="_blank"> Jetpack导航</a>开箱即用，应用程序设计的活动相对较少——甚至只有一个——包含多个片段。伊恩·莱克的精彩演讲<a class="ae hu" href="https://www.youtube.com/watch?v=2k8x8V77CrU" rel="noopener ugc nofollow" target="_blank">单一活动:为什么、何时以及如何</a>中涵盖了我们选择这种架构的一些原因。一个特别的原因是，这种架构允许您通过创建一个<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/viewmodel#sharing" rel="noopener ugc nofollow" target="_blank">活动共享视图模型</a>来在不同的目的地之间共享数据。您可以使用活动创建一个ViewModel，然后您可以从活动的任何片段中获得对该ViewModel的引用:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="1a89" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在想象一下，我们有一个活动应用程序，我们有八个片段目的地。其中，四个是购物结账流程:</p><figure class="mj mk ml mm fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mx"><img src="../Images/449a0f54442f57af41e12efe8b370810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ajyZKgb1Oa3aYQaD"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Navigation Graph with some screens that are in a shopping checkout flow</figcaption></figure><p id="80f7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于结账流程中的这四个目的地来说，共享数据很重要，比如送货地址或用户是否使用了优惠券代码。我们将把这些信息放在一个视图模型中，但是视图模型与什么相关联呢？这些信息对于应用程序的其余部分并不重要，但是以前我们共享视图模型的唯一选择是将视图模型与活动相关联。这意味着所有八个目的地都可以访问这个视图模型。</p><h2 id="5ec6" class="lq ko hx bd kp lr ls lt kt lu lv lw kx jf lx ly lb jj lz ma lf jn mb mc lj md bi translated">视图模型导航图集成</h2><p id="369a" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated"><a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/navigation#2.1.0-alpha02" rel="noopener ugc nofollow" target="_blank">导航2.1.0 </a>引入了与导航图相关的视图模型。在实践中，这意味着您可以获取一组关联的目的地，比如入职流程、登录流程或结账流程；将它们放入一个<a class="ae hu" href="https://developer.android.com/guide/navigation/navigation-nested-graphs" rel="noopener ugc nofollow" target="_blank">嵌套导航图</a>；并在这些屏幕之间共享数据。</p><p id="ad9d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要创建嵌套导航图，您可以选择您的屏幕，右键单击，然后选择<strong class="iw hy">移动到嵌套图→新图:</strong></p><figure class="mj mk ml mm fd hj er es paragraph-image"><div class="er es my"><img src="../Images/4c416f29f2e4580ea4aa973aa0f8b947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*o6KYHXaP9HbHR5SQEviXgg.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Screenshot showing how to “Move to Nested Graph”</figcaption></figure><p id="021b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在XML视图中，注意嵌套导航图的<strong class="iw hy"> id </strong>，在本例中为<code class="du me mf mg mh b">checkout_graph</code>:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="300c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦完成了这些，您就可以使用<code class="du me mf mg mh b">by navGraphViewModels</code>获得视图模型:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="4935" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这也适用于Java编程语言，使用:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="a8d5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意，嵌套图是从导航图的其余部分封装而来的。您可以导航到嵌套图形(您将转到嵌套图形的起始目标)，但不能从图形外部直接导航到嵌套图形中的特定目标。因此，它们意味着封装的屏幕集合，像结帐流或登录流。</p><p id="c02c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">ViewModel导航图集成是I/O 2019上宣布的新导航功能之一。更多信息，请查看talk <a class="ae hu" href="https://youtu.be/JFGq0asqSuA?t=588" rel="noopener ugc nofollow" target="_blank"> Jetpack导航</a>和<a class="ae hu" href="https://developer.android.com/guide/navigation/navigation-programmatic#share_" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="6376" class="kn ko hx bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">ViewModel和数据绑定:在数据绑定中使用ViewModel和LiveData</h1><p id="9c86" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">在<a class="ae hu" href="https://developer.android.com/studio/releases#update-data-binding" rel="noopener ugc nofollow" target="_blank"> Android Studio 3.1中添加了</a><br/>Java和Kotlin</p><h2 id="270a" class="lq ko hx bd kp lr ls lt kt lu lv lw kx jf lx ly lb jj lz ma lf jn mb mc lj md bi translated">所有这些LiveData样板文件</h2><p id="3914" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">这种整合是老一套，但却是好东西。视图模型通常包含<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank"> LiveData </a>，LiveData的意思是被观察。通常这意味着在fragment中添加一个观察者:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="f7f3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="https://developer.android.com/topic/libraries/data-binding" rel="noopener ugc nofollow" target="_blank">数据绑定库</a>就是观察你的数据和更新用户界面。通过一起使用ViewModel、LiveData和数据绑定，您可以删除以前的LiveData观察代码，并直接从布局XML中引用您的ViewModel和LiveData。</p><h2 id="1295" class="lq ko hx bd kp lr ls lt kt lu lv lw kx jf lx ly lb jj lz ma lf jn mb mc lj md bi translated">使用数据绑定、ViewModel和LiveData</h2><p id="e051" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">假设在您的XML布局中，您想要引用您的视图模型:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="a620" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要将LiveData用于数据绑定，您只需调用<code class="du me mf mg mh b">binding.setLifecycleOwner(this)</code>，然后将您的ViewModel传递给绑定，如下所示:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="0e87" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，在您的布局中，您可以使用您的视图模型。如下所示，我将文本设置为<code class="du me mf mg mh b">viewmodel.name</code>:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="184f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意，<code class="du me mf mg mh b">viewmodel.name</code>可能是一个字符串或一个LiveData。如果是LiveData，每当LiveData发生变化时，用户界面都会更新。</p></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="b002" class="kn ko hx bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">ViewModel和Kotlin协同例程:viewModelScope</h1><p id="e6b0" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated"><a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/lifecycle#2.1.0-alpha01" rel="noopener ugc nofollow" target="_blank">仅在生命周期2.1.0 </a> <br/>中添加</p><h2 id="61b3" class="lq ko hx bd kp lr ls lt kt lu lv lw kx jf lx ly lb jj lz ma lf jn mb mc lj md bi translated">Android上的协同程序</h2><p id="7cd0" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">Kotlin协同程序是一种处理异步代码的新方法。处理异步代码的另一种方法是使用回调。回调是好的，但是如果你正在编写复杂的异步代码，你可能会有很多层次的嵌套回调；这使得你的代码难以理解。协程简化了所有这一切，还提供了一种简单的方法来确保您没有阻塞主线程。如果你是协程的新手，有一个非常深入的博客文章系列，叫做Android上的<a class="ae hu" rel="noopener" href="/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb">协程</a>和在你的Android应用中使用Kotlin协程的codelab <a class="ae hu" href="https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#0" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0343" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个简单的协程看起来就像是完成一些工作的代码块:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="11cc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里我只启动了一个协程，但是很容易启动数百个协程，并可能失去对它们的跟踪——如果您失去了对一个协程的跟踪，并且它正在运行一些您想要停止的工作，这就是所谓的<strong class="iw hy">工作泄漏</strong>。</p><p id="981c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了避免工作泄漏，你应该通过将你的协同程序添加到一个<a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html" rel="noopener ugc nofollow" target="_blank">协同程序作用域</a>来组织它们，这个作用域是一个跟踪协同程序的对象。协程范围可以取消；当您取消一个作用域时，它们会取消所有相关的协程。上面我使用的是<a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/" rel="noopener ugc nofollow" target="_blank"> GlobalScope </a>，顾名思义，这是一个全球可用的协同作用域。出于同样的原因，使用全局范围通常不是好的做法，编写全局可访问的变量通常也不是好的做法。所以你需要做一个瞄准镜，或者找到一个。在视图模型中，如果使用<a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary.html#(androidx.lifecycle.ViewModel).viewModelScope:kotlinx.coroutines.CoroutineScope" rel="noopener ugc nofollow" target="_blank">视图模型范围</a>，这很容易。</p><h2 id="12e9" class="lq ko hx bd kp lr ls lt kt lu lv lw kx jf lx ly lb jj lz ma lf jn mb mc lj md bi translated">视图模型范围</h2><p id="69a4" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">通常，如果您的ViewModel被破坏，那么与ViewModel相关联的大量“工作”也应该停止。</p><p id="920a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，让我们说你准备一个位图显示在屏幕上。这是一个在不阻塞主线程<em class="mi">和</em>的情况下应该做的工作的例子，如果你永久地离开或关闭屏幕，这些工作应该停止。对于这样的工作，您应该使用<a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary.html#(androidx.lifecycle.ViewModel).viewModelScope:kotlinx.coroutines.CoroutineScope" rel="noopener ugc nofollow" target="_blank">视图模型范围</a>。</p><p id="b051" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">viewModelScope是ViewModel类上的Kotlin扩展属性。一旦ViewModel被销毁(当调用<code class="du me mf mg mh b"><a class="ae hu" href="https://developer.android.com/reference/androidx/lifecycle/ViewModel#onCleared()" rel="noopener ugc nofollow" target="_blank">onCleared()</a></code>时),它就是一个被取消的协同作用域。因此，当您使用ViewModel时，您可以使用这个作用域启动所有的协程。</p><p id="0099" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里有一个小例子:</p><figure class="mj mk ml mm fd hj"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="5f89" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你使用Kotlin协同程序和视图模型，Android中优秀的blogpost <a class="ae hu" rel="noopener" href="/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471"> Easy协同程序:viewModelScope </a>会提供更多细节。关于协程和架构组件的更多信息，请查看<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/coroutines" rel="noopener ugc nofollow" target="_blank">文档</a>和讲座<a class="ae hu" href="https://www.youtube.com/watch?v=BOHK_w09pVA" rel="noopener ugc nofollow" target="_blank">了解Android上的Kotlin协程</a>。</p></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><h1 id="5421" class="kn ko hx bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="d607" class="pw-post-body-paragraph iu iv hx iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">总而言之:</p><ol class=""><li id="5e82" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">视图模型用SavedStateHandle模块处理<code class="du me mf mg mh b">onSaveInstanceState</code>案例。</li><li id="a602" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">您可以将ViewModel的范围扩展到Jetpack Navigation NavGraph，以便在片段之间共享更精确和封装的数据。</li><li id="b8bf" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">如果使用数据绑定库和视图模型，可以将视图模型传递给绑定。如果您也在使用LiveData，请使用<code class="du me mf mg mh b">binding.setLifecycleOwner(lifecycleOwner)</code>。</li><li id="b88c" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">…如果您将Kotlin协同程序与ViewModel一起使用，那么当ViewModel被销毁时，请使用viewModelScope自动取消您的协同程序。</li></ol><p id="f3f3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些集成中有许多来自社区的直接反馈和请求。如果您正在寻找ViewModel特性或集成，您可以遵循特性请求<a class="ae hu" href="https://issuetracker.google.com/issues?q=status:open%20componentid:413132%20type:feature_request" rel="noopener ugc nofollow" target="_blank">列表</a>并考虑<a class="ae hu" href="https://issuetracker.google.com/issues/new?component=413132&amp;template=1096619" rel="noopener ugc nofollow" target="_blank">提出您自己的请求</a>。</p><p id="ac6a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要了解架构和Android Jetpack的最新进展，请关注<a class="ae hu" href="https://medium.com/androiddevelopers" rel="noopener"> Android开发者媒体博客</a>并关注<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases" rel="noopener ugc nofollow" target="_blank"> AndroidX发行说明</a>。</p><p id="b125" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对这些功能有疑问吗？留言评论！感谢阅读！</p><p id="a01b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mi">特别感谢Ian Lake、Yigit Boyar、Jose Alcérreca、肖恩·麦克奎蓝、Jisha Abubaker和Alex Michael Cook的修改和贡献。</em></p></div></div>    
</body>
</html>