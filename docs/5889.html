<html>
<head>
<title>3.14 Tips for using the Kubernetes Cluster Autoscaler on Oracle Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3.14在Oracle云上使用Kubernetes集群自动缩放器的技巧</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/3-14-tips-for-using-the-kubernetes-cluster-autoscaler-on-oracle-cloud-1e65011c2f1f?source=collection_archive---------0-----------------------#2022-03-14">https://medium.com/oracledevs/3-14-tips-for-using-the-kubernetes-cluster-autoscaler-on-oracle-cloud-1e65011c2f1f?source=collection_archive---------0-----------------------#2022-03-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="0659" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">在本文中，我们将介绍Oracle Cloud集群自动伸缩节点组的两种实现，以及我们在<em class="iw">大规模使用它们时学到的一些技巧</em></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/6ed93c7d44bb5f78a43b5f0ffd0a5677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9SmSuEjyohy1FuyDB12NSA.jpeg"/></div></div></figure><p id="a01a" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><a class="ae kf" href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler" rel="noopener ugc nofollow" target="_blank"> Kubernetes集群自动缩放器</a> (CA)通过动态调整后台云提供商上的缩放组大小，根据工作负载自动调整集群中Kubernetes节点的数量。<a class="ae kf" href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/cloudprovider" rel="noopener ugc nofollow" target="_blank">许多云提供商</a>都有一个或多个<em class="kg">实施</em>，作为包括Oracle云基础设施(OCI)在内的集群自动伸缩的<a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-scale-up-work" rel="noopener ugc nofollow" target="_blank">节点组</a>。如果您正在运行<a class="ae kf" href="https://docs.cloud.oracle.com/iaas/Content/ContEng/Concepts/contengoverview.htm" rel="noopener ugc nofollow" target="_blank">Oracle Container Engine for Kubernetes</a>(OKE)，节点组将<a class="ae kf" href="https://docs.oracle.com/en-us/iaas/Content/ContEng/Tasks/contengusingclusterautoscaler.htm" rel="noopener ugc nofollow" target="_blank">实现为后端(<code class="du kh ki kj kk b">--cloud-provider=oke</code>)上的OKE </a><a class="ae kf" href="https://docs.oracle.com/en-us/iaas/Content/ContEng/Tasks/contengscalingclusters.htm" rel="noopener ugc nofollow" target="_blank">节点池</a>。对于那些在OCI基础设施上运行<em class="kg">非托管</em> Kubernetes发行版的人，我们已经使用OCI <a class="ae kf" href="https://docs.oracle.com/en-us/iaas/Content/Compute/Tasks/creatinginstancepool.htm" rel="noopener ugc nofollow" target="_blank">实例池</a> ( <code class="du kh ki kj kk b">--cloud-provider=oci</code>)开发了一个新的<a class="ae kf" href="https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler/cloudprovider/oci" rel="noopener ugc nofollow" target="_blank">实现</a>。</p><p id="a09a" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">为了庆祝<a class="ae kf" href="https://en.wikipedia.org/wiki/Pi_Day" rel="noopener ugc nofollow" target="_blank"> Pi (π) Day </a>，我们认为我们应该看看在大规模自动扩展Kubernetes节点时正确配置的3个重要方面，包括后台<a class="ae kf" href="https://docs.oracle.com/en-us/iaas/Content/Compute/Tasks/creatinginstancepool.htm" rel="noopener ugc nofollow" target="_blank">实例池</a>和OKE <a class="ae kf" href="https://docs.oracle.com/en-us/iaas/Content/ContEng/Tasks/contengscalingclusters.htm" rel="noopener ugc nofollow" target="_blank">节点池</a>的配置、集群自动扩展配置，以及在我们的生产集群中运行的应用pod。在这些<strong class="jl hi"> 3 </strong>区域中，我们选择了我们所学过的最重要的<strong class="jl hi"> 14 </strong>技巧……<strong class="jl hi">3.14、<em class="kg">明白了吗？</em> </strong></p><p id="cdeb" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><em class="kg">注意:如果您还没有注册，您可以今天就</em> <a class="ae kf" href="https://signup.cloud.oracle.com/?language=en&amp;sourceType=:ow:de:te::::RC_WWMK220210P00062:Medium_314tipsKubernetes&amp;intcmp=:ow:de:te::::RC_WWMK220210P00062:Medium_314tipsKubernetes" rel="noopener ugc nofollow" target="_blank"> <em class="kg">注册甲骨文云免费层账户</em> </a> <em class="kg">。</em></p><h1 id="ddcc" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">概括地说，集群自动扩展</h1><p id="a446" class="pw-post-body-paragraph jj jk hh jl b jm ld ii jo jp le il jr js lf ju jv jw lg jy jz ka lh kc kd ke ha bi translated">在深入研究具体的技巧和建议之前，我们学到的第一件事是，通过熟悉CA如何工作，它如何<em class="kg">不</em>工作，以及它如何被调整和定制，您可以避免很多挫折。</p><p id="d263" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><strong class="jl hi">什么CA <em class="kg">做</em> : </strong></p><ol class=""><li id="43e2" class="li lj hh jl b jm jn jp jq js lk jw ll ka lm ke ln lo lp lq bi translated">等待<code class="du kh ki kj kk b"><em class="kg">--scan-interval</em></code>，检查Kubernetes集群中的<code class="du kh ki kj kk b">Pending</code>pod。</li><li id="3a75" class="li lj hh jl b jm lr jp ls js lt jw lu ka lv ke ln lo lp lq bi translated">对于CA配置中的每个节点组，要求提供商提供该组<em class="kg">中的新节点</em>的“模型”(即资源、标签、污点等)。).</li><li id="8913" class="li lj hh jl b jm lr jp ls js lt jw lu ka lv ke ln lo lp lq bi translated">模拟Kubernetes调度程序逻辑，查看/预测<code class="du kh ki kj kk b">Pending</code>Pod<em class="kg">是否可以在该组中的这个假想的新节点上进行调度。</em></li><li id="1d91" class="li lj hh jl b jm lr jp ls js lt jw lu ka lv ke ln lo lp lq bi translated">如果是，<em class="kg">和</em>该节点组未达到其最大或总节点数，则让云提供商执行调整大小(可能会将<em class="kg">多个</em>节点添加到<em class="kg">多个</em>组)。</li><li id="4c32" class="li lj hh jl b jm lr jp ls js lt jw lu ka lv ke ln lo lp lq bi translated">循环回到步骤1。</li></ol><p id="2e8a" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><strong class="jl hi">CA<em class="kg">没有</em>做的事情:</strong></p><ol class=""><li id="819f" class="li lj hh jl b jm jn jp jq js lk jw ll ka lm ke ln lo lp lq bi translated">考虑节点上的<em class="kg">实际</em> CPU、内存或GPU利用率(只有组合的<a class="ae kf" href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#requests-and-limits" rel="noopener ugc nofollow" target="_blank">资源<em class="kg">请求</em> </a>)。</li><li id="7e80" class="li lj hh jl b jm lr jp ls js lt jw lu ka lv ke ln lo lp lq bi translated">向您的Kubernetes集群注册节点。</li><li id="48b0" class="li lj hh jl b jm lr jp ls js lt jw lu ka lv ke ln lo lp lq bi translated">安装软件或配置节点。</li><li id="32d6" class="li lj hh jl b jm lr jp ls js lt jw lu ka lv ke ln lo lp lq bi translated">给节点添加标签或污点。</li><li id="ef89" class="li lj hh jl b jm lr jp ls js lt jw lu ka lv ke ln lo lp lq bi translated">将窗格计划到节点。</li></ol><p id="1737" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">GitHub上的CA <a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md" rel="noopener ugc nofollow" target="_blank">常见问题</a>有更多的信息，值得一读。</p><h1 id="f142" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">1.云提供商节点组配置提示</h1><blockquote class="lw lx ly"><p id="fd51" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示1.1: </strong>配置<a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/cloudprovider/oci/examples/oci-ip-cluster-autoscaler-w-config.yaml#L126" rel="noopener ugc nofollow" target="_blank"> CA部署</a>来管理<strong class="jl hi">多个</strong>节点组(即OKE节点池或OCI实例池)，每个节点组的作用域为<strong class="jl hi">单个</strong> <a class="ae kf" href="https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm" rel="noopener ugc nofollow" target="_blank">可用性域</a> (AD)。<em class="hh">这种配置允许自动缩放器的调度模拟器根据AD精确地和</em>确定性地<em class="hh">按比例增加Kubernetes节点，例如当</em><a class="ae kf" href="http://topology.kubernetes.io/zone" rel="noopener ugc nofollow" target="_blank"><em class="hh">topology.kubernetes.io/zone</em></a><em class="hh">的反亲缘关系是一个特定Pod待定/不可调度的原因时。</em></p></blockquote><pre class="iy iz ja jb fd mc kk md me aw mf bi"><span id="61d5" class="mg km hh kk b fi mh mi l mj mk">kind: Deployment<br/>metadata:<br/>  name: cluster-autoscaler<br/>  namespace: kube-system<br/>   ...<br/> - command:<br/>  - ./cluster-autoscaler<br/>  - --cloud-provider=oci<br/>  - --nodes=1:50:ocid1.instancepool.oc1.phx.ad1...<br/>  - --nodes=0:75:ocid1.instancepool.oc1.phx.ad2...<br/>  - --nodes=0:90:ocid1.instancepool.oc1.phx.ad3...</span></pre><blockquote class="lw lx ly"><p id="ca2b" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示1.2: </strong>在尽可能大的节点组上设置用户自定义的<a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-the-parameters-to-ca" rel="noopener ugc nofollow" target="_blank">最大节点数</a> <code class="du kh ki kj kk b"><em class="hh">--nodes=&lt;min&gt;:&lt;</em><strong class="jl hi"><em class="hh">max</em></strong><em class="hh">&gt;:&lt;id&gt;</em></code>。<em class="hh">由于扩展是一个耗时的过程，CA会连续执行</em>和<em class="hh">，我们观察到，通过让它在</em>最少<em class="hh">的独立操作中提供</em>最多<em class="hh">个节点，性能得到了提高。</em></p><p id="bd2e" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示1.3: </strong>将节点组的<a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-the-parameters-to-ca" rel="noopener ugc nofollow" target="_blank">最小节点计数</a>设置为0 <code class="du kh ki kj kk b"><em class="hh">--nodes=</em><strong class="jl hi"><em class="hh">0</em></strong><em class="hh">:&lt;max&gt;:&lt;id&gt;</em></code>。<em class="hh">CA能够完全缩减未使用的节点组</em><em class="hh">(即缩减至0)当不需要组中的节点时，允许完全缩减以减少或消除云提供商上不需要的资源的成本是非常有用的。</em></p><p id="ba8d" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示1.4: </strong>当使用多个节点组时，如果多个节点组满足Pod要求，使用<a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/expander/priority/readme.md" rel="noopener ugc nofollow" target="_blank">扩展器</a>来控制要扩展的节点组。<em class="hh">如前所述，我们几乎总是配置CA来管理多个<em class="hh">节点组</em>  <em class="hh">。</em>我们也<em class="hh">更喜欢使用</em> <a class="ae kf" href="https://docs.oracle.com/en-us/iaas/Content/Compute/References/computeshapes.htm" rel="noopener ugc nofollow" target="_blank"> <em class="hh">灵活计算形状</em> </a> <em class="hh">当它们可用时。</em> <code class="du kh ki kj kk b"><em class="hh">--expander=priority</em></code> <em class="hh">让我们</em>将我们的节点组优先排序<em class="hh">到CA，例如，这是一个将基于flex实例的池优先排序到基于虚拟机标准实例的池的扩展示例。</em></em></p></blockquote><pre class="iy iz ja jb fd mc kk md me aw mf bi"><span id="d731" class="mg km hh kk b fi mh mi l mj mk">kind: ConfigMap<br/>metadata:<br/>  name: cluster-autoscaler-priority-expander<br/>  namespace: kube-system<br/>data:<br/>  priorities: |-<br/>    50:<br/>      - .*flex-nodepool.*<br/>    20:<br/>      - .*vm-standard-nodepool.*</span></pre><h1 id="ca81" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">2.集群自动缩放配置提示</h1><blockquote class="lw lx ly"><p id="a7c0" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示2.5: </strong>使用与集群Autoscaler (CA)的<strong class="jl hi"> <em class="hh">相同的</em> </strong> <strong class="jl hi">版本</strong>作为您的Kubernetes服务器。<em class="hh">例如，如果你的集群正在运行</em><a class="ae kf" href="https://github.com/kubernetes/kubernetes/releases/tag/v1.23.0" rel="noopener ugc nofollow" target="_blank"><em class="hh">【Kubernetes】v 1.23</em></a><em class="hh">，那么你应该运行</em> <a class="ae kf" href="https://github.com/kubernetes/autoscaler/releases/tag/cluster-autoscaler-1.23.0" rel="noopener ugc nofollow" target="_blank"> <em class="hh">集群自动缩放器v1.23 </em> </a> <em class="hh">。原因是CA </em> <a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/simulator/scheduler_based_predicates_checker.go#L28" rel="noopener ugc nofollow" target="_blank"> <em class="hh">直接从Kubernetes本身导入调度逻辑</em> </a> <em class="hh">。为了避免难以诊断CA模拟器和实际调度程序之间的调度不匹配，请使用与Kubernetes相同的CA版本。此外，在您的部署中使用</em>自定义<em class="hh">调度程序之前，请考虑对CA的影响(即</em>调度策略<em class="hh">可能与CA的调度模拟器不同)。</em></p><p id="46d8" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">技巧2.6: </strong>将CA Pod与您的容器化工作负载隔离开来。<em class="hh">因为CA是CPU和内存密集型的，我们更喜欢在我们的Kubernetes主节点上运行它，让CA部署容忍我们主节点的</em> <a class="ae kf" href="https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/" rel="noopener ugc nofollow" target="_blank"> <em class="hh">污点</em> </a> <em class="hh">。我们避免让CA部署在节点上与我们的应用程序池一起运行，因为应用程序负载会对CA的性能产生负面影响，或者更糟，导致CA被驱逐，使其无法采取扩展措施来解决争用问题。</em></p><p id="4c6b" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示2.7: </strong>运行CA的多个副本。在任何给定时间，只有一个自动缩放副本可以成为主副本。<em class="hh">尽管如此，我们发现运行多个副本是有益的，因为它增加了一个副本总是健康和起作用的可能性。</em></p><p id="2b18" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示2.8: </strong>定制CA等待新节点被供应的<a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-the-parameters-to-ca" rel="noopener ugc nofollow" target="_blank">最大时间&amp;使用<code class="du kh ki kj kk b">--max-node-provision-time</code>在<strong class="jl hi">您的</strong>云提供商上加入您的集群(默认为15分钟)。<em class="hh">即使在同一个提供者中，新节点被供应和注册本身所花费的时间也可能因各种因素而有所不同，这些因素包括操作系统和新节点加入集群的引导程序(</em></a><a class="ae kf" href="https://www.oracle.com/cloud-native/container-engine-kubernetes/" rel="noopener ugc nofollow" target="_blank"><em class="hh">OKE</em></a><em class="hh">、</em> <a class="ae kf" href="https://rancher.com/docs/rke/latest/en/managing-clusters/" rel="noopener ugc nofollow" target="_blank"> <em class="hh">、RKE </em> </a> <em class="hh">、</em><a class="ae kf" href="https://github.com/kubernetes/kops/blob/master/addons/cluster-autoscaler/cluster-autoscaler.sh" rel="noopener ugc nofollow" target="_blank"><em class="hh">kops</em></a><em class="hh">等)。).</em></p><p id="f3a6" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示2.9: </strong>自定义<a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-are-the-parameters-to-ca" rel="noopener ugc nofollow" target="_blank">使用<code class="du kh ki kj kk b">--scan-interval</code>重新评估</a>集群的频率(默认为10秒)。<em class="hh">考虑您的CA响应要求与您的Kubernetes API服务器和云提供商所需的常规API调用量之间的权衡。您最不希望的事情就是CA在您需要它采取缩放操作的时候被抑制。在大多数云提供商上，配置节点需要几分钟时间。我们发现，我们可以将扫描间隔增加到2分钟以上，而不会明显影响CA的响应能力。</em></p><p id="8f5b" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示2.10: </strong>监控<code class="du kh ki kj kk b"><em class="hh">cluster-autoscaler-status</em></code>配置图、事件和CA的普罗米修斯风格<a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/proposals/metrics.md" rel="noopener ugc nofollow" target="_blank">/度量</a>端点。<em class="hh">除了CA容器日志，</em> <code class="du kh ki kj kk b"><em class="hh">cluster-autoscaler-status</em></code> <em class="hh"> configmap对调试问题很有帮助。它包含CA <em class="hh">感知的节点组</em>的状态，包括每个节点组的健康状况、请求了多少个节点以及实际加入集群的节点数量、伸缩事件等。CA的内部</em> <code class="du kh ki kj kk b"><em class="hh">/metrics</em></code> <em class="hh">端点包含更多的</em> <a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/proposals/metrics.md" rel="noopener ugc nofollow" target="_blank"> <em class="hh">详细指标</em></a><em class="hh">(go-routine的数量、CPU和内存细节等。)以及与CA框架的各个部分所花费的时间相关的度量。</em></p><p id="4f94" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示2.11: </strong>与<a class="ae kf" href="https://github.com/jthomperoo/horizontal-pod-autoscaler" rel="noopener ugc nofollow" target="_blank">水平Pod自动缩放器</a> (HPA)或<a class="ae kf" href="https://github.com/kubernetes-sigs/cluster-proportional-autoscaler" rel="noopener ugc nofollow" target="_blank">集群比例自动缩放器</a> (CPA)一起运行集群自动缩放器(CA)，以获得不同的可扩展性。<em class="hh">对于某些工作负载，这些不同的Kubernetes自动缩放器可以解决不同的问题，并且在一起使用</em>时可以很好地互补<em class="hh">。HPA和CPA都会动态增加部署副本数量，从而增加所需的资源。CA介入并调整节点计数，以满足新添加的副本的新资源需求。</em></p></blockquote><h1 id="9ab2" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">3.应用程序窗格配置提示</h1><blockquote class="lw lx ly"><p id="b1b7" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示3.12: </strong>尽可能确保您的应用程序单元能够承受移动。<em class="hh">除了监视不可调度的pod，CA还会定期寻找机会</em>将pod<em class="hh">移动到不同的节点，以减少集群中的节点数量(即删除未充分利用的节点)。重要的是要记住，删除一个给定的节点需要</em> <strong class="jl hi"> <em class="hh"> </em> </strong>重新启动之前在其上运行的所有Pods <em class="hh">。</em></p><p id="022e" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示3.13: </strong>防止任何没有弹性的应用舱被移动。有些豆荚没有弹性，或者移动起来很贵。 <em class="hh">我们用</em> <code class="du kh ki kj kk b"><em class="hh">cluster-autoscaler.kubernetes.io/safe-to-evict=false</em></code> <em class="hh">到</em> <a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#what-types-of-pods-can-prevent-ca-from-removing-a-node" rel="noopener ugc nofollow" target="_blank"> <em class="hh">标注这样的pod，防止它们</em> </a> <em class="hh">被CA强制到不同的节点上。</em></p><p id="cbd4" class="jj jk kg jl b jm jn ii jo jp jq il jr lz jt ju jv ma jx jy jz mb kb kc kd ke ha bi translated"><strong class="jl hi">提示3.14: </strong>确保你所有的豆荚都有<a class="ae kf" href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/" rel="noopener ugc nofollow" target="_blank">资源请求</a>设置在它们的规格中。CA不监控节点上的实际资源使用情况——只监控pod规范中的组合<a class="ae kf" href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-requests-and-limits-of-pod-and-container" rel="noopener ugc nofollow" target="_blank">资源请求。u<em class="hh">n如果您的pod的所有<em class="hh">都设置为</em> <code class="du kh ki kj kk b">spec.containers[].resources.requests</code> <em class="hh">，CA将无法准确了解节点的资源利用率，包括当未充分利用的节点的</em> <code class="du kh ki kj kk b"><em class="hh">--scale-down-utilization-threshold</em></code> <em class="hh"> </em> <a class="ae kf" href="https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-scale-down-work" rel="noopener ugc nofollow" target="_blank"> <em class="hh">满足</em> </a> <em class="hh">时。一个没有使用资源请求的</em>单个<em class="hh"> Pod将会丢弃它，因为它的资源没有反映在CA在该节点</em>上的Pod的总</em>资源请求<em class="hh">中。</em></a></p></blockquote><h1 id="3fc5" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">包扎</h1><p id="280a" class="pw-post-body-paragraph jj jk hh jl b jm ld ii jo jp le il jr js lf ju jv jw lg jy jz ka lh kc kd ke ha bi translated">在本帖中，我们分享了运行集群自动缩放器的最重要和最艰难的技巧。我们还提供了OCI为托管和非托管Kubernetes选项自动扩展节点组(OKE节点池、OCI实例池)的两个实现的链接。我们希望你至少发现了一些有用的提示。请不要犹豫，留下你的评论或者在相关的GitHub项目中提出问题。</p><p id="ed74" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><strong class="jl hi"> <em class="kg">快乐的霹日</em>！</strong></p><h1 id="7a72" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">加入对话！</h1><p id="82f6" class="pw-post-body-paragraph jj jk hh jl b jm ld ii jo jp le il jr js lf ju jv jw lg jy jz ka lh kc kd ke ha bi translated">如果你对甲骨文开发人员在他们的自然栖息地发生的事情感到好奇，来<a class="ae kf" href="https://join.slack.com/t/oracledevrel/shared_invite/zt-uffjmwh3-ksmv2ii9YxSkc6IpbokL1g?customTrackingParam=:ex:tb:::::RC_WWMK220210P00062:Medium_314tipsKubernetes" rel="noopener ugc nofollow" target="_blank">加入我们的公共休闲频道</a>！我们不介意成为你的鱼缸🐠</p><p id="9fa8" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><em class="kg">照片由</em> <a class="ae kf" href="https://unsplash.com/@lukaszlada?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="kg">乌卡斯兹阿达</em> </a> <em class="kg">上</em><a class="ae kf" href="https://unsplash.com/s/photos/cloud-pie?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><em class="kg">Unsplash</em></a></p></div></div>    
</body>
</html>