<html>
<head>
<title>7 Surprising Things I Learned Writing a Fibonacci Generator in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript写斐波那契生成器时我学到的7件令人惊讶的事情</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/7-surprising-things-i-learned-writing-a-fibonacci-generator-4886a5c87710?source=collection_archive---------2-----------------------#2016-05-14">https://medium.com/javascript-scene/7-surprising-things-i-learned-writing-a-fibonacci-generator-4886a5c87710?source=collection_archive---------2-----------------------#2016-05-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/059f489ff24ba37f7dc57b7a794477e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRYQd9SyTLDMtGsIUENlhw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Nautilus Shell — Dave Spindle (CC-BY-NC-2.0)</figcaption></figure><p id="5938" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">生成器函数是ES6中引入的JavaScript的新特性。为了更深入地探索它们，我决定写一个斐波那契生成器函数。</p><p id="781c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">以下是我学到的。</p><h2 id="3837" class="jr js hh bd jt ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl bi translated">采用新功能</h2><p id="cd1e" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">有时候一个新的语言特性出现了，我会跳过它，开始一直使用它。ES6的其他几个功能也是如此。我列出了我最喜欢的ES6功能，并将其命名为<a class="ae kr" href="https://ericelliottjs.com/product/es6-the-road-map-2-hour-webcast-recording/" rel="noopener ugc nofollow" target="_blank">路线图</a>:</p><ul class=""><li id="1e62" class="ks kt hh iv b iw ix ja jb je ku ji kv jm kw jq kx ky kz la bi translated"><strong class="iv hi">居</strong>息&amp;散</li><li id="59e6" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq kx ky kz la bi translated"><strong class="iv hi"> O </strong>对象文字快捷键(compact literals)</li><li id="d4fb" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq kx ky kz la bi translated"><strong class="iv hi"> A </strong>箭头功能</li><li id="3a40" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq kx ky kz la bi translated"><strong class="iv hi"> D </strong>析构&amp;默认参数</li><li id="716f" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq kx ky kz la bi">—</li><li id="7184" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq kx ky kz la bi translated"><strong class="iv hi"> M </strong>模块</li><li id="89e5" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq kx ky kz la bi translated"><strong class="iv hi"> A </strong>异步<strong class="iv hi"> P </strong>编程(承诺&amp;发电机)</li></ul><p id="4dda" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当我列出清单时，我认为这些是我最常用的ES6功能。最初，我对生成器非常感兴趣，但是现在我已经和它们一起生活了一段时间，在我真正的应用程序代码中，我还没有发现很多好的生成器用例。对于我可能使用生成器的大多数用例，我选择了RxJS，因为它有更丰富的API。</p><p id="c050" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这并不意味着生成器没有很多好的用例。我告诉自己，在我真的疯狂使用JS引擎之前，我一直在等待更好的JS引擎支持，但这可能是因为我的大脑还没有考虑到生成器。解决这个问题的最好方法就是多练习。</p><p id="1bb8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当我听说生成器时，立即跳入我脑海的一个用例是，我们可能使用它们从任何无穷级数中获取值。这可能有许多应用，如图形生成算法、电脑游戏关卡、音乐序列等…</p><h2 id="abd3" class="jr js hh bd jt ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl bi translated">什么是斐波那契数列？</h2><p id="986b" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">斐波那契是一个简单、规范的例子，你们大多数人可能已经很熟悉了。以下是基本情况:</p><p id="91e8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">斐波那契数列是一系列数字:</p><p id="d459" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="lg"> 0，1，1，2，3，5，8，13，21，34… </em></p><p id="005a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在种子号码<em class="lg"> 0 </em>和<em class="lg"> 1 </em>之后，每一个后续号码都是前两个号码的总和。该序列的一个有趣的性质是，序列中当前数字与前一个数字的比率向黄金分割比率收敛，<em class="lg"> 1.61803398875… </em></p><p id="16b5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">你可以使用斐波那契数列来生成各种有趣的东西，比如自然界中出现的黄金螺旋。</p><h2 id="a70e" class="jr js hh bd jt ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl bi translated">什么是生成器函数？</h2><p id="089d" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">生成器函数是ES6中的一个新特性，它允许一个函数通过返回一个对象来<em class="lg">随时间生成许多值</em>，该对象可以被迭代以从函数中一次提取一个值。</p><p id="ab08" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当调用生成器函数时，它不是直接返回值，而是返回一个迭代器对象。</p><p id="3bff" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">迭代器协议</strong></p><p id="cdbb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">迭代器对象有一个<em class="lg"> `.next()` </em>方法。当调用<em class="lg"> `.next()` </em>方法时，函数体在最后一次调用<em class="lg"> `.next()` </em>时执行的行之后恢复。它继续执行，直到达到一个<em class="lg"> `yield` </em>，此时，它返回一个对象，如下所示:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="4bb2" class="jr js hh lm b fi lq lr l ls lt">{<br/>  value: Any,<br/>  done: Boolean<br/>}</span></pre><p id="030f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="lg"> `value` </em>属性包含生成的值，<em class="lg"> `done` </em>表示生成器是否生成了最后一个值。</p><p id="cb50" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">JavaScript中的很多东西都使用迭代器协议，包括新的<em class="lg"> `for…of` </em>循环、数组rest/spread操作符等等。</p><h1 id="3634" class="lu js hh bd jt lv lw lx jx ly lz ma kb mb mc md ke me mf mg kh mh mi mj kk mk bi translated">1.生成器不喜欢递归</h1><p id="4721" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">我习惯于担心JavaScript中的递归。当一个函数调用另一个函数时，会分配一个新的堆栈帧来存储该函数的数据状态。无限递归会导致内存问题，因为可以分配多少堆栈帧是有限制的。当达到这些限制时，会导致堆栈溢出。</p><p id="723c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">堆栈溢出就像警察突袭你的聚会，并告诉你所有的朋友回家。完全扫兴。</p><p id="0501" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当ES6引入尾部调用优化时，我非常兴奋，它让递归函数在每次迭代中重用相同的堆栈帧——但它只有在递归调用位于尾部时才有效。尾部位置的调用意味着函数返回递归调用的结果，而无需任何进一步的计算。</p><p id="4a07" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">太好了！我的第一个天真的实现使用了一个非常简单的数学斐波那契定义:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/3a760517621997050e78e376bac0d761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lG0GQDeuitgxE2-_rybUDg.png"/></div></div></figure><p id="1fa7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">使用种子值<em class="lg"> 0 </em>和<em class="lg"> 1 </em>来启动序列，并将加法运算移入函数调用签名中，如下所示:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="6634" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我喜欢这看起来有多干净。种子值在函数签名中很明显，公式在递归调用中表达得非常清楚。</p><p id="ab33" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="lg"> `if` </em>条件允许当<em class="lg"> `n` </em>达到<em class="lg"> 0时，使用<em class="lg"> `return` </em>而不是<em class="lg"> `yield` </em>终止循环。</em>如果不通过<em class="lg"> `n` </em>，当我们试图从中减去<em class="lg"> `1` </em>时，它将`<em class="lg"> undefined` </em>并求值为<em class="lg"> `NaN` </em>，因此函数将永远不会终止。</p><p id="5055" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这个实现非常简单…也很幼稚。当我测试大值时，它爆炸了。</p><p id="c3f6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi">(ಥ﹏ಥ)</p><p id="a8b7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">可悲的是，<strong class="iv hi">尾调用优化不适用于生成器</strong>。在规范中函数调用<a class="ae kr" href="https://tc39.github.io/ecma262/#sec-function-calls" rel="noopener ugc nofollow" target="_blank">下运行时语义:求值</a>:</p><p id="7dea" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> 7。</strong>设<em class="lg"> tailCall </em>为<em class="lg">is tail position(this call)</em>。</p><p id="5bfd" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> 8。</strong>返回<em class="lg"> EvaluateDirectCall(func，thisValue，Arguments，tailCall) </em>。</p><p id="bdf8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"><em class="lg">is indail position</em></strong>为发电机返回false(参见<a class="ae kr" href="https://tc39.github.io/ecma262/#sec-tail-position-calls" rel="noopener ugc nofollow" target="_blank"> 14.6.1 </a>):</p><p id="19ef" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> 5。</strong>如果<em class="lg">体</em>是<em class="lg">发生器体</em>的<em class="lg">功能体</em>，则返回<em class="lg">假</em>。</p><p id="51a3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">换句话说，<strong class="iv hi">避免无限生成器</strong>的递归。如果你想避免堆栈溢出，你需要使用迭代的形式。</p><blockquote class="mo mp mq"><p id="5418" class="it iu lg iv b iw ix iy iz ja jb jc jd mr jf jg jh ms jj jk jl mt jn jo jp jq ha bi translated">几个月来，我一直在享受Babel中的尾部调用优化，但它已经被移除了。据我所知，在撰写本文时，<a class="ae kr" href="https://kangax.github.io/compat-table/es6/" rel="noopener ugc nofollow" target="_blank">由于引擎实现者提出的<a class="ae kr" href="https://github.com/kangax/compat-table/issues/819" rel="noopener ugc nofollow" target="_blank">争议/困难</a>，只有Webkit (Safari，Mobile Safari)支持新的ES6适当尾调用</a>。</p></blockquote><p id="8d42" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">稍加修改，我们可以去掉递归，而使用迭代形式:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="f1db" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">正如您所看到的，我们仍然在进行与原始函数调用签名中相同的变量交换，但是这次我们使用析构赋值来在while循环中完成它。我们需要`<em class="lg"> isInfinite` </em>在生成器中，以防我们没有超过一个限制。</p><h1 id="b4c3" class="lu js hh bd jt lv lw lx jx ly lz ma kb mb mc md ke me mf mg kh mh mi mj kk mk bi translated">2.让参数限制迭代</h1><p id="19df" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">可以结合使用析构赋值和…rest语法从生成器中提取数组:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="61bb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但是如果你的生成器是一个无穷级数，并且没有办法通过传递一个参数来描述一个极限，那么得到的数组将永远不会停止填充。</p><p id="e535" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi">┻━┻ ︵ヽ(`Д´)ﾉ︵ ┻━┻</p><p id="0713" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在上面的两个斐波那契实现中，我们允许调用者传递<em class="lg"> `n` </em>，这将序列限制为第一个<em class="lg"> `n` </em>数字。一切都好！</p><p id="3531" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi">┬─┬ ノ( ゜-゜ノ)</p><h1 id="15d9" class="lu js hh bd jt lv lw lx jx ly lz ma kb mb mc md ke me mf mg kh mh mi mj kk mk bi translated">3.小心记忆的函数</h1><p id="0138" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">很容易记住像斐波那契数列这样的东西，因为这样做可以极大地减少所需的迭代次数。换句话说，它使<strong class="iv hi"><em class="lg"/></strong>快了很多。</p><h2 id="4088" class="jr js hh bd jt ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl bi translated">什么是记忆功能？</h2><p id="c7eb" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">对于给定相同参数时总是产生相同输出的函数，您可以将结果记录在备忘录中以备将来调用，这样就不必重复计算结果。相反，结果会在备忘录中查找并返回，而不会重复计算。斐波那契算法重复大量的计算来得出结果，这意味着如果我们记住这个函数，我们可以节省很多时间。</p><p id="ea47" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们看看如何记忆斐波那契生成器的迭代形式:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="7b5e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">因为<em class="lg"> `n` </em>本质上表示一个数字数组的索引，所以我们可以把它作为一个文字数组索引。后续调用将只查找该索引并返回相应的结果值。</p><h2 id="ec1a" class="jr js hh bd jt ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl bi translated">编辑:</h2><p id="7aa1" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">这段代码的原始版本有一个错误。第一次运行这个函数时，一切都很好，但是备忘录写得不正确，因为当你发现一个备忘录命中时，你不能只产生一个值——不像<em class="lg"> `return`, `yield` </em>不会停止函数的其余部分的运行。它只是暂停执行，直到再次调用<em class="lg"> `.next()` </em>。</p><p id="fcd2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是我最难理解的一点。<em class="lg"> `yield` </em>不仅仅是发电机的<em class="lg"> `return` </em>。您还必须仔细考虑用<em class="lg"> `next()` </em>恢复函数会如何影响您编写逻辑的方式。</p><p id="dcf0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这种情况下，我能够使用<em class="lg"> `yield`, </em>让逻辑工作，但这使得控制流难以阅读。</p><p id="dedd" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我突然想到，对于可以用这种方式记忆的东西，当我把生成器函数和计算逻辑分开时，阅读起来会容易得多。</p><p id="5e09" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">正如您所看到的，新的生成器函数非常简单——它只是通过调用memoized <em class="lg"> `fib()` </em>来计算memo数组，然后使用<em class="lg"> `yield*` </em>将生成器委托给结果数组iterable。</p><p id="e792" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="lg"> `yield*` </em>是<em class="lg"> `yield` </em>的特殊形式，将委托给另一个生成器或iterable。例如:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h2 id="4468" class="jr js hh bd jt ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl bi translated">基准</h2><p id="e52a" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">每当我使用竞争算法实现时，我通常会编写一个简单的基准脚本来比较性能。</p><p id="669e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这个测试中，我生成了79个数字，每个数字。我使用Node的<em class="lg"> `process.hrtime()` </em>来记录两个实现的纳秒级精确计时，运行测试三次，并对结果取平均值:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mu"><img src="../Images/4e27d0a09a45dee411734f731a9cd434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_sWh_b61Xy3DqzG8SgTp8g.png"/></div></div></figure><p id="fbe6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如您所见，这是一个非常显著的差异。如果你正在生成大量的数字，并且你希望它很快，那么记忆化的解决方案显然是一个明智的选择。</p><p id="4cd4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">只有一个问题:对于无限序列，memo数组将会无限增长。最终，您将遇到堆大小限制，这将使JS引擎崩溃。</p><p id="66cc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">不过不用担心。使用Fibonacci，您将首先遇到最大精确JavaScript整数大小，即<em class="lg"> 9007199254740991。超过了<strong class="iv hi"> 9万亿次</strong>，这是一个很大的数字，但斐波那契并不以为然。斐波那契增长<strong class="iv hi">快<em class="lg">。仅生成79个数字后，你就能突破这个障碍。</em></strong></em></p><h1 id="ff88" class="lu js hh bd jt lv lw lx jx ly lz ma kb mb mc md ke me mf mg kh mh mi mj kk mk bi translated">4.JavaScript需要一个内置的API来精确计时</h1><p id="ee6b" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">每当我编写一个简单的基准测试脚本时，我都希望有一个能在浏览器和节点上工作的精确计时API，但是没有。我们能得到的最接近的是一个库，它提供了包装浏览器的<em class="lg"> `performance.now()` </em> API和节点的<em class="lg"> `process.hrtime()` </em> API的外观，以呈现一个统一的API。不过，实际上，仅节点基准测试对于这个测试来说已经足够了。</p><p id="62a8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我唯一的不满是Node的<em class="lg"> `process.hrtime()` </em>返回一个数组，而不是一个以纳秒为单位的直接值。不过，这很容易补救:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="fa30" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">只需将从<em class="lg"> `process.hrtime()` </em>返回的数组传递给这个函数，就可以得到人性化的纳秒。让我们来看看我用来比较迭代斐波那契生成器和记忆化版本的基准脚本:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="9a64" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我最喜欢的<em class="lg"> `hrtime()` </em>的特性是，您可以将开始时间传递到函数中，以获得从开始时间起经过的时间——这正是您进行分析所需要的。</p><p id="3130" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">有时候，操作系统任务调度程序会让进程遇到一些糟糕的运气，所以我喜欢多次运行这样的脚本，并平均结果。</p><p id="abe0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我确信您可以想出更准确的方法来对您的代码进行基准测试，但是这种方法对于大多数情况来说应该足够好了——尤其是当有像memoized Fibonacci实现这样明显的赢家时。</p><h1 id="214c" class="lu js hh bd jt lv lw lx jx ly lz ma kb mb mc md ke me mf mg kh mh mi mj kk mk bi translated">5.当心浮点精度错误</h1><p id="e37a" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">我不想用太多疯狂的数学来烦你，但你知道吗，有一种不用迭代或递归就能非常有效地计算斐波那契数列的方法？看起来是这样的:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="b1a3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">唯一的问题是浮点精度的限制。实际公式不包括任何舍入。我添加它是因为浮点误差在<em class="lg"> `n = 11 `之后开始导致结果漂移。没什么印象。</em></p><p id="c8a7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">好消息是，通过添加舍入，我们可以将精度提高到<em class="lg"> `n = 75`。</em> <em class="lg">好多了。</em>这离使用JavaScript的本地<em class="lg"> `Number` </em>类型的最大精确值还差几个数字，我们之前发现的是<em class="lg"> `n = 79` </em>。</p><p id="5b92" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">所以，只要我们不需要比<em class="lg"> `n = 75` </em>更高的值，这个更快的公式就很好用！让我们把它变成一个发电机:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="4764" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">看起来不错。让我们来看一次基准测试:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="10a8" class="jr js hh lm b fi lq lr l ls lt">Profile with 79 numbers<br/>    original: 901643ns<br/>    memoized: 544423ns<br/>    formula:  311068ns</span></pre><p id="0a5b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">是的，更快了，但是我们失去了最后几个准确的数字。值得权衡吗？</p><p id="43dc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">\( _o)/</p><h1 id="d229" class="lu js hh bd jt lv lw lx jx ly lz ma kb mb mc md ke me mf mg kh mh mi mj kk mk bi translated">6.了解你的极限</h1><p id="d0ca" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">在我开始之前:</p><ul class=""><li id="51b0" class="ks kt hh iv b iw ix ja jb je ku ji kv jm kw jq kx ky kz la bi translated">我不知道在这个系列中使用标准的JavaScript <em class="lg"> `Number` </em>类型能产生多少精确的值。</li><li id="dece" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq kx ky kz la bi translated">我不知道我可以用公式版本产生多少精确的值。</li><li id="13da" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq kx ky kz la bi translated">我不知道要进行多少次递归调用才能产生这些精确的值。</li></ul><p id="6264" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但是现在我知道了所有这些限制，到目前为止最好的实现是我还没有向您展示的:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="1f3d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我在实际应用中使用无穷级数的大多数时候，我实际上需要有限数量的值用于特定目的(通常是生成图形)。大多数时候，从<strong class="iv hi">查找表</strong>中获取值比计算值要快。事实上，这是在80年代和90年代的电脑游戏中经常使用的优化方法，可能现在仍然如此。</p><p id="a767" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">由于数组在ES6中是可迭代的，并且默认情况下已经表现得像生成器一样，我们可以简单地使用<em class="lg"> `yield*` </em>委托给查找表。</p><p id="4f69" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">不足为奇的是，这是该系列中速度最快的实现，远远领先于其他产品:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="38b2" class="jr js hh lm b fi lq lr l ls lt">Profile with 79 numbers<br/>    original: 890088ns<br/>    memoized: 366415ns<br/>    formula:  309792ns<br/>    lookup:   191683ns</span></pre><p id="7185" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">回过头来看，我很确定，只要我们将序列限制为精确的值，调用堆栈就不会有问题…稍微修改一下递归版本可能就可以了:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="47c7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是我最喜欢的一个。种子值可以放在备忘录中，让实际计算尽可能接近数学递归关系:<em class="lg"> Fn = Fn-1 + Fn-2 </em></p><p id="5a27" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">对于生成器，我们只是再次委托给memo数组。</p><h2 id="b147" class="jr js hh bd jt ju jv jw jx jy jz ka kb je kc kd ke ji kf kg kh jm ki kj kk kl bi translated">要注意的限制</h2><ul class=""><li id="ee21" class="ks kt hh iv b iw km ja kn je mv ji mw jm mx jq kx ky kz la bi translated">如果您使用一个利用浮点数学的公式，您应该明确地测试它的准确性限制。</li><li id="cd4b" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq kx ky kz la bi translated">如果您使用的是指数增长的序列，您应该在遇到JS <em class="lg"> `Number` </em>类型的限制之前，计算出可以生成多少序列。</li><li id="d801" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq kx ky kz la bi translated">如果您的限制足够小，可以考虑预先生成一个查找表来加速您的生产应用程序。</li></ul><p id="6a21" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您决定需要比JavaScript本身能够表示的更大的精确数字，那么您还没有完全失去运气。有任意大小的整数库可用，比如<a class="ae kr" href="https://github.com/peterolson/BigInteger.js" rel="noopener ugc nofollow" target="_blank"> BigInteger </a>。</p><h1 id="2760" class="lu js hh bd jt lv lw lx jx ly lz ma kb mb mc md ke me mf mg kh mh mi mj kk mk bi translated">7.很多东西都像发电机一样运转</h1><p id="ef51" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">当在ES6中引入生成器函数时，许多其他内置的东西也实现了<strong class="iv hi">迭代器</strong> <strong class="iv hi">协议</strong>(从生成器返回的可以被迭代的东西)。</p><p id="f27b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">更准确地说，他们实现了<strong class="iv hi">可迭代协议</strong>。<em class="lg"> `String `、` Array `、` TypedArray `、` Map` </em>和<em class="lg"> `Set` </em>都是内置的可迭代对象，也就是说它们都有一个<em class="lg">`【symbol . iterator】`</em>属性是不可枚举的。</p><p id="2c8e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">换句话说，现在可以使用迭代器<em class="lg"> `.next()` </em>方法迭代任何类似数组的内置对象。</p><p id="a7c8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">下面是你如何访问一个数组迭代器。这种技术对于实现iterable协议的任何东西都是一样的:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="ba39" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您甚至可以构建自己的自定义iterables:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="20ee" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">甚至重新定义内置的可迭代行为，但是要小心——我看到了Babel和V8之间不一致的行为:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="c08f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我想写一个基本上是<em class="lg">` arr[symbol . iterator]()`,</em>的快捷方式的函数可能会很方便，所以我做了一个，并给了它一个有趣的切片API，这样你就可以很容易地抓取数组的块并将它们转换成迭代器。我称之为arraygen。你可以<a class="ae kr" href="https://github.com/ericelliott/arraygen" rel="noopener ugc nofollow" target="_blank">在GitHub </a>上浏览arraygen。</p><h1 id="8f75" class="lu js hh bd jt lv lw lx jx ly lz ma kb mb mc md ke me mf mg kh mh mi mj kk mk bi translated">结论</h1><p id="faa0" class="pw-post-body-paragraph it iu hh iv b iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm kq jo jp jq ha bi translated">希望我发现了一些你可能不知道的关于发电机的东西。我也偏离了一些有趣的话题:</p><ol class=""><li id="98b2" class="ks kt hh iv b iw ix ja jb je ku ji kv jm kw jq my ky kz la bi translated"><strong class="iv hi">避免递归。</strong>发电机得不到优化尾调用。</li><li id="30ca" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq my ky kz la bi translated"><strong class="iv hi">允许参数限制你的生成器的长度</strong>，你可以使用…rest操作符来析构它们。</li><li id="fec6" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq my ky kz la bi translated"><strong class="iv hi">内存无限生成器可以突破堆大小限制。</strong></li><li id="fbf2" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq my ky kz la bi translated"><strong class="iv hi"> JavaScript有两个竞争的API用于精确计时。</strong>为什么我们不能一起努力？(ಥ﹏ಥ)</li><li id="cdb3" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq my ky kz la bi translated"><strong class="iv hi">浮点精度误差可能会导致基于公式的无限生成器出错。</strong>小心。</li><li id="af49" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq my ky kz la bi translated"><strong class="iv hi">了解自己的极限。</strong>您的发电机是否有足够的跑道来满足您的应用需求？它在跑道的跨度上足够精确吗？你会遇到你所使用的数据类型的限制吗？JS引擎有足够的内存让你的生成器运行你想要的时间吗？</li><li id="ec4a" class="ks kt hh iv b iw lb ja lc je ld ji le jm lf jq my ky kz la bi translated">大多数内置的行为有点像带有iterable协议的生成器，你可以定义你自己的定制iterable。</li></ol><p id="4984" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果你想玩斐波那契数列的例子，你可以从GitHub 克隆完整的源代码。</p></div><div class="ab cl mz na go nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ha hb hc hd he"><h1 id="caa1" class="lu js hh bd jt lv ng lx jx ly nh ma kb mb ni md ke me nj mg kh mh nk mj kk mk bi translated"><a class="ae kr" href="https://ericelliottjs.com/product/es6-the-road-map-2-hour-webcast-recording/" rel="noopener ugc nofollow" target="_blank">了解更多关于ES6的信息:<br/>路线图(会员免费)</a></h1></div><div class="ab cl mz na go nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ha hb hc hd he"><p id="3717" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="lg">埃里克·艾略特</em> </strong> <em class="lg">著有</em> <a class="ae kr" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="lg">【编程JavaScript应用】</em> </a> <em class="lg">(奥赖利)，以及</em> <a class="ae kr" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank"> <em class="lg">【跟埃里克·艾略特学JavaScript】</em></a><em class="lg">。他为Adobe Systems</em><strong class="iv hi"><em class="lg"/></strong><em class="lg"/><strong class="iv hi"><em class="lg">尊巴健身</em></strong><em class="lg"/><strong class="iv hi"><em class="lg">华尔街日报</em></strong><em class="lg"/><strong class="iv hi"><em class="lg">【ESPN</em></strong><em class="lg"/><strong class="iv hi"><em class="lg">BBC</em></strong><em class="lg">等顶级录音师贡献了软件经验</em></p><p id="61a2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>