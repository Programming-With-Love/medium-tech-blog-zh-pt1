<html>
<head>
<title>Android Testing Part 3 — MVP “Model” e Dependency Injection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android 测试第 3 部分:“模型” MVP 和依赖注入</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/android-testing-part-3-mvp-model-e-dependency-injection-32a9036d18d6?source=collection_archive---------1-----------------------#2016-10-25">https://medium.com/google-developer-experts/android-testing-part-3-mvp-model-e-dependency-injection-32a9036d18d6?source=collection_archive---------1-----------------------#2016-10-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d113" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在最新的“MVP”帖子中,我谈到了我们应该如何组织一个项目,以便我们可以轻松实现MVP架构标准,并演示了如何实现View和Presenter组件。</p><p id="457a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文旨在结束对 MVP 的解释及其在项目中的实现,以便我们可以转到本系列的主要目标,即教你如何为 Android 应用编写测试。</p><p id="1a82" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中,我将谈论:</p><ul class=""><li id="5fb9" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">依赖注入(Dependency Injection)(T4)为什么谈论它);</li><li id="6461" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb ji jj jk jl bi translated">实现一个干净的通用模型;</li></ul><h2 id="22f3" class="js jt hh bd ju jv jw jx jy jz ka kb kc ip kd ke kf it kg kh ki ix kj kk kl km bi translated">依赖注入 Dependency Injection</h2><blockquote class="kn"><p id="0858" class="ko kp hh bd kq kr ks kt ku kv kw jb dx translated">“依赖注入是用于一个非常便宜的概念的膨胀期”——Daniel Lew(Android @ Trello和GDE)</p></blockquote><p id="4566" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">@Daniel Lew Dependency Injection是一个非常漂亮的术语,对于一个非常简单的概念,我会说它吓人。(主要针对那些刚开始为android编程的人) <br/>这是因为这个术语(在android中)与Dagger类型的库有关,这些库可能非常好,但只是试图理解它是如何工作的,这使得一切都非常混乱。</p><p id="5511" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当代码的一部分依赖于另一部分来执行某些操作时,使用术语<em class="jm">依赖注入(T8),并且我们在依赖它的函数中注入变量。(这么简单)</em></p><p id="069c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个基本的场景,我相信每个人都曾经在某个时候,是需要一个变量X在类Y,它可以执行Z操作。</p><p id="26fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">看一下上面的场景,我们可以很快地说,操作Z依赖于X,并且可以通过两种方式传递给类Y:</p><ol class=""><li id="2277" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb lc jj jk jl bi translated">在创建类Y时将X作为构造函数参数传递。</li><li id="310a" class="jd je hh ig b ih jn il jo ip jp it jq ix jr jb lc jj jk jl bi translated">在类Y中创建X。</li></ol><p id="ab2c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些方法将允许执行Z操作,但这里要保留的最重要的是将X“注入”到Y类作为执行Z操作的重要变量。</p><h2 id="5c87" class="js jt hh bd ju jv jw jx jy jz ka kb kc ip kd ke kf it kg kh ki ix kj kk kl km bi translated">依赖注入(Dependency Injection,T10)</h2><p id="05f2" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">将此依赖注入概念放在本系列开头并与模型相关联的主要原因,以及此概念在创建良好测试环境中的重要性,其中主要因素之一是测试不受外部变量/组件的影响。</p><p id="e124" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将模型视为负责从给定源读取/存储数据的组件,假设单个源进行测试将假定我们必须依赖数据源(控制台、磁盘或服务器数据)来执行架构所需的测试。因此,依赖注入的概念将允许我们注入我们为测试而创建的假数据源(T0),并且只关注我们想要测试的组件,而不必担心REST API实现或磁盘上的数据是否成功。(T2 ) Non of our business (T3 )。</p><h2 id="1c78" class="js jt hh bd ju jv jw jx jy jz ka kb kc ip kd ke kf it kg kh ki ix kj kk kl km bi translated">实现一个干净的和通用的模型</h2><p id="7ee1" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">应用依赖注入的概念在很大程度上取决于我们如何构建代码。因此,我们必须适当地构建我们的类,以便我们可以利用上述概念提供的好处。</p><p id="6d79" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的模型将有不同的组件相互连接,如下图所示:</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es li"><img src="../Images/c9e2b46d57a638136e2760f7b622fd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*CD4l083jHOqsOru0ZrmZ4Q.png"/></div></figure><p id="8ada" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如上图所示(一个并发症),模型由以下类组成:</p><p id="8d06" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> EventServiceApi <br/></strong> 此接口定义了任何数据源(磁盘、网络)必须遵循的约定。<br/> 除了方法之外,这个接口还包含一个带有回调方法的接口,该接口将用于与存储库(如下所述)进行通信,如下面的代码所示。</p><p id="1017" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了这个创建的接口,我们可以从不同的源(Disco,REST API)读取数据,只需创建一个新类,根据我们正在实现的数据源实现合同中定义的方法。(示例:EventsService 实现从 REST API 读取数据,我们将在 <strong class="ig hi"> loadEvent </strong> 方法中使用 Retrofit 或任何其他机制调用 API)</p><pre class="lj lk ll lm fd lq lr ls lt aw lu bi"><span id="444a" class="js jt hh lr b fi lv lw l lx ly"><strong class="lr hi">public interface </strong>EventsServiceApi {<br/><br/>    <strong class="lr hi">interface </strong>EventsServiceApiCallback&lt;T&gt;{<br/>        <strong class="lr hi">void </strong>onEventsLoaded(T events);<br/><br/>    }<br/>    <strong class="lr hi">void </strong>loadEvents(EventsQueryForm form, EventsServiceApiCallback&lt;List&lt;Event&gt;&gt; callback);<br/><br/>}</span></pre><p id="4d0e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(T10) EventRepository(T11)</p><p id="8ec5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">EventRepository 接口定义了与 EventServiceApi 接口相同的方法,以及一个带有回调方法的接口,以便它可以将信息发送回 Presenter。</p><p id="59b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此接口是与 Presnter 的唯一通信点,确保 Presnter 只知道如何请求所需的数据,而不必担心数据的来源。</p><p id="e6db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了允许与 Presenter 通信的方法和接口之外,EventRepository 的实现包含对 EventServiceApi 类的引用,我们在构建新存储库时传递给所需的 EventServiceApi 实现(无论是从磁盘读取还是从 REST API 读取)。</p><p id="2e0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">EventRepository 接口和实现看起来像这样:</p><pre class="lj lk ll lm fd lq lr ls lt aw lu bi"><span id="dd84" class="js jt hh lr b fi lv lw l lx ly"><strong class="lr hi">public interface </strong>EventsRepository{<br/><br/>    <strong class="lr hi">interface </strong>EventsRepositoryCallback{<br/>        <strong class="lr hi">void </strong>onEventsLoaded(List&lt;Event&gt; events);<br/>    }<br/><br/>    <strong class="lr hi">void </strong>loadEvents(EventsQueryForm queryForm,EventsRepositoryCallback callback);<br/><br/>}</span><span id="8362" class="js jt hh lr b fi lz lw l lx ly"><strong class="lr hi">public class </strong>EventsRepositoryImpl <strong class="lr hi">implements </strong>EventsRepoistory {<br/><br/>    <strong class="lr hi">private </strong>EventsServiceApi <strong class="lr hi">mApi</strong>;<br/><br/>    <strong class="lr hi">public </strong>EventsRepositoryImpl(EventsServiceApi api){<br/>        <strong class="lr hi">this</strong>.<strong class="lr hi">mApi </strong>= api;<br/>    }<br/><br/><br/>    @Override<br/>    <strong class="lr hi">public void </strong>loadEvents(EventsQueryForm queryForm, <strong class="lr hi">final </strong>EventsRepositoryCallback callback) {<br/>        <strong class="lr hi">mApi</strong>.loadEvents(queryForm, <strong class="lr hi">new </strong>EventsServiceApi.EventsServiceApiCallback&lt;List&lt;Event&gt;&gt;() {<br/>            @Override<br/>            <strong class="lr hi">public void </strong>onEventsLoaded(List&lt;Event&gt; events) {<br/>                callback.onEventsLoaded(events);<br/>            }<br/>        });<br/>    }<br/>}</span></pre><p id="d4d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过正确创建和结构化模型,最终实现了正确实现MVP的目标,该MVP将具有相互关联的组件,如下图所示。</p><figure class="lj lk ll lm fd ln er es paragraph-image"><div class="er es ma"><img src="../Images/e76c7a64543e74937e1d77254512b754.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*2Cj__58EMfNG3A68mjzf5Q.png"/></div></figure><p id="84e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下一篇文章中,我们将继续讨论 <em class="jm"> build flavours </em>,以及为什么这些在创建测试环境时很重要,以及它们如何与依赖注入的概念相关联。</p><p id="8f65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你发现这篇文章很有趣 点击下面的绿色小心脏 并与可能感兴趣的朋友分享。</p><p id="9b8a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">吃下一个=)</p><p id="bb03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">DM</p></div></div>    
</body>
</html>