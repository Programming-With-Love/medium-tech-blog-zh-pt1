<html>
<head>
<title>Patchwork Plaid — A modularization story</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拼布格子——模块化的故事</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/a-patchwork-plaid-monolith-to-modularized-app-60235d9f212e?source=collection_archive---------0-----------------------#2018-10-16">https://medium.com/androiddevelopers/a-patchwork-plaid-monolith-to-modularized-app-60235d9f212e?source=collection_archive---------0-----------------------#2018-10-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/095d90039b31705d8f677cc4bb3faf73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7f6VI2TLc-P5iokR"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Illustrated by <a class="ae it" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><h2 id="ff0e" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><em class="js">我们如何和为什么模块化格子花呢以及未来的发展</em></h2><p id="b79c" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated"><em class="ko">本文深入探讨了</em> <a class="ae it" rel="noopener" href="/@crafty/restitching-plaid-9ca5588d3b0a"> <em class="ko">拼接格子</em> </a> <em class="ko">的模块化部分。</em></p><p id="818a" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">在这篇文章中，我将介绍我们如何将Plaid从一个单一的通用应用程序重构为一个模块化的应用程序包。这些是我们实现的一些优势:</p><ul class=""><li id="2899" class="ku kv hh jv b jw kp ka kq jf kw jj kx jn ky kn kz la lb lc bi translated">安装规模减少60%以上</li><li id="3ef2" class="ku kv hh jv b jw ld ka le jf lf jj lg jn lh kn kz la lb lc bi translated">极大地提高了代码的安全性</li><li id="b39c" class="ku kv hh jv b jw ld ka le jf lf jj lg jn lh kn kz la lb lc bi translated">动态交付的潜力，按需发货代码</li></ul><p id="b6f7" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">在整个过程中，我们没有对用户体验做任何改变。</p><h1 id="254c" class="li iv hh bd iw lj lk ll ja lm ln lo je lp lq lr ji ls lt lu jm lv lw lx jq ly bi translated">格子花呢一瞥</h1><figure class="ma mb mc md fd ii er es paragraph-image"><div class="er es lz"><img src="../Images/38aced29aae966a4977f89cb738e1c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/1*vVUYtBjOkcvcX13SsMdqnA.gif"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Navigating Plaid</figcaption></figure><p id="784c" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">Plaid是一个具有令人愉快的UI的应用程序。它的主屏幕显示了几个来源的一系列新闻。<br/>可以查看新闻条目的更多细节，从而进入单独的屏幕。<br/>该应用还包含“搜索”功能和“关于”屏幕。基于这些现有的特性，我们选择了几个进行模块化。</p><p id="c2fc" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">新闻来源(Designer News和Dribbble)成为他们自己的动态功能模块。<code class="du me mf mg mh b">about</code>和<code class="du me mf mg mh b">search</code>功能也被模块化为动态功能。</p><p id="a708" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated"><a class="ae it" href="https://developer.android.com/studio/projects/dynamic-delivery" rel="noopener ugc nofollow" target="_blank">动态特性</a>允许在不直接将代码包含在基本apk中的情况下发布代码。在连续的步骤中，这允许按需下载功能。</p><h1 id="e0b1" class="li iv hh bd iw lj lk ll ja lm ln lo je lp lq lr ji ls lt lu jm lv lw lx jq ly bi translated">盒子里是什么——格子花呢的构造</h1><p id="805c" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">像大多数Android应用程序一样，Plaid最初是作为一个通用apk构建的单个单片模块。安装大小不到7 MB。然而，这些数据中的大部分在运行时从未真正使用过。</p><h2 id="bd4d" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">代码结构</h2><p id="6972" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">从代码的角度来看，格子有清晰的包边界定义。但是，正如许多代码库所发生的那样，这些界限有时会被跨越，依赖性会悄悄进入。模块化迫使我们对这些界限更加严格，改善了分离。</p><h2 id="fc1a" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">本地图书馆</h2><p id="b139" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">最大一块未使用的数据来自<a class="ae it" href="https://github.com/Uncodin/bypass" rel="noopener ugc nofollow" target="_blank"> Bypass </a>，这是一个我们用来以格子显示markdown的库。它包括用于多CPU架构的本地库，所有这些都以占用大约4MB的通用apk结束。应用捆绑包支持仅交付设备架构所需的库，将所需的大小减少到1MB左右。</p><h2 id="fb81" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">可提取资源</h2><p id="118e" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">许多应用程序使用栅格化资源。这些依赖于密度，通常占应用程序文件大小的很大一部分。应用程序可以极大地受益于配置apk，其中每个显示密度都放在一个单独的apk中，允许设备定制安装，还可以大幅减少下载量和大小。</p><p id="8c18" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">格子很大程度上依赖于<a class="ae it" href="https://developer.android.com/guide/topics/graphics/vector-drawable-resources" rel="noopener ugc nofollow" target="_blank">矢量drawables </a>来显示图形资产。由于这些与密度无关，并且已经节省了大量文件大小，因此这里的数据节省对我们没有太大影响。</p><h1 id="af36" class="li iv hh bd iw lj lk ll ja lm ln lo je lp lq lr ji ls lt lu jm lv lw lx jq ly bi translated">将一切缝合在一起</h1><p id="6497" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">在模块化任务中，我们最初用<code class="du me mf mg mh b">./gradlew bundle</code>替换了<code class="du me mf mg mh b">./gradlew assemble</code>。Gradle现在将生产一个<a class="ae it" href="http://g.co/androidappbundle" rel="noopener ugc nofollow" target="_blank"> Android应用捆绑包</a> (aab)，而不是生产一个Android包(apk)。使用动态特性Gradle插件需要一个Android应用捆绑包，我们将在后面介绍。</p><h2 id="f9c8" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">Android应用捆绑包</h2><p id="23f1" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">aab生成许多更小的配置apk，而不是单个apk。然后，这些apk可以根据用户的设备进行定制，在交付期间和在磁盘上保存数据。App bundles也是动态特性模块的先决条件。</p><p id="2265" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">配置apk由Google Play在Android应用捆绑包上传后生成。随着<a class="ae it" href="http://g.co/androidappbundle" rel="noopener ugc nofollow" target="_blank">应用捆绑包</a>成为<a class="ae it" href="https://developer.android.com/guide/app-bundle#aab_format" rel="noopener ugc nofollow" target="_blank">开放规范</a>和开源<a class="ae it" href="https://github.com/google/bundletool" rel="noopener ugc nofollow" target="_blank">工具可用</a>，其他应用商店也可以实现这种交付机制。为了让谷歌Play商店生成并签署apk，该应用程序还必须通过Google Play 注册到<a class="ae it" href="https://developer.android.com/studio/publish/app-signing" rel="noopener ugc nofollow" target="_blank">应用程序签名。</a></p><h2 id="1a24" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">利益</h2><p id="d935" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">包装的这种变化为我们做了什么？</p><p id="30c5" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated"><strong class="jv hi"> Plaid现在在设备上缩小了60 %以上，相当于大约4 MB的数据。</strong></p><p id="edbe" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">这意味着每个用户都有更多的空间来使用其他应用程序。<br/>同样，由于文件大小的减少，下载时间也有所缩短。</p><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="mi mj l"/></div></figure><p id="fbf6" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">没有一行代码需要修改就可以实现这种巨大的改进。</p><h1 id="9c01" class="li iv hh bd iw lj lk ll ja lm ln lo je lp lq lr ji ls lt lu jm lv lw lx jq ly bi translated">接近模块化</h1><p id="c945" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">我们选择的模块化总体方法如下:</p><ol class=""><li id="68c1" class="ku kv hh jv b jw kp ka kq jf kw jj kx jn ky kn mk la lb lc bi translated">将所有代码和资源移到一个核心模块中。</li><li id="f1ee" class="ku kv hh jv b jw ld ka le jf lf jj lg jn lh kn mk la lb lc bi translated">识别可模块化的特性。</li><li id="8e4a" class="ku kv hh jv b jw ld ka le jf lf jj lg jn lh kn mk la lb lc bi translated">将相关代码和资源移动到功能模块中。</li></ol><figure class="ma mb mc md fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/8ee6c01af55dab53946080903048dbb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3OniQxsZEShiTnQLyuBwtQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">green: dynamic features | dark grey: application module | light grey: libraries</figcaption></figure><p id="7290" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">上图显示了Plaid模块化的当前状态:</p><ul class=""><li id="d5a5" class="ku kv hh jv b jw kp ka kq jf kw jj kx jn ky kn kz la lb lc bi translated"><code class="du me mf mg mh b">:bypass</code>和外部<code class="du me mf mg mh b">shared dependencies</code>包含在核心中</li><li id="71ea" class="ku kv hh jv b jw ld ka le jf lf jj lg jn lh kn kz la lb lc bi translated"><code class="du me mf mg mh b">:app</code>取决于<code class="du me mf mg mh b">:core</code></li><li id="9a0c" class="ku kv hh jv b jw ld ka le jf lf jj lg jn lh kn kz la lb lc bi translated">动态功能模块依赖于<code class="du me mf mg mh b">:app</code></li></ul><h2 id="7371" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">应用模块</h2><p id="63fb" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated"><code class="du me mf mg mh b">:app</code>模块基本上是已经存在的<code class="du me mf mg mh b"><a class="ae it" href="https://developer.android.com/studio/build/" rel="noopener ugc nofollow" target="_blank">com.android.application</a></code>，需要它来创建我们的应用捆绑包，并继续向我们的用户发送Plaid。大多数用于运行Plaid的代码不必在这个模块中，可以移到其他地方。</p><h2 id="b0b8" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">格子呢的<code class="du me mf mg mh b">core module</code></h2><p id="d97c" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">为了开始我们的重构，我们将所有代码和资源转移到一个<code class="du me mf mg mh b"><a class="ae it" href="https://developer.android.com/studio/projects/android-library" rel="noopener ugc nofollow" target="_blank">com.android.library</a></code>模块中。经过进一步的重构，我们的<code class="du me mf mg mh b">:core</code>模块只包含在功能模块之间共享的代码和资源。这使得依赖关系的分离更加清晰。</p><h2 id="0316" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">外部依赖性</h2><p id="8e83" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">通过<code class="du me mf mg mh b">:bypass</code>模块在核心中包含一个分叉的第三方依赖项。此外，使用gradle的<code class="du me mf mg mh b">api</code>依赖关键字，所有其他gradle依赖项从<code class="du me mf mg mh b">:app</code>移至<code class="du me mf mg mh b">:core</code>。</p><p id="efb6" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated"><em class="ko">梯度依赖声明:api vs实现</em></p><p id="9e88" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">通过利用<code class="du me mf mg mh b">api</code>而不是<code class="du me mf mg mh b">implementation</code>，依赖关系可以在整个应用中透明地共享。虽然使用<code class="du me mf mg mh b">api</code>使我们的依赖关系易于维护，因为它们是在单个文件中声明的，而不是分布在多个<code class="du me mf mg mh b">build.gradle</code>文件中，但这会降低构建速度。</p><p id="6a77" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">因此，我们没有采用最初的方法，而是回归到<code class="du me mf mg mh b">implementation</code>，这要求我们对依赖声明更加明确，但往往会使我们的增量构建更快。</p><div class="mm mn ez fb mo mp"><a href="https://github.com/nickbutcher/plaid/pull/556" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hi fi z dy mu ea eb mv ed ef hg bi translated">使用keyboard surfer Pull Request # 556 nick butcher/plaid的实现而不是api</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">Gradle指出哪里需要东西，以及在应用捆绑包的哪里放置代码。这也能使增量…</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd in mp"/></div></div></a></div><h2 id="1a8b" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">动态功能模块</h2><p id="8fa0" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">上面我提到了我们确定的可以重构到<code class="du me mf mg mh b"><a class="ae it" href="https://developer.android.com/studio/projects/dynamic-delivery" rel="noopener ugc nofollow" target="_blank">com.android.dynamic-feature</a></code>模块中的特性。这些是:</p><pre class="ma mb mc md fd ne mh nf ng aw nh bi"><span id="d46b" class="iu iv hh mh b fi ni nj l nk nl">:about<br/>:designernews<br/>:dribbble<br/>:search</span></pre><h2 id="1663" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><em class="js">介绍com . Android . dynamic-feature</em></h2><p id="0e6d" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">动态特征模块本质上是一个可从基础应用模块独立下载的梯度模块。它可以保存代码和资源，并包含依赖项，就像任何其他gradle模块一样。虽然我们还没有在格子中使用动态交付，但我们希望在未来进一步缩小初始下载大小。</p><h1 id="5fa4" class="li iv hh bd iw lj lk ll ja lm ln lo je lp lq lr ji ls lt lu jm lv lw lx jq ly bi translated">伟大的功能洗牌</h1><p id="d777" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">在将所有东西都移到<code class="du me mf mg mh b">:core</code>之后，我们将“about”屏幕标记为具有最少相互依赖性的特性，因此我们将其重构到一个新的<code class="du me mf mg mh b">:about</code>模块中。这包括活动、视图、仅由这一个特性使用的代码。此外，drawables、strings和transitions等资源也被移到了新模块中。</p><p id="2019" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">我们为每个功能模块重复这些步骤，有时需要打破依赖关系。</p><p id="e494" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">最终，<code class="du me mf mg mh b">:core</code>包含了大部分共享代码和home feed功能。由于home feed只显示在应用程序模块中，我们将相关代码和资源移回了<code class="du me mf mg mh b">:app</code>。</p><h2 id="c5b8" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">进一步了解特征结构</h2><p id="df93" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">编译后的代码可以打包。在将代码分成不同的编译单元之前，强烈建议将代码移动到功能一致的包中。幸运的是，我们不需要重组，因为格子已经很好地调整了功能。</p><figure class="ma mb mc md fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nm"><img src="../Images/7b2141507c7f2c6b6bd0934e1bfb513e.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*kE8K32z6aVssAmdboGuloA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">feature and core modules with their respective architectural layers</figcaption></figure><p id="78a4" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">正如我提到的，Plaid的许多功能都是通过新闻来源提供的。其中的每一层都由远程和本地的<strong class="jv hi">数据源、<strong class="jv hi">域</strong>和<strong class="jv hi"> UI </strong>层组成。</strong></p><p id="e8c7" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">数据源既显示在主页输入中，也显示在特征模块本身的详细屏幕中。领域层统一在一个包中。这必须分成两部分:一部分可以在整个应用程序中共享，另一部分只能在一个功能中使用。</p><p id="7dfb" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">可重复使用的部分保存在<code class="du me mf mg mh b">:core</code>库中，其他的都放在各自的功能模块中。数据层和大部分领域层至少与一个其他模块共享，并且都保存在核心中。</p><h2 id="b530" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">包装变更</h2><p id="d929" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">我们还修改了包名，以反映新的模块结构。<br/>仅与<code class="du me mf mg mh b">:dribbble</code>功能相关的代码从<code class="du me mf mg mh b">io.plaidapp</code>移至<code class="du me mf mg mh b">io.plaidapp.dribbble</code>。这同样适用于各自新模块名称中的每个特性。</p><p id="5572" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">这意味着许多进口商品不得不改变。</p><p id="bc11" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">模块化资源导致了一些问题，因为我们必须使用完全限定名来消除生成的<code class="du me mf mg mh b">R</code>类的歧义。例如，导入特征局部布局的视图会导致调用<code class="du me mf mg mh b">R.id.library_image</code>，而在同一文件中使用来自<code class="du me mf mg mh b">:core</code>的可绘制视图会导致调用</p><pre class="ma mb mc md fd ne mh nf ng aw nh bi"><span id="0afc" class="iu iv hh mh b fi ni nj l nk nl">io.plaidapp.core.R.drawable.avatar_placeholder</span></pre><p id="5629" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">我们使用Kotlin的导入别名特性缓解了这一问题，该特性允许我们像这样导入core的<code class="du me mf mg mh b">R</code>文件:</p><pre class="ma mb mc md fd ne mh nf ng aw nh bi"><span id="0616" class="iu iv hh mh b fi ni nj l nk nl">import io.plaidapp.core.R as coreR</span></pre><p id="b0ee" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">这样就可以把通话地点缩短到</p><pre class="ma mb mc md fd ne mh nf ng aw nh bi"><span id="dde4" class="iu iv hh mh b fi ni nj l nk nl">coreR.drawable.avatar_placeholder</span></pre><p id="6211" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">这使得阅读代码比每次阅读完整的包名要简洁和灵活得多。</p><h2 id="3ad9" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">准备资源移动</h2><p id="bb6e" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">与代码不同，资源没有包结构。这使得按特征排列它们变得更加困难。但是通过遵循代码中的一些约定，这也不是不可能的。</p><p id="42d9" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">在Plaid中，文件被加上前缀以反映它们被使用的位置。例如，仅在<code class="du me mf mg mh b">:dribbble</code>中使用的资源以<code class="du me mf mg mh b">dribbble_</code>为前缀。</p><p id="319a" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">此外，包含多个模块的资源的文件(如styles.xml)在结构上按模块分组，并且每个属性都有前缀。</p><p id="c2f7" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">举个例子:在一个单一的应用程序中，<code class="du me mf mg mh b">strings.xml</code>保存了大部分使用过的字符串。在模块化的应用程序中，每个功能模块都有自己的字符串。<br/>在模块化之前，当字符串按特性分组时，更容易分解文件。</p><p id="3bb7" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">遵循这样的惯例可以更快更容易地将资源转移到正确的地方。它还有助于避免编译错误和运行时崩溃。</p><h1 id="364d" class="li iv hh bd iw lj lk ll ja lm ln lo je lp lq lr ji ls lt lu jm lv lw lx jq ly bi translated">一路上的挑战</h1><p id="ee03" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">为了使像这样的大型重构任务更易于管理，团队内部的良好沟通是非常重要的。交流计划中的变更，并一步一步地进行这些变更，有助于我们将合并冲突和阻塞变更保持在最小程度。</p><h2 id="04bb" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">善意</h2><p id="4db3" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">本文前面的依赖图显示了动态特性模块知道app模块。另一方面，app模块不能容易地从动态特性模块访问代码。但是它们包含必须在某个时候执行的代码。</p><p id="b6b7" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">如果应用程序对功能模块没有足够的了解来访问它们的代码，就无法通过它们的类名以<code class="du me mf mg mh b">Intent(ACTION_VIEW, ActivityName::class.java)</code>的方式启动活动。<br/>不过，开展活动还有多种其他方式。我们决定显式指定组件名。</p><p id="2012" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">为此，我们在core中创建了一个<code class="du me mf mg mh b">AddressableActivity</code>接口。</p><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="nn mj l"/></div></figure><p id="f55d" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">使用这种方法，我们创建了一个统一活动启动意图创建的功能:</p><figure class="ma mb mc md fd ii"><div class="bz dy l di"><div class="nn mj l"/></div></figure><p id="efad" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">在其最简单的实现中，<code class="du me mf mg mh b">AddressableActivity</code>只需要一个字符串形式的显式类名。纵观格子，每一个<code class="du me mf mg mh b">Activity</code>都是通过这个机制发射的。有些包含额外的意图，也必须从应用程序的各个组件传递给活动。</p><p id="f540" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">您可以在这里的整个文件中看到我们是如何做到这一点的:</p><div class="mm mn ez fb mo mp"><a href="https://github.com/nickbutcher/plaid/blob/master/core/src/main/java/io/plaidapp/core/util/ActivityHelper.kt" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hi fi z dy mu ea eb mv ed ef hg bi translated">AddressableActivity.kt</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">帮助者在模块化的世界里开始活动。</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">github.com</p></div></div><div class="my l"><div class="no l na nb nc my nd in mp"/></div></div></a></div><h2 id="2005" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">造型问题</h2><p id="f59e" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">现在，每个动态功能模块都有单独的<code class="du me mf mg mh b">AndroidManifests</code>，而不是整个应用只有一个<code class="du me mf mg mh b">AndroidManifest</code>。<br/>这些清单主要包含与它们的组件实例化相关的信息和一些关于它们的交付类型的信息，由<code class="du me mf mg mh b">dist:</code>标签反映。<br/>这意味着活动和服务必须在功能模块中声明，该模块还包含该组件的相关代码。</p><p id="7f36" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">我们遇到了模块化我们的风格的问题；我们将仅由一个特性使用的样式提取到它们的相关模块中，但是它们通常使用隐式继承建立在<code class="du me mf mg mh b">:core</code>样式之上。</p><figure class="ma mb mc md fd ii er es paragraph-image"><div class="er es np"><img src="../Images/530c0da43d214de11df522e3127a0d92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*YJRNNNgg5JbRoe20l14Ffw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Parts of Plaid’s style hierarchy</figcaption></figure><p id="be66" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">这些样式用于通过模块的<code class="du me mf mg mh b">AndroidManifest</code>为相应的活动提供主题。</p><p id="655b" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">一旦我们完成了对它们的移动，我们就遇到了这样的编译时问题:</p><pre class="ma mb mc md fd ne mh nf ng aw nh bi"><span id="7786" class="iu iv hh mh b fi ni nj l nk nl">* What went wrong:</span><span id="15f7" class="iu iv hh mh b fi nq nj l nk nl">Execution failed for task ‘:app:processDebugResources’.<br/>&gt; Android resource linking failed<br/>~/plaid/app/build/intermediates/merged_manifests/debug/AndroidManifest.xml:177: AAPT:<br/>error: resource style/Plaid.Translucent.About (aka io.plaidapp:style/Plaid.Translucent.About) not found.<br/>error: failed processing manifest.</span></pre><p id="7fcd" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">清单合并尝试将所有功能模块中的清单合并到应用程序的模块中。由于此时功能模块的<code class="du me mf mg mh b">styles.xml</code>文件对应用模块不可用，所以失败。</p><p id="9998" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">我们通过在<code class="du me mf mg mh b">:core</code>的<code class="du me mf mg mh b">styles.xml</code>中为每个样式创建一个空声明来解决这个问题，如下所示:</p><pre class="ma mb mc md fd ne mh nf ng aw nh bi"><span id="c15d" class="iu iv hh mh b fi ni nj l nk nl">&lt;! — Placeholders. Implementations in feature modules. →</span><span id="e674" class="iu iv hh mh b fi nq nj l nk nl">&lt;style name=”Plaid.Translucent.About” /&gt;<br/>&lt;style name=”Plaid.Translucent.DesignerNewsStory” /&gt;<br/>&lt;style name=”Plaid.Translucent.DesignerNewsLogin” /&gt;<br/>&lt;style name=”Plaid.Translucent.PostDesignerNewsStory” /&gt;<br/>&lt;style name=”Plaid.Translucent.Dribbble” /&gt;<br/>&lt;style name=”Plaid.Translucent.Dribbble.Shot” /&gt;<br/>&lt;style name=”Plaid.Translucent.Search” /&gt;</span></pre><p id="a30c" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">现在，清单合并在合并期间选择样式，即使样式的实际实现是通过功能模块的样式引入的。</p><p id="56cc" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">避免这种情况的另一种方法是在核心模块中保留样式声明。但是这只有在所有引用的资源都在核心模块中时才有效。这就是我们决定采用上述方法的原因。</p><h2 id="096b" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">动态特性的仪器测试</h2><p id="f648" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">随着模块化的发展，我们发现插装测试目前不能驻留在动态特性模块中，而是必须包含在应用程序模块中。我们将在下一篇关于我们测试工作的博客文章中对此进行详述。</p><h1 id="ee0a" class="li iv hh bd iw lj lk ll ja lm ln lo je lp lq lr ji ls lt lu jm lv lw lx jq ly bi translated">接下来会发生什么？</h1><h2 id="8371" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">动态代码加载</h2><p id="ff9d" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">我们通过应用捆绑包使用动态交付，但在初始安装后，还没有通过<a class="ae it" href="https://developer.android.com/guide/app-bundle/playcore" rel="noopener ugc nofollow" target="_blank"> Play核心库</a>下载这些应用。例如，这将允许我们将默认未启用的新闻源(产品搜索)标记为仅在用户启用该源时安装。</p><h2 id="4f8f" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">添加更多新闻来源</h2><p id="5c31" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">在整个模块化过程中，我们牢记添加更多新闻来源的可能性。清晰地分离模块的工作以及按需交付模块的可能性使得这一点更加引人注目。</p><h2 id="46a8" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">完成模块化</h2><p id="0857" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">我们在模块化格子上做了很多进步。但仍有工作要做。产品搜索是一个新闻源，我们目前还没有将其放入动态功能模块中。此外，已经提取的特征模块的一些功能可以从核心中去除，并直接集成到相应的特征中。</p><h1 id="27e5" class="li iv hh bd iw lj lk ll ja lm ln lo je lp lq lr ji ls lt lu jm lv lw lx jq ly bi translated">那么，我们为什么决定模块化格子呢？</h1><p id="40b1" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">经历了这个过程，格子现在是一个高度模块化的app。所有这些都不需要改变用户体验。在我们的日常开发中，我们确实从这项工作中获得了一些好处:</p><h2 id="7aaf" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">安装尺寸</h2><p id="bbd9" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">现在，用户设备上的格子图案平均缩小了60 %以上。<br/>这样可以加快安装速度，节省宝贵的网络空间。</p><h2 id="e0ff" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">编译时间</h2><p id="8854" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">一个没有缓存的干净的调试版本现在需要32秒而不是48秒。* <br/>一直从大约50个任务增加到250多个任务。</p><p id="73fd" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">这种时间节省主要是由于模块化增加了并行构建和编译避免。</p><p id="4fea" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">此外，单个模块中的变化不需要重新编译每个模块，并使连续编译更快。</p><p id="fa15" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">*作为参考，这些是我为之前的<a class="ae it" href="https://github.com/nickbutcher/plaid/commit/9ae92ab39f631a75023b38c77a5cdcaa4b2489c5" rel="noopener ugc nofollow" target="_blank">和</a>计时之后的<a class="ae it" href="https://github.com/nickbutcher/plaid/tree/f7ab6499c0ae35ae063d7fbb155027443d458b3a" rel="noopener ugc nofollow" target="_blank">构建的提交。</a></p><h2 id="d99a" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">可维护性</h2><p id="6d0e" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">在整个过程中，我们已经理清了各种依赖关系，这使得代码更加清晰。此外，副作用也越来越少。我们的每个功能模块都可以单独工作，相互之间很少交互。这里的主要好处是，我们需要解决的合并冲突要少得多。</p><h1 id="2d2a" class="li iv hh bd iw lj lk ll ja lm ln lo je lp lq lr ji ls lt lu jm lv lw lx jq ly bi translated">最后</h1><p id="f6d0" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">我们将应用程序<strong class="jv hi">缩小了60%以上</strong>，改进了代码结构，并将Plaid模块化为动态功能模块，这增加了按需交付的潜力。</p><p id="56a1" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated">在整个过程中，我们始终将应用程序保持在可以交付给用户的状态。您可以切换您的应用程序，立即发布Android应用程序捆绑包，并节省安装空间。模块化可能需要一些时间，但是值得一试(见上面的好处)，特别是考虑到动态交付。</p><p id="e48a" class="pw-post-body-paragraph jt ju hh jv b jw kp jy jz ka kq kc kd jf kr kf kg jj ks ki kj jn kt kl km kn ha bi translated"><strong class="jv hi">去看看</strong> <a class="ae it" href="https://github.com/nickbutcher/plaid" rel="noopener ugc nofollow" target="_blank"> <strong class="jv hi">格子的源代码</strong> </a> <strong class="jv hi">看看我们的变化和快乐模块化的全部程度！</strong></p></div></div>    
</body>
</html>