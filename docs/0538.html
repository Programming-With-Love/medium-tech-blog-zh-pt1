<html>
<head>
<title>Fragments: rebuilding the internals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">片段:重建内部</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/fragments-rebuilding-the-internals-61913f8bf48e?source=collection_archive---------0-----------------------#2020-08-19">https://medium.com/androiddevelopers/fragments-rebuilding-the-internals-61913f8bf48e?source=collection_archive---------0-----------------------#2020-08-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/7be04e78819ff41763397e1e0ad5dc24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ir8CdY5D5Do5R_22Vo3uew.png"/></div></div></figure><div class=""/><div class=""><h2 id="8e1f" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">介绍:新的状态管理器</h2></div><p id="b1bd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">多年来，片段比大多数Android APIs进化得更加有机。它们开始是Android平台本身的一部分，成为Android平台中的镜像存在和Android支持库的一部分，现在作为Jetpack的一部分作为<a class="ae kd" href="https://developer.android.com/jetpack/androidx/releases/fragment" rel="noopener ugc nofollow" target="_blank"> AndroidX片段</a>单独存在。</p><blockquote class="ke kf kg"><p id="c7d2" class="jh ji kh jj b jk jl it jm jn jo iw jp ki jr js jt kj jv jw jx kk jz ka kb kc ha bi translated"><strong class="jj ht">注意</strong>:你在任何情况下都不应该使用Android框架版本的碎片。除了在Android 10中被完全否决之外，在此之前的相当长一段时间内，它们都没有收到修复程序，并且被纳入框架中，预计不会有修复程序的反向移植或跨设备和API级别的一致性。</p></blockquote><p id="b9b7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">虽然<a class="ae kd" href="https://developer.android.com/topic/libraries/architecture" rel="noopener ugc nofollow" target="_blank">架构组件</a>已经接管了许多传统上需要片段的角色(比如使用<code class="du kl km kn ko b">LifecycleObserver</code>进行生命周期回调，或者使用<code class="du kl km kn ko b">ViewModel</code>进行保留状态)，但是如果你使用片段，你就要通过<code class="du kl km kn ko b">FragmentManager</code>来添加、删除片段，并与之交互。</p><p id="1fde" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">随着<a class="ae kd" href="https://developer.android.com/jetpack/androidx/releases/fragment#1.3.0-alpha08" rel="noopener ugc nofollow" target="_blank">碎片</a> <code class="du kl km kn ko b"><a class="ae kd" href="https://developer.android.com/jetpack/androidx/releases/fragment#1.3.0-alpha08" rel="noopener ugc nofollow" target="_blank">1.3.0-alpha08</a></code>，<code class="du kl km kn ko b">FragmentManager</code>内部一些最重大的重组已经完成。这个版本用更小的、可测试的、可维护的(内部)类取代了过去直接存在于<code class="du kl km kn ko b">FragmentManager</code>中的许多逻辑，其核心是<code class="du kl km kn ko b"><a class="ae kd" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:fragment/fragment/src/main/java/androidx/fragment/app/FragmentStateManager.java?ss=androidx" rel="noopener ugc nofollow" target="_blank">FragmentStateManager</a></code>。</p><blockquote class="ke kf kg"><p id="d8f7" class="jh ji kh jj b jk jl it jm jn jo iw jp ki jr js jt kj jv jw jx kk jz ka kb kc ha bi translated"><strong class="jj ht">注意:</strong>我将在这篇文章中谈论很多关于<code class="du kl km kn ko b">FragmentManager</code>的内部情况。TL/DR:如果您发现任何回归，请尽快额外关注带有片段<code class="du kl km kn ko b">1.3.0-alpha08</code>和<a class="ae kd" href="https://issuetracker.google.com/issues/new?component=460964" rel="noopener ugc nofollow" target="_blank">文件问题</a>的回归测试。</p></blockquote><p id="576c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这个新的状态管理器负责片段的一些非常关键的部分:</p><ul class=""><li id="eec8" class="kp kq hs jj b jk jl jn jo jq kr ju ks jy kt kc ku kv kw kx bi translated">通过它们的生命周期方法移动片段</li><li id="a64d" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ku kv kw kx bi translated">运行动画和过渡</li><li id="cacf" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ku kv kw kx bi translated">处理延期交易</li></ul><p id="6a41" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们彻底研究了这些系统以前是如何工作的，发现<a class="ae kd" href="https://issuetracker.google.com/issues/147749580" rel="noopener ugc nofollow" target="_blank">它们缺少</a>，并从头开始重写它们。他们现在比以往任何时候都更好，我们能够解决10多个长期存在的相关问题，内部重组为在单个 <code class="du kl km kn ko b"><a class="ae kd" href="https://issuetracker.google.com/issues/80029773" rel="noopener ugc nofollow" target="_blank">FragmentManager</a></code>和<a class="ae kd" href="https://youtu.be/RS1IACnZLy4?t=956" rel="noopener ugc nofollow" target="_blank">中构建对多个后台堆栈的支持扫清了道路</a><a class="ae kd" href="https://issuetracker.google.com/issues/80029773" rel="noopener ugc nofollow" target="_blank">简化了片段生命周期</a>。</p><h1 id="370d" class="ld le hs bd lf lg lh li lj lk ll lm ln iy lo iz lp jb lq jc lr je ls jf lt lu bi translated">FragmentManager的moveToState()</h1><p id="c173" class="pw-post-body-paragraph jh ji hs jj b jk lv it jm jn lw iw jp jq lx js jt ju ly jw jx jy lz ka kb kc ha bi translated">每个<code class="du kl km kn ko b">FragmentManager</code>都与一个主机相关联。在绝大多数情况下，对于片段来说，这是一个<code class="du kl km kn ko b">FragmentActivity</code>(有一整层的<code class="du kl km kn ko b">FragmentController</code>和<code class="du kl km kn ko b">FragmentHostCallback</code>用于构建你自己的定制主机，但是让我们在这里避免讨论)。随着活动移动到<code class="du kl km kn ko b">CREATED</code>、<code class="du kl km kn ko b">STARTED</code>和<code class="du kl km kn ko b">RESUMED</code> , <code class="du kl km kn ko b">FragmentManager</code>将那些变更向下分派到它的片段。这就是<code class="du kl km kn ko b">moveToState()</code>的作用。</p><p id="12c0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当然，这并不那么简单。有许多条件逻辑来确定片段应该处于什么状态——活动生命周期状态(或者嵌套片段的父片段的状态)只是第一部分，是片段可以处于的最大状态。这个最大值是为了确保活动、片段以及它们的子片段的生命周期都被恰当地嵌套。</p><p id="e9b5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因此，我们在<a class="ae kd" href="https://issuetracker.google.com/139536619" rel="noopener ugc nofollow" target="_blank">简化</a> <code class="du kl km kn ko b"><a class="ae kd" href="https://issuetracker.google.com/139536619" rel="noopener ugc nofollow" target="_blank">moveToState()</a></code>的第一步是将所有的逻辑整合到一个地方。就这样诞生了<code class="du kl km kn ko b"><a class="ae kd" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:fragment/fragment/src/main/java/androidx/fragment/app/FragmentStateManager.java?ss=androidx" rel="noopener ugc nofollow" target="_blank">FragmentStateManager</a></code>。每个片段实例都与一个<code class="du kl km kn ko b">FragmentStateManager</code>联系在一起。通过在内部引入这个类，我们能够将许多与片段交互的代码(比如调用片段的<code class="du kl km kn ko b">onCreateView</code>和其他生命周期方法)从<code class="du kl km kn ko b">FragmentManager</code>本身中取出。</p><p id="02cb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这种分离还允许我们编写一个方法，这个方法将获取所有向后兼容的所需逻辑，以确定片段实际上应该处于什么状态，并将它集中在一个地方:<code class="du kl km kn ko b"><a class="ae kd" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:fragment/fragment/src/main/java/androidx/fragment/app/FragmentStateManager.java;l=165?ss=androidx" rel="noopener ugc nofollow" target="_blank">computeExpectedState()</a></code>。这种方法跟踪所有的当前状态，并确定片段应该处于什么状态。98%的时候，它与主机/父片段处于相同的状态，但这2%对于那些构建在片段上的应用程序来说有很大的不同。</p><p id="009d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然而，我们遇到了一种情况，我们没有办法确定正确的状态:推迟的片段。</p><h1 id="ab3e" class="ld le hs bd lf lg lh li lj lk ll lm ln iy lo iz lp jb lq jc lr je ls jf lt lu bi translated">延期片段</h1><p id="44ca" class="pw-post-body-paragraph jh ji hs jj b jk lv it jm jn lw iw jp jq lx js jt ju ly jw jx jy lz ka kb kc ha bi translated">无论好坏，片段继承了许多与活动相同的术语和API表面。这种继承的一部分是关于过渡和推迟进入过渡直到你准备好的能力。这对于共享元素的过渡是至关重要的(在开始过渡到那个位置之前，您真的希望加载一个图像，以了解它在屏幕上的尺寸和位置)，但也允许您确保更密集的加载调用不会与您的过渡同时发生，从而避免jank。</p><p id="52f0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">被推迟的片段有两个重要的特性:</p><ol class=""><li id="d4b5" class="kp kq hs jj b jk jl jn jo jq kr ju ks jy kt kc ma kv kw kx bi translated">它的视图已创建，但不可见</li><li id="210c" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ma kv kw kx bi translated">它的生命周期在<code class="du kl km kn ko b">STARTED</code>结束</li></ol><p id="8653" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">一旦您调用<code class="du kl km kn ko b">startPostponedEnterTransition()</code>，片段的转换将运行，视图将变得可见，并且片段将能够移动到<code class="du kl km kn ko b">RESUMED</code>。事实上，这正是新的状态管理器所做的，但是以前片段不是这样工作的。引用<a class="ae kd" href="https://issuetracker.google.com/147749580" rel="noopener ugc nofollow" target="_blank">推迟的片段使片段和片段管理器处于不一致的状态bug </a>:</p><blockquote class="mb"><p id="7cb5" class="mc md hs bd me mf mg mh mi mj mk kc dx translated">当使用<code class="du kl km kn ko b">postponeEnterTransition()</code>延迟一个片段时，预期的行为是该片段被添加到的容器不运行任何进入动画或先前排队的退出动画(例如，对于一个<code class="du kl km kn ko b">replace()</code>操作)，直到该片段调用<code class="du kl km kn ko b">startPostponedEnterTransition()</code>。还期望该片段在其容器被推迟时不会达到<code class="du kl km kn ko b">RESUMED</code>状态。</p><p id="4108" class="mc md hs bd me mf mg mh mi mj mk kc dx translated">然而，看起来FragmentManager不仅仅是在做这件事，而是将这个片段和整个FragmentManager移动到一个奇怪的、不一致的状态。</p><p id="8310" class="mc md hs bd me mf mg mh mi mj mk kc dx translated">也就是说，任何触及被推迟片段的容器的FragmentTransaction都被“回滚”(即，反向完成)，但是这些片段实际上并没有移动到它们正确的状态。</p></blockquote><p id="edfb" class="pw-post-body-paragraph jh ji hs jj b jk mm it jm jn mn iw jp jq mo js jt ju mp jw jx jy mq ka kb kc ha bi translated">这导致了一连串的问题:</p><ul class=""><li id="0368" class="kp kq hs jj b jk jl jn jo jq kr ju ks jy kt kc ku kv kw kx bi translated">片段的视图被创建，但是片段没有被添加(<code class="du kl km kn ko b">isAdded()</code>返回false)</li><li id="6d47" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ku kv kw kx bi translated"><code class="du kl km kn ko b">findFragmentById()</code>不会返回新添加的片段，即使使用了<code class="du kl km kn ko b">commitNow()</code></li><li id="382c" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ku kv kw kx bi translated">当FragmentManager启动时，停留在这种中间状态的片段不会启动(<a class="ae kd" href="https://issuetracker.google.com/issues/129035555" rel="noopener ugc nofollow" target="_blank">https://issuetracker.google.com/issues/129035555</a>)</li><li id="735b" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ku kv kw kx bi translated">碎片事务可以无序执行(<a class="ae kd" href="https://issuetracker.google.com/issues/147297731" rel="noopener ugc nofollow" target="_blank">https://issuetracker.google.com/issues/147297731</a>)</li><li id="f497" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ku kv kw kx bi translated">容器上的其他动画(例如先前启动的pop动画)仍然运行(<a class="ae kd" href="https://issuetracker.google.com/issues/37140383" rel="noopener ugc nofollow" target="_blank">https://issuetracker.google.com/issues/37140383</a>)</li><li id="36a4" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ku kv kw kx bi translated"><code class="du kl km kn ko b">onCreateView()</code>可称为第二次(<a class="ae kd" href="https://issuetracker.google.com/issues/143915710" rel="noopener ugc nofollow" target="_blank">https://issuetracker.google.com/issues/143915710</a>)</li></ul><p id="7c0f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">实际上，修复这些问题意味着用一个保持<code class="du kl km kn ko b">FragmentManager</code>一致、最新状态的系统来替换被推迟片段使用的整个回滚过程，同时仍然保持被推迟片段的重要质量。</p><h1 id="5fdc" class="ld le hs bd lf lg lh li lj lk ll lm ln iy lo iz lp jb lq jc lr je ls jf lt lu bi translated">在容器级别工作</h1><p id="4cfd" class="pw-post-body-paragraph jh ji hs jj b jk lv it jm jn lw iw jp jq lx js jt ju ly jw jx jy lz ka kb kc ha bi translated"><code class="du kl km kn ko b">FragmentManager</code>有一个很好的属性(读起来很方便，但是作为维护者来说并不有趣),它允许你在你想要放置片段的地方传入任何容器ID。甚至对于一个单独的<code class="du kl km kn ko b">FragmentTransaction</code>，你可以<code class="du kl km kn ko b">add</code>一个片段到一个容器，<code class="du kl km kn ko b">remove</code>另一个来自不同的容器，<code class="du kl km kn ko b">replace</code>第三个容器的最上面的片段，等等。当涉及到动画片段的输入/输出时，问题就来了——这种事情只发生在容器级别。</p><p id="bf48" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">片段支持许多动画系统:</p><ul class=""><li id="cf29" class="kp kq hs jj b jk jl jn jo jq kr ju ks jy kt kc ku kv kw kx bi translated">旧的<a class="ae kd" href="https://issuetracker.google.com/163084315#comment4" rel="noopener ugc nofollow" target="_blank">终结了</a>框架<code class="du kl km kn ko b">Animation</code> API</li><li id="169c" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ku kv kw kx bi translated">框架<code class="du kl km kn ko b">Animator</code> API</li><li id="39e3" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ku kv kw kx bi translated">框架<code class="du kl km kn ko b">Transition</code> API(只有API 21+，也很烂)</li><li id="a78a" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ku kv kw kx bi translated"><a class="ae kd" href="https://developer.android.com/jetpack/androidx/releases/transition" rel="noopener ugc nofollow" target="_blank">AndroidX</a>T9】API</li></ul><p id="bec4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">正如你可能知道的，命名是计算机科学中最困难的问题之一，所以当我们去构建一个可以控制所有这些API的类时，花了一段时间才决定使用<code class="du kl km kn ko b"><a class="ae kd" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:fragment/fragment/src/main/java/androidx/fragment/app/SpecialEffectsController.java" rel="noopener ugc nofollow" target="_blank">SpecialEffectsControlle</a>r</code>(谢天谢地，这个类不是公共API的一部分，所以名称仍然会改变)。这个类存在于容器级别，协调所有与进入和退出片段相关的“特殊效果”。</p><p id="0bef" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du kl km kn ko b">SpecialEffectsController</code>是关于该容器应该发生什么的唯一来源。这意味着如果最上面的添加片段被推迟，整个容器也被推迟。在<code class="du kl km kn ko b">FragmentManager</code>层不需要更多的逻辑，也不需要任何事务回滚(正如我们提到的，这会影响多个容器)。因此，<code class="du kl km kn ko b">FragmentManager</code>处于正确的状态，我们仍然得到被推迟片段的所有特殊属性。</p><p id="dab4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然后，这个基础API允许我们将fragment拥有的所有疯狂的特效API集中到一个负责运行过渡、动画和动画师的<code class="du kl km kn ko b"><a class="ae kd" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:fragment/fragment/src/main/java/androidx/fragment/app/DefaultSpecialEffectsController.java" rel="noopener ugc nofollow" target="_blank">DefaultSpecialEffectsController</a></code>中。再一次，将过去分散在<code class="du kl km kn ko b">FragmentManager</code>的逻辑转移到一个地方。</p><h1 id="76dd" class="ld le hs bd lf lg lh li lj lk ll lm ln iy lo iz lp jb lq jc lr je ls jf lt lu bi translated">那么，“新国家经理”意味着什么</h1><p id="cff8" class="pw-post-body-paragraph jh ji hs jj b jk lv it jm jn lw iw jp jq lx js jt ju ly jw jx jy lz ka kb kc ha bi translated">嗯，这意味着代替这种架构:</p><figure class="ms mt mu mv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mr"><img src="../Images/d4910af9070face89e259762a2675e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRKkZEAluuo4L3gewjvZwA.png"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx">The old state manager: everything is in FragmentManager</figcaption></figure><p id="74a5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">它看起来更像这样:</p><figure class="ms mt mu mv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mr"><img src="../Images/dd8fc763fc2b2cb639b6345cbd308407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxLsF2sNZNH0dqnqdfT_dQ.png"/></div></div><figcaption class="mw mx et er es my mz bd b be z dx">The new state manager: FragmentManager talks to individual FragmentStateManager instances, which coordinate with other fragments in their container via SpecialEffectsController</figcaption></figure><p id="8354" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">通过拆分<code class="du kl km kn ko b">FragmentManager</code>的内部，每一层的逻辑都得到了极大的简化:</p><ul class=""><li id="1f08" class="kp kq hs jj b jk jl jn jo jq kr ju ks jy kt kc ku kv kw kx bi translated"><code class="du kl km kn ko b">FragmentManager</code>只有适用于所有片段的状态</li><li id="5517" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ku kv kw kx bi translated"><code class="du kl km kn ko b">FragmentStateManager</code>在片段级别管理状态</li><li id="8bf6" class="kp kq hs jj b jk ky jn kz jq la ju lb jy lc kc ku kv kw kx bi translated"><code class="du kl km kn ko b">SpecialEffectsController</code>管理容器级别的状态</li></ul><p id="e8ff" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这种职责分离让我们将测试套件扩展了近30%,覆盖了更多几乎不可能单独测试的场景。</p><h1 id="cea5" class="ld le hs bd lf lg lh li lj lk ll lm ln iy lo iz lp jb lq jc lr je ls jf lt lu bi translated">我应该期待行为改变吗？</h1><p id="2da8" class="pw-post-body-paragraph jh ji hs jj b jk lv it jm jn lw iw jp jq lx js jt ju ly jw jx jy lz ka kb kc ha bi translated"><strong class="jj ht">否</strong>。事实上，我们针对新旧状态管理器运行了大量的内部片段测试，以确保我们有一套强大的回归测试。</p><p id="d293" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然而，如果你依赖于不一致的状态，一个被推迟的片段将<code class="du kl km kn ko b">FragmentManager</code>放入其中，那么是的，你会发现你现在实际上获得了正确的状态。作为<a class="ae kd" href="https://developer.android.com/jetpack/androidx/releases/fragment#1.3.0-alpha08" rel="noopener ugc nofollow" target="_blank">发行说明</a>的一部分，您将找到与新状态管理器相关的错误修复列表，因此请仔细查看，以确保您的问题不是由您自己对旧的错误行为的解决方法引起的，您现在可以删除这些错误行为。</p><p id="6ef8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">类似于对<a class="ae kd" href="https://developer.android.com/jetpack/androidx/releases/fragment#1.2.0" rel="noopener ugc nofollow" target="_blank">片段</a> <code class="du kl km kn ko b"><a class="ae kd" href="https://developer.android.com/jetpack/androidx/releases/fragment#1.2.0" rel="noopener ugc nofollow" target="_blank">1.2.0</a></code>中<code class="du kl km kn ko b">onDestroyView</code>计时的更改，新的状态管理器将使您的片段保持在<code class="du kl km kn ko b">STARTED</code>状态，直到其过渡/动画/动画制作者/特效全部完成，从而使所有片段保持一致，无论它们是直接推迟还是因为同一容器中的其他片段而推迟。</p><h1 id="a4cf" class="ld le hs bd lf lg lh li lj lk ll lm ln iy lo iz lp jb lq jc lr je ls jf lt lu bi translated">如果我*确实*看到了行为变化怎么办？</h1><p id="b974" class="pw-post-body-paragraph jh ji hs jj b jk lv it jm jn lw iw jp jq lx js jt ju ly jw jx jy lz ka kb kc ha bi translated">升级到<a class="ae kd" href="https://developer.android.com/jetpack/androidx/releases/fragment#1.3.0-alpha08" rel="noopener ugc nofollow" target="_blank">片段</a> <code class="du kl km kn ko b"><a class="ae kd" href="https://developer.android.com/jetpack/androidx/releases/fragment#1.3.0-alpha08" rel="noopener ugc nofollow" target="_blank">1.3.0-alpha08</a></code>后，默认启用新的状态管理器。如果您发现应用程序中存在差异，第一步是通过使用新的实验性API来查看它是否与新的状态管理器相关:</p><pre class="ms mt mu mv fd na ko nb nc aw nd bi"><span id="7329" class="ne le hs ko b fi nf ng l nh ni">FragmentManager.enableNewStateManager(false)</span></pre><p id="4a83" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这个API是回到旧世界的一个出口，让您验证您看到的任何更改都与新的状态管理器相关联。这解除了您升级片段<code class="du kl km kn ko b">1.3.0-alpha08</code>的障碍，并让您构建一个示例项目，该项目再现了当您<a class="ae kd" href="https://issuetracker.google.com/issues/new?component=460964" rel="noopener ugc nofollow" target="_blank">针对片段</a>提交问题时可以附加的问题。</p><blockquote class="ke kf kg"><p id="50ac" class="jh ji kh jj b jk jl it jm jn jo iw jp ki jr js jt kj jv jw jx kk jz ka kb kc ha bi translated">注意:<code class="du kl km kn ko b">FragmentManager.enableNewStateManager()</code> API是<strong class="jj ht">实验性的</strong>。这意味着它不被认为是片段的稳定API表面的一部分，可以在<strong class="jj ht">任何</strong>点移除。删除所有的旧代码是一个重要的代码减少，但是考虑到做好这一点的重要性，我们可能不会删除API，直到Fragment 1.3.0稳定发布之后——也就是说，考虑在Fragment 1.3.1发布中删除它。</p></blockquote><p id="e9bb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在11个月的时间里，有超过100个单独的变更，这绝对是一段时间以来最大的内部变更，并且为我们建立了一个更加可维护、可持续和可理解的代码库。这意味着跨片段的更一致的行为，以及在构建应用程序时可以依赖的坚实基础。如果你能继续<a class="ae kd" href="https://issuetracker.google.com/issues/new?component=460964" rel="noopener ugc nofollow" target="_blank">提交问题</a>并提供反馈，以确保这个新的状态管理器是最好的，我们将不胜感激。</p></div></div>    
</body>
</html>