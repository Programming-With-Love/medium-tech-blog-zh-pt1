<html>
<head>
<title>Performance Monitoring with Riemann and Clojure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Riemann和Clojure进行性能监控</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/performance-monitoring-with-riemann-and-clojure-eafc07fcd375?source=collection_archive---------2-----------------------#2017-09-01">https://medium.com/walmartglobaltech/performance-monitoring-with-riemann-and-clojure-eafc07fcd375?source=collection_archive---------2-----------------------#2017-09-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/25f21712959076fbaea4ee8de4c4bcbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ow3NIdma6epJ_NvgLupUtA.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Photo credit: <a class="ae hu" href="https://pixabay.com/en/shell-sea-underwater-world-beach-1680755/" rel="noopener ugc nofollow" target="_blank">katkaZV</a></figcaption></figure><div class=""/><p id="d3bf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<a class="ae hu" href="http://twitter.com/WalmartLabs" rel="noopener ugc nofollow" target="_blank"> @WalmartLabs </a>的eReceipts和杂货数据服务团队负责在基于Clojure的技术栈上构建、维护和操作关键的后端数据服务。沃尔玛的商店和在线顾客依赖我们的服务来提供平稳、可靠和快速的购物体验，我们已经将正常运行时间和性能作为我们构建的每个系统的基本考虑因素。我们的工程师团队非常依赖<a class="ae hu" href="http://riemann.io" rel="noopener ugc nofollow" target="_blank">黎曼</a>来监控我们系统的内部状态，并帮助我们发现、诊断和潜在升级或干预性能下降的情况，以免它们演变为影响客户的停机。</p><h1 id="d317" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">什么是黎曼？</h1><p id="bd75" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">Riemann是一个低延迟的事件流处理系统，因此它的核心领域是离散事件和事件流。这种方法不同于一些传统的监控系统，因为服务器和静态基础设施是紧急关注点，而不是基本关注点，这使得它非常适合动态、高度分布式的环境。</p><h1 id="8832" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">它是如何工作的？</h1><p id="7db1" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">Riemann通过UDP或TCP以协议缓冲区的形式接收事件。在我们的例子中，这些事件是来自应用程序的结构化日志条目，或者是由其他活动监控系统生成的特定事件。一旦接收到这些事件，Riemann将它们传递到事件“流”中，事件“流”是配置的一部分，负责过滤、聚集和处理它们。</p><p id="a53e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">黎曼配置实际上只是一个Clojure程序，其中大部分由事件流组成。事件流是使用Riemann <code class="du kv kw kx ky b"><a class="ae hu" href="http://riemann.io/api/riemann.config.html#var-streams" rel="noopener ugc nofollow" target="_blank">streams</a></code>函数配置的，该函数需要传递一个参数函数，每个接收到的事件都会调用这个函数。Riemann文档用顶级<code class="du kv kw kx ky b">streams</code>函数发出的事件“流”来描述这一点。</p><p id="9f7f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，这里有一个非常简单的黎曼配置:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="e561" class="lh jt hx ky b fi li lj l lk ll">(defn my-event-handler<br/> [event]<br/> (println “Handling event:” event))</span><span id="cf5b" class="lh jt hx ky b fi lm lj l lk ll">(streams my-event-handler)</span></pre><p id="0469" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为配置只是代码，事件流只是函数，所以Riemann实际上是无限灵活的。它提供了一个丰富的可组合函数库，这些函数库组成了一个流处理DSL，使您无需掌握Clojure的全面知识就能构建复杂的监控场景。从哲学上讲，这使得黎曼更像一个框架或库，而不是常规的监控软件。事件只是任意的结构(除了少数标准的、惯用的字段之外)，所以事件的语义几乎完全取决于流的实现，而不是事件本身所表示的数据。这意味着黎曼本身不会对事件做任何事；完全由流配置来处理。</p><p id="2ed7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">举一个更复杂的例子，如果您想要创建一个黎曼配置来监视错误事件，并最多每60秒发送一封电子邮件，您可以这样做:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="7dd6" class="lh jt hx ky b fi li lj l lk ll">(def email (mailer {:host “mail.relay”<br/>                    :from “<a class="ae hu" href="mailto:riemann@example.com" rel="noopener ugc nofollow" target="_blank">riemann@example.com</a>”}))</span><span id="c507" class="lh jt hx ky b fi lm lj l lk ll">(streams<br/>  (where (and (= (:service event) “my-service”)<br/>              (= (:level event) “ERROR”))<br/>    (rollup 1 60<br/>      (email “<a class="ae hu" href="mailto:ops@example.com" rel="noopener ugc nofollow" target="_blank">ops@example.com</a>”))))</span></pre><p id="7be3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，<code class="du kv kw kx ky b">where</code>、<code class="du kv kw kx ky b">rollup</code>和<code class="du kv kw kx ky b">mailer</code>都是由黎曼流DSL提供的。<code class="du kv kw kx ky b">where</code>是一个Clojure宏，它返回一个函数，该函数将根据提供的逻辑谓词过滤出事件，然后将这些事件传递给<code class="du kv kw kx ky b">rollup</code>函数，后者返回一个函数，该函数将累积事件并将它们传递给由<code class="du kv kw kx ky b">email</code>创建的流，最多每60秒一次。<code class="du kv kw kx ky b">email</code>是一个返回函数，该函数将一个或多个事件格式化成电子邮件通知，并将其发送到提供的地址。</p><p id="a29f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">诚然，这是一大堆“函数返回函数，函数返回函数”，但最终我们只需要考虑两个基本概念:事件和流，或者用Clojure的术语来说，映射和函数。这种简单性和灵活性是Riemann最吸引人的地方之一，它允许我们在现有架构的限制下构建复杂的监控。</p><h1 id="1da3" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">黎曼中的性能度量</h1><p id="f0cf" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在设计任何业务关键型系统的初始活动中，一个重要的部分是彻底理解性能和正常运行时间的需求，这最终必须用可测量的术语来定义。这些需求通常以目标的形式出现，比如“web服务响应时间的第99个百分点应该少于100毫秒”，或者“所有HTTP请求的95%应该是成功的”为了衡量我们在这些目标下的性能，我们在Riemann配置中构建了一个声明性性能阈值DSL。它允许我们通过配置建立阈值，并直接从已经流经Riemann的事件中获取度量。</p><p id="0bc2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们的DSL中，我们考虑两种不同的基本类型的性能指标:<code class="du kv kw kx ky b">percentiles</code>和<code class="du kv kw kx ky b">histograms</code>。百分比适用于数值测量值(例如响应时间)，可以在任意点定义，而直方图适用于离散值(例如HTTP响应状态代码)，并采用百分比或计数器阈值的形式。直方图和百分位数都是通过一个<code class="du kv kw kx ky b">interval</code>定义的，它是离散时间窗口内的秒数，在该时间窗口内事件将被一起考虑。</p><p id="7b48" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">举个例子，给定类似这样的事件:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="6787" class="lh jt hx ky b fi li lj l lk ll">{:service "query-service response"<br/> :metric 85<br/> :status-code “200”}</span></pre><p id="94a7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们在单独的<a class="ae hu" href="https://github.com/edn-format/edn" rel="noopener ugc nofollow" target="_blank"> EDN </a>配置文件中表示性能目标阈值:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="83e0" class="lh jt hx ky b fi li lj l lk ll">{:percentiles {"query-service response" {0.99 {:&lt;= 100 <br/>                                               :interval 600}}}<br/> :histograms {"query-service response" <br/>              {:status-code {"^2[0–9]{2}$" {:&gt;= 0.95<br/>                                           :interval 600<br/>                                           :type :percentage}<br/>                             ".*" {:&gt; 0<br/>                                   :interval 300<br/>                                   :type :count}}}}}</span></pre><p id="1246" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个片段中，我们跟踪3个不同的性能阈值:</p><ol class=""><li id="9e29" class="ln lo hx iw b ix iy jb jc jf lp jj lq jn lr jr ls lt lu lv bi translated">在10分钟的时间间隔内，第99个百分位数的响应时间应小于或等于100。用于比较的值将与事件上的<code class="du kv kw kx ky b">:metric</code>键相关联(这是与数字相关联的事件的黎曼习语)。</li><li id="237c" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">在10分钟的时间间隔内，95%的带有<code class="du kv kw kx ky b">:status-code</code>的响应事件应该具有2XX的状态代码。</li><li id="9c42" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">在5分钟内，所有带有<code class="du kv kw kx ky b">:status-code</code>的响应事件的计数应大于零。</li></ol><p id="afb0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的黎曼配置将上述阈值配置图转换为一组流，这些流过滤相关事件、累加值并将其与预期阈值进行比较。当给定阈值的状态从可接受变为不可接受，或者再次变为不可接受时，流会将更改事件传递给通知流，通知流会在我们的外部警报系统中发送或清除警报。</p><p id="8ba6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的配置从EDN阈值配置文件中生成这些流，但是上述阈值之一的静态(当然也是幼稚的)版本可能如下所示:</p><pre class="kz la lb lc fd ld ky le lf aw lg bi"><span id="359c" class="lh jt hx ky b fi li lj l lk ll">(percentiles 600    ;; interval<br/>             [0.99] ;; percentile<br/>             (smap (fn [event]<br/>                     (assoc<br/>                      event<br/>                      :state (if (&lt;= (:metric event) 100)<br/>                               "ok"<br/>                               "violation")))<br/>                   (changed :state {:init "ok"}<br/>                            (where (= (:state event) "ok")<br/>                                   notify-restored<br/>                                   (else<br/>                                    notify-violated)))))</span></pre><p id="5974" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本例中，我们使用了Riemann DSL提供的四个函数/宏:</p><ol class=""><li id="3e7d" class="ln lo hx iw b ix iy jb jc jf lp jj lq jn lr jr ls lt lu lv bi translated"><code class="du kv kw kx ky b">percentiles</code> —聚合600秒间隔内的事件，并将具有第99百分位的<code class="du kv kw kx ky b">:metric</code>值的事件传递到下一个流，在本例中为<code class="du kv kw kx ky b">smap</code>。</li><li id="9bda" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated"><code class="du kv kw kx ky b">smap</code> —这是一个流映射，这意味着它将作为第一个参数提供的函数映射到每个事件，然后将其传递给下一个流。在这种情况下，下一个流是<code class="du kv kw kx ky b">changed</code>。<br/>映射函数为事件<code class="du kv kw kx ky b">:state</code>属性赋值，如果事件的<code class="du kv kw kx ky b">:metric</code>值小于或等于100，则该值取决于<code class="du kv kw kx ky b">"ok"</code>或<code class="du kv kw kx ky b">"violation",</code>。由于该流位于<code class="du kv kw kx ky b">percentile</code>流之下，它将只接收代表由<code class="du kv kw kx ky b">percentile</code>处理的任何事件的第99个百分位度量值的事件。</li><li id="2b0a" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated"><code class="du kv kw kx ky b">changed</code> —该流过滤掉每个事件，除了那些指定属性(在本例中为<code class="du kv kw kx ky b">:state</code>)已经从它看到的最后一个事件改变的事件。<code class="du kv kw kx ky b">{:init “ok"}</code>参数只是一个初始化<code class="du kv kw kx ky b">changed</code>流状态的选项映射。这允许我们仅在某个方向超过性能指标阈值时发送通知，并防止在状态为<code class="du kv kw kx ky b">"ok"</code>时为第一个事件发送通知。</li><li id="4408" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated"><code class="du kv kw kx ky b">where</code> —这个流简单地调用基于状态的适当的<code class="du kv kw kx ky b">notify-*</code>流，在我们设计的例子中，假设这些流是在配置中的其他地方定义的函数。</li></ol><h1 id="758e" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">摘要</h1><p id="8c71" class="pw-post-body-paragraph iu iv hx iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">最后，我们喜欢黎曼，因为它不碍事，让我们可以集中精力决定<em class="mb">跟踪什么</em>，而不是<em class="mb">如何</em>跟踪它。然后，最大的挑战变成了确定反映稳定和标称操作值的指标、阈值和间隔，以确保阈值违规产生的信号的纯度和可用性。我们的团队为我们的系统定义了阈值，以便它们代表系统健康状况的强有力指标，并且我们将它们与我们的主动警报系统相集成，以自动管理事件，并在这些值落入和超出范围时通知待命工程师。这为我们提供了一个框架，可以顺利地自动化我们的错误检测试探法，而不需要在传统的监控集成方面进行大量投资，并且它将我们从检查仪表板和从上游或外部来源获得问题通知的恶性循环中解放出来。</p></div></div>    
</body>
</html>