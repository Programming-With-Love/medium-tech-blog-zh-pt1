<html>
<head>
<title>External tables in Azure Databricks with underlying data in Azure Data Lake gen2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure数据块中的外部表和Azure数据湖gen2中的底层数据</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/external-tables-in-azure-databricks-with-underlying-data-in-azure-data-lake-gen2-c45b9d81c6d5?source=collection_archive---------1-----------------------#2020-10-14">https://medium.com/walmartglobaltech/external-tables-in-azure-databricks-with-underlying-data-in-azure-data-lake-gen2-c45b9d81c6d5?source=collection_archive---------1-----------------------#2020-10-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="er es hf"><img src="../Images/066df5418ee6c13d6eb7bdc4d1724982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*6GIaiBE4YQ3m4sXQPzMlvg.png"/></div></figure><div class=""/><p id="bd07" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们可以通过多种方式在Azure Databricks中创建外部表格。这篇博客将试图涵盖不同的方式，每种方式的利弊，以及它们适用的场景。</p><p id="f855" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Databricks接受SQL语法或HIVE语法来创建外部表。在这篇博客中，我将使用SQL语法来创建表格。</p><p id="651a" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">注意:我没有使用凭证传递特性。</p><h1 id="47e9" class="jj jk ho bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated"><strong class="ak">方法一。使用挂载点</strong></h1><p id="b94d" class="pw-post-body-paragraph il im ho in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">第一种方法是使用location字段中的挂载点。在ADLS 2中，使用服务主体在所需的文件夹级别创建挂载点。将使用服务主体和OAuth 2.0进行身份验证</p><p id="406b" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="7aa2" class="kv jk ho kr b fi kw kx l ky kz"><strong class="kr hp">CREATE TABLE</strong> db_name.table_name(<br/>col_name1 col_type1,</span><span id="38a8" class="kv jk ho kr b fi la kx l ky kz">....<br/>)<strong class="kr hp">LOCATION</strong> "dbfs:/mnt/mount_name/......"</span></pre><p id="0ee1" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们不需要在create命令中指定external，因为我们正在指定位置，它会自动创建一个外部表。</p><p id="709d" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这种方法的优点是它是开始访问和操作数据的最简单的方法。假设数据所有者创建了挂载点，它在整个工作空间中都是可用的。业务用户和数据工程师可以使用这些挂载点并操作表数据。</p><p id="8def" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这种方法的缺点是存在未经授权访问数据的高风险。有权访问工作区的每个人都可以查询此表。假设业务用户“a”无权访问表(ADLS2位置)，但有权访问工作区，那么“a”仍然可以查询表，因为身份验证是通过服务主体进行的。</p><h1 id="ef51" class="jj jk ho bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">方法二。使用完整的ADLS2路径</h1><p id="dbaa" class="pw-post-body-paragraph il im ho in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">在这种方法中，我们在位置字段中使用完整的abfss路径。身份验证仍然通过服务主体进行。</p><p id="a6cf" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="5492" class="kv jk ho kr b fi kw kx l ky kz"><strong class="kr hp">CREATE</strong> <strong class="kr hp">TABLE </strong>db_name.table_name(<br/>col_name1 col_type1,<br/>...<br/>)  <br/><strong class="kr hp">USING</strong> data_source<br/><strong class="kr hp">LOCATION</strong> "abfss://container_name<a class="ae lb" href="mailto:hnw-exec-dashboard-write@pd21522c1spstg.dfs.core.windows.net" rel="noopener ugc nofollow" target="_blank">@s</a>torage_account/..."</span></pre><p id="f026" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">或者</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="7f86" class="kv jk ho kr b fi kw kx l ky kz"><strong class="kr hp">CREATE TABLE</strong> db_name.table_name(<br/>col_name1 col_type1,<br/>...<br/>)<br/><strong class="kr hp">USING</strong> data_source <br/><strong class="kr hp">OPTIONS</strong>(<strong class="kr hp">path</strong> "abfss://container_name<a class="ae lb" href="mailto:hnw-exec-dashboard-write@pd21522c1spstg.dfs.core.windows.net" rel="noopener ugc nofollow" target="_blank">@s</a>torage_account/...")</span></pre><p id="61b9" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">完整的创建表语法可以在<a class="ae lb" href="https://docs.databricks.com/spark/latest/spark-sql/language-manual/create-table.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><p id="f108" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这种方法的主要优点是只有知道授权码的用户才能访问这些表。这些代码需要在同一个会话中执行。在前面的方法中，即使我们不共享授权码，由于服务主体的原因，未授权用户仍然能够访问，而这里用户需要在每个会话中指定代码。</p><p id="a740" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">缺点是如果暴露了服务主体细节，用户就可以访问这些表。</p><h1 id="7f20" class="jj jk ho bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">结论</h1><p id="263d" class="pw-post-body-paragraph il im ho in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">在这篇博客中，我们已经介绍了在Azure Databricks中创建外部表的方法。每种方法都有优点和缺点，选择适合您的生产场景的方法。</p></div></div>    
</body>
</html>