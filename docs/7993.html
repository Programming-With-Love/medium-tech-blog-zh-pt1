<html>
<head>
<title>Solr Performance Tuning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solr性能调整</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/solr-performance-tuning-beb7d0d0f8d9?source=collection_archive---------0-----------------------#2021-04-07">https://medium.com/walmartglobaltech/solr-performance-tuning-beb7d0d0f8d9?source=collection_archive---------0-----------------------#2021-04-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/746708cc6cb3e22b3e9d8a1f598b6f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qMP8lggaXQ0l12zx"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@mattj_bowden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matt Bowden</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="602c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我想在下面分享我和我的团队在为我们的用例提出最佳Solr设置时的过山车体验。对于我们的大多数测试来说，性能是如此之差，以至于我们最终优化了设置的几乎所有部分，包括配置、模式、环境、JVM设置和查询。在这次练习中，我们学到了许多宝贵的经验，希望你也能学到。</p><h1 id="5396" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">问题是</h1><ul class=""><li id="fd97" class="kq kr hh iw b ix ks jb kt jf ku jj kv jn kw jr kx ky kz la bi translated">我们有4000万个文档(平均。文档大小为1 kb ),因此总索引大小约为40 GB。虽然我们会有更多的更新，但文档数量将保持不变。</li><li id="6f18" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">我们的查询有一个固定的模式，只有5或6个过滤查询(FQ)(没有查询搜索词，方面或排序)。</li><li id="956f" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">P99读取延迟必须在150毫秒以内。</li><li id="7408" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">我们将限制每分钟更新15万个文档。<br/>机器大小固定为28 GB RAM和8核CPU。</li><li id="e966" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">提交时间间隔设置为15分钟，这是我们的SLA，用户可以看到任何更新。</li></ul><p id="2bf1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们想要优化的是在满足延迟SLA和写入吞吐量限制后的读取吞吐量。</p><h1 id="99ac" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">初始设置</h1><p id="36ad" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">基于上述信息，然后阅读了很多关于Solr的文章(我将在下面链接，可能会很有帮助)，我们提出了我们的5个碎片的初始设置。</p><p id="b834" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是基于40GB索引/5个碎片= 8GB/碎片的事实。我们知道您希望将索引缓存在操作系统文件缓存中。因此，我们将JVM堆大小保持在16GB，这意味着我们为索引和一些缓冲区留出了将近12GB。事实上，更多的碎片意味着你的写被分割，根据我们之前的测试，我们知道单个碎片每分钟可以处理大约30K的文档更新。</p><p id="a641" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">到目前为止，一切看起来都很好，我们没有理由怀疑设置不会工作。</p><h1 id="9118" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">测试</h1><p id="4504" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">在这一点上，我们运行了我们的第一个性能测试，但结果出乎意料的可怕。我们勉强能够支持每个节点1个QPS。系统CPU达到100%，然后在几个小时的测试后崩溃(也是在禁止写入的情况下)。看看下面的指标-</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/5bde29542827c3e8edb941aa0e0783d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-cv6tdE07Wx-0T6PQ-b0IA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">P99 Latency at ~50sec</figcaption></figure><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lo"><img src="../Images/3b02fe66bf4f08bc6c29d5df52525d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Vq2M3xc-WoYdD5P6WkZ7A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">CPU reaching 100%</figcaption></figure><p id="8146" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">发布后，我们进行了多次测试，以了解并修复根本原因-<br/>-我们的过滤器缓存命中率为0.6，为了改善这一点，我们增加了过滤器缓存的大小。这并没有帮助，因为JVM堆的使用和CPU仍然达到100% <br/> —文档缓存的命中率为0.5，但驱逐率非常高，这会导致更频繁的GC周期。所以我们减少了文档缓存的大小。虽然还是没有太大的改善。<br/> —在重新访问我们的schema.xml时，我们发现很少有字段没有indexed=true，我们正在对它们运行过滤查询。所以我们更新了模式。仍然没有运气。</p><p id="4362" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">尽管上述优化都没有对性能产生太大影响，但我们注意到的一点是，过滤器缓存预热时间约为500秒，这对我们的查询来说是非常大的。考虑到CPU和JVM堆的大小是我们测试中经常遇到的瓶颈，我们决定将我们的设置和测试转移到具有128GB RAM和32核CPU的高配置XXL机器上。</p><h1 id="9dd9" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">终于有了一些希望</h1><p id="5059" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">在我们对XXL机器进行的第一次只读(无写入)测试中，在整个4小时测试期间，CPU利用率达到了60%。我们没有主要的GC运行，JVM堆使用率最高为70%。P99下降到111毫秒，这在当时似乎是不可思议的。</p><p id="9a17" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于下一个测试，我们引入了以21K文档更新/分钟的速度写入。但是在这个测试过程中，读取延迟发生了巨大的变化。P99约为37秒，尽管P95仍约为100毫秒。P99和P95潜伏期的巨大差异意味着我们需要更深入地了解正在发生的事情。</p><h1 id="d309" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">了解索尔的写作和表现</h1><p id="34c9" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">在Solr中，一旦引入写入，设置性能就会发生巨大变化。这可能主要是由于以下原因——</p><p id="ba3e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">—所有缓存现在都将在每次提交后失效，必须再次预热。<br/>(为了更好地管理这一点，Solr将自动从早期缓存中为顶级查询预填充缓存。这种情况下所花费的时间称为缓存预热时间)<br/> —写请求也将开始占用CPU周期<br/> —随着时间的推移，段数的增加可以减少读取延迟<br/>(为了应对这种情况，Solr根据<a class="ae it" href="https://lucene.apache.org/solr/guide/8_4/indexconfig-in-solrconfig.html#merging-index-segments" rel="noopener ugc nofollow" target="_blank"> Solr合并策略</a>运行“优化”。尽管优化步骤在CPU和磁盘使用方面有很大的成本。所以最好将其配置为不频繁运行)<br/>——如果没有足够的内存将写入数据缓存在<a class="ae it" href="https://www.thomas-krenn.com/en/wiki/Linux_Page_Cache_Basics" rel="noopener ugc nofollow" target="_blank">操作系统页面缓存</a>中，磁盘I/O可能是硬提交期间的主要瓶颈</p><p id="8323" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">随着我们对写入对Solr设置的影响的了解越来越多，我们得出的结论是，对于我们来说，缓存失效会导致我们的一些查询需要花费大量的时间来处理。同样的查询必须负责我们在早期测试中观察到的非常大的缓存预热时间。</p><h1 id="d3ad" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">优化:查询</h1><p id="0a2b" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">我们有一个fq，在一个函数上有<a class="ae it" href="https://lucene.apache.org/solr/guide/6_6/other-parsers.html#OtherParsers-FunctionRangeQueryParser" rel="noopener ugc nofollow" target="_blank"> frange filter </a>，它根据每个文档的几个其他字段计算最高和最低价格。深入研究后，我们发现在Solr中，默认情况下所有的FQ都在整个索引上运行，然后对这些单独的结果进行交集运算。Solr这样做是为了利用过滤器缓存，因为它可以独立地缓存这些结果，然后将它们用于所有未来的查询。但是当存在不频繁重复的fq(例如范围滤波器)并且计算起来非常昂贵时，这种方法的问题就出现了。这样的fq将从根本上降低整体查询性能。</p><p id="d81d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了管理这种情况，Solr提供了一种替代方法，在这种方法中，我们可以将cost参数添加到这样的FQ中，并且任何cost&gt;=100的FQ都在查询的其余部分的结果集上运行，而不是在整个索引上运行。并且对于带有<strong class="iw hi"> cache=false的frange查询(在SOLR 8中)</strong>默认为成本100，如这个<a class="ae it" href="https://issues.apache.org/jira/browse/SOLR-11641" rel="noopener ugc nofollow" target="_blank"> JIRA票</a>中所解释的。这正是我们所做的。我们的- <br/> — P99从37秒减少到130秒。<br/> —过滤器缓存预热时间从500秒减少到20秒</p><pre class="lk ll lm ln fd lp lq lr ls aw lt bi"><span id="3117" class="lu jt hh lq b fi lv lw l lx ly">Example use case - <br/>Min price selected is 0 <br/>Max price selected is 1500</span><span id="1d3a" class="lu jt hh lq b fi lz lw l lx ly">Original query - <br/>{!frange l=0.0 u=1500.0}</span><span id="042e" class="lu jt hh lq b fi lz lw l lx ly">Optimised query -<br/>{!frange cache=false l=0.0 u=1500.0}</span></pre><p id="3ccc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然这是朝着正确方向迈出的良好的第一步，但我们很高兴能够在最初的XL机器上再次运行我们的测试，该机器具有28GB内存和8核CPU。XL机器几乎是成本的三分之一，并且可以节省大量成本。</p><h1 id="c76e" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">回到原始设置</h1><p id="ce26" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">对XL机器的下一次测试在早期运行的基础上有了显著的改进—<br/>—CPU和JVM堆的使用没有达到100%<br/>—P99延迟开始于150毫秒左右，但逐渐增加，在4小时后达到大约70秒</p><p id="1c33" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这意味着在我们的设置中还有其他瓶颈。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div class="er es ma"><img src="../Images/8e09c7e9c2fe032cd798e60ba905f102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*n_o0KAjc8lzNh6PUpokt5g.jpeg"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Trying to do something new (Image source: <a class="ae it" rel="noopener" href="/@techindustan/best-technology-to-learn-for-future-a35f04cf3266">Medium</a>)</figcaption></figure><h1 id="9fb2" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">找到瓶颈</h1><p id="b437" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated"><strong class="iw hi">测试查询是否是瓶颈— </strong> <br/>我们已经优化了查询的一部分，并看到了非常好的改进。为了进一步研究我们的查询，我们运行了一个实验，在这个实验中，除了负责取回文档的术语过滤器之外，我们从查询中删除了所有的FQ。</p><pre class="lk ll lm ln fd lp lq lr ls aw lt bi"><span id="5895" class="lu jt hh lq b fi lv lw l lx ly">Sample simplified query — </span><span id="caad" class="lu jt hh lq b fi lz lw l lx ly">“q”: “*:*”,<br/>”fq”: “{!terms f=item_id}2ZSZKDSO4X5T,2WCULXLPA0JO,6R9RIWPF50AL,2EQYBAO5L251,69HCJ07YYR6T,14WVKW7HK898,10KWB6Y3YQE9,4R8JZCRANJVO,26WMP7XFQ5XA,1ZV85IKWLSWU,5BPBP26KIBBO,2RIRBKGUEVO6”,<br/>”wt”: “json”</span></pre><p id="6465" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">即使这个简化的查询也没有带来任何性能改进。因此我们可以排除这种可能性。</p><p id="2f90" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">测试网络是否是瓶颈— </strong> <br/>我们知道XL机器上的网络带宽远低于XXL机器。鉴于这一事实，碎片间的通信可能是一个主要的瓶颈。为了测试这一点，我们使用<a class="ae it" href="https://lucene.apache.org/solr/guide/8_4/distributed-requests.html#limiting-which-shards-are-queried" rel="noopener ugc nofollow" target="_blank"> shards查询参数</a>将所有查询限制为仅从单个碎片获取数据。<br/>由于我们没有看到任何性能提升，我们也排除了这种可能性。</p><p id="f98b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">测试磁盘I/O是否是瓶颈— </strong> <br/>磁盘I/O可能是一个主要瓶颈，尤其是在Solr延迟方面。默认情况下，Linux会自动将经常使用的文件缓存到OS页面缓存中(如果有空闲内存的话)。从内存中读取比从磁盘中读取要快得多(即使磁盘是SSD ),如下面的示例所示。</p><pre class="lk ll lm ln fd lp lq lr ls aw lt bi"><span id="0df1" class="lu jt hh lq b fi lv lw l lx ly"><strong class="lq hi">First run (file is being read from disk)</strong><br/>[my_linux_machine]$ /usr/bin/time -p cat 20_GB_FILE &gt; /dev/null<br/>real 177.64<br/>user 0.50<br/>sys 21.5</span><span id="53c8" class="lu jt hh lq b fi lz lw l lx ly"><strong class="lq hi">Second run (file is now cached in memory by OS)</strong><br/>[my_linux_machine]$ /usr/bin/time -p cat 20_GB_FILE &gt; /dev/null<br/>real 10.50<br/>user 0.39<br/>sys 10.10</span></pre><p id="ddd8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如您所看到的，一旦文件被缓存，读取它的时间从177秒下降到10秒。Solr依靠这个系统行为来缓存它的索引文件以获得更好的性能。</p><p id="1f67" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以使用<a class="ae it" href="https://www.thomas-krenn.com/en/wiki/Linux_Page_Cache_Basics" rel="noopener ugc nofollow" target="_blank"><strong class="iw hi">free-m</strong></a><strong class="iw hi"/>监控可用内存，使用<a class="ae it" href="https://www.tecmint.com/linux-performance-monitoring-with-vmstat-and-iostat-commands/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hi">iostat/vmstat</strong></a>监控磁盘I/O。你也可以使用惊人的免费工具，如<a class="ae it" href="https://hoytech.com/vmtouch/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi"> vmtouch </strong> </a>来锁定你在操作系统页面缓存上的索引。</p><h1 id="0c08" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">优化:JVM调优</h1><p id="5c60" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">为了优化磁盘I/O，我们决定减小JVM堆的大小。除此之外，为了确保我们不会遇到堆空间的OOM问题，我们还将过滤器缓存大小减小到原始设置T26，同时禁用了fieldValueCache和documentCache，因为它们的驱逐率很高</p><p id="7301" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们在JVM堆设置为8GB(最初为16GB)的情况下进行了测试，瞧，我们得到了惊人的结果— <br/> — P99读取延迟从平均。30秒到137毫秒。<br/> — CPU和JVM堆仍在限制范围内，没有观察到峰值</p><h1 id="89af" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">最后一次优化(至少我们是这么认为的)</h1><p id="1da3" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">我们试图再做一次优化，即在开始测试之前将索引合并到一个单独的片段中，正如许多关于调整Solr的文章所建议的那样。尽管Solr使用<a class="ae it" href="https://lucene.apache.org/solr/guide/8_4/indexconfig-in-solrconfig.html#IndexConfiginSolrConfig-CustomizingMergePolicies" rel="noopener ugc nofollow" target="_blank">合并策略</a>来“优化”索引，但是您仍然可以手动强制优化。</p><pre class="lk ll lm ln fd lp lq lr ls aw lt bi"><span id="d29e" class="lu jt hh lq b fi lv lw l lx ly">To manually optimise (merge segments) - </span><span id="3eef" class="lu jt hh lq b fi lz lw l lx ly">/update?optimize=true&amp;maxSegments=1</span></pre><p id="c57e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而对我们来说，结果很差。P99跳到了79秒。在我们的案例中，与一般准则相反，具有多个较小段的索引比具有较大单个段的索引表现得更好。</p><h1 id="c3c5" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">决赛成绩</h1><p id="cc00" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">我们现在有了最终的设置。如果我们仔细想想，我们并没有在Solr中做任何复杂的改变来达到同样的效果。尽管它确实需要我们建立对底层Solr设计的正确理解，以评估和进行所需的优化。正如我们从这个练习中所看到的(下表列出了要点),通过适当的调优可以实现巨大的性能提升。</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Initial setup vs Final setup</figcaption></figure><h1 id="b4d9" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">经验教训</h1><p id="c59a" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">Solr有很多相互影响的运动部件。因此，调整一个参数可能会对其他一些参数产生不良影响。因此，反复测试您的设置并在这些测试之间只做很少的更改是非常重要的，这样才能确信您正朝着正确的方向前进。</p><ul class=""><li id="a914" class="kq kr hh iw b ix iy jb jc jf md jj me jn mf jr kx ky kz la bi translated">对于Solr硬件的规模，没有<a class="ae it" href="https://lucidworks.com/post/sizing-hardware-in-the-abstract-why-we-dont-have-a-definitive-answer/" rel="noopener ugc nofollow" target="_blank">明确的答案。反复调整和测试您的设置是唯一真正的方法。</a></li><li id="8891" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">监控您的磁盘I/O。(除非延迟根本不是问题)</li><li id="2503" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated"><a class="ae it" href="https://lucene.apache.org/solr/guide/8_4/jvm-settings.html" rel="noopener ugc nofollow" target="_blank">仔细设置你的Solr JVM堆大小</a>。它应该能够容纳所有缓存和内部对象，同时留出足够的空间来避免频繁运行GC，但又不至于大到不给OS页面缓存留出空间来缓存您的索引。</li><li id="524a" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">检查所有在查询中唯一的FQ，并将它们标记为cache=false。</li><li id="5374" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">Solr缓存并不总是你的朋友。监控您的缓存命中率和驱逐率。无论是低命中率还是高驱逐率都不利于你的设置。我们完全禁用了文档缓存，没有发现延迟下降。</li></ul><h1 id="048e" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">进一步阅读</h1><div class="mg mh ez fb mi mj"><a href="https://lucidworks.com/post/scaling-lucene-and-solr/" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hi fi z dy mo ea eb mp ed ef hg bi translated">扩展Solr的提示和技巧</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">虽然许多Lucene/Solr应用程序永远不会超越一台配置良好的机器，但事实是，越来越多的…</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">lucidworks.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx in mj"/></div></div></a></div><div class="mg mh ez fb mi mj"><a href="https://cwiki.apache.org/confluence/display/SOLR/SolrPerformanceProblems" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hi fi z dy mo ea eb mp ed ef hg bi translated">阿帕奇软件基金会</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">另请参阅:SolrPerformanceFactors、SolrPerformanceData、基准测试Solr本页将尝试回答以下问题</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">cwiki.apache.org</p></div></div></div></a></div></div></div>    
</body>
</html>