<html>
<head>
<title>Support for newer Java language APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">支持较新的Java语言API</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/support-for-newer-java-language-apis-bca79fc8ef65?source=collection_archive---------0-----------------------#2020-07-14">https://medium.com/androiddevelopers/support-for-newer-java-language-apis-bca79fc8ef65?source=collection_archive---------0-----------------------#2020-07-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/ff8ebc2677daca66c752db8ee22f6421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVGmQY2YHfBUxwloDyhFwA.png"/></div></div></figure><div class=""/><p id="85d9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">想象开发一个需要处理时间计算的应用程序。在谷歌搜索了一番之后，您很可能会找到java.time包的优秀示例！然而，在发布您的应用程序后，您突然收到成千上万个API &lt; 26的崩溃和用户投诉！</p><p id="f857" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">想知道原因吗？观看视频或阅读下面的博客。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="d8eb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">原因是遇到问题的设备根本没有安装必要的类，因为那时这些类还不是Android的一部分。</p><p id="54e3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着每一个新版本的Android增加了java。* APIs从OpenJDK添加到Android。在Android 11中，我们添加了对从较新的OpenJDK版本到版本13的许多API的支持，包括对List、Set、Map和新的java.time API的添加。虽然我们不断地向每个平台版本添加新的Java APIs，但我们也希望这些API能为旧设备所用。</p><p id="e579" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我告诉你，当你使用Android Gradle Plugin 4.0.0和更新版本时，你现在可以使用来自更新OpenJDK版本的数百个API，并且你的应用程序可以在任何Android设备上工作，会怎么样？Android 11中的一些较新的Java APIs通过反向移植得到支持，而其他API也可以通过在Android平台没有运行时API的旧设备上解糖来获得。</p><p id="0477" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想知道这怎么可能，让我们来谈谈脱糖。</p><h1 id="b27a" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">D8/R8脱糖</h1><p id="b070" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">Android Gradle插件4.0为使用某些Java语言API和使用它们的第三方库提供了内置支持。以前，这些API仅在较新的Android版本上受支持，但随着AGP 4.0的推出，它们现在几乎在所有Android版本上都受支持。</p><p id="c5e4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">D8/R8表演的“去糖”技巧使这种支持成为可能。当您使用这些新的Java APIs构建应用程序时，Java编译器首先将Java源代码转换成Java字节码。然后，工具链通过在您的应用(包括您的应用使用的任何第三方库)上执行字节码转换来实现新的API，并将它们转换为dex代码，同时为缺少这些运行时类的设备添加必要的Java 8运行时代码作为单独的dex库。</p><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kw"><img src="../Images/f946504843dfb6e1d1fb569618bd319b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E_sy78ZiD0Zr5aGV"/></div></div></figure><p id="92b6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个过程被称为去糖，它使一组Java 8 APIs能够在所有现有设备上工作，除了并行设备，并行设备受API级别21的支持。</p><h1 id="31a2" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用较新的Java APIs</h1><p id="5ce1" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">要开始使用新的Java APIs，请将Android Gradle插件更新到4.0或更高版本，并在模块的<code class="du kx ky kz la b">build.gradle</code>文件中添加以下配置。</p><ul class=""><li id="0757" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated">设置<code class="du kx ky kz la b">coreLibraryDesugaringEnabled</code>标志。</li><li id="3fdd" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">将Java源和目标兼容性设置为Java 8。</li><li id="70f6" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">添加<code class="du kx ky kz la b">coreLibraryDesugaring</code>作为附属物。</li><li id="4ac7" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">启用<code class="du kx ky kz la b">multidex</code>。为了支持这些语言API，插件会编译一个单独的DEX文件，其中包含缺失API的实现，并将其包含在您的应用程序中</li></ul><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="5b3d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然您已经了解并启用了Java 8+去糖，那么让我们来看看新的API。</p><h1 id="ffc1" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">java.time</h1><p id="fe58" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">时间API有一些缺点。<code class="du kx ky kz la b">java.util.Date</code>和<code class="du kx ky kz la b">java.util.Calendar</code>类是可变的，这会导致并发问题。此外，API不是很一致，也不容易使用。举个简单的例子，在Date对象中，day从1开始，month从0开始，可能会比较混乱。</p><p id="10b7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kx ky kz la b">Date date = new Date(2, 3, 1); <em class="lq">//Tue Apr 01 00:00:00 PST 1902</em></code></p><p id="c4ed" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在OpenJDK第8版中，java中添加了一个新的Java时间API Java . Time package。新的java.time基于流行的库<code class="du kx ky kz la b">JodaTime</code>。所有核心<code class="du kx ky kz la b">java.time </code>类都是不可变的，并且没有setter方法，所以它们不会引入任何并发问题。此外，新的<code class="du kx ky kz la b">java.time</code> API使得处理时区变得更加容易。让我们看看新的日期和时间类。</p><p id="d02f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，如果您不需要日期和时间对象的时区数据，<code class="du kx ky kz la b">java.time</code>有两个新的类，<code class="du kx ky kz la b">LocalDate</code>和<code class="du kx ky kz la b">LocalTime</code>。这两个类表示相对于用户的日期和时间，比如闹钟或计时器，而不用担心时区。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="38ef" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您的用例需要时区，您可以使用<code class="du kx ky kz la b">ZonedDateTime</code>或<code class="du kx ky kz la b">OffsetDateTime</code>类。先说<code class="du kx ky kz la b">ZonedDateTime</code>。<code class="du kx ky kz la b">ZonedDateTime</code>是<code class="du kx ky kz la b">DateTime</code>的不可变表示，包含一个<code class="du kx ky kz la b">LocalDateTime</code>、一个<code class="du kx ky kz la b">ZoneId</code>和已解析的<code class="du kx ky kz la b">ZoneOffset</code>。</p><p id="3aba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以使用<code class="du kx ky kz la b">ZoneId</code>类以时区的缩写或长文本形式设置时区。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="7cbc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您需要存储日期和时间而不依赖于特定设备或应用程序的上下文时,<code class="du kx ky kz la b">ZonedDateTime</code>特别有用。<code class="du kx ky kz la b">ZonedDateTime</code>可以在任何时间点解析到任何时区。</p><p id="b89c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用<code class="du kx ky kz la b">ZoneOffsets</code>来计算当前时区和格林威治/UTC之间的时差。</p><p id="1c09" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kx ky kz la b">OffsetDateTime</code>与<code class="du kx ky kz la b">ZonedDateTime</code>相似，但保持与格林威治/UTC的偏差，而不是<code class="du kx ky kz la b">ZoneId</code>。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="2465" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总结一下<code class="du kx ky kz la b">ZonedDateTime</code>和<code class="du kx ky kz la b">OffsetDateTime</code>的区别，<code class="du kx ky kz la b">ZonedDateTime</code>非常适合显示时区敏感的日期时间数据。<code class="du kx ky kz la b">OffsetDateTime</code>最适合将日期时间数据存储到数据库，以及其他需要序列化数据的用例。</p><p id="239f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">新的<code class="du kx ky kz la b">java.time</code> API有两个新的类，<code class="du kx ky kz la b">Period</code>和<code class="du kx ky kz la b">Duration</code>，分别定义日期范围或时间长度。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><h1 id="a61d" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">java .实用程序.流</h1><p id="0b12" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">流允许您对集合执行函数式操作。流不存储数据或修改底层数据结构，并提供更好的可读性。</p><p id="9257" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">流有大量内置的中间和终端操作。中间操作是懒惰的，总是返回一个新的流。终端操作是急切的，一旦被调用，它们就完成了数据源的遍历，流就不能再使用了。由于在调用终端操作之前不会评估中间操作，因此在处理大型数据源时，流<em class="lq">可能会</em>执行得更好。</p><p id="62c9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要使用streams，您可以调用集合上的<code class="du kx ky kz la b">stream()</code>方法，或者使用<code class="du kx ky kz la b">Stream.of()</code>并传递您的数据源，或者使用<code class="du kx ky kz la b">Stream.Builder()</code>。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><h1 id="dbd0" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">其他java.util APIs</h1><p id="f4ea" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">在<code class="du kx ky kz la b">java.util</code>包中增加了新的映射、集合和比较器接口。</p><p id="39e0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编写一个比较器并不难，但是需要大量的样板代码，在这些代码中你很容易出错。在Java 8中，可以使用简单的链式代码来编写比较器。在方法句柄和lambdas的帮助下，Java 8中的比较器看起来就像这样简单。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="ca45" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对<code class="du kx ky kz la b">java.util</code>包的另一个有趣的添加是可选类及其原始对应物<code class="du kx ky kz la b">OptionalInt</code>、<code class="du kx ky kz la b">OptionalLong</code>和<code class="du kx ky kz la b">OptionalDouble</code>。Optional帮助您使用实类型而不是空引用。可选的可以用“缺少值”来表示null。您可以使用实用程序方法将值处理为“可用”或“不可用”，而不是检查空值。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lp js l"/></div></figure><p id="33ea" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可选类有多种实用方法，如<code class="du kx ky kz la b">orElse()</code>、<code class="du kx ky kz la b">orElseThrow()</code>、<code class="du kx ky kz la b">filter()</code>等，帮助您轻松处理空检查和空情况。</p><h1 id="874c" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><code class="du kx ky kz la b">java.util.concurrent</code></h1><p id="d639" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">Java 8+还在<code class="du kx ky kz la b">java.util.concurrent.atomic</code>包中引入了关于<code class="du kx ky kz la b">AtomicInteger</code>、<code class="du kx ky kz la b">AtomicLong</code>和<code class="du kx ky kz la b">AtomicReference</code>的新方法。<code class="du kx ky kz la b">java.util.concurrent</code>包中的另一个更新是对<code class="du kx ky kz la b">ConcurrentHashMap</code>的错误修复，这是<code class="du kx ky kz la b">HashMap</code>的线程安全替代方案。<code class="du kx ky kz la b">ConcurrentHashMap</code>一直是安卓的一部分。然而，在API级别21和22上，实现有一个<a class="ae lr" href="https://bugs.openjdk.java.net/browse/JDK-8028564" rel="noopener ugc nofollow" target="_blank">错误</a>。一个新的固定实现是去糖库的一部分，通过库去糖，该实现将在你的应用中使用，代替平台中可能有bug的实现。</p><p id="4947" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您不熟悉<code class="du kx ky kz la b">ConcurrentHashMap</code>，这个类允许任意数量的线程执行get操作，但是对于update和insert操作，执行线程必须锁定数据被修改或插入的特定段。尽管任何线程都可以执行get操作，但是这个锁可能会阻止试图访问锁定段中的数据的get操作。由于同步，<code class="du kx ky kz la b">ConcurrentHashMap</code>的执行速度可能比<code class="du kx ky kz la b">HashMap</code>慢。</p><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/b2b021544bec773aba26112883e22467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cXFoTNUSRt0xceyntzWGyA.gif"/></div></div></figure><blockquote class="lt lu lv"><p id="50b5" class="ip iq lq ir b is it iu iv iw ix iy iz lw jb jc jd lx jf jg jh ly jj jk jl jm ha bi translated">请注意，在Android Studio 4.0中，不支持在测试中使用这些库去糖类型。</p></blockquote><p id="2685" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">升级您的项目以充分利用所有较新的Java语言API。Streams、Optionals和新的时间API帮助您在使用现代语言API时编写更少的代码和引入更少的错误。请务必查看受支持的Java 8+API的完整列表。</p><blockquote class="lt lu lv"><p id="4ee5" class="ip iq lq ir b is it iu iv iw ix iy iz lw jb jc jd lx jf jg jh ly jj jk jl jm ha bi translated"><em class="hs">本页内容和代码样本受</em> <a class="ae lr" href="https://developer.android.com/license" rel="noopener ugc nofollow" target="_blank"> <em class="hs">内容许可</em> </a> <em class="hs">中所述许可的约束。Java是Oracle和/或其附属公司的注册商标。</em></p></blockquote></div></div>    
</body>
</html>