<html>
<head>
<title>Behavioral Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">行为设计模式</h1>
<blockquote>原文：<a href="https://medium.com/globant/behavioral-design-pattern-7b082d98165c?source=collection_archive---------1-----------------------#2022-05-31">https://medium.com/globant/behavioral-design-pattern-7b082d98165c?source=collection_archive---------1-----------------------#2022-05-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="31c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">中介行为设计模式</strong></p><p id="3bf1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">设计模式和软件开发中需要:</strong> <br/> <strong class="ig hi"> <em class="jc">设计模式:</em> </strong></p><p id="bc94" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.设计模式用一个简单的术语来说:就是以模板或者描述的形式来解决不同情况下的问题。</p><p id="310b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.模式是问题在上下文中的循环解决方案。</p><p id="d3a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.Christopher Alexander的设计模式，一种模式语言</p><p id="cd8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">“每个模式描述了一个在我们的环境中反复出现的问题，然后描述了该问题解决方案的核心，<br/>以这样一种方式，您可以使用该解决方案一百万次，而不必以同样的方式做两次。”</p><p id="0d5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">四人帮(g of)设计模式:</em> </strong> <br/> 1。设计模式对于软件开发人员来说是一个非常强大的工具。<br/> 2。开发人员将模式用于他们的特定设计，以解决他们的问题。<br/>以下是23种设计模式，也称为四人帮(g of)设计模式:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/3fb6554ac03b3270f9ce70a8f3e3588a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*RoBTSjhBrNKiUNEOcAJeyg.jpeg"/></div></figure><p id="79ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">行为设计模式在。NET: </strong> <br/> 1。在软件工程中，通过识别通用的通信模式来实现软件对象间通信的灵活性。行为设计模式又名<strong class="ig hi"> <em class="jc">行为链</em> </strong> <br/> 3。优点:<br/> 1。它简化了软件对象之间的通信。这是对象之间进行通信的最佳方式。通过节省资源在特定的时间内服务特定的客户。</p><p id="0725" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">中介行为设计模式:</strong> <br/> <strong class="ig hi"> <em class="jc"> 1。意图:</em> </strong> <br/> 1。为了减少对象之间的混乱依赖，中介器是最好的行为设计模式<br/> 2。对象之间直接通信会受到限制，它们之间的协作只能通过中介对象进行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jl"><img src="../Images/621515c4bfe854ea29a7b91950c7fdcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rMaDDyN_jkmHaiVveY6T-w.png"/></div></div></figure><p id="027c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc"> 2。问题:</em> </strong> <br/>假设我们有一个创建和编辑客户档案的对话框。<br/>由各种表单控件组成，如文本字段、复选框、按钮等。</p><p id="27bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一些表单元素可能会与其他元素交互。为了前任。要提交表单，提交按钮必须在保存数据之前验证所有字段的值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jq"><img src="../Images/9bbec39f21271ede1cfad80a266c238a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnzgkenBU6WrQcgPYKQ0lg.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx"><em class="jv">Elements can have lots of relations with other elements. Hence, changes to some elements may affect the others.</em></figcaption></figure><p id="f0da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们将这种逻辑直接实现在表单元素的代码中，我们就不能在应用程序的其他表单中重用它们。</p><p id="072d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc"> 3。解决方案:</em> </strong> <br/>通过中介模式，组件必须通过调用一个特殊的中介对象来间接协作，这个中介对象将调用重定向到适当的组件。因此，组件只依赖于单个中介类。<br/>在我们的概要文件编辑表单的例子中，对话框类本身可以充当中介。最有可能的是，dialog类已经知道了它的所有子元素，所以你甚至不需要在这个类中引入新的依赖项。</p><p id="b35e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最显著的变化发生在实际的表单元素上。让我们考虑一下提交按钮。以前，每次用户单击按钮时，都必须验证所有单个表单元素的值。现在它唯一的工作就是通知对话框关于点击的信息。收到通知后，对话框本身执行验证，或者将任务传递给各个元素。</p><p id="6b0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，按钮只依赖于对话框类，而不是绑定到十几个表单元素。</p><p id="dad5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc"> 4。真实世界的Ex。:</em> </strong></p><p id="21c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接近或离开机场控制区的飞机飞行员之间不会直接交流。取而代之的是，他们与一名空中交通管制员通话，后者坐在飞机跑道附近的一座高塔上。如果没有空中交通管制员，飞行员将需要知道机场附近的每一架飞机，并与几十名其他飞行员组成的委员会讨论着陆的优先顺序。这可能会使飞机失事的统计数字暴涨。<br/> <br/>塔台不需要控制整个飞行。它的存在仅仅是为了加强终端区域的约束，因为那里涉及的参与者数量可能会超出飞行员的承受能力。</p><p id="9f21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc"> 5。伪代码:</em> </strong> <br/>为Ex。考虑到一般情况，主持会议的人必须学习每一种语言，并找到一种方法同时相互交流。这将是一个非常复杂的过程。但是，调解人模式有助于消除通话中不同人员之间的相互依赖性。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jw"><img src="../Images/5508f6709c2a59370abecf766abbdf41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5UukbtvWH9rjtUjrfMzag.png"/></div></div></figure><p id="81ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管电话中的不同参与者似乎在直接交流，但他们并没有。相反，参与者只需要检查字幕系统来理解消息，然后在不知道其他参与者使用的单词及其含义的情况下发言。</p><p id="e5e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由用户触发的元素不会直接与其他元素通信，即使它看起来应该这样做。相反，元素只需要让它的中介知道这个事件，传递任何上下文信息和通知。</p><pre class="je jf jg jh fd jx jy jz ka aw kb bi"><span id="0c33" class="kc kd hh jy b fi ke kf l kg kh"><em class="jc">// The mediator interface declares a method used by components to notify the mediator about various events. </em><br/>interface Mediator is<br/>    method notify(sender: Component, language: string)<br/><br/>// The concrete mediator class. <br/>class Chat implements Mediator is<br/>    private field message: string<br/>    private field speaker, listener: User<br/>    private field isLanguageAccepted: Checkbox<br/>    constructor Chat() is<br/>    // When something happens with a component, it notifies the mediator. Upon receiving a notification, the mediator may do something on its own or pass the request to another component.      <br/>    method notify(sender, language) is<br/>	// if the language is filled into the system and can be translated, then it will inform the mediator regarding this and accordingly proceed with translation.<br/><br/>// Components communicate with a mediator using the mediator interface. <br/>class Component is<br/>    field message: Mediator<br/>    constructor Component(message) is<br/>        this. message = message<br/>    method translate() is<br/>        <em class="jc">// check the language to be translated and change the message based on the translated value</em><br/><br/><em class="jc">// Concrete components don't talk to each other. They have only one communication channel, which is sending notifications to the mediator. So our concrete components A and B (different people) share their message with each other after it getting translated using the mediator.</em><br/>class User extends Component is<br/>    <em class="jc">// ...</em><br/>class Language extends Component is<br/>    <em class="jc">// ...</em><br/>class Checkbox extends Component is<br/>    <em class="jc">// ...</em></span></pre><p id="ab3f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc"> 6。利弊:</em> </strong> <br/> <strong class="ig hi"> <em class="jc"> 1。优点:</em> </strong> <br/> 1。单一责任原则。<br/>我们可以将各种组件之间的通信提取到一个单独的地方，这样更容易理解和维护。<br/>2.Open/Closed原理。<br/>我们可以在不改变实际组件的情况下引入新的介体。<br/> 3。我们可以减少程序各部分之间的耦合。<br/> 4。我们可以更容易地重用单个组件。</p><p id="7d81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">②<em class="jc">。缺点:</em> </strong> <br/>随着时间的推移，一个中介可以演变成一个God对象(是一个引用大量不同类型的对象，有太多不相关或未分类的方法，或者两者的某种组合。)</p></div></div>    
</body>
</html>