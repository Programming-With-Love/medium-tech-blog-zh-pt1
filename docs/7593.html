<html>
<head>
<title>React state management with Context and Reducers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用上下文和缩减器反应状态管理</h1>
<blockquote>原文：<a href="https://medium.com/version-1/react-state-management-with-context-and-reducers-7d70f812bd75?source=collection_archive---------0-----------------------#2022-09-13">https://medium.com/version-1/react-state-management-with-context-and-reducers-7d70f812bd75?source=collection_archive---------0-----------------------#2022-09-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8113" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">今天我想开始一系列关于React使用上下文的状态管理的文章。</p><p id="26ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这第一篇文章中，我想给你一个状态管理的概述，什么是React上下文以及它与外部状态管理器的比较。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/7e30025765fa314e3cec7d1b155b53d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dlAhovj-EXY4v4rVunJSsA.jpeg"/></div></div></figure><h1 id="89c6" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">概观</h1><p id="d66d" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">我很久以前就开始开发web应用程序了。一开始，一切都是服务器端的:PHP、ASP.NET等等。前端很少或没有JavaScript。然后我不得不添加越来越多的JavaScript，但是当应用变得复杂，我不得不处理跨不同浏览器和浏览器版本的DOM时…“哦，这真是一场噩梦！”😱</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es kr"><img src="../Images/4053bdf3c84480abc350dc331b4c76fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QYLpfL18UkE7_LRFly1TwQ.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx">Photo by <a class="ae kw" href="https://unsplash.com/@yogendras31?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Yogendra Singh</a> on <a class="ae kw" href="https://unsplash.com/s/photos/screaming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="150e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后jQuery出现了，一切都变了…“OMG这就是未来！”😍直到我不得不开发一个复杂的应用程序…😱</p><p id="c936" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我从Angular.js开始，再一次，“耶！这是游戏规则的改变！未来就是现在！!"😍直到我不得不开发另一个复杂的应用程序…😱</p><p id="0732" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我仍然在这个循环中，我怀疑它是无限的。当我在2017年开始使用React时，我又有了一个😍感觉是因为与我以前使用的相比，这在我的开发体验中是一个很大的改进。它被设计成一个用于构建ui的JavaScript库，使用基于状态的组件呈现的声明式风格。它非常擅长处理本地组件状态。它允许您使用普通JavaScript(或TypeScript)并导入任何JavaScript库。它没有规定一种方法来处理web应用程序的任何不同方面，比如全局状态。这个方面，<strong class="ig hi">状态管理</strong>，是前端开发中最难的一个。</p><p id="fa4b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们必须在浏览器中管理应用程序的状态。这个应用程序状态的一部分是纯UI状态，但其余部分通常只是服务器状态的缓存(可能来自数据库)。我们使用无状态协议，比如HTTP来获取服务器状态。所以，我们必须设法处理软件开发的另一个最困难的方面:<strong class="ig hi">缓存失效</strong>。</p><p id="d74f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这可能解释了为什么React有这么多的状态管理库:Redux、MobX、Apollo、React Query、SWR、反冲、Zustand等等。</p><p id="136f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我过去使用过Redux，我认为让它工作所需的样板文件和复杂性(我称之为“管道系统”)太多了，尤其是对新手来说。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es kx"><img src="../Images/f0d2e1a152cf838af0f517f34d9ead26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xWxXLxDVk7YOEZV7"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx">Photo by <a class="ae kw" href="https://unsplash.com/@spacexuan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Crystal Kwok</a> on <a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c140" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦管道到位，Redux开始工作，事情就简单多了。但随着应用程序的增长，你必须创建更多的reducers、actions、dispatch calls等。在你的编辑器的标签森林里有很多打开的文件。我认为我们应该简化这一点，就像我们通过使用像<em class="ky"> create-react-app </em>、<em class="ky"> NextJS </em>等应用构建器来简化全局配置和其他复杂方面一样。</p><p id="7b16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我想解释如何在没有任何外部库的情况下以简单的方式处理状态管理，使用内置的React上下文API和<em class="ky"> useContext </em>和<em class="ky"> useReducer </em>钩子。特别是，我将展示如何实现一个非常简单的有限状态机(FSM)来处理一部分全局状态。</p><h1 id="f8b5" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">目标</h1><p id="50ff" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">我的目标是回答以下问题:</p><ol class=""><li id="6fc8" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated">什么是反应上下文？</li><li id="c72a" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">何时使用外部状态管理器？</li><li id="5da8" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">如何用React上下文管理全局状态？</li><li id="9cb4" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">如何用上下文和<em class="ky"> useReducer </em>创建一个简单的有限状态机？</li></ol><h1 id="1fc6" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是反应上下文</h1><p id="eaa5" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">React Context“提供了一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性”。</p><p id="84ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基本上，它是一个可以从上下文提供者的子树中的任何组件与之交互的对象。因此，它需要一个具有默认上下文对象的提供程序，并且该提供程序的所有子级都可以使用该对象。由于这个对象允许我们在应用程序级别处理状态，我们可以说React有一个内置的状态管理机制；不需要安装外部库。</p><p id="174d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">适用于:</p><ul class=""><li id="d2b1" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb ln lf lg lh bi translated">缓慢移动的全局数据:主题、认证用户、偏好等。</li><li id="db7d" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb ln lf lg lh bi translated">当数据改变时，许多UI元素需要更新</li><li id="990f" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb ln lf lg lh bi translated">微前端:数据占用空间小</li></ul><h1 id="cb74" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">何时使用外部状态管理器</h1><p id="8b6f" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">有时使用许多状态管理库中的一个会更好。由于它们不是React的一部分，我们必须做一些研究。然后，我们应该尝试并评估其中的几个，并最终选择一个，我们从那一刻起就依赖于它。因此，重要的是所选择的库有一个广泛的社区来支持和维护它。</p><p id="f686" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">适用于:</p><ul class=""><li id="d5c4" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb ln lf lg lh bi translated">快速移动的数据。</li><li id="1ad4" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb ln lf lg lh bi translated">更大的应用，更复杂的状态</li><li id="415a" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb ln lf lg lh bi translated">标准很重要时的团队合作</li></ul><h1 id="534d" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">如何用React上下文管理全局状态</h1><p id="dd20" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">我们应该将全局状态分成更小的部分，并尽可能靠近使用它的组件来使用这些部分。根据依赖于这些子状态的特性，从逻辑上将全局状态划分为子状态。然后，将上下文放在尽可能靠近使用它的组件的地方。</p><p id="6aa9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用TypeScript对定义和维护状态也很有帮助。当您重构状态时，例如，通过重命名、更改函数签名、添加或移除元素，如果您犯了任何错误，TypeScript都会立即通知您。</p><h1 id="4eae" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">一个不那么简单的例子</h1><p id="90c8" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">由于我已经厌倦了基本的例子，我想向您展示一个中等复杂度的状态管理例子。假设我们想要使用React上下文和TypeScript管理当前登录用户的状态。该状态将包含:</p><ul class=""><li id="dbb1" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb ln lf lg lh bi translated">用户资料:名/姓，电子邮件，设置等。在登录前和注销后将为空。</li><li id="2fbc" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb ln lf lg lh bi translated">用户功能:<br/> <code class="du lo lp lq lr b">login<br/>logout<br/>acceptTermsAndConditions<br/>updateUserProfile</code></li></ul><p id="d271" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些函数将处理用户配置文件，因此我们不必在使用该配置文件的组件中担心它。我们不必直接修改用户配置文件。所以，我们来定义一下:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="efe7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们定义上下文本身，它包括用户配置文件和功能:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="6fc4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，如果我们想要改变一个用户设置，我们用新的设置调用<em class="ky"> updateUserProfile </em>，并且<em class="ky"> userProfile </em>将被更新(并且可能我们将调用API在服务器端更新它)。那么所有使用上下文提供者中概要文件的组件都将被呈现。这一点很重要，因为如果受影响的组件树非常大，将会发生大量的组件渲染，可能会降低应用程序的速度。稍后我们将看到如何通过记忆上下文对象来部分缓解这个问题。</p><p id="c7c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们使用上面的接口创建上下文对象。我们需要传递这个对象的初始值，所以我们传递null作为<em class="ky"> userProfile </em>来表示用户没有登录:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="66aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将创建一个定制的钩子来帮助组件使用这个上下文。它将检查它是从上下文提供程序内部调用的(从相应的提供程序外部使用上下文是一个常见的错误):</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="8d8e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，假设我们需要一个组件来显示用户的电子邮件，如果用户已经登录，需要一个按钮来注销，否则需要一个到登录页面的链接；我们只需导入这个<em class="ky"> useCurrentUser </em>钩子，并分解用户配置文件和<em class="ky">注销</em>函数:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="8c8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，这个组件应该在上下文提供者内部，否则会抛出一个错误，并且组件不会被呈现。</p><p id="14b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看如何为提供者创建一个包装器，它应该尽可能地放在需要的地方:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="956f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如你所见，我们正在记忆<em class="ky"> UserContext </em>以避免在提供者级别不必要的渲染。我们稍后将添加“TODO”逻辑。</p><p id="1855" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们将把这个提供者放在离需要它的地方尽可能近的地方。假设我们只在用户页面需要它。我们可以像这样使用这个上下文提供程序:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="8ee4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，在组件<em class="ky"> UserContactInfo </em>、<em class="ky"> UserSettings </em>和<em class="ky"> UserAccount </em>中，我们可以使用带有<em class="ky"> useCurrentUser </em>的上下文，如下所述(参见<em class="ky">componentsusingusercontext</em>):</p><pre class="jd je jf jg fd lu lr lv lw aw lx bi"><span id="f8b0" class="ly jp hh lr b fi lz ma l mb mc">const { /* objects and functions you need */ } = useCurrentUser();</span></pre><p id="a7ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，让我们看看如何在提供者中实现剩余的逻辑(在<em class="ky"> CurrentUserProvider </em>中的“TODO”部分):</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="1840" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如你所见，我们可以通过实现<em class="ky"> useAnyUserAPI </em>定制钩子来使用任何API调用机制(fetch，Axios…)。然后，我们必须处理使用效果中的响应:</p><ul class=""><li id="a0ac" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb ln lf lg lh bi translated">在第一个useEffect中，当从API成功接收时，我们设置用户配置文件。</li><li id="1f79" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb ln lf lg lh bi translated">在第二个useEffect中，在成功的API调用注销后，我们将用户配置文件设置为null。</li><li id="925e" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb ln lf lg lh bi translated">在第三个useEffect中，当API调用OK时，我们只设置<em class="ky"> termsAccepted </em>的值；其余的用户资料道具保持不变。</li></ul><p id="1138" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这些情况下，以及当调用updateUserProfile时，所有依赖于UserProfile的组件都将使用更新后的配置文件重新呈现。这些useEffects通过更新配置文件来处理对API端点的成功调用(<em class="ky">登录、注销、acceptermsandconditions</em>)。在生产应用程序中，我们也应该处理错误响应。为此，我们可以在上下文中添加错误属性，这样，当组件进行API调用时，它可以检查错误，并可能显示一条消息或toast通知。此外，我们可能会添加一些功能，以便在通知用户后清除错误。</p><p id="e1ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如下所述，API调用逻辑是在自定义钩子<em class="ky"> useAnyUserAPI </em>中实现的，在这里你可以使用fetch、Axios或任何其他库，所以我们的上下文不依赖于此。您可以在补充本文的代码中找到使用Axios的实现(在本系列的最后一篇文章中)。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es md"><img src="../Images/579815964f5cd909f47b623450b193a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bbvMNt9odIizQFoIw0Vr5A.jpeg"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx">Photo by <a class="ae kw" href="https://unsplash.com/@sapegin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Artem Sapegin</a> on <a class="ae kw" href="https://unsplash.com/s/photos/react-context?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6734" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们有了所有的用户状态和逻辑，可以在应用程序的任何地方使用。在下一篇文章中，我们将看到如何测试它！</p><h1 id="83c0" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">关于作者:</h1><p id="5819" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">路易斯·卡纳斯是Version 1的高级软件工程师。</p></div></div>    
</body>
</html>