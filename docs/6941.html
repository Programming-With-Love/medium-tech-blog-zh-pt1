<html>
<head>
<title>Dutch Flag Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">荷兰国旗算法</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/dutch-flag-algorithm-3669af2b14fd?source=collection_archive---------0-----------------------#2020-12-29">https://medium.com/quick-code/dutch-flag-algorithm-3669af2b14fd?source=collection_archive---------0-----------------------#2020-12-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><h2 id="e4c1" class="hf hg hh bd b fp hi hj hk hl hm hn dx ho translated" aria-label="kicker paragraph">让我们来回答第三个问题</h2><div class=""/><p id="c40d" class="pw-post-body-paragraph in io hh ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk ha bi translated">荷兰国旗算法简介。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jl"><img src="../Images/72ee3a52432268da75001a4aee124ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AJhDDIN2ykUfZd5c"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx">Photo by <a class="ae kb" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="67e9" class="pw-post-body-paragraph in io hh ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk ha bi translated">荷兰旗算法(DFA)是数组最基本也是最重要的算法之一。它用于分离一个由线性时间复杂度的3个数组成的数组。</p><p id="f985" class="pw-post-body-paragraph in io hh ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk ha bi translated">DFA最坏的时间复杂度是O(n ),算法的空间复杂度是O(1)。问题陈述如下:</p><blockquote class="kc kd ke"><p id="38b5" class="in io kf ip b iq ir is it iu iv iw ix kg iz ja jb kh jd je jf ki jh ji jj jk ha bi translated">向您提供一个由0、1和2组成的数组。任务是编写一个函数，将所有的数字分离在一起。顺序可以是任何东西。</p></blockquote><p id="fd8e" class="pw-post-body-paragraph in io hh ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk ha bi translated">让我们假设提供的数组A是<br/> A = [1，2，0，1，2，0，1，2，0] <br/>，期望的输出是<br/> A = [2，2，2，0，0，0，1，1]</p><p id="52d5" class="pw-post-body-paragraph in io hh ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk ha bi translated">要解决这个问题，我们需要首先选择订单。对于本例，我们选择2，1，0。<br/>现在我们需要3个指针，分别是<strong class="ip hr"> start，end，</strong>和<strong class="ip hr"> P </strong>，指向数组的三个不同的索引。</p><p id="e7d1" class="pw-post-body-paragraph in io hh ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk ha bi translated"><strong class="ip hr">开始</strong>将表示中间元素的第一个索引，即这里的0。<strong class="ip hr">端</strong>将表示中间元素的最后一个索引，指针<strong class="ip hr"> P </strong>将用于遍历数组。</p><p id="8dc1" class="pw-post-body-paragraph in io hh ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk ha bi translated">当<strong class="ip hr"> P </strong>不等于<strong class="ip hr"> End时，循环将运行。</strong>当P遍历时，如果P遇到2，它将与<strong class="ip hr"> start </strong>交换并递增start。同样，如果P遇到1，它将与end交换，并递减end。代码如下:-</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="kj kk l"/></div></figure><p id="ba25" class="pw-post-body-paragraph in io hh ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk ha bi translated">为了更好地理解该算法，在纸上写下堆栈跟踪，并确保完成所有步骤。</p><p id="4d38" class="pw-post-body-paragraph in io hh ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk ha bi translated">如果您有任何疑问，或者希望我介绍任何其他算法，请随意评论这篇文章。</p><p id="13d6" class="pw-post-body-paragraph in io hh ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk ha bi translated">请继续关注更多这样的算法和概念。</p></div></div>    
</body>
</html>