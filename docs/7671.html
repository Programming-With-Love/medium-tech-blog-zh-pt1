<html>
<head>
<title>Increase your code coverage using Istanbul</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用伊斯坦布尔增加您的代码覆盖率</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/do-you-have-100-code-coverage-10c09a44832b?source=collection_archive---------1-----------------------#2017-03-12">https://medium.com/walmartglobaltech/do-you-have-100-code-coverage-10c09a44832b?source=collection_archive---------1-----------------------#2017-03-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="er es hf"><img src="../Images/d9593d898fe8d6ae41b7d8a8bc6b0d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*jHOlC9JcbLJBREioa7kLog.png"/></div><figcaption class="hm hn et er es ho hp bd b be z dx"><a class="ae hq" href="https://pixabay.com/en/code-code-editor-coding-computer-1839406/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/en/code-code-editor-coding-computer-1839406/</a></figcaption></figure><div class=""/><p id="5fcf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">很多时候，我们谈论我们的项目有100%的代码覆盖率。事实是，拥有100%的代码覆盖率是我们代码库的一颗闪亮的星星，但是对于一个过去覆盖率不是最高优先级的现有代码库来说，这是非常困难的。原因很简单:当你不以‘可测试’的方式编写代码时，你不能为你的代码编写单元测试，这意味着，你不能有100%的覆盖率。</p><p id="b4fd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">获得100%覆盖率的最好方法是在开发代码时不断评估覆盖率。在测试驱动开发(TDD)中，覆盖率伴随着努力而来。然而，在非TDD中，您需要非常小心地计算覆盖率。</p><p id="073d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在我们继续之前，请注意我不是100%覆盖率的执行者，但是朝着那个目标前进通常会启发我们代码中的许多隐藏流，否则我们可能会跳过测试。</p><h2 id="01ea" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><strong class="ak">工具</strong>:</h2><p id="7333" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn ha bi translated">因为我最近一直在使用NodeJS，所以我要谈谈最流行的代码覆盖工具之一，<code class="du ko kp kq kr b"><a class="ae hq" href="https://www.npmjs.com/package/istanbul" rel="noopener ugc nofollow" target="_blank">istanbul</a></code>。假设您可以从伊斯坦布尔自己的<a class="ae hq" href="https://github.com/gotwarlost/istanbul" rel="noopener ugc nofollow" target="_blank">文档</a>中获得伊斯坦布尔的基础知识，我将介绍一些使用伊斯坦布尔来增加现有项目覆盖面的技术。</p><p id="7410" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">伊斯坦布尔提出了一些体面的html报告，可以用来找到没有涵盖的代码。</p><h2 id="a423" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki bi translated"><strong class="ak">要记住的事情</strong>:</h2><ol class=""><li id="569c" class="ks kt ht is b it kj ix kk jb ku jf kv jj kw jn kx ky kz la bi translated">一段代码必须是可测试的。如果一个可导出的模块包含一个函数，它应该以一种可以从外部注入数据的方式被创建，这样一个测试就可以发送数据并在期望的输出上断言。举个例子，</li></ol><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="9ce4" class="jo jp ht kr b fi lj lk l ll lm">//example module index.js<br/>module.exports = {<br/>  add: <strong class="kr hu">function</strong>(x, y){<br/>      <strong class="kr hu">return </strong>x + y;<br/>  }<br/>}</span><span id="6eea" class="jo jp ht kr b fi ln lk l ll lm">//example test<br/>describe(<strong class="kr hu">'Index'</strong>, <strong class="kr hu">function</strong>(){<br/>    <em class="lo">it</em>(<strong class="kr hu">'should add 2 and 3 to give 5'</strong>, <strong class="kr hu">function</strong>(){<br/>        expect(<strong class="kr hu">index</strong>.add(2, 3)).<strong class="kr hu">to</strong>.be.equal(5);<br/>    });<br/>});</span><span id="5210" class="jo jp ht kr b fi ln lk l ll lm">//code coverage<br/>Statements   : 100% ( 4/4 )<br/>Branches     : 100% ( 0/0 )<br/>Functions    : 100% ( 1/1 )<br/>Lines        : 100% ( 4/4 )</span></pre><p id="1290" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">2.<strong class="is hu">条件语句</strong>:这些对于分支覆盖很重要。在下面的例子中，覆盖率被删除，因为测试用例没有覆盖条件语句。</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="dd50" class="jo jp ht kr b fi lj lk l ll lm">add2: <strong class="kr hu">function</strong>(x, y){<br/>    <strong class="kr hu">if </strong>(x &amp;&amp; y){<br/>        <strong class="kr hu">return </strong>x + y;<br/>    } <strong class="kr hu">else </strong>{<br/>        <strong class="kr hu">return null</strong>;<br/>    }<br/>}</span><span id="ae1d" class="jo jp ht kr b fi ln lk l ll lm">//test<br/><strong class="kr hu"><em class="lo">it</em></strong>(<strong class="kr hu">'should add 2 and 3 to give 5'</strong>, <strong class="kr hu">function</strong>(){<br/>    expect(<strong class="kr hu">index</strong>.add2(2, 3)).to.be.equal(5);<br/>});</span><span id="fd2f" class="jo jp ht kr b fi ln lk l ll lm">//code coverage<br/>Statements   : 85.71% ( 6/7 )<br/>Branches     : 75% ( 3/4 )<br/>Functions    : 100% ( 2/2 )<br/>Lines        : 85.71% ( 6/7 )</span></pre><p id="36c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">通过为else条件添加一个测试用例来修复它:</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="8f49" class="jo jp ht kr b fi lj lk l ll lm"><strong class="kr hu"><em class="lo">it</em></strong>(<strong class="kr hu">'should return a value based on conditions'</strong>, <strong class="kr hu">function</strong>(){<br/>    expect(<strong class="kr hu">index</strong>.add2(2, 3)).to.be.equal(5);<br/>});<br/><strong class="kr hu"><em class="lo">it</em></strong>(<strong class="kr hu">'should return null when no value is passed'</strong>, <strong class="kr hu">function</strong>(){<br/>    expect(<strong class="kr hu">index</strong>.add2()).to.be.null;<br/>});</span><span id="f734" class="jo jp ht kr b fi ln lk l ll lm">//code coverage<br/>Statements   : 100% ( 10/10 )<br/>Branches     : 100% ( 4/4 )<br/>Functions    : 100% ( 3/3 )<br/>Lines        : 100% ( 10/10 )</span></pre><p id="dc5e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">另一个例子是图片中的物体。通常我们使用“短路”评估来设置默认值，但是它也需要被测试来完成覆盖。</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="0704" class="jo jp ht kr b fi lj lk l ll lm">doSomething: <strong class="kr hu">function </strong>(y) {<br/>    <strong class="kr hu">var </strong>x = y || {};  // assign x as y or an empty object<br/>    <strong class="kr hu">return </strong>x.val;     <br/><br/>}<br/>//example test</span><span id="04bd" class="jo jp ht kr b fi ln lk l ll lm"><em class="lo">it</em>(<strong class="kr hu">'should return expected value '</strong>, <strong class="kr hu">function</strong>(){<br/>    expect(<strong class="kr hu">index</strong>.doSomething({<strong class="kr hu">val</strong>: 2 })).to.be.equal(2);<br/>});<br/><strong class="kr hu"><em class="lo">it</em></strong>(<strong class="kr hu">'should return expected value '</strong>, <strong class="kr hu">function</strong>(){<br/>    expect(<strong class="kr hu">index</strong>.doSomething()).to.be.undefined;<br/>});<br/>//code coverage<br/>Statements   : 100% ( 12/12 )<br/>Branches     : 100% ( 6/6 )<br/>Functions    : 100% ( 4/4 )<br/>Lines        : 100% ( 12/12 )</span></pre><p id="4ab8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在有点复杂的功能。</p><p id="9b29" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hu"> 3。异步操作和条件:</strong>考虑一个简单的读取文件的例子:</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="5c8f" class="jo jp ht kr b fi lj lk l ll lm">readStatus: <strong class="kr hu">function</strong>(fileName, callback){<br/>  fs.readFile(path.join(__dirname , fileName),<strong class="kr hu">'utf-8'</strong>,(<strong class="kr hu">err</strong>, <strong class="kr hu">data</strong>) =&gt;   {<br/>        <strong class="kr hu">if</strong>(err) callback(err);<br/>        <strong class="kr hu">if </strong>(<strong class="kr hu">data</strong>.length &gt; 0 ) {<br/>         <strong class="kr hu">return </strong>callback(<strong class="kr hu">null</strong>, <strong class="kr hu">data</strong>)<br/>        }<br/>  });<br/>}</span><span id="00fe" class="jo jp ht kr b fi ln lk l ll lm">//test<br/>it(<strong class="kr hu">'should read the data from the test file  '</strong>, <strong class="kr hu">function</strong>(done){<br/>    <strong class="kr hu">index</strong>.readStatus(<strong class="kr hu">'test.json'</strong>, (err, data) =&gt; {<br/>        expect(data).to.<em class="lo">equal</em>(<strong class="kr hu">'this is a test file'</strong>)<br/>        done();<br/>    });<br/>});</span><span id="e825" class="jo jp ht kr b fi ln lk l ll lm">//coverage<br/>Statements   : 94.44% ( 17/18 )<br/>Branches     : 80% ( 8/10 )<br/>Functions    : 100% ( 5/5 )<br/>Lines        : 100% ( 17/17 )</span></pre><p id="d70c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">请注意，尽管我们有一个测试，但是语句和分支的覆盖率已经显著下降。评估伊斯坦布尔创建的报告，您会看到这样的内容:</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es lp"><img src="../Images/fe4a33f04e1cfd2b2a48098c0dc80f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cSxJj__nu6bkvHDz3lp9Yg.png"/></div></div></figure><p id="f169" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">显然，错误场景没有被涵盖。“<strong class="is hu"> I </strong>”和“<strong class="is hu"> E </strong>”字母表示语句不包含if-else条件，因此分支覆盖范围缩小。为了解决这个问题，让我们创建一个包含错误条件的测试。</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="6294" class="jo jp ht kr b fi lj lk l ll lm">it(<strong class="kr hu">'should throw an error if the file is not read  '</strong>, <strong class="kr hu">function</strong>(done){<br/>    <strong class="kr hu">index</strong>.readStatus(<strong class="kr hu">'notexist'</strong>, (err, data) =&gt; {<br/>        expect(err).with.deep.property(<strong class="kr hu">'code'</strong>).to.<em class="lo">equal</em>(<strong class="kr hu">'ENOENT'</strong>)<br/>        expect(data).to.be.<strong class="kr hu">undefined</strong>;<br/>        done();<br/>    });<br/>});</span><span id="7268" class="jo jp ht kr b fi ln lk l ll lm">//coverage<br/>Statements   : 100% ( 18/18 )<br/>Branches     : 90% ( 9/10 )<br/>Functions    : 100% ( 5/5 )<br/>Lines        : 100% ( 17/17 )</span></pre><p id="52b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">因此，上述报表的覆盖率有所增加，但分行的覆盖率仍为90%。这是因为，<code class="du ko kp kq kr b">if(data.length &gt; 0)</code>的<code class="du ko kp kq kr b">else</code>部分还没有被测试。让我们为此创建一个测试。然而，在我们的测试函数中有一个缺陷。如果找到了文件，但是数据是空的，那么在回调中不返回任何东西。<code class="du ko kp kq kr b">data.length</code>是≤0。因此，我们需要首先修复函数:</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="de74" class="jo jp ht kr b fi lj lk l ll lm">readStatus: <strong class="kr hu">function</strong>(fileName, callback){<br/>    fs.readFile(path.join(__dirname , fileName), <strong class="kr hu">'utf-8'</strong>, (<strong class="kr hu">err</strong>, <strong class="kr hu">data</strong>) =&gt; {<br/>        <strong class="kr hu">if</strong>(err) callback(err);<br/>    <strong class="kr hu">if </strong>(<strong class="kr hu">data</strong>.length &gt; 0 ) {<br/>        <strong class="kr hu">return </strong>callback(<strong class="kr hu">null</strong>, <strong class="kr hu">data</strong>)<br/>    } <strong class="kr hu">else </strong>{<br/>        <strong class="kr hu">return </strong>callback(<strong class="kr hu">null</strong>, <strong class="kr hu">null</strong>)<br/>    }<br/>  });<br/>}</span></pre><p id="2716" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在测试变成了:</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="fab0" class="jo jp ht kr b fi lj lk l ll lm">it(<strong class="kr hu">'should return undefined when file exists but no data is present '</strong>, <strong class="kr hu">function</strong>(done){<br/>    <strong class="kr hu">index</strong>.readStatus(<strong class="kr hu">'test_empty.json'</strong>, (err, data) =&gt; {<br/>        expect(err).to.be.<strong class="kr hu">null</strong>;<br/>        expect(data).to.be.<strong class="kr hu">null</strong>;<br/>        done();<br/>    });<br/>});</span><span id="a1f0" class="jo jp ht kr b fi ln lk l ll lm">//coverage<br/>Statements   : 100% ( 19/19 )<br/>Branches     : 100% ( 10/10 )<br/>Functions    : 100% ( 5/5 )<br/>Lines        : 100% ( 18/18 )</span></pre><p id="0475" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">API测试覆盖范围的示例:</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="d8ae" class="jo jp ht kr b fi lj lk l ll lm">// a simple app<br/><strong class="kr hu">var </strong>express = require(<strong class="kr hu">'express'</strong>);<br/><strong class="kr hu">var </strong>app = express();<br/><br/><strong class="kr hu">var </strong>people = [<br/>    {<br/>        <strong class="kr hu">name</strong>: <strong class="kr hu">'John Doe'<br/>    </strong>},<br/>    {<br/>        <strong class="kr hu">name</strong>: <strong class="kr hu">'Jane Doe'<br/>    </strong>},<br/>    {<br/>        <strong class="kr hu">name</strong>: <strong class="kr hu">'Jim Doe'<br/>    </strong>}<br/>]<br/><br/>app.use(<strong class="kr hu">'/assets'</strong>, express.static(__dirname + <strong class="kr hu">'/public'</strong>));<br/>app.get(<strong class="kr hu">'/people'</strong>, <strong class="kr hu">function</strong>(req, res){<br/>    res.send(people);<br/>});<br/><br/><strong class="kr hu">var </strong>server = app.listen(3000);<br/>module.exports = server;</span></pre><p id="7886" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">相应测试</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="4ad2" class="jo jp ht kr b fi lj lk l ll lm"><strong class="kr hu">var </strong>expect = require(<strong class="kr hu">'chai'</strong>).expect;<br/><strong class="kr hu">var </strong>request = require(<strong class="kr hu">'supertest'</strong>);<br/><br/>describe(<strong class="kr hu">'app'</strong>, <strong class="kr hu">function</strong>(){<br/>    <strong class="kr hu">var </strong>server;<br/>    <strong class="kr hu">beforeEach</strong>(<strong class="kr hu">function</strong>(){<br/>        server = require(<strong class="kr hu">'../app'</strong>);<br/>    });<br/>    <strong class="kr hu">afterEach</strong>(<strong class="kr hu">function </strong>() {<br/>        server.close();<br/>    });<br/>    it(<strong class="kr hu">'should respond with status code 200'</strong>, <strong class="kr hu">function</strong>(done){<br/>        request(server)<br/>            .get(<strong class="kr hu">'/people'</strong>)<br/>            .expect(200)<br/>            .end((<strong class="kr hu">err</strong>, res) =&gt; {<br/>               expect(res.body).to.be.an(<strong class="kr hu">'array'</strong>);<br/>               done();<br/>            });<br/><br/>        })<br/>})</span><span id="f728" class="jo jp ht kr b fi ln lk l ll lm">//<br/>Statements   : 100% ( 9/9 )<br/>Branches     : 100% ( 0/0 )<br/>Functions    : 100% ( 1/1 )<br/>Lines        : 100% ( 9/9 )</span></pre><p id="7f98" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hu"> 4。带条件的异步操作:</strong>考虑以下api</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="d814" class="jo jp ht kr b fi lj lk l ll lm">app.get(<strong class="kr hu">'/api/todos/:uname'</strong>, <strong class="kr hu">function</strong>(req, res, next){<br/>    Todos.find({<strong class="kr hu">username</strong>: req.<strong class="kr hu">params</strong>.uname}, <strong class="kr hu">function</strong>(err, results){<br/>       <strong class="kr hu">if</strong>(err) {<br/>            next(err)<br/>        }<strong class="kr hu">else</strong>{<br/>           res.send(results);<br/>       }<br/>    });<br/>});</span></pre><p id="f302" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">相应的测试:</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="9ba5" class="jo jp ht kr b fi lj lk l ll lm">it(<strong class="kr hu">'should respond successfully to /api/todos for a username'</strong>, <strong class="kr hu">function</strong>(done){<br/>    request(server)<br/>        .get(<strong class="kr hu">'/api/todos/test'</strong>)<br/>        .expect(200)<br/>        .end(<strong class="kr hu">function</strong>(req, res) {<br/>            expect(res.<strong class="kr hu">body</strong>).to.be.an(<strong class="kr hu">'array'</strong>);<br/>            done();<br/>        });<br/>});<br/>//coverage<br/>Statements   : 97.06% ( 33/34 )<br/>Branches     : 75% ( 3/4 )<br/>Functions    : 100% ( 5/5 )<br/>Lines        : 97.06% ( 33/34 )</span></pre><p id="db3d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">覆盖率下降是因为我们还没有检查错误情况。</p><figure class="lb lc ld le fd hj er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es lu"><img src="../Images/b5cdbe0db1590f2c0e38836e9f1dc95b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pSgaje1Sl3CgH3PBswOzcA.png"/></div></div></figure><h1 id="46d4" class="lv jp ht bd jq lw lx ly ju lz ma mb jy mc md me kb mf mg mh ke mi mj mk kh ml bi translated"><strong class="ak">引入存根</strong></h1><p id="2123" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn ha bi translated">存根或模拟在单元测试中起着非常重要的作用。当您不知道如何在正常场景中遇到错误情况时，您需要使用一个存根，基本上是原始函数的模拟，但它在您的控制之下。您可以强制这个函数以您想要的方式抛出一个错误。</p><p id="2ba8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">回到上面的场景，我们需要覆盖用粉色突出显示的错误条件。<code class="du ko kp kq kr b">sinon</code>是Node中一个流行的库，可用于此目的。</p><p id="d583" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我们创建了一个<code class="du ko kp kq kr b">Error</code>的对象，并将其传递给stub，作为在<code class="du ko kp kq kr b">Todos</code>上从<code class="du ko kp kq kr b">find</code>方法回调的结果。注意，我们为此使用了<code class="du ko kp kq kr b">sinon.stub</code>上的<code class="du ko kp kq kr b">yields</code> API。<code class="du ko kp kq kr b">yields</code>获取调用回调时应该使用的参数列表。</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="1c7a" class="jo jp ht kr b fi lj lk l ll lm"><br/>it(<strong class="kr hu">'should throw an error when any kind of error is encountered'</strong>, <strong class="kr hu">function</strong>(done){<br/>    <strong class="kr hu">var </strong>stub = sinon.stub(Todos, <strong class="kr hu">'find'</strong>);<br/>    <strong class="kr hu">var </strong>expectedError = <strong class="kr hu">new </strong>Error(<strong class="kr hu">'oops'</strong>);<br/>    stub.yields(expectedError);<br/><br/>    request(server)<br/>      .get(<strong class="kr hu">'/api/todos/test'</strong>)<br/>      .expect(<strong class="kr hu">function</strong>(res){<br/>        expect(res.error).to.have.deep.property(<strong class="kr hu">'text'</strong>).to.contain(<strong class="kr hu">'oops'</strong>)<br/>        })<br/>      .end(done);<br/>});</span></pre><p id="6d74" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">因此，我们完整的测试套件如下所示:</p><pre class="lb lc ld le fd lf kr lg lh aw li bi"><span id="8761" class="jo jp ht kr b fi lj lk l ll lm"><strong class="kr hu">var </strong>expect = require(<strong class="kr hu">'chai'</strong>).expect;<br/><strong class="kr hu">var </strong>request = require(<strong class="kr hu">'supertest'</strong>);<br/><strong class="kr hu">var </strong>sinon = require(<strong class="kr hu">'sinon'</strong>);<br/><strong class="kr hu">var </strong>Todos = require(<strong class="kr hu">'../models/todomodel'</strong>);<br/><strong class="kr hu">var </strong>AssertionError = require(<strong class="kr hu">"assert"</strong>).<strong class="kr hu">AssertionError</strong>;<br/><br/>describe(<strong class="kr hu">'main app'</strong>, <strong class="kr hu">function</strong>(){<br/>    <strong class="kr hu">var </strong>server;<br/>    <strong class="kr hu">beforeEach</strong>(<strong class="kr hu">function</strong>(){<br/>        server = require(<strong class="kr hu">'../app'</strong>);<br/>    });<br/>    <strong class="kr hu">afterEach</strong>(<strong class="kr hu">function </strong>() {<br/>        server.close();<br/>    });<br/>    it(<strong class="kr hu">'should respond successfully to /api/todos for a username'</strong>, <strong class="kr hu">function</strong>(done){<br/>        request(server)<br/>            .get(<strong class="kr hu">'/api/todos/test'</strong>)<br/>            .expect(200)<br/>            .end(<strong class="kr hu">function</strong>(req, res) {<br/>                expect(res.<strong class="kr hu">body</strong>).to.be.an(<strong class="kr hu">'array'</strong>);<br/>                done();<br/>            });<br/>    });<br/><br/>    it(<strong class="kr hu">'should throw an error when any kind of error is encountered'</strong>, <strong class="kr hu">function</strong>(done){<br/>        <strong class="kr hu">var </strong>stub = sinon.stub(Todos, <strong class="kr hu">'find'</strong>);<br/>        <strong class="kr hu">var </strong>expectedError = <strong class="kr hu">new </strong>Error(<strong class="kr hu">'oops'</strong>);<br/>        stub.yields(expectedError);<br/><br/>        request(server)<br/>            .get(<strong class="kr hu">'/api/todos/test'</strong>)<br/>            .expect(500)<br/>            .expect(<strong class="kr hu">function</strong>(res){<br/>             expect(res.error).to.have.deep.property(<strong class="kr hu">'text'</strong>).to.contain(<strong class="kr hu">'oops'</strong>)<br/>            })<br/>            .end(done);<br/>    });<br/><br/>});</span><span id="8392" class="jo jp ht kr b fi ln lk l ll lm">/coverage<br/>Statements   : 100% ( 34/34 )<br/>Branches     : 100% ( 4/4 )<br/>Functions    : 100% ( 5/5 )<br/>Lines        : 100% ( 34/34 )</span></pre><h1 id="fd04" class="lv jp ht bd jq lw lx ly ju lz ma mb jy mc md me kb mf mg mh ke mi mj mk kh ml bi translated">总结:</h1><p id="5759" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn ha bi translated">一个100%覆盖率的代码库给你的代码提供了一个保护盾，防止一些不可预见的错误。尽管有些错误没有意义，但是100%覆盖代码的努力会让你经历某些场景，否则你可能不会经历。这就产生了一个可靠的软件产品，您可以对它充满信心。</p><p id="9b2d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hu">有用资源:</strong></p><div class="hg hh ez fb hi mm"><a href="http://jstest.jcoglan.com/mocking.html" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hu fi z dy mr ea eb ms ed ef hs bi translated">jstest</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">在创建模拟时，您可以使用上面显示的整个存根API，唯一的区别是如果您使用expect(…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">jstest.jcoglan.com</p></div></div></div></a></div><div class="hg hh ez fb hi mm"><a href="https://martinfowler.com/bliki/TestCoverage.html" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab dw"><div class="mo ab mp cl cj mq"><h2 class="bd hu fi z dy mr ea eb ms ed ef hs bi translated">bliki:测试覆盖率</h2><div class="mt l"><h3 class="bd b fi z dy mr ea eb ms ed ef dx translated">标签:我不时听到有人问他们应该以什么样的测试覆盖率(也称为代码覆盖率)为目标…</h3></div><div class="mu l"><p class="bd b fp z dy mr ea eb ms ed ef dx translated">martinfowler.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na hk mm"/></div></div></a></div></div></div>    
</body>
</html>