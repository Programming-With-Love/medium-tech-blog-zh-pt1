<html>
<head>
<title>Transitioning Legacy Applications with storage requirements into containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将具有存储需求的传统应用程序转移到容器中</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/transitioning-legacy-applications-with-storage-requirements-into-containers-6d2bd333e88f?source=collection_archive---------5-----------------------#2020-05-20">https://medium.com/walmartglobaltech/transitioning-legacy-applications-with-storage-requirements-into-containers-6d2bd333e88f?source=collection_archive---------5-----------------------#2020-05-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="aa19" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将遗留应用程序转移到容器中</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/c77737c4323f53209bf54cc56662c0be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TmRW2xXM3JEuB2Vp5LwHRQ.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">photo credit: <a class="ae js" href="https://pixabay.com/images/id-449784/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/images/id-449784/</a></figcaption></figure></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><p id="cd74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi ka translated"><span class="l kb kc kd bm ke kf kg kh ki di"> B </span> <strong class="ig hi">背景</strong> <br/>给个背景，我们现在的基础设施和应用程序设置都是在传统平台上。我们通常在tomcat或jetty中部署java应用程序，并在虚拟机上运行。然后，我们也有这些配置文件或我们称之为模型文件，它们驻留在NFS服务器上</p><p id="3866" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一步是创建一个docker图像。我们已经创建了基本的java和jetty映像。现在，它只是添加部署我们的应用程序的指令，包括将代码工件和数据模型复制到jetty“web apps”目录中的步骤。</p><p id="384f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里的一个重要目标是利用自动扩展功能。主要关注点是保持容器启动时间最短，以减少容器转换到就绪状态所需的时间。<br/>尽管不推荐，我们仍然决定在构建期间复制代码和数据模型，并让容器在启动时将它们加载到内存中。</p><h1 id="9481" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">结果</strong></h1><p id="a39e" class="pw-post-body-paragraph ie if hh ig b ih lh ij ik il li in io ip lj ir is it lk iv iw ix ll iz ja jb ha bi translated">创建了一个大小为9.8GB的docker映像。<br/>开机时间为<strong class="ig hi">8分钟</strong>。</p><p id="69bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图像的巨大尺寸是任何标准都无法接受的，这直接导致我们的应用程序无法被封装和部署到k8s中。</p><h1 id="61c2" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">分析</h1><p id="ad58" class="pw-post-body-paragraph ie if hh ig b ih lh ij ik il li in io ip lj ir is it lk iv iw ix ll iz ja jb ha bi translated">我们后退一步，分析我们是否还能让这一切发生。<br/>我们知道的一件事是，占据空间的是数据模型。</p><p id="ca22" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们首先分析一下数据文件有多大。<br/>我们有大约8个，总计7.8G，然后我们还有大约180MB的代码工件。<br/>很明显，如果我们能对图像中的数据(代码和数据文件)做些什么，我们就能节省一些空间。<br/>另一件需要注意的事情是，当我们复制传统设计时，我们也在构建阶段对压缩配置进行解压缩</p><h1 id="61f0" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">O 优化</h1><p id="a316" class="pw-post-body-paragraph ie if hh ig b ih lh ij ik il li in io ip lj ir is it lk iv iw ix ll iz ja jb ha bi translated">180MB的代码工件被移到了容器启动阶段，我们还将模型的解压缩步骤也移到了运行时。<br/>现在的图像尺寸是，<strong class="ig hi"> 8.63G </strong>！集装箱的正常运行时间现在是9分钟。差不多有1.4克的空间被释放出来。<br/>但这还不够，我们已经被管理nexus repo中docker映像的存储团队拉了上来。</p><p id="3d77" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">目标是将映像的大小至少缩减到5G，这是存储团队设置的最大阈值。</p><h1 id="5466" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">下一个目标</strong></h1><p id="853c" class="pw-post-body-paragraph ie if hh ig b ih lh ij ik il li in io ip lj ir is it lk iv iw ix ll iz ja jb ha bi translated">如前所述，数据模型大约为<strong class="ig hi"> 7.8G </strong>，所以我们必须对它们做些什么。<br/>已经将代码工件转移到运行时，一个固定的想法是对数据模型进行排序，并尝试将较小的模型转移到运行时，而不会对启动时间产生负面影响。<br/>在这个练习中，我们了解到有2个型号分别为3.8G和2.2G，其余6个型号的最大容量约为200MB。非常高兴的是，所有这6个较小的模型都转移到运行时。这很有帮助，图像现在是<strong class="ig hi">7.43克</strong>。</p><h1 id="3530" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">接下来是什么</strong></h1><p id="8841" class="pw-post-body-paragraph ie if hh ig b ih lh ij ik il li in io ip lj ir is it lk iv iw ix ll iz ja jb ha bi translated">我们的焦点一直是数据模型。让我们来看看拉模型时发生了什么。<br/> 1。压缩后的tar从我们当地的NFS配置商店中取出<br/> 2。在启动阶段解压缩它们</p><p id="cf00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据文件是gzip压缩的，在移动较小的数据文件后，我们现在只有其中的2个文件处于构建阶段。</p><p id="7c85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">改变压缩格式</strong></p><p id="982c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然XZ是新的，但如果你使用它的最大能力，它在压缩方面是很棒的。<br/>现在，我们对gz归档文件进行解压缩，然后使用xz重新压缩它，使用压缩选项来提供最大压缩，以时间换取压缩。</p><div class="lm ln ez fb lo lp"><a href="https://linux.die.net/man/1/xz" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab dw"><div class="lr ab ls cl cj lt"><h2 class="bd hi fi z dy lu ea eb lv ed ef hg bi translated">xz(1) - Linux手册页</h2><div class="lw l"><h3 class="bd b fi z dy lu ea eb lv ed ef dx translated">xz，unxz，xzcat，lzma，unlzma，lzcat -压缩或解压缩。xz和。lzma文件unxz相当于xz…</h3></div><div class="lx l"><p class="bd b fp z dy lu ea eb lv ed ef dx translated">linux.die.net</p></div></div></div></a></div><p id="5081" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图像大小从7.4大幅减少到5.8G！！。然而建造时间增加到了一个多小时。XZ的压缩速度很慢，但是做得很好。<br/>这对启动时也有影响，因为我们在部署时进行了untar。启动时间现在是11分钟，考虑到当前部署到虚拟机中大约需要9分钟，这有点偏高。</p><p id="2f73" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">一看Docker图像</strong></p><p id="30be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">检查我们的docker文件和映像时，我们注意到的一件事是，为了使映像安全，我们使用切换到非root用户，然后在jetty主目录上对该用户执行chown操作，因为基本映像是以root用户身份运行的。<br/>这一步是添加一个额外的418MB的层覆盖。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ly"><img src="../Images/56326ad76135eaa0b90252de5e8bad2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MwLgYLMRtjFZnGeIwMnBSQ.png"/></div></div></figure><p id="26e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们进入基本映像，将基本映像的用户更改为非根用户。这有助于将图像尺寸缩小到5.38克。</p><p id="692e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">持续的努力已经将图像尺寸从巨大的9.8G降低到5.3G。尽管仍然比阈值高了<strong class="ig hi"> 340M </strong>，但在这个阶段，它看起来已经是我们能做到的最大值了。</p><h1 id="5fda" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><span class="l kb kc kd bm ke kf kg kh ki di">T</span>T23】何改变游戏规则</h1><p id="c194" class="pw-post-body-paragraph ie if hh ig b ih lh ij ik il li in io ip lj ir is it lk iv iw ix ll iz ja jb ha bi translated">在我们追求进一步改进的过程中，我们试图找到将完整数据模型移出映像的瓶颈。这里的主要障碍是访问存储在我们私人数据中心的文件。这涉及到跨DC的传输，增加了延迟。因此，下一个问题是，如果我们可以在云端有类似的东西，情况会如何改善。</p><p id="6bd0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如前所述，这是一个遗留系统。因此，大多数最新的云功能并不总是存在。此外，该集群由另一个团队管理，我们无法在规定的时间内添加任何类型的卷支持来将我们的应用程序转移到生产环境。这里的想法是尝试从传统的角度解决这个问题，并能够将其过渡到基于云的方法。<br/>回到考虑中的解决方案，我们想要一种文件服务器设置，模拟我们当前基于NFS的存储。由于管理原因，我们无法将NFS存储安装在云端机器上。</p><p id="f726" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> NodeJS来救援</strong></p><p id="b31f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Node.js允许按照下面的步骤启动http服务器，该服务器可以通过http托管静态文件。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lz"><img src="../Images/585faa896e3864a6ccb4cb583d144cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuXvjAtGflfmp3xu1Mav7Q.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">installing node file server</figcaption></figure><p id="9770" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就这样，你都准备好了。这些文件现在应该可以通过http在<em class="ma">http://&lt;server _ hostname&gt;:5050&gt;/filename</em>获得</p><p id="b2fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们将较大的模型移到这个存储中，并添加了一个在运行时下载它们的步骤。现在，所有的模型都驻留在文件服务器上，需要时可以调出。这是它现在的样子</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mb"><img src="../Images/003474510a2f63f382c7bf7898e6e2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9KbwIeqKtxdP8j2EQPzL-g.png"/></div></div></figure><h1 id="3dd0" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak">冲击</strong></h1><ol class=""><li id="2dc7" class="mc md hh ig b ih lh il li ip me it mf ix mg jb mh mi mj mk bi translated">图像大小现在是<strong class="ig hi"> 670MB </strong>，我们从<strong class="ig hi"> 9.8GB </strong>开始</li><li id="2469" class="mc md hh ig b ih ml il mm ip mn it mo ix mp jb mh mi mj mk bi translated">启动时间现在不到<strong class="ig hi">5分钟</strong>，这比虚拟机中超过<strong class="ig hi">8分钟</strong>的启动时间要好得多</li></ol><p id="2aed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我已经介绍了为遗留应用程序优化容器映像大小的思考过程。希望这能帮助那些正在将遗留应用程序迁移到云并寻找某种卷支持的人。</p><blockquote class="mq mr ms"><p id="f290" class="ie if ma ig b ih ii ij ik il im in io mt iq ir is mu iu iv iw mv iy iz ja jb ha bi translated">我们现在在k8s集群中提供了卷支持，并提出了访问请求。这样，模型将被移动到卷中，而不必在运行时下载。从而进一步缩短启动时间</p></blockquote></div></div>    
</body>
</html>