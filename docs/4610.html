<html>
<head>
<title>How to Fix the ES6 `class` keyword</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何修复ES6“class”关键字</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/how-to-fix-the-es6-class-keyword-2d42bb3f4caf?source=collection_archive---------0-----------------------#2015-03-03">https://medium.com/javascript-scene/how-to-fix-the-es6-class-keyword-2d42bb3f4caf?source=collection_archive---------0-----------------------#2015-03-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="5e13" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">第一个版本中没有什么是完美的，但这并不意味着没有希望。也许我们可以修复ES7中的“类”</h2></div><blockquote class="iw ix iy"><p id="f7ed" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="jc hi">TL；博士</strong>因为与它们相关的危险<em class="hh">(已经对很多实际项目造成了很多实际的损害)</em>我们需要在lint规则中不允许<em class="hh"> `new` </em>，<em class="hh"> `extends` </em>，<em class="hh"> `super，</em> &amp; <em class="hh"> `instanceof` </em>。ES6类不会让我们不允许<em class="hh"> `new` </em>不抛出错误。</p></blockquote><p id="c87c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">JavaScript中的`<em class="jb"> class </em>`关键字似乎不可避免地会流行起来，但这是一个问题，因为<strong class="jc hi">它在很多方面都是不完整的</strong>。</p><p id="4134" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">既然它已经出来了，人们正在使用它，似乎唯一合理的前进方式就是<strong class="jc hi">努力让它对每个人都更好</strong>。</p><p id="e520" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">在JavaScript中，<strong class="jc hi">任何函数都可以实例化并返回对象。</strong>当你在没有构造函数的情况下这样做时，它被称为<strong class="jc hi">工厂函数</strong>。类`无法与工厂的能力和灵活性竞争—特别是印记，对象池不是唯一的工厂用例。</p><p id="758b" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">GoF的《设计模式》一书中有整整一节是关于对象构造的，它的存在只是为了避开构造函数和类的限制。</p><p id="9c8c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">参见:<a class="ae jz" href="http://ericleads.com/2013/02/fluent-javascript-three-different-kinds-of-prototypal-oo/" rel="noopener ugc nofollow" target="_blank">三种不同的OO原型。</a></p><p id="ac7d" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">底线:<strong class="jc hi">类不会给你任何功能</strong>，这些功能不是由<strong class="jc hi">工厂函数</strong>和内置于语言中的<strong class="jc hi">原型OO </strong>提供的。当你创建一个类时，你所做的就是选择一个<em class="jb">不太强大、不太灵活的机制</em>和<a class="ae jz" rel="noopener" href="/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3"> <strong class="jc hi">一大堆陷阱和痛苦。</strong> </a></p><h2 id="5ddd" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jw kl km kn jx ko kp kq jy kr ks kt ku bi translated">阶级是一种病毒</h2><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/29db086807f0e444feabc8fb526e75aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NZUhr1jZdBK5YLZogMZgow.png"/></div></div></figure><p id="6e6c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">`<em class="jb"> class </em>`关键字有希望有用吗？也许吧。</p><h1 id="1d6c" class="lh kb hh bd kc li lj lk kg ll lm ln kk in lo io kn iq lp ir kq it lq iu kt lr bi translated">我们为什么要烦恼呢？</h1><p id="ff2d" class="pw-post-body-paragraph iz ja hh jc b jd ls ii jf jg lt il ji jw lu jl jm jx lv jp jq jy lw jt ju jv ha bi translated">为什么我们不创建一个lint规则，然后继续呢？</p><p id="2da9" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="jc hi">`<em class="jb">class</em>`关键字正在JavaScript社区中制造裂痕</strong>。</p><p id="8f2f" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="jc hi">类可能有用</strong>。如果我们想在它的基础上构建抽象呢？如果我们想在语言本身中做更多受益于“T2”类集成的事情(比如内置的<em class="jb">特征</em>)，该怎么办？</p><p id="252b" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">难道整个JavaScript社区不应该从`<em class="jb">类</em>中受益吗？</p><h1 id="a807" class="lh kb hh bd kc li lj lk kg ll lm ln kk in lo io kn iq lp ir kq it lq iu kt lr bi translated"><strong class="ak">如何修复“类”</strong></h1><h2 id="93d7" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jw kl km kn jx ko kp kq jy kr ks kt ku bi translated"><strong class="ak">使类继承复合</strong></h2><p id="fb81" class="pw-post-body-paragraph iz ja hh jc b jd ls ii jf jg lt il ji jw lu jl jm jx lv jp jq jy lw jt ju jv ha bi translated">类似于<a class="ae jz" href="http://chimera.labs.oreilly.com/books/1234000000262/ch03.html#prototypal_inheritance_with_stamps" rel="noopener ugc nofollow" target="_blank">邮票的排版方式。</a>换句话说，改变`<em class="jb">扩展</em>'的行为，或者<strong class="jc hi">反对`<em class="jb">扩展【T20`</em></strong>,用类似于【T22`<em class="jb">组合</em>`关键字的东西替换它，这样<strong class="jc hi">可以组合任意数量的类。</strong></p><p id="8e66" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">已经有人讨论过在ES7中这样做了，(可能是通过<em class="jb">特征</em>)，我们做得正确真的很重要，而且我们提出的任何解决方案都是与工厂函数的调用点兼容的，这样你就可以很容易地切换实现。</p><p id="6a3c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">据我所知，即使<a class="ae jz" href="http://refactoring.com/catalog/replaceConstructorWithFactoryMethod.html" rel="noopener ugc nofollow" target="_blank">对工厂函数的重构在应用程序开发项目中相当常见</a>，但是<em class="jb">工厂替换透明性在TC-39上并不是一个高优先级。</em> <strong class="jc hi">说错了请指正</strong>，附参考链接。</p><h2 id="faac" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jw kl km kn jx ko kp kq jy kr ks kt ku bi translated">弃用`新的'</h2><p id="1d3d" class="pw-post-body-paragraph iz ja hh jc b jd ls ii jf jg lt il ji jw lu jl jm jx lv jp jq jy lw jt ju jv ha bi translated">`<em class="jb"> new </em>关键字违反了<strong class="jc hi">替换原则</strong>和<strong class="jc hi">打开/关闭原则</strong>。它也是破坏性的，因为<strong class="jc hi">给语言</strong>增加了零值，并且<strong class="jc hi">将所有调用者耦合到对象实例化的细节</strong>。</p><p id="ff9b" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">如果你从一个需要`<em class="jb">new</em>`( ES6中的所有类)的类开始，然后你决定你需要使用一个工厂而不是一个类，<strong class="jc hi">你不能在不重构所有调用者的情况下做出改变。</strong> <a class="ae jz" href="https://gist.github.com/ericelliott/e994ee541d0ed365f5fd" rel="noopener ugc nofollow" target="_blank">看看这个例题要领</a>。</p><p id="f0fc" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">这对于共享库和公共接口来说尤其成问题，因为<strong class="jc hi">你可能无法使用类访问所有的代码。</strong>你可能认为用`<em class="jb"> new </em>关键字调用一个工厂函数没有任何害处，但是`<em class="jb"> new </em>关键字触发了一些行为，这些行为改变了函数被调用时的情况。某些种类的工厂很难用“新的”来实现。<a class="ae jz" href="https://gist.github.com/ericelliott/e994ee541d0ed365f5fd" rel="noopener ugc nofollow" target="_blank">更深入的解释参见要点</a>。</p><p id="1a9f" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated"><strong class="jc hi">更新:</strong>根据<strong class="jc hi"> Brendan Eich </strong>的消息，针对“<em class="jb">新</em>”问题的修复程序正在ES7中讨论:</p><blockquote class="iw ix iy"><p id="ad43" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">一个被抛出捕获的错误比一个在运行时语义中作为一个无声但致命的(不考虑分配权重)差异而逃脱的错误要好。</p><p id="ac98" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">如果有帮助的话，为ES7提出的想法是，你可以在类中添加一个“调用处理程序”,在没有“new”的情况下调用它:</p></blockquote><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lx ly l"/></div></figure><blockquote class="iw ix iy"><p id="ba48" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">我使用了“this.constructor ”,但是当然也可以直接使用“Point2D”。在这种情况下，子类将不得不覆盖`[Symbol.call]'方法，这似乎是不可取的，并很容易避免，如上所示。</p><p id="4101" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">底线是，我们不希望ES6中有隐式的调用处理程序。我们需要在ES7中做到这一点，目前努力失败是未来的唯一方法。</p><p id="67ae" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">/是</p></blockquote><h2 id="90e7" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jw kl km kn jx ko kp kq jy kr ks kt ku bi translated">确保<strong class="ak"> ` <em class="lz">类</em>`遵守替换原则</strong></h2><p id="b766" class="pw-post-body-paragraph iz ja hh jc b jd ls ii jf jg lt il ji jw lu jl jm jx lv jp jq jy lw jt ju jv ha bi translated">当你从一个职业转换到一个工厂时，<strong class="jc hi"> ` <em class="jb">职业</em>遵守替代原则</strong>是至关重要的。这是很重要的一点。如果调用者依赖于某个类的任何行为或属性，而您决定将实现更改为工厂，那么您就破坏了调用代码。我不知道有什么好的理由从工厂转到一个班。</p><p id="d68a" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">在构建大型应用程序(100kloc+代码库)的团队中，将大型类层次结构分解成更小、更具可组合性的工厂是一项常见的维护活动。事实上，你不能简单地用一个工厂来代替一个类，这浪费了大量的时间和精力，也是很多创业公司的主要资源消耗。我哪里知道？我为许多这样的项目、小型创业公司和企业组织提供过咨询。</p><p id="4ba0" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">相信我的话:这相当普遍，而且非常昂贵。如今，公司被迫不仅重构类的实现，而且重构所有的调用点——有时类在图书馆和公共SDK中，需要大量的协调、宣传和教育。我见过这个具体问题<strong class="jc hi">扼杀项目</strong>和<strong class="jc hi">让创业公司屈服</strong>。</p><h2 id="207d" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jw kl km kn jx ko kp kq jy kr ks kt ku bi translated">弃用<strong class="ak">超级</strong></h2><p id="4347" class="pw-post-body-paragraph iz ja hh jc b jd ls ii jf jg lt il ji jw lu jl jm jx lv jp jq jy lw jt ju jv ha bi translated">根据定义，Super将子类与父类紧密耦合，这意味着父类中的任何变化都可能导致<strong class="jc hi">不可知的连锁变化</strong>，这些连锁变化<strong class="jc hi">会破坏从父类</strong>继承的任何东西。</p><p id="0160" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">我曾经不得不调试一个子类的问题，这个子类在类层次结构中有6层。我的同事们毫无保留地对主干扩展进行子类化。我不得不一行一行地遍历每个子视图，沿着`<em class="jb">超级</em>'链的控制流程向上。最后在顶级基类中发现问题并修复。然后我花了接下来的几个小时修复所有在我修复基类的行为时被破坏的子类。</p><p id="e36e" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">如果你正在导出一个人们可以继承的库类，并且你对父类的行为做了<strong class="jc hi">任何改变</strong>，<strong class="jc hi">你可能已经破坏了一个你甚至不知道存在的子类</strong>。</p><p id="1bd8" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">这尤其麻烦，因为<strong class="jc hi">子类不遵守封装规则</strong>。他们经常调用`<em class="jb"> super </em>`,使用和覆盖私有属性和方法等等……基本上，<a class="ae jz" href="http://martinfowler.com/bliki/CallSuper.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jc hi"> super是一个代码气味</strong> </a>，并且是一个灾难的配方。</p><p id="5522" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">它也<strong class="jc hi">不与工厂</strong>合作，这意味着<strong class="jc hi">它违反了替代原则。</strong></p><p id="b0ae" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">如果我们不能用`<em class="jb">类</em>解决这些问题，我们应该推动<strong class="jc hi">完全废弃这个关键字，</strong>因为就目前而言，<a class="ae jz" rel="noopener" href="/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3"> <strong class="jc hi"> ` <em class="jb">类</em>`已经坏了，绝对不应该使用</strong> </a> <strong class="jc hi">。</strong></p><h1 id="0b40" class="lh kb hh bd kc li lj lk kg ll lm ln kk in lo io kn iq lp ir kq it lq iu kt lr bi translated">替代中断目录</h1><p id="32f7" class="pw-post-body-paragraph iz ja hh jc b jd ls ii jf jg lt il ji jw lu jl jm jx lv jp jq jy lw jt ju jv ha bi translated">替换的问题很严重，需要解决。</p><p id="6989" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jw jk jl jm jx jo jp jq jy js jt ju jv ha bi translated">如果我们能够<em class="jb">在这里列出每一个可能的突破性变化</em>，假设我们能够将一致性融入到语言规范中，那么在未来“<em class="jb">类</em>”可能会有一些希望。</p><ul class=""><li id="f236" class="ma mb hh jc b jd je jg jh jw mc jx md jy me jv mf mg mh mi bi translated"><strong class="jc hi">`<em class="jb">新的</em>要求。坦率地说，在JavaScript中,“new”没有理由像这样改变行为。它没有增加任何价值，并且由于破坏了构造函数/工厂替换，它确实增加了显著的痛苦和复杂性。</strong></li><li id="7be7" class="ma mb hh jc b jd mj jg mk jw ml jx mm jy mn jv mf mg mh mi bi translated"><strong class="jc hi">的行为`<em class="jb">这个</em> ` </strong>。它总是引用类构造函数中的新实例。在工厂函数中，`<em class="jb">这个</em>`是动态的，遵循一套完全不同的规则。可能的解决方案:<strong class="jc hi">弃用`<em class="jb"> this </em> ` </strong>而代之以按名称引用类或函数。这种解决方案的一个主要缺点是它会破坏`<em class="jb">。call() </em>`，`<em class="jb">`。apply() </em>`和`<em class="jb">。bind() </em>`，除非我们<strong class="jc hi">也改变它们的行为</strong>来覆盖函数名引用。我不喜欢这些解决方案。请随意提出更好的选择。</li><li id="26ef" class="ma mb hh jc b jd mj jg mk jw ml jx mm jy mn jv mf mg mh mi bi translated"><strong class="jc hi">`<em class="jb">instance of</em>`—</strong>IMO，<strong class="jc hi"> ` <em class="jb"> instanceof </em>无论如何都是坏的</strong>，因为它不做名字所描述的事情，而且从用户的角度来看，<strong class="jc hi">当你试图跨执行上下文使用它时，或者当构造器原型属性改变时，它完全就是</strong>。可能的解决方案:<strong class="jc hi">弃用 ` </strong>的`<em class="jb">实例。</em></li><li id="e8cf" class="ma mb hh jc b jd mj jg mk jw ml jx mm jy mn jv mf mg mh mi bi translated"><strong class="jc hi">`<em class="jb">super</em>`—</strong>`<em class="jb">super</em>`显然不能用于工厂函数，因为继承与工厂的工作方式完全不同(返回的实例可以是任何东西)，所有用户都应该遵守公共API。<strong class="jc hi"> </strong>可能的解决方案:<strong class="jc hi">弃`<em class="jb">超</em> ` </strong>，以及<a class="ae jz" href="http://martinfowler.com/bliki/CallSuper.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jc hi">好的除掉</strong> </a> <strong class="jc hi">。</strong></li></ul></div></div>    
</body>
</html>