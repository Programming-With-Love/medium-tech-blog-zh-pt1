<html>
<head>
<title>Functions vs Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数与容器</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/containers-vs-functions-51c879216b97?source=collection_archive---------0-----------------------#2017-11-06">https://medium.com/oracledevs/containers-vs-functions-51c879216b97?source=collection_archive---------0-----------------------#2017-11-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="fa6e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">容器和函数“现在这么火”，但是这两者到底有什么区别呢？我最近一直在谈论这个话题，很明显没有简单的答案。在这篇文章中，我将尝试给出一个答案，至少我们可以将对话向前推进，以便更好地理解容器和函数是如何相互关联的。让我们从一些宽泛的定义开始:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/0b3e29fce4bf8d1510de6c97e4a26ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wKGMB7tjWB_7tlHtegDmuw.png"/></div></div></figure><h1 id="78c7" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">定义</h1><p id="5fa3" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">Docker网站上的容器:“容器映像是一个轻量级的、独立的、可执行的软件包，包含了运行它所需的一切:代码、运行时、系统工具、系统库、设置。”</p><p id="2950" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">函数</strong>:函数是代码块，理想情况下很小且用途单一。在无服务器的环境中，它们由一个功能即服务(FaaS)平台来协调和调度，如供应商服务<a class="ae kr" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>、<a class="ae kr" href="https://azure.microsoft.com/en-us/services/functions/" rel="noopener ugc nofollow" target="_blank"> Azure Functions </a>和<a class="ae kr" href="https://cloud.google.com/functions/" rel="noopener ugc nofollow" target="_blank"> Google Cloud Functions </a>，或开源框架，如<a class="ae kr" href="http://fnproject.io" rel="noopener ugc nofollow" target="_blank"> Fn项目</a>(我们的项目)、<a class="ae kr" href="https://openwhisk.apache.org/" rel="noopener ugc nofollow" target="_blank">open whish</a>和<a class="ae kr" href="https://www.openfaas.com/" rel="noopener ugc nofollow" target="_blank"> OpenFaas </a>。</p><p id="7204" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">无服务器:</strong>一类软件设计，开发者的抽象层位于应用层，在操作系统、基础设施和云IaaS API之上。换句话说，开发者从不考虑基础设施。</p><p id="67a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最早加入游戏的FaaS公司(Lambda，Azure，Google，OpenWhisk)给你一个API或GUI来上传代码。没有公开容器，因此，用户受到预构建环境和不太理想的依赖关系管理和构建系统的限制。Kelsey Hightower发起的一个丰富多彩的Twitter帖子强调了这种模式的当前思维状态。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="342d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">包括<a class="ae kr" href="http://fnproject.io" rel="noopener ugc nofollow" target="_blank"> Fn </a>(我们的项目)在内的新一代框架是“容器原生的”，这意味着Docker容器是一等公民，任何图像都可以用作函数本身。</p><p id="e7a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是困惑的症结所在— <em class="ku">如果函数是容器，容器是函数，它们实际上是不同的吗</em>？此外，如果你只能在Cloud Foundry或Kubernetes这样的平台上运行容器，那么FaaS系统的价值是什么？<a class="ae kr" href="https://twitter.com/maximilien" rel="noopener ugc nofollow" target="_blank">IBM的Max </a>博士反复思考了这一点，他向我所在的欧洲码头委员会的一个小组提出了这个问题。那时我决定尝试在这里用更长的格式回答这个问题。</p><h1 id="0970" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">函数&lt; Container</h1><p id="49ea" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">A container can contain anything, from a webservice, to a million LOC monolith, to a complete DBMS system, to the data tier that DBMS writes into. These containers can live forever, scale horizontally (or not), take 20 minutes to start, 20 days to run, and on and on.</p><p id="f07b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Contrast this to a Function, which typically has a set of known characteristics:</p><ol class=""><li id="0c94" class="kv kw hh ig b ih ii il im ip kx it ky ix kz jb la lb lc ld bi translated"><strong class="ig hi">短期运行:</strong>函数存在一小段时间，然后进程结束。“短”当然是主观的，但是让我们假设我们说的是5分钟甚至更短。</li><li id="6b89" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated"><strong class="ig hi">短暂的:</strong>运行函数的外部容器可能只存在于函数的一次调用中。</li><li id="4363" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated"><strong class="ig hi">无状态:</strong>函数本身不包含任何状态。所有状态都必须推送到结构化或非结构化存储。</li><li id="910b" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated"><strong class="ig hi">调用:</strong>函数由定义的事件通过HTTP、TCP或其他协议调用。</li><li id="4791" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated"><strong class="ig hi">单一目的:</strong>函数有一个清晰明确的目的，具有最小的API表面积，这意味着它们需要相当短的输入，并提供相当短的输出。</li><li id="1f16" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated"><strong class="ig hi">自包含:</strong>一个函数可以自己运行并服务于它的目的。虽然一个函数很可能只是一个更大的函数组的一部分(例如，许多函数创建一个API，一系列函数创建一个“流”)，但就其本身而言，只要它得到所需的输入，它就可以独立运行。[感谢<a class="lj lk ge" href="https://medium.com/u/5ef46aa7291f?source=post_page-----51c879216b97--------------------------------" rel="noopener" target="_blank">托拜厄斯·昆泽</a>的命名建议]</li></ol><p id="b87b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，如果我们将具有这些特征的函数打包到一个容器中，那么我们现在可以以不同的方式思考和推理该容器，从而产生一个强大的概念——一个新的计算原子单位。</p><h1 id="c08c" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">计算机原子单位</h1><p id="cb60" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">其核心是，封装在容器中的函数给了我们一个新的“计算的原子单位”。我们可以用我们理解的构件来思考和讨论我们的软件，比如图像处理功能、情感分析功能等等。我们可以共享和扩展功能，以及构建复合应用程序。建立原子单位使我们有能力构建分子和复杂有机体的软件等价物。</p><p id="e495" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们不仅获得了这种计算的原子单位，而且还继承了容器本身的所有优势，如标准化的打包格式、运行时、存储、运输等。此外，平台和工具可以针对这种新的计算原子单元进行专门设计和构建。这就是围绕功能和无服务器计算的蓬勃发展的生态系统，这就是容器隐喻首先代表的东西。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="6eda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们将这个原子单元应用到一些对软件开发很重要的概念上。</p><h2 id="12fc" class="ll jp hh bd jq lm ln lo ju lp lq lr jy ip ls lt kc it lu lv kg ix lw lx kk ly bi translated">用作缩放单位</h2><p id="4711" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">大多数软件都是为了扩展到许多用户而构建的。过去是纵向扩展<em class="ku">(更大的机器)，现在是横向扩展<em class="ku"/>(更多的机器)，我们可以以比机器更精细的精度做到这一点，我们可以以单个流程的精度纵向扩展/横向扩展。不需要函数调用，不需要容器，不需要机器，重新利用它们来执行一些其他操作。大量的函数调用，利用免费资源旋转容器。这是一个简化的视图，但是函数的特性加上容器的通用打包/运行时给了我们一个更有效的方法来扩展我们的应用程序。</em></p><h2 id="da39" class="ll jp hh bd jq lm ln lo ju lp lq lr jy ip ls lt kc it lu lv kg ix lw lx kk ly bi translated">作为计费单位</h2><p id="e6f0" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">“无服务器”的计费模式是一项激动人心的进步。我们现在可以以更精细的方式支付费用，而不是数天、数月或数年运行服务器或虚拟机，即特定功能消耗的时间，有时是毫秒。这使得很少使用的应用程序的成本降低，在市场上测试应用程序功能的成本更低，等等。</p><h2 id="67c2" class="ll jp hh bd jq lm ln lo ju lp lq lr jy ip ls lt kc it lu lv kg ix lw lx kk ly bi translated">作为设计单元的功能</h2><p id="a050" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">设计是我能想到的描述我所认为的“SOA的下一个到来”的最好的词。封装在容器中并有自己的契约的功能应该是内在可共享的，这样就可以构建和重用复合应用程序。这也需要功能编排工具，这也是我们打算用<a class="ae kr" href="https://github.com/fnproject/flow" rel="noopener ugc nofollow" target="_blank"> Fn流</a>解决的问题。</p><h1 id="0a38" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">下一步是什么？</h1><p id="66ef" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">好了，我已经做了我一直想做的事情，发布了一个关于容器、函数、无服务器和原子单元的帖子。我希望这有助于我们从争论差异走向拥抱结合。我也觉得这个话题已经谈得不多了，但话说回来，我生活在人们谈论无服务器计算的泡沫中。</p><p id="f881" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将继续在高层次上谈论无服务器，但开始越来越多地关注如何将该架构及其优势带给早期的大多数应用程序，以及更多类型的应用程序，甚至是复杂的应用程序。鉴于事件驱动的性质，我们稍微陷入了一个触发器的世界，这是可以理解的，但是让我们进化吧。</p><p id="f578" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来会有更多…关于这个主题的预览，请查看我们在Fn项目博客上发布的<a class="ae kr" rel="noopener" href="/fnproject/flow-101-be7f328ffce2"> Flow 101 </a>和<a class="ae kr" rel="noopener" href="/fnproject/serverless-sagas-with-fn-flow-d8199b608b12">无服务器传奇</a>。</p></div></div>    
</body>
</html>