<html>
<head>
<title>Maneuvering Color Mask into Object Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">操纵彩色掩模进行目标检测</h1>
<blockquote>原文：<a href="https://medium.com/globant/maneuvering-color-mask-into-object-detection-fce61bf891d1?source=collection_archive---------1-----------------------#2020-08-28">https://medium.com/globant/maneuvering-color-mask-into-object-detection-fce61bf891d1?source=collection_archive---------1-----------------------#2020-08-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/97f7857683ade2f9c047fd3125f0b1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*lMLv9l9jFxpzs0Co_XeTGw.jpeg"/></div></figure><p id="b824" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我已经研究对象检测算法有一段时间了，在本文中，我将使用Python和OpenCV构建一个小型对象检测应用程序。</p><p id="9c3d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">想法</strong></p><p id="e699" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们将通过识别对象的颜色信息来为我们试图检测的对象生成遮罩，然后使用该遮罩来检测帧中的对象。我们还将围绕对象绘制一个边界框。</p><p id="3a9b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在我们动手之前，让我们先弄清楚一些我用来实现这一点的基本概念。</p><p id="0bb7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi"> HSV颜色模型</strong></p><p id="019e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi"> HSV </strong></p><ul class=""><li id="1578" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated"><strong class="in hi">色调</strong>指定颜色在RGB色环上的角度。</li><li id="d73d" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><strong class="in hi">饱和度</strong>控制使用的颜色数量。</li><li id="0886" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><strong class="in hi">值</strong>控制颜色的亮度。</li></ul><p id="7a29" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了准确地获取物体的颜色信息，我们将图像转换成HSV颜色模型。</p><p id="d9cc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">为什么是HSV？</strong></p><p id="d18e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">任何颜色基本上都可以用各种颜色模型来描述(<a class="ae jx" href="https://en.wikibooks.org/wiki/Color_Models:_RGB,_HSV,_HSL" rel="noopener ugc nofollow" target="_blank">详情在此</a>)。HSV模型相对于RGB或BGR模型的优势在于，它将<strong class="in hi"><em class="jy"/></strong>、或图像<em class="jy">强度</em>与<strong class="in hi"> <em class="jy">色度</em> </strong>或<em class="jy">颜色信息</em>分开。</p><p id="fef4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">这怎么帮你问？</strong></p><p id="6dd9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">假设我们有一个单色平面，上面有一个阴影。在RGB色彩空间中，阴影部分很可能与没有阴影的部分具有非常不同的特征。在HSV色彩空间中，两个色标的色调成分更可能是相似的:阴影将主要影响该值，或者可能影响饱和度成分，而指示主要“颜色”(没有其亮度和被白/黑稀释)的色调不应该变化太多。</p><p id="2085" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要将我们的图像转换到HSV空间，我们可以使用OpenCV cvtColor函数并传递cv2。COLOR_BGR2HSV枚举作为第二个参数，而第一个参数是图像。像下面这样，</p><p id="609a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jy"> cv2.cvtColor(图片，cv2。COLOR_BGR2HSV) </em></p><p id="ee0d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">算法</strong></p><figure class="ka kb kc kd fd ii er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es jz"><img src="../Images/783d2c6523b2970bb9c49dffc5ce3a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CEgnhPR1-uUfFSoM"/></div></div><figcaption class="ki kj et er es kk kl bd b be z dx">Photo by <a class="ae jx" href="https://unsplash.com/@rosssneddon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ross Sneddon</a> on <a class="ae jx" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><ul class=""><li id="6e92" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">加载图像</li><li id="6696" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">将图像转换成HSV颜色模型。</li><li id="6e43" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">确定蓝色、绿色和红色通道的最小值和最大值(阈值)</li><li id="d8f0" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">读取我们想要检测对象的图像或帧</li><li id="2e78" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">将图像/帧转换为HSV颜色模型</li><li id="0fc8" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">使用BGR通道的阈值提取遮罩。</li><li id="e649" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">找到蒙版上物体的轮廓。</li><li id="5334" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">选择最大的轮廓。</li><li id="e811" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">使用轮廓信息在图像上绘制边界框。</li><li id="0360" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">显示图像/帧。</li></ul><p id="eeb9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在让代码开始吧！</p><p id="4f47" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我将分两部分构建我们的应用程序-</p><ol class=""><li id="7d2a" class="jj jk hh in b io ip is it iw jl ja jm je jn ji km jp jq jr bi translated">首先，我将构建一个应用程序来计算蓝色、绿色和红色通道的阈值。</li><li id="2d22" class="jj jk hh in b io js is jt iw ju ja jv je jw ji km jp jq jr bi translated">然后，我将在我们的第二个应用程序中使用这些阈值来创建一个遮罩，并尝试找到这些值在图像/帧中的确切位置。</li></ol><p id="29f8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">应用识别阈值</strong></p><figure class="ka kb kc kd fd ii"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="f088" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们从导入OpenCV并创建一个空函数开始，这个函数什么也不做(我们稍后将回到这个问题)</p><figure class="ka kb kc kd fd ii"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="0f5e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后我们创建一个可调整大小的窗口，并给它一个名字——“跟踪条”。</p><figure class="ka kb kc kd fd ii"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="e745" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，由于我们需要计算出对象的蓝色、绿色和红色通道的最小值和最大值，我们将创建6个跟踪条，我们可以调整这些跟踪条来计算出最佳匹配。</p><p id="0983" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们知道颜色值的范围是从0到255，我们的trackbar也有相同的范围。</p><p id="25f4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">函数语法中的最后一个参数是onChange function，trackbar的每次改变都会调用它，但是因为我们不想对位置的改变做任何事情，所以我们传递了一个空函数。</p><p id="e561" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">注意:第二个参数是OpenCV显示跟踪栏的窗口名。</p><figure class="ka kb kc kd fd ii"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="845d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们使用cv2.imread读取图像，然后我们可以选择调整图像的大小。</p><figure class="ka kb kc kd fd ii"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="c64d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后，我们将调整后的图像转换为HSV模型，默认情况下，OpenCV在BGR模型中读取图像，然后显示两幅图像。</p><figure class="ka kb kc kd fd ii"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="317c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后，我们开始一个无限循环，通过使用<em class="jy"> getTrackbarPos </em>函数并向其传递我们想要从中读取当前值的跟踪条的名称和它所在的窗口名称，来获取BGR通道的最小-最大值。</p><p id="d2b1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一旦我们获得了对象的阈值，我们就使用OpenCV的<a class="ae jx" href="https://docs.opencv.org/3.4/d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981" rel="noopener ugc nofollow" target="_blank"><em class="jy">in range</em></a><em class="jy"/>函数创建一个遮罩，通过识别落在给定阈值范围内的像素范围来检测对象。</p><p id="2c54" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后我们使用<em class="jy"> imshow </em>功能显示掩模图像。</p><figure class="ka kb kc kd fd ii"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="3967" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一旦我们找到了正确的阈值，我们可以通过按“q”键退出循环，打印值，并销毁所有窗口。</p><figure class="ka kb kc kd fd ii er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kp"><img src="../Images/f04012880ba4b5509f6f401d254db3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bobxc27_qnEPrDBi"/></div></div></figure><p id="6af5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">左上</strong>:原始图像T <strong class="in hi"> op右</strong>:跟踪条</p><p id="5c8e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">左下</strong> : HSV图像<strong class="in hi">右下</strong>:遮罩图像</p><p id="fad5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">物体检测</strong></p><p id="a533" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，我们将创建另一个应用程序，其中我们将使用上述阈值来生成遮罩并检测视频中的对象。</p><figure class="ka kb kc kd fd ii"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="723f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们从第1行导入OpenCV开始</p><p id="d619" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后，我们声明从前面的应用程序中生成的阈值(第4–9行)。</p><figure class="ka kb kc kd fd ii"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="589c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后在第4行，我们使用OpenCV <em class="jy"> VideoCapture </em>函数打开视频</p><figure class="ka kb kc kd fd ii"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="f432" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后，我们开始一个while循环来读取视频的每一帧，并将其与检测到的对象一起显示出来。</p><p id="1e0d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第3行我们使用<em class="jy">相机读取单帧(静止图像)。read </em>功能。</p><p id="f761" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第5–6行我们检查是否有帧没有返回，然后我们简单地退出while循环</p><p id="24f7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们把图像转换成HSV格式。</p><p id="0765" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第11行我们使用我们确定的阈值生成掩码。</p><p id="c0ee" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第13行我们找到使用蒙版找到的轮廓(你可以在这里阅读更多关于轮廓的内容<a class="ae jx" href="https://docs.opencv.org/3.4/d4/d73/tutorial_py_contours_begin.html#:~:text=To%20draw%20the%20contours%2C%20cv,useful%20when%20drawing%20individual%20contour." rel="noopener ugc nofollow" target="_blank"/></p><p id="03dd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第15行一旦我们有了一个轮廓数组，我们就对该数组进行排序，并传递reverse = True来使它们以最大的优先方式排序。</p><p id="aca5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Lin # 17–23我们检查是否在该帧中发现任何轮廓。然后我们选择最大的轮廓，并使用<a class="ae jx" href="https://docs.opencv.org/3.4/d3/dc0/group__imgproc__shape.html#ga103fcbda2f540f3ef1c042d6a9b35ac7" rel="noopener ugc nofollow" target="_blank"> boundingRect </a>函数得到该轮廓的包围盒。一旦我们得到边界框的尺寸，我们通过使用OpenCV <a class="ae jx" href="https://docs.opencv.org/3.4/d6/d6e/group__imgproc__draw.html#ga07d2f74cadcf8e305e810ce8eed13bc9" rel="noopener ugc nofollow" target="_blank"> rectangle </a>函数在图像/帧中的坐标周围画一个矩形。</p><p id="9788" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">最后，我们使用<em class="jy"> imshow </em>功能显示帧/图像。我们显示if条件之外的框架，因为即使没有找到轮廓，我们也希望显示该框架。</p><p id="1855" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第29–30行我们读取任何按键，如果按下的键是“q ”,我们中断while循环</p><figure class="ka kb kc kd fd ii"><div class="bz dy l di"><div class="kn ko l"/></div></figure><p id="b9a2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">最后，当一切完成后，我们释放相机资源并销毁所有打开的窗口。</p><figure class="ka kb kc kd fd ii er es paragraph-image"><div role="button" tabindex="0" class="ke kf di kg bf kh"><div class="er es kq"><img src="../Images/2cbaabb9422bb2603bd86ec20d939936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GiD1rVJYKh7KG4wcwg5VXA.gif"/></div></div></figure><p id="1d89" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">就这样。</strong></p><p id="6b77" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，当我们运行这段代码时，你会看到一个视频，在对象周围画了一个边框，如下图所示。</p><p id="c273" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">感谢您阅读我的文章。</p></div></div>    
</body>
</html>