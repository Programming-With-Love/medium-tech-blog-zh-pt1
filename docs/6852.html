<html>
<head>
<title>Dynamic Programming 1— Learning by doing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态编程1—边做边学</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/dynamic-programming-learning-by-doing-bba46701cb0b?source=collection_archive---------0-----------------------#2020-05-16">https://medium.com/quick-code/dynamic-programming-learning-by-doing-bba46701cb0b?source=collection_archive---------0-----------------------#2020-05-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="f75e" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">1.网上购物(中型)—厨师</h1><h1 id="7909" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">问题:</h1><p id="be47" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">她从网上商店购买商品。两家商店里同样的商品价格不同。她总共需要购买<strong class="je hi"> N </strong>件物品。她可以在任何一家商店购买每一件商品。所有的商店都提供一定的折扣。如果她在一家商店购买了第<em class="ka"> i </em>件商品，她将获得同一家商店第<em class="ka"> i+1 </em>件商品的优惠券。但是如果她从另一家商店购买第i+1件商品，她就不能使用折扣券。</p><p id="25b6" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">告诉她获得所有物品的最少花费。</p><h1 id="6e7a" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">方案一:蛮力O(M * M^N)</h1><p id="4a51" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们可以尝试各种商店组合来购买。我们知道有M^N可能的组合，要迭代和计算花费O(M)时间。我们通过从购买0件商品、1件商品、2件商品……一直到N件商品的迭代来做到这一点。当我们购买N件商品时，我们必须更新我们的最低成本。</p><p id="c144" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">请注意，我们在这里重新计算了许多子问题，因此，如果我们计算去一些商店的最小成本，我们希望能够节省该值。这是正在使用的DP的指标。</p><h1 id="8f92" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">解决方案2:动态规划O(M N)</h1><p id="8a75" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">如上所述，我们需要存储某种状态，以便我们不会再次重新计算。这种状态能是什么？这是寻找动态规划解决方案最棘手的部分之一，可能需要一些批判性的分析才能想到。</p><p id="e34a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">我们状态的一个自然参数可能是我们购买的物品数量。注意在我们的<strong class="je hi">强力</strong>解决方案中，我们已经迭代了我们购买的商品数量。我们将使用相同的状态参数:<strong class="je hi">我们购买的商品数量。</strong></p><p id="ba23" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">当前状态参数:<br/> 1。我们购买的物品数量</strong></p><p id="365b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">好了，我们有了第一个参数，但是这足以记录信息来解决这个问题吗？不完全是。请注意，为了进入我们购买的下一个项目，我们必须相应地计算成本。如果我们去同一家商店，那么我们的成本计算是不同的，因为我们使用优惠券。很自然，这让我们想到了另一个参数:<strong class="je hi">我们购买的最后一个商品商店。</strong></p><p id="3a24" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">完成我们的状态:<br/>状态:<br/>I—#我们购买的物品<br/> j —商店#我们从</strong>购买了最新的物品</p><p id="48ad" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这样够了吗？是的，似乎是这样，我们的直觉说是的，所以让我们继续我们的过渡和基本情况。</p><p id="90dc" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">基本情况:所有j个商店的state(1，j)<br/></strong>让我们为我们的状态参数想一个简单的数字。我们可以只买第一个项目，所以state(1，j)。我们如何计算从商店j购买第一件商品的最小成本？嗯，我们可以从j商店买那件商品。</p><p id="55bf" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">过渡:</strong></p><p id="9dea" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">好，我们有所有j的所有状态(1，j)。现在，用这个我们如何计算所有j的状态(2，j)？我们知道，对于state(2，j)，即从商店j购买前两件商品和第二件商品的最小成本，我们可以迭代购买第一件商品的所有成本，然后将其更新为这些选项中的最小值。更正式地说，</p><p id="bc28" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">state(2，j) =对于从1，…，M开始的所有商店k，我们将做:<br/>如果(k == j)那么我们可以使用我们的优惠券so = state(1，j) + item_cost-discount <br/>否则:那么我们不能使用我们的优惠券so = state(1，k) + item_cost</p><p id="25d5" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">我们希望取所有这些计算值的最小值，并为其设置state(2，j)= 1。</p><p id="5e49" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">我们可以对此进行概括，说:<br/> state(i，j) = min of all state(i-1，k) + item_cost-(如果适用的话折扣)。</p><p id="23fc" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">解题</strong></p><p id="c078" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">最后，我们计算所有j的最小状态(N，j)并返回。这很直观，因为我们希望找到购买N件商品的最小值，其中最后一件商品是所有可能的商品。</p><p id="a31d" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi">运行时复杂度<br/> </strong>有O(MN)个状态，对于每个状态，我们通过迭代它之前的每M个状态来计算它的最小代价。因此，O(M N)</p><h1 id="a09c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">解3(最优解):动态规划O(MN)</h1><p id="f4ff" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">让我们将时间复杂度降低O(M)。注意，对于每个状态，我们迭代M个先前的状态来计算它的最小成本。我们能减少吗？</p><p id="d1b0" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">是的，对于每个第I项(即对于状态(I，…))，我们可以计算购买前I项的最小成本，并保存该值。我们可以如下使用这个保存的值:</p><p id="1885" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">在我们的基本情况下，当我们计算所有j的state(1，j)时，我们保存所有state(1，j)的最小成本，并保存该值。</p><p id="5f47" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">然后，当我们计算state(2，j)时，不是遍历每个state(1，j)并计算最小成本，我们可以自己想，对于state(2，j)，我们可以从同一个供应商处购买并获得优惠券，即，我们可以从不同的供应商处购买state(2，j) = state(1，j) + item_cost-coupon <br/>或<br/>，即，我们保存的所有j的state(1，j)的最小成本。</p><p id="9db0" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">所以形式上:state(2，j) = min( state(1，j)+ item_cost-coupon)，saved_value + item_cost)。</p><p id="9d7e" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">Tada，我们用O(MN)就解决了</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/4bb0311d88d625470df9ea2ebde09f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4BR93Ej7uXEkuQOJtBcjQ.png"/></div></div></figure></div></div>    
</body>
</html>