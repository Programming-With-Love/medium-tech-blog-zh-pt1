<html>
<head>
<title>Re-writing the AOSP Calendar App in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用科特林语言重新编写AOSP日历应用程序</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/re-writing-the-aosp-calendar-app-in-kotlin-48ceb0e3a65c?source=collection_archive---------0-----------------------#2021-08-03">https://medium.com/androiddevelopers/re-writing-the-aosp-calendar-app-in-kotlin-48ceb0e3a65c?source=collection_archive---------0-----------------------#2021-08-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/c8aec61320bfcf0fad2440868c7132d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yor9_gGzfxRlRWMJQ173AQ.png"/></div></div></figure><div class=""/><p id="2272" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><em class="jo">作者达米安·帕特尔</em> <a class="jp jq ge" href="https://medium.com/u/be32be256154?source=post_page-----48ceb0e3a65c--------------------------------" rel="noopener" target="_blank">和<em class="jo">作者玛希·K</em></a></p><p id="9eb4" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">两年前，<a class="ae jr" href="https://android.googlesource.com/platform/packages/apps/" rel="noopener ugc nofollow" target="_blank"> Android开源项目(AOSP)应用</a>团队开始了将AOSP应用从Java重构为<a class="ae jr" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>的过程。推行这一举措有两个原因:确保AOSP应用程序遵循Android的最佳实践，并首先提供用Kotlin开发应用程序的良好范例。此外，Kotlin最大的吸引力之一是其简洁的语法。在许多情况下，用Kotlin编写的大部分代码块比相应的功能相同的Java代码块要小。此外，这种富于表现力的编程语言具有各种其他有益的特性，例如:</p><ul class=""><li id="2aff" class="js jt hs is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka bi translated">空安全:这个概念已经深入Kotlin，有助于避免毁灭性的空指针异常。</li><li id="d803" class="js jt hs is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">并发:正如Android在<a class="ae jr" href="https://developer.android.com/kotlin/first" rel="noopener ugc nofollow" target="_blank"> Google I/O 2019 </a>上所描述的，结构化并发允许协同例程简化后台任务管理。</li><li id="3573" class="js jt hs is b it kb ix kc jb kd jf ke jj kf jn jx jy jz ka bi translated">与Java的兼容性:特别是在这个项目的环境中，Kotlin与Java编程语言的兼容性允许我们一次执行一个文件的转换过程。</li></ul><p id="64b9" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">去年夏天，AOSP团队发表了一篇文章，详细介绍了AOSP桌面时钟应用的<a class="ae jr" rel="noopener" href="/androiddevelopers/re-writing-the-aosp-deskclock-app-in-kotlin-76c836370cb">转换过程。今年夏天，我们将AOSP日历应用程序从Java转换成了Kotlin。在转换之前，该应用程序有超过18，000行代码。转换之后，我们能够减少大约300行代码。遵循与AOSP桌面时钟转换类似的技术，我们利用Kotlin与Java编程语言的互操作性，一个接一个地转换Java文件，并在转换时使用单独的构建目标将Java文件替换为它们的Kotlin等效文件。因为我们中的两个人正在做这件事，所以我们还在<code class="du kg kh ki kj b">Android.bp</code>文件中为我们每个人创建了一个<code class="du kg kh ki kj b">exclude_srcs</code>属性，这样我们两个人都可以转换和推送变更，同时减少合并冲突。此外，这使我们能够逐步测试并查明哪些文件导致了错误。</a></p><p id="209c" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为了转换任何给定的文件，我们从<a class="ae jr" href="https://developer.android.com/studio" rel="noopener ugc nofollow" target="_blank"> Android Studio的</a> Kotlin插件中的<a class="ae jr" href="https://developer.android.com/kotlin/add-kotlin#convert" rel="noopener ugc nofollow" target="_blank">自动Java到Kotlin转换工具</a>开始。虽然该插件成功地转换了大部分代码，但开发人员可能会遇到一些必须手动解决的问题。我们必须进行的手动更改将在下一节中描述。</p><p id="542c" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在将每个文件转换为Kotlin后，我们手动测试了日历应用程序的UI，运行了单元测试，并运行了<a class="ae jr" href="https://source.android.com/compatibility/cts" rel="noopener ugc nofollow" target="_blank">兼容性测试套件(CTS) </a>测试的子集，以验证功能并确保没有回归。</p><h1 id="682e" class="kk kl hs bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">自动转换后采取的步骤</h1><p id="b6a9" class="pw-post-body-paragraph iq ir hs is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ha bi translated">如前所述，在运行自动转换工具后，有许多重复出现的问题需要手动解决。AOSP桌面时钟的文章详细介绍了这些错误以及必要的修复。下面是我们在转换AOSP日历时遇到的几个例子。</p><h2 id="88b5" class="ln kl hs bd km lo lp lq kq lr ls lt ku jb lu lv ky jf lw lx lc jj ly lz lg ma bi translated"><strong class="ak">打开父类</strong></h2><p id="6f6c" class="pw-post-body-paragraph iq ir hs is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ha bi translated">我们遇到的一个问题是Kotlin中父类和子类的交互。在Kotlin中，要将类标记为可继承的，必须在类声明中添加<code class="du kg kh ki kj b">open</code>关键字。对于在子类中被覆盖的父类中的任何方法也是如此。<code class="du kg kh ki kj b">open</code>关键字在Java继承中不是必需的。由于Kotlin和Java的互操作性，这个问题直到大部分文件完全转换成Kotlin后才出现。</p><p id="e4a4" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">例如，下面的代码片段显示了一个继承了<code class="du kg kh ki kj b">SimpleWeeksAdapter</code>的声明类:</p><figure class="mb mc md me fd hj"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="aff7" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">由于转换过程是一次执行一个文件，这会导致一个错误，因为即使是完全转换的<code class="du kg kh ki kj b">SimpleWeeksAdapter.kt</code>文件在其类声明中也没有<code class="du kg kh ki kj b">open</code>关键字。这需要手动添加，以便<code class="du kg kh ki kj b">SimpleWeeksAdapter</code>可以继承。这个特定的类声明看起来像这样:</p><figure class="mb mc md me fd hj"><div class="bz dy l di"><div class="mf mg l"/></div></figure><h2 id="a472" class="ln kl hs bd km lo lp lq kq lr ls lt ku jb lu lv ky jf lw lx lc jj ly lz lg ma bi translated">覆盖修饰符</h2><p id="0395" class="pw-post-body-paragraph iq ir hs is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ha bi translated">类似地，子类中覆盖父类中方法的方法必须用一个<code class="du kg kh ki kj b">override</code>修饰符来标记。在Java中，这是使用<code class="du kg kh ki kj b">@Override</code>注释来完成的。然而，尽管看到了相应的Java注释，自动转换器并没有自动将<code class="du kg kh ki kj b">override</code>修饰符添加到Kotlin的方法声明中。修复方法是手动将<code class="du kg kh ki kj b">override</code>修饰符添加到所有适当的方法声明中。</p><h2 id="e4f1" class="ln kl hs bd km lo lp lq kq lr ls lt ku jb lu lv ky jf lw lx lc jj ly lz lg ma bi translated">覆盖属性</h2><p id="2ec3" class="pw-post-body-paragraph iq ir hs is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ha bi translated">在Kotlin中，我们遇到了另一个关于覆盖属性的异常问题。当一个子类声明了一个与父类中定义的非私有变量同名的变量时，我们需要添加一个<code class="du kg kh ki kj b">override</code>修饰符。然而，即使子类的变量与父类的类型不同，修饰符似乎仍然是必需的。添加<code class="du kg kh ki kj b">override</code>修饰符在某些情况下并不能解决问题，尤其是当子类的类型完全不同的时候。事实上，如果存在类型不匹配，将<code class="du kg kh ki kj b">override</code>修饰符添加到子类的变量并将<code class="du kg kh ki kj b">open</code>添加到父类的变量会导致另一个错误:</p><pre class="mb mc md me fd mh kj mi mj aw mk bi"><span id="10a5" class="ln kl hs kj b fi ml mm l mn mo">type of *property name* doesn’t match the type of the overridden var-property</span></pre><p id="c282" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这可能会造成混乱，因为在Java中，以下代码编译起来没有任何问题:</p><figure class="mb mc md me fd hj"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="0829" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">然而，在Kotlin中，下面相应的代码会导致前面提到的错误:</p><figure class="mb mc md me fd hj"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="a17f" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这是一个有趣的问题，目前我们已经重命名了子类中的变量以避免这种冲突。上面的Java代码片段用Android Studio当前的转换器转换成麻烦的Kotlin代码，甚至被<a class="ae jr" href="https://youtrack.jetbrains.com/issue/KTIJ-8621" rel="noopener ugc nofollow" target="_blank">报告为bug </a>。</p><h2 id="f31c" class="ln kl hs bd km lo lp lq kq lr ls lt ku jb lu lv ky jf lw lx lc jj ly lz lg ma bi translated">导入报表</h2><p id="f85d" class="pw-post-body-paragraph iq ir hs is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ha bi translated">在我们转换的每个文件中，自动转换器工具倾向于将Java文件中import语句的完整列表截断到相应Kotlin文件的第一行。最初，这会导致一些令人沮丧的错误，编译器会抱怨整个代码中存在“未知引用”。在意识到这个bug之后，我们开始手动将导入语句从Java文件复制到Kotlin文件，并单独转换该段。</p><h2 id="12a2" class="ln kl hs bd km lo lp lq kq lr ls lt ku jb lu lv ky jf lw lx lc jj ly lz lg ma bi translated">公开字段</h2><p id="b248" class="pw-post-body-paragraph iq ir hs is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ha bi translated">默认情况下，Kotlin会自动为类中的实例变量生成getters和setters。然而，有时我们希望变量是一个简单的Java字段。这可以使用<code class="du kg kh ki kj b">@JvmField</code>注释来完成。</p><p id="433c" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><a class="ae jr" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/" rel="noopener ugc nofollow" target="_blank"> @JvmField批注</a>“指示Kotlin编译器不要为该属性生成getter/setter，并将其作为字段公开”。这个注释在包含两个静态最终变量的<a class="ae jr" href="https://android.googlesource.com/platform/packages/apps/Calendar/+/42e4b43133c4f866e0729438fb38bebc6d03b0a4/src/com/android/calendar/CalendarData.kt" rel="noopener ugc nofollow" target="_blank"> CalendarData类</a>中特别有用。通过在只读<a class="ae jr" href="https://kotlinlang.org/docs/basic-syntax.html#variables" rel="noopener ugc nofollow" target="_blank"> val变量</a>上使用<code class="du kg kh ki kj b">@JvmField</code>注释，我们确保了这些变量可以作为字段被其他类访问，从而允许Java和Kotlin类之间的兼容性。</p><h2 id="6800" class="ln kl hs bd km lo lp lq kq lr ls lt ku jb lu lv ky jf lw lx lc jj ly lz lg ma bi translated">对象中的静态方法</h2><p id="8f09" class="pw-post-body-paragraph iq ir hs is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ha bi translated">在Kotlin对象中定义的函数必须用<code class="du kg kh ki kj b">@JvmStatic</code>标记，以允许它们在Java代码中通过方法名调用，而不是通过实例化。换句话说，这个注释强制类名调用的方法具有类似Java的行为。根据Kotlin <a class="ae jr" href="https://kotlinlang.org/docs/java-to-kotlin-interop.html#static-methods" rel="noopener ugc nofollow" target="_blank">文档</a>，“编译器将在对象的封闭类中生成一个静态方法，并在对象本身中生成一个实例方法。”我们在<a class="ae jr" href="https://android.googlesource.com/platform/packages/apps/Calendar/+/42e4b43133c4f866e0729438fb38bebc6d03b0a4/src/com/android/calendar/Utils.kt" rel="noopener ugc nofollow" target="_blank">实用程序文件</a>中遇到了这个问题。一旦被转换，Java类就变成了一个Kotlin对象。随后，对象中定义的所有方法都必须用<code class="du kg kh ki kj b">@JvmStatic</code>标记，这样就可以在其他文件中使用<code class="du kg kh ki kj b">Utils.<em class="jo">method</em>()</code>语法调用它们。另外值得一提的是，在类名和方法名之间使用<code class="du kg kh ki kj b">.INSTANCE</code>(<code class="du kg kh ki kj b">Utils.INSTANCE.method()</code>)是一种替代；然而，它违背了普通的Java语法，并且需要修改所有的Java静态方法调用。</p><h1 id="296e" class="kk kl hs bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">绩效评估和分析</h1><p id="b7fd" class="pw-post-body-paragraph iq ir hs is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ha bi translated">所有基准测试都是在具有96个内核和176 GiB RAM的机器上进行的。为这个项目分析的主要指标是删除的代码行数、目标APK大小、构建时间以及显示初始启动屏幕所用的时间。除了对上述每个因素的分析，我们还提供了为每个参数收集的数据的表格表示。</p><h2 id="a338" class="ln kl hs bd km lo lp lq kq lr ls lt ku jb lu lv ky jf lw lx lc jj ly lz lg ma bi translated">代码行被删除</h2><figure class="mb mc md me fd hj er es paragraph-image"><div class="er es mp"><img src="../Images/7c1632f36bc43fce2fe27f082baf8319.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*c-aRQcBhsUr4sMrsmDlxQQ.png"/></div></figure><p id="0d5e" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">从Java完全转换到Kotlin后，代码行数从<strong class="is ht"> 18，004减少到了17，729 </strong>。这大约比最初的Java代码减少了1.5%的T2。虽然减少的代码量并不多，但这种转换可能会大大减少大型应用程序的代码行，比如本文<a class="ae jr" rel="noopener" href="/androiddevelopers/re-writing-the-aosp-deskclock-app-in-kotlin-76c836370cb">中提到的</a>。</p><h2 id="c9af" class="ln kl hs bd km lo lp lq kq lr ls lt ku jb lu lv ky jf lw lx lc jj ly lz lg ma bi translated">目标APK尺寸</h2><figure class="mb mc md me fd hj er es paragraph-image"><div class="er es mq"><img src="../Images/50d455c43454319a3c9e18a78f7fa826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*c380T4gIJQ7q1-tt9Gpc2g.png"/></div></figure><p id="9c8d" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">Kotlin应用的APK大小为<strong class="is ht"> 2.7 MB </strong>，而Java应用的APK大小为<strong class="is ht"> 2.6 MB </strong>。可以肯定地说，这种大小差异可以忽略不计，由于包含了一些额外的小型Kotlin库，这种微小的大小增加实际上是意料之中的。这种尺寸的增加可以通过使用<a class="ae jr" href="https://developer.android.com/studio/build/shrink-code" rel="noopener ugc nofollow" target="_blank">progguard</a>或<a class="ae jr" href="https://r8.googlesource.com/r8" rel="noopener ugc nofollow" target="_blank"> R8 </a>来缓解。</p><h2 id="07aa" class="ln kl hs bd km lo lp lq kq lr ls lt ku jb lu lv ky jf lw lx lc jj ly lz lg ma bi translated">构建时间</h2><figure class="mb mc md me fd hj er es paragraph-image"><div class="er es mr"><img src="../Images/0b7a234e1102ddcae39ce36576870567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*GkKOCCZ7INIS5M8z2Usz7Q.png"/></div></figure><p id="52f5" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">Kotlin和Java应用程序的构建时间是通过取10次干净构建试验的平均时间(不包括异常值)来计算的。<strong class="is ht"> Kotlin应用程序</strong>的平均构建时间为<strong class="is ht"> 13分27秒</strong>，而<strong class="is ht"> Java应用程序</strong>的平均构建时间为<strong class="is ht"> 12分6秒</strong>。Java和Kotlin之间的差异(如<a class="ae jr" href="https://www.educba.com/java-vs-kotlin/" rel="noopener ugc nofollow" target="_blank"><em class="jo"/></a><em class="jo"/>和<a class="ae jr" rel="noopener" href="/keepsafe-engineering/kotlin-vs-java-compilation-speed-e6c174b39b5d"> <em class="jo"> Kotlin vs Java:编译速度</em> </a> <em class="jo"> </em>讨论到，特别是对于干净的构建，Kotlin编译时间实际上落后于Java的编译时间。一些分析断言Java的编译速度大约快10-15 %,而其他人则宣称快15-20%。根据干净编译时间，Java比Kotlin快大约11.2%，尽管这一微小的差异不在上述范围内，可能是由于AOSP日历是一个相对较小的应用程序，仅由43个类组成。尽管清理构建时间较慢，但Kotlin仍然有其优势，这一点应该被考虑在内。例如，如前所述，与Java相比，使用Kotlin的语法更简洁，因此通常可以保证代码量更少。这使得维护Kotlin代码库变得更加容易。此外，作为一种隐含的更安全和更高效的语言，可以合理地论证为什么较慢的干净构建时间可以忽略不计。</p><h2 id="4f24" class="ln kl hs bd km lo lp lq kq lr ls lt ku jb lu lv ky jf lw lx lc jj ly lz lg ma bi translated">初始显示时间</h2><figure class="mb mc md me fd hj er es paragraph-image"><div class="er es mr"><img src="../Images/f978abdf1ff748c93ccc643f8ecef124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*H4YCEQlSlzohe8DXgzyHWw.png"/></div></figure><p id="7d1b" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">使用<a class="ae jr" href="https://developer.android.com/topic/performance/vitals/launch-time#time-initial" rel="noopener ugc nofollow" target="_blank">这种方法</a>测试应用程序完全显示初始启动屏幕的时间，我们发现<strong class="is ht"> Kotlin应用程序</strong>在10次测试后的平均时间约为<strong class="is ht"> 197.7 ms </strong>，而<strong class="is ht">Java</strong>T8】应用程序的平均时间约为<strong class="is ht"> 194.9 ms </strong>。这些试验都是在Pixel 3a XL设备上进行的。从这个测试中可以得出结论，与Kotlin应用程序相比，Java应用程序可能具有微小的优势；然而，由于平均时间非常相似，时间差可能可以忽略不计。因此，可以肯定地说，AOSP日历的Kotlin转换没有对应用程序的初始启动时间产生负面影响。</p><h1 id="0a10" class="kk kl hs bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">结论</h1><p id="6b10" class="pw-post-body-paragraph iq ir hs is b it li iv iw ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ha bi translated">在两名实习生的参与下，将AOSP日历应用程序转换为Kotlin花费了大约1.5个月(6周)的时间。一旦我们熟悉了代码库，并且更加擅长解决反复出现的编译时、运行时和语法问题，效率肯定会提高。总的来说，这个特殊的项目成功地展示了Kotlin如何影响现有的Android应用程序，并被证明是向其他AOSP应用程序转换的下一个伟大步骤。</p></div></div>    
</body>
</html>