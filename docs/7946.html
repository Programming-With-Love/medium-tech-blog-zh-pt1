<html>
<head>
<title>Service Worker Lifecycle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">服务人员生命周期</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/service-worker-lifecycle-20333ccd570a?source=collection_archive---------1-----------------------#2020-11-30">https://medium.com/walmartglobaltech/service-worker-lifecycle-20333ccd570a?source=collection_archive---------1-----------------------#2020-11-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/cf63e0ccf770cf2c0ace6408f630b921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*s7YXv7rBkL7iVPapZCLCeA.gif"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Service Worker is symbolized with Gear (Source: <a class="ae it" href="https://www.deviantart.com/" rel="noopener ugc nofollow" target="_blank">https://www.deviantart.com</a> )</figcaption></figure><p id="434d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看gear GIF不要害怕。这不是一个机械工程相关的博客。相信我，这个博客是一个软件工程博客。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es js"><img src="../Images/dd4e4fd5420424cfe007944886327b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qC8kkk7hpMFEVGI3MPtQDw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The motto of this blog series</figcaption></figure></div><div class="ab cl jx jy go jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="ha hb hc hd he"><h1 id="c983" class="ke kf hh bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">什么是服务人员？</h1><p id="5d31" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi lh translated"><span class="l li lj lk bm ll lm ln lo lp di"> It </span> <strong class="iw hi"> </strong>是<strong class="iw hi"/>JavaScript程序，可以在您的web应用程序中使用，使其能够在客户离线时为客户请求提供服务，并提供各种功能，使您的Web应用程序成为<a class="ae it" href="https://developers.google.com/web/updates/2015/12/getting-started-pwa" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi">渐进式Web应用程序</strong> </a>。</p><p id="c90e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了更好地了解服务人员，请阅读<a class="ae it" rel="noopener" href="/walmartglobaltech/mobile-first-an-introduction-to-service-workers-61da5cb5780c">这篇</a>博客。</p><p id="cec0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇博客中，我们将讨论服务人员的生命周期。</p></div><div class="ab cl jx jy go jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="ha hb hc hd he"><h1 id="e157" class="ke kf hh bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">生命周期</h1><h2 id="d7ca" class="lq kf hh bd kg lr ls lt kk lu lv lw ko jf lx ly ks jj lz ma kw jn mb mc la md bi translated">注册服务工作者脚本</h2><p id="8121" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">为了启动服务工作者生命周期，我们首先需要<strong class="iw hi">在JavaScript( <em class="me"> main.js </em>)中注册</strong>我们的服务工作者脚本(<em class="me"> serviceWorker.js) </em>，该脚本链接到您的应用程序的登录页面(<em class="me">index.html</em>)。</p><p id="5e28" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面给出的代码用于检查ServiceWorker API在您的浏览器中是否可用。如果API可用，我们可以注册我们的服务工作者脚本。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Code that Registers your Service Worker script</figcaption></figure><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/8c3e84610d6c17b2f69b205c7b98a2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HUnu3nbBSq2lDoOSllBkiA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Service Worker Lifecycle (Source: <a class="ae it" href="https://developers.google.com/web/fundamentals/primers/service-workers" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/web/fundamentals/primers/service-worker</a>s)</figcaption></figure><h2 id="5e9b" class="lq kf hh bd kg lr ls lt kk lu lv lw ko jf lx ly ks jj lz ma kw jn mb mc la md bi translated"><strong class="ak"> <em class="mi">安装事件</em> </strong></h2><p id="ba81" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">这是服务工作者得到的第一个事件，每个服务工作者调用一次。这意味着，一旦注册了新的或更新的服务人员，它将被视为新的服务人员，并将获得自己的安装事件。<br/>在安装步骤中，我们可以缓存静态资产。创建缓存存储后，可以缓存静态文件，如媒体资产(图像、音频文件)、CSS文件、静态HTML页面。这一步是必不可少的，因为离线请求将被服务人员截获，并在此事件期间使用缓存的文件提供服务。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Code for Install Event</figcaption></figure><blockquote class="mj mk ml"><p id="b05e" class="iu iv me iw b ix iy iz ja jb jc jd je mm jg jh ji mn jk jl jm mo jo jp jq jr ha bi translated">在安装事件中，我们将一个<a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi">承诺</strong> </a>传递给<strong class="iw hi"> event.waitUntil() </strong>。我们可以记录与缓存和安装事件完成相对应的消息。使用<strong class="iw hi">open(cache name)</strong><em class="hh"/>创建缓存，并使用<strong class="iw hi">cache . addall(cache assets)</strong><em class="hh">将文件添加到缓存中。</em></p></blockquote><h2 id="aed6" class="lq kf hh bd kg lr ls lt kk lu lv lw ko jf lx ly ks jj lz ma kw jn mb mc la md bi translated">激活事件</h2><p id="5ebe" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">在安装事件之后，必须调用激活事件<strong class="iw hi"/>，以使服务工作器拦截来自该时间点的请求。注册服务工作者指令码的目前页面将不受已安装的服务工作者控制。我们需要重新加载该页面，以便将其置于服务工作者的控制之下。<br/> Activate event，是我们可以管理由老服务工作者创建的缓存的地方。我们可以删除旧版本的Service Worker创建的以前的缓存。<br/> <strong class="iw hi"> <em class="me">注意</em> </strong>:为每个脚本更新创建新的缓存通常由开发人员完成。因此，我们需要为每个服务工作者脚本更新更改缓存的名称。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Code for Activate Event</figcaption></figure><blockquote class="mj mk ml"><p id="5fba" class="iu iv me iw b ix iy iz ja jb jc jd je mm jg jh ji mn jk jl jm mo jo jp jq jr ha bi translated">在这里，我们向执行缓存管理的<strong class="iw hi">event . wait直至】(</strong>)传递一个承诺。在上述代码中，如果存在当前<strong class="iw hi"> cacheNam </strong> e以外名称的缓存，将被删除。</p></blockquote><p id="7dba" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">激活事件后，Service Worker将控制其<a class="ae it" href="#283f" rel="noopener ugc nofollow"> <strong class="iw hi">范围</strong> </a>内的所有页面。如果加载的站点处于离线状态，服务工作者将处理“<strong class="iw hi">获取</strong>”和“<strong class="iw hi">消息</strong>事件。如果连接处于空闲状态，则请求将由服务器提供服务，而Service Worker将被终止。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Handle Fetch Event by Serving file from Cache</figcaption></figure></div><div class="ab cl jx jy go jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="ha hb hc hd he"><h2 id="283f" class="lq kf hh bd kg lr ls lt kk lu lv lw ko jf lx ly ks jj lz ma kw jn mb mc la md bi translated">服务范围员工</h2><p id="fac8" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">我们的服务工作者的默认范围是相对于服务工作者脚本URL的<code class="du mp mq mr ms b">./</code>。这意味着，如果脚本位于根目录中，范围将是根目录中的所有文件、根目录中的包以及这些包下的所有文件。<br/>对于范围之外的页面的获取请求不会被Service Worker截获。因此，我们应该将Service Worker脚本放在目录中的某个位置，在该位置下存在大多数必须脱机可用的页面。</p><h2 id="061f" class="lq kf hh bd kg lr ls lt kk lu lv lw ko jf lx ly ks jj lz ma kw jn mb mc la md bi translated">服务工作者更新</h2><p id="ab74" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">如果服务工作者指令码有任何变更，下次使用者连线至网站时，浏览器将会在背景中重新下载指令码。它将与现有的一款产品同时推出，并会有自己的<strong class="iw hi"> Install </strong>活动。<br/>如果旧的服务工作者正在控制页面，则新的服务工作者将进入<strong class="iw hi">等待</strong>状态。安装事件成功后，新的服务工作者将不会获得激活事件，直到它完全控制客户端(即旧的服务工作者不再服务任何客户端请求)。如果所有加载的页面都关闭，旧的服务工作进程将被终止，而新的工作进程将获得控制权。此时，新的服务人员会收到<strong class="iw hi"> Activate </strong>事件。</p><p id="88a0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了避免<strong class="iw hi">等待</strong>状态，我们可以在Install事件中调用<code class="du mp mq mr ms b">self.skipWaiting()</code>。因此，新的服务工作人员会在安装完成后立即激活。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="mf mg l"/></div></figure></div><div class="ab cl jx jy go jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="ha hb hc hd he"><h1 id="a35f" class="ke kf hh bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">结论</h1><p id="8d1b" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">了解服务工作者生命周期非常重要。它可以帮助我们决定在哪里执行缓存和缓存管理的代码是正确的。当客户处于离线状态时，服务人员在服务客户请求方面非常有用。它还提供了<a class="ae it" href="https://developers.google.com/web/updates/2015/03/push-notifications-on-the-open-web" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi"> <em class="me">【推送通知】</em></strong></a><a class="ae it" href="https://developers.google.com/web/updates/2015/12/background-sync" rel="noopener ugc nofollow" target="_blank"><strong class="iw hi"><em class="me">后台同步</em> </strong> </a>等多种功能，可以帮助网络开发者给客户提供丰富的线下体验。</p><h1 id="4eba" class="ke kf hh bd kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx mx kz la lb bi translated">下一步是什么？</h1><p id="c38d" class="pw-post-body-paragraph iu iv hh iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">在了解了生命周期之后，我们应该看到一个实现服务工作者的例子。本系列的下一篇博客<a class="ae it" href="#" rel="noopener ugc nofollow">将展示Service Worker。它将帮助您更好地了解Service Worker的有用特性以及如何在web应用程序中实现这些特性。希望对你有所帮助🙂。</a></p></div></div>    
</body>
</html>