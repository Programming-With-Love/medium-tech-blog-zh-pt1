<html>
<head>
<title>Mock final and static methods on Android devices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android设备上模拟final和static方法</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/mock-final-and-static-methods-on-android-devices-b383da1363ad?source=collection_archive---------6-----------------------#2018-08-20">https://medium.com/androiddevelopers/mock-final-and-static-methods-on-android-devices-b383da1363ad?source=collection_archive---------6-----------------------#2018-08-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/da888d2e1488a05445a60aa7732eae28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pHq1PiqSMF0x3UqJwQQ21Q.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/photos/dmHnXJ-5ilQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Steven Lewis</a></figcaption></figure><h2 id="0be1" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><em class="js">TL；博士:</em></h2><p id="61cb" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">使用Android P，开发人员可以模仿final类和stub final和static方法。这将允许测试直接针对以前不可检测的类运行。</p><h2 id="8d8d" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">关于莫奇托</h2><p id="7adc" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated"><a class="ae it" href="http://site.mockito.org/" rel="noopener ugc nofollow" target="_blank"> Mockito </a>是一个流行的Java模仿库。开发人员可以使用它来拦截方法调用，并用其他行为替换它们:</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="a872" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">这种方法行为替换被称为“存根方法”。</p><p id="bf7f" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">此外，Mockito方法<code class="du kz la lb lc b"><a class="ae it" href="https://static.javadoc.io/org.mockito/mockito-core/2.19.1/org/mockito/Mockito.html#spy-T-" rel="noopener ugc nofollow" target="_blank">spy</a></code>创建原始对象的可清除克隆。间谍对象的字段是原始字段的副本，并且间谍对象的方法可以被存根化:</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="cf27" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">使用Mockito的插件系统，可以替换Mockito的某些组件。例如<a class="ae it" href="https://repo.spring.io/jcenter/org/mockito/mockito-android/" rel="noopener ugc nofollow" target="_blank"><em class="ld">mock ITO-android</em></a><em class="ld"/>和<em class="ld"/><a class="ae it" href="https://bintray.com/linkedin/maven/dexmaker-mockito" rel="noopener ugc nofollow" target="_blank"><em class="ld">dexmaker-mock ITO</em></a><em class="ld"/>用一个能够生成在Android设备上工作的模拟的组件替换常规的模拟生成组件。让我们使用“Mockito变体”这个术语来讨论替换了组件的Mockito库。</p><p id="a9eb" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">所有变体都支持相同的API，即<code class="du kz la lb lc b"><a class="ae it" href="https://static.javadoc.io/org.mockito/mockito-core/2.19.1/org/mockito/Mockito.html#when-T-" rel="noopener ugc nofollow" target="_blank">mock</a></code>、<code class="du kz la lb lc b"><a class="ae it" href="https://static.javadoc.io/org.mockito/mockito-core/2.19.1/org/mockito/Mockito.html#spy-T-" rel="noopener ugc nofollow" target="_blank">spy</a></code>、<code class="du kz la lb lc b"><a class="ae it" href="https://static.javadoc.io/org.mockito/mockito-core/2.19.1/org/mockito/Mockito.html#when-T-" rel="noopener ugc nofollow" target="_blank">when</a></code>、<code class="du kz la lb lc b"><a class="ae it" href="https://static.javadoc.io/org.mockito/mockito-core/2.19.1/org/mockito/Mockito.html#verify-T-" rel="noopener ugc nofollow" target="_blank">verify</a></code>等。</p><h2 id="39f0" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">Stubbing最终方法</h2><p id="d7df" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">常规的Mockito模仿和间谍是模仿类的子类。所有拦截代码都存在于覆盖原始方法的方法中。因此，最初只能清除非最终实例方法。</p><p id="7e4a" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">从Mockito 2.1.0开始，Mockito变体<a class="ae it" href="https://repo.spring.io/jcenter/org/mockito/mockito-inline/" rel="noopener ugc nofollow" target="_blank"> <em class="ld"> mockito-inline </em> </a>也允许开发者存根最终方法:</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="5314" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">由于最终方法不能被覆盖，<em class="ld">的模拟生成代码mockito-inline </em>会修改被模拟类的字节码，并将拦截代码直接内联到原始方法中。</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es le"><img src="../Images/5355e44db548bb51eb10f1b039217012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W78u1T69tZANxeehI1Gr5g.png"/></div></div></figure><p id="6c8f" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated"><em class="ld"> mockito-inline </em>实现了对基于Java字节码的运行时的存根最终方法的支持。Android运行时使用<a class="ae it" href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode" rel="noopener ugc nofollow" target="_blank"> Dalvik字节码</a>，因此该变体不适用于Android。</p><p id="9e68" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">Mockito变种<a class="ae it" href="https://bintray.com/linkedin/maven/dexmaker-mockito-inline" rel="noopener ugc nofollow" target="_blank"><em class="ld">dexmaker-mock ITO-inline</em></a>可以通过使用Android P中增加的改进的<a class="ae it" href="https://en.wikipedia.org/wiki/Java_Virtual_Machine_Tools_Interface" rel="noopener ugc nofollow" target="_blank"> JVMTI </a>功能，将方法调用拦截代码内联到原类的Dalvik字节码中。</p><p id="5959" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">JVMTI是应用程序和运行时之间的接口。它允许对当前应用程序进行深度自省和操作。目前，该应用程序需要标记为<a class="ae it" href="https://developer.android.com/guide/topics/manifest/application-element#debug" rel="noopener ugc nofollow" target="_blank">Android:debuggeable</a>才能使用JVMTI。因此<em class="ld">dexmaker-mock ITO-inline</em>要求将应用程序标记为可调试。</p><p id="dd80" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">在Android P之前，JVMTI支持不足以满足T21的需求。因此，新的模拟功能至少需要Android P。</p><h2 id="2c57" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">Android特有的增强功能</h2><p id="c28e" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn ha bi translated">用于最终方法的相同字节码修改可用于允许开发人员存根静态方法。Mockito API <a class="ae it" href="https://github.com/mockito/mockito/issues/1013" rel="noopener ugc nofollow" target="_blank">还没有提供stub静态方法的接口</a>，因此需要添加新的接口。</p><p id="47ec" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">与常规的实例存根化最大的区别是没有自然的地方来重置静态方法的存根化。为了定义范围，mock ITO variant<a class="ae it" href="https://bintray.com/linkedin/maven/dexmaker-mockito-inline-extended" rel="noopener ugc nofollow" target="_blank"><em class="ld">dexmaker-mock ITO-inline-extended</em></a>扩展了<a class="ae it" href="https://static.javadoc.io/org.mockito/mockito-core/2.7.6/org/mockito/MockitoSession.html" rel="noopener ugc nofollow" target="_blank"> Mockito sessions </a>来定义嘲讽的范围。<em class="ld">dexmaker-mockito-inline-extended</em>是dex maker-mock ITO-inline的扩展，因此适用相同的限制。</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="4d96" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">在Android中，某些对象是由系统创建的。因此，拦截此类对象的创建并不容易。这类物体中最突出的可能是<a class="ae it" href="https://developer.android.com/reference/android/app/Activity" rel="noopener ugc nofollow" target="_blank">活动</a>物体。</p><p id="b2e3" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">为了解决这个问题<em class="ld">, dexmaker-mock ITO-inline-extended</em>添加了将现有对象转换为间谍的方法<code class="du kz la lb lc b"><a class="ae it" href="https://moltmann.github.io/dexmaker/com/android/dx/mockito/inline/extended/ExtendedMockito.html#spyOn-java.lang.Object-" rel="noopener ugc nofollow" target="_blank">spyOn</a></code>。</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="8810" class="pw-post-body-paragraph jt ju hh jv b jw ku jy jz ka kv kc kd jf kw kf kg jj kx ki kj jn ky kl km kn ha bi translated">关于新增功能的完整描述可在<a class="ae it" href="https://moltmann.github.io/dexmaker/com/android/dx/mockito/inline/extended/ExtendedMockito.html" rel="noopener ugc nofollow" target="_blank"> github </a>上找到。</p><h2 id="c8a5" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">基于Dalvik字节码的运行时的Mockito变体比较</h2><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lf"><img src="../Images/bb69b0f89f47bb34f883664e24c9af50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7teh9eqN5jE57zkxmkn-LQ.png"/></div></div></figure><h2 id="e5f8" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">端到端示例</h2><div class="lg lh ez fb li lj"><a href="https://github.com/moltmann/dexmaker-mockito-inline-extended-examples/blob/master/app/src/main/java/priv/moltmann/locationlogger/LocationLogger.java" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab dw"><div class="ll ab lm cl cj ln"><h2 class="bd hi fi z dy lo ea eb lp ed ef hg bi translated">应用</h2><div class="lq l"><h3 class="bd b fi z dy lo ea eb lp ed ef dx translated">dex maker-mock ITO-inline-extended-Examples-dex maker-mock ITO-inline-extended的示例</h3></div><div class="lr l"><p class="bd b fp z dy lo ea eb lp ed ef dx translated">github.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx in lj"/></div></div></a></div><div class="lg lh ez fb li lj"><a href="https://github.com/moltmann/dexmaker-mockito-inline-extended-examples/blob/master/app/src/androidTest/java/priv/moltmann/locationlogger/PermissionGrantLocationLoggerTest.java" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab dw"><div class="ll ab lm cl cj ln"><h2 class="bd hi fi z dy lo ea eb lp ed ef hg bi translated">试验</h2><div class="lq l"><h3 class="bd b fi z dy lo ea eb lp ed ef dx translated">dex maker-mock ITO-inline-extended-Examples-dex maker-mock ITO-inline-extended的示例</h3></div><div class="lr l"><p class="bd b fp z dy lo ea eb lp ed ef dx translated">github.com</p></div></div><div class="ls l"><div class="ly l lu lv lw ls lx in lj"/></div></div></a></div></div></div>    
</body>
</html>