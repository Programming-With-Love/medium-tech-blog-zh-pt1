<html>
<head>
<title>Guide of the Advanced Encryption Standard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级加密标准指南</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/understanding-the-advanced-encryption-standard-7d7884277e7?source=collection_archive---------1-----------------------#2020-04-27">https://medium.com/quick-code/understanding-the-advanced-encryption-standard-7d7884277e7?source=collection_archive---------1-----------------------#2020-04-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="fd21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">AES演练:它是什么以及如何工作。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/5540cb0b41e7d36ffcc64da73958076b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GkW1SMdK55ZjciuE"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@tinaflour?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kristina Flour</a> on <a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="50d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">或简称为AES，是当今最常用的加密算法，因为它仍未被破坏。在本文中，我们将介绍AES:它是什么以及它是如何工作的。</p><h1 id="fbfd" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">编码不是加密</h1><p id="5431" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">如果您不熟悉这个术语，加密可以定义为将信息或数据转换为代码以隐藏其原始内容的过程。因此，解密就是将这种加密代码转换回原始状态的过程。为了将其视为加密而非编码，需要一个<strong class="ig hi">密钥</strong>。</p><p id="f02c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们用锁来打个比方。如果你只是关闭锁，而没有用T2钥匙T3锁住，它看起来像是被锁住了，但实际上任何人都可以打开它。为了确保锁的安全，你必须用你的<strong class="ig hi">钥匙</strong>锁住它，所以没有你用来锁住它的<strong class="ig hi">钥匙</strong>它是打不开的。就像关上锁一样，编码信息给人一种被加密的感觉，但实际上任何人都可以将其转换回原始状态。对于加密来说，情况并非如此。</p><h1 id="1f91" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">破解AES</h1><p id="77a3" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">AES是对称密码，这意味着，就像我们以前的锁一样，用于加密数据的相同密钥是解密数据所必需的。我们之前提到过AES保持不变，但这是什么意思呢？这意味着，在不知道密钥的情况下，还没有找到比通过<strong class="ig hi">暴力破解其密钥更快的解密AES加密数据的方法:</strong>检查所有可能的密钥，直到找到用于加密的密钥。</p><p id="b727" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回到我们的类比，这就好比有一个装满钥匙的包，一个一个地检查它是否打开了锁。但是在AES中找到正确的密钥要稍微微妙一些。如果你用不同于加密所用的密钥解密一条加密的消息，结果将是一组随机的字符，和加密的消息一样有意义:没有。</p><p id="d756" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们知道一把锁的钥匙可能是什么样子，但是AES钥匙是什么样子的呢？</p><p id="3ee6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">AES密钥是一串位(1和0)，有三种不同的大小:128、192或256位。所以，要想暴力破解AES，你可能要在找到正确的密钥之前，遍历⁵⁶不同的密钥。为了以更人性化的方式设置密钥，它们可以用Unicode字符<a class="ae js" href="https://www.utf8-chartable.de/" rel="noopener ugc nofollow" target="_blank"/>(字母、数字和一些符号)建立，每个字符占用8位。密钥越长，加密过程就越强，因此您应该始终使用256位密钥。</p><h1 id="c7d7" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">操作模式</h1><p id="4e0e" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">AES是一种分组密码:它将接收128位文本，这些文本将被转换以获得不同的128位加密数据。但是128位或16个字符很可能不足以容纳我们希望加密的所有数据，那么AES如何加密充满文本的整个文档呢？</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es kw"><img src="../Images/568d60d804c02d78bbbfc8562fecc6ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2qtphu8RTSQTOVuvQNygQ.png"/></div></div></figure><p id="e79c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">分而治之，AES将您希望加密的数据分割成128位大小的块，然后对它们进行加密。如果输入数据不是128的倍数，我们必须延长消息的长度。这个过程被称为<strong class="ig hi">填充</strong>，最简单的形式是在消息的末尾加上0，直到它是128位的倍数。</p><p id="a28e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们希望如何以及以什么样的顺序加密和进一步显示我们的数据块属于<strong class="ig hi">操作模式</strong>的范畴。操作模式并不是AES所独有的，事实上，本文所涉及的操作模式几乎可以应用于任何其他分组密码。</p><h2 id="0ffa" class="kx ju hh bd jv ky kz la jz lb lc ld kd ip le lf kh it lg lh kl ix li lj kp lk bi translated">英国板球理事会</h2><p id="9e41" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">最简单的一个，<strong class="ig hi"> ECB </strong>，自己加密每个块，并一个接一个地显示加密后的块。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es kw"><img src="../Images/33ca5d5347025e660d7853f9e84f908d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odZgv-842fB_bJ1Zir873A.png"/></div></div></figure><p id="a274" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是欧洲央行也有弱点，因为它不能恰当地隐藏重复的信息。为了演示这一点，让我们来看看Linux的penguin在<strong class="ig hi"> ECB </strong>模式下的加密结果:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ll"><img src="../Images/7c60e768b65f65daa3233e3e2c89eca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bFbOMVCHJNznFWr80oF33g.png"/></div></div></figure><p id="2f7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管丢失了一些信息，加密后的图像仍然可以辨认，而且看起来也不是随机的。为此，您应该避免使用<strong class="ig hi"> ECB </strong>模式，而是使用更复杂的模式，例如<strong class="ig hi"> CBC </strong>。</p><h2 id="074a" class="kx ju hh bd jv ky kz la jz lb lc ld kd ip le lf kh it lg lh kl ix li lj kp lk bi translated">加拿大广播公司</h2><p id="e23b" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><strong class="ig hi"> CBC </strong>输入AES密码，即当前纯文本块和先前加密块之间异或运算的结果。对于第一个明文块，由于没有先前的加密块，所以需要一个<strong class="ig hi">初始化向量</strong>来执行xor运算。这个<strong class="ig hi"> IV </strong>将与我们的块具有相同的大小，128位或16个字符。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lm"><img src="../Images/7572fd361c5138397ed0b6810df5bd48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*IAFxh1Y-R6GUVcuHGsi-QA.png"/></div></figure><p id="9caf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每次加密时生成一个新的<strong class="ig hi"> IV </strong>被认为是一个很好的做法，这样可以使输出更加随机。但是为了在<strong class="ig hi"> CBC </strong>模式下解密，我们现在还必须将<strong class="ig hi"> IV </strong>用于加密，因此它应该放在加密块之前，并且成为加密输出的一部分。使用这种方法，当我们想要解密时，我们知道我们加密消息的第一块是IV。</p><p id="bef4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然还有多种加密模式，但<strong class="ig hi"> ECB </strong>和<strong class="ig hi"> CBC </strong>是最具启发性的，因为它们表明选择正确的操作模式与选择加密算法同样重要。其他流行的操作模式有<strong class="ig hi"> OFB </strong>、<strong class="ig hi"> CTR </strong>或<strong class="ig hi"> CFB。这篇文章不会涉及到它们，但是如果你感到好奇的话，可以随意了解它们。</strong></p><h1 id="b386" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">加密</h1><p id="e849" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">到目前为止，我们已经介绍了AES如何通过将大量输入分成128位的块来加密它们，但是我们还没有介绍数据实际上是如何加密的:当AES加密数据时，它内部发生了什么。</p><p id="b7b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可能还记得，我们之前提到过，AES可以有三种大小的密钥，即128、192、256位，密钥越长，加密越强。为了理解这一点，我们必须知道，当AES加密时，如果在一定数量的轮次中应用相同的算法加密算法，则每轮次使用不同的子密钥，该子密钥是在称为<strong class="ig hi">密钥扩展</strong>的过程中从我们的初始密钥生成的。我们的密钥越长，AES能够生成的子密钥就越多，因此可以对加密算法执行更多轮次，从而实现更强的加密。</p><p id="0aab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该算法由4个操作组成:<strong class="ig hi">字节Sub、移位行、混合列</strong>和<strong class="ig hi">添加轮密钥</strong>。对于视觉表示，我们的128位输入文本块将被表示在一个4×4矩阵上，每个位置表示来自我们的输入块的8位。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ln"><img src="../Images/017fa08c0a34f521b0a685bb5c3e18d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*-cu6QEdXQY58t2AZXi5EsQ.png"/></div></figure><h2 id="43c1" class="kx ju hh bd jv ky kz la jz lb lc ld kd ip le lf kh it lg lh kl ix li lj kp lk bi translated">字节Sub</h2><p id="ddd5" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">顾名思义，Byte Sub将每个8位单元替换为另外8位。什么8位？这8位将从预定义的查找表中选择，在整个循环中保持不变。又是怎么做到的？每个单元的前四位将决定行，后四位决定列，这是查找表的位置，在该位置我们可以找到将替换该单元的8位。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lo"><img src="../Images/bdca05967453692a483eae23c45c817b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nN5lt3mk6Sk65yCIbjRnrg.png"/></div></div></figure><p id="020a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是<strong class="ig hi">字节子</strong>查找表:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lp"><img src="../Images/e6afc8905ac9fb11b334e97a34e84592.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*FVS5Za7vIh5s9kVm3ix5_g.jpeg"/></div></figure><p id="8c17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">查找表的值以十六进制编码，每个数字对应4位。因此，如果每个单元格中有两位数，每个单元格就相当于8位空间，就像我们的输入矩阵一样。</p><p id="1212" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们做一个简单的例子。假设a有一个值为10100101或A5的单元格。它将被查找表中的行A或10和列10中的单元替换为06或00000110。</p><h2 id="3ad1" class="kx ju hh bd jv ky kz la jz lb lc ld kd ip le lf kh it lg lh kl ix li lj kp lk bi translated">移动行</h2><p id="4e65" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">比<strong class="ig hi"> Byte Sub </strong>简单，顾名思义，将矩阵的每一行向左移动。几个位置？第一行根本不会移动，第二行将移动一个位置，第三个移动两个位置，第四个和最后一个移动3个位置。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lo"><img src="../Images/f8de6ebb9e7f6411e278320c113ebe44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FVvkJz-MnHth7Dzj9AQow.png"/></div></div></figure><h2 id="790c" class="kx ju hh bd jv ky kz la jz lb lc ld kd ip le lf kh it lg lh kl ix li lj kp lk bi translated">混合列</h2><p id="ff5b" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">在Mix列中，我们将在当前矩阵和预定义的给定矩阵之间执行矩阵乘法，该乘法在整轮中保持不变。但是这是一个稍微复杂一点的矩阵乘法，因为求和运算被<strong class="ig hi">异或</strong>和乘法运算代替了<strong class="ig hi">和。</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lq"><img src="../Images/a90e86dc51e4dab540803f3375c416c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*RIsEo_r50T1595fhc7CKEw.png"/></div></figure><h2 id="0109" class="kx ju hh bd jv ky kz la jz lb lc ld kd ip le lf kh it lg lh kl ix li lj kp lk bi translated">添加圆形密钥</h2><p id="6214" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">到现在为止，我们根本没有加密信息。所有这些转换都可能被任何人取消，因为我们还没有将我们的关键引入等式。每个轮密钥的长度为128位，因此我们可以用与输入块相同的方式在矩阵中表示它。现在，我们将在我们的输入块的每个块之间执行<strong class="ig hi">异或</strong>运算，该输入块是来自密钥矩阵的相应块。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lo"><img src="../Images/c7b8192a7a99e796a66756b6fcaa5d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOMkCqoYEiva6zbZDdrdQg.png"/></div></div></figure><p id="d15c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是AES加密的工作原理！既然我们能够加密，我相信我们会在某个时候恢复这些信息:让我们来谈谈<strong class="ig hi">解密</strong>。</p><p id="ead9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">解密</strong></p><p id="5f46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你理解了加密过程，你理解解密过程就不会有太大的困难。正如人们最初可能认为的那样，为了解除加密，我们必须逆转加密过程。我们将执行相同的操作，只是顺序相反。与加密相反，这是解密算法:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lr"><img src="../Images/10f1cca7168e19d05cc21d9c0e5c502e.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*XdC3ZfRLZDiIZ96pxoFeig.png"/></div></figure><p id="82df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可能已经注意到，这个图看起来与加密算法相当相似，事实上它们是相似的！但是如果你更仔细地观察，你会注意到所有的操作都以<strong class="ig hi"> INV </strong>开始，这象征着相反的操作。例如，<strong class="ig hi">逆混合列</strong>是混合列的逆运算。这是什么意思？这意味着为了反转混合列操作，我们必须应用<strong class="ig hi">反转混合列</strong>。</p><h2 id="8264" class="kx ju hh bd jv ky kz la jz lb lc ld kd ip le lf kh it lg lh kl ix li lj kp lk bi translated"><strong class="ak">反相加圆键</strong></h2><p id="2cac" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">是它自己的逆:如果你申请了两次添加轮键，你将离开你开始。由于这个属性，为了撤销添加轮密钥，我们必须再次应用它。为此，<strong class="ig hi">反加圆键</strong>和加圆键是<strong class="ig hi">相同的操作</strong>。</p><h2 id="c442" class="kx ju hh bd jv ky kz la jz lb lc ld kd ip le lf kh it lg lh kl ix li lj kp lk bi translated">反向移位行</h2><p id="fd24" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">如果您还记得，shift rows只是将每一行向左移动了一定数量的位置。因此，为了反转，我们必须将每行移动相同数量的位置，但要向右移动。就这么简单！</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ls"><img src="../Images/bedbfd4fc8f0be5451d44e960735993e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0746YF9NDmJ5Jn-Lx7a_Q.png"/></div></div></figure><h2 id="1704" class="kx ju hh bd jv ky kz la jz lb lc ld kd ip le lf kh it lg lh kl ix li lj kp lk bi translated">反向子字节</h2><p id="c409" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">本质上是与子字节相同的操作:它将获取我们矩阵中的每个块，并与预定义矩阵中的另一个块交换。在<strong class="ig hi">反向子字节</strong>和子字节之间唯一改变的就是这个表。这是<strong class="ig hi">反向子字节</strong>的表格:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lt"><img src="../Images/c021293f34a76d0be485a4dc5dee0b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*c3bp1VcuhjnTaHe5zKcgBA.png"/></div></figure><p id="9dcb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">逆混列</strong></p><p id="cd98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你懂一些代数，你会记得如果我们用矩阵c乘以它的逆矩阵C^-1，我们得到的结果是。如果你不熟悉代数的这些概念，可以把恒等式想成1:如果我们把5和它的倒数1/5相乘，我们得到1。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lu"><img src="../Images/f339c93e4babd457252a8b88793a2b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*cP92owyRPD8XHijjuuYrYA.png"/></div></figure><p id="0e1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，让我们将数据矩阵称为X。在混合列中，我们设置X = X C。为了取消此乘法，我们必须乘以C的倒数，如下所示:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lv"><img src="../Images/8a9d8f00de48a4b71e591e93efc3a847.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*3I0XWZUXBlY_5qjcYfA91A.png"/></div></figure><p id="0392" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在Mix列中显示了C矩阵，因此这里我们将显示C的逆:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lw"><img src="../Images/14a63b923e693dff5dc22d53cecc3547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*peP0o_5NpcmpJ8xJvJatog.jpeg"/></div></div></figure><p id="fa6d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就是这样！我们已经介绍了什么是AES，如何在不同的操作模式下使用，并希望了解如何使用它进行加密和解密。如果你想钻研AES，我推荐这篇<a class="ae js" href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197.pdf" rel="noopener ugc nofollow" target="_blank">文章</a>。希望你喜欢这篇文章，</p><p id="f73f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">加密快乐！</p></div></div>    
</body>
</html>