<html>
<head>
<title>Enabling Modern JavaScript in Rails with Webpack(er)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Webpack(er)在Rails中启用现代JavaScript</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/enabling-modern-javascript-in-rails-with-webpack-er-fd4a1b8dd0c6?source=collection_archive---------0-----------------------#2018-11-06">https://medium.com/square-corner-blog/enabling-modern-javascript-in-rails-with-webpack-er-fd4a1b8dd0c6?source=collection_archive---------0-----------------------#2018-11-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/0d4014a348766190e51968e00cc5693d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G7Q5Xo5_n4-BE80M"/></div></div></figure><blockquote class="ip iq ir"><p id="a6d1" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jr" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="9a25" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">当我在2016年加入Caviar时，我完全被React和所有关于构建模块化系统的好东西所吸引。jQuery不再是街区里最酷的孩子了。NPM是获得任何缺失的依赖的地方。随着Babel等编译器帮助旧浏览器支持新语法，ES6开始获得更多关注。</p><p id="dd01" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我很高兴听到鱼子酱使用反应！我可以看到自己用承诺和酷的新语法构建组件。只使用过Node，很容易找到与JavaScript相关的解决方案。想要在旧浏览器上使用ES6，还是想要在工作时检查代码的linter？没问题，Webpack支持你。那是在我对Rails约定一无所知之前。</p><h1 id="34f1" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">JavaScript: Rails被忽视的兄弟</h1><p id="a77f" class="pw-post-body-paragraph is it hh iv b iw kx iy iz ja ky jc jd js kz jg jh jt la jk jl ju lb jo jp jq ha bi translated">另一方面，众所周知，Rails更喜欢约定而不是配置。这意味着它对如何处理JavaScript有强烈的意见。具体来说，Rails有自己的资产打包库，称为“链轮”,它没有预先配置来解决NPM依赖性。相反，jQuery和少量由Gems包装的流行JavaScript库是可用的。最重要的是，Rails附带的语言是CoffeeScript，它正在失去对日益流行的ES6语法的青睐。</p><p id="f865" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">前端资产的Rails设置当然可以工作，但是从节点设置来看，架构感觉很旧，各个部分看起来没有很好地结合在一起。路径解析很难配置，而且有一些非常奇怪的方式来包含依赖关系。由于<code class="du jv jw jx jy b">node_modules</code>不是开箱即用的，如果你想包含一个供应商依赖，你必须寻找一个Gem，或者手动下载依赖，并把它放在<code class="du jv jw jx jy b">vendor/assets/javascripts</code>目录中。然后，供应商库可以通过链轮特殊指令处理器，如<code class="du jv jw jx jy b">//=require jquery</code>，包含到基本<code class="du jv jw jx jy b">application.js</code>清单文件中。这对于在浏览器的全局上下文中实例化的传统依赖关系来说很好，但是如果您需要预处理代码或使用CommonJS，事情就会变得很糟糕。要求模块的语法变得臃肿，因为除了JavaScript <code class="du jv jw jx jy b">require</code>之外，还需要通过链轮包含模块。</p><p id="28b9" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">链轮能够通过从左到右读取扩展来预处理JS代码。因此，如果您想处理一些Rails环境，然后将CoffeeScript处理成普通的JS，那么您会有一个类似于<code class="du jv jw jx jy b">*.js.coffee.erb</code>的扩展。最重要的是，为了支持React，我们使用了<code class="du jv jw jx jy b">react-rails</code>，它允许通过添加<code class="du jv jw jx jy b">*.js.jsx</code>来处理React文件，所以现在有了<code class="du jv jw jx jy b">*.js.jsx.coffee</code>(幸运的是我们在JavaScript中没有经常编译Rails数据)。但是等等，还有呢！如果您想使用CommonJS require语法，您必须安装另一个名为链轮-commonjs的Gem，它要求您为要用Javascript require(…)语法处理的文件添加<code class="du jv jw jx jy b">*.module*</code>扩展名。这意味着我们几乎所有的React文件都以<code class="du jv jw jx jy b">*.module.js.jsx.coffee</code>结尾😰。</p><p id="57da" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">在Rails Asset Pipeline的指导下工作使得实现模块化代码库变得困难，因为它将开发人员限制在旧的整体依赖上。在React中使用jQuery通常是不被允许的，但是我们确实没有任何方法可以合理地填充承诺或获取。这限制了我们使用过时的编码方法，我们将来不得不重构这些方法。当使用像React这样的视图库时，没有NPM是一个巨大的障碍，因为通常的做法是通过可用的NPM依赖项来“构建自己的框架”。</p><p id="89c2" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">这个公式缺少的组件是一个像Webpack这样的构建工具。众所周知，Webpack很难配置，但是一旦安装完毕，它就是JavaScript社区中最通用的资产打包库。通过Webpack加载器和插件，你可以实现树抖动、代码分割、热模块重载、ES6编译和代码林挺等等。问题是没有用Rails安装Webpack常规方法。我们考虑过像<code class="du jv jw jx jy b">react_on_rails</code>这样的库，但是设置它需要大量的重构，我们负担不起。</p><h1 id="1ee5" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">输入Webpacker</h1><p id="0135" class="pw-post-body-paragraph is it hh iv b iw kx iy iz ja ky jc jd js kz jg jh jt la jk jl ju lb jo jp jq ha bi translated">幸运的是，Rails社区也发现了对Webpack的需求。他们推出了兼容Rails 4.2+的<code class="du jv jw jx jy b">Webpacker</code> gem。开箱即用，Webpacker生成应用开发、试运行和生产环境最佳实践的配置。这立即与我们的部署管道一起工作，因为它被预先配置为遵循Rails约定。具体来说，它将构建过程与<code class="du jv jw jx jy b">rake asset:precompile</code>联系起来。这为我们节省了大量处理配置文件的时间，让我们可以将注意力集中在重构和移植代码上。</p><h1 id="0388" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">迁移过程</h1><p id="057c" class="pw-post-body-paragraph is it hh iv b iw kx iy iz ja ky jc jd js kz jg jh jt la jk jl ju lb jo jp jq ha bi translated">理想情况下，最好能留出大量时间来进行迁移。事实上，我们仍然有许多功能要发布，在一个不会立即给公司的成功带来回报的项目上花费时间并不总是容易的。尽管如此，我认为控制我们的技术债务并向现代堆栈发展是很重要的。因此，我们在迁移中采用了增量方法，在一段时间内加载两个应用程序包。为了节省时间，我们专注于纯重构，在第一次通过时解决不太理想的更改，以便我们不会破坏任何特定的拉请求。</p><p id="35db" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">我们首先开始移动明显的模块化组件；在我们的代码库中，它是React组件。由于新代码会定期添加，因此不中断其他工程师的工作流程非常重要。尽管Webpacker的默认Javascript目录位于<code class="du jv jw jx jy b">app/javascript</code>中，但我通过<code class="du jv jw jx jy b">resolve.modules</code>属性重新配置了Webpack，将旧路径<code class="du jv jw jx jy b">app/assets/javascripts</code>作为根路径。现在我们的文件中使用的相对路径是有效的，但是我们必须做一些调整来处理长文件扩展名。</p><p id="93de" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">为了处理我们的文件扩展名，Webpack需要将长扩展名视为单个扩展名。我将所有不同的扩展组合添加到了<code class="du jv jw jx jy b">resolve.extensions</code>数组中。接下来，我必须对现有的加载器进行一些调整。Webpacker附带了通过Babel编译Coffeescript和React的加载器，但没有将两者结合起来，也没有处理我们特殊文件扩展名的能力。为了实现这一点，我添加了以下加载程序。</p><pre class="lc ld le lf fd lg jy lh li aw lj bi"><span id="e808" class="lk ka hh jy b fi ll lm l ln lo">module.exports = {<br/>  test: /(\.module)?\.js(\.jsx)?\.coffee$/,<br/>  exclude: /node_modules/,<br/>  use: ['babel-loader', 'coffee-loader']</span><span id="1b06" class="lk ka hh jy b fi lp lm l ln lo">}</span></pre><p id="bd16" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">如果一个文件的扩展名与在<code class="du jv jw jx jy b">test</code>属性中指定的正则表达式匹配，它将从左到右应用在<code class="du jv jw jx jy b">use</code>中指定的加载器。</p><p id="a65c" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">迁移页面加载时执行的旧Javascript资产相当简单。您可以使用<code class="du jv jw jx jy b">require.context</code>指定整个目录作为解析路径的基本上下文。遍历上下文中的每个路径并解析文件将实例化代码。</p><pre class="lc ld le lf fd lg jy lh li aw lj bi"><span id="d492" class="lk ka hh jy b fi ll lm l ln lo">const context = require.context(‘global’);<br/>context.keys().forEach(context);</span></pre><p id="89bf" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">一旦通过Webpack配置正确处理了路径解析，就可以安全地将Webpack成功编译的文件迁移到传统的<code class="du jv jw jx jy b">app/javascript</code>目录。迁移文件和重命名扩展名被留在最后一步，以减少其他工程师的困惑。</p><p id="75df" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">最后，我们使用Yarn代替Rails bundler或者通过供应商目录重新安装了我们的供应商依赖。由于依赖关系通常是使用链轮在全局上下文中实例化的(而Webpack将只包含您显式注入的依赖关系)，您将需要遍历每个文件以找到模块使用的<code class="du jv jw jx jy b">require</code>依赖关系。除非您有一个脚本来注入依赖项，否则这可能非常耗时。作为替代，无论何时发现某个变量，如<code class="du jv jw jx jy b">moment</code>或<code class="du jv jw jx jy b">React</code>，都可以使用<code class="du jv jw jx jy b">ProvidePlugin</code>来要求依赖关系。这样做的缺点是，您正在向代码库引入魔法，而不是明确在任何给定的文件中使用了哪些依赖项。</p><h1 id="7119" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">立即改进</h1><p id="e0d6" class="pw-post-body-paragraph is it hh iv b iw kx iy iz ja ky jc jd js kz jg jh jt la jk jl ju lb jo jp jq ha bi translated">一旦迁移完成，就会有一些立竿见影的效果。Webpack的生产配置将自动缩小您的应用程序包，并对您的资产名称应用哈希，以使浏览器中的缓存资产无效。您可以进一步为您的供应商和入口包设置一个单独的块，因为供应商文件很少更改。</p><p id="05f2" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">使用Webpack，您还可以用加载器设置林挺和ES6编译。ES6已经附带了Webpacker，所以您可以立即开始使用新的语法。需要注意的是，您可能需要包含<code class="du jv jw jx jy b">presets</code>来启用React编译。ESLint也像安装和配置<code class="du jv jw jx jy b">eslint-loader</code>一样简单。</p><p id="3343" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">如果您觉得您的包变得太大，您可以设置<code class="du jv jw jx jy b">BundleAnalyzer</code>来可视化您正在拉入的依赖项。这可以帮助您识别重复的依赖项，或者找到您拆分成较小块的依赖项，以便在需要时动态导入。</p><p id="f5fe" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">Webpacker还附带了<code class="du jv jw jx jy b">webpack-dev-server</code>，这是一个节点服务器，可以在开发时编译包。这不仅是调试代码的有用工具，还可以启用热模块替换来提高生产率。热模块替换将在不刷新页面的情况下重新加载任何前端代码更改，节省了开发人员往返服务器的麻烦。Caviar使用<code class="du jv jw jx jy b">react-rails</code>来安装来自多个元素的组件，这使得启用HMR变得特别棘手，因为没有单一的应用程序容器组件。您可以使用<code class="du jv jw jx jy b">react-rails-ujs</code>挂载方法来启用React热加载，而不是设置<code class="du jv jw jx jy b">react-hot-loader</code>。</p><pre class="lc ld le lf fd lg jy lh li aw lj bi"><span id="590e" class="lk ka hh jy b fi ll lm l ln lo">function initReactRailsContext() {<br/>  const componentRequireContext = require.context(‘containers’, true);<br/>  ReactRailsUJS.useContext(componentRequireContext);<br/>  // convert the component names passed into react_component<br/>  // from pascal-case to snake-case for the file names to be resolved<br/>  const originalGetConstructor = ReactRailsUJS.getConstructor;<br/>  <br/>  ReactRailsUJS.getConstructor = function (reqctx) {<br/>    return originalGetConstructor(_.snakeCase(reqctx));<br/>  };<br/>  return componentRequireContext;<br/>}<br/></span><span id="e832" class="lk ka hh jy b fi lp lm l ln lo">const componentRequireContext = initReactRailsContext();<br/>if (module.hot) {<br/>  module.hot.accept(<a class="ae jr" href="http://componentrequirecontext.id" rel="noopener ugc nofollow" target="_blank">componentRequireContext.id</a>, () =&gt; {<br/>    initReactRailsContext();<br/>    ReactRailsUJS.mountComponents();<br/>  });<br/>}</span></pre><p id="5ccd" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">如果没有合适的工具，很难跟上前端开发不断发展的步伐。Webpack使Caviar能够更高效地生产我们的产品，让我们的工程师能够构建最好的食品订购平台。自从迁移到Webpack，我们已经能够<a class="ae jr" href="https://decaffeinate-project.org/" rel="noopener ugc nofollow" target="_blank">去除</a>我们的代码并转移到ES6+语法。此外，我们还能够将Enzyme等库集成到我们的测试套件中，这是一个声誉良好的测试库，很难通过Rails资产管道安装。尽管有其他方法可以通过Rails或其他构建工具来完成上述任务，但我发现Webpack是解决各种前端需求的一站式商店。</p><p id="9e58" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">有了Webpack，我们可以利用NPM上的各种工具。我们的团队现在专注于减少我们为客户提供的应用捆绑包。如上所述，我们正在积极研究使用<a class="ae jr" href="https://github.com/jamiebuilds/react-loadable" rel="noopener ugc nofollow" target="_blank">react-loaded</a>在组件级动态服务资产。虽然本文没有讨论，但是Webpack也能够捆绑CSS资产。使用像<a class="ae jr" href="https://www.npmjs.com/package/purifycss" rel="noopener ugc nofollow" target="_blank"> PurifyCSS </a>这样的工具，可以消除像Bootstrap这样的框架产生的无用CSS。所有这些努力都是为了给我们的用户建立一个高性能和愉快的网络体验。</p><p id="cbd7" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd js jf jg jh jt jj jk jl ju jn jo jp jq ha bi translated">感觉饿吗？参观trycaviar.com，在你附近最好的餐馆点餐。</p></div></div>    
</body>
</html>