<html>
<head>
<title>Encrypting your application memory with Intel SGX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用SGX加密您的应用内存</h1>
<blockquote>原文：<a href="https://medium.com/globant/encrypting-your-application-memory-with-intel-sgx-8796de2afc5c?source=collection_archive---------1-----------------------#2020-08-31">https://medium.com/globant/encrypting-your-application-memory-with-intel-sgx-8796de2afc5c?source=collection_archive---------1-----------------------#2020-08-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie if ig"><p id="1513" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">你能控制你的物联网设备吗？你对他们的安全投资了吗？还是他们会反对你？</p></blockquote><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/9e402af4c2af30bf58cbc7b383ae5fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4moqRhlqDMjd_JT81fPKaQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx"><em class="jw">Image source: Le musée du Bastion Jean Cocteau (Menton, France)</em></figcaption></figure><h1 id="b036" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">介绍</h1><p id="3951" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">在本文中，我们将讨论由英特尔开发的名为软件保护扩展(SGX)的技术，操作系统如何发展以减少权限提升问题，英特尔SGX有哪些记录在案的潜在漏洞，以及如何使用库操作系统将您的应用移植到英特尔SGX。</p><h1 id="8103" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">软件保护扩展</h1><p id="5c12" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">英特尔在2015年推出了第六代CPU架构中的<a class="ae ld" href="https://www.intel.com/content/www/us/en/architecture-and-technology/software-guard-extensions.html" rel="noopener ugc nofollow" target="_blank">软件防护扩展</a> CPU指令代码，称为<a class="ae ld" href="https://software.intel.com/sites/default/files/managed/c5/9a/The-Compute-Architecture-of-Intel-Processor-Graphics-Gen9-v1d0.pdf" rel="noopener ugc nofollow" target="_blank"> Skylake </a>微架构。这些指令代码提供了用户空间应用程序或操作系统定义私有和加密内存区域(RAM)的能力。这些私有内存区域不能被任何其他用户空间进程或特权级进程读取，比如内核空间线程。</p><p id="c5f0" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">CPU负责加密这些内存区域，并在必须读取该内存区域时在同一个CPU内核中动态解密，从而保护被检查的进程代码。</p><p id="2b4a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">这项英特尔SGX技术并不独特，因为AMD推出了一项名为<a class="ae ld" href="https://developer.amd.com/sev/" rel="noopener ugc nofollow" target="_blank">安全加密虚拟化</a> (SEV)的类似技术，该技术为分配给虚拟机的所有内存提供加密，避免虚拟机管理程序读取这些内存区域。</p><p id="4572" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">目前，对于云基础设施工作负载，微软Azure提供了一个名为<a class="ae ld" href="https://azure.microsoft.com/en-us/solutions/confidential-compute/" rel="noopener ugc nofollow" target="_blank">机密计算</a>的产品，使应用程序SGX可以在这个资源上运行。</p><h1 id="bc7e" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">用例</h1><p id="a4c5" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">SGX可用于多种用例，例如:</p><ul class=""><li id="4557" class="le lf hh ik b il im ip iq kx lg kz lh lb li jf lj lk ll lm bi translated"><strong class="ik hi">密钥管理</strong>:加密存储区可用于帮助管理加密密钥，并提供类似于硬件安全模块的功能。</li><li id="884e" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf lj lk ll lm bi translated"><strong class="ik hi">区块链</strong>:它有助于提高交易处理、共识和智能合同的隐私性和安全性。</li><li id="cd61" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf lj lk ll lm bi translated"><strong class="ik hi">安全隔离</strong>:为敏感数据的多方计算提供额外的私密性。</li><li id="90d8" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf lj lk ll lm bi translated"><strong class="ik hi">边缘计算</strong>:帮助保护物联网设备和云基础设施之间的通信。</li><li id="b1a8" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf lj lk ll lm bi translated"><strong class="ik hi">数字钱包</strong>:它提供了一种帮助确保支付和交易安全的防御手段。</li><li id="8cd8" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf lj lk ll lm bi translated"><strong class="ik hi">通信和消息传递</strong>:帮助确保发送方和接收方之间的通信安全。</li></ul><p id="928a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">要使用SGX并实现一个加密的内存区域，应用程序必须以说SGX语的方式编写。要做到这一点，需要理解用户应用程序和操作系统是如何相互作用的。</p><h1 id="1e67" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">一个关于操作系统的故事…</h1><p id="f752" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">操作系统已经改进了它们的实现，使它们更加安全，并防止应用程序读取其他应用程序的内存。操作系统在CPU指令的帮助下尽力提供经典的保护机制——如果CPU架构提供的话。然而，SGX提供了经典操作系统设计所不能提供的更加增强的安全机制。</p><h2 id="bc45" class="ls jy hh bd jz lt lu lv kd lw lx ly kh kx lz ma kl kz mb mc kp lb md me kt mf bi translated">整体系统</h2><p id="29f9" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">操作系统开发中实现最多的设计之一是单片方法，其中有两个分离:英特尔x86架构中第三个保护环中的用户空间；和运行在零保护环中的内核空间或管理程序。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mg"><img src="../Images/4d5ab461d83a8e70a5ad40739235e3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*gBjlwFZMdnUP2Wudd1xA0w.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Separation of User Space and Supervisor Space</figcaption></figure><p id="2331" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">这种设计方法是实现最多的方法之一，它是为Linux、FreeBSD和其他类似Unix的操作系统设计的。通过这种实现，操作系统负责将应用程序数据分离到不同的内存区域，并且不允许任何应用程序看到内存中另一个应用程序的内容。当在应用程序或操作系统结构中发现漏洞时，该漏洞可以升级到管理空间，并能够读取内存中的任何数据，访问任何机密。</p><p id="555f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">这个实现中的内存根本没有加密，它只是依赖于标准的特权语义。例如，一个专注于安全性的用户空间应用程序请求为操作系统内核分配特定大小的内存，该应用程序自行加密所请求的内存空间，并最终在不再需要它或应用程序存在时释放它，当该应用程序执行此操作时，可能会有几个竞争条件和可利用阶段，它们可能会读取加密内存的内容。</p><p id="1707" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">操作系统已经发展到使用隔离技术为应用程序提供安全性。其中一种技术是轻量级虚拟化，现在正在大量使用。</p><h2 id="2781" class="ls jy hh bd jz lt lu lv kd lw lx ly kh kx lz ma kl kz mb mc kp lb md me kt mf bi translated">轻量级虚拟化</h2><p id="5b6d" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">轻量级虚拟化并不新鲜，但随着Linux中的Docker引擎的出现，它变得越来越流行。这种实现允许通过使用操作系统内核提供的名称空间将不同的用户空间进程隔离在它们自己的沙箱中。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mh"><img src="../Images/7e829fc79a7cfe0f77d23bbe596ac24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*n51ldeMRofKapj3dKDZHRw.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Separation of Containers and Operating System</figcaption></figure><p id="3c35" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">在所描述的实现中，鼓励不要重写应用程序来提供预期的自然行为，同时保持与当前操作系统设计的兼容性。这些实施并没有提供SGX所提供的更安全的机制。</p><h2 id="0d17" class="ls jy hh bd jz lt lu lv kd lw lx ly kh kx lz ma kl kz mb mc kp lb md me kt mf bi translated">操作系统如何为应用程序提供虚拟内存管理？</h2><p id="a72f" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">几个操作系统为它们的用户空间应用程序提供了相同的虚拟内存管理机制，为它们提供了内存堆栈模型:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mi"><img src="../Images/579d33d0b1ecdf9d7def61869502ab1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*UjkMe0o8vJxQASKWfFGOnQ.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Structure of process stack in virtual memory</figcaption></figure><p id="1471" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">所有的用户空间应用程序都试图在请求时分配和释放内存(就像C语言的应用程序一样，带有传统的malloc()和free()函数和相关函数),或者使用垃圾收集器动态分配和释放内存。在内存释放时，在某些情况下，当另一个用户应用程序可以从另一个应用程序读取释放的内存区域时，可能会出现漏洞，甚至在内核空间也会出现这种情况。在修复发现的漏洞时，有多项工作正在进行中，以使操作系统和应用更加安全，但这些修复仅在漏洞发现后应用，没有万无一失的机制来主动减少这些攻击，这正是SGX英特尔公司试图解决的问题。</p><h1 id="df43" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">英特尔SGX是如何工作的？</h1><p id="ccf1" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">应用中的SGX机制是将执行代码分成两个主要部分:不安全部分和安全部分。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mj"><img src="../Images/75cfe49ae1a7e0e44a58779d5d8117cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/0*uX0V04f1CLgrJy44"/></div><figcaption class="js jt et er es ju jv bd b be z dx"><em class="jw">Image source: Intel</em></figcaption></figure><p id="54df" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">不安全(不可信)部分和安全(可信)部分之间的交互如下:</p><ol class=""><li id="3d9b" class="le lf hh ik b il im ip iq kx lg kz lh lb li jf mk lk ll lm bi translated">应用程序由可信和不可信部分组成。</li><li id="047d" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf mk lk ll lm bi translated">应用程序运行并创建一个enclave，该enclave位于可信内存中。</li><li id="17db" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf mk lk ll lm bi translated">可信函数被调用；enclave内部运行的代码以明文形式查看数据，拒绝外部访问数据。</li><li id="823f" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf mk lk ll lm bi translated">可信函数处理enclave中的数据。</li><li id="0921" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf mk lk ll lm bi translated">可信函数存在；enclave数据保留在可信内存中。</li></ol><p id="d2d7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">enclave中的数据在内存中加密，并由CPU动态解密。内核或管理程序都不能读取enclave的内容，因为它们在内存的这个区域是加密的，当请求时在CPU中是不加密的。</p><h2 id="099a" class="ls jy hh bd jz lt lu lv kd lw lx ly kh kx lz ma kl kz mb mc kp lb md me kt mf bi translated">你怎么能信任一个支持SGX的应用程序呢？</h2><p id="4a3d" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">SGX设计为只有enclave受处理器信任，其他不受处理器信任，因此操作系统、Enclave之外的应用和虚拟机管理程序被视为敌对，因此它们无法执行任何CPU指令来解密Enclave并查看其内容。但是，你怎么能相信一个实际上将秘密存储在飞地中的应用程序呢？这就是证明机制发挥作用的地方。</p><p id="aa4a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated"><a class="ae ld" href="https://software.intel.com/content/www/us/en/develop/topics/software-guard-extensions/attestation-services.html" rel="noopener ugc nofollow" target="_blank">证明</a>功能是一种在Enclave之间提供安全通信(本地证明)或提供信任链以验证Enclave已验证且未被篡改(远程证明)的方式。当enclave初始化时，它可以向服务器发送报告，服务器可以验证该报告是否由SGX指令集生成，从而建立信任链。供应商可以请求将英特尔添加到认证实施列表中，这样用户就可以完全确认相关软件没有被恶意软件篡改。</p><h1 id="eac1" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">我可以在SGX飞地运行我最喜欢的应用程序吗？</h1><p id="6c98" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">简短的回答是否定的，长的回答是“视情况而定”。为了将应用程序移植到SGX，如果技术上可行的话，必须在应用程序的源代码中重写几个部分。这些部件必须与英特尔的SGX软件开发套件相连接才能运行。许多流行的服务应用与SGX完全不兼容，因为它们是在SGX存在之前设计的，所以它们有自己的安全实现，所以移植它们将需要大量的重新设计工作。</p><p id="5a50" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">这就是一个库操作系统能帮上忙的地方。</p><h2 id="d129" class="ls jy hh bd jz lt lu lv kd lw lx ly kh kx lz ma kl kz mb mc kp lb md me kt mf bi translated">石墨烯SGX库操作系统</h2><p id="29c7" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">库操作系统是一种软件，它提供一个经典操作系统所提供的所有服务的抽象，例如库形式的系统调用接口或网络堆栈，一个用户空间应用程序可以将它们链接起来，以提供可以作为一个二进制文件部署的操作系统映像。</p><p id="2e00" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">使用石墨烯SGX库操作系统，应用程序在编译时与其链接，然后加载平台适配层，该适配层负责Enclave初始化，以在其中运行整个应用程序。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ml"><img src="../Images/c3553a417e10670e763f11b7833476de.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*ouGTrLdEQnc13ljRBa_tVw.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx">Separation of process inside an SGX Enclave and Operating System</figcaption></figure><p id="cf20" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">石墨烯LibOS具有以下优势:</p><ul class=""><li id="56a8" class="le lf hh ik b il im ip iq kx lg kz lh lb li jf lj lk ll lm bi translated">它允许在SGX飞地内运行几乎任何应用程序，无需修改</li><li id="6044" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf lj lk ll lm bi translated">系统调用在Enclave内部实现</li><li id="9afa" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf lj lk ll lm bi translated">增强可信计算基础</li></ul><h1 id="0fbd" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">那么，英特尔SGX真的安全吗？</h1><p id="439f" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">SGX在处理器级别提供了一个新的安全层，提高了应用的安全性，但它并不是绝对可靠的。记录了不同的漏洞。</p><ul class=""><li id="0aa4" class="le lf hh ik b il im ip iq kx lg kz lh lb li jf lj lk ll lm bi translated"><strong class="ik hi">内存腐败攻击</strong>。当发生缓冲区溢出时，调用中的例程返回地址被可执行区域中的例程地址替换，绕过不执行位功能(如果存在),就会发生这种情况。这可以通过在支持SGX的程序中启用地址空间布局随机化(ASLR)来解决。</li><li id="6568" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf lj lk ll lm bi translated"><strong class="ik hi">未初始化的内存</strong>。当有一个内存页面尚未被操作系统初始化，允许操作系统在enclave中注入数据时，就会发生这种情况。这被称为SGX出血，可以通过在内核空间启用<a class="ae ld" href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="noopener ugc nofollow" target="_blank">地址空间布局随机化</a> (ASLR)来解决。</li><li id="ae9d" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf lj lk ll lm bi translated"><strong class="ik hi">页表攻击</strong>。当操作页表时会发生这种情况，因此会观察到页面访问模式。这可以通过在编译时改进SGX的可信执行环境来解决。</li><li id="3eaa" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf lj lk ll lm bi translated"><strong class="ik hi">缓存攻击</strong>。当试图访问处理器中的缓存和非缓存数据时会发生这种情况。由于飞地与其他进程共享处理器缓存，该漏洞是由SGX设计的，因此没有关于它的修正，尽管这种攻击很难完成。</li><li id="28bf" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf lj lk ll lm bi translated"><strong class="ik hi">分支阴影</strong>。利用易受攻击的SGX SDK，编译的应用程序具有暴露Enclave外部数据的影子代码。这可以通过更新SGX SDK和更新英特尔微码来解决。</li><li id="499a" class="le lf hh ik b il ln ip lo kx lp kz lq lb lr jf lj lk ll lm bi translated"><strong class="ik hi">排锤攻击</strong>。故障DRAM模块会发生这种情况，影响enclave所在的内存，然后阻塞处理器。这可以通过更新DRAM模块硬件来解决。</li></ul><h1 id="40d5" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">你的电话！</h1><p id="6597" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">如上所述，SGX在硬件层面提供安全解决方案，以提供可信计算基础。和所有基于硬件的技术一样，它给软件开发带来了一些新的挑战。幸运的是，有像石墨烯SGX操作系统库这样的解决方案可以帮助简化软件移植到这项技术。重要的是要记住，SGX有一些记录在案的漏洞，因此拥有一个基于安全第一的良好软件开发实践可以帮助减少漏洞，即使最终您决定完全不使用SGX而采用另一种方法。</p></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><h1 id="5d5f" class="jx jy hh bd jz ka mt kc kd ke mu kg kh ki mv kk kl km mw ko kp kq mx ks kt ku bi translated">参考</h1><p id="b8b4" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">这些都是用来写这篇文章的参考资料，按已知的安全攻击和技术分类。</p><h2 id="1bfc" class="ls jy hh bd jz lt lu lv kd lw lx ly kh kx lz ma kl kz mb mc kp lb md me kt mf bi translated">攻击和漏洞</h2><p id="0bc0" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated">与英特尔SGX相关的上述安全漏洞的链接</p><p id="5689" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated"><a class="ae ld" href="https://github.com/jaebaek/SGX-Shield" rel="noopener ugc nofollow" target="_blank">https://github.com/jaebaek/SGX-Shield</a><br/><a class="ae ld" href="https://arxiv.org/pdf/1710.09061.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1710.09061.pdf</a><br/><a class="ae ld" href="https://github.com/sslab-gatech/t-sgx" rel="noopener ugc nofollow" target="_blank">https://github.com/sslab-gatech/t-sgx</a><br/><a class="ae ld" href="https://dl.acm.org/doi/10.1145/3065913.3065915" rel="noopener ugc nofollow" target="_blank">https://dl.acm.org/doi/10.1145/3065913.3065915</a><br/><a class="ae ld" href="https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-lee-sangho.pdf" rel="noopener ugc nofollow" target="_blank">https://www . usenix . org/system/files/conference/usenix security 17/sec 17-lee-sangho . pdf</a><br/><a class="ae ld" href="https://taesoo.kim/pubs/2017/jang:sgx-bomb-slides.pdf" rel="noopener ugc nofollow" target="_blank">https://taesoo.kim/pubs/2017/jang:sgx-bomb-slides.pdf</a></p><h2 id="8621" class="ls jy hh bd jz lt lu lv kd lw lx ly kh kx lz ma kl kz mb mc kp lb md me kt mf bi translated">制品</h2><p id="b75a" class="pw-post-body-paragraph ih ii hh ik b il kv in io ip kw ir is kx ky iv iw kz la iz ja lb lc jd je jf ha bi translated"><a class="ae ld" href="https://software.intel.com/content/www/us/en/develop/topics/software-guard-extensions.html" rel="noopener ugc nofollow" target="_blank">https://software . Intel . com/content/www/us/en/develop/topics/software-guard-extensions . html</a></p><p id="bb6c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is kx iu iv iw kz iy iz ja lb jc jd je jf ha bi translated">格洛邦特</p></div></div>    
</body>
</html>