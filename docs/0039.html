<html>
<head>
<title>Turbocharged JavaScript Refactoring with Codemods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Codemods的涡轮增压JavaScript重构</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/turbocharged-javascript-refactoring-with-codemods-b0cae8b326b9?source=collection_archive---------0-----------------------#2016-04-27">https://medium.com/airbnb-engineering/turbocharged-javascript-refactoring-with-codemods-b0cae8b326b9?source=collection_archive---------0-----------------------#2016-04-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/75eca60d52502bbc7cb9de7d2958c9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ACzkLTlx7DLPA-PIfj9Msg.png"/></div></div></figure><div class=""/><p id="17ad" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">乔·伦乔尼</p><p id="741d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我的花园里种植和收获新作物很有趣，但如果我不定期除草，我最终会醒来发现一团糟。虽然每种杂草本身并不构成问题，但它们会合力堵塞整个系统。在一个没有杂草的花园里工作是一种富有成效的乐趣。代码库也是这样。</p><p id="2c6a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我也不喜欢除草，所以我忘了除草，结果惹上了麻烦。值得庆幸的是，在编码方面，我们有像<a class="ae jp" href="http://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>和<a class="ae jp" href="https://github.com/brigade/scss-lint" rel="noopener ugc nofollow" target="_blank">SCSS-林特</a>这样的好工具来确保我们在前进的过程中剔除杂草。然而，如果我们发现大块的遗留代码值得关注，我们可能会被手动调整一百万个空格和无数个悬空逗号的想法淹没。</p><p id="aa26" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在过去的8年里，数百万行JavaScript代码已经在Airbnb的源代码控制中被签入；与此同时，前端Web开发已经发生了巨大的变化。特性、框架甚至JavaScript本身都是移动的目标——尽管从一开始就遵循<a class="ae jp" href="https://github.com/airbnb/javascript" rel="noopener ugc nofollow" target="_blank">一个好的风格指南</a>将有助于最小化这种痛苦，但很容易以不再遵循当前“最佳实践”的代码库而告终。每一个小的不一致就像一棵小杂草，等着被拔掉，为一些有益的事情腾出空间，为一个更有生产力的团队铺平道路。看看我们花园的形状:</p><figure class="jq jr js jt fd hj"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx">Before codemods</figcaption></figure><p id="2c4e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我痴迷于使团队更快，并且知道来自linters的一致的代码和信息收紧了反馈循环并减少了通信开销。我们最近开始了一个清理项目，准备大量的旧JavaScript来遵循我们的风格指南，并在更多的地方启用我们的linters。手工完成所有的工作是非常乏味和耗时的，所以我们寻找工具来自动完成一些工作。虽然`<em class="ka"> eslint </em> — <em class="ka"> fix </em>是一个很好的起点，但是<a class="ae jp" href="https://github.com/eslint/eslint/issues/5329" rel="noopener ugc nofollow" target="_blank">目前它能修复的</a>是有限的。他们最近已经开始接受自动修正任何规则的拉请求，并且正在努力为JavaScript实现一个具体的语法树，但是这还需要一些时间。谢天谢地，我们找到了脸书的<a class="ae jp" href="https://github.com/facebook/jscodeshift" rel="noopener ugc nofollow" target="_blank"> jscodeshift </a>，这是一个codemod的工具包(codemod是帮助大规模、部分自动化的代码库重构的工具)。如果一个代码库是一个花园，jscodeshift就是一个机器人园丁。</p><p id="5041" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该工具将JavaScript解析成<a class="ae jp" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树(AST) </a>，应用转换，写出修改后的JavaScript，同时匹配本地编码风格。转换本身是用JavaScript编写的，这使得我们的团队很容易使用这个工具。寻找或发明我们需要的转换加速了平凡的重构，这有助于我们的团队专注于更有意义的工作。</p><p id="e109" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行了几个codemods之后，我们的花园看起来稍微好了一点:</p><figure class="jq jr js jt fd hj"><div class="bz dy l di"><div class="ju jv l"/></div><figcaption class="jw jx et er es jy jz bd b be z dx">After codemods</figcaption></figure><h1 id="6b61" class="kb kc hs bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">策略</h1><p id="f4a2" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">由于大多数codemods处理成千上万的文件只需要不到一分钟的时间，我发现当我在主线程上等待某些事情(例如代码审查)的时候，codemods是一个很好的辅助任务。这有助于最大限度地提高我的工作效率，同时在更大或更重要的项目上取得进展。</p><p id="e1f5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在进行大规模重构时遇到的主要挑战通常围绕着4 C:沟通、正确性、代码审查和(合并)冲突。我使用了以下一些策略来帮助最小化这些挑战。</p><p id="c1e7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">并不是所有的codemods在每种情况下都能产生我想要的精确结果，所以回顾和调整这些变化是很重要的。我发现在运行codemod后，以下命令非常有用:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="14fd" class="lj kc hs lf b fi lk ll l lm ln">git diff<br/>git add --patch<br/>git checkout --patch</span></pre><p id="d5ca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">小提交和拉请求是最好的，codemods也不例外。我通常一次处理一个codemod，以便于检查和解决合并冲突。我还经常提交codemod结果本身，如果需要的话，再提交一个手动清理。这使得在重定分支的基础时解决合并冲突变得更加容易，因为我通常可以</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="97e5" class="lj kc hs lf b fi lk ll l lm ln">git checkout --ours path/to/conflict</span></pre><p id="a308" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">并对该文件再次运行codemod，而不干扰我的手动更改。</p><p id="0947" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有时，codemod会产生非常大的差异。对于这些情况，我发现对基于路径或文件名的代码片段使用单独的提交或拉请求是有帮助的。例如，一次提交修复*。js文件和另一个提交修复*。jsx文件。这使得审查更容易，并顺利合并冲突的解决。得益于对Unix哲学的坚持，在不同的片上运行codemods就像调整对“<em class="ka"> find </em>”的调用一样简单:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="a34f" class="lj kc hs lf b fi lk ll l lm ln">find app/assets/javascripts -name *.jsx -not -path */vendor/* | \<br/>  xargs jscodeshift -t ~/path/to/transform.js</span></pre><p id="cf1c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了避免踩到别人的脚趾，我在周五的早些时候推动codemod提交进行评审，然后在周一早些时候在大多数人重新开始工作之前进行重置和合并，这样做效果很好。这让人们有机会在周末之前完成他们正在做的工作，而不会被你的codemod妨碍。</p><h1 id="72e0" class="kb kc hs bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">对我们很有用的Codemods</h1><p id="444a" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">虽然这个工具还很年轻，但是已经有很多有用的codemods可以使用了。这里有一些我们迄今为止已经成功的例子。</p><h2 id="b6b2" class="lj kc hs bd kd lo lp lq kh lr ls lt kl ja lu lv kp je lw lx kt ji ly lz kx ma bi translated">轻量级代码模块</h2><p id="8eb1" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">这些codemods非常有用，应用起来相对容易，给我们带来了立竿见影的效果。</p><p id="0e8e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jp" href="https://github.com/cpojer/js-codemod#arrow-function" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">js-code mod/arrow-function</strong></a><strong class="ir ht">:</strong>保守地将函数转换为箭头函数</p><p id="550a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之前:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="d855" class="lj kc hs lf b fi lk ll l lm ln">[1, 2, 3].map(function(x) {<br/>  return x * x;<br/>}.bind(this));</span></pre><p id="d486" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="a77a" class="lj kc hs lf b fi lk ll l lm ln">[1, 2, 3].map(x =&gt; x * x);</span></pre><p id="2ab6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jp" href="https://github.com/cpojer/js-codemod#no-vars" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">js-code mod/no-vars</strong></a><strong class="ir ht">:</strong>保守地将`<em class="ka"> var </em>转换为`<em class="ka"> const </em>或`<em class="ka"> let </em></p><p id="16c5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之前:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="1e7f" class="lj kc hs lf b fi lk ll l lm ln">var belong = 'anywhere';</span></pre><p id="db60" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="f8ed" class="lj kc hs lf b fi lk ll l lm ln">const belong = 'anywhere';</span></pre><p id="236a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jp" href="https://github.com/cpojer/js-codemod#object-shorthand" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">js-code mod/object-速记</strong> </a> <strong class="ir ht"> : </strong>将对象文字转换为使用ES6速记的属性和方法</p><p id="8c16" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之前:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="be9b" class="lj kc hs lf b fi lk ll l lm ln">const things = {<br/>  belong: belong,<br/>  anywhere: function() {},<br/>};</span></pre><p id="8b73" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="993e" class="lj kc hs lf b fi lk ll l lm ln">const things = {<br/>  belong,<br/>  anywhere() {},<br/>};</span></pre><p id="052c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jp" href="https://github.com/cpojer/js-codemod#unchain-variables" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">js-code mod/un chain-variables</strong></a><strong class="ir ht">:</strong>un chain链式变量声明</p><p id="c964" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之前:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="9cab" class="lj kc hs lf b fi lk ll l lm ln">const belong = 'anywhere', welcome = 'home';</span></pre><p id="7b86" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="8d2e" class="lj kc hs lf b fi lk ll l lm ln">const belong = 'anywhere';<br/>const welcome = 'home';</span></pre><p id="69d2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jp" href="https://github.com/cpojer/js-codemod#unquote-properties" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">js-code mod/un quote-properties</strong></a><strong class="ir ht">:</strong>从对象属性中删除引号</p><p id="70e9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之前:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="fbad" class="lj kc hs lf b fi lk ll l lm ln">const things = {<br/>  'belong': 'anywhere',<br/>};</span></pre><p id="78b5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="86a8" class="lj kc hs lf b fi lk ll l lm ln">const things = {<br/>  belong: 'anywhere',<br/>};</span></pre><h2 id="8a00" class="lj kc hs bd kd lo lp lq kh lr ls lt kl ja lu lv kp je lw lx kt ji ly lz kx ma bi translated">重量级代码模块</h2><p id="0cce" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">这些codemods要么产生了更大的差异，这对于合并和避免冲突来说更具挑战性，要么它们需要更多的后续调整来确保代码看起来仍然不错。</p><p id="8af0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jp" href="https://github.com/reactjs/react-codemod#class" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">react-code mod/class</strong></a><strong class="ir ht">:</strong>将`<em class="ka"> React.createClass </em>`调用到ES6类中</p><p id="5eb9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个codemod避免了mixins参与时的转换，并且它很好地完成了其他必要的转换，比如`<em class="ka"> propTypes </em>`、默认属性和初始状态是如何定义的，以及在构造函数中绑定回调。</p><p id="7460" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之前:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="31ee" class="lj kc hs lf b fi lk ll l lm ln">const BelongAnywhere = React.createClass({<br/>  // ... <br/>});</span></pre><p id="e1f0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="3c7a" class="lj kc hs lf b fi lk ll l lm ln">class BelongAnywhere extends React.Component {<br/>  // ...<br/>}</span></pre><p id="8b5a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jp" href="https://github.com/reactjs/react-codemod#sort-comp" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">react-code mod/sort-comp</strong></a><strong class="ir ht">:</strong>重新排序React组件方法以匹配<a class="ae jp" href="https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/sort-comp.md" rel="noopener ugc nofollow" target="_blank"> ESLint react/sort-comp规则</a></p><p id="5f71" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为这会移动大量的大块代码，git不会自动解决大多数合并冲突。我发现在运行这个转换之前最好进行充分的沟通，并且在最不可能出错的时候运行它(例如，在一个周末)。当我在这个基础上遇到冲突时，</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="2903" class="lj kc hs lf b fi lk ll l lm ln">git checkout --ours path/to/conflict</span></pre><p id="741b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">再次运行codemod是最好的方法。</p><p id="e1be" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之前:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="1de2" class="lj kc hs lf b fi lk ll l lm ln">class BelongAnywhere extends React.Component {<br/>  render() {<br/>    return &lt;div&gt;Belong Anywhere&lt;/div&gt;;<br/>  }</span><span id="0890" class="lj kc hs lf b fi mb ll l lm ln">  componentWillMount() {<br/>    console.log('Welcome home');<br/>  }<br/>}</span></pre><p id="c18d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="faf0" class="lj kc hs lf b fi lk ll l lm ln">class BelongAnywhere extends React.Component {<br/>  componentWillMount() {<br/>    console.log('Welcome home');<br/>  }</span><span id="d7b0" class="lj kc hs lf b fi mb ll l lm ln">  render() {<br/>    return &lt;div&gt;Belong Anywhere&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="de55" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jp" href="https://github.com/cpojer/js-codemod#template-literals" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">js-code mod/template-literals</strong></a><strong class="ir ht">:</strong>将字符串串联转换为模板文字</p><p id="33bd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于我们有许多字符串连接，并且这个codemod尽可能多地将其转换为模板文字，所以我最终发现了许多可读性较差的情况。我把这个codemod列在“重量级”部分，只是因为它涉及了太多的文件，需要大量的手动选择和调整才能获得最佳结果。</p><p id="8e19" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之前:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="1405" class="lj kc hs lf b fi lk ll l lm ln">const belong = 'anywhere '+ welcomeHome;</span></pre><p id="df3a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后:</p><pre class="jq jr js jt fd le lf lg lh aw li bi"><span id="39cc" class="lj kc hs lf b fi lk ll l lm ln">const belong = `anywhere ${welcomeHome}`;</span></pre><h1 id="e484" class="kb kc hs bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">资源</h1><p id="fd81" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">无论您是想编写自己的codemods，还是只是想了解什么是可能的，这里都有一些有用的资源:</p><ul class=""><li id="b11e" class="mc md hs ir b is it iw ix ja me je mf ji mg jm mh mi mj mk bi translated">Christoph Pojer著复杂系统的渐进发展。在JSConf EU 2015上谈论脸书的codemod(参见<a class="ae jp" rel="noopener" href="/@cpojer/effective-javascript-codemods-5a6686bb46fb">有效的JavaScript codemod</a>)。</li><li id="9389" class="mc md hs ir b is ml iw mm ja mn je mo ji mp jm mh mi mj mk bi translated">如何编写一个codemod :指导你编写一个codemod来将字符串连接转换成模板文字的教程。</li><li id="e1a9" class="mc md hs ir b is ml iw mm ja mn je mo ji mp jm mh mi mj mk bi translated"><a class="ae jp" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST Explorer </a>:探索各种解析器生成的AST的web工具。这是一个很好的地方，您可以在这里体验一下，看看对于您想要转换的一些代码，AST是什么样子的。</li><li id="b5cb" class="mc md hs ir b is ml iw mm ja mn je mo ji mp jm mh mi mj mk bi translated"><a class="ae jp" rel="noopener" href="/nfl-engineers/nfl-codemods-migrating-a-monolith-1e3363571707"> NFL ♥ Codemods:迁移一个整体</a>:NFL如何使用Codemods的案例研究。</li><li id="fbd4" class="mc md hs ir b is ml iw mm ja mn je mo ji mp jm mh mi mj mk bi translated"><a class="ae jp" href="https://github.com/reactjs/react-codemod" rel="noopener ugc nofollow" target="_blank">React-codemod</a>:React特定的code mod集合。</li><li id="e8bb" class="mc md hs ir b is ml iw mm ja mn je mo ji mp jm mh mi mj mk bi translated"><a class="ae jp" href="https://github.com/cpojer/js-codemod" rel="noopener ugc nofollow" target="_blank"> js-codemod </a>:通用JavaScript codemods的集合。</li></ul><h1 id="af67" class="kb kc hs bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">影响</h1><p id="e30d" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">使用可用的codemods和一些我们编写并反馈回来的代码，我们很快对旧代码做了很大的改进。我通过codemod不费吹灰之力修改了40，000行代码，这使得许多旧代码更好地符合我们的ES6风格指南。我们的菜园状况更好了，我们已经准备好迎接更快乐、更高产的收成。</p><p id="932d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行已经可用的codemods只是触及了表面——当你拿起键盘开始编写自己的代码时，真正的力量就被释放了。Codemods非常适合从样式重构到支持突破性API更改的各种修改，所以请尽情发挥您的想象力。这些技术非常值得投资，可能会为您和使用您项目的人节省大量时间和精力。</p><figure class="jq jr js jt fd hj er es paragraph-image"><div class="er es mq"><img src="../Images/3913f6470a7657e02386189e67b4eb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:108/format:webp/1*YsUOrWx3mRxZZljtc9xZyw.png"/></div></figure><h2 id="8e81" class="lj kc hs bd kd lo lp lq kh lr ls lt kl ja lu lv kp je lw lx kt ji ly lz kx ma bi translated">在<a class="ae jp" href="http://airbnb.io" rel="noopener ugc nofollow" target="_blank"> airbnb.io </a>查看我们所有的开源项目，并在Twitter上关注我们:<a class="ae jp" href="https://twitter.com/AirbnbEng" rel="noopener ugc nofollow" target="_blank">@ Airbnb eng</a>+<a class="ae jp" href="https://twitter.com/AirbnbData" rel="noopener ugc nofollow" target="_blank">@ Airbnb data</a></h2></div></div>    
</body>
</html>