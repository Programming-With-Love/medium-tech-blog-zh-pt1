<html>
<head>
<title>Intro to RxDart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxDart简介</h1>
<blockquote>原文：<a href="https://medium.com/globant/intro-to-rxdart-7e1429fabce0?source=collection_archive---------1-----------------------#2020-02-12">https://medium.com/globant/intro-to-rxdart-7e1429fabce0?source=collection_archive---------1-----------------------#2020-02-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="63b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大多数时候，在移动应用程序中，我们必须并行或一个接一个地执行多个异步操作，根据结果，我们需要转换数据，然后更新UI。为了处理这些复杂的情况，Rx来救援。</p><p id="8266" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Reactive来自react这个词，意思是对状态的变化做出反应。RxDart 属于反应式编程，它只关心数据流和变化的传播。</p><p id="a8cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">想到的一个问题是，<strong class="ig hi">为什么要用<em class="jc"> RxDart </em>？</strong> <br/> Dart附带了体面的<em class="jc">流API</em>,<em class="jc">rx Dart</em>没有试图提供该API的替代方案，而是在它的基础上添加了“反应式扩展规范”中的功能。<em class="jc"> RxDart </em>不提供自己的“可观察”类来替代<em class="jc"> Dart流</em>。相反，它提供了几个额外的流类、操作符(流类的扩展方法)和<em class="jc">主题</em>。</p><p id="2e9f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">为什么要进行反应式编程？</strong></p><ol class=""><li id="7964" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">更容易链接多个请求和应用转换。</li><li id="72d9" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">将一个流转换成另一个具有多种能力的流。</li><li id="a01d" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">回调处理和跟踪错误。</li><li id="3a34" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">通过执行复杂的线程操作来处理多线程，保持一切同步并返回相关的内容。</li></ol><p id="0377" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">流</strong></p><p id="519f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">流</strong>是一系列异步事件。它就像一个管道，当你在一端放入数据，如果在另一端有一个监听器，这个监听器将接收那个值。使用<em class="jc">Stream controller/Subject</em>可以将数据放入<em class="jc">流</em>中。由于使用RxDart 0.23.x <strong class="ig hi">流</strong>代替<strong class="ig hi">可观察。</strong></p><p id="aeae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Subjects- <br/> </strong> Dart已经提供了<em class="jc"> StreamController </em>来创建和管理<em class="jc">流</em>。然而，<em class="jc"> RxDart </em>提供了与<em class="jc"> StreamControllers </em>相同的<em class="jc">主题</em>，但是具有额外的功能。</p><p id="3502" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">学科类型:<br/> 1。behavioral Subject</strong>-这是广播流控制器，意味着<em class="jc"> Subject流</em>可以多次收听。<em class="jc">行为主体</em>捕捉最新的值或错误。当新的监听器订阅<em class="jc">流</em>时，最新的值或错误将被发送给监听器。</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="b7fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.这是一个默认的广播流控制器。仅订阅后添加的值/错误将被发送给侦听器。</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="3f1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.<strong class="ig hi">replay subject</strong>——这是一个特殊的广播<em class="jc"> StreamController </em>，它捕获所有已经添加到控制器中的项目。这个主题允许向监听器发送数据、错误和完成事件。随着项目被添加到<em class="jc">主题</em>，<em class="jc"> ReplaySubject </em>将会存储它们。当<em class="jc">流</em>被收听时，那些记录的项目将被发送给收听者。之后，任何新添加的内容都将被传递给侦听器。</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="782c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了限制存储的元素，我们可以设置maxSize。</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="0d15" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">流控制器</em>和<em class="jc">主题</em>的比较</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jy"><img src="../Images/3ea3816691fdd2f2ae7912d69d569ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S56yK2Vyg1vIqrabdV_Zvg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Comparision</figcaption></figure><p id="3059" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们在前面的例子中看到的，我们必须监听<em class="jc">流</em>来捕获事件。下面是<em class="jc">流订阅</em>的语法:</p><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="3bef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> onData，on error&amp;on done methods<br/><em class="jc">on data</em></strong>:每次发布新事件时都会调用这个方法。在这里，我们可以对事件执行操作。<br/> <strong class="ig hi"> <em class="jc"> onError </em> </strong>:这是在<em class="jc"> RxDart框架</em>代码或者我们的事件处理代码中抛出未处理的异常时调用的。<br/> <strong class="ig hi"> <em class="jc"> onDone </em> : </strong>当与流相关联的事件序列完成时，调用此函数。<br/> <strong class="ig hi"> <em class="jc">取消错误</em> : </strong>取消错误的默认值为false。如果cancelOnError为true，则在传递第一个错误事件时，订阅将自动取消。</p><p id="0b92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">到目前为止，我们已经看到了基本的<em class="jc"> RxDart </em>和<em class="jc">流</em>。</p><p id="41b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们看看如何在flutter UI中使用所有这些组件。</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kj"><img src="../Images/e48f31f6b314637cabc48d837e035779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z32ur4-xZC1I0aPF2JRrEQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">bloc.dart</figcaption></figure><figure class="jr js jt ju fd jv er es paragraph-image"><div class="er es kk"><img src="../Images/4e4df595a8e576ccb44c8d0844b7e985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*wGCAGfeU0sPmY0-OANZfGA.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx">ticket_widget.dart</figcaption></figure><p id="af22" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这都是关于<em class="jc">流</em>和<em class="jc"> RxDart </em>的。在下一篇博客中，我们将详细探讨Rx操作符。</p><p id="161d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">希望这篇博客对你有所帮助。谢谢！！</p><p id="daa5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参考资料:</p><p id="a2d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae kl" href="https://pub.dev/documentation/rxdart/latest/" rel="noopener ugc nofollow" target="_blank">https://pub.dev/documentation/rxdart/latest/</a></p></div></div>    
</body>
</html>