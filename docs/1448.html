<html>
<head>
<title>Closures are the Generics for Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">闭包是Go的泛型</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/closures-are-the-generics-for-go-cb32021fb5b5?source=collection_archive---------0-----------------------#2017-06-07">https://medium.com/capital-one-tech/closures-are-the-generics-for-go-cb32021fb5b5?source=collection_archive---------0-----------------------#2017-06-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="f157" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">围棋系列之二</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/707aba92f75deee0b0619dd0bb635c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3YZ9zEp6eeaj85cpbwbyg.jpeg"/></div></div></figure><p id="4436" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">你如何解决Go泛型的问题？</p><p id="cb11" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Go是一种具有有意限制的特性集的语言；其中一个特性是省略了用户定义的泛型类型和函数。概括地说，人们使用泛型有两个目的。</p><p id="0c6b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">最常见的请求是通用数据结构。有时候，我们需要比切片或地图更复杂的东西。在Go中，您有两种选择——要么您可以为您需要的每种类型反复编写数据结构(或者使用代码生成器来节省一些输入),要么您需要根据<em class="ke">接口{} </em>来定义您的数据类型，并在它们从结构中返回时强制转换值。</p><p id="c4e0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">泛型的另一个用途是功能性的。有时，您需要对不同的数据类型运行相同的算法，而不仅仅是存储不同种类的值。与一般的数据结构不同，有一种方法感觉像是这种用法的必经之路<em class="ke">。</em></p><h1 id="ce3a" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">检验中的仿制药</strong></h1><p id="7f11" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">作为一个例子，让我们看看LGTM的一个分支Checks-Out，它是一个开源项目，帮助团队通过Github执行代码审查策略。你可以在https://github.com/capitalone/checks-out找到结账处。作为与Github集成的一部分，check-Out调用几个Github APIs来返回不同事物的列表，包括团队和用户。</p><p id="20c8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">例如，下面是最初的<em class="ke">getteamembers</em>函数:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ld"><img src="../Images/3bafb6de8824ef0886ed541999a2e82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ss7hCUnBUrvZvodT0z4LbA.png"/></div></div></figure><h1 id="eb4a" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">一种不是很干的溶液</strong></h1><p id="3495" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">这段代码运行良好，直到一个新的签出用户试图在一个有45个团队的组织中注册一个项目。原来所有的<em class="ke"> List* </em> API调用实际上都是分页的，页面大小为30。新用户有三分之一的团队没有被加载，这导致在引用第二页上的团队时出现错误。</p><p id="f338" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当这种情况发生时，我们必须为签出添加分页支持。</p><p id="e661" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们的第一次修复是这样的:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es le"><img src="../Images/d42da04220a55e430826b4f71286c67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MO-lJn3E3V-5ttsdYVDrVQ.png"/></div></div></figure><p id="4bd9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">并且:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lf"><img src="../Images/c3e6f97c7a0781410085200e67f890ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dmzl6ff1L3VsI7e3qqpjuA.png"/></div></div></figure><p id="8880" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然这种方法修复了bug，但是它确实使代码变得更长了，并且重复了很多次。有办法解决这个问题吗？ </p><p id="844c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">ListTeams 和<em class="ke"> ListTeamMembers </em>都以非常相似的方式分页，但是它们期望不同的参数并返回非常不同的数据。如果这些是代码中唯一需要分页的地方，我们可能会让它保持原样。但是代码中还有另外十个位置有相同的问题。我们不想一遍又一遍地重复微小变化的分页代码。</p><h1 id="727f" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">快速绕道去Java </strong></h1><p id="47cb" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">在过去的二十年中，我大部分时间都在用Java编程。在Java中，您可以用一个如下所示的泛型方法来解决这个问题:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ld"><img src="../Images/0a127bfe1da388e96e6802bf3401deea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxNRFDBRxs8ZXHhFjeEySA.png"/></div></div></figure><p id="76d8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">最初的空<em class="ke">列表</em>作为一个参数传入，同时传入的还有用于进行远程调用的数据。<em class="ke"> Loader </em>是一个界面，看起来像:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lg"><img src="../Images/8e99635ba43be34500a72a9c6fd37734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txTv2oHgH3PLuOq0MgNnMg.png"/></div></div></figure><p id="ff4c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">与Go不同，我们不能从一个Java方法返回多个值，所以<em class="ke"> LoaderInfo </em>被创建为一个简单的包装类:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lh"><img src="../Images/28b0390748b2d0fadb6069ec9f8c0890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1r9em6U4P_1vgw2GXOqUUg.png"/></div></div></figure><p id="325d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">有了这些代码，我们就可以将所有团队拉下来:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es li"><img src="../Images/e43b6b9f328f6cff793b3890cbd1a93b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*srry8weyk-wtR2KnNBR9dw.png"/></div></div></figure><p id="58ac" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以通过以下方式拉下团队中的所有用户:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/cf570a371c192f8dc31fed0a43cd9bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PTNzDEDz1yZmRyVEuycsQA.png"/></div></div></figure><p id="b06a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这个解决方案表明泛型的力量不仅仅是类型安全的容器；泛型允许您在多种数据类型上抽象相同的算法。</p><h1 id="fbe6" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">返回去</strong></h1><p id="f67f" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">但是Go没有泛型。我们如何优雅地解决这个分页问题？</p><p id="055e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以使用<em class="ke">接口{} </em>作为传递无类型输入和输出参数的一种方式，但是这没有抓住要点。它创建了需要强制转换的丑陋代码，并颠覆了帮助我们编写正确代码的类型系统。</p><p id="c948" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">再看两个GitHub API调用，有一些数据类型是相同的。都有<em class="ke"> *github。ListOptions </em>作为输入参数(在<em class="ke"> ListTeams </em>的情况下是直接的，在<em class="ke"> ListTeamMembers </em>中是嵌入的结构)，它们都返回* <em class="ke"> github。响应</em>和<em class="ke">错误</em>。<strong class="jk hi"> <em class="ke">有没有一种方法可以传递相同的参数，同时仍然引用不同的参数？</em> </strong></p><p id="a749" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Go中最强大的特性之一是闭包。闭包看起来像是在函数内部声明的函数:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lk"><img src="../Images/1d9be3b456da903db1d40bf9f147fd52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64KjvMp4h9-w2N3_CODEmA.png"/></div></div></figure><p id="57bc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">用“hello”作为参数调用outer将返回10:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ll"><img src="../Images/4c6f3f7217cf0e372072ae8cffbdc8bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pQ0smLp6AY8xvHYQfyM0jQ.png"/></div></div></figure><p id="d2d5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">你可以在</strong><a class="ae lc" href="https://play.golang.org/p/U3HV-0nvTB" rel="noopener ugc nofollow" target="_blank"><strong class="jk hi">https://play.golang.org/p/U3HV-0nvTB</strong></a>亲自尝试一下</p><p id="6312" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">起初，在一个函数中声明另一个函数似乎很愚蠢。为什么要拆分逻辑？闭包的力量来自两件事。首先是它们引用和修改外部函数中声明的变量的能力。其次，闭包可以传递给其他函数，甚至可以从它们的声明函数返回。当与对局部变量的引用相结合时，这会导致一些有趣的行为:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lm"><img src="../Images/ac4dc7f99a34e6e8ced525862a2aaade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NvLjv058kfDu3F9-0gqh3Q.png"/></div></div></figure><p id="02c7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">调用<em class="ke"> outer2 </em>返回20:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lg"><img src="../Images/1c015863c34eee064c3cc9dca014ebbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-vOoOdGxATz1kbj-7I-WA.png"/></div></div></figure><p id="c02d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">代码可以在<a class="ae lc" href="https://play.golang.org/p/dNmhg_6x9T" rel="noopener ugc nofollow" target="_blank">https://play.golang.org/p/dNmhg_6x9T</a>运行</p><p id="4917" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">看<em class="ke">外2 </em>。当<em class="ke"> myClosure </em>被传递给helper并从那里被调用时，它的局部变量<em class="ke"> total </em>被修改。在helper中没有对总计<em class="ke">的引用，但是使用闭包允许对其进行修改。就像Go中的<em class="ke">结构</em>一样，闭包也有状态。这个州为我们的问题提供了解决方案。</em></p><h1 id="89cc" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">将所有这些放在一起</strong></h1><p id="c837" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">使用闭包技术，我们可以生成我们需要的类型的切片，并在传递给执行分页循环的函数的闭包中修改该切片。我们的闭包需要一个参数，即<em class="ke"> *github。ListOptions </em>拥有当前页面信息，并返回两个值，一个<em class="ke"> *github。回应</em>和无处不在的<em class="ke">错误</em>。该函数如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ln"><img src="../Images/0603e64fb662905652b56c7646c32664.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vx3EF5zxYgS_-oRwr0fiKA.png"/></div></div></figure><p id="550b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">随后的代码如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lo"><img src="../Images/934db82d5647d53cc20765ca9c9659c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJZnwJb2zTYaU1Hg5SI3wQ.png"/></div></div></figure><p id="2d81" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">和</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lp"><img src="../Images/90d7da33d293434fe6c9ead9fe533114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VMp-CLSkwavBoNxYT8Vqhw.png"/></div></div></figure><p id="148f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们做的最后一个改变是分解代码，让所有的团队都进入自己的功能。除了<em class="ke">getteamembers</em>，还有一个函数需要一片<em class="ke"> *github。团队</em>，我们不再重复自己，而是再次分享代码:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es le"><img src="../Images/5ac65665a0f53bca1ac387753c4db085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3mdq_8-b6CzQEBYE6OtWw.png"/></div></div></figure><p id="fe08" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们的<em class="ke">getteamembers</em>函数的最终版本是:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lq"><img src="../Images/19c60a4adb2e31292666771dd7040258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TPs8FYJrWaAtaHpnF4z6Lg.png"/></div></div></figure><h1 id="912b" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">用闭包排序</strong></h1><p id="c0dd" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">闭包法可以用在Go代码中的很多地方，在这些地方你会用到其他语言中的泛型。再比如排序。为了使用<em class="ke">排序。Sort </em>函数，你需要给它传递一个<em class="ke"> sort的实现。接口</em>接口。您可以使用以下代码，而不是每次需要对切片进行排序时都创建一个新类型:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lr"><img src="../Images/ca895fabfa38287e45726bf08d07a6f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f2WA4qI3LHk0W6C8sZMIFw.png"/></div></div></figure><p id="aff0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然后排序方式:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ls"><img src="../Images/fca2687f76082c4be7864dce31dc96cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDxT41pd-4pATQsaadJQhQ.png"/></div></div></figure><p id="dac3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在<a class="ae lc" href="https://play.golang.org/p/hYMcQ81AvN" rel="noopener ugc nofollow" target="_blank">https://play.golang.org/p/hYMcQ81AvN</a>尝试一下</p><p id="7910" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Go 1.8中增加了这种技术的一个变种，即新的<em class="ke">排序。切片</em>功能。</p><h1 id="26c4" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">半条面包</strong></h1><p id="1960" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">那么这是否意味着我们在Go中根本不需要泛型呢？不完全是。我们可以对通用函数进行抽象，但是我们仍然不能获得额外的用户定义的通用数据结构。</p><p id="9b70" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用闭包代替泛型的最大缺点是它们会产生副作用。现代软件开发不鼓励副作用，因为它们使得对数据流进行推理变得更加困难。当程序的函数只依赖于作为参数传入的数据，并且只修改在函数中创建的数据时，测试和理解程序会更容易。当一个函数依赖于设置在程序中其他地方的数据，并修改非本地数据时，就存在一个需要记录的看不见的依赖性。</p><p id="cb9c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当您传递闭包时，您可能会将本地状态转换成非本地数据。这些数据需要被管理。如果没有适当的锁定，就不能从多个goroutines调用它。没有办法知道传入的函数是一个闭包；你需要理解闭包是如何流过你的程序的。</p><p id="b09a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在上面的代码中，不清楚如何正确使用<em class="ke"> buildCompleteList </em>，因为该方法的输入和输出参数并不指示数据是如何创建或存储的。您需要查看函数的现有用法，看看传递给<em class="ke"> buildCompleteList </em>的闭包是否在它们声明的函数中修改了变量。</p><p id="9bf7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，这并没有让闭包变得糟糕；这只意味着你需要在适当的时候使用它们，并且要小心。我们可以使用它所拥有的工具来帮助我们解决这个限制，而不是在Go中寻找泛型</p></div><div class="ab cl lt lu go lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ha hb hc hd he"><p id="e27e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="ke">声明:以上观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权均为其各自所有者所有。本文为2017首都一。</em> </strong></p></div><div class="ab cl lt lu go lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ha hb hc hd he"><h1 id="cd24" class="kf kg hh bd kh ki ma kk kl km mb ko kp in mc io kr iq md ir kt it me iu kv kw bi translated"><strong class="ak">附加链接</strong></h1><ul class=""><li id="2b2b" class="mf mg hh jk b jl kx jo ky jr mh jv mi jz mj kd mk ml mm mn bi translated"><a class="ae lc" rel="noopener" href="/capital-one-developers/building-an-unbounded-channel-in-go-789e175cd2cd">在Go中构建无界通道</a></li><li id="a9d2" class="mf mg hh jk b jl mo jo mp jr mq jv mr jz ms kd mk ml mm mn bi translated"><a class="ae lc" href="https://developer.capitalone.com/blog-post/building-a-serverless-rest-api-in-go/" rel="noopener ugc nofollow" target="_blank">在Go中构建REST API</a></li></ul></div></div>    
</body>
</html>