<html>
<head>
<title>Migrating a 1M users app to Android 12 — Challenges &amp; Solutions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将100万用户应用迁移到Android 12——挑战和解决方案</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/migrating-a-1m-users-app-to-android-12-challenges-solutions-cfc00b0e36b3?source=collection_archive---------0-----------------------#2022-07-15">https://medium.com/walmartglobaltech/migrating-a-1m-users-app-to-android-12-challenges-solutions-cfc00b0e36b3?source=collection_archive---------0-----------------------#2022-07-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/dc0a96a15096010f55edbe120164b16b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pKycPmOPskDar-nljAotuA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Image source: <a class="ae it" href="https://en.wikipedia.org/wiki/Android_12#/media/File:Android_12_Developer_Preview_logo.svg" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Android_12#/media/File:Android_12_Developer_Preview_logo.svg</a></figcaption></figure><p id="38e8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android 12于2021年10月4日推出，是Android OS的最新稳定版本。随着越来越多的人将手机升级到Android 12或购买支持Android 12的新手机，及时将Android应用迁移到Android 12是当务之急。</p><p id="63eb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个博客是一个全面的指南，使Android开发者能够升级他们的应用代码库，以支持Android 12设备。这篇博客将揭示android 12的新功能，将应用程序迁移到android 12的一步一步的过程，以及在将应用程序代码库升级到android 12时应对挑战。那么，我们开始吧。</p><p id="ab3d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">第一步:更新目标SDK版本，将SDK版本编译为31 </strong></p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="a4ea" class="kb kc hh jx b fi kd ke l kf kg">compileSdkVersion 31<br/>...<br/>targetSdkVersion 31</span></pre><p id="da21" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">第二步:更安全的组件出口</strong></p><p id="13a8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您尝试在完成步骤1后构建您的应用程序，您将遇到以下错误，<br/> " <em class="kh">当相应的组件定义了意图过滤器时，针对Android 12及更高版本的应用程序需要为“android:exported”指定一个显式值。"</em></p><p id="7cf8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里开始你的Android 12的实际旅程:)<br/> <strong class="iw hi">规则1 </strong> —如果你的应用程序针对Android 12或更高版本，并且包含使用意图过滤器的活动、服务或广播接收器，你<strong class="iw hi">必须</strong>为这些应用程序组件显式声明<strong class="iw hi"> android:exported </strong>属性。</p><p id="2121" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">规则2 </strong> —如果app组件包含启动器类别，则设置android:exported = "true "。在大多数情况下，将“android:exported”设置为false。</p><p id="f839" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简而言之，如果需要从我们的应用程序外部访问任何组件(通过操作系统或其他应用程序)，我们需要将exported设置为true，否则需要将它们设置为false(仅由我们的应用程序使用)。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="5b72" class="kb kc hh jx b fi kd ke l kf kg">&lt;activity<br/>    android:name=".app.main.view.LauncherActivity"<br/>    android:configChanges="orientation|keyboardHidden|screenSize"<br/>    android:label="@string/app_name"<br/>    android:launchMode="singleTop"<br/>    ...<br/>    <strong class="jx hi">android:exported="true"</strong>&gt;<br/>    &lt;intent-filter&gt;<br/>        &lt;action android:name="android.intent.action.MAIN" /&gt;<br/><br/>        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;<br/>    &lt;/intent-filter&gt;<br/>    ...</span><span id="0ffa" class="kb kc hh jx b fi ki ke l kf kg">&lt;/activity&gt;</span></pre><p id="4d83" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是Android 12中引入的重大安全改进。<br/>完成此步骤后，您应该能够在Android 12设备/仿真器上安装您的应用程序。</p><p id="888b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">步骤3:待定意向可变性</strong></p><p id="ed0b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">完成第2步后，您会看到您的应用程序成功安装，但是，它不会在android 12设备上启动。在Android 12设备上启动应用程序时，您可能会遇到以下崩溃，</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="eac0" class="kb kc hh jx b fi kd ke l kf kg">Caused by: java.lang.IllegalArgumentException: &lt;application id&gt;: Targeting S+ (version 31 and above) requires that one of FLAG_IMMUTABLE or FLAG_MUTABLE be specified when creating a PendingIntent.<br/>    Strongly consider using FLAG_IMMUTABLE, only use FLAG_MUTABLE if some functionality depends on the PendingIntent being mutable, e.g. if it needs to be used with inline replies or bubbles.<br/>        at android.app.PendingIntent.checkFlags(PendingIntent.java:375)<br/>        at android.app.PendingIntent.getActivityAsUser(PendingIntent.java:458)<br/>        at android.app.PendingIntent.getActivity(PendingIntent.java:444)<br/>        at android.app.PendingIntent.getActivity(PendingIntent.java:408)<br/>...</span></pre><p id="0aa5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以上意味着，如果你的应用以Android 12为目标，你必须指定你的应用创建的每个PendingIntent对象的可变性。这一要求也提高了你的应用程序的安全性。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="d37e" class="kb kc hh jx b fi kd ke l kf kg">var pendingIntent: PendingIntent<br/>if (Build.VERSION.<em class="kh">SDK_INT </em>&gt;= Build.VERSION_CODES.<em class="kh">S</em>) {<br/>    pendingIntent = PendingIntent.getActivity(<br/>        context, 0, intent,<br/>        PendingIntent.<em class="kh">FLAG_UPDATE_CURRENT </em>or PendingIntent.<em class="kh">FLAG_IMMUTABLE<br/>    </em>)<br/>} else {<br/>    pendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.<em class="kh">FLAG_UPDATE_CURRENT</em>)<br/>}</span></pre><p id="16a3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">建议使用<em class="kh"> FLAG_IMMUTABLE。</em>然而，这里指定的<a class="ae it" href="https://developer.android.com/guide/components/intents-filters#CreateImmutablePendingIntents" rel="noopener ugc nofollow" target="_blank">的某些用例</a>可能需要你使用可变挂起意图，所以检查你的应用是否属于这些。<em class="kh"> <br/> </em>完成这一步后，你应该可以看到你的应用在Android 12设备上成功启动了。</p><p id="9e1e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我想在这里分享的几个技巧如下，<br/> <strong class="iw hi">技巧1: </strong>如果你的应用程序使用工作管理器(并且使用的版本不是最新的)，那么你仍然会遇到上面的崩溃。您应该使用最新版本的工作管理器(2.7.0或更高版本),因为2.7.0已经修复了此崩溃。<br/>请记住，最新版本的工作管理器(2.7.0及以上)需要您在应用中使用最新版本的Kotlin(1.6.0或以上)。</p><p id="1afb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">提示2: </strong>您可能会从您的应用程序中使用的任何第三方库或Android SDK库中获得此崩溃。在这种情况下，请升级到具有崩溃修复程序的最新版本的库。</p><p id="0f7f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">第四步:精确报警许可</strong></p><p id="d4db" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了鼓励应用程序节省系统资源，针对Android 12和更高版本并设置准确警报的应用程序必须能够访问“警报和提醒”功能。此功能出现在系统设置中的特殊应用程序访问屏幕上，要获得此访问权限，应用程序需要在清单中提及以下权限。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="9a03" class="kb kc hh jx b fi kd ke l kf kg">&lt;uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM"/&gt;</span></pre><p id="0933" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于某些面向客户的功能，应该使用精确的警报。在此检查设置精确报警<a class="ae it" href="https://developer.android.com/training/scheduling/alarms#exact-acceptable-use-cases" rel="noopener ugc nofollow" target="_blank">的可接受用例。</a></p><p id="5139" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">第五步:大概位置</strong></p><p id="37a8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在针对Android 12的应用程序上，用户可以要求你的应用程序只检索大概的位置信息，即使你的应用程序请求ACCESS_FINE_LOCATION权限。</p><p id="1b6a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了处理这种潜在的用户行为，不要单独请求ACCESS_FINE_LOCATION权限。相反，请在一个运行时请求中同时请求ACCESS_FINE_LOCATION权限和ACCESS_COARSE_LOCATION权限。</p><p id="3b8a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您的应用程序请求ACCESS_FINE_LOCATION和ACCESS_COARSE_LOCATION时,“系统权限”对话框为用户提供了以下选项:</p><ul class=""><li id="642c" class="kj kk hh iw b ix iy jb jc jf kl jj km jn kn jr ko kp kq kr bi translated"><strong class="iw hi">精确</strong>:这可以让你的app获得精确的位置信息。</li><li id="9620" class="kj kk hh iw b ix ks jb kt jf ku jj kv jn kw jr ko kp kq kr bi translated"><strong class="iw hi">近似</strong>:这让你的应用程序只能获得大概的位置信息。</li></ul><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es kx"><img src="../Images/5e0c36adb0fa8d678f0a36564b027028.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*7aBhSXXW6LoWf5B5quBTVw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">System permissions dialog that appears when your app requests both <code class="du ky kz la jx b">ACCESS_FINE_LOCATION</code> and <code class="du ky kz la jx b">ACCESS_COARSE_LOCATION</code> in a single runtime request. Image source: <a class="ae it" href="https://developer.android.com/" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/</a></figcaption></figure><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es kx"><img src="../Images/f9f76694d403c1f355dfc6e1dc365180.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*xR3Rvu3YvlnJnyltk21xEw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Changing permission from approximate to precise. Image source: <a class="ae it" href="https://developer.android.com/" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/</a></figcaption></figure><p id="1986" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">第六步:前台服务启动限制</strong></p><p id="ca92" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">针对Android 12或更高版本的应用程序不允许在后台运行时启动前台服务，除非出现少数例外情况。如果你的应用程序试图在后台运行时启动前台服务，就会出现异常(少数情况除外)。</p><p id="b94d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">考虑使用工作管理器来安排和开始工作，同时您的应用程序在后台运行。</p><p id="c1c5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">步骤7:不安全意图启动</strong></p><p id="41df" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在瞄准Android 12的同时，我们需要确保不使用不安全的意图启动。</p><p id="3057" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里需要遵循一些提示如下:</p><p id="9904" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">提示1 : </strong>检查是否过度使用putExtras(Intent)或putExtras(Bundle)调用。此外，要注意太大的包。可能的缓冲存储上限<a class="ae it" href="https://developer.android.com/reference/android/os/TransactionTooLargeException.html" rel="noopener ugc nofollow" target="_blank">只有1MB </a>。</p><p id="33ad" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不要试图将整个位图传递给某个意图。在这种情况下，您将遇到TransactionTooLargeException。</p><p id="baf3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">提示2 : </strong>在触发内部意图启动时，确保各个组件的“导出”标志设置为假。</p><p id="2407" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">技巧3 : 避免使用嵌套意图。这意味着我们应该理解将一个意图作为额外的意图传递给另一个意图，另一方面，这调用startActivity()。使用PendingIntents，而不要使用嵌套的intents。</p><p id="e380" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要检查应用程序中的不安全启动，请在应用程序类的onCreate()中配置VmPolicy时调用detectUnsafeIntentLaunch()。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="9f1c" class="kb kc hh jx b fi kd ke l kf kg">StrictMode.VmPolicy.Builder vmPolicyBuilder =<br/>    <strong class="jx hi">new </strong>StrictMode.VmPolicy.Builder()<br/>...<br/><strong class="jx hi">if </strong>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {<br/>  vmPolicyBuilder.detectUnsafeIntentLaunch();<br/>}<br/>StrictMode.setVmPolicy(vmPolicyBuilder.build());</span></pre><p id="6a83" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这段代码将列出控制台上所有不安全的启动。</p><p id="f37b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">步骤8: web意向解析</strong> <br/>从Android 12 (API级别31)开始，只有当您的应用程序被批准用于Web意向中包含的特定域时，Web意向才会解析为您应用程序中的活动。如果您的应用程序未获得该域的批准，它将解析为用户的默认浏览器应用程序。</p><p id="9c20" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">应用程序可以通过使用Android应用程序链接验证域来获得此批准。如果您的应用程序支持深层链接，那么要将它们转换为应用程序链接，并使您的应用程序成为所有URL的默认处理程序，请执行以下步骤:</p><p id="e29b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">1-在意图过滤器中添加“自动验证”属性</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="7691" class="kb kc hh jx b fi kd ke l kf kg">&lt;intent-filter <strong class="jx hi">android:autoVerify="true</strong>"&gt;<br/>    &lt;action android:name="android.intent.action.VIEW" /&gt;<br/><br/>    &lt;category android:name="android.intent.category.DEFAULT" /&gt;<br/>    &lt;category android:name="android.intent.category.BROWSABLE" /&gt;<br/><br/>    &lt;data android:scheme="https" /&gt;<br/>    &lt;data android:scheme="http" /&gt;</span><span id="57cf" class="kb kc hh jx b fi ki ke l kf kg">    <em class="kh">&lt;!-- If your website is www.example.com, then host will be example.com--&gt;<br/>    </em>&lt;data android:host="your site host name" /&gt;<br/>  <br/>    &lt;data android:path="/" /&gt;<br/> <br/>    &lt;data android:pathPrefix="/product/" /&gt;<br/>    ...<br/>&lt;/intent-filter&gt;</span></pre><p id="ff13" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2-将您的android应用程序与您的网站相关联:创建一个数字资产链接文件，如这里展示的<a class="ae it" href="https://developer.android.com/studio/write/app-link-indexing#associatesite" rel="noopener ugc nofollow" target="_blank"/>并上传到您的网站，每个人都可以在https:// &lt; yoursite &gt; /上阅读。知名/assetlinks.json。</p><p id="33ba" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">完成以上步骤后，每当用户点击一个Android应用程序链接时，如果你的应用程序安装在设备上，它会立即打开，不会出现歧义消除对话框。</p><p id="7ecf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">第九步:新安卓系统闪屏</strong></p><p id="1e20" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从Android 12开始，系统总是在所有应用的冷启动和热启动时应用新的默认闪屏。默认情况下，这个系统默认闪屏是使用你的应用程序的启动器图标元素和你的主题的窗口背景(如果它是单色的)构建的。</p><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lb"><img src="../Images/417b890d15caa02f53d04724c892bb5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujl87hoHQRBFYxKCqcD8XA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Splash screen Android 12(App icon dimensions highlighted). Image source: <a class="ae it" href="https://developer.android.com/guide/topics/ui/splash-screen" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/guide/topics/ui/splash-screen</a></figcaption></figure><p id="5c32" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">系统闪屏由您的应用程序图标组成，图标位于中心，图标背景位于具有窗口背景颜色的窗口内。</p><p id="44ca" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">将在另一篇博客中讨论迁移闪屏。</p><p id="d26c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">结论</strong></p><p id="a8c1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">完成我们的android应用到Android 12的迁移，并在生产中发布，这是一次激动人心的学习经历。我们了解了引入的功能和API，并在应用程序的各个领域利用了它们。通过这一举措，我们已经能够为我们的Android 12设备用户提供安全、个性化和轻松的体验。</p><p id="dbfe" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇博文的最后，我鼓励读者开始将他们的应用程序升级到android 12，并记住Google Play的最后期限，这里是<a class="ae it" href="https://support.google.com/googleplay/android-developer/answer/11926878?hl=en-IN" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="14cc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">参考文献</strong></p><ol class=""><li id="4f17" class="kj kk hh iw b ix iy jb jc jf kl jj km jn kn jr lc kp kq kr bi translated"><a class="ae it" href="https://developer.android.com/about/versions/12" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/about/versions/12</a></li><li id="ce92" class="kj kk hh iw b ix ks jb kt jf ku jj kv jn kw jr lc kp kq kr bi translated"><a class="ae it" href="https://www.android.com/android-12/" rel="noopener ugc nofollow" target="_blank">https://www.android.com/android-12/</a></li></ol></div></div>    
</body>
</html>