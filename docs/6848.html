<html>
<head>
<title>Leetcode Weekly Contest 188 — Solutions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leetcode每周竞赛188 —解决方案</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/leetcode-weekly-contest-188-38c847ccf0d3?source=collection_archive---------0-----------------------#2020-05-10">https://medium.com/quick-code/leetcode-weekly-contest-188-38c847ccf0d3?source=collection_archive---------0-----------------------#2020-05-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/c66ed56895420ad1f15ac845b01a84cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kBWo_GWrG58h28kDHwnBfg.png"/></div></div></figure><div class=""/><p id="25be" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个星期我排名第194，大约55分钟的比赛188。我大三的最后一个学期即将结束，所以我可能会更频繁地为每个Leetcode竞赛创建每周解决方案。</p><p id="82df" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这次比赛的特色是一些有趣的问题，包括一个数学问题，一个树的问题，和一个困难的(显然是来自日本的谷歌面试？对于谷歌问题来说，DP问题出奇的难。我将为前3个简单的问题做一个中等水平的指导(假设对Leetcode风格或竞争性编程风格有中等水平的了解),并真正带您完成大多数人未能解决的最后一个难题。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="e73f" class="ju jv hs bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">问题A: 1441。用堆栈操作构建数组(简单)</h1><h1 id="88c4" class="ju jv hs bd jw jx ks jz ka kb kt kd ke kf ku kh ki kj kv kl km kn kw kp kq kr bi translated"><strong class="ak">问题:</strong></h1><p id="1dfe" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><a class="ae lc" href="https://leetcode.com/contest/weekly-contest-188/problems/build-an-array-with-stack-operations/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/contest/weekly-contest-188/problems/build-a-array-with-stack-operations/</a></p><p id="d2b6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">给定一个数组<code class="du ld le lf lg b">target</code>和一个整数<code class="du ld le lf lg b">n</code>。在每一次迭代中，你都会读到一个来自<code class="du ld le lf lg b">list = {1,2,3..., n}</code>的数字。<br/>使用以下操作构建<code class="du ld le lf lg b">target</code>数组:<br/> <strong class="ir ht"> Push </strong>:从头<code class="du ld le lf lg b">list</code>读取一个新元素，并将其推入数组。<br/> <strong class="ir ht"> Pop </strong>:删除数组的最后一个元素<br/>如果目标数组已经建立，停止读取更多的元素。<br/>保证目标数组严格递增，只包含1到<code class="du ld le lf lg b">n</code>之间的数字。<br/> <strong class="ir ht">返回</strong>构建目标阵列的操作。向您保证答案是唯一的。</p><h1 id="810d" class="ju jv hs bd jw jx ks jz ka kb kt kd ke kf ku kh ki kj kv kl km kn kw kp kq kr bi translated"><strong class="ak">解决方案:</strong></h1><p id="cc51" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><strong class="ir ht">蛮力O(N)时间+空间:<br/> </strong>假设给我们一个以数字j结尾的目标数组，我们先把目标数组数字扔进一个集合，从数字1，2，3…j开始迭代，对于1到j中每一个不在集合中的数字I，我们就写push + pop。否则，写push。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="7d01" class="ju jv hs bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">问题B: 1442。计数可以形成两个相等XOR数组的三元组(中)</h1><h1 id="7b79" class="ju jv hs bd jw jx ks jz ka kb kt kd ke kf ku kh ki kj kv kl km kn kw kp kq kr bi translated"><strong class="ak">问题:</strong></h1><p id="ce72" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><a class="ae lc" href="https://leetcode.com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-array-of-equal-xor/</a></p><p id="6626" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">给定一个整数数组<code class="du ld le lf lg b">arr</code>。<br/>我们要选择三个指标<code class="du ld le lf lg b">i</code>、<code class="du ld le lf lg b">j</code>和<code class="du ld le lf lg b">k</code>，其中<code class="du ld le lf lg b">(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code>。<br/>让我们将<code class="du ld le lf lg b">a</code>和<code class="du ld le lf lg b">b</code>定义如下:</p><ul class=""><li id="5066" class="lh li hs ir b is it iw ix ja lj je lk ji ll jm lm ln lo lp bi translated"><code class="du ld le lf lg b">a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]</code></li><li id="4613" class="lh li hs ir b is lq iw lr ja ls je lt ji lu jm lm ln lo lp bi translated"><code class="du ld le lf lg b">b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]</code></li></ul><p id="0f5b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，<strong class="ir ht"> ^ </strong>表示<strong class="ir ht">逐位异或</strong>运算。<br/> <strong class="ir ht">返回</strong> <em class="lv">三胞胎数</em> ( <code class="du ld le lf lg b">i</code>、<code class="du ld le lf lg b">j</code>、<code class="du ld le lf lg b">k</code>)其中<code class="du ld le lf lg b">a == b</code>。</p><h1 id="76bb" class="ju jv hs bd jw jx ks jz ka kb kt kd ke kf ku kh ki kj kv kl km kn kw kp kq kr bi translated"><strong class="ak">解决方案:</strong></h1><p id="7094" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><strong class="ir ht">前缀蛮力O(N)时间+ O(1)空间:<br/> </strong>在比赛中，看输入大小总是很重要的。通常，如果输入大小在一百或一千的量级，那么一个蛮力或稍微优化的蛮力就足以被接受。我采用的解决方案是简单地对每一对I、j、k进行强力运算，并检查I和j-1之间的异或以及j和k之间的异或是否相等。我们需要跟踪前缀XOR，使其成为O(N)而不是O(N⁴).否则，你将会超时。</p><p id="e571" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">优化解:O(N)时间+ O(N)空间:</strong></p><p id="8c8d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以用不同的方式来看待这个问题。请注意，该问题要求子数组[i，j-1]和子数组[j，k]相等。两个异或相等意味着如果你对这两个异或，你得到0。实际上，这个问题的另一种观点是，我们寻找一个子数组[i，k],使得该子数组的XOR为0。一旦我们这样做了，我们就可以数一数我们可以把子数组[i，k]分成多少个j(这只是k-i-1，因为它的长度是-1)。如果你在想，在I，k之间拆分任意j，是否还会保持I和j-1之间的XOR和j和k之间的XOR相等的条件，那么放心，它们永远是相等的。你可以自己尝试一下！</p><p id="2986" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们现在构建解决方案。我们可以先在O(N)时间内建立前缀异或数组。然后，我们将使用这个前缀异或数组，并在O(N)时间内检查每对前缀值，以查看是否有任何两个值相等。如果是，那么在O(1)时间内计算其中的j。</p><p id="c9ef" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">最佳优化解:O(N)时间+ O(N)空间:<br/> </strong>如果你知道/听说过哈希，那么你大概就能算出这个。看一下子阵列和等于k的问题。它本质上是这里使用的相同技术。我们只是保存了一个前缀XOR的hashmap，但是这次我们还需要一个对应的事件总数的hashmap。这涉及到一些数学知识，但您可以查看详细信息:<a class="ae lc" href="https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/discuss/623747/JavaC%2B%2BPython-One-Pass-O(N4)-to-O(N)" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/count-triplets-than-can-form-two-arrays-of-equal-xor/discuse/623747/JavaC % 2B % 2b python-One-Pass-O(N4)-to-O(N)</a></p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="ef12" class="ju jv hs bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">问题C: 1443。收集树上所有苹果的最短时间(中等)</h1><h1 id="19e3" class="ju jv hs bd jw jx ks jz ka kb kt kd ke kf ku kh ki kj kv kl km kn kw kp kq kr bi translated">问题</h1><p id="d574" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><a class="ae lc" href="https://leetcode.com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apples-in-a-tree/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apple-in-a-tree/</a></p><p id="f0fa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">给定一棵由从0到T1的<code class="du ld le lf lg b">n</code>个顶点组成的无向树，树的顶点中有一些苹果。你花1秒钟走过树的一边。<em class="lv">返回从</em> <strong class="ir ht"> <em class="lv">顶点0 </em> </strong> <em class="lv">开始收集树上所有苹果并返回该顶点所需的最短时间(秒)。</em></p><p id="b663" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">数组<code class="du ld le lf lg b">edges</code>中给出了无向树的边，其中<code class="du ld le lf lg b">edges[i] = [fromi, toi]</code>表示存在一条连接顶点<code class="du ld le lf lg b">fromi</code>和<code class="du ld le lf lg b">toi</code>的边。此外，还有一个布尔数组<code class="du ld le lf lg b">hasApple</code>，其中<code class="du ld le lf lg b">hasApple[i] = true</code>表示顶点<code class="du ld le lf lg b">i</code>有一个苹果，否则它没有任何苹果。</p><h1 id="026d" class="ju jv hs bd jw jx ks jz ka kb kt kd ke kf ku kh ki kj kv kl km kn kw kp kq kr bi translated"><strong class="ak">解决方案:</strong></h1><p id="cf14" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><strong class="ir ht"> 2 DFS — O(N)时间+ O(N)空间<br/> </strong>我的解法很直观。请注意，我们需要访问一个节点，当且仅当该节点中有一个苹果，或者其后代中有一个苹果。这意味着我们需要一些没有给出的额外信息:节点的后代中是否有苹果。我们可以将这些数据存储在一个名为hasDescendantApples[]的数组中。我们将使用自底向上的DFS在O(N)空间和时间中获得这些信息。本质上，我们将首先向下递归到叶子，然后我们的工作将是检查孩子的hasDesendantApples是否为真，或者孩子本身是一个苹果。一旦我们有了这些信息，那么问题本身就简单了。让我们创建一个函数DFS，它将返回从当前节点获取所有苹果需要多少秒。我们将递归地使用这个函数。我们将从根开始DFS，按以下方式递归:如果当前节点的hasDescentApples为false，则返回0。否则，我们将递归到左节点和右节点，如果它们中的任何一个是苹果或者它们中的任何一个有后代苹果。我们将递归地添加DFS(子节点)，其中2来自于到那个节点并返回到当前节点。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h1 id="21cb" class="ju jv hs bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">问题D: 1444。切比萨饼的方法数量(硬)</h1><h1 id="e260" class="ju jv hs bd jw jx ks jz ka kb kt kd ke kf ku kh ki kj kv kl km kn kw kp kq kr bi translated">问题</h1><p id="7242" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">给定一个矩形披萨，表示为包含以下字符的<code class="du ld le lf lg b">rows x cols</code>矩阵:<code class="du ld le lf lg b">'A'</code>(一个苹果)和<code class="du ld le lf lg b">'.'</code>(空单元格)，并给定整数<code class="du ld le lf lg b">k</code>。你必须用<code class="du ld le lf lg b">k-1</code>刀把披萨切成<code class="du ld le lf lg b">k</code>块。</p><p id="09c6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于每一次切割，您选择方向:垂直或水平，然后选择单元格边界处的切割位置，将比萨饼切成两片。如果你垂直切比萨饼，把比萨饼的左边部分给一个人。如果你横着切披萨，把披萨的上半部分给一个人。把最后一块披萨给最后一个人。</p><p id="af6e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lv">返回切披萨的方式数，使每一块包含</em> <strong class="ir ht"> <em class="lv">至少</em> </strong> <em class="lv">个苹果。</em>由于答案可以是一个很大的数字，返回这个模10⁹ + 7。</p><h1 id="fcc5" class="ju jv hs bd jw jx ks jz ka kb kt kd ke kf ku kh ki kj kv kl km kn kw kp kq kr bi translated">解决办法</h1><p id="c589" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated"><strong class="ir ht"> DFS +记忆化(更简单的动态编程)——</strong></p><p id="45be" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个问题求DFS +内存化/ DP。如果你不熟悉或不擅长DP，那你来对地方了。我将一步一步地解释如何在所有面试和大多数比赛中得出最优解并解决任何DP问题。让我们开始吧:</p><p id="5caa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">蛮力——回溯/DFS: (TLE): O(K*M^N) 在任何类似这样的问题中，当我们被要求最小化/最大化某个数字时，我的第一直觉是首先编写一个蛮力解决方案。当然，暴力解决方案会超过时间限制(TLE ),但这是最佳解决方案的垫脚石。<br/>我们可以用下面的方式蛮力:</p><p id="f5d3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">陈述</strong>:首先，我们需要一种方式来表示我们当前的进展。在这种情况下，这就是我们正在处理的比萨饼的大小。由于比萨饼是一个矩形，我们将用左上角点和右下角点来表示当前的比萨饼切片。这是编程中用两点表示矩形的常用技巧。我们还需要记录我们削减的次数。</p><p id="ac67" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">尝试可能的动作:</strong>根据问题，我们可能的动作是水平和垂直分割披萨。因此，我们将这样做。我们会用许多不同的方法来分割比萨饼，并在这些比萨饼切片上递归。对于水平切割，这将简单地遍历每一行，并通过在一个较小的行上重复来“切割比萨饼”。类似于垂直，但有柱。我们也</p><p id="bd96" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">基本情况:</strong>如果我们切k-1次，那么我们知道我们完成了。我们只需要k个切片，所以切割k-1次意味着我们划分了正确的次数。</p><p id="bb69" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">将所有这些放在一起:</strong>我们从调用整个比萨饼开始，即从(0，0)到(m-1，n-1)，cut = 0。然后，我们迭代每个可能的切割，并递归这些新的比萨饼切片。我们需要跟踪的一件事是，每个切口必须包含一个苹果。要在O(1)时间内确定一个矩形是否有一个苹果，我们可以使用另一个DP表。如果不使用DP，时间复杂度会增加O(MN)，所以需要实现这个简单的表。这被称为不可变的2D查询，你可以在这里查看:<a class="ae lc" href="https://leetcode.com/problems/range-sum-query-2d-immutable/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/range-sum-query-2d-immutable</a>/<br/>一旦我们到达我们的基本情况，即我们已经进行了k-1次切割，我们需要检查这个矩形切片上是否有一个苹果。如果是的话，我们给全局返回变量加1。如果没有，那么就返回并在这里完成递归分支。</p><p id="30d9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">接受:O(MNK) —带记忆的DFS:</strong></p><p id="e0be" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，我们需要做一些聪明的事情。注意我们的蛮力是如何跟踪状态的5个变量的。左上角的点，由两个变量行和列组成，右下角的点，也是另外两个变量，第五个变量，我们进行的切割次数。我们可以减少变量的数量来保持状态，通过注意到问题说，对于我们进行的每一次切割，当我们垂直切割时，我们保持右半部分，或者当我们水平切割时，保持下半部分。这意味着我们的比萨饼切片将始终包含点(m-1，n-1)，即比萨饼的右下部分。因此，没有必要再跟踪右下角的点，因为它总是(m-1，n-1)。因此，我们的新状态是左上角的点和切割数。</p><p id="1614" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们只需要将我们的DFS暴力转化为记忆。这是通过保存每个递归调用的值，并在最后返回这些递归调用的总和来实现的。我们还需要将它存储在一个全局DP表中，以缓存调用。在每次递归调用的开始，我们首先检查这个状态以前是否已经解决过。如果它已经被归还了。搞定了。你刚刚解决了问题！</p><h1 id="179f" class="ju jv hs bd jw jx ks jz ka kb kt kd ke kf ku kh ki kj kv kl km kn kw kp kq kr bi translated">接触</h1><p id="f424" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">如有任何问题或代码，请发电子邮件至<strong class="ir ht">samatbryan@berkeley.edu</strong>联系我！一定要给这个帖子竖起大拇指，并对未来的上传给予反馈！</p></div></div>    
</body>
</html>