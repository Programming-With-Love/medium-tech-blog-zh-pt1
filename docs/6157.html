<html>
<head>
<title>Building a Python monorepo for fast, reliable development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为快速、可靠的开发构建Python monorepo</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/building-a-python-monorepo-for-fast-reliable-development-be763781f67?source=collection_archive---------0-----------------------#2017-10-20">https://medium.com/pinterest-engineering/building-a-python-monorepo-for-fast-reliable-development-be763781f67?source=collection_archive---------0-----------------------#2017-10-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="f316" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">苏曼·卡鲁穆里| Pinterest技术主管，可视性&amp;露丝·王君馨| Pinterest工程师，核心网站可靠性</p><p id="106e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每月有超过2亿人在Pinterest上发现并做他们喜欢的事情。我们依靠数百种Python服务和工具来增强这些体验。这些服务的代码存在于100多个Git存储库中(除了我们的Python前端monolith)。随着时间的推移，我们发现在越来越多的回购上开发Python应用程序会引起摩擦，并减慢我们开发人员的速度。我们构建Python commons是为了给我们的Python开发者提供无缝体验。在本帖中，我们将分享我们在大规模管理Python代码时遇到的一些挑战，以及Python commons如何提供快速可靠的代码开发环境。</p><h1 id="5954" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">大规模管理Python代码的挑战</h1><p id="77a6" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">虽然Python工具非常适合管理单个回购中的代码，但这些工具并不是为管理跨回购的代码而设计的。即使在单个repo中，也有一个陡峭的学习曲线来正确设置和使用工具和实用程序，如requirements、setup.py和tox，以实现可重现的构建和测试环境。考虑到所涉及的复杂性，很少有开发人员会花时间去做正确的事情。下面，我们将解释我们的开发人员在100多个回购中构建、测试和部署Python代码时面临的一些问题。</p><p id="2362" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">管理虚拟环境:</strong>每个Python项目都有自己的<a class="ae kf" href="https://virtualenv.pypa.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> virtualenv </a>，开发者在项目和分支工作时需要注意使用正确的virtualenv。使用错误的虚拟会导致开发、构建和部署过程中难以跟踪的错误。</p><p id="f0ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">使用tox运行单元测试:</strong>为了测试的完整性，开发人员被建议使用tox在virtualenv中运行他们的测试。鉴于管理虚拟env和正确设置tox的复杂性，实践中很少有项目这样做。(有些开发人员完全跳过编写单元测试。)</p><p id="02f5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">包固定:</strong>如果包没有固定到特定的版本，当它们的依赖关系升级时，它们可能会在生产中中断。即使每个repo都固定了其包的版本，跨repo重用代码也会导致包版本冲突，并在部署期间破坏包。</p><p id="ec6b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">部署安全修复:</strong>升级软件包来修复数百个回购中的安全问题是一个艰难、枯燥和乏味的过程。</p><p id="74a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Pip安装:</strong>我们大部分开发者都是用<code class="du kg kh ki kj b"><em class="kk">pip install</em></code> <em class="kk">部署Python包的。</em>在实践中，我们发现pip安装不是一个健壮的部署机制，原因如下:</p><ul class=""><li id="9f09" class="kl km hh ig b ih ii il im ip kn it ko ix kp jb kq kr ks kt bi translated">Pip安装不是原子的。失败的pip安装可能会使一些软件包升级，而另一些软件包是旧版本。这偶尔会导致部署中断。</li><li id="e94f" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">Pip可能会在生产机器上无声地失败，从而导致生产中断。</li><li id="d547" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">小版本变更时，Pip的命令行选项不一致，这可能导致pip随着新的操作系统版本一起升级时pip安装失败。</li><li id="9b05" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">Pip递归下载每个依赖项。虽然这在小范围内是无害的，但是每天在数万台机器上多次这样做是低效的。</li><li id="2a64" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">Pip安装对于部署内部工具并不理想，因为不一致的开发环境变得难以支持。大多数工具都带有定制脚本，用于设置虚拟env并在那里部署工具。虽然这样做可行，但这是一个乏味且容易出错的过程。</li></ul><p id="d623" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">一致的开发环境:</strong>由于开发人员建立了他们自己的回购协议，随着时间的推移，开发、构建、测试和部署设置几乎没有一致性。几个项目没有为他们的构建过程建立持续的集成，而编码约定和质量在不同的repos之间变化。即使是小问题，如未能正确命名一个包，也会在代码被重用时导致命名空间崩溃问题，从而导致复杂的解决方法。这种额外的复杂性阻碍了代码在repos中的重用。</p><p id="8b7d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的结论是，标准Python工具链需要大量前期工作，以便在单个repo中创建一致且可重复的构建环境。即使我们小心地设置了工具，标准工具也不能确保跨repos的一致构建和部署管道。</p><h1 id="f8be" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">Python commons</h1><p id="a6c9" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">当我们设计新的解决方案时，我们有一个主要目标——我们希望在让开发人员快速发布代码的同时，能够轻松地做正确的事情。因此，我们使用Pants构建工具构建了一个名为Python Commons的monorepo。为了简化我们的发布过程，我们使用一个<a class="ae kf" href="https://www.pantsbuild.org/pex_design.html" rel="noopener ugc nofollow" target="_blank"> Python可执行(PEX) </a>文件作为我们的发布原语。</p><h1 id="0930" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">Python commons monorepo</h1><p id="85fe" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">第一个决定是开始对我们工具的所有代码使用monorepo。这为所有代码提供了一个单一的位置，并允许我们在多回购解决方案上实施健康的开发实践。一致的开发、构建和测试环境也鼓励模块化代码和代码重用。monorepo对我们来说是更自然的工作流，因为我们有几个特定于语言的mono repo，并且几个工具共享同一个repo是很常见的。</p><p id="8eeb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于我们的前端应用程序代码已经有了一个Python monorepo，我们的第一反应是将工具的代码移到这个repo中，为所有Python代码创建一个单一的repo。然而，这并不奏效，因为开发工作流是为构建我们的整体Python web前端而大量定制的。因此，我们决定为我们的工具和服务构建一个名为“Python commons”的独立monorepo。</p><h1 id="d875" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">裤子</h1><p id="2b96" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">虽然决定monorepo很容易，但困难的部分是建立一个适合广泛Python应用程序的开发工作流，从web应用程序到服务、库和命令行工具。为了使管理和使用monorepo更容易，我们使用<a class="ae kf" href="https://www.pantsbuild.org/" rel="noopener ugc nofollow" target="_blank"> Pants </a>作为我们的构建工具。Pants有助于在保持我们的配置<a class="ae kf" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干燥</a>的同时，强制执行构建、测试和打包应用程序的统一开发工作流程。</p><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div><figcaption class="lg lh et er es li lj bd b be z dx">Figure 2: A snippet of our Python requirements file that lists external dependencies. The versions of packages are pinned for the entire repo, and the package versions are conflict-free, so all code in the repo can be reused.</figcaption></figure><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div><figcaption class="lg lh et er es li lj bd b be z dx">Figure 3: Each project in our repo contains its own folder. Each folder has a BUILD file, which lists the internal and external dependencies for the projects. In the BUILD file above, _bot target depends on argparse project. The srebot binary depends on _bot target.</figcaption></figure><figure class="kz la lb lc fd ld"><div class="bz dy l di"><div class="le lf l"/></div><figcaption class="lg lh et er es li lj bd b be z dx">Figure 4: A user can run predefined Pants goals on the targets.</figcaption></figure><p id="ec4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在回购中使用的代码布局为回购中的每个项目提供了一致的开发工作流。</p><ul class=""><li id="1923" class="kl km hh ig b ih ii il im ip kn it ko ix kp jb kq kr ks kt bi translated">图1所示的文件夹结构确保源代码和测试是分离的，所有内部代码都在Pinterest名称空间中。这种分离保护了我们免于将测试或它们的依赖项发布到产品中。</li><li id="cc67" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">Pants附带了一个内置的Python linter，用于强制执行回购的代码样式。</li><li id="e235" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">标准构建目标为构建、测试、运行和发布包提供了直观和一致的开发工作流(如图4所示)。</li><li id="39a2" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">pants repl选项提供了一个交互式repl来处理代码。</li><li id="440e" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">Pants基于构建文件中的依赖项为每次运行创建一个virtualenv。如果Git分支之间的依赖关系发生变化，开发人员不必切换virtual env来确保他们的代码正确工作，从而实现无缝的虚拟环境管理。</li><li id="ae5d" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">由于测试是在虚拟环境中运行的，开发人员不必学习或使用tox。</li><li id="e278" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">Pants测试目标会自动创建一个测试运行程序，因此不需要单独的脚本来运行测试。</li></ul><p id="306a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pants使用repo和版本锁定简化了跨项目的依赖管理。</p><ul class=""><li id="f3cc" class="kl km hh ig b ih ii il im ip kn it ko ix kp jb kq kr ks kt bi translated">Pants控制我们从哪个外部仓库下载包。当我们对PyPi repo的访问被阻塞时，我们通过对pants.ini文件的一行配置更改将repo指向一个内部镜像。</li><li id="200e" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">我们对整个repo使用相同的固定依赖集(如图2所示)。这是repo中定义我们的外部依赖关系并简化我们的依赖关系管理的唯一地方。Pants为每个构建构建了一个虚拟环境，所以任何依赖冲突都会被立即检测出来。</li><li id="f7b8" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">固定依赖项的单一位置允许我们一次升级repo中所有项目的包。这大大简化了安全审计和包版本升级。</li></ul><p id="b40d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过支持快速可复制的构建，Pants简化了构建和发布管理。</p><ul class=""><li id="1379" class="kl km hh ig b ih ii il im ip kn it ko ix kp jb kq kr ks kt bi translated">构建文件中的Pants run target可以用来在本地运行程序，不需要脚本。</li><li id="c228" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">Pants为我们的包提供了快速、可重复的构建。Pants在它的目标上执行增量构建，所以只有改变的模块被重建，这加快了构建过程。在虚拟envs中运行所有构建目标确保构建是可重复的。</li><li id="9d80" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">Pants python_library目标可以包含一个setup.py定义(如图3所示)。通过使用这个目标，开发者不必学习setup.py就可以发布Python彩蛋。</li><li id="2670" class="kl km hh ig b ih ku il kv ip kw it kx ix ky jb kq kr ks kt bi translated">Pants二进制目标为项目生成一个独立的pex二进制文件。</li></ul><h1 id="d2ae" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">最大运动量</h1><p id="8e1d" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">monorepo with pants简化了我们的开发和测试过程。我们观察到我们的开发人员更喜欢他们自己的repos，因为这让他们能够控制他们的代码作为Debian包、Docker容器、Python egg或脚本的分发。为了迎合这些用例并简化我们的包发布和部署过程，我们需要一种机制来轻松地将包导出为各种格式。导出一个鸡蛋很容易，因为Pants本身就支持它。为了将我们的代码打包成其他格式，我们使用<a class="ae kf" href="https://www.pantsbuild.org/pex_design.html" rel="noopener ugc nofollow" target="_blank"> PEX </a>作为我们代码的基本打包原语。PEX是一种自包含的、跨平台的Python可执行格式，带有打包的依赖项，因此它只需要运行它的机器上有一个Python解释器。一个PEX可以打包到Debian包、Docker容器或者上传到S3。最后一个部署选项非常适合内部工具，因为内部工具最难部署和管理。</p><p id="c526" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的多格式包发布过程由Jenkins脚本提供支持(如图5所示)。它使用项目名称和发布类型来生成必要的文件(Dockerfile、Debian package、Python egg、PEX二进制文件),并通过将它们上传到各自的repos来使构建可用于部署。发布过程不仅减轻了我们的开发人员对Docker、Debian包管理或Python egg格式的理解，而且还实施了最佳卫生和安全的包管理实践。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lk"><img src="../Images/b74f0d2136d97c10a53be8a00b3ce9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7D6TCkwy1DcvTZ4MEJDQAg.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Figure 5: Jenkins release workflow takes the package name and release type as input and generates a Docker container, Debian package, a Pypi package or a PEX binary.</figcaption></figure><h1 id="2554" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">结论</h1><p id="da5f" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">使用这种开发设置，我们可以在开发项目之前处理开发人员编写的所有样板代码。这有助于我们的开发人员专注于代码，而不必担心setup.py、tox、virtualenv。它还消除了创建脚本来本地设置和运行项目、创建脚本来发布Docker或Debian包或者创建脚本来本地或在Jenkins中测试代码的需要。大约一年前，我们推出了Python commons，并且已经将35个项目移植到它上面。</p></div><div class="ab cl lr ls go lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ha hb hc hd he"><p id="a95d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">鸣谢</strong>:感谢、徐永文和Nick Zheng对项目的帮助和反馈。我们还要感谢<a class="ae kf" href="https://www.pantsbuild.org/howto_contribute.html" rel="noopener ugc nofollow" target="_blank">裤子社区</a>的支持。</p><figure class="kz la lb lc fd ld er es paragraph-image"><div class="er es ly"><img src="../Images/c2e708437034ef3a06c845ca00e483ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:290/format:webp/1*VS-SIyipZqIIfQYxAvva3A.png"/></div></figure></div></div>    
</body>
</html>