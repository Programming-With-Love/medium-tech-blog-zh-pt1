<html>
<head>
<title>Implementing Google Recaptcha with Oracle JET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Oracle JET实现Google Recaptcha</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/google-recaptcha-and-oracle-jet-4dd17a8a6a20?source=collection_archive---------0-----------------------#2017-09-19">https://medium.com/oracledevs/google-recaptcha-and-oracle-jet-4dd17a8a6a20?source=collection_archive---------0-----------------------#2017-09-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3377" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我接近我的客户面向JET的网站的终点线时，我不得不做的最后一项任务是“保护服务器”。</p><p id="7c81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中一部分意味着在我的搜索表单上放置一个安全措施，这样它就不会被自动化滥用。谷歌reCAPTCHA非常适合这一点。谷歌现在也使用隐形模式，这意味着用户不必做任何事情。</p><h1 id="1e90" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">谷歌reCAPTCHA</h1><p id="d79d" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">如果你前往<a class="ae kf" href="https://www.google.com/recaptcha/intro/" rel="noopener ugc nofollow" target="_blank">https://www.google.com/recaptcha/</a>你可以创建你的API密匙。</p><p id="64d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就像多年来一样，所以这里没有变化…除了一件事:隐形reCAPTCHA</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/8234c611b8bd8ba1d2e880fcd6bb1e53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*F_JOHonHI6n5xVvdWOVsMQ.jpeg"/></div></figure><p id="8550" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦你创建了你的密钥，就该把它插入JET了。</p><h1 id="d4e1" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">在Oracle JET中使用reCAPTCHA</h1><p id="bc58" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated"><strong class="ig hi">添加URL作为库</strong></p><p id="0808" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们需要将reCAPTCHA添加到require路径中，这样我们就可以在需要时调用它。所以在main.js文件中:</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="349c" class="kt jd hh kp b fi ku kv l kw kx">$projectRoot/src/js/main.js</span></pre><p id="18ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<em class="ky">路径中添加以下内容:</em>对象，如下所示:</p><p id="a3bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kz la lb kp b">paths:<br/> //injector:mainReleasePaths<br/> {<br/><strong class="ig hi"> ‘googlerecaptcha’:’</strong><a class="ae kf" href="https://www.google.com/recaptcha/api.js?onload=onloadCallback&amp;render=explicit'" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">https://www.google.com/recaptcha/api.js?onload=onloadCallback&amp;render=explicit'</strong></a><strong class="ig hi">,</strong><br/> ‘knockout’: ‘libs/knockout/knockout-3.4.0.debug’,<br/> ‘jquery’: ‘libs/jquery/jquery-3.1.1’,<br/> ‘jqueryui-amd’: ‘libs/jquery/jqueryui-amd-1.12.0’,<br/> ‘promise’: ‘libs/es6-promise/es6-promise’,<br/> ‘hammerjs’: ‘libs/hammer/hammer-2.0.8’,</code></p><p id="e05b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你会注意到，我们使用explit方法将reCAPTCHA附加到页面上，当我试图弄清楚这一切时，这给我带来了一些严重的痛苦。如果您正在使用它(您应该这样做),那么此时将它添加到发布路径中可能是明智的。)</p><p id="2fdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">在您的模型中使用reCAPTCHA</strong></p><p id="b7f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里是我的乐趣开始的地方。默认情况下，Google reCAPTCHA希望用类<code class="du kz la lb kp b">g-recaptcha</code>绑定到一个按钮或div，并且本质上绑定到它。然而，在单页应用程序(SGA)中，这种情况不会发生，因为视图模型在视图之前运行。这就是我们之前使用<code class="du kz la lb kp b">render=explit</code>的原因。</p><p id="f5d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还提供了另一个参数，<code class="du kz la lb kp b">onload=onloadCallback.</code>,这样我们可以自己手动处理reCAPTCHA附件。</p><p id="79cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，在视图模型中创建一个函数，实现reCAPTCHA的onload功能:</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="c2e1" class="kt jd hh kp b fi ku kv l kw kx">onloadCallback=function(a){</span><span id="d389" class="kt jd hh kp b fi lc kv l kw kx">grecaptcha.render('<strong class="kp hi">submit</strong>', {<br/>                      'sitekey'  : 'YOUR_API_KEY',<br/>                      'callback' : onSubmit<br/>                  },true);<br/>}</span></pre><p id="af78" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将把reCAPTCHA代码的运行附加到一个id为<code class="du kz la lb kp b">submit.</code>的元素上。还提供了一个回调方法<code class="du kz la lb kp b">onSubmit </code>，一旦reCAPTCHA完成，这个方法就会被调用。</p><p id="141b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了回放，当我单击表单提交按钮(id为' submit ')时，reCAPTCHA将运行并自动检查我是否是机器人。如果成功，那么<code class="du kz la lb kp b">onSubmit </code>将被调用，它将生成的令牌作为参数传入，用于服务器端验证。如果reCAPTCHA认为我不是一个人，我得到的挑战是在写作的时候选择有特定目标的方块。</p><p id="a2bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了结束模型代码，<code class="du kz la lb kp b">onSubmit </code>方法看起来像这样:</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="0d21" class="kt jd hh kp b fi ku kv l kw kx">onSubmit=function(token){<br/>        console.info("google recatpcha onSubmit",token)</span><span id="df2b" class="kt jd hh kp b fi lc kv l kw kx">        //do validation/application code using token<br/>}</span></pre><p id="603d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以reCAPTCHA <code class="du kz la lb kp b">onSubmit </code>函数现在是您进入应用程序的入口点。</p><p id="34ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">查看代码</strong></p><p id="4c0c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在模型中，我们将reCATPCHA附加到id submit按钮上。定义如下:</p><p id="631e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kz la lb kp b">&lt;button id=”submit” data-bind=”ojComponent: { <br/> component: ‘ojButton’, <br/> label: ‘Send’}”/&gt;</code></p><p id="4832" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您会注意到这里没有click事件处理。这是因为reCAPTCHA bind为我们做了这一切。</p><h1 id="21b4" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">从这里去哪里</h1><p id="1f28" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">当运行你的应用程序时，你应该在应用程序的右下角看到reCAPTCHA横幅，告诉你它正确加载。如果您没有看到这一点，然后检查您的控制台；可能你的API不允许你的域名。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ld"><img src="../Images/9f747e6663875b648f2f3c1efe902b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:226/format:webp/1*PidTCZ9RuON8iE1NMWaygQ.png"/></div><figcaption class="le lf et er es lg lh bd b be z dx">reCAPTCHA loaded successfully</figcaption></figure><p id="e515" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您现在应该扩展<code class="du kz la lb kp b">onSubmit </code>方法来调用您的应用程序代码，确保将令牌发送到您的服务器，在那里您可以验证它。在验证该令牌之前，您不应该在服务器上做任何工作。</p><p id="6914" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我的后端验证看起来很松散，如下所示(NodeJS):</p><pre class="kh ki kj kk fd ko kp kq kr aw ks bi"><span id="f7fa" class="kt jd hh kp b fi ku kv l kw kx">var data = {secret: grecaptcha, response: recaptchaToken}<br/>  request.post({<br/>       url:"<a class="ae kf" href="https://www.google.com/recaptcha/api/siteverify" rel="noopener ugc nofollow" target="_blank">https://www.google.com/recaptcha/api/siteverify</a>",<br/>       form: data</span><span id="79cf" class="kt jd hh kp b fi lc kv l kw kx">})<br/>  .then(function (e){<br/>      //recaptcha service called...check result<br/>      var resp = JSON.parse(e);<br/>      if (resp.success == false){<br/>        console.info("recaptcha token outcome is false")<br/>       <br/>      } else {<br/>        console.info("recaptcha token validated")<br/>      }</span><span id="962c" class="kt jd hh kp b fi lc kv l kw kx">  })</span></pre><p id="9921" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请求的数据包含两个参数:<code class="du kz la lb kp b">secret </code>和<code class="du kz la lb kp b">response.</code><code class="du kz la lb kp b">secret</code>来自您在Google内部的API帐户。<code class="du kz la lb kp b">response </code>是您从前端的<code class="du kz la lb kp b">onSubmit </code>调用中收到的令牌，它应该已经被传递到您的API中。</p><p id="4059" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在这里做的是要求Google验证给定的令牌是有效的，而不是伪造的。否则任何机器人都可以传入令牌并调用我们的API。</p><h1 id="d140" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">外卖食品</h1><p id="464d" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">使用不可见的reCAPTCHA很容易出错，但是一旦实现，它会为你提供一些保护来抵御编程攻击/僵尸程序，从而拯救你的API。</p><p id="2018" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">——杰森·斯卡夫::<a class="ae kf" href="http://www.griffiths-waite.co.uk" rel="noopener ugc nofollow" target="_blank">格里菲斯·韦特</a></p></div></div>    
</body>
</html>