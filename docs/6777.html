<html>
<head>
<title>Even more tips on improving web app performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于提高web应用程序性能的更多提示</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/even-more-tips-on-improving-web-app-performance-4fff22da049d?source=collection_archive---------7-----------------------#2019-12-18">https://medium.com/quick-code/even-more-tips-on-improving-web-app-performance-4fff22da049d?source=collection_archive---------7-----------------------#2019-12-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/28e4c3e7fbca5bcb6a4c638934d32bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eQEN9QjYcyGRmdud.jpg"/></div></div></figure><h1 id="8df7" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">客户端缓存</h1><p id="d558" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">反复加载相对静态的内容以保持与数据库的同步性是非常昂贵的，即使是异步进行。与其让客户端一遍又一遍地下载这些大型响应，不如直接将第一次往返命中存储到数据库中，并设置一个缓存到期令牌，将缓存控制最大期限设置为任意长度(通常为60-120秒)。这将确保你至少在<max-age>段时间内不会打同样昂贵的电话。一旦计时器超时，缓存就会失效，无论数据库中的数据是否发生了变化，您都必须再次调用。但是这是相当低效的，因为如果什么都没有改变，你不需要返回整个响应，对吗？</max-age></p><p id="2c12" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这就是我们引入hashcode或某种独特的指纹令牌的地方。在这里使用你最喜欢的散列算法。基本上，流程是这样的:</p><p id="b8bf" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">客户端发送请求→ API发送回带有哈希码和到期令牌的数据→客户端尝试发送另一个请求，但当前时间小于到期令牌时间，因此请求未被发送→客户端尝试在令牌到期后发送另一个请求→ API处理请求→如果来自客户端的哈希码(最后结果)与来自当前响应的哈希码匹配，则发送回空响应，因此下载时间为0，否则发送带有更新哈希码的响应。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/2f9f43276d40cfc6d419ee310131fffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oB6LYDXlc0BC8sUv0QNV9g.jpeg"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">Before/After</figcaption></figure><h1 id="d309" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">服务器端缓存</h1><p id="e420" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这一部分对我来说很重要，因为我已经无数次地讨论了不同缓存机制的优缺点以及何时使用它们… Redis、memcached和Hazelcast几乎是任何应用程序的最佳竞争者…但我的奖项属于Varnish cache，从安装到实现到堆栈中的一切都是无缝的。</p><p id="1e4f" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">Varnish基本上充当了请求/响应的大规模键值存储，并可以与客户端缓存相结合，实现超快的UX。Varnish充当位于API盒子前面的反向代理。如果传入的请求已经在缓存中，它会立即返回，不需要服务器处理时间(在这里添加来自客户端缓存的hashcodes，以便在必要时使缓存无效)。每当您更新/删除记录时，确保使用非官方的PURGE http方法来清除该请求的缓存，然后将最新的数据加载到缓存中。</p><p id="7e8e" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这带来了很大的开销，在更新/删除后发送一个清除请求，以及重新加载数据到缓存中，但是相信我，你的用户会感谢你的。</p><p id="57a7" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">开个玩笑，你的用户更有可能注意到你取出加载旋转器并用<a class="ae kz" rel="noopener" href="/octopus-wealth/skeleton-loading-pages-with-react-5a931f12677b">骨架</a>替换它们</p><h1 id="f2be" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">分析UI/API代码的瓶颈</h1><p id="602e" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">oof owieee……这一点说起来很伤人，因为它需要最大的努力:(你必须分析每个端点，优化API上昂贵的操作/查询。然后分析您的UI渲染时间，找出哪些需要虚拟化或分页…这里没有提示或技巧，只是努力工作。</p><h1 id="0c54" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">转到体检</h1><p id="9689" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这是可选的。如果你和一堆其他应用/服务共享服务器空间，而这些应用/服务正在窃取你宝贵的计算时间，那么考虑出租一些专用的服务器空间，比如namecheap.com或heroku。我是个吝啬的混蛋，通常尽可能长时间使用免费计划。我只是说，当我还是一个破产的大学生时，我让Heroku在我的一个低劣的服务上为大约150个并发用户提供服务…全部免费。</p></div></div>    
</body>
</html>