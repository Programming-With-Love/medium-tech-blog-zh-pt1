<html>
<head>
<title>As a matter of Factory — Part 3 (Method Chaining)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工厂问题—第3部分(方法链接)</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/as-a-matter-of-factory-part-3-method-chaining-224217074d31?source=collection_archive---------0-----------------------#2019-02-19">https://medium.com/oracledevs/as-a-matter-of-factory-part-3-method-chaining-224217074d31?source=collection_archive---------0-----------------------#2019-02-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="03f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">学习如何通过利用<a class="ae jc" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>中一些不太为人所知的API，流畅地在Java集合中添加或删除元素。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/7d7804b077922de8338107f6ec905b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4L89DAN4fMUKpj8TdwLV7Q.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Let’s take a look under the hood at some lesser known APIs in Eclipse Collections.</figcaption></figure><h1 id="2aa4" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">静态工厂</h1><p id="4bf2" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">在“工厂问题”博客系列的第一期<a class="ae jc" rel="noopener" href="/@donraab/as-a-matter-of-factory-part-1-mutable-75cc2c5d72d9">、第二期</a><a class="ae jc" rel="noopener" href="/@donraab/as-a-matter-of-factory-part-2-immutable-8cb72ff897ee">和第二期</a>中，我描述了如何使用<code class="du kw kx ky kz b">Lists</code>、<code class="du kw kx ky kz b">Sets</code>和<code class="du kw kx ky kz b">Maps</code>类中可用的方法来创建和初始化可变和不可变集合。例如，Lists类中有静态实例<code class="du kw kx ky kz b">MutableListFactory</code>和<code class="du kw kx ky kz b">ImmutableListFactory</code>，它们存储在名为<em class="la">可变</em>和<em class="la">不可变</em>的公共静态最终变量中。</p><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="f90d" class="lf ju hh kz b be lg lh l li lj">MutableList&lt;String&gt; list = <br/>    Lists.mutable.with("1", "2", "3");<br/><br/>ImmutableList&lt;String&gt; list = <br/>    Lists.immutable.with("1", "2", "3");</span></pre><p id="05c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">方法<code class="du kw kx ky kz b">with</code>在<code class="du kw kx ky kz b">MutableListFactory</code>类上重载。一个版本的<code class="du kw kx ky kz b">with</code>方法不带参数，返回一个空的<code class="du kw kx ky kz b">MutableList</code>。该方法的另一个版本采用一个<em class="la"> varargs </em>参数，它将使用指定的参数构造一个<code class="du kw kx ky kz b">MutableList</code>。</p><h1 id="42db" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">流畅多变的界面</h1><p id="ef39" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">静态工厂方法并不是初始化<code class="du kw kx ky kz b">List</code>、<code class="du kw kx ky kz b">Set</code>、<code class="du kw kx ky kz b">Bag</code>或<code class="du kw kx ky kz b">Map</code>的唯一方法。可变接口上有直接可用的方法，可以用来流畅地改变集合。每个方法都会通过添加或移除元素来改变基础集合，然后返回相同的集合。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/d7a48a9c6e579097503b02f566986f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hxgYPl7zUiZAhysHAw4dKQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Fluent methods available on Mutable interfaces for mutating collections</figcaption></figure><h2 id="06b7" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">JDK接口的等效方法</h2><ul class=""><li id="4fb8" class="lz ma hh ig b ih kr il ks ip mb it mc ix md jb me mf mg mh bi translated"><code class="du kw kx ky kz b">with</code>-&gt;-<code class="du kw kx ky kz b">add</code></li><li id="f421" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><code class="du kw kx ky kz b">without</code>-&gt;-<code class="du kw kx ky kz b">remove</code></li><li id="e0ed" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><code class="du kw kx ky kz b">withAll</code>-&gt;-<code class="du kw kx ky kz b">addAll</code></li><li id="17b1" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><code class="du kw kx ky kz b">withoutAll</code>-&gt;-<code class="du kw kx ky kz b">removeAll</code></li><li id="bf9d" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><code class="du kw kx ky kz b">withKeyValue</code>——&gt;——T23】</li><li id="bdcb" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><code class="du kw kx ky kz b">withoutKey</code>-&gt;-<code class="du kw kx ky kz b">removeKey</code></li></ul><h1 id="6dec" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">流利地构建地图</h1><p id="07aa" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><code class="du kw kx ky kz b">MutableListFactory</code>上的<code class="du kw kx ky kz b">with</code>方法可以构造一个具有可变项数的<code class="du kw kx ky kz b">MutableList</code>，但是对于<code class="du kw kx ky kz b">MutableMapFactory</code>来说就不一样了。<code class="du kw kx ky kz b">MutableMapFactory</code>上的<code class="du kw kx ky kz b">with</code>方法过载五次。</p><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="0529" class="lf ju hh kz b be lg lh l li lj">&lt;K, V&gt; MutableMap&lt;K, V&gt; with();<br/>&lt;K, V&gt; MutableMap&lt;K, V&gt; with(K key, V value);<br/>&lt;K, V&gt; MutableMap&lt;K, V&gt; with(K key1, V value1, K key2, V value2);<br/>&lt;K, V&gt; MutableMap&lt;K, V&gt; with(K key1, V value1, K key2, V value2, K key3, V value3);<br/>&lt;K, V&gt; MutableMap&lt;K, V&gt; with(K key1, V value1, K key2, V value2, K key3, V value3, K key4, V value4);</span></pre><p id="7f4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您只能使用<code class="du kw kx ky kz b">with</code>方法创建一个最多有四个键和值的<code class="du kw kx ky kz b">MutableMap</code>。</p><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="fa94" class="lf ju hh kz b be lg lh l li lj">MutableMap&lt;Integer, String&gt; map =<br/>        Maps.mutable.with(<br/>                1, "One",<br/>                2, "Two",<br/>                3, "Three",<br/>                4, "Four");</span></pre><h2 id="a07c" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">如果需要四个以上的键和值，该怎么办？</h2><p id="1930" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">在<code class="du kw kx ky kz b">MutableMap</code>上有一个名为<code class="du kw kx ky kz b">withKeyValue</code>的方法，通过利用方法链接，它可以用来流畅地添加无限数量的键和值对。</p><h2 id="d302" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">使用withKeyValue流畅地构建一个可变映射</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="6500" class="lf ju hh kz b be lg lh l li lj">MutableMap&lt;Integer, String&gt; numbers =<br/>        Maps.mutable.&lt;Integer, String&gt;empty()<br/>                .withKeyValue(0, "Zero")<br/>                .withKeyValue(1, "One")<br/>                .withKeyValue(2, "Two")<br/>                .withKeyValue(3, "Three")<br/>                .withKeyValue(4, "Four")<br/>                .withKeyValue(5, "Five")<br/>                .withKeyValue(6, "Six")<br/>                .withKeyValue(7, "Seven")<br/>                .withKeyValue(8, "Eight")<br/>                .withKeyValue(9, "Nine")<br/>                .withKeyValue(10, "Ten");<br/><br/>Assert.assertEquals("Zero", numbers.get(0));<br/>Assert.assertEquals("One", numbers.get(1));<br/>Assert.assertEquals("Ten", numbers.get(10));</span></pre><h2 id="129b" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">withKeyValue方法</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="5247" class="lf ju hh kz b be lg lh l li lj">public MutableMap&lt;K, V&gt; withKeyValue(K key, V value)<br/>{<br/>    this.put(key, value);<br/>    return this;<br/>}</span></pre><h2 id="de33" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">流畅地构建一个不变的地图</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="f127" class="lf ju hh kz b be lg lh l li lj">ImmutableMap&lt;Integer, String&gt; numbers =<br/>        Maps.mutable.&lt;Integer, String&gt;empty()<br/>                .withKeyValue(0, "Zero")<br/>                .withKeyValue(1, "One")<br/>                .withKeyValue(2, "Two")<br/>                .withKeyValue(3, "Three")<br/>                .withKeyValue(4, "Four")<br/>                .withKeyValue(5, "Five")<br/>                .withKeyValue(6, "Six")<br/>                .withKeyValue(7, "Seven")<br/>                .withKeyValue(8, "Eight")<br/>                .withKeyValue(9, "Nine")<br/>                .withKeyValue(10, "Ten")<br/>                .toImmutable();<br/><br/>Assert.assertEquals("Zero", numbers.get(0));<br/>Assert.assertEquals("One", numbers.get(1));<br/>Assert.assertEquals("Ten", numbers.get(10));</span></pre><h2 id="4118" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">流畅地构建一个不可变的对象/原语映射</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="c550" class="lf ju hh kz b be lg lh l li lj">ObjectIntMap&lt;String&gt; numbers =<br/>        ObjectIntMaps.mutable.&lt;String&gt;empty()<br/>                .withKeyValue("Zero", 0)<br/>                .withKeyValue("One", 1)<br/>                .withKeyValue("Two", 2)<br/>                .withKeyValue("Three", 3)<br/>                .withKeyValue("Four", 4)<br/>                .withKeyValue("Five", 5)<br/>                .withKeyValue("Six", 6)<br/>                .withKeyValue("Seven", 7)<br/>                .withKeyValue("Eight", 8)<br/>                .withKeyValue("Nine", 9)<br/>                .withKeyValue("Ten", 10)<br/>                .toImmutable();<br/><br/>Assert.assertEquals(0, numbers.get("Zero"));<br/>Assert.assertEquals(1, numbers.get("One"));<br/>Assert.assertEquals(10, numbers.get("Ten"));</span></pre><h2 id="8fc4" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">流畅地构建一个不可变的原语/对象映射</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="7b54" class="lf ju hh kz b be lg lh l li lj">IntObjectMap&lt;String&gt; numbers =<br/>        IntObjectMaps.mutable.&lt;String&gt;empty()<br/>                .withKeyValue(0, "Zero")<br/>                .withKeyValue(1, "One")<br/>                .withKeyValue(2, "Two")<br/>                .withKeyValue(3, "Three")<br/>                .withKeyValue(4, "Four")<br/>                .withKeyValue(5, "Five")<br/>                .withKeyValue(6, "Six")<br/>                .withKeyValue(7, "Seven")<br/>                .withKeyValue(8, "Eight")<br/>                .withKeyValue(9, "Nine")<br/>                .withKeyValue(10, "Ten")<br/>                .toImmutable();<br/><br/>Assert.assertEquals("Zero", numbers.get(0));<br/>Assert.assertEquals("One", numbers.get(1));<br/>Assert.assertEquals("Ten", numbers.get(10));</span></pre><h2 id="5afd" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">流利地建立一个不可变的原始/原始地图</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="47ea" class="lf ju hh kz b be lg lh l li lj">IntCharMap numbers = IntCharMaps.mutable.empty()<br/>        .withKeyValue(0, '0')<br/>        .withKeyValue(1, '1')<br/>        .withKeyValue(2, '2')<br/>        .withKeyValue(3, '3')<br/>        .withKeyValue(4, '4')<br/>        .withKeyValue(5, '5')<br/>        .withKeyValue(6, '6')<br/>        .withKeyValue(7, '7')<br/>        .withKeyValue(8, '8')<br/>        .withKeyValue(9, '9')<br/>        .toImmutable();<br/><br/>Assert.assertEquals('0', numbers.get(0));<br/>Assert.assertEquals('1', numbers.get(1));<br/>Assert.assertEquals('9', numbers.get(9));</span></pre><h1 id="cbfb" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">流利地建立清单，集和袋</h1><p id="15d0" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">使用方法链接流畅地构建一个<code class="du kw kx ky kz b">Map</code>通常比流畅地构建一个<code class="du kw kx ky kz b">List</code>、<code class="du kw kx ky kz b">Set</code>或<code class="du kw kx ky kz b">Bag</code>更有用。如果您需要，功能仍然存在。</p><h2 id="d19b" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">流利地建立一个列表</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="af22" class="lf ju hh kz b be lg lh l li lj">ImmutableList&lt;Integer&gt; numbers =<br/>        Lists.mutable.with(1)<br/>                .with(2)<br/>                .with(3)<br/>                .with(4)<br/>                .withAll(Interval.fromTo(5, 10))<br/>                .toImmutable();<br/><br/>Assert.assertEquals(Interval.oneTo(10), numbers);</span></pre><p id="c200" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，我使用了两种方法来流畅地构建<code class="du kw kx ky kz b">MutableList</code>。方法<code class="du kw kx ky kz b">with</code>采用单个参数，方法<code class="du kw kx ky kz b">withAll</code>采用一个<code class="du kw kx ky kz b">Iterable</code>。</p><h2 id="7d6f" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">with方法</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="f8a8" class="lf ju hh kz b be lg lh l li lj">public MutableList&lt;T&gt; with(T element)<br/>{<br/>    this.add(element);<br/>    return this;<br/>}</span></pre><h2 id="86a6" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">withAll方法</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="bc03" class="lf ju hh kz b be lg lh l li lj">public MutableList&lt;T&gt; withAll(Iterable&lt;? extends T&gt; elements)<br/>{<br/>    this.addAllIterable(elements);<br/>    return this;<br/>}</span></pre><h2 id="4720" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">流利地搭建布景</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="c511" class="lf ju hh kz b be lg lh l li lj">ImmutableSet&lt;Integer&gt; numbers =<br/>        Sets.mutable.with(1)<br/>                .with(2)<br/>                .with(3)<br/>                .with(4)<br/>                .withAll(Interval.fromTo(5, 10))<br/>                .toImmutable();<br/><br/>Assert.assertEquals(Interval.oneTo(10).toSet(), numbers);</span></pre><h2 id="5709" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">流利地制作一个包</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="381f" class="lf ju hh kz b be lg lh l li lj">ImmutableBag&lt;Integer&gt; numbers =<br/>        Bags.mutable.with(1)<br/>                .with(2)<br/>                .with(3)<br/>                .with(4)<br/>                .withAll(Interval.fromTo(5, 10))<br/>                .toImmutable();<br/><br/>Assert.assertEquals(Interval.oneTo(10).toBag(), numbers);</span></pre><h2 id="2d22" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">流利地建立原始列表、集合和包</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="8493" class="lf ju hh kz b be lg lh l li lj">ImmutableIntList list =<br/>        IntLists.mutable.with(1)<br/>                .with(2)<br/>                .with(3)<br/>                .with(4)<br/>                .withAll(IntInterval.fromTo(5, 10))<br/>                .toImmutable();<br/><br/>Assert.assertEquals(IntInterval.oneTo(10), list);<br/><br/>ImmutableIntSet set =<br/>        IntSets.mutable.with(1)<br/>                .with(2)<br/>                .with(3)<br/>                .with(4)<br/>                .withAll(IntInterval.fromTo(5, 10))<br/>                .toImmutable();<br/><br/>Assert.assertEquals(IntInterval.oneTo(10).toSet(), set);<br/><br/>ImmutableIntBag bag =<br/>        IntBags.mutable.with(1)<br/>                .with(2)<br/>                .with(3)<br/>                .with(4)<br/>                .withAll(IntInterval.fromTo(5, 10))<br/>                .toImmutable();<br/><br/>Assert.assertEquals(IntInterval.oneTo(10).toBag(), bag);</span></pre><h1 id="c145" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">在收集器2中使用withAll</h1><p id="dc75" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><code class="du kw kx ky kz b">withAll</code>方法对于构建返回集合的收集器非常有用。在Eclipse集合的<code class="du kw kx ky kz b">Collectors2</code>类中，<code class="du kw kx ky kz b">withAll</code>方法被反复用作方法引用。</p><h2 id="6dc2" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">Collectors2.toList()</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="748b" class="lf ju hh kz b be lg lh l li lj">public static &lt;T&gt; Collector&lt;T, ?, MutableList&lt;T&gt;&gt; toList()<br/>{<br/>    return Collector.of(<br/>            Lists.mutable::empty,<br/>            MutableList::add,<br/>            MutableList::withAll,<br/>            EMPTY_CHARACTERISTICS);<br/>}</span></pre><h2 id="d0c6" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">Collectors2.toImmutableList()</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="4c91" class="lf ju hh kz b be lg lh l li lj">public static &lt;T&gt; Collector&lt;T, ?, ImmutableList&lt;T&gt;&gt; toImmutableList()<br/>{<br/>    return Collector.&lt;T, MutableList&lt;T&gt;, ImmutableList&lt;T&gt;&gt;of(<br/>            Lists.mutable::empty,<br/>            MutableList::add,<br/>            MutableList::withAll,<br/>            MutableList::toImmutable,<br/>            EMPTY_CHARACTERISTICS);<br/>}</span></pre><h2 id="63f2" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">Collectors2.countBy(函数)</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="3246" class="lf ju hh kz b be lg lh l li lj">public static &lt;T, K&gt; Collector&lt;T, ?, MutableBag&lt;K&gt;&gt; <br/>countBy(Function&lt;? super T, ? extends K&gt; function)<br/>{<br/>    return Collector.of(<br/>            Bags.mutable::empty,<br/>            (bag, each) -&gt; bag.with(function.valueOf(each)),<br/>            MutableBag::withAll,<br/>            EMPTY_CHARACTERISTICS);<br/>}</span></pre><h1 id="a494" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">有或没有</h1><p id="ef53" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我们喜欢在Eclipse集合中提供良好的对称性。如果您可以流畅地向集合中添加项目，那么能够流畅地从集合中移除项目也是有意义的。</p><h2 id="7647" class="ll ju hh bd jv lm ln lo jz lp lq lr kd ip ls lt kh it lu lv kl ix lw lx kp ly bi translated">UnifiedSet上的without方法</h2><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="5aa4" class="lf ju hh kz b be lg lh l li lj">public UnifiedSet&lt;T&gt; without(T element)<br/>{<br/>    this.remove(element);<br/>    return this;<br/>}</span></pre><p id="1996" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里有一个结合了Eclipse集合工厂的一些流畅方面的例子。</p><pre class="je jf jg jh fd lb kz lc bn ld le bi"><span id="c734" class="lf ju hh kz b be lg lh l li lj">ImmutableSet&lt;String&gt; strings =<br/>        Sets.mutable.with("or", "without", "you")<br/>                .with("or")<br/>                .without("you")<br/>                .toImmutable();<br/><br/>Assert.assertEquals(Sets.mutable.with("or", "without"), strings);</span></pre><h1 id="8697" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最后的想法</h1><p id="6ea8" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">希望这篇博客中的信息和例子对你有用。这个博客的灵感来自最近提交给Eclipse Collections的<a class="ae jc" href="https://github.com/eclipse/eclipse-collections/pull/699" rel="noopener ugc nofollow" target="_blank"> pull请求</a>。Eclipse集合中有许多隐藏的珍宝。当它们变得不那么容易被发现时，我喜欢写它们。</p><p id="608b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="la">我是</em><a class="ae jc" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="la">Eclipse Collections</em></a><em class="la">OSS项目在</em><a class="ae jc" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="la">Eclipse Foundation</em></a><em class="la">的项目负责人。</em> <a class="ae jc" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="la">月食收藏</em> </a> <em class="la">开作</em> <a class="ae jc" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="la">投稿</em> </a> <em class="la">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p></div></div>    
</body>
</html>