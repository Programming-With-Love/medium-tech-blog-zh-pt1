<html>
<head>
<title>Challenges &amp; Solutions for Migrating Java Apps to Reactive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Java应用迁移到Reactive的挑战和解决方案</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/challenges-solutions-for-migrating-java-apps-to-reactive-f6df16d19c9c?source=collection_archive---------0-----------------------#2021-08-26">https://medium.com/capital-one-tech/challenges-solutions-for-migrating-java-apps-to-reactive-f6df16d19c9c?source=collection_archive---------0-----------------------#2021-08-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="6b55" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">通过使用反应式WebFlux重新实现Java Spring Boot应用程序，我学到了什么</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/44d05756b89af787e77663a1d7a12d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xvEJ8bI87cLGc2eA"/></div></div></figure><p id="ead3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我在Capital One的团队定期进行创新冲刺(T1)，这是为期两周的时间，我们可以在正常需求之外做一些事情，比如新技术或工具。最近有一些关于<a class="ae kf" href="https://www.reactive-streams.org/" rel="noopener ugc nofollow" target="_blank">反应流API </a>的讨论，认为它是web应用中非阻塞IO的一个引人注目的策略，我有兴趣深入研究一下。因此，我们和同事Kristian Langholm一起，决定通过将我们团队的一个<a class="ae kf" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>应用程序迁移到使用<a class="ae kf" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html" rel="noopener ugc nofollow" target="_blank"> WebFlux </a>来研究Reactive范式，这是Reactive for Spring应用程序的一个实现。对于我们的测试主题，我们决定使用一个小的API来处理包含客户交易信息的请求，并返回关于应该允许还是阻止交易的决定。</p><p id="6853" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然Kristian和我已经对WebFlux做了一些研究，阅读了文档和几篇解释如何使用它的文章(我发现<a class="ae kf" href="https://dzone.com/articles/spring-webflux-eventloop-vs-thread-per-request-mod" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae kf" href="https://www.baeldung.com/spring-reactive-guide" rel="noopener ugc nofollow" target="_blank">这个</a>特别有帮助)，我们仍然在重新实现我们的应用程序的整个过程中面临着几个挑战。其中一些在本质上更加抽象<em class="ke">(你如何以“反应方式”编写代码？Reactive是否是这种应用的正确选择？)</em>还有一些更加专业和具体<em class="ke">(你如何以非阻塞的方式处理错误？Map、flatMap和flatmapny有什么区别？)</em>。在这个过程结束时，我们已经找到了这些问题的答案，并认为与对使用Reactive实现应用程序的过程感兴趣的其他人分享我们的发现可能会有所帮助。</p><p id="c671" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">注意——在本文中，我将使用广义的术语“反应式”来指代未来的反应式流API，但是您也可以用自己选择的反应式框架来代替它。</em></p><h1 id="c712" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">挑战0:如何看待反应式编程和命令式编程</h1><p id="c293" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">使用Reactive的第一个挑战是如何思考代码及其工作方式的思维转变。我喜欢按照<em class="ke">“每个请求一个工人”</em>和<em class="ke">“每个子任务一个工人”来考虑这个问题</em>基本上，命令型线程处理整个请求的方式不同，而反应型线程只处理请求的一小部分。</p><p id="56c9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们打个比方:假设你拥有一家定制家具厂，并雇佣了一个劳动力来帮助组装家具。当收到请求时，你派出一名工人，向他们提出请求，他们执行所有的任务来按照提供的规格建造家具——收集木材，切割碎片，将它们连接在一起，上漆和染色，最后包装成品以便交付。这大概就是命令式web应用程序的工作方式。为每个请求分派一个工作线程，它处理请求的每个部分。如果该过程的任何部分导致一些延迟(例如，等待油漆干燥)，工人在继续之前等待该延迟结束。</p><p id="7eae" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在反应式范例中，事情完全不同。假设你有一群工人在休息室被分配任务；这个工作者集合类似于Reactive中的执行器线程池(关于执行器线程池和Reactive线程模型的更多细节可以在<a class="ae kf" href="https://dzone.com/articles/understanding-the-reactive-thread-model-part-1" rel="noopener ugc nofollow" target="_blank">这篇有用的文章</a>中找到)。在家具制造的每个阶段，可以要求任何可用的工人来完成任务。一旦工人完成了那部分任务，他们可以回到休息室等待下一个任务。同样，如果任务的一部分需要等待(例如等待油漆变干)，工人也可以回到休息室。一旦油漆干了，其他人(或者可能是同一个工人)会被派去做下一步。反应式家具工厂的这种特殊性质类似于非阻塞IO。与其让工人浪费时间等待油漆变干，工人可以自由地去做其他事情。该工厂中的工人花费更少的时间等待，更多的时间在实际任务上，同样，在反应式范例中，线程处于空闲状态的时间更少。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ld"><img src="../Images/cf9ff36bc2f8283304e78864851bc167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCEuhaeNjmXdAkMGFFxUPA.jpeg"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">Source <a class="ae kf" href="https://commons.wikimedia.org/w/index.php?title=File:Woodworker_using_sliding_mitre_saw.jpg&amp;oldid=522132852" rel="noopener ugc nofollow" target="_blank">Wikipedia</a>. This file is licensed under the <a class="ae kf" href="https://en.wikipedia.org/wiki/en:Creative_Commons" rel="noopener ugc nofollow" target="_blank">Creative Commons</a> <a class="ae kf" href="https://creativecommons.org/licenses/by/2.0/deed.en" rel="noopener ugc nofollow" target="_blank">Attribution 2.0 Generic</a> license.</figcaption></figure><h1 id="7bdc" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">挑战1:我们应该使用反应式吗？</h1><p id="d3e0" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">那么，为什么首先要使用反应范式呢？反应式Java的主要优势是更有效地利用线程:</p><ul class=""><li id="b41a" class="li lj hh jk b jl jm jo jp jr lk jv ll jz lm kd ln lo lp lq bi translated">随着并发请求数量的增加，使用的线程总数减少。</li><li id="8450" class="li lj hh jk b jl lr jo ls jr lt jv lu jz lv kd ln lo lp lq bi translated">线程间切换花费的时间更少。</li></ul><p id="223a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这两个优点中，前者在大多数情况下更为重要。在现代系统中，线程间切换的上下文开销越来越小(在几纳秒或十亿分之一秒的规模上)。除非您的API具有非常严格的SLA，否则这可能不是一个大问题。</p><p id="5d6f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，使用更少的线程的优势是显著的。线程将内存用于上下文，使用较少的线程应该直接对应于更有效的内存使用，这在内存受限的环境中可能是一个问题。由于这个原因，在某些情况下，切换到反应式可以显著减少内存消耗。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lw"><img src="../Images/5251b451056fb4c944231fe88be93233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhO44FXwe0lRi7o0GNfNLg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx">Links for Reactive implementations of databases: <a class="ae kf" href="http://reactivemongo.org/" rel="noopener ugc nofollow" target="_blank">MongoDB</a>, <a class="ae kf" href="https://docs.spring.io/spring-data/cassandra/docs/current/api/org/springframework/data/cassandra/repository/ReactiveCassandraRepository.html" rel="noopener ugc nofollow" target="_blank">Cassandra</a>, <a class="ae kf" href="https://www.javacodegeeks.com/2018/12/reactive-spring-webflux-aws-dynamodb.html" rel="noopener ugc nofollow" target="_blank">DynamoDB</a>.</figcaption></figure><p id="c9a1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">总的来说，切换到反应式可能不会提高速度性能，但是如果您使用异步调用同时处理许多请求，它可能会有利于您的内存性能。</p><h1 id="5ed4" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">挑战Java Streaming API、Java Futures和Reactive之间有什么异同？</h1><p id="343b" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">如果你熟悉<a class="ae kf" href="https://www.baeldung.com/java-8-streams" rel="noopener ugc nofollow" target="_blank"> Java流API </a>或<a class="ae kf" href="https://www.baeldung.com/java-future" rel="noopener ugc nofollow" target="_blank"> Java Futures </a>，那么这些知识在反应式编程领域也有类似的概念。我们将首先看一看Java流和Java Future与Reactive之间的相似之处，然后讨论一个特别令人困惑的案例，它突出了一些不同之处。</p><h2 id="d58a" class="lx kh hh bd ki ly lz ma km mb mc md kq jr me mf ks jv mg mh ku jz mi mj kw mk bi translated">Java流API</h2><p id="660c" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">Java流API<a class="ae kf" href="https://www.baeldung.com/java-8-streams" rel="noopener ugc nofollow" target="_blank">允许你将函数应用到元素流中。这里有一个简单的例子:</a></p><pre class="ix iy iz ja fd ml mm mn mo aw mp bi"><span id="9c4a" class="lx kh hh mm b fi mq mr l ms mt">List<em class="ke">&lt;</em>String<em class="ke">&gt; </em>uppercaseStringList = <br/>    Stream.<em class="ke">of(</em>"alpha", "bravo", "charlie"<em class="ke">)<br/>          </em>.map<em class="ke">(</em>String::toUpperCase<em class="ke">)</em>.collect<em class="ke">(</em>Collectors.<em class="ke">toList())</em>;</span></pre><p id="fc59" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这个例子中，我们创建了一个字符串“alpha”、“bravo”和“charlie”的流，对每个字符串应用大写函数，并将它们收集到一个列表中。Reactive也有一个流的概念，它们非常相似:可以对其应用函数的元素集合。关键的区别在于，Java流API流用于阻塞/同步元素，而反应式Java流用于非阻塞/异步元素。</p><h2 id="b353" class="lx kh hh bd ki ly lz ma km mb mc md kq jr me mf ks jv mg mh ku jz mi mj kw mk bi translated">Java未来</h2><p id="f5d6" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">Java Futures 可以进一步扩展命令流和反应流之间的相似性。考虑这个例子:</p><pre class="ix iy iz ja fd ml mm mn mo aw mp bi"><span id="49a0" class="lx kh hh mm b fi mq mr l ms mt">List results = Stream.<em class="ke">of(</em>CompletableFuture.<em class="ke">runAsync(() </em>-&gt; downstreamCall<em class="ke">())</em>, CompletableFuture.<em class="ke">runAsync(() </em>-&gt; downstreamCall2<em class="ke">())<br/>  </em>.map<em class="ke">(</em>future -&gt; {<br/>    try <em class="ke">{<br/>      </em>return future.get<em class="ke">()</em>;<br/>    <em class="ke">} </em>catch <em class="ke">(</em>Exception e<em class="ke">) {<br/>      </em>e.printStackTrace<em class="ke">()</em>;<br/>   <em class="ke">}<br/>   </em>return null;<br/><em class="ke">})</em>.collect<em class="ke">(</em>Collectors.<em class="ke">toList())</em>;</span></pre><p id="762c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">假设我们有多个下游调用(比如对数据库或API的调用)，我们希望这些调用同时发生。在这个例子中，我们创建了那些<em class="ke">期货</em>的流，当下游调用的响应可用时，它将被填充。然后我们在<code class="du mu mv mw mm b">future.get()</code>调用中“打开”这些值，并将它们收集到我们想要的实际对象列表中。</p><p id="4fc5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">将反应流想象成包含未来的<strong class="jk hi"> <em class="ke"> Java流API流通常是有帮助的。</em> </strong>在其他编程语言中，这些被称为“承诺”本质上，您有一个尚未出现的项目流，一旦它们出现，您就可以对它们执行一些逻辑。</p><h2 id="a09f" class="lx kh hh bd ki ly lz ma km mb mc md kq jr me mf ks jv mg mh ku jz mi mj kw mk bi translated">与Java未来流的类比到此结束…</h2><p id="5bd1" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">既然我们已经拼凑出了反应流与未来对象的Java流API流是如何相似的，那么让我们来看看它们的不同之处。首先，一些好消息。实际上，使用反应式流并对其执行操作比使用未来的Java流API流要容易得多。我们有许多方便的函数，除了发送延迟错误甚至空的未来值之外，还允许我们“解开”反应流中的未来。所以基本上，有更多的功能<em class="ke">来处理反应流的异步数据，并且接口更简单。</em></p><p id="fa20" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">但是有一点坏消息。Java流API流和反应流有一些相似命名的函数…但是它们做不同的事情。下一节试图澄清这个最令人困惑的例子，关于<em class="ke">映射</em>、<em class="ke">平面映射</em>和<em class="ke">平面映射许多</em>函数。</p><h2 id="7138" class="lx kh hh bd ki ly lz ma km mb mc md kq jr me mf ks jv mg mh ku jz mi mj kw mk bi translated">关于地图、平面地图和平面地图的困惑</h2><p id="4b38" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">当我第一次遇到Webflux flatmap命令时，我对它可能做的事情有一些期望。事实证明，这些预期是不正确的。</p><p id="c8a7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我以前在Java流的上下文中使用过flatMap。在该上下文中，flatmap接受一个元素流，并返回一个新的元素流，每个源元素有零个或多个元素的映射。例如，如果你有一个整数流，你想返回一个原始整数流和它们乘以2的值，你可以这样写:</p><pre class="ix iy iz ja fd ml mm mn mo aw mp bi"><span id="fba6" class="lx kh hh mm b fi mq mr l ms mt">Stream.<em class="ke">of(</em>1,2,3<em class="ke">)<br/>  </em>.flatMap<em class="ke">(</em>i -&gt; Stream.<em class="ke">of(</em>i, i*2<em class="ke">))<br/>  </em>.collect<em class="ke">(</em>Collectors.<em class="ke">toList())</em>;</span></pre><p id="9527" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">注意，在<code class="du mu mv mw mm b">flatMap()</code>函数中，我们返回一个新的流，其中元素和元素的乘积为2，然后我们收集所有的元素，因此输出列表包含值[1，2，2，4，3，6]。FlatMap负责将所有创建的流合并成一个新的流。</p><p id="80b5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因此，我期望WebFlux flatMap接受一个“承诺流”(单声道)，并返回一个承诺流流(流量)。但这不是它的作用。<strong class="jk hi"> FlatMap实际上返回一个流，其中每个同步元素都被转换为异步元素。</strong>在上面使用Java流的例子中，应用于每个元素的操作只是将它乘以2，这是同步的。但是假设您有一个元素列表，并且您想要对每个元素应用阻塞操作。例如，您有一个员工ID，您想调用数据库来获取每个ID的员工姓名。那么你可能会这样写:</p><p id="b01d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这种情况下，我们不是为每个输入元素返回多个输出元素，而是为每个输入元素返回一个异步输出元素。这样，我们就把输入转换成了异步输出。记住这个例子，让我们更深入地研究Java流和Reactive中Map、flatMap和flatMapMany之间的区别，然后我们将在Java流和Reactive流之间所有可用选项的上下文中重新审视这个例子。</p><h2 id="2a67" class="lx kh hh bd ki ly lz ma km mb mc md kq jr me mf ks jv mg mh ku jz mi mj kw mk bi translated">比较JavaStreams、Mono和Flux中的Map、flatMap和flatMapMany</h2><p id="1b45" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">在下表中，SE代表同步元素(与包含异步元素的Mono或Flux相比)。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mx"><img src="../Images/b23244043d7404382055348225477ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnK2AhAvfl6SZjF5GNeXyA.png"/></div></div></figure><p id="9fbf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">请注意，Java Streams API的Map和flatMap之间的差异<strong class="jk hi">与反应式Streams API的Map和flatMap之间的差异</strong>不同。这是我最初感到困惑的地方。</p><h2 id="9fcc" class="lx kh hh bd ki ly lz ma km mb mc md kq jr me mf ks jv mg mh ku jz mi mj kw mk bi translated"><strong class="ak">地图对平面对多——意义取决于上下文</strong></h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es my"><img src="../Images/0c8cdcae88ed98ed76a209192919afec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lYOVChWst72XPsE0PQWWw.png"/></div></div></figure><p id="346a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">需要理解的关键是，Java流的“flatMap”中的“flat”意味着您正在“展平”由函数创建的一堆流。然而,“flatMap”中用于反应流的“flat”意味着您正在将同步元素转换为异步元素。你会注意到，反应式“平面图”中的“平面”与扁平化没有任何关系，依我拙见，这是令人困惑的。</p><p id="6a5e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们用一个例子来帮助完整地说明在不同的情况下使用哪个Map命令。</p><ul class=""><li id="3217" class="li lj hh jk b jl jm jo jp jr lk jv ll jz lm kd ln lo lp lq bi translated"><strong class="jk hi">小写雇员姓名:</strong>对于每个雇员，我们以小写返回雇员姓名。这没有下游/阻塞调用。在这种情况下，假设我们有一个雇员姓名列表，我们应该使用Java Streams Map函数将雇员姓名列表转换为小写值。在这种情况下不需要反应！</li><li id="3b7b" class="li lj hh jk b jl lr jo ls jr lt jv lu jz lv kd ln lo lp lq bi translated"><strong class="jk hi">从雇员ID中获取雇员姓名(数据库调用):</strong>对于每个雇员，我们在数据库中查找雇员并获取他们对应的部门ID。在这种情况下，如果我们有一个雇员，我们将使用Reactive Streams Mono flatMap，因为我们希望将我们的雇员id转换为带有雇员姓名的异步Mono。如果我们在一个流中有多个雇员id，我们也将使用flatMap，输出也将是一个流。</li><li id="e147" class="li lj hh jk b jl lr jo ls jr lt jv lu jz lv kd ln lo lp lq bi translated"><strong class="jk hi">通过员工ID获取员工队友的姓名(数据库调用):</strong>对于每个员工，我们在数据库中查找该员工的队友。如果我们在Mono中有一个雇员ID，我们将使用flatMapMany，因为我们希望得到一个Flux(队友名字的多个“承诺”)。如果我们有多个不断变化的员工id，我们将使用flatMap来获得队友名字的“承诺”。</li></ul><h1 id="df49" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">挑战3:使用Reactive重写我的应用程序的最好方法是什么？</h1><p id="5d10" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">如果您有一个现有的命令式应用程序，那么在reactive中重写所有内容可能会令人望而生畏。好消息是，你可以使用一些策略，这样你就可以在你的应用程序中增加反应行为。在迁移我们的应用程序时，我们发现最好的方法是从后到前进行工作——从调用下游APIs数据库开始，然后向客户端响应前进。这种方法使我们更容易定义初始Mono和Flux，然后不断重构调用函数以接受Mono/Flux响应。</p><p id="0149" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从后到前的重构还允许您增量地转换部分代码以使用Reactive。例如，如果您有五个对数据库或API的下游调用，您可以一次调用一个。如果您将其余的下游调用保留为命令性的，代码仍然会编译并运行良好，只是您不会完全被动。</p><p id="3a30" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一旦您准备好部署应用程序，您将希望确认一切都按预期运行。显然，修复单元和组件测试是这个过程的一部分。但是，您还应该考虑安全部署到生产环境的计划。我建议使用一个<a class="ae kf" href="https://martinfowler.com/bliki/CanaryRelease.html" rel="noopener ugc nofollow" target="_blank"> <em class="ke">金丝雀部署</em> </a>或其他一些增量部署策略，以避免在出现错误时产生广泛的影响。对不同部署选项的全面讨论超出了本文的范围，但是生产部署是该过程中的一个关键步骤，并且考虑到重新编写应用程序以使用Reactive所需要的更改程度，我强烈建议考虑一下您计划如何去做。</p><h1 id="9adb" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">挑战4:错误处理在Reactive中是如何工作的？</h1><p id="a9fb" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">在传统的命令式应用程序中，使用try catch块处理错误，如下所示:</p><pre class="ix iy iz ja fd ml mm mn mo aw mp bi"><span id="a164" class="lx kh hh mm b fi mq mr l ms mt">try <em class="ke">{<br/>  </em>Response response = downstreamApi.execute<em class="ke">(</em>request<em class="ke">)</em>;<br/><em class="ke">} </em>catch <em class="ke">(</em>TimeoutException e<em class="ke">)  {<br/>  log</em>.info<em class="ke">(</em>"Timeout occurred"<em class="ke">)</em>;<br/><em class="ke">}</em></span></pre><p id="c3cf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，当使用Reactive时，您是在使用异步数据，或者未来数据的“承诺”。错误也不例外(没有双关语)，这些错误也可以异步处理。</p><p id="b3fd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">考虑使用反应式的相应实现:</p><pre class="ix iy iz ja fd ml mm mn mo aw mp bi"><span id="95cc" class="lx kh hh mm b fi mq mr l ms mt">public Mono<em class="ke">&lt;</em>Response<em class="ke">&gt; </em>downstreamAPICall<em class="ke">(</em>Request request<em class="ke">) {<br/>  </em>return webClient<br/>    .post<em class="ke">()<br/>    </em>.uri<em class="ke">(</em>this.downstreamURI<em class="ke">)<br/>    </em>.bodyValue<em class="ke">(</em>request)<br/>    .header<em class="ke">(</em>"Client-Correlation-Id", "my correlation id"<em class="ke">)<br/>    </em>.retrieve<em class="ke">()<br/>    </em>.bodyToMono<em class="ke">(</em>Response`.class<em class="ke">)</em>;<br/><em class="ke">}</em></span><span id="6d6f" class="lx kh hh mm b fi mz mr l ms mt">public Mono<em class="ke">&lt;</em>ProcessedResponse<em class="ke">&gt; </em>processResponse<em class="ke">() {<br/>  </em>downstreamApiCall<em class="ke">(</em>request<em class="ke">)</em>.map<em class="ke">(</em>response -&gt; <em class="ke">{<br/>    </em>//process response<br/>  }<em class="ke">)<br/></em>}</span></pre><p id="6391" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果对downstreamAPICall的调用失败或超时，异常将不会被抛出，直到它到达processResponse中的map函数。换句话说，异常直到在map调用中被“解包”后才会被抛出。</p><h2 id="1323" class="lx kh hh bd ki ly lz ma km mb mc md kq jr me mf ks jv mg mh ku jz mi mj kw mk bi translated">错误处理</h2><p id="d985" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">要处理Reactive中的错误，您需要使用onError*调用之一:</p><ul class=""><li id="9e79" class="li lj hh jk b jl jm jo jp jr lk jv ll jz lm kd ln lo lp lq bi translated"><strong class="jk hi"> onErrorResume: </strong>接受一个函数，该函数在出错时返回一个新的无功流(单声道或通量)。您可以调用另一个后备服务器并返回该反应流。</li><li id="6c8e" class="li lj hh jk b jl lr jo ls jr lt jv lu jz lv kd ln lo lp lq bi translated"><strong class="jk hi"> onErrorMap: </strong>接受返回同步元素的函数；该功能在异常情况下执行。</li><li id="7ce8" class="li lj hh jk b jl lr jo ls jr lt jv lu jz lv kd ln lo lp lq bi translated"><strong class="jk hi"> onErrorReturn: </strong>接受在异常发生时返回的同步元素。这是出错时的“默认”元素。</li></ul><p id="ed37" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">举一个例子:</p><pre class="ix iy iz ja fd ml mm mn mo aw mp bi"><span id="eca9" class="lx kh hh mm b fi mq mr l ms mt">public Mono processResponse() {<br/>  downstreamApiCall(request).map(response -&gt; {<br/>   //process response<br/>  })<br/>}<br/> <br/>//some other function...<br/>processResponse().onErrorResume(e -&gt; {<br/>   log.error("Call to Downstream API failed: {}", e.toString());<br/>   return Mono.empty();<br/>  });<br/>}</span></pre><p id="fcc5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这种情况下，我们简单地记录错误并返回一个<code class="du mu mv mw mm b">Mono.empty()</code>，当上游调用者打开单声道流中的项目时，它基本上被跳过。</p><h2 id="781c" class="lx kh hh bd ki ly lz ma km mb mc md kq jr me mf ks jv mg mh ku jz mi mj kw mk bi translated">零处理</h2><p id="27ae" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">前面的例子也是我的团队在重写应用程序时遇到的一个常见情况的解决方案。我们有几个调用下游API的例子，如果失败，我们会记录异常并返回null。然后，在调用函数中，我们会有一个过滤掉这些空响应的if语句。上面的代码片段使用了<code class="du mu mv mw mm b">Mono.empty()</code>而不是null，允许您通过删除这些检查null值的if语句来简化代码。</p><h1 id="8e85" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">收获和影响</h1><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es na"><img src="../Images/eab7613e5db6bf87fdb4e1c8bae324a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zukT4BMeDlyr4WQ_"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx"><em class="nb">This figure shows a comparison of the number of active threads between the Reactive (Rx) and Non-Reactive (NonRx) implementation of the API as we increase the number of concurrent requests. We found that the Reactive implementation uses far fewer threads, with the caveat that the thread pool size may be providing a hard upper limit in these cases.</em></figcaption></figure><p id="572e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">最后，我们成功地将Spring应用程序迁移到使用WebFlux，并想看看这给我们带来了什么好处。为了评估性能，我们对最初的命令式版本和新的反应式版本应用了一些模拟几十个并发用户的性能测试。然后，我们测量了线程数和响应时间。</p><p id="1dd8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们发现两个版本的响应时间基本相同，但是反应式版本的线程数要低得多。Reactive版本中较低的线程数量符合我们的预期，因为Reactive以非阻塞的方式有效地重用了线程。然而，您在内存、运行时或任何其他指标方面观察到的实际好处将高度依赖于您的应用程序、它的负载以及它正在进行的下游调用的数量和类型。</p><p id="dfdb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在将一个新的应用程序实现到Reactive或者迁移一个现有的应用程序之前，我强烈建议仔细看看您的应用程序是否适合Reactive范例。上面挑战1部分中的表格可以对此有所帮助。如果您正在迁移现有的应用程序，我也建议您制定一个计划，在它准备好之后如何安全地将您的流量迁移到反应版本，因为如果操作不当，这可能是一个有风险的过程。</p><p id="f74e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">考虑到这些因素，我认为反应式编程对于许多应用程序来说有着重要的前景，但是对于所有工具来说，它都是关于学习如何有效地使用它，并确保您使用正确的工具来完成手头的任务。</p></div><div class="ab cl nc nd go ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ha hb hc hd he"><p id="f045" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">披露声明:2021首创一号。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p><p id="3d77" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">最初发表于</em><a class="ae kf" href="https://www.capitalone.com/tech/software-engineering/migrating-java-apps-to-reactive/" rel="noopener ugc nofollow" target="_blank"><em class="ke">【https://www.capitalone.com】</em></a><em class="ke">。</em></p></div></div>    
</body>
</html>