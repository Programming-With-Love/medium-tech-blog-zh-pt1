<html>
<head>
<title>Abstractive Text Summarization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抽象文本摘要</h1>
<blockquote>原文：<a href="https://medium.com/globant/abstractive-text-summarization-bccb4bf5851c?source=collection_archive---------0-----------------------#2022-08-18">https://medium.com/globant/abstractive-text-summarization-bccb4bf5851c?source=collection_archive---------0-----------------------#2022-08-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/246e80459e39c547c7073a4a223de57d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HfVyrJL2qkKG82uG"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@gulfergin_01?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gülfer ERGİN</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cbb9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有两种主要的方法来自动概括文本——抽象的和摘录的。它们之间的主要区别是如何从文档中提取信息以及如何生成摘要。我试图解释这篇文章中的摘要</p><p id="340b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇文章中，我们将讨论抽象概括。这种方法试图重写和重构原始文档中的文本，这更类似于人类编写摘要的方式。</p><p id="28fd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">抽象摘要集中于原始文本中最关键的信息，并为摘要创建一组新的句子。这项技术需要识别关键部分，解释上下文，并以新的方式重新创建它们。由于从文档中提取相关信息以及自动生成连贯文本的困难，抽象摘要被认为是一个比抽取摘要更复杂的问题。抽象概括方法与深度学习模型如seq2seq模型、LSTM等一起工作良好。，以及流行的Python包(Spacy、NLTK等。)和框架(Tensorflow，Keras)</p><h2 id="549e" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">做抽象总结的方法</h2><p id="1a00" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">那么现在当我们知道什么是抽象概括的时候，怎么做呢？做抽象概括有各种各样的方法，事实上，有许多方法的引用。但是我们不会在这里提到所有这些，因为如果我们这样做，那么这篇文章本身就需要一个总结！！😜</p><p id="232d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们使用了<strong class="iw hi"> HuggingFace的变形金刚</strong>库来进行抽象概括。Transformers为我们提供了数以千计的预训练模型，可用于文本摘要以及各种各样的NLP任务，如文本分类、问答、翻译、语音识别、光学字符识别等。</p><h2 id="68eb" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">什么是变形金刚？</h2><p id="d134" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">这个名字让我们想起了著名的科幻电影《变形金刚》,但不幸的是，在这里我们看不到任何一个酷酷的机器人在变形🤖。尽管我们在这里会看到一个转变，不是机器人的转变，而是我们想要生成摘要的所有那些冗长的文本或文档的转变。</p><p id="3669" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Huggingface Transformers是一个非常受欢迎的库，其中包含了在过去几年中彻底改变了NLP的预训练模型。这些模型在ML社区获得了广泛的关注。预训练意味着这些模型以自我监督的方式在一些数据集(大量原始文本)上进行训练。在这种训练中，目标是根据模型的输入自动计算的。</p><h2 id="ec87" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">总结过程</h2><p id="1732" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">使用变形金刚库进行总结的最简单的方法是使用现有总结模型的“<strong class="iw hi">总结</strong> <strong class="iw hi">管道</strong>”。我们可以从transformers导入管道，并提供一个"<strong class="iw hi">summary "</strong>task<strong class="iw hi"/>作为管道的字符串参数。由于我们没有指定任何模型，管道将使用默认模型<a class="ae it" href="https://huggingface.co/sshleifer/distilbart-cnn-12-6" rel="noopener ugc nofollow" target="_blank">sshleifer/distilbart-CNN-12–6</a>。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ks"><img src="../Images/38b63408dab9b847d3c53ed173149a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3MHvTO2qDJqQcNLG6p_B0w.png"/></div></div></figure><p id="ed5f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码中，Pipeline是一个简单的API，它抽象了生成摘要的大部分复杂代码，并且只接受一个参数，这是一个定义返回的管道的任务。在上面的例子中，我们使用了一个“<strong class="iw hi">summary”</strong>任务，它将返回一个SummarizationPipeline。</p><p id="5fc4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">使用训练好的模型</strong></p><p id="1d13" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将使用谷歌的《变形金刚》T5 模型和它的分词器。根据《变形金刚》的官方文档，“T5是一个编码器-解码器模型，在非监督和监督任务的多任务混合上进行预训练，每个任务都转换为文本到文本的格式。”</p><p id="a4c2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">完全理解，对！！！😄。</p><p id="4498" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简单地说，这是一个文本到文本的转换程序，所有的NLP任务都被重新组织成一个统一的文本到文本的格式，输入和输出都是文本串。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kx"><img src="../Images/c2db709c08dcdd5a9bc0daaf32835bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*60g54I1mCfKKYv3wTgfq8A.gif"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">source: <a class="ae it" href="https://ai.googleblog.com/2020/02/exploring-transfer-learning-with-t5.html" rel="noopener ugc nofollow" target="_blank">Google AI Blog</a></figcaption></figure><p id="73e1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是使用T5ForConditionalGeneration模型生成摘要的过程-</p><ul class=""><li id="afbb" class="ky kz hh iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">首先，我们将导入模型和标记器，然后初始化模型架构和权重，然后初始化标记器。</li></ul><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lh"><img src="../Images/208510a80b66e79a7f25dbf9206a7da3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aHHKvJOQRK9MGSJJOfilxQ.png"/></div></div></figure><p id="b8c5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码中，我们使用了<code class="du li lj lk ll b"><strong class="iw hi">from_pretrained()</strong></code> <strong class="iw hi"> </strong>方法来加载预先训练好的<strong class="iw hi"> t5-base </strong>模型。t5型号有不同的尺寸，例如-t5小型、T5底座、T5大型、T5–3b和t511b。这些模型在训练数据集的大小和生成的摘要的准确性方面有所不同。</p><p id="c41b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们还初始化了一个标记器。标记化器对于将文本转换成模型可以处理的数据非常重要。模型只理解和处理数字，因此记号赋予器将提供的输入转换成数字数据。</p><p id="e3f5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们第一次执行这段代码时，会花费很多时间，因为t5-base模型将与其权重(词汇)和配置一起下载。</p><ul class=""><li id="9231" class="ky kz hh iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">然后，我们创建一个变量来存储输入文本，并使用上面创建的标记器将文本编码为标记。</li></ul><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lm"><img src="../Images/60652fc81242b8a3c0f245174a3cccae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOExqXfhqZ9IRmAB_UpEww.png"/></div></div></figure><p id="a0ad" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码中，我们使用了<code class="du li lj lk ll b"><strong class="iw hi">encode()</strong></code> <strong class="iw hi"> </strong>方法，并传递了以下参数-</p><ul class=""><li id="9cf3" class="ky kz hh iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated"><strong class="iw hi"> return_tensors: </strong>如果设置，将返回张量而不是python整数列表。我们还可以用<strong class="iw hi">【TF】</strong>表示tensor flow<strong class="iw hi"/><strong class="iw hi">pt "</strong>表示PyTorch，<strong class="iw hi">【NP】</strong>表示Numpy。</li><li id="966f" class="ky kz hh iw b ix ln jb lo jf lp jj lq jn lr jr ld le lf lg bi translated"><strong class="iw hi"> max_length: </strong>控制截断/填充参数之一使用的最大长度。</li><li id="6688" class="ky kz hh iw b ix ln jb lo jf lp jj lq jn lr jr ld le lf lg bi translated"><strong class="iw hi">截断:</strong>激活并控制截断。</li></ul><p id="67db" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">max_length和truncation参数一起表示我们不希望原始文本绕过512个标记，这是Transformers中为标记化设置的默认限制。</p><p id="c712" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后一步是使用<code class="du li lj lk ll b"><strong class="iw hi">model.generate()</strong></code> <strong class="iw hi"> </strong>方法生成汇总输出。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ls"><img src="../Images/9e9181ea1331bc6d916906f262e692fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Vovw58jVa_iuZ_O_URBHw.png"/></div></div></figure><p id="7e88" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">输出</strong></p><p id="3fe5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">“垃圾食品是市场上发现的袋装油炸食品。它热量高，胆固醇高，健康营养成分低，钠矿物质低，糖、淀粉、不健康脂肪高，缺乏膳食纤维。”</p><h2 id="b37a" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">限制</h2><p id="4927" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">尽管上面提到的过程生成了一篇长文章的良好转换的摘要，但是这个过程有一些限制。</p><ul class=""><li id="617d" class="ky kz hh iw b ix iy jb jc jf la jj lb jn lc jr ld le lf lg bi translated">如果输入文本太长，并且标记化过程超过了默认设置的512个标记的限制，那么我们就无法控制生成的摘要的输出。改变<code class="du li lj lk ll b"><strong class="iw hi">model.generate()</strong></code> <strong class="iw hi"> </strong>方法中的参数值，对生成的输出没有任何影响。</li><li id="ff04" class="ky kz hh iw b ix ln jb lo jf lp jj lq jn lr jr ld le lf lg bi translated">所以我们不能用这个来概括一个很长的文档。即使我们想这样做，我们也需要将内容分成块，并创建这些块的摘要。最后，我们将它们结合起来，创建一个完整的输入摘要。这将使该过程成为一项乏味的任务。</li><li id="3f98" class="ky kz hh iw b ix ln jb lo jf lp jj lq jn lr jr ld le lf lg bi translated">并且由于抽象摘要不仅仅提取已经存在的句子，而是使用训练的模型生成它自己的句子，所以有时生成的摘要包含那些与所提供的输入的上下文不匹配的单词。发生这种情况是因为模型在数据集上进行了训练。</li></ul><p id="9bb1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可以使用定制数据集来重新训练预先训练的模型，但是训练模型在所使用的存储器、处理能力、处理时间等方面是非常昂贵的。我们需要非常强大的GPU。虽然在云上有解决方案，但是这些也涉及到巨大的成本。</p><h2 id="fc41" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">结论</h2><p id="35b7" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">这些提取和抽象的总结文章包括总结任何文本所需的所有基础知识。虽然这些不是总结文本的唯一方法，但它们肯定有助于在不损失信息质量的情况下创建冗长文本的摘要。在这个快节奏的世界里，这有助于节省时间。</p><h2 id="1912" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">参考</h2><ul class=""><li id="7ea2" class="ky kz hh iw b ix kn jb ko jf lt jj lu jn lv jr ld le lf lg bi translated"><a class="ae it" href="https://huggingface.co/docs/transformers/index" rel="noopener ugc nofollow" target="_blank">https://huggingface.co/docs/transformers/index</a></li><li id="39f4" class="ky kz hh iw b ix ln jb lo jf lp jj lq jn lr jr ld le lf lg bi translated">https://huggingface.co/blog/how-to-generate<a class="ae it" href="https://huggingface.co/blog/how-to-generate" rel="noopener ugc nofollow" target="_blank"/></li><li id="2cda" class="ky kz hh iw b ix ln jb lo jf lp jj lq jn lr jr ld le lf lg bi translated"><a class="ae it" href="https://www.thepythoncode.com/article/text-summarization-using-huggingface-transformers-python" rel="noopener ugc nofollow" target="_blank">https://www . thepythoncode . com/article/text-summarying-using-hugging face-transformers-python</a></li></ul></div></div>    
</body>
</html>