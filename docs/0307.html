<html>
<head>
<title>Large Database Queries on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上的大型数据库查询</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/large-database-queries-on-android-cb043ae626e8?source=collection_archive---------2-----------------------#2017-09-15">https://medium.com/androiddevelopers/large-database-queries-on-android-cb043ae626e8?source=collection_archive---------2-----------------------#2017-09-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/8785b6b784c953e7ffa056f8e380fca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZPvyH9YGMikVGV-AQCI2Dg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Photo by <a class="ae hu" href="https://unsplash.com/photos/XOW1WqrWNKg" rel="noopener ugc nofollow" target="_blank">Anastasia Zhenina on Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="b2f3" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">机会之窗</h2></div><p id="26a7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">SQLite是在Android上持久化成千上万项数据的一种很好的方式，但是在UI中呈现这些巨大的数据集一直很困难，并且可能导致性能问题。在启动新的<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/paging.html" rel="noopener ugc nofollow" target="_blank">分页库</a>之前，我们研究了平台中现有的分页方法，尤其是SQLiteCursor中的潜在缺陷。</p><p id="cecb" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这篇博文中，我们将回顾它的问题，以及为什么它会促使我们在<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/index.html" rel="noopener ugc nofollow" target="_blank"> Android架构组件</a>中对<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/room.html" rel="noopener ugc nofollow" target="_blank">房间持久化</a>和<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/paging.html" rel="noopener ugc nofollow" target="_blank">分页</a>库使用小查询。</p><h1 id="4d4c" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">SQLiteCursor和CursorAdapter</h1><p id="302b" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated"><a class="ae hu" href="https://developer.android.com/reference/android/database/sqlite/SQLiteCursor.html" rel="noopener ugc nofollow" target="_blank"> SQLiteCursor </a>是Android SQLite数据库查询的返回类型。它允许您以固定的初始加载成本查看大型查询结果。<br/>第一次读取初始化一个<a class="ae hu" href="https://developer.android.com/reference/android/database/CursorWindow.html" rel="noopener ugc nofollow" target="_blank"> CursorWindow </a>，一个通常为2MB大小的行缓冲区，包含来自数据库的内容。每当您请求一个不存在的行时，SQLiteCursor都会刷新此窗口。这样，SQLiteCursor就实现了分页，具有固定的页面大小。</p><p id="5a33" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><a class="ae hu" href="https://developer.android.com/reference/android/widget/CursorAdapter.html" rel="noopener ugc nofollow" target="_blank"> CursorAdapter </a>从Android API 1开始就存在了，它提供了一种简单的方法将数据从游标(通常是SQLiteCursor)绑定到ListView中的项目。虽然它很好地完成了这个功能，但它在任何需要新加载的时候都会直接在UI线程上查询数据库。这本身对于一个现代的、反应灵敏的应用程序来说是不可接受的。所以有人可能会问:难道我们不能有一个基于光标的适配器，在后台线程上加载吗？毕竟，SQLiteCursor内置了分页功能。</p><h1 id="4846" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">SQLiteCursor中的分页问题</h1><p id="4946" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">SQLiteCursor中分页的大部分问题来自于它使用窗口将内容分页时令人惊讶的行为。以下是我们在为<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/paging.html" rel="noopener ugc nofollow" target="_blank">分页库</a>试验SQLiteCursor的内部分页时发现的挑战列表:</p><h2 id="7a28" class="lf kj hx bd kk lg lh li ko lj lk ll ks jv lm ln ku jz lo lp kw kd lq lr ky ls bi translated"><strong class="ak"> SQLiteCursor没有保持任何数据库事务打开</strong></h2><p id="1f1e" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">当我开始研究分页时，我对SQLite没有经验，尤其是Android上的游标。我只是假设SQLiteCursor会在加载一个窗口后暂停查询，并在需要下一个窗口时继续。这样，访问第10个窗口将和第1个窗口一样有效。<strong class="jo hy">这个不正确</strong>。每次读取新窗口时，查询从位置0重新开始，并跳过填充窗口不需要的行，一次一行。这是因为<strong class="jo hy"> SQLiteCursor不能恢复查询</strong>。</p><p id="d94a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这就像访问链表中的1000到1050项一样——你必须跳过大量的项才能访问下一个要加载的页面。加载时，每个后续窗口都必须跳过越来越多的查询，这会降低速度。这相当于使用SQL <code class="du lt lu lv lw b">OFFSET</code>关键字来跳过内容，这<a class="ae hu" href="http://www.sqlite.org/cvstrac/wiki?p=ScrollingCursor" rel="noopener ugc nofollow" target="_blank">不是分页内容</a>的最有效方式，但是当依赖于SQLiteCursor中的分页时，这是无法避免的。您可以在这里看到SQLiteCursor如何在新窗口<a class="ae hu" href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/jni/android_database_SQLiteConnection.cpp#695" rel="noopener ugc nofollow" target="_blank">中翻页。</a></p><h2 id="a076" class="lf kj hx bd kk lg lh li ko lj lk ll ks jv lm ln ku jz lo lp kw kd lq lr ky ls bi translated"><strong class="ak"> SQLiteCursor.getCount()是必需的，并且扫描整个查询</strong></h2><p id="8db7" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">在读取第一行之前，SQLiteCursor调用<code class="du lt lu lv lw b">getCount()</code>进行边界检查。由于<strong class="jo hy"> SQLite必须扫描查询的整个结果集才能计数</strong>(同样，像链表一样)，这可能会增加大量开销。如果您为了响应用户滚动而将一个大型查询逐渐分页到一个UI中，您可能不需要知道查询的整体大小，因此计数会增加不必要的前期工作。</p><h2 id="7e11" class="lf kj hx bd kk lg lh li ko lj lk ll ks jv lm ln ku jz lo lp kw kd lq lr ky ls bi translated"><strong class="ak"> SQLiteCursor.getCount()总是加载行的第一个窗口</strong></h2><p id="4842" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">作为计算计数的一部分，在扫描结果集时，SQLiteCursor从位置0开始主动填充其窗口，并假设将需要查询中的第一个项目。</p><p id="9c85" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">它预先加载了这些项，这样它就可以提前大致知道一个窗口可以容纳多少行(下面将详细介绍)。如果您从查询的开始呈现数据，这种机会加载是合理的，但是从保存的实例状态恢复的位置可能会在列表的更下方开始索引，其中初始窗口是不相关的。如果您想从第三个内容窗口呈现数据，您必须先加载并丢弃2MB的数据。这个计数行为的代码在这里是<a class="ae hu" href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/java/android/database/sqlite/SQLiteCursor.java#130" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="20a9" class="lf kj hx bd kk lg lh li ko lj lk ll ks jv lm ln ku jz lo lp kw kd lq lr ky ls bi translated"><strong class="ak"> SQLiteCursor可能会加载您没有要求的数据</strong></h2><p id="80ec" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated"><code class="du lt lu lv lw b"><a class="ae hu" href="https://developer.android.com/reference/android/database/Cursor.html#moveToPosition(int)" rel="noopener ugc nofollow" target="_blank">Cursor.moveToPosition()</a></code>保证被请求的行在窗口中，但是<strong class="jo hy"> SQLiteCursor没有在被请求的行</strong>开始填充。因为SQLiteCursor并不假设应用程序正在向前读取，所以当它距离目标位置大约一个窗口的⅓时，它就开始填充它的窗口。这意味着一个CursorAdapter在一次窗口加载后向后滚动几行不会触发另一次窗口加载。这也意味着，在第一次加载之后，每加载2MB的数据会加载650KB或更多的数据，您已经看到了。你可以在这里看到这个行为<a class="ae hu" href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/java/android/database/DatabaseUtils.java#742" rel="noopener ugc nofollow" target="_blank">的代码和解释。</a></p><h2 id="b81a" class="lf kj hx bd kk lg lh li ko lj lk ll ks jv lm ln ku jz lo lp kw kd lq lr ky ls bi translated"><strong class="ak"> SQLiteCursor加载位置不可预测</strong></h2><p id="44ee" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">当SQLiteCursor试图加载一个目标位置时，它试图提前启动一个窗口的⅓。这意味着它必须猜测一个窗口中有多少行。为此，它使用第一次窗口加载时填充的行数。不幸的是，这意味着如果您的行大小不同(例如，如果您嵌入任意长度的用户注释字符串)，它的猜测可能是错误的。<strong class="jo hy"> SQLiteCursor可以低于目标位置</strong>，用内容填充一个窗口——然后丢弃所有内容，并重新开始填充。例如，如果您正在扫描一个长查询，并到达一个需要重新加载窗口的行，那么加载可能只会捕获少量的新行。这里的清除窗口和重启代码是<a class="ae hu" href="https://android.googlesource.com/platform/frameworks/base/+/fee4546fd648b519ad828ea1f950554c1054699d/core/jni/android_database_SQLiteConnection.cpp#709" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="ba61" class="lf kj hx bd kk lg lh li ko lj lk ll ks jv lm ln ku jz lo lp kw kd lq lr ky ls bi translated"><strong class="ak">光标需要关闭</strong></h2><p id="1f88" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">必须使用<code class="du lt lu lv lw b"><a class="ae hu" href="https://developer.android.com/reference/android/database/Cursor.html#close()" rel="noopener ugc nofollow" target="_blank">close()</a></code>方法关闭游标，所以不管它们存储在哪里，都必须有代码在不再需要时清理它们。CursorAdapter显然在这方面没有帮助，它把责任推给了应用程序开发人员。存储和重用游标需要开发人员编写代码来处理像活动停止这样的事件。</p><h2 id="f1af" class="lf kj hx bd kk lg lh li ko lj lk ll ks jv lm ln ku jz lo lp kw kd lq lr ky ls bi translated"><strong class="ak"> SQLiteCursor不知道数据已经改变</strong></h2><p id="8c3f" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated"><strong class="jo hy">在第一次窗口读取</strong>(和第一次计数)后，SQLiteCursor不会跟踪数据库是否发生了变化。这意味着，如果添加或删除了某些项，SQLiteCursor的缓存大小是不正确的——这对于边界检查和希望加载的数据看起来一致来说都是一个问题。这可能会在移动到不再存在的行时导致异常，或者在某些情况下导致数据不一致。例如，如果您已经加载了第N行，并且在位置0插入了一个新项，然后您试图读取第N+1行，您将再次加载旧的第N行。</p><h1 id="ae84" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">回避问题</h1><p id="0e4a" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">上述问题告诉我们，SQLCursor不能扩展到有成千上万个结果的查询。幸运的是，这些问题都有一个简单的解决方法:小查询。适合单个CursorWindow的查询避免了所有的问题，这就是为什么我们在分页和空间中如此强烈地支持它们。通常只配置十到二十个条目的页面大小，并且一次只查询那么多条目。</p><p id="4524" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">不过，选择页面大小有很多因素——最大到一个窗口的较大查询通常会提高性能，较小的查询会提高延迟和内存。10个条目对于数据库不是瓶颈的高列表条目来说可能是有意义的，而如果列表条目很小或者查询很昂贵，那么300个条目可能会更好。</p><p id="b721" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果您依赖SQLiteCursor的内部分页来延迟加载大量结果，我们建议您切换到另一种方法。要么使用新的<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/paging.html" rel="noopener ugc nofollow" target="_blank">分页库</a>及其与<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/room.html" rel="noopener ugc nofollow" target="_blank"> Room Persistence库</a>的集成，要么使用自定义实现，您自己处理分页，并确保您的查询结果足够小，可以放在单个CursorWindow中。</p><p id="05ff" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">要使用新的分页库对大型SQL查询结果和小型查询进行分页，您可以更改:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="5297" class="lf kj hx lw b fi mf mg l mh mi">@Dao<br/>interface UserDao {<br/>    // regular list query — falls over with too much data<br/>    @Query(“SELECT * FROM user ORDER BY age DESC”)<br/>    <strong class="lw hy">LiveData&lt;List&lt;User&gt;&gt;</strong> loadUsersByAgeDesc();<br/>}</span></pre><p id="0a48" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">变成:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="62ba" class="lf kj hx lw b fi mf mg l mh mi">@Dao<br/>interface UserDao {<br/>    // paged query — handles arbitrarily large queries<br/>    @Query(“SELECT * FROM user ORDER BY age DESC”)<br/>    <strong class="lw hy">DataSource.Factory&lt;Integer, User&gt;</strong> loadUsersByAgeDesc();<br/>}</span></pre><p id="fc75" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">然后将它传递给一个<code class="du lt lu lv lw b"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/livedata.html" rel="noopener ugc nofollow" target="_blank">LivePagedListBuilde</a>r</code>以得到一个<code class="du lt lu lv lw b"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/livedata.html" rel="noopener ugc nofollow" target="_blank">LiveData</a>&lt;<a class="ae hu" href="https://developer.android.com/reference/android/arch/paging/PagedList.html" rel="noopener ugc nofollow" target="_blank">PagedList</a>&gt;</code>来处理任意大的结果集:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="811d" class="lf kj hx lw b fi mf mg l mh mi"><strong class="lw hy">LiveData&lt;PagedList&lt;User&gt;&gt;</strong> users = new LivePagedListBuilder&lt;&gt;(<br/>        userDao.loadUsersByAgeDesc(), <strong class="lw hy">/*page size*/ 20</strong>).build();</span></pre><p id="a170" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在上面的代码中，我们获得了分页查询结果的<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/livedata.html" rel="noopener ugc nofollow" target="_blank"> LiveData </a>版本，当数据库发生变化时，它还将更新任何订阅的<a class="ae hu" href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html" rel="noopener ugc nofollow" target="_blank">观察者</a>。要了解更多关于使用架构组件从SQLite分页的信息，请参阅Github 上的<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/paging.html" rel="noopener ugc nofollow" target="_blank">分页介绍</a>和<a class="ae hu" href="https://github.com/googlesamples/android-architecture-components/tree/master/PagingSample" rel="noopener ugc nofollow" target="_blank">分页示例。</a></p><div class="hg hh ez fb hi mj"><a href="https://github.com/googlesamples/android-architecture-components/tree/master/PagingSample" rel="noopener  ugc nofollow" target="_blank"><div class="mk ab dw"><div class="ml ab mm cl cj mn"><h2 class="bd hy fi z dy mo ea eb mp ed ef hw bi translated">Android-架构-组件/分页示例</h2><div class="mq l"><h3 class="bd b fi z dy mo ea eb mp ed ef dx translated">android架构组件-Android架构组件示例。</h3></div><div class="mr l"><p class="bd b fp z dy mo ea eb mp ed ef dx translated">github.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx ho mj"/></div></div></a></div><h2 id="24e1" class="lf kj hx bd kk lg lh li ko lj lk ll ks jv lm ln ku jz lo lp kw kd lq lr ky ls bi translated"><strong class="ak">安卓平台—安卓P更新！</strong></h2><p id="f567" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">自从本文最初发表以来，我们已经在Android P开发者预览版中添加了新的API来改进上述行为。该平台现在允许应用程序<a class="ae hu" href="https://developer.android.com/reference/android/database/sqlite/SQLiteCursor.html#setFillWindowForwardOnly(boolean)" rel="noopener ugc nofollow" target="_blank">禁用窗口启发式</a>和<a class="ae hu" href="https://developer.android.com/reference/android/database/CursorWindow.html#CursorWindow(java.lang.String,%20long)" rel="noopener ugc nofollow" target="_blank">配置光标或窗口大小</a>。小查询仍然是避免上述所有问题的好方法，但P的变化给了应用程序更多的控制，我们将很快在Room中使用它们，以尽可能保持查询的效率。</p></div></div>    
</body>
</html>