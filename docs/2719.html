<html>
<head>
<title>React Router v4 Tutorial - Create Routing for your React Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React路由器v4教程-为React应用程序创建路由</h1>
<blockquote>原文：<a href="https://medium.com/edureka/react-router-2aab4e781736?source=collection_archive---------3-----------------------#2017-09-12">https://medium.com/edureka/react-router-2aab4e781736?source=collection_archive---------3-----------------------#2017-09-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/daf5973fdfd52802d23cefd80e7dfc20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Vt3MEDjC-h3G-GKi2cU3Zw.png"/></div><figcaption class="il im et er es in io bd b be z dx">React Router V4-Edureka</figcaption></figure><p id="ab79" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我开始这篇文章之前，我希望你已经看完了我的<a class="ae jn" rel="noopener" href="/edureka/reactjs-tutorial-aa087fd7fc90"> <strong class="ir hi"> <em class="jo"> React教程</em> </strong> </a>文章中React的<strong class="ir hi">积木</strong>。如果没有，请先浏览一遍，以便更好地理解React。在学习React的基础知识时，我相信您一定想知道如何在应用程序中添加导航。如果是这样，你就来对地方了。在这篇<strong class="ir hi"> React路由器</strong>博客中，我将带你浏览React中的<strong class="ir hi">路由</strong>概念。</p><p id="ff78" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将关注以下主题:</p><ul class=""><li id="909f" class="jp jq hh ir b is it iw ix ja jr je js ji jt jm ju jv jw jx bi translated">传统路由</li><li id="ccf2" class="jp jq hh ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">为什么我们需要React路由器？</li><li id="93ec" class="jp jq hh ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">React中的路由</li><li id="3ade" class="jp jq hh ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated">React路由器v4的优势</li></ul><h1 id="4f82" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">传统路由</h1><p id="4883" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">通常，当用户在浏览器中键入URL时，会向服务器发送一个HTTP请求，然后服务器检索HTML页面。对于每个<em class="jo">新的URL，</em>用户被重定向到一个<strong class="ir hi">新的</strong> HTML页面。您可以参考下图来更好地理解路由是如何工作的。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lg"><img src="../Images/4b43af40defb5a4abfa3045d1f0dca76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YUP-jx8mhX1FC9IpcQ_tcg.png"/></div></div></figure><h1 id="2a37" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">为什么我们需要React路由器？</h1><p id="5ec4" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">单页面应用程序仅限于<strong class="ir hi">单视图</strong>对于许多流行的社交媒体网站来说是不公平的，比如脸书、Instagram，它们使用React today呈现多视图。我们需要继续前进，学习如何在我们的单页应用程序中显示多视图。</p><p id="f31d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，我们习惯于看到一个显示欢迎信息和相关内容的主页。该网站的背景资料可以在“关于我们”页面上找到，用户列表和他们的详细信息列在不同的页面上，可能有各种其他页面包括几个不同的视图。</p><p id="b8d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么你认为这是如何实现的呢？在我们的应用程序中添加一个路由器库解决了这个需求。</p><h1 id="8d6b" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">React中的路由</h1><p id="1211" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">这就把我们带到了今天博客的主题:React路由器v4。2017年3月13日，Micheal Jackson &amp; Ryan Florence发布了React路由器v4以及可靠的文档。</p><p id="b3c3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">他们信奉“学一次，路到天涯”的意识形态。</p><p id="d0be" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在React Conf 2017的演讲中，他们解释了这一点，展示了他们如何将他们的路由概念从Web无缝地投影到原生平台，以及将<strong class="ir hi"> React Router </strong>集成到<strong class="ir hi"> VR </strong>中，并在<strong class="ir hi"> React Native </strong>中创建动画。尽管他们谈话的吸引点围绕着他们的路由器API是如何“<strong class="ir hi">都是关于组件</strong>”的。</p><p id="922b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在React中，只涉及到一个<strong class="ir hi">单个</strong>‘Html’文件。每当用户键入一个<strong class="ir hi">新的</strong> URL请求时，路由器不是从服务器获取数据，而是为每个新的URL请求换入一个不同的<strong class="ir hi">组件</strong>。用户被骗在多个页面之间切换，但实际上，每个单独的<strong class="ir hi">组件重新呈现</strong>以根据我们的需要实现多个视图。</p><h2 id="1ec4" class="lp ke hh bd kf lq lr ls kj lt lu lv kn ja lw lx kr je ly lz kv ji ma mb kz mc bi translated">React是如何做到这一点的？</h2><p id="a447" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">这就是<strong class="ir hi">‘历史’</strong>的概念出现的地方。在React中，路由器查看每个<strong class="ir hi">组件</strong>的历史，当历史中有任何变化时，该<strong class="ir hi">组件</strong>会重新呈现。直到路由器版本4，我们不得不手动<strong class="ir hi"/>设置<em class="jo">历史</em>值。然而，从路由器v4开始，基本路径被&lt;浏览器路由器&gt;绕过，节省了我们很多工作。如果你仍然需要访问历史，HTML5提供了一个内置的API，允许我们通过<strong class="ir hi">推状态</strong>和<strong class="ir hi">替换状态</strong>方法来修改<strong class="ir hi">历史</strong>对象。</p><p id="3aea" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">事实上，React Router 4完全重写了之前的版本。创建自己的路由只是您已经非常熟悉的React组件代码的自然扩展。尽管需要一些时间来理解，但是一旦你向前迈进，路由器v4将开始变得有意义。</p><p id="0972" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好了，现在让我们深入了解一下第4版提供了什么。</p><h1 id="8c48" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">React路由器v4的优势</h1><p id="d91c" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">我们本质上想在React的render方法中调用路由器组件。这是因为整个路由器API都是关于组件的。当然，每个组件的作用是呈现UI，就像任何React应用程序一样。</p><h2 id="4f6d" class="lp ke hh bd kf lq lr ls kj lt lu lv kn ja lw lx kr je ly lz kv ji ma mb kz mc bi translated"><strong class="ak"> 1。</strong> <strong class="ak">无需手动设置历史</strong></h2><p id="ecfa" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">我们所做的就是将路由器应用程序组件包装在<browserrouter>中。</browserrouter></p><pre class="lh li lj lk fd md me mf mg aw mh bi"><span id="b62a" class="lp ke hh me b fi mi mj l mk ml">ReactDOM.render((<br/>&lt;BrowserRouter&gt;<br/>&lt;App/&gt;<br/>&lt;/BrowserRouter&gt;<br/>), document.getElementById(“root”));</span></pre><p id="8872" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我们借助一个示例来理解路由:</p><p id="b975" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将创建三个页面。这是页面列表及其地址。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es mm"><img src="../Images/7e8202716177c3b05a5799055a04001c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPHKPvz1X0Q4jyhRHvCQ2g.png"/></div></div></figure><h2 id="7f33" class="lp ke hh bd kf lq lr ls kj lt lu lv kn ja lw lx kr je ly lz kv ji ma mb kz mc bi translated"><strong class="ak"> 2。套餐拆分:</strong></h2><p id="4f2f" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">“react-router”库现在被分成三个独立的包。</p><ul class=""><li id="87ed" class="jp jq hh ir b is it iw ix ja jr je js ji jt jm ju jv jw jx bi translated"><strong class="ir hi"> react-router-dom </strong>:专为web应用设计。</li><li id="3213" class="jp jq hh ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated"><strong class="ir hi"> react-router-native </strong>:专为移动应用设计。</li><li id="1be1" class="jp jq hh ir b is jy iw jz ja ka je kb ji kc jm ju jv jw jx bi translated"><strong class="ir hi"> react-router-core: </strong>可以在任何地方用于核心应用。</li></ul><p id="cfff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们需要安装依赖项:</p><pre class="lh li lj lk fd md me mf mg aw mh bi"><span id="457c" class="lp ke hh me b fi mi mj l mk ml">$ npm install --save react-router-dom</span></pre><p id="09de" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">(如果您没有安装最新的npm (5.x)版本，请使用“保存”命令。)<br/>我们从‘react-router-DOM’库中导入‘browser router’<strong class="ir hi">组件</strong>以及‘Link’和‘Route’。</p><p id="04c9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以将<strong class="ir hi"> BrowserRouter </strong>视为呈现子路由的根组件。</p><pre class="lh li lj lk fd md me mf mg aw mh bi"><span id="a438" class="lp ke hh me b fi mi mj l mk ml">import {<br/>BrowserRouter,<br/>Route,<br/>Link<br/>} from 'react-router-dom'</span></pre><p id="9f74" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在继续介绍路由器v4的优势之前，让我们先了解一下<strong class="ir hi">链路</strong>和<strong class="ir hi">路由</strong>组件。</p><p id="a6c2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jo">链接</em> </strong></p><p id="cb0c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Link用于在路由器应用程序的<strong class="ir hi">内部路由</strong>中导航。它相当于锚标签:&lt; a &gt; &lt; /a &gt;。</p><p id="6e50" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将字符串参数<strong class="ir hi">传递给指定URL路径的“</strong>”。</p><pre class="lh li lj lk fd md me mf mg aw mh bi"><span id="93cc" class="lp ke hh me b fi mi mj l mk ml">&lt;ul&gt;<br/>&lt;li&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt;<br/>&lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt;<br/>&lt;li&gt;&lt;Link to="/topics"&gt;Topics&lt;/Link&gt;&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="f858" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jo">路线</em> </strong></p><p id="3208" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在来看一下<strong class="ir hi"> &lt;路由&gt;，</strong>，它们可以被认为是负责根据用户的输入位置呈现<strong class="ir hi"> UI、</strong>的单个<strong class="ir hi">子</strong> <strong class="ir hi">组件</strong>。如果用户指定的位置与<strong class="ir hi"> &lt;路线&gt; </strong>中定义的路径相匹配，那么<strong class="ir hi"> &lt;路线&gt; </strong>可以通过两种方式定义<strong class="ir hi">视图</strong>:</p><ol class=""><li id="7896" class="jp jq hh ir b is it iw ix ja jr je js ji jt jm mn jv jw jx bi translated">在<strong class="ir hi"> &lt;路径&gt; </strong>中创建一个<strong class="ir hi">组件</strong></li><li id="af44" class="jp jq hh ir b is jy iw jz ja ka je kb ji kc jm mn jv jw jx bi translated">使用内嵌的<strong class="ir hi">渲染</strong>函数</li></ol><p id="a5e9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果指定的URL与定义的路径不匹配，&lt;<strong class="ir hi">路由</strong> &gt;将返回null。基本的<strong class="ir hi"> &lt;路径&gt; </strong>有两个参数，一个用于<strong class="ir hi">路径</strong>，一个用于渲染<strong class="ir hi"> UI。</strong></p><p id="a9c8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我在下面举例说明:</p><pre class="lh li lj lk fd md me mf mg aw mh bi"><span id="7c1c" class="lp ke hh me b fi mi mj l mk ml">&lt;BrowserRouter&gt;<br/>&lt;div&gt;<br/>&lt;Route exact path="/" render={ ( ) =&gt; (&lt;h2&gt; HomePage &lt;/h2&gt;) } /&gt;<br/>&lt;Route path="/about" component={About}/&gt;<br/>&lt;Route path="/topics" component={Topics}/&gt;<br/>&lt;/div&gt;<br/>&lt;/BrowserRouter&gt;</span></pre><h2 id="570f" class="lp ke hh bd kf lq lr ls kj lt lu lv kn ja lw lx kr je ly lz kv ji ma mb kz mc bi translated"><strong class="ak"> 3。IndexRoute被替换为“精确的</strong>”<strong class="ak">:</strong></h2><p id="20f2" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">无需使用IndexRoute来呈现主页，您会注意到前面代码片段中的<strong class="ir hi">‘exact’</strong>prop。这是React路由器v4的<strong class="ir hi">声明性</strong>本质的一个很好的例子。</p><p id="9dc1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">v4中的路线包含<strong class="ir hi"><em class="jo"/></strong>意味着可以同时渲染<em class="jo">多条路线</em>。我们使用<strong class="ir hi">【exact】</strong>道具来解决多个匹配之间的争用。</p><p id="573f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在前面的例子中没有使用“exact”，URL <strong class="ir hi"> '/' </strong>将匹配路径为'/'、'/about '和'/topics '的路线。然而<strong class="ir hi">，</strong>我们希望<strong class="ir hi"> '/' </strong>只匹配<strong class="ir hi"/>我们的渲染函数，因此使用‘exact’显式实现了这一点。</p><h2 id="eb21" class="lp ke hh bd kf lq lr ls kj lt lu lv kn ja lw lx kr je ly lz kv ji ma mb kz mc bi translated"><strong class="ak"> 4。路由器只能有一个子元素:</strong></h2><p id="2169" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">这就是为什么我们需要在<div>内包装我们的路线。</div></p><p id="e25d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们没有这样做，您将得到以下异常。</p><pre class="lh li lj lk fd md me mf mg aw mh bi"><span id="d1c9" class="lp ke hh me b fi mi mj l mk ml">* Uncaught Error: A &lt;Router&gt; may have only one child element *</span></pre><h2 id="c5dd" class="lp ke hh bd kf lq lr ls kj lt lu lv kn ja lw lx kr je ly lz kv ji ma mb kz mc bi translated"><strong class="ak"> 5。开关:</strong></h2><p id="a527" class="pw-post-body-paragraph ip iq hh ir b is lb iu iv iw lc iy iz ja ld jc jd je le jg jh ji lf jk jl jm ha bi translated">虽然我们可以在单个<div>标签中封装几个路由。如果我们希望一次只呈现一个路由组件，我们使用一个<switch>标签。它依次检查每条路线的匹配<strong class="ir hi"/>，一旦找到第一个<strong class="ir hi"/>匹配就停止。</switch></div></p><pre class="lh li lj lk fd md me mf mg aw mh bi"><span id="30c3" class="lp ke hh me b fi mi mj l mk ml">&lt;switch&gt;<br/>&lt;route exact path=’/’   component={Home}/&gt;<br/>&lt;route path=’/users/:id’ component={User }/&gt;<br/>&lt;route path=’/users’   component={Roster}/&gt;<br/>&lt;switch&gt;</span></pre><p id="722c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的示例中，我们将路径为“users/:id”的路由放置在“users”之上。这是因为“用户/:id”将与“用户”和“用户/:id”匹配。</p><p id="f8a1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在您已经对React Router有了基本的了解，下面是定义我们的路由器应用程序组件的完整代码。</p><pre class="lh li lj lk fd md me mf mg aw mh bi"><span id="dd1c" class="lp ke hh me b fi mi mj l mk ml">const App= () =&gt; (<br/>&lt;BrowserRouter&gt;<br/>&lt;div&gt;<br/>&lt;ul&gt;<br/>&lt;li&gt;&lt;Link to="/"&gt;Home&lt;/Link&gt;&lt;/li&gt;<br/>&lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt;<br/>&lt;li&gt;&lt;Link to="/topics"&gt;Topics&lt;/Link&gt;&lt;/li&gt;<br/>&lt;/ul&gt;<br/>&lt;Route exact path="/" render={ ( ) =&gt; (&lt;h2&gt; HomePage &lt;/h2&gt;) } /&gt;<br/>&lt;Route path="/about" component={About}/&gt;<br/>&lt;Route path="/topics" component={Topics}/&gt;<br/>&lt;/div&gt;<br/>&lt;/BrowserRouter&gt;<br/>)</span></pre><p id="4436" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，你可以参考Edureka的官方网站。</p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释Reactjs的各个其他方面。</p><blockquote class="mo mp mq"><p id="93c3" class="ip iq jo ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">1.<a class="ae jn" rel="noopener" href="/edureka/reactjs-tutorial-aa087fd7fc90"> ReactJS教程</a></p><p id="7732" class="ip iq jo ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">2.<a class="ae jn" rel="noopener" href="/edureka/react-components-65dc1d753af5">反应堆组件</a></p><p id="2fa9" class="ip iq jo ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">3.<a class="ae jn" rel="noopener" href="/edureka/react-redux-tutorial-2b3d81cfd3f7"> React Redux教程</a></p><p id="558e" class="ip iq jo ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">4.<a class="ae jn" rel="noopener" href="/edureka/html-vs-html5-83302f95652e"> HTML vs HTML5 </a></p><p id="25df" class="ip iq jo ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">5.<a class="ae jn" rel="noopener" href="/edureka/what-is-rest-api-d26ea9000ee6">什么是REST API？</a></p><p id="2bb1" class="ip iq jo ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">6.<a class="ae jn" rel="noopener" href="/edureka/flutter-vs-react-native-58133fbf9f33">颤振vs反应原生</a></p><p id="81ec" class="ip iq jo ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">7.<a class="ae jn" rel="noopener" href="/edureka/front-end-developer-skills-ebb32d19f488">前端开发者技能</a></p><p id="7170" class="ip iq jo ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">8.<a class="ae jn" rel="noopener" href="/edureka/front-end-developer-resume-c3d443f98296">前端开发者简历</a></p><p id="25f6" class="ip iq jo ir b is it iu iv iw ix iy iz mr jb jc jd ms jf jg jh mt jj jk jl jm ha bi translated">9.<a class="ae jn" rel="noopener" href="/edureka/web-development-projects-b01f0fe85d3f">网络开发项目</a></p></blockquote></div><div class="ab cl mu mv go mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ha hb hc hd he"><p id="b74b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jo">原载于2017年9月12日</em><a class="ae jn" href="https://www.edureka.co/blog/react-router/" rel="noopener ugc nofollow" target="_blank"><em class="jo">www.edureka.co</em></a><em class="jo">。</em></p></div></div>    
</body>
</html>