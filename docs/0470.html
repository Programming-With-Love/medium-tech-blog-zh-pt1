<html>
<head>
<title>When using enums and R8…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当使用枚举和R8时…</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/when-using-enums-and-r8-3f8f314c0a13?source=collection_archive---------0-----------------------#2020-03-10">https://medium.com/androiddevelopers/when-using-enums-and-r8-3f8f314c0a13?source=collection_archive---------0-----------------------#2020-03-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/7dbdff2f6243de6e06b0425e311eb83b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QpP21pn8EmDouGf0jAK_Q.png"/></div></div></figure><div class=""/><div class=""><h2 id="629c" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">科特林词汇——开启枚举和R8优化</h2></div><p id="1b6c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">无论何时使用或学习一门新语言，了解该语言中的可用特性以及这些特性是否有相关的开销是很重要的。</p><p id="69d7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这在Kotlin中变得特别有趣，因为它提供了Java编程语言中没有的特性，尽管它可以编译成Java字节码。这是怎么回事？这些特性有相关的开销吗？如果有开销，我们能做些什么吗？</p><p id="e899" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这篇文章是关于枚举和when语句(Java中的switch语句)。我将讨论一些与何时以及如何使用Android R8编译器来优化您的应用程序并降低开销相关的非显而易见的开销。</p><h1 id="014d" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">编译程序</h1><p id="1a4e" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">首先，让我们谈谈D8和R8。</p><p id="83eb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">实际上，有三个<em class="la">T2编译器步骤来处理你为Android应用程序编写的Kotlin代码。</em></p><h2 id="7b50" class="lb ke hs bd kf lc ld le kj lf lg lh kn jq li lj kp ju lk ll kr jy lm ln kt lo bi translated"># 1 kot Lin编译器</h2><p id="748f" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">首先，Kotlin编译器运行并将您的代码转换成Java编程语言的字节码。这很好，除了……我们不在Android设备上运行那个字节码。相反，我们运行一个叫做DEX的东西，它代表Dalvik可执行文件。Dalvik是Android上最初的运行时的名字。目前的运行时，自Android 5.0 Lollipop以来，被称为ART，代表Android运行时…但ART仍然运行相同的DEX代码(如果用不处理旧可执行文件的东西来替换运行时，那就太傻了，不是吗？)</p><h2 id="45ef" class="lb ke hs bd kf lc ld le kj lf lg lh kn jq li lj kp ju lk ll kr jy lm ln kt lo bi translated">#2 D8</h2><p id="4135" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">D8 是这个链中的第二个编译器，从Java字节码翻译成DEX代码。此时，您已经有了可以在Android上运行的代码。或者，你可以选择使用第三个编译器<em class="la">，称为<a class="ae lp" href="https://developer.android.com/studio/build/shrink-code" rel="noopener ugc nofollow" target="_blank"> R8 </a>。</em></p><h2 id="35fb" class="lb ke hs bd kf lc ld le kj lf lg lh kn jq li lj kp ju lk ll kr jy lm ln kt lo bi translated">#3 R8(可选，但推荐)</h2><p id="4420" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated"><a class="ae lp" href="https://developer.android.com/studio/build/shrink-code" rel="noopener ugc nofollow" target="_blank"> R8 </a>是D8的扩展模式，用于优化和收缩应用程序。基本上，它是ProGuard的替代品。因为R8作为D8编译步骤的一部分运行，所以它能够比ProGuard更快，ProGuard是一个完全独立的编译器。</p><p id="1117" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">但是R8在默认情况下是不启用的，所以如果您想使用它(对于这里讨论的一些优化，您可以使用它)，您需要启用它。在应用程序的build.gradle文件中设置<code class="du lq lr ls lt b">minifyEnabled = true</code>来强制R8运行。这将发生在所有其他编译之后，以确保您得到一个缩小和优化的应用程序。</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="79f6" class="lb ke hs lt b fi mc md l me mf">android {<br/>    buildTypes {<br/>        release {<br/>            minifyEnabled true</span><span id="406a" class="lb ke hs lt b fi mg md l me mf">            proguardFiles getDefaultProguardFile(<br/>                ‘proguard-android-optimize.txt’),<br/>                ‘proguard-rules.pro’<br/>        }<br/>    }<br/>}</span></pre><h1 id="ebf4" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">枚举</h1><p id="4196" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">现在，我们来谈谈枚举。</p><p id="68e0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">不管你是用Java还是Kotlin代码编写，枚举的开销和功能本质上是一样的，但是有趣的是，一旦我们将R8引入其中，我们可以对其中的一些开销做些什么。</p><p id="9686" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">枚举本身没有任何不明显的开销。如果你在Kotlin中使用一个enum，那么它将被翻译成Java编程语言中的enum。这没什么大不了的。(是的，我们曾经谈论过避免枚举…但那是很多年前的事了，而且是在整个运行时之前——枚举是好的)。</p><p id="3c35" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当您使用when语句时，开销就会增加。</p><p id="f16c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">首先，让我们看一个示例枚举:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="eac9" class="lb ke hs lt b fi mc md l me mf">enum class BlendMode {<br/>    OPAQUE,<br/>    TRANSPARENT,<br/>    FADE,<br/>    ADD<br/>}</span></pre><p id="38e6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这里我们的枚举有四个值。那些是什么并不重要；这只是一个例子。</p><h1 id="92d9" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">枚举+ When</h1><p id="1fd3" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">现在让我们添加一个when语句，打开该枚举:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="2ab3" class="lb ke hs lt b fi mc md l me mf">fun blend(b: BlendMode) {<br/>    when (b) {<br/>        BlendMode.OPAQUE -&gt; src()<br/>        BlendMode.TRANSPARENT -&gt; srcOver()<br/>        BlendMode.FADE -&gt; srcOver()<br/>        BlendMode.ADD -&gt; add()<br/>    }<br/>}</span></pre><p id="50ef" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对于每个枚举值，我们将调用另一个函数。</p><p id="735c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你看看它在Java字节码中编译成了什么(你可以在Android Studio中直接查看字节码(工具-&gt; Kotlin -&gt;显示Kotlin字节码)，然后点击“反编译”按钮)，它看起来就像这样:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="550d" class="lb ke hs lt b fi mc md l me mf">public static void blend(@NotNull BlendMode b) {<br/>    switch (BlendingKt$WhenMappings.<br/>            $EnumSwitchMapping$0[b.ordinal()]) {<br/>        case 1: {<br/>            src();<br/>            break;<br/>        }<br/>        // ...<br/>    }<br/>}</span></pre><p id="a884" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">它调用此数组，而不是直接对枚举值进行切换。那个数组是从哪里来的？</p><p id="9691" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">数组被保存在这个生成的类文件中。那个类文件是从哪里来的？</p><p id="5f47" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是怎么回事？</p><h1 id="afdd" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">自动生成的枚举映射</h1><p id="f4a7" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">事实证明，出于二进制兼容性的原因，代码不能简单地打开枚举的序数值，因为这是脆弱的。你可以有一个带有枚举的库，如果你改变了枚举中这些项的顺序，你可以破坏别人的应用程序，即使它在代码中看起来是一样的，它们只是顺序不同而已。但是是订单的实现细节导致了破坏。</p><p id="7d20" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因此，相反，编译器接受序数值并将其映射到另一个值，然后无论您对这些枚举做什么，用该库构建的代码仍将运行。</p><p id="ce26" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当然，这意味着某些东西会以你的名义产生。或者在这种情况下，多个东西。</p><p id="b9bf" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">生成的代码如下所示:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="5259" class="lb ke hs lt b fi mc md l me mf">public final class BlendingKt$WhenMappings {<br/>    public static final int[] $EnumSwitchMapping$0 =<br/>            new int[BlendMode.values().length];<br/>    <br/>    static {<br/>        $EnumSwitchMapping$0[BlendMode.OPAQUE.ordinal()] = 1;<br/>        $EnumSwitchMapping$0[BlendMode.TRANSPARENT.ordinal()] = 2;<br/>        $EnumSwitchMapping$0[BlendMode.FADE.ordinal()] = 3;<br/>        $EnumSwitchMapping$0[BlendMode.ADD.ordinal()] = 4;<br/>    }<br/>}</span></pre><p id="9f5a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">生成了一个类BlendingKt$WhenMappings。其中包含一个数组$EnumSwitchMapping$0，其中存放了映射，然后是一些实际执行映射操作的静态代码。</p><p id="5f3c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">只有一个when语句时就是这种情况。如果我们有更多的when语句，我们将为这些语句中的每一个都有另一个数组，即使它们使用相同的枚举。</p><p id="6ab8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">所有这些开销没什么大不了的。但这确实意味着，在您不知道的情况下，一个类正在以您的名义生成，然后该类中的一些数组，所有这些都需要在类加载和实例化时花费更多的时间。</p><p id="ce9c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">幸运的是，我们可以做些事情来减少开销:这就是R8的用武之地。</p><h1 id="1138" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">R8来了</h1><p id="23c9" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">R8是一个有趣的优化器。它可以看到你应用程序中的所有东西。它能看到所有的代码，不管是你写的代码还是你正在编译的库代码。例如，它知道可以避免这些枚举映射的开销，就可以做出关于优化的决策。它不需要映射信息，因为它知道代码只会以这种特定的方式使用这些枚举，所以它可以调用序数值。</p><p id="eaa1" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这是R8优化代码反编译后的样子:</p><pre class="lu lv lw lx fd ly lt lz ma aw mb bi"><span id="1681" class="lb ke hs lt b fi mc md l me mf">public static void blend(@NotNull BlendMode b) {<br/>    switch (b.ordinal()) {<br/>        case 0: {<br/>            src();<br/>            break;<br/>        }<br/>        // ...<br/>    }<br/>}</span></pre><p id="ca1b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">它避免了生成类和映射数组，只是创建了您想要的最佳代码。</p><p id="862b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">看看R8，看看科特林，享受用科特林编写更好的应用程序。</p><h1 id="979b" class="kd ke hs bd kf kg kh ki kj kk kl km kn iy ko iz kp jb kq jc kr je ks jf kt ku bi translated">欲了解更多信息</h1><p id="e764" class="pw-post-body-paragraph jh ji hs jj b jk kv it jm jn kw iw jp jq kx js jt ju ky jw jx jy kz ka kb kc ha bi translated">有关这些主题的更多信息，请访问以下链接:</p><div class="hg hh ez fb hi mh"><a href="https://developer.android.com/studio/command-line/d8" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd ht fi z dy mm ea eb mn ed ef hr bi translated">d8 |安卓开发者</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">d8是一个命令行工具，Android Studio和Android Gradle插件使用它来编译项目的Java字节码…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">developer.android.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv ho mh"/></div></div></a></div><div class="hg hh ez fb hi mh"><a href="https://developer.android.com/studio/build/shrink-code" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd ht fi z dy mm ea eb mn ed ef hr bi translated">缩小、混淆和优化您的应用| Android开发者</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">为了让你的应用程序尽可能的小，你应该在你的发布版本中启用收缩来移除未使用的代码和…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">developer.android.com</p></div></div><div class="mq l"><div class="mw l ms mt mu mq mv ho mh"/></div></div></a></div><div class="hg hh ez fb hi mh"><a href="https://jakewharton.com/blog/" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd ht fi z dy mm ea eb mn ed ef hr bi translated">邮件</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">博客文章、演示文稿、GitHub等等。</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">jakewharton.com</p></div></div><div class="mq l"><div class="mx l ms mt mu mq mv ho mh"/></div></div></a></div><p id="cccb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><a class="my mz ge" href="https://medium.com/u/8ddd94878165?source=post_page-----3f8f314c0a13--------------------------------" rel="noopener" target="_blank">杰克·沃顿</a>详细介绍了d8和r8的工作原理，给出了各种特性的具体例子，以及如何直接运行编译器和如何获得反编译结果。</p><figure class="lu lv lw lx fd hj"><div class="bz dy l di"><div class="na nb l"/></div></figure><p id="d402" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这篇文章(和它的视频版本)摘自我和<a class="my mz ge" href="https://medium.com/u/c967b7e51f8b?source=post_page-----3f8f314c0a13--------------------------------" rel="noopener" target="_blank">罗曼·盖伊</a>在KotlinConf 2019上做的一个更长的演示。查看视频，了解关于Kotlin、语言特性和优化的更多信息。</p></div></div>    
</body>
</html>