<html>
<head>
<title>Using BiometricPrompt with CryptoObject: how and why</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将BiometricPrompt与CryptoObject结合使用:方式和原因</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/using-biometricprompt-with-cryptoobject-how-and-why-aace500ccdb7?source=collection_archive---------0-----------------------#2020-02-27">https://medium.com/androiddevelopers/using-biometricprompt-with-cryptoobject-how-and-why-aace500ccdb7?source=collection_archive---------0-----------------------#2020-02-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/c457510c3ada190b3f002429e90310d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Irlhmj7G8D9hieNw9kL7lg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="5b7e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">生物识别</em>和<em class="js">密码学</em>不是一回事。它们实际上是完全相互独立的:</p><ul class=""><li id="8808" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated"><em class="js">密码术</em>是对对手隐藏信息并验证信息的真实性。在密码学中，没有密钥，对手无法读取加密的数据。此外，大多数加密技术都有防篡改机制。</li><li id="9f8d" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><em class="js">另一方面，生物识别</em>是利用身体测量来验证个人身份。在生物识别技术中，指纹、面部或其他身份信息可用于身份认证。</li></ul><p id="561e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android上有许多系统协同工作来保护数据。从Android 4.4开始，用户数据分区的内容默认加密。一般来说<a class="ae hu" href="https://developer.android.com/topic/security/data" rel="noopener ugc nofollow" target="_blank"> Jetpack Security </a>是一个足够开发人员友好的选项，它在AndroidKeyStore中处理密钥生成的繁重工作，并为加密<a class="ae hu" rel="noopener" href="/p/e4cb0b2d2a9">文件和共享引用</a>提供抽象。</p><p id="c42c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">尽管加密技术不依赖于生物识别技术，但在某些情况下，使用生物识别技术来保护您的加密密钥以提供额外的安全层是有意义的。这些用例包括:企业、政府、金融和医疗保健。这篇文章探索了<em class="js">生物识别</em> <em class="js">库</em>的<code class="du kh ki kj kk b"><a class="ae hu" href="https://developer.android.com/reference/androidx/biometric/BiometricPrompt.CryptoObject.html" rel="noopener ugc nofollow" target="_blank">CryptoObject</a></code>在这些用例中派上用场的几个地方。Android的生物识别API支持以下加密操作——密码、MAC和签名。在本帖中，我们将重点讨论密码。</p><p id="4897" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了理解这两个系统是如何结合在一起的，让我们先深入了解一下加密技术在Android上是如何工作的。然后，我们将展示如何将生物识别技术用于额外的安全层，使您的应用程序更能抵御潜在的攻击者。</p><h1 id="c2c5" class="kl km hx bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">Android上的加密和密钥管理</h1><p id="0501" class="pw-post-body-paragraph iu iv hx iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr ha bi translated">Java Crypto API的核心是一个<code class="du kh ki kj kk b"><a class="ae hu" href="https://developer.android.com/reference/javax/crypto/Cipher" rel="noopener ugc nofollow" target="_blank">Cipher</a></code>，一个可以用来执行数据加密和解密的对象。要应用密码，您需要一个引用底层加密密钥的<code class="du kh ki kj kk b"><a class="ae hu" href="https://developer.android.com/reference/javax/crypto/SecretKey" rel="noopener ugc nofollow" target="_blank">SecretKey</a></code>对象。只有拥有这个密钥的人才能使用这个密码来解密你的数据。在Android上，密钥应该保存在一个名为<a class="ae hu" href="https://developer.android.com/training/articles/keystore.html" rel="noopener ugc nofollow" target="_blank"><em class="js">Android Keystore</em></a>的安全系统中。<em class="js"> Android密钥库</em>的目的是将密钥材料完全保存在Android操作系统之外，并保存在一个安全的位置，该位置有时被称为<em class="js">可信执行环境</em> (TEE)或<em class="js">保险箱</em>。无论密钥材料存在于何处，攻击者都有可能获得它。因此,<em class="js"> Android Keystore </em>尽可能严格地限制密钥材料，确保应用程序、Android用户空间甚至Linux内核都无法访问这些材料。</p><p id="7cf7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设你希望在Android上加密你的应用数据。当你的应用程序请求<a class="ae hu" href="https://developer.android.com/reference/java/security/KeyStore.html" rel="noopener ugc nofollow" target="_blank"> Android密钥库</a>创建一个秘密密钥时，密钥库实际上从来不会给你的应用程序这个秘密密钥的值。那是因为秘钥永远不允许离开安全区域。实际过程是这样的:</p><ol class=""><li id="7343" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr lo jz ka kb bi translated">你的应用程序向安卓<code class="du kh ki kj kk b">KeyStore</code>请求一个<code class="du kh ki kj kk b">SecretKey</code></li><li id="b3f4" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">Android密钥库在安全的位置(Strongbox或TEE)创建密钥。</li><li id="4beb" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">密钥库向您的应用程序返回一个别名。只有密钥库知道如何将这个别名映射到您新创建的<code class="du kh ki kj kk b">SecretKey</code>。</li><li id="fc49" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">当您的应用程序想要执行加密时，它会要求密钥库系统执行加密。</li><li id="08f5" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">密钥库系统接收明文和别名，并返回加密的数据，称为密文。(注意<code class="du kh ki kj kk b">Cipher</code>只是一个例子。其他工件包括<code class="du kh ki kj kk b"><a class="ae hu" href="https://developer.android.com/reference/java/security/Signature" rel="noopener ugc nofollow" target="_blank">Signature</a></code>、<code class="du kh ki kj kk b"><a class="ae hu" href="https://developer.android.com/reference/javax/crypto/Mac" rel="noopener ugc nofollow" target="_blank">Mac</a></code>和<code class="du kh ki kj kk b">IdentityCredential</code>。)</li><li id="767d" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">当您的应用程序想要执行解密时，密钥库系统接收密文和别名，并返回解密的数据或明文。</li></ol><h1 id="b02c" class="kl km hx bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">添加生物特征以要求用户在场</h1><p id="5eac" class="pw-post-body-paragraph iu iv hx iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr ha bi translated">默认情况下，Android已经使用PIN/模式/密码进行了全磁盘加密。您在应用程序中添加了生物认证，要求系统使用<em class="js">认证绑定</em>来进一步保护您的密钥。即使设备遭到破坏，攻击者发出请求，Android密钥库仍然会拒绝解密数据——除非攻击者能够以某种方式让用户使用他们的生物特征凭证进行身份验证。生物特征认证增加了额外的安全层，即使在受损的设备上也是如此，因为除非用户在场，否则无法访问由密钥库管理的硬件。</p><p id="7374" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用生物识别技术来锁定您的密钥的好处在于，与Android上的所有其他加密解决方案一样，生物识别系统和Android密钥库系统之间的所有敏感操作都发生在安全空间(TEE/SE)中，远离窥探的目光。为了理解这一点的重要性，让我们先来看看生物识别技术是如何工作的，以及这两个系统是如何交互的。</p><h1 id="60da" class="kl km hx bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">在安卓生物识别系统的掩护下</h1><p id="24ae" class="pw-post-body-paragraph iu iv hx iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr ha bi translated">Android需要一个强大的信任链。在添加生物特征之前，用户必须验证他们是他们所说的那个人。这个决定是当场作出的。在此过程中，生物识别凭据不会与您的应用程序共享，也不允许离开设备上的安全空间。</p><p id="5262" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一般来说，Android生物识别系统在两个地方使用，注册期间(又名帐户设置)和认证期间(在应用程序或键盘守卫中使用)。</p><p id="a371" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当用户在其设备上设置新帐户时，会发生以下情况:</p><ol class=""><li id="9add" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr lo jz ka kb bi translated">他们可以选择登记他们的指纹(或面部或虹膜)。</li><li id="8643" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">如果用户决定注册生物特征凭证，相关联的传感器在TEE中生成模板(也称为嵌入)。</li></ol><p id="1cc4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">稍后，您的应用程序允许用户使用生物特征进行身份验证。该框架与TEE/SE中的Android生物识别系统一起处理实际的身份验证。该过程包括以下步骤:</p><ol class=""><li id="66d2" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr lo jz ka kb bi translated">用户在传感器上出示他们的生物特征凭证，例如指纹。</li><li id="3478" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">系统安全地在TEE中生成嵌入，并将其与设置期间创建的嵌入进行比较。也就是说，生物识别系统检查凭证是否与设备中注册的凭证相匹配。</li><li id="ed76" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">框架将结果传递给你的应用程序:要么是，凭证匹配一个注册的模板，要么不是，凭证未被识别。</li><li id="4f04" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">如果使用了<code class="du kh ki kj kk b">CryptoObject</code>,则会生成一个额外的证明，该证明稍后可以由TEE确认该生物特征是真实的。这是用来解锁<code class="du kh ki kj kk b">CryptoObject</code>的。</li></ol><p id="a163" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简而言之，这就是生物识别系统在Android上的工作方式。</p><h1 id="ed63" class="kl km hx bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">合作:安全空间中的私人数据检索</h1><p id="8db2" class="pw-post-body-paragraph iu iv hx iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr ha bi translated">正如你所看到的，Android上的密钥库系统和生物识别系统都自行提供了安全措施，尤其是因为它们将自己的资料和敏感操作保存在安全空间(TEE/SE)中。但是，当你需要生物认证来解锁与你的应用相关的<code class="du kh ki kj kk b">SecretKey</code>时，数据变得更加安全。这是因为整个交易发生在安全空间(TEE/SE)。不过，重要的是要注意，生物认证只是加密数据过程的一部分；它仅仅确定用户存在。</p><p id="e5b0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是生物识别系统和密钥库系统如何协同工作来保护您的用户数据:</p><ol class=""><li id="692c" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr lo jz ka kb bi translated">作为开发人员，您请求通过设置<code class="du kh ki kj kk b"><a class="ae hu" href="https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.Builder.html#setUserAuthenticationRequired(boolean)" rel="noopener ugc nofollow" target="_blank">setUserAuthenticationRequired(true)</a></code>来访问您的密钥。</li><li id="08d8" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">当您的应用程序请求与<code class="du kh ki kj kk b">SecretKey</code>相关联的数据时，用户会收到提供有效生物特征凭证的提示。</li><li id="a712" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">回想一下，生物传感器安全地与TEE通信，因此框架和第三方应用程序都不参与交易。因此，当用户轻触指纹传感器时，材料被TEE直接读取。</li><li id="e0b1" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">如果生物特征凭证与注册的凭证相匹配，TEE中的生物特征组件将生成一个硬件认证令牌(hat)。HATs包含一个HMAC，可以用来验证消息的完整性和真实性。</li><li id="0962" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">TEE/SE和Keymaster中的生物识别组件(也在TEE/SE中)共享一个密钥。因此，当框架将这个HAT转发给密钥库系统时，Keymaster能够验证HAT的真实性和完整性，并解锁适当的密钥。</li><li id="c8ec" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr lo jz ka kb bi translated">生物识别框架调用你的应用程序的<code class="du kh ki kj kk b">onAuthenticated()</code>回调。</li></ol><p id="728e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意，因为系统试图将生物特征凭证与现有模板进行匹配，所以默认情况下，如果登记了新的生物特征凭证，则系统将使与生物特征认证相关联的所有现有密钥无效。这样一来，对手就无法注册他们的指纹或面部，并利用这些来访问您的私人数据。密钥将简单地停止工作，并且依赖于它的数据基本上丢失了。因此，如果您的应用程序处理高价值交易，如银行应用程序，请监视回调，该回调指示用户何时添加新的生物识别凭据。在那次回调中，在允许用户在你的应用中重新注册他们的生物特征凭证之前，通知用户并询问他们是否是故意的。</p><figure class="lq lr ls lt fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lp"><img src="../Images/a74fb3f04118256db01866e821e8f1df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*07S1KiTW7rnLg0lw"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Figure 1</figcaption></figure><h1 id="43c5" class="kl km hx bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">神秘物体</h1><p id="bfd5" class="pw-post-body-paragraph iu iv hx iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr ha bi translated">生物统计学和密码学是如此的独立，以至于在你自己的项目中，处理生物统计学认证的代码和处理加密/解密的代码甚至不需要在同一个类中。在您的项目中，这两个系统唯一应该交叉的地方是您对<code class="du kh ki kj kk b">CryptoObject</code>的定义。</p><p id="d3a5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，<code class="du kh ki kj kk b">CryptoObject</code>只是一个包装器，可以方便地将密码带到您可能需要的地方。当你的应用程序调用<code class="du kh ki kj kk b"><a class="ae hu" href="https://developer.android.com/reference/androidx/biometric/BiometricPrompt.html#authenticate(androidx.biometric.BiometricPrompt.PromptInfo,%20androidx.biometric.BiometricPrompt.CryptoObject)" rel="noopener ugc nofollow" target="_blank">biometricPrompt.authenticate(CryptoObject)</a></code>时，它会传入<code class="du kh ki kj kk b">CryptoObject</code>，<code class="du kh ki kj kk b">BiometricPrompt</code>会将完全相同的<code class="du kh ki kj kk b">CryptoObject</code>返回给你的应用程序的<code class="du kh ki kj kk b"><a class="ae hu" href="https://developer.android.com/reference/androidx/biometric/BiometricPrompt.AuthenticationCallback.html#onAuthenticationSucceeded(androidx.biometric.BiometricPrompt.AuthenticationResult)" rel="noopener ugc nofollow" target="_blank">onAuthenticationSucceeded()</a></code>回调函数。</p><p id="a2df" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不可否认的是，这个故事还有更多的内容。API还使用<code class="du kh ki kj kk b">CryptoObject</code>参数来指示您需要一个<a class="ae hu" href="https://source.android.com/compatibility/android-cdd#7_3_10_biometric_sensors" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy">强生物识别</strong> </a>传感器来进行身份验证；所以，如果你不传入参数，你的app的<code class="du kh ki kj kk b">SecretKey</code>在用户提供生物认证后是不会解锁的。此外，<code class="du kh ki kj kk b">CryptoObject</code>专用于特定的加密操作，并且<code class="du kh ki kj kk b">CryptoObject</code>被传递到的生物认证仅解锁该操作。这允许开发人员确保每次使用密钥都必须经过身份验证/批准。</p><h1 id="35af" class="kl km hx bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">现在来看一些代码</h1><p id="d759" class="pw-post-body-paragraph iu iv hx iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr ha bi translated">这里我们将保持加密部分简单。我们将演示如何使用一个<code class="du kh ki kj kk b">Cipher</code>和一个<code class="du kh ki kj kk b">SecretKey</code>来对称地加密/解密数据。你可以通过阅读DAC上的页面来了解更多关于Android 上的<a class="ae hu" href="https://developer.android.com/guide/topics/security/cryptography" rel="noopener ugc nofollow" target="_blank">密码术。</a></p><p id="6d9a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了避免混淆和分离问题，您可以将所有的加密代码放在一个文件中，并将该文件命名为<code class="du kh ki kj kk b">CryptographyManager</code>。该文件可能如下所示。</p><figure class="lq lr ls lt fd hj"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="0d72" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了进一步表明关注点的分离确实是真实的，将<code class="du kh ki kj kk b">CryptographyManagerImpl</code>声明为私有的，这样客户端代码只能看到接口及其方法签名。</p><p id="4b92" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在导入生物特征梯度依赖项后，构建您的<code class="du kh ki kj kk b">PromptInfo</code>对象和您的<code class="du kh ki kj kk b">BiometricPrompt</code>实例，而无需考虑加密。在显示认证对话框的代码中，比如<code class="du kh ki kj kk b">MainActivity</code>，像往常一样设置<code class="du kh ki kj kk b">BiometricPrompt</code>，如下所示。</p><h1 id="ed6c" class="kl km hx bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">1.导入Gradle依赖项</h1><p id="5fcf" class="pw-post-body-paragraph iu iv hx iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr ha bi translated">始终使用库的最新版本。截至本文发布之日，最新版本是1.0.1。</p><figure class="lq lr ls lt fd hj"><div class="bz dy l di"><div class="lu lv l"/></div></figure><h1 id="e878" class="kl km hx bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">2.创建BiometricPrompt的实例</h1><figure class="lq lr ls lt fd hj"><div class="bz dy l di"><div class="lu lv l"/></div></figure><h1 id="741a" class="kl km hx bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">3.生成PromptInfo对象</h1><figure class="lq lr ls lt fd hj"><div class="bz dy l di"><div class="lu lv l"/></div></figure><h1 id="e8d8" class="kl km hx bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">4.特定于业务的OnClickListener</h1><p id="471a" class="pw-post-body-paragraph iu iv hx iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr ha bi translated">现在你已经有了你的<code class="du kh ki kj kk b">BiometricPrompt</code>和<code class="du kh ki kj kk b">PromptInfo</code>，接下来你要做什么取决于你的应用程序的业务逻辑。在我们的例子中，用户输入一个<code class="du kh ki kj kk b"><a class="ae hu" href="https://developer.android.com/reference/android/support/v7/widget/AppCompatEditText" rel="noopener ugc nofollow" target="_blank">EditText</a></code>对象，然后点击一个<code class="du kh ki kj kk b"><a class="ae hu" href="https://developer.android.com/reference/android/support/v7/widget/AppCompatButton" rel="noopener ugc nofollow" target="_blank">Button</a></code>来加密文本，或者点击另一个<code class="du kh ki kj kk b">Button</code>来解密任何已经加密的文本。</p><figure class="lq lr ls lt fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lw"><img src="../Images/dfee21c6894b7e10b2f4b877a3499739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r0VuY4YNjDmAdBOt"/></div></div></figure><p id="d679" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，对我们来说，有两个点击监听器:一个调用用户进行认证，以便<em class="js">加密</em>数据；另一个调用用户认证，以便<em class="js">解密</em>数据。因为这些<code class="du kh ki kj kk b">onClick</code>方法在调用<code class="du kh ki kj kk b">biometricPrompt.authenticate()</code>时都必须传入一个<code class="du kh ki kj kk b">CryptoObject</code>的实例，所以最终需要<code class="du kh ki kj kk b">Cipher</code>。</p><figure class="lq lr ls lt fd hj"><div class="bz dy l di"><div class="lu lv l"/></div></figure><h1 id="8eab" class="kl km hx bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">把所有的放在一起</h1><p id="0d71" class="pw-post-body-paragraph iu iv hx iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr ha bi translated">对我们来说，<code class="du kh ki kj kk b">MainActivity</code>类最终看起来如下:</p><figure class="lq lr ls lt fd hj"><div class="bz dy l di"><div class="lu lv l"/></div></figure><h1 id="9052" class="kl km hx bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">摘要</h1><p id="5ac8" class="pw-post-body-paragraph iu iv hx iw b ix lj iz ja jb lk jd je jf ll jh ji jj lm jl jm jn ln jp jq jr ha bi translated">在这篇文章中，你学到了以下内容:</p><ul class=""><li id="36df" class="jt ju hx iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">Android上的加密(密钥库)系统和生物识别系统的区别。</li><li id="802e" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">如何通过将数据与生物特征相关联来保护特定于应用的安全数据。</li><li id="5654" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">如何使用<code class="du kh ki kj kk b">CryptoObject</code>将两个系统结合起来，实现更高程度的安全性。</li><li id="a91b" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">如何在定义您的<code class="du kh ki kj kk b">SecretKey</code>时使用<code class="du kh ki kj kk b">setUserAuthenticationRequired(true)</code>，以便使用认证绑定锁定密钥。</li><li id="6b9f" class="jt ju hx iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">如何在认证时将您的加密密码传递给<code class="du kh ki kj kk b">CryptoObject</code>以解锁密钥。</li></ul><p id="e831" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">展示这些概念的完整Android应用程序样本在https://github.com/isaidamier/blogs.biometrics.cryptoBlog的<a class="ae hu" href="https://github.com/isaidamier/blogs.biometrics.cryptoBlog" rel="noopener ugc nofollow" target="_blank">展出。</a></p><p id="18df" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">编码快乐！</p></div></div>    
</body>
</html>