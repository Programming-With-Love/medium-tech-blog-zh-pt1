<html>
<head>
<title>Android testing with Espresso’s Idling Resources and testing fidelity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Espresso的空闲资源和测试保真度进行Android测试</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-testing-with-espressos-idling-resources-and-testing-fidelity-8b8647ed57f4?source=collection_archive---------2-----------------------#2019-05-30">https://medium.com/androiddevelopers/android-testing-with-espressos-idling-resources-and-testing-fidelity-8b8647ed57f4?source=collection_archive---------2-----------------------#2019-05-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/5e4cda142ea487f507d5fdc49bf95e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WR5Fw07XP7sJ71pBtyt4kA.png"/></div></div></figure><h1 id="ef03" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">将您的应用程序与Espresso同步</h1><p id="9120" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><em class="kl">如果知道为什么需要闲置资源，可以跳到下一节</em></p><p id="11e8" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">与其他UI测试框架相比，Espresso 的主要优势在于它可以与你的应用程序同步。这意味着它只会在你的应用空闲时(等待用户输入)做出断言和执行动作。其他测试框架会等到满足某个条件(例如显示一个视图)时再进行测试，但是这在很多情况下被证明是有问题的，会导致不可靠的测试。其他框架依赖于您猜测某个操作将花费的时间。这使得测试很慢，并且不能真正保证确定性。<strong class="jp hi">在浓缩咖啡测试中，你永远都不应该使用</strong> <code class="du ks kt ku kv b"><strong class="jp hi">Thread.sleep</strong></code> <strong class="jp hi">。</strong></p><blockquote class="kw kx ky"><p id="c91e" class="jn jo kl jp b jq km js jt ju kn jw jx kz ko ka kb la kp ke kf lb kq ki kj kk ha bi translated">Espresso了解Android的内部结构，能够预测未来。如果主线程很忙(或者在不久的将来会很忙)，Espresso会在运行下一个操作之前等待。这种同步机制，以及Espresso的其他技巧，使其成为Android上最常用的UI测试框架。</p></blockquote><p id="4dee" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">然而，编写UI测试并不容易，大多数问题仍然与同步有关。有些事情是浓缩咖啡不知道的:</p><ul class=""><li id="05e5" class="lc ld hh jp b jq km ju kn jy le kc lf kg lg kk lh li lj lk bi translated"><strong class="jp hi">动画</strong>。如果动画无限期运行，Espresso可能会超时等待动画结束。这就是为什么你应该<a class="ae kr" href="https://developer.android.com/training/testing/espresso/setup#set-up-environment" rel="noopener ugc nofollow" target="_blank">在你的测试设备中禁用动画</a>。</li><li id="2de9" class="lc ld hh jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp hi">后台操作</strong>。Espresso不仅查看主线程，还查看<a class="ae kr" href="https://developer.android.com/reference/android/os/AsyncTask" rel="noopener ugc nofollow" target="_blank"> AsyncTask </a>线程池。然而，已经没有多少人使用AsyncTask了。如果您使用自己的线程池执行器，<a class="ae kr" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank"> Kotlin协同程序</a>或<a class="ae kr" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>，您需要一种方法来将它们与Espresso同步</li><li id="7a6c" class="lc ld hh jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp hi">调度更新的其他机制</strong>。例如，<a class="ae kr" href="https://developer.android.com/topic/libraries/data-binding" rel="noopener ugc nofollow" target="_blank">数据绑定</a>使用<a class="ae kr" href="https://developer.android.com/reference/android/view/Choreographer" rel="noopener ugc nofollow" target="_blank">编排器</a>来发布更新，而不是主Looper队列(Espresso监视的对象)。</li></ul><p id="e0c1" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">当这种情况发生时，你会看到不同的错误，但它通常是一个<code class="du ks kt ku kv b">NoMatchingViewException</code>,因为屏幕上显示的(还)不是你告诉Espresso期待的。</p><p id="934f" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">Espresso提供的让您指示应用程序何时繁忙的API被称为<a class="ae kr" href="https://developer.android.com/training/testing/espresso/idling-resource.html" rel="noopener ugc nofollow" target="_blank">空闲资源</a>。</p><h1 id="3d9c" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">空闲资源是如何注册的</h1><p id="053b" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在测试开始之前，您可以根据需要注册任意多的空闲资源。通常在@Before方法内的测试类中这样做:</p><p id="f392" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><code class="du ks kt ku kv b">IdlingRegistry.getInstance().register(myIdlingResource)</code></p><p id="07e5" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">在下一步中，您将学习如何创建空闲资源。</p><p id="fd45" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">记得在完成后注销它们，例如在@After方法中:</p><p id="d338" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><code class="du ks kt ku kv b">IdlingRegistry.getInstance().unregister(myIdlingResource)</code></p><h1 id="2379" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">创造闲置资源</h1><p id="9516" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">空闲资源实现了<code class="du ks kt ku kv b">IdlingResource</code>接口，您可以创建自己的接口:</p><figure class="lq lr ls lt fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="d44e" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">然而，我建议你使用浓缩咖啡自带的<code class="du ks kt ku kv b"><a class="ae kr" href="https://developer.android.com/reference/android/support/test/espresso/idling/CountingIdlingResource" rel="noopener ugc nofollow" target="_blank">CountingIdlingResource</a></code>，它可以让你在每次开始一项任务时呼叫<code class="du ks kt ku kv b">increment</code>，在完成任务时呼叫<code class="du ks kt ku kv b">decrement</code>。这样，您可以控制同时运行的多个任务。</p><h2 id="0b04" class="lw iq hh bd ir lx ly lz iv ma mb mc iz jy md me jd kc mf mg jh kg mh mi jl mj bi translated">示例1:小吃店</h2><p id="b1c1" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">显示Snackbars的测试很难进行UI测试，因为它们会启动一个弹出动画，显示一会儿，然后又被另一个动画隐藏起来。Espresso并不真正知道你的应用程序何时空闲，因为它只看到未来的<a class="ae kr" href="https://github.com/android/android-test/blob/master/espresso/core/java/androidx/test/espresso/base/Interrogator.java#L41" rel="noopener ugc nofollow" target="_blank"> 15 ms </a>和<code class="du ks kt ku kv b">Snackbar.LENGTH_SHORT</code>2秒。即使禁用动画，Snackbar也会显示。</p><figure class="lq lr ls lt fd ii er es paragraph-image"><div class="er es mk"><img src="../Images/bac18c4e628ffb19bb9616f9dc4a96d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/0*G6maDH9UwlOn3Y62"/></div></figure><p id="bb69" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">您可以在每次显示Snackbar时添加一个回调，并在显示和关闭snack bar时通知空闲资源。这个例子摘自<a class="ae kr" href="https://codelabs.developers.google.com/codelabs/android-testing/#6" rel="noopener ugc nofollow" target="_blank"> Android测试代码实验室</a>:</p><figure class="lq lr ls lt fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="969c" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">您也可以在UI测试中完全禁用Snackbars，以使它们通过得更快，因为您并没有通过这种方式来验证它们的内容。</p><p id="6c68" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">看看我们<a class="ae kr" href="https://github.com/googlecodelabs/android-testing/blob/codelab2019/app/src/test/java/com/example/android/architecture/blueprints/todoapp/tasks/TasksViewModelTest.kt#L212" rel="noopener ugc nofollow" target="_blank">如何在测试代码实验室</a>的单元测试中验证Snackbar内容。</p><h2 id="e4c9" class="lw iq hh bd ir lx ly lz iv ma mb mc iz jy md me jd kc mf mg jh kg mh mi jl mj bi translated">示例2:仅从测试中使用的空闲资源</h2><p id="a404" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">并非所有空闲资源都存在于您的生产代码中。例如，在<a class="ae kr" href="https://codelabs.developers.google.com/codelabs/android-testing/#9" rel="noopener ugc nofollow" target="_blank">测试代码实验室</a>中，我们使用了一个<a class="ae kr" href="https://github.com/googlecodelabs/android-testing/blob/codelab2019/app/src/sharedTest/java/com/example/android/architecture/blueprints/todoapp/util/DataBindingIdlingResource.kt" rel="noopener ugc nofollow" target="_blank">databindingdingresource</a>来寻找活动中的绑定，并对它们调用<code class="du ks kt ku kv b">hasPendingBindings</code>来判断它们是忙还是闲。</p><p id="4ef3" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这些工具只在测试中使用，所以<strong class="jp hi">它们是完美的闲置资源</strong>:不需要修改产品代码。</p><p id="6e97" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">其他例子有<a class="ae kr" href="https://github.com/square/RxIdler" rel="noopener ugc nofollow" target="_blank"> RxIdler </a>，一个封装了RxJava调度程序的空闲资源和<a class="ae kr" href="https://github.com/JakeWharton/okhttp-idling-resource" rel="noopener ugc nofollow" target="_blank"> okhttp-idling-resource </a>，你猜对了，okhttp请求。我们目前正在<a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/issues/242" rel="noopener ugc nofollow" target="_blank">探索如何用Kotlin协程</a>做到这一点。</p><h2 id="93a9" class="lw iq hh bd ir lx ly lz iv ma mb mc iz jy md me jd kc mf mg jh kg mh mi jl mj bi translated"><strong class="ak">例3:修改生产代码😵</strong></h2><p id="8089" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">如果您在后台操作中加载数据，并且没有其他空闲资源机制可用，您可以将应用程序中的空闲资源暴露给测试。例如，在视图模型或数据存储库中:</p><figure class="lq lr ls lt fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="e633" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">然而，您只是为了测试而修改测试中的代码。理想情况下，我们不应该这样做。</p><figure class="lq lr ls lt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ba6d72ce2c634aee3785461cc6d6ac0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KcLPJj-O8P1kNVkeFfwvlA.png"/></div></div></figure><p id="ca82" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">争论的焦点是:<strong class="jp hi">我们应该在生产代码中使用空闲资源吗？</strong></p><p id="c0fd" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">一方面，它们非常易于使用，并且确实使您的代码更易于测试。另一方面，你在给一个潜在的数百万用户运行的应用程序添加代码，但它什么也不做……<strong class="jp hi">什么也不做。</strong></p><p id="5d1a" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">如果你走这条路，你应该限制生产中的负面影响。例如，如果你正在使用一个来自<a class="ae kr" href="https://github.com/googlecodelabs/android-testing/blob/codelab2019/app/src/main/java/com/example/android/architecture/blueprints/todoapp/util/EspressoIdlingResource.kt" rel="noopener ugc nofollow" target="_blank">对象</a>的<code class="du ks kt ku kv b">CountingIdlingResource</code>，为调试和发布(或者为不同的风格)创建这个对象的不同版本。发布的版本应该什么都不做:</p><figure class="lq lr ls lt fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="c36c" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">Snackbar的例子也是如此，我们在其中添加了侦听器。该版本的扩展功能将替换为:</p><figure class="lq lr ls lt fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="231e" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">问题是这些类没有UI测试覆盖，所以应该保持简单。</p><h1 id="c880" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">生产中闲置资源的替代方法</h1><blockquote class="kw kx ky"><p id="387d" class="jn jo kl jp b jq km js jt ju kn jw jx kz ko ka kb la kp ke kf lb kq ki kj kk ha bi translated">你必须找到<em class="hh">你的</em>在修改测试代码和保持测试保真度之间的平衡。<strong class="jp hi">高保真是指你测试的就是用户会用的</strong>。否则，测试可能无法捕获特定的bug。</p></blockquote><p id="62f1" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated"><strong class="jp hi">假设您想通过让所有后台操作顺序运行而不是并发运行来解决问题</strong>。正如我们之前看到的，你可以使用主线程甚至是<code class="du ks kt ku kv b">AsyncTask</code>线程来完成这个任务。这很棒，因为您只需要在测试中注入一些测试执行器或替换一些调度程序。但是，请考虑以下代码:</p><figure class="lq lr ls lt fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="1ac1" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这将启动两个协同程序，它们将在生产中并发运行。如果你不熟悉协程，这就像在一个线程池中执行两个Runnables。在测试中，我们可以将<em class="kl">的执行简化为一系列操作，但是远程数据源调用总是首先执行。</em></p><figure class="lq lr ls lt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/c3f8bb5b998be6e6114d9b06d152794b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rKPLA3JhSPux-Vt0"/></div></div><figcaption class="mm mn et er es mo mp bd b be z dx">Running asynchronous jobs sequentially for tests</figcaption></figure><p id="18b2" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">这种行为是忠诚的吗(它符合生产中的现实吗)？差不多！但是，您可能会遗漏低端设备或有限连接等边缘情况。</p><p id="9273" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">使用这种方法，您可以避免生产中的资源闲置，但是<strong class="jp hi">您应该意识到后果</strong>并弥补缺失的情况。例如，您可能应该添加一系列确定性单元测试来验证您没有在UI测试中测试的情况，其中作业#2在作业#1之前完成。</p><p id="d55b" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">注意:协同例程的解决方案正在开发中，并在<a class="ae kr" href="https://github.com/Kotlin/kotlinx.coroutines/issues/242" rel="noopener ugc nofollow" target="_blank">EspressoIdlingResource integration</a>中进行了跟踪。这个想法是能够设置一个可以注册为空闲资源的调度程序。</p><h1 id="dfc2" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">摘要</h1><p id="14fc" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">1.如果可以的话，使用你正在使用的库提供的空闲资源来完成主线程之外的工作。</p><p id="7e26" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">2.否则，决定是否要通过添加类似<code class="du ks kt ku kv b"><a class="ae kr" href="https://developer.android.com/reference/android/support/test/espresso/idling/CountingIdlingResource" rel="noopener ugc nofollow" target="_blank">CountingIdlingResource</a></code>的闲置资源来修改生产代码。如果您正在修改代码，请确保它具有较低的影响。如果你正在修改你的应用程序的行为以避免资源闲置，请确保你了解反响并在不同的测试中增加覆盖率。</p><p id="f99c" class="pw-post-body-paragraph jn jo hh jp b jq km js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kq ki kj kk ha bi translated">3.如果您的测试范围可以更小，您总是可以用一个假的来替换您的依赖项。在<a class="ae kr" href="https://codelabs.developers.google.com/codelabs/android-testing/#0" rel="noopener ugc nofollow" target="_blank"> codelab </a>中，所有的“片段”测试都使用FakeTasksRepository，所以速度很快。参见测试代码实验室的<a class="ae kr" href="https://github.com/googlecodelabs/android-testing/blob/codelab2019/app/src/sharedTest/java/com/example/android/architecture/blueprints/todoapp/tasks/TasksFragmentTest.kt#L55" rel="noopener ugc nofollow" target="_blank">任务FragmentTest </a>和其余的<code class="du ks kt ku kv b">@MediumTest</code></p></div></div>    
</body>
</html>