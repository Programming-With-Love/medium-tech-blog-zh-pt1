<html>
<head>
<title>Oracle Offline Persistence Toolkit — Controlling Online Replay</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle离线持久性工具包—控制在线重放</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/oracle-offline-persistence-toolkit-controlling-online-replay-e7c4d1f5df54?source=collection_archive---------1-----------------------#2018-08-10">https://medium.com/oracledevs/oracle-offline-persistence-toolkit-controlling-online-replay-e7c4d1f5df54?source=collection_archive---------1-----------------------#2018-08-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="93c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">几个月前，我发表了一篇关于Oracle Offline Persistence Toolkit的帖子，它与Oracle JET(Oracle的JavaScript toolkit)集成得很好—<a class="ae jc" href="http://andrejusb.blogspot.com/2018/03/oracle-jet-offline-persistence-toolkit.html" rel="noopener ugc nofollow" target="_blank">Oracle JET Offline Persistence Toolkit—离线更新处理</a>。随着示例应用程序升级到JET 5.1和离线工具包升级到1.1.5，我又回到了这个主题。在这篇文章中，我将描述如何通过过滤掉一些请求来控制在线重放。</p><p id="1551" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">源代码可以在<a class="ae jc" href="https://github.com/abaranovskis-redsamurai/persistencejetapp" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。下面我描述最新提交中的变化和功能。</p><p id="e135" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要测试在线重放，请离线并在示例应用程序中执行一些操作——更改一些记录并尝试按名字搜索，还尝试使用页面导航按钮。你可以在离线模式下保存更改，但如果这是你第一次加载应用程序，并且尚未从其他页面获取数据，则页面导航在离线模式下不会带来任何新结果(请确保在在线时加载更多记录，然后再离线):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c123a80af36d01ad978f046534b85d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJd9lw3rQinEAzigNRg3gA.png"/></div></div></figure><p id="8767" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在在线重放管理器中，我有意过滤掉GET请求。一旦上线，我只重放补丁请求。这样做主要是为了测试，学习如何控制重放过程。补丁程序请求在重放期间执行:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jp"><img src="../Images/ad9c5a1cea171c97bcc70181148d80b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mp-a4MwlgWeZFwAiQV_9RA.png"/></div></div></figure><p id="8a67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在日志中打印出从重放循环中删除的每个GET请求:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jq"><img src="../Images/12d921a3a5662f394a72c815d030dcfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ldiVwnHlNRvW9Bi1l1lp5w.png"/></div></div></figure><p id="66d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重放实现(我建议阅读<a class="ae jc" href="https://github.com/oracle/offline-persistence-toolkit/blob/master/USAGE.md" rel="noopener ugc nofollow" target="_blank">离线持久性工具包</a>使用文档以了解更多信息):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jr"><img src="../Images/b7915d4d92515bfbb53f8ff384cb17b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bxw6c41FOj-9L6gOZto01A.png"/></div></div></figure><p id="5389" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在转换到联机状态后，执行此代码。从同步管理器中调用getSyncLog方法—返回等待重放的请求列表。Promise返回带有等待在线重放的请求数组的函数。我已经将函数标记为异步，这允许实现顺序循环，其中每个GET请求将按顺序一个接一个地删除。这是必要的，因为来自同步管理器的removeRequest是在promise中执行的，并且循环会完成得太晚——在我们通过执行重放阶段之后。阅读更多关于JS中顺序循环实现的内容，当promise被使用时——<a class="ae jc" href="http://javascript/%20-%20method%20to%20call%20backend%20logic%20in%20sequential%20loop/" rel="noopener ugc nofollow" target="_blank">JavaScript——调用顺序循环中后端逻辑的方法</a>。一旦所有GET请求被删除，我们执行sync方法，这将强制队列中所有剩余的请求被重放。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="9aee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jz">原载于2018年8月10日</em><a class="ae jc" href="http://andrejusb.blogspot.com/2018/08/oracle-offline-persistence-toolkit.html" rel="noopener ugc nofollow" target="_blank"><em class="jz">【andrejusb.blogspot.com】</em></a><em class="jz">。</em></p></div></div>    
</body>
</html>