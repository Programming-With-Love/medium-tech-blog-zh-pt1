<html>
<head>
<title>What’s new in Angular 9 — Angular 9 Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular 9的新功能— Angular 9功能</h1>
<blockquote>原文：<a href="https://medium.com/edureka/angular-9-f666b136df76?source=collection_archive---------0-----------------------#2020-02-14">https://medium.com/edureka/angular-9-f666b136df76?source=collection_archive---------0-----------------------#2020-02-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/37ed267617d7fc1c6448e2dd0112f64e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*PDcAkaoxe9oFYCCJjfXubA.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">Angular 9 — Edureka</figcaption></figure><p id="abae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的世界在不断前进，为了跟上它的步伐，Angular社区一直致力于提供新的功能。这可以确保您的应用程序不会被遗忘。2020年2月7日，Angular发布了Angular的全新版本，即Angular 9。所以，如果你是一个Angular爱好者，并且很想知道Angular 9提供了什么，那么这篇关于“Angular 9的新功能”的文章一定会帮你解渴。</p><p id="f268" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在继续之前，看看这里讨论的所有内容:</p><ol class=""><li id="984a" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">了解角度版本控制</li><li id="a3bf" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">更新路径</li><li id="ade9" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">支持的版本</li><li id="6fde" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Angular 9有什么新功能？</li></ol><ul class=""><li id="84ef" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kb jt ju jv bi translated">角藤</li><li id="f0d4" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">使用Ivy的好处</li><li id="3856" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">AOT和艾薇</li><li id="caa6" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">常春藤和图书馆</li><li id="be5b" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">什么是AOT？</li><li id="5339" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">AOT和JIT的区别是什么？</li><li id="438c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">AOT的工作？</li><li id="19e7" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">编译阶段</li></ul><h1 id="82db" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">了解角度版本控制</h1><p id="d771" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">角度版本指的是版本提出的变更级别，它实际上帮助用户理解当他们升级到新版本时会发生什么。你在Angular中看到的版本号有三个部分，即<em class="lf"> major.minor.patch </em>。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es lg"><img src="../Images/6b05b45c08ce5eb4567d2f3817a1b8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/0*AlW0AWoBoJFeLLuK.png"/></div></figure><p id="9f48" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">主</strong>版本通常包含大量新功能，而<strong class="ir hi">次</strong>版本引入了较小的新功能，并且它们完全向后兼容。补丁发布通常是风险很低的错误修复。</p><h1 id="4766" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">更新路径</h1><p id="4adc" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">角度更新路径取决于两个因素，即<strong class="ir hi"> <em class="lf">是否在同一个主要版本中更新，或者从一个主要版本更新到另一个</em> </strong>。</p><ul class=""><li id="3c18" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kb jt ju jv bi translated">在同一个主版本中更新时，可以省略中间版本，您可以直接升级到最新的次版本</li><li id="936c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">从一个主要版本升级到另一个主要版本时，Angular建议您不要跳过任何中间的主要版本</li></ul><h1 id="3dcf" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">支持的版本</strong></h1><p id="bc3b" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">版本<strong class="ir hi"> 4x </strong>、<strong class="ir hi"> 5x、</strong>和<strong class="ir hi"> 6x </strong>不再支持<strong class="ir hi">。然而，Angular <strong class="ir hi"> 7x </strong>将被<strong class="ir hi">支持到2020年4月18日</strong>，而version <strong class="ir hi"> 8x </strong>将被支持到2020年11月20日<strong class="ir hi"/>。</strong></p><h1 id="279d" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Angular 9有什么新功能？</h1><p id="aea1" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">Angular 9有许多新变化，包括:</p><ul class=""><li id="7bc2" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kb jt ju jv bi translated">在Angular 9中，用Ivy编译应用程序是默认的</li><li id="f8b0" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">你的角度应用提前编译<strong class="ir hi"><em class="lf">(AOT)。</em> </strong>这意味着Angular的AOT编译器会在你的浏览器下载并运行它之前，将你的代码中存在的所有HTML和类型脚本编译成JavaScript。这种转换发生在构建过程本身，也包括类型检查</li><li id="470b" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">Angular 9需要TypeScript 3.7。不支持任何较低版本</li><li id="5bf2" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">tslib或TypeScript运行时库现在已经成为对等依赖项，而不是直接依赖项。以前，这个库会自动安装，但是现在，你必须使用<em class="lf"> npm </em>或<em class="lf"> yarn </em>显式地添加它</li></ul><h1 id="55ee" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">有角9常春藤</h1><p id="bc01" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">Angular 9的编译和渲染引擎被称为Ivy。旧版本的Angular使用了视图引擎。视图引擎产生的包的大小非常大，但是有了Ivy，这个包的大小大大减少了，从而帮助Angular克服了它的包问题。</p><p id="9e6a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，最简单的Hello World程序大约有36Kb，对于一个简单的Hello World程序来说，这是一个相当大的包。因此，Angular团队决定保持10Kb的阈值。这被称为蛋糕阈值，因为该团队的负责人决定给团队所有的蛋糕，以防他们将包的大小减少到10Kb以下。该团队在缩小版的Ivy上成功地将包的大小减少到了7.3Kb，而在压缩版的Ivy上，包的大小甚至更小，只有2.7Kb。这确实是一个伟大的成就，他们应该得到所有的蛋糕！</p><h2 id="17e0" class="ll kd hh bd ke lm ln lo ki lp lq lr km ja ls lt kq je lu lv ku ji lw lx ky ly bi translated"><strong class="ak">使用常春藤的好处</strong></h2><ul class=""><li id="af41" class="jn jo hh ir b is la iw lb ja lz je ma ji mb jm kb jt ju jv bi translated">较小的束尺寸</li><li id="b97c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">非常有助于调试</li><li id="7085" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">带来更快的编译</li></ul><h2 id="ce3e" class="ll kd hh bd ke lm ln lo ki lp lq lr km ja ls lt kq je lu lv ku ji lw lx ky ly bi translated"><strong class="ak">常春藤如何产生更小的束尺寸？</strong></h2><p id="d8b3" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">要理解Ivy如何减少包的大小，首先需要理解视图引擎是如何工作的。当您使用视图引擎编译任何组件时，比方说example.component，您基本上会得到两个JavaScript文件。它们是example.component.js文件和example.component.ngfactory.js文件，前者由已编译的TypeScript代码组成，后者是模板代码的静态表示形式。因此，在这里，这两个文件将有一个映射，这将消耗更长的构建时间。</p><p id="a8e6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，Angular团队决定，第二个文件，即. ngfactory.js文件，可以通过在JavaScript代码本身中添加模板代码来删除。Ivy使用函数调用，而不是像视图引擎那样遍历每个元素。</p><h2 id="bd47" class="ll kd hh bd ke lm ln lo ki lp lq lr km ja ls lt kq je lu lv ku ji lw lx ky ly bi translated"><strong class="ak">有助于调试</strong></h2><p id="9734" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">有了Angular 9，您将不必通过框架进行调试，而是可以在组件本身上进行调试，这有助于您立即调试代码。</p><h2 id="e329" class="ll kd hh bd ke lm ln lo ki lp lq lr km ja ls lt kq je lu lv ku ji lw lx ky ly bi translated"><strong class="ak">更快的编译</strong></h2><p id="4671" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">以前，当您使用ng build命令时，整个应用程序会被重新编译。这是因为角度组件知道它们自身的所有依赖性。</p><p id="0b3c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，如果您的应用程序有一个包含*ngIf的组件，那么该组件也会知道这个*ngIf需要什么来编译它。因此，如果您对任何*ngIf依赖项进行更改，所有包含该*ngIf的组件都需要重新编译。结果，该团队提出了局部性原则<strong class="ir hi"> </strong>的想法，这带来了单个文件编译。包含*ngIf的组件实际上不需要知道它的依赖关系。因此，在这种情况下，如果某个组件被重新编译，就不需要重新编译任何东西，从而结束了全局重新编译。常春藤调用*ngIf的构造函数，它知道它的确切依赖关系。</p><h1 id="1ee9" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak"> AOT和艾薇</strong></h1><p id="50c7" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">AOT和常春藤一起加速了应用程序的创建。为您的项目激活AOT，打开<strong class="ir hi"> <em class="lf"> angular.json </em> </strong>文件，将<strong class="ir hi"> <em class="lf"> aot </em> </strong>设置为<strong class="ir hi"> <em class="lf"> true </em> </strong>。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/40eba8d368975c79a3cfae1b4c4561f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*-HfCpzxi9vGvZAQpiF-qew.png"/></div></figure><h1 id="1171" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">常春藤和图书馆</strong></h1><p id="52b7" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">您可以使用<em class="lf"> ngcc </em>或Angular compatibility编译器，使用视图引擎编译器的库来构建Ivy应用程序。为了高效地构建您的应用程序，您必须在每次安装第三方软件包后运行ngcc。为此，请将脚本插入package.json文件，如下所示:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/b6c02f7b628e6e9630914ba61e9e9ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9UhKIAtRTKP5-Bk9NJ1a0A.png"/></div></div></figure><p id="a6be" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每次你安装一个新的模块，将会执行<em class="lf">后安装</em>脚本。</p><p id="5b57" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lf">注意:</em> </strong> <em class="lf">如果您正在连续安装多个库，postinstall可能比允许Angular CLI在构建上运行ngcc要慢。</em></p><h1 id="4bec" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是AOT？</h1><p id="9b95" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">如前所述，Angular AOT编译器会在浏览器下载并执行代码之前，将代码的HTML和TypeScript编译成JavaScript。以下是您必须使用AOT编译器的几个原因:</p><ul class=""><li id="0ef0" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kb jt ju jv bi translated">使用AOT时，渲染速度会更快。这是因为浏览器可以下载项目的预编译版本并加载可执行代码。这有助于应用程序立即呈现，而不必先编译代码。</li><li id="4dd9" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">AOT编译器会将所有外部HTML和CSS内联到应用程序JavaScript中，从而消除对这些源文件的离散ajax请求。</li><li id="59aa" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">当应用已经被编译时，没有必要下载Angular编译器。这有助于减少正在下载的Angular框架的大小，因为编译器的大小是Angular本身的一半。</li><li id="7a2c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">Angular的AOT编译器将帮助您在构建过程中发现模板错误。</li><li id="a2c5" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">减少注入攻击，因为HTML模板在客户端呈现之前已预编译为JavaScript，从而提供了更好的安全性。</li></ul><h1 id="9551" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">JIT和AOT的区别是什么？</h1><ul class=""><li id="d25c" class="jn jo hh ir b is la iw lb ja lz je ma ji mb jm kb jt ju jv bi translated">AOT加载应用程序比JIT编译器快得多，因为JIT在运行时编译应用程序。</li><li id="ecfd" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">与JIT编译器不同，AOT根本不需要下载编译器。</li><li id="023c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">JIT产生的包大小会大得多，因为它也包含编译器代码。</li><li id="2fa5" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">在AOT的情况下，模板绑定错误可以在构建时被检测到，这与JIT不同，JIT在显示应用程序时才发现模板错误。</li></ul><h1 id="9f14" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用AOT</h1><p id="246b" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">当您使用ng serve或ng build时，JIT编译器将开始运行。要使用<strong class="ir hi"> AOT </strong>编译器，您可以使用带有-aot扩展名的相同命令，如下所示:</p><ul class=""><li id="888e" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kb jt ju jv bi translated">ng serve-AOT//建造和服务</li><li id="694e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kb jt ju jv bi translated">ng构建-AOT//要构建</li></ul><h1 id="1640" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">AOT的工作</h1><p id="3f47" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">AOT通过使用在@Component、@Input decorators或构造函数中指定的元数据来解释应用程序。AOT编译器将获取所有元数据，然后为其生成一个工厂。例如，如果您有一个组件，如下所示:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mi"><img src="../Images/4d5ec1f99c8aea774813e3d0b9e9baa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LpjstAtQffxM7HQIfmdOg.png"/></div></div></figure><p id="6127" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Angular的AOT编译器将一次性提取DashboardComponent的所有元数据，然后创建一个工厂。每当要创建这个类的实例时，AOT编译器将调用产生可视元素的工厂。这将被绑定到目标组件类的一个新实例，并注入依赖项。</p><h2 id="6c7d" class="ll kd hh bd ke lm ln lo ki lp lq lr km ja ls lt kq je lu lv ku ji lw lx ky ly bi translated">编译阶段</h2><p id="fb11" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">AOT编译器分三个阶段编译应用程序:</p><ol class=""><li id="23df" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi">代码分析<br/> </strong>在这个阶段，AOT收集器将收集元数据，分析语法，并以尽可能好的方式表示它。元数据语法中的任何错误都将被记录，并且不会有元数据解释</li><li id="2443" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">代码生成<br/> </strong>这里，收集的元数据将由编译器的<em class="lf"> StaticReflector </em>进行解释，并且还将再次检查元数据验证。如果有任何违反，将抛出一个错误</li><li id="6a65" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">模板类型检查<br/> </strong>这是一个可选阶段，Angulars的模板编译器利用TypeScript编译器来检查模板中绑定表达式的有效性。如果您希望启用此功能，您可以将<strong class="ir hi"> fullTemplateTypeCheck </strong>配置选项设置为true，如下所示:</li></ol><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es mj"><img src="../Images/25721a38e0187cc5016de623618c939f.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*L2MKJ4ZO15qzh_qV_Ub4cA.png"/></div></figure><p id="cc51" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您正在寻找角度更新，请查看以下链接:<a class="ae mk" href="https://update.angular.io/#8.0:9.0" rel="noopener ugc nofollow" target="_blank">角度更新路径</a></p><p id="2c1b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就把我们带到了这篇关于AngularJS Bootstrap的文章的结尾。如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，你可以参考<a class="ae mk" href="https://www.edureka.co/blog/?utm_source=medium&amp;utm_medium=content-link&amp;utm_campaign=angular9" rel="noopener ugc nofollow" target="_blank"> Edureka的官方网站。</a></p><p id="6847" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释Web开发的各个方面。</p><blockquote class="ml mm mn"><p id="7435" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 1。</em> <a class="ae mk" rel="noopener" href="/edureka/reactjs-tutorial-aa087fd7fc90"> <em class="hh"> ReactJS教程</em> </a></p><p id="dbc0" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 2。</em> <a class="ae mk" rel="noopener" href="/edureka/react-components-65dc1d753af5"> <em class="hh">反应元件</em> </a></p><p id="dc19" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 3。</em> <a class="ae mk" rel="noopener" href="/edureka/react-router-2aab4e781736"> <em class="hh"> React路由器v4教程</em> </a></p><p id="0c7b" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 4。</em> <a class="ae mk" rel="noopener" href="/edureka/react-redux-tutorial-2b3d81cfd3f7"> <em class="hh"> React Redux教程</em> </a></p><p id="60ea" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 5。</em> <a class="ae mk" rel="noopener" href="/edureka/angular-tutorial-for-beginners-4738ce387b03"> <em class="hh">棱角教程</em> </a></p><p id="33f2" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 6。</em> <a class="ae mk" rel="noopener" href="/edureka/angular-directive-tutorial-3b203de7948a"> <em class="hh">角度指令教程</em> </a></p><p id="2621" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 7。</em> <a class="ae mk" rel="noopener" href="/edureka/animating-angularjs-apps-with-nganimate-directive-510500755b76"> <em class="hh">用ngAnimate指令</em> </a>制作AngularJS应用程序动画</p><p id="9a7d" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 8。</em> <a class="ae mk" rel="noopener" href="/edureka/php-tutorial-beginners-guide-to-php-f78a189de6f"> <em class="hh"> PHP教程</em> </a></p><p id="b776" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 9。</em> <a class="ae mk" rel="noopener" href="/edureka/jquery-tutorial-for-beginners-679021d74ab4"> <em class="hh"> JQuery教程</em> </a></p><p id="5e6b" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 10。</em> <a class="ae mk" rel="noopener" href="/edureka/node-js-tutorial-800e03bc596b"> <em class="hh"> NodeJS教程</em> </a></p><p id="570d" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 11。</em> <a class="ae mk" rel="noopener" href="/edureka/top-10-javascript-frameworks-3179f1b5bd41"> <em class="hh">十大JavaScript框架</em> </a></p><p id="0658" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 12。</em> <a class="ae mk" rel="noopener" href="/edureka/node-js-mysql-tutorial-cef7452f2762"> <em class="hh">使用Node.js和MySQL </em> </a>构建CRUD应用程序</p><p id="362b" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 13。</em> <a class="ae mk" rel="noopener" href="/edureka/node-js-mongodb-tutorial-fa80b60fb20c"> <em class="hh">使用节点构建CRUD应用程序。JS和MongoDB </em> </a></p><p id="6bf3" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 14。</em> <a class="ae mk" rel="noopener" href="/edureka/rest-api-with-node-js-b245e345f7a5"> <em class="hh">用Node.js </em> </a>构建REST API</p><p id="e320" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 15。</em> <a class="ae mk" rel="noopener" href="/edureka/node-js-requests-6b94862307a2"> <em class="hh">制作Node.js请求的最佳3种方式</em> </a></p><p id="d9a1" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 16。</em><a class="ae mk" rel="noopener" href="/edureka/html-vs-html5-83302f95652e"><em class="hh">HTML vs HTML 5</em></a></p><p id="26d4" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 17。</em> <a class="ae mk" rel="noopener" href="/edureka/what-is-rest-api-d26ea9000ee6"> <em class="hh">什么是REST API？</em>T101】</a></p><p id="a6e7" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 18。</em> <a class="ae mk" rel="noopener" href="/edureka/flutter-vs-react-native-58133fbf9f33"> <em class="hh">颤振vs反应原生</em> </a></p><p id="851e" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated"><em class="hh"> 19。</em> <a class="ae mk" rel="noopener" href="/edureka/node-js-docker-tutorial-72e7542d69d8"> <em class="hh">如何对Node.js App进行Dockerize？</em>T113】</a></p><p id="1cde" class="ip iq lf ir b is it iu iv iw ix iy iz mo jb jc jd mp jf jg jh mq jj jk jl jm ha bi translated">20.<a class="ae mk" rel="noopener" href="/edureka/angularjs-bootstrap-18402208bce1"><em class="hh"/></a></p></blockquote></div><div class="ab cl mr ms go mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ha hb hc hd he"><p id="6622" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">【https://www.edureka.co】原载于2020年2月14日<a class="ae mk" href="https://www.edureka.co/blog/angular-9/" rel="noopener ugc nofollow" target="_blank"><em class="lf"/></a><em class="lf">。</em></p></div></div>    
</body>
</html>