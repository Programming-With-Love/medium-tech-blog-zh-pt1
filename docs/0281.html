<html>
<head>
<title>Android Data Binding: List Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android数据绑定:列举技巧</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/android-data-binding-list-tricks-ef3d5630555e?source=collection_archive---------0-----------------------#2017-02-22">https://medium.com/androiddevelopers/android-data-binding-list-tricks-ef3d5630555e?source=collection_archive---------0-----------------------#2017-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/a906e467ca5488e10909fee9a1ec3fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ftl2kzvQbFvxk65lFSSZng.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="d6f6" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">对于那些小小的视图列表</h2></div><p id="0c43" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我在想以前的一篇文章，在那篇文章中<a class="ae kd" rel="noopener" href="/google-developers/android-data-binding-recyclerview-db7c40d9f0e4#.mhdx00m3r">我写了使用Android数据绑定和recycle view</a>。如果您有一个元素列表，但并不真正需要RecyclerView来处理它，该怎么办？毕竟，如果你只打算在屏幕上展示三到四种元素，而且它们永远不会被回收，那么就没有必要拿出大家伙。</p><p id="3653" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">开发人员通常会遍历他们的条目并手动创建视图:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="1661" class="kn ko hs kj b fi kp kq l kr ks"><strong class="kj ht">for </strong>(Account item : items) {<br/>    ItemBinding itemBinding =<br/>        ItemBinding.<em class="kt">inflate</em>(getLayoutInflater(), parent, <strong class="kj ht">true</strong>);<br/>    itemBinding.setData(item);<br/>}</span></pre><p id="1d01" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这很简单。如果我们可以绑定到XML中的列表，那不是很好吗？类似这样的事情会很棒:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="455d" class="kn ko hs kj b fi kp kq l kr ks">&lt;<strong class="kj ht">LinearLayout<br/>    app:entries="@{entries}"<br/>    app:layout="@{@layout/item}"<br/>    ...</strong>/&gt;</span></pre><h2 id="bfbe" class="kn ko hs bd ku kv kw kx ky kz la lb lc jq ld le lf ju lg lh li jy lj lk ll lm bi translated">简单列表绑定适配器</h2><p id="046f" class="pw-post-body-paragraph jh ji hs jj b jk ln it jm jn lo iw jp jq lp js jt ju lq jw jx jy lr ka kb kc ha bi translated">我想使用条目列表在LinearLayout中创建视图，并将这些视图绑定到列表中的值。每个不同的布局都有自己生成的绑定类，所以如果我想做一个通用的绑定适配器，我不能只调用普通的setter。我当然不想使用反射——它的成本很高。相反，<a class="ae kd" rel="noopener" href="/google-developers/android-data-binding-recyclerview-db7c40d9f0e4#.mhdx00m3r">就像使用RecyclerView </a>一样，我们可以使用<em class="kt">约定</em>来解决问题。</p><p id="6780" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们将使用只有一个变量的约定，并且该变量总是被命名为某个一致的值。无论列表中有什么，布局都只有一个名为“data”的变量然后，我们可以使用ViewDataBinding.setVariable()方法来绑定布局中的数据。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="3d94" class="kn ko hs kj b fi kp kq l kr ks">@BindingAdapter({<strong class="kj ht">"entries"</strong>, <strong class="kj ht">"layout"</strong>})<br/><strong class="kj ht">public static </strong>&lt;T&gt; <strong class="kj ht">void </strong>setEntries(ViewGroup viewGroup,<br/>                                  List&lt;T&gt; entries, <strong class="kj ht">int </strong>layoutId) {<br/>    viewGroup.removeAllViews();<br/>    <strong class="kj ht">if </strong>(entries != <strong class="kj ht">null</strong>) {<br/>        LayoutInflater inflater = (LayoutInflater)<br/>            viewGroup.getContext()      <br/>                .getSystemService(Context.<strong class="kj ht"><em class="kt">LAYOUT_INFLATER_SERVICE</em></strong>);<br/>        <strong class="kj ht">for </strong>(<strong class="kj ht">int </strong>i = 0; i &lt; entries.size(); i++) {<br/>            T entry = entries.get(i);<br/>            ViewDataBinding binding = DataBindingUtil<br/>                .<em class="kt">inflate</em>(inflater, layoutId, viewGroup, <strong class="kj ht">true</strong>);<br/>            binding.setVariable(BR.<strong class="kj ht"><em class="kt">data</em></strong>, entry);<br/>        }<br/>    }<br/>}</span></pre><p id="eb6c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">你可以像这样把它绑定到你的视图组:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="6bcf" class="kn ko hs kj b fi kp kq l kr ks">&lt;<strong class="kj ht">LinearLayout<br/>    app:entries="@{entries}"<br/>    app:layout="@{@layout/item}"<br/>    ...</strong>/&gt;</span></pre><p id="0960" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">上面的LinearLayout将使用item.xml布局自动添加子元素，并将“data”变量设置为条目中的条目。这可用于addView()足以管理子视图的任何视图组。</p><h2 id="4f49" class="kn ko hs bd ku kv kw kx ky kz la lb lc jq ld le lf ju lg lh li jy lj lk ll lm bi translated">动态列表</h2><p id="b17b" class="pw-post-body-paragraph jh ji hs jj b jk ln it jm jn lo iw jp jq lp js jt ju lq jw jx jy lr ka kb kc ha bi translated">上面的绑定适配器非常适合静态列表，但是如果您的列表动态地改变了呢？也许用户添加了一个新选项，该选项必须添加到单选按钮列表中。ObservableList让我们能够观察变化并做出反应。我们使用OnListChangedCallback来观察列表的变化:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="98a7" class="kn ko hs kj b fi kp kq l kr ks">@BindingAdapter({<strong class="kj ht">"entries"</strong>, <strong class="kj ht">"layout"</strong>})<br/><strong class="kj ht">public static </strong>&lt;T&gt; <strong class="kj ht">void </strong>setEntries(ViewGroup viewGroup,<br/>        ObservableList&lt;T&gt; oldEntries, <strong class="kj ht">int </strong>oldLayoutId,<br/>        ObservableList&lt;T&gt; newEntries, <strong class="kj ht">int </strong>newLayoutId) {<br/>    <strong class="kj ht">if </strong>(oldEntries == newEntries &amp;&amp; oldLayoutId == newLayoutId) {<br/>        <strong class="kj ht">return</strong>; <em class="kt">// nothing has changed<br/>    </em>}<br/><br/>    EntryChangeListener listener =<br/>            ListenerUtil.<em class="kt">getListener</em>(viewGroup, R.id.<strong class="kj ht"><em class="kt">entryListener</em></strong>);<br/>    <strong class="kj ht">if </strong>(oldEntries != newEntries &amp;&amp; listener != <strong class="kj ht">null</strong>) {<br/>        oldEntries.removeOnListChangedCallback(listener);<br/>    }<br/><br/>    <strong class="kj ht">if </strong>(newEntries == <strong class="kj ht">null</strong>) {<br/>        viewGroup.removeAllViews();<br/>    } <strong class="kj ht">else </strong>{<br/>        <strong class="kj ht">if </strong>(listener == <strong class="kj ht">null</strong>) {<br/>            listener =<br/>                    <strong class="kj ht">new </strong>EntryChangeListener(viewGroup, newLayoutId);<br/>            ListenerUtil.<em class="kt">trackListener</em>(viewGroup, listener,<br/>                    R.id.<strong class="kj ht"><em class="kt">entryListener</em></strong>);<br/>        } <strong class="kj ht">else </strong>{<br/>            listener.setLayoutId(newLayoutId);<br/>        }<br/>        <strong class="kj ht">if </strong>(newEntries != oldEntries) {<br/>            newEntries.addOnListChangedCallback(listener);<br/>        }<br/>        <em class="kt">resetViews</em>(viewGroup, newLayoutId, newEntries);<br/>    }<br/>}</span></pre><p id="f6d4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">setEntries()绑定适配器中有几件事情值得注意。首先，我使用数据绑定的特性，该特性允许我获取旧值和新值。通过提供两倍于属性的数据参数，第一组参数接收旧值，第二组接收新值。我用它来从旧条目列表中删除侦听器。</p><p id="657b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">其次，Android数据绑定通常会监视列表的变化，当发生变化时，它会重新计算表达式。我想管理绑定适配器中的更改，这样当没有实例更改发生时，它不会做任何事情。我使用ListenerUtil跟踪EntryChangeListener，一个OnListChangedCallback。ListenerUtil跟踪侦听器，以便可以在调用之间检索它，我使用它，以便可以删除或修改旧的侦听器，并可能将它添加到新列表中。我需要提供一个标识符作为键，所以我创建了一个:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="c9c9" class="kn ko hs kj b fi kp kq l kr ks">&lt;<strong class="kj ht">resources</strong>&gt;<br/>    &lt;<strong class="kj ht">item type="id" name="entryListener"</strong>/&gt;<br/>&lt;/<strong class="kj ht">resources</strong>&gt;</span></pre><p id="c35e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">第三，setEntries()依赖EntryChangeListener在只有数据更改时更新子视图。否则，它将完全替换子视图。例如，如果布局ID改变，我们丢弃旧的子元素，然后重新填充整个元素。</p><p id="fa6d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">除此之外，它相当简单。以下是它使用的其他方法:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="c305" class="kn ko hs kj b fi kp kq l kr ks"><strong class="kj ht">private static </strong>ViewDataBinding bindLayout(LayoutInflater inflater,<br/>        ViewGroup parent, <strong class="kj ht">int </strong>layoutId, Object entry) {<br/>    ViewDataBinding binding = DataBindingUtil.<em class="kt">inflate</em>(inflater,<br/>            layoutId, parent, <strong class="kj ht">false</strong>);<br/>    binding.setVariable(BR.<strong class="kj ht"><em class="kt">data</em></strong>, entry);<br/>    <strong class="kj ht">return </strong>binding;<br/>}<br/><br/><strong class="kj ht">private static void </strong>resetViews(ViewGroup parent, <strong class="kj ht">int </strong>layoutId,<br/>        List entries) {<br/>    parent.removeAllViews();<br/>    <strong class="kj ht">if </strong>(layoutId == 0) {<br/>        <strong class="kj ht">return</strong>;<br/>    }<br/>    LayoutInflater inflater = (LayoutInflater) parent.getContext()<br/>            .getSystemService(Context.<strong class="kj ht"><em class="kt">LAYOUT_INFLATER_SERVICE</em></strong>);<br/>    <strong class="kj ht">for </strong>(<strong class="kj ht">int </strong>i = 0; i &lt; entries.size(); i++) {<br/>        Object entry = entries.get(i);<br/>        ViewDataBinding binding = <em class="kt">bindLayout</em>(inflater, parent,<br/>                layoutId, entry);<br/>        parent.addView(binding.getRoot());<br/>    }<br/>}</span></pre><p id="882f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这些基本上完成了原始绑定适配器中的工作。resetViews()方法首先从ViewGroup中删除所有视图，然后膨胀视图并绑定列表中的数据。</p><p id="98c6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您可以拥有一个简单的EventChangeListener，它每次都会重置视图:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="9ecf" class="kn ko hs kj b fi kp kq l kr ks"><strong class="kj ht">private static class </strong>EntryChangeListener<br/>            <strong class="kj ht">extends </strong>ObservableList.OnListChangedCallback {<br/>    <strong class="kj ht">private final </strong>ViewGroup <strong class="kj ht">mTarget</strong>;<br/>    <strong class="kj ht">private int mLayoutId</strong>;<br/><br/>    <strong class="kj ht">public </strong>EntryChangeListener(ViewGroup target, <strong class="kj ht">int </strong>layoutId) {<br/>        <strong class="kj ht">mTarget </strong>= target;<br/>        <strong class="kj ht">mLayoutId </strong>= layoutId;<br/>    }<br/><br/>    <strong class="kj ht">public void </strong>setLayoutId(<strong class="kj ht">int </strong>layoutId) {<br/>        <strong class="kj ht">mLayoutId </strong>= layoutId;<br/>    }<br/><br/>    @Override<br/>    <strong class="kj ht">public void </strong>onChanged(ObservableList observableList) {<br/>        <em class="kt">resetViews</em>(<strong class="kj ht">mTarget</strong>, <strong class="kj ht">mLayoutId</strong>, observableList);<br/>    }<br/><br/>    @Override<br/>    <strong class="kj ht">public void </strong>onItemRangeChanged(ObservableList observableList,<br/>                                   <strong class="kj ht">int </strong>start, <strong class="kj ht">int </strong>count) {<br/>        <em class="kt">resetViews</em>(<strong class="kj ht">mTarget</strong>, <strong class="kj ht">mLayoutId</strong>, observableList);<br/>    }<br/><br/>    @Override<br/>    <strong class="kj ht">public void </strong>onItemRangeInserted(ObservableList observableList,<br/>                                    <strong class="kj ht">int </strong>start, <strong class="kj ht">int </strong>count) {<br/>        <em class="kt">resetViews</em>(<strong class="kj ht">mTarget</strong>, <strong class="kj ht">mLayoutId</strong>, observableList);<br/>    }<br/><br/>    @Override<br/>    <strong class="kj ht">public void </strong>onItemRangeMoved(ObservableList observableList,<br/>                                 <strong class="kj ht">int </strong>from, <strong class="kj ht">int </strong>to, <strong class="kj ht">int </strong>count) {<br/>        <em class="kt">resetViews</em>(<strong class="kj ht">mTarget</strong>, <strong class="kj ht">mLayoutId</strong>, observableList);<br/>    }<br/><br/>    @Override<br/>    <strong class="kj ht">public void </strong>onItemRangeRemoved(ObservableList observableList,<br/>                                   <strong class="kj ht">int </strong>start, <strong class="kj ht">int </strong>count) {<br/>        <em class="kt">resetViews</em>(<strong class="kj ht">mTarget</strong>, <strong class="kj ht">mLayoutId</strong>, observableList);<br/>    }<br/>}</span></pre><p id="b8fd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">老实说，对于大多数用例来说，这可能已经足够好了。你不应该对大量的视图使用它——这就是RecyclerView的用途。然而，如果我想在发生变化时激活视图，我希望更好地处理变化事件。您可能会考虑这样的变更监听器:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="0d8b" class="kn ko hs kj b fi kp kq l kr ks">@Override<br/><strong class="kj ht">public void </strong>onItemRangeChanged(ObservableList observableList,<br/>                               <strong class="kj ht">int </strong>start, <strong class="kj ht">int </strong>count) {<br/>    TransitionManager.<em class="kt">beginDelayedTransition</em>(<strong class="kj ht">mTarget</strong>);<br/>    <strong class="kj ht">final int </strong>end = start + count;<br/>    <strong class="kj ht">for </strong>(<strong class="kj ht">int </strong>i = start; i &lt; end; i++) {<br/>        Object data = observableList.get(i);<br/>        View view = <strong class="kj ht">mTarget</strong>.getChildAt(i);<br/>        ViewDataBinding binding = DataBindingUtil.<em class="kt">getBinding</em>(view);<br/>        binding.setVariable(BR.<strong class="kj ht"><em class="kt">data</em></strong>, data);<br/>    }<br/>}</span></pre><p id="31f5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">它只是重新绑定当前视图中的数据。不幸的是，如果我们有非常智能的转换，这可能行得通，但是当数据改变时，默认的转换不知道做什么。相反，我们必须实际替换视图:</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="5480" class="kn ko hs kj b fi kp kq l kr ks">@Override<br/><strong class="kj ht">public void </strong>onItemRangeChanged(ObservableList observableList,<br/>                               <strong class="kj ht">int </strong>start, <strong class="kj ht">int </strong>count) {<br/>    LayoutInflater inflater = (LayoutInflater) <strong class="kj ht">mTarget</strong>.getContext()<br/>            .getSystemService(Context.<strong class="kj ht"><em class="kt">LAYOUT_INFLATER_SERVICE</em></strong>);<br/>    TransitionManager.<em class="kt">beginDelayedTransition</em>(<strong class="kj ht">mTarget</strong>);<br/>    <strong class="kj ht">final int </strong>end = start + count;<br/>    <strong class="kj ht">for </strong>(<strong class="kj ht">int </strong>i = start; i &lt; end; i++) {<br/>        Object data = observableList.get(i);<br/>        ViewDataBinding binding = <em class="kt">bindLayout</em>(inflater, <br/>            <strong class="kj ht">mTarget</strong>, <strong class="kj ht">mLayoutId</strong>, data);<br/>        binding.setVariable(BR.<strong class="kj ht"><em class="kt">data</em></strong>, observableList.get(i));<br/>        <strong class="kj ht">mTarget</strong>.removeViewAt(i);<br/>        <strong class="kj ht">mTarget</strong>.addView(binding.getRoot(), i);<br/>    }<br/>}</span></pre><p id="a217" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，当视图改变时，我们可以看到一个很好的淡出和淡入效果。其余实现的方法相当简单，使用TransitionManager来激活视图。</p><pre class="ke kf kg kh fd ki kj kk kl aw km bi"><span id="e449" class="kn ko hs kj b fi kp kq l kr ks">@Override<br/><strong class="kj ht">public void </strong>onItemRangeInserted(ObservableList observableList,<br/>                                <strong class="kj ht">int </strong>start, <strong class="kj ht">int </strong>count) {<br/>    TransitionManager.<em class="kt">beginDelayedTransition</em>(<strong class="kj ht">mTarget</strong>);<br/>    <strong class="kj ht">final int </strong>end = start + count;<br/>    LayoutInflater inflater = (LayoutInflater) <strong class="kj ht">mTarget</strong>.getContext()<br/>            .getSystemService(Context.<strong class="kj ht"><em class="kt">LAYOUT_INFLATER_SERVICE</em></strong>);<br/>    <strong class="kj ht">for </strong>(<strong class="kj ht">int </strong>i = end - 1; i &gt;= start; i--) {<br/>        Object entry = observableList.get(i);<br/>        ViewDataBinding binding =<br/>            <em class="kt">bindLayout</em>(inflater, <strong class="kj ht">mTarget</strong>, <strong class="kj ht">mLayoutId</strong>, entry);<br/>        <strong class="kj ht">mTarget</strong>.addView(binding.getRoot(), start);<br/>    }<br/>}<br/><br/>@Override<br/><strong class="kj ht">public void </strong>onItemRangeMoved(ObservableList observableList,<br/>                             <strong class="kj ht">int </strong>from, <strong class="kj ht">int </strong>to, <strong class="kj ht">int </strong>count) {<br/>    TransitionManager.<em class="kt">beginDelayedTransition</em>(<strong class="kj ht">mTarget</strong>);<br/>    <strong class="kj ht">for </strong>(<strong class="kj ht">int </strong>i = 0; i &lt; count; i++) {<br/>        View view = <strong class="kj ht">mTarget</strong>.getChildAt(from);<br/>        <strong class="kj ht">mTarget</strong>.removeViewAt(from);<br/>        <strong class="kj ht">int </strong>destination = (from &gt; to) ? to + i : to;<br/>        <strong class="kj ht">mTarget</strong>.addView(view, destination);<br/>    }<br/>}<br/><br/>@Override<br/><strong class="kj ht">public void </strong>onItemRangeRemoved(ObservableList observableList,<br/>                               <strong class="kj ht">int </strong>start, <strong class="kj ht">int </strong>count) {<br/>    TransitionManager.<em class="kt">beginDelayedTransition</em>(<strong class="kj ht">mTarget</strong>);<br/>    <strong class="kj ht">for </strong>(<strong class="kj ht">int </strong>i = 0; i &lt; count; i++) {<br/>        <strong class="kj ht">mTarget</strong>.removeViewAt(start);<br/>    }<br/>}</span></pre><h2 id="3d2c" class="kn ko hs bd ku kv kw kx ky kz la lb lc jq ld le lf ju lg lh li jy lj lk ll lm bi translated">考虑</h2><p id="cee2" class="pw-post-body-paragraph jh ji hs jj b jk ln it jm jn lo iw jp jq lp js jt ju lq jw jx jy lr ka kb kc ha bi translated">您可能会尝试使用列表绑定技术，而不是RecyclerView。<em class="kt">不要</em>。数据绑定列表不能替代RecyclerView。相反，使用它来绑定到一小部分在布局中可见的视图。一个好的经验是，如果你必须滚动列表，使用RecyclerView。如果没有，就使用数据绑定。</p><p id="dbb4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我最初使用的例子只有四行代码，但我不知何故制作了一个将近150行代码的绑定适配器。但是现在已经写好了，我可以在应用程序的任何地方使用它来填充我的小型数据驱动UI列表。它甚至会随着值的变化而变化，我永远不用担心直接更新视图。现在你也不用担心了。</p><p id="5c4f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">你可以在这里看到<a class="ae kd" href="https://github.com/google/android-ui-toolkit-demos" rel="noopener ugc nofollow" target="_blank"> DataBoundList项目中的代码。在这个项目中，用户在列表中被添加和删除，它动态地更新一个LinearLayout。您永远不会将它用于用户列表，因为它很容易滚动。这意味着您应该使用RecyclerView，但这只是一个演示。我希望您会发现这种方法对于在应用程序中将列表绑定到视图组非常有用。</a></p><figure class="ke kf kg kh fd hj er es paragraph-image"><div class="er es ls"><img src="../Images/e5ef478211b858c2fc7a54754a5f01b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/1*74JuPcuDp8-VfUV3zHzbRw.gif"/></div><figcaption class="lt lu et er es lv lw bd b be z dx">Sample Project Showing Data Bound LinearLayout to an ObservableList</figcaption></figure></div></div>    
</body>
</html>