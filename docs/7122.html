<html>
<head>
<title>Building Portable Binaries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建可移植的二进制文件</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/building-portable-binaries-50ca4f3d75cd?source=collection_archive---------1-----------------------#2015-06-15">https://medium.com/square-corner-blog/building-portable-binaries-50ca4f3d75cd?source=collection_archive---------1-----------------------#2015-06-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="75bd" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">尝试自包含应用程序依赖项</h2></div><p id="890d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">由</em> <a class="ae jt" href="https://twitter.com/alexcoomans" rel="noopener ugc nofollow" target="_blank"> <em class="js">亚历克斯·库曼斯</em> </a> <em class="js">撰写。</em></p><blockquote class="ju"><p id="eea9" class="jv jw hh bd jx jy jz ka kb kc kd jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jt" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="f426" class="pw-post-body-paragraph iw ix hh iy b iz ke ii jb jc kf il je jf kg jh ji jj kh jl jm jn ki jp jq jr ha bi translated">部署您的代码是向用户展示全新功能或重要缺陷修复的最后一个主要障碍。然而，确保您的应用程序拥有它所需要的一切可能是一件苦差事。准备应用程序进行部署的三种典型方法是:</p><ol class=""><li id="93f9" class="kj kk hh iy b iz ja jc jd jf kl jj km jn kn jr ko kp kq kr bi translated">在运行时系统范围内安装依赖项</li><li id="df26" class="kj kk hh iy b iz ks jc kt jf ku jj kv jn kw jr ko kp kq kr bi translated">通过应用程序交付依赖项，并依赖系统运行时</li><li id="2c48" class="kj kk hh iy b iz ks jc kt jf ku jj kv jn kw jr ko kp kq kr bi translated">应用程序附带运行时和依赖项</li></ol><p id="b6d1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这篇文章将讨论第三种方法。但是首先，我将指出我们在方法一和方法二中遇到的一些问题，以及这两个选项是如何将我们推向第三个选项的。</p><p id="2c1c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于选项一和选项二，你的应用程序依赖系统来提供一些东西。通常情况下，这是很好的，但是想象一下，如果你碰巧升级了你的操作系统，它包括了对你的运行时的更新。例如，Python出现在许多Linux机器上。您可能刚刚损坏了您的应用程序并导致停机。使用选项一，您可能还会丢失所有系统依赖项。即使您尝试重新安装它们，它们也可能无法与较新的运行时一起工作。</p><p id="128e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们以前见过这种情况，当操作系统升级破坏了一些依赖于系统二进制文件的服务时。这些服务使用的是旧的MySQL共享对象，在操作系统升级后消失了。因此，我们寻找一个更好的解决方案:选项3。</p><h1 id="8489" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">为什么不用X？</h1><p id="3917" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">在寻找解决方案时，我们没有找到任何能够以我们需要的方式完全隔离运行时和依赖项的东西。相反，我们转向了两个众所周知的——尽管有些晦涩Linux栈的部分:<a class="ae jt" href="http://en.wikipedia.org/wiki/Shebang_(Unix)" rel="noopener ugc nofollow" target="_blank"> shebangs </a>和<a class="ae jt" href="http://wikipedia.org/wiki/Rpath" rel="noopener ugc nofollow" target="_blank"> rpaths </a>。</p><p id="5dbe" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Shebangs是以#开头的第一行脚本，比如/bin/bash或/usr/bin/env ruby！。内核读取#！并用这个解释器执行脚本。</p><p id="d52f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">rpath是共享库的运行时搜索路径，被硬编码到编译后的二进制文件的头中。这允许二进制代码搜索自身的其他部分或核心内容，如提供核心C标准库的<a class="ae jt" href="http://en.wikipedia.org/wiki/C_standard_library" rel="noopener ugc nofollow" target="_blank"> libc </a>。</p><p id="4ddf" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所有这些工作都始于一个简单的需求，即修复一个应用程序，该应用程序依赖于系统来提供它的所有依赖项，并在部署到新机器时发生故障。虽然Virtualenv作为一种解决方案出现，但它对Python安装问题没有帮助。结果，一旦我有了一个可重定位的Python，我就像普通的那样安装了依赖项——因此Virtualenv不会提供任何额外的东西。</p><h1 id="3588" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">舍邦</h1><p id="9fde" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">shebangs最大的缺点是它们不支持相对于二进制位置的相对路径。您需要硬编码一个系统路径，或者在执行时使用一个相对于当前工作目录的路径。第一个选项在重定位二进制文件时不起作用，第二个选项也不起作用，因为它要求您将cd放入正确的目录。</p><p id="1855" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是我编译的一个Python版本中的pip shim示例:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="6486" class="md ky hh lz b fi me mf l mg mh">#!/home/vagrant/python/bin/python<br/># EASY-INSTALL-ENTRY-SCRIPT: 'pip==1.3.1','console_scripts','pip'<br/>__requires__ = 'pip==1.3.1'<br/>import sys<br/>from pkg_resources import load_entry_point</span><span id="d8d0" class="md ky hh lz b fi mi mf l mg mh">if __name__ == '__main__':<br/>    sys.exit(<br/>        load_entry_point('pip==1.3.1', 'console_scripts', 'pip')()<br/>    )</span></pre><p id="877e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你会注意到#！/home/vagger/python/bin/Python she bang，如果我将Python二进制文件移到别处，它会失败。</p><p id="4d05" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">某些语言支持使这个问题更容易解决的技巧。例如，很久以前内核不支持shebangs所以，你必须确保你在运行你的解释器。受这些工作的启发(经过反复试验)，我想到了以下方法:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="620a" class="md ky hh lz b fi me mf l mg mh">#!/bin/bash -e<br/>"eval" '$(cd `dirname $0`; pwd)/python $(cd `dirname $0`; pwd)/$(basename $0) "$@" &amp;&amp; exit 0'<br/># python code</span></pre><p id="2db7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Python中执行时，相邻的字符串被简单地连接在一起，充当一个空操作。但是在Bash中，它是作为代码执行的，整个引用部分被视为eval的一个参数——这正是我们需要的。</p><p id="6c1d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于它期望参数的方式，我不得不使用eval和exit 0命令与-e标志配对，而不是exec，因为否则您会得到如下命令:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="ed3e" class="md ky hh lz b fi me mf l mg mh">"/home/vagrant/python/bin/python /home/vagrant/python/bin/pip"</span></pre><p id="199b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">棘手的是，在参数名称中，空格被视为文字空格，但在打印时，它与正确的参数集没有什么不同:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="3f7e" class="md ky hh lz b fi me mf l mg mh">"/home/vagrant/python/bin/python" "/home/vagrant/python/bin/pip"</span></pre><p id="0c64" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">单引号是最后一部分，我花了一段时间来纠正，以便$@(即脚本的参数)被正确传递。</p><h1 id="22cf" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">RPATH</h1><p id="3d12" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">可执行文件的rpath是程序中的一个头，它帮助链接器在运行时找到所需的共享对象。共享对象是一组编译后的代码，旨在在一组不同的二进制文件之间共享。Libc是共享对象的最好例子，因为几乎所有东西都需要它。以下是/bin/bash的一些头文件示例:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="f7ab" class="md ky hh lz b fi me mf l mg mh">$ readelf -d /bin/bash<br/>Dynamic section at offset 0xd3738 contains 26 entries:<br/>  Tag        Type                         Name/Value<br/> 0x0000000000000001 (NEEDED)             Shared library: [libtinfo.so.5]<br/> 0x0000000000000001 (NEEDED)             Shared library: [libdl.so.2]<br/> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]<br/>(other header information)</span></pre><p id="6d8f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您会注意到bash需要libc、libdl和libtinfo。在那个二进制文件上运行ldd会给出链接器完成的依赖关系解析的准确位置:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="617c" class="md ky hh lz b fi me mf l mg mh">$ ldd /bin/bash<br/>    linux-vdso.so.1 =&gt;  (0x00007fff463ff000)<br/>    libtinfo.so.5 =&gt; /lib64/libtinfo.so.5 (0x0000003415400000)<br/>    libdl.so.2 =&gt; /lib64/libdl.so.2 (0x0000003412c00000)<br/>    libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003413000000)<br/>    /lib64/ld-linux-x86-64.so.2 (0x0000003412800000)</span></pre><p id="57b3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">ldd将报告它找到的共享对象的位置，但是它忽略rpath(如果存在的话)。bash不使用rpath，但是这里有一个Python的例子，我们将很快编译它来帮助实现第三个选项(即，将运行时和依赖项与应用一起发布):</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="5807" class="md ky hh lz b fi me mf l mg mh">$ readelf -d /example/python/bin/python<br/>Dynamic section at offset 0x8f0 contains 26 entries:<br/>  Tag        Type                         Name/Value<br/> 0x0000000000000001 (NEEDED)             Shared library: [libpython2.7.so.1.0]<br/> 0x0000000000000001 (NEEDED)             Shared library: [libpthread.so.0]<br/> 0x0000000000000001 (NEEDED)             Shared library: [libdl.so.2]<br/> 0x0000000000000001 (NEEDED)             Shared library: [libutil.so.1]<br/> 0x0000000000000001 (NEEDED)             Shared library: [libm.so.6]<br/> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]<br/> 0x000000000000000f (RPATH)              Library rpath: [$ORIGIN/../lib]</span></pre><p id="d90e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意RPATH行吗？这就是允许我们重新定位二进制文件的魔力。这对Python尤其重要，因为二进制文件需要一个共享对象。$ORIGIN变量也非常重要，因为它允许您创建相对于二进制文件的路径。在这种情况下，Python应该在/example/lib中查找共享对象，以及默认的链接器位置。<a class="ae jt" href="http://man7.org/linux/man-pages/man8/ld.so.8.html" rel="noopener ugc nofollow" target="_blank"> ld.so </a>的手册页有更多详细信息。</p><p id="3ff2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然这很神奇，但实际上从源代码到实际的二进制代码有点困难。由于shell中变量的形式是$var，所以对shell的嵌套调用可能会导致变量被插值或格式错误。(注意:要使这个rpath工作，需要存在文字字符串$ORIGIN。)</p><p id="e835" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我知道，这是一个悬念。我为什么选择第三个选项？抓紧了。你首先需要了解我为什么使用rpaths的背景。我正在使用Python，并计划将mod_wsgi编译为我的应用服务器，但是它要求Python是一个共享对象。因此，在编译Python时，可以给它-enable-shared标志，让它构建共享对象。唯一的缺点是Python解释器现在需要能够找到那个共享对象。在我第一次尝试编译一个默认的Python版本后，我结束了这个错误:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="68c5" class="md ky hh lz b fi me mf l mg mh">$ /example/python/bin/python<br/>/home/vagrant/python/bin/python: error while loading shared libraries: libpython2.7.so.1.0: cannot open shared object file: No such file or directory</span></pre><p id="5a6c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">嗯，那不是我想要的。我需要做以下事情之一:</p><ol class=""><li id="8054" class="kj kk hh iy b iz ja jc jd jf kl jj km jn kn jr ko kp kq kr bi translated">在运行时设置LD_LIBRARY_PATH。</li><li id="ae5c" class="kj kk hh iy b iz ks jc kt jf ku jj kv jn kw jr ko kp kq kr bi translated">在编译时设置RPATH，以便它在执行时引用正确的libpython.sowhen。</li></ol><p id="c741" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">LD_LIBRARY_PATH最大的缺点是它需要被设置为一个环境变量，每当你想使用Python时，记住这一点有点痛苦。相反，我决定选择第二个选项(rpath ),这使我第一次尝试使用RPATH进行编译:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="6bb3" class="md ky hh lz b fi me mf l mg mh">LDFLAGS='-Wl,-rpath=$ORIGIN/../lib' ./configure --prefix=/example/python --enable-shared</span></pre><p id="b726" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">配置运行良好，所以制作应该是小菜一碟:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="e11e" class="md ky hh lz b fi me mf l mg mh">$ make<br/>...<br/>gcc -pthread -shared -Wl,-rpath=RIGIN/../lib -Wl,-hlibpython2.7.so.1.0 -o libpython2.7.so.1.0 Modules/getbuildinfo.o Parser/bitset.o Parser/metagrammar.o Parser/firstsets.o ...  Modules/pwdmodule.o  Modules/_sre.o  Modules/_codecsmodule.o -lpthread -ldl  -lutil  -lm ; \<br/>        ln -f libpython2.7.so.1.0 libpython2.7.so;<br/>...</span></pre><p id="0555" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意RIGIN/../lib缺少$O部分？变量需要作为$ORIGIN/一直传递给链接器../lib以使该技巧起作用。经过大量的反复试验，将变量正确传递给链接器的最后一个命令是:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="6697" class="md ky hh lz b fi me mf l mg mh">LDFLAGS='-Wl,-rpath=\$$ORIGIN/../lib' ./configure --prefix=/example/python --enable-shared</span></pre><p id="154b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我能够使用我在上面发布的readelf进行验证，最后的确认来自于运行:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="ee6e" class="md ky hh lz b fi me mf l mg mh">$ /example/python/bin/python<br/>Python 2.7.8 (default, Aug 26 2014, 06:15:54)<br/>[GCC 4.4.7 20120313 (Red Hat 4.4.7-4)] on linux2<br/>Type "help", "copyright", "credits" or "license" for more information.<br/>&gt;&gt;&gt;</span></pre><p id="73f6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您想要三重检查它是否加载了正确的库(即您的编译库，而不是系统库，如果它碰巧存在的话)，您可以使用strace:</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="b568" class="md ky hh lz b fi me mf l mg mh">$ strace -e open,stat python/bin/python<br/>...<br/>open("/example/python/bin/../lib/tls/x86_64/libpython2.7.so.1.0", O_RDONLY) = -1 ENOENT (No such file or directory)<br/>stat("/example/python/bin/../lib/tls/x86_64", 0x7fffa5a4d520) = -1 ENOENT (No such file or directory)<br/>open("/example/python/bin/../lib/tls/libpython2.7.so.1.0", O_RDONLY) = -1 ENOENT (No such file or directory)<br/>stat("/example/python/bin/../lib/tls", 0x7fffa5a4d520) = -1 ENOENT (No such file or directory)<br/>open("/example/python/bin/../lib/x86_64/libpython2.7.so.1.0", O_RDONLY) = -1 ENOENT (No such file or directory)<br/>stat("/example/python/bin/../lib/x86_64", 0x7fffa5a4d520) = -1 ENOENT (No such file or directory)<br/>open("/example/python/bin/../lib/libpython2.7.so.1.0", O_RDONLY) = 3<br/>...</span></pre><p id="56ce" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以看到它最终会在/example/python/lib目录中查找。</p><h1 id="bd89" class="kx ky hh bd kz la lb lc ld le lf lg lh in li io lj iq lk ir ll it lm iu ln lo bi translated">结论</h1><p id="1346" class="pw-post-body-paragraph iw ix hh iy b iz lp ii jb jc lq il je jf lr jh ji jj ls jl jm jn lt jp jq jr ha bi translated">显然，选择第三种方法不是最简单或最明显的方法——编译可重定位的二进制文件可能很难(有时甚至不可能)。然而，使用相对的shebangs和rpaths有助于简化应用程序的部署，并允许更大的灵活性，同时仍然保持可靠性。</p></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><div class="lu lv lw lx fd mq"><a href="https://twitter.com/alexcoomans" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hi fi z dy mv ea eb mw ed ef hg bi translated">亚历克斯·库曼斯(@亚历克斯·库曼斯)|推特</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">亚历克斯·库曼斯的最新推文(@alexcoomans)。“幻想新事物”方，骄傲的“乌达斯汀校友”。德克萨斯州奥斯汀…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">twitter.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne nf mq"/></div></div></a></div></div></div>    
</body>
</html>