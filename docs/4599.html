<html>
<head>
<title>How to Sharpen Your Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提高你的单元测试</h1>
<blockquote>原文：<a href="https://medium.com/compendium/how-to-sharpen-your-unit-tests-58ee01329f15?source=collection_archive---------6-----------------------#2022-01-04">https://medium.com/compendium/how-to-sharpen-your-unit-tests-58ee01329f15?source=collection_archive---------6-----------------------#2022-01-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4723" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我在做我的爱好项目时，我尽可能地遵循TDD的原则。在我实现一个新的特性或者改变一个现有的特性之前编写一个失败的单元测试就是这些原则之一。我还跟踪测试覆盖率以确保没有小故障，尽管我不得不说我不像关心突变覆盖率那样关心行覆盖率。然而，经常发生的是，我的单元测试变得有点“模糊”:类A上的单元测试应该驻留在测试类a test中，但经常发现类A中的一些功能被测试类BTest和CTest中的单元测试所覆盖，或者说ATest中的单元测试只通过类A，而实际上只测试类D或E中的功能。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/c1d3016fbf918feb2ae7ed3741ff8519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aIddX7VfNGeH7DPd2PLjBQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Illustration of how unit tests in ATest test most of A, but also a little bit of D and E, while some parts of A are covered by BTest and CTest. Of course, things are much more complex in real projects.</figcaption></figure><p id="c931" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">单元测试变得模糊不清的原因有很多。一个原因可能是类A中的一些功能很难直接测试，但通过类b测试很容易。另一个原因可能是一些功能需要通过类c进行一些设置。结果，单元测试分别在测试类BTest和CTest中结束，即使它们实际上是类A上的单元测试。</p><p id="a2e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是另一个原因:您在CTest中编写了一个单元测试来测试C中的一些功能，但是作为副作用，它碰巧也测试了类A中的一些功能。结果，类A的一部分似乎已经包含在测试覆盖报告中，所以您没有意识到A上的一些单元测试现在位于测试类CTest中。</p><p id="94b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，一个非常常见的原因，但也是在没有正确工具的情况下处理起来非常棘手的情况:您开始时只有一个类A，但它变得太大了，所以您提取了两个新的类D和e。幸运的是，您有很好的测试覆盖率，所以源代码的重构，包括两个类的提取，并不是很大的风险。接下来，您还将显然只测试类D和E中功能的单元测试转移到了新创建的测试类d test和ETest中。但是并不是所有的单元测试都在A类、D类和/或E类之间划分得那么清楚，所以它们仍然处于测试阶段，当然如果它们继续使用A类的接口作为它们进入源代码的主要入口的话。</p><p id="4280" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，只要您的测试覆盖率足够高，并且您的单元测试足够接近他们正在测试的功能，这就不是一个大问题。测试类BTest中的单元测试依赖于类A中的源代码也不是问题，因为类B依赖于它。在大多数情况下，它就是需要这样。问题是当类A中的部分源代码只被测试类BTest中的单元测试覆盖时。我喜欢这样，如果我在类A中犯了一个错误，比如在重构它的时候，测试类ATest中至少有一个单元测试会失败。其他测试类中的单元测试也可能开始失败，因为它们依赖于类A中的功能，但是类A中的一个bug应该总是对测试类ATest中的至少一个单元测试产生影响。</p><p id="6958" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果A类是你唯一学习的一个类，那么找出你在哪一个类中犯了错误就不是问题。然而，如果您已经对类A、B、C和D进行了更改，那么您可以假设类B和D很可能是好的，因为只有测试类ATest和CTest有单元测试失败。当然，从理论上讲，您仍然有可能在B类中创建了一个偷偷摸摸的问题，它以某种方式绕过了测试类BTest中的单元测试，而没有通过测试类ATest和CTest中的几个单元测试。或者可能真正的问题是测试类BTest中的一个单元测试不正确，这也是一种可能性。但那真的应该是极少数的例外。</p><p id="2b9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么，如何避免您的测试类开始模糊到相邻的类中呢？据我所知，测试覆盖报告工具目前还没有现成的支持来表明A类在多大程度上被测试类ATest中的单元测试所覆盖。我希望有一个扩展，不仅显示源代码的哪些部分没有被覆盖(红色)，哪些部分被覆盖(绿色)，而且显示哪些部分被“正确的”测试类覆盖(绿色)，哪些部分被其他测试类覆盖(琥珀色)。哪一个单元测试类对哪一个源代码类是“正确的”,这可能取决于惯例、注释或任何最有效的东西。我的简单规则是给源代码类名加上后缀“Test”。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es js"><img src="../Images/f866b0af8b88d596a9514ac7ddddf28a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v9bYo0VfAMD1ePAj65O5lA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Feature request for an extension to test coverage reports: at the top how a traditional test coverage report would present the situation from the illustration at the beginning of the article, and at the bottom how I would like to see it reported.</figcaption></figure><p id="a85a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是在缺乏对这种特性的支持的情况下，人们总是可以尝试编写几个脚本来获得相同的结果。当在Linux机器上的Java Maven项目中使用突变测试工具<a class="ae jt" href="https://pitest.org" rel="noopener ugc nofollow" target="_blank"> PITEST </a>时，我已经这样做了。结果可以在GitHub上一个名为<a class="ae jt" href="https://github.com/filipvanlaenen/sharpen_pitest" rel="noopener ugc nofollow" target="_blank"> sharpen_pitest </a>的存储库中找到。对于我从事的小爱好项目来说，它工作得非常好，并且当我用它运行老项目时，给了我一些惊喜。到目前为止最重要的教训:这是惊人的——也是可怕的——在一个小小的爱好项目中，你可以有多么混乱，即使你正在尽最大努力编写单元测试，并疯狂地检查测试覆盖报告，以确保没有源代码被发现。只要确保所有的单元测试都在正确的测试类中，并且源代码不仅被单元测试覆盖，而且被正确的测试类中的单元测试覆盖，也可以提高单元测试的质量。为什么？我认为这是因为在测试类ATest中为类A编写单元测试也迫使你根据类A的抽象级别来考虑你想要测试的功能。</p></div></div>    
</body>
</html>