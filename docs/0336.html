<html>
<head>
<title>Deep Dive: MediaPlayer Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度探讨:MediaPlayer最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/deep-dive-mediaplayer-best-practices-feb4d15a66f5?source=collection_archive---------3-----------------------#2018-03-15">https://medium.com/androiddevelopers/deep-dive-mediaplayer-best-practices-feb4d15a66f5?source=collection_archive---------3-----------------------#2018-03-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d1c9528cdbfa6a6206bd475b4f9aaaf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1602X8rIcWq3AjaH_m8Iw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/photos/YrtFlrLo2DQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Marcela Laskoski</a> on <a class="ae it" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="07d6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">MediaPlayer看起来似乎很容易使用，但复杂性隐藏在表面之下。例如，写下这样的内容是很有诱惑力的:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="2f52" class="kb kc hh jx b fi kd ke l kf kg">MediaPlayer.create(context, R.raw.cowbell).start()</span></pre><p id="6073" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这在第一次很好，可能在第二次、第三次甚至更多次都是如此。但是，每个新的MediaPlayer都会消耗系统资源，例如内存和编解码器。这可能会降低应用程序的性能，甚至可能会降低整个设备的性能。</p><p id="b57f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">幸运的是，只要遵循一些简单的规则，就有可能以既简单又安全的方式使用MediaPlayer。</p><h1 id="04d8" class="kh kc hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">简单的例子</h1><p id="738f" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">最基本的情况是，我们有一个声音文件，也许是一个原始资源，我们只想播放它。在这种情况下，我们将创建一个单独的播放器，每次需要播放声音时都可以重用它。播放器应该是这样创建的:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="f4f7" class="kb kc hh jx b fi kd ke l kf kg"><strong class="jx hi">private val </strong>mediaPlayer = MediaPlayer().apply <strong class="jx hi">{<br/>    </strong>setOnPreparedListener <strong class="jx hi">{ </strong>start() <strong class="jx hi">}<br/>    </strong>setOnCompletionListener <strong class="jx hi">{ </strong>reset() <strong class="jx hi">}<br/>}</strong></span></pre><p id="0b85" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">播放器由两个监听器创建:</p><ul class=""><li id="4d43" class="lj lk hh iw b ix iy jb jc jf ll jj lm jn ln jr lo lp lq lr bi translated"><a class="ae it" href="https://developer.android.com/reference/android/media/MediaPlayer.OnPreparedListener.html" rel="noopener ugc nofollow" target="_blank"> OnPreparedListener </a>，播放器准备好后会自动开始播放。</li><li id="fbb1" class="lj lk hh iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated"><a class="ae it" href="https://developer.android.com/reference/android/media/MediaPlayer.OnCompletionListener.html" rel="noopener ugc nofollow" target="_blank"> OnCompletionListener </a>，播放结束后自动清理资源。</li></ul><p id="185d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">创建播放器后，下一步是创建一个函数，该函数获取一个资源ID并使用该MediaPlayer来播放它:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="a6a0" class="kb kc hh jx b fi kd ke l kf kg"><strong class="jx hi">override fun </strong>playSound(@RawRes rawResId: Int) {<br/>    <strong class="jx hi">val </strong>assetFileDescriptor = context.<em class="lx">resources</em>.openRawResourceFd(rawResId) ?: <strong class="jx hi">return<br/>    </strong>mediaPlayer.run <strong class="jx hi">{<br/>        </strong>reset()<br/>        setDataSource(assetFileDescriptor.fileDescriptor, assetFileDescriptor.startOffset, assetFileDescriptor.declaredLength)<br/>        prepareAsync()<br/>    <strong class="jx hi">}<br/></strong>}</span></pre><p id="66b6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个简短的方法中发生了很多事情:</p><ul class=""><li id="4c13" class="lj lk hh iw b ix iy jb jc jf ll jj lm jn ln jr lo lp lq lr bi translated">资源ID必须转换成一个<a class="ae it" href="https://developer.android.com/reference/android/content/res/AssetFileDescriptor.html" rel="noopener ugc nofollow" target="_blank"> AssetFileDescriptor </a>，因为这是MediaPlayer用来播放原始资源的。空检查确保资源存在。</li><li id="c874" class="lj lk hh iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated">调用reset()确保播放器处于初始化状态。无论玩家处于什么状态，这都是有效的。</li><li id="9a77" class="lj lk hh iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated">为播放器设置数据源。</li><li id="68e1" class="lj lk hh iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated">prepareAsync准备播放器播放并立即返回，保持UI响应。这是因为附加的OnPreparedListener在源准备好之后开始播放。</li></ul><p id="999f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">需要注意的是，我们没有在播放器上调用release()或者将其设置为null。我们想再利用它！因此，我们调用reset()，释放它正在使用的内存和编解码器。</p><p id="ce39" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">播放声音就像打电话一样简单:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="0c50" class="kb kc hh jx b fi kd ke l kf kg">playSound(R.raw.cowbell)</span></pre><p id="bced" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简单！</p><h1 id="7190" class="kh kc hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">更多牛铃</h1><p id="755c" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">一次播放一个声音很容易，但是如果你想在第一个声音还在播放的时候开始另一个声音呢？像这样多次调用<code class="du ly lz ma jx b">playSound()</code>是行不通的:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="6bfb" class="kb kc hh jx b fi kd ke l kf kg">playSound(R.raw.big_cowbell)<br/>playSound(R.raw.small_cowbell)</span></pre><p id="1ca0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，<code class="du ly lz ma jx b">R.raw.big_cowbell</code>开始准备，但是第二个调用在任何事情发生之前重置了播放器，所以只有你只听到<code class="du ly lz ma jx b">R.raw.small_cowbell</code>。</p><p id="30dc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们想同时播放多种声音呢？我们需要为每一个创建一个媒体播放器。最简单的方法是拥有一个活跃玩家的列表。也许是这样的:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="e94e" class="kb kc hh jx b fi kd ke l kf kg"><strong class="jx hi">class </strong>MediaPlayers(context: Context) {<br/>    <strong class="jx hi">private val context</strong>: Context = context.<em class="lx">applicationContext<br/>    </em><strong class="jx hi">private val playersInUse </strong>= <em class="lx">mutableListOf</em>&lt;MediaPlayer&gt;()<br/><br/>    <strong class="jx hi">private fun </strong>buildPlayer() = MediaPlayer().apply <strong class="jx hi">{<br/>        </strong>setOnPreparedListener <strong class="jx hi">{ </strong>start() <strong class="jx hi">}<br/>        </strong>setOnCompletionListener <strong class="jx hi">{<br/>            </strong>it.release()<br/>            playersInUse -= it<br/>        <strong class="jx hi">}<br/>    }<br/><br/>    override fun </strong>playSound(@RawRes rawResId: Int) {<br/>        <strong class="jx hi">val </strong>assetFileDescriptor = context.resources.openRawResourceFd(rawResId) ?: <strong class="jx hi">return<br/>        val </strong>mediaPlayer = buildPlayer()<br/><br/>        mediaPlayer.run <strong class="jx hi">{<br/>            </strong>playersInUse += it<br/>            setDataSource(assetFileDescriptor.fileDescriptor, assetFileDescriptor.startOffset,<br/>                    assetFileDescriptor.declaredLength)<br/>            prepareAsync()<br/>        <strong class="jx hi">}<br/>    </strong>}<br/>}</span></pre><p id="1cb6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在每种声音都有自己的播放器，可以同时播放<code class="du ly lz ma jx b">R.raw.big_cowbell</code>和<code class="du ly lz ma jx b">R.raw.small_cowbell</code>！完美！</p><p id="f3ac" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">…嗯，几乎完美。我们的代码中没有任何东西限制一次可以播放的声音数量，MediaPlayer仍然需要内存和编解码器。当它们用完时，MediaPlayer会无声地失败，只在logcat中注明“<code class="du ly lz ma jx b">E/MediaPlayer: Error (1,-19)</code>”。</p><h1 id="4228" class="kh kc hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">输入MediaPlayerPool</h1><p id="00a4" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">我们希望支持同时播放多种声音，但我们不想耗尽内存或编解码器。管理这些事情的最好方法是有一个玩家池，然后当我们想要播放一个声音时选择一个来使用。我们可以这样更新我们的代码:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="d8e7" class="kb kc hh jx b fi kd ke l kf kg"><strong class="jx hi">class </strong>MediaPlayerPool(context: Context, maxStreams: Int) {<br/>    <strong class="jx hi">private val context</strong>: Context = context.<em class="lx">applicationContext<br/><br/>    </em><strong class="jx hi">private val mediaPlayerPool </strong>= <em class="lx">mutableListOf</em>&lt;MediaPlayer&gt;().<em class="lx">also </em><strong class="jx hi">{<br/>        for </strong>(i <strong class="jx hi">in </strong>0..maxStreams) <strong class="jx hi">it </strong>+= buildPlayer()<br/>    <strong class="jx hi">}<br/>    private val playersInUse </strong>= <em class="lx">mutableListOf</em>&lt;MediaPlayer&gt;()<br/><br/>    <strong class="jx hi">private fun </strong>buildPlayer() = MediaPlayer().apply <strong class="jx hi">{<br/>        </strong>setOnPreparedListener <strong class="jx hi">{ </strong>start() <strong class="jx hi">}<br/>        </strong>setOnCompletionListener <strong class="jx hi">{ </strong>recyclePlayer(it) <strong class="jx hi">}<br/>    }<br/><br/>    </strong><em class="lx">/**<br/>     * Returns a </em><strong class="jx hi"><em class="lx">[MediaPlayer]</em></strong><em class="lx"> if one is available,<br/>     * otherwise null.<br/>     */<br/>    </em><strong class="jx hi">private fun </strong>requestPlayer(): MediaPlayer? {<br/>        <strong class="jx hi">return if </strong>(!<strong class="jx hi">mediaPlayerPool</strong>.isEmpty()) {<br/>            <strong class="jx hi">mediaPlayerPool</strong>.removeAt(0).also <strong class="jx hi">{<br/>                playersInUse </strong>+= it<br/>            <strong class="jx hi">}<br/>        </strong>} <strong class="jx hi">else null<br/>    </strong>}<br/><br/>    <strong class="jx hi">private fun </strong>recyclePlayer(mediaPlayer: MediaPlayer) {<br/>        mediaPlayer.reset()<br/>        <strong class="jx hi">playersInUse </strong>-= mediaPlayer<br/>        <strong class="jx hi">mediaPlayerPool </strong>+= mediaPlayer<br/>    }<br/><br/>    <strong class="jx hi">fun </strong>playSound(@RawRes rawResId: Int) {<br/>        <strong class="jx hi">val </strong>assetFileDescriptor = <strong class="jx hi">context</strong>.<em class="lx">resources</em>.openRawResourceFd(rawResId) ?: <strong class="jx hi">return<br/>        val </strong>mediaPlayer = requestPlayer() ?: <strong class="jx hi">return<br/><br/>        </strong>mediaPlayer.<em class="lx">run </em><strong class="jx hi">{<br/>            </strong>setDataSource(assetFileDescriptor.fileDescriptor, assetFileDescriptor.startOffset,<br/>                    assetFileDescriptor.declaredLength)<br/>            prepareAsync()<br/>        <strong class="jx hi">}<br/>    </strong>}<br/>}</span></pre><p id="7dee" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在多种声音可以同时播放，我们可以控制同时播放的最大数量，以避免使用太多的内存或太多的编解码器。而且，因为我们正在回收实例，所以垃圾收集器不必运行来清理所有已经结束播放的旧实例。</p><p id="a581" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种方法有一些缺点:</p><ul class=""><li id="88e3" class="lj lk hh iw b ix iy jb jc jf ll jj lm jn ln jr lo lp lq lr bi translated">在播放完<em class="lx"> maxStreams </em>声音后，任何对playSound的额外调用都会被忽略，直到一个播放器被释放。你可以通过“偷”一个已经被用来播放新声音的播放器来解决这个问题。</li><li id="89e2" class="lj lk hh iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated">调用playSound和实际播放声音之间可能会有明显的延迟。尽管MediaPlayer正在被重用，但它实际上是一个通过JNI控制底层C++原生对象的瘦包装器。每次您调用<code class="du ly lz ma jx b">MediaPlayer.reset()</code>时，本机播放器都会被销毁，每当准备好MediaPlayer时，必须重新创建它。</li></ul><p id="e261" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在保持重用播放器的能力的同时改善延迟是很难做到的。幸运的是，对于某些类型的声音和需要低延迟的应用程序，我们下次会看到另一个选项:<a class="ae it" href="https://developer.android.com/reference/android/media/SoundPool.html" rel="noopener ugc nofollow" target="_blank"> SoundPool </a>。</p></div></div>    
</body>
</html>