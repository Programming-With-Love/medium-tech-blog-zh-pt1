<html>
<head>
<title>Opaque Return type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不透明返回类型</h1>
<blockquote>原文：<a href="https://medium.com/globant/opaque-return-type-in-swift5-x-79cba49ccc39?source=collection_archive---------9-----------------------#2020-06-22">https://medium.com/globant/opaque-return-type-in-swift5-x-79cba49ccc39?source=collection_archive---------9-----------------------#2020-06-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/352a22f5ab2fc06bc53c6e60353a9912.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/0*2fE0rYbLyCp593Pk"/></div><figcaption class="il im et er es in io bd b be z dx">Opaque return type is reverse generic behaviour. What?</figcaption></figure><h2 id="e67b" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">那么，泛型是如何表现的呢？🤔</h2><p id="be58" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh ha bi translated">泛型函数、类、结构、枚举或associatedtype是以这样一种抽象和通用的方式设计的，即它们的调用方决定应该绑定什么类型，因为泛型类型的占位符和泛型代码的类型将适用于所有类型。例如:</p><figure class="ki kj kk kl fd ii"><div class="bz dy l di"><div class="km kn l"/></div></figure><p id="09e6" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">在这里，当调用<strong class="jp hi"> printArray </strong>函数时，无论传递什么类型，比如这个代码片段中的<strong class="jp hi"> Int </strong>和<strong class="jp hi"> String </strong>都会被传递，它们成为调用者的决定类型。由于其通用行为，printArray 方法适用于所有类型。有关generic的更多详情，请查看Swift 中的<a class="ae kt" rel="noopener" href="/@nitesh.kumar.pal.dev/generic-type-in-swift-c37c993080e3"> Generic type。</a></p><h2 id="adc3" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">反向类属</h2><p id="9733" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh ha bi translated">让我们颠倒一下用于解释上述一般情况的陈述。<strong class="jp hi">反向泛型</strong>是指当返回类型或参数类型在其托管代码内部决定时(如类、结构、枚举或函数本身内部)。</p><h1 id="0ac2" class="ku iq hh bd ir kv kw kx iv ky kz la iz lb lc ld jd le lf lg jh lh li lj jl lk bi translated">不透明返回类型(ORT)</h1><p id="a154" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh ha bi translated">ORT意味着调用方不需要指定底层的返回类型或参数类型，而调用方必须确定获得具体的类型。</p><p id="570a" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">让我们看看不同类型的用例，通过这些用例，我们可以在不透明返回类型的帮助下解决问题:</p><blockquote class="ll lm ln"><p id="0942" class="jn jo lo jp b jq ko js jt ju kp jw jx lp kq jz ka lq kr kc kd lr ks kf kg kh ha bi translated"><strong class="jp hi"> <em class="hh">用例1:自身或关联类型需求👇</em> </strong></p></blockquote><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ls"><img src="../Images/376b8e8cbb34ba4f0ca37d421dd6d00a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JB3dTgj4ERhazyQW"/></div></div></figure><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es lx"><img src="../Images/20750cd5fb3e4d97d2f1c7d887466b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vypOANoeTgvDkmXc"/></div></div><figcaption class="il im et er es in io bd b be z dx">Though Mobile confirms the protocol UniqueProduct, you cannot set UniqueProduct as return type because of its generic behaviour, It requires special treatment. Let’s see how we can resolve the issue 👇</figcaption></figure><p id="82d1" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated"><strong class="jp hi">解决方案1: </strong></p><p id="334c" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">我们可以直接返回具体类型<strong class="jp hi">移动</strong>，因为<strong class="jp hi">逆向泛型</strong>概念说调用者必须获得具体类型。</p><figure class="ki kj kk kl fd ii er es paragraph-image"><div class="er es ly"><img src="../Images/a8cb144aaeb585973eb9d48e1bdb41cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/0*ouQw3XEqp5a_KjFk"/></div></figure><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es lz"><img src="../Images/784335e78b9452f48b5f1ff32d892269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I5t9BtUq-cMfLeTY"/></div></div><figcaption class="il im et er es in io bd b be z dx">Check the type by <strong class="bd ir">option + click</strong> on <strong class="bd ir">product</strong>, we can see <strong class="bd ir">manufactureProduct</strong>() is returning <strong class="bd ir">Mobile</strong> so as due to type inference <strong class="bd ir">product</strong> type is set as Mobile.</figcaption></figure><p id="99aa" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">但是这里我们有一个问题，如果我们将Mobile设置为返回类型，它会将返回类型暴露给调用者，这意味着不完全符合。让我们看看如何在解决方案2中解决这个问题。</p><p id="41ff" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated"><strong class="jp hi">解决方案2: </strong></p><p id="4280" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">不透明的返回类型有助于避免向调用者公开返回类型。</p><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es ma"><img src="../Images/4d176d4cc5a1726ea877e7ceb2284fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qtvG6nojghxT5KQE"/></div></div><figcaption class="il im et er es in io bd b be z dx">(<strong class="bd ir">some </strong>is the keyword to indicate ORT)</figcaption></figure><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mb"><img src="../Images/2d6ea5beb144b7e8139dd7c5f6b290aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NqGCC1h0z4z0SjyP"/></div></div><figcaption class="il im et er es in io bd b be z dx">Check the type by <strong class="bd ir">option + click</strong> on <strong class="bd ir">product</strong>, we can see <strong class="bd ir">manufactureProduct</strong>() is now showing <strong class="bd ir">some UnqueProduct </strong>as return type.</figcaption></figure><p id="c28c" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">这里<strong class="jp hi">一些UniqueProduct </strong>暗示manufactureProduct()将返回一个具体类型，该类型必须确认<strong class="jp hi"> UniqueProduct </strong>协议。这正是反向类属概念。</p><p id="0808" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">呼叫者不知道产品的类型是<strong class="jp hi">手机</strong>还是<strong class="jp hi">平板电脑</strong>。这里我们利用了ORT的优势，它通过使用<strong class="jp hi"> some </strong>关键字将返回类型定义为ORT。</p><figure class="ki kj kk kl fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/303608bd24cbb4f12fbfff4eb72b7462.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*GkOiG8W3Ddkr5sqGmbF7rg.gif"/></div><figcaption class="il im et er es in io bd b be z dx">Phew! now you must have digested Reverse Generic with ORT, let's check UseCase 2 next</figcaption></figure><blockquote class="ll lm ln"><p id="8d7f" class="jn jo lo jp b jq ko js jt ju kp jw jx lp kq jz ka lq kr kc kd lr ks kf kg kh ha bi translated"><strong class="jp hi"> <em class="hh">用例2:使用ORT隐藏复杂返回类型👇</em> </strong></p></blockquote><figure class="ki kj kk kl fd ii"><div class="bz dy l di"><div class="km kn l"/></div><figcaption class="il im et er es in io bd b be z dx">Please check this code sample before further reading.</figcaption></figure><p id="55ed" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">在上面的代码片段中，相同的代码写在两个函数<strong class="jp hi">getshortletdstudentlist</strong>和<strong class="jp hi">getshortletdstudents中。</strong></p><p id="ab19" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">函数<strong class="jp hi">getshortlestedstudentlist</strong>中编写的代码实际上是返回类型<strong class="jp hi">lazy map sequence&lt;lazy filter sequence&lt;lazy sequence&lt;【学生】&gt;。元素&gt;，字符串&gt; <br/> </strong>因此由于类型推断<em class="lo">shortabledbysixtycutoff</em>常量的类型将是相同的。在ORT的帮助下，我们可以隐藏这些不必要的类型细节。</p><p id="5486" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">调用者更感兴趣的只是得到结果类型，根据要求，这里只是简单的<strong class="jp hi">集合</strong>类型。因此，只需将<strong class="jp hi">某个集合</strong>设置为<strong class="jp hi">getshortletedstudents</strong>的返回类型，就可以解决将所有类型细节暴露给<em class="lo">shortletbebyventycutoff</em>常量的问题。</p><p id="5cb7" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">我们可以看到SwiftUI中的<strong class="jp hi">视图</strong>协议使用了相同的方法</p><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es md"><img src="../Images/8e666ff89c4344d25e59264ad6c431c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmXlgqliVJYfqqnia7MSZQ.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Option + click on <strong class="bd ir">stack</strong></figcaption></figure><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es me"><img src="../Images/c3eb1dbba471edaf1c848f8979dec9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r556VlNV1j3jkLPXCsSwbg.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">It’s returning the complex type as <strong class="bd ir">VStack&lt;TupleView&lt;(Text, Text)&gt;&gt; </strong>but the type of body would be always<strong class="bd ir"> some View </strong>which implies that it would always carry a concrete type with the abstraction of ORT</figcaption></figure><blockquote class="ll lm ln"><p id="8ce3" class="jn jo lo jp b jq ko js jt ju kp jw jx lp kq jz ka lq kr kc kd lr ks kf kg kh ha bi translated"><strong class="jp hi"> <em class="hh">用例3:你不能欺骗ORT的具体类型。</em> </strong></p></blockquote><figure class="ki kj kk kl fd ii"><div class="bz dy l di"><div class="mf kn l"/></div></figure><p id="4476" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">使用ORT作为返回类型，如果编译器不允许，就不能编写可能返回多种类型的代码😈。</p><p id="5238" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">让我们看看这意味着什么:</p><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mg"><img src="../Images/9db2cb25a6ce7d21d80851e2d53f1238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KAtV6FuIb2PS1BCiNII8Zw.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Either return type can be Mobile</figcaption></figure><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es mh"><img src="../Images/176e135809786e6e805f968d052cfb8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtcMibrEgbLHxRrGJwcc-w.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">or return type can be Tablet</figcaption></figure><figure class="ki kj kk kl fd ii er es paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="er es lx"><img src="../Images/d43c4f56bf54f0f89f14b98935772a6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a1IlNvf21qPVT8IT-egyfA.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">But function cannot return multiple types if the return type is OTR.</figcaption></figure><h1 id="95e3" class="ku iq hh bd ir kv kw kx iv ky kz la iz lb lc ld jd le lf lg jh lh li lj jl lk bi translated">摘要</h1><ul class=""><li id="499b" class="mi mj hh jp b jq jr ju jv ja mk je ml ji mm kh mn mo mp mq bi translated">不透明返回类型的使用非常具体，您可以在<strong class="jp hi">用例1 </strong>(协议中的自身或关联类型需求)<strong class="jp hi"> </strong>和<strong class="jp hi">用例2 </strong>(通过使用ORT隐藏复杂的返回类型)中看到。</li></ul><p id="881f" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated"><strong class="jp hi">结构</strong> VStack &lt;内容&gt;:查看<strong class="jp hi">其中</strong>内容:查看</p><p id="53d1" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">在SwiftUI中，观察诸如HStack、ZStack、Group、List等类型，它们确认<strong class="jp hi">视图</strong>，也期望它们的泛型类型(<strong class="jp hi">内容</strong>)无论是什么都必须确认<strong class="jp hi">视图。</strong></p><ul class=""><li id="3c34" class="mi mj hh jp b jq ko ju kp ja mr je ms ji mt kh mn mo mp mq bi translated">SwiftUI中有许多这样的通用类型，它们可以包含创建复杂类型结构的其他视图。ORT对只会知道这个结构是<strong class="jp hi">某个视图</strong>的客户(呼叫者)很有帮助。</li><li id="f689" class="mi mj hh jp b jq mu ju mv ja mw je mx ji my kh mn mo mp mq bi translated">ORT使您的代码在运行时更具性能。因为协议迫使编译器在运行时检查其底层的具体类型，这增加了性能开销。但是ORT为编译器提供了具体类型的保证，即使是在编译时。</li><li id="9deb" class="mi mj hh jp b jq mu ju mv ja mw je mx ji my kh mn mo mp mq bi translated">一般来说，在应用程序开发中，由于我们不怎么处理协议中的泛型和Self或associatedtype，我个人认为使用ORT的理由很少，但另一方面，如果您正在构建一个框架或库，其中您将广泛使用ORT <strong class="jp hi">用例</strong> (1、2和3)，并且您希望使您的代码灵活、高度可重用，并对调用者抽象复杂的泛型类型，那么您应该使用ORT。</li><li id="39f0" class="mi mj hh jp b jq mu ju mv ja mw je mx ji my kh mn mo mp mq bi translated">作为开发人员，我们有时需要灵活性，根据某个参数值(比如不同的枚举情况)从函数中返回多个具体类型，在这种情况下，我们不能使用ORT。</li></ul><p id="45af" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated"><strong class="jp hi">您可以在以下链接查看不透明类型的更多详情:</strong> <br/> <a class="ae kt" href="https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html" rel="noopener ugc nofollow" target="_blank"> Swift-Book:不透明类型</a> <br/> <a class="ae kt" href="https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md" rel="noopener ugc nofollow" target="_blank">不透明返回类型建议:SE-0244 </a></p><p id="e1cb" class="pw-post-body-paragraph jn jo hh jp b jq ko js jt ju kp jw jx ja kq jz ka je kr kc kd ji ks kf kg kh ha bi translated">感谢您阅读博客，如果您发现更多的用例，请告诉我，我们也可以将它们添加到这里。分享一下你的想法。</p></div></div>    
</body>
</html>