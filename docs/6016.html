<html>
<head>
<title>How to Restructure an OCI Oracle Linux 8 LVM Platform Image</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何重构OCI Oracle Linux 8 LVM平台映像</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/how-to-restructure-an-oci-oracle-linux-8-lvm-platform-image-bee6febeb791?source=collection_archive---------0-----------------------#2022-12-16">https://medium.com/oracledevs/how-to-restructure-an-oci-oracle-linux-8-lvm-platform-image-bee6febeb791?source=collection_archive---------0-----------------------#2022-12-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6d7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为单独的<code class="du jc jd je jf b">/var</code>、<code class="du jc jd je jf b">/tmp</code>、<code class="du jc jd je jf b">/home</code>等重构一个OCI Oracle Linux 8 LVM平台镜像。</p><p id="9900" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">⚠️此过程是<strong class="ig hi"> <em class="jg">破坏性的</em> </strong> —强烈建议在副本、克隆或易于替换的引导卷上运行此过程。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/c5a58c26097531efe93bae5d8c8c1f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njJPzkl1cyes3HImsqtIIw.jpeg"/></div></div></figure><h2 id="a183" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">背景</h2><p id="0ae9" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">OCI平台映像通过简单的分区方案交付，该方案简单易用；根(/)文件系统包含所有内容。然而，一些客户更喜欢(或要求)一种更具防御性的结构，它隔离文件系统的易变部分，以减少文件系统上的不利事件导致整个实例停机的可能性。例如，填充根(/)文件系统会导致各种各样的意外行为。当像<code class="du jc jd je jf b">/tmp</code>、<code class="du jc jd je jf b">/var</code>和<code class="du jc jd je jf b">/home</code>这样的位置是根文件系统的一部分时，整个系统更容易暴露于流氓进程、过多的日志记录和人为错误。虽然可以通过主动监控和维护来降低一些风险，但是仍然有可能遇到问题。</p><blockquote class="kt ku kv"><p id="7297" class="ie if jg ig b ih ii ij ik il im in io kw iq ir is kx iu iv iw ky iy iz ja jb ha bi translated">虽然不常见，但完全填满的文件系统可能会导致管理员无法登录，或者实例可能无法成功启动，从而导致恢复过程更加复杂和耗时。</p></blockquote><p id="d59f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">OCI Oracle Linux 8平台映像的磁盘结构如下:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="867a" class="ld ju hh jf b be le lf l lg lh"><br/>$ lsblk -f<br/>NAME FSTYPE LABEL UUID MOUNTPOINT<br/>sda <br/>├─sda1 vfat 20D9-FA96 /boot/efi<br/>├─sda2 xfs 70b15dc2–5ada-4399–9df5-b48c348cd4f1 /boot<br/>└─sda3 LVM2_member VxgtY1–3gar-4ACy-JeJI-YAJf-A7MK-gFdAOT <br/> ├─ocivolume-root xfs 25dae1d1-c678–45b2-bd0c-c308e8c950cc /<br/> └─ocivolume-oled xfs a8c9a3f3–5052–445e-8868–5c1249ae071e /var/oled<br/><br/>$ df -hP<br/>Filesystem Size Used Avail Use% Mounted on<br/>devtmpfs 302M 0 302M 0% /dev<br/>tmpfs 343M 0 343M 0% /dev/shm<br/>tmpfs 343M 14M 329M 4% /run<br/>tmpfs 343M 0 343M 0% /sys/fs/cgroup<br/>/dev/mapper/ocivolume-root 36G 6.6G 29G 19% /<br/>/dev/mapper/ocivolume-oled 10G 119M 9.9G 2% /var/oled<br/>/dev/sda2 1014M 777M 238M 77% /boot<br/>/dev/sda1 100M 5.0M 95M 5% /boot/efi<br/>tmpfs 69M 0 69M 0% /run/user/0<br/>tmpfs 69M 0 69M 0% /run/user/987<br/>tmpfs 69M 0 69M 0% /run/user/1000</span></pre><p id="9d1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">需要使用<code class="du jc jd je jf b">sda1</code>和<code class="du jc jd je jf b">sda2</code>分区来引导实例，但是操作系统的其余部分安装在<code class="du jc jd je jf b">sda3</code>中，这又是一个LVM卷组(<code class="du jc jd je jf b">ocivolume</code>，具有多个逻辑卷(<code class="du jc jd je jf b">root</code>和<code class="du jc jd je jf b">oled</code>)。操作系统存在于<code class="du jc jd je jf b">root</code>中，<code class="du jc jd je jf b">oled</code>用于Oracle <code class="du jc jd je jf b">oswatcher</code>和崩溃日志；<code class="du jc jd je jf b">oled</code>的分离与我们想要对<code class="du jc jd je jf b">/tmp</code>、<code class="du jc jd je jf b">/home</code>和剩余的<code class="du jc jd je jf b">/var</code>进行的分离相同。为了改变这种结构，我们面临许多挑战:</p><ul class=""><li id="7292" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb ln lo lp lq bi translated">整个卷组被分配(没有空闲空间)</li><li id="59ef" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated">XFS文件系统<strong class="ig hi">不能</strong>收缩(对于EXT和其他一些文件系统不是这样)</li><li id="2bef" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated">由于以上几点，重构文件系统将是破坏性的，至少是部分破坏性的</li><li id="d480" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated">SELinux(默认强制)会不会对这个结果感到高兴</li></ul><h2 id="0083" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">方法</h2><blockquote class="kt ku kv"><p id="83e8" class="ie if jg ig b ih ii ij ik il im in io kw iq ir is kx iu iv iw ky iy iz ja jb ha bi translated">附录中有一个示例脚本，可以自动执行步骤3-12。它非常基础，应该谨慎使用。</p></blockquote><p id="b2f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于新的结构，我们希望将<code class="du jc jd je jf b">/tmp</code>、<code class="du jc jd je jf b">/var</code>、<code class="du jc jd je jf b">/var/log</code>和<code class="du jc jd je jf b">/home</code>分成独特的逻辑卷和文件系统。我们不希望重新创建LVM物理卷或重新创建现有的逻辑卷——这将消除我们在重构后重新配置<code class="du jc jd je jf b">grub</code>的需要。</p><ul class=""><li id="c61d" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb ln lo lp lq bi translated"><code class="du jc jd je jf b">/tmp</code>将是一个独立的4Gb文件系统，将在名为<code class="du jc jd je jf b">tmp</code> <br/>的逻辑卷中创建。<code class="du jc jd je jf b">/var</code>将是一个独立的1Gb文件系统，将在名为<code class="du jc jd je jf b">var</code> <br/>的逻辑卷中创建。<code class="du jc jd je jf b">/var/log</code>将是一个独立的1Gb文件系统，将在名为<code class="du jc jd je jf b">varlog</code> <br/>的逻辑卷中创建。<code class="du jc jd je jf b">/home</code>将是一个独立的1Gb文件系统，将在名为<code class="du jc jd je jf b">home</code>的逻辑卷中创建</li></ul><blockquote class="kt ku kv"><p id="25fc" class="ie if jg ig b ih ii ij ik il im in io kw iq ir is kx iu iv iw ky iy iz ja jb ha bi translated">默认引导卷大约为50Gb，根(/)文件系统的内容可能在7–10Gb范围内。如果您添加的额外逻辑卷需要调整大小，或者可能需要增长到一个大小，这将耗尽默认的大约50Gb的引导卷，那么在对其进行资源调配时，可能值得考虑增加源实例的引导卷的大小。</p></blockquote><p id="2425" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了完成这项工作，我们将使用两个计算实例；第一个是源OL8实例，第二个是临时工作实例，我们将使用它来修改源OL8实例的引导卷。</p><blockquote class="kt ku kv"><p id="2931" class="ie if jg ig b ih ii ij ik il im in io kw iq ir is kx iu iv iw ky iy iz ja jb ha bi translated">值得注意的是，OCI计算实例是克隆，因此，从同一平台映像创建的实例将具有相同的磁盘UUIDs、磁盘标签和LVM标签(如果使用LVM方案)。这对用户和软件来说都会变得非常混乱。因此，建议worker基于完全不同的平台映像。在这个例子中，我将使用Ubuntu 20.04平台映像。</p></blockquote><p id="0343" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">高级步骤包括:</p><ol class=""><li id="08b9" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb lw lo lp lq bi translated">创建源OL8实例，停止源实例并分离源实例的引导卷</li><li id="4840" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb lw lo lp lq bi translated">创建工作实例，确保安装了所有必要的工具，并将源实例启动卷作为块(非启动)卷附加</li><li id="44ff" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb lw lo lp lq bi translated">检查并备份工作实例中的源实例根(/)文件系统</li><li id="a263" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb lw lo lp lq bi translated">调整源实例<code class="du jc jd je jf b">root</code>逻辑卷的大小，并重新创建<code class="du jc jd je jf b">root</code>逻辑卷文件系统</li><li id="a4b2" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb lw lo lp lq bi translated">在源实例卷组(<code class="du jc jd je jf b">ocivolume</code>)中创建额外的逻辑卷(<code class="du jc jd je jf b">tmp</code>、<code class="du jc jd je jf b">var</code>、<code class="du jc jd je jf b">varlog </code>和<code class="du jc jd je jf b">home</code>，并在其上创建文件系统</li><li id="5ce9" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb lw lo lp lq bi translated">将源实例根(/)文件系统恢复到调整后的<code class="du jc jd je jf b">root</code>逻辑卷</li><li id="2d2a" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb lw lo lp lq bi translated">为新的<code class="du jc jd je jf b">tmp</code>、<code class="du jc jd je jf b">var</code>、<code class="du jc jd je jf b">varlog</code>、<code class="du jc jd je jf b">home</code>和<code class="du jc jd je jf b">agent</code>逻辑卷创建临时挂载点，并挂载它们</li><li id="2ac3" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb lw lo lp lq bi translated">将<code class="du jc jd je jf b">/tmp</code>、<code class="du jc jd je jf b">/var</code>、<code class="du jc jd je jf b">/var/log</code>和<code class="du jc jd je jf b">/home</code>从源根(/)文件系统复制到临时挂载点上的新文件系统</li><li id="331c" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb lw lo lp lq bi translated">重命名原始的<code class="du jc jd je jf b">/tmp</code>、<code class="du jc jd je jf b">/var</code>和<code class="du jc jd je jf b">/home</code>目录，并替换为新的挂载点</li><li id="c746" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb lw lo lp lq bi translated">更新源实例<code class="du jc jd je jf b">fstab</code>以在引导时挂载新的文件系统</li><li id="da94" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb lw lo lp lq bi translated">确保SELinux会开心</li><li id="ac6d" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb lw lo lp lq bi translated">从worker中卸载并分离源实例引导卷，并连接到源实例</li><li id="f79c" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb lw lo lp lq bi translated">试验</li></ol><blockquote class="kt ku kv"><p id="d0e4" class="ie if jg ig b ih ii ij ik il im in io kw iq ir is kx iu iv iw ky iy iz ja jb ha bi translated">如果SELinux不需要在重构后强制执行，可以在执行这些步骤之前禁用它，但不建议这样做。</p></blockquote><h2 id="ddc0" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">步伐</h2><p id="54c9" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated"><strong class="ig hi"> 1。创建并准备源OL8实例</strong></p><p id="3875" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用OCI控制台、CLI或其他机制创建新的OL8计算实例。形状和CPU架构是不相关的(这些步骤也适用于ARM实例)，因为我们只是在处理引导卷。创建实例后，您可能希望登录并更新实例，或者在继续之前进行任何其他配置更改，但这不是必需的。</p><p id="0176" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用OCI控制台或您选择的工具停止源OL8实例并分离其引导卷。</p><p id="7cdf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。创建并准备工人实例</strong></p><p id="fcc1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个练习中，使用了一个Ubuntu 20.04实例，运行在一个具有16Gb内存的E4-Flex 1 OCPU图形上。也可以使用不同的形状。记得添加您的SSH密钥！</p><p id="ff4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦worker实例启动，登录并确保安装了XFS工具。</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="9c42" class="ld ju hh jf b be le lf l lg lh">$ sudo apt install -y xfsprogs xfsdump<br/>Reading package lists… Done<br/>Building dependency tree <br/>Reading state information… Done<br/>xfsprogs is already the newest version (5.3.0–1ubuntu2).<br/>Suggested packages:<br/>  acl attr quota<br/>The following NEW packages will be installed:<br/>  xfsdump<br/>0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.<br/>Need to get 183 kB of archives.<br/>After this operation, 692 kB of additional disk space will be used.<br/>Get:1 http://ap-sydney-1-ad-1.clouds.ports.ubuntu.com/ubuntu-ports focal/main arm64 xfsdump arm64 3.1.6+nmu2build1 [183 kB]<br/>Fetched 183 kB in 2s (91.5 kB/s) <br/>Selecting previously unselected package xfsdump.<br/>(Reading database … 148592 files and directories currently installed.)<br/>Preparing to unpack …/xfsdump_3.1.6+nmu2build1_arm64.deb …<br/>Unpacking xfsdump (3.1.6+nmu2build1) ...<br/>Setting up xfsdump (3.1.6+nmu2build1) ...<br/>Processing triggers for man-db (2.9.1–1) ...</span></pre><p id="8544" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用OCI控制台或您选择的工具，将源实例的引导卷作为<strong class="ig hi">半虚拟化的</strong>块卷附加到工作实例。</p><p id="4ec8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3。检查并备份源实例根(/)文件系统</strong></p><p id="582d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦附加了源实例的引导卷，最好确保工作实例可以正确地看到它:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="aed0" class="ld ju hh jf b be le lf l lg lh">$ sudo vgchange -a y<br/>  2 logical volume(s) in volume group "ocivolume" now active<br/><br/>$ sudo lvdisplay<br/>  --- Logical volume ---<br/>  LV Path                /dev/ocivolume/oled<br/>  LV Name                oled<br/>  VG Name                ocivolume<br/>  LV UUID                QYLO3I-YbXn-d92M-Jhaa-xJoo-hujB-A70hHe<br/>  LV Write Access        read/write<br/>  LV Creation host, time localhost.localdomain, 2022-05-18 23:33:06 +0000<br/>  LV Status              available<br/>  # open                 0<br/>  LV Size                10.00 GiB<br/>  Current LE             2560<br/>  Segments               1<br/>  Allocation             inherit<br/>  Read ahead sectors     auto<br/>  - currently set to     4096<br/>  Block device           253:0<br/>   <br/>  --- Logical volume ---<br/>  LV Path                /dev/ocivolume/root<br/>  LV Name                root<br/>  VG Name                ocivolume<br/>  LV UUID                asKqqn-xF8Z-T3me-XYSi-ZUSN-17Rm-dUahdB<br/>  LV Write Access        read/write<br/>  LV Creation host, time localhost.localdomain, 2022-05-18 23:33:07 +0000<br/>  LV Status              available<br/>  # open                 0<br/>  LV Size                35.47 GiB<br/>  Current LE             9081<br/>  Segments               1<br/>  Allocation             inherit<br/>  Read ahead sectors     auto<br/>  - currently set to     4096<br/>  Block device           253:1<br/><br/>$ sudo lsblk -f<br/>NAME               FSTYPE      FSVER    LABEL           UUID                                   FSAVAIL FSUSE% MOUNTPOINTS<br/>loop0              squashfs    4.0                                                                   0   100% /snap/core18/2409<br/>loop1              squashfs    4.0                                                                   0   100% /snap/core20/1434<br/>loop2              squashfs    4.0                                                                   0   100% /snap/lxd/22923<br/>loop3              squashfs    4.0                                                                   0   100% /snap/oracle-cloud-agent/36<br/>loop4              squashfs    4.0                                                                   0   100% /snap/snapd/15534<br/>sda                                                                                                           <br/>├─sda1             ext4        1.0      cloudimg-rootfs 96695e07-a270-493b-b66c-ce28d94e1409     42.9G     5% /<br/>├─sda14                                                                                                       <br/>└─sda15            vfat        FAT32    UEFI            9DB3-1174                                99.1M     5% /boot/efi<br/>sdb                                                                                                           <br/>├─sdb1             vfat        FAT16                    2314-8847                                             <br/>├─sdb2             xfs                                  a619a666-d067-48a1-84c0-597037623f97                  <br/>└─sdb3             LVM2_member LVM2 001                 5QtWJg-49vg-4Ces-2Iv3-MRP5-dNdG-nLQwgd                <br/>  ├─ocivolume-oled xfs                                  0950a10f-ab7a-4ade-81df-abfe0b973620                  <br/>  └─ocivolume-root xfs                                  b74c7d6e-a842-4ab7-a47e-2ac332edaa3d                  </span></pre><p id="12ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">既然源实例数据块卷已连接，那么在开始更改之前验证文件系统是一个好主意:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="91be" class="ld ju hh jf b be le lf l lg lh">$ sudo xfs_repair /dev/mapper/ocivolume-root<br/>Phase 1 - find and verify superblock...<br/>Phase 2 - using internal log<br/>        - zero log...<br/>        - scan filesystem freespace and inode maps...<br/>        - found root inode chunk<br/>Phase 3 - for each AG...<br/>        - scan and clear agi unlinked lists...<br/>        - process known inodes and perform inode discovery...<br/>        - agno = 0<br/>        - agno = 1<br/>        - agno = 2<br/>        - agno = 3<br/>        - process newly discovered inodes...<br/>Phase 4 - check for duplicate blocks...<br/>        - setting up duplicate extent list...<br/>        - check for inodes claiming duplicate blocks...<br/>        - agno = 0<br/>        - agno = 1<br/>        - agno = 2<br/>        - agno = 3<br/>clearing reflink flag on inodes when possible<br/>Phase 5 - rebuild AG headers and trees...<br/>        - reset superblock...<br/>Phase 6 - check inode connectivity...<br/>        - resetting contents of realtime bitmap and summary inodes<br/>        - traversing filesystem ...<br/>        - traversal finished ...<br/>        - moving disconnected inodes to lost+found ...<br/>Phase 7 - verify and correct link counts...<br/>done</span></pre><p id="e0ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们知道我们有一个干净的文件系统，让我们挂载它:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="2c59" class="ld ju hh jf b be le lf l lg lh">$ sudo mount /dev/mapper/ocivolume-root /mnt/</span></pre><blockquote class="kt ku kv"><p id="f837" class="ie if jg ig b ih ii ij ik il im in io kw iq ir is kx iu iv iw ky iy iz ja jb ha bi translated">注意，linux设备映射器为LVM创建条目为<volume_group> - <logical_volume>，因此<code class="du jc jd je jf b">ocivolume</code>(卷组)和<code class="du jc jd je jf b">root</code>(逻辑卷)变成了<code class="du jc jd je jf b">ocivolume-root</code>。</logical_volume></volume_group></p></blockquote><p id="f3d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们现在需要使用xfsdump备份整个根(/)卷:</p><blockquote class="kt ku kv"><p id="290d" class="ie if jg ig b ih ii ij ik il im in io kw iq ir is kx iu iv iw ky iy iz ja jb ha bi translated">注意，在这个例子中，源实例没有被定制，因此文件系统转储并不大，可以安全地放在worker实例的<code class="du jc jd je jf b">/tmp</code>中。如果您的源实例已经过定制或安装了其他软件，请考虑将转储放在<code class="du jc jd je jf b">/tmp</code>之外的其他地方，例如，考虑向工作实例添加另一个块卷，或将一些文件系统服务(FSS)存储附加到工作节点以临时保存备份。</p></blockquote><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="68ea" class="ld ju hh jf b be le lf l lg lh">$ sudo xfsdump -L "" -M "" -0uf /tmp/ol8_root_backup /mnt<br/>xfsdump: using file dump (drive_simple) strategy<br/>xfsdump: version 3.1.9 (dump format 3.0) - type ^C for status and control<br/>xfsdump: WARNING: no session label specified<br/>xfsdump: WARNING: most recent level 0 dump was interrupted, but not resuming that dump since resume (-R) option not specified<br/>xfsdump: level 0 dump of worker:/mnt<br/>xfsdump: dump date: Mon Jun 13 06:51:40 2022<br/>xfsdump: session id: c078bec3-1852-463b-ab5a-4e94943eb219<br/>xfsdump: session label: ""<br/>xfsdump: ino map phase 1: constructing initial dump list<br/>xfsdump: ino map phase 2: skipping (no pruning necessary)<br/>xfsdump: ino map phase 3: skipping (only one dump stream)<br/>xfsdump: ino map construction complete<br/>xfsdump: estimated dump size: 8501529728 bytes<br/>xfsdump: WARNING: no media label specified<br/>xfsdump: creating dump session media file 0 (media 0, file 0)<br/>xfsdump: dumping ino map<br/>xfsdump: dumping directories<br/>xfsdump: dumping non-directory files<br/>xfsdump: ending media file<br/>xfsdump: media file size 8263474064 bytes<br/>xfsdump: dump size (non-dir files) : 8158542168 bytes<br/>xfsdump: dump complete: 232 seconds elapsed<br/>xfsdump: Dump Summary:<br/>xfsdump:   stream 0 /tmp/ol8_root_backup OK (success)<br/>xfsdump: Dump Status: SUCCESS</span></pre><p id="abfd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据源实例的根(/)文件系统的大小，备份可能需要几分钟时间。</p><p id="5e23" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">备份成功完成后，从<code class="du jc jd je jf b">/mnt</code>卸载源实例根(/)文件系统:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="b306" class="ld ju hh jf b be le lf l lg lh">$ sudo umount /mnt</span></pre><p id="c493" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 4。调整源实例“根”逻辑卷的大小，并重新创建“根”逻辑卷文件系统</strong></p><p id="efb9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们需要调整源实例的<code class="du jc jd je jf b">root</code>逻辑卷的大小。使用<code class="du jc jd je jf b">lvreduce</code>执行收缩操作，我们将其减少15Gb ( <code class="du jc jd je jf b">-L -15G</code>)。选择15Gb是因为4+1+1+1 Gb用于新文件系统，还有一些空间(8Gb)留给未来的文件系统(如其他代理软件)。在本例中,<code class="du jc jd je jf b">root</code>逻辑卷可能会缩减超过10Gb，但是请记住，需要保留足够的空间来恢复备份的根(/)文件系统。</p><p id="8a0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">⚠️:下面的步骤是破坏性的！</p><p id="1950" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，使用测试模式(<code class="du jc jd je jf b">-t</code>)检查调整大小是否成功:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="004e" class="ld ju hh jf b be le lf l lg lh">$ sudo lvreduce -ft -L -15G /dev/ocivolume/root<br/>  TEST MODE: Metadata will NOT be updated and volumes will not be (de)activated.<br/>  WARNING: Reducing active logical volume to 20.47 GiB.<br/>  THIS MAY DESTROY YOUR DATA (filesystem etc.)<br/>  Size of logical volume ocivolume/root changed from 35.47 GiB (9081 extents) to 20.47 GiB (5241 extents).<br/>  Logical volume ocivolume/root successfully resized.</span></pre><p id="4c4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果调整大小操作测试正常，实际调整大小:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="8b95" class="ld ju hh jf b be le lf l lg lh">$ sudo lvreduce -f -L -15G /dev/ocivolume/root<br/>  WARNING: Reducing active logical volume to 20.47 GiB.<br/>  THIS MAY DESTROY YOUR DATA (filesystem etc.)<br/>  Size of logical volume ocivolume/root changed from 35.47 GiB (9081 extents) to 20.47 GiB (5241 extents).<br/>  Logical volume ocivolume/root successfully resized.</span></pre><p id="5f96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后在源实例的<code class="du jc jd je jf b">root</code>逻辑卷(<code class="du jc jd je jf b">ocivolume-root</code>)上重新创建XFS文件系统:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="8512" class="ld ju hh jf b be le lf l lg lh">$ sudo mkfs.xfs -f /dev/mapper/ocivolume-root<br/>meta-data=/dev/mapper/ocivolume-root isize=512    agcount=4, agsize=1341696 blks<br/>         =                       sectsz=4096  attr=2, projid32bit=1<br/>         =                       crc=1        finobt=1, sparse=1, rmapbt=0<br/>         =                       reflink=1    bigtime=0 inobtcount=0<br/>data     =                       bsize=4096   blocks=5366784, imaxpct=25<br/>         =                       sunit=0      swidth=0 blks<br/>naming   =version 2              bsize=4096   ascii-ci=0, ftype=1<br/>log      =internal log           bsize=4096   blocks=2620, version=2<br/>         =                       sectsz=4096  sunit=1 blks, lazy-count=1<br/>realtime =none                   extsz=4096   blocks=0, rtextents=0</span></pre><p id="5ef9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 5。创建额外的逻辑卷，并在其上创建文件系统</strong></p><p id="5947" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建新的逻辑卷:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="7a33" class="ld ju hh jf b be le lf l lg lh">$ sudo lvcreate ocivolume -L 4G -n tmp<br/>  Logical volume "tmp" created.<br/>$ sudo lvcreate ocivolume -L 1G -n var<br/>  Logical volume "var" created.<br/>$ sudo lvcreate ocivolume -L 1G -n varlog<br/>  Logical volume "varlog" created.<br/>$ sudo lvcreate ocivolume -L 1G -n home<br/>  Logical volume "home" created.</span></pre><p id="6480" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用<code class="du jc jd je jf b">mkfs.xfs</code>创建新的文件系统:</p><blockquote class="kt ku kv"><p id="768f" class="ie if jg ig b ih ii ij ik il im in io kw iq ir is kx iu iv iw ky iy iz ja jb ha bi translated">请记住，设备映射器将以<volume_group> - <logical_volume>的形式创建新条目。</logical_volume></volume_group></p></blockquote><ul class=""><li id="5594" class="li lj hh ig b ih ii il im ip lk it ll ix lm jb ln lo lp lq bi translated">对于新的<code class="du jc jd je jf b">/tmp</code> — <code class="du jc jd je jf b">sudo mkfs.xfs -f /dev/mapper/ocivolume-tmp</code></li><li id="10a8" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated">为新的<code class="du jc jd je jf b">/var</code> — <code class="du jc jd je jf b">sudo mkfs.xfs -f /dev/mapper/ocivolume-var</code></li><li id="c1e3" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated">为了新的<code class="du jc jd je jf b">/var/log</code>——<code class="du jc jd je jf b">sudo mkfs.xfs -f /dev/mapper/ocivolume-varlog</code></li><li id="f289" class="li lj hh ig b ih lr il ls ip lt it lu ix lv jb ln lo lp lq bi translated">为了新的<code class="du jc jd je jf b">/home</code>——<code class="du jc jd je jf b">sudo mkfs.xfs -f /dev/mapper/ocivolume-home</code></li></ul><p id="f06a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这应该是这样的:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="ac5a" class="ld ju hh jf b be le lf l lg lh">$ sudo mkfs.xfs -f /dev/mapper/ocivolume-tmp<br/>meta-data=/dev/mapper/ocivolume-tmp isize=512    agcount=4, agsize=262144 blks<br/>         =                       sectsz=4096  attr=2, projid32bit=1<br/>         =                       crc=1        finobt=1, sparse=1, rmapbt=0<br/>         =                       reflink=1    bigtime=0 inobtcount=0<br/>data     =                       bsize=4096   blocks=1048576, imaxpct=25<br/>         =                       sunit=0      swidth=0 blks<br/>naming   =version 2              bsize=4096   ascii-ci=0, ftype=1<br/>log      =internal log           bsize=4096   blocks=2560, version=2<br/>         =                       sectsz=4096  sunit=1 blks, lazy-count=1<br/>realtime =none                   extsz=4096   blocks=0, rtextents=0<br/><br/>$ sudo mkfs.xfs -f /dev/mapper/ocivolume-var<br/>meta-data=/dev/mapper/ocivolume-var isize=512    agcount=4, agsize=65536 blks<br/>         =                       sectsz=4096  attr=2, projid32bit=1<br/>         =                       crc=1        finobt=1, sparse=1, rmapbt=0<br/>         =                       reflink=1    bigtime=0 inobtcount=0<br/>data     =                       bsize=4096   blocks=262144, imaxpct=25<br/>         =                       sunit=0      swidth=0 blks<br/>naming   =version 2              bsize=4096   ascii-ci=0, ftype=1<br/>log      =internal log           bsize=4096   blocks=2560, version=2<br/>         =                       sectsz=4096  sunit=1 blks, lazy-count=1<br/>realtime =none                   extsz=4096   blocks=0, rtextents=0<br/><br/>$ sudo mkfs.xfs -f /dev/mapper/ocivolume-varlog<br/>meta-data=/dev/mapper/ocivolume-varlog isize=512    agcount=4, agsize=65536 blks<br/>         =                       sectsz=4096  attr=2, projid32bit=1<br/>         =                       crc=1        finobt=1, sparse=1, rmapbt=0<br/>         =                       reflink=1    bigtime=0 inobtcount=0<br/>data     =                       bsize=4096   blocks=262144, imaxpct=25<br/>         =                       sunit=0      swidth=0 blks<br/>naming   =version 2              bsize=4096   ascii-ci=0, ftype=1<br/>log      =internal log           bsize=4096   blocks=2560, version=2<br/>         =                       sectsz=4096  sunit=1 blks, lazy-count=1<br/>realtime =none                   extsz=4096   blocks=0, rtextents=0<br/><br/>$ sudo mkfs.xfs -f /dev/mapper/ocivolume-home<br/>meta-data=/dev/mapper/ocivolume-home isize=512    agcount=4, agsize=65536 blks<br/>         =                       sectsz=4096  attr=2, projid32bit=1<br/>         =                       crc=1        finobt=1, sparse=1, rmapbt=0<br/>         =                       reflink=1    bigtime=0 inobtcount=0<br/>data     =                       bsize=4096   blocks=262144, imaxpct=25<br/>         =                       sunit=0      swidth=0 blks<br/>naming   =version 2              bsize=4096   ascii-ci=0, ftype=1<br/>log      =internal log           bsize=4096   blocks=2560, version=2<br/>         =                       sectsz=4096  sunit=1 blks, lazy-count=1<br/>realtime =none                   extsz=4096   blocks=0, rtextents=0</span></pre><p id="953a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">6。将源实例根(/)文件系统恢复到调整大小后的“根”逻辑卷</p><p id="d910" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将源实例<code class="du jc jd je jf b">root</code>逻辑卷(现在已格式化且为空)挂载回<code class="du jc jd je jf b">/mnt</code>:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="1ead" class="ld ju hh jf b be le lf l lg lh">$ sudo mount /dev/mapper/ocivolume-root /mnt<br/>$ df -hP<br/>Filesystem                  Size  Used Avail Use% Mounted on<br/>tmpfs                       1.6G  1.1M  1.6G   1% /run<br/>/dev/sda1                    45G  9.5G   36G  21% /<br/>tmpfs                       7.9G     0  7.9G   0% /dev/shm<br/>tmpfs                       5.0M     0  5.0M   0% /run/lock<br/>/dev/sda15                  105M  5.3M  100M   5% /boot/efi<br/>tmpfs                       1.6G  4.0K  1.6G   1% /run/user/1001<br/>/dev/mapper/ocivolume-root   21G  179M   21G   1% /mnt</span></pre><p id="4e10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">调整大小后的空源实例的<code class="du jc jd je jf b">root</code>逻辑卷装载到<code class="du jc jd je jf b">/mnt</code>后，我们恢复文件系统备份:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="bd41" class="ld ju hh jf b be le lf l lg lh">$ sudo xfsrestore -f /tmp/ol8_root_backup /mnt<br/>xfsrestore: using file dump (drive_simple) strategy<br/>xfsrestore: version 3.1.9 (dump format 3.0) - type ^C for status and control<br/>xfsrestore: searching media for dump<br/>xfsrestore: examining media file 0<br/>xfsrestore: dump description: <br/>xfsrestore: hostname: worker<br/>xfsrestore: mount point: /mnt<br/>xfsrestore: volume: /dev/mapper/ocivolume-root<br/>xfsrestore: session time: Mon Jun 13 00:28:36 2022<br/>xfsrestore: level: 0<br/>xfsrestore: session label: ""<br/>xfsrestore: media label: ""<br/>xfsrestore: file system id: b74c7d6e-a842-4ab7-a47e-2ac332edaa3d<br/>xfsrestore: session id: 08bc394b-465a-4f67-b301-8364ad848d9b<br/>xfsrestore: media id: 15cccbfe-fcde-4b71-9122-52f6500610f8<br/>xfsrestore: using online session inventory<br/>xfsrestore: searching media for directory dump<br/>xfsrestore: reading directories<br/>xfsrestore: 18592 directories and 170057 entries processed<br/>xfsrestore: directory post-processing<br/>xfsrestore: restoring non-directory files<br/>xfsrestore: restore complete: 253 seconds elapsed<br/>xfsrestore: Restore Summary:<br/>xfsrestore:   stream 0 /tmp/ol8_root_backup OK (success)<br/>xfsrestore: Restore Status: SUCCESS</span></pre><p id="8ec9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 7。为新的逻辑卷创建挂载点并挂载它们</strong></p><p id="4451" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">新的(即替换的)<code class="du jc jd je jf b">tmp</code>(<code class="du jc jd je jf b">/mnt/tmp-new</code>)<code class="du jc jd je jf b">var</code>(<code class="du jc jd je jf b">/mnt/var-new</code>)<code class="du jc jd je jf b">varlog</code>(<code class="du jc jd je jf b">/mnt/var-new/log</code>)和<code class="du jc jd je jf b">home</code> ( <code class="du jc jd je jf b">/mnt/home-new</code>)位置需要临时挂载点。</p><blockquote class="kt ku kv"><p id="c3d8" class="ie if jg ig b ih ii ij ik il im in io kw iq ir is kx iu iv iw ky iy iz ja jb ha bi translated">请注意，新的目标<code class="du jc jd je jf b">/var/log</code>位置是一个新的文件系统，必须相对于新的<code class="du jc jd je jf b">/var</code>位置进行挂载。因此，在新的<code class="du jc jd je jf b">var</code>逻辑卷已经被挂载到<code class="du jc jd je jf b">/mnt/var-new</code>之后，新的<code class="du jc jd je jf b">varlog</code>逻辑卷将被挂载到<code class="du jc jd je jf b">/mnt/var-new/log</code>用于复制数据<strong class="ig hi">。</strong></p></blockquote><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="4764" class="ld ju hh jf b be le lf l lg lh">$ sudo mkdir /mnt/tmp-new /mnt/home-new /mnt/var-new<br/><br/>$ sudo mount /dev/mapper/ocivolume-tmp /mnt/tmp-new<br/>$ sudo chmod 1777 /mnt/tmp-new                         # Set correct permissions for a "/tmp"<br/>$ sudo mount /dev/mapper/ocivolume-var /mnt/var-new<br/>$ sudo mount /dev/mapper/ocivolume-home /mnt/home-new<br/>$ sudo mkdir /mnt/var-new/log                          # Place the new "/var/log" mount point into the new "/var"<br/>$ sudo mount /dev/mapper/ocivolume-varlog /mnt/var-new/log</span></pre><p id="6665" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 8。将</strong><code class="du jc jd je jf b"><strong class="ig hi">/tmp</strong></code><strong class="ig hi"/><code class="du jc jd je jf b"><strong class="ig hi">/var</strong></code><strong class="ig hi"/><code class="du jc jd je jf b"><strong class="ig hi">/var/log</strong></code><strong class="ig hi">和</strong> <code class="du jc jd je jf b"><strong class="ig hi">/home</strong></code> <strong class="ig hi">从源根(/)文件系统复制到新文件系统上的临时挂载点</strong></p><p id="4d96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从恢复的根(/)文件系统复制(并保留属性)到新逻辑卷的临时挂载:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="80b6" class="ld ju hh jf b be le lf l lg lh">$ sudo cp -rp /mnt/home/. /mnt/home-new/<br/>$ sudo cp -rp /mnt/tmp/. /mnt/tmp-new/<br/>$ sudo cp -rp /mnt/var/. /mnt/var-new/</span></pre><p id="e0e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 9。重命名原始的</strong> <code class="du jc jd je jf b"><strong class="ig hi">/tmp</strong></code> <strong class="ig hi">、</strong> <code class="du jc jd je jf b"><strong class="ig hi">/var</strong></code> <strong class="ig hi">和</strong> <code class="du jc jd je jf b"><strong class="ig hi">/home</strong></code> <strong class="ig hi">目录，并替换为新的挂载点</strong></p><p id="611c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一部分是将现有目录转移到“备份位置”,并重新定位临时挂载点以替换那些原始目录。</p><p id="2878" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们需要从临时挂载点卸载逻辑卷，以便可以对它们以及原始位置进行重命名:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="757e" class="ld ju hh jf b be le lf l lg lh">$ sudo umount /mnt/home-new /mnt/var-new/log /mnt/var-new /mnt/tmp-new</span></pre><p id="b5e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，重新排列旧位置和新挂载点:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="12ba" class="ld ju hh jf b be le lf l lg lh">$ sudo mv /mnt/home /mnt/home-old &amp;&amp; sudo mv /mnt/home-new /mnt/home<br/>$ sudo mv /mnt/tmp /mnt/tmp-old &amp;&amp; sudo mv /mnt/tmp-new /mnt/tmp<br/>$ sudo mv /mnt/var /mnt/var-old &amp;&amp; sudo mv /mnt/var-new /mnt/var</span></pre><p id="f689" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">10。更新源实例 <code class="du jc jd je jf b"><strong class="ig hi">fstab</strong></code> <strong class="ig hi">以在引导时挂载新的文件系统</strong></p><p id="c0ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了确保新的逻辑卷和文件系统在引导时挂载，请将以下条目添加到源实例的<code class="du jc jd je jf b">fstab</code>中的<code class="du jc jd je jf b">/var/oled</code>条目之前:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="eb72" class="ld ju hh jf b be le lf l lg lh">/dev/mapper/ocivolume-tmp /tmp                     xfs     defaults        0 0<br/>/dev/mapper/ocivolume-var /var                     xfs     defaults        0 0<br/>/dev/mapper/ocivolume-varlog /var/log              xfs     defaults        0 0<br/>/dev/mapper/ocivolume-home /home                   xfs     defaults        0 0</span></pre><p id="7a5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，编辑源OL8图像的<code class="du jc jd je jf b">fstab</code>(当前位于<code class="du jc jd je jf b">/mnt/etc</code>)文件，使其内容反映如下:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="0e0e" class="ld ju hh jf b be le lf l lg lh">$ sudo vi /mnt/etc/fstab <br/><br/>$ cat /mnt/etc/fstab<br/><br/>#<br/># /etc/fstab<br/># Created by anaconda on Wed May 18 23:33:09 2022<br/>#<br/># Accessible filesystems, by reference, are maintained under '/dev/disk/'.<br/># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info.<br/>#<br/># After editing this file, run 'systemctl daemon-reload' to update systemd<br/># units generated from this file.<br/>#<br/>/dev/mapper/ocivolume-root /                       xfs     defaults        0 0<br/>UUID=a619a666-d067-48a1-84c0-597037623f97 /boot                   xfs     defaults        0 0<br/>UUID=2314-8847          /boot/efi               vfat    defaults,uid=0,gid=0,umask=077,shortname=winnt 0 2<br/>/dev/mapper/ocivolume-tmp /tmp                     xfs     defaults        0 0<br/>/dev/mapper/ocivolume-var /var                     xfs     defaults        0 0<br/>/dev/mapper/ocivolume-varlog /var/log              xfs     defaults        0 0<br/>/dev/mapper/ocivolume-home /home                   xfs     defaults        0 0<br/>/dev/mapper/ocivolume-oled /var/oled               xfs     defaults        0 0<br/>tmpfs                   /dev/shm                tmpfs   defaults,nodev,nosuid,noexec      0 0<br/>######################################<br/>## ORACLE CLOUD INFRASTRUCTURE CUSTOMERS<br/>##<br/>## If you are adding an iSCSI remote block volume to this file you MUST<br/>## include the '_netdev' mount option or your instance will become<br/>## unavailable after the next reboot.<br/>## SCSI device names are not stable across reboots; please use the device UUID instead of /dev path.<br/>##<br/>## Example:<br/>## UUID="94c5aade-8bb1-4d55-ad0c-388bb8aa716a"   /data1    xfs       defaults,noatime,_netdev      0      2<br/>##<br/>## More information:<br/>## https://docs.us-phoenix-1.oraclecloud.com/Content/Block/Tasks/connectingtoavolume.htm<br/>/.swapfile none swap sw,comment=cloudconfig 0 0</span></pre><p id="539e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">11。保证SELinux会开心</p><p id="fc44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果SELinux被启用并且<code class="du jc jd je jf b">enforcing</code>它不会高兴文件系统被修改。虽然实例可以启动，但它不太可能正常工作，用户将无法远程登录。为了确保这种情况不会发生，最简单的方法是在下次引导时强制重新标记实例。为此，在源实例的根(/)文件系统中创建一个标志文件(<code class="du jc jd je jf b">.autorelabel</code>)(再次提醒，源实例根(/)当前被挂载到<code class="du jc jd je jf b">/mnt</code>):</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="79e3" class="ld ju hh jf b be le lf l lg lh">$ sudo touch /mnt/.autorelabel</span></pre><p id="dc93" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是所有应该要求的。下次引导时，SELinux应该将所有标签重新应用到文件系统。</p><blockquote class="kt ku kv"><p id="e6ab" class="ie if jg ig b ih ii ij ik il im in io kw iq ir is kx iu iv iw ky iy iz ja jb ha bi translated">⚠️重新标记整个文件系统结构可能需要相当长的时间，所以在第一次启动时要有耐心。一旦完成，标记文件将自动删除，随后的引导将是正常的。</p></blockquote><p id="ddaf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">12。从工作实例中卸载并分离源实例引导卷，并连接回源实例</p><p id="0250" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">剩下的工作就是卸载并分离源实例的<code class="du jc jd je jf b">root</code>逻辑卷，将其从worker实例中分离出来，将其连接回源实例，并启动源实例进行测试。</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="55b0" class="ld ju hh jf b be le lf l lg lh">$ sudo umount /mnt</span></pre><p id="ea80" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jg">可选</em> </strong>检查所有新的文件系统:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="46b3" class="ld ju hh jf b be le lf l lg lh">$ sudo xfs_repair /dev/mapper/ocivolume-root<br/>...<br/>$ sudo xfs_repair /dev/mapper/ocivolume-tmp<br/>...<br/>$ sudo xfs_repair /dev/mapper/ocivolume-var<br/>...<br/>$ sudo xfs_repair /dev/mapper/ocivolume-varlog<br/>...<br/>$ sudo xfs_repair /dev/mapper/ocivolume-home<br/>...</span></pre><p id="2029" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">满意地完成所有工作并且卸载了源实例的<code class="du jc jd je jf b">root</code>逻辑卷后，使用OCI控制台或您选择的工具将源实例的引导卷从工作实例中分离出来。然后将源实例的引导卷挂回到源OL8实例，作为其引导卷。</p><p id="e840" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 13。测试</strong></p><p id="aa2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在使用重新构建的引导卷启动源实例之前，建议为该实例创建一个串行控制台连接，并使用另一个会话连接到该实例，以监控引导过程中的任何问题。</p><p id="28cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">启动源实例后，登录并验证新的文件系统结构。</p><p id="b7e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jc jd je jf b">/tmp</code>、<code class="du jc jd je jf b">/var</code>和<code class="du jc jd je jf b">/home</code>的原结构仍为<code class="du jc jd je jf b">/tmp-old</code>、<code class="du jc jd je jf b">/var-old</code>和<code class="du jc jd je jf b">/home-old</code>。如果一切正常，移除这些先前的结构:</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="4c15" class="ld ju hh jf b be le lf l lg lh">$ sudo rm -rf /tmp-old /var-old /home-old</span></pre><p id="647b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果一切正常，可以考虑创建一个定制的映像，以便于重用新的文件系统结构。参见<a class="ae lx" href="https://docs.oracle.com/en-us/iaas/Content/Compute/Tasks/managingcustomimages.htm" rel="noopener ugc nofollow" target="_blank">管理自定义图像</a>。</p><p id="4b90" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大概就是这样！</p><p id="df9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你对Oracle开发人员在他们的自然环境中发生的事情感到好奇，来<a class="ae lx" href="https://bit.ly/odevrel_slack" rel="noopener ugc nofollow" target="_blank">加入我们的公共休闲频道</a>！</p><h2 id="ccd8" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">附录—脚本</h2><p id="d9a9" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">⚠️ <strong class="ig hi"> <em class="jg">慎用！</em> </strong></p><p id="6517" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的脚本非常简单，一旦源实例的启动卷被连接，如果在worker实例上运行，它将执行步骤3到12(除了detatch)。检查非常有限，所有值都是硬编码的。如果OL8的平台映像发生变化，或者针对不同的平台映像运行，脚本很可能会失败，导致重构不完整或目标引导卷损坏。强烈建议创建备份或使用目标启动卷的副本。</p><p id="a083" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">⚠️ <strong class="ig hi"> <em class="jg">慎用！</em> </strong></p><p id="1f8d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> refactor.sh </strong> —用法<code class="du jc jd je jf b">sudo refactor.sh</code>交叉手指…</p><pre class="ji jj jk jl fd kz jf la bn lb lc bi"><span id="7596" class="ld ju hh jf b be le lf l lg lh">#!/bin/bash<br/><br/>if [ "${EUID}" -ne 0 ]; then<br/>  printf "Please run as root.\n"<br/>  exit 1<br/>fi<br/><br/>printf "Refreshing volume groups...\n%s\n\n" "$(vgchange -a y)"<br/>printf "These are the logical volumes...\n%s\n\n" "$(lvdisplay)"<br/>printf "The block devices...\n%s\n\n" "$(lsblk -f)"<br/><br/>printf "Sanity checking the root file system...\n"<br/>printf "%s\n\n" "$(xfs_repair /dev/mapper/ocivolume-root 2&gt;&amp;1)"<br/><br/>printf "Mounting root file system... "<br/>mount /dev/mapper/ocivolume-root /mnt<br/>if [ ${?} -ne 0 ]; then<br/>  printf "mounting failed!\nAbort...\n"<br/>  exit 1<br/>else<br/>  printf "done.\n\n"<br/>fi<br/><br/>printf "Backing up root file system...\n"<br/>OUTPUT=$(xfsdump -L \"\" -M \"\" -0uf /tmp/ol8_root_backup /mnt 2&gt;&amp;1)<br/>if [ ${?} -ne 0 ]; then<br/>  printf "%s\n\nBackup failed!\nAbort...\n" "${OUTPUT}"<br/>  umount /mnt<br/>  exit 1<br/>else<br/>  printf "%s\n\n" "${OUTPUT}"<br/>fi<br/><br/>printf "Unmounting root file system... "<br/>umount /mnt<br/>if [ ${?} -ne 0 ]; then<br/>  printf "unmounting failed!\nAbort...\n"<br/>  exit 1<br/>else<br/>  printf "done.\n\n"<br/>fi<br/><br/>printf "Testing resize of root file system...\n"<br/>OUTPUT=$(lvreduce -ft -L -15G /dev/ocivolume/root 2&gt;&amp;1)<br/>if [ ${?} -ne 0 ]; then<br/>  printf "%s\n\nTest failed!\nAbort...\n" "${OUTPUT}"<br/>  exit 1<br/>else<br/>  printf "%s\n\nTest ok, procceding.\n\n" "${OUTPUT}"<br/>fi<br/><br/>printf "Resize of root file system...\n"<br/>OUTPUT=$(lvreduce -f -L -15G /dev/ocivolume/root)<br/>if [ ${?} -ne 0 ]; then<br/>  printf "%s\n\nResize failed!\n Abort...\n" "${OUTPUT}"<br/>  exit 1<br/>else<br/>  printf "%s\n\nResized!\n\n" "${OUTPUT}"<br/>fi<br/><br/>printf "Recreate root file system...\n%s\n\n" "$(mkfs.xfs -f /dev/mapper/ocivolume-root 2&gt;&amp;1)"<br/><br/>printf "Creating new logical volumes...\n"<br/>lvcreate ocivolume -L 4G -n tmp<br/>lvcreate ocivolume -L 1G -n var<br/>lvcreate ocivolume -L 1G -n varlog<br/>lvcreate ocivolume -L 1G -n home<br/><br/>printf "Creating new file systems...\n"<br/>mkfs.xfs -f /dev/mapper/ocivolume-tmp<br/>mkfs.xfs -f /dev/mapper/ocivolume-var<br/>mkfs.xfs -f /dev/mapper/ocivolume-varlog<br/>mkfs.xfs -f /dev/mapper/ocivolume-home<br/><br/>printf "Remounting root file systems... "<br/>mount /dev/mapper/ocivolume-root /mnt<br/>if [ ${?} -ne 0 ]; then<br/>  printf "mounting failed!\nAbort...\n"<br/>  exit 1<br/>else<br/>  printf "done.\n\n"<br/>fi<br/><br/>printf "Restoring root file system...\n"<br/>OUTPUT=$(xfsrestore -f /tmp/ol8_root_backup /mnt 2&gt;&amp;1)<br/>if [ ${?} -ne 0 ]; then<br/>  printf "%s\n\nRestore failed!\nAbort...\n" "${OUTPUT}"<br/>  umount /mnt<br/>  exit 1<br/>else<br/>  printf "%s\n\n" "${OUTPUT}"<br/>fi<br/><br/>printf "Creating temporary mount points...\n"<br/>mkdir /mnt/tmp-new /mnt/home-new /mnt/var-new /mnt/agent<br/><br/>printf "Mount volumes... "<br/>mount /dev/mapper/ocivolume-tmp /mnt/tmp-new &amp;&amp; chmod 1777 /mnt/tmp-new &amp;&amp; mount /dev/mapper/ocivolume-var /mnt/var-new &amp;&amp; mount /dev/mapper/ocivolume-home /mnt/home-new &amp;&amp; mount /dev/mapper/ocivolume-agent /mnt/agent &amp;&amp; mkdir /mnt/var-new/log &amp;&amp; mount /dev/mapper/ocivolume-varlog /mnt/var-new/log<br/>if [ ${?} -ne 0 ]; then<br/>  printf "mounting and mapping failed!\nAbort...\n"<br/>  exit 1<br/>else<br/>  printf "done.\n\n"<br/>fi<br/><br/>printf "Copying files to volumes...\n"<br/>cp -rp /mnt/home/. /mnt/home-new/<br/>cp -rp /mnt/tmp/. /mnt/tmp-new/<br/>cp -rp /mnt/var/. /mnt/var-new/<br/><br/>printf "Unmounting volumes... "<br/>umount /mnt/home-new /mnt/var-new/log /mnt/var-new /mnt/tmp-new /mnt/agent<br/>if [ ${?} -ne 0 ]; then<br/>  printf "unmounting failed!\nAbort...\n"<br/>  exit 1<br/>else<br/>  printf "done.\n\n"<br/>fi<br/><br/>printf "Shuffling locations and mount points... "<br/>mv /mnt/home /mnt/home-old &amp;&amp; sudo mv /mnt/home-new /mnt/home &amp;&amp; mv /mnt/tmp /mnt/tmp-old &amp;&amp; sudo mv /mnt/tmp-new /mnt/tmp &amp;&amp; mv /mnt/var /mnt/var-old &amp;&amp; sudo mv /mnt/var-new /mnt/var<br/>if [ ${?} -ne 0 ]; then<br/>  printf "failed!\nAbort...\n"<br/>  exit 1<br/>else<br/>  printf "done.\n\n"<br/>fi<br/><br/>printf "Touching marker file for SELinux relabelling...\n"<br/>touch /mnt/.autorelabel<br/><br/>printf "Changing fstab...\n"<br/>sed -i-$(date +%Y%m%d) -e'/.*\/var\/oled.*/i /dev/mapper/ocivolume-tmp /tmp                     xfs     defaults        0 0\n/dev/mapper/ocivolume-var /var                     xfs     defaults        0 0\n/dev/mapper/ocivolume-varlog /var/log              xfs     defaults        0 0\n/dev/mapper/ocivolume-home /home                   xfs     defaults        0 0\n/dev/mapper/ocivolume-agent /agent                 xfs     defaults        0 0' /mnt/etc/fstab<br/><br/>cat /mnt/etc/fstab<br/><br/>printf "Unounting root file system... "<br/>umount /mnt<br/>if [ ${?} -ne 0 ]; then<br/>  printf "unmounting failed!\nAbort...\n"<br/>  exit 1<br/>else<br/>  printf "done.\n\n"<br/>fi<br/><br/>printf "\nAll done.\n\nPlease detach the volume and test.\n"</span></pre></div></div>    
</body>
</html>