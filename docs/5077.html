<html>
<head>
<title>Building a form with dropdown lists for specialised objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为特定对象构建带有下拉列表的表单</h1>
<blockquote>原文：<a href="https://medium.com/mendix/build-form-with-dropdown-lists-for-switching-specialised-objects-in-mendix-a8e3cf5891fc?source=collection_archive---------4-----------------------#2020-11-20">https://medium.com/mendix/build-form-with-dropdown-lists-for-switching-specialised-objects-in-mendix-a8e3cf5891fc?source=collection_archive---------4-----------------------#2020-11-20</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/b71bac5810e1056705844b97758c3184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLDh-vrDXsUB9sHsurZ1Ow.png"/></div></div></figure><div class=""/></div><div class="ab cl jc jd hb je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="hn ho hp hq hr"><h1 id="5e13" class="jj jk if bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">背景</h1><p id="3b41" class="pw-post-body-paragraph kh ki if bd b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">我的域模型包含一个名为Object A的实体，它与另一个名为Object_B的实体有两种关系:Object和CounterObject。对象B有两个专门化Spec_L和Spec_K。</p><p id="1c31" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">Object_A有一个ObjectType属性，可以是Type_X或Type _ y。Type _ X表示Spec_L是对象，Spec_K是反对象。Type_Y表示Spec_K是对象，Spec_L是反对象。</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lj"><img src="../Images/ed6412fa163b8d042a46060df9df02df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JJJvNTMRrh-pfE2JLoMbA.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Domain Model</figcaption></figure></div><div class="ab cl jc jd hb je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="hn ho hp hq hr"><h1 id="0375" class="jj jk if bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">界面</h1><p id="007f" class="pw-post-body-paragraph kh ki if bd b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">我们有对象A和对象b的选项卡。在对象A选项卡上，有一个3:9布局网格，在较小的左半部分有一个所有对象的ListView，在较大的右半部分有一个DataView，它监听对象a ListView。根据设置，对象和反对象的下拉列表取决于对象类型。所以对于Type_X，对象是Spec_L，反对象是Spec_K，</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ls"><img src="../Images/6876f8102328951740afa54a773b82fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QeeGgvZbOYGpwgtDX4UiCA.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Type X View of Object A</figcaption></figure><p id="94ee" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">而对于Type_Y，对象是Spec_K的，反对象是Spec_L的</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lt"><img src="../Images/f0dd647710b93cfe6130c5fb0ecee189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jVJCmnu9k3LRslCj1Zi6Q.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Type_Y view of Object A</figcaption></figure><p id="b5ff" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">这是通过依赖于对象类型的可见性来实现的。该表单有四个dropdownlists(两对)，其中每种类型都有两个可见的列表。</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lu"><img src="../Images/c242c3888fcc81ffc1b875d972c4ed8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvmc8WbtdVj3S6m1zjGVKw.png"/></div></div></figure><p id="ad49" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">还有一个加号按钮，它创建一个Object_A对象并打开一个模态弹出窗口来输入数据。</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff lv"><img src="../Images/af7fa53e6531e20d244dc85f8bb3aadd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENrRyQpJHIHVevZpCIyjag.png"/></div></div><figcaption class="lo lp fg fe ff lq lr bd b be z ek">Object A create modal</figcaption></figure><p id="4b8f" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">对象形式是一个片段。所有三个字段(Type、Object、CounterObject)都将commit对象作为onChange事件。</p><p id="619f" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">如您所见，任何视图上都没有保存或取消按钮。因此任何更改一发生就被提交。</p></div><div class="ab cl jc jd hb je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="hn ho hp hq hr"><h1 id="5ad2" class="jj jk if bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">问题是</h1><p id="a3c4" class="pw-post-body-paragraph kh ki if bd b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">一旦对象类型改变，就会有一个Spec_L-Object_B作为参考，其中可选项目是Spec_K-ObjectBs，反之亦然。Mendix无法显示条目，并且在页面重新加载之前拒绝接受对下拉列表的更改。因为我们已经定义了任何特化都可以存储为对象或反对象，所以我们可能需要通过微流手动切换对象。但是Mendix仍然没有显示条目，并且在页面重新加载之前无法进行更改。</p><h1 id="613f" class="jj jk if bd jl jm lw jo jp jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg dt translated">详细步骤</h1><ol class=""><li id="05ca" class="mb mc if bd b kj kk kn ko kr md kv me kz mf ld mg mh mi mj dt translated">创建两个对象b，一个名为L_Beer，另一个名为K _香肠。</li></ol><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mk"><img src="../Images/6955251dfa0cda16bcf1407b4947eea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXag_6rfyoGSvXrVyz27zA.png"/></div></div></figure><p id="68ae" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">2.创建一个对象A作为Type_X对象:</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff ml"><img src="../Images/a67aa85fb4aff0ff6c1fccccf1974cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HU6UeqWnQ-wRpbUGVdKfFQ.png"/></div></div></figure><p id="a1a3" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">3.将类型切换到类型_Y</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mm"><img src="../Images/2134e23bd4490fa7f9522a11e2c66bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uu_XIZ14xWbskOu6GoIeKg.png"/></div></div></figure><p id="b401" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">正如所料，下拉字段现在显示B_Spec_K作为第一个元素，B_Spec_L作为第二个元素。但是条目不见了。在页面重新加载之前，无法选择对象。</p></div><div class="ab cl jc jd hb je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="hn ho hp hq hr"><h1 id="e347" class="jj jk if bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg dt translated">第一种方法</h1><p id="a668" class="pw-post-body-paragraph kh ki if bd b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">我在support.mendix.com制造了一个事件指向这篇文章，他们建议:</p><p id="3f68" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated"><em class="mn">可能的解决方法是，每个属性使用两个引用选择器，而不是使用条件可见性在它们之间切换，这可以通过每个属性一个引用选择器来实现。引用选择器应该使用泛化(ObjectB)作为它的“数据源”,使用微流作为它的“可选对象”,根据对象类型查询正确的专门化。</em></p><p id="a252" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">这些对象没有出现的原因是:</p><p id="c199" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">似乎只要类型被切换一次，就有两个引用选择器(一个可见，一个不可见)同时对同一个属性进行操作，并且具有冲突的约束。每当其中一个试图设置一个值时，另一个会立即将其重置为空，因为它无效。</p><p id="f9a3" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">所以我更改了代码片段(实际上我复制了它并更改了副本)，但很快发现标签也需要由微流确定，正如它所显示的(B_Spec_L ),即使其中有B_Spec_K对象:</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mo"><img src="../Images/69f515f1734e00574c8cd83ad3165a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZXcyPoLBsHg5CBilutc8g.png"/></div></div></figure><p id="36c1" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">标签只能通过计算的属性动态创建，所以我给对象b添加了一个标签属性。我知道这很难看，但现在看来这是解决问题的唯一方法(尽管有多个固定的形式)。</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/99320afe500409de1c837c20e7edb653.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*tmV3Ilfu5VOzQ1p7ueNYLA.png"/></div></figure><p id="f618" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">标签现在显示了属性</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mq"><img src="../Images/0d9161075ca500fcbff2a230760a9f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-UmU_0XEJrLdLA8NLRBJng.png"/></div></div></figure><p id="5201" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">它必须在一般化的ObjectB上完成，因为我们在请求属性时不知道专门化。属性后面的微流只做出一个对象决定，并在结束事件中硬编码了名称。是的，这真的很丑。</p><figure class="lk ll lm ln fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mr"><img src="../Images/f80b9a4c64d0e96bd6f5267cd4e5d656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ExLOCk02WAj11hUIM42Rvg.png"/></div></div></figure><p id="80f7" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">它不起作用。仅当选择了一个对象时，标签才会显示正确的值。当值为空时，没有关联，因此不能调用微流。</p><h1 id="3a5e" class="jj jk if bd jl jm lw jo jp jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg dt translated">借口:为什么对象类型决策是坏的</h1><p id="00b3" class="pw-post-body-paragraph kh ki if bd b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated"><a class="ae ms" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank">多态</a>(一般化-特殊化)模式开辟了一种高度灵活和可扩展的方式，将具有相同元结构的对象分组。要使用元对象的属性和关系，新定义的子对象应该只需要将元对象定义为其父对象(一般化)。有了对象类型决策，你就挫败了多态性的全部目的。例如，每次您扩展您的模型时，您都必须扩展您以前创建的所有对象类型决策。你越专门化，你的微流程就会越混乱。</p><p id="5e5e" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">早在c编程时代，最昂贵的代码修复位于嵌套的if和开关中。</p><p id="74f5" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">做！不是！用！ObjectTypeDecisions！</p><h1 id="0900" class="jj jk if bd jl jm lw jo jp jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg dt translated">结果</h1><p id="30a2" class="pw-post-body-paragraph kh ki if bd b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hn dt translated">如上所示，对象类型决策方法既不成功也不值得称赞。支持团队发现了问题。它之所以发生，是因为两个选择器对同一个对象进行操作。他们告诉我，他们<em class="mn">将在React中完全重写这个小部件，以扩展其功能，并使其与平台的其他部分保持一致。鉴于React小部件是如何实现条件可见性的，重写很可能会解决这个问题。</em></p><p id="d6b7" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">所以期待他们的解决方案！</p></div><div class="ab cl jc jd hb je" role="separator"><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh ji"/><span class="jf bw bk jg jh"/></div><div class="hn ho hp hq hr"><p id="e89a" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated"><em class="mn">来自发布者- </em></p><p id="2e59" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated"><em class="mn">上面讨论的问题将在未来的版本中解决。</em></p><p id="9418" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">如果你喜欢这篇文章，你可以在我们的 <a class="ae ms" href="https://medium.com/mendix" rel="noopener"> <em class="mn">媒体页面</em> </a> <em class="mn">或我们自己的</em> <a class="ae ms" href="https://developers.mendix.com/community-blog/" rel="noopener ugc nofollow" target="_blank"> <em class="mn">社区博客网站</em> </a> <em class="mn">找到更多类似的内容。</em></p><p id="e209" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated"><em class="mn">希望入门的创客可以注册一个</em> <a class="ae ms" href="https://developers.mendix.com/meetups/#meetupsNearYou" rel="noopener ugc nofollow" target="_blank"> <em class="mn">免费账号</em> </a> <em class="mn">，通过我们的</em> <a class="ae ms" href="https://academy.mendix.com/link/home" rel="noopener ugc nofollow" target="_blank"> <em class="mn">学苑</em> </a> <em class="mn">获得即时学习。</em></p><p id="b34d" class="pw-post-body-paragraph kh ki if bd b kj le kl km kn lf kp kq kr lg kt ku kv lh kx ky kz li lb lc ld hn dt translated">有兴趣加入我们的社区吗？你可以加入我们的 <a class="ae ms" href="https://join.slack.com/t/mendixcommunity/shared_invite/zt-hwhwkcxu-~59ywyjqHlUHXmrw5heqpQ" rel="noopener ugc nofollow" target="_blank"> <em class="mn"> slack社区频道</em> </a> <em class="mn">或者那些想更多参与的人，看看加入我们的</em> <a class="ae ms" href="https://developers.mendix.com/meetups/#meetupsNearYou" rel="noopener ugc nofollow" target="_blank"> <em class="mn">聚会</em> </a> <em class="mn">。</em></p></div></div>    
</body>
</html>