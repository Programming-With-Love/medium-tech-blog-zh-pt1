# 塑造成功框架的哲学

> 原文：<https://medium.com/capital-one-tech/philosophies-that-shaped-successful-frameworks-f976781e9bd4?source=collection_archive---------3----------------------->

![](img/7730731e1c351870d182957c7668c033.png)

在过去的十年中，我们看到许多软件框架涌现出来。像 [Spring](http://spring.io/) 和 Ruby on Rails 这样的框架已经变得如此成功，以至于掌握它们意味着打开了无数工作机会的大门。然而，对于每一个成功的框架，甚至有更多的框架在没有被大多数开发人员注意到的情况下逐渐消失。[维基百科](https://en.wikipedia.org/wiki/Software_framework)在 2008 年 1 月 1 日列出了 67 个 web 框架。然而，到今天为止，超过三分之二的网站要么已经从列表中消失，要么已经超过三年没有更新了。作为 [Yii 框架](http://www.yiiframework.com/)的创建者，我花了很多时间研究各种框架，理解为什么有些成功了，有些失败了。在这篇文章中，我将描述一些我对那些成功框架的哲学的发现。**为什么选择框架？**

要构建一个成功的框架，理解框架是做什么的以及开发人员为什么需要它们是很重要的。

Douglas C. Schmidt 等人将框架描述为一组集成的软件工件(如类、对象和组件),它们协作为一系列相关的应用程序提供可重用的架构。根据这个定义，框架就像一个半完整的应用程序框架，由可重用和可定制的组件组成。开发者被期望通过提供他们的应用和领域特定的逻辑来扩展和定制一个框架，以形成一个完整的应用。

框架的一个定义特征是所谓的[控制反转](http://martinfowler.com/bliki/InversionOfControl.html)。框架通常在编排和调用应用程序代码时扮演主程序的角色。控制流在这里是颠倒的——它调用我而不是我调用框架。下图说明了框架、库和应用程序之间的关系。请注意，框架通常以库的形式提供现成的特性，以帮助开发人员更快地构建应用程序。

![](img/2e83b7d1da78fff5f6a8f2179dd84e79.png)

框架对开发人员有用的首要原因是它们如何提高生产率和帮助提高代码质量。例如，现代框架(如 [Play](https://www.playframework.com/) 、 [django](https://www.djangoproject.com/) )经常提供代码生成工具或样板文件来帮助立即启动新项目。此外，设计良好的框架通常具有内置的安全措施，有助于防止开发人员犯下典型的安全缺陷。

在企业中，使用框架的另一个好处是，它有助于实施适用于整个企业的标准。框架提供了文档化的模式、详细的设计和工具的实现，用于在所有应用程序中提供一致的结构。例如，在 Capital One，我们开发了一个名为“机箱”的框架，作为统一公司内部开发的许多 API 生产者和消费者应用程序的集成基础。

当然，并不是所有的开发者都喜欢使用框架。一些一致的抱怨包括陡峭的学习曲线、与所选框架的紧密耦合、低性能等等。今天，大多数这些抱怨不再成立，因为现代框架已经通过坚持本帖中解释的哲学很好地解决了它们。

# **哲学**

像任何产品一样，一个框架的成功取决于许多因素，包括它背后的想法、代码质量、文档、围绕它的社区、营销、支持等等。在我看来，一个特别重要的项目是在设计和开发一个框架时要考虑的哲学。

长期从事 Python 研究的 Tim Peters 在被称为[Python 之禅](https://www.python.org/dev/peps/pep-0020/)的二十句格言中表达了 Python 背后的设计原则。“漂亮总比难看好；显性比隐性好；简单比复杂好……”他们启发了许多类似的编程语言 zens ，我发现其中一些格言也适用于框架设计。基于我的框架开发经验，我在此浓缩和总结了我认为对任何框架的成功最重要的哲学。

*   简单更好
*   单片更糟
*   保持一致
*   显性超过隐性
*   约定胜于配置

# **简单越好**

将开发人员转换到一个新的框架从来都不是一件容易的事情。然而，当开发人员采用一个框架时，他们将会在它上面投入大量的资金，并且在他们当前和将来的项目中依赖它。此外，与使用库不同——开发人员只能在实现 API 时学习它——学习框架需要开发人员在将其投入实际使用之前完全理解框架规则。因此，在设计一个框架时，重要的是要确保简单性，使它更易访问、更令人愉快、更易于学习、采用和利用。

为了实现简单性，框架应该限制它所执行的规则的数量；此外，这些规则应该以一致的方式设计，并有良好的文档记录。一个框架实施的规则越多，学习曲线就越陡峭，被开发人员采用的可能性就越小。当规则一致时，开发人员可以更快地学习它们。此外，没有文档，一个框架是没有用的，因为没有人会花时间去逆向工程它的规则。

框架规则设计的一个很好的例子就是 [Express.js 框架](http://expressjs.com/)设置的路由语法，这是一个非常流行的 web 应用框架。路由是 web 应用程序中的一个重要概念，它决定了应用程序如何响应客户端对特定端点的请求(HTTP 方法和 URI 的组合)。Express.js 引入了一个定义路线的简单规则，app。METHOD(PATH，HANDLER)，其中 METHOD 是 HTTP 请求方法(例如 GET，POST)，PATH 是服务器上的 URI 路径，HANDLER 是路由匹配时要执行的回调函数。下面的代码片段展示了 Express.js 路由代码的样子。

```
var express = require(‘express’);
var app = express();// accept homepage request 
app.get(‘/’, function (req, res) {
 res.send(‘Hello World!’);
});// accept POST request at /user 
app.post(‘/user’, function (req, res) {
 res.send(‘Got a PUT request at /user’);
});// accept DELETE request at /user 
app.delete(‘/user’, function (req, res) {
 res.send(‘Got a DELETE request at /user’);
});
```

上面的代码是不言自明的，因为它类似于 HTTP 请求的样子。正因为如此，开发人员学习和记忆这种路由语法并将其应用到他们的项目中几乎不费吹灰之力。

# **单片更糟糕**

这里，术语“整体式”指的是作为一个单元构建的框架，具有紧密耦合的代码库。当 web 框架开始流行时，它们往往是单一的，因为它们的主要目标是为快速 web 应用程序开发提供全面的支持。渐渐地，人们意识到单一框架有很多问题。例如，对框架的一小部分所做的更改需要重新测试和发布整个框架，这反过来会导致用框架构建的应用程序被重新构建，即使更改是完全不相关的。整体框架中的代码是交织在一起的，这使得这些框架很难保持不同版本之间的向后兼容性。最后但同样重要的是，有了更容易获得的专门框架，比如那些专门用于缓存、日志和数据库的框架，人们就不太愿意局限于单一的整体框架。

现代框架在架构上倾向于松散耦合。全栈框架(例如 [Spring](http://spring.io/) )已经发展成为由松散耦合的组件组成的框架，这些组件可以独立使用，也可以与第三方交换。专门的框架由明确的契约构建，以支持更好的[互操作性](https://en.wikipedia.org/wiki/Interoperability)，这使得应用程序更少依赖于特定的框架。

例如，一种非常流行的 web 路由框架是所谓的“Sinatra 类型框架”，如 [Sinatra](http://www.sinatrarb.com/) 、 [Express.js](http://expressjs.com/) 和 [Martini](http://martini.codegangsta.io/) 。这些框架使用以下中间件管道架构来支持 web 应用程序中的请求路由和处理。框架本身非常小，但是开放的架构允许它们被各种各样的中间件组件无限制地丰富。

![](img/e9e791078b6c653d1c5a12a07b687103.png)

# **保持一致**

一致性意味着一个框架在其使用设计、命名约定、代码风格、代码组织等方面坚持统一的模式。一致的框架将降低入门的门槛，因为用户可以学习框架的一个方面，并应用相同的模式快速学习结构的其余部分。保持一致也有助于用户减少框架特性输入错误或误用的可能性。

例如，在为 Yii 框架设计查询构建器时，我们将一致性作为指导标准。查询生成器允许您以编程方式构建与数据库无关的 SQL 语句，并避免 SQL 注入攻击。为了帮助用户更容易记住它的 API，我们引入了 [fluent 接口](https://en.wikipedia.org/wiki/Fluent_interface)，并以相应的 SQL 关键字命名这些方法。下面的代码片段展示了如何使用我们设计的查询构建器来构建 SQL 语句。

```
(new Query())
 ->select(‘id, email’)
 ->from(‘user’)
 ->orderBy(‘last_name, first_name’)
 ->limit(10)
 ->all();
```

上述代码将生成并执行以下 MySQL 语句:

```
SELECT `id`, `email`
FROM `user`
ORDER BY `last_name`, `first_name`
LIMIT 10
```

如您所见，这段代码看起来与您编写 SQL 语句的方式非常相似。查询构建器和 SQL 语法之间的一致性使得学习查询构建器变得很容易。

# **显性超过隐性**

显式比隐式更重要的是编写自我解释的代码，避免太多的“自动魔术”坚持这种哲学有两个原因。首先，显式代码更容易理解和维护。由于代码是自解释的，可能不是代码最初作者的维护人员不需要来回跳转来挖掘代码实际上做了什么。其次，显式代码不容易出错。虽然显式可能需要编写更多的代码行，但它减少了在看似简单的隐式背后忽略重要代码的机会。

看看下面两段 PHP 中的 [ORM(对象关系映射)](https://en.wikipedia.org/wiki/Object-relational_mapping)代码。他们都希望实现相同的目标，即在“order”DB 记录和“customer”DB 记录之间建立外键引用约束。

```
$order->link(‘customer’, $customer);
```

对抗

```
$order->customer = $customer;
```

第一个版本是一个普通的方法调用。第二个版本看起来更酷，因为复杂的数据库链接操作可以通过一个看似简单的赋值来完成。然而，这是一种错觉，因为第二个版本的简单性被隐藏在别处的复杂性所掩盖。例如，用户必须通过某种形式的文档来学习这种特殊的赋值语法，以便在实践中使用它。此外，因为链接操作看起来像一个正常的赋值，用户可能会忘记处理由此导致的潜在异常，从而导致整个程序出现故障。

事实上，在 Yii 的开发过程中，我们就两个版本进行了大量的讨论，并最终选定了第一个版本，这个版本收到的投诉很少。

# **约定优于配置**

约定胜于配置的概念已经存在多年了。这个想法是，框架应该采用合理的默认值，这些默认值符合约定，同时仍然允许通过配置进行扩展。目标是减少开发人员需要做出的决策数量，从而实现哲学# 1——简单。

约定优于配置最初是在 Ruby on Rails 框架中流行起来的。Rails 提供了一个 ActiveRecord 库，用于处理数据库中的类和表之间的映射。按照惯例，表名是类名的复数形式。因此，类 Account 将有一个名为 Accounts 的表。如果表不是这样命名的，用户就必须显式地配置类名和表名之间的映射。

![](img/41fae1a76474bee0bd293de5785208fc.png)

许多 MVC 框架使用约定胜于配置来将请求路由到特定的代码段。如左图所示， [Sails.js 框架](http://sailsjs.org/)使用了一个约定，其中对/we/say/hi URL 的请求将被路由到位于 controllers/we 目录下的 SayController 控制器类的 hi action。遵循这一约定，开发人员不再需要为控制器动作定义路由规则。然而，如果开发人员想要使用不同的路由规则，他们仍然可以通过将路由显式绑定到控制器动作来实现。

约定胜于配置有助于减少需要编写的代码量。然而，这可能是以引入开发人员需要遵循的额外规则为代价的。此外，它也倾向于与前面讨论的“显性优于隐性”的哲学相冲突。事实上，虽然 Spring 框架的早期版本使用了与 Sails.js 类似的路由约定，但 Spring 现在要求开发人员通过注释明确指定映射。因此，在决定是否引入新规则来支持约定优于配置时，应该做出明智的判断。

# **总结**

构建一个成功的框架就是要在强大和简单之间找到平衡。在构建框架的整个过程中，经常需要考虑权衡，以便坚持和体现上述哲学。

有时，你可能会面临一种哲学与另一种哲学直接冲突的情况。一致性比简单性更重要吗？约定比明确更重要吗？在这种情况下，请记住，框架的最终目标是简化开发人员的工作，并简化编写代码的过程。所以保持简单明了。如果惯例与明确性冲突，那么它们就可以被牺牲掉，因为前者会引入隐藏的复杂性。类似地，如果严格地坚持会导致额外的复杂化，一致性可能会被轻微地破坏。

要了解更多关于 Capital One 的 API、开源、社区活动和开发人员文化的信息，请访问我们的一站式开发人员门户网站 DevExchange。[](https://developer.capitalone.com/)