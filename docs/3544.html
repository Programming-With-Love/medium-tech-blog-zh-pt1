<html>
<head>
<title>Vanilla Kubernetes User Authentication and Authorization in Depth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vanilla Kubernetes深入的用户验证和授权</h1>
<blockquote>原文：<a href="https://medium.com/globant/vanilla-kubernetes-user-authentication-and-authorization-in-depth-b26ec2626734?source=collection_archive---------0-----------------------#2020-11-12">https://medium.com/globant/vanilla-kubernetes-user-authentication-and-authorization-in-depth-b26ec2626734?source=collection_archive---------0-----------------------#2020-11-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="fea6" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="bfdf" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">你好，</p><p id="9dbd" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在本文中，我们将讨论K8s中最有争议的话题之一，它将解决许多关于用户认证和授权的未解问题。</p><p id="ac1f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">当您管理普通K8s集群时，您需要解决一些问题，如入口服务、负载平衡、分布式存储和用户管理，然而，在本文中，我们将主要关注RBAC。</p><p id="4e0c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">用户<a class="ae kf" href="https://auth0.com/docs/authorization/authentication-and-authorization" rel="noopener ugc nofollow" target="_blank">认证&amp;授权</a>，简单来说，就是验证用户是谁，验证他们可以访问什么，我们将在集群中使用<a class="ae kf" href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" rel="noopener ugc nofollow" target="_blank"> RBAC </a>进行授权。</p><p id="d562" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">Kubernetes可以使用客户端证书、无记名令牌、代理或HTTP基本身份验证，所有这些方法都将由API服务器进行验证，API服务器用于身份验证的属性如下:</p><ul class=""><li id="cbdf" class="kg kh hh je b jf ka jj kb jn ki jr kj jv kk jz kl km kn ko bi translated">用户名:这是一个标识用户的字符串，在所有用户中应该是唯一的，(例如<a class="ae kf" href="mailto:admin@example.com" rel="noopener ugc nofollow" target="_blank">admin@example.com</a>，我的用户id，x24diausu=，等等。)</li><li id="1c16" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">UID:与Username的作用相同，但是它试图比后者更加一致，如果可能的话，你应该给它们赋予相同的值</li><li id="fb38" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">Groups:一组字符串，以逻辑方式表示K8s中用户集合的成员关系，通常用于给组加前缀，例如<code class="du ku kv kw kx b">system:masters</code>或<code class="du ku kv kw kx b">oidc:devs</code></li><li id="d506" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">额外字段:包含额外信息的字符串映射，可以被插件、连接器等使用。</li></ul><p id="267c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">kubernetes的文档建议至少使用两种方法:</p><ul class=""><li id="3ed9" class="kg kh hh je b jf ka jj kb jn ki jr kj jv kk jz kl km kn ko bi translated">附加到pod的服务帐户的服务帐户令牌</li><li id="40af" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">至少另一种用户认证方法。幸运的是，我们将介绍3种方法。</li></ul><p id="6424" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">废话少说，让我们切入正题。</p><p id="01e4" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们将展示以下方法:</p><ol class=""><li id="b555" class="kg kh hh je b jf ka jj kb jn ki jr kj jv kk jz ky km kn ko bi translated"><strong class="je hi"> CSR(证书签名请求)方法</strong></li><li id="7f5e" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz ky km kn ko bi translated"><strong class="je hi"> WebToken方法</strong></li><li id="9874" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz ky km kn ko bi translated"><strong class="je hi"> OIDC (OpenID连接)方法</strong></li></ol><h1 id="609c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">资源</h1><p id="9302" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们将使用<a class="ae kf" href="https://github.com/JorgeReus/k8s-user-auth" rel="noopener ugc nofollow" target="_blank">回购</a>，因此，克隆它！</p></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><h1 id="c3d8" class="ie if hh bd ig ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb bi translated">证书签名请求方法</h1><p id="a5b6" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这种方法允许客户端请求由CA颁发X.509证书并交付给用户，您可以在repo中的csr目录中检查代码</p><h1 id="ecae" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">手动过程</h1><p id="7ce1" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">对于使用<code class="du ku kv kw kx b">minikube start</code>的测试环境spin up minikube实例，这是使用<code class="du ku kv kw kx b">minikube version: v1.13.0</code>测试的</p><ol class=""><li id="8018" class="kg kh hh je b jf ka jj kb jn ki jr kj jv kk jz ky km kn ko bi translated">创建您的私钥<code class="du ku kv kw kx b">openssl genrsa -out myUsername.key 2048</code></li><li id="c2da" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz ky km kn ko bi translated">创建CSR文件<code class="du ku kv kw kx b">openssl req -new -key myUsername.key -out myUsername.csr -subj "O=admin/CN=myUsername"</code></li><li id="7418" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz ky km kn ko bi translated">使用kubectl创建证书请求</li></ol><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="c19d" class="lt if hh kx b fi lu lv l lw lx">cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: certificates.k8s.io/v1<br/>kind: CertificateSigningRequest<br/>metadata:<br/>  # This has to match the id that you will use<br/>  name: myUsername<br/>spec:<br/>  groups:<br/>  # This means we want to add this csr to all of the authenticated users<br/>  - system:authenticated<br/>  request: $(cat myUsername.csr | base64 | tr -d "\n")<br/>  signerName: kubernetes.io/kube-apiserver-client<br/>  usages:<br/>  - client auth<br/>EOF</span></pre><p id="c61c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">4.作为管理员，通过<code class="du ku kv kw kx b">kubectl certificate approve MyUsername</code>批准请求。</p><p id="eb25" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">5.用<code class="du ku kv kw kx b">kubectl get csr/MyUsername -o jsonpath="{.status.certificate}" | base64 -d &gt; myUsername.crt</code>领证。</p><p id="dcf6" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">6.为管理组创建clusterrole绑定。</p><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="7b4b" class="lt if hh kx b fi lu lv l lw lx">kind: ClusterRoleBinding<br/>apiVersion: rbac.authorization.k8s.io/v1beta1<br/>metadata:<br/>  name: admin-binding<br/>subjects:<br/>- kind: Group<br/>  # This value is the one that k8s uses to define group membership<br/>  # Must be the same in the openssl subject<br/>  name: admin<br/>  apiGroup: rbac.authorization.k8s.io<br/>roleRef:<br/>  kind: ClusterRole<br/>  name: cluster-admin<br/>  apiGroup: rbac.authorization.k8s.io</span></pre><p id="1e8f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">7.用<code class="du ku kv kw kx b">kubectl config set-credentials myUsername --client-key=myUsername.key --client-certificate=myUsername.crt --embed-certs=true</code>将新凭证添加到kubeconfig中。</p><p id="d63e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">8.用<code class="du ku kv kw kx b">kubectl config set-context myContext--cluster=minikube --user=myUsername</code>添加上下文。</p><p id="572a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">9.与<code class="du ku kv kw kx b">kubectl config use-context myContext</code>一起使用上下文。<br/>您应该拥有集群的管理员权限。</p><h1 id="34f9" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">使用go k8s客户端</h1><ol class=""><li id="9840" class="kg kh hh je b jf jg jj jk jn ly jr lz jv ma jz ky km kn ko bi translated">创建rsa私钥</li></ol><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="3852" class="lt if hh kx b fi lu lv l lw lx">func getPrivateKeyPEMBytes(key *rsa.PrivateKey) *[]byte {<br/>	var privateKey = &amp;pem.Block{<br/>		Type:  "PRIVATE KEY",<br/>		Bytes: x509.MarshalPKCS1PrivateKey(key),<br/>	}</span><span id="171a" class="lt if hh kx b fi mb lv l lw lx">	var b bytes.Buffer<br/>	err := pem.Encode(&amp;b, privateKey)<br/>	if err != nil {<br/>		fmt.Println("Fatal error ", err.Error())<br/>		panic(err)<br/>	}<br/>	var rsaBytes = b.Bytes()<br/>	return &amp;rsaBytes<br/>}</span></pre><p id="0678" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">2.创建企业社会责任</p><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="5e6e" class="lt if hh kx b fi lu lv l lw lx">type RSAData struct {<br/>	Csr *[]byte<br/>	Key *[]byte<br/>}</span><span id="d19b" class="lt if hh kx b fi mb lv l lw lx">func getCsrBytes(commonName string, organization string) *RSAData {<br/>	reader := rand.Reader<br/>	bitSize := 2048<br/>	key, err := rsa.GenerateKey(reader, bitSize)<br/>	keyBytes := getPrivateKeyPEMBytes(key)<br/>	if err != nil {<br/>		fmt.Println("Fatal error ", err.Error())<br/>		panic(err)<br/>	}</span><span id="cc84" class="lt if hh kx b fi mb lv l lw lx">	subj := pkix.Name{<br/>		CommonName:   commonName,<br/>		Organization: []string{organization},<br/>	}</span><span id="ad0d" class="lt if hh kx b fi mb lv l lw lx">	templateCsr := x509.CertificateRequest{<br/>		Subject:            subj,<br/>		SignatureAlgorithm: x509.SHA256WithRSA,<br/>	}</span><span id="2d1c" class="lt if hh kx b fi mb lv l lw lx">	var b bytes.Buffer<br/>	csrBytes, _ := x509.CreateCertificateRequest(rand.Reader, &amp;templateCsr, key)<br/>	err = pem.Encode(&amp;b, &amp;pem.Block{Type: "CERTIFICATE REQUEST", Bytes: csrBytes})<br/>	sliceAddr := b.Bytes()<br/>	var result = RSAData{<br/>		Csr: &amp;sliceAddr,<br/>		Key: keyBytes,<br/>	}<br/>	return &amp;result<br/>}</span></pre><p id="6e6c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">3.在集群中创建CSR</p><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="7faa" class="lt if hh kx b fi lu lv l lw lx">var csr = k8sCertsV1.CertificateSigningRequest{}<br/>csr.Name = user<br/>csr.Spec.Groups = []string{"system:authenticated"}<br/>csr.Spec.Usages = []k8sCertsV1.KeyUsage{"client auth"}<br/>csr.Spec.Request = *rsaData.Csr<br/>csr.Spec.SignerName = "kubernetes.io/kube-apiserver-client"<br/>_, err := k8sClient.CertificatesV1().CertificateSigningRequests().Create(ctx, &amp;csr, k8sMetaV1.CreateOptions{})<br/>check(err)</span></pre><p id="16e5" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">4.批准CSR</p><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="3ee5" class="lt if hh kx b fi lu lv l lw lx">func approveCsr(ctx context.Context, k8sClient *kubernetes.Clientset, csr k8sCertsV1.CertificateSigningRequest) {<br/>	csr.Status.Conditions = append(csr.Status.Conditions, k8sCertsV1.CertificateSigningRequestCondition{<br/>		Type:           k8sCertsV1.CertificateApproved,<br/>		Reason:         "Approved by CICD",<br/>		Message:        "This CSR was approved by CICD",<br/>		Status:         "True",<br/>		LastUpdateTime: k8sMetaV1.Now(),<br/>	})<br/>	_, err := k8sClient.CertificatesV1().CertificateSigningRequests().UpdateApproval(ctx, csr.Name, &amp;csr, k8sMetaV1.UpdateOptions{})<br/>	check(err)<br/>}</span></pre><p id="f712" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">5.创建kubeconfig</p><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="6b49" class="lt if hh kx b fi lu lv l lw lx">func createKubeConfig(data KubeConfigData) {<br/>	t, err := template.New("kubeconfig").Parse(kubeConfigTemplate)<br/>	check(err)<br/>	resultFile := fmt.Sprintf("/tmp/%v.kubeconfig", data.UserEmail)<br/>	f, err := os.Create(resultFile)<br/>	check(err)<br/>	w := bufio.NewWriter(f)<br/>	err = t.Execute(w, data)<br/>	check(err)<br/>	err = w.Flush()<br/>	check(err)<br/>}</span></pre><p id="bfbe" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这是模板:</p><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="9d94" class="lt if hh kx b fi lu lv l lw lx">apiVersion: v1<br/>kind: Config<br/>clusters:<br/>- cluster:<br/>    {{ .CAKey }}: {{ .ClusterCA }}<br/>    server: {{ .ClusterEndpoint }}<br/>  name: {{ .ClusterName }}<br/>users:<br/>- name: {{ .UserEmail }}<br/>  user:<br/>    client-certificate-data: {{ .ClientCertificateData }}<br/>    client-key-data: {{ .ClientKeyData }}<br/>contexts:<br/>- context:<br/>    cluster: {{ .ClusterName }}<br/>    user: {{ .UserEmail }}<br/>  name: {{ .User }}-{{ .ClusterName }}<br/>current-context: {{ .User }}-{{ .ClusterName }}</span></pre></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><h1 id="e75a" class="ie if hh bd ig ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb bi translated">Webhook令牌方法</h1><p id="2ec6" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">出于演示目的，我们在本例中使用<code class="du ku kv kw kx b">k3d versionk3d version v3.0.1</code>和<code class="du ku kv kw kx b">k3s version v1.18.6-k3s1 (default)</code>。您可以检查webhook目录中的代码。这种方法允许通过验证不记名令牌进行身份验证。为此，您需要一个服务来处理用户向API服务器发送请求时kubernetes提供的令牌。我们将在下面详细说明该过程:</p><ol class=""><li id="34c3" class="kg kh hh je b jf ka jj kb jn ki jr kj jv kk jz ky km kn ko bi translated">创建一个包含以下内容的文件，并保存为<code class="du ku kv kw kx b">webhook-config.yaml</code></li></ol><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="c2f1" class="lt if hh kx b fi lu lv l lw lx">apiVersion: v1<br/>kind: Config<br/>clusters:<br/>  # The name of the service<br/>  - name: myServiceName<br/>    cluster:<br/>      server: http://localhost:3000/authenticate<br/>users:<br/>  # The api configuration for the webhook<br/>  - name: apiUsername<br/>    user:<br/>      token: secret<br/>contexts:<br/>  - name: webhook<br/>    context:<br/>      cluster: myServiceName<br/>      user: apiUsername<br/>current-context: webhook</span></pre><p id="4698" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">2.对于这一部分，我们需要一个应用程序以某种方式处理承载令牌，并告诉api服务器用户已经过身份验证。api服务器期望您的应用程序在<code class="du ku kv kw kx b">/authenticate</code>有一个带有POST方法的端点，下面我们在GO中有一个这样的例子</p><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="6871" class="lt if hh kx b fi lu lv l lw lx">type AuthResponseStatus struct {<br/>	Authenticated bool                    `json:"authenticated"`<br/>	User          *AuthResponseStatusUser `json:"user,omitempty"`<br/>}</span><span id="7816" class="lt if hh kx b fi mb lv l lw lx">type AuthResponseStatusUser struct {<br/>	Username string   `json:"username"`<br/>	Uid      string   `json:"uid"`<br/>	Groups   []string `json:"groups"`<br/>}</span><span id="919b" class="lt if hh kx b fi mb lv l lw lx">type AuthResponse struct {<br/>	ApiVersion string             `json:"apiVersion"`<br/>	Kind       string             `json:"kind"`<br/>	Status     AuthResponseStatus `json:"status"`<br/>}</span><span id="deb3" class="lt if hh kx b fi mb lv l lw lx">func authenticate(w http.ResponseWriter, r *http.Request) {<br/>  # Accepts json<br/>	w.Header().Set("Content-Type", "application/json")</span><span id="25f4" class="lt if hh kx b fi mb lv l lw lx">  # Read the body as text<br/>	reqBody, _ := ioutil.ReadAll(r.Body)<br/>	var authRequest AuthRequest</span><span id="9434" class="lt if hh kx b fi mb lv l lw lx">  # Unmarshal the text into json<br/>	err := json.Unmarshal(reqBody, &amp;authRequest)</span><span id="1763" class="lt if hh kx b fi mb lv l lw lx">	if err != nil {<br/>		json.NewEncoder(w).Encode(unauthorizedRespose)<br/>		log.Printf("User : %v Cause: %v, ", reqBody, err)<br/>		return<br/>	}<br/>	// Query github data username and groups of an org<br/>	ctx := context.Background()<br/>	ts := oauth2.StaticTokenSource(<br/>		&amp;oauth2.Token{AccessToken: authRequest.Spec.Token},<br/>	)</span><span id="1b30" class="lt if hh kx b fi mb lv l lw lx">  // Create and oauth2 client to connect to github<br/>	tc := oauth2.NewClient(ctx, ts)<br/>	client := github.NewClient(tc)<br/>	req, _, err := client.Users.Get(context.Background(), "")</span><span id="0b6d" class="lt if hh kx b fi mb lv l lw lx">	if err != nil {<br/>		json.NewEncoder(w).Encode(unauthorizedRespose)<br/>		log.Printf("Cause: %v, ", err)<br/>		return<br/>	}</span><span id="8455" class="lt if hh kx b fi mb lv l lw lx">	user := *req.Login<br/>  <br/>  // Query the membership of the user to an specified organization<br/>	membership, _, err := client.Organizations.GetOrgMembership(context.Background(), "", ",MY_GITHUB_ORGANIZATION&gt;")</span><span id="8938" class="lt if hh kx b fi mb lv l lw lx">	if err != nil {<br/>		json.NewEncoder(w).Encode(unauthorizedRespose)<br/>		log.Printf("User : %v Cause: %v, ", user, err)<br/>		return<br/>	}<br/>  <br/>  // This is what kubernetes expects. See https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication<br/>	authRespose := AuthResponse{<br/>		ApiVersion: authRequest.ApiVersion,<br/>		Kind:       authRequest.Kind,<br/>		Status: AuthResponseStatus{<br/>			Authenticated: true,<br/>			User: &amp;AuthResponseStatusUser{<br/>				Username: user,<br/>				Uid:      user,<br/>				Groups:   []string{*membership.Role},<br/>			},<br/>		},<br/>	}<br/>	json.NewEncoder(w).Encode(authRespose)<br/>	log.Printf("User %v authenticated sucessfully", user)<br/>}</span></pre><p id="e9b0" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">3.使用docker构建图像(例如<code class="du ku kv kw kx b">docker build -t webhook-app:v1 -f app/Dockerfile ./app</code>)</p><p id="41be" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">4.创建k3d集群:</p><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="c01a" class="lt if hh kx b fi lu lv l lw lx"># Notice that authentication-token-webhook-config-file flag points to the file create previously<br/>k3d cluster create webhook \<br/>-v $PWD/config:/etc/webhook \<br/>--k3s-server-arg "--kube-apiserver-arg=authentication-token-webhook-config-file=/etc/webhook/webhook-config.yaml"</span></pre><p id="809f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">5.将webhook服务映像导入k3d: <code class="du ku kv kw kx b">k3d image import webhook-app:v1 -c webhook</code></p><p id="fd16" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">6.使用此应用程序创建daemonset</p><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="838c" class="lt if hh kx b fi lu lv l lw lx">cat &lt;&lt;EOF | kubectl apply -f -<br/>apiVersion: apps/v1<br/>kind: DaemonSet<br/>metadata:<br/>  labels:<br/>    k8s-app: webhook-app<br/>  name: webhook-app<br/>  namespace: kube-system<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      k8s-app: webhook-app<br/>  template:<br/>    metadata:<br/>      labels:<br/>        k8s-app: webhook-app<br/>      annotations:<br/>        scheduler.alpha.kubernetes.io/critical-pod: ''<br/>    spec:<br/>      tolerations:<br/>      # Allow the pods to be runned in master nodes (when the api server lives)<br/>      - key: node-role.kubernetes.io/master<br/>        effect: NoSchedule<br/>      containers:<br/>      - image: webhook-app:v1<br/>        name: webhook-app<br/>        ports:<br/>        - containerPort: 3000<br/>          hostPort: 3000<br/>          protocol: TCP<br/>      # This is for accessing it as localhost<br/>      hostNetwork: true<br/>      restartPolicy: Always<br/>EOF</span></pre><p id="df0d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">7.创建一个带有配置文件访问的github令牌(这是一个展示灵活性的例子，您可以实现另一个auth方法，重要的是您将json返回给API服务器，指定用户是否经过身份验证)</p><p id="1b8a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">8.用<code class="du ku kv kw kx b">kubectl config set-credentials webhook --token=YOUR_GITHUB_TOKEN</code>将新凭证添加到kubeconfig。</p><p id="996f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">9.用<code class="du ku kv kw kx b">kubectl config set-context myWHContext --cluster=webhook --user=webhook</code>添加上下文。</p><p id="7591" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">10.使用带有<code class="du ku kv kw kx b">kubectl config use-context myWHContext</code>的上下文。<br/>所以现在kubernetes使用您的github令牌来验证您是否属于某个组织。</p></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><h1 id="d0ac" class="ie if hh bd ig ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb bi translated">OIDC (OpenId连接)方法</h1><p id="411e" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">出于演示的目的，我们在这个例子中使用了<code class="du ku kv kw kx b">k3d versionk3d version v3.0.1</code>和<code class="du ku kv kw kx b">k3s version v1.18.6-k3s1 (default)</code>。你可以在idc目录下查看代码。</p><p id="1ebe" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">K8s允许OIDC提供者作为身份提供者；这是来自官方文件的一个极好的序列图。</p><figure class="ll lm ln lo fd md er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mc"><img src="../Images/ed39b2de3f424e1a5fa931f10d80ab58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AT4btGqPMifkG22IXPquKw.png"/></div></div><figcaption class="mk ml et er es mm mn bd b be z dx">K8s OIDC workflow</figcaption></figure><p id="161e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">正如您所看到的，当您作为用户登录IDP以获取和<code class="du ku kv kw kx b">id token</code>时，神奇的事情发生了，然后这个令牌被用作kubectl命令的不记名令牌。</p><p id="f5e0" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在本例中，我们将构建自己的<a class="ae kf" href="https://github.com/dexidp/dex" rel="noopener ugc nofollow" target="_blank"> Dex </a>实例，该实例可以作为上游提供者访问Gitlab。</p><h1 id="5665" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">为什么是德克斯？</h1><p id="4e96" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">因为Dex可以有多个上游提供者，并展示了一个更复杂的OIDC身份验证示例</p><h1 id="7a8b" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">地形代码</h1><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="af21" class="lt if hh kx b fi lu lv l lw lx"># A keypair for ssh provisioning, this uses your default public key<br/>resource "aws_key_pair" "ssh-key" {<br/>  key_name_prefix = "dex"<br/>  public_key      = file("~/.ssh/id_rsa.pub")<br/>}</span><span id="e368" class="lt if hh kx b fi mb lv l lw lx">locals {<br/>  dex-config = {<br/>    record-name      = "dex"<br/>    domain-name      = "dex.mydomain.com"<br/>    dex-home-path    = "/home/ubuntu/dex"<br/>    gitlab-client-id = var.gitlab-client-id<br/>    gitlab-secret    = var.gitlab-secret<br/>    gitlab-groups    = var.gitlab-groups<br/>  }<br/>}</span><span id="481b" class="lt if hh kx b fi mb lv l lw lx"># An static ip<br/>resource "aws_eip_association" "eip_assoc" {<br/>  instance_id   = aws_instance.dex.id<br/>  allocation_id = data.aws_eip.selected.id<br/>}</span><span id="7f93" class="lt if hh kx b fi mb lv l lw lx"># An EC2 instance containing dex<br/>resource "aws_instance" "dex" {<br/>  ami                    = data.aws_ami.ubuntu.id<br/>  vpc_security_group_ids = [aws_security_group.allow_dex.id]<br/>  key_name               = aws_key_pair.ssh-key.key_name<br/>  instance_type          = "t3.micro"</span><span id="58ab" class="lt if hh kx b fi mb lv l lw lx">  provisioner "remote-exec" {<br/>    inline = ["mkdir -p /home/ubuntu/dex"]<br/>    connection {<br/>      type = "ssh"<br/>      user = "ubuntu"<br/>      host = self.public_ip<br/>    }<br/>  }</span><span id="8043" class="lt if hh kx b fi mb lv l lw lx">  # Dex config<br/>  provisioner "file" {<br/>    content     = templatefile("./templates/dex-server-config.yml", local.dex-config)<br/>    destination = "${local.dex-config.dex-home-path}/server-config.yaml"<br/>    connection {<br/>      type = "ssh"<br/>      user = "ubuntu"<br/>      host = self.public_ip<br/>    }<br/>  }</span><span id="a8b0" class="lt if hh kx b fi mb lv l lw lx">  # Ssl certificates for dex<br/>  provisioner "file" {<br/>    source      = "certs"<br/>    destination = "${local.dex-config.dex-home-path}/certs"<br/>    connection {<br/>      type = "ssh"<br/>      user = "ubuntu"<br/>      host = self.public_ip<br/>    }<br/>  }<br/>}<br/></span><span id="34d7" class="lt if hh kx b fi mb lv l lw lx"># Privision the dex instance sincrououlsy<br/>resource "null_resource" "provisioner" {<br/>  depends_on = [aws_instance.dex]<br/>  provisioner "remote-exec" {<br/>    script = "${path.root}/init.sh"<br/>    connection {<br/>      type = "ssh"<br/>      user = "ubuntu"<br/>      host = data.aws_eip.selected.public_ip<br/>    }<br/>  }<br/>}</span></pre><h1 id="58ce" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">供应代码</h1><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="5b72" class="lt if hh kx b fi lu lv l lw lx">#!/bin/bash</span><span id="869a" class="lt if hh kx b fi mb lv l lw lx"># Dependecies<br/>export GOPATH=/home/ubuntu/go<br/>sudo apt update<br/>sudo apt update<br/>sudo apt install -y golang make<br/>go get github.com/dexidp/dex<br/>cd $GOPATH/src/github.com/dexidp/dex<br/>make<br/>mv web /home/ubuntu/dex/<br/>sudo mv bin/dex /usr/bin/</span><span id="d7f1" class="lt if hh kx b fi mb lv l lw lx"># Systemd Service<br/>sudo tee /etc/systemd/system/dex.service &gt; /dev/null &lt;&lt;'EOF'<br/>[Unit]<br/>Description=Dex service k8s OICD authentication<br/>[Service]<br/>ExecStart=/usr/bin/dex serve /home/ubuntu/dex/server-config.yaml<br/>[Install]<br/>WantedBy=multi-user.target<br/>EOF<br/>sudo systemctl daemon-reload<br/>sudo systemctl start dex</span></pre><p id="310a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">如您所见，该脚本非常简单，它构建了dex并为dex创建了systemd服务。</p><h1 id="96c5" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">Dex配置</h1><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="4fff" class="lt if hh kx b fi lu lv l lw lx"># Use sqlite as the backend<br/>issuer: https://${domain-name}/dex<br/>storage:<br/>  type: sqlite3<br/>  config:<br/>    file: ${dex-home-path}/dex.db</span><span id="f3d0" class="lt if hh kx b fi mb lv l lw lx"># web &amp; TLS config<br/>web:<br/>  https: 0.0.0.0:443<br/>  tlsCert: ${dex-home-path}/certs/cert.pem<br/>  tlsKey: ${dex-home-path}/certs/key.pem</span><span id="bc2f" class="lt if hh kx b fi mb lv l lw lx"># html, css and js files<br/>frontend:<br/>  dir: ${dex-home-path}/web</span><span id="dc1e" class="lt if hh kx b fi mb lv l lw lx"># Configuration for telemetry<br/>telemetry:<br/>  http: 0.0.0.0:5558<br/>  <br/>expiry:<br/>  signingKeys: "10m"<br/>  idTokens: "30m"</span><span id="777a" class="lt if hh kx b fi mb lv l lw lx">logger:<br/>  level: "debug"<br/>  format: "json" </span><span id="a3fd" class="lt if hh kx b fi mb lv l lw lx">oauth2:<br/>  responseTypes: ["code", "token", "id_token"]<br/>  skipApprovalScreen: true<br/></span><span id="2e1a" class="lt if hh kx b fi mb lv l lw lx"># Use gitlab as an example for oidc in here we need to use the group's id's for authentication<br/>connectors:<br/>  - type: gitlab<br/>    id: gitlab<br/>    name: GitLab<br/>    config:<br/>      baseURL: https://gitlab.com<br/>      clientID: ${gitlab-client-id}<br/>      clientSecret: ${gitlab-secret}<br/>      redirectURI: https://${domain-name}/dex/callback<br/>      useLoginAsID: false<br/>      groups:<br/>  %{ for group in gitlab-groups ~}<br/>    - ${group} <br/>  %{ endfor ~}</span><span id="0d69" class="lt if hh kx b fi mb lv l lw lx">enablePasswordDB: True<br/></span><span id="0da0" class="lt if hh kx b fi mb lv l lw lx"># Secret id and clientID for the kubelogin client<br/>- id: kube-login-client<br/>  name: Kube Login Client<br/>  secret: qgODwpzNk7NmyxrXINFAHf1R<br/>  redirectURIs:<br/>    - http://localhost:8000<br/>    - <a class="ae kf" href="http://localhost:18000" rel="noopener ugc nofollow" target="_blank">http://localhost:18000</a></span></pre><p id="6817" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这是dex的基本配置，它支持gitlab组，你可以在k8s中将它们映射到组中</p><h1 id="dbff" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">运行地形</h1><p id="219a" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">你只需要做一个<code class="du ku kv kw kx b">terraform apply --auto-approve</code>，然后你可以使用terratest测试它是否工作，只需运行tests文件夹中的<code class="du ku kv kw kx b">go test</code>，如果测试没有失败，dex就启动并运行了！</p><h1 id="dd91" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">K8s配置</h1><p id="4ab3" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一旦有了dex(可以使用不同的oidc提供者)，就需要更新api服务器标志来支持它:</p><ul class=""><li id="2902" class="kg kh hh je b jf ka jj kb jn ki jr kj jv kk jz kl km kn ko bi translated">oidc-issuer-url:这是dex发行者的url</li><li id="bf05" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">oidc-username-claim:这是k8s将用来识别用户的声明</li><li id="e768" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">oidc-client-id:这是客户端应用程序的标识符，它将应用程序作为一个整体来标识，在本例中是k8s集群</li><li id="d397" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">oidc-ca-file:dex的认证机构pem文件，通常为CA.pem</li><li id="ca60" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">oidc-groups-claim:k8s将用来定义组成员资格的声明，这在rolebindings中使用</li><li id="591c" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">oidc-groups-prefix:一个可选的前缀，不与k8s中的预定义组冲突，如<code class="du ku kv kw kx b">system:</code></li><li id="4924" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz kl km kn ko bi translated">oidc-username-prefix:服务器与前一个目的相同，但用于用户。</li></ul><p id="a220" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">k3d中的一个例子是</p><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="d745" class="lt if hh kx b fi lu lv l lw lx">k3d cluster create oidc \<br/>-v /tmp/certs:/etc/self-ssl/ \<br/>--k3s-server-arg "--kube-apiserver-arg=oidc-issuer-url=&lt;your-dex-url&gt;" \<br/>--k3s-server-arg "--kube-apiserver-arg=oidc-username-claim=email" \<br/>--k3s-server-arg "--kube-apiserver-arg=oidc-client-id=&lt;your-dex-client-id&gt;" \<br/>--k3s-server-arg "--kube-apiserver-arg=oidc-ca-file=/etc/self-ssl/ca.pem" \<br/>--k3s-server-arg "--kube-apiserver-arg=oidc-groups-claim=groups" \<br/>--k3s-server-arg "--kube-apiserver-arg=oidc-groups-prefix=oidc:" \<br/>--k3s-server-arg "--kube-apiserver-arg=oidc-username-prefix=oidc:"</span></pre><p id="e814" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">注意指标证书所在的体积</p><h1 id="2ae6" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">Kubectl配置</h1><ol class=""><li id="7476" class="kg kh hh je b jf jg jj jk jn ly jr lz jv ma jz ky km kn ko bi translated">使用<code class="du ku kv kw kx b">kubectl krew install odic-login</code>下载安装kube-login</li><li id="0788" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz ky km kn ko bi translated">运行:</li></ol><pre class="ll lm ln lo fd lp kx lq lr aw ls bi"><span id="0725" class="lt if hh kx b fi lu lv l lw lx">kubectl config set-credentials test-oidc --exec-api-version=client.authentication.k8s.io/v1beta1 \<br/>--exec-api-version=client.authentication.k8s.io/v1beta1 \<br/>--exec-command=kubectl \<br/>--exec-arg=oidc-login \<br/>--exec-arg=get-token \<br/>--exec-arg=--oidc-issuer-url=&lt;your-dex-url&gt; \<br/>--exec-arg=--oidc-client-id=&lt;your-dex-client-id&gt; \<br/>--exec-arg=--oidc-client-secret=&lt;your-client-secret&gt; \<br/>--exec-arg=--insecure-skip-tls-verify \<br/>--exec-arg=--oidc-extra-scope="groups email" \<br/>--exec-arg=--v=0<!-- --> </span></pre><p id="fde4" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">3.用<code class="du ku kv kw kx b">kubectl get secret --user=test-oidc</code>测试一下</p></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><h1 id="fb1e" class="ie if hh bd ig ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb bi translated">结论</h1><p id="b694" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">正如我们所看到的，k8s在用户认证和授权方面有很大的灵活性。只要k8s能够达到，你可以实现你想要的任何东西。务必使用terratest、ansible tests和/或unittests等工具测试您的解决方案！</p><p id="e9d8" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">作为总结，</p><ol class=""><li id="6d6e" class="kg kh hh je b jf ka jj kb jn ki jr kj jv kk jz ky km kn ko bi translated">如果您没有包括任何IDP，请使用证书申请(CRD ),这样您就不必担心轮换问题。</li><li id="ddc1" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz ky km kn ko bi translated">如果你有用户OIDC和支持它的IDP，这意味着你有许多用户使用几个IDP的，你想实施通用令牌。</li><li id="fd0b" class="kg kh hh je b jf kp jj kq jn kr jr ks jv kt jz ky km kn ko bi translated">如果您有自己的身份验证和授权方法，或者想要完全控制令牌生命周期，请使用WAF令牌身份验证。</li></ol><p id="fca8" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">作为额外的提示，您可以在托管环境中使用OIDC，如EKS、GKE等。使用<a class="ae kf" href="https://github.com/jetstack/kube-oidc-proxy" rel="noopener ugc nofollow" target="_blank"> kube-oidc-proxy </a>。</p><p id="c45b" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">供稿人:</strong></p><p id="0fb2" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">豪尔赫·戈麦斯·雷乌斯【https://github.com/JorgeReus T4】</p><p id="6015" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">https://github.com/onurg</p></div></div>    
</body>
</html>