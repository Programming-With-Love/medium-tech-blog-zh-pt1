<html>
<head>
<title>Implementing Stack and Queue in JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JS中实现堆栈和队列</h1>
<blockquote>原文：<a href="https://medium.com/globant/implementing-stack-and-queue-in-js-600c81a92120?source=collection_archive---------0-----------------------#2021-12-30">https://medium.com/globant/implementing-stack-and-queue-in-js-600c81a92120?source=collection_archive---------0-----------------------#2021-12-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/cd89342367ab76b50daf8b9e380ae0b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bcQmCeJ2piGqlzO2"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@adolfofelix?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Adolfo Félix</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0215" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在JavaScript中，堆栈和队列不是内置在数据结构中的。因此，在本文中，我们将看到如何使用数组和单链表实现堆栈和队列。</p><h1 id="5f1f" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">什么是栈？</strong></h1><p id="960e" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">堆栈是一种数据结构，其中最后添加的元素首先被删除。它遵循后进先出(LIFO)原则。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Credit: <a class="ae it" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">https://giphy.com/</a></figcaption></figure><p id="fdd0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">实现堆栈</strong></p><p id="65e4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于堆栈实现，我们将编写下面的方法。</p><ol class=""><li id="b39a" class="lb lc hh iw b ix iy jb jc jf ld jj le jn lf jr lg lh li lj bi translated"><code class="du lk ll lm ln b">push(value)</code> —该方法将在堆栈的一端插入<code class="du lk ll lm ln b">value</code></li><li id="68b3" class="lb lc hh iw b ix lo jb lp jf lq jj lr jn ls jr lg lh li lj bi translated"><code class="du lk ll lm ln b">pop()</code> —此方法将从堆栈插入值的同一端移除值。</li></ol><p id="0022" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将看到如何使用数组和单链表实现堆栈。</p><p id="4f9d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">使用数组</strong></p><p id="b7b9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在JavaScript中，Array有一些内置的方法，我们可以利用它们来实现Stack。</p><ol class=""><li id="2df9" class="lb lc hh iw b ix iy jb jc jf ld jj le jn lf jr lg lh li lj bi translated">使用<code class="du lk ll lm ln b">push(value)</code>和<code class="du lk ll lm ln b">pop()</code>方法分别在栈尾插入和删除。</li><li id="51d2" class="lb lc hh iw b ix lo jb lp jf lq jj lr jn ls jr lg lh li lj bi translated">使用<code class="du lk ll lm ln b">unshift(value)</code>和<code class="du lk ll lm ln b">shift()</code>方法从堆栈开始插入和删除。</li></ol><blockquote class="lt lu lv"><p id="5b1d" class="iu iv lw iw b ix iy iz ja jb jc jd je lx jg jh ji ly jk jl jm lz jo jp jq jr ha bi translated">注意:因为<code class="du lk ll lm ln b">unshift()</code>和<code class="du lk ll lm ln b">shift()</code>方法将在堆栈的开始插入和删除，所以它们需要重新索引整个数组。因此，这不是一个好方法。</p></blockquote><p id="8621" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">使用单链表</strong></p><p id="d2b1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">像数组一样，也有两种使用链表实现堆栈的方法。</p><p id="7781" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一种方法是从末端插入和取出。但是当从末尾移除时，我们将不得不遍历整个列表，到达倒数第二个元素，将其<code class="du lk ll lm ln b">next</code>设置为null。因此这个操作的复杂度是O(n)。</p><p id="bba5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一种方法是在开始时插入和删除，我们将在这里实现。插入和删除都具有O(1)复杂度。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/20c74d22e27e25e362a7ce76b562ff49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmFq4SGUermkg6P8dPzUXg.png"/></div></div></figure><p id="8474" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每当我们将一些值压入堆栈时，我们必须创建一个节点。下面是用于创建节点的节点类。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div class="er es mb"><img src="../Images/300b6dabb545ebcf8caefd6726c7689b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*7vbX2vLNH3O-2NWwruwltw.png"/></div></figure><p id="a49a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们将使用<code class="du lk ll lm ln b">push(value)</code>和<code class="du lk ll lm ln b">pop()</code>方法实现Stack类。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/c53df3c5549bedad78175a6c1432027d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVeQQEnNryG6JMHmixXbwQ.png"/></div></div></figure></div><div class="ab cl md me go mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ha hb hc hd he"><h1 id="9c52" class="js jt hh bd ju jv mk jx jy jz ml kb kc kd mm kf kg kh mn kj kk kl mo kn ko kp bi translated"><strong class="ak">什么是队列？</strong></h1><p id="a3f7" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">队列是一种数据结构，其中首先添加的元素首先被移除。它遵循先进先出(FIFO)原则。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mp la l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Credit: <a class="ae it" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">https://giphy.com/</a></figcaption></figure><p id="30de" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">实现队列</strong></p><p id="12df" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于队列实现，我们将编写下面的方法。</p><ol class=""><li id="d7f0" class="lb lc hh iw b ix iy jb jc jf ld jj le jn lf jr lg lh li lj bi translated"><code class="du lk ll lm ln b">enqueue(value)</code> —该方法将在队列的一端插入<code class="du lk ll lm ln b">value</code></li><li id="de75" class="lb lc hh iw b ix lo jb lp jf lq jj lr jn ls jr lg lh li lj bi translated"><code class="du lk ll lm ln b">dequeue()</code> —此方法将从队列的另一端移除值。</li></ol><p id="2ad6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">使用数组</strong></p><ol class=""><li id="6645" class="lb lc hh iw b ix iy jb jc jf ld jj le jn lf jr lg lh li lj bi translated">使用<code class="du lk ll lm ln b">unshift(value)</code>方法在开头插入，使用<code class="du lk ll lm ln b">pop()</code>方法从结尾删除。</li><li id="206d" class="lb lc hh iw b ix lo jb lp jf lq jj lr jn ls jr lg lh li lj bi translated">使用<code class="du lk ll lm ln b">push(value)</code>方法在末尾插入，使用<code class="du lk ll lm ln b">shift()</code>方法从开头删除。</li></ol><p id="0dca" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这两种方法都使用了<code class="du lk ll lm ln b">shift()</code>或<code class="du lk ll lm ln b">unshift(value) </code>方法，因此使用数组来实现队列不是一个好方法。</p><p id="159a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">使用单链表</strong></p><p id="83a5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如上所述，在单链表中，从末尾移除item的复杂度为O(n ),因此我们将避免在开头插入和从末尾移除。</p><p id="cab3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于我们的实现，我们将在末尾插入并从开头移除，以具有恒定的时间复杂度。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/becad942c36c6b5c13fdeebaeaab1381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XeYLEDzQmN90qDmGDx0mmw.png"/></div></div></figure><figure class="kv kw kx ky fd ii er es paragraph-image"><div class="er es mb"><img src="../Images/300b6dabb545ebcf8caefd6726c7689b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*7vbX2vLNH3O-2NWwruwltw.png"/></div></figure><p id="3610" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们将使用<code class="du lk ll lm ln b">enqueue(value)</code>和<code class="du lk ll lm ln b">dequeue()</code>方法实现队列类。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mq"><img src="../Images/a6542ae4706efe9d747bf465915d38cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AhOH99UtDR8Sgbmm_MpzLA.png"/></div></div></figure></div><div class="ab cl md me go mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ha hb hc hd he"><h1 id="c644" class="js jt hh bd ju jv mk jx jy jz ml kb kc kd mm kf kg kh mn kj kk kl mo kn ko kp bi translated"><strong class="ak">我们来总结一下！！</strong></h1><ul class=""><li id="cb9c" class="lb lc hh iw b ix kq jb kr jf mr jj ms jn mt jr mu lh li lj bi translated">栈是LIFO数据结构，而队列是FIFO数据结构。</li><li id="a6f2" class="lb lc hh iw b ix lo jb lp jf lq jj lr jn ls jr mu lh li lj bi translated">为了实现常量时间的堆栈，可以使用数组的<code class="du lk ll lm ln b">push(value)</code> / <code class="du lk ll lm ln b">pop()</code>方法进行插入/删除，也可以使用链表在开始时进行插入和删除。</li><li id="41a3" class="lb lc hh iw b ix lo jb lp jf lq jj lr jn ls jr mu lh li lj bi translated">为了实现常数时间队列，可以使用链表在末尾插入，在开头删除。</li></ul><p id="ccc0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请在这里找到完整的源代码<a class="ae it" href="https://stackblitz.com/edit/js-fkryvk" rel="noopener ugc nofollow" target="_blank"/>。对于本文内容改进的任何疑问或建议，请留下评论。</p><p id="24ce" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">快乐学习！！！</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="mv la l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Credit: <a class="ae it" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">https://giphy.com/</a></figcaption></figure></div></div>    
</body>
</html>