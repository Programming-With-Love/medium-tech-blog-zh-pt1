<html>
<head>
<title>Quickly spinning up Docker Containers with baseline Oracle Database Setup — for performing automated tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用基线Oracle数据库设置快速启动Docker容器—用于执行自动化测试</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/quickly-spinning-up-docker-containers-with-baseline-oracle-database-setup-for-performing-5a715ab92e6a?source=collection_archive---------0-----------------------#2018-04-18">https://medium.com/oracledevs/quickly-spinning-up-docker-containers-with-baseline-oracle-database-setup-for-performing-5a715ab92e6a?source=collection_archive---------0-----------------------#2018-04-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/dec8ac7314ed89428eadaf90984fa83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6dEXMD5lQHYDD_1I."/></div></div></figure><p id="8f13" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是运行Oracle数据库、准备对象(表、存储过程)和数据中的基线、创建该基线的映像以及随后基于该基线映像运行容器的过程。每个容器都以全新的设置开始。对于运行需要测试数据在已知状态下可用的自动化测试来说，这是一种很好的工作方式。</p><p id="d45b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最初的Docker容器是使用Oracle数据库11gR2 XE映像创建的:<a class="ae jn" href="https://github.com/wnameless/docker-oracle-xe-11g" rel="noopener ugc nofollow" target="_blank">https://github.com/wnameless/docker-oracle-xe-11g</a>。</p><p id="a5d2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Docker主机上执行以下语句:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="4f43" class="jx jy hh jt b fi jz ka l kb kc">docker run -d -p 49160:22 -p 49161:1521 -e ORACLE_ALLOW_REMOTE=true --name oracle-xe  wnameless/oracle-xe-11g</span></pre><p id="25fd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将启动一个名为oracle-xe的容器。5–20秒后，数据库创建并启动，可以从外部数据库客户端访问。</p><p id="53ab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从数据库客户端，准备数据库基线，例如:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="5440" class="jx jy hh jt b fi jz ka l kb kc">create user newuser identified by newuser; <br/>create table my_data (data varchar2(200)); <br/>insert into my_data values ('Some new data '||to_char(sysdate,'DD-MM HH24:MI:SS')); <br/>commit;</span></pre><p id="d070" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些操作代表应用程序的完整数据库安装—可能包含数百或数千个对象和数兆字节的数据。步骤和原理保持完全相同。</p><p id="1279" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这一点上，创建一个基线的映像——它由应用了当前应用程序版本的DDL和DML的普通数据库组成:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7b8a" class="jx jy hh jt b fi jz ka l kb kc">docker commit --pause=true oracle-xe</span></pre><p id="d9f2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个命令返回一个id，即现在为容器的当前状态创建的Docker映像的标识符——我们的基线。原始容器现在可以被停止(或杀死)甚至移除。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="c2c0" class="jx jy hh jt b fi jz ka l kb kc">docker stop oracle-xe</span></pre><p id="dcf0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从基线图像旋转容器现在已经完成:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="5782" class="jx jy hh jt b fi jz ka l kb kc">docker run -d -p 49160:22 -p 49161:1521 -e ORACLE_ALLOW_REMOTE=true  --name oracle-xe-testbed  &lt;image identifier&gt;</span></pre><p id="4dc2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">几秒钟后，数据库启动，远程数据库客户机可以开始与数据库交互。他们将找到作为基线映像一部分的数据库对象和数据。要进行测试，不需要额外的设置或任何拆卸。</p><p id="8764" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">执行需要执行的测试。试验后的拆卸包括杀死和移除试验台容器:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="de97" class="jx jy hh jt b fi jz ka l kb kc">docker kill oracle-xe-testbed &amp;&amp; docker rm oracle-xe-testbed</span></pre><p id="e349" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在回到步骤“旋转容器”</p><p id="a242" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">旋转容器需要几秒钟——5到10秒钟。时间主要被不得不从头开始的数据库进程占用。</p><p id="abe0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">应该可以创建一个正在运行的容器的快照(使用Docker检查点)并从该快照中恢复testbed容器。这种从检查点-kill-rm开始的创建-启动应该比我们现在开始的run-kill-rm循环更快。一个挑战是，打开数据库不仅要启动进程和操作内存，还要处理文件。这意味着我们需要提交正在运行的容器，并将恢复的检查点与该映像相关联。我一直在努力解决这个问题——但还没有成功——遇到了各种问题(O <a class="ae jn" href="https://stackoverflow.com/questions/31338916/sqlplus-remote-connection-giving-ora-21561" rel="noopener ugc nofollow" target="_blank"> RA-21561 </a> OID生成失败，ora 27101共享内存领域不存在，找不到重做日志文件等等)。我会继续调查此事。</p><h1 id="b80b" class="kd jy hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用Oracle Database 12c映像</h1><p id="a958" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">注意:代替之前使用的Oracle数据库XE映像，我们可以基于例如映像sath89/oracle-12c执行相同的步骤(参见https://hub.docker.com/r/sath89/oracle-12c/<a class="ae jn" href="https://hub.docker.com/r/sath89/oracle-12c/" rel="noopener ugc nofollow" target="_blank"/>)。</p><p id="29f4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">命令和步骤现在是:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0d19" class="jx jy hh jt b fi jz ka l kb kc">docker pull sath89/oracle-12c docker run -d -p 8080:8080 -p 1521:1521 --name oracle-db-12c sath89/oracle-12c</span></pre><p id="c020" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从客户端连接—创建基线。</p><p id="d19a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">设置好基线数据库和数据库内容后，创建该状态的容器映像:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="4967" class="jx jy hh jt b fi jz ka l kb kc">docker commit --pause=true oracle-db-12c</span></pre><p id="d47f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">返回图像标识符。停下集装箱。</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="1b39" class="jx jy hh jt b fi jz ka l kb kc">docker stop oracle-db-12c</span></pre><p id="88eb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在要运行一个测试迭代，从基线图像运行一个容器:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9a46" class="jx jy hh jt b fi jz ka l kb kc">docker run -d -p 1521:1521  --name oracle-db-12c-testbed  &lt;image identifier&gt;</span></pre><p id="13bc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在端口1521连接到数据库，或者让正在测试的web应用程序或API建立连接。</p><h1 id="abc0" class="kd jy hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">资源</h1><p id="45d9" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">Docker创建命令:<a class="ae jn" href="https://docs.docker.com/engine/reference/commandline/create/#parent-command" rel="noopener ugc nofollow" target="_blank">https://docs . Docker . com/engine/reference/Command line/Create/# parent-Command</a></p><p id="2f4d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Docker日常使用的俏皮Docker命令:<a class="ae jn" href="https://codefresh.io/docker-tutorial/everyday-hacks-docker/" rel="noopener ugc nofollow" target="_blank">https://codefresh.io/docker-tutorial/everyday-hacks-docker/</a></p><p id="749f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Circle CI博客—使用CRIU检查点和恢复Docker容器—<a class="ae jn" href="https://circleci.com/blog/checkpoint-and-restore-docker-container-with-criu/" rel="noopener ugc nofollow" target="_blank">https://circle CI . com/Blog/check point-and-restore-Docker-container-with-criu/</a></p><p id="a31c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lf">原载于2018年4月18日</em><a class="ae jn" href="https://technology.amis.nl/2018/04/18/quickly-spinning-up-docker-containers-with-baseline-oracle-database-setup-for-performing-automated-tests/" rel="noopener ugc nofollow" target="_blank"><em class="lf">technology . amis . nl</em></a><em class="lf">。</em></p></div></div>    
</body>
</html>