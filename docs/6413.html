<html>
<head>
<title>Creating a Task Queue with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript创建任务队列</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/creating-a-task-queue-with-typescript-3993ed2cc303?source=collection_archive---------1-----------------------#2018-02-02">https://medium.com/quick-code/creating-a-task-queue-with-typescript-3993ed2cc303?source=collection_archive---------1-----------------------#2018-02-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8b71605147ec788b3fcbaaf5ef6cbbc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_HBBqTpiUy038DWXjsSSsw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/photos/1O77vgBVkXQ?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Michał Parzuchowski</a> on <a class="ae it" href="https://unsplash.com/search/photos/queue?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1f97" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一直想写一个超级基础的任务队列。我没有任何特定的语言来实现它，所以我决定使用TypeScript。</p><p id="67ec" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们继续之前，我只想说下面的代码是不整洁的，它并不总是使用类型。例如，保存所有队列项的变量应该有一个类型，但它只是一个普通的JS对象。</p><p id="9a4b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好了，让我们进入代码。</p><h1 id="4366" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">长队</h1><p id="518b" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我将从队列类开始。这是非常基本的。它有一个属性和两个方法。</p><p id="dd0d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该属性保存所有的任务或我称之为“queueItems”。这只是一个简单的空白JavaScript对象。</p><p id="318e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">代码的下一部分是“addQueueItemForTopic”函数。它所做的就是接受一个IQueueItem类型的queueItem(我们稍后会讲到)和一个主题。主题只是一个字符串，它将是“queueItems”属性中的一个键。queueItem参数将是需要运行的任务。</p><p id="46e2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下一个函数是“processItemsForQueueTopic”。这基本上做到了它所说的。它只是为队列当前拥有的每个任务或“queueItem”运行代码。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="b14a" class="le jt hh la b fi lf lg l lh li">class Queue<br/>{<br/>   queueItems = {};<br/><br/>   addQueueItemForTopic(<em class="lj">queueItem</em>: IQueueItem, <em class="lj">topic</em>: string)<br/>   {<br/>      if (this.queueItems[<em class="lj">topic</em>] === undefined)<br/>      {<br/>         this.queueItems[<em class="lj">topic</em>] = [<em class="lj">queueItem</em>];<br/>      }<br/>      else<br/>      {<br/>         this.queueItems[<em class="lj">topic</em>].push(<em class="lj">queueItem</em>);<br/>      }<br/>   }<br/><br/>   processItemsForQueueTopic(<em class="lj">topic</em>: string)<br/>   {<br/>      for (let item of <em class="lj">queue</em>.queueItems[<em class="lj">topic</em>])<br/>      {<br/>         item.main();<br/>      }<br/>      <br/>      this.queueItems[<em class="lj">topic</em>] = [];<br/>      let numberOfItemsLeft = this.queueItems[<em class="lj">topic</em>].length;<br/>      <br/>      if (numberOfItemsLeft &gt; 0)<br/>      {<br/>         console.log("Number of items left in Queue for topic" + <em class="lj">topic</em>, this.queueItems[<em class="lj">topic</em>].length);<br/>      }<br/>      else<br/>      {<br/>         console.log("No more tasks for topic " + <em class="lj">topic</em>);<br/>      }<br/>   }<br/>}<br/><br/>let <em class="lj">queue </em>= new Queue();</span></pre><h1 id="297d" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">队列项</h1><p id="ecda" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">现在我们进入“IQueueItem”界面。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="4ffb" class="le jt hh la b fi lf lg l lh li">// Interface that an item added to the queue needs to conform to<br/>interface IQueueItem<br/>{<br/>   main&lt;T&gt;(something?:T);<br/>}</span></pre><p id="14ba" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就是“processItemsForQueueTopic”函数能够运行的原因。添加到队列中的每个项目都需要符合这个协议。这个接口有一个叫做“main”的方法。当您创建一个符合这个接口的对象时，您想要进行的所有处理都将发生在这个“main”函数中。</p><p id="aeef" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当调用“processItemsForQueueTopic”函数时，它将遍历您指定的主题队列中的每个项目，并调用“queueItem”或任务的“main”函数。</p><h1 id="f158" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建任务</h1><p id="8140" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">创建任务非常简单。它只需要符合IQueueItem接口。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="e20e" class="le jt hh la b fi lf lg l lh li">let <em class="lj">task1</em>: IQueueItem = {<br/>   main: function&lt;T&gt;(something?:T)<br/>   {<br/>      let <em class="lj">calculation </em>= 1 + 1;<br/>      console.log(<em class="lj">calculation</em>);<br/>   }<br/>}</span></pre><p id="3c57" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该任务需要符合IQueueItem接口的原因是，它需要具有您在上面看到的main函数。</p><p id="ce0a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该函数将包含您需要处理的所有逻辑。</p><p id="9841" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后当您告诉队列处理特定主题的项目时。它将运行该主题的所有项目，然后在每个任务上调用main函数，该函数将执行您希望它执行的所有处理。</p><p id="0b99" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一项任务的示例，但以“电子邮件”为主题:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="3b7f" class="le jt hh la b fi lf lg l lh li">let <em class="lj">task2</em>: IQueueItem = {<br/>   main: function&lt;T&gt;(something?:T)<br/>   {<br/>      let <em class="lj">email </em>= "test@email.com";<br/>      console.log("Send mail to:", <em class="lj">email</em>);<br/>   }<br/>}</span></pre><h1 id="8d09" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">添加到队列中</h1><p id="a464" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">现在需要做的就是将它添加到队列中，如下所示:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="dfe3" class="le jt hh la b fi lf lg l lh li">queue.addQueueItemForTopic(<em class="lj">task1</em>, "calculation");<br/>queue.addQueueItemForTopic(<em class="lj">task2</em>, "email");</span></pre><p id="066f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就是将它添加到队列中所需要做的全部工作。之后，我们将只告诉队列处理或调用主函数。</p><h1 id="b4c0" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">处理队列中的任务</h1><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="3f76" class="le jt hh la b fi lf lg l lh li">queue.processItemsForQueueTopic("calculation");<br/>queue.processItemsForQueueTopic("email");</span></pre><p id="f032" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们想要处理每个主题的所有任务时，我们只需调用processItemsForQueue函数来处理我们想要运行的主题，这样就完成了。</p><p id="8342" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这将运行我们添加到队列中的所有任务。</p><p id="e7d5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意，这是队列的一个非常基本的版本。可以添加许多其他功能来使它变得更好，更实用。</p><p id="077c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请在评论中告诉我是否有我可以用这段代码改进的地方！</p></div></div>    
</body>
</html>