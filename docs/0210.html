<html>
<head>
<title>Faster JavaScript Builds with Metro</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Metro构建更快的JavaScript</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/faster-javascript-builds-with-metro-cfc46d617a1f?source=collection_archive---------1-----------------------#2022-05-24">https://medium.com/airbnb-engineering/faster-javascript-builds-with-metro-cfc46d617a1f?source=collection_archive---------1-----------------------#2022-05-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d786" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">Airbnb如何从Webpack迁移到Metro，并使开发反馈循环近乎即时，最大的生产构建速度提高了50%,最终用户运行时间略有改善。</em></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0e3735d3f142c2e57541d5025179b948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZFWkaoezUfVzTxvpfm2gQ.jpeg"/></div></div></figure><p id="5b5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> By: </strong> <a class="ae jp" href="https://www.linkedin.com/in/raejin/" rel="noopener ugc nofollow" target="_blank"> Rae刘</a></p><h1 id="6e9e" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="53df" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">2018年，前端Airbnb基础设施依赖Webpack进行JavaScript捆绑，在此之前一直为我们提供良好的服务；然而，随着我们的代码库在去年几乎翻了两番，前端团队注意到了对开发体验的重大影响。不仅构建性能慢，而且一行代码的平均页面刷新时间在30秒到2分钟之间，这取决于项目的大小。为了减轻这种情况，团队决定迁移到<a class="ae jp" href="https://facebook.github.io/metro/" rel="noopener ugc nofollow" target="_blank">地铁</a>。</p><p id="ecd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于切换到Metro，我们提高了构建性能。在开发中，反映和加载一个简单的UI更改所需的时间(<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Glossary/Time_to_interactive" rel="noopener ugc nofollow" target="_blank">时间到交互TTI指标</a>)比<strong class="ig hi">快80%</strong>。编译大约49k模块(JavaScript文件)的最慢的生产构建比<strong class="ig hi">快55%</strong>(从30.5分钟降到13.8分钟)。作为一个额外的奖励，我们观察到使用Metro构建的页面在<a class="ae jp" rel="noopener" href="/airbnb-engineering/creating-airbnbs-page-performance-score-5f664be0936"> Airbnb页面性能得分</a>上提高了~ <strong class="ig hi"> 1% </strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kt"><img src="../Images/a266e6a3b83b96c56e54fcaed79cb090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*Og_DCsn0p_8RkRR3eu40hw.png"/></div></figure><p id="30d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">JavaScript bundlers的扩展问题当然不是Airbnb独有的问题。在这篇博文中，我们想要强调Webpack和Metro之间的关键架构差异，以及我们在开发和生产构建中面临的一些迁移挑战。如果你预计你自己的一个项目在未来会有很大的扩展，我们希望这篇文章能提供解决这个问题的有用见解。</p><h1 id="8b9d" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">什么是地铁？</h1><p id="4583" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated"><a class="ae jp" href="https://facebook.github.io/metro/" rel="noopener ugc nofollow" target="_blank"> Metro </a>是React Native的开源JavaScript捆绑器。虽然Airbnb不再使用React Native ，但我们相信它的基础设施也可以用于网络。在与Meta的Metro人员进行了多次磋商以及我们自己的一些修改后，我们设法建立了一种Metro风格，现在可以为所有Airbnb网站提供开发和生产捆绑服务。</p><p id="a6fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从概念上讲，Metro将捆绑分解为三个步骤，顺序如下:<a class="ae jp" href="https://facebook.github.io/metro/docs/concepts#resolution" rel="noopener ugc nofollow" target="_blank">解析</a>、<a class="ae jp" href="https://facebook.github.io/metro/docs/concepts#transformation" rel="noopener ugc nofollow" target="_blank">转换</a>和<a class="ae jp" href="http://serialization" rel="noopener ugc nofollow" target="_blank">序列化</a>。</p><ul class=""><li id="5356" class="ku kv hh ig b ih ii il im ip kw it kx ix ky jb kz la lb lc bi translated">解析处理如何解析import/require语句。</li><li id="29be" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">Transformation负责编译代码(源代码到源代码的编译器，它将现代的TypeScript/JavaScript源代码转换成功能相当的JavaScript代码，这些代码经过了更好的优化并向后兼容旧的浏览器)，一个示例工具是<a class="ae jp" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> babel </a>。</li><li id="6d2a" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">序列化将转换后的文件组合成JavaScript包。</li></ul><p id="c9dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这三个概念是理解Metro如何工作的基础。在接下来的章节中，我们将重点介绍Metro和Webpack之间的关键架构差异，以便更深入地了解Metro的优势。</p><h1 id="1368" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Metro和Webpack之间的主要架构差异</h1><h1 id="754c" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">在开发中按需处理JS包</h1><p id="8776" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">当我们谈论包时，JavaScript包在技术上只是一个序列化的依赖图，其中入口点是图的根。在Airbnb，一个网页映射到一个入口点。在开发中，Webpack(甚至是最新的v5版本)需要知道所有页面的入口点<a class="ae jp" href="https://webpack.js.org/concepts/entry-points/" rel="noopener ugc nofollow" target="_blank">才能开始捆绑。另一方面，Metro开发服务器动态处理请求的JavaScript包。</a></p><p id="693f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更具体地说，在Airbnb，每个前端项目都有一个节点服务器，它匹配到特定入口点的路径。当请求一个web页面时，DOM包含带有开发JavaScript URLs的脚本标记。浏览器加载页面，并向Metro开发服务器请求JavaScript包。在图1中，我们展示了Metro和Webpack开发设置之间的差异:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es li"><img src="../Images/c2be6e82d59d3f3529b0c56a29b19f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d0S7RQA6IXt1YqAO"/></div></div></figure><p id="09f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图Metro和Webpack的JS包开发设置之间的差异</p><p id="e31a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个示例中，有一个web项目，它有三个入口点:entryPageA.js、entryPageB.js和entryPageC.js。如图1所示，在这两个场景中，浏览器加载页面A (1)，然后向捆绑器请求entryPageA.js文件(2)，最后捆绑器用适当的捆绑包响应浏览器(4)。使用Webpack bundler (1a)，即使浏览器只请求entryPageA.js，Webpack也会在启动时编译所有入口点，然后才能响应来自浏览器的entryPageA.js请求。另一方面，在Metro bundler (1b)中，我们看到开发服务器没有花费任何时间编译entryPageB.js或entryPageC.js，而是在响应浏览器请求之前只编译entryPageA.js。</p><p id="c794" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Airbnb最大的前端项目之一有大约2.6万个独立模块，每页模块数量的中位数是大约7.2万个模块。因为我们也做服务器端渲染，我们最终需要处理的模块数量翻倍，大约为48k。使用Metro的开发模型，我们通过按需编译JavaScript节省了大约70%的工作。</p><p id="cb77" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一关键的架构差异改善了开发人员的体验，因为Metro只编译需要的内容(请求页面上的JavaScript包)，而Webpack在启动时预编译整个项目。</p><h1 id="bcda" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">多层高速缓存</h1><p id="dc67" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">我们利用的另一个强大的Metro特性是它的<a class="ae jp" href="https://facebook.github.io/metro/docs/caching" rel="noopener ugc nofollow" target="_blank">多层缓存</a>特性，这使得设置持久和非持久缓存变得简单明了。虽然Webpack 5也配有<a class="ae jp" href="https://webpack.js.org/guides/build-performance/#persistent-cache" rel="noopener ugc nofollow" target="_blank">磁盘永久缓存</a>，但它没有Metro的多层缓存灵活。Webpack提供了两种<a class="ae jp" href="https://webpack.js.org/configuration/cache/#cachetype" rel="noopener ugc nofollow" target="_blank">截然不同的缓存类型</a>:“文件系统”或“内存”，仅限于内存或磁盘缓存，没有远程缓存功能。相比之下，Metro提供了更多的灵活性，允许我们定义缓存实现，包括混合不同类型的缓存层。如果一个层有缓存未命中，Metro会尝试从下一层检索缓存，依此类推。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lj"><img src="../Images/2397fe5538dc6a7c24570f932c8b5500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/0*bvgMUBI6wm9xe0fZ"/></div></figure><p id="227e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图Airbnb如何使用Metro配置多缓存层</p><p id="f16c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">高速缓存的排序决定了高速缓存的优先级。检索缓存时，将使用第一个有结果的缓存层。在图2所示的设置中，速度最快的内存缓存层的优先级最高，其次是文件/磁盘缓存，最后是远程只读缓存。与没有缓存的默认Metro实现相比，在编译22k文件的项目中，使用远程只读缓存可以使服务器构建速度提高56%。</p><p id="d53d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Metro性能的一个贡献因素是其内置的工人支持，这放大了多层缓存的效果。虽然Webpack需要仔细配置才能通过第三方插件利用worker，但Metro默认情况下会加速worker以卸载昂贵的转换，从而无需配置即可提高并行性。</p><p id="dbae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是为什么要使用远程只读缓存而不是常规的远程缓存(读和写)？我们发现，对于具有22k文件的同一个项目，不写入远程缓存可以额外节省17% <strong class="ig hi"> </strong>的构建时间。向远程缓存写入数据会导致网络调用，这可能会造成很高的开销，尤其是在速度较慢的网络上。为了填充缓存，我们引入了一个在默认分支提交时定期运行的CI作业，而不是远程缓存写入。</p><h1 id="972b" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">序列化</h1><p id="3b9f" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">在bundler上下文中，序列化意味着将转换后的源文件组合成一个或多个包。在Webpack中，序列化的概念封装在<a class="ae jp" href="https://webpack.js.org/api/compilation-hooks/#root" rel="noopener ugc nofollow" target="_blank">编译挂钩</a> (Webpack的公共API)中。在Metro中，序列化函数负责将源文件组合成包。</p><p id="74bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于序列化重要性的一个例子，让我们看看国际化支持。我们目前支持大约70个地区的Airbnb网站，2020年，我们的<a class="ae jp" rel="noopener" href="/airbnb-engineering/building-airbnbs-internationalization-platform-45cf0104b63c">国际化平台</a>提供了超过100万条内容。为了支持JS包的国际化，我们需要在序列化步骤中实现特定的逻辑。尽管我们在序列化Metro和Webpack的捆绑包时必须实现类似的国际化逻辑，但是Webpack需要大量的源代码阅读来找到合适的编译挂钩，以便我们实现这种支持。除此之外，还需要理解复杂的概念，比如什么是依赖模板以及如何编写我们自己的模板。相比之下，与Metro实现相同的国际化支持则是一股新鲜空气。我们只需关注如何将JS包与翻译内容序列化，所有任务都在单个序列化器函数中完成。Metro捆绑概念的简单性使得任何定制功能的实现都非常简单。</p><h1 id="c952" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Airbnb采用Metro的挑战</h1><p id="d0a8" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">尽管Metro具有上述的架构优势，但它也带来了需要克服的挑战，以便在web上充分利用它。因为Metro是为在React本地环境中使用而设计的，所以我们需要编写更多的代码来实现与Webpack同等的功能，所以决定改用Metro的代价是重新发明一些轮子，并学习通常与我们无关的JavaScript bundler的内部工作方式。</p><p id="1812" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在开发中，我们必须创建一个带有自定义端点的Metro服务器来处理构建依赖图、翻译、捆绑JS &amp; CSS文件以及构建源地图。对于产品构建，我们将Metro作为一个节点API来处理解析、转换和序列化。</p><p id="b0d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">完全迁移的表面积很大，所以我们将其分为两个阶段。因为我们的Webpack设置的缓慢迭代速度导致了开发人员生产力方面的巨大成本，所以我们将使用Metro development server解决缓慢的Webpack开发体验作为我们的首要任务。在第二阶段，我们让Metro具有与Webpack对等的特性，并在生产中运行Metro和Webpack之间的A/B测试。我们在这一过程中面临的两个最大挑战概述如下。</p><h1 id="c32f" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">束分裂</h1><p id="3d7c" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">用于开发的开箱即用Metro设置在每个入口点产生了大约5MiB的巨大包，因为单个包是React Native的预期用例。对于Web来说，这个包的大小对浏览器资源和网络延迟造成了很大的负担。每次代码更改都会导致5mb的包被处理和下载，效率很低，并且无法进行HTTP缓存。即使更改后的代码立即重新编译，我们仍然需要减小代码的大小并提高浏览器的可缓存性。</p><p id="dedf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了提高Metro在Web环境中的性能，我们通过<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#dynamic_import" rel="noopener ugc nofollow" target="_blank">动态导入</a>边界来分割包，这种技术也被称为<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting" rel="noopener ugc nofollow" target="_blank">代码分割</a>。代码分割边界使我们能够有效地利用HTTP缓存。</p><p id="e1bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在图3中，导入('。/file’)表示动态导入边界。左手侧的束(3a)被分解成右边的三个更小的束(3b)。当导入(')时，需要额外的包。/file’)语句。</p><p id="c84a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在图3a中，假设fileA.js已更改，则需要重新下载整个包，以便浏览器获取fileA.js中的更改。对于图3b所示的通过动态导入拆分的包，fileA.js中的更改只会导致重新下载fileA.js包。其余的包可以重用浏览器缓存。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/17a3448987a475cc8fae735ae7e3117f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R2QCSRzc7ysunr3_"/></div></div></figure><p id="adf5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图3:通过动态导入边界分割包。束由带有粉色背景的矩形框表示。</p><p id="1a32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们开始考虑生产捆绑包时，我们希望优化与开发中有所不同。运行束分裂算法需要时间，我们不想在开发中浪费时间优化束大小。相反，我们优先考虑页面加载性能，而不是最小化包的大小。</p><p id="b33b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在生产中，我们希望向最终用户交付更少更小的JavaScript包，以便页面加载更快，用户体验更好。生产中没有Metro开发服务器，所以所有的包都是预构建的。这使得束分裂成为使我们的Metro构建产品就绪所需的最大的阻塞特性。受Webpack的束分裂算法的启发，我们实现了一个类似的机制来分裂Metro依赖图。与通过动态导入边界进行的开发分割相比，在airbnb.com上产生的包大小减少了约20%(1549 KB –&gt; 1226 KB)。</p><p id="1aea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在比较Metro和Webpack实现之间的捆绑包分割结果时，我们意识到两者都提供了大小相当的捆绑包，其中一些页面使用Metro提供了数量略高的Javascript捆绑包。尽管页面权重稍重，Metro和Webpack的<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Glossary/First_contentful_paint" rel="noopener ugc nofollow" target="_blank"> TTFCP </a>、<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/API/Largest_Contentful_Paint_API" rel="noopener ugc nofollow" target="_blank">最大内容油漆</a>和<a class="ae jp" href="https://web.dev/lighthouse-total-blocking-time/" rel="noopener ugc nofollow" target="_blank">总阻塞时间</a>指标不相上下。</p><h1 id="c601" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">摇树</h1><p id="f469" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">单独的束分裂显著地减少了束的大小，但是我们能够通过删除死代码使束更小。然而，在一个项目中识别什么被认为是死代码并不总是显而易见的，因为一个项目中的一些“死代码”可能是其他项目中的“用过的代码”。这就是摇树运动发挥作用的地方。它依赖于代码库中<a class="ae jp" href="https://tc39.es/ecma262/#sec-modules" rel="noopener ugc nofollow" target="_blank"> ECMAScript模块</a>(ESM)<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">import</a>/<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export" rel="noopener ugc nofollow" target="_blank">export</a>语句的一致用法。基于项目中的导入/导出使用，我们分析了哪些特定的导出语句没有被项目中的任何文件导入。最后，bundler删除未使用的导出语句，使整个包变得更小。</p><p id="da97" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在为Metro产品构建实现树摇动算法时面临的一个挑战是错误地删除运行时执行的代码的风险。例如，我们遇到了与<a class="ae jp" href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export#re-exporting_aggregating" rel="noopener ugc nofollow" target="_blank">重导出语句</a>相关的多个bug。由于Webpack以不同的方式处理ESM导入/导出语句，因此没有可比较的现有技术可供参考。在多次迭代树抖动算法实现之后，下表显示了在给定项目规模的情况下，我们最终能够丢弃多少死代码。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/edc98e42aeafbdc49a4790780f426a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlsTTqWIGeJzk_ccUzFuBw.png"/></div></div></figure><h1 id="4248" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="2629" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">地铁迁移带来了一些非常重要的改进。Airbnb最大的前端项目编译了大约48k模块(包括服务器和浏览器编译)，平均构建时间从30.5分钟下降到13.8分钟，下降了大约55%。此外，我们看到<a class="ae jp" rel="noopener" href="/airbnb-engineering/creating-airbnbs-page-performance-score-5f664be0936"> Airbnb页面性能分数</a>有所提高，由Metro创建的页面性能分数提高了约1%。最终用户性能的提高是一个惊喜，因为我们最初的目标是获得中性的实验结果。</p><p id="24ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Metro架构的简单性在许多方面让我们受益匪浅。来自其他团队的工程师迅速加入到Airbnb的Metro实施中，这意味着为捆绑系统做出贡献的门槛更低。<a class="ae jp" href="https://facebook.github.io/metro/docs/caching" rel="noopener ugc nofollow" target="_blank">多层缓存系统</a>操作简单，使得缓存实验成为可能。定制捆绑器功能集成变得显而易见且更易于实施。</p><p id="7ccf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们承认，自从我们在2018年评估<a class="ae jp" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">地块</a>、<a class="ae jp" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank">网络包4 </a>和<a class="ae jp" href="https://facebook.github.io/metro/" rel="noopener ugc nofollow" target="_blank">地铁</a>以来，情况已经发生了变化。还有其他一些工具，比如<a class="ae jp" href="https://rollupjs.org/guide/en/" rel="noopener ugc nofollow" target="_blank"> rollup.js </a>和<a class="ae jp" href="https://esbuild.github.io/" rel="noopener ugc nofollow" target="_blank"> esbuild </a>，我们还没有探索太多，我们知道与Webpack相比，Metro不是一个通用的JavaScript bundler。然而，在Metro特性奇偶校验上工作了几年之后，我们看到的结果向我们证明了追求Metro是一个好的决定。Metro <strong class="ig hi">通过缩短开发和生产构建时间，解决了</strong>我们最绝望的扩展问题。借助即时开发反馈循环和更快的生产构建，我们比以往任何时候都更加高效。如果你想帮助我们继续改进我们的JavaScript工具和构建优化，或者解决其他网络基础设施的挑战，请查看Airbnb的这些开放角色:</p><p id="6393" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jp" href="https://careers.airbnb.com/positions/3903900/?gh_src=61d6ab411us" rel="noopener ugc nofollow" target="_blank">高级前端基础设施工程师，网络平台</a></p><p id="8375" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jp" href="https://careers.airbnb.com/positions/3903900/?gh_src=61d6ab411us" rel="noopener ugc nofollow" target="_blank">基础设施工程经理</a></p><p id="65b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jp" href="https://careers.airbnb.com/positions/2623004/" rel="noopener ugc nofollow" target="_blank">云基础设施高级软件工程师</a></p><p id="4dac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jp" href="https://careers.airbnb.com/positions/4168852/" rel="noopener ugc nofollow" target="_blank">高级/职员软件工程师，可观察性</a></p><h1 id="7e86" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">感谢</h1><p id="69a1" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">感谢所有为这个多年项目做出贡献的人。没有你们任何一个人，我们不可能做到！特别感谢我可爱的团队<a class="ae jp" href="mailto:michael.james@airbnb.com" rel="noopener ugc nofollow" target="_blank">迈克尔·詹姆斯</a>和<a class="ae jp" href="mailto:noah.sugarman@airbnb.com" rel="noopener ugc nofollow" target="_blank">诺亚·舒格曼</a>将地铁生产迁移到终点线。感谢<a class="ae jp" href="mailto:breanna.bunge@airbnb.com" rel="noopener ugc nofollow" target="_blank">布里·邦吉</a>、<a class="ae jp" href="mailto:dan.beam@airbnb.com" rel="noopener ugc nofollow" target="_blank">丹·比姆</a>、<a class="ae jp" href="mailto:ian.myers@airbnb.com" rel="noopener ugc nofollow" target="_blank">伊恩·迈尔斯</a>、<a class="ae jp" href="mailto:ian.remmel@airbnb.com" rel="noopener ugc nofollow" target="_blank">伊恩·雷梅尔</a>、<a class="ae jp" href="mailto:joe.lencioni@airbnb.com" rel="noopener ugc nofollow" target="_blank">乔·伦乔尼</a>、<a class="ae jp" href="mailto:madison.capps@airbnb.com" rel="noopener ugc nofollow" target="_blank">麦迪森·卡普斯</a>、<a class="ae jp" href="mailto:michael.james@airbnb.com" rel="noopener ugc nofollow" target="_blank">迈克尔·詹姆斯</a>、<a class="ae jp" href="mailto:noah.sugarman@airbnb.com" rel="noopener ugc nofollow" target="_blank">诺亚·舒格曼</a>对这篇博文的评论和巨大反馈。</p><p id="9ae1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">所有产品名称、标识和品牌都是其各自所有者的财产。本网站中使用的所有公司、产品和服务名称仅用于识别目的。使用这些名称、标志和品牌并不意味着认可。</em></p></div></div>    
</body>
</html>