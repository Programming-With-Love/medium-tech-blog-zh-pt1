<html>
<head>
<title>Introduction to HTTP 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP 2简介</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/introduction-to-http-2-d3e3b4f4d662?source=collection_archive---------2-----------------------#2019-07-26">https://medium.com/walmartglobaltech/introduction-to-http-2-d3e3b4f4d662?source=collection_archive---------2-----------------------#2019-07-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/c2e1cd56ab15d120fafc7a37ef883369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1rP31GmPVWjAryML8s-EQ.png"/></div></div></figure><div class=""/><h1 id="06fe" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">HTTP的简史</h1><p id="fb28" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">HTTP是一个古老的协议，最初定义于1991年，最新的主要修订版HTTP/1.1发布于1999年。1999年的网站与我们今天开发的网站非常不同。现在加载一个普通网站的主页所需的数据量是1.9 MB，显示一个页面需要100多个单独的资源。资源可以是从图像或字体到JavaScript或CSS文件的任何东西。当检索显示一个现代网站所需的大量资源时，HTTP/1.1的性能并不好。</p><h1 id="3d06" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">HTTP/2简介</h1><p id="ace7" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">HTTP/2将使我们的应用程序更快、更简单、更健壮，因为它允许我们撤销以前在应用程序中完成的许多HTTP/1.1变通方法，并在传输层本身解决这些问题。</p><p id="293c" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">HTTP/2的主要目标是通过启用完整的请求和响应多路复用来减少延迟，通过有效压缩HTTP头字段来最小化协议开销，并添加对请求优先级和服务器推送的支持。</p><p id="9158" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">HTTP/2不会以任何方式修改HTTP的应用程序语义。所有的核心概念，比如HTTP方法、状态代码、URIs和头字段都保留了下来，这意味着所有现有的应用程序都可以不加任何修改地交付。</p><h1 id="2eb6" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">HTTP/2的功能</h1><h1 id="4391" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">二进制帧层</h1><p id="db22" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">HTTP/2引入了新的二进制帧层，它规定了HTTP消息如何在客户机和服务器之间封装和传输。</p><p id="1cca" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">HTTP/1.1使用换行符分隔的明文协议，而HTTP/2通信被分成更小的消息和帧，每个消息和帧都以二进制格式编码。</p><figure class="kr ks kt ku fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kq"><img src="../Images/678a772ea25970661fed14b7dc66fed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*imI93QnNw-m7ezH3"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">source:developers.google.com</figcaption></figure><h1 id="c3a4" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">流、消息和帧</h1><p id="d616" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">为了理解用于在客户机和服务器之间交换数据的新的二进制成帧机制，我们需要熟悉HTTP/2术语:</p><ul class=""><li id="660e" class="kz la hs jp b jq kl ju km jy lb kc lc kg ld kk le lf lg lh bi translated"><em class="li">流</em>:已建立连接内的双向字节流，可以携带一条或多条消息。</li><li id="b220" class="kz la hs jp b jq lj ju lk jy ll kc lm kg ln kk le lf lg lh bi translated"><em class="li">消息</em>:映射到逻辑请求或响应消息的完整帧序列。</li><li id="5d0c" class="kz la hs jp b jq lj ju lk jy ll kc lm kg ln kk le lf lg lh bi translated">帧:HTTP/2中最小的通信单元，每个单元包含一个帧头，它至少标识该帧所属的流。</li></ul><figure class="kr ks kt ku fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lo"><img src="../Images/5c17bb33515c859b152462d51cc6831b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bqOzhDnVGAlQBMre"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">source:developers.google.com</figcaption></figure><p id="a3f8" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这些术语的关系描述如下:</p><ul class=""><li id="5ff0" class="kz la hs jp b jq kl ju km jy lb kc lc kg ld kk le lf lg lh bi translated">所有通信都是通过一个TCP连接进行的，该连接可以承载任意数量的双向流。</li><li id="9fb4" class="kz la hs jp b jq lj ju lk jy ll kc lm kg ln kk le lf lg lh bi translated">每个流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息。</li><li id="528e" class="kz la hs jp b jq lj ju lk jy ll kc lm kg ln kk le lf lg lh bi translated">每个消息都是一个逻辑HTTP消息，如请求或响应，由一个或多个帧组成。</li><li id="0d86" class="kz la hs jp b jq lj ju lk jy ll kc lm kg ln kk le lf lg lh bi translated">帧是承载特定类型数据的最小通信单元，例如HTTP报头、消息有效载荷等。来自不同流的帧可以被交织，然后经由每个帧的报头中嵌入的流标识符被重组。</li></ul><h1 id="c39f" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">请求和响应多路复用</h1><p id="88fa" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">对于HTTP/1.1，客户端使用多个TCP连接来发出多个并行请求，以提高性能。使用HTTP/1.1，每个连接一次只能传送一个响应(响应队列)。</p><p id="3abc" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">有了HTTP/2，新的二进制成帧层消除了这些限制，并通过允许客户机和服务器将HTTP消息分解成独立的帧，将它们交错，然后在另一端重新组合，实现了完全的请求和响应多路复用。</p><figure class="kr ks kt ku fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kq"><img src="../Images/31b97e6ddb9f0c508092b94c17e95b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QDn-fiGRIv4qHXXo"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">source:developers.google.com</figcaption></figure><h1 id="a628" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">每个原点一个连接</h1><p id="c9da" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">HTTP/2不再需要多个TCP连接来并行多路传输流，因为它使用了新的二进制成帧机制，HTTP/2中的每个流都被分割成多个帧，这些帧可以交错并区分优先级。因此，对于HTTP/2，每个源只需要一个连接，这提供了许多性能优势。</p><h1 id="4438" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">服务器推送</h1><p id="216d" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">HTTP/2的另一个强大的新特性是服务器能够为单个客户机请求发送多个响应。也就是说，除了对原始请求的响应之外，服务器可以将额外的资源推送到客户端，而客户端不必显式地请求每一个资源。</p><figure class="kr ks kt ku fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kq"><img src="../Images/b326ce343a699217a2b1d4c441e38046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1-xVSdZj3nBXBH8P"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">source:developers.google.com</figcaption></figure><p id="6e2e" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">典型的web应用程序由多个资源组成，这些资源由客户端通过检查服务器提供的文档来发现。然后，我们可以消除额外的延迟，让服务器提前推送相关资源。服务器已经知道客户端将需要哪些资源，这就是服务器推送。</p><h1 id="2097" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">标题压缩</h1><p id="f350" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">每个HTTP传输都带有一组描述传输的资源及其属性的头。在HTTP/1.1中，该元数据总是以纯文本的形式发送，每次传输会增加500-800字节的开销，如果使用HTTP cookies，有时会增加数千字节。为了减少这种开销并提高性能，HTTP/2使用HPACK压缩格式来压缩请求和响应头元数据，这种压缩格式使用了两种简单但功能强大的技术。</p><ol class=""><li id="29c5" class="kz la hs jp b jq kl ju km jy lb kc lc kg ld kk lp lf lg lh bi translated">它允许通过静态霍夫曼码对传输的报头字段进行编码，从而减小了它们各自的传输大小。</li><li id="ad40" class="kz la hs jp b jq lj ju lk jy ll kc lm kg ln kk lp lf lg lh bi translated">它要求客户端和服务器都维护和更新先前看到的报头字段的索引列表(换句话说，它建立了共享的压缩上下文)，然后该列表被用作有效编码先前传输的值的参考。</li></ol><figure class="kr ks kt ku fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/4909d7d56ad788bd05bf93a3513be4ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iJLy4dVfd3HkcPSI"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx">source:developers.google.com</figcaption></figure><h1 id="6d45" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">利弊</h1><h1 id="4afe" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">优点:</h1><ul class=""><li id="6154" class="kz la hs jp b jq jr ju jv jy lr kc ls kg lt kk le lf lg lh bi translated">HTTP/2是二进制的，而不是文本的。</li><li id="faf1" class="kz la hs jp b jq lj ju lk jy ll kc lm kg ln kk le lf lg lh bi translated">通过引入报头字段压缩，HTTP2能够更有效地利用网络资源并减少延迟。</li><li id="ea49" class="kz la hs jp b jq lj ju lk jy ll kc lm kg ln kk le lf lg lh bi translated">HTTP/2是完全多路复用的。我们可以在一个TCP连接中发出多个并行请求来提高性能。这又导致可用网络容量的更好利用。</li><li id="ce4f" class="kz la hs jp b jq lj ju lk jy ll kc lm kg ln kk le lf lg lh bi translated">有了服务器推送的新特性，服务器已经知道客户端将需要哪些资源，而无需客户端像CSS或JS文件那样明确地请求每一个资源。</li><li id="3bab" class="kz la hs jp b jq lj ju lk jy ll kc lm kg ln kk le lf lg lh bi translated">总的来说，有了HTTP2，我们可以大大减少应用程序的加载时间。</li></ul><h1 id="5494" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">缺点:</h1><p id="cc1e" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">首先，目前确实没有比HTTP/2更好的替代方案。但是，作为一名IT专家，您仍然应该知道该协议的弱点。一些专家认为，随着“HTTP/3”协议的发布，这些问题可能会在未来得到解决，但就目前而言，这些只是一些不利因素。</p><ul class=""><li id="aec6" class="kz la hs jp b jq kl ju km jy lb kc lc kg ld kk le lf lg lh bi translated">不需要加密。</li><li id="b31f" class="kz la hs jp b jq lj ju lk jy ll kc lm kg ln kk le lf lg lh bi translated">Cookie安全性仍然是一个问题。</li><li id="4985" class="kz la hs jp b jq lj ju lk jy ll kc lm kg ln kk le lf lg lh bi translated">它不是很快，也不是超级现代。</li></ul><h1 id="e13a" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">在Azure应用服务上启用HTTP/2</h1><p id="fa67" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">默认情况下，对所有客户禁用HTTP/2。但是，如果您想为您的站点启用HTTP/2，请遵循以下步骤:</p><p id="c4c1" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">打开Azure portal，转到您的应用服务并搜索“配置”。</p><p id="96aa" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在配置中，转到“常规设置”选项卡</p><p id="34e6" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在常规设置中会有一个名为“HTTP版本”的下拉菜单。选择2.0版本并保存。</p><p id="3219" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">重新启动你的应用服务，你就完成了！</p><figure class="kr ks kt ku fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lu"><img src="../Images/11fa8edf3ed5bb23df0ddb28cee3f0e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XLIEv_A-sWtYwxZ-LHVrTQ.jpeg"/></div></div></figure><p id="dac9" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp ht">注意</strong>:大多数现代浏览器只支持在SSL上使用HTTP/2协议，而非SSL流量则继续使用HTTP/1.1，App Service使SSL的启动和运行变得很容易。<a class="ae lv" href="https://docs.microsoft.com/en-us/azure/app-service/web-sites-purchase-ssl-web-site" rel="noopener ugc nofollow" target="_blank">了解如何为你的应用配置</a>新的SSL证书，或者了解如何<a class="ae lv" href="https://docs.microsoft.com/en-us/Azure/app-service/app-service-web-tutorial-custom-ssl" rel="noopener ugc nofollow" target="_blank">将现有的SSL证书</a>绑定到你的应用。</p><h1 id="c9ef" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">向后兼容HTTP/1.1</h1><p id="93ce" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">HTTP/2是向后兼容的，不支持HTTP/2的浏览器将回退到使用HTTP/1.1。我们将测试curl请求的向后兼容性。</p><h1 id="8ee3" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">使用HTTP/1.1的Curl请求</h1><pre class="kr ks kt ku fd lw lx ly lz aw ma bi"><span id="a971" class="mb iq hs lx b fi mc md l me mf">curl -I — http1.1 &lt;hostname&gt;</span><span id="1975" class="mb iq hs lx b fi mg md l me mf"><strong class="lx ht">response</strong> :</span><span id="0b21" class="mb iq hs lx b fi mg md l me mf">HTTP/1.1 200 OK<br/>Content-Length: 3318<br/>Content-Type: text/html<br/>Last-Modified: Wed, 15 May 2019 11:19:57 GMT<br/>Accept-Ranges: bytes<br/>Date: Wed, 15 May 2019 18:18:48 GMT</span></pre><h1 id="a6e9" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">使用HTTP/2的Curl请求</h1><pre class="kr ks kt ku fd lw lx ly lz aw ma bi"><span id="80da" class="mb iq hs lx b fi mc md l me mf">curl -I — http2 &lt;hostname&gt;</span><span id="e6c1" class="mb iq hs lx b fi mg md l me mf"><strong class="lx ht">response</strong> :</span><span id="c2c8" class="mb iq hs lx b fi mg md l me mf">HTTP/2 200<br/>content-length: 3318<br/>content-type: text/html<br/>last-modified: Wed, 15 May 2019 11:19:57 GMT<br/>accept-ranges: bytes<br/>date: Wed, 15 May 2019 18:22:09 GMT</span></pre><p id="92c3" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">正如我们在上面的例子中看到的，当我们使用HTTP/1.1协议向启用了HTTP/2的服务器发送curl请求时，我们得到的是HTTP/1.1中的响应，但是当我们使用HTTP/2协议发送请求时，我们得到的是HTTP/2中的响应。这个测试表明HTTP/2向后兼容HTTP/1.1</p><h1 id="197c" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">HTTP/2的性能改进</h1><p id="2358" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我创建了一个简单的页面，其中包含多个Rest api调用，我将用它来演示HTTP/2的性能改进。</p><h1 id="f695" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">代码片段</h1><p id="3db2" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><strong class="jp ht"> HTML </strong></p><figure class="kr ks kt ku fd hj"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="0fb1" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp ht"> JS控制器</strong></p><figure class="kr ks kt ku fd hj"><div class="bz dy l di"><div class="mh mi l"/></div></figure><p id="e380" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在上面的controller代码中，我们创建了一个someFunction()方法，其中我们调用了一个资源(部署在azure app service上的Rest API ),然后我们使用q.all()方法多次调用someFunction()方法来测试加载时间。</p><h1 id="22eb" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">使用HTTP/1.1的页面加载时间</h1><p id="a800" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们可以在瀑布图中看到，请求是如何通过多个批处理(TCP连接)发出的，导致页面加载时间达到9.408秒。</p><figure class="kr ks kt ku fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mj"><img src="../Images/1bdc6c27c9f14dad562a7d6e7d25bd80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qcm_Yva65QNTYl1tD_BDmQ.png"/></div></div></figure><h1 id="a343" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">使用HTTP/2的页面加载时间</h1><p id="a420" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们可以在瀑布图中看到请求是如何通过2个批处理(TCP连接)发出的，从而将页面加载时间减少到4.196秒。这与HTTP/1.1相比在加载时间上有很大不同</p><figure class="kr ks kt ku fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mk"><img src="../Images/fa047ee3af075751fb4bbadc2920c722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oO8hwY5h50ydy5vok7rlA.png"/></div></div></figure><p id="1a10" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">正如我们在上面的比较中所看到的，使用HTTP/2，我们可以极大地提高网页性能。目前，几乎所有的web客户机都广泛支持HTTP/2，所以它的实现是没有痛苦的。虽然HTTP/2协议的实现很容易，但是你应该记住，使用HTTP/2，你可能需要改变应用程序的机制(比如为客户端提供资源),以充分发挥该协议的潜力。</p></div></div>    
</body>
</html>