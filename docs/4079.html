<html>
<head>
<title>Angular — Introduction to new HTTP Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular —新HTTP模块简介</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/angular-2-introduction-to-new-http-module-1278499db2a0?source=collection_archive---------0-----------------------#2015-11-08">https://medium.com/google-developer-experts/angular-2-introduction-to-new-http-module-1278499db2a0?source=collection_archive---------0-----------------------#2015-11-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="a151" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用反应式编程和可观察值的新数据架构</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/da5d07559a5f27e4c9473964017ddee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p0zsNZMfSIrR3_VGkA-q6g.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx"><a class="ae js" href="http://paperjs.org/" rel="noopener ugc nofollow" target="_blank">Paper.js</a> spiral rasterisation plus effects by <a class="ae js" href="https://ello.co/gsans" rel="noopener ugc nofollow" target="_blank">gsans</a></figcaption></figure><p id="e892" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jt translated">ngular引入了许多创新:性能改进、组件路由器、锐化依赖注入(DI)、延迟加载、异步模板、服务器渲染(又名Angular Universal)、编排动画、使用原生脚本的移动开发；所有这些都配备了可靠的工具(多亏了TypeScript和新的Angular CLI)和出色的测试支持。</p><p id="99f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本帖中，我们将关注新的Angular <strong class="ig hi"> HTTP模块</strong>。我们将研究:</p><ul class=""><li id="9f9d" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated">使用RxJS 5的新角度数据架构</li><li id="4e37" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">设置角度/http</li><li id="1dd5" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">创建简单的Http服务(使用http.get)</li><li id="0f3d" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">基本身份验证场景(使用http.post)</li><li id="184d" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">$http和angular/http的区别</li></ul><p id="8a86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Angular使用<strong class="ig hi">反应式编程</strong>作为其核心构建模块。这是基于异步数据流，又名<strong class="ig hi">可观测数据</strong>。</p><p id="df69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://embed.plnkr.co/r1QFQj0wZ5hgJxrsRoGF/" rel="noopener ugc nofollow" target="_blank">演示</a> | <a class="ae js" href="https://plnkr.co/edit/r1QFQj0wZ5hgJxrsRoGF?p=preview" rel="noopener ugc nofollow" target="_blank">来源</a></p><p id="0e00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<a class="ae js" href="https://twitter.com/intent/user?screen_name=gerardsans" rel="noopener ugc nofollow" target="_blank"> @gerardsans </a>找到我的最新观点。</p><h1 id="8b83" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">使用RxJS 5的新角度数据架构</h1><p id="663e" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">JavaScript的反应式扩展(RxJS)是一个反应式流库，它允许您处理可观察对象。RxJS结合了<strong class="ig hi">观察值</strong>、<strong class="ig hi">操作符</strong>和<strong class="ig hi">调度器</strong>，因此我们可以订阅流并使用可组合操作对变化做出反应。</p><p id="a0de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">棱角团队决定用<a class="ae js" href="https://github.com/ReactiveX/RxJS" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="lt">RxJS 5</em></strong></a>代替<a class="ae js" href="https://github.com/Reactive-Extensions/RxJS" rel="noopener ugc nofollow" target="_blank"> <em class="lt"> RxJS 4 </em> </a>。这是一次重写，重点是提高性能和降低API复杂性，以便于采用。不言而喻，Angular发布时，第5版将取代第4版。</p><blockquote class="lu"><p id="9517" class="lv lw hh bd lx ly lz ma mb mc md jb dx translated"><em class="me">🐒</em>角度用途<a class="ae js" href="https://github.com/ReactiveX/RxJS" rel="noopener ugc nofollow" target="_blank"> RxJS 5 </a>。在研究特定的操作符和文档时要考虑到这一点。</p></blockquote><h2 id="98ec" class="mf kr hh bd ks mg mh mi kw mj mk ml la ip mm mn le it mo mp li ix mq mr lm ms bi translated">以打字打的文件</h2><p id="259f" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">在这篇文章中，我们将使用TypeScript。这是ES6的超集。阅读<a class="ae js" rel="noopener" href="/sons-of-javascript/javascript-an-introduction-to-es6-1819d0d89a0f">ES6简介</a>以熟悉ES6的常见功能。</p><p id="1a08" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将使用<a class="ae js" href="http://www.typescriptlang.org/Handbook#basic-types" rel="noopener ugc nofollow" target="_blank">基本类型</a>、<a class="ae js" href="http://www.typescriptlang.org/Handbook#functions-optional-and-default-parameters" rel="noopener ugc nofollow" target="_blank">可选参数</a>、<a class="ae js" href="http://www.typescriptlang.org/Handbook#interfaces" rel="noopener ugc nofollow" target="_blank">接口</a>和<a class="ae js" href="http://www.typescriptlang.org/Handbook#generics" rel="noopener ugc nofollow" target="_blank">泛型</a>。点击链接，了解有关这些功能的更多信息。</p><h1 id="84d8" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">设置角度/http</h1><p id="2620" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">为了在我们的组件中使用新的Http模块，我们必须导入<strong class="ig hi"> Http </strong> <em class="lt"> </em>(参见<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank"> ES6导入</a>)。之后，我们可以在构造函数中通过依赖注入来注入它。下面找个例子。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="c861" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了使用<strong class="ig hi"> Http </strong>对我们的组件进行更改之外，我们还需要在引导过程中包含<strong class="ig hi"> HttpModule </strong>。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="1d12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的应用程序中，我们使用一个数组(第8行)为属性<strong class="ig hi"> <em class="lt">导入<a class="ae js" href="https://angular.io/docs/ts/latest/guide/ngmodule.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> ngModule </strong> </a>中的</em> </strong>在引导期间使<strong class="ig hi"> HttpModule </strong>可用。注意我们是从:angular/http ( <em class="lt"> line 4 </em>)导入的。对于Angular，Http不再包含在核心中，而是作为一个单独的文件。</p><h1 id="aa22" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">创建简单的Http服务</h1><p id="e8fa" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">让我们创建一个简单的例子，使用一个从JSON文件中读取一些数据的服务。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h2 id="9def" class="mf kr hh bd ks mg mv mi kw mj mw ml la ip mx mn le it my mp li ix mz mr lm ms bi translated">新依赖注入</h2><p id="e222" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">为了使我们的服务对DI可用，我们添加了<a class="ae js" href="https://angular.io/docs/ts/latest/api/core/InjectableMetadata-class.html" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="lt">@可注射</em> </strong> </a>注释(第5行)。这指示依赖注入器，该类具有在创建该类的实例时应该注入到构造函数中的依赖项。</p><blockquote class="na nb nc"><p id="0d18" class="ie if lt ig b ih ii ij ik il im in io nd iq ir is ne iu iv iw nf iy iz ja jb ha bi translated">注释允许我们声明性地将元数据添加到类和属性中，供Angular使用。常见的注释有:@Component、@ Injectable、@Pipe或@NgModule。</p></blockquote><p id="1e63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用一个类定义了一个简单的服务(第6行)。我们还在它前面加上了<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> <em class="lt">导出</em> </strong> </a>，以便其他组件可以访问它。在下面找到用于将http注入到构造函数的Http参数中的语法。</p><pre class="jd je jf jg fd ng nh ni nj aw nk bi"><span id="6bfa" class="mf kr hh nh b fi nl nm l nn no">import {<strong class="nh hi">Http</strong>} from ‘@angular/http’;</span><span id="1653" class="mf kr hh nh b fi np nm l nn no">constructor(private http:<strong class="nh hi">Http</strong>){ ... }</span></pre><h2 id="44e8" class="mf kr hh bd ks mg mv mi kw mj mw ml la ip mx mn le it my mp li ix mz mr lm ms bi translated">Http GET</h2><p id="acf3" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">在构造函数上我们设置了一个公共属性<strong class="ig hi"> <em class="lt"> this.http </em> </strong>并调用<em class="lt"/><a class="ae js" href="https://github.com/angular/angular/blob/8daa9b202d4643e3cd032604b0ae6bb46ea5aaf9/modules/angular2/src/http/http.ts#L118" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="lt">http . get</em></strong></a>。我们来看看它的定义。</p><pre class="jd je jf jg fd ng nh ni nj aw nk bi"><span id="470f" class="mf kr hh nh b fi nl nm l nn no">http.get(url: string, options?: <a class="ae js" href="https://github.com/angular/angular/blob/b0009f03d510370d9782cf76197f95bb40d16c6a/modules/angular2/src/http/interfaces.ts#L29" rel="noopener ugc nofollow" target="_blank">RequestOptionsArgs</a>)<br/>  : Observable&lt;<a class="ae js" href="https://github.com/angular/angular/blob/e1d7bdcfe7f25156c8a462452db5367b68a02df6/modules/angular2/src/http/static_response.ts#L26" rel="noopener ugc nofollow" target="_blank">Response</a>&gt;</span><span id="b88c" class="mf kr hh nh b fi np nm l nn no">interface RequestOptionsArgs {  <br/>  url?: string;  <br/>  method?: string | <a class="ae js" href="https://github.com/angular/angular/blob/b0009f03d510370d9782cf76197f95bb40d16c6a/modules/angular2/src/http/enums.ts#L6" rel="noopener ugc nofollow" target="_blank">RequestMethods</a>;  <br/>  search?: string | <a class="ae js" href="https://github.com/angular/angular/blob/b0009f03d510370d9782cf76197f95bb40d16c6a/modules/angular2/src/http/url_search_params.ts#L28" rel="noopener ugc nofollow" target="_blank">URLSearchParams</a>;  <br/>  headers?: <a class="ae js" href="https://github.com/angular/angular/blob/e1d7bdcfe7f25156c8a462452db5367b68a02df6/modules/angular2/src/http/headers.ts#L37" rel="noopener ugc nofollow" target="_blank">Headers</a>; <br/>  body?: string;<br/>}</span></pre><p id="c058" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的<a class="ae js" href="https://github.com/angular/angular/blob/8daa9b202d4643e3cd032604b0ae6bb46ea5aaf9/modules/angular2/src/http/http.ts#L118" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="lt">http . get</em></strong></a>签名是用打字稿写的，内容如下。我们需要提供一个url和一个可选的选项对象，在冒号之后我们找到相应的类型。</p><blockquote class="na nb nc"><p id="f26e" class="ie if lt ig b ih ii ij ik il im in io nd iq ir is ne iu iv iw nf iy iz ja jb ha bi translated">ide可以使用类型信息来提供类似于Visual Studio中的IntelliSense和类型检查的功能。</p></blockquote><p id="a77e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当提供一个<strong class="ig hi"> <em class="lt">选项</em> </strong>对象时，它将遵循<a class="ae js" href="https://github.com/angular/angular/blob/b0009f03d510370d9782cf76197f95bb40d16c6a/modules/angular2/src/http/interfaces.ts#L29" rel="noopener ugc nofollow" target="_blank"> RequestOptionsArgs </a>接口。在我们的例子中，我们没有使用选项参数。最后最后一位表明<a class="ae js" href="https://github.com/angular/angular/blob/8daa9b202d4643e3cd032604b0ae6bb46ea5aaf9/modules/angular2/src/http/http.ts#L118" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="lt">http . get</em></strong></a>返回一个<strong class="ig hi"> <em class="lt">可观察</em> </strong>发射<a class="ae js" href="https://github.com/angular/angular/blob/e1d7bdcfe7f25156c8a462452db5367b68a02df6/modules/angular2/src/http/static_response.ts#L26" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> <em class="lt">响应</em> </strong> </a>的对象。</p><p id="6cae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你会注意到的第一件事不是返回一个承诺<a class="ae js" href="https://github.com/angular/angular/blob/8daa9b202d4643e3cd032604b0ae6bb46ea5aaf9/modules/angular2/src/http/http.ts#L118" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> <em class="lt">而是返回一个<strong class="ig hi"> <em class="lt">可观察的</em> </strong> <em class="lt">。</em>最后我们使用<strong class="ig hi"><em class="lt">map</em></strong><em class="lt"/>将结果解析成一个JSON对象。这段代码使用了一个<a class="ae js" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头函数</a>(在ES6中)或者胖箭头(在TypeScript中也称为lambda语法)。让我们看看它如何翻译成ES5(第8行):</em></strong></a></p><pre class="jd je jf jg fd ng nh ni nj aw nk bi"><span id="0fba" class="mf kr hh nh b fi nl nm l nn no">// TypeScript/ES6<br/>.map(response =&gt; response.json())</span><span id="5e81" class="mf kr hh nh b fi np nm l nn no">// ES5<br/>.map(function(response){ return response.json(); })</span></pre><p id="17cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://github.com/ReactiveX/RxJS/blob/40e9757d751b4328d6f79d8c6ea33adb299d7466/src/operators/map.ts#L17" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> <em class="lt"> map </em> </strong> </a>的结果也是一个<strong class="ig hi"> <em class="lt"> Observable </em> </strong>发出一个包含一个人数组的JSON对象。</p><h2 id="380e" class="mf kr hh bd ks mg mv mi kw mj mw ml la ip mx mn le it my mp li ix mz mr lm ms bi translated">使用返回可观察对象的服务</h2><p id="0894" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">让我们看看如何使用我们刚刚创建的新的<strong class="ig hi"><em class="lt">PeopleService</em></strong>来显示人员列表。参见下面代码的简化版本:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mt mu l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mt mu l"/></div></figure><p id="e6ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们导入了<strong class="ig hi"><em class="lt">PeopleService</em></strong>(第1行)。接下来，在构造函数中，我们使用之前看到的相同语法注入服务(第8行)。</p><p id="7cde" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<em class="lt"> App </em>实例化期间，<strong class="ig hi"><em class="lt">peopleservice . get people()</em></strong><em class="lt"/>将返回一个可观察值。我们想要显示一个人员列表，这样我们就可以在数据发出时使用<a class="ae js" href="https://github.com/ReactiveX/RxJS/blob/40e9757d751b4328d6f79d8c6ea33adb299d7466/src/Subscriber.ts#L9" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="lt">subscribe</em></strong></a>来设置我们的本地<strong class="ig hi"> <em class="lt"> people </em> </strong>变量。在这种情况下，我们只需将结果数组设置到<em class="lt"> this.people </em>中。</p><p id="c29b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用这个<a class="ae js" href="https://plnkr.co/edit/r1QFQj0wZ5hgJxrsRoGF?p=preview" rel="noopener ugc nofollow" target="_blank">探测器</a>探索上面的例子。</p><h1 id="31f5" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">基本身份验证场景</h1><p id="5fb8" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">让我们看看如何使用Angular实现一个常见的身份验证场景。我们将使用一个来自<a class="ae js" href="https://auth0.com/blog/2015/10/15/angular-2-series-part-3-using-http" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>的简化示例，并查看下面的代码。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="mt mu l"/></div></figure><h2 id="db43" class="mf kr hh bd ks mg mv mi kw mj mw ml la ip mx mn le it my mp li ix mz mr lm ms bi translated">Http帖子</h2><p id="80fd" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">假设我们从用户提交的表单中收到了<em class="lt">用户名</em>和<em class="lt">密码</em>。我们将调用<strong class="ig hi"> <em class="lt">验证</em> </strong>登录用户。用户登录后，我们将继续存储令牌，以便在后续请求中包含它。</p><pre class="jd je jf jg fd ng nh ni nj aw nk bi"><span id="b5fe" class="mf kr hh nh b fi nl nm l nn no">http.post(url: string, body: string, options?: <a class="ae js" href="https://github.com/angular/angular/blob/b0009f03d510370d9782cf76197f95bb40d16c6a/modules/angular2/src/http/interfaces.ts#L29" rel="noopener ugc nofollow" target="_blank">RequestOptionsArgs</a>)<br/>  : Observable&lt;<a class="ae js" href="https://github.com/angular/angular/blob/e1d7bdcfe7f25156c8a462452db5367b68a02df6/modules/angular2/src/http/static_response.ts#L26" rel="noopener ugc nofollow" target="_blank">Response</a>&gt;</span></pre><p id="f20d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的<a class="ae js" href="https://github.com/angular/angular/blob/8daa9b202d4643e3cd032604b0ae6bb46ea5aaf9/modules/angular2/src/http/http.ts#L126" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="lt">http . post</em></strong></a>签名如下。我们需要提供一个url和一个主体，都是字符串，然后可选地提供一个选项对象。在我们的例子中，我们传递修改后的<em class="lt"> headers </em>属性。<a class="ae js" href="https://github.com/angular/angular/blob/8daa9b202d4643e3cd032604b0ae6bb46ea5aaf9/modules/angular2/src/http/http.ts#L126" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="lt">http . post</em></strong></a>返回一个<strong class="ig hi"> <em class="lt">可观察的</em> </strong>，我们使用<a class="ae js" href="https://github.com/ReactiveX/RxJS/blob/40e9757d751b4328d6f79d8c6ea33adb299d7466/src/operators/map.ts#L17" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="lt">map</em></strong></a>从响应中提取JSON对象和<a class="ae js" href="https://github.com/ReactiveX/RxJS/blob/40e9757d751b4328d6f79d8c6ea33adb299d7466/src/Subscriber.ts#L9" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="lt">subscribe</em></strong></a>。这将在我们的流发出结果后立即设置它。最后我们用相应的用户令牌调用<strong class="ig hi"><em class="lt">this . store token</em></strong>。</p><blockquote class="na nb nc"><p id="bd33" class="ie if lt ig b ih ii ij ik il im in io nd iq ir is ne iu iv iw nf iy iz ja jb ha bi translated">注意，我们以明文形式传递密码。在真实的场景中，我们会应用更严格的选项并使用https。</p></blockquote><h1 id="4f61" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">$http和angular/http的区别</h1><p id="28f7" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">Angular Http默认返回一个<strong class="ig hi"> <em class="lt">可观察的</em> </strong>与一个<strong class="ig hi"> <em class="lt">承诺</em> </strong> ( <a class="ae js" href="https://github.com/angular/angular.js/blob/898a3fd3b916602b725a60a5347ee9e01febe628/src/ng/q.js#L219" rel="noopener ugc nofollow" target="_blank"> $q模块</a>)在$http中相对。这允许我们使用更加灵活和强大的RxJS操作符，如<a class="ae js" href="https://github.com/ReactiveX/RxJS/blob/e1966574715bc526c4c0da9262699187d1a7fbcb/src/operators/switchMap.ts" rel="noopener ugc nofollow" target="_blank"> switchMap </a>(版本4中的最新flatMapLatest】、重试、<a class="ae js" href="https://github.com/ReactiveX/RxJS/blob/e1966574715bc526c4c0da9262699187d1a7fbcb/src/operators/buffer.ts" rel="noopener ugc nofollow" target="_blank">缓冲</a>、<a class="ae js" href="https://github.com/ReactiveX/RxJS/blob/dea7847c43061ccffc19d5fdd150240c76c9d50b/src/operators/debounce.ts" rel="noopener ugc nofollow" target="_blank">去抖</a>、<a class="ae js" href="https://github.com/ReactiveX/RxJS/blob/e1966574715bc526c4c0da9262699187d1a7fbcb/src/operators/merge.ts" rel="noopener ugc nofollow" target="_blank">合并</a>或<a class="ae js" href="https://github.com/ReactiveX/RxJS/blob/e1966574715bc526c4c0da9262699187d1a7fbcb/src/operators/zip.ts" rel="noopener ugc nofollow" target="_blank">压缩</a>。</p><p id="cbc6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过使用<strong class="ig hi"> <em class="lt"> Observables </em> </strong>，我们提高了应用程序的可读性和可维护性，因为它们可以优雅地响应更复杂的场景，包括多个发出的值，而不是只有一个一次性的单个值。</p><h2 id="8e37" class="mf kr hh bd ks mg mv mi kw mj mw ml la ip mx mn le it my mp li ix mz mr lm ms bi translated">可观察到的与承诺</h2><p id="2528" class="pw-post-body-paragraph ie if hh ig b ih lo ij ik il lp in io ip lq ir is it lr iv iw ix ls iz ja jb ha bi translated">当与<strong class="ig hi"> Http </strong>一起使用时，两种实现都提供了处理请求的简单API，但是有一些关键的区别使得<strong class="ig hi"> Observables </strong>成为更好的选择:</p><ul class=""><li id="c146" class="kc kd hh ig b ih ii il im ip ke it kf ix kg jb kh ki kj kk bi translated">除非我们组合多个承诺，否则承诺只接受一个值(例如:<a class="ae js" href="https://github.com/angular/angular.js/blob/898a3fd3b916602b725a60a5347ee9e01febe628/src/ng/q.js#L540" rel="noopener ugc nofollow" target="_blank"> $q.all </a>)。</li><li id="7111" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">承诺是不能取消的。</li></ul><p id="6c80" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那都是乡亲们！希望这篇文章能给你一些启发。感谢阅读！有什么问题吗？在推特上给我发短信<a class="ae js" href="https://twitter.com/intent/user?screen_name=gerardsans" rel="noopener ugc nofollow" target="_blank"> @gerardsans </a></p><div class="nq nr ez fb ns nt"><a href="http://www.meetup.com/AngularZone/" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab dw"><div class="nv ab nw cl cj nx"><h2 class="bd hi fi z dy ny ea eb nz ed ef hg bi translated">安古拉宗社区</h2><div class="oa l"><h3 class="bd b fi z dy ny ea eb nz ed ef dx translated">欢迎来到我们的社区。我们的激情是有棱角的。加入我们吧！🚀</h3></div></div><div class="ob l"><div class="oc l od oe of ob og jm nt"/></div></div></a></div><h1 id="e3f1" class="kq kr hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">更多资源</h1><ul class=""><li id="1e93" class="kc kd hh ig b ih lo il lp ip oh it oi ix oj jb kh ki kj kk bi translated"><a class="ae js" href="http://blog.thoughtram.io/angular/2015/09/17/resolve-service-dependencies-in-angular-2.html" rel="noopener ugc nofollow" target="_blank">以角度</a>将服务注入服务，作者帕斯卡尔·普雷奇<a class="ae js" href="https://twitter.com/PascalPrecht" rel="noopener ugc nofollow" target="_blank">@帕斯卡尔·普雷奇</a></li><li id="4cdc" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated">由杰夫·克罗斯<a class="ae js" href="https://twitter.com/jeffbcross" rel="noopener ugc nofollow" target="_blank">@杰夫·克罗斯</a>、罗布·沃玛德<a class="ae js" href="https://twitter.com/robwormald" rel="noopener ugc nofollow" target="_blank">@罗布·沃玛德</a>和亚历克斯·里卡鲍<a class="ae js" href="http://twitter.com/@synalx" rel="noopener ugc nofollow" target="_blank"> @synalx </a>所作的《Angular connect talk》<a class="ae js" href="https://www.youtube.com/watch?v=bVI5gGTEQ_U" rel="noopener ugc nofollow" target="_blank">角度数据流</a></li><li id="5c1a" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><a class="ae js" href="http://chariotsolutions.com/blog/post/angular2-observables-http-separating-services-components/" rel="noopener ugc nofollow" target="_blank">角度可观测量，Http和分离服务和组件</a>，作者Ken Rimple <a class="ae js" href="https://twitter.com/krimple" rel="noopener ugc nofollow" target="_blank"> @krimple </a></li><li id="aef1" class="kc kd hh ig b ih kl il km ip kn it ko ix kp jb kh ki kj kk bi translated"><a class="ae js" rel="noopener" href="/google-developer-experts/angular-introduction-to-reactive-extensions-rxjs-a86a7430a61f#.g3ggrh21b">反应式扩展简介</a>，上一篇文章</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><a href="https://twitter.com/intent/user?screen_name=gerardsans"><div class="er es ok"><img src="../Images/abefda0aa7864742686ec7f7fdffe2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1tQhWBuVOdzR7OAGvyd8Q.png"/></div></a></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ol"><img src="../Images/6b7d888dcaf096cfd65eddc5e39ef3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a8gaubq_9t5VgMUAzNanHg.png"/></div></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es om"><img src="../Images/67b37e5d672384f0953563450fca0029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uNeEFxYiwJq8RfiDCsI-Xg.gif"/></div></div></figure></div></div>    
</body>
</html>