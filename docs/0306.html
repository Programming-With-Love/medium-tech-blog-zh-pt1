<html>
<head>
<title>ViewModels and LiveData: Patterns + AntiPatterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">视图模型和活动数据:模式+反模式</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/viewmodels-and-livedata-patterns-antipatterns-21efaef74a54?source=collection_archive---------0-----------------------#2017-09-12">https://medium.com/androiddevelopers/viewmodels-and-livedata-patterns-antipatterns-21efaef74a54?source=collection_archive---------0-----------------------#2017-09-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="b645" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">视图和视图模型</h1><h2 id="b9d0" class="jc if hh bd ig jd je jf ik jg jh ji io jj jk jl is jm jn jo iw jp jq jr ja js bi translated">分配责任</h2><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/953ac772515e448f91994aecd903f1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9WPcnpGNuI4CjxxrkP0-g.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx"><em class="kj">Typical interaction of entities in an app built with Architecture Components</em></figcaption></figure><p id="7480" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">理想情况下，视图模型不应该知道任何关于Android的事情。这提高了可测试性、泄漏安全性和模块化。一般的经验法则是确保在你的视图模型中没有<code class="du lf lg lh li b">android.*</code>导入(除了像<code class="du lf lg lh li b"> android.arch.*</code>这样的例外)。这同样适用于演讲者。</p><blockquote class="lj lk ll"><p id="d15b" class="kk kl lm km b kn ko kp kq kr ks kt ku ln kv kw kx lo ky kz la lp lb lc ld le ha bi translated">❌不让视图模型(和演示者)知道Android框架类</p></blockquote><p id="9a41" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">条件语句、循环和一般决策应该在视图模型或应用程序的其他层中完成，而不是在活动或片段中。这个视图通常没有经过单元测试(除非你使用<a class="ae lq" href="http://robolectric.org/" rel="noopener ugc nofollow" target="_blank"> Robolectric </a>)，所以代码行越少越好。视图应该只知道如何显示数据并将用户事件发送给视图模型(或演示者)。这就是所谓的<a class="ae lq" href="https://martinfowler.com/eaaDev/PassiveScreen.html" rel="noopener ugc nofollow" target="_blank"> <em class="lm">被动</em> <em class="lm">视野</em> </a>格局。</p><blockquote class="lj lk ll"><p id="c5b4" class="kk kl lm km b kn ko kp kq kr ks kt ku ln kv kw kx lo ky kz la lp lb lc ld le ha bi translated">✅把活动和片断中的逻辑保持到最低限度</p></blockquote><h2 id="e073" class="jc if hh bd ig jd je jf ik jg jh ji io jj jk jl is jm jn jo iw jp jq jr ja js bi translated">在视图模型中查看引用</h2><p id="7334" class="pw-post-body-paragraph kk kl hh km b kn lr kp kq kr ls kt ku jj lt kw kx jm lu kz la jp lv lc ld le ha bi translated"><a class="ae lq" href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" rel="noopener ugc nofollow" target="_blank">视图模型</a>的作用域不同于活动或片段。当一个视图模型正在运行时，一个活动可以处于它的任何一个生命周期状态。活动和片段可以在ViewModel不知情的情况下被销毁和重新创建。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lw"><img src="../Images/fc187adbd368a254ffcf11e87f7aa4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86RjXnTJucJMkW4Xi4kUlA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">ViewModels persist configuration changes</figcaption></figure><p id="7cef" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">将视图(活动或片段)的引用传递给视图模型是一个<strong class="km hi">严重的风险</strong>。让我们假设ViewModel从网络请求数据，数据在一段时间后返回。此时，视图引用可能被破坏，或者可能是一个不再可见的旧活动，从而产生内存泄漏，并可能导致崩溃。</p><blockquote class="lj lk ll"><p id="9e5b" class="kk kl lm km b kn ko kp kq kr ks kt ku ln kv kw kx lo ky kz la lp lb lc ld le ha bi translated">❌避免在视图模型中引用视图。</p></blockquote><p id="553c" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">在视图模型和视图之间进行通信的推荐方式是observer模式，使用LiveData或其他库中的observables。</p><h2 id="8c18" class="jc if hh bd ig jd je jf ik jg jh ji io jj jk jl is jm jn jo iw jp jq jr ja js bi translated">观察者模式</h2><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lx"><img src="../Images/0dda6a1a544f035f3c67984285cf6397.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*hjvCDY_2W4PpK7HQoHsS2Q.png"/></div></figure><p id="4bef" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">在Android中设计表示层的一个非常方便的方法是让视图(活动或片段)观察视图模型(<em class="lm">订阅</em>中的变化)。由于ViewModel不了解Android，所以不知道Android是怎么喜欢频繁杀视图的。这有一些优点:</p><ol class=""><li id="78ed" class="ly lz hh km b kn ko kr ks jj ma jm mb jp mc le md me mf mg bi translated">视图模型在配置更改时保持不变，因此在轮换发生时，不需要重新查询外部数据源(如数据库或网络)。</li><li id="2710" class="ly lz hh km b kn mh kr mi jj mj jm mk jp ml le md me mf mg bi translated">当长时间运行的操作完成时，ViewModel中的可观察对象被更新。数据是否被观察并不重要。尝试更新不存在的视图时，不会发生空指针异常。</li><li id="12dc" class="ly lz hh km b kn mh kr mi jj mj jm mk jp ml le md me mf mg bi translated">视图模型不引用视图，所以内存泄漏的风险较小。</li></ol><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mm mn l"/></div><figcaption class="kf kg et er es kh ki bd b be z dx">Typical subscription from an activity or fragment.</figcaption></figure><blockquote class="lj lk ll"><p id="ebd8" class="kk kl lm km b kn ko kp kq kr ks kt ku ln kv kw kx lo ky kz la lp lb lc ld le ha bi translated">✅不是把数据推给用户界面，而是让用户界面观察数据的变化。</p></blockquote><h1 id="238d" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">胖视图模型</h1><p id="5be9" class="pw-post-body-paragraph kk kl hh km b kn lr kp kq kr ls kt ku jj lt kw kx jm lu kz la jp lv lc ld le ha bi translated">无论什么能让你分开关注都是一个好主意。如果您的视图模型包含太多代码或者有太多职责，请考虑:</p><ul class=""><li id="9788" class="ly lz hh km b kn ko kr ks jj ma jm mb jp mc le mo me mf mg bi translated">将一些逻辑转移到演示者，其范围与ViewModel相同。它将与应用程序的其他部分进行通信，并更新ViewModel中的LiveData容器。</li><li id="1435" class="ly lz hh km b kn mh kr mi jj mj jm mk jp ml le mo me mf mg bi translated">增加一个域层，采用<a class="ae lq" href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">清洁架构</a>。这导致了一个非常可测试和可维护的架构。这也有助于快速脱离主线程。在<a class="ae lq" href="https://github.com/googlesamples/android-architecture" rel="noopener ugc nofollow" target="_blank">建筑蓝图</a>中有一个干净的建筑样本。</li></ul><blockquote class="lj lk ll"><p id="688c" class="kk kl lm km b kn ko kp kq kr ks kt ku ln kv kw kx lo ky kz la lp lb lc ld le ha bi translated">✅分配职责，如果需要，添加一个域层。</p></blockquote><h1 id="731b" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">使用数据存储库</h1><p id="da2c" class="pw-post-body-paragraph kk kl hh km b kn lr kp kq kr ls kt ku jj lt kw kx jm lu kz la jp lv lc ld le ha bi translated">如<a class="ae lq" href="https://developer.android.com/topic/libraries/architecture/guide.html" rel="noopener ugc nofollow" target="_blank">应用架构指南</a>所示，大多数应用都有多个数据源，例如:</p><ol class=""><li id="1758" class="ly lz hh km b kn ko kr ks jj ma jm mb jp mc le md me mf mg bi translated">远程:网络还是云</li><li id="fc3d" class="ly lz hh km b kn mh kr mi jj mj jm mk jp ml le md me mf mg bi translated">本地:数据库或文件</li><li id="bf16" class="ly lz hh km b kn mh kr mi jj mj jm mk jp ml le md me mf mg bi translated">内存缓存</li></ol><p id="43ae" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">在你的应用程序中有一个数据层是一个好主意，完全不知道你的表示层。保持缓存和数据库与网络同步的算法并不简单。建议使用一个单独的存储库类作为处理这种复杂性的单一入口点。</p><p id="9768" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">如果您有多个非常不同的数据模型，请考虑添加多个存储库。</p><blockquote class="lj lk ll"><p id="10e9" class="kk kl lm km b kn ko kp kq kr ks kt ku ln kv kw kx lo ky kz la lp lb lc ld le ha bi translated">✅添加一个数据存储库作为您的数据的单点入口</p></blockquote><h1 id="73ac" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">处理数据状态</h1><p id="94b2" class="pw-post-body-paragraph kk kl hh km b kn lr kp kq kr ls kt ku jj lt kw kx jm lu kz la jp lv lc ld le ha bi translated">考虑这个场景:您正在观察一个由ViewModel公开的LiveData，它包含一个要显示的项目列表。视图如何区分正在加载的数据、网络错误和空列表？</p><ul class=""><li id="7ec2" class="ly lz hh km b kn ko kr ks jj ma jm mb jp mc le mo me mf mg bi translated">您可以从视图模型中公开一个<code class="du lf lg lh li b">LiveData&lt;MyDataState&gt;</code>。例如，<code class="du lf lg lh li b">MyDataState</code>可以包含关于数据当前正在加载、已经成功加载还是失败加载的信息。</li></ul><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es mp"><img src="../Images/63a08317726969c9e1cdf88643aa75d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*Hj8ChdU7pakjcM3kxj_Fzg.png"/></div></figure><p id="a196" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">您可以将数据包装在具有状态和其他元数据(如错误消息)的类中。请参见我们示例中的<a class="ae lq" href="https://developer.android.com/topic/libraries/architecture/guide.html#addendum" rel="noopener ugc nofollow" target="_blank">资源</a>类。</p><blockquote class="lj lk ll"><p id="6ce7" class="kk kl lm km b kn ko kp kq kr ks kt ku ln kv kw kx lo ky kz la lp lb lc ld le ha bi translated">✅使用包装器或其他LiveData公开关于数据状态的信息。</p></blockquote><h1 id="38a6" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">保存活动状态</h1><p id="27f0" class="pw-post-body-paragraph kk kl hh km b kn lr kp kq kr ls kt ku jj lt kw kx jm lu kz la jp lv lc ld le ha bi translated">活动状态是在活动消失时重新创建屏幕所需的信息，这意味着活动被销毁或进程被终止。旋转是最明显的例子，我们已经用视图模型覆盖了它。如果状态保存在视图模型中，它就是安全的。</p><p id="54ed" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">然而，在视图模型也消失的其他场景中，您可能需要恢复状态:例如，当操作系统资源不足并终止您的进程时。</p><p id="2d11" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">为了有效地保存和恢复UI状态，请结合使用persistence、<code class="du lf lg lh li b">onSaveInstanceState()</code>和ViewModels。</p><p id="42eb" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">例如，请参见:<a class="ae lq" rel="noopener" href="/google-developers/viewmodels-persistence-onsaveinstancestate-restoring-ui-state-and-loaders-fc7cc4a6c090">视图模型:持久性，onSaveInstanceState()，恢复UI状态和加载器</a></p><h1 id="e0b9" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">事件</h1><p id="53f0" class="pw-post-body-paragraph kk kl hh km b kn lr kp kq kr ls kt ku jj lt kw kx jm lu kz la jp lv lc ld le ha bi translated">事件是只发生一次的事情。视图模型公开了数据，但是事件呢？例如，导航事件或显示Snackbar消息是只应执行一次的操作。</p><p id="2768" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">事件的概念并不完全符合LiveData存储和恢复数据的方式。考虑具有以下字段的视图模型:</p><pre class="ju jv jw jx fd mq li mr ms aw mt bi"><span id="3bb5" class="jc if hh li b fi mu mv l mw mx">LiveData&lt;String&gt; snackbarMessage = new MutableLiveData&lt;&gt;();</span></pre><p id="77b3" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">一个活动开始对此进行观察，ViewModel完成一个操作，因此它需要更新消息:</p><pre class="ju jv jw jx fd mq li mr ms aw mt bi"><span id="3419" class="jc if hh li b fi mu mv l mw mx">snackbarMessage.setValue("Item saved!");</span></pre><p id="47e2" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">该活动接收该值并显示Snackbar。显然，这很有效。</p><p id="a95a" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">然而，如果用户旋转手机，新的活动被创建并开始观察。当LiveData观察开始时，活动立即接收旧值，这导致消息再次显示！</p><p id="04e0" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">与其试图用库或架构组件的扩展来解决这个问题，不如把它当作一个设计问题来面对。<strong class="km hi">我们建议您将您的活动视为您所在州的一部分</strong>。</p><blockquote class="lj lk ll"><p id="1977" class="kk kl lm km b kn ko kp kq kr ks kt ku ln kv kw kx lo ky kz la lp lb lc ld le ha bi translated">✅把活动设计成你所在州的一部分。欲了解更多详情，请阅读<a class="ae lq" rel="noopener" href="/google-developers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150"> LiveData with SnackBar，Navigation and other events(单个LiveEvent案例)</a>。</p></blockquote><h1 id="2119" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">泄漏视图模型</h1><p id="faf4" class="pw-post-body-paragraph kk kl hh km b kn lr kp kq kr ls kt ku jj lt kw kx jm lu kz la jp lv lc ld le ha bi translated">反应范式在Android中工作得很好，因为它允许UI和应用程序的其余层之间的方便连接。LiveData是这个结构的关键组件，所以通常您的活动和片段将观察LiveData实例。</p><p id="25f9" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">ViewModels如何与其他组件通信由您决定，但是要注意泄漏和边缘情况。考虑这个图表，其中表示层使用观察者模式，数据层使用回调:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es my"><img src="../Images/d3c9f7874a164ea6e5745e27af7e39f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0BaDp6eyWAEkUwmprKC9Rg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">Observer pattern in the UI and callbacks in the data layer</figcaption></figure><p id="cce8" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">如果用户退出应用程序，视图将消失，因此视图模型不再被观察到。如果储存库是单例的或者以其他方式作用于应用程序，<strong class="km hi">储存库不会被销毁，直到进程被终止</strong>。只有在系统需要资源或者用户手动杀死app的情况下才会出现这种情况。如果存储库持有对ViewModel中回调的引用，ViewModel将会暂时泄漏</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mz"><img src="../Images/6364a7a99b0f33d3d1258fa2c6b7c3ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYyXV-qPtgmAlbDjI640KA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx">The activity is finished but the ViewModel is still around</figcaption></figure><p id="ea80" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">如果ViewModel是轻量级的，或者操作可以保证快速完成，那么这种泄漏不是什么大问题。然而，情况并非总是如此。理想情况下，视图模型应该可以在没有任何视图观察它们的时候自由活动:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es na"><img src="../Images/cc0306923102d050d6094d5e243798d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1Zimc4SFMentSLsk6VCcQ.png"/></div></div></figure><p id="5921" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">要实现这一点，您有许多选择:</p><ul class=""><li id="6b22" class="ly lz hh km b kn ko kr ks jj ma jm mb jp mc le mo me mf mg bi translated">使用ViewModel.onCleared() 您可以告诉存储库放弃对ViewModel的回调。</li><li id="24bb" class="ly lz hh km b kn mh kr mi jj mj jm mk jp ml le mo me mf mg bi translated">在存储库中，你可以使用一个<strong class="km hi"> WeakReference </strong>或者你可以使用一个<strong class="km hi"> Event Bus </strong>(两者都容易被误用，甚至被认为是有害的)。</li><li id="4bb0" class="ly lz hh km b kn mh kr mi jj mj jm mk jp ml le mo me mf mg bi translated">使用LiveData在存储库和ViewModel之间进行通信，就像在视图和ViewModel之间使用LiveData一样。</li></ul><blockquote class="lj lk ll"><p id="7c18" class="kk kl lm km b kn ko kp kq kr ks kt ku ln kv kw kx lo ky kz la lp lb lc ld le ha bi translated">✅考虑边缘情况、泄漏以及长时间运行的操作如何影响你的架构中的实例。</p><p id="f76a" class="kk kl lm km b kn ko kp kq kr ks kt ku ln kv kw kx lo ky kz la lp lb lc ld le ha bi translated">❌不要在视图模型中放置对保存干净状态至关重要或与数据相关的逻辑。您从ViewModel发出的任何调用都可能是最后一个调用。</p></blockquote><h1 id="491b" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">存储库中的实时数据</h1><p id="a8c2" class="pw-post-body-paragraph kk kl hh km b kn lr kp kq kr ls kt ku jj lt kw kx jm lu kz la jp lv lc ld le ha bi translated">为了避免泄漏视图模型和<em class="lm">回调地狱</em>，可以这样观察存储库:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es nb"><img src="../Images/d5b43274dfcecb60d55045a447fae62a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ptw2Z3PyvOKCamvRHQsyCQ.png"/></div></div></figure><p id="494e" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">当视图模型被清除或视图的生命周期结束时，订阅也被清除:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es na"><img src="../Images/cc0306923102d050d6094d5e243798d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1Zimc4SFMentSLsk6VCcQ.png"/></div></div></figure><p id="c626" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">如果您尝试这种方法，会有一个问题:如果您不能访问LifecycleOwner，如何从ViewModel订阅存储库？使用<a class="ae lq" href="https://developer.android.com/topic/libraries/architecture/livedata#transform_livedata" rel="noopener ugc nofollow" target="_blank">转换</a>是解决这个问题的一个非常方便的方法。<code class="du lf lg lh li b">Transformations.switchMap</code>允许您创建新的LiveData，该LiveData对其他live data实例的更改做出反应。它还允许在整个链中传递观察者生命周期信息:</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mm mn l"/></div><figcaption class="kf kg et er es kh ki bd b be z dx">Transformations example [<a class="ae lq" href="https://github.com/googlesamples/android-architecture-components/blob/master/GithubBrowserSample/app/src/main/java/com/android/example/github/ui/repo/RepoViewModel.java" rel="noopener ugc nofollow" target="_blank"><em class="kj">source</em></a>]</figcaption></figure><p id="ddfa" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">在此示例中，当触发器获得更新时，将应用该函数，并向下游发送结果。一个活动将观察到<code class="du lf lg lh li b">repo</code>，同一个生命周期所有者将被用于<code class="du lf lg lh li b">repository.loadRepo(id)</code>调用。</p><blockquote class="lj lk ll"><p id="61a2" class="kk kl lm km b kn ko kp kq kr ks kt ku ln kv kw kx lo ky kz la lp lb lc ld le ha bi translated">✅每当你认为你需要一个<a class="ae lq" href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.html" rel="noopener ugc nofollow" target="_blank">生命周期</a>对象在<a class="ae lq" href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" rel="noopener ugc nofollow" target="_blank">视图模型</a>中，一个<a class="ae lq" href="https://developer.android.com/topic/libraries/architecture/livedata#transform_livedata" rel="noopener ugc nofollow" target="_blank">转换</a>可能就是解决方案。</p></blockquote><h1 id="b918" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">扩展LiveData</h1><p id="5581" class="pw-post-body-paragraph kk kl hh km b kn lr kp kq kr ls kt ku jj lt kw kx jm lu kz la jp lv lc ld le ha bi translated">LiveData最常见的用例是在视图模型中使用<code class="du lf lg lh li b">MutableLiveData</code>,并将它们公开为<code class="du lf lg lh li b">LiveData</code>,使它们对于观察者来说是不可变的。</p><p id="81f0" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">如果您需要更多功能，扩展LiveData将让您知道何时有活动的观察者。例如，当您想要开始收听位置或传感器服务时，这很有用。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h2 id="fb6a" class="jc if hh bd ig jd je jf ik jg jh ji io jj jk jl is jm jn jo iw jp jq jr ja js bi translated">何时不扩展LiveData</h2><p id="0fad" class="pw-post-body-paragraph kk kl hh km b kn lr kp kq kr ls kt ku jj lt kw kx jm lu kz la jp lv lc ld le ha bi translated">您也可以使用<code class="du lf lg lh li b">onActive()</code>来启动一些加载数据的服务，但是除非您有一个好的理由，否则您不需要等待LiveData被观察到。一些常见模式:</p><ul class=""><li id="f1e7" class="ly lz hh km b kn ko kr ks jj ma jm mb jp mc le mo me mf mg bi translated">向视图模型添加一个<code class="du lf lg lh li b">start()</code>方法，并尽快调用它【参见<a class="ae lq" href="https://github.com/googlesamples/android-architecture/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/addedittask/AddEditTaskFragment.java#L64" rel="noopener ugc nofollow" target="_blank">蓝图示例</a></li><li id="c111" class="ly lz hh km b kn mh kr mi jj mj jm mk jp ml le mo me mf mg bi translated">设置一个启动加载的属性[参见<a class="ae lq" href="https://github.com/googlesamples/android-architecture-components/blob/master/GithubBrowserSample/app/src/main/java/com/android/example/github/ui/repo/RepoFragment.kt" rel="noopener ugc nofollow" target="_blank"> GithubBrowserExample </a> ]。</li></ul><blockquote class="lj lk ll"><p id="12fb" class="kk kl lm km b kn ko kp kq kr ks kt ku ln kv kw kx lo ky kz la lp lb lc ld le ha bi translated">❌:你通常不会扩展LiveData。让您的活动或片段告诉ViewModel什么时候开始加载数据。</p></blockquote></div><div class="ab cl nc nd go ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ha hb hc hd he"><p id="94de" class="pw-post-body-paragraph kk kl hh km b kn ko kp kq kr ks kt ku jj kv kw kx jm ky kz la jp lb lc ld le ha bi translated">您是否需要关于架构组件的任何其他主题的指导(或意见)?请在评论中告诉我们。</p></div></div>    
</body>
</html>