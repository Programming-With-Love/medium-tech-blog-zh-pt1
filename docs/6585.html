<html>
<head>
<title>Learning Solidity with a Simple Fundraising Smart Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用一个简单的筹款智能合同学习可靠性</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/learning-solidity-with-a-simple-fundraising-smart-contract-2fad8b1d8b73?source=collection_archive---------2-----------------------#2019-02-21">https://medium.com/quick-code/learning-solidity-with-a-simple-fundraising-smart-contract-2fad8b1d8b73?source=collection_archive---------2-----------------------#2019-02-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="bbc4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">偶尔，我们会遇到不仅对创作者有益，而且对社区有益的产品。</p><p id="3b33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Kickstarter就是这样一个产品。你可能知道这个，但对于不熟悉这个的人来说，它是一个在线平台，人们可以在这里为他们的产品筹集资金。他们可以展示他们的想法和想法，依靠这一点，其他人可以为他们感兴趣的项目做出贡献，以换取项目所有者提供的未来利益。</p><p id="e496" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在了解了Kickstarter之后，你可能会想，对于筹资者和贡献者来说，它都是一个完美的地方，没有任何问题，对吗？</p><p id="4788" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">答案是<strong class="ig hi">不</strong>It<strong class="ig hi">T3】当然是一个不错的融资解决方案，但它面临着自己独特的问题</strong></p><h1 id="34c0" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">问题是</h1><p id="6a28" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">这个平台本身没有任何问题，但是当项目所有者(想筹集资金的人…姑且称他为<strong class="ig hi">管理员</strong>)有某种恶意。</p><p id="ea2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦资金被转移到管理，他们几乎从捐助者的手中消失了。管理员可以将这些资金转移到他的个人银行账户中。</p><p id="ade7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这甚至会导致募集的资金被用于欧洲旅行和一辆好车……:)</p><h1 id="b0ee" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">解决方案</h1><p id="c13f" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">整个场景的主要问题是资金完全在管理员的控制之下。如果我们能让管理员只在大多数贡献者同意的情况下才能使用收集到的钱，那会怎么样？</p><p id="4a3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简单地说，我们可以锁定资金，这样管理员就可以要求贡献者允许任何种类的支出。</p><p id="0f1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是等等什么..？锁定资金？这可能吗..？</p><h2 id="0077" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">输入Solidity</h2><p id="54db" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">是的，使用智能契约(也称为去中心化)完全有可能实现上述场景。</p><p id="5c05" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以使用Solidity Smart合同，这样管理员每次需要从基金中获得任何金额时，都需要为贡献者创建一个<strong class="ig hi">支出请求</strong>。</p><p id="825b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们要怎么做？这就是我接下来要展示给你的。</p><h1 id="0919" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">了解智能合同</h1><p id="67bb" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在继续编写代码之前，让我们确切地了解一下我们的智能契约在基本层面上是如何工作的。</p><p id="cec9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">智能合约的运作方式如下:</p><ul class=""><li id="39f5" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">管理员将启动一个有特定目标和截止日期的筹款活动或项目。</li><li id="c815" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">贡献者将通过发送所需的令牌(在本例中为ether)来为该项目做出贡献。</li><li id="3432" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">管理员每次想要使用这些资金中的任何金额时，都会创建一个<strong class="ig hi">支出请求</strong></li><li id="0989" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated"><strong class="ig hi">贡献者</strong>将投票支持该支出请求。</li><li id="414d" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">如果超过50%的总贡献者投票支持该请求，那么管理员将获得使用支出请求中提到的金额的许可</li><li id="b6a6" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">如果要求的金额(目标)没有在截止日期内筹集到，贡献者可以撤回他们的以太。</li></ul><p id="dfea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注意:</strong>只有达到目标时，才能创建支出请求。</p><h1 id="f113" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">让我们从代码</strong>开始</h1><p id="7e33" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">有几点我想先提一下:</p><ul class=""><li id="0729" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">这不是一个生产就绪的智能合同。在生产之前，我们需要考虑很多事情</li><li id="d011" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">我会向你解释一些代码块，但整个合同代码加载了注释。</li></ul><h2 id="da44" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated"><strong class="ak">存储变量</strong></h2><p id="e4a6" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">让我们先来看看我们的存储变量</p><figure class="lh li lj lk fd ll"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="5961" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从代码中可以清楚地看到大部分事情。让我解释剩下的几个</p><ul class=""><li id="b3c7" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">我们首先看到的是一个<strong class="ig hi">结构定义</strong>(不是一个存储变量)。顾名思义，它只是一个定义，而不是变量本身。每次创建新的支出请求时，我们都会创建该结构的一个实例。</li><li id="19d0" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">结构定义包括各种属性，如描述、值、接收者等。其中大部分很容易理解，但其余的将在合同中进一步阐明</li><li id="b878" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">映射<code class="du lo lp lq lr b">contributions</code> <strong class="ig hi"> </strong>是存储所有贡献者的贡献(金钱)的可靠性映射。<strong class="ig hi">把它看作一个javascript对象，其中贡献者的地址是键，他/她贡献的数量是值。</strong></li><li id="d16c" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">最后是一个<code class="du lo lp lq lr b">Request</code>类型的动态数组<code class="du lo lp lq lr b">requests</code> <strong class="ig hi"> </strong>(前面定义的结构)。我们需要存储已经创建的所有支出请求。</li></ul><h2 id="bdd7" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">构造函数</h2><p id="08c8" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">构造函数是:</p><figure class="lh li lj lk fd ll"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="26f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们契约的构造函数非常简单</p><p id="0456" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们只是初始化了一些静态存储变量。我称它们为静态的，因为它们不会随时间而改变。这就是为什么它们应该在构造函数中定义，因为构造函数只被调用一次(在部署时)</p><p id="120f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一件要注意的事情是我们如何使用截止日期的块号。您可以使用时间戳，但是这些时间戳很容易被矿工操纵或更改。</p><p id="10bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一种解决方法是使用<strong class="ig hi">块号</strong>来计算时间。</p><p id="257c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，假设管理员在一周的期限内部署了合同(当然是使用前端应用程序)。众所周知，网络挖掘一个以太坊块的平均时间是15秒。因此，1周(以秒为单位)将是<strong class="ig hi"> 604800秒</strong>，在这段时间内可开采的区块数将是<strong class="ig hi"> 40320。</strong>因此<strong class="ig hi"> </strong>为<code class="du lo lp lq lr b">_deadline</code>输入的值是40320。</p><p id="19b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在在构造函数中，我们正在做</p><p id="0a83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du lo lp lq lr b">deadline=block.number + _deadline</code></p><p id="89b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它表示“将活动的时间段添加到当前块号中”</p><p id="db44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du lo lp lq lr b">block.number</code>返回我们当前所在的块。因此，如果当前区块数是1000000，那么筹款活动的截止日期将是1040320。</p><p id="cda8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第1040320 <em class="ls">个</em>区块后，该活动应停止接受资金。</p><h2 id="dc18" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">contribute()函数</h2><figure class="lh li lj lk fd ll"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="1195" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于contribute函数，您应该注意的第一件事是，它是一个<strong class="ig hi"> payable </strong>函数。调用这个函数的地址需要发送一些以太网。这正是一个捐助者对竞选的贡献。</p><p id="9169" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大多数事情都在代码中解释过了，但是有两件事我需要提一下</p><ul class=""><li id="67cb" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">我们在函数开始时使用的<code class="du lo lp lq lr b">require()</code>语句用于检查条件。它只允许代码在其内部获得一个<strong class="ig hi">真值</strong>时进一步运行。比方说，发送的数量小于<code class="du lo lp lq lr b">minimumContribution</code>，那么函数的其余部分将不会执行。</li><li id="cb7b" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated"><code class="du lo lp lq lr b">msg</code>是可靠性的全局变量，包括发送交易的地址的数据。这就是为什么我们使用<code class="du lo lp lq lr b">msg.value</code>表示通过交易发送的金额，使用<code class="du lo lp lq lr b">msg.sender</code>表示发送者地址</li></ul><h2 id="7f36" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">getRefund()函数</h2><figure class="lh li lj lk fd ll"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="4108" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du lo lp lq lr b">getRefund()</code>函数是所有函数中最简单的一个，它非常简单明了。</p><p id="2c0c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们只需要确保一些条件，人们应该能够拿回他们的钱。如果在设定的期限内没有达到目标，退款应该是可用的。还有一个条件是，发件人首先应该捐一些钱。</p><h2 id="bb4a" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">createSpendingRequest()函数</h2><p id="30d1" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">如前所述，管理员应该创建一个支出请求，如果他想花一些资金。</p><figure class="lh li lj lk fd ll"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="d2c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在解释这个函数的其余部分之前，我想再介绍一件事。</p><p id="6d47" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你应该能在public关键字后面看到两个字<code class="du lo lp lq lr b">onlyAdmin</code>和<code class="du lo lp lq lr b">goalReached</code>。</p><p id="baea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些是我在合同中定义的修饰符，所以我们的代码遵循DRY(不要重复)原则。这些代码是:</p><figure class="lh li lj lk fd ll"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="2e44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个修改是确保只有管理员能够创建支出请求。</p><p id="6cdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个修饰符确保只有在活动达到其目标(所需金额)时才创建支出请求。</p><p id="1643" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">转到<code class="du lo lp lq lr b">createSpendingRequest()</code>功能-</p><p id="c3c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们基于作为函数参数传递给我们的数据实例化一个新的请求结构。注意我们在实例化<code class="du lo lp lq lr b">Request</code>类型变量时是如何使用关键字<code class="du lo lp lq lr b">memory</code>的。当我们像这样使用关键字<code class="du lo lp lq lr b">memory</code>时，它通常意味着我们正在使用的参考类型。</p><p id="07eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，如果我们使用关键字<code class="du lo lp lq lr b">storage</code>，它将检查所提到的变量是否存在于存储器中，然后直接指向它。</p><p id="2c29" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们对函数中定义的变量所做的任何改变都会直接影响存储变量。</p><p id="4351" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，我们使用关键字memory，因为没有在右边使用的<code class="du lo lp lq lr b">Request </code>类型的存储变量，所以它将在<code class="du lo lp lq lr b">memory</code>(类似计算机Ram的临时位置)内创建一个<code class="du lo lp lq lr b">Request </code>类型变量的副本。</p><p id="cd8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在这可能会让你感到困惑，但是在下一个函数中事情会变得很清楚，因为我们也使用了<code class="du lo lp lq lr b">storage</code>关键字。</p><h2 id="f65e" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">voteForRequest()函数</h2><figure class="lh li lj lk fd ll"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="e114" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你应该注意的第一件事是我们这次是如何使用关键字<code class="du lo lp lq lr b">storage</code>的。这正是我在<code class="du lo lp lq lr b">createSpendingRequest()</code>函数中所说的。</p><p id="142b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们从存储中的requests数组中挑选一个特定的支出请求，然后将它分配给函数中的一个请求类型变量。</p><p id="31c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着变量<code class="du lo lp lq lr b">thisRequest</code>是对位于请求数组(保存在存储器中)的特定<code class="du lo lp lq lr b">index</code>(通过函数参数传递)的支出请求的直接引用。</p><p id="16cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们对<code class="du lo lp lq lr b">thisRequest</code>所做的任何更改也会影响存储中保存的支出请求。我希望这能澄清一些事情。</p><p id="1024" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此后，我们使用<code class="du lo lp lq lr b">require()</code>检查必要的条件。</p><ul class=""><li id="d796" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated"><code class="du lo lp lq lr b">require(contributions[msg.sender] &gt; 0);</code>这将检查投票人是否做出了贡献。</li><li id="66b2" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated"><code class="du lo lp lq lr b">require(thisRequest.voters[msg.sender] == false);</code>检查该人是否已经投票。因此要确保一个投稿人只投一次票。</li></ul><p id="7435" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">休息应该很好理解。</p><p id="69fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">页（page的缩写）s——我们可以使用<code class="du lo lp lq lr b">thisRequest</code>访问特定消费请求的所有属性(不记得属性了？…这些是我们在定义请求结构时声明的属性。</p><h2 id="11e3" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">makePayment()函数</h2><figure class="lh li lj lk fd ll"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="7716" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在讨论代码之前，我们需要了解这个函数具体做什么。在支出请求被批准后，管理员可以将提到的资金用于提到的目的(如向供应商和制造商付款)。</p><p id="6fe6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，如果超过50%的贡献者投票支持支出请求，该请求将被批准，管理员可以将这笔钱发送到上述收件人地址。</p><p id="6bb3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">代码应该很清楚，因为它与前面的函数<code class="du lo lp lq lr b">voteForRequest()</code>非常相似。</p><p id="2b89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用语句<code class="du lo lp lq lr b">require(thisRequest.completed == false);</code>检查特定请求(使用<code class="du lo lp lq lr b">index </code>参数获取)是否已经完成。一旦支付完成，请求的completed属性将被设置为true。这确保了管理员在每个请求中只使用一次钱</p><p id="8352" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我们将钱<code class="du lo lp lq lr b">thisRequest.value</code>发送到地址<code class="du lo lp lq lr b">thisRequest.recipient</code>，然后由于上面提到的原因将属性<code class="du lo lp lq lr b">thisRequest.completed</code>更改为true。</p><h1 id="363f" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">最后的话</h1><p id="0e36" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">现在你知道了。一个展示我们如何分散筹款的基本例子。当然，如果你真的想做一个生产就绪的应用程序，还有很多事情是你可以做的，你需要做的，但这仍然是令人惊讶的。</p><figure class="lh li lj lk fd ll er es paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="er es lt"><img src="../Images/d875b6d07b354c1604fff4b604eb26cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqqGStYfuvllP2PMsQ9Arg.jpeg"/></div></div></figure><p id="7b51" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你想要完整的合同代码，可以在我的Github库中找到</p><div class="ma mb ez fb mc md"><a href="https://github.com/ankitbrahmbhatt1997/Ethereum_real_life_examples/blob/master/FundRaising.sol" rel="noopener  ugc nofollow" target="_blank"><div class="me ab dw"><div class="mf ab mg cl cj mh"><h2 class="bd hi fi z dy mi ea eb mj ed ef hg bi translated">ankitbrahmbhatt 1997/以太坊_真实生活_实例</h2><div class="mk l"><h3 class="bd b fi z dy mi ea eb mj ed ef dx translated">在GitHub上创建一个帐户，为ankitbrahmbhatt 1997/ether eum _ real _ life _ examples开发做贡献。</h3></div><div class="ml l"><p class="bd b fp z dy mi ea eb mj ed ef dx translated">github.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ly md"/></div></div></a></div><p id="361e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您有任何问题，请随时在下面提问</p></div></div>    
</body>
</html>