<html>
<head>
<title>What is JavaScript “this”?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript“这个”是什么？</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/what-is-javascript-this-3d2194cb7a6c?source=collection_archive---------7-----------------------#2022-02-03">https://medium.com/walmartglobaltech/what-is-javascript-this-3d2194cb7a6c?source=collection_archive---------7-----------------------#2022-02-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f18e907b4a0d2abc1995bbc736cd5870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pUi3vkj06Vqp_sXeiI-UbQ.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Image taken from Unsplash <a class="ae hu" href="https://unsplash.com/photos/vpOeXr5wmR4" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/vpOeXr5wmR4</a></figcaption></figure><div class=""/><p id="4c34" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b">this</code>是一个被很多开发者误解的JavaScript关键字，这篇文章旨在弥补这个差距。虽然这篇文章是为初学者写的，但即使是有经验的开发人员也可以把它作为复习资料。<code class="du js jt ju jv b">this </code>是一个特殊的标识符关键字，在每个函数的范围内自动定义，但它实际指的是真实的交易。这篇文章分为三个部分，在第一部分，我们将谈论什么是<strong class="iw hy"> <em class="jw"> </em> </strong> <code class="du js jt ju jv b">this</code>，然后我们将谈论一些关于<code class="du js jt ju jv b">this</code>的常见误解，最后，我们将看到与<code class="du js jt ju jv b">this</code>关键字相关的JS的一些特征。</p></div><div class="ab cl jx jy go jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="ha hb hc hd he"><h1 id="c9b9" class="ke kf hx bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">先决条件</h1><p id="ced9" class="pw-post-body-paragraph iu iv hx iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">我相信学习就像健身，如果你不做好热身运动，你可能会伤害到自己。因此，在讨论<code class="du js jt ju jv b">this</code>之前，让我们先来讨论一些JavaScript概念，对于本文来说，这些概念你应该很熟悉。</p><p id="6efc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> 1) </strong> <strong class="iw hy"> <em class="jw">在全局范围内声明为</em> </strong> <code class="du js jt ju jv b"><em class="jw">var a = 2;</em></code> <strong class="iw hy"> <em class="jw">的变量不过是同名的全局对象属性。</em> </strong>是的，他们不是彼此的复制品而是彼此。为了更清楚地说明这一点，请看下面的例子，我们如何访问作为全局对象<code class="du js jt ju jv b">window</code>的键的<code class="du js jt ju jv b">x</code>的值。此外，这里必须注意的一点是，这只适用于使用<code class="du js jt ju jv b">var</code>的声明，而不是<code class="du js jt ju jv b">let/const</code>。</p><figure class="lh li lj lk fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="f286" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> 2)调用位置:</strong>调用函数的位置称为<em class="jw">调用位置</em>。通常寻找<em class="jw">调用点</em>只包括定位调用函数的代码行，但是这可能会产生误导，因为函数可能在代码中的多个地方被调用。因此，找到<em class="jw">调用点</em>的最准确方法是找到<em class="jw">调用栈</em>，然后查看从哪里调用该函数，或者换句话说，在<em class="jw">调用栈</em>中的前一个函数是什么。我们用一个例子来理解这个。</p><figure class="lh li lj lk fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure></div><div class="ab cl jx jy go jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="ha hb hc hd he"><h1 id="64b4" class="ke kf hx bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">什么是<code class="du js jt ju jv b">this</code>？</h1><p id="a335" class="pw-post-body-paragraph iu iv hx iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">是为每个函数调用创建的绑定，其值取决于调用函数的方式和位置。为<code class="du js jt ju jv b">this</code>做的绑定通常与使用<code class="du js jt ju jv b">var</code>声明的变量和运行在<a class="ae hu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" rel="noopener ugc nofollow" target="_blank">非严格</a>模式的JavaScript相关。进一步在<em class="jw">调用点</em>的基础上，我们可以将这样的绑定分为如下四个部分:</p><ul class=""><li id="643a" class="ln lo hx iw b ix iy jb jc jf lp jj lq jn lr jr ls lt lu lv bi translated">默认绑定</li><li id="5291" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">隐式结合</li><li id="b566" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated">显式绑定</li><li id="9882" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr ls lt lu lv bi translated"><em class="jw">新</em>装订</li></ul><p id="842b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi mb translated"><span class="l mc md me bm mf mg mh mi mj di"> D </span>函数内部的这个被绑定到全局作用域。是的，你可以在这样的函数中使用<em class="jw">这个</em>来访问所有的全局变量。这里需要注意的一点是，它只适用于使用<code class="du js jt ju jv b">var</code>定义的<code class="du js jt ju jv b">non-strict</code>模式和变量。</p><figure class="lh li lj lk fd hj"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Default Binding</figcaption></figure><p id="c3c5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="jw">严格模式</em>:此时<code class="du js jt ju jv b">this</code>的值未定义。</p><p id="bf9f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="jw"> let/const </em>:用<code class="du js jt ju jv b">let/const</code>定义的变量不绑定。</p><p id="c707" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi mb translated"><span class="l mc md me bm mf mg mh mi mj di">I</span><strong class="iw hy">implicit Binding</strong>:当函数的调用点有一个包含对象(上下文对象)时，如下所示。该上下文对象被绑定到该函数内的<em class="jw"> this </em>。在下面的例子中，<code class="du js jt ju jv b">obj</code>是上下文对象，<em class="jw">这个</em>被绑定到这个对象，所有的键都可以在函数内部使用<em class="jw">这个</em>来访问。</p><figure class="lh li lj lk fd hj"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Implicit Binding</figcaption></figure><p id="ae56" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="jw">严格模式</em>:这将与<code class="du js jt ju jv b">non-strict</code>模式一样工作。</p><p id="1e1c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="jw"> let/const </em>:不适用</p><p id="737e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi mb translated">透明绑定:这种绑定给了我们赋予任何东西的权力。我们可以使用<code class="du js jt ju jv b">call(..)</code>和<code class="du js jt ju jv b">apply(..)</code>方法实现这一点。是的，我们可以将<code class="du js jt ju jv b">this</code>设置为一个对象、变量、函数或任何东西。但是有一个问题，<code class="du js jt ju jv b">null</code>和<code class="du js jt ju jv b">undefined</code>被替换为全局对象，原语被转换为等价对象。无论我们将传递什么作为第一个参数，它将被函数调用用作<em class="jw">这个</em>绑定。</p><figure class="lh li lj lk fd hj"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Explicit Binding</figcaption></figure><p id="4255" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="jw">严格模式</em> : <code class="du js jt ju jv b">null</code>和<code class="du js jt ju jv b">undefined</code>不会被全局对象替换，图元也不会被转换成对象。</p><p id="71d3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="jw"> let/const </em>:当<code class="du js jt ju jv b">this</code>绑定到全局对象时不支持(直接或者从<code class="du js jt ju jv b">null</code>或<code class="du js jt ju jv b">undefined</code>替换后)，但是用<code class="du js jt ju jv b">let/const</code>定义的变量可以直接作为<code class="du js jt ju jv b">this</code>传递，它会被绑定。</p><p id="ed6e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi mb translated"><span class="l mc md me bm mf mg mh mi mj di"> N </span>在这种绑定中，如果我们用关键字<code class="du js jt ju jv b">new</code>调用函数，并将其赋给一个变量，那么<code class="du js jt ju jv b">this</code>就会绑定到该变量。看下面的例子就明白了。这里我们将<code class="du js jt ju jv b">new doSomething()</code>的值赋给<code class="du js jt ju jv b">bar</code>，因此在函数内部，<em class="jw">这个</em>被绑定到<code class="du js jt ju jv b">bar</code>。</p><figure class="lh li lj lk fd hj"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">new Binding</figcaption></figure><p id="92be" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="jw">严格模式</em>:无效果</p><p id="6ddc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="jw"> let/const </em>:定义的变量可以都是<code class="du js jt ju jv b">let/const</code>，观察到相同的行为。</p></div><div class="ab cl jx jy go jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="ha hb hc hd he"><h1 id="d4d4" class="ke kf hx bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">这个不是什么<strong class="ak">？</strong></h1><p id="000d" class="pw-post-body-paragraph iu iv hx iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated">让我们看看许多开发人员对<code class="du js jt ju jv b">this</code>最常见的误解，并深入探究每一个。人们认为<code class="du js jt ju jv b">this</code>中的功能是指:</p><ol class=""><li id="d7be" class="ln lo hx iw b ix iy jb jc jf lp jj lq jn lr jr mk lt lu lv bi translated">它自己</li><li id="5273" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr mk lt lu lv bi translated">其范围</li></ol><p id="c20b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi mb translated"><span class="l mc md me bm mf mg mh mi mj di">我</span> <strong class="iw hy"> <em class="jw"> tself </em> </strong>很多开发者认为<em class="jw">这个</em>指的是调用它的函数本身哪个是错的。下面是一个简单的例子来证明它。</p><figure class="lh li lj lk fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="9aa6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">确切地说，跟踪调用了多少次<code class="du js jt ju jv b">increase</code>的正确方法应该是实际使用<code class="du js jt ju jv b">call</code>方法来显式地将<code class="du js jt ju jv b">this</code>关键字定义为<code class="du js jt ju jv b">increase</code>对象(自身)。下面给出的代码示例是它的一个工作示例。</p><figure class="lh li lj lk fd hj"><div class="bz dy l di"><div class="ll lm l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Corrent way</figcaption></figure><p id="aa30" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi mb translated"><span class="l mc md me bm mf mg mh mi mj di"> I </span> <strong class="iw hy"> <em class="jw"> ts作用域</em> </strong>开发人员的另一个著名的误解是，他们认为它指的是函数的作用域。这是一个棘手的问题，因为在全局作用域中，<code class="du js jt ju jv b">this</code>指的是全局作用域本身，但这是一个非常误导的陈述，因为我们在前面的部分中已经看到这是不正确的。</p></div><div class="ab cl jx jy go jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="ha hb hc hd he"><h1 id="7401" class="ke kf hx bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">关于`<code class="du js jt ju jv b">this`</code>的更多JavaScript特性</h1><p id="bd5e" class="pw-post-body-paragraph iu iv hx iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr ha bi translated"><strong class="iw hy"> <em class="jw"> bind() </em>函数:</strong> ES5引入了这个函数，帮助显式绑定<code class="du js jt ju jv b">this</code>的值。<code class="du js jt ju jv b">bind</code>返回一个函数，将<code class="du js jt ju jv b">this</code>设置为<code class="du js jt ju jv b">bind</code>的第一个参数。这与<code class="du js jt ju jv b">call</code>和<code class="du js jt ju jv b">apply</code>有些相似，但是不同之处在于一旦我们使用了<code class="du js jt ju jv b">bind</code>，函数会保留它的上下文，这样它就可以被重用。</p><figure class="lh li lj lk fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="b64f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> <em class="jw">箭头</em>函数:</strong>在这些函数中，<code class="du js jt ju jv b">this</code>保留封闭词法上下文的<code class="du js jt ju jv b">this</code>的值。在全局代码中，它将被设置为全局对象。下面我们来看几个例子:</p><figure class="lh li lj lk fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="6dcc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b"><strong class="iw hy">this</strong></code> <strong class="iw hy">在类中:</strong><code class="du js jt ju jv b">this</code>在类和函数中的行为是相同的，因为类只是幕后的函数。尽管如此，我还是建议阅读<a class="ae hu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#class_context" rel="noopener ugc nofollow" target="_blank">这里的</a>有一些边角案例。一个常见的约定是覆盖<code class="du js jt ju jv b">this</code>行为，这样类中的<code class="du js jt ju jv b">this</code>总是引用类实例。这在React类组件中很常见。</p><p id="aa89" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b"><strong class="iw hy">this</strong></code> <strong class="iw hy">作为DOM处理程序:</strong>当一个函数被用作事件处理程序时，它的<code class="du js jt ju jv b">this</code>被设置为监听器所在的元素。下面给出的代码将打印DOM元素本身。</p><figure class="lh li lj lk fd hj"><div class="bz dy l di"><div class="ll lm l"/></div></figure><h1 id="b426" class="ke kf hx bd kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx mp kz la lb bi translated">参考文献和推荐读物:</h1><ol class=""><li id="053e" class="ln lo hx iw b ix lc jb ld jf mq jj mr jn ms jr mk lt lu lv bi translated"><a class="ae hu" href="https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/this%20&amp;%20object%20prototypes/README.md#you-dont-know-js-this--object-prototypes" rel="noopener ugc nofollow" target="_blank">你不知道JS:这个和对象原型</a></li><li id="d4b0" class="ln lo hx iw b ix lw jb lx jf ly jj lz jn ma jr mk lt lu lv bi translated"><a class="ae hu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">本:MDN文档</a></li></ol></div></div>    
</body>
</html>