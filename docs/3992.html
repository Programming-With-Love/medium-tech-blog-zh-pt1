<html>
<head>
<title>Kotlin Coroutines Part — 1: Basic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林协程第1部分:基础</h1>
<blockquote>原文：<a href="https://medium.com/globant/kotlin-coroutines-part-1-basic-febca09b66d4?source=collection_archive---------2-----------------------#2022-09-22">https://medium.com/globant/kotlin-coroutines-part-1-basic-febca09b66d4?source=collection_archive---------2-----------------------#2022-09-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d3fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用协程的异步编程最佳选择。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/8e644df82650940fdd907eef4cf2d701.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*xa15H2jwq41D2pQ48wTsNw.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx">Referred from <a class="ae jo" href="https://www.google.com/imgres?imgurl=https%3A%2F%2Frepository-images.githubusercontent.com%2F61722736%2F08e87280-62dc-11ea-8fed-a8a4a4ea865d&amp;imgrefurl=https%3A%2F%2Fgithub.com%2FKotlin%2Fkotlinx.coroutines&amp;tbnid=jlQYUzxmAhWpdM&amp;vet=12ahUKEwjanbacxNf4AhULaMAKHWs9CacQMygBegUIARC5AQ..i&amp;docid=g-5vbHfe9yVteM&amp;w=5573&amp;h=2778&amp;q=kotlin%20coroutines&amp;ved=2ahUKEwjanbacxNf4AhULaMAKHWs9CacQMygBegUIARC5AQ" rel="noopener ugc nofollow" target="_blank">https://github.com/Kotlin/kotlinx.coroutines</a></figcaption></figure><p id="1b4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最近，协同程序在Android开发人员中非常流行。毫无疑问，与传统的异步实践相比，协程给我们带来了惊人的好处。</p><p id="c649" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我首先想说的是<strong class="ig hi">协程试图解决什么问题？</strong></p><p id="36e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">协程解决的主要问题是通过替换回调来简化异步编程；它还有助于管理生命周期和避免内存泄漏。所以在讨论异步编程之前，我们先来看看同步编程问题。当我们同步执行某个任务时，我们会等待它完成，然后再继续下一个任务。因此，我们面临着应用程序块等问题。这里有一个例子。</p><p id="193f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设我们发出一个请求调用来获取一些用户数据，在获取数据之后，我们只需更新UI。<br/> <strong class="ig hi">如</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jp"><img src="../Images/33809a7d565ca1097898db5957a24c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xxjwa8PXcNomOaj-5WoWBg.png"/></div></div></figure><p id="9c4f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们执行上述代码时，我们会注意到它触发了错误“应用程序没有响应(ANR)”，应用程序将被冻结或没有响应。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ju"><img src="../Images/e85b3f9703f965a16cdc482fb66e1d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S14fpFllweAM8Wv_F-954g.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Image referred from <a class="ae jo" href="https://proandroiddev.com/kotlin-coroutines-in-andriod-ff0b3b399fa0" rel="noopener ugc nofollow" target="_blank">https://proandroiddev.com/kotlin-coroutines-in-andriod-ff0b3b399fa0</a></figcaption></figure><p id="de2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决上面的问题，我们需要用回调把我们的代码移到不同的线程中。类似这样的。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jv"><img src="../Images/6968a89d50e58b6a03a17286ae2e704f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q1PS7Ot-SEd5b-VJ2DiIng.png"/></div></div></figure><p id="c91f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我们在不同的线程上执行这个方法，这样我们的主线程就可以自由地执行其他操作。看下面的图片，我们会得到更多的想法。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jw"><img src="../Images/fa12351307bbb4a0df8c025073a3279a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byce5YAkRfQuhde985mGGg.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx"><a class="ae jo" href="https://proandroiddev.com/kotlin-coroutines-in-andriod-ff0b3b399fa0" rel="noopener ugc nofollow" target="_blank">https://proandroiddev.com/kotlin-coroutines-in-andriod-ff0b3b399fa0</a></figcaption></figure><p id="2093" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我们已经解决了回调的问题，但回调也有其局限性，即回调地狱。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jx"><img src="../Images/3e87893e5673177b2a5732069926485b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Ty2mS9soWLgOdVGCB5yig.png"/></div></div></figure><p id="f85d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当有太多嵌套回调时，代码变得难以阅读，也难以处理异常和维护代码。让我们看看协程如何解决我们的问题。<br/> Kotlin协同程序的工作方式与<strong class="ig hi"><em class="jy"/></strong>异步。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jx"><img src="../Images/bc44661f2d2cfeb1328a88306fca482c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xB_kDYIk8I4Kqt3vQVzXRA.png"/></div></div></figure><p id="07b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">什么是协程？<br/>T12】我们可以说协程类似于线程。同步执行<strong class="ig hi">和异步执行</strong>需要一段代码。</strong></p><p id="23a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">嗯<strong class="ig hi"> </strong>协程是轻量级线程，这意味着，与默认的Java线程相比，协程占用更少的内存和时间。例如，对于传统的线程方式，如果我们创建了数千个线程，它们可能会消耗大量内存和时间，并引发内存不足错误。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jz"><img src="../Images/427499a12da09bbfe049b17b605a857b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7g6dT7Abh7-0_BPVlvmVQ.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx">Consume too much memory and throw an out-of-memory error.</figcaption></figure><p id="9cc0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">协程是可挂起计算的一个实例。协程可以在一个线程中暂停其执行，稍后在某个特定时间或在另一个线程中继续。</p><p id="a068" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">暂停功能</strong></p><p id="8d6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">暂停功能是一种可以暂停并在稍后恢复的功能。暂停函数的语法与常规的<strong class="ig hi">函数</strong>相同，但是增加了<strong class="ig hi"> <em class="jy">暂停</em> </strong>关键字。让我们来看看这个场景:如果我们想执行长时间运行的操作，并等待它们完成并返回结果，在这里，对于普通函数，我们可能会被引入回调，而且我们会被阻塞，直到结果返回。为了克服这个问题，我们可以使用一个挂起函数，挂起函数能够挂起代码而不阻塞它，并返回结果。</p><p id="4ffa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:我们只能从协程或另一个挂起函数中调用挂起函数。<br/> <strong class="ig hi">例如:</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ka"><img src="../Images/915c92445b7eba2c0f33628d338317e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOzr3xf8GMiScYjzmVbw3g.png"/></div></div></figure><p id="ba5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">什么是协程构建器？<br/> 协程生成器用于创建协程。下面列出了三个协同程序构建器。</p><ol class=""><li id="7edd" class="kb kc hh ig b ih ii il im ip kd it ke ix kf jb kg kh ki kj bi translated"><strong class="ig hi">发射</strong></li><li id="5ec9" class="kb kc hh ig b ih kk il kl ip km it kn ix ko jb kg kh ki kj bi translated"><strong class="ig hi">异步</strong></li><li id="1691" class="kb kc hh ig b ih kk il kl ip km it kn ix ko jb kg kh ki kj bi translated"><strong class="ig hi">运行阻塞</strong></li></ol><p id="7479" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们来详细探讨一下它们</p><p id="64e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 1。启动生成器</strong></p><p id="25ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以基本上它会启动一个新的协程，而不会阻塞当前线程。它返回对作业对象的引用。使用作业对象，我们可以取消协程或等待协程完成。<br/> <strong class="ig hi">如:</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kp"><img src="../Images/bcdb8bc081ef3643294506895fef8e3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tSd0bPB1TmCyNilLAdHT6g.png"/></div></div></figure><p id="9ff4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。异步生成器</strong></p><p id="7470" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这和发射建造者是一样的。唯一的区别是它返回一个延迟的对象。使用延迟对象，我们可以取消协同程序，等待协同程序完成，或者检索返回的结果。<br/> <strong class="ig hi">例如:</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ka"><img src="../Images/b906a2bf5b2788de7539628b0ef0010b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HjzuWJ02l-XbWA5WhbOpgA.png"/></div></div></figure><p id="6bd0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:这个启动和同步永远不会阻塞运行的线程</p><p id="921c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3。运行阻塞生成器:</strong></p><p id="6be5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它启动了一个新的协程，但它阻塞了一个当前线程，并等待协程完成执行。那么，当我们清楚地聚焦于避免阻塞主线程时，为什么还需要runBlocking呢？</p><p id="c268" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通常，<strong class="ig hi"> runBlocking </strong>它用于Android中的单元测试或者其他一些同步代码的情况。</p><p id="964f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">例如:</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jx"><img src="../Images/f1354a36afa3c43576168ae43414ce61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRMDjhJGNA_I9OBzLnCnsA.png"/></div></div></figure><p id="8620" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">回顾:<br/> </strong>我希望我们现在理解了协程的基础知识。我们之前关于协程的问题是什么？用协程进行异步编程是最好的选择。使用协程，管理回调、处理异常和避免内存泄漏变得非常容易。</p><p id="ebce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在第一部分学习了协程的基础，现在我们要学习作用域和调度程序<a class="ae jo" rel="noopener" href="/@mahesh.jadkar/kotlin-coroutines-part-2-scope-dispatchers-4d67e17eae82"> <em class="jy">科特林协程第二部分:作用域&amp;调度程序</em> </a></p><p id="8b24" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">信用标签</strong> <br/>这里是我参考的几个参考链接。<br/><a class="ae jo" href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/docs/coroutines-overview.html</a><br/><a class="ae jo" href="https://developer.android.com/kotlin/coroutines" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/kotlin/coroutines</a><br/><a class="ae jo" href="https://proandroiddev.com/kotlin-coroutines-in-andriod-ff0b3b399fa0" rel="noopener ugc nofollow" target="_blank">https://proandroiddev . com/kotlin-coroutines-in-andr iod-ff 0 b 399 fa 0</a></p></div></div>    
</body>
</html>