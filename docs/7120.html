<html>
<head>
<title>Dependency Injection: Give Your iOS Code a Shot in the Arm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入:给你的iOS代码打一针强心剂</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/dependency-injection-give-your-ios-code-a-shot-in-the-arm-ba98594f5002?source=collection_archive---------0-----------------------#2015-06-05">https://medium.com/square-corner-blog/dependency-injection-give-your-ios-code-a-shot-in-the-arm-ba98594f5002?source=collection_archive---------0-----------------------#2015-06-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="416c" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">将依赖注入设计模式应用于Objective-C或Swift代码库。</h2></div><p id="490e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">由</em> <a class="ae jt" href="https://twitter.com/firetweet" rel="noopener ugc nofollow" target="_blank">撰写<em class="js">埃里克·费尔斯通</em> </a> <em class="js">。</em></p><blockquote class="ju"><p id="cc23" class="jv jw hh bd jx jy jz ka kb kc kd jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jt" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><h1 id="d6a6" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">什么是依赖注入？</h1><p id="303b" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">依赖注入(DI)在许多语言中是一种流行的设计模式，如<a class="ae jt" href="http://square.github.io/dagger/" rel="noopener ugc nofollow" target="_blank"> Java </a>和<a class="ae jt" href="https://msdn.microsoft.com/en-us/library/vstudio/hh323705%28v=vs.100%29.aspx" rel="noopener ugc nofollow" target="_blank"> C# </a>，但在Objective-C中还没有得到广泛采用。本文旨在使用Objective-C示例简要介绍依赖注入，以及在Objective-C代码中使用依赖注入的实用方法。尽管本文关注的是Objective-C，但所有概念也适用于Swift。</p><p id="b066" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">依赖注入的概念非常简单:一个对象应该要求你传递任何依赖，而不是自己创建它们。马丁·福勒关于这个主题的精彩讨论是非常值得推荐的背景读物。</p><p id="e4cc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">依赖关系可以通过初始化器(或“构造器”)或属性(或“设置器”)传递给对象。这些通常被称为“构造器注入”和“设置器注入”</p><p id="6f4a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">构造函数注入:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="de2f" class="lk kf hh lg b fi ll lm l ln lo">- (<strong class="lg hi">instancetype</strong>)<strong class="lg hi">initWithDependency1:</strong>(Dependency1 <strong class="lg hi">*</strong>)d1 <br/>                        <strong class="lg hi">dependency2:</strong>(Dependency2 <strong class="lg hi">*</strong>)d2;</span></pre><p id="476e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Setter注入:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="c15c" class="lk kf hh lg b fi ll lm l ln lo"><strong class="lg hi">@property</strong> (<strong class="lg hi">nonatomic</strong>, <strong class="lg hi">retain</strong>) Dependency1 <strong class="lg hi">*</strong>dependency1;<br/><strong class="lg hi">@property</strong> (<strong class="lg hi">nonatomic</strong>, <strong class="lg hi">retain</strong>) Dependency2 <strong class="lg hi">*</strong>dependency2;</span></pre><p id="6f3d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如Fowler所描述的，<a class="ae jt" href="http://martinfowler.com/articles/injection.html#ConstructorVersusSetterInjection" rel="noopener ugc nofollow" target="_blank">构造函数注入是首选的</a>，一般来说，只有在构造函数注入不可能的情况下，才应该使用setter注入。通过构造函数注入，您可能仍然拥有这些依赖项的@property定义，但是您可以将它们设为只读，以简化对象的API。</p><h1 id="d729" class="ke kf hh bd kg kh ki kj kk kl km kn ko in lp io kq iq lq ir ks it lr iu ku kv bi translated">为什么要使用依赖注入？</h1><p id="4ba2" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">依赖注入提供了许多好处，但是一些更重要的好处是:</p><ul class=""><li id="1a3f" class="ls lt hh iy b iz ja jc jd jf lu jj lv jn lw jr lx ly lz ma bi translated"><strong class="iy hi">明确声明依赖关系</strong>对象需要什么来操作变得显而易见，危险的隐藏依赖关系——如全局变量——消失了。</li><li id="769a" class="ls lt hh iy b iz mb jc mc jf md jj me jn mf jr lx ly lz ma bi translated">复合 DI鼓励<a class="ae jt" href="http://en.wikipedia.org/wiki/Composition_over_inheritance" rel="noopener ugc nofollow" target="_blank">复合而非继承</a>，这提高了代码的可重用性。</li><li id="7bb8" class="ls lt hh iy b iz mb jc mc jf md jj me jn mf jr lx ly lz ma bi translated"><strong class="iy hi">轻松定制</strong>在创建一个对象时，很容易为特定场景定制对象的某些部分。</li><li id="4617" class="ls lt hh iy b iz mb jc mc jf md jj me jn mf jr lx ly lz ma bi translated"><strong class="iy hi">明确所有权</strong>特别是在使用构造函数注入时，对象所有权规则被严格执行——有助于构建一个<a class="ae jt" href="http://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener ugc nofollow" target="_blank">有向无环对象图</a>。</li><li id="d7e7" class="ls lt hh iy b iz mb jc mc jf md jj me jn mf jr lx ly lz ma bi translated">最重要的是，依赖注入提高了对象的可测试性。因为它们可以简单地通过填充初始化式来创建，所以不需要管理任何隐藏的依赖关系。此外，模仿依赖关系以将测试集中在被测试的对象上变得很简单。</li></ul><h1 id="89d9" class="ke kf hh bd kg kh ki kj kk kl km kn ko in lp io kq iq lq ir ks it lr iu ku kv bi translated">切换到依赖注入</h1><p id="8cd9" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">您的代码库可能还没有使用依赖注入设计模式进行设计，但是它很容易上手。依赖注入的一个好的方面是你不需要采用“要么全部要么什么都不要”相反，您可以将它应用到代码库的特定区域，并从那里扩展。</p><h1 id="88b9" class="ke kf hh bd kg kh ki kj kk kl km kn ko in lp io kq iq lq ir ks it lr iu ku kv bi translated">要注入的类的类型</h1><p id="c5e3" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">首先，让我们将类分为两个桶:基本类和复杂类。基本类是没有依赖关系的类，或者只依赖于其他基本类的类。基本类不太可能被子类化，因为它们的功能是清晰的、不变的，并且不引用外部资源。很多基础类的例子都来自Cocoa本身，比如NSString、NSArray、NSDictionary、NSNumber。</p><p id="ed89" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">复杂类则相反。它们还有其他复杂的依赖关系，包括应用程序级逻辑(可能需要更改)，或者访问外部资源，如磁盘、网络或全局内存服务。应用程序中的大多数类都很复杂，包括几乎所有的控制器对象和大多数模型对象。许多Cocoa类也很复杂，比如NSURLConnection或UIViewController。</p><p id="dfe1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">给定这些分类，最简单的开始方法是在应用程序中选择一个复杂的类，并在该类中寻找初始化其他复杂对象的位置(搜索“alloc] init”或“new]”)。要将依赖注入引入到类中，请将这个实例化的对象更改为类的初始化参数，而不是实例化对象本身的类。</p><h1 id="b3db" class="ke kf hh bd kg kh ki kj kk kl km kn ko in lp io kq iq lq ir ks it lr iu ku kv bi translated">初始化期间分配的依赖关系</h1><p id="1a99" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">让我们看一个例子，其中子对象(依赖项)作为父对象初始化的一部分被初始化。原始代码可能如下所示:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="7c96" class="lk kf hh lg b fi ll lm l ln lo"><strong class="lg hi">@interface</strong> <strong class="lg hi">RCRaceCar</strong> ()</span><span id="063f" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@property</strong> (<strong class="lg hi">nonatomic</strong>, <strong class="lg hi">readonly</strong>) RCEngine <strong class="lg hi">*</strong>engine;</span><span id="59e2" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@end</strong><br/></span><span id="f8b1" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@implementation</strong> <strong class="lg hi">RCRaceCar</strong></span><span id="26f9" class="lk kf hh lg b fi mg lm l ln lo">- (<strong class="lg hi">instancetype</strong>)<strong class="lg hi">init</strong><br/>{<br/>   ...</span><span id="d6bd" class="lk kf hh lg b fi mg lm l ln lo">   <em class="js">// Create the engine. Note that it cannot be customized or</em><br/>   <em class="js">// mocked out without modifying the internals of RCRaceCar.</em><br/>   _engine <strong class="lg hi">=</strong> [[RCEngine alloc] init];</span><span id="9980" class="lk kf hh lg b fi mg lm l ln lo">   <strong class="lg hi">return</strong> self;<br/>}</span><span id="1abd" class="lk kf hh lg b fi mg lm l ln lo">@<strong class="lg hi">end</strong></span></pre><p id="a098" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是一个简单的变化:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="6df4" class="lk kf hh lg b fi ll lm l ln lo"><strong class="lg hi">@interface</strong> <strong class="lg hi">RCRaceCar</strong> ()</span><span id="f231" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@property</strong> (<strong class="lg hi">nonatomic</strong>, <strong class="lg hi">readonly</strong>) RCEngine <strong class="lg hi">*</strong>engine;</span><span id="9e2c" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@end</strong><br/></span><span id="5b72" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@implementation</strong> <strong class="lg hi">RCRaceCar</strong></span><span id="6b1c" class="lk kf hh lg b fi mg lm l ln lo"><em class="js">// The engine is created before the race car and passed in</em><br/><em class="js">// as a parameter, and the caller can customize it if desired.</em><br/>- (<strong class="lg hi">instancetype</strong>)<strong class="lg hi">initWithEngine:</strong>(RCEngine <strong class="lg hi">*</strong>)engine<br/>{<br/>   ...</span><span id="6211" class="lk kf hh lg b fi mg lm l ln lo">   _engine <strong class="lg hi">=</strong> engine;</span><span id="35db" class="lk kf hh lg b fi mg lm l ln lo">   <strong class="lg hi">return</strong> self;<br/>}</span><span id="0912" class="lk kf hh lg b fi mg lm l ln lo">@<strong class="lg hi">end</strong></span></pre><h1 id="ddc2" class="ke kf hh bd kg kh ki kj kk kl km kn ko in lp io kq iq lq ir ks it lr iu ku kv bi translated">延迟初始化的依赖项</h1><p id="aba5" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">有些对象在初始化之后才需要，或者根本不需要。一个示例(在使用依赖注入之前)可能如下所示:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="043b" class="lk kf hh lg b fi ll lm l ln lo"><strong class="lg hi">@interface</strong> <strong class="lg hi">RCRaceCar</strong> ()</span><span id="3b22" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@property</strong> (<strong class="lg hi">nonatomic</strong>) RCEngine <strong class="lg hi">*</strong>engine;</span><span id="ca7d" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@end</strong><br/></span><span id="b043" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@implementation</strong> <strong class="lg hi">RCRaceCar</strong></span><span id="421a" class="lk kf hh lg b fi mg lm l ln lo">- (<strong class="lg hi">instancetype</strong>)<strong class="lg hi">initWithEngine:</strong>(RCEngine <strong class="lg hi">*</strong>)engine<br/>{<br/>   ...</span><span id="a627" class="lk kf hh lg b fi mg lm l ln lo">   _engine <strong class="lg hi">=</strong> engine;</span><span id="1c0d" class="lk kf hh lg b fi mg lm l ln lo">   <strong class="lg hi">return</strong> self;<br/>}</span><span id="d26c" class="lk kf hh lg b fi mg lm l ln lo">- (<strong class="lg hi">void</strong>)<strong class="lg hi">recoverFromCrash</strong><br/>{<br/>   <strong class="lg hi">if</strong> (self.fire <strong class="lg hi">!=</strong> nil) {<br/>      RCFireExtinguisher <strong class="lg hi">*</strong>fireExtinguisher <strong class="lg hi">=</strong> [[RCFireExtinguisher alloc] init];<br/>      [fireExtinguisher extinguishFire:self.fire];<br/>   }<br/>}</span><span id="a27a" class="lk kf hh lg b fi mg lm l ln lo">@<strong class="lg hi">end</strong></span></pre><p id="642d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，赛车希望永远不会崩溃，我们永远不需要使用我们的灭火器。因为需要这个对象的机会很低，我们不想通过在初始化时立即创建它来减慢每辆赛车的创建。或者，如果我们的赛车需要从多次碰撞中恢复，它将需要创建多个灭火器。对于这些情况，我们可以使用工厂。</p><p id="ee32" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">工厂是标准的Objective-C块，不需要参数，返回对象的具体实例。对象可以控制何时使用这些块创建其依赖项，而不需要知道如何创建它们的细节。</p><p id="fc01" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里有一个使用依赖注入的例子，它使用一个工厂来创建我们的灭火器:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="54f8" class="lk kf hh lg b fi ll lm l ln lo"><strong class="lg hi">typedef</strong> RCFireExtinguisher <strong class="lg hi">*</strong>(<strong class="lg hi">^</strong>RCFireExtinguisherFactory)();<br/></span><span id="57f6" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@interface</strong> <strong class="lg hi">RCRaceCar</strong> ()</span><span id="42a1" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@property</strong> (<strong class="lg hi">nonatomic</strong>, <strong class="lg hi">readonly</strong>) RCEngine <strong class="lg hi">*</strong>engine;<br/><strong class="lg hi">@property</strong> (<strong class="lg hi">nonatomic</strong>, <strong class="lg hi">copy</strong>, <strong class="lg hi">readonly</strong>) RCFireExtinguisherFactory fireExtinguisherFactory;</span><span id="f0c1" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@end</strong><br/></span><span id="ccbe" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@implementation</strong> <strong class="lg hi">RCRaceCar</strong></span><span id="b933" class="lk kf hh lg b fi mg lm l ln lo">- (<strong class="lg hi">instancetype</strong>)<strong class="lg hi">initWithEngine:</strong>(RCEngine <strong class="lg hi">*</strong>)engine<br/>       <strong class="lg hi">fireExtinguisherFactory:</strong>(RCFireExtinguisherFactory)extFactory<br/>{<br/>   ...</span><span id="583c" class="lk kf hh lg b fi mg lm l ln lo">   _engine <strong class="lg hi">=</strong> engine;<br/>   _fireExtinguisherFactory <strong class="lg hi">=</strong> [extFactory <strong class="lg hi">copy</strong>];</span><span id="99de" class="lk kf hh lg b fi mg lm l ln lo">   <strong class="lg hi">return</strong> self;<br/>}</span><span id="2460" class="lk kf hh lg b fi mg lm l ln lo">- (<strong class="lg hi">void</strong>)<strong class="lg hi">recoverFromCrash</strong><br/>{<br/>   <strong class="lg hi">if</strong> (self.fire <strong class="lg hi">!=</strong> nil) {<br/>      RCFireExtinguisher <strong class="lg hi">*</strong>fireExtinguisher <strong class="lg hi">=</strong> self.fireExtinguisherFactory();<br/>      [fireExtinguisher extinguishFire:self.fire];<br/>   }<br/>}</span><span id="6e9f" class="lk kf hh lg b fi mg lm l ln lo">@<strong class="lg hi">end</strong></span></pre><p id="f272" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们需要创建未知数量的依赖项的情况下，工厂也很有用，即使创建是在初始化期间完成的。例如:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="8e03" class="lk kf hh lg b fi ll lm l ln lo"><strong class="lg hi">@implementation</strong> <strong class="lg hi">RCRaceCar</strong></span><span id="14ab" class="lk kf hh lg b fi mg lm l ln lo">- (<strong class="lg hi">instancetype</strong>)<strong class="lg hi">initWithEngine:</strong>(RCEngine <strong class="lg hi">*</strong>)engine <br/>                  <strong class="lg hi">transmission:</strong>(RCTransmission <strong class="lg hi">*</strong>)transmission<br/>                  <strong class="lg hi">wheelFactory:</strong>(RCWheel <strong class="lg hi">*</strong>(<strong class="lg hi">^</strong>)())wheelFactory;<br/>{<br/>   self <strong class="lg hi">=</strong> [super init];<br/>   <strong class="lg hi">if</strong> (self <strong class="lg hi">==</strong> nil) {<br/>      <strong class="lg hi">return</strong> nil;<br/>   }</span><span id="eeb2" class="lk kf hh lg b fi mg lm l ln lo">   _engine <strong class="lg hi">=</strong> engine;<br/>   _transmission <strong class="lg hi">=</strong> transmission;</span><span id="2b11" class="lk kf hh lg b fi mg lm l ln lo">   _leftFrontWheel <strong class="lg hi">=</strong> wheelFactory();<br/>   _leftRearWheel <strong class="lg hi">=</strong> wheelFactory();<br/>   _rightFrontWheel <strong class="lg hi">=</strong> wheelFactory();<br/>   _rightRearWheel <strong class="lg hi">=</strong> wheelFactory();</span><span id="caa8" class="lk kf hh lg b fi mg lm l ln lo">   <em class="js">// Keep the wheel factory for later in case we need a spare.</em><br/>   _wheelFactory <strong class="lg hi">=</strong> [wheelFactory <strong class="lg hi">copy</strong>];</span><span id="7062" class="lk kf hh lg b fi mg lm l ln lo">   <strong class="lg hi">return</strong> self;<br/>}</span><span id="8331" class="lk kf hh lg b fi mg lm l ln lo">@<strong class="lg hi">end</strong></span></pre><h1 id="671a" class="ke kf hh bd kg kh ki kj kk kl km kn ko in lp io kq iq lq ir ks it lr iu ku kv bi translated">避免繁琐的配置</h1><p id="83ed" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">如果对象不应该被分配到其他对象中，那么它们被分配到哪里呢？所有这些依赖关系不是很难配置吗？大部分不是每次都一样吗？这些问题的解决方案在于类便利初始化器(think +[NSDictionary dictionary])。我们将把对象图的配置从普通对象中抽出来，留给它们纯粹的、可测试的业务逻辑。</p><p id="03b5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在添加一个类便利初始化器之前，确保它是必要的。如果一个对象的init方法只有几个参数，并且这些参数没有合理的默认值，那么就没有必要使用类便利初始化器，调用者应该直接使用标准的init方法。</p><p id="2e8b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了配置我们的对象，我们将从四个地方收集依赖关系:</p><ul class=""><li id="0e4d" class="ls lt hh iy b iz ja jc jd jf lu jj lv jn lw jr lx ly lz ma bi translated"><strong class="iy hi">没有合理默认值的值</strong>这些值包括布尔值或数字，这些值在每个实例中可能会有所不同。这些值应该作为参数传递给类便利初始化器。</li><li id="23e5" class="ls lt hh iy b iz mb jc mc jf md jj me jn mf jr lx ly lz ma bi translated"><strong class="iy hi">现有的共享对象</strong>这些应该作为参数(比如pit无线电频率)传递给类便利初始化器。这些是以前可能被评估为单例或通过“父”指针评估的对象。</li><li id="f5e2" class="ls lt hh iy b iz mb jc mc jf md jj me jn mf jr lx ly lz ma bi translated"><strong class="iy hi">新创建的对象</strong>如果我们的对象不与另一个对象共享这种依赖关系，那么应该在类便利初始化器中新实例化一个collaborator对象。这些是以前在对象的实现中直接分配的对象。</li><li id="c4b7" class="ls lt hh iy b iz mb jc mc jf md jj me jn mf jr lx ly lz ma bi translated">这些是Cocoa提供的单例，可以直接从单例中访问。这适用于像[NSFileManager defaultManager]这样的单例，在这种情况下，可以合理地期望在您的生产应用程序中只使用一个实例。下面有更多关于系统单件的内容。</li></ul><p id="d7bc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的赛车的类便利初始化器应该是这样的:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="f4eb" class="lk kf hh lg b fi ll lm l ln lo">+ (<strong class="lg hi">instancetype</strong>)<strong class="lg hi">raceCarWithPitRadioFrequency:</strong>(RCRadioFrequency <strong class="lg hi">*</strong>)frequency;<br/>{<br/>   RCEngine <strong class="lg hi">*</strong>engine <strong class="lg hi">=</strong> [[RCEngine alloc] init];<br/>   RCTransmission <strong class="lg hi">*</strong>transmission <strong class="lg hi">=</strong> [[RCTransmission alloc] init];</span><span id="fc0e" class="lk kf hh lg b fi mg lm l ln lo">   RCWheel <strong class="lg hi">*</strong>(<strong class="lg hi">^</strong>wheelFactory)() <strong class="lg hi">=</strong> <strong class="lg hi">^</strong>{<br/>      <strong class="lg hi">return</strong> [[RCWheel alloc] init];<br/>   };</span><span id="fb18" class="lk kf hh lg b fi mg lm l ln lo">   <strong class="lg hi">return</strong> [[self alloc] initWithEngine:engine <br/>                          transmission:transmission <br/>                     pitRadioFrequency:frequency <br/>                          wheelFactory:wheelFactory];<br/>}</span></pre><p id="89d0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你的类便利初始化器应该放在它感觉最合适的地方。一个常用的(和可重用的)配置将存在于相同的。m文件作为对象，而Foo对象专用的配置应该位于@ interface RaceCar(Foo configuration)类别中，并命名为类似fooRaceCar的名称。</p><h1 id="0d15" class="ke kf hh bd kg kh ki kj kk kl km kn ko in lp io kq iq lq ir ks it lr iu ku kv bi translated">系统单例</h1><p id="7306" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">对于Cocoa中的许多对象，只有一个实例存在。示例包括[ui application shared application]、[NSFileManager defaultManager]、[nsuser defaults standardUserDefaults]和[UIDevice currentDevice]。如果一个对象依赖于这些对象中的一个，那么<strong class="iy hi">它应该作为初始化参数</strong>被包含。即使在您的产品代码中可能只有一个实例，您的测试也可能想要模拟出那个实例，或者为每个测试创建一个实例，以避免测试相互依赖。</p><p id="7910" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">建议您避免在自己的代码中创建全局引用的单例，而是在第一次需要时创建一个对象的单个实例，并将其注入到依赖它的所有对象中。</p><h1 id="fad2" class="ke kf hh bd kg kh ki kj kk kl km kn ko in lp io kq iq lq ir ks it lr iu ku kv bi translated">不可修改的构造函数</h1><p id="a724" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">偶尔会有这样的情况，一个类的初始化器/构造器不能被改变或者不能被直接调用。在这些情况下，您应该使用setter注入。例如:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="2cfb" class="lk kf hh lg b fi ll lm l ln lo"><em class="js">// An example where we can't directly call the the initializer.</em><br/>RCRaceTrack <strong class="lg hi">*</strong>raceTrack <strong class="lg hi">=</strong> [objectYouCantModify createRaceTrack];</span><span id="c44c" class="lk kf hh lg b fi mg lm l ln lo"><em class="js">// We can still use properties to configure our race track.</em><br/>raceTrack.width <strong class="lg hi">=</strong> 10;<br/>raceTrack.numberOfHairpinTurns <strong class="lg hi">=</strong> 2;</span></pre><p id="3c76" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Setter注入允许您配置对象，但是它引入了额外的可变性，必须在对象的设计中进行测试和处理。幸运的是，有两种主要情况会导致初始化器不可访问或不可修改，这两种情况都是可以避免的。</p><h1 id="133d" class="ke kf hh bd kg kh ki kj kk kl km kn ko in lp io kq iq lq ir ks it lr iu ku kv bi translated">班级注册</h1><p id="7ef6" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">“类注册”工厂模式的使用意味着对象不能修改它们的初始化器。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="7677" class="lk kf hh lg b fi ll lm l ln lo">NSArray <strong class="lg hi">*</strong>raceCarClasses <strong class="lg hi">=</strong> @[<br/>   [RCFastRaceCar <strong class="lg hi">class</strong>],<br/>   [RCSlowRaceCar <strong class="lg hi">class</strong>],<br/>];</span><span id="3b7e" class="lk kf hh lg b fi mg lm l ln lo">NSMutableArray <strong class="lg hi">*</strong>raceCars <strong class="lg hi">=</strong> [[NSMutableArray alloc] init];<br/><strong class="lg hi">for</strong> (<strong class="lg hi">Class</strong> raceCarClass <strong class="lg hi">in</strong> raceCarClasses) {<br/>   <em class="js">// All race cars must have the same initializer ("init" in this case).</em><br/>   <em class="js">// This means we can't customize different subclasses in different ways.</em><br/>   [raceCars addObject:[[raceCarClass alloc] init]];<br/>}</span></pre><p id="3052" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个简单的替代方法是使用工厂块而不是类来声明你的列表。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="d863" class="lk kf hh lg b fi ll lm l ln lo"><strong class="lg hi">typedef</strong> RCRaceCar <strong class="lg hi">*</strong>(<strong class="lg hi">^</strong>RCRaceCarFactory)();</span><span id="513d" class="lk kf hh lg b fi mg lm l ln lo">NSArray <strong class="lg hi">*</strong>raceCarFactories <strong class="lg hi">=</strong> @[<br/>   <strong class="lg hi">^</strong>{ <strong class="lg hi">return</strong> [[RCFastRaceCar alloc] initWithTopSpeed:200]; },<br/>   <strong class="lg hi">^</strong>{ <strong class="lg hi">return</strong> [[RCSlowRaceCar alloc] initWithLeatherPlushiness:11]; }<br/>];</span><span id="a410" class="lk kf hh lg b fi mg lm l ln lo">NSMutableArray <strong class="lg hi">*</strong>raceCars <strong class="lg hi">=</strong> [[NSMutableArray alloc] init];<br/><strong class="lg hi">for</strong> (RCRaceCarFactory raceCarFactory <strong class="lg hi">in</strong> raceCarFactories) {<br/>   <em class="js">// We now no longer care which initializer is being called.</em><br/>   [raceCars addObject:raceCarFactory()];<br/>}</span></pre><h1 id="7717" class="ke kf hh bd kg kh ki kj kk kl km kn ko in lp io kq iq lq ir ks it lr iu ku kv bi translated">脚本</h1><p id="093c" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">故事板提供了一种布局用户界面的便捷方式，但是当涉及到依赖注入时，它们也会带来问题。特别是，在故事板中实例化初始视图控制器不允许您选择调用哪个初始化器。类似地，当遵循故事板中定义的序列时，目标视图控制器会为您实例化，而不会让您指定初始化器。</p><p id="9fe8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里的解决方案是避免使用故事板。这似乎是一个极端的解决方案，但是我们发现故事板在大型团队中还有其他问题。此外，没有必要失去故事板的大部分好处。xib提供了故事板提供的所有好处，除了segues，但是仍然允许你定制初始化器。</p><h1 id="299b" class="ke kf hh bd kg kh ki kj kk kl km kn ko in lp io kq iq lq ir ks it lr iu ku kv bi translated">公共与私有</h1><p id="2b51" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">依赖注入鼓励你在公共接口中公开更多的对象。如上所述，这有很多好处。但是在构建框架时，它会极大地膨胀您的公共API。在应用依赖注入之前，公共对象A可能已经使用了私有对象B(私有对象B又使用了私有对象C)，但是对象B和C从未暴露在框架之外。通过依赖注入，对象A在其公共初始化器中有对象B，而对象B又使对象C在其初始化器中成为公共的。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="f9de" class="lk kf hh lg b fi ll lm l ln lo"><em class="js">// In public ObjectA.h.</em><br/><strong class="lg hi">@interface</strong> <strong class="lg hi">ObjectA</strong><br/><em class="js">// Because the initializer uses a reference to ObjectB we need to</em><br/><em class="js">// make the Object B header public where we wouldn't have before.</em><br/>- (<strong class="lg hi">instancetype</strong>)<strong class="lg hi">initWithObjectB:</strong>(ObjectB <strong class="lg hi">*</strong>)objectB;<br/><strong class="lg hi">@end</strong></span><span id="97f1" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@interface</strong> <strong class="lg hi">ObjectB</strong><br/><em class="js">// Same here: we need to expose ObjectC.h.</em><br/>- (<strong class="lg hi">instancetype</strong>)<strong class="lg hi">initWithObjectC:</strong>(ObjectC <strong class="lg hi">*</strong>)objectC;<br/><strong class="lg hi">@end</strong></span><span id="a612" class="lk kf hh lg b fi mg lm l ln lo"><strong class="lg hi">@interface</strong> <strong class="lg hi">ObjectC</strong><br/>- (<strong class="lg hi">instancetype</strong>)<strong class="lg hi">init</strong>;<br/><strong class="lg hi">@end</strong></span></pre><p id="d9f7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对象B和对象C是实现细节，您不希望框架消费者必须担心它们。我们可以通过协议来解决这个问题。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="f27c" class="lk kf hh lg b fi ll lm l ln lo"><strong class="lg hi">@interface</strong> <strong class="lg hi">ObjectA</strong><br/>- (<strong class="lg hi">instancetype</strong>)<strong class="lg hi">initWithObjectB:</strong>(<strong class="lg hi">id</strong> <strong class="lg hi">&lt;</strong>ObjectB<strong class="lg hi">&gt;</strong>)objectB;<br/><strong class="lg hi">@end</strong></span><span id="6f20" class="lk kf hh lg b fi mg lm l ln lo"><em class="js">// This protocol exposes only the parts of the original ObjectB that</em><br/><em class="js">// are needed by ObjectA. We're not creating a hard dependency on</em><br/><em class="js">// our concrete ObjectB (or ObjectC) implementation.</em><br/><strong class="lg hi">@protocol</strong> <strong class="lg hi">ObjectB</strong><br/>- (<strong class="lg hi">void</strong>)<strong class="lg hi">methodNeededByObjectA</strong>;<br/><strong class="lg hi">@end</strong></span></pre><h1 id="e71f" class="ke kf hh bd kg kh ki kj kk kl km kn ko in lp io kq iq lq ir ks it lr iu ku kv bi translated">关闭</h1><p id="2dfa" class="pw-post-body-paragraph iw ix hh iy b iz kw ii jb jc kx il je jf ky jh ji jj kz jl jm jn la jp jq jr ha bi translated">依赖注入是Objective-C(以及Swift的扩展)的天然选择。如果应用得当，它会让你的代码易于阅读、易于测试和维护。</p></div><div class="ab cl mh mi go mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ha hb hc hd he"><div class="lb lc ld le fd mo"><a href="https://twitter.com/firetweet" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab dw"><div class="mq ab mr cl cj ms"><h2 class="bd hi fi z dy mt ea eb mu ed ef hg bi translated">埃里克·费尔斯通(@firetweet) |推特</h2><div class="mv l"><h3 class="bd b fi z dy mt ea eb mu ed ef dx translated">埃里克·费尔斯通的最新推文(@firetweet):“祝贺@segiddins和@CocoaPods团队达到1.0…</h3></div><div class="mw l"><p class="bd b fp z dy mt ea eb mu ed ef dx translated">twitter.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc nd mo"/></div></div></a></div></div></div>    
</body>
</html>