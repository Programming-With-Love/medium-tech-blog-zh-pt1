<html>
<head>
<title>Ember and Yarn Workspaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">灰烬和纱线工作空间</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/ember-and-yarn-workspaces-fca69dc5d44a?source=collection_archive---------2-----------------------#2018-03-28">https://medium.com/square-corner-blog/ember-and-yarn-workspaces-fca69dc5d44a?source=collection_archive---------2-----------------------#2018-03-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie"><p id="8c5c" class="if ig hh bd ih ii ij ik il im in io dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们在https://developer.squareup.com/blog<a class="ae ip" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">的新家</a></p></blockquote><p id="9f9f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm io ha bi translated">Square有几个Ember web应用，Square Dashboard是最老最大的。最初的commit被丢进了历史的垃圾箱，但我被告知它始于2011年，是Sproutcore 2.0(Ember的前身)上的一个简单的销售报告应用程序。今天，它是一个Ember 3.0应用程序，有报告、客户管理、发票、员工工时记录卡等等。几乎每个月都有100名Square工程师接触代码库，我们每天都进行生产部署。</p><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es jn"><img src="../Images/52108e501b41f0230ec6abb400bb6c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Fm_W0hJE0mwnnOd_9uVoQ.png"/></div></div><figcaption class="jz ka et er es kb kc bd b be z dx">Square Dashboard circa 2012 versus Square Dashboard in the near future</figcaption></figure><p id="0c70" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">将如此多的功能构建到一个应用程序中，使我们能够快速开发新产品和修复错误。直到去年年底，我们没有其他选择——我们使用的是定制的基于Rails的构建管道，不理解Ember应用程序。但是应用程序的规模是一个沉重的负担:构建和CI时间非常慢，并且代码库对新的和经验丰富的开发人员来说都是令人生畏的。</p><p id="bb81" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">我们在12月1日完成了向Ember CLI的迁移，并且我们开始将monolith分解成Ember特有的NPM包，称为<a class="ae ip" href="https://ember-cli.com/extending/#developing-addons-and-blueprints" rel="noopener ugc nofollow" target="_blank">插件</a>和<a class="ae ip" href="http://ember-engines.com" rel="noopener ugc nofollow" target="_blank">引擎</a>，原因有二:</p><ul class=""><li id="59f5" class="ki kj hh is b it kd ix ke jb kk jf kl jj km io kn ko kp kq bi translated">插件和引擎允许我们模块化代码库，并在逻辑域之间创建边界，使所有权更加清晰，并允许我们在团队之间共享代码，而不会创建依赖关系的老鼠窝。</li><li id="bfce" class="ki kj hh is b it kr ix ks jb kt jf ku jj kv io kn ko kp kq bi translated">引擎支持<a class="ae ip" href="http://ember-engines.com/guide/lazy-loading" rel="noopener ugc nofollow" target="_blank">延迟加载代码</a>，这意味着我们的商家不会下载应用程序的一部分代码，直到他们需要它。</li></ul><p id="90ad" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">然而，分解应用程序并不是万能的。如果我们简单地将代码从应用程序转移到单独的NPM包中，如下所示:</p><figure class="jo jp jq jr fd js er es paragraph-image"><div class="er es kw"><img src="../Images/444fe4ccafda995ec0496ff776dd2bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*ENRyyFbIh7eRzc5R6mFavw.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx">A working directory with three folders: “dashboard”, “sales-reports-engine”, and ”shared-ui-addon”. The latter could contain components and utilities used by both the app and the engine.</figcaption></figure><p id="9010" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">…将附件和引擎安装到仪表板上，如下所示:</p><pre class="jo jp jq jr fd kx ky kz la aw lb bi"><span id="fd09" class="lc ld hh ky b fi le lf l lg lh">{<br/>  "name": "dashboard",<br/>  "devDependencies": {<br/>    "sales-reports-engine": "^1.0.0",<br/>    "shared-ui-addon": "^1.0.0"<br/>  }<br/>}</span></pre><p id="857c" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">…跨包同时开发代码会非常痛苦。默认情况下，NPM和Yarn会在包之间复制文件。如果你在<code class="du lj lk ll ky b">sales-reports-engine</code>中改变了一个文件，并想在<code class="du lj lk ll ky b">dashboard</code>中看到它的反映，你必须完全重新安装引擎包。</p><figure class="jo jp jq jr fd js er es paragraph-image"><div class="er es lm"><img src="../Images/448e8779eb1335ea7d1ad57f033c9c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/1*3vUUzX8BiIOxejlo8PZOdA.gif"/></div><figcaption class="jz ka et er es kb kc bd b be z dx">#headdesk (from <a class="ae ip" href="https://giphy.com/gifs/fml-headdesk-frustrated-cvHSpGveXf5rG" rel="noopener ugc nofollow" target="_blank">https://giphy.com/gifs/fml-headdesk-frustrated-cvHSpGveXf5rG</a>)</figcaption></figure><p id="628e" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">我们想要的是在不妨碍每个人的开发体验的情况下拆分应用程序的方法——特别是当我们鼓励工程师将大部分时间花在开发插件和引擎上，而不是添加到主应用程序上。</p><h1 id="a3c8" class="ln ld hh bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">npm链接</h1><p id="1a55" class="pw-post-body-paragraph iq ir hh is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm io ha bi translated">一个解决方案是使用<a class="ae ip" href="https://docs.npmjs.com/cli/link" rel="noopener ugc nofollow" target="_blank"> npm link </a>，一个将包符号链接在一起的工具。做着完全一样的事情。)使用它相当简单:</p><pre class="jo jp jq jr fd kx ky kz la aw lb bi"><span id="8e7a" class="lc ld hh ky b fi le lf l lg lh"><strong class="ky hi">&gt;</strong> cd sales-reports-engine<br/><strong class="ky hi">&gt;</strong> npm link</span><span id="f90b" class="lc ld hh ky b fi mp lf l lg lh"><strong class="ky hi">success</strong> Registered "sales-reports-engine".<br/><strong class="ky hi">info</strong> You can now run `npm link "sales-reports-engine"` in the projects where you want to use this module and it will be used instead.</span><span id="8c32" class="lc ld hh ky b fi mp lf l lg lh"><strong class="ky hi">&gt;</strong> cd ../dashboard<br/><strong class="ky hi">&gt;</strong> npm link sales-report-engine</span><span id="73b3" class="lc ld hh ky b fi mp lf l lg lh"><strong class="ky hi">success</strong> Using linked module for "sales-reports-engine".</span></pre><p id="01b7" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">运行这些命令后，您会在<code class="du lj lk ll ky b">dashboard</code>包的<code class="du lj lk ll ky b">node_modules</code>文件夹中看到一个指向引擎文件夹的符号链接:</p><figure class="jo jp jq jr fd js er es paragraph-image"><div class="er es mq"><img src="../Images/daab8d381d80fb5a1c4007af7d92bd38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*2rBBy0z8bdQYJTWCCGES4w.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx">The “dashboard” package now has a symlink to the “sales-reports-engine” code in its node_modules folder.</figcaption></figure><p id="535c" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">这种结构允许Dashboard在开发过程中直接从您的工作副本<code class="du lj lk ll ky b">sales-reports-engine</code>中访问文件。</p><p id="3c2c" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">但是，如果您想一次看到所有三个包的变化，这是不够的。你真正想要的是:</p><figure class="jo jp jq jr fd js er es paragraph-image"><div class="er es mq"><img src="../Images/2d86788831790dff56d6eca228738e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*Akbn7jfIwMqkCD92Y9X35w.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx">Tying everything together requires symlinks all over the place.</figcaption></figure><p id="9ca6" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">这种安排需要大量的<code class="du lj lk ll ky b">npm link</code>命令来构建，尤其是当我们有三个以上的包时。就我个人而言，我从来没有可靠地让<code class="du lj lk ll ky b">npm link</code>工作——这个工具工作正常，但是我不停地交换命令或者忘记我是否已经运行了它们。</p><p id="b9a3" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">还好有更好的办法！🙌</p><h1 id="f46e" class="ln ld hh bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">纱线工作空间</h1><p id="b5e3" class="pw-post-body-paragraph iq ir hh is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm io ha bi translated">对工作空间<a class="ae ip" href="https://yarnpkg.com/blog/2017/08/02/introducing-workspaces/" rel="noopener ugc nofollow" target="_blank">的支持于2017年8月在Yarn </a>中推出，我们发现自版本1.3.2以来，该功能稳定且易于使用。从Ember CLI 3.1开始(现在是测试版)，工作区和Ember是最好的朋友！</p><p id="a4ea" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">要设置好一切，您需要将您的包移动到一个“工作空间根目录”中，并有自己的<code class="du lj lk ll ky b">package.json</code>文件:</p><figure class="jo jp jq jr fd js er es paragraph-image"><div class="er es mr"><img src="../Images/b1bda9519f9c448f2496de10d952fa02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*hvrZkrdjsZMeLaSS-ecpjA.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx">The “packages” folder could be named anything, but it’s a common folder name in other monorepos like Babel and React.</figcaption></figure><p id="f655" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">工作区根目录<code class="du lj lk ll ky b">package.json</code>的内容非常简单:</p><pre class="jo jp jq jr fd kx ky kz la aw lb bi"><span id="bfca" class="lc ld hh ky b fi le lf l lg lh">{<br/>  "private": true,<br/>  "workspaces": [<br/>    "packages/*"<br/>  ]<br/>}</span></pre><p id="36d3" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">现在，当您在工作区根目录中的任何地方运行<code class="du lj lk ll ky b">yarn install</code>时，Yarn将发现包之间的依赖关系，并将符号链接提升到顶层<code class="du lj lk ll ky b">node_modules</code>文件夹:</p><figure class="jo jp jq jr fd js er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es mq"><img src="../Images/653f10b77942da4296034d4dd025f9ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*FwQLTzn8dqay5-h48B7oIA.png"/></div></div><figcaption class="jz ka et er es kb kc bd b be z dx">Yarn workspaces organize all the necessary symlinks in a top-level node_modules folder.</figcaption></figure><p id="7633" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated"><strong class="is hi">没有第二步！大多数在Dashboard上工作的工程师可能没有意识到这正在发生。</strong></p><p id="2603" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated"><em class="li">如果你想知道更多关于包如何在顶层</em> <code class="du lj lk ll ky b"><em class="li">node_modules</em></code> <em class="li">文件夹中找到它们的依赖关系，节点文档</em> <a class="ae ip" href="https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders" rel="noopener ugc nofollow" target="_blank"> <em class="li">解释查找算法</em> </a> <em class="li">。</em></p><h2 id="cc90" class="lc ld hh bd lo ms mt mu ls mv mw mx lw jb my mz ma jf na nb me jj nc nd mi ne bi translated">回购插件呢？</h2><p id="c5ee" class="pw-post-body-paragraph iq ir hh is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm io ha bi translated">Ember CLI最初的同步开发插件的解决方案是<a class="ae ip" href="https://ember-cli.com/extending/#in-repo-addons" rel="noopener ugc nofollow" target="_blank"> in-repo插件</a>，它从来不需要任何<code class="du lj lk ll ky b">npm link</code>诡计。我们有几个不使用它们的理由:</p><ul class=""><li id="f94f" class="ki kj hh is b it kd ix ke jb kk jf kl jj km io kn ko kp kq bi translated">In-repo插件不能有自己的测试套件。测试文件进入主机应用程序。我们希望我们的测试像我们的应用程序代码一样解耦。</li><li id="9d96" class="ki kj hh is b it kr ix ks jb kt jf ku jj kv io kn ko kp kq bi translated">我们希望能够发布某些插件，供Square上的其他Ember应用程序使用。In-repo插件不是真正的NPM包，所以它们不能自己发布。</li><li id="f6b8" class="ki kj hh is b it kr ix ks jb kt jf ku jj kv io kn ko kp kq bi translated">类似地，<strong class="is hi">如果对他们的产品有意义的话，我们希望允许团队在未来脱离monorepo </strong>。一旦他们的代码在一个“真正的”插件中，有了自己的依赖项和测试套件，他们就可以毫不费力地将文件转移到另一个存储库中。</li></ul><p id="1113" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated"><em class="li">注意:命名是困难的——我们的“真正的”插件在同一个git存储库中，所以它们不是“in-repo”插件吗？</em>🤯为了区分这两种模式，我们在Yarn工作空间中使用术语“monorepo addon”来表示插件。</p><h2 id="a3e2" class="lc ld hh bd lo ms mt mu ls mv mw mx lw jb my mz ma jf na nb me jj nc nd mi ne bi translated">有什么问题吗？</h2><p id="bb92" class="pw-post-body-paragraph iq ir hh is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm io ha bi translated">不尽然！你必须在<strong class="is hi"> Ember CLI ≥ 2.18 </strong>上才能使用Yarn workspaces，Ember才能工作(Edward Faulkner的commit <a class="ae ip" href="https://github.com/ember-cli/ember-cli/commit/9a35faf169d46f6d428043de132d4ff6b2a54709#diff-392bb207fea8bcbeb4a084bb445f7cc7" rel="noopener ugc nofollow" target="_blank">对原因有很好的解释</a>)。</p><p id="ce09" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">如果你使用Ember CLI ≤ 3.1，像<code class="du lj lk ll ky b">ember install</code>这样的命令将默认使用NPM，但这可以通过添加<code class="du lj lk ll ky b">--yarn</code>标志来弥补:</p><pre class="jo jp jq jr fd kx ky kz la aw lb bi"><span id="1658" class="lc ld hh ky b fi le lf l lg lh">ember install ember-animate --yarn</span></pre><p id="e675" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">(我们自己的Timothy Park <a class="ae ip" href="https://github.com/ember-cli/ember-cli/pull/7492" rel="noopener ugc nofollow" target="_blank">在3.1中发布了补丁</a>来解决这个问题！)</p><h2 id="1716" class="lc ld hh bd lo ms mt mu ls mv mw mx lw jb my mz ma jf na nb me jj nc nd mi ne bi translated">迁移到Yarn工作空间</h2><p id="d8d3" class="pw-post-body-paragraph iq ir hh is b it mk iv iw ix ml iz ja jb mm jd je jf mn jh ji jj mo jl jm io ha bi translated">如果你遵循以下三个步骤，你会非常幸运:</p><ul class=""><li id="9e05" class="ki kj hh is b it kd ix ke jb kk jf kl jj km io kn ko kp kq bi translated">将您现有的<code class="du lj lk ll ky b">yarn.lock</code>文件从原来的应用程序文件夹移动到Yarn workspace根目录。</li><li id="868f" class="ki kj hh is b it kr ix ks jb kt jf ku jj kv io kn ko kp kq bi translated">按照<a class="ae ip" href="https://yarnpkg.com/en/docs/workspaces#toc-how-to-use-it" rel="noopener ugc nofollow" target="_blank">纱线文档</a>中的描述，在锁文件旁边创建新的<code class="du lj lk ll ky b">package.json</code>文件。</li><li id="f5bf" class="ki kj hh is b it kr ix ks jb kt jf ku jj kv io kn ko kp kq bi translated">跑<code class="du lj lk ll ky b">yarn install</code>。</li></ul><p id="7d8e" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">如果你不移动原来的锁文件，Yarn将创建一个新的锁文件，并升级你所有的传递依赖。这可能会导致意外的破损。</p></div><div class="ab cl nf ng go nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ha hb hc hd he"><p id="15a6" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated">将我们的应用程序切换到Yarn工作空间是我们在现代化代码库的过程中做出的最具影响力的决定之一。不再是一个巨大的应用程序，我们现在有了一个(稍微)更小的应用程序和十几个组织良好的插件和引擎，使用起来更好。<strong class="is hi">如果你有一个整体的应用程序，可能会在它自身的重量下开始弯曲，我强烈建议试试Yarn workspaces。</strong></p></div><div class="ab cl nf ng go nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ha hb hc hd he"><p id="23fe" class="pw-post-body-paragraph iq ir hh is b it kd iv iw ix ke iz ja jb kf jd je jf kg jh ji jj kh jl jm io ha bi translated"><em class="li">又及一个额外的亲提示:</em> <code class="du lj lk ll ky b"><em class="li">yarn upgrade-interactive</em></code> <em class="li">和</em> <code class="du lj lk ll ky b"><em class="li">yarn outdated</em></code> <em class="li">工作</em> <strong class="is hi"> <em class="li">异想天开</em> </strong> <em class="li">在一个纱线工作区内。</em>💯</p></div></div>    
</body>
</html>