<html>
<head>
<title>Introducing esprint: a fast, open source eslint CLI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">esprint简介:快速、开源的eslint CLI</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/introducing-esprint-a-fast-open-source-eslint-cli-19a470cd1c7d?source=collection_archive---------5-----------------------#2017-06-30">https://medium.com/pinterest-engineering/introducing-esprint-a-fast-open-source-eslint-cli-19a470cd1c7d?source=collection_archive---------5-----------------------#2017-06-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6c7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Arthur Lee &amp; Allen Kleiner | Pinterest工程师，核心经验</p><p id="f4b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Pinterest，我们非常关心开发人员的工作效率。我们希望让工程师能够在保持高代码质量的同时快速行动。我们的网络代码库包含4000多个JavaScript文件，每个文件都使用<a class="ae jc" href="http://eslint.org" rel="noopener ugc nofollow" target="_blank"> eslint </a>以及Pinterest和<a class="ae jc" href="https://github.com/airbnb/javascript" rel="noopener ugc nofollow" target="_blank"> Airbnb的JavaScript lint规则组合</a>进行了严格的<a class="ae jc" href="https://en.wikipedia.org/wiki/Lint_(software)" rel="noopener ugc nofollow" target="_blank">lint</a>。我们相信一套强大而全面的规则会鼓励我们的工程师编写出一致可读和可维护的代码，而不会陷入语法陷阱。然而，随着代码库和大量规则的增长，lint times很快成为我们构建中最慢的路径。这开始减慢开发过程，所以我们构建了esprint，这是一个针对CI和开发环境的快速林挺解决方案，我们今天<a class="ae jc" href="https://github.com/pinterest/esprint" rel="noopener ugc nofollow" target="_blank">开源了这个解决方案</a>。</p><h2 id="a552" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated"><strong class="ak">多线程eslint </strong></h2><p id="afdc" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">我们发现的最大瓶颈是eslint运行在单线程上。我们使用<a class="ae jc" href="https://github.com/rvagg/node-worker-farm" rel="noopener ugc nofollow" target="_blank"> worker-farm </a>包在多个内核上并行运行eslint。然后，我们将需要林挺的文件列表分发给多个工作进程。这给我们带来了立竿见影的效果，在一台8核机器上加速了约3倍。考虑到在node中启动工作进程所涉及的开销，这是合理的。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/a33f41e6230d781926800671da7fdf12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AK3YcS5rfHOvyerW."/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx"><em class="kt">Lint times: eslint, single vs. multi-threaded on an 8-core machine</em></figcaption></figure><p id="1d95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个显著的改进，尤其是对于我们的持续集成(CI)工作。然而，在我们的开发环境中，每次文件发生变化时，我们都会运行eslint，这样工程师就可以定期得到关于他们代码状态的反馈。每次文件改变时运行一个消耗CPU的进程会太慢，同时也可能减慢更重要的进程，比如webpack。很明显，我们需要一个更好的开发环境解决方案。</p><h2 id="d5c8" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated"><strong class="ak">灵感来自流量</strong></h2><p id="d8a9" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">Flow是脸书的JavaScript类型检查器。虽然flow不像eslint那样是样式检查器，但它也需要读取许多文件，处理它们并返回结果。Flow很好地做到了这一点，它在初始运行期间并行执行大量工作，并保持后台服务器运行以缓存结果，以便后续运行几乎是即时的。我们从flow的架构中获得了灵感，构建了一个后台服务器，将lint结果缓存在内存中，并观察源文件的变化。</p><h2 id="5e40" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated"><strong class="ak">介绍esprint </strong></h2><p id="df13" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">我们将新的eslint cli <strong class="ig hi">称为esprint </strong>(读作E-S-sprint)。它使用一个多线程的lint runner来lint文件，并使用脸书的<a class="ae jc" href="https://facebook.github.io/watchman/" rel="noopener ugc nofollow" target="_blank"> watchman </a>启动一个后台服务器来监视源文件。每当文件发生变化时，watchman就会发现变化，而esprint会先发制人地将这些变化的文件进行lints处理。运行<code class="du ku kv kw kx b">esprint</code>命令只是向后台服务器查询最新的lint状态。由于林挺每个额外的文件需要很少的时间，运行时的esprint是在秒的数量级，除了最初的运行。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ky"><img src="../Images/f475d28d9f6d15bc1abc5532b46c2a41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WPmjrZNsHYdZNBaPJuy0iQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx"><em class="kt">esprint architecture</em></figcaption></figure><p id="b452" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们有一个快速的林挺解决方案，既适合于CI环境，也适合于开发环境。展望未来，我们计划使用重用eslint引擎实例等技术来提高后台服务器的可靠性和性能。你可以在GitHub 上找到测试版的代码。我们欢迎任何问题和拉请求！</p><p id="0836" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">鸣谢:感谢核心体验团队和我们的网络工程师的测试和反馈。</p></div></div>    
</body>
</html>