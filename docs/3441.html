<html>
<head>
<title>Unraveling the Web Components!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解开Web组件！</h1>
<blockquote>原文：<a href="https://medium.com/globant/unraveling-the-web-components-5df1df4ec605?source=collection_archive---------2-----------------------#2020-07-24">https://medium.com/globant/unraveling-the-web-components-5df1df4ec605?source=collection_archive---------2-----------------------#2020-07-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1a5e28044f622577a9cbf388e15f7e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4kXXRXiR4eH67Wag"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@filisantillan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Filiberto Santillán</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1c42" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> <em class="js">【代码重用】</em> </strong>，当你开始你的项目时，你决定坚持这个术语。后来，当你意识到我们正在为Angular重写组件，我们是从Rails移植过来的，并且可能会过渡到React时，它开始慢慢消失。今天，我们多次为每个平台重新构建相同的UI。这当然会导致更多的技术和设计债务。还有，这是对我们时间的巨大浪费。</p><p id="85d0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">那么，Web组件来拯救我们了！他们将你与技术革新隔离开来。它们帮助我们构建一个设计系统，以便在不同的项目/应用中重用实现，而不管它们是在什么框架中编写的。</p><p id="d01e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">听起来很棒，不是吗？让我们再深入一点。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="cb81" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">什么是web组件？</strong></h1><blockquote class="ky kz la"><p id="0228" class="iu iv js iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated">Web组件是可重用的UI构建块，封装了所有的HTML、CSS和Javascript。它们可以跨现代浏览器工作，可以与任何支持HTML的JavaScript库或框架一起使用。</p></blockquote><p id="1153" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Web组件与我们想要构建可重用的定制元素的用例相关。</p><p id="e1a4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">设计系统可以包括UI组件、它们的文档和代码片段，以方便开发人员在项目中使用它们。</p><h2 id="f6c8" class="le kb hh bd kc lf lg lh kg li lj lk kk jf ll lm ko jj ln lo ks jn lp lq kw lr bi translated">越来越有趣了！让我们检查一下Web组件的规范</h2><p id="da47" class="pw-post-body-paragraph iu iv hh iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr ha bi translated">Web组件基于4种规范</p><ul class=""><li id="ecce" class="lx ly hh iw b ix iy jb jc jf lz jj ma jn mb jr mc md me mf bi translated">自定义元素</li><li id="fe31" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated">阴影DOM</li><li id="4f14" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated">ES模块</li><li id="5efb" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated">HTML模板</li></ul><p id="25d6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们深入探讨这些问题:</p><p id="ce41" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">自定义元素</strong></p><p id="560a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" href="https://w3c.github.io/webcomponents/spec/custom/" rel="noopener ugc nofollow" target="_blank">自定义元素规范</a>为设计和使用新型DOM元素奠定了基础。这些是一组JavaScript APIs，帮助我们创建自己的HTML元素，并控制DOM及其行为。</p><p id="ca92" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">阴影DOM </strong></p><p id="19f1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该规范的目的是为组件创建一个私有范围。影子DOM的工作方式有点像iframe，内容从文档的其余部分中分离出来；然而，当我们创建一个影子根时，我们仍然对页面的这一部分有完全的控制权，但是范围是在一个上下文中。这就是我们所说的<strong class="iw hi">封装</strong>。</p><figure class="mm mn mo mp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/a1facef0a449cd30f74b4f9b3ea2d680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fo_dMBCr8e5j67E1"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Source: <a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM" rel="noopener ugc nofollow" target="_blank">MDN — Shadow DOM</a></figcaption></figure><figure class="mm mn mo mp fd ii er es paragraph-image"><div class="er es mq"><img src="../Images/449fac595f5dfc683a81b8d3ee40c484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*cpwpe5Wy1BXnJtL6"/></div></figure><p id="7975" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> ES模块</strong></p><p id="8886" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">ES模块规范以基于标准、模块化、高性能的方式定义了JS文档的包含和重用。</p><p id="f006" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">模板</strong></p><p id="a57b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个规范的目的是创建一个轻量级的DOM树。模板中定义的HTML标记本质上是惰性的。简而言之，模板内容在被激活之前不是DOM的一部分。定义模板的语法如下:</p><pre class="mm mn mo mp fd mr ms mt mu aw mv bi"><span id="4d00" class="le kb hh ms b fi mw mx l my mz">&lt;template&gt;<br/>   &lt;!-- HTML Markup goes here --&gt;<br/>&lt;/template&gt;</span></pre><h1 id="e130" class="ka kb hh bd kc kd na kf kg kh nb kj kk kl nc kn ko kp nd kr ks kt ne kv kw kx bi translated">自定义元素的生命周期挂钩</h1><p id="f299" class="pw-post-body-paragraph iu iv hh iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr ha bi translated">从一个自定义元素被创建到被销毁，中间会发生很多<strong class="iw hi"> <em class="js">【事情】</em> </strong>:</p><ul class=""><li id="afb1" class="lx ly hh iw b ix iy jb jc jf lz jj ma jn mb jr mc md me mf bi translated">元素被插入到DOM中</li><li id="b27b" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated">当一个UI事件被触发时，它被更新</li><li id="2f4d" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated">可以从DOM中删除一个元素</li></ul><p id="81e5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以上所有的都被称为元素的生命周期，我们可以用一些回调函数来挂钩它生命周期中的关键事件。这些回调函数可以用来操作我们自己的定制元素的行为。</p><figure class="mm mn mo mp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nf"><img src="../Images/22f17238ce45bdffb10510ddb5ce2716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E54TUx7fCd0WWNAM"/></div></div></figure><p id="e91c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">web组件中有以下生命周期挂钩:</p><p id="3c4b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> connectedCallback </strong></p><p id="51f3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们的自定义元素被添加到DOM时，这个函数将被调用。我们可以确定当这个方法被调用时，这个元素对DOM是可用的。</p><p id="fa1c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这意味着我们可以安全地设置属性、获取资源、运行设置代码或呈现模板。</p><p id="8eff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">采用了回调</strong></p><p id="1e52" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们的自定义元素被移动到一个新文档中时，这个函数将被调用。它只发生在我们处理iframes的时候。</p><p id="7ee9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">属性改变回调</strong></p><p id="9db0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们的自定义元素的属性发生了变化，比如属性被更改、添加或删除，那么这个特定的函数将被调用。</p><p id="36b9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">断开的回调</strong></p><p id="cac6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们的定制元素从DOM断开连接时，将调用这个函数，它是添加清理逻辑(在元素被销毁之前需要执行的代码)和释放资源的理想位置</p><figure class="mm mn mo mp fd ii"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="bf43" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们看看如何创建web组件。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="d0fe" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">是时候动手做一些代码了！</h1><p id="41b3" class="pw-post-body-paragraph iu iv hh iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr ha bi translated">我们将构建一个简单的自定义组件<strong class="iw hi">&lt;hello-word&gt;&lt;/hello-world&gt;</strong></p><p id="cbd0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">目前，浏览器不理解hello-world标签。当浏览器发现像hello-world这样的未知HTML标记时，它会将其呈现为一个内联元素，并继续呈现下一个元素。使用自定义元素API，我们可以告诉浏览器如何处理新的HTML标签。</p><p id="3102" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">自定义元素的功能是使用扩展HTMLElement的ES2015类定义的。扩展HTMLElement确保自定义元素继承整个DOM API，并意味着您添加到该类的任何属性/方法都成为元素的DOM接口的一部分。本质上，使用类为您的标记创建一个公共JavaScript API。</p><figure class="mm mn mo mp fd ii"><div class="bz dy l di"><div class="ng nh l"/></div></figure><p id="a603" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，我们正在创建一个hello world组件，它将添加</p><pre class="mm mn mo mp fd mr ms mt mu aw mv bi"><span id="64dc" class="le kb hh ms b fi mw mx l my mz">&lt;div&gt;Hello World&lt;/div&gt;</span></pre><p id="5204" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们添加了<hello-world>标签的内容。</hello-world></p><p id="390a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Web组件的基础是定制元素。<strong class="iw hi"> customElements </strong> API为我们提供了一个定义自定义HTML标签的路径，这些标签可以在任何包含定义类的文档中使用。</p><p id="90d4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本质上，自定义元素由两部分组成:一个标记名和一个扩展内置HTMLElement类的类。我们的自定义元素的最基本版本如下所示:</p><pre class="mm mn mo mp fd mr ms mt mu aw mv bi"><span id="6308" class="le kb hh ms b fi mw mx l my mz">customElements.define('hello-world', HelloWorld)</span></pre><p id="e73c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们的定制元素(<hello-world>)被定义，浏览器被指示呈现包含在调用定制元素的HTML模板中的内容。</hello-world></p><h1 id="3d03" class="ka kb hh bd kc kd na kf kg kh nb kj kk kl nc kn ko kp nd kr ks kt ne kv kw kx bi translated"><strong class="ak">关闭思想！</strong></h1><p id="5932" class="pw-post-body-paragraph iu iv hh iw b ix ls iz ja jb lt jd je jf lu jh ji jj lv jl jm jn lw jp jq jr ha bi translated">人生苦短，不能重写组件！</p><p id="de6b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Web组件看起来很容易理解和实现，但却非常强大。一定要试一试。我相信你会日复一日地使用它们。</p><p id="1ffe" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以在这里找到我的另一篇用Angular <a class="ae it" rel="noopener" href="/globant/bringing-web-components-into-play-with-ng-d9b1042af267">编写web组件的文章</a>。</p></div></div>    
</body>
</html>