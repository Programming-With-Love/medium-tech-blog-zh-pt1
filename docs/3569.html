<html>
<head>
<title>The JS Bifrost — Keep the ‘this’ at peace!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS彩虹桥——让“这个”保持平静！</h1>
<blockquote>原文：<a href="https://medium.com/globant/the-js-bifrost-keep-the-this-at-peace-d87011b5a685?source=collection_archive---------1-----------------------#2020-12-07">https://medium.com/globant/the-js-bifrost-keep-the-this-at-peace-d87011b5a685?source=collection_archive---------1-----------------------#2020-12-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="542b" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">揭开令人困惑的关键字<code class="du iw ix iy iz b">this</code>以及调用、应用和绑定方法的用法的神秘面纱。</h2></div><p id="b79d" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">欢迎回到“JS Bifrost ”,这是您通向神级JavaScript的坚实基础的道路。这是本系列的下一篇文章。我们这次的重点是— <code class="du iw ix iy iz b">.call</code>、<code class="du iw ix iy iz b">.apply</code>、<code class="du iw ix iy iz b">.bind</code>方法。</p><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es jw"><img src="../Images/2378b2813eaf8c9ff0374bdcdd372d93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0DFzqUbzPH9-C18kcWM0g.png"/></div></div></figure><p id="edca" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><code class="du iw ix iy iz b">this</code>关键字是JavaScript中使用最广泛也最令人困惑的关键字之一。在这篇文章中，我将通过各种方法来稳定“这个”。这也是大多数JS面试的精髓面试题目。是的，没错，这三种方法，即<code class="du iw ix iy iz b">call</code>、<code class="du iw ix iy iz b">apply</code>和<code class="du iw ix iy iz b">bind</code>在几乎所有的web开发人员面试中都被频繁地问到，所以如果你是一名JavaScript开发人员，就不能忽视对它们及其用例的理解。</p><p id="c91f" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><em class="ki">在我们谈论方法本身之前，让我们先花点时间来理解一下</em> <code class="du iw ix iy iz b">this</code> <em class="ki">关键字在JS中是如何工作的，因为理解</em> <code class="du iw ix iy iz b">this</code> <em class="ki">关键字是如何工作的对于理解上述方法至关重要。</em></p><h1 id="08dc" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated"><strong class="ak">本</strong>关键字概述</h1><figure class="jx jy jz ka fd kb"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="bd88" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">现在，如果您熟悉JS中的<code class="du iw ix iy iz b">this</code>关键字的工作方式，请随意跳过这一节，进入下一节。每当在JavaScript中创建一个函数时，就会创建<code class="du iw ix iy iz b">this</code>关键字，当然是在幕后，它将该函数链接到该函数所属的对象。听起来很困惑？让我们看看代码，以便更好地理解这一点。</p><pre class="jx jy jz ka fd ld iz le lf aw lg bi"><span id="ce51" class="lh kk hh iz b fi li lj l lk ll">//declare function</span><span id="79c6" class="lh kk hh iz b fi lm lj l lk ll">const yourFunc = function() {</span><span id="790e" class="lh kk hh iz b fi lm lj l lk ll">console.log(this) // this === window <br/>                   'strict' mode? this === undefined</span><span id="40f6" class="lh kk hh iz b fi lm lj l lk ll">}<br/>yourFunc();</span></pre><p id="6dbf" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">现在让我们看另一个例子，一个函数在一个对象中</p><pre class="jx jy jz ka fd ld iz le lf aw lg bi"><span id="fe4a" class="lh kk hh iz b fi li lj l lk ll">//Object Literal<br/>const Person = {<br/> firstName : 'John',<br/> lastName : 'Doe',<br/> sayHi(){<br/>  console.log(this)<br/>  console.log(`Hello ${this.firstName} ${this.lastName}`)<br/> },<br/>}</span><span id="2cab" class="lh kk hh iz b fi lm lj l lk ll">Person.sayHi() // Implicit Binding</span><span id="0407" class="lh kk hh iz b fi lm lj l lk ll"><em class="ki">Output: {firstName: "John", lastName: "Doe", sayHi: ƒ}</em></span><span id="b245" class="lh kk hh iz b fi lm lj l lk ll"><em class="ki">        Hello John Doe</em></span></pre><p id="372d" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">在上面的例子中，<code class="du iw ix iy iz b">this</code>的值将指向Person对象，因为它是在<code class="du iw ix iy iz b">Person</code> <code class="du iw ix iy iz b">object</code>的上下文中调用的，我们得到如上所示的输出。以上两个例子都是<code class="du iw ix iy iz b">implicit binding</code>的。<strong class="jc hi">隐式绑定</strong>总是查看谁调用了<code class="du iw ix iy iz b">dot</code>左侧的函数(上下文)或任何东西，然后将那个<code class="du iw ix iy iz b">object</code>的值赋给<code class="du iw ix iy iz b">this</code>。在第一个例子中，调用<code class="du iw ix iy iz b">yourFunc()</code>与<code class="du iw ix iy iz b">window.yourFunc()</code>相同，这就是为什么我们将<code class="du iw ix iy iz b">window</code>作为<code class="du iw ix iy iz b">this</code>的值。</p><p id="f864" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">在JS中有不同的方法来绑定<code class="du iw ix iy iz b">this</code>关键字，我们已经看到了一个这样的方法，这里是<strong class="jc hi">隐式绑定</strong>，现在让我们来看看<strong class="jc hi">显式绑定</strong></p><h1 id="9cd7" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">显式绑定(调用、应用、绑定)</h1><p id="e6c0" class="pw-post-body-paragraph ja jb hh jc b jd ln ii jf jg lo il ji jj lp jl jm jn lq jp jq jr lr jt ju jv ha bi translated"><code class="du iw ix iy iz b">Explicit binding</code>是当我们明确指定方法/函数必须调用的上下文时。这可以通过<code class="du iw ix iy iz b">call</code>、<code class="du iw ix iy iz b">apply</code>和<code class="du iw ix iy iz b">bind</code>来完成。现在，让我们逐一通过一些示例来看一下其中的每一项。</p><h2 id="995a" class="lh kk hh bd kl ls lt lu kp lv lw lx kt jj ly lz kv jn ma mb kx jr mc md kz me bi translated">打电话</h2><p id="db9e" class="pw-post-body-paragraph ja jb hh jc b jd ln ii jf jg lo il ji jj lp jl jm jn lq jp jq jr lr jt ju jv ha bi translated">因为在JavaScript中包括函数在内的所有东西都被认为是一个对象，所以它可以有属性。<code class="du iw ix iy iz b">.call</code>方法就是这样一种属性，可以在任何函数的原型中找到。让我们考虑另一个例子，我们有一个函数<code class="du iw ix iy iz b">sayHi</code>并没有做很多事情，但是这里我们的重点是理解<code class="du iw ix iy iz b">call</code>方法做了什么。使用<code class="du iw ix iy iz b">.call</code>方法，我们可以调用具有特定上下文的函数。下面是<code class="du iw ix iy iz b">.call</code>方法的一般语法。</p><pre class="jx jy jz ka fd ld iz le lf aw lg bi"><span id="c259" class="lh kk hh iz b fi li lj l lk ll">function_name.call(<em class="ki">this</em>,a1,a2,a3,...);</span></pre><p id="8043" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><em class="ki">所以从语法上，我们可以看到</em> <code class="du iw ix iy iz b"><em class="ki">.call</em></code> <em class="ki">方法接受</em> <code class="du iw ix iy iz b"><em class="ki">object</em></code> <em class="ki"> ( </em> <code class="du iw ix iy iz b"><em class="ki">this</em></code> <em class="ki">)作为第一个参数，然后是一个逗号分隔的所有其他参数的列表。</em></p><pre class="jx jy jz ka fd ld iz le lf aw lg bi"><span id="5293" class="lh kk hh iz b fi li lj l lk ll">const Person1 = {<br/> firstName : 'John',<br/> lastName : 'Doe',<br/>}<br/>const Person2 = {<br/> firstName : 'Mark',<br/> lastName : 'Twain',<br/>}</span><span id="191d" class="lh kk hh iz b fi lm lj l lk ll">const Hobbies = ['Cricket','Football','Netflix'];<br/>const sayHi = function (h1,h2,h3){<br/>  console.log(this);<br/>  console.log(`My name is ${this.firstName} ${this.lastName} and I  love ${h1},${h2} and ${h3}`);<br/> }</span><span id="1549" class="lh kk hh iz b fi lm lj l lk ll">sayHi.call(<em class="ki">Person1</em>,Hobbies[0],Hobbies[1],Hobbies[2]);//this=Person1<br/>sayHi.call(<em class="ki">Person2</em>,Hobbies[0],Hobbies[1],Hobbies[2]);//this=Person2</span></pre><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es mf"><img src="../Images/400a57f14ed26d505c5fbc1e15e336b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORFtRRS7ZX2wwaZFLl9jxw.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx">output for the above code snippet</figcaption></figure><h1 id="2ddb" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">应用</h1><p id="720b" class="pw-post-body-paragraph ja jb hh jc b jd ln ii jf jg lo il ji jj lp jl jm jn lq jp jq jr lr jt ju jv ha bi translated">现在，<code class="du iw ix iy iz b">.apply</code>方法类似于<code class="du iw ix iy iz b">.call</code>方法，唯一的区别是<code class="du iw ix iy iz b">.apply</code>方法接受一个参数数组作为第二个参数，如下面的语法所示</p><pre class="jx jy jz ka fd ld iz le lf aw lg bi"><span id="cede" class="lh kk hh iz b fi li lj l lk ll">function_name.apply(this,[arguments array]);</span></pre><p id="96f5" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">让我们尝试重新创建同一个示例，但这一次，让我们使用apply方法调用函数，并使用<code class="du iw ix iy iz b">Person2</code>作为上下文。</p><pre class="jx jy jz ka fd ld iz le lf aw lg bi"><span id="f548" class="lh kk hh iz b fi li lj l lk ll">const Person1 = {<br/> firstName : 'John',<br/> lastName : 'Doe',<br/>}<br/>const Person2 = {<br/> firstName : 'Mark',<br/> lastName : 'Twain',<br/>}</span><span id="2318" class="lh kk hh iz b fi lm lj l lk ll">const Hobbies = ['Cricket','Football','Netflix']<br/>const sayHi = function (h1,h2,h3){<br/>  console.log(this);<br/>  console.log(`My name is ${this.firstName} ${this.lastName} and I  love ${h1},${h2} and ${h3}`);<br/> }</span><span id="7581" class="lh kk hh iz b fi lm lj l lk ll">sayHi.call(<em class="ki">Person1</em>,Hobbies[0],Hobbies[1],Hobbies[2]);//this=Person1<br/>sayHi.apply(<em class="ki">Person2</em>,Hobbies);//this=Person2</span></pre><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es mf"><img src="../Images/400a57f14ed26d505c5fbc1e15e336b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORFtRRS7ZX2wwaZFLl9jxw.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx">output for the above snippet</figcaption></figure><p id="3d3b" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><em class="ki">从上面的例子中，我们可以看到call和apply几乎是一样的，但是根本的区别是</em> <code class="du iw ix iy iz b"><em class="ki">.call</em></code> <em class="ki">接受一个逗号分隔的参数列表，而</em> <code class="du iw ix iy iz b"><em class="ki">.apply</em></code> <em class="ki">接受一个参数数组。</em></p><h1 id="cd9b" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">约束</h1><p id="55a6" class="pw-post-body-paragraph ja jb hh jc b jd ln ii jf jg lo il ji jj lp jl jm jn lq jp jq jr lr jt ju jv ha bi translated">我们看到<code class="du iw ix iy iz b">.call</code>和<code class="du iw ix iy iz b">.apply</code>都用期望的上下文和参数调用函数。<code class="du iw ix iy iz b">.bind</code>返回一个新函数，它可以存储在一个变量中，然后在以后的任何时间点使用特定的上下文调用。</p><pre class="jx jy jz ka fd ld iz le lf aw lg bi"><span id="bcb9" class="lh kk hh iz b fi li lj l lk ll">const boundFunction = function.bind(this,arg1,arg2...);</span></pre><p id="e7c1" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">返回的函数是一个绑定函数，它是原始函数对象周围的一个对象。调用绑定函数将调用带有初始<code class="du iw ix iy iz b">.bind</code>调用期间设置的<code class="du iw ix iy iz b">context</code>的包装函数。让我们看看下面的例子来更好地理解它。</p><pre class="jx jy jz ka fd ld iz le lf aw lg bi"><span id="970d" class="lh kk hh iz b fi li lj l lk ll">const Person1 = {<br/> firstName : 'John',<br/> lastName : 'Doe',<br/>}<br/>const Hobbies = ['Cricket','Football','Netflix'];<br/>const sayHi = function (h1,h2,h3){<br/>  console.log(this);<br/>  console.log(`My name is ${this.firstName} ${this.lastName} and I  love ${h1},${h2} and ${h3}`);<br/> }<br/>const boundHi= sayHi.bind(Person1,Hobbies[0],Hobbies[1],Hobbies[2]);<br/>boundHi();</span></pre><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es mk"><img src="../Images/088b94aded608d1b38cd9680105e8d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCV-D5Mg2MXFtSaq_aP6gw.png"/></div></div><figcaption class="mg mh et er es mi mj bd b be z dx">output for the above code snippet</figcaption></figure><p id="9160" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">所以在上面的例子中,<code class="du iw ix iy iz b">boundHi</code>是一个变量，它存储将原始函数与<code class="du iw ix iy iz b">Person1</code>对象和参数绑定后返回的绑定函数。当我们调用<code class="du iw ix iy iz b">boundHi().</code>时，我们得到期望的输出</p><p id="03df" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><code class="du iw ix iy iz b">.bind</code>也用于我们希望保留<code class="du iw ix iy iz b">this</code>值的地方，例如在<code class="du iw ix iy iz b">callbacks</code>中。让我们再举一个例子来更好地理解这一点。</p><pre class="jx jy jz ka fd ld iz le lf aw lg bi"><span id="abb4" class="lh kk hh iz b fi li lj l lk ll">let user = {<br/>  firstName: "John",<br/>  sayHi() {<br/>    alert(`Hello, ${this.firstName}!`);<br/>  }<br/>};<br/>setTimeout(user.sayHi, 1000); </span><span id="8261" class="lh kk hh iz b fi lm lj l lk ll"><em class="ki">output: Hello, undefined</em></span></pre><p id="69e1" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">在上面的例子中，<code class="du iw ix iy iz b">this</code>的值在作为<code class="du iw ix iy iz b">setTimeout</code>函数中的<code class="du iw ix iy iz b">callback</code>传递时丢失，并且<code class="du iw ix iy iz b">setTimeout</code>中的<code class="du iw ix iy iz b">this</code>将指向<code class="du iw ix iy iz b">window</code> <code class="du iw ix iy iz b">object</code>，而<code class="du iw ix iy iz b">window</code><code class="du iw ix iy iz b">object</code>反过来又改变了<code class="du iw ix iy iz b">this.firstName =&gt; window.firstName</code>，实际上给出了<code class="du iw ix iy iz b">undefined</code>。我们如何克服这一点？当然是用<code class="du iw ix iy iz b">.bind</code>的方法。</p><pre class="jx jy jz ka fd ld iz le lf aw lg bi"><span id="fee2" class="lh kk hh iz b fi li lj l lk ll">let user = {<br/>  firstName: "John",<br/>  sayHi() {<br/>    alert(`Hello, ${this.firstName}!`);<br/>  }<br/>};<br/>const boundHi = user.sayHi.bind(user); //<em class="ki">binds user obj </em></span><span id="81b1" class="lh kk hh iz b fi lm lj l lk ll">setTimeout(boundHi, 1000);</span><span id="77e2" class="lh kk hh iz b fi lm lj l lk ll"><em class="ki">output: Hello, John</em></span></pre><p id="6922" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">这里，我们将绑定的函数作为回调传递给setTimeout函数，该函数给出了我们想要的输出。<em class="ki">这里主要说的是</em> <code class="du iw ix iy iz b"><em class="ki">.bind</em></code> <em class="ki">用一个固定的</em> <code class="du iw ix iy iz b"><em class="ki">context</em></code> <em class="ki">回馈同样的功能，可以传递给</em> <code class="du iw ix iy iz b"><em class="ki">callbacks</em></code> <em class="ki">或者以后随时使用。</em></p><h1 id="ba9e" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">让我们总结一下</h1><figure class="jx jy jz ka fd kb"><div class="bz dy l di"><div class="ml lc l"/></div></figure><p id="ce8a" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><code class="du iw ix iy iz b">.call</code>:调用具有特定上下文的函数，并接受逗号分隔的参数列表</p><p id="90ad" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><code class="du iw ix iy iz b">.apply</code>:做与<code class="du iw ix iy iz b">.call</code>相同的事情，但是接受一个参数数组作为第二个参数</p><p id="f102" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><code class="du iw ix iy iz b">.bind</code>:返回一个新的绑定函数，它是将<code class="du iw ix iy iz b">this</code>变量绑定到指定的<code class="du iw ix iy iz b">object</code>的原始函数。</p><p id="7240" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">就这样了，伙计们。我希望这能对<code class="du iw ix iy iz b">.call</code>、<code class="du iw ix iy iz b">.apply</code>和<code class="du iw ix iy iz b">.bind</code>方法的使用有所启发。谢谢:)</p><p id="df37" class="pw-post-body-paragraph ja jb hh jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">更多敬请关注我们下面的'<strong class="jc hi"><em class="ki">JS的</em> </strong>'！！</p></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><div class="jx jy jz ka fd mt"><a rel="noopener follow" target="_blank" href="/globant/the-js-bifrost-currying-functions-in-javascript-e03a216b4b59"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">JS Bifrost——Javascript中的Currying函数</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">JS的世界</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh kg mt"/></div></div></a></div><div class="ni nj ez fb nk mt"><a rel="noopener follow" target="_blank" href="/globant/the-js-bifrost-shallow-or-deep-copy-22144e6787d6"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">JS彩虹糖——浅拷贝还是深拷贝？</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">复制数据都是关于值、引用和内存分配的</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="nl l ne nf ng nc nh kg mt"/></div></div></a></div><div class="ni nj ez fb nk mt"><a rel="noopener follow" target="_blank" href="/globant/cleaner-code-with-javascript-functions-d08d3bb37836"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">带有JavaScript函数的更干净的代码</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">了解纯函数和高阶函数来编写最先进的代码！</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="nm l ne nf ng nc nh kg mt"/></div></div></a></div><div class="ni nj ez fb nk mt"><a rel="noopener follow" target="_blank" href="/globant/the-js-bifrost-nullish-coalescing-operator-6ac55e59f61f"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">JS双花聚结(？？)运算符</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">what-why-how无效合并运算符以及链接和逻辑运算</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="nn l ne nf ng nc nh kg mt"/></div></div></a></div><div class="ni nj ez fb nk mt"><a rel="noopener follow" target="_blank" href="/globant/the-js-bifrost-understanding-the-coding-pattern-called-iife-794b46006550"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">JS彩虹桥——理解称为(IIFE)的编码模式</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">最受欢迎的函数表达式习语</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="no l ne nf ng nc nh kg mt"/></div></div></a></div><div class="ni nj ez fb nk mt"><a rel="noopener follow" target="_blank" href="/globant/the-js-bifrost-memoization-it-is-65f890f14308"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">JS彩虹糖——就是它了！</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">使迭代或递归函数更加优化的编程实践</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="np l ne nf ng nc nh kg mt"/></div></div></a></div><div class="ni nj ez fb nk mt"><a rel="noopener follow" target="_blank" href="/globant/the-js-bifrost-incredible-javascript-features-587b78865e67"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">JS Bifrost——不可思议的JavaScript特性</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">您应该在项目中开始使用的7个Javascript特性</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="nq l ne nf ng nc nh kg mt"/></div></div></a></div><div class="ni nj ez fb nk mt"><a rel="noopener follow" target="_blank" href="/globant/the-js-bifrost-callback-hell-4c699e1954b8"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">JS彩虹桥——回调地狱</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">你需要知道如何应对这个地狱，如何超越陈词滥调！</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="nr l ne nf ng nc nh kg mt"/></div></div></a></div><div class="ni nj ez fb nk mt"><a rel="noopener follow" target="_blank" href="/globant/the-js-bifrost-all-that-we-need-to-know-about-promises-2c7b087b56f3"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">JS彩虹桥——关于承诺，我们需要知道的一切</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">理解承诺及其解决实际应用问题陈述的方法</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="ns l ne nf ng nc nh kg mt"/></div></div></a></div><div class="ni nj ez fb nk mt"><a rel="noopener follow" target="_blank" href="/globant/the-js-bifrost-inheritance-in-js-prototype-and-class-inheritance-84ec4c60b1a2"><div class="mu ab dw"><div class="mv ab mw cl cj mx"><h2 class="bd hi fi z dy my ea eb mz ed ef hg bi translated">JS中的继承——原型和类继承</h2><div class="na l"><h3 class="bd b fi z dy my ea eb mz ed ef dx translated">欢迎来到JS Bifrost，这是您通向神级JavaScript坚实基础的道路。这是下一篇文章…</h3></div><div class="nb l"><p class="bd b fp z dy my ea eb mz ed ef dx translated">medium.com</p></div></div><div class="nc l"><div class="nt l ne nf ng nc nh kg mt"/></div></div></a></div></div></div>    
</body>
</html>