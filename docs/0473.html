<html>
<head>
<title>Coroutines: first things first</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协程:先做最重要的事情</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/coroutines-first-things-first-e6187bf3bb21?source=collection_archive---------2-----------------------#2020-03-11">https://medium.com/androiddevelopers/coroutines-first-things-first-e6187bf3bb21?source=collection_archive---------2-----------------------#2020-03-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/4d08893442e6d6cbd909ec38bf974783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YcXLfA7ah4xelW1O"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="97c2" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">协同程序中的取消和异常(第一部分)</h2></div><p id="89da" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这一系列博客文章深入探讨了协程中的取消和异常。取消对于避免做多余的工作很重要，这样会浪费内存和电池寿命；正确的异常处理是良好用户体验的关键。作为本系列其他两部分的基础(<a class="ae hu" rel="noopener" href="/androiddevelopers/cancellation-in-coroutines-aa6b90163629">第2部分:取消</a>、<a class="ae hu" rel="noopener" href="/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c">第3部分:异常</a>)，定义一些核心协程概念很重要，比如<code class="du ki kj kk kl b">CoroutineScope</code>、<code class="du ki kj kk kl b">Job</code>和<code class="du ki kj kk kl b">CoroutineContext</code>，这样我们就能达成一致。</p><p id="82bc" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你喜欢视频，可以看看我和弗洛里纳·芒特内斯库在2019年科特林康夫的演讲:</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><h1 id="5130" class="ku kv hx bd kw kx ky kz la lb lc ld le jd lf je lg jg lh jh li jj lj jk lk ll bi translated">验光仪</h1><p id="d2cd" class="pw-post-body-paragraph jm jn hx jo b jp lm iy jr js ln jb ju jv lo jx jy jz lp kb kc kd lq kf kg kh ha bi translated">一个<code class="du ki kj kk kl b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/" rel="noopener ugc nofollow" target="_blank"><strong class="jo hy">CoroutineScope</strong></a></code>跟踪你使用<code class="du ki kj kk kl b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html" rel="noopener ugc nofollow" target="_blank">launch</a></code>或<code class="du ki kj kk kl b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html" rel="noopener ugc nofollow" target="_blank">async</a></code>(这些是<code class="du ki kj kk kl b">CoroutineScope</code>上的扩展函数)创建的任何协程。正在进行的工作(运行协程)可以通过在任何时间点调用<code class="du ki kj kk kl b">scope.cancel()</code>来取消。</p><p id="e40f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">每当您想要在应用程序的特定层启动和控制协程的生命周期时，您都应该创建一个<code class="du ki kj kk kl b">CoroutineScope</code>。在一些像Android这样的平台上，KTX库已经在某些生命周期类中提供了一个<code class="du ki kj kk kl b">CoroutineScope</code>，比如<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#(androidx.lifecycle.ViewModel).viewModelScope:kotlinx.coroutines.CoroutineScope" rel="noopener ugc nofollow" target="_blank">viewModelScope</a></code>和<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#lifecyclescope" rel="noopener ugc nofollow" target="_blank">lifecycleScope</a></code>。</p><p id="1835" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">当创建一个<code class="du ki kj kk kl b">CoroutineScope</code>时，它将一个<code class="du ki kj kk kl b">CoroutineContext</code>作为其构造函数的参数。您可以使用以下代码创建一个新的作用域&amp;协程:</p><pre class="ko kp kq kr fd lr kl ls lt aw lu bi"><span id="8484" class="lv kv hx kl b fi lw lx l ly lz">// Job and Dispatcher are combined into a CoroutineContext which<br/>// will be discussed shortly<br/>val scope = CoroutineScope(Job() + Dispatchers.Main)</span><span id="f524" class="lv kv hx kl b fi ma lx l ly lz">val job = scope.launch {<br/>    // new coroutine<br/>}</span></pre><h1 id="7adc" class="ku kv hx bd kw kx ky kz la lb lc ld le jd lf je lg jg lh jh li jj lj jk lk ll bi translated">职位</h1><p id="b374" class="pw-post-body-paragraph jm jn hx jo b jp lm iy jr js ln jb ju jv lo jx jy jz lp kb kc kd lq kf kg kh ha bi translated"><code class="du ki kj kk kl b">Job</code>是协程程序的句柄。对于您(通过<code class="du ki kj kk kl b">launch</code>或<code class="du ki kj kk kl b">async</code>创建的)每个协程，它返回一个<code class="du ki kj kk kl b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="jo hy">Job</strong></a></code>实例，该实例唯一地标识协程并管理它的生命周期。正如我们在上面看到的，您也可以将一个<code class="du ki kj kk kl b">Job</code>传递给一个<code class="du ki kj kk kl b">CoroutineScope</code>来保持对其生命周期的控制。</p><h1 id="c6b8" class="ku kv hx bd kw kx ky kz la lb lc ld le jd lf je lg jg lh jh li jj lj jk lk ll bi translated">协同上下文</h1><p id="1edf" class="pw-post-body-paragraph jm jn hx jo b jp lm iy jr js ln jb ju jv lo jx jy jz lp kb kc kd lq kf kg kh ha bi translated"><code class="du ki kj kk kl b"><a class="ae hu" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="jo hy">CoroutineContext</strong></a></code>是一组定义协程行为的元素。它由以下材料制成:</p><ul class=""><li id="43d4" class="mb mc hx jo b jp jq js jt jv md jz me kd mf kh mg mh mi mj bi translated"><code class="du ki kj kk kl b">Job</code> —控制协程的生命周期。</li><li id="d0aa" class="mb mc hx jo b jp mk js ml jv mm jz mn kd mo kh mg mh mi mj bi translated"><code class="du ki kj kk kl b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html" rel="noopener ugc nofollow" target="_blank">CoroutineDispatcher</a></code> —将工作分派给适当的线程。</li><li id="7908" class="mb mc hx jo b jp mk js ml jv mm jz mn kd mo kh mg mh mi mj bi translated"><code class="du ki kj kk kl b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/index.html" rel="noopener ugc nofollow" target="_blank">CoroutineName</a></code> —协程的名称，用于调试。</li><li id="fe34" class="mb mc hx jo b jp mk js ml jv mm jz mn kd mo kh mg mh mi mj bi translated"><code class="du ki kj kk kl b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html" rel="noopener ugc nofollow" target="_blank">CoroutineExceptionHandler</a></code> —处理未捕获的异常，将在本系列的第3部分中讨论。</li></ul><p id="06a4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">新协程的<code class="du ki kj kk kl b">CoroutineContext</code>是什么？我们已经知道将会创建一个新的<code class="du ki kj kk kl b">Job</code>实例，允许我们控制它的生命周期。其余的元素将从其父元素的<code class="du ki kj kk kl b">CoroutineContext</code>继承(要么是另一个协程，要么是创建它的<code class="du ki kj kk kl b">CoroutineScope</code>)。</p><p id="a443" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">由于<code class="du ki kj kk kl b">CoroutineScope</code>可以创建协程，并且您可以在一个协程内创建更多的协程，因此创建了一个隐式的<strong class="jo hy"> <em class="mp">任务层次</em> </strong>。在下面的代码片段中，除了使用<code class="du ki kj kk kl b">CoroutineScope</code>创建一个新的协同程序，还可以看到如何在一个协同程序中创建更多的协同程序:</p><pre class="ko kp kq kr fd lr kl ls lt aw lu bi"><span id="d5b7" class="lv kv hx kl b fi lw lx l ly lz">val scope = CoroutineScope(Job() + Dispatchers.Main)</span><span id="15b7" class="lv kv hx kl b fi ma lx l ly lz">val job = scope.<strong class="kl hy">launch</strong> {<br/>    // New coroutine that has CoroutineScope as a parent<br/>    val result = <strong class="kl hy">async</strong> {<br/>        // New coroutine that has the coroutine started by <br/>        // launch as a parent<br/>    }.await()<br/>}</span></pre><p id="7f6a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这个层级的根通常是<code class="du ki kj kk kl b">CoroutineScope</code>。我们可以将这种层次形象化如下:</p><figure class="ko kp kq kr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/17a2dfb312e1f535880011f0db82f0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cIlNrjUhl4aZjrkJ"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mq">Coroutines are executed in a task hierarchy. The parent can be either a CoroutineScope or another coroutine.</em></figcaption></figure><h1 id="5da7" class="ku kv hx bd kw kx ky kz la lb lc ld le jd lf je lg jg lh jh li jj lj jk lk ll bi translated">作业生命周期</h1><p id="ce72" class="pw-post-body-paragraph jm jn hx jo b jp lm iy jr js ln jb ju jv lo jx jy jz lp kb kc kd lq kf kg kh ha bi translated">一个<code class="du ki kj kk kl b">Job</code>可以经历一组状态:新建、活动、完成、完成、取消和取消。虽然我们不能访问状态本身，但是我们可以访问作业的属性:<code class="du ki kj kk kl b">isActive</code>、<code class="du ki kj kk kl b">isCancelled</code>和<code class="du ki kj kk kl b">isCompleted</code>。</p><figure class="ko kp kq kr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/b814b0bba4cbcad987fdfe17a72e58b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zGHzocA6-lCxk0aX"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Job lifecycle</figcaption></figure><p id="4568" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果协程处于活动状态，协程或调用<code class="du ki kj kk kl b">job.cancel()</code>的失败将使作业处于取消状态(<code class="du ki kj kk kl b">isActive = false</code>、<code class="du ki kj kk kl b">isCancelled = true</code>)。一旦所有的孩子都完成了他们的工作，协程将进入取消状态和<code class="du ki kj kk kl b">isCompleted = true</code>。</p><h1 id="f87e" class="ku kv hx bd kw kx ky kz la lb lc ld le jd lf je lg jg lh jh li jj lj jk lk ll bi translated">父协同上下文解释</h1><p id="513c" class="pw-post-body-paragraph jm jn hx jo b jp lm iy jr js ln jb ju jv lo jx jy jz lp kb kc kd lq kf kg kh ha bi translated">在任务层次结构中，每个协程都有一个父协程，它可以是一个<code class="du ki kj kk kl b">CoroutineScope</code>或另一个协程。然而，协程的结果父级<code class="du ki kj kk kl b">CoroutineContext</code>可能不同于父级的<code class="du ki kj kk kl b">CoroutineContext</code>,因为它是基于以下公式计算的:</p><blockquote class="mr ms mt"><p id="0e67" class="jm jn mp jo b jp jq iy jr js jt jb ju mu jw jx jy mv ka kb kc mw ke kf kg kh ha bi translated"><strong class="jo hy">父上下文</strong> =默认值+继承的<code class="du ki kj kk kl b">CoroutineContext</code> +参数</p></blockquote><p id="88e2" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">其中:</p><ul class=""><li id="f147" class="mb mc hx jo b jp jq js jt jv md jz me kd mf kh mg mh mi mj bi translated">有些元素有<strong class="jo hy">默认</strong>值:<code class="du ki kj kk kl b">Dispatchers.Default</code>是<code class="du ki kj kk kl b">CoroutineDispatcher</code>的默认值，<code class="du ki kj kk kl b">“coroutine”</code>是<code class="du ki kj kk kl b">CoroutineName</code>的默认值。</li><li id="a8fe" class="mb mc hx jo b jp mk js ml jv mm jz mn kd mo kh mg mh mi mj bi translated">继承了 <code class="du ki kj kk kl b"><strong class="jo hy">CoroutineContext</strong></code>的<strong class="jo hy">是创建它的<code class="du ki kj kk kl b">CoroutineScope</code>或协程的<code class="du ki kj kk kl b">CoroutineContext</code>。</strong></li><li id="c710" class="mb mc hx jo b jp mk js ml jv mm jz mn kd mo kh mg mh mi mj bi translated"><strong class="jo hy">协程生成器中传递的参数</strong>将优先于继承上下文中的那些元素。</li></ul><p id="7af9" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> <em class="mp">注</em> </strong> : <code class="du ki kj kk kl b">CoroutineContext</code> s可以用<code class="du ki kj kk kl b">+</code>运算符组合。由于<code class="du ki kj kk kl b">CoroutineContext</code>是一组元素，一个新的<code class="du ki kj kk kl b">CoroutineContext</code>将被创建，加号右边的元素覆盖左边的元素。例如<code class="du ki kj kk kl b">(Dispatchers.Main, “name”) + (Dispatchers.IO) = (Dispatchers.IO, “name”)</code></p><figure class="ko kp kq kr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mx"><img src="../Images/c925a2f1cd6a6081530c1f612882faff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gjkoETUbx4mPhYEF"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mq">Every coroutine started by this CoroutineScope will have at least those elements in the CoroutineContext. CoroutineName is gray because it comes from the default values.</em></figcaption></figure><p id="d5dd" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">现在我们知道了新协程的父代<code class="du ki kj kk kl b">CoroutineContext</code>是什么，它的实际<code class="du ki kj kk kl b">CoroutineContext</code>将是:</p><blockquote class="mr ms mt"><p id="fca0" class="jm jn mp jo b jp jq iy jr js jt jb ju mu jw jx jy mv ka kb kc mw ke kf kg kh ha bi translated"><strong class="jo hy">新协程上下文</strong> =父<code class="du ki kj kk kl b">CoroutineContext</code> + <code class="du ki kj kk kl b">Job()</code></p></blockquote><p id="741b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果我们用上图所示的<code class="du ki kj kk kl b">CoroutineScope</code>创建一个新的协程，如下所示:</p><pre class="ko kp kq kr fd lr kl ls lt aw lu bi"><span id="8332" class="lv kv hx kl b fi lw lx l ly lz">val job = scope.launch(Dispatchers.IO) {<br/>    // new coroutine<br/>}</span></pre><p id="1a0a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">那个协程的父<code class="du ki kj kk kl b">CoroutineContext</code>和它的实际<code class="du ki kj kk kl b">CoroutineContext</code>是什么？见下图的解决方案！</p><figure class="ko kp kq kr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es my"><img src="../Images/ca3716413611e0ee7c2ba69334d85f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LPnIOfVGQqrqPZ__"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mq">The Job in the CoroutineContext and in the parent context will never be the same instance as a new coroutine always get a new instance of a Job</em></figcaption></figure><p id="f915" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">所得到的父级<code class="du ki kj kk kl b">CoroutineContext</code>具有<code class="du ki kj kk kl b">Dispatchers.IO</code>而不是作用域的<code class="du ki kj kk kl b">CoroutineDispatcher</code>,因为它被协程生成器的参数覆盖了。另外，检查父<code class="du ki kj kk kl b">CoroutineContext</code>中的<code class="du ki kj kk kl b">Job</code>是作用域的<code class="du ki kj kk kl b">Job</code>(红色)的实例，并且<code class="du ki kj kk kl b">Job</code>(绿色)的新实例已经被分配给新协程的实际<code class="du ki kj kk kl b">CoroutineContext</code>。</p><p id="f1b7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">正如我们将在本系列的第3部分看到的，一个<code class="du ki kj kk kl b">CoroutineScope</code>可以在它的<code class="du ki kj kk kl b">CoroutineContext</code>中有一个不同的<code class="du ki kj kk kl b">Job</code>实现，称为<code class="du ki kj kk kl b">SupervisorJob</code>，它改变了<code class="du ki kj kk kl b">CoroutineScope</code>处理异常的方式。因此，用该作用域创建的新协程可以将<code class="du ki kj kk kl b">SupervisorJob</code>作为父<code class="du ki kj kk kl b">Job</code>。然而，当一个协程的父代是另一个协程时，父代<code class="du ki kj kk kl b">Job</code>将总是类型<code class="du ki kj kk kl b">Job</code>。</p></div><div class="ab cl mz na go nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ha hb hc hd he"><p id="2ab1" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">既然您已经了解了协程的基础知识，那么就从本系列的第二部分和第三部分开始学习更多关于协程中的取消和异常:</p><div class="hg hh ez fb hi ng"><a rel="noopener follow" target="_blank" href="/androiddevelopers/cancellation-in-coroutines-aa6b90163629"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hy fi z dy nl ea eb nm ed ef hw bi translated">协同程序中的取消</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">协程中的取消和异常(下)</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">medium.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ho ng"/></div></div></a></div><div class="hg hh ez fb hi ng"><a rel="noopener follow" target="_blank" href="/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hy fi z dy nl ea eb nm ed ef hw bi translated">协程中的异常</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">协程中的取消和异常(第三部分)——必须全部捕获！</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">medium.com</p></div></div><div class="np l"><div class="nv l nr ns nt np nu ho ng"/></div></div></a></div><div class="hg hh ez fb hi ng"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-patterns-for-work-that-shouldnt-be-cancelled-e26c40f142ad"><div class="nh ab dw"><div class="ni ab nj cl cj nk"><h2 class="bd hy fi z dy nl ea eb nm ed ef hw bi translated">不应该取消的工作的协程和模式</h2><div class="nn l"><h3 class="bd b fi z dy nl ea eb nm ed ef dx translated">协同程序中的取消和例外(第四部分)</h3></div><div class="no l"><p class="bd b fp z dy nl ea eb nm ed ef dx translated">medium.com</p></div></div><div class="np l"><div class="nw l nr ns nt np nu ho ng"/></div></div></a></div></div></div>    
</body>
</html>