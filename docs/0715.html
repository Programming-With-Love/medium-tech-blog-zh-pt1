<html>
<head>
<title>Alternatives to Idling Resources in Compose tests : the waitUntil APIs (updated)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写测试中空闲资源的替代方法:waitUntil APIs(更新)</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/alternatives-to-idling-resources-in-compose-tests-8ae71f9fc473?source=collection_archive---------2-----------------------#2022-04-22">https://medium.com/androiddevelopers/alternatives-to-idling-resources-in-compose-tests-8ae71f9fc473?source=collection_archive---------2-----------------------#2022-04-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f1bc818605af5462c058788b62c1fb20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRjRTP-6hOKKcnRl6kwRAQ.png"/></div></div></figure><div class=""/><p id="7920" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，您将学习如何在Compose中使用<code class="du jn jo jp jq b">waitUntil</code>测试API来等待满足某些条件。在某些情况下，这是使用空闲资源的一个很好的替代方法。</p><p id="a6ee" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">[2023更新] Tldr:使用<a class="ae jr" href="https://gist.github.com/JoseAlcerreca/c5b94db07f04b15255b1637ded3a3bbd" rel="noopener ugc nofollow" target="_blank">新的wait until API</a>来同步合成测试(v1.4.0+)。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="2af8" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么是同步？</h1><p id="e59e" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">对测试进行分类的一种方法是根据它们的范围。小测试，或称单元测试，关注于你的应用程序的小部分，而大测试，或称端到端测试，覆盖了你的应用程序的大部分。你可以在最新更新的<a class="ae jr" href="https://developer.android.com/training/testing/fundamentals" rel="noopener ugc nofollow" target="_blank">测试文档</a>中读到这种和其他类型的测试。</p><figure class="ld le lf lg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lc"><img src="../Images/2af4b6b0b9a662f6b3277dfc1f8d3cd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9nNqktHHUTOQInAI"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Different test scopes in an app</figcaption></figure><p id="4b95" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同步是让测试知道何时运行下一个操作的机制。您选择验证的代码块越大，就越难与测试同步。在单元测试中，完全控制要验证的代码的执行是很容易的。然而，随着我们将范围扩大到包括更多的类、模块和层，测试框架知道应用程序是否正在运行变得很棘手。</p><figure class="ld le lf lg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ll"><img src="../Images/a3c979018ea1e11e3abe89f56a989620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_a4DNewayyb4T8_0Mh8cQ.png"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx">Correct synchronization between test and app</figcaption></figure><p id="34d7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">androidx.test</code>还有，推而广之，<a class="ae jr" href="https://developer.android.com/jetpack/compose/testing" rel="noopener ugc nofollow" target="_blank">撰写测试</a>，引擎盖下用点小技巧，这样就不用太担心这个了。例如，如果主线程很忙，测试会暂停，直到它可以执行下一行。</p><p id="5125" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，他们不可能什么都知道。例如，如果您在后台线程中加载数据，测试框架可能会过早地执行下一个操作，使您的测试失败。最糟糕的情况是这种情况只发生了很小一部分时间，使得测试<a class="ae jr" href="https://developer.android.com/training/testing/fundamentals#flaky" rel="noopener ugc nofollow" target="_blank">变得不稳定</a>。</p><h1 id="7f12" class="jz ka hs bd kb kc lm ke kf kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw bi translated">选项1:闲置资源</h1><p id="d2c4" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">空闲资源是Espresso的一个特性，让你，开发者，决定应用什么时候忙。您有两种方法来使用它们:</p><p id="8ad6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"> 1。将它们安装在框架或库中，这些框架或库正在做测试看不到的工作。</strong></p><p id="26af" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个很好的例子是<a class="ae jr" href="https://github.com/square/RxIdler" rel="noopener ugc nofollow" target="_blank"> RxIdler </a>，它包装了一个RxJava调度器。这是注册空闲资源的首选方式，因为它可以让您的测试设置与测试代码完全分离。</p><figure class="ld le lf lg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="d58b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"> 2。修改测试中的代码，以明确公开关于应用程序是否繁忙的信息。</strong></p><p id="2121" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，您可以修改您的存储库(或一个<a class="ae jr" href="https://developer.android.com/training/testing/fundamentals/test-doubles" rel="noopener ugc nofollow" target="_blank">测试double </a>)来表明在从数据源加载数据时繁忙:</p><figure class="ld le lf lg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="63a1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这并不理想，因为您正在污染您的生产代码，或者创建复杂的测试副本，并且在某些情况下它们很难安装。例如，如何在Kotlin流中使用空闲资源？<em class="lt">决赛</em>哪个更新？</p><p id="0ca1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">相反，我们可以<em class="lt">等待</em>事情。</p><h1 id="ba12" class="jz ka hs bd kb kc lm ke kf kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw bi translated">选项2:等待事情…错误的方式</h1><p id="fdca" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">加载数据通常很快，尤其是在使用假数据的情况下，那么当您可以让测试休眠几秒钟时，为什么还要浪费时间让资源闲置呢？</p><figure class="ld le lf lg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="81df" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该测试要么<strong class="ir ht">运行速度慢于所需速度，要么</strong>失败。当您有数百或数千个UI测试时，您希望测试尽可能快。</p><p id="bc82" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，有时模拟器或设备行为不当和jank，使操作需要一点时间比那些2000毫秒，打破你的构建。当你有数百个测试时，这就成了一个大问题。</p><figure class="ld le lf lg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lu"><img src="../Images/9d4131872452d83a7bcd47eabbd53b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DOCdjq-JpPDGV5OB"/></div></div></figure><h1 id="deb9" class="jz ka hs bd kb kc lm ke kf kg ln ki kj kk lo km kn ko lp kq kr ks lq ku kv kw bi translated">选项3:以正确的方式等待事情的发生！</h1><p id="22d9" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">如果您不想修改测试中的代码以便在繁忙时公开，另一种选择是等待，直到满足某个条件，而不是等待任意长的时间。</p><p id="51b0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Compose中，您可以利用<a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/test/junit4/ComposeTestRule#waitUntil(kotlin.Long,kotlin.Function0)" rel="noopener ugc nofollow" target="_blank"> waitUntil </a>函数，该函数接受另一个生成布尔值的函数。</p><figure class="ld le lf lg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="a90d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2023/03/22更新:从Compose 1.4.0开始，我们添加了一组新的waitUntil APIs:</p><figure class="ld le lf lg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="bf95" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">[1 . 4 . 0之前:使用这些帮助器:<a class="ae jr" href="https://gist.github.com/JoseAlcerreca/902a0c5a06e02a7411c0518c3f997dbf" rel="noopener ugc nofollow" target="_blank">waituntlexists</a>，<a class="ae jr" href="https://gist.github.com/JoseAlcerreca/ff5c1f43fe31f1a55ce462bc214cdc83" rel="noopener ugc nofollow" target="_blank"> waitUntilNodeCount </a></p><p id="ed3a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">…并像这样使用它们:</p><figure class="ld le lf lg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="e10f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">仅当您需要将测试与UI同步时，才使用这些API。对每个测试语句进行同步会不必要地污染测试代码，使其更难维护。</p><p id="6b17" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么你应该什么时候使用它呢？一个很好的用例是从可观察对象加载数据(使用LiveData、Kotlin Flow或RxJava)。当您的UI需要在您认为它空闲之前接收多个更新时，您可能想要使用<code class="du jn jo jp jq b">waitUntil</code>来简化同步。</p><p id="7d7c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，当您从视图中收集流时:</p><figure class="ld le lf lg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="9f71" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你向它发射多种物品:</p><figure class="ld le lf lg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="9db8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果<code class="du jn jo jp jq b">repository</code>花费不确定的时间返回第一个结果，测试框架将认为“加载”是空闲状态(在<code class="du jn jo jp jq b">collectAsState</code>中分配的初始值)，并继续下一个语句。</p><figure class="ld le lf lg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="a754" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，如果您确保UI没有显示加载指示器，您可以使测试更加可靠:</p><figure class="ld le lf lg fd hj"><div class="bz dy l di"><div class="lr ls l"/></div></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="def8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">开心…等着吧…测试！</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="a3d9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lt">代码片段许可证:</em></p><pre class="ld le lf lg fd lv jq lw lx aw ly bi"><span id="1bad" class="lz ka hs jq b fi ma mb l mc md">Copyright 2022 Google LLC.<br/>SPDX-License-Identifier: Apache-2.0</span></pre></div></div>    
</body>
</html>