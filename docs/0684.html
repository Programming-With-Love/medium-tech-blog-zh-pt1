<html>
<head>
<title>Gradle and AGP build APIs: How to write a plugin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">格雷尔和AGP构建API:如何编写插件</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/gradle-and-agp-build-apis-how-to-write-a-plugin-1695b590e4ec?source=collection_archive---------3-----------------------#2021-11-24">https://medium.com/androiddevelopers/gradle-and-agp-build-apis-how-to-write-a-plugin-1695b590e4ec?source=collection_archive---------3-----------------------#2021-11-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/23c70bdc81b12d7b6cb24dad0ddb0123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WkRft2aAKv19MoIm.jpeg"/></div></div></figure><div class=""/><p id="1a88" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是这个MAD技能系列的第二篇文章。在<a class="ae jn" rel="noopener" href="/androiddevelopers/gradle-and-agp-build-apis-configure-your-build-9a10db5b2262">上一篇文章</a>中，你已经看到了Gradle的基础知识以及如何配置Android Gradle插件。在本文中，您将学习如何通过编写自己的插件来扩展您的构建。如果你更喜欢看这些内容而不是阅读，看看下面的视频:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="bae5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从7.0版本开始，Android Gradle插件现在提供了稳定的扩展点来操作变体配置和生成的构建工件。该API的某些部分最近才最终确定，所以在本文中我将使用AGP的7.1版本(在撰写本文时处于测试阶段)。</p><h2 id="3e3f" class="ju jv hs bd jw jx jy jz ka kb kc kd ke ja kf kg kh je ki kj kk ji kl km kn ko bi translated">梯度任务</h2><p id="f04c" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">我将开始一个新的清洁项目。如果您想继续，您可以通过选择基本活动模板来创建一个新项目。</p><p id="35af" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们先创建一个任务并打印出来，猜猜是什么，<em class="ku"> hello world </em>。为此，在应用程序级<code class="du kv kw kx ky b">build.gradle.kts</code>文件中，我将注册一个新任务，并将该任务命名为“<em class="ku"> hello </em>”。</p><p id="35de" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kv kw kx ky b">tasks.register(“hello”){ }</code></p><p id="b96c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好了，现在任务已经准备好了，让我们打印出hello并添加项目名称。注意这个<code class="du kv kw kx ky b">build.gradle.kts</code>文件属于app模块，所以<code class="du kv kw kx ky b">project.name</code>将返回这个模块的名称，即“<em class="ku"> app </em>”。相反，我将使用<code class="du kv kw kx ky b">project.parent?.name</code>，它返回项目的名称。</p><pre class="jo jp jq jr fd kz ky la lb aw lc bi"><span id="2ac7" class="ju jv hs ky b fi ld le l lf lg">tasks.register("hello"){<br/>    <strong class="ky ht">println("Hello " + project.parent?.name)</strong><br/>}</span></pre><p id="82b8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在是运行任务的时候了。查看任务列表，我可以看到我的新任务列在这里。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es lh"><img src="../Images/2ffc629a6807c3d2e3c75fa4ef35eb46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*qkwP_RqiwdVzWb7jKTTnSA.png"/></div><figcaption class="li lj et er es lk ll bd b be z dx">The new task is listed in Gradle pane in Android Studio</figcaption></figure><p id="8b96" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我可以双击hello任务或通过终端执行该任务，并在构建输出中看到hello消息。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lm"><img src="../Images/fd5d1f55be05d6b5484de80115a94399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R8sfZTWIRXvjenvQ1h1tMg.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx">The task prints hello message in the build output</figcaption></figure><p id="aa2b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我检查日志时，我可以看到这条消息是在配置阶段打印的。配置阶段实际上不是执行任务功能，就像本例中打印Hello World一样。配置阶段是配置任务以影响其执行的时间。您可以告诉任务输入、参数和输出的位置。</p><p id="e607" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">无论请求运行哪个任务，配置阶段都会运行。在配置阶段运行耗时的代码会导致很长的配置时间。</p><p id="b652" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">任务执行应该只发生在执行阶段，所以我们需要将这个打印调用移到执行阶段。为此，我可以添加<code class="du kv kw kx ky b">doFirst()</code>或<code class="du kv kw kx ky b">doLast()</code>，它们将分别在执行阶段的开始或结束时打印hello消息。</p><pre class="jo jp jq jr fd kz ky la lb aw lc bi"><span id="bb98" class="ju jv hs ky b fi ld le l lf lg">tasks.register("hello"){<br/>    <strong class="ky ht">doLast {</strong><br/>        println("Hello " + project.parent?.name)<br/>    <strong class="ky ht">}</strong><br/>}</span></pre><p id="737d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我再次运行该任务时，这一次我可以看到在执行阶段打印了hello消息。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ln"><img src="../Images/9d8f1549b1bc46bfefa8be590af58761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s4bI5kuLayHCPmZYPBOmvg.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx">The task now prints the hello message in execution phase</figcaption></figure><p id="2c1a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我的定制任务位于<code class="du kv kw kx ky b">build.gradle.kts</code>文件中。向<code class="du kv kw kx ky b">build.gradle</code>文件添加定制任务是创建定制构建脚本的一种简单方法。然而，随着我的插件代码变得越来越复杂，这并不能很好地扩展。我们建议将自定义任务和插件实现放在一个<code class="du kv kw kx ky b">buildSrc</code>文件夹中。</p><h2 id="6d24" class="ju jv hs bd jw jx jy jz ka kb kc kd ke ja kf kg kh je ki kj kk ji kl km kn ko bi translated">在buildSrc中实现插件</h2><p id="dc7d" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">在编写更多代码之前，让我们将我的hello任务移到<code class="du kv kw kx ky b">buildSrc</code>。我将创建一个新文件夹，命名为<code class="du kv kw kx ky b">buildSrc</code>。接下来，我为插件项目创建一个<code class="du kv kw kx ky b">build.gradle.kts</code>文件，这样Gradle会自动将这个文件夹添加到构建中。</p><p id="03e0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是根项目文件夹中的顶级目录。注意，我不需要将它作为一个模块添加到我的项目中。Gradle会自动编译这个目录中的代码，并将其放入您的构建脚本的类路径中。</p><p id="76f8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我创建一个新的src文件夹和一个名为<code class="du kv kw kx ky b">HelloTask</code>的新类。我将这个新类转换成一个<code class="du kv kw kx ky b">abstract</code>类并扩展<code class="du kv kw kx ky b">DefaultTask</code>。接下来，我将添加一个名为<code class="du kv kw kx ky b">taskAction</code>的新函数，用<code class="du kv kw kx ky b">@TaskAction</code>注释来注释这个函数，并将我的自定义任务代码从<code class="du kv kw kx ky b">build.gradle.kts</code>移到这个函数中。</p><pre class="jo jp jq jr fd kz ky la lb aw lc bi"><span id="9e5f" class="ju jv hs ky b fi ld le l lf lg">abstract class HelloTask: DefaultTask() {    <br/>    @TaskAction<br/>    fun taskAction() {<br/>        println("Hello \"${project.parent?.name}\" from task!")<br/>    }<br/>}</span></pre><p id="f00b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我的任务已经准备好了，我将创建一个新的插件类，它需要实现<code class="du kv kw kx ky b">Plugin</code>并覆盖<code class="du kv kw kx ky b">apply()</code>函数。Gradle将调用这个函数并传入<code class="du kv kw kx ky b">Project</code>对象。为了注册<code class="du kv kw kx ky b">HelloTask</code>，我将在<code class="du kv kw kx ky b">project.tasks</code>上调用<code class="du kv kw kx ky b">register()</code>，并给这个新任务命名。</p><pre class="jo jp jq jr fd kz ky la lb aw lc bi"><span id="88d7" class="ju jv hs ky b fi ld le l lf lg">class CustomPlugin: Plugin&lt;Project&gt; {<br/>    override fun apply(project: Project) {<br/>        project.tasks.register&lt;HelloTask&gt;("hello")<br/>    }<br/>}</span></pre><p id="0d0a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此时，我还可以声明我的任务依赖于另一个任务。</p><pre class="jo jp jq jr fd kz ky la lb aw lc bi"><span id="058f" class="ju jv hs ky b fi ld le l lf lg">class CustomPlugin: Plugin&lt;Project&gt; {<br/>    override fun apply(project: Project) {<br/>        project.tasks.register&lt;HelloTask&gt;("hello"){<br/>            <strong class="ky ht">dependsOn("build")</strong><br/>        }<br/>    }<br/>}</span></pre><p id="dbef" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，让我们应用新的插件。注意，如果我的项目有不止一个模块，我可以通过将它添加到其他<code class="du kv kw kx ky b">build.gradle</code>文件中来重用这个插件。</p><pre class="jo jp jq jr fd kz ky la lb aw lc bi"><span id="5eac" class="ju jv hs ky b fi ld le l lf lg">plugins {<br/>    id ("com.android.application")<br/>    id ("org.jetbrains.kotlin.android")<br/>}</span><span id="be9e" class="ju jv hs ky b fi lo le l lf lg"><strong class="ky ht">apply&lt;CustomPlugin&gt;()</strong></span><span id="ac99" class="ju jv hs ky b fi lo le l lf lg">android {<br/>   ...<br/>}</span></pre><p id="0349" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我将执行<code class="du kv kw kx ky b">hello</code>任务，并观察我的插件像以前一样工作。</p><p id="0166" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kv kw kx ky b">./gradlew hello</code></p><p id="2f6a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我把我的任务转移到了<code class="du kv kw kx ky b">buildSrc</code>，让我们更进一步，发现新的Android Gradle插件API。AGP在构建工件时提供了生命周期的扩展点。</p><p id="9915" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从变体API开始，让我们首先讨论什么是<a class="ae jn" href="https://developer.android.com/studio/build/build-variants" rel="noopener ugc nofollow" target="_blank">变体</a>。变体是您可以构建的应用程序的不同版本。比方说，除了一个全功能的应用程序之外，你还想为你的应用程序构建一个演示版本或者一个内部版本用于调试。您还可以针对不同的API级别或设备类型。变体是通过组合构建类型(如<code class="du kv kw kx ky b">debug</code>和<code class="du kv kw kx ky b">release</code>)和构建脚本中定义的产品风格来创建的。</p><p id="d785" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在构建文件中使用声明性DSL来添加构建类型是非常好的。然而，在代码中这样做给了你的插件一种影响构建的方式，这种方式用声明性语法是不可能或难以表达的。</p><p id="7346" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">AGP通过解析构建脚本和在<code class="du kv kw kx ky b">android</code>块中设置的属性开始构建。新的变体API回调允许我从<code class="du kv kw kx ky b">androidComponents</code>扩展添加一个<code class="du kv kw kx ky b">finalizeDSL()</code>回调。在这个回调中，我可以在DSL对象用于变量创建之前对它们进行更改。我将创建一个新的构建类型并设置它的属性。</p><pre class="jo jp jq jr fd kz ky la lb aw lc bi"><span id="7a40" class="ju jv hs ky b fi ld le l lf lg">val extension = project.extensions.getByName(<br/>    "androidComponents"<br/>) as ApplicationAndroidComponentsExtension<br/>       <br/>extension.<strong class="ky ht">finalizeDsl</strong> { ext-&gt;<br/>    ext.buildTypes.create("staging").let { buildType -&gt;<br/>        buildType.initWith(ext.buildTypes.getByName("debug"))<br/>        buildType.manifestPlaceholders["hostName"] = "example.com"<br/>        buildType.applicationIdSuffix = ".debugStaging"<br/>    }<br/>}</span></pre><p id="7127" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，在这个阶段，我可以创建或注册新的构建类型并设置它们的属性。在这个阶段的最后，AGP将锁定DSL对象，因此它们不能被更改。如果我再次运行构建，我可以看到应用程序的一个临时版本已经构建好了。</p><p id="8d64" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，假设我的一个测试失败了，我想禁用单元测试来构建一个内部版本来找出问题所在。</p><p id="bbb6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要禁用单元测试，我可以使用<code class="du kv kw kx ky b">beforeVariants()</code>回调，它允许我通过<code class="du kv kw kx ky b">VariantBuilder</code>对象进行这样的更改。这里我将检查当前的变体是否是我为<code class="du kv kw kx ky b">staging</code>创建的。接下来，我将禁用单元测试并设置一个不同的<code class="du kv kw kx ky b">minSdk</code>版本。</p><pre class="jo jp jq jr fd kz ky la lb aw lc bi"><span id="d3fa" class="ju jv hs ky b fi ld le l lf lg">extension.<strong class="ky ht">beforeVariants</strong> { variantBuilder -&gt;<br/>    if (variantBuilder.name == "staging") {<br/>        variantBuilder.enableUnitTest = false<br/>        variantBuilder.minSdk = 23<br/>    }<br/>}</span></pre><p id="2ce4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个阶段之后，将要创建的组件和工件的列表现在已经最终确定了！</p><p id="0253" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在下面找到这个示例的完整代码清单。此外，如果你想看到更多这样的样本，请务必查看Github上的<a class="ae jn" href="https://github.com/android/gradle-recipes" rel="noopener ugc nofollow" target="_blank"> gradle-recipes repo </a>。</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="lp jt l"/></div></figure><h2 id="6eb8" class="ju jv hs bd jw jx jy jz ka kb kc kd ke ja kf kg kh je ki kj kk ji kl km kn ko bi translated">摘要</h2><p id="9fae" class="pw-post-body-paragraph ip iq hs ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">编写您自己的插件，让您扩展Android Gradle插件，并根据您的项目需求定制您的构建！</p><p id="80c6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，您已经看到了如何使用新的变体API在<code class="du kv kw kx ky b">AndroidComponentsExtension</code>中注册回调，使用DSL对象来初始化变体，影响哪些变体被创建，以及它们在<code class="du kv kw kx ky b">beforeVariants()</code>中的属性。</p><p id="392e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下一篇文章中，我们将进一步介绍工件API，并向您展示如何从您的定制任务中读取和转换工件！</p></div></div>    
</body>
</html>