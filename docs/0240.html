<html>
<head>
<title>Sharing Content between Android apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android应用程序之间共享内容</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/sharing-content-between-android-apps-2e6db9d1368b?source=collection_archive---------4-----------------------#2016-01-21">https://medium.com/androiddevelopers/sharing-content-between-android-apps-2e6db9d1368b?source=collection_archive---------4-----------------------#2016-01-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/77bf159d98cdb20e4cb302158ad92e2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jgddf-oUyyPi5mMpCm3hxQ.png"/></div></figure><p id="25e8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">正如他们所说，分享是关爱，但在Android上分享的意义可能略有不同。“共享”实际上是在应用程序之间发送文本、格式化文本、文件或图像等内容的简称。</p><p id="b642" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因此，如果“共享”==发送内容，那么使用<a class="ae jj" href="http://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#ACTION_SEND" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> ACTION_SEND </em> </a>(或<a class="ae jj" href="http://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#ACTION_SEND_MULTIPLE" rel="noopener ugc nofollow" target="_blank"><em class="jk">ACTION _ SEND _ MULTIPLE</em></a>)意图和它的十几个额外功能来实现就更有意义了。</p><p id="c0bf" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">虽然这种方法非常有效，但我更喜欢使用<a class="ae jj" href="http://developer.android.com/reference/android/support/v4/app/ShareCompat.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> ShareCompat </em> </a>，这是<a class="ae jj" href="http://developer.android.com/tools/support-library/features.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#v4" rel="noopener ugc nofollow" target="_blank"> v4支持库</a>中的一组类，旨在简化构建共享内容的意图。</p><figure class="jl jm jn jo fd ii"><div class="bz dy l di"><div class="jp jq l"/></div></figure><h1 id="30f6" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">共享文本</h1><p id="6b87" class="pw-post-body-paragraph il im hh in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ha bi translated">可以想象，共享纯文本是一个很好的起点。事实上，这没什么大不了的:</p><pre class="jl jm jn jo fd ku kv kw kx aw ky bi"><span id="2801" class="kz js hh kv b fi la lb l lc ld">Intent shareIntent = ShareCompat.IntentBuilder.from(activity)<br/>  .setType("text/plain")<br/>  .setText(shareText)<br/>  .getIntent();<br/>if (shareIntent.resolveActivity(getPackageManager()) != null) {<br/>  startActivity(shareIntent);<br/>}</span></pre><p id="b19a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jj" href="http://developer.android.com/reference/android/support/v4/app/ShareCompat.IntentBuilder.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> ShareCompat。IntentBuilder </em>对于共享，最重要的部分之一是选择正确的mime类型——这是应用程序过滤它们可以接收的内容类型的方式。通过使用<em class="jk">文本/纯文本</em>，我们表示我们的<em class="jk">意图</em>将只包含纯文本。然后，当然，</a><a class="ae jj" href="http://developer.android.com/reference/android/support/v4/app/ShareCompat.IntentBuilder.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#setText(java.lang.CharSequence)" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> setText() </em> </a>就是我们实际上如何将<em class="jk"> CharSequence </em>添加到意图发送中。虽然你当然可以使用<em class="jk"> setText() </em>发送样式化的文本，但不能保证接收应用程序会接受这种样式，所以你应该确保无论有没有样式化，文本都清晰易读。</p><p id="53c8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你会注意到我们在调用<a class="ae jj" href="http://developer.android.com/reference/android/content/Context.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#startActivity(android.content.Intent)" rel="noopener ugc nofollow" target="_blank"><em class="jk">start activity()</em></a>之前使用了<a class="ae jj" href="http://developer.android.com/reference/android/content/pm/PackageManager.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#resolveActivity(android.content.Intent,%20int)" rel="noopener ugc nofollow" target="_blank"><em class="jk">resolve activity()</em></a>。正如在<a class="ae jj" href="https://www.youtube.com/watch?v=HGElAW224dE?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">使用运行时检查保护隐式意图</a>中所提到的，这对于在没有活动可用于处理您选择的mime类型时防止<a class="ae jj" href="http://developer.android.com/reference/android/content/ActivityNotFoundException.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jk">ActivityNotFoundException</em></a>是至关重要的。虽然对于<em class="jk"> text/plain </em>可能没有那么多问题，但它对于其他类型可能更常见。</p><blockquote class="le lf lg"><p id="a3e8" class="il im jk in b io ip iq ir is it iu iv lh ix iy iz li jb jc jd lj jf jg jh ji ha bi translated"><strong class="in hi">注意:</strong>当您使用startActivity(shareIntent)时，会考虑用户设置的任何默认应用程序(即，如果他们之前选择了将所有“文本/普通”项目共享到某个应用程序)。如果你想总是显示一个消歧选择器，使用从<a class="ae jj" href="http://developer.android.com/reference/android/support/v4/app/ShareCompat.IntentBuilder.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#createChooserIntent()" rel="noopener ugc nofollow" target="_blank">intent builder . createchooserintent()</a>生成的意图，如<a class="ae jj" href="http://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#ACTION_CHOOSER" rel="noopener ugc nofollow" target="_blank"> ACTION_CHOOSER文档</a>中所述。</p></blockquote><h1 id="dc4b" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">共享HTML文本</h1><p id="4146" class="pw-post-body-paragraph il im hh in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ha bi translated">一些应用程序，尤其是电子邮件客户端，也支持HTML格式。与纯文本相比，这些变化相当小:</p><pre class="jl jm jn jo fd ku kv kw kx aw ky bi"><span id="9f27" class="kz js hh kv b fi la lb l lc ld">Intent shareIntent = ShareCompat.IntentBuilder.from(activity)<br/>  .setType("text/html")<br/>  .setHtmlText(shareHtmlText)<br/>  .setSubject("Definitely read this")<br/>  .addEmailTo(importantPersonEmailAddress)<br/>  .getIntent();</span></pre><p id="44d4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这里的不同之处在于，我们使用了<a class="ae jj" href="http://developer.android.com/reference/android/support/v4/app/ShareCompat.IntentBuilder.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#setHtmlText(java.lang.String)" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> setHtmlText() </em> </a>来代替<em class="jk"> setText() </em>以及一个mime类型的<em class="jk"> text/html </em>来代替<em class="jk"> text/plain </em>。这里<em class="jk"> ShareCompat </em>实际上做了一点额外的事情:<em class="jk"> setHtmlText() </em>还使用<a class="ae jj" href="http://developer.android.com/reference/android/text/Html.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#fromHtml(java.lang.String)" rel="noopener ugc nofollow" target="_blank"><em class="jk">html . from html()</em></a>来创建一个回退格式的文本，如果你自己以前没有调用过<em class="jk"> setText() </em>的话，它将传递给接收应用程序。</p><p id="fe02" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">鉴于许多可以接收HTML文本的应用程序都是电子邮件客户端，有许多帮助方法可以将主题设置为:，抄送:，密件抄送:电子邮件地址，考虑在任何共享意图中至少添加一个主题，以实现与电子邮件应用程序的最佳兼容性。</p><p id="5044" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当然，您仍然需要像以前一样调用<em class="jk">resolve activity()</em>——没有任何变化。</p><h1 id="1db4" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">接收文本</h1><p id="116d" class="pw-post-body-paragraph il im hh in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ha bi translated">虽然到目前为止，我们关注的是发送端，但是了解另一端到底发生了什么是很有帮助的(如果不仅仅是构建一个简单的接收应用程序来安装在您的仿真器上进行测试的话)。接收活动将一个<a class="ae jj" href="http://developer.android.com/guide/components/intents-filters.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">意图过滤器</a>添加到活动中:</p><pre class="jl jm jn jo fd ku kv kw kx aw ky bi"><span id="3ba7" class="kz js hh kv b fi la lb l lc ld">&lt;activity android:name=”.ShareActivity”&gt;<br/>  &lt;intent-filter&gt;<br/>    &lt;action android:name=”android.intent.action.SEND”/&gt;<br/>    &lt;category android:name=”android.intent.category.DEFAULT”/&gt;<br/>    &lt;category android:name=”android.intent.category.BROWSABLE”/&gt;<br/>    &lt;data android:mimeType=”text/plain”/&gt;<br/>  &lt;/intent-filter&gt;<br/>&lt;/activity&gt;</span></pre><p id="559c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">动作显然是更关键的部分——如果没有它，就没有什么能表明这是一个<em class="jk">动作_发送</em>(分享背后的动作)。mime类型，与我们的发送代码一样，也出现在这里。不太明显的是这两个类别。从<a class="ae jj" href="http://developer.android.com/guide/topics/manifest/category-element.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">的&lt;类&gt;元素文档</a>:</p><blockquote class="le lf lg"><p id="b6fd" class="il im jk in b io ip iq ir is it iu iv lh ix iy iz li jb jc jd lj jf jg jh ji ha bi translated"><strong class="in hi">注意:</strong>为了接收隐式意图，您必须在意图过滤器中包含CATEGORY_DEFAULT类别。startActivity()和startActivityForResult()方法将所有意图视为声明了CATEGORY_DEFAULT类别。如果您没有在意图过滤器中声明它，那么没有隐含的意图会解析到您的活动中。</p></blockquote><p id="cc66" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">所以我们的用例需要<em class="jk"> CATEGORY_DEFAULT </em>。然后，<a class="ae jj" href="http://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#CATEGORY_BROWSABLE" rel="noopener ugc nofollow" target="_blank"><em class="jk">CATEGORY _ BROWSABLE</em></a>允许<a class="ae jj" href="https://paul.kinlan.me/sharing-natively-on-android-from-the-web?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">网页本地共享到应用</a>中，而不需要接收端的任何额外工作。</p><p id="f78d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">而要真正从意图中提取信息，有用的<a class="ae jj" href="http://developer.android.com/reference/android/support/v4/app/ShareCompat.IntentReader.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> ShareCompat。可以使用IntentReader </em> </a>:</p><pre class="jl jm jn jo fd ku kv kw kx aw ky bi"><span id="d766" class="kz js hh kv b fi la lb l lc ld">ShareCompat.IntentReader intentReader =<br/>    ShareCompat.IntentReader.from(activity);<br/>if (intentReader.isShareIntent()) {<br/>  String[] emailTo = intentReader.getEmailTo();<br/>  String subject = intentReader.getSubject();<br/>  String text = intentReader.getHtmlText();<br/>  // Compose an email<br/>}</span></pre><p id="30bd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">与<em class="jk"> IntentBuilder </em>类似，<em class="jk"> IntentReader </em>只是一个简单的包装器，使得提取信息变得容易。</p><h1 id="ad2c" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">共享文件和图像</h1><p id="7e50" class="pw-post-body-paragraph il im hh in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ha bi translated">虽然发送和接收文本足够简单(创建文本，将其包含在<em class="jk">意图</em>中)，但发送文件(尤其是图像——目前最常见的类型)还有一个额外的难题:文件权限。</p><p id="3079" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">您可以尝试的最简单的代码可能如下所示</p><pre class="jl jm jn jo fd ku kv kw kx aw ky bi"><span id="5c41" class="kz js hh kv b fi la lb l lc ld">File imageFile = ...;<br/>Uri uriToImage = ...; // Convert the File to a Uri</span><span id="9b1f" class="kz js hh kv b fi lk lb l lc ld">Intent shareIntent = ShareCompat.IntentBuilder.from(activity)<br/>  .setType("image/png")<br/>  .setStream(uriToImage)<br/>  .getIntent();</span></pre><p id="59cd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这几乎是可行的——棘手的部分是获得其他应用程序实际可以读取的<em class="jk">文件</em>的<em class="jk"> Uri </em>，特别是当涉及Android 6.0棉花糖设备和<a class="ae jj" href="http://developer.android.com/training/permissions/requesting.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">运行时权限</a>(包括现在危险的<a class="ae jj" href="http://developer.android.com/reference/android/Manifest.permission.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#READ_EXTERNAL_STORAGE" rel="noopener ugc nofollow" target="_blank"><em class="jk">READ _ EXTERNAL _ STORAGE</em></a>和<a class="ae jj" href="http://developer.android.com/reference/android/Manifest.permission.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#WRITE_EXTERNAL_STORAGE" rel="noopener ugc nofollow" target="_blank"><em class="jk">WRITE _ EXTERNAL _ STORAGE</em></a>权限)。</p><p id="7cec" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我的恳求:<strong class="in hi">不要用<em class="jk"> Uri.fromFile() </em> </strong>。它强制接收应用程序具有<em class="jk"> READ_EXTERNAL_STORAGE </em>权限，如果你试图在用户之间<a class="ae jj" href="http://developer.android.com/training/enterprise/app-compatibility.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#sharing_files" rel="noopener ugc nofollow" target="_blank">共享，它根本不起作用，而且在KitKat之前，会要求你的应用程序具有<em class="jk"> WRITE_EXTERNAL_STORAGE </em>。而真正重要的共享目标，如</a><a class="ae jj" href="https://play.google.com/store/apps/details?id=com.google.android.gm?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> Gmail </a>，没有<em class="jk"> READ_EXTERNAL_STORAGE </em>权限——所以只会失败。</p><p id="f725" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">相反，你可以使用<a class="ae jj" href="http://developer.android.com/guide/topics/security/permissions.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#uri" rel="noopener ugc nofollow" target="_blank"> URI权限</a>来授予其他应用访问特定URI的权限。虽然URI权限不能在由<em class="jk"> Uri.fromFile() </em>生成的<em class="jk"> file:// </em> URIs上工作，但是它们可以在与<a class="ae jj" href="http://developer.android.com/guide/topics/providers/content-providers.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">内容提供商</a>相关联的Uri上工作。你<strong class="in hi">可以并且应该使用</strong><a class="ae jj" href="http://developer.android.com/reference/android/support/v4/content/FileProvider.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><strong class="in hi"><em class="jk">File provider</em></strong></a>，而不是仅仅为此实现你自己的。</p><p id="b5b4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一旦设置好，我们的代码就变成了:</p><pre class="jl jm jn jo fd ku kv kw kx aw ky bi"><span id="94e5" class="kz js hh kv b fi la lb l lc ld">File imageFile = ...;<br/>Uri uriToImage = <strong class="kv hi">FileProvider.getUriForFile</strong>(<br/>    context, FILES_AUTHORITY, imageFile);</span><span id="11c3" class="kz js hh kv b fi lk lb l lc ld">Intent shareIntent = ShareCompat.IntentBuilder.from(activity)<br/>  .setStream(uriToImage)<br/>  .getIntent();<br/>// Provide read access<br/>shareIntent.setData(uriToImage);<br/>shareIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span></pre><p id="eeb8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用<a class="ae jj" href="http://developer.android.com/reference/android/support/v4/content/FileProvider.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#getUriForFile(android.content.Context,%20java.lang.String,%20java.io.File)" rel="noopener ugc nofollow" target="_blank">file provider . geturiforfile()</a>，你将获得一个<em class="jk"> Uri </em>，它实际上适合发送给另一个应用程序——他们将能够在没有任何存储权限的情况下读取它——相反，你使用<a class="ae jj" href="http://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#FLAG_GRANT_READ_URI_PERMISSION" rel="noopener ugc nofollow" target="_blank"><em class="jk">FLAG _ GRANT _ READ _ URI _ PERMISSION</em></a>专门授予他们读取权限。</p><blockquote class="le lf lg"><p id="3858" class="il im jk in b io ip iq ir is it iu iv lh ix iy iz li jb jc jd lj jf jg jh ji ha bi translated"><strong class="in hi">注意:</strong>在构建我们的<em class="hh"> ShareCompat时，我们不会在任何地方调用<em class="hh"> setType() </em>(尽管在视频中我确实设置了)</em>。正如在<a class="ae jj" href="http://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#setDataAndType(android.net.Uri,%20java.lang.String)" rel="noopener ugc nofollow" target="_blank"><em class="hh">setDataAndType()</em>Javadoc</a>中所解释的，类型是使用<em class="hh"> getContentResolver()从数据URI中自动推断出来的。getType(uriToImage) </em>。由于<em class="hh"> FileProvider </em>自动返回正确的mime类型，我们根本不需要手动指定mime类型。</p></blockquote><p id="472c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您有兴趣了解更多关于避免存储权限的信息，可以考虑观看我的<a class="ae jj" href="https://www.youtube.com/watch?v=C28pvd2plBA?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">忘记存储权限讲座</a>或者至少浏览一下<a class="ae jj" href="https://speakerdeck.com/ianhanniballake/forget-the-storage-permission-alternatives-for-sharing-and-collaborating?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">幻灯片</a>，在<a class="ae jj" href="https://youtu.be/C28pvd2plBA?t=893&amp;utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> 14:55 </a>(幻灯片11)中深入讨论了这个主题。</p><h1 id="dfd4" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">接收文件</h1><p id="38ad" class="pw-post-body-paragraph il im hh in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ha bi translated">接收文件和接收文本没有太大区别，因为你仍然要使用ShareCompat。意图者。例如，要将一个传入的文件制作成一个<em class="jk">位图</em>，看起来应该是这样的:</p><pre class="jl jm jn jo fd ku kv kw kx aw ky bi"><span id="7edf" class="kz js hh kv b fi la lb l lc ld">Uri uri = ShareCompat.IntentReader.from(activity).getStream();<br/>Bitmap bitmap = null;</span><span id="dd30" class="kz js hh kv b fi lk lb l lc ld">try {<br/>  // Works with content://, file://, or android.resource:// URIs<br/>  InputStream inputStream =<br/>      getContentResolver().openInputStream(uri);<br/>  bitmap = BitmapFactory.decodeStream(inputStream);<br/>} catch (FileNotFoundException e) {<br/>  // Inform the user that things have gone horribly wrong<br/>}</span></pre><p id="359a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当然，您可以自由地使用InputStream做任何您想做的事情——注意那些太大的图像，以至于遇到了<em class="jk"> OutOfMemoryException </em>。你所知道的关于<a class="ae jj" href="http://developer.android.com/training/displaying-bitmaps/load-bitmap.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">加载位图</a>的所有事情仍然适用。</p><h1 id="4b4f" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">支持库是你的朋友</h1><p id="be43" class="pw-post-body-paragraph il im hh in b io kp iq ir is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ha bi translated">有了<a class="ae jj" href="http://developer.android.com/reference/android/support/v4/app/ShareCompat.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> ShareCompat </em> </a>(及其<a class="ae jj" href="http://developer.android.com/reference/android/support/v4/app/ShareCompat.IntentBuilder.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> IntentBuilder </em> </a>和<a class="ae jj" href="http://developer.android.com/reference/android/support/v4/app/ShareCompat.IntentReader.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> IntentReader </em> </a>)和<a class="ae jj" href="http://developer.android.com/tools/support-library/features.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog#v4" rel="noopener ugc nofollow" target="_blank"> v4支持库</a>中的<a class="ae jj" href="http://developer.android.com/reference/android/support/v4/content/FileProvider.html?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jk"> FileProvider </em> </a>，默认情况下，您将能够在您的应用程序中包括共享文本、HTML文本和文件。</p><p id="73c6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"># BuildBetterApps</p><p id="edf2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">关注<a class="ae jj" href="https://plus.google.com/collection/sLR0p?utm_campaign=android_series_sharingcontent_012116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> Android开发模式集合</a>了解更多！</p><figure class="jl jm jn jo fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/ede78edee0069962aa0daa7cc8c85f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6K7IYkWhCzkS6YAgxLfXw.png"/></div></div></figure></div></div>    
</body>
</html>