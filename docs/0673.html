<html>
<head>
<title>Introduction to Paging 3.0 in the MAD Skills Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MAD技能系列中的分页3.0介绍</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/introduction-to-paging-3-0-in-the-mad-skills-series-648f77231121?source=collection_archive---------1-----------------------#2021-10-11">https://medium.com/androiddevelopers/introduction-to-paging-3-0-in-the-mad-skills-series-648f77231121?source=collection_archive---------1-----------------------#2021-10-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/ec3aed893acac649e393e9ce71ba397f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_ZJwMHs17SmEFr3uEbxDg.png"/></div></div></figure><div class=""/><p id="9aa8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">欢迎来到寻呼3.0 MAD技能系列！在本文中，我将介绍分页3.0，并强调如何将其集成到应用程序的数据层中。想看看书？点击这里查看这一集的视频！</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="jr js l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Paging MAD Skills episode 1</figcaption></figure><h1 id="3081" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">为什么选择分页3.0？</h1><p id="e58c" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">向用户显示数据列表是最常见的UI模式之一。在处理大型数据集时，您可以通过以块为单位异步获取/显示数据来提高应用程序性能并减少内存使用。这是一个非常常见的模式，让一个库提供一个促进这一点的抽象是一个巨大的好处。这些都是分页3.0从容解决的用例。作为额外的好处，它还允许您的应用程序支持无限数据集，如果您正在下载网络数据，它还提供了本地缓存的途径。</p><p id="ea6a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您目前正在使用分页2.0，分页3.0提供了一系列超越其前身的改进，包括:</p><ul class=""><li id="97f7" class="la lb hs ir b is it iw ix ja lc je ld ji le jm lf lg lh li bi translated">对Kotlin协程和流的一流支持。</li><li id="1d22" class="la lb hs ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">使用RxJava Single或Guava ListenableFuture原语支持异步加载。</li><li id="ba49" class="la lb hs ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">响应性UI设计的内置加载状态和错误信号，包括重试和刷新功能。</li><li id="de4b" class="la lb hs ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">对存储库层的改进，包括取消支持和简化的数据源接口。</li><li id="bb46" class="la lb hs ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">对表示层、列表分隔符、自定义页面转换以及加载状态页眉和页脚的改进。</li></ul><p id="5921" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请务必查看分页2.0到分页3.0 <a class="ae lo" href="https://developer.android.com/topic/libraries/architecture/paging/v3-migration" rel="noopener ugc nofollow" target="_blank">迁移指南</a>了解更多信息。</p><h2 id="b5a6" class="lp jy hs bd jz lq lr ls kd lt lu lv kh ja lw lx kl je ly lz kp ji ma mb kt mc bi translated">扔进去</h2><p id="aaf9" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">在您的应用程序架构方案中，分页3.0最适合作为从数据层获取数据的方式，并通过<code class="du md me mf mg b">ViewModel</code>在UI层进行转换和呈现。在Paging 3.0中，对数据层的访问是通过一个称为<code class="du md me mf mg b">PagingSource</code>的类型来实现的，这个类定义了如何在由<code class="du md me mf mg b">PagingConfig</code>定义的边界周围获取和刷新数据。</p><p id="190a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个<code class="du md me mf mg b">PagingSource</code>，类似于一个<code class="du md me mf mg b">Map</code>，由两个通用类型定义:其分页键的类型和加载数据的类型。例如，从基于页面的Github API获取<code class="du md me mf mg b">Repo</code>项的<code class="du md me mf mg b">PagingSource</code>的声明将被定义为:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="mh js l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">PagingSource definition</figcaption></figure><p id="3738" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">PagingSource需要实现两个抽象方法才能完全发挥作用:</p><ol class=""><li id="d433" class="la lb hs ir b is it iw ix ja lc je ld ji le jm mi lg lh li bi translated"><code class="du md me mf mg b">load()</code></li><li id="5529" class="la lb hs ir b is lj iw lk ja ll je lm ji ln jm mi lg lh li bi translated"><code class="du md me mf mg b">getRefreshKey()</code></li></ol><h1 id="19f8" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">加载方法</h1><p id="d697" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated"><code class="du md me mf mg b">load()</code>方法，就像它的名字所暗示的那样，被分页库调用来异步获取要显示的数据。这或者是为了初始加载，或者是为了响应用户的滚动。可以从作为参数传递给方法的LoadParams对象中确定调用load的触发器。它保存与加载操作相关的信息，包括以下内容:</p><ul class=""><li id="d3f2" class="la lb hs ir b is it iw ix ja lc je ld ji le jm lf lg lh li bi translated">待加载页面的按键:如果是第一次调用加载(初始加载)，则<code class="du md me mf mg b">LoadParams.key</code>为<code class="du md me mf mg b">null</code>。在这种情况下，您必须定义初始页面键。</li><li id="eac0" class="la lb hs ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">加载大小:请求加载的项目数。</li></ul><p id="a877" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">负载的返回类型为<code class="du md me mf mg b">LoadResult</code>。它可以是:</p><ul class=""><li id="d01c" class="la lb hs ir b is it iw ix ja lc je ld ji le jm lf lg lh li bi translated"><code class="du md me mf mg b">LoadResult.Page</code>:成功加载。</li><li id="ba2d" class="la lb hs ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated"><code class="du md me mf mg b">LoadResult.Error</code>:出现错误时使用。</li></ul><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="mh js l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">load implementation</figcaption></figure><p id="6c0b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，默认情况下，初始加载大小是3 *页面大小。这确保了第一次加载列表时，如果用户滚动一点，用户将看到足够多的条目，而不会触发太多的网络请求。这也是在<code class="du md me mf mg b">PagingSource</code>实现中计算下一个键时要考虑的事情。</p><h1 id="f305" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">getRefreshKey方法</h1><p id="340d" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">刷新键用于对<code class="du md me mf mg b">PagingSource.load()</code>的后续刷新调用(第一次调用是初始加载，它使用提供给寻呼机的初始键)。每当分页库想要加载新数据来替换当前列表时，例如，在滑动以刷新时，或者在由于数据库更新、配置改变、进程死亡等而无效时，都会发生刷新。通常，后续的刷新调用将希望重新开始加载以代表最近访问的索引的<code class="du md me mf mg b">PagingState.anchorPosition</code>为中心的数据。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="mh js l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">getRefreshKey implementation</figcaption></figure><h1 id="fe62" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">寻呼机对象</h1><p id="42b8" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">定义了<code class="du md me mf mg b">PagingSource</code>之后，我们现在可以创建一个<code class="du md me mf mg b">Pager</code>。一个<code class="du md me mf mg b">Pager</code>是一个类，它负责按照UI的请求从<code class="du md me mf mg b">PagingSource</code>中逐步提取数据块。由于<code class="du md me mf mg b">Pager</code>需要访问<code class="du md me mf mg b">PagingSource</code>，它通常在定义<code class="du md me mf mg b">PagingSource</code>的数据层中创建。</p><p id="da5f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">构建<code class="du md me mf mg b">Pager</code>需要的第二件事是<code class="du md me mf mg b">PagingConfig</code>，它定义了控制<code class="du md me mf mg b">Pager</code>如何获取数据的参数。它公开了相当多的可选参数，让您可以微调分页器的行为，但是<code class="du md me mf mg b">pageSize</code>参数是必需的。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="mh js l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Creating a Pager</figcaption></figure><p id="1dbf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是构建上述<code class="du md me mf mg b">PagingConfig</code>时使用的参数的简要描述:</p><ul class=""><li id="e653" class="la lb hs ir b is it iw ix ja lc je ld ji le jm lf lg lh li bi translated"><code class="du md me mf mg b">pageSize</code>:从<code class="du md me mf mg b">PagingSource</code>一次装载的物品数量。</li><li id="b567" class="la lb hs ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated"><code class="du md me mf mg b">enablePlaceholders</code>:对于尚未加载的项目，<code class="du md me mf mg b">PagingData</code>是否返回空值。</li></ul><p id="f85e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们通常希望<code class="du md me mf mg b">pageSize</code>足够大(至少足够填充屏幕的可见区域，但最好是2-3倍)，这样<code class="du md me mf mg b">Pager</code>就不必在用户滚动时反复读取数据以在屏幕上显示足够的内容。</p><h1 id="2a66" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">获取您的数据</h1><p id="b5d7" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">由<code class="du md me mf mg b">Pager</code>产生的类型是<code class="du md me mf mg b">PagingData</code>，这种类型提供了一个进入其背面的独特窗口<code class="du md me mf mg b">PagingSource</code>。当用户滚动列表时，分页数据将继续从<code class="du md me mf mg b">PagingSource</code>获取以提供内容。如果<code class="du md me mf mg b">PagingSource</code>无效，将发出一个新的<code class="du md me mf mg b">PagingData</code>，以确保分页的项目与用户界面中显示的项目同步。将<code class="du md me mf mg b">PagingData</code>视为某个时间点上<code class="du md me mf mg b">PagingSource</code>的快照可能会有所帮助。</p><p id="b687" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于<code class="du md me mf mg b">PagingSource</code>是在<code class="du md me mf mg b">PagingSource</code>无效时会发生变化的快照，因此分页库提供了多种将<code class="du md me mf mg b">PagingData</code>作为流使用的方式，包括:</p><ul class=""><li id="eafb" class="la lb hs ir b is it iw ix ja lc je ld ji le jm lf lg lh li bi translated">柯特林流过<code class="du md me mf mg b">Pager.flow</code></li><li id="1f43" class="la lb hs ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">LiveData通过<code class="du md me mf mg b">Pager.liveData</code></li><li id="abd7" class="la lb hs ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">RxJava可通过<code class="du md me mf mg b">Pager.flowable</code>流动</li><li id="8c82" class="la lb hs ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">RxJava可通过<code class="du md me mf mg b">Pager.observable</code>观察到</li></ul><p id="b7b1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种<code class="du md me mf mg b">PagingData</code>流是<code class="du md me mf mg b">ViewModel</code>在将分页项目呈现给用户界面之前可以选择转换的。</p><h1 id="1545" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">下一步是什么？</h1><p id="6070" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">有了以上这些，我们已经将Paging 3.0集成到了应用程序的数据层！请继续关注，看看如何在用户界面中使用分页数据，并填充我们的转发列表！</p></div></div>    
</body>
</html>