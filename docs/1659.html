<html>
<head>
<title>Using Multi-Stage Builds to Simplify And Standardize Build Processes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用多阶段构建来简化和标准化构建过程</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/multi-stage-builds-and-dockerfile-b5866d9e2f84?source=collection_archive---------1-----------------------#2019-03-14">https://medium.com/capital-one-tech/multi-stage-builds-and-dockerfile-b5866d9e2f84?source=collection_archive---------1-----------------------#2019-03-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/75a909a69083007d9e734abb0f070bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygy76Sn3ubLQ-WYNQnUdFw.png"/></div></div></figure><h1 id="1e1b" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="ac1b" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Capital One DevOps工程师面临的挑战之一是为他们的开发人员提供一致的构建、运行和部署环境。在我的例子中，我的开发人员支持大约65个不同的网站，这意味着维护管道和构建过程很快变得复杂。为了满足合规性，保持代码质量，并防止问题，我们在构建中加入了各种工具和测试；依靠CICD平台来管理这些测试和工具过于依赖外部依赖，如Jenkins插件升级、CICD平台上的二进制升级以及底层软件的新版本。</p><p id="e194" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">想象一个应用程序的普通管道。它可能看起来像这样:</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/81bcf577f13c2a0bb00cf7ab43331113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eAFcZ68_pRDO6phu"/></div></div></figure><p id="0735" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">每个阶段——构建、lint、测试(单元、集成、可访问性和回归)、静态代码分析、动态代码分析以及最终的部署——都需要访问不同的工具、系统和二进制文件。每次开发人员运行一个构建或推送到GitHub时，他们可能会发现管道中的新问题，并不得不迭代解决它们。这将我们希望开发人员拥有的信息推到了开发过程的右边，这是次优的。可以对该过程进行两种改进:</p><ol class=""><li id="2c75" class="kv kw hh jp b jq kl ju km jy kx kc ky kg kz kk la lb lc ld bi translated"><strong class="jp hi">将信息左移— </strong>无论是安全性、合规性、可访问性、代码覆盖率还是林挺，我们都希望开发人员能够在流程的早期获得结果。</li><li id="035d" class="kv kw hh jp b jq le ju lf jy lg kc lh kg li kk la lb lc ld bi translated"><strong class="jp hi">标准化命令— </strong>这样，无论特定的阶段在哪里运行，都会返回相同的结果。</li></ol><p id="c1cd" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">多阶段Dockerfile构建以一种优雅的方式解决了这两个问题。利用多阶段Dockerfiles意味着开发人员可以运行与CICD服务器完全相同的命令，并且因为它运行在一个容器中，所以每次都应该返回相同的结果。</p><h1 id="52e8" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">什么是多阶段构建？</h1><p id="85c5" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">多阶段构建是一种组织Docker文件的方法，可以最小化最终容器的大小，提高运行时性能，更好地组织Docker命令和文件，并提供运行构建操作的标准化方法。多阶段构建是通过创建done文件的不同部分来完成的，每个部分引用一个不同的基本映像。这允许多阶段构建通过使用多个docker文件、在容器之间复制文件或运行不同的管道来实现先前填充的功能。</p><p id="25cb" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">更多关于多级船坞建造规格的具体阅读请见<a class="ae lj" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">这里</a>。Docker文档很好地介绍了多阶段构建。然而，介绍并不是真实世界的例子。所以让我们深入一个。</p><h1 id="92f6" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">编写多阶段Dockerfile文件</h1><p id="d9eb" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">现在，我们已经了解了什么是多阶段构建，以及它要解决的问题，让我们尝试为我们的示例管道编写一个docker文件——涵盖构建、lint、测试、静态代码分析、动态代码分析，最后是部署。</p><h1 id="9fa1" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">建筑物</h1><p id="b328" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">对于这个示例，我们将通过管道放置一个节点应用程序，并且我们将使用一个多级docker文件来完成这项工作。为此，我们将使用一个运行NPM安装的基本docker文件。现在，我们要做的就是添加一个标题。</p><pre class="kr ks kt ku fd lk ll lm ln aw lo bi"><span id="eb70" class="lp iq hh ll b fi lq lr l ls lt">```<br/># Copies in our code and runs NPM Install<br/>FROM node:latest as builder<br/>WORKDIR /usr/src/app<br/>COPY package* ./<br/>COPY src/ src/<br/>RUN [“npm”, “install”]</span><span id="c5f6" class="lp iq hh ll b fi lu lr l ls lt">```</span></pre><h1 id="15c9" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">林挺</h1><p id="e5fa" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">也许我们需要运行一个linter来对抗一组规则，比如AirBnB的ES6规则组。为此，我们将复制前一阶段——构建器——以确保我们不会以修改或额外的代码结束。我们只希望查看来自初始副本的代码。在我使用的eslinter的图形中，虽然有各种javascript linters可用，但另一种选择是jslint。</p><pre class="kr ks kt ku fd lk ll lm ln aw lo bi"><span id="7d1f" class="lp iq hh ll b fi lq lr l ls lt">```</span><span id="160c" class="lp iq hh ll b fi lu lr l ls lt"># Lints Code<br/>FROM node:latest as linting<br/>WORKDIR /usr/src/app<br/>COPY — from=builder /usr/src/app/src .<br/>RUN [“npm”, “lint”]</span><span id="be25" class="lp iq hh ll b fi lu lr l ls lt">```</span></pre><h1 id="d132" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">静态分析</h1><p id="26b8" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">像许多公司的许多应用程序一样，您可能会使用一些静态代码分析。这里我使用SonarQube作为例子，因为它是开源的，易于使用，易于设置。然而，您也可以为您的公司或应用程序使用的任何静态分析工具编写Dockerfile扫描器；在<a class="ae lj" href="https://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis" rel="noopener ugc nofollow" target="_blank">维基百科</a>上列出了Sonarqube的各种替代品。</p><pre class="kr ks kt ku fd lk ll lm ln aw lo bi"><span id="0e46" class="lp iq hh ll b fi lq lr l ls lt">```</span><span id="ae2d" class="lp iq hh ll b fi lu lr l ls lt"># Gets Sonarqube Scanner from Dockerhub and runs it<br/>FROM newtmitch/sonar-scanner:latest as sonarqube<br/>COPY — from=builder /usr/src/app/src /root/src</span><span id="e209" class="lp iq hh ll b fi lu lr l ls lt">```</span></pre><h1 id="7cb1" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">单元测试</h1><p id="73fc" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">希望您正在编写单元测试，对吗？并且确保您已经用测试覆盖了您的业务逻辑代码，这些测试显示是否发生了错误，数据是否被验证，等等。？这是一个简单的、一般化的例子，但是它确保了通过从先前的测试阶段复制来只测试预期的代码。这有助于保证可重复的结果。在图形/代码中，我使用jest来表示单元测试，尽管还有一长串的测试框架。例子包括:JSUnit、Mocha和Jasmine。</p><pre class="kr ks kt ku fd lk ll lm ln aw lo bi"><span id="4649" class="lp iq hh ll b fi lq lr l ls lt">```</span><span id="edf0" class="lp iq hh ll b fi lu lr l ls lt"># Runs Unit Tests<br/>FROM node:latest as unit-tests<br/>WORKDIR /usr/src/app<br/>COPY --from=builder /usr/src/app/ .<br/>RUN [“npm”, “test”]<br/>```</span></pre><h1 id="0238" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">可访问性测试</h1><p id="3002" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">类似于单元测试，我们运行任何需要的可访问性测试。希望你这样做是为了让色盲的人可以使用你的应用程序/网站。关于可访问性测试的更多信息，请参见这篇<a class="ae lj" href="https://marcysutton.github.io/a11y-automated-testing/#/" rel="noopener ugc nofollow" target="_blank">文章</a>。在图形和代码中，我使用Pa11y来表示单元测试，尽管有开源和闭源的替代方案，如Paypal的AATT。</p><pre class="kr ks kt ku fd lk ll lm ln aw lo bi"><span id="64cf" class="lp iq hh ll b fi lq lr l ls lt">```</span><span id="b1e7" class="lp iq hh ll b fi lu lr l ls lt"># Runs Accessibility Tests<br/>FROM node:latest as access-tests<br/>WORKDIR /usr/src/app<br/>COPY --from=builder /usr/src/app/ .<br/>RUN [“npm”, “access-tests”]<br/>```</span></pre><h1 id="8840" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">启动应用程序</h1><p id="c419" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">最后是实际应用阶段。在此阶段，我们从目标复制构建文件和任何package.json/package-lock.json文件，然后运行npm start。然而，如果您使用其他语言/方法运行应用程序，这显然会有所不同。</p><pre class="kr ks kt ku fd lk ll lm ln aw lo bi"><span id="8ee1" class="lp iq hh ll b fi lq lr l ls lt">```</span><span id="1846" class="lp iq hh ll b fi lu lr l ls lt"># Starts and Serves Web Page<br/>FROM node:latest as serve<br/>WORKDIR /usr/src/app<br/>COPY --from=builder /usr/src/app/dest ./<br/>COPY --from=builder /usr/src/app/package* ./<br/>RUN [“npm”, “start”]</span><span id="99f1" class="lp iq hh ll b fi lu lr l ls lt">```</span></pre><p id="71e9" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">既然我们已经编写了每个单独的阶段，那么完整的docker文件将类似于这样:</p><pre class="kr ks kt ku fd lk ll lm ln aw lo bi"><span id="017e" class="lp iq hh ll b fi lq lr l ls lt"># Copies in our code and runs NPM Install<br/>FROM node:latest as builder<br/>WORKDIR /usr/src/app<br/>COPY package* ./<br/>COPY src/ src/<br/>RUN [“npm”, “install”]</span><span id="4e22" class="lp iq hh ll b fi lu lr l ls lt"># Lints Code<br/>FROM node:latest as linting<br/>WORKDIR /usr/src/app<br/>COPY --from=builder /usr/src/app/ .<br/>RUN [“npm”, “lint”]</span><span id="e50e" class="lp iq hh ll b fi lu lr l ls lt"># Gets Sonarqube Scanner from Dockerhub and runs it<br/>FROM newmitch/sonar-scanner:latest as sonarqube<br/>COPY --from=builder /usr/src/app/src /root/src</span><span id="04c2" class="lp iq hh ll b fi lu lr l ls lt"># Runs Unit Tests<br/>FROM node:latest as unit-tests<br/>WORKDIR /usr/src/app<br/>COPY --from=builder /usr/src/app/ .<br/>RUN [“npm”, “test”]</span><span id="11f0" class="lp iq hh ll b fi lu lr l ls lt"># Runs Accessibility Tests<br/>FROM node:latest as access-tests<br/>WORKDIR /usr/src/app<br/>COPY --from=builder /usr/src/app/ .<br/>RUN [“npm”, “access-tests”]</span><span id="9e23" class="lp iq hh ll b fi lu lr l ls lt"># Starts and Serves Web Page<br/>FROM node:latest as serve<br/>WORKDIR /usr/src/app<br/>COPY --from=builder /usr/src/app/dest ./<br/>COPY --from=builder /usr/src/app/package* ./<br/>RUN [“npm”, “start”]</span></pre><p id="2a0e" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">您会注意到，在每个部分中，在基本图像之后，有一个如下列出的名称:<code class="du lv lw lx ll b">as</code>这允许通过do:<code class="du lv lw lx ll b">docker build --target builder -t example-node:latest</code>来运行各个部分。如果你想运行你的单元测试，你可以通过<code class="du lv lw lx ll b">docker build --target unit-tests -t example-node:latest</code>来运行它们。当需要为运行/部署构建应用程序时，您可以像构建任何其他容器一样使用<code class="du lv lw lx ll b">docker build -t example-node:latest</code>来构建它。这将在一个小的、可部署的映像中生成最终的应用程序容器。</p><p id="1a89" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这使得开发人员可以很快在本地看到与等待CICD服务器返回相同的结果。这也允许开发人员确定当CICD服务器调用或构建特定部分时将运行什么命令。</p><h1 id="fd0b" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">为什么不使用多阶段构建</h1><p id="108f" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">使用多阶段构建有很多很好的理由。可以创建一个阶段，根据不同的环境进行不同的构建，或者将不同的数据加载到基于特定客户端的应用程序中，这种可能性是无限的。但是多阶段构建并不总是有意义的。</p><p id="d818" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">虽然多阶段构建提供了跨构建和运行环境的一致性，但在组织构建和运行阶段、增加docker文件的物理大小和逻辑组织以及管理阶段之间复制的文件方面存在挑战。如果您试图使docker文件尽可能简单，多阶段构建可能也不适合您，因为您的开发人员不像他们的传统工具那样习惯于它。它还需要围绕应用程序中常见的钩子进行讨论，例如，<code class="du lv lw lx ll b">build</code>命令将总是产生一个构建好的工件。这些不一定是使用多阶段构建所独有的，但是在你编写阶段时要记住。这些问题通常会作为代码在Jenkinsfile或其他管道中解决。虽然您移动了阶段和信息，但也增加了管理中间Docker容器、映像和依赖项的复杂性。</p><h1 id="b9bb" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">为什么使用多阶段构建</h1><p id="b21b" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">多阶段构建允许您将需要单独docker文件的构建、测试和运行时环境分开。它们允许您最小化您部署的最终Docker容器的实际大小，因为各种层不再存储在最终容器中。这可以将你的容器减少一半，甚至三分之二，这取决于你的阶段和用例。它还允许您确保部署的容器中没有额外的二进制文件，从而减少您的攻击媒介。它可以很容易地突出您构建过程中的低效之处，并允许统一优化，因为只需更新Dockerfile/base映像。这可以让您标准化您的命令，防止不必要的混乱，并移动在编写代码过程中留下的信息。</p><p id="dea1" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">多阶段构建的另一个好处是能够并行运行各个步骤/阶段。随着您的测试框架和存储库的增长，集成也在增长，并且需求改变了同时运行所有阶段的能力，并且减少了使用任何CICD工具或本地的构建时间。消除开发人员获取信息的时间障碍是DevOps的基础部分，它的目标是将信息向左移动，多阶段构建是如何在独立的阶段并行运行以获得开发人员所需的东西的一个很好的代表。</p><p id="ec71" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">多阶段构建简化了我的团队的许多CICD管道，并为我们的开发人员提供了一种在生产部署过程中与各种预期关口进行交互的简单方法。这极大地提高了我们应用程序的一致性，并为我们的开发人员和审计人员提供了一个统一的获取结果的方法。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><a href="https://criticalstack.com/"><div class="er es ly"><img src="../Images/4ad80896d23dc47884fbccb544026789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YAXq5H29jZ4r3mHZ"/></div></a></figure></div><div class="ab cl lz ma go mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ha hb hc hd he"><h2 id="2abf" class="lp iq hh bd ir mg mh mi iv mj mk ml iz jy mm mn jd kc mo mp jh kg mq mr jl ms bi translated">相关:</h2><ul class=""><li id="bfdb" class="kv kw hh jp b jq jr ju jv jy mt kc mu kg mv kk mw lb lc ld bi translated"><a class="ae lj" rel="noopener" href="/capital-one-tech/secure-docker-containers-require-secure-applications-75eb358abef9">安全Docker容器需要安全应用</a></li><li id="c162" class="kv kw hh jp b jq le ju lf jy lg kc lh kg li kk mw lb lc ld bi translated"><a class="ae lj" rel="noopener" href="/capital-one-tech/the-whale-in-the-refrigerator-80f659fea1a4">冰箱里的鲸鱼——码头工人简介</a></li><li id="3d50" class="kv kw hh jp b jq le ju lf jy lg kc lh kg li kk mw lb lc ld bi translated"><a class="ae lj" rel="noopener" href="/capital-one-tech/whale-in-the-grocery-store-an-introduction-to-docker-and-docker-images-311319688692">杂货店里的鲸鱼Docker文件和Docker图像介绍</a></li></ul></div><div class="ab cl lz ma go mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ha hb hc hd he"><p id="02eb" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这些是作者的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2019首都一。</p></div></div>    
</body>
</html>