# Python 中的切片是什么？

> 原文：<https://medium.com/duomly-blockchain-online-courses/what-is-slicing-in-python-8584abf2eabe?source=collection_archive---------1----------------------->

![](img/d0a9a6350c77b1fa3e2f0928649605a9.png)

[Duomly — programming online courses](https://www.duomly.com)

本文最初发表于[https://www.blog.duomly.com/slicing-in-python-what-is-it/](https://www.blog.duomly.com/slicing-in-python-what-is-it/)

Python 中的切片是一种支持访问字符串、元组和列表等序列部分的特性。您还可以使用它们来修改或删除可变序列的项目，如列表。切片还可以应用于第三方对象，如 NumPy 数组，以及 Pandas 系列和数据框。

切片使得编写干净、简洁、可读的代码成为可能。

本文展示了如何访问、修改和删除带有索引和切片的项目，以及如何使用内置的类 slice()。

[Slicing in Python](https://youtu.be/ZOxs7grEjWM)

# 索引

您可以使用相应的整数索引来访问 Python 序列的单个项目(如字符串、元组或列表)。Python 中的索引是从零开始的。这意味着索引 0 对应于序列的第一个(最左边的)项，1 对应于第二个项，依此类推。

让我们创建一个字符串、一个元组和一个列表来说明如何使用索引:

```
>>> str_ = 'Python is awesome!'
>>> str_
'Python is awesome!'
>>> tuple_ = (1, 2, 4, 8, 16, 32, 64, 128)
>>> tuple_
(1, 2, 4, 8, 16, 32, 64, 128)
>>> list_ = [1, 2, 4, 8, 16, 32, 64, 128]
>>> list_
[1, 2, 4, 8, 16, 32, 64, 128]
```

括号内提供了索引，即语法序列[index]:

```
>>> str_[0]
'P'
>>> str_[1]
'y'
>>> str_[4]
'o'
>>> tuple_[0]
1
>>> tuple_[1]
2
>>> tuple_[4]
16
>>> list_[0]
1
>>> list_[1]
2
>>> list_[4]
16
```

如你所见,“P”是字符串“Python 太棒了！”的第一个字符它对应的索引是 0，' y '是第二个，索引是 1，以此类推。

它与元组和列表非常相似。

Python 也提供了使用负整数索引的可能性。这在实践中似乎非常有用，尤其是当您想要访问序列的最后(最右边)项时。

索引-1 对应于最后一项，-2 对应于倒数第二项，依此类推:

```
>>> str_[-1]
'!'
>>> str_[-2]
'e'
>>> str_[-5]
's'
>>> tuple_[-1]
128
>>> tuple_[-2]
64
>>> tuple_[-5]
8
>>> list_[-1]
128
>>> list_[-2]
64
>>> list_[-5]
8
```

如你所见，字符'！'是字符串“Python 真棒！”中的最后一项它对应于索引-1。它还有索引 17，也就是 string_[17]返回'！'。字符“e”出现在它的前面，索引为-2 和 16。

同样，元组和列表的行为类似。

您可以使用索引来修改可变序列的项目。在 Python 中，字符串和元组是不可变的，但列表是可变的:

```
>>> list_[-1] = 100
>>> list_
[1, 2, 4, 8, 16, 32, 64, 100]
```

本示例将列表的最后一项更改为 100。因为这个列表有八个条目，所以您也可以使用从零开始的索引 7 来访问最后一个条目，也就是说，您可以使用语句 list_[7] = 100 来实现相同的效果。

# 限幅

切片类似于索引，但它返回一系列项目，而不是单个项目。用于切片的索引也是从零开始的。

切片语法有两种变体:sequence[start:stop]和 sequence[start:stop:step]。这篇文章解释了这两者。

当你使用语法序列[start:stop]时，你会得到新的序列。它将从索引开始(含)的项目开始，并在索引停止的项目之前结束*。换句话说，语句 sequence[start:stop]返回项目 sequence[start]，sequence[stop-1]以及它们之间的所有项目:*

```
>>> str_[1:5]
'ytho'
>>> tuple_[2:4]
(4, 8)
>>> tuple_[2:3]
(4,)
>>> tuple_[2:2]
()
```

如您所见，当 start + 1 == stop 时，返回序列只能包含一个项目，或者当 start == stop 时，它可以是一个空序列。

当您省略 start 时，取值 0，即结果序列从原始序列的开始处开始:

```
>>> str_[:2]
'Py'
>>> tuple_[:4]
(1, 2, 4, 8)
```

如果省略 stop，则产生的序列将在原始序列的末尾停止:

```
>>> str_[2:]
'thon is awesome!'
>>> tuple_[4:]
(16, 32, 64, 128)
```

同样，您可以省略 start 和 stop:

```
>>> str_[:]
'Python is awesome!'
>>> tuple_[:]
(1, 2, 4, 8, 16, 32, 64, 128)
>>> list_[:]
[1, 2, 4, 8, 16, 32, 64, 100]
```

这就是你如何得到一个序列的浅层拷贝。

可以像索引一样应用负值的开始和停止:

```
>>> str_[-8:]
'awesome!'
>>> tuple_[:-1]
(1, 2, 4, 8, 16, 32, 64)
>>> tuple_[-4:-2]
(8, 16)
>>> tuple_[3:5]
(8, 16)
```

在 tuple_ 的情况下，从-1 开始向后计数时，值-4 对应于从 0 开始向前计数时的值 3。对于值 5 和-2 也是一样的。同样，对应于索引停止点*的项目不包含在结果序列中。*

语法序列[start:stop:step]是相似的，但是细节更少。

如果要跳过某些项目，可以使用步骤来指定步骤:

```
>>> tuple_[1:5:2]
(2, 8)
```

在本例中，步骤为 2，因此您从索引为 1 的项目(项目 2)开始，每隔一个项目收集一次，并在到达索引为 5 的项目(32)之前停止。你拿第二项，跳过第四项，拿第八项。

如果步长为正，并且您省略了 start，则生成的序列将再次从原始序列的开始处开始。如果省略 stop，操作将在原始文件的末尾停止。然而，如果你省略了一个步骤，它被认为是 1，你会得到与语法序列[start:stop]相同的行为:

```
>>> tuple_[:6:2]
(1, 4, 16)
>>> tuple_[3::2]
(8, 32, 128)
>>> tuple_[1:5:]
(2, 4, 8, 16)
```

负值的步长与大于停止时间的开始时间相结合，可用于向后收集物料:

```
>>> tuple_[4:1:-1]
(16, 8, 4)
>>> tuple_[6:1:-2]
(64, 16, 4)
```

在负步长和省略 start 的情况下，结果序列从原始序列的结尾开始。如果省略 stop，操作将在原始文件的开头停止:

```
>>> tuple_[:2:-1]
(128, 64, 32, 16, 8)
>>> tuple_[5::-1]
(32, 16, 8, 4, 2, 1)
```

通过省略 start 和 stop，可以方便地应用这些规则来获得项目顺序相反的序列的浅层副本:

```
>>> tuple_[::-1]
(128, 64, 32, 16, 8, 4, 2, 1)
```

您可以使用切片来修改可变序列的项目:

```
>>> list_[1:6:2]
[2, 8, 32]
>>> list_[1:6:2] = [20, 80, 320]
>>> list_
[1, 20, 4, 80, 16, 320, 64, 100]
```

在这个例子中，具有索引 1、3 和 5 的项目被访问和修改。

如果使用语法 sequence[start:stop]，可以用更小或更大的序列替换序列的一部分:

```
>>> list_[1:5]
[20, 4, 80, 16]
>>> list_[1:5] = [0, 0]
>>> list_
[1, 0, 0, 320, 64, 100]
```

在本例中，删除了四个项目([20，4，80，16])，并添加了两个新项目([0，0])。

按照这个逻辑，您可以删除可变序列的一部分，方法是用空序列替换它们，如[]:

```
>>> list_[1:3]
[0, 0]
>>> list_[1:3] = []
>>> list_
[1, 320, 64, 100]
```

也可以在 del 语句中使用 slices 删除部分序列:

```
>>> list_[:2]
[1, 320]
>>> del list_[:2]
>>> list_
[64, 100]
```

因此，有两种方法可以删除列表的一部分。然而，后者看起来可读性更强，也更容易理解，因为使用 del 语句可以让您的意图(删除某些内容)更加明显。

# 切片是什么？

切片是 Python 内置类切片的实例。您可以用语句片段(start、stop、step)来创建它们。可以传递切片的实例，而不是 start:stop:step 或 start:stop:

```
>>> s = slice(1, 5, 2)
>>> s
slice(1, 5, 2)
>>> s.start, s.stop, s.step
(1, 5, 2)
>>> tuple_[s]
(2, 8)
```

同样，您可以省略 step 并获得 start:stop:

```
>>> s = slice(1, 5)
>>> s.start, s.stop, s.step
(1, 5, None)
>>> tuple_[s]
(2, 4, 8, 16)
```

如果您传递一个参数，slice 将其用作 stop，并表现为:

```
>>> s = slice(5)
>>> s.start, s.stop, s.step
(None, 5, None)
>>> tuple_[s]
(1, 2, 4, 8, 16)
```

您可以在函数和方法中操作切片:

```
>>> def get_items_with_slice(sequence, start, stop, step):
...     return sequence[slice(start, stop, step)]
... 
>>> get_items_with_slice([1, 2, 4, 8, 16, 32, 64, 128], 1, 5, None)
[2, 4, 8, 16]
```

这个函数使用自己的参数创建一个切片，并传递它以从序列中获取一些数据。

最后，下面是一个示例，说明如何结合使用切片和 Python 特殊方法 __getitem__()来定义一个类，该类的实例可以与索引符号一起使用:

```
>>> class C:
...     def __init__(self, *args):
...         self.__data = args
...     def __getitem__(self, index_or_slice):
...         print('index or slice:', index_or_slice)
...         return self.__data[index_or_slice]
... 
>>> x = C(1, 2, 4, 8, 16, 32, 128)
>>> x[4]
index or slice: 4
16
>>> x[1:5:2]
index or slice: slice(1, 5, 2)
(2, 8)
```

如果将一个整数传递给 __getitem__()，它将表现为 self 的索引。_ _ 数据。如果您改为传递 start:stop:step，__getitem__()实际上会获取一个切片对象作为参数。

还可以使用 __setitem__()来修改数据，使用 __delitem__()来删除数据，这可能与切片结合使用。

# 结论

本文展示了如何在 Python 中使用切片。当您需要从字符串、元组和列表等序列中提取项目时，它们非常强大和有用。还有一些第三方对象比如 NumPy 数组和 Pandas 系列和数据框。

您可以在函数和方法中使用切片。如果您希望使用 instance[index_or_slice]表示法定义可以访问、修改或删除数据的类，则应该实现特殊方法 __getitem__()、__setitem__()、或 __delitem__()并可能应用切片。

![](img/373724f5e413def0e29f153c00af2f94.png)

[Duomly — programming online courses](https://www.duomly.com)

感谢您的阅读。

本文由我们的队友米尔科提供。