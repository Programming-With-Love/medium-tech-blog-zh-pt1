<html>
<head>
<title>webpack optimization — A Case Study</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">webpack优化—案例研究</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/webpack-optimization-a-case-study-92b130334b6c?source=collection_archive---------0-----------------------#2017-07-25">https://medium.com/walmartglobaltech/webpack-optimization-a-case-study-92b130334b6c?source=collection_archive---------0-----------------------#2017-07-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/138653d6905c8e973bcc6cc74227e056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATx8gbzyhKdIsb3xZxoDug.png"/></div></div></figure><div class=""/><p id="b021" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi jn translated"><span class="l jo jp jq bm jr js jt ju jv di"> S </span>自从我们从<a class="jx jy ge" href="https://medium.com/u/c884135151a4?source=post_page-----92b130334b6c--------------------------------" rel="noopener" target="_blank"> @WalmartLabs </a>开源了<a class="ae jw" href="http://electrode.io" rel="noopener ugc nofollow" target="_blank">电极</a>平台的一部分，我们已经对我们的<a class="ae jw" href="https://github.com/electrode-io/electrode/blob/0d7942ac91798cc7b48563e6c5cb67757c294bbc/docs/chapter1/intermediate/app-archetype/what-are-archetypes.md" rel="noopener ugc nofollow" target="_blank"> NodeJS和ReactJS原型</a>模块做出了很多贡献，包括错误修复、新功能以及更新到<a class="ae jw" href="https://github.com/webpack/webpack" rel="noopener ugc nofollow" target="_blank"> <em class="jz"> webpack </em> </a> 2.0。为了利用这些优势，我们正在迁移我们的内部应用程序以使用OSS版本。我们做的第一个应用是服务于<a class="ae jw" href="http://www.walmart.com" rel="noopener ugc nofollow" target="_blank">http://www.walmart.com</a>登陆页面的<em class="jz">主页</em>。在这篇博客中，我将谈谈我们在现实世界应用中使用最新原型发现的一些问题，以及我们实现的解决方案。</p></div><div class="ab cl ka kb go kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ha hb hc hd he"><h1 id="5627" class="kh ki hs bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">更新电极原型</strong></h1><p id="1b82" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">转换我们的<em class="jz">主页</em>应用程序以使用我们最新的OSS原型是相对简单的，因为我们已经在次要功能上保持我们内部的大部分同步。这个过程包括更新<em class="jz"> npm </em>包和代码中的几个<code class="du lk ll lm ln b">require</code>调用，一切顺利。在那之后，通常的烟雾测试看起来都很好。开发模式启动时没有错误，并且本地提供了walmart.com的副本。生产构建也顺利完成。<em class="jz">到目前为止一切顺利，它还加强了我们原型的设计目标和灵活性——只需更新依赖关系，即可获得应用程序和webpack 1.0到2.0的所有新功能。</em></p><p id="c7e7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们提交了一份变更的PR，希望它能通过CI和回归测试。然而，我们的主页技术负责人Arunesh Joshi在查看后发现了一些问题。原型中有一些小问题，比如林挺，很快就被修复了，但是Arunesh注意到捆绑的CSS和JS文件的大小显著增加了30%以上。是时候做些调查了。</p><p id="b12e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="jx jy ge" href="https://medium.com/u/e53a2da4253b?source=post_page-----92b130334b6c--------------------------------" rel="noopener" target="_blank">在</a><a class="jx jy ge" href="https://medium.com/u/c884135151a4?source=post_page-----92b130334b6c--------------------------------" rel="noopener" target="_blank"> @WalmartLabs </a>的电极团队成员盛迪，对Arunesh提出的问题做了一些调查工作，她在这里打开了<a class="ae jw" href="https://github.com/electrode-io/electrode/pull/353" rel="noopener ugc nofollow" target="_blank"> PR来解决棉绒问题。她发现增加的CSS大小是因为我们在更新到<em class="jz"> webpack </em> 2.0时错误地删除了优化插件。她打开</a><a class="ae jw" href="https://github.com/electrode-io/electrode/pull/355" rel="noopener ugc nofollow" target="_blank">这个PR </a>来修复。关于JS包的大小，她检查了<em class="jz"> webpack </em>的统计数据，发现来自<code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/node-libs-browser" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">node-libs-browser</strong></a></code>的一些模块在<em class="jz"> webpack </em> 2.0对1.0中的大小有所增加。她还找到了<a class="ae jw" href="https://stackoverflow.com/questions/40467141/webpack2-node-libs-browser-exclude" rel="noopener ugc nofollow" target="_blank">关于堆栈溢出</a>的一个相关问题。这是一个很好的线索，也是深入挖掘的时间。</p></div><div class="ab cl ka kb go kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ha hb hc hd he"><h1 id="5649" class="kh ki hs bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">学习</strong>学习<code class="du lk ll lm ln b"><strong class="ak">NodeSourcePlugin</strong></code></h1><p id="115a" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">在我们试图找出为什么<code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/node-libs-browser" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">node-libs-browser</strong></a></code>代码的大小增加之前，更令人困惑的问题是，为什么我们还要从中提取代码？为了找出JS代码需要什么，对所有JS文件上的字符串<code class="du lk ll lm ln b">node-libs-browser</code>进行简单的递归grep，包括那些在<code class="du lk ll lm ln b"><strong class="ir ht">node_modules</strong></code>下的文件，得到了答案。下面是我使用的命令:</p><pre class="lo lp lq lr fd ls ln lt lu aw lv bi"><span id="2f20" class="lw ki hs ln b fi lx ly l lz ma">$ find . -type f -name "*.js*" | grep \.js[x]*\$ |  grep -v \/test\/ | grep -v \/example\/ |  grep -v \/dist\/ | xargs -n 20 grep node-libs-browser | less</span></pre><p id="fbec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">结果:</strong></p><pre class="lo lp lq lr fd ls ln lt lu aw lv bi"><span id="3c65" class="lw ki hs ln b fi lx ly l lz ma">./node_modules/webpack/lib/node/NodeSourcePlugin.js:const nodeLibsBrowser = require("node-libs-browser");</span><span id="c177" class="lw ki hs ln b fi mb ly l lz ma">./node_modules/webpack/lib/node/NodeSourcePlugin.js:                            return require.resolve(`node-libs-browser/mock/${module}`);</span><span id="6d88" class="lw ki hs ln b fi mb ly l lz ma">./node_modules/webpack/lib/node/NodeSourcePlugin.js:                            return require.resolve("node-libs-browser/mock/empty");</span></pre><p id="33b9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在所有的<strong class="ir ht"/>JS代码中，只有一个来自<em class="jz"> webpack </em>的文件<code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/webpack/blob/2ba04991056475509a4e45599a1f42e91cce6233/lib/node/NodeSourcePlugin.js" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">NodeSourcePlugin.js</strong></a></code>引用了<code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/node-libs-browser" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">node-libs-browser</strong></a></code>。为什么这会导致它被捆绑到我们的应用程序中？这让我开始研究<em class="jz"> webpack的</em>文档和代码。</p><p id="9416" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">这是我发现的:</strong></p><ul class=""><li id="07d8" class="mc md hs ir b is it iw ix ja me je mf ji mg jm mh mi mj mk bi translated"><em class="jz"> webpack的</em> <a class="ae jw" href="https://webpack.js.org/configuration/target/" rel="noopener ugc nofollow" target="_blank">目标配置默认为</a> <code class="du lk ll lm ln b"><a class="ae jw" href="https://webpack.js.org/configuration/target/" rel="noopener ugc nofollow" target="_blank">web</a></code></li><li id="73f7" class="mc md hs ir b is ml iw mm ja mn je mo ji mp jm mh mi mj mk bi translated"><code class="du lk ll lm ln b">web</code>目标默认<a class="ae jw" href="https://github.com/webpack/webpack/blob/60824f1bab53aa7ffc74495ac9cee7a979a7983d/lib/WebpackOptionsApply.js#L75" rel="noopener ugc nofollow" target="_blank">应用</a>一个内部插件<code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/docs/wiki/internal-webpack-plugins#nodenodesourcepluginoptions" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">NodeSourcePlugin</strong></a></code>，通过<code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/node-libs-browser" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">node-libs-browser</strong></a></code>自动使NodeJS内置模块可供浏览器使用。</li></ul></div><div class="ab cl ka kb go kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ha hb hc hd he"><h1 id="982e" class="kh ki hs bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">言归正传</h1><p id="55e7" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">我尝试的第一件事就是去掉<code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/docs/wiki/internal-webpack-plugins#nodenodesourcepluginoptions" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">NodeSourcePlugin</strong></a></code>。然而，在浏览了<em class="jz"> webpack的</em>文档和代码后，似乎没有一种简单的方法可以用一个开关禁用它。我在这里提出了一个<a class="ae jw" href="https://github.com/webpack/webpack/issues/4976" rel="noopener ugc nofollow" target="_blank">问题</a>，在与<em class="jz"> webpack的</em> <a class="jx jy ge" href="https://medium.com/u/cccc522e775a?source=post_page-----92b130334b6c--------------------------------" rel="noopener" target="_blank"> Tobias Koppers </a>讨论之后，我们决定允许<a class="ae jw" href="https://github.com/webpack/webpack/pull/4995" rel="noopener ugc nofollow" target="_blank"> <em class="jz"> webpack的</em> </a> <code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/webpack/pull/4995" rel="noopener ugc nofollow" target="_blank">node</a></code> <a class="ae jw" href="https://github.com/webpack/webpack/pull/4995" rel="noopener ugc nofollow" target="_blank">选项接受一个</a> <code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/webpack/pull/4995" rel="noopener ugc nofollow" target="_blank">false</a></code> <a class="ae jw" href="https://github.com/webpack/webpack/pull/4995" rel="noopener ugc nofollow" target="_blank">配置</a>。</p><p id="c233" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着<code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/docs/wiki/internal-webpack-plugins#nodenodesourcepluginoptions" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">NodeSourcePlugin</strong></a></code>被禁用，我们依赖于它的代码全部失败，我能够在我们的数百个组件中精确定位，查看哪一个。</p><p id="1f98" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我发现一些只有服务器端行为的组件通过<a class="ae jw" href="https://www.npmjs.com/package/exenv" rel="noopener ugc nofollow" target="_blank"> exenv </a>提供的运行时标志来实现它，就像这样:</p><pre class="lo lp lq lr fd ls ln lt lu aw lv bi"><span id="875a" class="lw ki hs ln b fi lx ly l lz ma">import { canUseDOM } from "exenv"</span><span id="e252" class="lw ki hs ln b fi mb ly l lz ma">function foo() {</span><span id="0515" class="lw ki hs ln b fi mb ly l lz ma">  if (<strong class="ln ht">!canUseDOM</strong>) {</span><span id="1d8c" class="lw ki hs ln b fi mb ly l lz ma">    const crypto = require("crypto")</span><span id="a44c" class="lw ki hs ln b fi mb ly l lz ma">    // do something with crypto<br/>  }<br/>}</span></pre><p id="2b65" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">想法很简单，如果代码不在浏览器上执行，那么只使用<code class="du lk ll lm ln b">crypto</code>模块在服务器端做一些事情。遗憾的是，<em class="jz"> webpack </em>只做静态分析，找出需要捆绑哪些代码。这意味着NodeJS <code class="du lk ll lm ln b">crypto</code>被包括在内，尽管它只是服务器端需要的。甚至在我们使用webpack 1.0的时候，这一点已经被忽视了一段时间。</p></div><div class="ab cl ka kb go kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ha hb hc hd he"><h1 id="084f" class="kh ki hs bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">解决方案</strong></h1><p id="6303" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">为了解决这个问题，我将所有服务器端代码提取到另一个<em class="jz"> npm </em>模块中。在它的<code class="du lk ll lm ln b">package.json</code>中，我将<code class="du lk ll lm ln b"><strong class="ir ht">browser</strong></code>字段指向一个包含空函数的虚拟JS文件，将<code class="du lk ll lm ln b"><strong class="ir ht">main</strong></code>字段指向真正的实现。<em class="jz">最终结果是在优化的包中减少了</em> <code class="du lk ll lm ln b"><em class="jz">100K</em></code> <em class="jz">。</em></p><p id="5c4a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还有一些引用NodeJS内置模块的组件，比如<code class="du lk ll lm ln b">path</code>和<code class="du lk ll lm ln b">util</code>。即使它们很小，我仍然计划重构它们，这样我们就可以不再依赖<code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/docs/wiki/internal-webpack-plugins#nodenodesourcepluginoptions" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">NodeSourcePlugin</strong></a></code>。在我们下一个主要的原型版本中，我将默认关闭它，以防止任何代码引入大量的服务器端代码。如果<code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/docs/wiki/internal-webpack-plugins#nodenodesourcepluginoptions" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">NodeSourcePlugin</strong></a></code>允许将NodeJS内置切换到仅白名单模式而不是默认启用的所有模式，那就太好了。</p></div><div class="ab cl ka kb go kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ha hb hc hd he"><h1 id="ed44" class="kh ki hs bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">结论</strong></h1><p id="d685" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">由于<em class="jz"> webpack的</em>默认包含了<code class="du lk ll lm ln b"><a class="ae jw" href="https://github.com/webpack/docs/wiki/internal-webpack-plugins#nodenodesourcepluginoptions" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">NodeSourcePlugin</strong></a></code>，有一个副作用是，如果你的服务器端代码只被运行时标志关闭，它们将被捆绑。当您有大型项目，有许多团队在数百个组件上工作时，这是很难跟踪的。我们遇到了这个问题，我们的捆绑包无意中包含了<code class="du lk ll lm ln b">100K</code>精简代码。我用<em class="jz"> webpack对<code class="du lk ll lm ln b">package.json</code>中<code class="du lk ll lm ln b"><strong class="ir ht">browser</strong></code>字段的</em>支持修复了它。我建议你也在你的应用程序中仔细检查这一点。我计划在原型模块中默认关闭插件，以便更容易发现这个问题。</p><h1 id="6de3" class="kh ki hs bd kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la mu lc ld le bi translated"><strong class="ak">喊出</strong></h1><p id="b687" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">非常感谢<a class="jx jy ge" href="https://medium.com/u/c884135151a4?source=post_page-----92b130334b6c--------------------------------" rel="noopener" target="_blank">@ walmartlab</a><em class="jz">主页</em>技术负责人<a class="jx jy ge" href="https://medium.com/u/f034b4cfef9f?source=post_page-----92b130334b6c--------------------------------" rel="noopener" target="_blank"> Arunesh Joshi </a>总是第一个帮助我们开发新功能，<a class="ae jw" href="http://electrode.io" rel="noopener ugc nofollow" target="_blank">电极</a>团队成员<a class="jx jy ge" href="https://medium.com/u/e53a2da4253b?source=post_page-----92b130334b6c--------------------------------" rel="noopener" target="_blank">盛迪</a>为平台和此次更新所做的出色工作，当然还有令人惊叹的<em class="jz"> webpack </em>贡献者，特别是<a class="jx jy ge" href="https://medium.com/u/cccc522e775a?source=post_page-----92b130334b6c--------------------------------" rel="noopener" target="_blank"> Tobias Koppers </a>所做的一切。</p><p id="5bfa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当然还有<a class="jx jy ge" href="https://medium.com/u/9f42c93e61de?source=post_page-----92b130334b6c--------------------------------" rel="noopener" target="_blank">戴夫·史蒂文斯</a>对此的评论。</p></div></div>    
</body>
</html>