<html>
<head>
<title>Why Every React Developer Should Learn Function Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么每个React开发人员都应该学习函数组合</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/why-every-react-developer-should-learn-function-composition-23f41d4db3b1?source=collection_archive---------0-----------------------#2022-09-01">https://medium.com/javascript-scene/why-every-react-developer-should-learn-function-composition-23f41d4db3b1?source=collection_archive---------0-----------------------#2022-09-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/93bf2ff569ca1d1e51001517e7d8841d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBXh03CyvoI9khCNzX17FQ.png"/></div></div></figure><p id="c05a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设您正在构建一个React应用程序。在应用程序的每一个页面视图中，你都有很多事情要做。</p><ul class=""><li id="0915" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">检查并更新用户验证状态</li><li id="d484" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">检查当前活动的特征以决定呈现哪些特征(连续交付需要)</li><li id="c115" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">记录每个页面组件装载</li><li id="e952" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">呈现标准布局(导航、侧边栏等)</li></ul><p id="0f82" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">像这样的事情通常被称为横切关注点。起初，你不会这样想他们。您只是厌倦了将一堆样板代码复制粘贴到每个组件中。类似于:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="0724" class="kk kl hh kg b fi km kn l ko kp">const MyPage = ({ user = {}, signIn, features = [], log }) =&gt; {<br/>  // Check and update user authentication status<br/>  useEffect(() =&gt; {<br/>    if (!user.isSignedIn) {<br/>      signIn();<br/>    }<br/>  }, [user]);</span><span id="7eeb" class="kk kl hh kg b fi kq kn l ko kp">  // Log each page component mount<br/>  useEffect(() =&gt; {<br/>    log({<br/>      type: 'page',<br/>      name: 'MyPage',<br/>      user: user.id,<br/>    });<br/>  }, []);</span><span id="d6d2" class="kk kl hh kg b fi kq kn l ko kp">  return &lt;&gt;<br/>    {<br/>      /* render the standard layout */<br/>      user.isSignedIn ?<br/>        &lt;NavHeader&gt;<br/>          &lt;NavBar /&gt;<br/>          {<br/>            features.includes('new-nav-feature')<br/>            &amp;&amp; &lt;NewNavFeature /&gt;<br/>          }<br/>        &lt;/NavHeader&gt;<br/>          &lt;div className="content"&gt;<br/>            {/* our actual page content... */}<br/>          &lt;/div&gt;<br/>        &lt;Footer /&gt; :<br/>        &lt;SignInComponent /&gt;<br/>    }<br/>  &lt;/&gt;;<br/>};</span></pre><p id="cb86" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以通过将所有这些东西抽象成独立的提供者组件来消除这些弊端。那么我们的页面可能看起来像这样:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="ead6" class="kk kl hh kg b fi km kn l ko kp">const MyPage = ({ user = {}, signIn, features = [], log }) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;AuthStatusProvider&gt;<br/>        &lt;FeatureProvider&gt;<br/>          &lt;LogProvider&gt;<br/>            &lt;StandardLayout&gt;<br/>              &lt;div className="content"&gt;{/* our actual page content... */}&lt;/div&gt;<br/>            &lt;/StandardLayout&gt;<br/>          &lt;/LogProvider&gt;<br/>        &lt;/FeatureProvider&gt;<br/>      &lt;/AuthStatusProvider&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="d7ec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管如此，我们仍然有一些问题。如果我们的标准横切关注点发生变化，我们需要在每一页上改变它们，并保持所有页面同步。我们还必须记住向每个页面添加提供者。</p><h1 id="b5be" class="kr kl hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">高阶组件</h1><p id="f9e6" class="pw-post-body-paragraph ip iq hh ir b is lo iu iv iw lp iy iz ja lq jc jd je lr jg jh ji ls jk jl jm ha bi translated">更好的解决方案是使用高阶组件(HOC)来包装我们的页面组件。这是一个接受一个组件并返回一个新组件的函数。新组件将呈现原始组件，但具有一些附加功能。我们可以用它来包装我们的页面组件和我们需要的所有提供者。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="03f5" class="kk kl hh kg b fi km kn l ko kp">const MyPage = ({ user = {}, signIn, features = [], log }) =&gt; {<br/>  return &lt;&gt;{/* our actual page content... */}&lt;/&gt;;<br/>};</span><span id="151b" class="kk kl hh kg b fi kq kn l ko kp">const MyPageWithProviders = withProviders(MyPage);</span></pre><p id="a65c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看我们的日志记录器作为一个特设的样子:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="58d3" class="kk kl hh kg b fi km kn l ko kp">const withLogger = (WrappedComponent) =&gt; {<br/>  return function LoggingProvider ({ user, ...props }) {<br/>    useEffect(() =&gt; {<br/>      log({<br/>        type: 'page',<br/>        name: 'MyPage',<br/>        user: user.id,<br/>      });<br/>    }, []);</span><span id="e075" class="kk kl hh kg b fi kq kn l ko kp">    return &lt;WrappedComponent {...props} /&gt;;<br/>  };<br/>};</span></pre><h1 id="6cb2" class="kr kl hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">功能组成</h1><p id="98b4" class="pw-post-body-paragraph ip iq hh ir b is lo iu iv iw lp iy iz ja lq jc jd je lr jg jh ji ls jk jl jm ha bi translated">为了让我们所有的提供者一起工作，我们可以使用函数组合将它们组合成一个单独的HOC。功能组合是将两个或多个功能组合起来产生一个新功能的过程。这是一个非常强大的概念，可以用来构建复杂的应用程序。</p><p id="fcc0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">函数组合是将一个函数应用于另一个函数的返回值。在代数中，它由函数复合运算符来表示:∘</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="3358" class="kk kl hh kg b fi km kn l ko kp">(f ∘ g)(x) = f(g(x))</span></pre><p id="239c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在JavaScript中，我们可以创建一个名为<code class="du lt lu lv kg b">compose</code>的函数，并用它来组成更高阶的组件:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="bc2e" class="kk kl hh kg b fi km kn l ko kp">const compose = (...fns) =&gt; (x) =&gt; fns.reduceRight((y, f) =&gt; f(y), x);</span><span id="a3ec" class="kk kl hh kg b fi kq kn l ko kp">const withProviders = compose(<br/>  withUser,<br/>  withFeatures,<br/>  withLogger,<br/>  withLayout<br/>);</span><span id="27a9" class="kk kl hh kg b fi kq kn l ko kp">export default withProviders;</span></pre><p id="c3cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在你可以在任何需要的地方导入<code class="du lt lu lv kg b">withProviders</code>。不过，我们还没完。大多数应用程序都有很多不同的页面，不同的页面有时会有不同的需求。例如，我们有时不想显示页脚(例如，在有无限内容流的页面上)。</p><h1 id="738a" class="kr kl hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">函数Currying</h1><p id="b344" class="pw-post-body-paragraph ip iq hh ir b is lo iu iv iw lp iy iz ja lq jc jd je lr jg jh ji ls jk jl jm ha bi translated">curried函数是一个一次接受多个参数的函数，通过返回一系列函数，每个函数接受下一个参数。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="5701" class="kk kl hh kg b fi km kn l ko kp">// Add two numbers, curried:<br/>const add = (a) =&gt; (b) =&gt; a + b;</span><span id="a263" class="kk kl hh kg b fi kq kn l ko kp">// Now we can specialize the function to add 1 to any number:<br/>const increment = add(1);</span></pre><p id="fa26" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个简单的例子，但是currying有助于函数合成，因为一个函数只能返回一个值。如果我们想定制布局函数来获取额外的参数，最好的解决方案是curry。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="6c8e" class="kk kl hh kg b fi km kn l ko kp">const withLayout = ({ showFooter = true }) =&gt;<br/>  (WrappedComponent) =&gt; {<br/>    return function LayoutProvider ({ features, ...props}) {<br/>      return (<br/>        &lt;&gt;<br/>          &lt;NavHeader&gt;<br/>            &lt;NavBar /&gt;<br/>            {<br/>              features.includes('new-nav-feature')<br/>              &amp;&amp; &lt;NewNavFeature /&gt;<br/>            }<br/>         &lt;/NavHeader&gt;<br/>        &lt;div className="content"&gt;<br/>          &lt;WrappedComponent features={features} {...props} /&gt;<br/>        &lt;/div&gt;<br/>        { showFooter &amp;&amp; &lt;Footer /&gt; }<br/>      &lt;/&gt;<br/>    );<br/>  };<br/>};</span></pre><p id="0b64" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但不能只咖喱布局功能。我们还需要满足<code class="du lt lu lv kg b">withProviders</code>的功能:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="a598" class="kk kl hh kg b fi km kn l ko kp">const withProviders = (options) =&gt;<br/>  compose(<br/>    withUser,<br/>    withFeatures,<br/>    withLogger,<br/>    withLayout(options)<br/>  );</span></pre><p id="f6dc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们可以使用<code class="du lt lu lv kg b">withProviders</code>用我们需要的所有提供者包装任何页面组件，并为每个页面定制布局。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="3e1e" class="kk kl hh kg b fi km kn l ko kp">const MyPage = ({ user = {}, signIn, features = [], log }) =&gt; {<br/>  return &lt;&gt;{/* our actual page content... */}&lt;/&gt;;<br/>};</span><span id="6147" class="kk kl hh kg b fi kq kn l ko kp">const MyPageWithProviders = withProviders({<br/>  showFooter: false<br/>})(MyPage);</span></pre><h1 id="ff97" class="kr kl hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">API路由中的函数组合</h1><p id="9030" class="pw-post-body-paragraph ip iq hh ir b is lo iu iv iw lp iy iz ja lq jc jd je lr jg jh ji ls jk jl jm ha bi translated">函数组合不仅仅在客户端有用。它还可以用于处理API路线中的横切关注点。一些常见的问题包括:</p><ul class=""><li id="1a23" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">证明</li><li id="7724" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">批准</li><li id="a533" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">确认</li><li id="91f9" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">记录</li><li id="e7ab" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">错误处理</li></ul><p id="03a2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">像上面的例子一样，我们可以使用函数组合来包装我们的API路由处理程序和我们需要的所有提供者。</p><p id="7d9b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一个。JS对API路由使用轻量级云函数，不再使用Express。Express主要对它的中间件栈和<code class="du lt lu lv kg b">app.use()</code>函数有用，它允许我们轻松地将中间件添加到我们的API路由中。</p><p id="6c3b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lt lu lv kg b">app.use()</code>函数只是API中间件的异步函数组合。它是这样工作的:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="7b36" class="kk kl hh kg b fi km kn l ko kp">app.use((request, response, next) =&gt; {<br/>  // do something<br/>  next();<br/>});</span></pre><p id="eca0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是我们可以用<code class="du lt lu lv kg b">asyncPipe</code>做同样的事情——一个可以用来组合返回承诺的函数的函数。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b4cb" class="kk kl hh kg b fi km kn l ko kp">const asyncPipe = (...fns) =&gt; (x) =&gt;<br/>  fns.reduce(async (y, f) =&gt; f(await y), x);</span></pre><p id="b9e9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们可以像这样编写我们的中间件和API路线:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="07cc" class="kk kl hh kg b fi km kn l ko kp">const withAuth = async ({request, response}) =&gt; {<br/>  // do something<br/>};</span></pre><p id="37d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们开发的应用中，我们有为自己创建服务器路径的功能。它基本上是一个围绕asyncPipe的薄薄的包装器，内置了一些错误处理功能:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="c3e7" class="kk kl hh kg b fi km kn l ko kp">const createRoute = (...middleware) =&gt;<br/>  async (request, response) =&gt; {<br/>    try {<br/>      await asyncPipe(...middleware)({<br/>        request,<br/>        response,<br/>      });<br/>    } catch (e) {<br/>      const requestId = response.locals.requestId;<br/>      const { url, method, headers } = request;<br/>      console.log({<br/>        time: new Date().toISOString(),<br/>        body: JSON.stringify(request.body),<br/>        query: JSON.stringify(request.query),<br/>        method,<br/>        headers: JSON.stringify(headers),<br/>        error: true,<br/>        url,<br/>        message: e.message,<br/>        stack: e.stack,<br/>        requestId,<br/>      });<br/>      response.status(500);<br/>      response.json({<br/>        error: 'Internal Server Error',<br/>        requestId,<br/>      });<br/>    }<br/>  };</span></pre><p id="fea0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在您的API路由中，您可以像这样导入和使用它:</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="4b11" class="kk kl hh kg b fi km kn l ko kp">import createRoute from 'lib/createRoute';<br/>// A pre-composed pipeline of default middleware<br/>import defaultMiddleware from 'lib/defaultMiddleware';<br/><br/>const helloWorld = async ({ request, response }) =&gt; {<br/>  request.status(200);<br/>  request.json({ message: 'Hello World' });<br/>};<br/><br/>export default createRoute(<br/>  defaultMiddleware,<br/>  helloWorld<br/>);</span></pre><p id="3837" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了这些模式，功能组合就形成了将应用程序中所有横切关注点集合在一起的主干。</p><p id="126e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">任何时候你发现自己在想，“对于每一个组件/页面/路线，我需要做X，Y，Z”，你就应该考虑用函数合成来解决问题。</p><h1 id="d5b7" class="kr kl hh bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">后续步骤</h1><p id="c557" class="pw-post-body-paragraph ip iq hh ir b is lo iu iv iw lp iy iz ja lq jc jd je lr jg jh ji ls jk jl jm ha bi translated"><a class="ae lw" rel="noopener" href="/javascript-scene/composing-software-the-book-f31c77fc3ddc">作曲软件</a>是一本畅销书，更深入地涵盖了作曲主题。</p><p id="ebe5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你知道吗，与大学学位相比，师徒关系更能带来高薪？我们创建了<a class="ae lw" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank"> DevAnywhere.io </a>来为各个层次的软件构建者提供指导。从初级到CTO，无论你在旅程的哪个阶段，我们都有一位导师可以帮助你更上一层楼。这可能是你职业生涯中最好的投资。</p><p id="23fe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lx">埃里克·艾略特</em> </strong> <em class="lx">是一位科技产品和平台顾问，《T5】 <a class="ae lw" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="lx">【作曲软件】</em></a><em class="lx"/><a class="ae lw" href="https://ericelliottjs.com/" rel="noopener ugc nofollow" target="_blank"><em class="lx">【EricElliottJS.com】</em></a><em class="lx"/><a class="ae lw" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank"><em class="lx">devanywhere . io</em></a><em class="lx">的联合创始人，以及dev团队导师。他曾为Adobe Systems、</em> <strong class="ir hi"> <em class="lx">、Zumba Fitness、</em> </strong> <em class="lx"> </em> <strong class="ir hi"> <em class="lx">【华尔街日报、</em></strong><em class="lx"/><strong class="ir hi"><em class="lx">【ESPN、</em></strong><em class="lx"/><strong class="ir hi"><em class="lx">【BBC】</em></strong><em class="lx">等顶级录音艺人和包括</em> <strong class="ir hi"> <em class="lx"> Usher、【Metallica】</em></strong></em></p><p id="60ac" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>