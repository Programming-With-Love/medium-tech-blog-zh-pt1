<html>
<head>
<title>New features of ECMAScript 2019 (ES2019)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ECMAScript 2019 (ES2019)的新功能</h1>
<blockquote>原文：<a href="https://medium.com/duomly-blockchain-online-courses/new-features-of-ecmascript-2019-es2019-1777dfe804d4?source=collection_archive---------7-----------------------#2019-08-19">https://medium.com/duomly-blockchain-online-courses/new-features-of-ecmascript-2019-es2019-1777dfe804d4?source=collection_archive---------7-----------------------#2019-08-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1fd338bd3d7a4a73d9099fc153204f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3A-ASXHE9GZGIgUkWRkGsQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming online courses</a></figcaption></figure><p id="de94" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文原载:<a class="ae it" href="https://www.blog.duomly.com/whats-new-in-ecmascript-2019-es2019/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/whats-new-in-ecmascript-2019-es 2019/</a></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="2b48" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">自2015年以来，每年都会发布新的ECMAScript功能。创建一个新的ECMAScript标准有四个阶段，从阶段0到阶段3主要是规划和起草，阶段4是最终阶段。可以使用谷歌Chrome版本72的最新功能。让我们看看ES2019到底给我们带来了什么:</p><ul class=""><li id="31f5" class="jz ka hh iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated">Object.fromEntries()，</li><li id="4c36" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">trimStart()和trimEnd()，</li><li id="2170" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">平()，</li><li id="2d5b" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">flatMap()，</li><li id="1df8" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">符号对象描述属性，</li><li id="ccbe" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">捕捉随意的狂欢，</li><li id="8b12" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">格式良好的JSON.stringify，</li></ul><p id="1866" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们一个接一个地检查我们如何使用这个出色的新特性。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="28b4" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">1.object . from entries()；</h1><p id="cbe1" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">在Javascript中转换数据是非常常见的，几乎ECMAScript的每次更新都带来了新的简单方法。在ES2017中，creators引入了一个新方法Object.entries()，用于将对象转换为数组。但是没有相反的方法，用一个简单的方法将键值对数组转换成一个对象。</p><p id="1649" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这里，ES2019为我们带来了新功能Object.fromEntries()，它允许将键值对数组转换为对象。</p><p id="6582" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看如何使用ES2019新功能Object.fromEntries()恢复Object.entries方法:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="bb43" class="lz ko hh lv b fi ma mb l mc md">var car = {<br/>make: 'Volvo',<br/>seats: 4,<br/>year: 2018,<br/>}</span><span id="dd9f" class="lz ko hh lv b fi me mb l mc md">console.log(Object.entries(car)); // [['make', 'Volvo], ['seats', 4], ['year', 2018]];</span><span id="434c" class="lz ko hh lv b fi me mb l mc md">var carArr = [['make', 'Volvo], ['seats', 4], ['year', 2018]];<br/>console.log(Object.fromEntries(carArr)); // { make: 'Volvo', seats: 4, year: 2018 };</span></pre><p id="67bf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从上面的代码中，我们可以看到，现在反转Object.entries结果是非常容易的。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="027b" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">2.trimStart()和trimEnd()</h1><p id="d9d5" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">在前端使用Javascript时，字符串操作非常常见。有时我们需要调整字符串到需要的格式，我们需要修剪字符串的一部分。ES2019为我们带来了两个有用的功能:trimStart()和trimEnd()。trimStart()方法从字符串的开头删除空格，trimEnd()显然从字符串的结尾修剪空格。</p><p id="a4e3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们来看一个代码示例:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="5e02" class="lz ko hh lv b fi ma mb l mc md">var string = '    string to trim     ';</span><span id="a12b" class="lz ko hh lv b fi me mb l mc md">console.log(string.trimStart()); // 'string to trim     '<br/>console.log(string.trimEnd()); // '    string to trim'</span></pre><p id="e426" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个看起来很简单，对吧？</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="70fe" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">3.扁平()</h1><p id="516a" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">新数组。flat()方法创建一个新数组，其中的子数组元素以递归方式集中到特定深度。默认情况下，深度为1，但可以将其设置为一个参数，也可以将其设置为无穷大，以确保所有的子数组都将被展平。</p><p id="095e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看一个代码示例:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="cd07" class="lz ko hh lv b fi ma mb l mc md">var array = [1, 2, [4, 4, [4, 7, [20, 1]]]];</span><span id="3f9f" class="lz ko hh lv b fi me mb l mc md">console.log(array.flat()); // [1, 2, 4, 4, [4, 7, [20, 1]]]; <br/>console.log(array.flat(2)); // [1, 2, 4, 4, 4, 7, [20, 1]];<br/>console.log(arra.flat(Infinity)); // [1, 2, 4, 4, 4, 7, 20, 1];</span></pre><p id="4275" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在的第一种用法中。flat()方法，它只集中一个级别数组，因为这是默认深度。在另一个console.log中，我定义了两个深度，它集中了两级子数组，最后一个console.log我们将深度级别设置为无穷大，它集中了数组的所有级别。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="e719" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">4.平面地图()</h1><p id="f5fb" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">如果你经常使用数组，你就会知道它有多有用。map()方法，该方法允许遍历数组并对每个元素执行任何函数。的。flatMap()方法是。map()和。扁平()。</p><p id="e880" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们来看一个代码示例:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="2a13" class="lz ko hh lv b fi ma mb l mc md">var array = [1, 23, [10, 43]];</span><span id="993e" class="lz ko hh lv b fi me mb l mc md">console.log(array.flatMap(item =&gt; item + 2)); // [3, 25, 12, 45];</span></pre><p id="2fef" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这似乎是一个非常有用的方法。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="842d" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">5.符号对象描述属性</h1><p id="0fac" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">符号是ES6中引入的新功能。符号中的描述主要是为了调试目的而添加的，但直到现在，开发人员都必须将其转换为字符串才能通过console.log访问描述。现在，从2019年开始，可以通过Symbol.description访问描述。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="98e3" class="lz ko hh lv b fi ma mb l mc md">var symbolDesc = 'This is Symbol';<br/>var symbolObj = Symbol(symbolObj);</span><span id="3ca8" class="lz ko hh lv b fi me mb l mc md">console.log(symbolObj.description); // 'This is Symbol';</span></pre></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="9e32" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">6.捕捉可选绑定</h1><p id="48ea" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">许多开发人员使用try…catch语句，直到现在还需要在catch中使用绑定来避免语法错误，但在某些情况下并不使用。让我们来看看ES2019之前的代码示例:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="dc76" class="lz ko hh lv b fi ma mb l mc md">try {<br/>  ...<br/>} catch (value) {<br/>  ...<br/>}</span></pre><p id="5d65" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">ES2019之后:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="2959" class="lz ko hh lv b fi ma mb l mc md">try {<br/>  ...<br/>} catch {<br/>  ...<br/>}</span></pre><p id="2169" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的例子中，我们可以看到catch语句中的value是不需要的，在这种情况下，使用最新版本的ECMAScript很可能会跳过它。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="4e3a" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">7.JSON.stringify超集</h1><p id="145e" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">在使用Javascript时，JSON.strignify的用法很常见。ES2019中的这一更改是为了防止JSON.stringify()方法返回格式错误的Unicode字符串。现在JSON.stringify()将代理代码点表示为字符串，当我们使用JSON.parse()时，它将被转换为原始表示。</p><p id="7587" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看一些例子:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="a68f" class="lz ko hh lv b fi ma mb l mc md">JSON.stringify('\uDF06\uD834'); // '"\\udf06\\ud834"'<br/>JSON.stringify('\uDEAD'); // '"\\udead"'</span></pre></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="aecf" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="adf6" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">ES2019为我们带来了许多有用的功能，这将使我们的开发过程更加愉快。在本文中，我介绍了最重要的几个:Object.fromEntries()、trimStart()和trimEnd()字符串方法、flat()和flatMap()数组方法、Symbol的新描述属性、catch可选绑定和JSON.stringify()超集。</p><p id="f0f6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您不熟悉前几年的任何更新，我鼓励您查看我们的上一篇文章<a class="ae it" href="https://www.blog.duomly.com/the-most-useful-features-in-the-latest-javascript-since-es6/" rel="noopener ugc nofollow" target="_blank">自ES6 </a>以来最新Javascript中最有用的特性，并开始使用最新特性开发您的代码。</p><p id="20d8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好好编码！</p><figure class="lq lr ls lt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/6a75cb93b3344450196d0222c0edeefb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*s0sz6uc9wpmhweEJ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming online courses</a></figcaption></figure><p id="8055" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的阅读。</p><p id="a096" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这篇文章是由我们的队友安娜创作的。</p></div></div>    
</body>
</html>