<html>
<head>
<title>Paradigm shifts with declarative UI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">声明式用户界面的范式转变</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/paradigm-shifts-with-declarative-ui-62c609ecccf9?source=collection_archive---------2-----------------------#2020-04-27">https://medium.com/google-developer-experts/paradigm-shifts-with-declarative-ui-62c609ecccf9?source=collection_archive---------2-----------------------#2020-04-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/308ca9235e3955ff2f652d0d21e0227b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_2iF-E6xeytb-OsMYdLldQ.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Picture by <a class="ae hu" href="https://www.pexels.com/it-it/@alexasfotos?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Alexas Fotos</a> on <a class="ae hu" href="https://www.pexels.com/it-it/foto/arte-bokeh-business-colorato-2277784/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><div class=""/><p id="5abe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">声明式UI在开发世界中并不是一个新概念，但是它最近在mobile native SDK上获得了发展势头，可能是在一些其他跨平台框架开始探索这些方法之后。学习如何使用它们意味着改变过去几年我们想象布局和整个图形用户界面的方式。</p><p id="809e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">随着SwiftUI在iOS上的到来，Jetpack Compose正在为Android生态系统开放构建。</p><blockquote class="js jt ju"><p id="f065" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr ha bi translated">在撰写本文时，<a class="ae hu" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank"> Jetpack Compose </a>仍在大量开发中，许多事情每天都在变化。</p></blockquote><p id="9c34" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我想尝试一下Compose，用它来创建一个小应用程序，给定Lego套件编号，它将检索这样一个套件的基本信息:图片、标题和指向说明的链接。</p><figure class="ka kb kc kd fd hj er es paragraph-image"><div class="er es jz"><img src="../Images/20dd481fff8e70b2555841c8de231982.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/1*KEjO4-S6XSRA_2bMIilpRw.gif"/></div></figure><h2 id="d9b0" class="ke kf hx bd kg kh ki kj kk kl km kn ko jf kp kq kr jj ks kt ku jn kv kw kx ky bi translated">功能概述</h2><p id="d8a7" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">作为一名开发人员，很容易突出前面提到的例子中的要点:</p><ul class=""><li id="101e" class="le lf hx iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated"><strong class="iw hy">需要一个网络请求</strong>来从网络上获取数据</li><li id="b8c6" class="le lf hx iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated">后端很可能会返回一个图片链接，以便稍后可以<strong class="iw hy">下载</strong></li><li id="1b9e" class="le lf hx iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><strong class="iw hy">数据应显示在列表上</strong></li></ul><h2 id="debb" class="ke kf hx bd kg kh ki kj kk kl km kn ko jf kp kq kr jj ks kt ku jn kv kw kx ky bi translated">舒适区内</h2><p id="51ab" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">由于熟悉Android生态系统，我将自己指向了使用一大堆知名库来帮助我完成工作的方向，这些库包括<a class="ae hu" href="https://developer.android.com/guide/topics/ui/layout/recyclerview" rel="noopener ugc nofollow" target="_blank"> RecyclerView </a>、<a class="ae hu" href="https://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank">改型</a>、<a class="ae hu" href="https://github.com/Kotlin/kotlinx.serialization" rel="noopener ugc nofollow" target="_blank"> KotlinX系列</a>、<a class="ae hu" href="https://square.github.io/picasso/" rel="noopener ugc nofollow" target="_blank"> Picasso </a>和<a class="ae hu" href="https://dagger.dev/" rel="noopener ugc nofollow" target="_blank"> Dagger </a>。</p><p id="c320" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于这样一个小应用程序来说，使用像Dagger这样的依赖注入框架似乎有些大材小用，但是在一个真实的项目中，它应该是构建对象的首选。在这种情况下，使用这样一个涉及使用<em class="jv"> kapt </em>的articulate框架可能会导致与Compose所需的Kotlin插件发生冲突，所以我决定将两者混合使用，看看会发生什么。</p><p id="fb91" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">重要的一点是Picasso(或任何其他图像下载工具)的使用:我们通常会将它称为尽可能接近视图层，因为这些库中的每一个都在引用图像将被下载到的<code class="du ls lt lu lv b">View</code>时工作得最好。</p><h1 id="5c78" class="lw kf hx bd kg lx ly lz kk ma mb mc ko md me mf kr mg mh mi ku mj mk ml kx mm bi translated">新的方式(？)</h1><p id="8061" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">到目前为止，还没有简单的方法可以用Compose异步提供图像。它肯定正在被开发中(我们可以通过<a class="ae hu" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:ui/ui-framework/src/main/java/androidx/ui/res/ImageResources.kt;l=36?q=ImageResources.kt" rel="noopener ugc nofollow" target="_blank">理解代码</a>中留下的注释，至少是关于从资源中加载的内容)，但是它还没有出现在SDK中:</p><figure class="ka kb kc kd fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mn"><img src="../Images/b29ba616168de209b6b41953993d156c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dg7xJ6gBECFRUsPKmSdeeg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">A screenshot showing the comment in the documentation</figcaption></figure><p id="b6ac" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在理想的情况下，我会告诉一个<code class="du ls lt lu lv b">Image</code>从哪里获取它的内容，它会自动显示给我看，但是现在还不是这样。直到现在，当然现在也不是这样。</p><p id="f68b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以，我决定尝试一些不同的，可以很容易复制的东西。我没有传递URL，而是将Picasso调用封装在一个协程中，并在将模型发送到UI之前下载图像，就在API调用之后:</p><figure class="ka kb kc kd fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><h2 id="8f7f" class="ke kf hx bd kg kh ki kj kk kl km kn ko jf kp kq kr jj ks kt ku jn kv kw kx ky bi translated">好的，坏的，丑陋的</h2><p id="4d46" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">虽然这种解决方案是可行的(好的)，但是只有当我们知道我们正在下载的图像数量是相当有限的(坏的)时，它才是一个可行的过程，并且它总体上是一个坏的实践(难看的):我们不想获取比我们的用户将看到的数量更多的数据，并且我们当然更喜欢在一个单独的链中下载图像。</p><h2 id="2437" class="ke kf hx bd kg kh ki kj kk kl km kn ko jf kp kq kr jj ks kt ku jn kv kw kx ky bi translated">还有一件事…</h2><p id="2970" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">另一件让我震惊的事情(的确是以积极的方式！)的事实是，<code class="du ls lt lu lv b">Composable</code>组件不管理状态:到目前为止，状态的每一个变化都应该由一个特定的对象来管理，这个对象应该与<code class="du ls lt lu lv b">Composable</code>绑定在一起。让我们看一个例子:</p><figure class="ka kb kc kd fd hj"><div class="bz dy l di"><div class="mo mp l"/></div></figure><p id="45aa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">重要的部分与第6行相关:如果我们将<code class="du ls lt lu lv b">onValueChange</code>参数作为一个整体移除，我们将无法看到文本字段中输入的内容。在我看来，这是一个巨大的飞跃:使用当前的方法，永远不清楚在何时何地保存和更新<code class="du ls lt lu lv b">Widget</code>的状态。管理一个<code class="du ls lt lu lv b">View</code>的状态不是一件容易的事情，但是从长远来看，由声明式UI框架绘制的路径将使开发图形界面变得更容易，更少混乱。</p><h2 id="0a5e" class="ke kf hx bd kg kh ki kj kk kl km kn ko jf kp kq kr jj ks kt ku jn kv kw kx ky bi translated">结论</h2><p id="8cb0" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">对于我所面临的问题，这是一个简单的解决方案(肯定有其他方法来执行相同的任务),它让我意识到声明式ui，如Compose，正在改变我们塑造代码的方式，这是需要记住的。</p><p id="8872" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，与我们现在所做的相比，使用这种方法，我们肯定更接近真正的<code class="du ls lt lu lv b">ViewModel</code>概念，但我确信这只是新一波UI框架带来的数百万个小变化中的一个。</p><p id="a589" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="jv">感谢</em> <a class="ae hu" href="https://twitter.com/danybony_" rel="noopener ugc nofollow" target="_blank"> <em class="jv">丹尼尔·博纳尔多</em></a><em class="jv"/><a class="ae hu" href="https://twitter.com/fabioCollini" rel="noopener ugc nofollow" target="_blank"><em class="jv">法比奥·科里尼</em></a><em class="jv"/><a class="ae hu" href="https://twitter.com/FMuntenescu" rel="noopener ugc nofollow" target="_blank"><em class="jv">弗洛里纳·芒特内斯库</em> </a> <em class="jv">对本帖进行校对。</em></p></div></div>    
</body>
</html>