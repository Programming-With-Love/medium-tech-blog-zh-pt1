<html>
<head>
<title>OkHttp’s New URL Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OkHttp的新URL类</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/okhttps-new-url-class-515460eea661?source=collection_archive---------1-----------------------#2015-05-26">https://medium.com/square-corner-blog/okhttps-new-url-class-515460eea661?source=collection_archive---------1-----------------------#2015-05-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="9a63" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">Java URLs很痛苦。HttpURL是来帮忙的。</h2></div><p id="f9c7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">由</em> <a class="jt ju ge" href="https://medium.com/u/dee2b4f5bec4?source=post_page-----515460eea661--------------------------------" rel="noopener" target="_blank">撰写<em class="js">杰西·威尔逊</em>T5<em class="js">。</em></a></p><blockquote class="jv"><p id="090f" class="jw jx hh bd jy jz ka kb kc kd ke jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae kf" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="b033" class="pw-post-body-paragraph iw ix hh iy b iz kg ii jb jc kh il je jf ki jh ji jj kj jl jm jn kk jp jq jr ha bi translated">Android和Java开发人员在处理URL时有几种选择:</p><ul class=""><li id="b45b" class="kl km hh iy b iz ja jc jd jf kn jj ko jn kp jr kq kr ks kt bi translated"><a class="ae kf" href="http://developer.android.com/reference/java/net/URL.html" rel="noopener ugc nofollow" target="_blank">Java . net . URL</a>20岁，显示年龄。它可以工作，但是存在一些实现上的问题。</li><li id="dcd5" class="kl km hh iy b iz ku jc kv jf kw jj kx jn ky jr kq kr ks kt bi translated"><a class="ae kf" href="http://developer.android.com/reference/java/net/URI.html" rel="noopener ugc nofollow" target="_blank"> java.net.URI </a>太严格了，因为它拒绝了像<a class="ae kf" href="http://maps.googleapis.com/maps/api/staticmap?center=Brooklyn+Bridge,New+York,NY&amp;zoom=13&amp;size=370x250&amp;maptype=roadmap%20&amp;markers=color:blue|label:S|40.702147,-74.015794&amp;markers=color:green|label:G|40.711614,-74.012318%20&amp;markers=color:red|color:red|label:C|40.718217,-73.998284&amp;sensor=false" rel="noopener ugc nofollow" target="_blank">这个</a>这样的真实世界的URL，也太宽松了，因为它接受了像“”这样的部分URL。</li><li id="c898" class="kl km hh iy b iz ku jc kv jf kw jj kx jn ky jr kq kr ks kt bi translated"><a class="ae kf" href="http://developer.android.com/reference/android/net/Uri.html" rel="noopener ugc nofollow" target="_blank"> android.net.Uri </a>是乐观的:它不验证它的输入。这在某些情况下节省了不必要的工作，但在其他情况下限制了它的效用。</li></ul><p id="d0e2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<a class="ae kf" href="http://square.github.io/okhttp/" rel="noopener ugc nofollow" target="_blank"> OkHttp </a>中，我们一直使用java.net.URL作为我们的首选模型。这是可行的，但是很麻烦；每种方法几乎都是正确的，但不完全正确。因此，我们依靠助手方法和变通方法来获得我们想要的行为。例如，这是我们获取URL端口的代码:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="e470" class="li lj hh le b fi lk ll l lm ln"><strong class="le hi">public</strong> <strong class="le hi">static</strong> <strong class="le hi">int</strong> <strong class="le hi">getEffectivePort(</strong>URL url<strong class="le hi">)</strong> <strong class="le hi">{</strong><br/>  <strong class="le hi">int</strong> specifiedPort <strong class="le hi">=</strong> url<strong class="le hi">.</strong>getPort<strong class="le hi">();</strong><br/>  <strong class="le hi">return</strong> specifiedPort <strong class="le hi">!=</strong> <strong class="le hi">-</strong>1<br/>      <strong class="le hi">?</strong> specifiedPort<br/>      <strong class="le hi">:</strong> getDefaultPort<strong class="le hi">(</strong>url<strong class="le hi">.</strong>getProtocol<strong class="le hi">());</strong><br/><strong class="le hi">}</strong></span><span id="90d4" class="li lj hh le b fi lo ll l lm ln"><strong class="le hi">public</strong> <strong class="le hi">static</strong> <strong class="le hi">int</strong> <strong class="le hi">getDefaultPort(</strong>String protocol<strong class="le hi">)</strong> <strong class="le hi">{</strong><br/>  <strong class="le hi">if</strong> <strong class="le hi">(</strong>"http"<strong class="le hi">.</strong>equals<strong class="le hi">(</strong>protocol<strong class="le hi">))</strong> <strong class="le hi">return</strong> 80<strong class="le hi">;</strong><br/>  <strong class="le hi">if</strong> <strong class="le hi">(</strong>"https"<strong class="le hi">.</strong>equals<strong class="le hi">(</strong>protocol<strong class="le hi">))</strong> <strong class="le hi">return</strong> 443<strong class="le hi">;</strong><br/>  <strong class="le hi">return</strong> <strong class="le hi">-</strong>1<strong class="le hi">;</strong><br/><strong class="le hi">}</strong></span></pre><p id="59df" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们厌倦了变通办法。所以在OkHttp 2.4中，我们创建了自己的URL模型，<a class="ae kf" href="http://square.github.io/okhttp/javadoc/com/squareup/okhttp/HttpUrl.html" rel="noopener ugc nofollow" target="_blank"> HttpUrl </a>。它在四个重要方面改进了它的前辈。</p><h1 id="08cc" class="lp lj hh bd lq lr ls lt lu lv lw lx ly in lz io ma iq mb ir mc it md iu me mf bi translated">1.解析URL</h1><p id="3742" class="pw-post-body-paragraph iw ix hh iy b iz mg ii jb jc mh il je jf mi jh ji jj mj jl jm jn mk jp jq jr ha bi translated">作为一名Java程序员，最糟糕的是什么？捕捉不可能抛出的异常:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="3371" class="li lj hh le b fi lk ll l lm ln"><strong class="le hi">public</strong> URL <strong class="le hi">makeYouCry()</strong> <strong class="le hi">{</strong><br/>  <strong class="le hi">try</strong> <strong class="le hi">{</strong><br/>    <strong class="le hi">return</strong> <strong class="le hi">new</strong> <strong class="le hi">URL(</strong>"https://youtube.com/watch?v=dQw4w9WgXcQ"<strong class="le hi">);</strong><br/>  <strong class="le hi">}</strong> <strong class="le hi">catch</strong> <strong class="le hi">(</strong>MalformedURLException e<strong class="le hi">)</strong> <strong class="le hi">{</strong><br/>    <strong class="le hi">throw</strong> <strong class="le hi">new</strong> <strong class="le hi">AssertionError(</strong>"say goodbye"<strong class="le hi">);</strong><br/>  <strong class="le hi">}</strong><br/><strong class="le hi">}</strong></span></pre><p id="839e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们新的HttpUrl类不会强迫您处理malformedurexception or urisynctaxexception。相反，parse()只是在不理解您传递给它的内容时返回null。没有异常意味着我们终于可以声明URL常量了:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="1e60" class="li lj hh le b fi lk ll l lm ln"><strong class="le hi">public</strong> <strong class="le hi">static</strong> <strong class="le hi">final</strong> HttpUrl ANDROID_DOWNLOAD_URL <strong class="le hi">=</strong> HttpUrl<strong class="le hi">.</strong>parse<strong class="le hi">(</strong><br/>    "https://play.google.com/store/apps/details?id=com.squareup.cash"<strong class="le hi">);</strong></span></pre><p id="f909" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">解析器足够严格，只能生成格式良好的URL，但对原始用户输入足够宽松。它适合在浏览器的地址栏中使用，并与主流web浏览器中的URL解析器保持一致。</p><h1 id="d219" class="lp lj hh bd lq lr ls lt lu lv lw lx ly in lz io ma iq mb ir mc it md iu me mf bi translated">2.规范化URL</h1><p id="95c0" class="pw-post-body-paragraph iw ix hh iy b iz mg ii jb jc mh il je jf mi jh ji jj mj jl jm jn mk jp jq jr ha bi translated">让我们解析一些URL，将它们添加到一个集合中，并打印结果。这是了解equals()是如何实现的一个简单方法。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="c0d7" class="li lj hh le b fi lk ll l lm ln">Set<strong class="le hi">&lt;</strong>URL<strong class="le hi">&gt;</strong> set <strong class="le hi">=</strong> <strong class="le hi">new</strong> LinkedHashSet<strong class="le hi">&lt;&gt;();</strong><br/>set<strong class="le hi">.</strong>add<strong class="le hi">(new</strong> <strong class="le hi">URL(</strong>"http://Square.GitHub.io/"<strong class="le hi">));</strong><br/>set<strong class="le hi">.</strong>add<strong class="le hi">(new</strong> <strong class="le hi">URL(</strong>"http://square.github.io:80/"<strong class="le hi">));</strong><br/>set<strong class="le hi">.</strong>add<strong class="le hi">(new</strong> <strong class="le hi">URL(</strong>"http://google.github.io/"<strong class="le hi">));</strong><br/>System<strong class="le hi">.</strong>out<strong class="le hi">.</strong>println<strong class="le hi">(</strong>set<strong class="le hi">);</strong></span></pre><p id="4ebc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">示例中的前两个URL在语义上是相等的:它们具有相同的主机名(主机名不区分大小写)和相同的端口(因为80是HTTP的默认端口)。第三个网址不同。</p><p id="8e3c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是java.net.URL对三个网址都是一视同仁的，因为square.github.io和google.github.io托管在同一个IP地址！上面的程序打印了以下内容:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="63ef" class="li lj hh le b fi lk ll l lm ln">[http://Square.GitHub.io/]</span></pre><p id="40c9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">恶！调用URL.equals()还会进行DNS查找，这对性能和正确性都不利。这是一个长期存在的问题，奇怪的是二十年后它仍然没有被修复。</p><p id="ebb1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">URI和Uri都没有规范化它们的输入。因此，尽管前两个URL在语义上是等价的，但它们并不相等。对于这两个模型，程序打印:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="ab7c" class="li lj hh le b fi lk ll l lm ln">[http://Square.GitHub.io/, <a class="ae kf" href="http://square.github.io:80/," rel="noopener ugc nofollow" target="_blank">http://square.github.io:80/,</a> <a class="ae kf" href="http://google.github.io/]" rel="noopener ugc nofollow" target="_blank">http://google.github.io/]</a></span></pre><p id="5f89" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用HttpUrl，我们对输入Url进行轻度规范化。它打印两个值:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="3848" class="li lj hh le b fi lk ll l lm ln">[http://square.github.io/, <a class="ae kf" href="http://google.github.io/]" rel="noopener ugc nofollow" target="_blank">http://google.github.io/]</a></span></pre><p id="e596" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一个好的equals()方法意味着HttpUrl适合用作LinkedHashMap甚至是<a class="ae kf" href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/cache/Cache.html" rel="noopener ugc nofollow" target="_blank"> Guava缓存</a>中的一个键。</p><h1 id="f683" class="lp lj hh bd lq lr ls lt lu lv lw lx ly in lz io ma iq mb ir mc it md iu me mf bi translated">3.查询参数</h1><p id="22c9" class="pw-post-body-paragraph iw ix hh iy b iz mg ii jb jc mh il je jf mi jh ji jj mj jl jm jn mk jp jq jr ha bi translated">Java的内置URL类缺乏从URL中提取查询参数的能力。假设您有这样一个用于Twitter搜索的URL:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="6add" class="li lj hh le b fi lk ll l lm ln"><a class="ae kf" href="https://twitter.com/search?q=cute%20%23puppies&amp;f=images" rel="noopener ugc nofollow" target="_blank">https://twitter.com/search?q=cute%20%23puppies&amp;f=images</a></span></pre><p id="1617" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">调用getQuery()或getRawQuery()会返回一个字符串，其中所有参数都粘在一起:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="2edd" class="li lj hh le b fi lk ll l lm ln">q=cute%20%23puppies&amp;f=images</span></pre><p id="da51" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这很尴尬。幸运的是，HttpUrl可以轻松地分解查询:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="2592" class="li lj hh le b fi lk ll l lm ln">HttpUrl url <strong class="le hi">=</strong> HttpUrl<strong class="le hi">.</strong>parse<strong class="le hi">(</strong><br/>    "https://twitter.com/search?q=cute%20%23puppies&amp;f=images"<strong class="le hi">);</strong><br/>System<strong class="le hi">.</strong>out<strong class="le hi">.</strong>println<strong class="le hi">(</strong>url<strong class="le hi">.</strong>queryParameter<strong class="le hi">(</strong>"q"<strong class="le hi">));</strong><br/>System<strong class="le hi">.</strong>out<strong class="le hi">.</strong>println<strong class="le hi">(</strong>url<strong class="le hi">.</strong>queryParameter<strong class="le hi">(</strong>"f"<strong class="le hi">));</strong></span></pre><p id="be18" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">queryParameter()方法提取请求的值并解码。上面的代码打印如下:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="5068" class="li lj hh le b fi lk ll l lm ln">cute #puppies<br/>images</span></pre><p id="56c7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">还有一种不用解码就可以检索查询参数的方法(如果你喜欢这类东西的话)。</p><h1 id="da19" class="lp lj hh bd lq lr ls lt lu lv lw lx ly in lz io ma iq mb ir mc it md iu me mf bi translated">4.HttpUrl。建设者</h1><p id="8e1e" class="pw-post-body-paragraph iw ix hh iy b iz mg ii jb jc mh il je jf mi jh ji jj mj jl jm jn mk jp jq jr ha bi translated">正如HttpUrl类允许您将Url分解成它的方案、主机、路径、查询和片段，它的构建器可以从原始材料中构建URL。</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="a0cc" class="li lj hh le b fi lk ll l lm ln">HttpUrl url <strong class="le hi">=</strong> <strong class="le hi">new</strong> HttpUrl<strong class="le hi">.</strong>Builder<strong class="le hi">()</strong><br/>    <strong class="le hi">.</strong>scheme<strong class="le hi">(</strong>"https"<strong class="le hi">)</strong><br/>    <strong class="le hi">.</strong>host<strong class="le hi">(</strong>"www.google.com"<strong class="le hi">)</strong><br/>    <strong class="le hi">.</strong>addPathSegment<strong class="le hi">(</strong>"search"<strong class="le hi">)</strong><br/>    <strong class="le hi">.</strong>addQueryParameter<strong class="le hi">(</strong>"q"<strong class="le hi">,</strong> "polar bears"<strong class="le hi">)</strong><br/>    <strong class="le hi">.</strong>build<strong class="le hi">();</strong></span></pre><p id="fec9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">构建器接受语义或编码形式的每个组件。它不会对百分比字符进行双重编码，也不会将加号误解为空格。构建器还使基于现有URL的构建变得容易:</p><pre class="kz la lb lc fd ld le lf lg aw lh bi"><span id="49bd" class="li lj hh le b fi lk ll l lm ln"><strong class="le hi">public</strong> <strong class="le hi">static</strong> <strong class="le hi">final</strong> HttpUrl APP_DETAILS_URL <strong class="le hi">=</strong><br/>    HttpUrl<strong class="le hi">.</strong>parse<strong class="le hi">(</strong>"https://play.google.com/store/apps/details"<strong class="le hi">);</strong></span><span id="f47f" class="li lj hh le b fi lo ll l lm ln"><strong class="le hi">public</strong> HttpUrl <strong class="le hi">playStoreUrl(</strong>String appId<strong class="le hi">)</strong> <strong class="le hi">{</strong><br/>  <strong class="le hi">return</strong> APP_DETAILS_URL<strong class="le hi">.</strong>newBuilder<strong class="le hi">()</strong><br/>      <strong class="le hi">.</strong>setQueryParameter<strong class="le hi">(</strong>"id"<strong class="le hi">,</strong> appId<strong class="le hi">)</strong><br/>      <strong class="le hi">.</strong>build<strong class="le hi">();</strong><br/><strong class="le hi">}</strong></span></pre><h1 id="2541" class="lp lj hh bd lq lr ls lt lu lv lw lx ly in lz io ma iq mb ir mc it md iu me mf bi translated">在OkHttp上获取</h1><p id="ff6a" class="pw-post-body-paragraph iw ix hh iy b iz mg ii jb jc mh il je jf mi jh ji jj mj jl jm jn mk jp jq jr ha bi translated">在GitHub 上获得<a class="ae kf" href="https://github.com/square/okhttp" rel="noopener ugc nofollow" target="_blank"> OkHttp 2.4.0。它有你在Java和Android应用程序中进行HTTP请求所需要的东西。</a></p></div><div class="ab cl ml mm go mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ha hb hc hd he"><div class="kz la lb lc fd ms"><a rel="noopener follow" target="_blank" href="/@swankjesse"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hi fi z dy mx ea eb my ed ef hg bi translated">杰西·威尔逊</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">安卓和笑话。</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">medium.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng nh ms"/></div></div></a></div></div></div>    
</body>
</html>