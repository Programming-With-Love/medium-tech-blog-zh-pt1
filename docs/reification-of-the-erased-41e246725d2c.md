# 被抹去者的具体化

> 原文：<https://medium.com/androiddevelopers/reification-of-the-erased-41e246725d2c?source=collection_archive---------3----------------------->

![](img/4b33cf0d3fb83fcc5135f7f9b50b313e.png)

## 科特林词汇，具体化

这个标题可能听起来像是一部 B 级恐怖电影，但实际上，Kotlin 的“具体化”关键词可以帮助你做以前不可能做的事情。[泛型](https://en.wikipedia.org/wiki/Generics_in_Java)提供类型安全，帮助你避免显式类型转换。泛型扩展了类型系统，允许类型或方法对各种类型的对象进行操作，同时提供编译时类型安全。另一方面，当你需要访问一个泛型函数中的类型信息时，泛型可能是有限制的，编译器告诉你该信息不存在！

![](img/41ad8e363f63132879e873a593907e17.png)

Can not access generic parameter type.

这种缺失的类型信息是 JVM 中如何实现泛型的结果(*提示*:类型擦除，我们将在后面讨论)。作为一种变通方法，您可以通过将泛型类型的类作为函数的参数进行传递来访问已删除的泛型类型。

这还不算太糟，但是正如你在 Kotlin 词汇表系列的其他文章中所知道的，Kotlin 讨厌样板代码，并致力于帮助你编写更少的代码！Kotlin 用一个独特的关键字*具体化*解决了这个问题，它让您可以从一个泛型函数中访问类型信息。如果你熟悉泛型是如何工作的，你可能会问这怎么可能。我们来看看如何:)

# 无商标消费品

在 5.0 版 Java 中加入泛型之前，集合中不存在类型信息。这意味着没有迹象表明`ArrayList`是`String`、`Integer`的`ArrayList`还是任何其他对象类型。

如果没有泛型，每次你想访问集合中的一个对象时，你都需要进行显式的强制转换。另外，对于导致运行时异常的无效强制转换，没有任何防范措施。

为了解决这个问题，Java 5 中增加了泛型。使用泛型，您可以为集合定义一个特定的类型，如果您试图添加任何其他类型，编译器将会警告您。此外，您不需要执行显式强制转换，这可能会导致运行时异常。

泛型是用一个叫做 [*类型擦除*](https://en.wikipedia.org/wiki/Type_erasure) 的技巧实现的。由于 Java 5 之前没有类型信息，Java 编译器首先用一个基本的`Object`类型替换所有类型信息，并添加必要的类型转换。类型擦除通过向编译器提供类型信息来实现编译时类型安全，并通过保持字节代码与以前的 Java 版本相同来实现向后兼容性。同时，当您需要泛型函数中的类型信息时，类型擦除可能会受到限制。

# 使具体化

现在让我们看看`reified`是如何设法在运行时访问类型信息的，这些信息在编译时就应该被删除。为了解决这个问题，reified 使用了内联函数。如果你不熟悉内联函数，请阅读这篇博文。

概括地说，如果一个函数被标记为 inline，Kotlin 编译器会将函数体复制到每个使用它的地方。这样做的一个好处是，当函数体被复制时，编译器可以自由地修改函数体。要使用具体化的参数类型，首先需要将函数内联，然后将关键字`reified`添加到泛型参数中。

让我们看看在反编译的 Java 代码中发生了什么。当调用具体化类型的内联函数时，编译器将复制函数体并用实际声明的类型替换泛型类型。因此，您不需要传递类来访问类型信息。

物化只能用于内联函数，所以适用于内联函数的规则也适用于物化。另外，请记住**具体化的函数不能从 Java** 中访问。Java 不支持内联，没有内联，泛型参数就无法避免被编译器删除。

物化也允许重载函数返回泛型类型。例如，下面的函数可以返回一个`Int`或`Float`。

通常，一个函数不能用相同的输入重载，也不能有不同的返回类型。使用内联函数，编译器可以在复制函数体的同时用期望的类型替换泛型返回类型。如果你看一下反编译的 Java 代码，编译器对`intCall`变量使用了`Integer`类型，对`floatCall`变量使用了`Float`。

具体化允许你用泛型做一些事情，这在以前是不可能的，因为在运行时缺少类型信息。当您需要内联函数中的类类型信息或重载泛型返回类型时，请使用 reified。物化不会引入任何性能损失，但是内联一个大函数会。因为函数需要内联才能使用具体化类型，所以不要忘记保持具体化函数简短，以避免性能损失，并遵循内联函数的最佳实践。