<html>
<head>
<title>Docker Swarm: Set Up A Cluster Of Docker Engines For Achieving High Availability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker Swarm:建立一个Docker引擎集群以实现高可用性</h1>
<blockquote>原文：<a href="https://medium.com/edureka/docker-swarm-cluster-of-docker-engines-for-high-availability-40d9662a8df1?source=collection_archive---------0-----------------------#2017-12-01">https://medium.com/edureka/docker-swarm-cluster-of-docker-engines-for-high-availability-40d9662a8df1?source=collection_archive---------0-----------------------#2017-12-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/bc6e1ee5ffcd9737c0e0d357fdc07038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*3i1N_OzxnZl5vqVPPFhvBg.png"/></div><figcaption class="il im et er es in io bd b be z dx">Docker Swarm - Edureka</figcaption></figure><p id="c0df" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">任何基于网络的应用程序最重要的特征是什么？有很多，但对我来说，<strong class="ir hi">高可用性</strong>最重要。这就是Docker Swarm帮助我们实现的目标！这有助于提高应用程序的可用性。</p><p id="db08" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我之前的博客中，我解释了Docker Compose是如何工作的。这篇关于Docker Swarm的博客是前者的延续，这里已经解释了使用Docker Swarm容器化任何多容器应用程序的好处。</p><p id="9c30" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个博客的情况下，它只是一个有角度的应用程序，将被Docker蜂拥而至。</p><blockquote class="jn jo jp"><p id="b187" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><strong class="ir hi">注意</strong>:容器化MEAN Stack app的方法是一样的。</p></blockquote><h1 id="2244" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">那么，Docker Swarm是什么？</h1><p id="7968" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated"><strong class="ir hi"> Docker Swarm </strong>是一种创建和维护集群<strong class="ir hi"> Docker引擎</strong>的技术。<strong class="ir hi"/>Docker引擎可以托管在不同的节点上，当以群组模式连接时，这些位于远程位置的节点形成一个<em class="jq">集群</em>。</p><h1 id="8020" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">为什么要用Docker Swarm？</h1><p id="2c3d" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">原因已经提到了！实现<strong class="ir hi">高可用性</strong>而不出现任何宕机是每个服务提供商的首要任务。高可用性会给客户留下深刻印象吗？如果他们面临停机，他们不会被打动。这是显而易见的。</p><h1 id="efe1" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Docker Swarm的其他优势</h1><p id="0ac5" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">像许多其他服务一样，Docker Swarm为我们实现了自动负载平衡。因此，当一个节点出现故障时，DevOps工程师不需要将处理请求路由到其他节点。集群的管理器将自动为我们执行负载平衡。</p><p id="7004" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">分散访问</strong>是另一个好处。那是什么意思？这意味着可以从管理器轻松访问所有节点。管理器还会定期提示节点，并跟踪其健康/状态，以应对停机。但是，节点不能访问或跟踪在其他节点/管理器中运行的服务。</p><p id="d580" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以根据我们的要求，通过执行一个命令来检查一个节点中运行的集装箱数量，<strong class="ir hi">放大</strong>集装箱数量或<strong class="ir hi">缩小</strong>集装箱数量。</p><p id="4202" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">即使在应用程序已经部署之后，我们也可以发布<strong class="ir hi">滚动更新</strong>并确保实现CI(持续集成)。滚动更新一个接一个地发布到一个节点，从而确保没有停机时间，并且负载在集群中的其他节点之间分布。</p><p id="58e7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么，接下来呢？做显而易见的事情。如果您已经使用过Docker，或者您的组织希望将一个可靠的web服务容器化，那么就开始使用Docker Swarm吧。</p><blockquote class="jn jo jp"><p id="351c" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><strong class="ir hi">注意</strong> : Docker引擎安装在独立的主机/服务器上，或者安装在一台主机的多个虚拟机中。</p></blockquote><p id="ef3a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">开始使用群体模式</strong></p><p id="d304" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Docker Swarm由管理器启动，或者这么说吧，启动Swarm集群的实例成为管理器。启动集群的命令是:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="6090" class="lg jv hh lc b fi lh li l lj lk">$ docker swarm init --advertise-addr ip-address</span></pre><p id="8c59" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，'<strong class="ir hi">–advertise-addr</strong>'标志用于向想要加入集群的其他节点通告自己。管理器的IP地址需要与标志一起指定。下面是示例截图。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/f0215476a54c379d5e85ab1286a7a22c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AGEbQVcjzVe5fHcrk0166w.png"/></div></div></figure><p id="2f75" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当群集群被启动时，在管理者端生成一个令牌。其他节点需要使用这个令牌来加入swarm集群。</p><p id="747b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">具体是怎样的？复制在管理器的docker引擎生成的整个令牌，将其粘贴到节点的docker引擎并执行它。上面截图突出显示的部分是一个令牌。当令牌在一个worker节点上执行时，它将看起来像下面的屏幕截图。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/9234e193f21e9399c513049015766a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LZ4RuhMrncDvdO-ZUtyyag.png"/></div></div></figure><p id="1636" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">任何加入集群的节点都可以在以后升级为管理器。如果您希望docker引擎作为管理器加入，请在管理器端执行以下命令:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="60ce" class="lg jv hh lc b fi lh li l lj lk">$ docker swarm join-token manager</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/5f176d112cb0835bedc4ed7e9c977455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYYg58ZeuzOMMJ9Cn7Ldnw.png"/></div></div></figure><p id="62cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">稍后，如果您希望某个节点的令牌加入群集，请运行以下命令:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="0efa" class="lg jv hh lc b fi lh li l lj lk">$ docker swarm join-token node</span></pre><p id="2c61" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">继续，在您想要加入集群的每个节点上执行令牌。当所有这些都完成后，您可以运行docker node list命令来检查有多少节点加入了集群以及它们的状态。命令是:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="0d66" class="lg jv hh lc b fi lh li l lj lk">$ docker node ls</span></pre><p id="bada" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">截图如下:</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/37ceb464b12f9724d518f04fec506ad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WyMF9nxZ0XQ1hqd_7MEM7g.png"/></div></div></figure><h1 id="2a77" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">为Angular应用程序创建Docker图像</h1><p id="ad9e" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">如果一切顺利，那么我们可以开始我们的Swarm服务，前提是Docker映像已经构建好。Docker映像可以从Docker文件中构建。用于构建应用程序的Dockerfile文件如下:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="0841" class="lg jv hh lc b fi lh li l lj lk">FROM node:6<br/>RUN mkdir -p /usr/src/app<br/>WORKDIR /usr/src/app<br/>COPY package.json /usr/src/app<br/>RUN npm cache clean<br/>RUN npm install<br/>COPY . /usr/src/app<br/>EXPOSE 4200<br/>CMD ["npm","start"]</span></pre><p id="7e3f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Docker文件用于一起执行一组命令，以便从基础映像构建自定义Docker映像。如你所见，我使用的基本图像是'<strong class="ir hi">节点:6' </strong>。NodeJS是来自Docker Hub的图像I，标记为版本6。</p><p id="d155" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我在容器中创建一个新的Docker目录，并使它成为我的容器中的工作目录。</p><p id="907b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我正在将本地机器上的'<strong class="ir hi"> package.json </strong>'文件复制到容器的工作目录中。然后，我指定'<strong class="ir hi">运行npm缓存清理</strong>'和'<strong class="ir hi">运行npm安装</strong>'命令。<em class="jq"> npm install </em>命令下载package.json文件中提到的依赖项版本。</p><p id="331b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我将所有项目代码从本地机器复制到容器中，公开端口号4200，以便在浏览器上访问Angular应用程序，最后，我指定了npm start命令，该命令将应用程序打包。</p><p id="885a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，要基于这个Docker文件创建Docker映像，请运行以下命令:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="7751" class="lg jv hh lc b fi lh li l lj lk">$ docker build -t angular-image .</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es lq"><img src="../Images/6a8cf6cfc5fd732f506327df6769840f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*lH4P-78ShlL0_bc1ZIVOfw.png"/></div></figure><blockquote class="jn jo jp"><p id="b6c1" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>Docker映像需要在集群中的所有节点上构建。没有它，容器不能在其他Docker引擎中旋转。</p></blockquote><h1 id="bf52" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">启动Docker群服务</h1><p id="b3eb" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">假设我们的Docker映像已经构建好了，我们可以从这个映像中旋转出一个容器。但是，我们会做得更好:用它创建一个Docker Swarm服务。创建群服务的命令是:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="06fa" class="lg jv hh lc b fi lh li l lj lk">$ docker service create --name "Angular-App-Container" -p 4200:4200 angular-image</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/86453abf62d9bf8fa60358d84ee9057e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zB6EIpVPIfcz4T7uxI_iPQ.png"/></div></div></figure><p id="7a39" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，'<strong class="ir hi"> name </strong>标志用于给我的服务命名，而'<strong class="ir hi"> p </strong>标志用于将容器端口暴露给主机端口。在package.json文件中，我已经指定了应该托管Angular应用程序的容器端口。这个命令中的4200帮助将容器的端口4200映射到主机的端口4200。“角度图像”是我之前制作的图像的名字。</p><blockquote class="jn jo jp"><p id="1f1a" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><strong class="ir hi">记住</strong>:当我们创建一个服务时，它可以托管在集群中的任何docker引擎上。蜂群的管理者将决定它将在哪里被托管。但是，无论应用程序驻留在哪个节点上，都可以从集群中连接的任何节点访问localhost:4200上的应用程序。</p></blockquote><p id="9005" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这怎么可能呢？因为Swarm在内部公开了可供集群中所有其他节点访问的端口号。这意味着，集群中任何节点/管理器上的端口号4200都会呈现Angular应用程序。</p><p id="5200" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在怎么办？容器是活动的吗？</p><p id="5aaa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以通过运行docker service list命令来验证服务是否被容器化。但是，部署容器可能需要一分钟的时间。下面是命令:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="ec68" class="lg jv hh lc b fi lh li l lj lk">$ docker service ls</span></pre><p id="383e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个命令将列出所有由Swarm集群管理的服务。在我们的例子中，它应该显示一个活动容器。看下面截图做参考。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/1a7f8655af0449290dd8e233ba2c1943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qi86fJ_KvnxPIMAc0dfEzw.png"/></div></div></figure><p id="009b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，“<strong class="ir hi"> REPLICAS=1/1 </strong>”表示集群中有一个容器的“服务”。而“<strong class="ir hi"> MODE=replicated </strong>”表示服务在集群中的所有节点上被复制。</p><p id="e629" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，为了确定应用程序托管在哪个节点/管理器上，我们可以运行docker service ps命令，后跟容器名称。命令是:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="fe37" class="lg jv hh lc b fi lh li l lj lk">$ docker service ps Angular-App-Container</span></pre><p id="61ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">相同的截图如下。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/b325bb65dd51ed712ea938a741992b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2ps3lfl3ZL03jZh7GOIUw.png"/></div></div></figure><p id="1e9b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这提到了应用程序所在节点的详细信息，以及用于启动服务的命令。</p><p id="6db5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">'<strong class="ir hi"> docker ps </strong>'命令揭示了关于活动容器的细节。命令是:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="7409" class="lg jv hh lc b fi lh li l lj lk">$ docker ps</span></pre><p id="e67d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">看下面截图做参考。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/dadfc61943ef32be3b175f81625045e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dq_VaR7b_pdxpFVJ1IwNIg.png"/></div></div></figure><p id="fcda" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是，这个命令只能在集群管理器和实际托管服务的节点上运行。</p><p id="e1ff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要检查有多少节点正在运行，请运行node list命令。命令是:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="650a" class="lg jv hh lc b fi lh li l lj lk">$ docker node ls</span></pre><p id="2da4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要检查特定主机中运行的容器，请运行node ps命令。命令是:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="145a" class="lg jv hh lc b fi lh li l lj lk">$ docker node ps</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/d52dcc0285599c3e0467c29a3ecf09e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RkbbJbdF8V4QxW9LthdiHg.png"/></div></div></figure><p id="9e46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您还记得的话，我之前提到过该服务目前是以复制模式运行的。这意味着服务在集群中的所有节点上复制。你认为有其他选择吗？</p><p id="02cc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">绝对的！有一种东西叫做<strong class="ir hi">全局模式</strong>。在这种模式下，集群中的每个/ manager上都运行着该容器的服务。记得在旋转另一组容器之前停止当前服务/容器。</p><p id="96b7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对此的命令是:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="2543" class="lg jv hh lc b fi lh li l lj lk">$ docker service rm Angular-App-Container</span></pre><p id="cd2e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在全局模式下旋转容器的命令是:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="6919" class="lg jv hh lc b fi lh li l lj lk">$ docker service create --name "Angular-App-Container" -p 4200:4200 --mode global angular-image</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/8ed4489c5656ff3c2467ad0685062ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*STBlbLCb8NsLvX4adqIA9Q.png"/></div></div></figure><p id="09c0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将在集群中的3个节点上创建3个服务。您可以通过运行docker服务列表命令来验证它。下面是这个的截图。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/582307bd1c244ff740871649dba3c876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6K2VHw07i3UYNKClVAvo_w.png"/></div></div></figure><p id="3b68" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当docker service ps命令被执行时，您将看到如下内容:</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/b0c4c66d3ff3643ac05831440d33e3d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4B3Fb5fw5dH2f7WZKOgpA.png"/></div></div></figure><p id="d04a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如您所见，它显示模式是复制的，该容器的副本是3。现在是这个博客最精彩的部分。</p><p id="d8e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要在三个容器之间运行服务的两个副本，我们可以使用replicas标志。查看下面的命令:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="6f9f" class="lg jv hh lc b fi lh li l lj lk">$ docker service create --name "Angular-App-Container" -p 4200:4200 --replicas=2 angular-image</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/866c6a947885373a62952b407c9762ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wnhQzTSWoRGQZRe7ADQxg.png"/></div></div></figure><p id="f450" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您会注意到这两个服务在集群中的三个节点之间实现了负载平衡。运行docker服务进程命令来验证容器在哪些节点上是活动的。看下面截图做参考。容器在一个管理器节点和一个工作者节点中是活动的。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/51c4813cdf4e59eb45095ace68f01b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PwYMCuDXbeN8M_hy5P3v6g.png"/></div></div></figure><p id="c4be" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从Worker节点，您可以通过执行'<strong class="ir hi"> docker ps </strong>命令来验证容器是否正在运行。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/dfd454c5dfcce8bf84fab85505d3f1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yNwneEfZ-Jy4_sRghvhddg.png"/></div></div></figure><h1 id="1ccd" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Docker Swarm实现高可用性</h1><p id="f6a5" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">现在，为了实际验证我们的集群中是否有高可用性，我们需要体验一个场景，其中一个节点发生故障，集群中的其他节点会弥补这个故障。我们可以通过使用以下命令从其中一个节点手动停止容器来实现这种情况:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="6ef4" class="lg jv hh lc b fi lh li l lj lk">$ docker stop Angular-App-Container</span></pre><p id="5613" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在运行容器的节点Worker-1上运行上面的命令。在管理器中，运行以下命令:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="f6cb" class="lg jv hh lc b fi lh li l lj lk">$ docker service ps Angular-App-Container</span></pre><p id="9f03" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您现在会注意到容器现在运行在节点:Worker-2和Manager中。但是，它已从节点Worker-1关闭。从下面的截图中可以看到同样的情况。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/ddbcd0afd974e950bd3275fb2c3257e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8dWQ-TYHLJn01680qQlUw.png"/></div></div></figure><p id="b30a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是<strong class="ir hi"> <em class="jq"> Docker高可用性</em> </strong>是如何实现的。尽管容器在Worker-1中处于非活动状态，但应用程序可以在该Worker节点上的端口号4200处呈现。这是因为它在内部连接到集群中的其他节点，并且能够在浏览器中呈现应用程序。</p><h1 id="e69b" class="ju jv hh bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">扩展服务后的高可用性</h1><p id="77b1" class="pw-post-body-paragraph ip iq hh ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">无论是在复制模式还是全局模式下，我们都可以增加集群中运行的服务数量。即使在扩展之后，我们也能够保持高可用性。太棒了，不是吗？</p><p id="0d08" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是回到我们的观点，让我们看看在我们的集群中增加服务数量是多么容易。假设我们的集群中有2个或3个副本，让我们通过运行一个命令将服务扩展到5个。命令是:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="b135" class="lg jv hh lc b fi lh li l lj lk">$ docker service scale Angular-App-Container=5</span></pre><p id="1e62" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是这个的截图。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es lr"><img src="../Images/9fbedbc612426f455d6807f1bbfc993e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*6qWH2TW8DFWui1mvhCWaoA.png"/></div></figure><p id="83b3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过运行docker service list命令，您可以注意到副本的数量现在是5。通过运行docker service ps命令和服务名，您可以看到这5个服务是如何在3个节点上实现负载平衡和分布的。命令包括:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="0ff5" class="lg jv hh lc b fi lh li l lj lk">$ docker service ls <br/>$ docker service ps Angular-App-Container</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/81d96ee9b90e865d96f6ccb3d89103ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rvtZsIPEB5zDJ2IMW2kWAw.png"/></div></div></figure><p id="80ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，在Docker Swarm设置中，如果您不希望您的经理参与进程并只负责管理进程，那么我们可以让经理不再托管任何应用程序。因为这个世界就是这样运作的，不是吗？经理只是用来管理其他员工的。总之，这样做的命令是:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="495a" class="lg jv hh lc b fi lh li l lj lk">$ docker node update --availability drain Manager-1</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ls"><img src="../Images/7d236a486b3bf34ab3db7881edab0747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVWVZ6ECIcusidXdDdvNDg.png"/></div></div></figure><p id="428c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以通过运行docker node list命令和docker service ps命令来验证manager现在是否加入了集群:</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="934a" class="lg jv hh lc b fi lh li l lj lk">$ docker node ls <br/>$ docker service ps Angular-App-Container</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/7393ce443aedb48140405d51df695733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EP_qaJzt-T5wj4bdQBEOUQ.png"/></div></div></figure><p id="0174" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您现在可以注意到，容器服务已经在Worker节点之间进行了划分，Manager节点实际上已经不再对任何服务进行容器化了。截图如下。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ll"><img src="../Images/7393ce443aedb48140405d51df695733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EP_qaJzt-T5wj4bdQBEOUQ.png"/></div></div></figure><p id="4380" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以，Docker Swarm上的这篇博客到此结束。我希望这篇博客解释了实现群体模式对于实现高可用性的重要性。</p><p id="8570" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，你可以参考Edureka的官方网站。</p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释DevOps的各个方面。</p><blockquote class="jn jo jp"><p id="12a1" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 1。</em> <a class="ae lt" rel="noopener" href="/edureka/devops-tutorial-89363dac9d3f"> <em class="hh"> DevOps教程</em> </a></p><p id="afba" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 2。</em> <a class="ae lt" rel="noopener" href="/edureka/git-tutorial-da652b566ece"> <em class="hh"> Git教程</em> </a></p><p id="d36b" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 3。</em> <a class="ae lt" rel="noopener" href="/edureka/jenkins-tutorial-68110a2b4bb3"> <em class="hh">詹金斯教程</em> </a></p><p id="e500" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 4。</em> <a class="ae lt" rel="noopener" href="/edureka/docker-tutorial-9a6a6140d917"> <em class="hh">码头工人教程</em> </a></p><p id="bdbb" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 5。</em> <a class="ae lt" rel="noopener" href="/edureka/ansible-tutorial-9a6794a49b23"> <em class="hh"> Ansible教程</em> </a></p><p id="8d48" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 6。</em> <a class="ae lt" rel="noopener" href="/edureka/puppet-tutorial-848861e45cc2"> <em class="hh">木偶教程</em> </a></p><p id="b6bb" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 7。</em> <a class="ae lt" rel="noopener" href="/edureka/chef-tutorial-8205607f4564"> <em class="hh">厨师教程</em> </a></p><p id="fb1f" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 8。</em> <a class="ae lt" rel="noopener" href="/edureka/nagios-tutorial-e63e2a744cc8"> <em class="hh"> Nagios教程</em> </a></p><p id="60db" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 9。</em> <a class="ae lt" rel="noopener" href="/edureka/devops-tools-56e7d68994af"> <em class="hh">如何编排DevOps工具？</em>T53】</a></p><p id="b6c6" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 10。</em> <a class="ae lt" rel="noopener" href="/edureka/continuous-delivery-5ca2358aedd8"> <em class="hh">连续交货</em> </a></p><p id="db01" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 11。</em> <a class="ae lt" rel="noopener" href="/edureka/continuous-integration-615325cfeeac"> <em class="hh">持续集成</em> </a></p><p id="8961" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 12。</em> <a class="ae lt" rel="noopener" href="/edureka/continuous-deployment-b03df3e3c44c"> <em class="hh">连续部署</em> </a></p><p id="5fd0" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">13。 <a class="ae lt" rel="noopener" href="/edureka/continuous-delivery-vs-continuous-deployment-5375642865a"> <em class="hh">持续交付vs持续部署</em> </a></p><p id="3bbf" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 14。</em> <a class="ae lt" rel="noopener" href="/edureka/ci-cd-pipeline-5508227b19ca"> <em class="hh"> CI CD管道</em> </a></p><p id="10aa" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 15。</em> <a class="ae lt" rel="noopener" href="/edureka/docker-compose-containerizing-mean-stack-application-e4516a3c8c89"> <em class="hh">码头工人撰写</em> </a></p><p id="f059" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">16。 <a class="ae lt" rel="noopener" href="/edureka/docker-networking-1a7d65e89013"> <em class="hh"> Docker联网</em> </a></p><p id="8b61" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">17。 <a class="ae lt" rel="noopener" href="/edureka/ansible-roles-78d48578aca1"> <em class="hh">可替代角色</em> </a></p><p id="cc40" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">18。<a class="ae lt" rel="noopener" href="/edureka/ansible-vault-secure-secrets-f5c322779c77"><em class="hh"/></a></p><p id="cc7f" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 19。</em> <a class="ae lt" rel="noopener" href="/edureka/ansible-for-aws-provision-ec2-instance-9308b49daed9"> <em class="hh">适用于AWS </em> </a></p><p id="0dbc" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 20。</em> <a class="ae lt" rel="noopener" href="/edureka/jenkins-pipeline-tutorial-continuous-delivery-75a86936bc92"> <em class="hh">詹金斯管道</em> </a></p><p id="79d0" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 21。</em> <a class="ae lt" rel="noopener" href="/edureka/git-commands-with-example-7c5a555d14c"> <em class="hh">顶级Git命令</em> </a></p><p id="3b83" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 22。</em> <a class="ae lt" rel="noopener" href="/edureka/docker-commands-29f7551498a8"> <em class="hh">顶级Docker命令</em> </a></p><p id="49ea" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 23。</em><a class="ae lt" rel="noopener" href="/edureka/git-vs-github-67c511d09d3e"><em class="hh">Git vs GitHub</em></a></p><p id="b9ed" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 24。</em> <a class="ae lt" rel="noopener" href="/edureka/devops-interview-questions-e91a4e6ecbf3"> <em class="hh"> DevOps面试问题</em> </a></p><p id="649f" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 25。</em> <a class="ae lt" rel="noopener" href="/edureka/devops-engineer-role-481567822e06"> <em class="hh">谁是DevOps工程师？</em>T83】</a></p><p id="f809" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 26。</em> <a class="ae lt" rel="noopener" href="/edureka/devops-lifecycle-8412a213a654"> <em class="hh"> DevOps生命周期</em> </a></p><p id="46f4" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 27。</em><a class="ae lt" rel="noopener" href="/edureka/git-reflog-dc05158c1217"><em class="hh">Git ref log</em></a></p><p id="8d7c" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 28。</em><a class="ae lt" rel="noopener" href="/edureka/ansible-provisioning-setting-up-lamp-stack-d8549b38dc59"><em class="hh"/></a></p><p id="b9b8" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 29。</em> <a class="ae lt" rel="noopener" href="/edureka/devops-skills-f6a7614ac1c7"> <em class="hh">组织寻找的顶尖DevOps技能</em> </a></p><p id="f43e" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh">三十。</em> <a class="ae lt" rel="noopener" href="/edureka/waterfall-vs-agile-991b14509fe8"> <em class="hh">瀑布vs敏捷</em> </a></p><p id="c9be" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">31。 <a class="ae lt" rel="noopener" href="/edureka/maven-tutorial-2e87a4669faf"> <em class="hh"> Maven用于构建Java应用</em> </a></p><p id="4fa9" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">32。 <a class="ae lt" rel="noopener" href="/edureka/jenkins-cheat-sheet-e0f7e25558a3"> <em class="hh">詹金斯小抄</em> </a></p><p id="3176" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 33。</em><a class="ae lt" rel="noopener" href="/edureka/ansible-cheat-sheet-guide-5fe615ad65c0"><em class="hh"/></a></p><p id="8293" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 34。</em> <a class="ae lt" rel="noopener" href="/edureka/ansible-interview-questions-adf8750be54"> <em class="hh"> Ansible面试问答</em> </a></p><p id="fffd" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">35。 <a class="ae lt" rel="noopener" href="/edureka/docker-interview-questions-da0010bedb75"> <em class="hh"> 50码头工人面试问题</em> </a></p><p id="85d2" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh">三十六。</em> <a class="ae lt" rel="noopener" href="/edureka/what-is-agile-methodology-fe8ad9f0da2f"> <em class="hh">敏捷方法论</em> </a></p><p id="a429" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">37。 <a class="ae lt" rel="noopener" href="/edureka/jenkins-interview-questions-7bb54bc8c679"> <em class="hh">詹金斯面试问题</em> </a></p><p id="576a" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 38。</em> <a class="ae lt" rel="noopener" href="/edureka/git-interview-questions-32fb0f618565"> <em class="hh"> Git面试问题</em> </a></p><p id="801d" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 39。</em> <a class="ae lt" rel="noopener" href="/edureka/docker-architecture-be79628e076e"> <em class="hh"> Docker架构</em> </a></p><p id="0455" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">40。 <a class="ae lt" rel="noopener" href="/edureka/linux-commands-in-devops-73b5a2bcd007"> <em class="hh"> Linux中使用的命令DevOps </em> </a></p><p id="d9f1" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 41。</em> <a class="ae lt" rel="noopener" href="/edureka/jenkins-vs-bamboo-782c6b775cd5"> <em class="hh">詹金斯vs竹子</em> </a></p><p id="0b19" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 42。</em> <a class="ae lt" rel="noopener" href="/edureka/nagios-interview-questions-f3719926cc67"> <em class="hh"> Nagios面试问题</em> </a></p><p id="a00d" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 43。</em> <a class="ae lt" rel="noopener" href="/edureka/jenkins-x-d87c0271af57"> <em class="hh"> DevOps实时场景</em> </a></p><p id="b0cd" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 44。</em> <a class="ae lt" rel="noopener" href="/edureka/jenkins-vs-bamboo-782c6b775cd5"> <em class="hh">詹金斯和詹金斯X的区别</em> </a></p><p id="59f6" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 45。</em><a class="ae lt" rel="noopener" href="/edureka/docker-for-windows-ed971362c1ec"><em class="hh">Windows Docker</em></a></p><p id="2b8b" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated"><em class="hh"> 46。</em><a class="ae lt" href="http://git%20vs%20github/" rel="noopener ugc nofollow" target="_blank"><em class="hh">Git vs Github</em></a></p></blockquote></div><div class="ab cl lu lv go lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ha hb hc hd he"><p id="2e05" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jq">原载于2017年12月1日</em><a class="ae lt" href="https://www.edureka.co/blog/docker-swarm-cluster-of-docker-engines-for-high-availability" rel="noopener ugc nofollow" target="_blank"><em class="jq">www.edureka.co</em></a><em class="jq">。</em></p></div></div>    
</body>
</html>