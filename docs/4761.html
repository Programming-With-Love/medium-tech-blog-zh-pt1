<html>
<head>
<title>Handling null and undefined in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中处理null和undefined</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/handling-null-and-undefined-in-javascript-1500c65d51ae?source=collection_archive---------0-----------------------#2019-11-11">https://medium.com/javascript-scene/handling-null-and-undefined-in-javascript-1500c65d51ae?source=collection_archive---------0-----------------------#2019-11-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/0e64511f128becbcf8e990a339f1b899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atGUpgtpYCEw5q97dz0Cfg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Image Credit: <a class="ae it" href="http://www.sun.org/images/black-hole-cygnus-x-1" rel="noopener ugc nofollow" target="_blank">NASA/CXC/M.Weiss</a></figcaption></figure><p id="119e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">JavaScript开发的一个方面是处理可选值，这是许多开发人员都很头疼的。最大限度地减少由可能是<code class="du js jt ju jv b">null</code>、<code class="du js jt ju jv b">undefined</code>或在运行时未初始化的值引起的错误的最佳策略是什么？</p><p id="618d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一些语言为这些情况提供了内置的启示。在一些静态类型语言中，你可以说<code class="du js jt ju jv b">null</code>和<code class="du js jt ju jv b">undefined</code>是非法值，并让你的编程语言在编译时抛出一个TypeError，但即使在那些语言中，也不能阻止空输入在运行时流入程序。</p><p id="4391" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了更好地处理这个问题，我们需要了解这些值来自哪里。以下是一些最常见的来源:</p><ul class=""><li id="df32" class="jw jx hh iw b ix iy jb jc jf jy jj jz jn ka jr kb kc kd ke bi translated">用户输入</li><li id="c582" class="jw jx hh iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated">数据库/网络记录</li><li id="0581" class="jw jx hh iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated">未初始化状态</li><li id="19db" class="jw jx hh iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated">不返回任何值的函数</li></ul><h1 id="5007" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">用户输入</h1><p id="7066" class="pw-post-body-paragraph iu iv hh iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">当你处理用户输入时，验证是第一道也是最好的防线。我经常依靠模式验证器来帮助完成这项工作。例如，查看<a class="ae it" href="https://rjsf-team.github.io/react-jsonschema-form/" rel="noopener ugc nofollow" target="_blank"> react-jsonschema-form </a>。</p><h1 id="f9d6" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">输入的补水记录</h1><p id="b32a" class="pw-post-body-paragraph iu iv hh iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">我总是通过水化功能传递从网络、数据库或用户接收的输入。例如，我将使用能够处理<code class="du js jt ju jv b">undefined</code>值的<a class="ae it" rel="noopener" href="/javascript-scene/10-tips-for-better-redux-architecture-69250425af44"> redux action creators </a>来合并用户记录:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="3da2" class="lv kl hh jv b fi lw lx l ly lz">const setUser = ({ name = 'Anonymous', avatar = 'anon.png' } = {}) =&gt; ({<br/>  type: setUser.type,<br/>  payload: {<br/>    name,<br/>    avatar<br/>  }<br/>});<br/>setUser.type = 'userReducer/setUser';</span></pre><p id="7a21" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有时，您需要根据数据的当前状态显示不同的内容。如果有可能在所有数据初始化之前显示一个页面，您可能会发现自己处于这种情况。例如，当您向用户显示资金余额时，您可能会在数据加载之前意外地显示0美元余额。我已经多次看到这让用户感到不安。您可以创建基于当前状态生成不同输出的自定义数据类型:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="f8fb" class="lv kl hh jv b fi lw lx l ly lz">const createBalance = ({<br/>  // default state<br/>  state = 'uninitialized',<br/>  value = createBalance.empty<br/>} = {}) =&gt; createBalance.isValidState(state) &amp;&amp; ({<br/>  __proto__: {<br/>    uninitialized: () =&gt; '--',<br/>    initialized: () =&gt; value,<br/>    format () {<br/>      return this[this.getState()](value);<br/>    },<br/>    getState: () =&gt; state,<br/>    set: value =&gt; {<br/>      const test = Number(value);<br/>      assert(!Number.isNaN(test), `setBalance Invalid value: ${ value }`);<br/>      return createBalance({<br/>        state: 'initialized',<br/>        value<br/>      });<br/>    }<br/>  }<br/>});<br/>createBalance.empty = '0';<br/>createBalance.isValidState = state =&gt; {<br/>  if (!['uninitialized', 'initialized'].includes(state)) {<br/>    throw new Error(`createBalance Invalid state: ${ state }`);<br/>  }<br/>  return true;<br/>};</span><span id="523c" class="lv kl hh jv b fi ma lx l ly lz">const setBalance = value =&gt; createBalance().set(value);</span><span id="b97e" class="lv kl hh jv b fi ma lx l ly lz">const emptyBalanceForDisplay = createBalance()<br/>  .format();<br/>console.log(emptyBalanceForDisplay); // '--'</span><span id="da14" class="lv kl hh jv b fi ma lx l ly lz">const balanceForDisplay = setBalance('25')<br/>  .format(balance);<br/>console.log(balanceForDisplay); // '25'</span><span id="2a4a" class="lv kl hh jv b fi ma lx l ly lz">// Uncomment these calls to see the error cases:<br/>// setBalance('foo'); // Error: setBalance Invalid value: foo</span><span id="47fb" class="lv kl hh jv b fi ma lx l ly lz">// Error: createBalance Invalid state: THIS IS NOT VALID<br/>// createBalance({ state: 'THIS IS NOT VALID', value: '0' });</span></pre><p id="0d19" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上面的代码是一个状态机，它不可能显示无效的状态。当您首次创建天平时，它将被设置为<code class="du js jt ju jv b">uninitialized</code>状态。如果您试图在状态为<code class="du js jt ju jv b">uninitialized</code>时显示余额，您将总是得到一个占位符值(<code class="du js jt ju jv b">--</code>)。</p><p id="37da" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要改变这一点，您必须通过调用<code class="du js jt ju jv b">.set</code>方法或者我们在<code class="du js jt ju jv b">createBalance</code>工厂下面定义的<code class="du js jt ju jv b">setBalance</code>快捷方式来显式设置一个值。</p><p id="5498" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">状态本身被<a class="ae it" rel="noopener" href="/javascript-scene/encapsulation-in-javascript-26be60e325b4">封装</a>以保护它不受外界干扰，确保其他函数不能抓取它并将其设置为无效状态。</p><blockquote class="mb mc md"><p id="d49e" class="iu iv me iw b ix iy iz ja jb jc jd je mf jg jh ji mg jk jl jm mh jo jp jq jr ha bi translated"><em class="hh">注意:如果您想知道为什么我们在这里使用字符串而不是数字，这是因为我用具有大量小数精度的大数字字符串来表示货币类型，以避免舍入误差，并准确地表示加密货币交易的值，加密货币交易可以具有任意有效的小数精度。</em></p></blockquote><p id="8213" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你使用Redux或Redux架构，你可以用<a class="ae it" href="https://github.com/ericelliott/redux-dsm" rel="noopener ugc nofollow" target="_blank"> Redux-DSM </a>声明状态机。</p><h1 id="eaff" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">避免创建<code class="du js jt ju jv b">null</code>和<code class="du js jt ju jv b">undefined</code>值</h1><p id="b74f" class="pw-post-body-paragraph iu iv hh iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">在您自己的函数中，您可以避免一开始就创建<code class="du js jt ju jv b">null</code>或<code class="du js jt ju jv b">undefined</code>值。有几种内置于JavaScript中的方法可以做到这一点。见下文。</p><h1 id="09b8" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">避免空值</h1><p id="09c0" class="pw-post-body-paragraph iu iv hh iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">我从来没有在JavaScript中显式地创建过<code class="du js jt ju jv b">null</code>值，因为我从来没有真正明白拥有两个不同的原始值有什么意义，这实际上意味着“这个值不存在”</p><p id="4e1d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">自2015年以来，JavaScript支持默认值，当您没有为有问题的参数或属性提供值时，会填充默认值。这些默认值不适用于<code class="du js jt ju jv b">null</code>值。根据我的经验，这通常是一个错误。为了避免这个陷阱，不要在JavaScript中使用<code class="du js jt ju jv b">null</code>。</p><p id="7a7b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您需要未初始化或空值的特殊情况，状态机是一个更好的选择。见上文。</p><h1 id="694d" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">新的JavaScript特性</h1><p id="b79e" class="pw-post-body-paragraph iu iv hh iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">有几个特性可以帮助您处理<code class="du js jt ju jv b">null</code>或<code class="du js jt ju jv b">undefined</code>值。在我写这篇文章的时候，这两个都是第三阶段的提议，但是如果你是从未来开始阅读，你也许可以使用它们。</p><p id="d8ec" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在撰写本文时，可选链接是第3阶段的提议。它是这样工作的:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="0eee" class="lv kl hh jv b fi lw lx l ly lz">const foo = {};<br/>// console.log(foo.bar.baz); // throws error<br/>console.log(foo.bar?.baz) // undefined</span></pre><h2 id="eb6c" class="lv kl hh bd km mi mj mk kq ml mm mn ku jf mo mp ky jj mq mr lc jn ms mt lg mu bi translated">零融合算子</h2><p id="4661" class="pw-post-body-paragraph iu iv hh iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">还有一个第三阶段的提议将被添加到规范中，“无效合并操作符”基本上是“回退值操作符”的一种奇特说法。如果左边的值是<code class="du js jt ju jv b">undefined</code>或<code class="du js jt ju jv b">null</code>，则计算右边的值。它是这样工作的:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="8f97" class="lv kl hh jv b fi lw lx l ly lz">let baz;<br/>console.log(baz); // undefined<br/>console.log(baz ?? 'default baz');<br/>// default baz</span><span id="b209" class="lv kl hh jv b fi ma lx l ly lz">// Combine with optional chaining:<br/>console.log(foo.bar?.baz ?? 'default baz');<br/>// default baz</span></pre><p id="ccc7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果未来还没有到来，你需要安装<code class="du js jt ju jv b">@babel/plugin-proposal-optional-chaining</code>和<code class="du js jt ju jv b">@babel/plugin-proposal-nullish-coalescing-operator</code>。</p><h1 id="bd29" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">与承诺不同步</h1><p id="43fa" class="pw-post-body-paragraph iu iv hh iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">如果一个函数可能没有返回值，那么将它包装在一个。在函数式编程中，要么monad是一种特殊的抽象数据类型，它允许您附加两种不同的代码路径:成功路径或失败路径。JavaScript有一个名为Promise的内置异步非单子数据类型。您可以使用它对未定义的值进行声明性错误分支:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="73fe" class="lv kl hh jv b fi lw lx l ly lz">const exists = x =&gt; x != null;</span><span id="d3d7" class="lv kl hh jv b fi ma lx l ly lz">const ifExists = value =&gt; exists(value) ?<br/>  Promise.resolve(value) :<br/>  Promise.reject(`Invalid value: ${ value }`);</span><span id="fc6e" class="lv kl hh jv b fi ma lx l ly lz">ifExists(null).then(log).catch(log); // Invalid value: null<br/>ifExists('hello').then(log).catch(log); // hello</span></pre><p id="cc04" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你愿意，你可以写一个同步版本，但是我不太需要它。我会把它作为一个练习留给你。如果你在<a class="ae it" rel="noopener" href="/javascript-scene/functors-categories-61e031bac53f">函子</a>和<a class="ae it" rel="noopener" href="/javascript-scene/javascript-monads-made-simple-7856be57bfe8">单子</a>方面有很好的功底，这个过程会比较容易。如果这听起来很吓人，不用担心。只用承诺。它们是内置的，大部分时间都能正常工作。</p><h1 id="86e8" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">可能的数组</h1><p id="01e3" class="pw-post-body-paragraph iu iv hh iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">数组实现了一个<code class="du js jt ju jv b">map</code>方法，该方法采用一个应用于数组每个元素的函数。如果数组为空，则永远不会调用该函数。换句话说，JavaScript中的数组可以充当Haskell等语言中的“可能”的角色。</p><h2 id="7b6e" class="lv kl hh bd km mi mj mk kq ml mm mn ku jf mo mp ky jj mq mr lc jn ms mt lg mu bi translated">什么是可能？</h2><p id="4853" class="pw-post-body-paragraph iu iv hh iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">Maybe是一种特殊的抽象数据类型，它封装了一个可选值。数据类型有两种形式:</p><ul class=""><li id="2aa7" class="jw jx hh iw b ix iy jb jc jf jy jj jz jn ka jr kb kc kd ke bi translated">只是—一个包含值的可能</li><li id="2e81" class="jw jx hh iw b ix kf jb kg jf kh jj ki jn kj jr kb kc kd ke bi translated">什么都没有——一个没有价值的可能</li></ul><p id="dafd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个想法的要点是:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="a3a8" class="lv kl hh jv b fi lw lx l ly lz">const log = x =&gt; console.log(x);<br/>const exists = x =&gt; x != null;</span><span id="ec23" class="lv kl hh jv b fi ma lx l ly lz">const Just = value =&gt; ({<br/>  map: f =&gt; Just(f(value)),<br/>});</span><span id="528e" class="lv kl hh jv b fi ma lx l ly lz">const Nothing = () =&gt; ({<br/>  map: () =&gt; Nothing(),<br/>});</span><span id="7cff" class="lv kl hh jv b fi ma lx l ly lz">const Maybe = value =&gt; exists(value) ?<br/>  Just(value) :<br/>  Nothing();</span><span id="9f2c" class="lv kl hh jv b fi ma lx l ly lz">const empty = undefined;<br/>Maybe(empty).map(log); // does not log<br/>Maybe('Maybe Foo').map(log); // logs "Maybe Foo"</span></pre><p id="4024" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这只是一个演示概念的例子。你可以围绕可能构建一个有用的函数库，实现其他操作，如<code class="du js jt ju jv b">flatMap</code>和<code class="du js jt ju jv b">flat</code>(例如，当你组合多个可能返回的函数时，避免使用<code class="du js jt ju jv b">Just(Just(value))</code>)。但是JavaScript已经有一种数据类型实现了很多现成的特性，所以我通常用数组来代替。</p><p id="32ba" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你想创建一个可能产生也可能不产生结果的函数(特别是当有多个结果时)，你可能有一个很好的用例来返回一个数组。</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="f6bb" class="lv kl hh jv b fi lw lx l ly lz">const log = x =&gt; console.log(x);<br/>const exists = x =&gt; x != null;</span><span id="0c9b" class="lv kl hh jv b fi ma lx l ly lz">const arr = [1,2,3];<br/>const find = (p, list) =&gt; [list.find(p)].filter(exists);<br/>find(x =&gt; x &gt; 3, arr).map(log); // does not log anything<br/>find(x =&gt; x &lt; 3, arr).map(log); // logs 1</span></pre><p id="3b7b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我发现在空列表中不会调用<code class="du js jt ju jv b">map</code>这一事实对于避免<code class="du js jt ju jv b">null</code>和<code class="du js jt ju jv b">undefined</code>值非常有用，但是请记住，如果数组包含<code class="du js jt ju jv b">null</code>和<code class="du js jt ju jv b">undefined</code>值，它将调用具有这些值的函数，因此如果您正在运行的函数可能产生<code class="du js jt ju jv b">null</code>或<code class="du js jt ju jv b">undefined</code>，您将需要从返回的数组中过滤掉它们，如上所示。这可能会改变集合的长度。</p><p id="589e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Haskell中，有一个函数<code class="du js jt ju jv b">maybe</code>(像<code class="du js jt ju jv b">map</code>)将函数应用于一个值。但是这个值是可选的，并且封装在一个<code class="du js jt ju jv b">Maybe</code>中。我们可以使用JavaScript的<code class="du js jt ju jv b">Array</code>数据类型做本质上相同的事情:</p><pre class="ln lo lp lq fd lr jv ls lt aw lu bi"><span id="f3f0" class="lv kl hh jv b fi lw lx l ly lz">// maybe = b =&gt; (a =&gt; b) =&gt; [a] =&gt; b<br/>const maybe = (fallback, f = () =&gt; {}) =&gt; arr =&gt;<br/>  arr.map(f)[0] || fallback;</span><span id="c19d" class="lv kl hh jv b fi ma lx l ly lz">// turn a value (or null/undefined) into a maybeArray<br/>const toMaybeArray = value =&gt; [value].filter(exists);</span><span id="e929" class="lv kl hh jv b fi ma lx l ly lz">// maybe multiply the contents of an array by 2,<br/>// default to 0 if the array is empty<br/>const maybeDouble = maybe(0, x =&gt; x * 2);</span><span id="5578" class="lv kl hh jv b fi ma lx l ly lz">const emptyArray = toMaybeArray(null);<br/>const maybe2 = toMaybeArray(2);</span><span id="07c3" class="lv kl hh jv b fi ma lx l ly lz">// logs: "maybeDouble with fallback:  0"<br/>console.log('maybeDouble with fallback: ', maybeDouble(emptyArray));<br/>// logs: "maybeDouble(maybe2):  4"<br/>console.log('maybeDouble(maybe2): ', maybeDouble(maybe2));</span></pre><p id="4754" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b">maybe</code>接受一个回退值，然后接受一个映射到maybe数组的函数，再接受一个maybe数组(一个包含一个值或不包含任何值的数组)，并返回对数组内容应用函数的结果，或者返回回退值(如果数组为空)。</p><p id="142d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了方便起见，我还定义了一个<code class="du js jt ju jv b">toMaybeArray</code>函数，并修改了<code class="du js jt ju jv b">maybe</code>函数，使其在本演示中更加明显。</p><p id="2a85" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您想在生产代码中做类似的事情，我已经创建了一个单元测试开源库来使它更容易。它叫做<a class="ae it" href="https://github.com/ericelliott/maybearray" rel="noopener ugc nofollow" target="_blank"> Maybearray </a>。Maybearray相对于其他JavaScript Maybe库的优势在于，它使用原生JavaScript数组来表示值，因此您不必对它们进行任何特殊处理或做任何特殊的来回转换。当你在调试中遇到Maybe数组时，你不必问“这是什么古怪的类型？!"它只是一个值的数组或者一个空数组，你已经见过无数次了。</p><h1 id="e686" class="kk kl hh bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">后续步骤</h1><p id="86b1" class="pw-post-body-paragraph iu iv hh iw b ix li iz ja jb lj jd je jf lk jh ji jj ll jl jm jn lm jp jq jr ha bi translated">在<a class="ae it" href="https://ericelliottjs.com/" rel="noopener ugc nofollow" target="_blank">EricElliottJS.com</a>上有更多的内容，包括许多视频、练习、录制的截屏和快速提示。如果你不是会员，现在是一个伟大的时间来看看你错过了什么！</p><figure class="ln lo lp lq fd ii er es paragraph-image"><a href="https://ericelliottjs.com/premium-content/lesson-pure-functions"><div class="er es mv"><img src="../Images/51899c049d6eec343d3330a2f8dde537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uRgzsRvSpoz8l3zh.png"/></div></a><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://ericelliottjs.com/premium-content/lesson-pure-functions" rel="noopener ugc nofollow" target="_blank">Start your free lesson on EricElliottJS.com</a></figcaption></figure></div><div class="ab cl mw mx go my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ha hb hc hd he"><p id="f262" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> <em class="me">艾里克·艾略特</em> </strong> <em class="me">著有《书籍》、</em> <a class="ae it" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="me">【排版软件】</em></a><em class="me"/><a class="ae it" href="https://www.amazon.com/Programming-JavaScript-Applications-Architecture-Libraries-dp-1491950293/dp/1491950293/ref=as_li_ss_tl?_encoding=UTF8&amp;language=en_US&amp;linkCode=ll1&amp;linkId=06971c7a0f2b13309e5af242b2483609&amp;me=&amp;qid=&amp;tag=eejs-20" rel="noopener ugc nofollow" target="_blank"><em class="me">【编程JavaScript应用】</em> </a> <em class="me">。作为</em><a class="ae it" href="https://ericelliottjs.com/" rel="noopener ugc nofollow" target="_blank"><em class="me">【EricElliottJS.com】</em></a><em class="me">和</em><a class="ae it" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank"><em class="me">devanywhere . io</em></a><em class="me">的联合创始人，他教授开发者必备的软件开发技能。他为加密项目组建开发团队并提供建议，为Adobe Systems、</em> <strong class="iw hi"> <em class="me">、Zumba Fitness、</em> </strong> <em class="me"> </em> <strong class="iw hi"> <em class="me">【华尔街日报、</em></strong><em class="me"/><strong class="iw hi"><em class="me">【ESPN、</em></strong><em class="me"/><strong class="iw hi"><em class="me">BBC、</em> </strong> <em class="me">以及包括</em> <strong class="iw hi"> <em class="me"> Usher、弗兰克·奥申、金属乐队在内的顶级录音</em></strong></p><p id="08fd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>