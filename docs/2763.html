<html>
<head>
<title>Solidity Tutorial — Solidity Programming For Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity教程——面向初学者的Solidity编程</h1>
<blockquote>原文：<a href="https://medium.com/edureka/solidity-programming-for-beginners-bc9dccbf5588?source=collection_archive---------6-----------------------#2018-02-28">https://medium.com/edureka/solidity-programming-for-beginners-bc9dccbf5588?source=collection_archive---------6-----------------------#2018-02-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/26e332eec4a5ec7d1da3e4c19f2a7d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*L_9Ee8iLsceHpmmCnNsQlA.png"/></div></figure><p id="b777" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这篇关于坚固性教程的文章展示了许多坚固性的特性。本教程假设您对以太坊虚拟机和编程有一定的了解。</p><p id="9fdc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">以太坊，世界计算机提供了一个非常强大的共享全球基础设施，使用一种叫做<strong class="in hi"> Solidity的编程语言来构建一个去中心化的应用程序。</strong></p><p id="9e05" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这个关于Solidity教程的博客涵盖了以下主题:</p><ol class=""><li id="7661" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">什么是扎实？</li><li id="da2b" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">以太坊契约</li><li id="ceb1" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">实体文件的布局</li><li id="c956" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">可靠性中的值类型</li><li id="0530" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">经营者</li><li id="a90e" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">固体中的数据结构</li><li id="b370" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">控制结构</li><li id="533b" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">功能</li><li id="97df" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">遗产</li></ol><p id="7569" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jx">让我们从坚固性的介绍开始我们的坚固性教程。</em></p><h1 id="90b9" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">什么是扎实？</h1><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es kw"><img src="../Images/2f8a61bfd17a84f71920a0acfed27b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:204/format:webp/0*kQMni99SoatQx3yW.jpg"/></div></figure><p id="7c44" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jx">以太坊是一种面向契约的高级语言，语法类似于JavaScript。</em></p><p id="027b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">solidity是一个用来生成在EVM上执行的机器代码的工具。solidity编译器将高级代码分解成更简单的指令。</p><p id="6868" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jx">固化代码封装在</em> <strong class="in hi"> <em class="jx">契约</em> </strong>中</p><h1 id="865f" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">以太坊契约</h1><p id="e5b3" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">契约是以太坊的分散式应用程序的基本构件。所有的变量和功能都是合同的一部分，这是所有项目的起点。</p><p id="b953" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">名为的空协定如下所示:</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="062f" class="ll jz hh lh b fi lm ln l lo lp">version pragma ^0.4.19; contract MyFirst{ }</span></pre><p id="5a9e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">坚持你的屏幕，因为接下来在我们的坚固性教程中，我们将开始编码…</p><h2 id="ae46" class="ll jz hh bd ka lq lr ls ke lt lu lv ki iw lw lx km ja ly lz kq je ma mb ku mc bi translated">实体文件的布局</h2><p id="ea37" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">源文件可以包含任意数量的协定定义，包括指令和pragma指令。</p><p id="fef4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">版本杂注</strong></p><p id="fbcc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Version Pragma是特定代码应该使用的Solidity编译器版本的声明。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="1e4d" class="ll jz hh lh b fi lm ln l lo lp">version pragma ^0.4.00;</span></pre><p id="4cbb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">注意:</strong>上面显示的源文件不能在早于0.4.0版本的编译器上编译，也不能在0.5.0版本的编译器上运行。</p><p id="0f6f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Ethereum Solidity支持与JavaScript中的导入语句非常相似的导入语句，尽管Solidity不知道“默认导出”的概念。</p><p id="2381" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在全局级别，您可以使用以下形式的import语句:</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="9f57" class="ll jz hh lh b fi lm ln l lo lp">import "filename";</span></pre><p id="c42f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">上述语句将“filename”中的所有全局符号导入到当前的全局作用域中。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="d76f" class="ll jz hh lh b fi lm ln l lo lp">import * as symbolName from "filename";</span></pre><p id="fcb7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">…创建一个新的全局符号<strong class="in hi"> symbolName </strong>，其成员是来自“filename”的所有全局符号</p><p id="2c90" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">评论</strong></p><p id="7643" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">就像任何其他语言一样，<em class="jx">单行</em>和<em class="jx">多行</em>注释在坚固性上是可能的。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="9377" class="ll jz hh lh b fi lm ln l lo lp">// This is a single-line comment. /* This is a multi-line comment */</span></pre><p id="dc47" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，在我们继续我们的实体教程之前，你应该知道以太坊有三个区域可以储存物品。</p><ol class=""><li id="7d22" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated"><strong class="in hi">存储:</strong>所有契约状态变量驻留的地方。每个契约都有自己的存储，并且在函数调用之间是持久的</li><li id="55ac" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><strong class="in hi">内存:</strong>保存临时值，在(外部)函数调用之间被擦除，使用起来更便宜</li><li id="05c0" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><strong class="in hi"> Stack: </strong>保存小的局部变量，几乎可以免费使用，但是只能保存有限的值</li></ol><p id="47bf" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于几乎所有的类型，您不能指定它们应该存储在哪里，因为它们在每次使用时都会被复制。好了，现在你知道以太坊的存储位置了，让我告诉你一般的值类型。</p><h1 id="9624" class="jy jz hh bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">可靠性中的值类型</h1><p id="0093" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">下列类型也称为值类型，因为这些类型的变量总是通过值传递。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/b0953b7dbd8adcc0ffa916cde9bc35c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*skCpD0Ve_OliDzfM.png"/></div></div></figure><p id="3d6c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">可能的值是常量，即<strong class="in hi">真</strong>或<strong class="in hi">假</strong></p><p id="3095" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">整数</strong></p><p id="3130" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jx">关键字:</em> int/uint(以8为步长的uint8至uint256(无符号8至256位)和int8至int256)</p><p id="4c3d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">各种大小的有符号和无符号整数。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="1154" class="ll jz hh lh b fi lm ln l lo lp">contract MySample{ uint UnsignedInt =50; }</span></pre><p id="2742" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在上面的语句中，我们创建了一个名为<strong class="in hi">的<strong class="in hi">uint</strong>insignedit</strong>T53】将其设置为50。</p><p id="4034" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">地址:</strong></p><p id="b9d6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jx">关键字:</em>地址</p><p id="8950" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">保存20字节的值(以太坊地址的大小)。地址类型也有<em class="jx">成员</em>，并作为所有契约的基础。</p><p id="4219" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">会员地址:余额&amp;转账</strong></p><p id="d612" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">可以使用属性<strong class="in hi"> <em class="jx"> balance </em> </strong>查询地址的余额，并使用<strong class="in hi"> <em class="jx"> transfer </em> </strong>函数将以太网发送到地址。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="30ba" class="ll jz hh lh b fi lm ln l lo lp">address x = 0x123; <br/>address myAddress = this; <br/>if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt; = 10) <br/>x.transfer(10);</span></pre><p id="a45b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">字符串:</strong></p><p id="10a8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jx">关键字:</em>字符串文字用双引号或单引号<strong class="in hi">【foo】</strong>或<strong class="in hi">【bar】</strong>写成。<br/> <br/>用于任意长度的UTF数据。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="8b5e" class="ll jz hh lh b fi lm ln l lo lp">string language = "Solidity";</span></pre><p id="5047" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这些值类型可以在包含运算符的表达式中相互交互。接下来，在我们的Solidity教程中，让我告诉你各种各样的操作符。</p><h2 id="956f" class="ll jz hh bd ka lq lr ls ke lt lu lv ki iw lw lx km ja ly lz kq je ma mb ku mc bi translated">经营者</h2><p id="bd8e" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">solidity中的运算符与JavaScript中的相同。坚实度有四种类型的运算符:</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mi"><img src="../Images/576a71457c1b867af87702bc14271be6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uYHQxnzwQGRmcIwK.png"/></div></div></figure><p id="1dfa" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">算术运算符</strong></p><p id="f4fc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">坚实度有非常简单的数学运算。以下类似于大多数编程语言:</p><ul class=""><li id="79bd" class="jj jk hh in b io ip is it iw jl ja jm je jn ji mj jp jq jr bi translated">加法:<code class="du mk ml mm lh b"><strong class="in hi">x + y</strong></code></li><li id="c8a9" class="jj jk hh in b io js is jt iw ju ja jv je jw ji mj jp jq jr bi translated">减法:<code class="du mk ml mm lh b"><strong class="in hi">x - y</strong></code></li><li id="f54a" class="jj jk hh in b io js is jt iw ju ja jv je jw ji mj jp jq jr bi translated">乘法:<code class="du mk ml mm lh b"><strong class="in hi">x * y</strong></code></li><li id="7c0b" class="jj jk hh in b io js is jt iw ju ja jv je jw ji mj jp jq jr bi translated">分部:<code class="du mk ml mm lh b"><strong class="in hi">x / y</strong></code></li><li id="9308" class="jj jk hh in b io js is jt iw ju ja jv je jw ji mj jp jq jr bi translated">模数/余数:<code class="du mk ml mm lh b"><strong class="in hi">x % y</strong></code></li></ul><p id="dd9c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">坚固性也给你一个使用指数操作符的选项，如下所示:</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="54ef" class="ll jz hh lh b fi lm ln l lo lp">uint x = 10 ** 3; // equal to 10^3 = 1000</span></pre><p id="9baf" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">增量运算符</strong></p><p id="d03e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">实度中的增量算子:a++，a-，++a，-a，a+=1，a=a+1</p><p id="96c8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">适用于其他编程语言的规则在可靠性上也是相似的。</p><p id="537a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">按位运算符:</strong></p><p id="9f33" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">以下是运算符:(按位或)' | '、(按位异或)、(按位求反)' ~ '、(按位右移)' &gt; '、(按位左移)'&lt;</p><p id="a644" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">逻辑运算符:</strong></p><p id="d6ee" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Solidity中的逻辑运算符:！(逻辑否定)，&amp;&amp;(逻辑与)，||(逻辑或)，==(相等)，！=(不相等)</p><p id="123f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">举例:</strong></p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="4cef" class="ll jz hh lh b fi lm ln l lo lp">contract operators {<br/>// Arithmetic Operators<br/>// +,-,*,/, %, **<br/>// Incremental Operators<br/>// a++, a--, a+=1, a=a+1,++a,--a;<br/>a=10;<br/>a= a++; //here, output will be 10, because the value is first returned and then then increment is done<br/>a=++a;<br/>//Logical Operators<br/>!, &amp;&amp;, ||, ==, !=<br/>isOwner = true &amp;&amp; false;<br/>var orValue= 0x02 | 0x01; // output would be 0x03<br/>//Bitwise Operators~,&gt;&gt;, &lt;&lt;;<br/>function Operators() {<br/>// Initialize state variables here}}</span></pre><p id="b9c8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在有时需要更复杂的数据类型。为此，Solidity提供了<br/>和<strong class="in hi">结构。</strong></p><h2 id="7303" class="ll jz hh bd ka lq lr ls ke lt lu lv ki iw lw lx km ja ly lz kq je ma mb ku mc bi translated">固体中的数据结构</h2><p id="529f" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">可靠性提供了三种类型的数据结构:</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es mn"><img src="../Images/0e76670085be7be5589ae2eb879eecfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pP1QaNEu9LflJYYH.png"/></div></div></figure><h2 id="1233" class="ll jz hh bd ka lq lr ls ke lt lu lv ki iw lw lx km ja ly lz kq je ma mb ku mc bi translated">结构</h2><p id="44af" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">坚固性提供了一种以结构形式定义新类型的方法。结构是自定义的类型，可以将几个变量组合在一起。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="2f68" class="ll jz hh lh b fi lm ln l lo lp">pragma solidity ^0.4.0;<br/>contract Ballot {<br/>struct Voter { // Struct<br/>uint weight1, weight2, weight3;<br/>bool voted;<br/>address delegate1, delegate2, delegate3, delegate4;<br/>string name;<br/>uint vote1, vote2, vote3, vote4, vote5;<br/>uint height1, height2, height3   } }</span></pre><p id="beda" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">注意:</strong>结构只能有16个成员，超过这个数目可能会出现以下错误:堆栈太深。</p><p id="9d49" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jx">结构允许您创建具有多个属性的更复杂的数据类型。</em></p><p id="bb0f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，如果你需要收集一些东西，比如地址。嗯，就像大多数语言一样，Solidity也有数组。</p><h2 id="1763" class="ll jz hh bd ka lq lr ls ke lt lu lv ki iw lw lx km ja ly lz kq je ma mb ku mc bi translated">数组</h2><p id="b910" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">Solidity中的数组可以有一个编译时固定的大小，也可以是动态的。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="8846" class="ll jz hh lh b fi lm ln l lo lp">uint[3] fixed; //array of fixed length 3</span><span id="aae3" class="ll jz hh lh b fi mo ln l lo lp">uint[] dynamic; //a dynamic array has no fixed size, it can keep growing</span></pre><p id="9d76" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">您还可以创建结构数组。使用先前创建的<strong class="in hi">表决器</strong>结构:</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="ba2c" class="ll jz hh lh b fi lm ln l lo lp">Voter[] voting;</span></pre><p id="c1bc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">注意:</strong>将一个数组声明为public会自动为它创建一个getter方法。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="1c90" class="ll jz hh lh b fi lm ln l lo lp">Voter[] public voting;</span></pre><h2 id="85c0" class="ll jz hh bd ka lq lr ls ke lt lu lv ki iw lw lx km ja ly lz kq je ma mb ku mc bi translated">映射</h2><p id="b117" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">映射可以看作是哈希表，它被虚拟地初始化，使得每个可能的键都存在，并被映射到一个字节表示全为零的值:一个类型的默认值。</p><p id="367a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">映射被声明为:</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="6b6d" class="ll jz hh lh b fi lm ln l lo lp">Mapping(_Keytype =&gt; _ValueType )</span></pre><p id="090f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">注意:</strong> _Keytype几乎可以是任何类型，除了动态大小数组、契约、枚举和结构。</p><p id="32c9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">例如:</strong></p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="d27a" class="ll jz hh lh b fi lm ln l lo lp">contract MappingExample {<br/>mapping(address =&gt; uint) public balances;<br/>function update(uint newBalance) {<br/>balances[msg.sender] = newBalance;  }}<br/>contract MappingUser {<br/>function f() returns (uint) {<br/>MappingExample m = new MappingExample();<br/>m.update(100);<br/>return m.balances(this);<br/>}}</span></pre><h2 id="20a1" class="ll jz hh bd ka lq lr ls ke lt lu lv ki iw lw lx km ja ly lz kq je ma mb ku mc bi translated">控制结构</h2><p id="61f3" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">JavaScript中的大部分控制结构在Solidity中都有，除了switch和goto。</p><p id="731a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">于是就有了<strong class="in hi"> : if，else，while，do，for，break，continue，return，？:</strong>，带有从C或JavaScript已知的常用语义。</p><p id="6da9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">注意:</strong>不存在像C和JavaScript中那样的从非布尔类型到布尔类型的转换。</p><p id="dc08" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在让我们看看这些控制结构是如何在Solidity中使用的。</p><p id="31ed" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">例如:</strong></p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="9ada" class="ll jz hh lh b fi lm ln l lo lp">contract ControlStructure {<br/>address public a;<br/>function ControlStructure&gt;){<br/>// if-else can be used like this<br/>if(input1==2)<br/>a=1;<br/>else<br/>a=0;<br/>// while can be used like this<br/>while(input1&gt;=0){<br/>if(input1==5)<br/>continue;<br/>input1=input1-1;<br/>a++;}<br/>// for loop can be used like this<br/>for(uint i=0;i&lt;=50;i++) { a++; if(a==4) break; } //do while can be used like this do { a--; } (while a&gt;0);<br/>// Conditional Operator can be used like this<br/>bool IsTrue = (a == 1)?true: false;<br/>/*will show an error because<br/>there is no type conversion from non-boolean to boolean<br/>*/<br/>if(1)<br/>{<br/>}</span></pre><p id="5786" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">继续我们的Solidity教程博客，让我们讨论一下契约中代码的可执行单元。这些被称为<em class="jx">功能。</em></p><h2 id="3824" class="ll jz hh bd ka lq lr ls ke lt lu lv ki iw lw lx km ja ly lz kq je ma mb ku mc bi translated">功能</h2><p id="11f8" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">下面是如何在Solidity中声明一个函数。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="f670" class="ll jz hh lh b fi lm ln l lo lp">function sampleFunc(string name, uint amount) { }</span></pre><p id="32ff" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">上面声明的是一个空体函数，它接受两个参数:一个字符串和一个uint。</p><p id="d2c7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">您可以像这样调用这个函数:</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="e2d9" class="ll jz hh lh b fi lm ln l lo lp">sampleFunc("Shashank", 10000);</span></pre><p id="bfa7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">说到函数，Solidity还提供了<strong class="in hi">函数修饰符。</strong></p><p id="6066" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">功能修饰符</strong></p><p id="9ec6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">它用于轻松地更改函数的行为。这些条件甚至可以在进行函数调用之前进行检查，因为它们已经在智能合约的函数定义中声明了。</p><p id="f632" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">举例:</strong>如果你想只通过函数的拥有者或创建者调用一个kill contract函数。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="d442" class="ll jz hh lh b fi lm ln l lo lp">contract FunctionModifiers{<br/>address public creator;<br/>function FunctionModifiers() {<br/>creator = msg.sender;}<br/>Modifier onlyCreator() {<br/>if(msg.sender!=creator){<br/>throw; }<br/>_; //resumes the function wherever the access modifier is used<br/>}<br/>function killContract() onlyCreator{ //function will not execute if an exception occurs<br/>self-destruct(creator); }}</span></pre><h2 id="41d6" class="ll jz hh bd ka lq lr ls ke lt lu lv ki iw lw lx km ja ly lz kq je ma mb ku mc bi translated">遗产</h2><p id="b611" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">Solidity通过复制包含多态性的代码来支持多重继承。</p><pre class="kx ky kz la fd lg lh li lj aw lk bi"><span id="9880" class="ll jz hh lh b fi lm ln l lo lp">contract Owned {<br/>address Owner ;<br/>function owned() {<br/>owner = msg.sender;<br/>}}<br/>contract Mortal is Owned {  // 'is' keyword is used for inheritance<br/>function kill(){<br/>self-destruct(owner);   }}<br/>contract User is Owned, Mortal //Multiple inheritance<br/>{<br/>string public UserName;<br/>function User(string _name){<br/>UserName = _name;<br/>}}</span></pre><p id="0e6b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jx">好的，我觉得上面讨论的概念已经足够让你开始使用可靠性编程了。</em></p><p id="d3dd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">去码！！</strong></p><p id="eb34" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">至此，我结束了这篇<em class="jx">坚实度教程</em>博客。我希望你喜欢阅读这个博客，并发现它的信息量。到目前为止，您一定已经很好地理解了什么是Solidity编程语言。现在开始练习吧。</p><p id="e7ac" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jx">有问题要问我们吗？请在评论区提到它，我们会尽快回复您。</em></p><p id="85be" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我希望这篇博客能给你提供信息，增加你的知识。</p><p id="aec0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，那么你可以参考<a class="ae mp" href="https://www.edureka.co/blog/?utm_source=medium&amp;utm_medium=solidity-tutorial" rel="noopener ugc nofollow" target="_blank"> Edureka的官方网站。</a></p><p id="26b7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">请留意本系列中的其他文章，它们将解释区块链的其他各个方面。</p><blockquote class="mq mr ms"><p id="a7f5" class="il im jx in b io ip iq ir is it iu iv mt ix iy iz mu jb jc jd mv jf jg jh ji ha bi translated"><em class="hh"> 1。</em> <a class="ae mp" rel="noopener" href="/edureka/blockchain-tutorial-d05f9c36b62b"> <em class="hh">区块链教程</em> </a></p><p id="60b1" class="il im jx in b io ip iq ir is it iu iv mt ix iy iz mu jb jc jd mv jf jg jh ji ha bi translated"><em class="hh"> 2。</em> <a class="ae mp" rel="noopener" href="/edureka/ethereum-tutorial-with-smart-contracts-db7f80175646"> <em class="hh">以太坊教程</em> </a></p><p id="8b8e" class="il im jx in b io ip iq ir is it iu iv mt ix iy iz mu jb jc jd mv jf jg jh ji ha bi translated"><em class="hh"> 3。</em> <a class="ae mp" rel="noopener" href="/edureka/ethereum-private-network-tutorial-22ef4119e4c3"> <em class="hh">以太坊专用网络</em> </a></p><p id="ea63" class="il im jx in b io ip iq ir is it iu iv mt ix iy iz mu jb jc jd mv jf jg jh ji ha bi translated"><em class="hh"> 4。</em> <a class="ae mp" rel="noopener" href="/edureka/smart-contracts-301d39565b76"> <em class="hh">什么是智能合约？</em> </a></p><p id="fe09" class="il im jx in b io ip iq ir is it iu iv mt ix iy iz mu jb jc jd mv jf jg jh ji ha bi translated"><em class="hh"> 5。</em> <a class="ae mp" rel="noopener" href="/edureka/developing-ethereum-dapps-with-truffle-7533289c8b2"> <em class="hh">松露以太坊教程</em> </a></p><p id="c603" class="il im jx in b io ip iq ir is it iu iv mt ix iy iz mu jb jc jd mv jf jg jh ji ha bi translated"><em class="hh"> 6。</em> <a class="ae mp" rel="noopener" href="/edureka/ethereum-development-tools-7175503a1ac7"> <em class="hh">最好的以太坊开发工具</em> </a></p><p id="5ff1" class="il im jx in b io ip iq ir is it iu iv mt ix iy iz mu jb jc jd mv jf jg jh ji ha bi translated"><em class="hh"> 7。</em> <a class="ae mp" rel="noopener" href="/edureka/hyperledger-fabric-184667460-edc184667460"> <em class="hh">超帐面料</em> </a></p><p id="3d06" class="il im jx in b io ip iq ir is it iu iv mt ix iy iz mu jb jc jd mv jf jg jh ji ha bi translated"><em class="hh"> 8。</em> <a class="ae mp" rel="noopener" href="/edureka/hyperledger-vs-ethereum-bdc868e10817"> <em class="hh"> Hyperledge vs以太坊</em> </a></p></blockquote><p id="a9da" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jx">原载于2020年7月21日</em><a class="ae mp" href="https://www.edureka.co/blog/solidity-tutorial/" rel="noopener ugc nofollow" target="_blank"><em class="jx">【https://www.edureka.co】</em></a><em class="jx">。</em></p></div></div>    
</body>
</html>