<html>
<head>
<title>The Power of HTTP for REST APIs — PART 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP对于REST APIs的威力—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/the-power-of-http-for-rest-apis-part-2-hypermedia-apis-hateoas-and-caching-2b41b9a40ff8?source=collection_archive---------4-----------------------#2018-07-22">https://medium.com/capital-one-tech/the-power-of-http-for-rest-apis-part-2-hypermedia-apis-hateoas-and-caching-2b41b9a40ff8?source=collection_archive---------4-----------------------#2018-07-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="1399" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">超媒体API、HATEOAS和缓存</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/6a5f371c36a351925c10acf216f1a348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTY6ltpkf6MeCX3u64YtBw.jpeg"/></div></div></figure><p id="489f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在第1部分  <em class="ke">的</em> <a class="ae kf" rel="noopener" href="/capital-one-developers/the-power-of-http-for-rest-apis-part-1-ca2a2bf525f"> <em class="ke">中，我们讲述了使用HTTP帮助我们设计健壮的REST APIs的基础知识。在第2部分中，我们将深入探讨一些细节。</em></a></p><h1 id="d1e3" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak">超媒体链接:都是相对的</strong></h1><p id="f5f3" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">超媒体API是由指向其他相关API端点的自描述链接驱动的。通常，这些链接指向相关的其他资源，例如项目的所有者，或者基于使用者的上下文指向相关的端点。为了利用超媒体链接，我们通过为资源分配唯一的URL来构建HTTP的核心原则。</p><p id="191e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是一个在资源表示中嵌入超媒体链接的Github示例:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="03a5" class="li kh hh le b fi lj lk l ll lm">GET <a class="ae kf" href="https://api.github.com/users/launchany" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/launchany</a><br/>{<br/>  “login”: “launchany”,<br/>  “id”: 17768866,<br/> "avatar_url”: “<a class="ae kf" href="https://avatars3.githubusercontent.com/u/17768866?v=3" rel="noopener ugc nofollow" target="_blank">https://avatars3.githubusercontent.com/u/17768866?v=3</a>",<br/>  “gravatar_id”: “”,<br/> “url”: “<a class="ae kf" href="https://api.github.com/users/launchany" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/launchany</a>",<br/> “html_url”: “<a class="ae kf" href="https://github.com/launchany" rel="noopener ugc nofollow" target="_blank">https://github.com/launchany</a>",<br/> “followers_url”:  “<a class="ae kf" href="https://api.github.com/users/launchany/followers" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/launchany/followers</a>",<br/> “following_url”:<br/> “<a class="ae kf" href="https://api.github.com/users/launchany/following" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/launchany/following</a>{/other_user}",<br/> “gists_url”:   “<a class="ae kf" href="https://api.github.com/users/launchany/gists" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/launchany/gists</a>{/gist_id}",</span><span id="3449" class="li kh hh le b fi ln lk l ll lm">  …<br/>}</span></pre><p id="8a47" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这个示例响应中提供的链接帮助客户端导航API，因为它需要关于用户的更多细节，例如用户的gravitar图像。客户端不需要关心图像托管在哪里，以及图像托管服务是否会随着时间的推移而改变——它只是在显示gravitar时使用提供的URL。我们的API客户端变得更能适应变化，并且受益于不再需要手工制作URL。</p><p id="ae11" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">需要支持分页的API通常使用offset和limit参数来设计，以便在返回第一组结果后请求后续页面。对于经常变化的数据集，更好的方法可能是使用游标来避免跳过或重复结果。我们的分页策略可能需要改变，如果我们改变我们的分页策略，我们不希望导致我们的API客户端突然中断。</p><p id="1867" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们如何设计一种分页方法，既适用于这两种情况，也适用于目前还不知道的其他情况？我们可以再次使用超媒体链接，但是这一次是为了引导API客户端在结果中导航，而不仅仅是引用外部图像或API的其他部分。</p><p id="a76c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们看一个超媒体响应的例子:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="402e" class="li kh hh le b fi lj lk l ll lm">{<br/>   “_links”: { <br/>   “self”: {“href”: “/projects” }, <br/>  “curies”: [{“name”: “cofrel”, “href”:   “<a class="ae kf" href="http://api.example.com/hypermedia/rels/" rel="noopener ugc nofollow" target="_blank">http://api.example.com/hypermedia/rels/</a>{rel}", “templated”: true }],<br/>  “next”: {“href”: “/projects?since=d266f6cd-fddf-41d8–906f355cbecfb2de&amp;maxResults=20” }, <br/>  “prev”: {“href”: “/projects?since=43be807d-d518–41f3–9206- e43b5a8f0928&amp;maxResults=20” }, <br/>  “first”: {“href”: “/projects?since=ef24266a-13b3–4730–8a79- ab9647173873&amp;maxResults=20” }, <br/>  “last”: {“href”: “/projects?since=4e8c74be-0e99–4cb8-a473- 896884be11c8&amp;maxResults=20” }, <br/>  “cofrel:find”: { “href”: “/orders{?id}”, “templated”: true }, <br/> }, <br/> “currentlyActive”: 4, <br/> “currentlyArchived”: 24<br/> }</span></pre><p id="9190" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">有了我们的导航超媒体链接，API客户能够通过结果在任何方向跟踪结果。他们不必关心分页样式，如何正确地编写URL，或者样式是否发生了变化。这是非常强大的，甚至模仿了我们今天使用谷歌或必应搜索的方式。</p><p id="6ccf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这种管理分页的方法还有一个额外的好处，就是可以将服务器端的状态传递给客户端。如果我们在结果的第一页，不会提供“上一页”链接，用户界面可以通过禁用“上一页”链接来反映这一点。同样，如果我们在结果的最后一页，将不会提供“下一页”链接。这是HATEOAS约束的一个应用。</p><p id="0e7e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">HATEOAS <em class="ke">(“作为应用程序状态引擎的超媒体”</em>)是REST中的一个约束，起源于<a class="ae kf" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf" rel="noopener ugc nofollow" target="_blank">菲尔丁的论文</a>。HATEOAS的主要优点是避免发送布尔字段或与状态相关的字段，这些字段需要客户端解释它们并决定接下来可以采取什么行动。相反，服务器提前确定这一点，并通过提供的链接的存在与否来传达什么可以做，什么不可以做。</p><blockquote class="lo lp lq"><p id="1222" class="ji jj ke jk b jl jm ii jn jo jp il jq lr js jt ju ls jw jx jy lt ka kb kc kd ha bi translated">概要:超媒体和HATEOAS是由分配给API中资源的URL驱动的。这些链接可以将状态传递给客户端，根据用户的权限和数据状态，通知用户在特定时间可以做什么和不可以做什么。正是HTTP和URL的使用使我们能够通过超媒体和HATEOAS构建可进化的应用程序。</p></blockquote><h1 id="4e12" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak">客户端缓存:提升应用性能</strong></h1><p id="f33f" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">缓存是数据的本地存储，以防止将来重新检索数据。熟悉这个术语的开发人员可能已经使用过服务器端缓存，使用诸如<a class="ae kf" href="https://memcached.org/" rel="noopener ugc nofollow" target="_blank"> memcached </a>之类的工具将数据保存在内存中，并减少从数据库获取未更改数据的需求，以提高应用程序性能。</p><p id="f2af" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae kf" href="https://tools.ietf.org/html/rfc7234#section-2" rel="noopener ugc nofollow" target="_blank"> HTTP缓存语义</a>允许客户端将可缓存的响应存储在本地，将缓存从服务器端移到离客户端更近的地方，以获得更好的性能并减少对网络的依赖。</p><p id="0d10" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为了支持这一点，HTTP通过<em class="ke"> Cache-Control </em> response头提供了几个缓存选项，该头定义了响应是否可缓存，如果可缓存，可缓存多长时间。只有当HTTP方法是GET或HEAD并且正确的<em class="ke"> Cache-Control </em>头指示内容可缓存时，才可以缓存响应。</p><p id="5987" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们重新检查我们的内容协商示例请求:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="6b38" class="li kh hh le b fi lj lk l ll lm">GET <a class="ae kf" href="https://api.example.com/projects" rel="noopener ugc nofollow" target="_blank">https://api.example.com/projects</a> HTTP/1.0<br/>Accept: application/json;q=0.5,application/xml;q=1.0</span></pre><p id="11be" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是一个示例响应，其中包括来自API服务器的缓存指令:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="808c" class="li kh hh le b fi lj lk l ll lm">HTTP/1.0 200 OK<br/>Date: Tue, 16 June 2015 06:57:43 GMT<br/>Content-Type: application/xml<br/>Cache-Control: max-age=240</span><span id="310e" class="li kh hh le b fi ln lk l ll lm"><br/>&lt;project&gt;…&lt;/project&gt;</span></pre><p id="4d2f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在本例中，最大年龄表示在客户端认为数据过时之前，数据最多可以缓存240秒(4分钟)。</p><p id="63b0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">谷歌开发者网站上有伊利亚·格里戈利克的一篇很棒的文章，详细描述了HTTP缓存的客户端-服务器交互。</p><blockquote class="lo lp lq"><p id="8ecb" class="ji jj ke jk b jl jm ii jn jo jp il jq lr js jt ju ls jw jx jy lt ka kb kc kd ha bi translated">摘要:HTTP提供了一个cache-control头，通知客户端一个响应是否可以缓存以及缓存多长时间。将这个头应用到我们的API客户端代码将会减少网络流量，加快我们的web和移动应用程序的速度。为了利用HTTP提供的这些功能，需要进行深思熟虑的缓存设计，包括哪些资源可以缓存以及缓存多长时间。</p></blockquote><h1 id="ee8d" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak">中介缓存:减少网络延迟</strong></h1><p id="7bc2" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">HTTP规范<a class="ae kf" href="https://tools.ietf.org/html/rfc7230#section-2.3" rel="noopener ugc nofollow" target="_blank">定义了对中介</a>的支持，允许通过一系列连接来处理请求。这些中介根据需要放置在客户机和API服务器之间，使网络行为可以在不了解API的情况下添加。中介使用的示例包括:</p><ul class=""><li id="254a" class="lu lv hh jk b jl jm jo jp jr lw jv lx jz ly kd lz ma mb mc bi translated">一个反向代理/网关，用于路由到防火墙内部的服务并实施安全/速率限制。</li><li id="4538" class="lu lv hh jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc bi translated">一个web应用程序防火墙，用于防范常见的攻击媒介，如XML解析器攻击、SQL注入等。</li><li id="a107" class="lu lv hh jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc bi translated">生成传入请求的度量和分析，以向团队提供关于使用了什么端点、是否有任何端点返回过多的错误响应代码等的见解。</li><li id="3e30" class="lu lv hh jk b jl md jo me jr mf jv mg jz mh kd lz ma mb mc bi translated">缓存服务器可以快速地将响应返回给客户端，而不涉及后端服务，例如由<a class="ae kf" href="https://varnish-cache.org/intro/index.html#intro" rel="noopener ugc nofollow" target="_blank"> Varnish </a>和<a class="ae kf" href="https://www.nginx.com/resources/wiki/modules/redis/" rel="noopener ugc nofollow" target="_blank"> nginx+Redis </a>提供的那些服务器。</li></ul><p id="90ad" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">上面列出的最后一点，缓存服务器，是非常强大的。它们位于提供<em class="ke">缓存控制</em>响应指令的API前面，并代表API服务器存储响应。这使得API客户端无需实现缓存支持，同时在置于API后端之前提供透明的应用加速。</p><p id="7757" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">缓存服务器离客户端应用程序越远，进行一次往返API请求所需的时间就越长。这正是内容分发网络(cdn)的用武之地，因为它们将缓存服务器放在世界各地，离客户端应用程序更近。让我们看一个例子:</p><p id="8163" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在第一次请求时，从伦敦连接到澳大利亚的API服务器的移动应用可以通过CDN边缘节点透明地连接到远程API服务器。然后，CDN边缘节点缓存API服务器响应，并将结果返回给API客户端。后续请求将由更靠近移动应用的CDN边缘节点提供服务，直到超过缓存到期时间，CDN边缘节点需要从API服务器刷新其缓存。</p><p id="59e8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">fastly<a class="ae kf" href="https://www.fastly.com/blog/api-caching-part-i" rel="noopener ugc nofollow" target="_blank">发表了一篇关于API缓存</a>的好文章，提供了它如何工作的详细示例，以及一些后端缓存控制技术，用于在后端数据发生变化时使CDN缓存失效。</p><p id="cd2f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">值得注意的是，当使用缓存服务器时，客户端应用程序仍然必须通过网络连接到缓存服务器来刷新数据。为了完全避免网络往返，可以使用客户端缓存将数据存储在应用程序本身中。总的来说，我们减少了不必要的网络往返，但是当我们需要刷新客户端缓存时，我们从缓存服务器中受益。</p><blockquote class="lo lp lq"><p id="7526" class="ji jj ke jk b jl jm ii jn jo jp il jq lr js jt ju ls jw jx jy lt ka kb kc kd ha bi translated">概要:HTTP支持API客户机和服务器之间的中介。它们理解HTTP协议，可以评估传入请求的可缓存性，而不需要解析或理解特定的请求/响应负载。</p></blockquote><h1 id="1692" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak">条件请求:保持最新</strong></h1><p id="9c68" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">条件请求是HTTP提供的一个不太为人所知但很强大的功能。条件请求允许客户端仅在某些内容发生变化时请求更新的资源表示。如果内容没有改变，发送条件请求的客户端将接收到未修改的<em class="ke">304</em>，或者连同改变的内容一起接收到<em class="ke"> 200 OK </em>。有两种方法可以将客户机的本地缓存副本告知服务器进行比较:eTags和基于时间。</p><p id="8f08" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae kf" href="https://tools.ietf.org/html/rfc7232#section-2.3" rel="noopener ugc nofollow" target="_blank">实体标签</a>，或“eTag”，是一个代表当前资源状态的不透明值。客户端可以在GET、POST或PUT请求后存储eTag，并使用该值通过HEAD请求检查未来对表示的更改。通常，eTag是状态的散列值，尽管这不是必需的。所需的只是服务器生成唯一的eTag值的方法，该值可用于确定自上次检索以来状态是否已被修改:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="9368" class="li kh hh le b fi lj lk l ll lm">200 OK<br/>Location: /projects/12345<br/>Cache-Control: public, max-age=31536000<br/>ETag: “17f0fff99ed5aae4edffdd6496d7131f”</span></pre><p id="b8ee" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">客户端然后可以使用<em class="ke"> If-None-Match </em>请求报头来指示接收到的最后一个eTag:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="e1da" class="li kh hh le b fi lj lk l ll lm">GET /projects/12345<br/>If-None-Match: “17f0fff99ed5aae4edffdd6496d7131f”</span></pre><p id="89ac" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">或者，我们可以在<em class="ke">最后修改的</em>响应头中使用基于时间的前提条件。然后，<em class="ke"> If-Modified-Since </em>请求头可用于指定最后更新的时间戳，以与服务器上的最后更新时间戳进行比较，查看是否有任何更改:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="15d1" class="li kh hh le b fi lj lk l ll lm">200 OK<br/>Location: /projects/12345<br/>Cache-Control: public, max-age=31536000<br/>Last-Modified: Mon, 19 Mar 2018 17:45:57 GMT</span></pre><p id="0893" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当API客户端发送GET请求时，它会将最后修改的时间戳作为条件请求的一部分:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="a514" class="li kh hh le b fi lj lk l ll lm">GET /projects/12345<br/>If-Modified-Since: Mon, 19 Mar 2018 17:45:57 GMT</span></pre><p id="3adf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果资源自2018年3月19日星期一17:45:57 GMT 以来没有发生变化，那么客户端将收到一个<em class="ke"> 304 Not Modified </em>而不是一个带有最新资源表示的200 OK。</p><blockquote class="lo lp lq"><p id="d627" class="ji jj ke jk b jl jm ii jn jo jp il jq lr js jt ju ls jw jx jy lt ka kb kc kd ha bi translated">摘要:条件请求减少了验证和重新获取缓存资源所需的工作量。etag是表示当前内部状态的不透明值，而最后修改的时间戳可以用于基于日期的比较，而不是etag。我们使用适当的前提条件请求头来通知服务器客户机上的版本。然后，API服务器返回资源的最新表示，或者如果自上次获取以来没有发生任何变化，则返回304未修改。</p></blockquote><h1 id="5f03" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak">并发控制:保护资源完整性</strong></h1><p id="08d5" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">条件请求也用于支持并发控制。通过将eTags或最后修改日期与状态更改方法(例如PUT)结合起来，我们可以确保数据不会被另一个API客户端意外覆盖。这在PUT方法的情况下尤其重要，在PUT方法中，整个资源表示被客户机提供的新表示所取代。</p><p id="5eaf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当API客户端发出修改请求时，如果eTag已经改变(通过<em class="ke"> If-Match </em>请求报头)或者如果时间戳没有改变(通过<em class="ke"> If-Unmodified-Since </em>请求报头),它们可以向请求添加前提条件以防止修改。如果前提条件失败，则服务器发送<em class="ke"> 412前提条件失败</em>响应。如果这两个请求头都没有找到，服务器还可以通过用<em class="ke"> 428要求的前提条件</em>进行响应来强制执行前提条件头的要求，以强制执行并发控制。</p><p id="7d2c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们举一个例子，两个API客户端试图修改一个项目。首先，每个客户端使用GET请求检索客户端，获得以下响应:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="42bb" class="li kh hh le b fi lj lk l ll lm">Location: /projects/12345<br/>Cache-Control: public, max-age=31536000<br/>ETag: “27f0fff99ed5aae4edffdd6496d7131f”</span><span id="c8a6" class="li kh hh le b fi ln lk l ll lm">{…}</span></pre><p id="32b0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然后，第一个API客户端通过用新的表示替换当前的表示来修改项目:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="06a3" class="li kh hh le b fi lj lk l ll lm">PUT /projects/1234<br/>If-Match: “27f0fff99ed5aae4edffdd6496d7131f”</span><span id="5d91" class="li kh hh le b fi ln lk l ll lm">{ “name”:”Project 1234", “Description”:”My project” }</span></pre><p id="5e30" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">服务器以<em class="ke"> 200 OK </em>响应，因为eTag匹配并返回具有新eTag的更新表示:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="4a77" class="li kh hh le b fi lj lk l ll lm">200 OK<br/>Location: /projects/12345<br/>Cache-Control: public, max-age=31536000<br/>ETag: “57f0fff99ed5aae4edffdd6496d7131f”</span><span id="9e1a" class="li kh hh le b fi ln lk l ll lm">{…}</span></pre><p id="5480" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">第二个API客户机在最初获取项目时具有相同的eTag，它也试图修改项目:</p><pre class="ix iy iz ja fd ld le lf lg aw lh bi"><span id="eb8a" class="li kh hh le b fi lj lk l ll lm">PUT /projects/1234<br/>If-Match: “27f0fff99ed5aae4edffdd6496d7131f”</span><span id="0264" class="li kh hh le b fi ln lk l ll lm">{ “name”:”Project ABCDE”, “Description”:”My renamed project” }</span></pre><p id="c5f7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">不幸的是，项目已经改变，所以第二个API客户端收到了不同的响应:</p><p id="f4ca" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="ke"> 412前置条件失败</em> </strong></p><p id="73bc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">第二个API客户端现在必须重新获取资源实例的当前表示，然后通知用户这些更改，并允许他们决定是希望重新提交所做的更改还是保持原样。</p><blockquote class="lo lp lq"><p id="4869" class="ji jj ke jk b jl jm ii jn jo jp il jq lr js jt ju ls jw jx jy lt ka kb kc kd ha bi translated">概要:并发控制可以通过请求报头中的HTTP前提条件添加到API中。如果eTag/last modified date没有改变，那么请求被正常处理。如果它已更改，将返回412响应代码，防止客户端因两个单独的客户端同时修改同一资源而覆盖数据。</p></blockquote><h1 id="d640" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated"><strong class="ak">总结部分2 </strong></h1><p id="e014" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc kd ha bi translated">在这个由两部分组成的系列中，我们只研究了HTTP规范中对我们的API有用的一小部分。有了这些东西，我们开始意识到HTTP是一个支持我们各种需求的健壮协议。通过应用这些技术，我们可以构建健壮的API来驱动既有弹性又可发展的复杂应用程序。</p><p id="bbf1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="ke">特别感谢</em> </strong> <a class="ae kf" href="https://urldefense.proofpoint.com/v2/url?u=https-3A__twitter.com_darrel-5Fmiller&amp;d=DwMFaQ&amp;c=pLULRYW__RtkwsQUPxJVDGboCTdgji3AcHNJU0BpTJE&amp;r=_AA5HejV89MayBA4AaRcjfFZu1EqtyznyyaBerOSTEbGKVYYEZ4vxIKnipbV-u4_KsWlis-DhR-xh8jnPwd4dA&amp;m=qLPLWmuLdkZehA29ITq3ZcZjfOEp1555lgBMyZItMPg&amp;s=gIa_u_VSyR9m4e5KFw-2KYvheYP1G_M4K8D_EgjRONQ&amp;e=" rel="noopener ugc nofollow" target="_blank"> <strong class="jk hi"> <em class="ke">达雷尔·米勒</em> </strong> </a> <strong class="jk hi"> <em class="ke">对本文的点评。</em>T13】</strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><a href="https://medium.com/capital-one-tech/api/home"><div class="er es mi"><img src="../Images/c6c5bb1f3967049ba012aebf5757e08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*x8RfN3y_bm7aDVs1vHMfkg.jpeg"/></div></a></figure></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><p id="8dad" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">披露声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权均为其各自所有者所有。本文为2018首都一。</em></p></div></div>    
</body>
</html>