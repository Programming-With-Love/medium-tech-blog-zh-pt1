<html>
<head>
<title>Cloning an Object in Javascript: Shallow Copy vs. Deep Copy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Javascript克隆一个对象:浅层拷贝与深层拷贝</h1>
<blockquote>原文：<a href="https://medium.com/version-1/cloning-an-object-in-javascript-shallow-copy-vs-deep-copy-fa8acd6681e9?source=collection_archive---------0-----------------------#2022-07-04">https://medium.com/version-1/cloning-an-object-in-javascript-shallow-copy-vs-deep-copy-fa8acd6681e9?source=collection_archive---------0-----------------------#2022-07-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/3a57a2ca9ad2a64fed3f7f475a2db251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ol0mvksfclUxJOwa"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@phillshaw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Phil Shaw</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3e99" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi js translated">有多少次你试图用Javascript克隆一个对象，结果却不是你期望的那样？在本文中，我们将解释克隆背后的基本概念，以确保您始终使用正确的选项。</p><h1 id="3189" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">浅层拷贝与深层拷贝</h1><p id="6589" class="pw-post-body-paragraph iu iv hh iw b ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">Javascript中有两种克隆对象的方法:</p><ul class=""><li id="8fee" class="lf lg hh iw b ix iy jb jc jf lh jj li jn lj jr lk ll lm ln bi translated"><strong class="iw hi">浅复制:</strong>表示<strong class="iw hi">只复制对象的第一级</strong>。引用更深层次的内容。</li><li id="eb2d" class="lf lg hh iw b ix lo jb lp jf lq jj lr jn ls jr lk ll lm ln bi translated"><strong class="iw hi">深度复制:</strong>表示<strong class="iw hi">对象的所有级别都被复制</strong>。这是该对象的真实副本。</li></ul><h1 id="5630" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">浅拷贝</h1><p id="a1ea" class="pw-post-body-paragraph iu iv hh iw b ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">使用<strong class="iw hi">扩展操作符(…) </strong>或使用<strong class="iw hi">对象可以实现浅拷贝。</strong></p><figure class="lt lu lv lw fd ii"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="6937" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如您在这段代码中看到的:</p><ul class=""><li id="4fd1" class="lf lg hh iw b ix iy jb jc jf lh jj li jn lj jr lk ll lm ln bi translated">在更新克隆对象的第一层中的属性后，<strong class="iw hi">原始属性不会被更新</strong>。</li><li id="6450" class="lf lg hh iw b ix lo jb lp jf lq jj lr jn ls jr lk ll lm ln bi translated">在更新更深层次的属性后，<strong class="iw hi">原始属性也被更新</strong>。发生这种情况是因为，在这种情况下，更深的级别被引用，而不是被复制。</li></ul><h1 id="342a" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">深层拷贝</h1><p id="45a9" class="pw-post-body-paragraph iu iv hh iw b ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">使用<strong class="iw hi">JSON . parse+JSON . stringify</strong>可以实现深度复制:</p><figure class="lt lu lv lw fd ii"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="ff19" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如您在这段代码中看到的:</p><ul class=""><li id="0ccc" class="lf lg hh iw b ix iy jb jc jf lh jj li jn lj jr lk ll lm ln bi translated">在更新克隆对象的第一层中的属性后，<strong class="iw hi">原来的属性不更新</strong>。</li><li id="f8c7" class="lf lg hh iw b ix lo jb lp jf lq jj lr jn ls jr lk ll lm ln bi translated">更新更深层次的属性后，<strong class="iw hi">原始属性不再更新</strong>。发生这种情况是因为，在这种情况下，更深的层次也被复制。</li></ul><h1 id="cbc8" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">表演</h1><p id="2a95" class="pw-post-body-paragraph iu iv hh iw b ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">由于显而易见的原因，浅层拷贝比深层拷贝快得多。但这并不意味着您应该总是使用浅层副本，因为有时您也需要嵌套对象的副本。那么，我应该使用哪个选项呢？</p><ul class=""><li id="04b7" class="lf lg hh iw b ix iy jb jc jf lh jj li jn lj jr lk ll lm ln bi translated">如果对象的深度等于1，使用浅拷贝。</li><li id="5ece" class="lf lg hh iw b ix lo jb lp jf lq jj lr jn ls jr lk ll lm ln bi translated">如果对象的深度大于1，使用深度副本。</li></ul><p id="867f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">编码快乐！</p><p id="0375" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">关于作者:</strong></p><p id="379b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">米格尔·穆尼奥斯是版本1的首席软件工程师。关注我们的媒体账户了解更多内容。</p></div></div>    
</body>
</html>