<html>
<head>
<title>MediaBrowserServiceCompat and the modern media playback app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MediaBrowserServiceCompat和现代媒体播放应用程序</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/mediabrowserservicecompat-and-the-modern-media-playback-app-7959a5196d90?source=collection_archive---------0-----------------------#2016-03-02">https://medium.com/androiddevelopers/mediabrowserservicecompat-and-the-modern-media-playback-app-7959a5196d90?source=collection_archive---------0-----------------------#2016-03-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7aa6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">与大多数应用程序相比，媒体应用程序从与Android系统和其他应用程序的合作中受益匪浅。有些事情，比如用音频焦点处理中断，几乎从Android诞生之初就一直存在，现在也和以前一样重要。虽然使用mediasessionpat的<a class="ae jc" href="https://www.youtube.com/watch?v=FBC1FgWe5X4&amp;utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">媒体回放相对较新，但它提供了一种跨所有API 4+ API级别与系统对话的一致方式。</a></p><p id="4ccb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是这些都没有触及最重要的部分:让你喜欢上<em class="jd">media session pat</em>——使用服务与你的用户界面或者其他任何人对话。这就是<em class="jd">MediaBrowserServiceCompat</em><strong class="ig hi"/>介入的地方Android支持库的<a class="ae jc" href="http://android-developers.blogspot.com/2016/02/android-support-library-232.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">版本23.2中的新添加。</a></p><p id="a27b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"><em class="jd">MediaBrowserServiceCompat和MediaBrowserCompat </em>用作您的媒体播放服务和其他组件之间的预建通信协议。</strong></p><h1 id="29c5" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">我们来分解一下</h1><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/602c86d5bb64aaf31a0d8ea1663ad857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZTLDnkAEl3c1oygw7lhKg.png"/></div></div></figure><p id="1cf9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MediaBrowserServiceCompat是一个很长的名字，我给你。但是大部分应该是不言自明的:</p><ul class=""><li id="a2e0" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kt ku kv kw bi translated"><strong class="ig hi">媒体</strong>:这个类专门针对媒体播放应用，更侧重于<strong class="ig hi">音频</strong>播放</li><li id="3454" class="ko kp hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated">浏览器:这是新的部分，我们将在下面详细介绍</li><li id="faa5" class="ko kp hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated"><strong class="ig hi">服务</strong>:这是<em class="jd">服务</em>的一个子类，你可以用它作为你的媒体播放服务(管理后台播放的服务)的基类</li><li id="ae62" class="ko kp hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated"><strong class="ig hi"> Compat </strong>:与<a class="ae jc" href="http://developer.android.com/reference/android/service/media/MediaBrowserService.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jd">MediaBrowserService</em></a>(添加在棒棒糖中)不同，这个版本是<a class="ae jc" href="http://developer.android.com/tools/support-library/features.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog#v4" rel="noopener ugc nofollow" target="_blank">支持v4 </a>的一部分，并且一直支持回到API 4</li></ul><p id="0acb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，如果<em class="jd">MediaBrowserServiceCompat</em>是您的服务子类，那么通信协议的另一半(即，您的UI将用来连接到<em class="jd">MediaBrowserServiceCompat</em>的部分)是<em class="jd"> MediaBrowserCompat </em>。不需要编写自定义操作，管理捆绑包和意图，或任何这样的事情！</p><p id="9bcd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Compat方面重要的一点:<strong class="ig hi">这些Compat类与其框架版本是交叉兼容的。</strong>这意味着您可以使用<em class="jd"> MediaBrowserCompat </em>连接到使用<em class="jd"> MediaBrowserService </em>的应用程序，或者使用<em class="jd">MediaBrowserService compat</em>并仍然使用<em class="jd"> MediaBrowser </em>处理连接到您的服务的应用程序。它只是工作。</p><p id="9c44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同时使用<em class="jd">MediaBrowserServiceCompat</em>和<em class="jd"> MediaBrowserCompat </em>有一个显著的好处——你也可以在棒棒糖设备上使用最新的棉花糖API。#魔法</p><h1 id="1192" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">基础知识</h1><p id="a950" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">让我们先把“浏览器”部分放在一边，看看最基本的:连接一个<em class="jd">MediaBrowserServiceCompat</em>和一个<em class="jd"> MediaBrowserCompat </em>。</p><p id="7717" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对服务的更改包括添加意图过滤器:</p><pre class="kd ke kf kg fd lh li lj lk aw ll bi"><span id="8de9" class="lm jf hh li b fi ln lo l lp lq">&lt;service android:name=".MediaPlaybackService"<br/>  android:exported="true"&gt;<br/> <strong class="li hi">&lt;intent-filter&gt;<br/>  &lt;action android:name="android.media.browse.MediaBrowserService" /&gt;<br/> &lt;/intent-filter&gt;</strong><br/>&lt;/service&gt;</span></pre><p id="2b6e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您还需要稍微更新您的代码:</p><pre class="kd ke kf kg fd lh li lj lk aw ll bi"><span id="4918" class="lm jf hh li b fi ln lo l lp lq">public class MediaPlaybackService extends MediaBrowserServiceCompat {<br/> private MediaSessionCompat mMediaSession;</span><span id="0285" class="lm jf hh li b fi lr lo l lp lq"> @Override<br/> public void onCreate() {<br/>  super.onCreate();<br/>  // Create your MediaSessionCompat.<br/>  // You should already be doing this<br/>  mMediaSession = new MediaSessionCompat(this,<br/>    MediaPlaybackService.class.getSimpleName());</span><span id="6f4e" class="lm jf hh li b fi lr lo l lp lq">  // Make sure to configure your MediaSessionCompat as per<br/>  // <a class="ae jc" href="https://www.youtube.com/watch?v=FBC1FgWe5X4&amp;utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=FBC1FgWe5X4</a></span><span id="cda5" class="lm jf hh li b fi lr lo l lp lq">  <strong class="li hi">setSessionToken(mMediaSession.getSessionToken());<br/> </strong>}</span><span id="2f11" class="lm jf hh li b fi lr lo l lp lq"> @Override<br/> <strong class="li hi">public BrowserRoot onGetRoot(@NonNull String clientPackageName,<br/>   int clientUid, Bundle rootHints) {<br/>  </strong>// Returning null == no one can connect<br/>  // so we’ll return something<br/>  return new BrowserRoot(<br/>    getString(R.string.app_name), // Name visible in Android Auto<br/>    null); // Bundle of optional extras<br/> }</span><span id="b96c" class="lm jf hh li b fi lr lo l lp lq"> @Override<br/> <strong class="li hi">public void onLoadChildren(String parentId,<br/>    Result&lt;List&lt;MediaBrowserCompat.MediaItem&gt;&gt; result) {<br/>  </strong>// I promise we’ll get to browsing<br/>  result.sendResult(null);<br/> }<br/>}</span></pre><p id="c7f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">是的，我们必须实现两个新的(抽象)方法。唯一的其他变化是调用<em class="jd">setSessionToken()</em>——最好是在您的<em class="jd"> onCreate() </em>方法中，但基本上要尽快。您不应该等待回放开始，因为我们需要在<em class="jd"> MediaBrowserCompat </em>端使用该令牌:</p><pre class="kd ke kf kg fd lh li lj lk aw ll bi"><span id="7331" class="lm jf hh li b fi ln lo l lp lq">private MediaBrowserCompat mMediaBrowser;</span><span id="f29c" class="lm jf hh li b fi lr lo l lp lq">@Override<br/>protected void onCreate(Bundle savedInstanceState) {<br/> super.onCreate(savedInstanceState);<br/> // The usual setContentView, etc<br/> // Now create the MediaBrowserCompat<br/> <strong class="li hi">mMediaBrowser = new MediaBrowserCompat</strong>(<br/>   <strong class="li hi">this</strong>, // a Context<br/>   <strong class="li hi">new ComponentName(this, MediaPlaybackService.class)</strong>,<br/>     // Which MediaBrowserService<br/>   <strong class="li hi">new MediaBrowserCompat.ConnectionCallback()</strong> {<br/>    @Override<br/>    public void onConnected() {<br/>     try {<br/>      // Ah, here’s our Token again<br/>      MediaSessionCompat.Token token =<br/>        mMediaBrowser.getSessionToken();<br/>      // This is what gives us access to everything<br/>      MediaControllerCompat controller =<br/>        new MediaControllerCompat(MainActivity.this, token);</span><span id="60ca" class="lm jf hh li b fi lr lo l lp lq">      // Convenience method to allow you to use<br/>      // MediaControllerCompat.getMediaController() anywhere<br/>      MediaControllerCompat.setMediaController(<br/>        MainActivity.this, controller);<br/>     } catch (RemoteException e) {<br/>      Log.e(MainActivity.class.getSimpleName(),<br/>        "Error creating controller", e);<br/>     }<br/>    }</span><span id="8ada" class="lm jf hh li b fi lr lo l lp lq">    @Override<br/>    public void onConnectionSuspended() {<br/>     // We were connected, but no longer :-(<br/>    }</span><span id="60f2" class="lm jf hh li b fi lr lo l lp lq">    @Override<br/>    public void onConnectionFailed() {<br/>      // The attempt to connect failed completely.<br/>      // Check the ComponentName!<br/>    }<br/>   },<br/>   <strong class="li hi">null</strong>); // optional Bundle<br/> <strong class="li hi">mMediaBrowser.connect();<br/></strong>}</span><span id="c760" class="lm jf hh li b fi lr lo l lp lq">@Override<br/>protected void onDestroy() {<br/> super.onDestroy();<br/> <strong class="li hi">mMediaBrowser.disconnect();</strong><br/>}</span></pre><p id="70fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以我们专门调用一个<em class="jd">组件名</em>来连接，并使用它来连接<em class="jd">MediaBrowserServiceCompat</em>。正如您可能已经猜到的，这为绑定服务包装了API，这是有意义的，因为我们试图连接到一个服务。一旦连接上，我们就可以访问<em class="jd">mediasessionpat。令牌</em>。<em class="jd">标记</em>允许我们创建一个<a class="ae jc" href="http://developer.android.com/reference/android/support/v4/media/session/MediaControllerCompat.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jd">媒体控制器比较</em> </a>。</p><blockquote class="ls lt lu"><p id="e4d8" class="ie if jd ig b ih ii ij ik il im in io lv iq ir is lw iu iv iw lx iy iz ja jb ha bi translated"><strong class="ig hi">注意:</strong>在这种情况下，我们从<em class="hh">fragmentation activity</em>内部进行连接，但这不是硬性要求。它也可以是一个<em class="hh">片段</em>或<em class="hh">加载器</em>——如果你使用的是保留片段/加载器，请确保你使用的是应用程序上下文。</p></blockquote><p id="3f3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请记住，当最后一个客户端解除绑定时，绑定的<strong class="ig hi">服务就会被销毁。如果您实际上使用<em class="jd">MediaBrowserServiceCompat</em>进行浏览，这通常没什么问题，但您应该在开始媒体播放时调用<a class="ae jc" href="http://developer.android.com/reference/android/content/Context.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog#startService(android.content.Intent)" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> startService() </em> </a>，在媒体播放停止时调用<a class="ae jc" href="http://developer.android.com/reference/android/content/Context.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog#stopSelf()" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> stopSelf() </em> </a>，以确保您的媒体播放不会因客户端解除绑定/重新绑定而中断——这种情况在配置更改时会发生。参见<a class="ae jc" href="https://github.com/googlesamples/android-UniversalMusicPlayer/blob/master/mobile/src/main/java/com/example/android/uamp/MusicService.java?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">通用Android音乐播放器的<em class="jd"> MusicService </em> </a>的例子，它正确处理了这种情况。</strong></p><h1 id="8384" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">MediaControllerCompat的力量</h1><p id="ada8" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">所有这些，我们得到的只是一个<a class="ae jc" href="http://developer.android.com/reference/android/support/v4/media/session/MediaControllerCompat.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jd">MediaControllerCompat</em></a>。谢天谢地，<strong class="ig hi">一个<em class="jd">媒体控制器比较</em>足够用来构建一个完整的UI </strong>。</p><p id="53cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用<a class="ae jc" href="http://developer.android.com/reference/android/support/v4/media/session/MediaControllerCompat.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog#getMetadata()" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="jd">get metadata()</em></strong></a>就可以得到当前所有的元数据。这包括当前艺术家、专辑、曲目名称、评级、专辑封面等信息，以及您在服务端传递给<a class="ae jc" href="https://developer.android.com/reference/android/support/v4/media/session/MediaSessionCompat.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog#setMetadata(android.support.v4.media.MediaMetadataCompat)" rel="noopener ugc nofollow" target="_blank"><em class="jd">set metadata()</em></a>的任何其他信息。</p><p id="1303" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用<a class="ae jc" href="http://developer.android.com/reference/android/support/v4/media/session/MediaControllerCompat.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog#getPlaybackState()" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="jd">getPlaybackState()</em></strong></a>，你会发现播放的当前状态(想不到吧)是什么——播放、暂停等。以及支持什么动作(例如跳到下一个)。</p><p id="dc79" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这两个都只是时间点的读数。但是不是让你不断地轮询这些值，而是有一个<a class="ae jc" href="http://developer.android.com/reference/android/support/v4/media/session/MediaControllerCompat.Callback.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="jd">MediaControllerCompat。回调</em> </strong> </a>可以传递给<a class="ae jc" href="http://developer.android.com/reference/android/support/v4/media/session/MediaControllerCompat.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog#registerCallback(android.support.v4.media.session.MediaControllerCompat.Callback)" rel="noopener ugc nofollow" target="_blank"><em class="jd">register callback()</em></a>。无论什么时候发生变化，你都会得到一个回调，让你的用户界面和你的服务保持同步。</p><p id="5586" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，这是一个双向通道，我们还没有谈到如何<strong class="ig hi">获取信息到您的服务</strong>—<a class="ae jc" href="http://developer.android.com/reference/android/support/v4/media/session/MediaControllerCompat.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog#getTransportControls()" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="jd">getTransportControls()</em></strong></a>填补了这一空白，为您提供了触发任何操作的方法(包括特定于您的媒体播放的自定义操作，如“向前跳过30秒”)。所有这些都直接触发了您的<a class="ae jc" href="https://developer.android.com/reference/android/support/v4/media/session/MediaSessionCompat.Callback.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jd">mediasessionpat中的方法。回调</em>为您服务</a>。</p><p id="4f42" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它还有更多的功能(音量调整、队列管理),所以我鼓励您全面了解它——您可能有自己的定制系统，可以完全替换它(节省您的代码维护！).</p><h1 id="ce63" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">浏览</h1><p id="825d" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">到目前为止，我们一直在关注使连接工作所需的最低要求。当然，这已经给了你很多可以玩的东西。但是如果没有一些浏览功能，我们就不会称之为<em class="jd">MediaBrowserServiceCompat</em>。<strong class="ig hi">浏览允许那些连接到您的<em class="jd">MediaBrowserServiceCompat</em>的用户获得您可用的媒体项目列表</strong>作为一个基本层次，从根开始，向下一层或多层子节点。</p><p id="f0d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然构建自己的UI是完全可选的，但浏览是Android Auto上构建UI的主要方式<strong class="ig hi">。只需在<a class="ae jc" href="http://developer.android.com/training/auto/audio/index.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">上添加Compat，为自动训练</a>提供音频回放。你会注意到<strong class="ig hi"> Android Wear也会在你的播放通知上提供一个浏览动作</strong>。</strong></p><h2 id="46d3" class="lm jf hh bd jg ly lz ma jk mb mc md jo ip me mf js it mg mh jw ix mi mj ka mk bi translated">onGetRoot()</h2><p id="a54b" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">一切从根开始。正如上面代码中提到的，<strong class="ig hi">您必须返回一个非空的<em class="jd"> BrowserRoot </em>来允许连接到您的<em class="jd">MediaBrowserServiceCompat</em></strong>。这个事实意味着选择返回什么根实际上是一件相当大的事情。</p><p id="a2d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://github.com/googlesamples/android-UniversalMusicPlayer?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">通用Android音乐播放器示例应用</a> (UAMP)包含一个方便的<a class="ae jc" href="https://github.com/googlesamples/android-UniversalMusicPlayer/blob/master/mobile/src/main/java/com/example/android/uamp/PackageValidator.java?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jd">package validator</em></a>类，你可以使用它来允许你自己的应用、Android Auto和Android Wear连接——这将是一个“白名单”风格的模型。你是选择使用白名单还是允许访问所有应用，更多的是商业决策，而不是技术决策。</p><p id="8626" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">返回根时要记住的另一件事是<strong class="ig hi">这是一个你可以根据连接应用</strong>改变行为的地方。例如，您可以使用UAMP的<a class="ae jc" href="https://github.com/googlesamples/android-UniversalMusicPlayer/blob/master/mobile/src/main/java/com/example/android/uamp/utils/CarHelper.java?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> CarHelper </a>或<a class="ae jc" href="https://github.com/googlesamples/android-UniversalMusicPlayer/blob/master/mobile/src/main/java/com/example/android/uamp/utils/WearHelper.java?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> WearHelper </a>作为检查传入包名称并返回不同根的示例。</p><p id="a9fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">返回不同的根可以在用户体验上产生巨大的差异</strong>。例如，让我们假设你将要浏览你自己的媒体并且想要支持Android Auto。一种简单的方法可能会让您为两者返回相同的层次结构。在Android Auto的安全问题上，拥有一个很深的层次或者任意长的列表(比如按字母顺序排列的艺术家列表)会导致一个沮丧的司机。考虑简化你的层级或者强调最有可能的内容(顶部的最近列表会有很大帮助！)来最小化用户和他们选择的专辑/歌曲之间的步骤数。</p><p id="a401" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<em class="jd"> MediaBrowserCompat端</em>，您将使用<em class="jd"> getRoot() </em>来获取根id。很简单。</p><h2 id="4288" class="lm jf hh bd jg ly lz ma jk mb mc md jo ip me mf js it mg mh jw ix mi mj ka mk bi translated">onLoadChildren()</h2><p id="35ef" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">一旦返回了一个根，这个根id将作为<em class="jd"> parentMediaId </em>传递给<em class="jd"> onLoadChildren() </em>。这里是您加载<em class="jd"> parentMediaId </em>的所有直接子节点的地方。</p><p id="5dfd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">乍一看，该方法的参数似乎有点奇怪(我知道它们让我陷入了一个循环)。不是直接返回值，而是通过调用<em class="jd"> Result.sendResult() </em>来返回值。这种机制允许您立即返回一个值(就像返回值一样)或调用<em class="jd"> detach() </em>，将结果推送到另一个线程，并且只有在加载完所有项目后才调用<em class="jd"> sendResult() </em>。如果你需要从网络上获取信息，这一点至关重要——不要因为把所有信息都加载到位而耽误了一切！</p><blockquote class="ls lt lu"><p id="8b1f" class="ie if jd ig b ih ii ij ik il im in io lv iq ir is lw iu iv iw lx iy iz ja jb ha bi translated"><strong class="ig hi">注意:</strong>你会发现如果你在返回之前没有调用detach()或者sendResult()，你会得到一个<em class="hh"> IllegalStateException </em>。这是100%意料之中的。确保每个代码路径都调用一个或另一个。</p></blockquote><p id="ff33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">返回的每个项目都是一个<em class="jd"> MediaItem </em>，每个<em class="jd"> MediaItem </em>由一个<a class="ae jc" href="http://developer.android.com/reference/android/support/v4/media/MediaDescriptionCompat.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jd">MediaDescriptionCompat</em></a>(元数据的一个子集)和两个可用标志的某种组合组成:</p><ul class=""><li id="c944" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kt ku kv kw bi translated"><em class="jd"> FLAG_BROWSABLE </em>表示这个<em class="jd"> MediaItem </em>有自己的子节点(即，它的媒体id可以传递给<em class="jd"> onLoadChildren() </em>以获得更多的<em class="jd"> MediaItem </em>。</li><li id="e9a2" class="ko kp hh ig b ih kx il ky ip kz it la ix lb jb kt ku kv kw bi translated"><em class="jd">当这个<em class="jd"> MediaItem </em>可以直接播放(即传递给<a class="ae jc" href="http://developer.android.com/reference/android/support/v4/media/session/MediaControllerCompat.TransportControls.html?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog#playFromMediaId(java.lang.String,%20android.os.Bundle)" rel="noopener ugc nofollow" target="_blank"> playFromMediaId() </a>开始播放)时，应该使用FLAG_PLAYABLE </em></li></ul><p id="f89f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<em class="jd"> MediaBrowserCompat </em>端检索子节点需要调用<em class="jd"> subscribe() </em>。每当孩子发生变化时(例如，当服务调用<em class="jd">notifychilderchanged()</em>)您都会得到一个回调:</p><pre class="kd ke kf kg fd lh li lj lk aw ll bi"><span id="e679" class="lm jf hh li b fi ln lo l lp lq">String root = mediaBrowser.getRoot();<br/><strong class="li hi">mediaBrowser.subscribe(</strong>root,<br/>  <strong class="li hi">new MediaBrowserCompat.SubscriptionCallback()</strong> {<br/>   @Override<br/>   <strong class="li hi">public void onChildrenLoaded(@NonNull String parentId,<br/>     List&lt;MediaBrowserCompat.MediaItem&gt; children) {</strong><br/>    if (children == null || children.isEmpty()) {<br/>     return;<br/>    }<br/>    MediaBrowserCompat.MediaItem firstItem = children.get(0);<br/>    // Play the first item?<br/>    // Probably should check firstItem.isPlayable()<br/>    MediaControllerCompat.getMediaController(MainActivity.this)<br/>      .getTransportControls()<br/>      .playFromMediaId(firstItem.getMediaId(), null);<br/>  }<br/>});</span></pre><p id="33da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当你不再喜欢回电的时候，有一个等价的unsubscribe() 。</p><h2 id="70ad" class="lm jf hh bd jg ly lz ma jk mb mc md jo ip me mf js it mg mh jw ix mi mj ka mk bi translated">onLoadItem()</h2><p id="94fe" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated"><em class="jd"> onLoadItem() </em>是<em class="jd">MediaBrowserService</em>API的新成员，仅在棉花糖中添加。这是一种方便的方法，允许连接的<em class="jd"> MediaBrowserCompat </em>实例检索仅与单个媒体id相关联的<em class="jd"> MediaItem </em>。</p><p id="6dbd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您会注意到，默认实现只返回空值。因为这允许更有效地查询单个元素，所以请实现它！鉴于这应该返回与来自父节点的<em class="jd"> onLoadChildren() </em>相同的<em class="jd"> MediaItem </em>，您应该能够重用大部分逻辑。</p><p id="141c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您将在连接的<em class="jd"> MediaBrowserCompat </em>中使用<em class="jd"> getItem() </em>来检索特定的项目。回调<em class="jd"> onError() </em>在您没有连接或者另一端发生了可怕的事情时使用——在大多数情况下，您会得到对<em class="jd"> onItemLoaded() </em>的回调。</p><h1 id="947f" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">我可以继续</h1><p id="ebba" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">我所说的大部分内容很有可能是现有的媒体播放应用程序已经在做的事情:向您的服务发送命令，广播更改以更新您的UI，存储和检索媒体项目的层次结构，等等。相信我，如果这不是一个伟大的媒体应用程序的关键，我不会谈论这一切。</p><p id="e008" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是与竞争对手相比，编写和维护这种逻辑真的是你的独特的定义特征吗？我希望不会。</p><p id="f780" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你还会收到要求你使用<em class="jd"> MediaBrowserService </em>来支持Android Auto的请求吗？大概吧。我们要在这个API上构建更多吗？是的，是的，我们是。(我们已经添加了Android Wear。)</p><p id="93ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你会发现UAMP已经完全升级到利用<em class="jd">MediaBrowserServiceCompat</em>以及<em class="jd">mediasessionpat</em>的优势，所以请查看<a class="ae jc" href="https://github.com/googlesamples/android-UniversalMusicPlayer?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">完整源代码</a>！</p><p id="23c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您一直在拖延查看API或将其集成到您的应用程序中，那么现在没有比<em class="jd">更好的时间了</em>来看看并#BuildBetterApps</p><p id="7c54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关注<a class="ae jc" href="https://plus.google.com/collection/sLR0p?utm_campaign=adp_series_mediabrowserservicecompat_030116&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> Android开发模式集合</a>了解更多！</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ml"><img src="../Images/ede78edee0069962aa0daa7cc8c85f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6K7IYkWhCzkS6YAgxLfXw.png"/></div></div></figure></div></div>    
</body>
</html>