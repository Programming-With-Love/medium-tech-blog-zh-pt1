<html>
<head>
<title>MapStruct — Let me write the tedious piece of code for you!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">map struct——让我来为您编写这段冗长的代码吧！</h1>
<blockquote>原文：<a href="https://medium.com/globant/mapstruct-let-me-write-the-tedious-piece-of-code-for-you-d3c27f667314?source=collection_archive---------0-----------------------#2021-06-03">https://medium.com/globant/mapstruct-let-me-write-the-tedious-piece-of-code-for-you-d3c27f667314?source=collection_archive---------0-----------------------#2021-06-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/723b74708f911b37fcd6dee9c6fe67a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rugBTbkefQQgseC7"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@heykellybrito?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">J. Kelly Brito</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4ec7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi js translated"><span class="l jt ju jv bm jw jx jy jz ka di"> A </span>你还在为多层架构应用程序中的bean mapping编写样板代码吗？</p><p id="3a07" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果是这样，接下来的10分钟将会给你的编码风格带来欢乐。</p><h1 id="bdfd" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="d180" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">让我介绍一下<a class="ae it" href="https://mapstruct.org/documentation/stable/reference/html/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi"> MapStruct </strong> </a> —一个强大的Java注释处理器，通过为我们编写类型安全的bean映射类来简化我们的生活。</p><p id="9ba8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">与手动编写映射代码相比，MapStruct通过生成在编译时手动编写的冗长且容易出错的代码来节省时间。它使用合理的缺省值，但是当涉及到根据我们的业务需求配置或实现特殊行为时，它就不在我们的考虑范围内了。</p><p id="9a6f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您一定在想这个魔术是如何工作的，所以不再多说，让我们从Mapstruct开始吧。</p></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h1 id="90af" class="kb kc hh bd kd ke ll kg kh ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky bi translated">设置</h1><h2 id="8453" class="lq kc hh bd kd lr ls lt kh lu lv lw kl jf lx ly kp jj lz ma kt jn mb mc kx md bi translated">依赖性-</h2><ol class=""><li id="ec47" class="me mf hh iw b ix kz jb la jf mg jj mh jn mi jr mj mk ml mm bi translated"><em class="mn">如果您使用</em><strong class="iw hi"><em class="mn">Maven</em></strong><em class="mn">，请将以下依赖项添加到您的</em> <strong class="iw hi"> <em class="mn"> POM.xml </em> </strong></li></ol><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mo"><img src="../Images/08da16e78b83a7c0e83de79a4485c4d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WsCskawX1hKaNUnVu4l4Xg.png"/></div></div></figure><p id="3b70" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">用<code class="du mt mu mv mw b">maven-compile-plugin</code>配置，用maven命令生成实现。</p><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mx"><img src="../Images/6b7d2476ef75f38c88ee1e1ad25a429e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VtlETtl9N3lbT2RaHtRFpQ.png"/></div></div></figure><blockquote class="my mz na"><p id="dc39" class="iu iv mn iw b ix iy iz ja jb jc jd je nb jg jh ji nc jk jl jm nd jo jp jq jr ha bi translated"><strong class="iw hi">提示</strong> —如果也使用<em class="hh"> Lombok </em>，在Mapstruct之前声明Lombok的路径定义，让Lombok在Mapstruct之前生成实现，这样Mapstruct就可以使用Lombok生成的方法。</p></blockquote></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><p id="68f4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2.<em class="mn">如果您使用</em><strong class="iw hi"><em class="mn">Gradle</em></strong><em class="mn">，请将以下依赖项添加到您的</em><strong class="iw hi"><em class="mn">build . Gradle</em></strong></p><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ne"><img src="../Images/e175ea1e219458dbcf6e336ab2f1f862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWbDUParE9FGCeZJd7L82g.png"/></div></div></figure><p id="9215" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">3.如果使用<em class="mn"> IDE </em>，不要忘记执行以下动作-</p><p id="9242" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">a) <em class="mn">启用注释处理器</em>(首选项/设置- &gt;构建执行部署- &gt;编译器- &gt;注释处理器)</p><p id="c563" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">b)将MapStruct插件安装到您的IDE中-</p><ul class=""><li id="6196" class="me mf hh iw b ix iy jb jc jf nf jj ng jn nh jr ni mk ml mm bi translated">要在Eclipse中安装MapStruct插件，<a class="ae it" href="https://marketplace.eclipse.org/content/mapstruct-eclipse-plugin" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi">点击我</strong> </a></li><li id="d5de" class="me mf hh iw b ix nj jb nk jf nl jj nm jn nn jr ni mk ml mm bi translated">要在IntelliJ中安装MapStruct插件，<a class="ae it" href="https://plugins.jetbrains.com/plugin/10036-mapstruct-support" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi">点击我</strong> </a></li></ul></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h1 id="2264" class="kb kc hh bd kd ke ll kg kh ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky bi translated">履行</h1><p id="b0de" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">为了让这种神奇的事情发生，我们只需要创建一个接口，用<strong class="iw hi"> <em class="mn"> @Mapper </em> </strong>注释<em class="mn"> MapStruct </em>并声明一些方法。</p><p id="56b1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们举个例子:</p><p id="7742" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设我们有两个POJO类——<em class="mn">Customer.java</em>和<em class="mn">客户到</em>。java，我们希望在它们之间执行字段映射。</p><p id="4a93" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"><em class="mn"/>Customer.java</strong></p><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es no"><img src="../Images/bdb10fdda5793c61737dc0a734404e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m-ZvmnYu02ug-sSnbKmhTQ.png"/></div></div></figure><p id="ec1c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">【CustomerDto.java】T5<strong class="iw hi">T6</strong></p><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es no"><img src="../Images/b6749b1a3b6b5116d574dd63b5f51975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hdq9AUaPYFSh-sJWd9-KoA.png"/></div></div></figure><p id="8938" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要在上述两个POJOs之间建立映射逻辑，我们只需编写如下接口</p><p id="5f39" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"><em class="mn">CustomerMapper.java</em></strong></p><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es np"><img src="../Images/4944c20a426c7728846f2ca257e04c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B5PuqWhZBxwP1YCDM0hsbw.png"/></div></div></figure><blockquote class="my mz na"><p id="1062" class="iu iv mn iw b ix iy iz ja jb jc jd je nb jg jh ji nc jk jl jm nd jo jp jq jr ha bi translated"><strong class="iw hi"><em class="hh">@ Mapper</em></strong><em class="hh"/>—该注释将告诉MapStruct生成接口的实现类。</p></blockquote><p id="61ce" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mn"> MapStruct </em>将通过查看声明方法的返回类型和参数类型来推断用户的意图，并将为其实现逻辑。</p><p id="5bcf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">编译完上面的代码后，你会得到下面由<em class="mn"> MapStruct </em>自动生成的类</p><p id="d0a6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"><em class="mn">CustomerMapperImpl.java</em></strong></p><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nq"><img src="../Images/c20f37787751acf035ccdd007c64a722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJTj1-I7S-7YZll57Qqryg.png"/></div></div></figure><p id="6e6a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这里，我们可以看到MapStruct通过遵循所有Java最佳实践为我们的Mapper接口生成了实现类。这只是POJO中两个字段的情况，但是考虑一下现实生活中的场景，我们可以有大量的字段和POJO，在这种情况下，Mapstruct可以非常方便地为我们生成映射。</p><p id="31d9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这太酷了，对吧！😎</p><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nr"><img src="../Images/544383cf744ff08747a6fd66637d9017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*px7Kn-YkJ9CCXboN"/></div></div></figure><p id="d4cc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以在以下位置找到生成的类:</p><ul class=""><li id="2886" class="me mf hh iw b ix iy jb jc jf nf jj ng jn nh jr ni mk ml mm bi translated">如果使用maven - <em class="mn">目标&gt;生成-源&gt;注释</em></li><li id="3623" class="me mf hh iw b ix nj jb nk jf nl jj nm jn nn jr ni mk ml mm bi translated">如果使用gradle - <em class="mn">构建&gt;生成&gt; annotationProcessor </em></li></ul></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><blockquote class="ns"><p id="d8af" class="nt nu hh bd nv nw nx ny nz oa ob jr dx translated"><em class="oc">上面的场景只是字段名相同的基本场景，但是我知道生活并不容易，所以现在让我们一个接一个地尝试一些真实的场景:</em></p></blockquote><h2 id="f720" class="lq kc hh bd kd lr od lt kh lu oe lw kl jf of ly kp jj og ma kt jn oh mc kx md bi translated"><strong class="ak">映射具有不同字段名的字段:</strong></h2><p id="85c4" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">新的POJOs将会是-</p><div class="mp mq mr ms fd ab cb"><figure class="oi ii oj ok ol om on paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/bb014a40192b9a7fe3da8b5cceb38050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*xI7mVOKYQGZz0AuBRjttag.png"/></div></figure><figure class="oi ii oj ok ol om on paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/c2cd93b90c5628c60115cf6d6bd2375f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Xu_XFmXav-ff0Np18rqWUQ.png"/></div></figure></div><p id="2b86" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要用不同的名称映射这些字段，我们所要做的就是告诉<em class="mn"> MapStruct </em>哪个字段映射到哪个字段。通过一个非常简单的注释<strong class="iw hi"> <em class="mn"> @Mapping </em> </strong>，新的Mapper界面将如下所示-</p><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es oo"><img src="../Images/11fa19a9a366f52f75ff3ee04e54bac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*celvO9_Pn-GiOyZElirrOQ.png"/></div></div></figure><blockquote class="my mz na"><p id="237d" class="iu iv mn iw b ix iy iz ja jb jc jd je nb jg jh ji nc jk jl jm nd jo jp jq jr ha bi translated"><strong class="iw hi">加分- </strong></p><p id="8ed1" class="iu iv mn iw b ix iy iz ja jb jc jd je nb jg jh ji nc jk jl jm nd jo jp jq jr ha bi translated">当有人更改了其中一个POJOs中的字段名称，但忘记在Mapper接口中更新该名称时，会发生什么情况？？？</p><p id="c8b8" class="iu iv mn iw b ix iy iz ja jb jc jd je nb jg jh ji nc jk jl jm nd jo jp jq jr ha bi translated">会给出编译时错误吗？？？</p><p id="2534" class="iu iv mn iw b ix iy iz ja jb jc jd je nb jg jh ji nc jk jl jm nd jo jp jq jr ha bi translated">答案是否定的，但是它会在运行时显示一些不希望的行为，因为不会为该字段执行映射。</p></blockquote><p id="469e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了在编译时发现这个错误，我们可以如下配置我们的映射器</p><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es op"><img src="../Images/ad39fd1ce33deb9597b2691a92bb26e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zYAiX_LpTBdgbDKl-F73g.png"/></div></div></figure><p id="9b99" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">注意</strong>:仅当您确定想要映射POJO中的所有字段时，才使用此配置，否则您可以将<em class="mn"> ReportingPolicy </em>保留为<em class="mn"> IGNORE </em>或<em class="mn"> WARN </em>以避免编译错误。</p></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h2 id="5235" class="lq kc hh bd kd lr ls lt kh lu lv lw kl jf lx ly kp jj lz ma kt jn mb mc kx md bi translated">用嵌套bean映射<strong class="ak">bean:</strong></h2><p id="bae1" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">假设我们分别有<em class="mn">Order.java</em>和<em class="mn">OrderDto.java</em>在<em class="mn">Customer.java</em>和<em class="mn">CustomerDto.java</em>之内，如下-</p><div class="mp mq mr ms fd ab cb"><figure class="oi ii oj ok ol om on paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/7ab6d524ca7f92333670f692327cb892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*XtYvrbXjCMXFAm9KNYBynw.png"/></div></figure><figure class="oi ii oj ok ol om on paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/6717ba74961210187b04360e3cc8d932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*gcMEGRMaiLpWOY938u4jTQ.png"/></div></figure></div><p id="a361" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了获得嵌套beans的映射，我们所要做的就是为<em class="mn">Order.java</em>到<em class="mn">OrderDto.java</em>添加方法，反之亦然，如果<em class="mn"> MapStruct </em>检测到需要转换的对象类型和要转换的方法存在于同一个类中，它将自动使用它。</p><p id="a840" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们新的映射界面看起来像-</p><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es np"><img src="../Images/949883594b489d42d176e87277ff01af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1QVAapUghqY4hhSve6bPZA.png"/></div></div></figure></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h2 id="a023" class="lq kc hh bd kd lr ls lt kh lu lv lw kl jf lx ly kp jj lz ma kt jn mb mc kx md bi translated">映射嵌套Bean内的<strong class="ak">字段:</strong></h2><p id="62b3" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">让我们考虑一下，我们想要将来自<em class="mn">Order.java</em>的<em class="mn"> id </em>映射到<em class="mn">CustomerDto.java</em>中的<em class="mn">Customer.java</em>到<em class="mn">订单Id </em>的嵌套bean。</p><p id="897e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">映射器将如下图所示-</p><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es oq"><img src="../Images/28369fa35c65243acd40555a7c94e044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ys6mGg508nBaC_fpOBlYgw.png"/></div></div></figure><blockquote class="my mz na"><p id="f1b8" class="iu iv mn iw b ix iy iz ja jb jc jd je nb jg jh ji nc jk jl jm nd jo jp jq jr ha bi translated"><em class="hh">类似地，我们可以将选定的字段从一个嵌套bean映射到另一个嵌套bean - </em></p></blockquote><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es or"><img src="../Images/2fd412dcdc073979471ed0a06f868d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-383Pc-ZANPdobpmK0sXFA.png"/></div></div></figure></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h2 id="956e" class="lq kc hh bd kd lr ls lt kh lu lv lw kl jf lx ly kp jj lz ma kt jn mb mc kx md bi translated">用几个源参数绘制<strong class="ak">方法:</strong></h2><p id="2984" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">MapStruct还支持带有几个源参数的映射方法。这对于将几个实体组合成一个数据传输对象非常有用。</p><p id="49d2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面显示了一个例子，其中我们有两个输入POJO<em class="mn">Customer.java</em>和<em class="mn">Order.java</em>被映射到单个POJO<em class="mn">CustomerDetailDto.java</em>:</p><figure class="mp mq mr ms fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es os"><img src="../Images/903555c1e91be91497533f40b70488aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WdwiZ-4wRJv_UyngxF9SnQ.png"/></div></div></figure></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h1 id="a55e" class="kb kc hh bd kd ke ll kg kh ki lm kk kl km ln ko kp kq lo ks kt ku lp kw kx ky bi translated">结论</h1><p id="b814" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">这是对<em class="mn"> Mapstruct </em>的基本介绍，你可以随时将<em class="mn"> MapStruct </em>与<em class="mn"> Lombok </em>结合使用，以加速你的开发，并使你的代码免于错误和维护。</p><p id="15f4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你知道其他映射框架，如<em class="mn">推土机</em>、<em class="mn"> Orika </em>、<em class="mn">模型映射器</em>和<em class="mn"> JMapper </em>，你一定在想为什么我要选择<em class="mn"> MapStruct </em>？它有什么特别之处？</p><p id="5e04" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以让我告诉你，你的思考方向是正确的，答案是-</p><blockquote class="ns"><p id="75ee" class="nt nu hh bd nv nw nx ny nz oa ob jr dx translated"><em class="oc"> MapStruct用最少的配置给了我们最好的性能。</em></p></blockquote><p id="a8c8" class="pw-post-body-paragraph iu iv hh iw b ix ot iz ja jb ou jd je jf ov jh ji jj ow jl jm jn ox jp jq jr ha bi translated">要进一步分析所有映射框架的性能，请阅读来自<em class="mn"> Baeldung </em>的信息丰富的<a class="ae it" href="https://www.baeldung.com/java-performance-mapping-frameworks" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi"> <em class="mn">文章</em> </strong> </a>。</p><p id="11be" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有关Mapstruct的高级概念，如Spring集成、类型转换、集合映射等，请浏览本系列的下一篇博客，<a class="ae it" rel="noopener" href="/@akshay.jain_76848/mapstruct-advanced-concepts-and-dependency-injection-46f28af54e33"> c <strong class="iw hi"> <em class="mn">舔我，我会带你到那里！</em>T58</strong></a></p><h2 id="a4bc" class="lq kc hh bd kd lr ls lt kh lu lv lw kl jf lx ly kp jj lz ma kt jn mb mc kx md bi translated">编码快乐！</h2></div></div>    
</body>
</html>