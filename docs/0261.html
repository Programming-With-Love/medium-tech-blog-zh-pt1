<html>
<head>
<title>No More findViewById</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不再有findViewById</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/no-more-findviewbyid-457457644885?source=collection_archive---------0-----------------------#2016-06-19">https://medium.com/androiddevelopers/no-more-findviewbyid-457457644885?source=collection_archive---------0-----------------------#2016-06-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3965" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用Android Studio开发Android应用程序的一个鲜为人知的特性是数据绑定。它带来了许多优秀的特性，我将在以后的文章中介绍，但最基本的是消除了findViewById。</p><p id="2f48" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这不就是个讨厌的家伙吗？</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="2cd6" class="jl jm hh jh b fi jn jo l jp jq">TextView hello = (TextView) findViewById(R.id.hello);</span></pre><p id="dfcf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有一些工具的主要工作是消除这一小部分代码，但现在Android Studio 1.5和更高版本有了一个官方的方法。</p><p id="ffe2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，您必须编辑应用程序的build.gradle文件，并将以下内容添加到android块中:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="e106" class="jl jm hh jh b fi jn jo l jp jq">android {<br/>    …<br/><strong class="jh hi"><em class="jr">    dataBinding.enabled = true<br/></em></strong>}</span></pre><p id="3d09" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一件事是通过使用外部标签<layout>而不是您使用的任何视图组来更改布局文件:</layout></p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="12b8" class="jl jm hh jh b fi jn jo l jp jq">&lt;<strong class="jh hi">layout xmlns:android="http://schemas.android.com/apk/res/android"<br/>        xmlns:tools="http://schemas.android.com/tools"</strong>&gt;<br/>    &lt;<strong class="jh hi">RelativeLayout<br/>            android:layout_width="match_parent"<br/>            android:layout_height="match_parent"<br/>            android:paddingLeft="@dimen/activity_horizontal_margin"<br/>            android:paddingRight="@dimen/activity_horizontal_margin"<br/>            android:paddingTop="@dimen/activity_vertical_margin"<br/>            android:paddingBottom="@dimen/activity_vertical_margin"<br/>            tools:context=".MainActivity"</strong>&gt;<br/><br/>        &lt;<strong class="jh hi">TextView<br/>                android:id="@+id/hello"<br/>                android:layout_width="wrap_content"<br/>                android:layout_height="wrap_content"</strong>/&gt;<br/><br/>    &lt;/<strong class="jh hi">RelativeLayout</strong>&gt;<br/>&lt;/<strong class="jh hi">layout</strong>&gt;</span></pre><p id="96ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">布局</strong>标签告诉Android Studio，这个布局应该在编译时进行额外的处理，以找到所有有趣的视图，并为下一步做好记录。所有没有外部<strong class="ig hi">布局</strong>标签的布局都不会得到额外的处理步骤，所以你可以把这些添加到你喜欢的新项目中，而不用改变应用程序的其他部分。</p><p id="8828" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来你要做的就是告诉它在运行时以不同的方式加载布局文件。因为这可以追溯到Eclaire版本，所以加载这些预处理布局文件不依赖于新的框架更改。因此，你必须对你的装载程序做一点小小的改变。</p><p id="cfc3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从活动中，而不是:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="5f20" class="jl jm hh jh b fi jn jo l jp jq">setContentView(R.layout.hello_world);<br/>TextView hello = (TextView) findViewById(R.id.hello);<br/>hello.setText("Hello World"); // for example, but you'd use<br/>                              // resources, right?</span></pre><p id="4bb6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你这样加载它:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="5115" class="jl jm hh jh b fi jn jo l jp jq">HelloWorldBinding binding = <br/>    DataBindingUtil.<em class="jr">setContentView</em>(<strong class="jh hi">this</strong>, R.layout.<strong class="jh hi"><em class="jr">hello_world</em></strong>);<br/>binding.hello.setText("Hello World"); // you should use resources!</span></pre><p id="b87f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，您可以看到为<strong class="ig hi"> hello_world.xml </strong>布局文件生成了一个类<strong class="ig hi"> HelloWorldBinding </strong>，ID为“@+id/hello”的视图被分配给一个您可以使用的最终字段<strong class="ig hi"> hello </strong>。没有casting，就没有findViewById。</p><p id="0233" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">事实证明，这种访问视图的机制不仅比findViewById容易得多，而且还可以更快！绑定过程对布局中的所有视图进行一次遍历，以将视图分配给字段。运行findViewById时，每次都会遍历视图层次结构以找到它。</p><p id="fc18" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您将看到的一件事是，它改变了您的变量名(就像hello_world.xml成为HelloWorldBinding类一样)，所以如果您给它一个ID“@+ID/hello _ text”，那么字段名将是<strong class="ig hi"> helloText </strong>。</p><p id="e451" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当您为RecyclerView、ViewPager或其他不设置活动内容的内容展开布局时，您会希望在生成的类上使用生成的类型安全方法。有几个版本与LayoutInflater相匹配，因此请使用最适合您的版本。例如:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="ce53" class="jl jm hh jh b fi jn jo l jp jq">HelloWorldBinding binding = HelloWorldBinding.inflate(<br/>    getLayoutInflater(), container, attachToContainer);</span></pre><p id="f0fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您没有将展开的视图附加到包含视图组，您将必须访问展开的视图层次结构。您可以通过绑定的getRoot()方法实现这一点:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="ee27" class="jl jm hh jh b fi jn jo l jp jq">linearLayout.addView(binding.getRoot());</span></pre><p id="f2a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，你可能想知道，如果我有一个布局，它有不同的配置和不同的视图呢？布局预处理和运行时膨胀阶段通过将所有视图id添加到生成的类中来处理这个问题，如果它们不在膨胀的布局中，就将它们设置为null。</p><p id="c0dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很神奇，是吧？最棒的是，在运行时没有使用反射或任何其他高成本的技术。很容易将这一点加入到你当前的应用程序中，让你的生活变得简单一点，你的布局可以加载得更快一点。</p></div></div>    
</body>
</html>