<html>
<head>
<title>Airbnb’s Page Performance Score on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Airbnb在Android上的页面性能得分</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/airbnbs-page-performance-score-on-android-f9fd5e733e?source=collection_archive---------4-----------------------#2021-12-17">https://medium.com/airbnb-engineering/airbnbs-page-performance-score-on-android-f9fd5e733e?source=collection_archive---------4-----------------------#2021-12-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="461d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">我们系列的第四部分关于</em> <a class="ae jd" rel="noopener" href="/airbnb-engineering/creating-airbnbs-page-performance-score-5f664be0936"> <em class="jc"> Airbnb的页面性能评分</em> </a>。</p><p id="6b55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jd" href="https://www.linkedin.com/in/lupinglin/" rel="noopener ugc nofollow" target="_blank">林</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/b1663e180268c4055e45227ef4050ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jv0-M5bsGxi2bcXb"/></div></div></figure><p id="aa3f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Airbnb的自制<a class="ae jd" rel="noopener" href="/airbnb-engineering/creating-airbnbs-page-performance-score-5f664be0936">页面性能评分</a> (PPS)旨在通过收集大量以用户为中心的性能指标并将其制定为一个单一的0-100分，来捕捉丰富、复杂的性能现实。在本帖中，我们将深入探讨如何在Android上定义和实现这些指标。请务必先阅读<a class="ae jd" rel="noopener" href="/airbnb-engineering/creating-airbnbs-page-performance-score-5f664be0936">概述博客文章</a>，以熟悉我们的PPS指标和公式。</p><h1 id="2f91" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用仪器</h1><h2 id="55ff" class="ko jr hh bd js kp kq kr jw ks kt ku ka ip kv kw ke it kx ky ki ix kz la km lb bi translated">通用页面跟踪系统</h2><p id="d50c" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">Airbnb上的整个客户旅程分为不同的页面，每个页面都有自己衡量的PPS。为了支持这种基于页面的性能跟踪系统，我们构建了一个标准化的基础设施，使工程师能够配置代表其功能的页面。</p><p id="2468" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Android上，一个页面与一个<em class="jc">片段</em>相关联。每个片段必须提供一个指定页面名称的<em class="jc"> LoggingConfig </em>对象，以后需要引用页面名称时可以检索到该对象。我们在片段的整个生命周期中收集性能数据，并且只在片段暂停时发出日志事件。</p><p id="f5fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通用的<em class="jc"> PageName </em> enum用于唯一标识每个页面，并在所有平台上引用，以一致地表示我们用户旅程中的每个页面。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lh li l"/></div></figure><h2 id="298d" class="ko jr hh bd js kp kq kr jw ks kt ku ka ip kv kw ke it kx ky ki ix kz la km lb bi translated">捕捉用户感知的等待时间</h2><p id="54e4" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">我们新的页面性能评分(PPS)的一个关键区别在于它衡量用户可以看到的等待时间。而我们早期的测量工作(在我们的<a class="ae jd" rel="noopener" href="/airbnb-engineering/creating-airbnbs-page-performance-score-5f664be0936">概述博客文章</a>中提到过)，基于众所周知的<a class="ae jd" href="https://web.dev/interactive/" rel="noopener ugc nofollow" target="_blank">交互时间</a> (TTI)度量，测量代码执行时间和异步调用长度。例如，PPS测量用户在屏幕上看到加载指示器的时间，而TTI测量网络请求返回结果需要多长时间，以及建立视图模型需要多长时间。我们相信PPS更能反映我们用户的体验。</p><p id="8cef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了捕捉视觉感知的等待时间，我们需要所有具有加载状态的视图来实现一个API，报告它们的加载状态变化。我们创建了一个名为<em class="jc"> LoadableView </em>的简单接口。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="f873" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们提供了基本的<em class="jc">视图组</em>，基本的<em class="jc">文本视图</em>，基本的<em class="jc">图像视图</em>，所有这些都实现了<em class="jc"> LoadableView </em>接口。我们的开发人员只需要从这些原语中继承，就可以自动检测他们的视图。</p><p id="a4b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个挑战是我们需要跟踪一个视图的可见性，因为如果一个视图在屏幕上至少有10%是不可见的，我们不想在我们的测量中包括它的加载时间。每个视图的可见性百分比的计算是频繁的和递归的。此外，我们的大多数视图都在一个<em class="jc"> RecyclerView </em>中，我们必须确保它们的可见性在每个滚动事件中正确更新，同时保持<em class="jc"> RecyclerView </em>的性能。我们设计了算法来降低这些计算的频率和复杂性，包括在<em class="jc"> RecyclerView </em>中缓存可见性状态。</p><h1 id="602b" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">度量实施</h1><h2 id="e640" class="ko jr hh bd js kp kq kr jw ks kt ku ka ip kv kw ke it kx ky ki ix kz la km lb bi translated">首次布局时间(TTFL)</h2><p id="bfe8" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">TTFL测量用户在看到屏幕上的任何内容之前需要等待多长时间。TTFL从片段初始化开始，在片段布局后的第一个<em class="jc"> onGlobalLayout </em>事件结束，此时系统已经完成膨胀、测量和布局片段的视图层次。</p><p id="aa1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">缓慢的TTFL通常表明片段的视图层次过于复杂，或者UI线程在片段初始化期间忙于不必要的任务。</p><h2 id="f0f6" class="ko jr hh bd js kp kq kr jw ks kt ku ka ip kv kw ke it kx ky ki ix kz la km lb bi translated">初始装载时间(TTIL)</h2><p id="2754" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">TTIL测量用户在屏幕上显示有意义的内容之前看到加载指示器的时间(不包括单独测量的媒体加载)。TTIL像TTFL一样从片段初始化开始，当屏幕上不再有视图处于加载状态时结束。如果一个屏幕(片段)是静态的或缓存的，我们不会显示加载指示器。在这种情况下，TTIL将和TTFL一样。</p><p id="f148" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">缓慢的TTIL通常揭示了改善网络延迟或客户端渲染时间的机会。对于网络延迟，我们寻找缓慢的后端服务、大的有效负载、未被利用的缓存或不太优化的数据解析器。对于渲染时间，我们尽量遵循使用RecyclerView的最佳实践，避免在构建视图模型时进行繁重或递归计算，并减少过度绘制等。</p><p id="5e59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如上所述，具有加载状态的视图可以从具有内置<em class="jc"> LoadableView </em>实现的基本原语中继承。API自动向我们的日志框架报告视图的加载状态变化。我们使用一个简单的计数器，它在视图进入加载状态时递增，在数据被加载时递减。当计数器为0时，我们知道屏幕上不再有加载视图。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="388e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这张GIF展示了TTFL(当显示带有Airbnb徽标的灰色背景时标记)和TTIL(当加载点被有意义的内容替换时标记)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lj"><img src="../Images/adec771ede9a2381301660bf35933eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*53ZcfBamEiTotrgi"/></div></figure><h2 id="3d65" class="ko jr hh bd js kp kq kr jw ks kt ku ka ip kv kw ke it kx ky ki ix kz la km lb bi translated">主线程挂起(MTH)</h2><p id="9540" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">当ui帧花费太长时间渲染时，用户体验到屏幕冻结、滞后和不连贯。每个android设备都有一个基于设备容量的目标帧刷新率。然而，当主线程太忙时，设备的渲染速度会慢于它所能达到的帧速率。我们将MTH定义为任何帧花费两倍于系统帧刷新率的时间进行渲染。</p><p id="e705" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">频繁的月数表明主线程可能过载。繁重的操作或计算应该从UI线程中移走，或者延迟到内容被呈现。</p><p id="fd35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MTH是使用Android系统报告的<a class="ae jd" href="https://developer.android.com/reference/android/view/FrameMetrics" rel="noopener ugc nofollow" target="_blank">帧度量</a>计算的。我们从系统中获取帧刷新率，并使用它来计算线程挂起的阈值。然后，我们监听系统回调以接收<a class="ae jd" href="https://developer.android.com/reference/android/view/FrameMetrics" rel="noopener ugc nofollow" target="_blank">帧度量</a>，如果帧持续时间超过我们的阈值，我们将δ<em class="jc">(帧持续时间-挂起阈值)</em>记录为挂起。</p><h2 id="51b7" class="ko jr hh bd js kp kq kr jw ks kt ku ka ip kv kw ke it kx ky ki ix kz la km lb bi translated">附加装载时间(ALT)</h2><p id="8b56" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">ALT测量初始加载后发生的任何等待时间，例如等待列表分页或在按下保存按钮后等待内容更新。当视图在 TTIL被标记后进入加载状态<em class="jc">时，ALT开始，当不再显示加载视图时，ALT结束。ALT可以开始和结束多次，每次都被记录为一个单独的ALT。</em></p><p id="0f45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">提高ALT的机会通常在于预测和预取附加内容。还可以通过平衡在初始加载和附加加载中加载多少内容来提高总体PPS。</p><p id="40ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">这张GIF演示了ALT(当底部的加载指示器被从网络加载的分页内容替换时标记)。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lj"><img src="../Images/252164bed388642d07a19dd21b119d2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*fptmsQJ6LfgBRQdS"/></div></figure><h2 id="c63d" class="ko jr hh bd js kp kq kr jw ks kt ku ka ip kv kw ke it kx ky ki ix kz la km lb bi translated">丰富内容加载时间(RCLT)</h2><p id="df6c" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">RCLT测量用户在图像、视频或一些富媒体内容完全显示之前看到占位符或加载指示器的时间。<em class="jc"> ImageView </em>和其他富媒体容器实现相同的<em class="jc"> LoadableView </em> API向PPS logger报告加载状态变化。</p><p id="0ae5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了提高RCLT，我们希望缩小图像尺寸、改进图像缓存、优化图像格式和服务、战略性地安排加载尚未在屏幕上显示的丰富内容，以及选择高性能流库等。</p><p id="b042" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">这张GIF演示了RCLT(当占位符被替换为从网络加载的实际图像时进行标记)。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lj"><img src="../Images/b36156ea71040a70f23402ac24ebb055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*BtqfXhapm7jDuKL9"/></div></figure><h1 id="540d" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="22b0" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">我们成功地在Android上构建了一个工具框架，以捕捉更加丰富和以用户为中心的性能指标，其指导原则与Airbnb跨web和本地平台的页面性能评分 中的设计原则相同。在此框架和收集的数据之上，我们构建了仪表板来监控整个应用的性能，设置了针对页面所有者的自动警报，简化了团队和组织级别的性能目标设置，并系统地跟踪和减轻了性能衰退。</p><p id="635b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在2022年，我们计划提高我们工具的粒度和准确性，例如测量点击响应度，更好地区分滚动期间的性能，以及为图元提供内置的性能优化。我们还将投入资源构建工具来提高可调试性，并通过综合测试实现早期回归检测和预防。</p><p id="7552" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">PPS为我们的工程师和数据科学家提供了更好的见解和更多的方法来改进我们的产品。这也加强了我们<a class="ae jd" rel="noopener" href="/airbnb-engineering/commitment-to-craft-e36d5a8efe2a">对工艺</a>文化的承诺。我们希望您也能在您的组织中应用这些知识。</p><h2 id="96cc" class="ko jr hh bd js kp kq kr jw ks kt ku ka ip kv kw ke it kx ky ki ix kz la km lb bi translated">增值</h2><p id="d851" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">感谢所有帮助在Android上构建PPS的人:<a class="ae jd" href="https://www.linkedin.com/in/eli-hart-54a4b975/" rel="noopener ugc nofollow" target="_blank">伊莱·哈特</a>、<a class="ae jd" href="https://www.linkedin.com/in/charlesx2013/" rel="noopener ugc nofollow" target="_blank">查尔斯·薛</a>、<a class="ae jd" href="https://www.linkedin.com/in/nickbryanmiller/" rel="noopener ugc nofollow" target="_blank">尼克·米勒</a>、<a class="ae jd" href="https://www.linkedin.com/in/scheuermann/" rel="noopener ugc nofollow" target="_blank">安德鲁·谢尔曼</a>、<a class="ae jd" href="https://www.linkedin.com/in/hdezninirola/" rel="noopener ugc nofollow" target="_blank">安东尼奥·尼诺拉</a>、<a class="ae jd" href="https://www.linkedin.com/search/results/all/?keywords=joshua%20nelson%20%E2%9C%A8&amp;origin=RICH_QUERY_SUGGESTION&amp;position=0&amp;searchId=959d4aca-c80e-448a-b415-4a732ba7a84d&amp;sid=Rr6" rel="noopener ugc nofollow" target="_blank">乔希·尼尔森</a>、<a class="ae jd" href="https://www.linkedin.com/in/adityapunjani/" rel="noopener ugc nofollow" target="_blank">阿迪蒂亚·普贾尼</a>、<a class="ae jd" href="https://www.linkedin.com/in/joshpolsky/" rel="noopener ugc nofollow" target="_blank">乔希·波尔斯基</a>、<a class="ae jd" href="https://www.linkedin.com/in/jnvollmer/" rel="noopener ugc nofollow" target="_blank">让-尼古拉斯·沃尔默</a>、<a class="ae jd" href="https://www.linkedin.com/in/wensheng-mao-76ab7142/" rel="noopener ugc nofollow" target="_blank"/></p><p id="8971" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有兴趣在Airbnb工作吗？看看这些角色:<br/> <a class="ae jd" href="https://grnh.se/6c9839421us" rel="noopener ugc nofollow" target="_blank">员工安卓工程师</a> <br/> <a class="ae jd" href="https://grnh.se/1e5c9bf51us" rel="noopener ugc nofollow" target="_blank">高级安卓工程师</a> <br/> <a class="ae jd" href="https://grnh.se/aa366a2e1us" rel="noopener ugc nofollow" target="_blank">高级安卓工程师</a> <br/> <a class="ae jd" href="https://grnh.se/20c296251us" rel="noopener ugc nofollow" target="_blank">安卓工程师，特殊项目</a></p></div></div>    
</body>
</html>