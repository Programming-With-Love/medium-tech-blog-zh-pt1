<html>
<head>
<title>Design It The Templated Way!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以模板化的方式设计它！</h1>
<blockquote>原文：<a href="https://medium.com/globant/design-it-the-templated-way-6d89cba7beef?source=collection_archive---------6-----------------------#2022-08-25">https://medium.com/globant/design-it-the-templated-way-6d89cba7beef?source=collection_archive---------6-----------------------#2022-08-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/a8fb73d3fd88d345c137d24566257673.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*t1mbOhWw1F5lEyzZ4t2yow.jpeg"/></div></figure><p id="2c95" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">嘿各位程序员和爱好者们！</p><p id="5b57" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在编程过程中，您可能听说过封装对象创建、方法调用和其他复杂的接口。你可能不知道的是封装算法。让我们试着看一看模板方法设计模式如何帮助我们实现算法封装。我们将看看这个模式是关于什么的，为什么需要它，以及我们可以在哪里使用它。我们走吧！</p><p id="991a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">什么是模板方法设计模式？</strong></p><p id="a551" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">模板方法设计模式是一种行为设计模式，它在称为模板方法的抽象方法的帮助下提供了算法的抽象定义。目的是通过向子类提供某些步骤的责任来定义算法的框架，即子类可以定义或覆盖某些步骤而不影响框架。</p><figure class="jk jl jm jn fd ii er es paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="er es jj"><img src="../Images/0163787047ddc8a3f62c7a9b0a18e0eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQDARuRuILavosITgGBXsQ.jpeg"/></div></div></figure><p id="11ae" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">我们为什么需要它以及它的用法- </strong></p><p id="3890" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这种模式有助于实现代码的可重用性和消除代码冗余。有时我们需要设计可以被我们的系统重用的公共库和框架。在这种情况下，模板方法是我们分离出常见行为的方式。使用这种设计模式开发的应用程序允许低层组件适应高层组件，并允许它们对自己在系统中的行为进行模块化控制。</p><p id="efc6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">模板可以创建一次，子类可以根据需要覆盖抽象方法的行为，而不会扰乱算法的结构。在这种模式中，每个子调用一个抽象操作或一个原始操作。子类通过定义抽象操作为算法提供特定于需求的细节。</p><p id="1808" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">有哪些用例？</strong></p><ul class=""><li id="c014" class="js jt hh in b io ip is it iw ju ja jv je jw ji jx jy jz ka bi translated">在这种情况下，我们希望创建一个框架，框架类可以定义一些行为，并对用户应用程序承担一些责任。</li><li id="4714" class="js jt hh in b io kb is kc iw kd ja ke je kf ji jx jy jz ka bi translated">我们希望有一个模板设置，以便新用户遵循相同的一致性的情况。</li><li id="67c4" class="js jt hh in b io kb is kc iw kd ja ke je kf ji jx jy jz ka bi translated">同时在不同的屏幕上创建可重复使用的界面和用户界面。</li></ul><p id="824f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">它有助于解决哪种反模式？</strong></p><p id="a441" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这个模式有助于解决“<strong class="in hi">调用超</strong> <strong class="in hi">反</strong> - <strong class="in hi">模式</strong>”。这是一种反模式，其中子类<strong class="in hi">必须</strong>使用super关键字调用其父类方法，以使功能完整。使用Super关键字调用父类方法在OOP中并不是错误的做法。但是，如果它是完成业务逻辑的必要条件，那么它就被称为“代码味道”或“调用超级反模式”，因为它不会使程序员的期望变得强烈。</p><p id="0e3f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">模板方法设计模式通过将这种责任转移给子类来帮助修复这种反模式。父类中模板方法内部引用的抽象方法迫使子类实现业务逻辑，从而为子类提供更多的控制。</p><p id="e187" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">用例子编码。</strong></p><p id="a121" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们考虑一个典型的移动应用程序屏幕的例子。这包括数据加载、控件创建、设置帧和后期渲染回调。可以创建一个通用模板作为基类，它可以在每个屏幕上运行并执行不同的任务。这些方法的职责和定义可能因屏幕而异。</p><p id="6ae0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，我们可能在某些类中需要不同的数据加载逻辑，不同的呈现逻辑，等等。这些责任可以在单独的屏幕上承担。但是可以创建一个通用的模板方法，它一步一步地调用这些方法，并将其行为决定为运行时多态性。</p></div><div class="ab cl kg kh go ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="ha hb hc hd he"><ol class=""><li id="7497" class="js jt hh in b io ip is it iw ju ja jv je jw ji kn jy jz ka bi translated"><strong class="in hi">基础页面有模板方法、抽象方法和原语方法。</strong></li></ol><pre class="jk jl jm jn fd ko kp kq kr aw ks bi"><span id="4797" class="kt ku hh kp b fi kv kw l kx ky">public abstract class BasePage<br/>  {<br/>      public void Init()<br/>      { <br/>          RunAnalytics();<br/>          LoadData();<br/>          InitControls();<br/>          RenderControls();<br/>          SetFrames();<br/>      }<br/> <br/>      private void RunAnalytics()<br/>      {<br/>          //Call firebase analytics<br/>          //use common logging<br/>      }<br/> <br/> <br/>     //methods to be overriden<br/>      protected abstract void LoadData();<br/>      protected abstract void InitControls();<br/>      protected abstract void RenderControls();<br/>      protected abstract void SetFrames();<br/>  }</span></pre><p id="6c94" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi"> 2。子页面调用模板方法并覆盖抽象方法来决定运行时的控制流。</strong></p><pre class="jk jl jm jn fd ko kp kq kr aw ks bi"><span id="a1f8" class="kt ku hh kp b fi kv kw l kx ky">public class UserListPage : BasePage<br/>  {<br/>       public override void OnAppearing()<br/>       {<br/>           base.Init(); <br/>       }</span><span id="1c4b" class="kt ku hh kp b fi kz kw l kx ky">public override void LoadData()<br/>       {<br/>           Console.WriteLine("Loading data needed for this page");<br/>       }</span><span id="91a6" class="kt ku hh kp b fi kz kw l kx ky">public override void InitControls()<br/>       {<br/>           //Control Initialization logic<br/>       }</span><span id="93ef" class="kt ku hh kp b fi kz kw l kx ky">public override void RenderControls()<br/>       {<br/>           //Control rendering logic<br/>       }</span><span id="ca6f" class="kt ku hh kp b fi kz kw l kx ky">public override void SetFrames()<br/>       {<br/>           //set frames logic<br/>       }<br/>  }</span><span id="c8cb" class="kt ku hh kp b fi kz kw l kx ky">public class OrdersPage : BasePage<br/>   {<br/>           public override void OnAppearing()<br/>           {<br/>               base.Init(); <br/>           }</span><span id="9bcc" class="kt ku hh kp b fi kz kw l kx ky">public override void LoadData()<br/>           {<br/>               //API Calls to fetch user order list<br/>           }</span><span id="6098" class="kt ku hh kp b fi kz kw l kx ky">public override void InitControls()<br/>           {<br/>               //Control Initialisation logic<br/>           }</span><span id="7800" class="kt ku hh kp b fi kz kw l kx ky">public override void RenderControls()<br/>           {<br/>               //Control rendering logic<br/>           }</span><span id="acfd" class="kt ku hh kp b fi kz kw l kx ky">public override void SetFrames()<br/>           {<br/>               //set frames logic<br/>           }<br/>   }</span></pre><p id="6012" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">外卖- </strong></p><p id="04ea" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">综上所述，模板化设计模式是组织代码的好方法。如果您的系统需要在代码中大量使用抽象和继承，最好暂停一下，权衡一下，看看这种设计模式是否有助于更好地构建您的代码。然后开始编码。如果你有更多你认为这种模式可以帮助的用例，请在评论中分享你的想法。编码快乐！</p></div></div>    
</body>
</html>