<html>
<head>
<title>Pushing the limits of AndroidX Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">挑战安卓测试的极限</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/pushing-the-limits-of-androidx-test-3776ff249c71?source=collection_archive---------1-----------------------#2019-03-29">https://medium.com/google-developer-experts/pushing-the-limits-of-androidx-test-3776ff249c71?source=collection_archive---------1-----------------------#2019-03-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/2c3d9261b53312461789efaa0b930dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTZJ-9z5YtNFmAfe9yw1-w.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Picture by <a class="ae hu" href="https://stocksnap.io/author/bernardspragg" rel="noopener ugc nofollow" target="_blank">Bernard Spragg</a></figcaption></figure><div class=""/><p id="3a86" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">AndroidX Test是测试与Android框架交互的代码的新方法，它有一个非常好的特性，可以通过Robolectric在仿真器(或物理设备)或JVM上运行相同的测试类<strong class="iw hy">。这两种测试环境的主要区别在于测试实际包含在哪里。当我们希望测试在设备上运行时，类应该放在<code class="du js jt ju jv b">androidTest</code>文件夹中，而使用Robolectric意味着我们的文件放在<code class="du js jt ju jv b">test</code>文件夹中。</strong></p><p id="1d79" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种区别在某种程度上限制了在单独的环境中一次一次地运行测试的自由，因为每个特定的测试必须在<code class="du js jt ju jv b">androidTest</code>或<code class="du js jt ju jv b">test</code>文件夹中。</p><h2 id="f3a9" class="jw jx hx bd jy jz ka kb kc kd ke kf kg jf kh ki kj jj kk kl km jn kn ko kp kq bi translated">共享代码</h2><p id="ae0e" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">我们可能已经熟悉了通过单个文件夹 : <code class="du js jt ju jv b">sharedTest</code>在单元和集成测试之间共享一些资源的想法。我们可以利用这个想法，将我们希望能够在不同配置上运行的测试移动到这个文件夹中，这样<code class="du js jt ju jv b">test</code>和<code class="du js jt ju jv b">androidTest</code>源代码都可以看到它们。</p><p id="b1d3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第一步是手动创建共享文件夹，与其他两个文件夹位于同一级别，具有相同的包结构:</p><figure class="kx ky kz la fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kw"><img src="../Images/1cda6e1781a541a8d40b3045b1d02c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m1Rlov8uy8179AuCC7OhFg.png"/></div></div></figure><p id="0dfa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们可以在模块的<code class="du js jt ju jv b">build.gradle</code>文件中添加几行；这是在两种测试类型之间共享文件夹的逻辑:</p><figure class="kx ky kz la fd hj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h2 id="1280" class="jw jx hx bd jy jz ka kb kc kd ke kf kg jf kh ki kj jj kk kl km jn kn ko kp kq bi translated">一个非常简单的测试</h2><p id="3a7d" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">作为这个解决方案如何工作的例子，我们将使用这个非常简单的Espresso测试:</p><figure class="kx ky kz la fd hj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><blockquote class="ld le lf"><p id="525a" class="iu iv lg iw b ix iy iz ja jb jc jd je lh jg jh ji li jk jl jm lj jo jp jq jr ha bi translated">注意<code class="du js jt ju jv b">@RunWith</code>注释。当将这个测试用例作为集成测试运行时，这不是强制性的，但是当使用Robolectric来指导框架如何运行套件时，我们需要它。</p></blockquote><p id="bf02" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的下一步是将相同的依赖项声明为<code class="du js jt ju jv b">testImplementation</code>和<code class="du js jt ju jv b">androidTestImplementation</code>，这样我们可以确保我们的测试总是拥有它需要的所有对象，无论它是如何运行的。此程序的唯一例外是<strong class="iw hy">机器人电气依赖性</strong>，它仅在<code class="du js jt ju jv b">testImplementation</code>时需要，以便提供JVM环境:</p><figure class="kx ky kz la fd hj"><div class="bz dy l di"><div class="lb lc l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Latest versions of these artefacts can be found on <a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/test" rel="noopener ugc nofollow" target="_blank">Android Developers website</a>.</figcaption></figure><p id="c8c6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们可以指示我们的单元测试以正确的方式使用Android资源，包括框架值和特性，并返回默认值:</p><figure class="kx ky kz la fd hj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><blockquote class="ld le lf"><p id="003a" class="iu iv lg iw b ix iy iz ja jb jc jd je lh jg jh ji li jk jl jm lj jo jp jq jr ha bi translated">这一步可能是不必要的，我们应该总是检查什么是缺省值。</p></blockquote><h2 id="8394" class="jw jx hx bd jy jz ka kb kc kd ke kf kg jf kh ki kj jj kk kl km jn kn ko kp kq bi translated">运行配置</h2><p id="8a86" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">由于我们希望在两种不同的模式下运行我们的测试，我们需要一个配置来运行它们作为<strong class="iw hy">单元测试</strong>，另一个配置在设备上运行它们<strong class="iw hy">:这可以在Android Studio中通过几次点击来完成，我们的配置如下所示:</strong></p><figure class="kx ky kz la fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lk"><img src="../Images/3473f0dfebf2366c662347c346fe3da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHyEJTS3Jjt3X5nVnMoUNQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Configuration for Instrumentation tests</figcaption></figure><figure class="kx ky kz la fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lk"><img src="../Images/b92a84b47fa426ef96e37db1e9674151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIJWBtW50cw_ETdVfQp-iA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Configuration for Unit tests</figcaption></figure><blockquote class="ld le lf"><p id="ce76" class="iu iv lg iw b ix iy iz ja jb jc jd je lh jg jh ji li jk jl jm lj jo jp jq jr ha bi translated"><strong class="iw hy">注:</strong>在我所有的尝试中，每次从<code class="du js jt ju jv b">sharedTest</code>文件夹运行测试，使用靠近类名的绿色小play图标，Android Studio都把它解读成一个<code class="du js jt ju jv b">androidTest</code>。此外，一旦我创建了一个JVM配置并运行它，每次我从play按钮执行测试时，它都会在JVM上运行。我不确定这是意料之中的行为还是巧合，但这是一件有趣的事情。</p></blockquote><p id="eba4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">值得记住的一点是，这两种配置可能需要不同的名称，因为以完全相同的方式拼写它们可能会导致Android Studio混淆:在我们的例子中，我们只是添加了“JVM”来标识将在本地运行的配置和在设备上运行的配置。</p><h2 id="bd9e" class="jw jx hx bd jy jz ka kb kc kd ke kf kg jf kh ki kj jj kk kl km jn kn ko kp kq bi translated">挑战极限</h2><p id="faf8" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">我们刚刚探索的过程允许我们在两种配置中运行测试，但是如果我们使用CI，这可能成为我们测试例程中的一个缺陷:因为我们的类对于单元和工具测试都是可见的，所以包含在共享文件夹中的测试用例将运行两次。当我们执行<code class="du js jt ju jv b">test</code>任务时，第一个运行在JVM上，当我们运行<code class="du js jt ju jv b">connectedTest</code>任务时，第二个运行在真实版本的Android上。</p><p id="72ac" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们的测试只在两个环境中的一个环境中失败，这很快就会成为一个问题，因此我们需要找到一个解决方案，允许我们在需要的地方运行测试，但只限制我们的CI在特定的环境中运行测试。</p><p id="dde9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了做到这一点，我们可以使用JUnit 4中的一个API，它可以让我们将测试分成不同的类别，并轻松地包含或排除它们。第一步是创建一个空接口，这将是我们要处理的类别的名称:</p><figure class="kx ky kz la fd hj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="776d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，我们修改简单的Espresso测试，将上述类别分配给它:</p><figure class="kx ky kz la fd hj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="086c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后一步是通过在我们的<code class="du js jt ju jv b">build.gradle</code>文件中添加以下几行，从单元测试执行中排除类别，通过它的全名来识别:</p><figure class="kx ky kz la fd hj"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h2 id="8164" class="jw jx hx bd jy jz ka kb kc kd ke kf kg jf kh ki kj jj kk kl km jn kn ko kp kq bi translated">包扎</h2><p id="d065" class="pw-post-body-paragraph iu iv hx iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">这种方法确实很新，仍然需要一些改进。在有些情况下，这种方法非常简单，而且很有帮助，不仅仅是Espresso测试，还有仪器测试以及所有与Android框架相关的测试。</p><p id="f4b0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">无论如何，如果你想检验这个解决方案并探索它是如何工作的，或者可能给出一些关于如何使事情变得更好的建议，请随意访问GitHub 上的<a class="ae hu" href="https://github.com/tiwiz/AndroidXSharedTest/" rel="noopener ugc nofollow" target="_blank">资源库。</a></p></div></div>    
</body>
</html>