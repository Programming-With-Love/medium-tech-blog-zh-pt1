<html>
<head>
<title>How to generate Kotlin DSL Client by GraphQL schema</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用GraphQL模式生成Kotlin DSL客户端</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/how-to-generate-kotlin-dsl-client-by-graphql-schema-707fd0c55284?source=collection_archive---------2-----------------------#2021-10-20">https://blog.kotlin-academy.com/how-to-generate-kotlin-dsl-client-by-graphql-schema-707fd0c55284?source=collection_archive---------2-----------------------#2021-10-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="eff6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">介绍Kobby插件——kot Lin graph QL客户端的代码生成器</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a645500dacff3af6ccfddfd1560b25a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R8XLcm1o7zz98btEWN6SgA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">«Kotlin» and «GraphQL» mean the same thing to you!</figcaption></figure><p id="35b6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">一方面，GraphQL模式惟一地定义了数据模型和实现它的服务的可用操作。另一方面，Kotlin为创建您自己的特定领域语言(DSL)提供了惊人的机会。这样，您就可以根据发布的GraphQL模式编写一种特定于领域的语言来与您的GraphQL服务进行交互。但是手工编写这样的代码是徒劳的。这就是<a class="ae lo" href="https://github.com/ermadmi78/kobby" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> Kobby插件</strong> </a>的用武之地，它可以解析您的服务的GraphQL模式并生成用于交互的客户端DSL。我们来试试吧！</p><p id="12c2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">本文中示例的源代码可以在<a class="ae lo" href="https://github.com/ermadmi78/kobby-gradle-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> Kobby Gradle教程</strong> </a>和<a class="ae lo" href="https://github.com/ermadmi78/kobby-maven-tutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="ku io"> Kobby Maven教程</strong> </a>中找到。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="ea42" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">最后我们会得到什么？</h1><p id="6b3d" class="pw-post-body-paragraph ks kt in ku b kv mo jo kx ky mp jr la lb mq ld le lf mr lh li lj ms ll lm ln ig bi translated"><em class="mt">如果你懒得看整篇文章……</em></p><h2 id="4181" class="mu lx in bd ly mv mw dn mc mx my dp mg lb mz na mi lf nb nc mk lj nd ne mm nf bi translated">询问</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="697d" class="mu lx in bd ly mv mw dn mc mx my dp mg lb mz na mi lf nb nc mk lj nd ne mm nf bi translated">变化</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="aa56" class="mu lx in bd ly mv mw dn mc mx my dp mg lb mz na mi lf nb nc mk lj nd ne mm nf bi translated">签署</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="9270" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">Kobby插件设置</h1><blockquote class="ni nj nk"><p id="0cc8" class="ks kt mt ku b kv kw jo kx ky kz jr la nl lc ld le nm lg lh li nn lk ll lm ln ig bi translated">起初是这个词…</p></blockquote><p id="d007" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但是我们将从我们服务的模式开始。默认情况下，<a class="ae lo" href="https://github.com/ermadmi78/kobby/wiki/Gradle-GraphQL-Schema-Location" rel="noopener ugc nofollow" target="_blank"> Kobby插件在项目资源中扩展名为<code class="fe no np nq nr b">graphqls</code>的文件中寻找GraphQL模式</a>。为了简单起见，我们将模式放在一个名为<code class="fe no np nq nr b">cinema.graphqls</code>的文件中:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="dc1f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这个简单的模式将允许我们尝试所有种类的GraphQL操作——查询、变异和订阅。</p><p id="05fe" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">接下来，我们必须配置插件。对于Gradle项目，它看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5df0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">对于Maven项目，这看起来并不那么优雅:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="db3b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">有<a class="ae lo" href="https://github.com/ermadmi78/kobby/wiki/Available-Gradle-Plugin-Settings" rel="noopener ugc nofollow" target="_blank">显式</a>和隐式方式来配置插件。我们通过向<a class="ae lo" href="https://github.com/FasterXML/jackson" rel="noopener ugc nofollow" target="_blank"> Jackson </a>和<a class="ae lo" href="https://ktor.io/" rel="noopener ugc nofollow" target="_blank">kt</a>库添加依赖项来使用隐式方式。Kobby Plugin不仅会扫描资源中的模式文件，还会分析项目依赖关系。如果依赖项中存在Jackson，则该插件会将Jackson注释添加到生成的<a class="ae lo" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank"> DTO </a>类中，以确保JSON序列化。如果项目依赖项中存在Ktor，则该插件将生成默认DSL适配器。我们将在下一节讨论适配器。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="7e53" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">实例化DSL上下文</h1><p id="c601" class="pw-post-body-paragraph ks kt in ku b kv mo jo kx ky mp jr la lb mq ld le lf mr lh li lj ms ll lm ln ig bi translated">我们已经配置了我们的插件。现在，我们必须根据我们的模式生成一个DSL。为Gradle运行<code class="fe no np nq nr b">gradle build</code>，为Maven运行<code class="fe no np nq nr b">mvn compile</code>，插件将找到<code class="fe no np nq nr b">cinema.graphqls</code>文件，并基于该文件生成DSL:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/cdd9e9b549c94d4c38eab50ab7789653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*-WWmBB3zAmUEXmRhVkVXGA.png"/></div></figure><p id="ad21" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">该插件将使用<code class="fe no np nq nr b">cinemaContextOf </code> builder函数创建<code class="fe no np nq nr b">cinema.kt</code>文件，该函数实例化<code class="fe no np nq nr b">CinemaContext</code>接口，即所生成DSL的入口点:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="fd09" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们必须将<code class="fe no np nq nr b">CinemaAdapter</code>接口的实例传递给builder函数来创建上下文。什么是适配器？由Kobby Plugin生成的DSL上下文对传输层和GraphQL通信协议一无所知。上下文实现只是构建查询并将其传递给适配器。而适配器必须完成所有的脏工作—将查询发送到服务器，并接收和反序列化响应。您可以编写自己的适配器实现，或者使用插件生成的默认适配器。</p><p id="760d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们将使用默认的适配器。它使用<a class="ae lo" href="https://ktor.io/" rel="noopener ugc nofollow" target="_blank">kt或</a>在HTTP上执行GraphQL查询和变异，并在WebSocket上建立订阅会话:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="f9df" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">执行查询</h1><p id="1a9c" class="pw-post-body-paragraph ks kt in ku b kv mo jo kx ky mp jr la lb mq ld le lf mr lh li lj ms ll lm ln ig bi translated">我们准备执行第一个查询。让我们试着找一部有ID的演员的电影。在GraphQL中，这个查询如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7949" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在科特林，它看起来是这样的:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4933" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe no np nq nr b">context.query</code>为<a class="ae lo" href="https://kotlinlang.org/docs/coroutines-basics.html" rel="noopener ugc nofollow" target="_blank">挂起功能</a>，不阻塞当前线程。执行查询的结果是什么？在GraphQL中，结果是JSON，如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5571" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了浏览结果，插件生成如下所示的“实体”界面:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5272" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe no np nq nr b">context.query</code>函数返回<code class="fe no np nq nr b">Query</code>实体的一个实例，因此结果的导航如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="3003" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">执行突变</h1><p id="04a9" class="pw-post-body-paragraph ks kt in ku b kv mo jo kx ky mp jr la lb mq ld le lf mr lh li lj ms ll lm ln ig bi translated">让我们创作一部新电影。在GraphQL中，变异看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e321" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们将得到如下所示的JSON结果:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7cd3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在科特林，这种变异看起来像这样:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9024" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe no np nq nr b">context.mutation</code>函数返回<code class="fe no np nq nr b">Mutation</code>实体接口的一个实例，也是<a class="ae lo" href="https://kotlinlang.org/docs/coroutines-basics.html" rel="noopener ugc nofollow" target="_blank">暂停函数</a>。所以，我们的突变不会阻塞当前线程。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="3b90" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">建立订阅</h1><p id="5005" class="pw-post-body-paragraph ks kt in ku b kv mo jo kx ky mp jr la lb mq ld le lf mr lh li lj ms ll lm ln ig bi translated">让我们订阅新电影通知。在GraphQL中，订阅如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="bbff" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">有了这个订阅，我们将收到如下所示的JSON消息:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f548" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">Kotlin中订阅操作的语义不同于查询和变异操作的语义。虽然查询和变异只是发送一个请求和接收一个响应，但是订阅创建了一个长期会话来侦听传入的消息。因此，我们必须创建一个异步侦听器来接收传入的消息:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="180f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">别担心，我们没有在无限循环中阻塞线程，因为<code class="fe no np nq nr b">subscribe</code>函数和<code class="fe no np nq nr b">receive</code>函数是<a class="ae lo" href="https://kotlinlang.org/docs/coroutines-basics.html" rel="noopener ugc nofollow" target="_blank">暂停函数</a>。</p><p id="5149" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">订阅会话的生命周期与<code class="fe no np nq nr b">subscribe</code>函数的执行时间相同。当我们进入<code class="fe no np nq nr b">subscribe</code>函数时，一个会话被创建，当我们退出时，该会话被销毁。</p><p id="47ad" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe no np nq nr b">receive</code>函数为每个传入的消息返回一个<code class="fe no np nq nr b">Subscription</code>实体接口的实例。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="107a" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">我在这篇文章中没有提到什么？</h1><ul class=""><li id="2871" class="nt nu in ku b kv mo ky mp lb nv lf nw lj nx ln ny nz oa ob bi translated">我还没有介绍如何将模式中定义的标量映射到Kotlin数据类型。</li><li id="6bef" class="nt nu in ku b kv oc ky od lb oe lf of lj og ln ny nz oa ob bi translated">我还没有谈到插件如何处理抽象数据类型。</li><li id="7e9c" class="nt nu in ku b kv oc ky od lb oe lf of lj og ln ny nz oa ob bi translated">我还没有介绍如何使用GraphQL指令定制生成的DSL。</li><li id="7979" class="nt nu in ku b kv oc ky od lb oe lf of lj og ln ny nz oa ob bi translated">我还没有谈到插件<a class="ae lo" href="https://github.com/ermadmi78/kobby/wiki/GraphQL-Java-Kickstart-support" rel="noopener ugc nofollow" target="_blank">如何支持服务器端开发</a>。</li></ul><p id="ce34" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">而且最重要的是，我没有谈到如何使用<a class="ae lo" href="https://kotlinlang.org/docs/extensions.html" rel="noopener ugc nofollow" target="_blank"> Kotlin扩展函数</a>将生成的DSL变成类固醇上的丰富域模型。也许我会在以后的文章中讨论这个问题。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi oh"><img src="../Images/f40c3f11f78e94ac4b288a4dfb8b4396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjGp5fHBUq3Gzf8MiBUoiQ.png"/></div></a></figure></div></div>    
</body>
</html>