<html>
<head>
<title>How to Create a Kubernetes Cluster Locally — Simple Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在本地创建Kubernetes集群——简单教程</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/how-to-create-a-kubernetes-cluster-locally-simple-tutorial-63eab6c8c3f5?source=collection_archive---------3-----------------------#2020-07-08">https://medium.com/capital-one-tech/how-to-create-a-kubernetes-cluster-locally-simple-tutorial-63eab6c8c3f5?source=collection_archive---------3-----------------------#2020-07-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="0b78" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">如何在本地创建一个Kubernetes集群并部署与Kubernetes通信的简单前端应用程序</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/66f6bc9ebb7a691ebe6bcc8d7599b99d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GO1z6qPosfNgy1QGV7zLEQ.jpeg"/></div></div></figure><p id="ae58" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">作为第一资本公司的一名软件工程师，我每天都在工作中探索前沿技术。我曾与Docker和Docker Swarm合作，我一直想学习Kubernetes。但是，我一直推迟。最后，我能够一头扎进去，并想，“为什么不用Kubernetes创建一个应用程序，并在我头脑清醒时写下它！”这样，其他人——而不仅仅是我自己——可以从我学到的东西中受益。</p><h1 id="f7a6" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="2cc8" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">今天，我们将创建一个Kubernetes集群，并部署一个简单的React JS应用程序，它通过调用Express JS应用程序来生成一个随机数。我们将通过使用Kubernetes来协调整个过程。我们将首先对我们的前端/后端应用程序进行分类。然后，我们将使用Kubernetes部署pod(React前端应用程序/Express后端应用程序),并通过Kubernetes服务访问它们。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ks"><img src="../Images/95365164e45d8ab172e6ece63645cea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rsMFDAVek8hXG_i5"/></div></div></figure><h1 id="847b" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">什么是Kubernetes集群？</h1><p id="d649" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">像任何集群一样，您向Kubernetes提供一组节点。您告诉kubernetes如何在集群中部署容器。每个容器获得多少内存或处理单元，以及它们如何相互交互。</p><h1 id="26e1" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">Kubernetes聚类图</h1><p id="5103" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">下图描述了我们今天要实现的目标，我们将为我们的前端和后端创建一个Kubernetes集群和服务/部署。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es kt"><img src="../Images/11684d6f7ac4d3c642f8ed5b9d1d95e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nqas3nUDLcWChCOZ6taFXQ.png"/></div></div></figure><h1 id="885f" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">先决条件</h1><ol class=""><li id="8668" class="ku kv hh jq b jr kn jv ko jz kw kd kx kh ky kl kz la lb lc bi translated"><a class="ae ld" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank">桌面Docker</a>(最新版本)</li><li id="5ca4" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl kz la lb lc bi translated"><a class="ae ld" href="https://kubernetes.io/docs/setup/learning-environment/minikube/" rel="noopener ugc nofollow" target="_blank">库伯内特</a>或<a class="ae ld" href="https://www.docker.com/products/kubernetes" rel="noopener ugc nofollow" target="_blank">码头工人库伯内特</a></li><li id="33de" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl kz la lb lc bi translated">节点和NPM(仅当您希望独立运行应用程序时)</li><li id="d95e" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl kz la lb lc bi translated">YAML</li></ol><p id="b696" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi"> <em class="km">注:</em> </strong> <em class="km">本教程要求具备关于Docker、Node、&amp; NPM的基础/工作知识。</em></p><p id="79d5" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">让我们开始吧，不要再多费口舌了。</p><h1 id="caca" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">Kubernetes入门</h1><h2 id="f0c2" class="lj if hh bd ig lk ll lm ik ln lo lp io jz lq lr is kd ls lt iw kh lu lv ja lw bi translated">安装Kubernetes</h2><p id="3d3e" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated"><em class="km">如果你有</em> <strong class="jq hi"> <em class="km"> Docker桌面</em> </strong> <em class="km">，进入</em> <strong class="jq hi"> <em class="km">首选项</em> </strong> <em class="km">，进入</em> <strong class="jq hi"> <em class="km"> Kubernetes标签，</em> </strong> <em class="km">，点击</em> <strong class="jq hi"> <em class="km">启用Kubernetes </em> </strong> <em class="km">。将Kubernetes安装到你的机器上可能需要一段时间，所以在它发挥魔力的时候去做一杯咖啡吧。☕ </em></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lx"><img src="../Images/55632a61159bc17ce1ce8763a841a58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hKknutHbe5NeFfgnVWHrpg.png"/></div></div></figure><p id="b233" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">要验证Kubernetes是否正在运行，请键入以下两个命令:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="6b87" class="lj if hh lz b fi md me l mf mg">kubectl version</span><span id="3eed" class="lj if hh lz b fi mh me l mf mg">Outputs:</span><span id="74a8" class="lj if hh lz b fi mh me l mf mg">Client Version: version.Info{Major:"1", Minor:"15", GitVersion:"v1.15.0", GitCommit:"e8462b5b5dc2584fdcd18e6bcfe9f1e4d970a529", GitTreeState:"clean", BuildDate:"2019-06-19T16:40:16Z", GoVersion:"go1.12.5", Compiler:"gc", Platform:"darwin/amd64"}</span><span id="c9f3" class="lj if hh lz b fi mh me l mf mg">Server Version: version.Info{Major:"1", Minor:"14", GitVersion:"v1.14.8", GitCommit:"211047e9a1922595eaa3a1127ed365e9299a6c23", GitTreeState:"clean", BuildDate:"2019-10-15T12:02:12Z", GoVersion:"go1.12.10", Compiler:"gc", Platform:"linux/amd64"}</span><span id="2323" class="lj if hh lz b fi mh me l mf mg">kubectl cluster-info</span><span id="08cf" class="lj if hh lz b fi mh me l mf mg">Outputs:<br/>Kubernetes master is running at https://kubernetes.docker.internal:6443</span><span id="e945" class="lj if hh lz b fi mh me l mf mg">KubeDNS is running at <a class="ae ld" href="https://kubernetes.docker.internal:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy" rel="noopener ugc nofollow" target="_blank">https://kubernetes.docker.internal:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</a></span></pre><h1 id="0f96" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">将应用程序捆绑为Docker图像</h1><h2 id="6370" class="lj if hh bd ig lk ll lm ik ln lo lp io jz lq lr is kd ls lt iw kh lu lv ja lw bi translated">这方面的完整代码可以在<a class="ae ld" href="https://github.com/chiku11/react-k8" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到</h2><p id="ea31" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">请下载该项目。该项目中有两个子文件夹。</p><ul class=""><li id="3bac" class="ku kv hh jq b jr js jv jw jz mi kd mj kh mk kl ml la lb lc bi translated">客户端-&gt;基于React的应用程序</li><li id="7d92" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl ml la lb lc bi translated">服务器-&gt;基于Express的应用</li></ul><p id="6283" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">请按照以下步骤设置项目并启动Kubernetes集群:</p><h2 id="e07d" class="lj if hh bd ig lk ll lm ik ln lo lp io jz lq lr is kd ls lt iw kh lu lv ja lw bi translated">客户</h2><ul class=""><li id="bc79" class="ku kv hh jq b jr kn jv ko jz kw kd kx kh ky kl ml la lb lc bi translated"><em class="km">光盘客户端</em></li><li id="b381" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl ml la lb lc bi translated"><em class="km"> npm安装</em></li><li id="6e4f" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl ml la lb lc bi translated"><em class="km"> npm运行构建</em></li><li id="ca38" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl ml la lb lc bi translated"><strong class="jq hi"> <em class="km"> docker build -t前端:1.0。</em>T11】</strong></li><li id="3737" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl ml la lb lc bi translated"><strong class="jq hi"><em class="km">ku bectl apply-f frontend . deploy . yml</em></strong></li><li id="e8bb" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl ml la lb lc bi translated"><strong class="jq hi"><em class="km">ku bectl apply-f frontend . service . yml</em></strong></li></ul><h2 id="d88b" class="lj if hh bd ig lk ll lm ik ln lo lp io jz lq lr is kd ls lt iw kh lu lv ja lw bi translated">后端</h2><ul class=""><li id="46c7" class="ku kv hh jq b jr kn jv ko jz kw kd kx kh ky kl ml la lb lc bi translated"><em class="km">光盘服务器</em></li><li id="12f0" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl ml la lb lc bi translated"><em class="km"> npm安装</em></li><li id="ef22" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl ml la lb lc bi translated"><strong class="jq hi"> <em class="km"> docker build -t后端:1.0。</em> </strong></li><li id="8a8e" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl ml la lb lc bi translated"><strong class="jq hi"><em class="km">ku bectl apply-f back end . deploy . yml</em></strong></li><li id="bbb2" class="ku kv hh jq b jr le jv lf jz lg kd lh kh li kl ml la lb lc bi translated"><strong class="jq hi"><em class="km">ku bectl apply-f back end . service . yml</em></strong></li></ul><p id="8bb6" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">进入浏览器，键入<code class="du mm mn mo lz b">localhost</code>并按回车键，你应该看到应用程序加载。</p><h1 id="15bb" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">进一步降低</h1><h2 id="f34a" class="lj if hh bd ig lk ll lm ik ln lo lp io jz lq lr is kd ls lt iw kh lu lv ja lw bi translated">Kubernetes豆荚</h2><p id="f391" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">Pods是可以在Kubernetes中创建和管理的最小可部署计算单元。</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="1301" class="lj if hh lz b fi md me l mf mg">kubectl run nginx-frontend --image=frontend:1.0</span></pre><p id="d442" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">上面创建了一个托管前端容器的pod。您还不能访问它，因为没有为容器公开主机端口。我们稍后会揭开这些。</p><p id="6d44" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">一个pod也可以托管多个容器。让我们通过YAML文件来创建，而不是通过命令行。</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="7502" class="lj if hh lz b fi md me l mf mg"># To create a pod with multiple containers<br/> kubectl apply -f app.pod.yml</span><span id="c8ef" class="lj if hh lz b fi mh me l mf mg"># To see container status<br/> kubectl get pod/mymulticontainerapp<br/> Outputs:<br/> NAME                  READY   STATUS    RESTARTS   AGE<br/> mymulticontainerapp   2/2     Running   0          9m</span><span id="f5a1" class="lj if hh lz b fi mh me l mf mg"># To see more details about the container<br/>kubectl describe pod/mymulticontainerapp</span></pre><p id="3941" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">要从主机访问容器，您必须进行端口转发，即将主机端口连接到容器端口。您可以通过下面的命令来完成:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="729a" class="lj if hh lz b fi md me l mf mg">kubectl port-forward pod/mymulticontainerapp 9999:80 3000:3000</span><span id="ba4f" class="lj if hh lz b fi mh me l mf mg">Outputs:<br/>Forwarding from 127.0.0.1:9999 -&gt; 80<br/>Forwarding from [::1]:9999 -&gt; 80<br/>Forwarding from 127.0.0.1:3000 -&gt; 3000<br/>Forwarding from [::1]:3000 -&gt; 3000</span></pre><p id="0bc7" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">上述命令将主机端口9999暴露给容器端口80，将主机端口3000暴露给容器端口3000，这是我们的前端/后端容器正在侦听的端口。对主机9999的任何请求都将被转发到端口80上的容器。对主机3000的任何请求都将被转发到端口3000上的容器。</p><p id="ccb4" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">去浏览器打开127.0.0.1:9999或者localhost:9999，应该会加载前端app。</p><p id="7d00" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">要删除pod，您可以使用以下命令:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="d557" class="lj if hh lz b fi md me l mf mg">k delete pod/mymulticontainerapp</span></pre><p id="0e43" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">要检查pod，您可以使用以下命令:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="9c4c" class="lj if hh lz b fi md me l mf mg">Front End:<br/>kubectl exec mymulticontainerapp -c myfrontendapp -it /bin/sh<br/>ls /usr/share/nginx/html<br/>exit</span><span id="f884" class="lj if hh lz b fi mh me l mf mg">Back End:<br/>kubectl exec mymulticontainerapp -c mybackendapp -it /bin/sh<br/>ls<br/>exit</span></pre><p id="f95f" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">以上命令打开容器内部的外壳进行交互。</p><p id="51de" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">在我们跳到下一个主题<strong class="jq hi"> — </strong>部署之前，理解YAML文件中的元数据至关重要。元数据是关于容器的数据。您可以向元数据添加标签和键值。您还可以使用标签或键值作为选择器来标识稍后将由部署/服务使用的pod。</p><p id="9fc9" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">让我们把所有的豆荚都标上<code class="du mm mn mo lz b">mymulticontainerapp</code>:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="4a1c" class="lj if hh lz b fi md me l mf mg">kubectl get pods --selector=name=mymulticontainerapp</span></pre><h1 id="8e28" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">部署</h1><p id="0d0e" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">你描述一个展开中的期望状态，展开控制器<a class="ae ld" href="https://kubernetes.io/docs/concepts/architecture/controller/" rel="noopener ugc nofollow" target="_blank">以受控的速率将实际状态改变为期望状态。您可以定义部署来创建新的副本集，或者删除现有的部署并在新部署中采用它们的所有资源。</a></p><p id="f251" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">它看起来应该和你之前看到的YAML非常相似。这里要注意的要点是<em class="km">种类</em>——这是一种部署而不是pod。</p><p id="9743" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi">选择器:</strong>用于通过标签识别现有的pod，例如它们的元数据。如果有一个pod已经使用这样的标签运行，它将是此部署的一部分。</p><p id="64c8" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi">副本:</strong>它指定您希望在这个容器中创建多少个pod。如果您说两个，它将有两个pod运行后端。</p><p id="6eb9" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">假设副本设置为两个，并且已经有四个pod使用标签<code class="du mm mn mo lz b">app: node-backend</code>运行。它将终止其中两个pod以满足两个副本的要求。如果副本设置为6个，它还会将单元扩大2个。</p><p id="daf5" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi"> Spec: <em class="km"> </em> </strong>它指定了容器的详细信息，如图像名称、容器端口、pod内容器的CPU/内存限制等。</p><p id="d933" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi">模板:</strong>通过规范指定新创建的pod要使用的标签。</p><p id="f40a" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi"> *** </strong></p><p id="84bf" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">要创建部署，请运行以下命令:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="d8f3" class="lj if hh lz b fi md me l mf mg">kubectl apply -f backend.deploy.yml</span><span id="2af9" class="lj if hh lz b fi mh me l mf mg">Output:<br/>deployment.apps/node-backend created</span></pre><p id="414c" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">要查看所有部署:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="dc7e" class="lj if hh lz b fi md me l mf mg">k get deployments</span><span id="2a9b" class="lj if hh lz b fi mh me l mf mg">Output:<br/>NAME           READY   UP-TO-DATE   AVAILABLE   AGE<br/>node-backend   2/2     2            2           46s</span></pre><p id="2283" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">要访问部署期间创建的容器，可以使用port-forward。</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="8350" class="lj if hh lz b fi md me l mf mg">kubectl port-forward deployment/node-backend 3000:3000</span><span id="00f8" class="lj if hh lz b fi mh me l mf mg">You can access by going to localhost:3000/random</span></pre><h1 id="f15b" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">Kubernetes服务</h1><p id="5659" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">公开在一组<a class="ae ld" href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" rel="noopener ugc nofollow" target="_blank">pod</a>上运行的应用程序的一种抽象方式是作为网络服务。</p><p id="fe98" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这里需要注意的是——种类是服务，类型是负载平衡器。这在主机端口3000上创建了一个<code class="du mm mn mo lz b">LoadBalancer</code>,并将请求代理到3000上的容器。</p><p id="85f7" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这里<code class="du mm mn mo lz b">LoadBalancer</code>在平衡什么？如果你仔细观察，你会发现我们指定了一个选择器。选择器搜索标签为<code class="du mm mn mo lz b">app: node-background</code>的pod，发送到3000主机的任何请求都将在这些pod之间进行负载平衡。这里我们有两个副本，请求将被负载平衡到这两个单元。</p><p id="d72e" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">要创建服务，请运行以下命令:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="6623" class="lj if hh lz b fi md me l mf mg">kubectl apply -f backend.service.yml.</span></pre><p id="3750" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">要查看所有服务，请运行以下命令:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="a05a" class="lj if hh lz b fi md me l mf mg">k get service</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mp"><img src="../Images/fa58b56c6363a76ceeca9c859c1c1956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-A5_2m212NCTMtiY"/></div></div></figure><p id="22b4" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这将告诉您服务名称以及它是什么类型的服务。在这里，你可以看到有一个名为后端的服务，类型为<code class="du mm mn mo lz b">LoadBalancer</code>，我们刚刚使用服务yml创建了这个服务。</p><p id="4341" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">您也可以对前端执行相同的步骤:</p><pre class="jd je jf jg fd ly lz ma mb aw mc bi"><span id="51bb" class="lj if hh lz b fi md me l mf mg">kubectl apply -f backend.deploy.yml<br/>kubectl apply -f backend.service.yml</span></pre><h1 id="9f52" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">那不是很容易吗？</h1><p id="a30a" class="pw-post-body-paragraph jo jp hh jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl ha bi translated">我们已经了解了如何创建一个Kubernetes集群，以及如何部署一个简单的前端应用程序来与Kubernetes中的后端应用程序进行通信。希望这有助于你了解Kubernetes的基本知识。Kubernetes是一个巨大的海洋，我们只是触及了其中的一小滴。但是我希望这有助于为你将来学习Kubernetes铺平道路！</p><p id="694f" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="jq hi">有用链接:</strong></p><p id="307d" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">https://kubernetes.io/docs/concepts/<a class="ae ld" href="https://kubernetes.io/docs/concepts/" rel="noopener ugc nofollow" target="_blank"/></p><p id="58dd" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">【https://docs.docker.com/ T4】</p></div><div class="ab cl mq mr go ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ha hb hc hd he"><p id="329e" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><em class="km">披露声明:2020资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>