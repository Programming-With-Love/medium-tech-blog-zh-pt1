<html>
<head>
<title>Enterprise Integration Patterns With Apache Camel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Camel的企业集成模式</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/enterprise-integration-patterns-with-apache-camel-b8ed42967576?source=collection_archive---------3-----------------------#2021-06-16">https://medium.com/quick-code/enterprise-integration-patterns-with-apache-camel-b8ed42967576?source=collection_archive---------3-----------------------#2021-06-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e4b398018058e00d3af131dc28702738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DiWvcEgWpX00VP9s"/></div></div></figure><p id="d9ce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Apache Camel是一个集成框架。那是什么意思？假设您正在处理一个项目，该项目使用Kafka和RabbitMQ中的数据，读写各种数据库，转换数据，将所有内容记录到文件中，并将处理后的数据输出到另一个Kafka主题。您还必须实现服务的错误处理(重试、死信通道等)。)让一切完美运行。好像很难。</p><p id="d696" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Apache Camel帮助您集成许多组件，如数据库、文件、代理等等，同时保持简单性并促进企业集成模式。让我们看一些基于集成模式的例子。你可以在<a class="ae jn" href="https://github.com/diogodanielsoaresferreira/apache_camel_demo" rel="noopener ugc nofollow" target="_blank">这个资源库</a>中找到代码。</p><p id="bea8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你好。我想告诉你一个伟大的开源工具，它很棒，却没有得到应有的爱:<a class="ae jn" href="https://camel.apache.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">阿帕奇骆驼</strong> </a>。</p><p id="3eed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Apache Camel是一个集成框架。那是什么意思？假设您正在处理一个项目，该项目使用Kafka和RabbitMQ中的数据，读写各种数据库，转换数据，将所有内容记录到文件中，并将处理后的数据输出到另一个Kafka主题。您还必须实现服务的错误处理(重试、死信通道等)。)让一切完美运行。好像很难。</p><p id="4503" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Apache Camel帮助您集成许多组件，如数据库、文件、代理等等，同时保持简单性并促进企业集成模式。让我们看一些基于集成模式的例子。你可以在<a class="ae jn" href="https://github.com/diogodanielsoaresferreira/apache_camel_demo" rel="noopener ugc nofollow" target="_blank">这个库</a>中找到代码。</p><p id="fcda" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将利用<a class="ae jn" href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/EventDrivenConsumer.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">事件驱动的消费者</strong> </a>模式，从一个Kafka主题消费事件并输出到另一个主题。事件将是用户发送的文本消息的表示。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Example of event schema that will be received from Kafka</figcaption></figure><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Java code using Camel to read from topic and output message to another topic</figcaption></figure><p id="95a6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">差不多就是这样！我们还添加了日志，以便在日志中查看消息正文。log参数使用简单语言传递，这是一种用于计算表达式的Apache Camel语言。</p><p id="28b2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们实现一个<a class="ae jn" href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/Filter.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">消息过滤器</strong> </a>。此模式过滤掉不符合特定条件的邮件。在我们的例子中，我们将只处理类型为“chat”的那些。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Camel route to filter out messages of type other than “chat”</figcaption></figure><p id="6580" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">很简单，对吧？我们现在将消息从JSON解组到UserMessage POJO，以便能够按类型过滤。在发送到另一个Kafka主题之前，我们在JSON中再次封送。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">UserMessage POJO</figcaption></figure><p id="6406" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在假设我们想将所有消息存储在一个文件中。此外，对于发送者是“John Doe”的消息，我们希望将它们存储在一个不同的文件中，以便进行测试。为此，我们可以使用<a class="ae jn" href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/ContentBasedRouter.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">基于内容的路由器</strong> </a>模式。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">After sending the message to the broker, it will now also store it in a file, depending on the emitter</figcaption></figure><p id="719c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果文件已经存在，我们将追加事件并在每个事件的末尾添加一个新行。对于其他发射器，我们将做同样的事情，但是将它们存储在另一个文件中。它看起来确实像一个“如果”结构，对吗？</p><p id="5688" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以在事件中看到一个“设备”列表，我们希望逐个记录它们。我们如何做到这一点？使用<a class="ae jn" href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/Sequencer.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">拆分器</strong> </a>模式，我们可以遍历任何列表。我们可以按顺序或平行地做。在这个例子中，让我们试着按顺序来做。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Before sending the message to the output topic, we will iterate through each device and log it</figcaption></figure><p id="4b7b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以用任何可迭代的域来分割。如您所见，我们再次使用简单的语言来访问事件的内容。</p><p id="01df" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们试试更难的。我们从不同的发射器接收带有文本的消息，但是我们想要聚合多个文本消息，并为一个发射器创建一个包含所有消息的新消息。为此，我们可以使用<a class="ae jn" href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/Aggregator.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">聚合器</strong> </a>模式。聚合器模式允许缓冲事件并等待其他事件。当接收到另一个事件时，可以根据我们的需要执行自定义聚合。满足条件时，会发送新事件。该条件可以基于收到的事件数量、超时或任何其他自定义条件。</p><p id="5ac4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们的例子中，我们将创建一个新的POJO，它将聚合来自发射器的文本消息。新事件将在发射器收到第一个事件5秒后发送。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Aggregation to create a new event with the messages of an emitter</figcaption></figure><p id="062e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用内存聚合，但是也可以使用其他数据存储，比如Postgres或Redis。我们使用简单的语言来聚合消息的发送者，并且我们创建了一个定制的聚合策略，如下所示。</p><p id="0b9f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在自定义聚合策略中，对于第一个事件(oldExchange==null)，我们使用消息文本创建一个新的CombinedUserMessage。对于所有其他事件，我们将消息的文本添加到组合事件中。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Custom aggregation strategy</figcaption></figure><p id="f01c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这一切都很棒，但是我们如何将变换应用于一个领域呢？我们现在有了一个组合事件，但最棒的是我们可以通过某种方式处理组合事件，并通过组合文本消息的多个元素将其转换为纯文本。我们可以使用<a class="ae jn" href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageTranslator.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">消息转换器</strong> </a>模式来实现。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">We can call bean() to apply a transformation to our message</figcaption></figure><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Java Bean to apply transformations to a message</figcaption></figure><p id="cbc0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以直接从Camel Route调用bean函数，并使用普通的Java代码执行我们需要的所有转换。整洁！</p><p id="c608" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以看到我们的骆驼路线正在变大。例如，如果我们想要将它们在文件之间分开，我们该怎么做呢？两个内存组件允许我们这样做:<strong class="ir hi">直接</strong>和<strong class="ir hi"> SEDA </strong>。</p><p id="cb79" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> Direct </strong>是一个同步端点，其工作方式类似于从一个路由到另一个路由的调用。让我们用它来分离在一个文件中存储事件的路由。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">We separate our main route into two routes, connected with the Direct endpoint</figcaption></figure><p id="b20f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">太好了！还有一个内存组件对我们有用:<strong class="ir hi"> SEDA </strong>。SEDA的工作方式类似于Direct，但它是异步的，这意味着它将消息放在一个队列中，供其他线程处理。让我们用SEDA来把接收卡夫卡的信息和消费它的途径分离开来。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">With the SEDA endpoints, we now have only one consumer from Kafka instead of two</figcaption></figure><p id="6ce9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们的路线简单多了。假设我们需要执行一个周期性的任务，比如清理。我们可以利用<strong class="ir hi">定时器</strong>端点。让我们通过创建每5秒运行一次的路线来举例说明。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Simple timer that is activated every 5 seconds</figcaption></figure><p id="031a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然我们的应用程序几乎已经可以生产了，我们必须提高容错能力。如果由于某种原因，消息在路由中出错，会发生什么？让我们实现<a class="ae jn" href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/DeadLetterChannel.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">死信</strong> </a>模式。当路由出现错误时，消息被发送到另一个Kafka主题，以便稍后可以重新处理。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">Configure a default error handler for all routes, using the dead letter pattern to send messages to a kafka topic</figcaption></figure><p id="1498" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就是这样！错误处理程序配置适用于该类中的所有路由。我们将原始消息发送到主题(在路由中第一次收到的那个)。我们还可以配置重试策略、超时和其他常见的容错配置，但是因为我们不需要它，所以我们将保持原样。</p><p id="61f7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然我们已经到了本文的结尾，我还想向您展示一些东西:将<strong class="ir hi"> REST </strong>端点配置为Camel routes是可能的。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div><figcaption class="ju jv et er es jw jx bd b be z dx">REST endpoint for a GET to /api/helo</figcaption></figure><p id="21ce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就这么简单！我们刚刚为URL <em class="jy"> /api/hello </em>配置了一个GET，用“Hello World！”。</p><p id="7fd7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如您所见，Apache Camel是一个框架，它简化了与其他组件的集成，支持企业集成模式，并使创建数据管道变得更加容易。</p><p id="eb75" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">希望你喜欢！谢谢大家！</p></div></div>    
</body>
</html>