<html>
<head>
<title>Migration points for upgrading to actions-on-google-nodejs version 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">升级到actions-on-google-nodejs版本2的迁移点</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/migration-points-for-upgrading-to-actions-on-google-nodejs-version-2-4640648ab8b5?source=collection_archive---------5-----------------------#2018-08-05">https://medium.com/google-developer-experts/migration-points-for-upgrading-to-actions-on-google-nodejs-version-2-4640648ab8b5?source=collection_archive---------5-----------------------#2018-08-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="fdbd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在为Google Assistant开发应用时，actions-on-google-nodejs SDK是一个难以替代的工具。Google平台和Dialogflow上对动作的请求和响应的格式是JSON。JSON格式有许多属性。因此，我们很难用手来对待JSON。actions-on-google-nodejs是一个JavaScript SDK，提供了许多便利的特性，我们可以编写必要的代码来轻松处理Webhook请求。大多数开发人员将使用这个SDK。</p><p id="20b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实际上，当从初始版本(v1)升级到版本2 (v2)时，如何使用SDK已经发生了很大的变化。如果你把你的应用的SDK版本改成v2，你需要彻底地改变代码。</p><p id="669c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我有三个已经发布的应用程序。最后，我刚刚完成了向v2的迁移。我想为迁移提出一些观点。</p><h1 id="8134" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">将意向名称工艺路线更改为活动名称工艺路线</h1><p id="58df" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在v1中，策略是由包含在对话流的意图定义中的“动作名称”来决定您的实现的调用功能。也就是说，像下面的代码:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="b2ed" class="ko jd hh kk b fi kp kq l kr ks">const App = require("actions-on-google").DialogflowApp;<br/>const app = new App({request: req, response: res});</span><span id="9bd3" class="ko jd hh kk b fi kt kq l kr ks">const handleWelcome = app =&gt; {<br/>  app.ask("Welcome to my app! ...");<br/>};</span><span id="2040" class="ko jd hh kk b fi kt kq l kr ks">const actionMap = new Map();<br/>actionMap.set("action_welcome", handleWelcome);<br/>app.handleRequest(actionMap);</span></pre><p id="7983" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，在v2中,“动作名称”路由已经停止。然而，(可惜！)，引入了一种新的“意图名”路由机制。例如，像下面这样:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="9ed3" class="ko jd hh kk b fi kp kq l kr ks">const { dialogflow } = require("actions-on-google");<br/>const app = dialogflow({ debug: true });</span><span id="4b10" class="ko jd hh kk b fi kt kq l kr ks">app.intent("Default Welcome Intent", conv =&gt; {<br/>  conv.ask("Welcome to my app! ...");<br/>});</span></pre><p id="53af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae ku" href="https://github.com/actions-on-google/actions-on-google-nodejs/issues/108#issuecomment-387321310" rel="noopener ugc nofollow" target="_blank">对我来说</a>的改动很难接受，但spec是v2中当前的。我把所有的处理函数都改成了<code class="du kv kw kx kk b">app.intent("...", conv =&gt; {...})</code>。</p><p id="72f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您为一些意图指定了一个动作名，并且您在目前的实现中实现了一个处理函数，那么您可以指定一个数组，该数组将意图名作为<code class="du kv kw kx kk b">app.intent()</code>函数的第一个参数，以避免编写重复的代码。</p><h1 id="353b" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">回复时更改函数调用</h1><p id="d956" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在v1中，我们使用<code class="du kv kw kx kk b">ask</code>和<code class="du kv kw kx kk b">tell</code>函数来响应回复。特别是，可能会有很多反馈说<code class="du kv kw kx kk b">tell</code>不直观。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="6909" class="ko jd hh kk b fi kp kq l kr ks">// Return a reply<br/>app.ask("...");</span><span id="aaa5" class="ko jd hh kk b fi kt kq l kr ks">/// Return a reply and end the conversation<br/>app.tell("...");</span></pre><p id="9b6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在v2中，<code class="du kv kw kx kk b">ask</code>功能保持不变。但是，我们必须使用一个<code class="du kv kw kx kk b">close</code>函数来结束对话。此外，我们必须针对作为处理函数参数传递的conv对象调用这些函数。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="ff2f" class="ko jd hh kk b fi kp kq l kr ks">app.intent("...", conv =&gt; {<br/>  // Return a reply<br/>  conv.ask("...");</span><span id="0102" class="ko jd hh kk b fi kt kq l kr ks">// Return a reply and end the conversation<br/>  conv.close("...");<br/>});</span></pre><p id="2030" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<code class="du kv kw kx kk b">ask</code>功能上，出现另一个如下变化。</p><h1 id="7e48" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">将静态重新提示更改为动态重新提示</h1><p id="b324" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">重新提示是当用户在一段时间后没有说话时，从应用程序重新询问用户的功能。在v1中，有静态重新提示。用法非常简单。开发者可以创建一个数组，该数组中的消息作为函数的第二个参数重新询问用户。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="cf12" class="ko jd hh kk b fi kp kq l kr ks">const repromptMessages = [<br/>    "Hello?",<br/>    "Are you here?",<br/>    ...<br/>];</span><span id="b91a" class="ko jd hh kk b fi kt kq l kr ks">app.ask("Please say something.", repromptMessages);</span></pre><p id="5a99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不幸的是，这个静态重新提示功能已经停止。也就是说，v2没有这个特性。使用文件已经在<a class="ae ku" href="https://developers.google.com/actions/assistant/reprompts" rel="noopener ugc nofollow" target="_blank">文件</a>中删除。相反，我们必须使用<a class="ae ku" href="https://developers.google.com/actions/assistant/reprompts#dynamic_reprompts" rel="noopener ugc nofollow" target="_blank">动态重新提示</a>。例如，在对话流中，我们必须为重新提示创建一个新的意图。</p><figure class="kf kg kh ki fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ky"><img src="../Images/0a0d65a85131f3c46b9f3e82fda62ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*U7_T4acciD_hXejAcHDnNA.png"/></div></div></figure><p id="9909" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们需要添加一个带有<code class="du kv kw kx kk b">app.intent()</code>函数的handler函数。</p><h1 id="ad24" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">为异步流程返回一个承诺</h1><p id="7aaa" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在v1中，如果在被调用的handler函数中执行了某个异步进程，我们可以随时正常调用<code class="du kv kw kx kk b">app.ask()</code>，并返回响应。例如，我们可以编写下面的代码。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="90aa" class="ko jd hh kk b fi kp kq l kr ks">const request = require("request");</span><span id="06ac" class="ko jd hh kk b fi kt kq l kr ks">const welcome = app =&gt; {<br/>  request(..., (error, response, body) =&gt; {<br/>    ...<br/>    app.ask("...");<br/>  });<br/>};</span></pre><p id="63ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在v2中，上面的代码不会正常执行。也就是说，我们将得到如下所示的错误消息。</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="596e" class="ko jd hh kk b fi kp kq l kr ks">Error: No response has been set. Is this being used in an async call that was not returned as a promise to the intent handler? at DialogflowConversation.response</span></pre><p id="73d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们想在异步通信后响应回复，我们需要返回一个Promise对象作为处理函数的结果值。例如，它的代码如下所示:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="3308" class="ko jd hh kk b fi kp kq l kr ks">const request = require("request");</span><span id="d834" class="ko jd hh kk b fi kt kq l kr ks">app.input("welcome", conv =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    ...<br/>    request(..., (error, response, body) =&gt; {<br/>      ...<br/>      if (error) {<br/>        ...<br/>        reject(...);<br/>      } else {<br/>        ...<br/>        resolve(...);<br/>      }<br/>  }).then(result =&gt; {<br/>    ...<br/>    conv.ask(...);<br/>  }).catch(error =&gt; {<br/>    ...<br/>    conv.close(...);<br/>  });<br/>});</span></pre><p id="7b74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我的应用程序中，有外部通信(例如:API调用)和对数据存储的访问。因此，我重写了所有目标代码，以返回一个Promise对象。</p><h1 id="3bd2" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">设置和删除上下文</h1><p id="3ac5" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">到目前为止，我们只有<code class="du kv kw kx kk b">app.setContext()</code>函数来操作实现的处理函数中的上下文。例如，v1中操作上下文的代码如下所示:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="279b" class="ko jd hh kk b fi kp kq l kr ks">// Set a context (2nd argument is 1 or more）<br/>app.setContext("CONTEXT_FOOBAR", 1);</span><span id="1c5c" class="ko jd hh kk b fi kt kq l kr ks">// Delete the context (need to specify 0 as the 2nd argument)<br/>app.setContext("CONTEXT_FOOBAR", 0);</span></pre><p id="0f64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在v2中，定义了操作上下文的API。</p><p id="c64c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae ku" href="https://actions-on-google.github.io/actions-on-google-nodejs/classes/dialogflow.contextvalues.html" rel="noopener ugc nofollow" target="_blank">类上下文值</a></p><p id="edd6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">也就是说，操作上下文的代码类似于v2中的以下代码:</p><pre class="kf kg kh ki fd kj kk kl km aw kn bi"><span id="7cac" class="ko jd hh kk b fi kp kq l kr ks">// Set a context<br/>conv.contexts.set("CONTEXT_FOOBAR", 1);</span><span id="07d7" class="ko jd hh kk b fi kt kq l kr ks">// Delete the context<br/>conv.contexts.delete("CONTEXT_FOOBAR");</span></pre><p id="5eaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我认为这些API从v1到v2带来了更干净的规范。</p><h1 id="76ba" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">结论</h1><p id="67bb" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">从v1到v2的变化，相对较大的结构变化发生了，虽然我只使用了我的应用程序的基本功能。对于使用v1助手函数的应用程序，代码可能会有更大的变化(改变为将必要的对象传递给<code class="du kv kw kx kk b">conv.ask()</code>函数的形式，而不是函数调用)。</p><p id="5c48" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你还在用v1，我觉得还是早点迁移到v2比较好，参考上面的。</p></div></div>    
</body>
</html>