<html>
<head>
<title>Exploring the View Pager 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浏览视图页面2</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/exploring-the-view-pager-2-86dbce06ff71?source=collection_archive---------0-----------------------#2019-03-04">https://medium.com/google-developer-experts/exploring-the-view-pager-2-86dbce06ff71?source=collection_archive---------0-----------------------#2019-03-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/0ad85138585d90d0abf180a3ecd50ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4nGWBJL3EDwD60h0_Sdk5g.png"/></div></div></figure><blockquote class="ip iq ir"><p id="7c64" class="is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是最初张贴在joebirch.co</p></blockquote><div class="jr js ez fb jt ju"><a href="https://joebirch.co/2019/02/22/exploring-the-view-pager-2/" rel="noopener  ugc nofollow" target="_blank"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hi fi z dy jz ea eb ka ed ef hg bi translated">浏览视图页面2</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">在Android领域工作时，您可能会在某个时候遇到ViewPager类。这种观点允许我们…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">joebirch.co</p></div></div><div class="kd l"><div class="ke l kf kg kh kd ki in ju"/></div></div></a></div></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="1590" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">在Android领域工作时，您可能会在某个时候遇到ViewPager类。这个视图允许我们以可滑动的格式向用户显示片段或视图的集合——在车载和内容显示屏中特别流行。这个组件已经在Android世界中存在了一段时间，它甚至被移植到了androidx库——但现在我们有了这个组件的更新版本，即<a class="ae kt" href="https://developer.android.com/jetpack/androidx/releases/viewpager2#1.0.0-alpha01" rel="noopener ugc nofollow" target="_blank"> View Pager 2 </a>，它最近发布了alpha版本。让我们来看看这次迭代到底有什么不同。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="9a48" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">在某些情况下，对于用户来说，这些视图页面组件中的每一个都可能有相同的感觉。显示一个视图，在视图中滑动另一个视图，等等。但是如果我们想在一个视图页面中显示同一个视图的多个实例…即使使用了视图实例，我们仍然会遇到一些效率低下的问题。这就是View Pager 2的一个关键不同之处——它的不同之处在于利用了RecyclerView。这意味着，就像我们已经在使用回收器视图显示内容流一样，现在让我们的视图随着我们的前进而回收允许我们能够利用完全相同的行为来查看页面。在我看来，这是一个巨大的消息，不仅会给我们的用户带来更流畅的体验，还会让我们作为开发者更容易实现这个组件。</p><p id="3807" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">在这一点上，recycler视图的其他特性也变得可用——如果您已经使用了DiffUtil功能，那么您就会知道它有多么强大。因为我们现在使用了RecyclerView，所以我们现在能够使用这个类执行不同的操作，在处理视图页面组件中的动态或更新内容时会更有效。</p><p id="19d0" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">我们还有一些其他的特性，这些特性现在也在View Pager 2中引入了——从右到左的支持和垂直方向是其中的两个。这使我们能够创建更具包容性的应用程序，并将该组件用于特定的屏幕设计。</p><p id="fdc7" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">别担心，我们使用回收器视图并不意味着我们不能使用片段。我们可以利用FragmentStateAdapter在视图pager 2中处理我们的片段——这取代了FragmentStatePagerAdapter，并将使如何在这个组件中处理片段变得更加清晰。</p><p id="3566" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">另外，对于Android团队来说，维护起来会容易得多。不仅仅是回收器视图现在正在提升和经历重用，而且视图分页器类已经从<strong class="iv hi"> 3169 </strong>行代码减少到<strong class="iv hi"> 583 </strong>。如果您曾经深入查看过视图页面的源代码，那么您可能会记得其中有许多复杂性——边缘检测、手势检测、状态持续、偏移和定位计算、边距绘制、视图绘制和许多自定义计算。对于团队来说，消除维护一个有自己逻辑的类的需求将是一个巨大的胜利。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="6486" class="ku kv hh bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在后台</h1><p id="8bfe" class="pw-post-body-paragraph is it hh iv b iw ls iy iz ja lt jc jd kq lu jg jh kr lv jk jl ks lw jo jp jq ha bi translated">在使用组件时，很好地理解组件内部的情况通常会很有帮助。这不仅有助于您理解组件的能力，而且当遇到bug时，您将有更好的知识来解决发生的问题。就像视图分页器一样，视图分页器2从视图组类扩展而来——从那里，事情看起来有点不同。除了一些省略之外，这就是View Pager 2的核心部分:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/ec3d13805fd551c6301eae77956ed579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7BMFx6LhcqLxDeOG6uFtYA.png"/></div></div></figure><h1 id="a5fd" class="ku kv hh bd kw kx mc kz la lb md ld le lf me lh li lj mf ll lm ln mg lp lq lr bi translated">回收器视图</h1><p id="c5c4" class="pw-post-body-paragraph is it hh iv b iw ls iy iz ja lt jc jd kq lu jg jh kr lv jk jl ks lw jo jp jq ha bi translated">View Pager 2使用RecyclerView组件来处理您分配给它的内容的显示。这给我们带来了很多好处，我已经在这篇文章中概述了。—但本质上，这意味着我们现在可以利用我们已经熟悉的大多数回收器视图组件。</p><h1 id="4282" class="ku kv hh bd kw kx mc kz la lb md ld le lf me lh li lj mf ll lm ln mg lp lq lr bi translated">布局管理器</h1><p id="a08a" class="pw-post-body-paragraph is it hh iv b iw ls iy iz ja lt jc jd kq lu jg jh kr lv jk jl ks lw jo jp jq ha bi translated">这与您之前在应用程序中与RecyclerView组件一起使用的LayoutManager类完全相同。布局管理器由视图页面管理器管理，因此开发人员能够设置组件的方向。虽然您无法控制使用什么样的布局管理器(LinearLayoutManager是自动分配的)，但您可以设置管理器使用的方向。使用视图页面2上的<strong class="iv hi"> setOrientation() </strong>函数，我们可以传入一个方向值，这将允许我们为布局管理器设置方向。最初的视图页面只提供了水平方向，所以对于以垂直方式显示页面内容的应用程序来说，这将非常有用。</p><h1 id="076e" class="ku kv hh bd kw kx mc kz la lb md ld le lf me lh li lj mf ll lm ln mg lp lq lr bi translated">页面更改回调</h1><p id="a650" class="pw-post-body-paragraph is it hh iv b iw ls iy iz ja lt jc jd kq lu jg jh kr lv jk jl ks lw jo jp jq ha bi translated">您可以在我们的view pager 2上注册一个页面更改回调(以<strong class="iv hi"> OnPageChangeCallback </strong>类的形式)。这将允许您监听所选页面上的更改。在此回调中，我们可以监听:</p><ul class=""><li id="7159" class="mh mi hh iv b iw ix ja jb kq mj kr mk ks ml jq mm mn mo mp bi translated"><strong class="iv hi">onpagesulved()</strong>—当前页面发生滚动事件时触发</li><li id="25c1" class="mh mi hh iv b iw mq ja mr kq ms kr mt ks mu jq mm mn mo mp bi translated"><strong class="iv hi"> onPageSelected() </strong> —当新页面被选中时触发</li><li id="477d" class="mh mi hh iv b iw mq ja mr kq ms kr mt ks mu jq mm mn mo mp bi translated"><strong class="iv hi">onPageScrollStateChanged()</strong>—当滚动状态改变时触发</li></ul><h1 id="dcff" class="ku kv hh bd kw kx mc kz la lb md ld le lf me lh li lj mf ll lm ln mg lp lq lr bi translated">适配器</h1><p id="5bab" class="pw-post-body-paragraph is it hh iv b iw ls iy iz ja lt jc jd kq lu jg jh kr lv jk jl ks lw jo jp jq ha bi translated">就像我们在其他地方为RecyclerView组件设置适配器一样，我们现在可以为ViewPager做同样的事情。这与我们习惯使用RecyclerView适配器没有什么不同。</p><h1 id="aa88" class="ku kv hh bd kw kx mc kz la lb md ld le lf me lh li lj mf ll lm ln mg lp lq lr bi translated">寻呼机快照帮助程序</h1><p id="a63d" class="pw-post-body-paragraph is it hh iv b iw ls iy iz ja lt jc jd kq lu jg jh kr lv jk jl ks lw jo jp jq ha bi translated">这是我们无法配置的，但我想指出它的用法，因为它不同于最初的视图页面。在这里，ViewPager使用PagerSnapHelper类来模拟在满足选定项的滚动位置要求时捕捉该项。您可能以前在自己的RecyclerView中使用过这个类，但是这显示了重用已经存在的组件来改进框架中的某些东西。</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es mv"><img src="../Images/024fa9f628f25c788ec3347c22204804.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/0*8FQpDII-HW7jBViM"/></div></figure></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="0631" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">除了上面提到的功能，我们仍然可以从原始视图页面访问我们可能熟悉的其他部分。这些事情包括:</p><ul class=""><li id="808c" class="mh mi hh iv b iw ix ja jb kq mj kr mk ks ml jq mm mn mo mp bi translated"><strong class="iv hi"> setCurrentItem() </strong> —设置应在屏幕上显示的当前项目</li><li id="8552" class="mh mi hh iv b iw mq ja mr kq ms kr mt ks mu jq mm mn mo mp bi translated"><strong class="iv hi"> getCurrentItem() </strong> —获取屏幕上显示的项目的当前项目索引</li><li id="024c" class="mh mi hh iv b iw mq ja mr kq ms kr mt ks mu jq mm mn mo mp bi translated"><strong class="iv hi">setpage transformer()</strong>-设置一个转换器，以便在页面发生变化时应用自定义转换</li></ul><h1 id="bb87" class="ku kv hh bd kw kx mc kz la lb md ld le lf me lh li lj mf ll lm ln mg lp lq lr bi translated">实现视图页导航</h1><p id="6834" class="pw-post-body-paragraph is it hh iv b iw ls iy iz ja lt jc jd kq lu jg jh kr lv jk jl ks lw jo jp jq ha bi translated">要将视图Pager 2添加到我们的项目中，我们需要首先将所需的依赖项添加到build.gradle文件中:</p><pre class="ly lz ma mb fd mw mx my mz aw na bi"><span id="54e9" class="nb kv hh mx b fi nc nd l ne nf">implementation 'androidx.viewpager2:viewpager2:1.0.0-alpha01'</span></pre><p id="cfab" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">添加后，我们现在可以访问View Pager 2组件，这意味着我们可以继续将它添加到我们的布局文件中:</p><pre class="ly lz ma mb fd mw mx my mz aw na bi"><span id="2fc2" class="nb kv hh mx b fi nc nd l ne nf">&lt;androidx.viewpager2.widget.ViewPager2<br/>        android:id="@+id/view_pager"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"/&gt;</span></pre><p id="1d29" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">现在我们已经在布局中定义了视图分页器，我们需要通过创建一个从RecyclerView扩展的适配器，为它分配一些数据，以便在屏幕上显示给用户。适配器类。然后，我们可以将这个适配器分配给我们的view pager实例:</p><pre class="ly lz ma mb fd mw mx my mz aw na bi"><span id="7847" class="nb kv hh mx b fi nc nd l ne nf">val adapter = WelcomeAdapter()<br/>adapter.welcomeItems = listOf(WelcomeItem.WELCOME_ONE, WelcomeItem.WELCOME_TWO, WelcomeItem.WELCOME_THREE)<br/>view_pager.adapter = adapter</span></pre><p id="0b14" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">现在我们已经显示了内容，我们可能想要调整视图页面的方向。默认情况下，视图分页器使用<strong class="iv hi">水平</strong>方向:</p><pre class="ly lz ma mb fd mw mx my mz aw na bi"><span id="e982" class="nb kv hh mx b fi nc nd l ne nf">androidx.viewpager2.widget.ViewPager2.ORIENTATION_HORIZONTAL</span></pre><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es mv"><img src="../Images/d5e58e9639a852bdfa684f64574c3437.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/0*zSJ24n1qh8eYkg41"/></div></figure><p id="858f" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">如果这是您想要的方向，您不需要在这里做任何改变。但是，如果您希望使用垂直方向，那么您可以通过调用setOrientation()并传入<strong class="iv hi"> ORIENTATION_VERTICAL </strong>值来更改它:</p><pre class="ly lz ma mb fd mw mx my mz aw na bi"><span id="bb03" class="nb kv hh mx b fi nc nd l ne nf">view_pager.orientation = ORIENTATION_VERTICAL</span></pre><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es mv"><img src="../Images/1889f8f490f4899edb0bce4b67166dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/0*kM5Qyz62u7anA6zm"/></div></figure><p id="ffaa" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">我们还可以从视图页面中监听事件，因为我们可能希望根据用户选择的页面来调整我们的UI或数据。同样，这里我们可以观察到<strong class="iv hi">onpagesrolled()</strong>、<strong class="iv hi"> onPageSelected() </strong>和<strong class="iv hi">onPageScrollStateChanged()</strong>:</p><pre class="ly lz ma mb fd mw mx my mz aw na bi"><span id="8077" class="nb kv hh mx b fi nc nd l ne nf">view_pager.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {</span><span id="cc09" class="nb kv hh mx b fi ng nd l ne nf">   // override desired callback functions</span><span id="f9e4" class="nb kv hh mx b fi ng nd l ne nf">})</span></pre><p id="dc18" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">我们还可以对数据执行DiffUtil操作，以动态更新视图页面中的内容，这意味着我们不需要重新加载和设置整个数据集，只需要更改数据。您可以使用DiffUtil here 检查文档中的<a class="ae kt" href="https://developer.android.com/reference/android/support/v7/util/DiffUtil" rel="noopener ugc nofollow" target="_blank">，但是作为一个例子，我们将上面GiIFs中显示的内容作为我们的数据集。如果我们随后对相同的数据执行DiffUtil操作，其中只有最后一个屏幕的标题不同，我们将能够利用来自diff结果的change有效负载来只更新那段内容——这在涉及view pager组件中的动态内容时效率会高得多。</a></p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><p id="7af8" class="pw-post-body-paragraph is it hh iv b iw ix iy iz ja jb jc jd kq jf jg jh kr jj jk jl ks jn jo jp jq ha bi translated">我希望这已经让您深入了解了新的View Pager组件，以及使用它后我们能够实现的功能。虽然它仍处于<strong class="iv hi"> alpha </strong>阶段，但它承诺了一种更有效的方法来显示和管理我们的内容——这反过来将为我们的用户带来更好的体验。结合由回收器视图(动画等)支持的DiffUtil和其他功能，View Pager 2承诺在实现和使用方面都有改进的体验。您目前是否正在使用View Pager，您将如何使用View Pager 2？请在下面的评论区告诉我🙌</p><div class="jr js ez fb jt ju"><a href="https://twitter.com/hitherejoe" rel="noopener  ugc nofollow" target="_blank"><div class="jv ab dw"><div class="jw ab jx cl cj jy"><h2 class="bd hi fi z dy jz ea eb ka ed ef hg bi translated">乔·伯奇(@hitherejoe) |推特</h2><div class="kb l"><h3 class="bd b fi z dy jz ea eb ka ed ef dx translated">乔伯奇的最新推文(@hitherejoe)。Android Lead @Buffer。谷歌开发专家为@Android，@GooglePay &amp;…</h3></div><div class="kc l"><p class="bd b fp z dy jz ea eb ka ed ef dx translated">twitter.com</p></div></div><div class="kd l"><div class="nh l kf kg kh kd ki in ju"/></div></div></a></div></div></div>    
</body>
</html>