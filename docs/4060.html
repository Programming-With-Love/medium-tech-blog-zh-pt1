<html>
<head>
<title>Event-driven programming for Android (part III)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android的事件驱动编程(第三部分)</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/event-driven-programming-for-android-part-iii-3a2e68c3faa4?source=collection_archive---------0-----------------------#2015-02-08">https://medium.com/google-developer-experts/event-driven-programming-for-android-part-iii-3a2e68c3faa4?source=collection_archive---------0-----------------------#2015-02-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="84f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(这是由三部分组成的系列文章的第三部分)</p><p id="2e86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">之前，我已经介绍了Android的事件驱动编程，并展示了一些代码来创建一个<em class="jc"> HelloWorld事件驱动的</em>应用程序。</p><p id="4225" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们可能面临另一个问题:如何使用事件驱动开发轻松扩展应用程序，而不陷入混乱无序的代码中？在本文中，我将提供一个提议体系结构，它用于基于事件驱动的开发来扩展应用程序，但也可以用于创建更通用类型的应用程序。</p><p id="096f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我使用这个架构已经有一段时间了，它已经做出了改变。使用事件和MVP模式确保了我可以轻松地向应用程序添加特性。我还缩短了重构和重写之间的时间，所以我写的软件实际上可以活得更长，质量更好。</p><h1 id="0999" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">第一个任期:MVP</h1><p id="17a7" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">MVP代表Model View Presenter，是一种编程模式，它定义了要在软件系统中实现的三个基本实体:</p><p id="d666" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">模型</strong>:渲染什么</p><p id="0a55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">视图</strong>:如何渲染</p><p id="e982" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">展示者</strong>:处理模型和视图之间的通信。演示者用来自模型的内容更新视图，抽象出视图下面的任何复杂性。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/e6e5a6c4c8287bf17a6b86e543f15f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*QlAXwccEelGOyGSzP3tmcA.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Courtesy of WikiMedia</figcaption></figure><p id="e4b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MVP(以及其他编程模式)是一个概念，而不是一个概念坚固的框架，所以没有严格的规则。Android并没有实现纯粹的MVP模式，而是包含了一些元素:</p><ul class=""><li id="7727" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">用户界面(视图)在XML文件中定义。</li><li id="1bad" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">我们扩展扩展视图的类(Activity，Fragment ),并更新它们。</li></ul><p id="f6d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从MVP模式的所有组件来看，<em class="jc">呈现者</em>在Android中没有直接的表示。然而，这是一个重要的组成部分:想象一下，明天我们需要从web服务而不是数据库中检索数据。如果我们遵循了MVP方法，那么这种改变实现起来会很简单。</p><h1 id="ada6" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">事件驱动的支持架构</h1><p id="2382" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">以下架构旨在简化基于事件驱动的应用程序的实现。它还具有其他一些优点，如高度模块化和易于测试。</p><p id="7d07" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将创建我们自己的<em class="jc">应用程序</em>的实例。该实例将托管一个EventBus注册表，该注册表是一个包含所有总线订户的完整列表的类(稍后将详细介绍)。我们的<em class="jc">应用程序</em>将注册所有订户，并在终止时取消注册。</p><h2 id="36e6" class="lg je hh bd jf lh li lj jj lk ll lm jn ip ln lo jr it lp lq jv ix lr ls jz lt bi translated">事件总线注册表</h2><p id="bf9b" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">这个类基本上是一个包含所有总线用户的寄存器。我最终将我的订户命名为PluginControllers，因为您可以插入和拔出它们，应用程序将继续工作(当然，如果它们没有插入，它们将不会监听事件)。我知道这种命名会使读者困惑，所以在本文中我将把它命名为订户。</p><p id="e194" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">EventBus注册中心保存了对EventBus(这是一个静态类)的引用，因此它可以注册订户。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lu"><img src="../Images/d2833d1fc6e846e817dc3d868abf4b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*vqVV2XZ0HiZVlCNTBADxBw.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Conceptually: the Application will contain a EventBus Registry with references to the different subscribers, so they can be registered or unregistered. The EventBus is a static instance in the application.</figcaption></figure><h2 id="0bde" class="lg je hh bd jf lh li lj jj lk ll lm jn ip ln lo jr it lp lq jv ix lr ls jz lt bi translated">订户</h2><p id="ca88" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">订户将是唯一能够监听事件的类。这个类将总是包含一个或多个<em class="jc"> OnEvent() </em>方法。订阅者将在收到事件后执行操作。一个基本的例子:当收到“PerformCallEvent”时，您可以拥有一个执行调用的订户。</p><p id="b65a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">订阅者还可以将事件发布到EventBus中，作为对传入事件的响应。</p><h2 id="2e64" class="lg je hh bd jf lh li lj jj lk ll lm jn ip ln lo jr it lp lq jv ix lr ls jz lt bi translated">节目主持人</h2><p id="7923" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">主持人采取行动。这些观点给了他们命令，他们因此而行动。他们还可以将事件发布到EventBus中。</p><p id="fda1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种架构使用单个活动。对此有支持和反对的观点，但是因为我们将使用不同的片段来表示屏幕，使用单个活动使事情变得更容易(记住，作为开发人员，您的主要目标应该是编写更少的程序)。</p><p id="8e88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我已经向<a class="ae lv" href="https://github.com/kikoso/Event-Bus-Architecture" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上传了一个包含登录屏幕的示例项目，它触发事件来执行登录，并在登录后加载一个不同的片段。看一下项目结构:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lw"><img src="../Images/0ea703867e54d3963afee36ee4e1963f.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*hcpitlMO3V8yrW47pApIug.png"/></div></figure><p id="9bae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有用于EventBus注册表、活动和订户的基类(您可能希望根据您的项目需求添加一个基本片段类)。应用程序、EventBus和EventBus注册表都是为项目定制的(因此使用了ed前缀)。</p><p id="af10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将此应用程序扩展到新功能中基本上需要新的事件、订阅者和演示者，以及每个功能的视图。遵循这种模式可以确保应用程序是可伸缩的，代码是分离的，因此易于测试和理解。</p></div></div>    
</body>
</html>