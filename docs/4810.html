<html>
<head>
<title>Programmer Dictionary: Function literal with receiver vs Function type with receiver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">程序员字典:带接收方的函数文本与带接收方的函数类型</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/programmer-dictionary-function-literal-with-receiver-vs-function-type-with-receiver-cc21dba0f4ff?source=collection_archive---------6-----------------------#2018-01-04">https://blog.kotlin-academy.com/programmer-dictionary-function-literal-with-receiver-vs-function-type-with-receiver-cc21dba0f4ff?source=collection_archive---------6-----------------------#2018-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c3ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经讨论过<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e"> <em class="kj">函数字面量</em>和<em class="kj">函数类型</em> </a>的区别。尽管Kotlin引入了扩展函数，但它也需要特殊的<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类型</a>和<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">文字</a>来处理它们。它们被称为带接收器的<strong class="jm io">函数字面量</strong>和带接收器的<strong class="jm io">函数类型</strong>。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi kk"><img src="../Images/582f4f67119277a0587d56adcd560c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/0*fdaLZljnK3tjZg7F.jpg"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Image from <a class="ae ki" href="http://www.miva.com" rel="noopener ugc nofollow" target="_blank">miva.com</a></figcaption></figure><p id="db50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从头开始。下面是一个简单的扩展函数的例子:</p><pre class="kl km kn ko gt kw kx ky kz aw la bi"><span id="3cda" class="lb lc in kx b gy ld le l lf lg">fun Int.square() = this * this</span><span id="13cd" class="lb lc in kx b gy lh le l lf lg">// Usage<br/>println(2.square()) // Prints: 4</span></pre><p id="c0a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277">告诉</a>带有<code class="fe li lj lk kx b">Int</code>的参数被传递给函数的<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277"> <strong class="jm io">扩展接收器</strong> </a>，<code class="fe li lj lk kx b">this</code>或者隐式调用对它的引用。如果我们需要将这个函数与<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">属性</a>相关联，那么我们可以使用<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">函数引用</a>:</p><pre class="kl km kn ko gt kw kx ky kz aw la bi"><span id="f5b0" class="lb lc in kx b gy ld le l lf lg"><strong class="kx io">val </strong>squareFun: Int.()-&gt;Int = Int::square</span></pre><p id="3eca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用的<code class="fe li lj lk kx b">Int.()-&gt;Int</code>是带有接收器的<strong class="jm io">函数类型。除了使用函数引用，我们可以使用带有接收者</strong> 的<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e"> <strong class="jm io">函数来定义函数。这就是我们如何使用<strong class="jm io"> lambda表达式和接收者</strong>来定义它</strong></a></p><pre class="kl km kn ko gt kw kx ky kz aw la bi"><span id="9595" class="lb lc in kx b gy ld le l lf lg"><strong class="kx io">val </strong>squareFun: Int.()-&gt;Int = { this * this }</span></pre><p id="0d85" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是我们如何使用带有接收者的<strong class="jm io">匿名函数来定义它:</strong></p><pre class="kl km kn ko gt kw kx ky kz aw la bi"><span id="575e" class="lb lc in kx b gy ld le l lf lg"><strong class="kx io">val </strong>squareFun: Int.()-&gt;Int = <strong class="kx io">fun </strong>Int.() = <strong class="kx io">this </strong>* <strong class="kx io">this</strong></span></pre><p id="521c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，带有接收者的<strong class="jm io">匿名函数与标准<strong class="jm io">匿名函数</strong>具有不同的符号，因此当使用它时，可以推断出属性或变量类型:</strong></p><pre class="kl km kn ko gt kw kx ky kz aw la bi"><span id="170f" class="lb lc in kx b gy ld le l lf lg"><strong class="kx io">val </strong>squareFun = <strong class="kx io">fun </strong>Int.() = <strong class="kx io">this </strong>* <strong class="kx io">this</strong></span></pre><p id="abfb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">带有接收方</strong>的Lambda表达式没有这样的能力，所以它需要显式类型声明:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/92e2b8772349d371b56f5020b2a76608.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*aS0BJznLdrCOzRPF0GO4FA.png"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Error because lambda expression does not have receiver by default and this is not allowed in this context (there is no <a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c">implicit receiver</a>)</figcaption></figure><p id="bb25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">带接收器的Lambda表达式在Kotlin中非常重要，因为它在Kotlin DSL中被大量使用。下面是一个使用不同处理程序定义监听器的DSL示例:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi gj"><img src="../Images/74882a558a8dcd825d9bea63e1d20ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQlGGdiykOcsHfeKpusRFA.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">This listener creation was introduced and described in <a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/cleaning-up-android-project-using-kotlin-7265b24901">Cleaning up Android project using Kotlin</a></figcaption></figure><p id="6103" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于这个事实，我们可以使用带有接收者的<strong class="jm io">函数类型和带有接收者</strong>的<strong class="jm io"> lambda表达式，我们可以严格指定可以定义什么处理程序(这里是<code class="fe li lj lk kx b">onChildAdded</code>或<code class="fe li lj lk kx b">onCancelled</code>)以及我们如何定义它们。<code class="fe li lj lk kx b">childEventListener</code>的实现可以在<a class="ae ki" href="https://gist.github.com/MarcinMoskala/db8e182ecc526868149114fc6d088bd9" rel="noopener ugc nofollow" target="_blank">这个要诀</a>上找到。</strong></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><a href="https://www.kt.academy/#workshops-offer"><div class="gh gi lq"><img src="../Images/018370a2476e1ce49e6d3299428b4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-f1laplrjQQAMlYKfLgHw.png"/></div></a></figure></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="6324" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个帖子是<a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-2cb67fff1fe2" rel="noopener">科特林程序员词典</a>的<a class="ae ki" href="https://pl.bab.la/slownik/angielski-polski/thirteenth" rel="noopener ugc nofollow" target="_blank">第十三</a>部分。要了解最新的新部件，只需关注此媒体或<a class="ae ki" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank">在Twitter上观察我</a>。如果你需要帮助，记得<a class="ae ki" href="https://medium.com/@marcinmoskala/ive-just-opened-up-for-online-consultations-640349aaba55" rel="noopener">我随时欢迎咨询</a>。</p><p id="51e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">喜欢的话记得<strong class="jm io">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi ly"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="8d02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是《科特林程序员词典》的其他部分:</p><ul class=""><li id="f8a1" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">形参vs实参，类型形参vs类型实参</a></li><li id="1953" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0" rel="noopener">语句vs表达式</a></li><li id="2a4f" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">功能vs方法vs程序</a></li><li id="d41a" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">属性对字段</a></li><li id="84df" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类vs类型vs对象</a></li><li id="795a" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b">对象表达式vs对象声明</a></li><li id="fb03" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-b085b1620890">接收器</a></li><li id="4dc6" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c">隐式接收者vs显式接收者</a></li><li id="7a6f" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277">分机接收机vs调度接收机</a></li><li id="c987" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-type-vs-receiver-object-575d2705ddd9">接收器类型与接收器对象</a></li><li id="8277" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">函数类型vs函数文字vs Lambda表达式vs匿名函数</a></li><li id="304d" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-higher-order-function-9cadb07df94e">程序员字典:高阶函数</a></li><li id="2ac3" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-generics-variance-modifiers-36b82c7caa39">不变性vs协方差vs逆变</a></li><li id="f053" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-event-listener-vs-event-handler-305c667d0e3c">事件监听器vs事件处理器</a></li><li id="3f26" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-delegation-vs-composition-3025d9e8ae3d">代表团vs组成</a></li></ul><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mn"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>