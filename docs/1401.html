<html>
<head>
<title>Automating NoSQL Database Builds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动化NoSQL数据库构建</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/automating-nosql-database-builds-a-python-to-the-rescue-story-that-never-gets-old-1d9adbcf6792?source=collection_archive---------1-----------------------#2016-07-20">https://medium.com/capital-one-tech/automating-nosql-database-builds-a-python-to-the-rescue-story-that-never-gets-old-1d9adbcf6792?source=collection_archive---------1-----------------------#2016-07-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="e15a" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">一个永不过时的“蟒蛇拯救”故事</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/3132b4183b594b6cd72a267a8597a803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANp11Tl5OPfWGD3rxSVVPw.jpeg"/></div></div></figure><p id="2d99" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">这种感觉</em>当您的应用程序如此之大，如此重要，以至于您知道存储需求很快就会急剧增长。<em class="ke">“这个‘庞大’的分析工具将同时受到另一项业务、一项收购和强劲的有机增长的冲击。哦，翻倍的时间缩短了一半。”</em>看起来有人需要建立新的数据库服务器群。</p><p id="82fe" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从远处看，在这种情况下提供NoSQL数据库服务器群的想法似乎非常简单。<strong class="jk hi">分配服务器。分配存储。构建软件。完成满足企业标准、信息安全标准和生产支持标准所需的所有其他数据库配置。</strong> <em class="ke"> </em>这不就是DevOps的意义所在吗？只是<em class="ke">“嘿！转眼间。数据库！”</em>对吧？</p><p id="a68a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，当我们深究细节时，事情就没那么简单了。是的，这将会变成一个<em class="ke">“蟒蛇营救”</em>的故事。</p><h2 id="8038" class="kf kg hh bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz bi translated">涉及到什么？不，真的吗？</h2><p id="1257" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc kd ha bi translated">提供数据库服务器场的基本框架需要多种资源。最重要的资源是耐心。这些往往是具有大量磁盘存储的大型服务器。(30Gb至60Gb内存。)对于一些数据库——比如Cassandra——串行构建节点似乎是最明智的。在这种情况下，第一个和最后一个节点的处理方式与其他节点不同，第一个节点包含其他节点需要的种子信息。因此，似乎最简单的方法是避免构建数据库细节，直到所有节点都构建好，并且可以开始共享角色、用户和其他定义。这拖延了构建下一个版本<em class="ke">“cyclo pean数据库”的时间</em></p><p id="8ef6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从抽象的角度来看，我们将做以下事情来创建服务器场的每个单独的节点:</p><p id="1e41" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> 1。</strong> <strong class="jk hi">从供应服务器运行一个Chef recipe来构建每个节点。</strong></p><p id="6804" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> 2。</strong> <strong class="jk hi">更新域名。</strong></p><p id="58a1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> 3。在任何用于跟踪资产的配置管理数据库中创建条目。</strong></p><p id="e378" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> 4。</strong> <strong class="jk hi">计划备份(如果相关。)</strong></p><p id="8270" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这大部分只是API调用；它们非常简单，尤其是在Python 3中。厨师食谱问题是真正的工作出现的地方。我们需要在使用简单的Chef脚本和保持灵活性之间取得适当的平衡。此外，配方需要有足够的参数，这样我们就可以避免每次在我们构建的东西有变化的时候调整它们。</p><p id="539a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">问题是环境设置的变化速度很快，因为这些不是一般的安装:它们是为我们的企业需求定制的。昨天的企业最佳实践是今天“勉强够好”的实践。我们不想不断调整主厨的食谱。一个替代解决方案是动态收集数据。但是，动态收集数据的方法意味着我们可能很难恢复动态数据来重建现有的服务器。</p><p id="23e5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="ke">中间地带在哪里？</em>T3】</strong></p><h2 id="44ae" class="kf kg hh bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz bi translated">寻找灵活性</h2><p id="f987" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc kd ha bi translated">构建Chef食谱迫使我们看到有大量的参数驱动着Chef。如此之多，以至于我们需要外部工具来收集数据，并用它来构建有用的东西。这些参数分为几个部分:</p><p id="4cbd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">——<strong class="jk hi">用户必须提供的东西。</strong>应用程序名称(“Cyclopean”)。估计大小(“1Tb”)。他们的业务线和成本中心信息。显然，这推动了数据库构建请求。</p><p id="b806" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">- <strong class="jk hi">企业需要提供的东西。</strong>云配置详情、子网、其他公司级详情。其中一些配置细节经常变化。有API可以检索其中一些。在Chef菜谱中进行这些查找似乎是错误的，因为菜谱变成了动态的，并且失去了它的幂等性。</p><p id="96eb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">- <strong class="jk hi">数据库工程师需要定义的东西。</strong>命名约定、存储首选项、规模计算和其他环境细节。这可能是厨师食谱本身的一部分。</p><p id="fd98" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">- <strong class="jk hi">每个数据库产品特有的东西。</strong>例如，定义用户、角色、权限、企业LDAP连接的独特方式。我们需要灵活性，让这因业务线而异。与其创建许多不同的配方，我们更愿意将它作为构建的整个参数集合的一部分。</p><p id="c971" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">- <strong class="jk hi">简单的文字值，但会比菜谱需要更改的次数更多。</strong>例如，分发套件的版本号将会改变，但需要参数化。厨师属性已经提供了令人愉快的处理方式。15步属性优先表显示了配方如何提供默认属性，属性文件如何提供值，以及环境如何覆盖这些值。</p><p id="c2ed" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们的目标是尽量减少对主厨食谱的调整，经验表明这涉及到很多参数。对于我们的一些NoSQL数据库安装方法，这可能多达200个不同的值。</p><p id="01df" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Python为我们提供了一种从各种来源收集数据并构建必要的属性和配置选项的简便方法，以便使用相对稳定的Chef食谱。<strong class="jk hi"> <em class="ke">(还记得我们在介绍中说过这会成为一个“Python拯救”的故事吗？)</em> </strong>想法是用厨师菜谱缓存参数，让我们随时重建任意节点。拥有一个静态模板文件为我们提供了所需的幂等性。</p><p id="7682" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下一个要解决的问题是设计Python应用程序，使其能够支持可重复但灵活的构建。</p><h2 id="a658" class="kf kg hh bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz bi translated">使用Python字典的天真设计</h2><p id="9640" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc kd ha bi translated">先说Python吧。配方的参数可以序列化为一个大的JSON(或YAML)文档。如果我们创建一个字典中的字典结构，Python使得这变得非常简单，这可以很容易地序列化为JSON/YAML文件。(这是一个“json.dump(object，file)”级别的琐碎。)</p><p id="7cb4" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们如何建立这本字典中的字典？</p><p id="e0a1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们以存储定义为例。我们的主厨食谱中需要一些参数。细节包括一些计算和文字。我们可以试试这个:</p><pre class="ix iy iz ja fd lf lg lh li aw lj bi"><span id="60d8" class="kf kg hh lg b fi lk ll l lm ln">storage = {<br/>    'devices': [ <br/>        'device_name': '/dev/xvdz',<br/>        'configuration': {<br/>            'volume_type': get_volume_type(),<br/>            'iops': get_iops(),<br/>            'delete_on_termination': True,<br/>            'volume_size': get_volume_size(),<br/>            'snapshot_id': get_snapshot_id(get_line_of_business()),<br/>        }<br/>    ]<br/>}</span></pre><p id="ce3e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">强调词<strong class="jk hi">【尝试】</strong>。</p><p id="94c5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这将构建一个整洁的字典-字典数据结构。细节由获取和计算值的函数填充。为了一致性，我们甚至可以将文字值包装成函数，使所有参数更加一致:</p><pre class="ix iy iz ja fd lf lg lh li aw lj bi"><span id="8473" class="kf kg hh lg b fi lk ll l lm ln">def device_name():<br/> return ‘/dev/xvdz’</span></pre><p id="52f8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">问题是这些函数要么有许多参数，要么被迫使用全局变量。事实证明，配置信息有许多外部来源。将它们都作为参数传递是不方便的；每个函数都需要一个配置名称空间对象。</p><p id="e925" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">一些计算是有状态的。举个具体的例子，考虑一个在数据中心和机架之间分配数据库节点的循环算法:每个节点的分配都会导致全局变量的更新。像这样有副作用的函数是一个令人头疼的设计问题，也是一个单元测试的噩梦。</p><h2 id="670a" class="kf kg hh bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz bi translated">声明性Python</h2><p id="10ca" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc kd ha bi translated">我们如何提供一种更好的方法来使用参数而不是全局变量？我们如何让有状态的对象填充我们的模板呢？</p><p id="644a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们的答案是使用声明式编程风格。我们可以——不做任何实质性的工作——使用Python类定义创建一种特定于领域的语言。这个想法是构建懒惰对象，它将在需要时发出值。</p><p id="cb08" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">继续以存储为例，该方法如下所示:</p><pre class="ix iy iz ja fd lf lg lh li aw lj bi"><span id="bf6d" class="kf kg hh lg b fi lk ll l lm ln">class Storage(Template):<br/>    device_name = Literal("/dev/xvdz")<br/>    configuration = Document(<br/>        volume_size = VolumeSizeItem("/dev/xvdz", Request('size'),<br/>        "volume_size", conversion=int),<br/>        snapshot_id = ResourceProfileItem(Request('lob'),<br/>            Request('env'), Request('dc'), "Snapshot"),<br/>        delete_on_termination = Literal(True),<br/>        volume_type = ResourceProfileItem (Request('lob'),<br/>            Request('env'), Request('dc'), "VolumeType"),<br/>        iops = ResourceProfileItem (Request('lob'),<br/>            Request('env'), Request('dc'), "IOPS", conversion=int)<br/>)</span></pre><p id="50a1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">为此，细节由帮助构建JSON配置对象的类的实例和填充配置对象中的项目的类的实例创建。这些类有一个层次结构，提供不同种类的值和计算。它们都是基本项目类的扩展。</p><p id="ee1c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们的想法是构建一个模板类的实例，其中包含所有复杂的数据，这些数据需要组装并导出为一个大的JSON文档，供厨师菜谱使用。微妙之处在于，我们希望保留属性显示的顺序。这不是一个<em class="ke">要求</em>，但是如果JSON与Python匹配，阅读起来就容易多了。</p><p id="96ae" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">此外，我们需要稍微扩展Python的继承模型，以便Template的每个子类都有自己属性的具体列表，以及父属性。这也使得调试输出更加容易。</p><p id="242b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们将调整模板的元类定义来提供这些额外的特性。看起来是这样的:</p><pre class="ix iy iz ja fd lf lg lh li aw lj bi"><span id="941b" class="kf kg hh lg b fi lk ll l lm ln"><strong class="lg hi">class TemplateMeta</strong>(type):<br/>    @classmethod<br/>    <strong class="lg hi">def __prepare__</strong>(metaclass, name, bases):<br/>    """<em class="ke">Changes the internal dictionary to a :class:`bson.SON` object."""</em><br/>        <strong class="lg hi">return </strong>SON()<br/> <br/>    <strong class="lg hi">def </strong>__new__(cls, name, bases, kwds):<br/>    """<em class="ke">Create a new instance by merging attribute names.</em><br/>       <em class="ke">Sets the ``_attr_order`` to be parent attributes + child attributes.</em><br/>    """<br/>    local_attr_list = [a_name<br/>        <strong class="lg hi">for </strong>a_name <strong class="lg hi">in </strong>kwds<br/>            <strong class="lg hi">if </strong>isinstance(kwds[a_name], Item)]<br/>    parent_attr_list = []<br/>    <strong class="lg hi">for </strong>b <strong class="lg hi">in </strong>bases:<br/>        parent_attr_list.extend(b._attr_order)<br/>    <strong class="lg hi">for </strong>name <strong class="lg hi">in </strong>local_attr_list:<br/>        <strong class="lg hi">if </strong>name <strong class="lg hi">not in </strong>parent_attr_list:<br/>            parent_attr_list.append(name)<br/>    kwds['_attr_order'] = parent_attr_list<br/>    <strong class="lg hi">return </strong>super(TemplateMeta, cls).__new__(cls, name, bases, kwds)</span></pre><p id="9960" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">元类用bson替换类级__dict__对象。儿子反对。(是的，我们大量使用Mongo。)SON对象保留了键条目顺序信息，非常类似于Python的原生OrderedDict。</p><p id="4039" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">元类定义还构建了一个额外的类级属性_attr_order，它提供了这个Template子类及其所有父类的完整属性列表。顺序总是从父属性开始。注意，我们不依赖于所有提供_attr_order属性的父节点；我们实际上搜索了每个父类，以确保我们已经找到了所有的东西。</p><p id="e4f7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">模板的substitute()方法收集所有需要的数据。我们可以在这里生成JSON数据，我们更愿意等到请求输出时再生成。</p><pre class="ix iy iz ja fd lf lg lh li aw lj bi"><span id="f084" class="kf kg hh lg b fi lk ll l lm ln"><strong class="lg hi">def substitute</strong>(self, sourceContainer, request, **kw):<br/>    self._source = sourceContainer<br/>    self._request = request.copy()<br/>    self._request.update(kw)<br/>    <strong class="lg hi">return </strong>self</span></pre><p id="4661" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">构建数据的参数来自三个地方:包含所有各种配置文件的sourceContainer、指定下一版本“Cyclopean”有多少节点的详细信息的初始请求，以及可能出现的任何关键字覆盖。</p><p id="e094" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当模板作为用JSON表示法序列化的SON对象发出时，输出就出现了。</p><pre class="ix iy iz ja fd lf lg lh li aw lj bi"><span id="5f1d" class="kf kg hh lg b fi lk ll l lm ln"><strong class="lg hi">def to_dict</strong>(self):<br/>    result = SON()<br/>    <strong class="lg hi">for </strong>key <strong class="lg hi">in </strong>self._attr_order:<br/>        item = getattr(self.__class__, key)<br/>        value = item.get(self._source, self._request)<br/>        i<strong class="lg hi">f </strong>value <strong class="lg hi">is not None</strong>:<br/>            result[key]= value<br/>    <strong class="lg hi">return </strong>result</span></pre><p id="7879" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">所有填充属性的条目实例都有一个通用的get()方法来执行任何计算。这也可以更新该项目的任何内部状态。模板遍历所有的条目，计算get()。</p><p id="4e86" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">每个Item对象的get()方法被赋予配置细节。模板没有自由浮动的全局变量，而是有一个严格定义的配置细节的简短列表；这些被提供给每个单独的项目。</p><p id="a90b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这避免了依赖(可能模糊的)全局变量集合。奖金！因为它们是对象，有状态计算不包括更新全局变量的可怕技术。状态可以封装在项目实例中。单元测试进行得很好，因为每一项都可以单独测试。</p><p id="ce89" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这给了我们一些高度可测试的东西，并不比天真的设计复杂多少。我们可以有一个稳定，简单的厨师食谱。为Chef准备值的所有查找和计算都在我们的Python应用程序中。具体来说，它们被隔离在Item子类和模板的定义中。</p><h2 id="11a0" class="kf kg hh bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz bi translated">Python的价值</h2><p id="f450" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc kd ha bi translated">Python为我们工作有两个原因:</p><p id="1342" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> 1。灵活性。</strong></p><p id="ba37" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> 2。和灵活性。</strong></p><p id="f443" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">首先，我们可以灵活地修改用于Chef供应的JSON文档。Chef脚本调试起来很累，因为每次我们测试一个脚本时，似乎都要花很长时间来配置一个节点。作为Chef recipe输入的文档可以通过单元测试来定义，在做出更改后，运行测试套件只需不到一秒钟的时间。每一个新想法都可以很快得到检验。</p><p id="3849" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">例如，考虑改变企业分配子网的方式。昨天，“Cyclopean”在一个子网上，生活很好。现在它变得越来越大，它必须被移动，数据库从网络服务器中分离出来。子网的规范从简单的Item子类变成了基于环境和服务器目的的复杂查找。</p><p id="34f8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们以前有这样的:</p><pre class="ix iy iz ja fd lf lg lh li aw lj bi"><span id="a371" class="kf kg hh lg b fi lk ll l lm ln">class SubnetTemplate(Template):<br/>    subnet_id = Literal('name of net')</span></pre><p id="485f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在我们有了这个:</p><pre class="ix iy iz ja fd lf lg lh li aw lj bi"><span id="7cdc" class="kf kg hh lg b fi lk ll l lm ln">class Expanded_SubnetTemplate(Template):<br/>    subnet_id = ResourceProfileField(Request('env'),<br/>        Request('purpose'), 'Subnet')</span></pre><p id="cc54" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，这一变化对厨师的食谱没有任何影响。它在配置文件中添加了一些细节，并对这些文件进行了一些额外的查找。我们可以快速设计和单元测试变更。</p><p id="57dd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">其次，我们可以灵活地将所有配置步骤集成到一个统一的框架中。很多工作都是通过RESTful API完成的。使用Python 3和新的urllib使这变得相对简单。针对不同云供应商的附加库符合Python扩展模块的世界观，可以解决独特的问题。</p><p id="f458" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们为此使用了一个<strong class="jk hi">命令</strong>设计模式。构建过程中的每一步都是NodeCommand的子类。</p><pre class="ix iy iz ja fd lf lg lh li aw lj bi"><span id="f29f" class="kf kg hh lg b fi lk ll l lm ln"><strong class="lg hi">class NodeCommand</strong>:<br/>    """<em class="ke">Abstract superclass for all commands related to building a node.<br/>    """<br/>    </em><strong class="lg hi">def </strong>__init__(self):<br/>        self.logger = logging.getLogger(self.__class__.__name__)<br/> <br/>    <strong class="lg hi">def </strong>__repr__(self):<br/>        <strong class="lg hi">return </strong>self.__class__.__name__<br/> <br/>    <strong class="lg hi">def execute</strong>(self, configuration, build, node_number):<br/>        """<em class="ke">Executes command, returns a dictionary with 'status', <br/>           'log'.<br/> <br/>        Sources for some parameters::<br/> <br/>        build_id = build[‘_id’]<br/>        node = build[‘nodes’][node_number]<br/> <br/>        </em><strong class="lg hi"><em class="ke">:param</em></strong><em class="ke"> configuration: Global configuration<br/>        </em><strong class="lg hi"><em class="ke">:param</em></strong><em class="ke"> build: overall :class:`dbbuilder.model.Build` <br/>               document<br/>        </em><strong class="lg hi"><em class="ke">:param</em></strong><em class="ke"> node_number: number for the node within the sequence <br/>               of nodes<br/>        </em><strong class="lg hi"><em class="ke">:returns</em></strong><em class="ke">: dictionary with final status information plus any <br/>                  additional details created by this command.<br/>       """<br/>       </em><strong class="lg hi">raise </strong>NotImplementedError</span></pre><p id="466a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">NodeCommand最重要的子类之一是ChefCommand，它使用所有正确的参数执行chef供应脚本。</p><p id="bd62" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用多个命令实例意味着我们可以——通过简单的导入——将许多功能打包到一个高级Python脚本中。集成并不止于此。供应自动化引擎通过Flask容器提供。import语句让Flask容器向任何能够编写curl请求或简短Python脚本的内部客户提供复杂的批处理脚本功能。</p><h2 id="91b8" class="kf kg hh bd kh ki kj kk kl km kn ko kp jr kq kr ks jv kt ku kv jz kw kx ky kz bi translated">蟒蛇来了</h2><p id="68dd" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc kd ha bi translated"><em class="ke">那种感觉</em>当您的应用程序如此之大，如此重要，以至于您知道存储需求很快就会急剧增长…</p><p id="03f6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们认为我们已经找到了一种方法，以代码包的形式直接向业务线提供高级TechOps服务，以及RESTful web服务。我们认为Python是满足大规模构建NoSQL数据库的业务需求不可或缺的一部分。</p><p id="a98b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们尝试直接使用Chef，但是我们想要比这个工具更灵活的功能。不断调整方案的想法并不像拥有一个可以可靠地重建任何服务器的工具的最佳方式。</p><p id="85ea" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们试图使用相对简单的Python创建Chef参数，但是这导致了太多的全局变量和太多的显式函数参数。这成了单元测试噩梦。</p><p id="9419" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">喘过气后，我们意识到我们需要的是一种声明式的编程风格。我们没有发明新的DSL，我们只是根据我们的需要修改了Python现有的语法。一个简单的类结构和一个元类定义为我们提供了构建配置参数文件所需的一切。</p><p id="cb04" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，我们可以为“Cyclopean”的下一个版本创建巨大的服务器群。</p></div><div class="ab cl lo lp go lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ha hb hc hd he"><p id="67c1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">要了解更多关于Capital One的API、开源、社区活动和开发人员文化的信息，请访问我们的一站式开发人员门户网站DevExchange。<a class="ae lv" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><em class="ke"/></a></p></div></div>    
</body>
</html>