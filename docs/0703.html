<html>
<head>
<title>Unbundling the stable WindowManager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解开稳定的窗口管理器</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/unbundling-the-stable-windowmanager-a5471ff2907?source=collection_archive---------5-----------------------#2022-02-17">https://medium.com/androiddevelopers/unbundling-the-stable-windowmanager-a5471ff2907?source=collection_archive---------5-----------------------#2022-02-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/e7656fe7b6859c06065a474d6398e43a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dIXjHF8_-47CvYTb.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by Ocupop</figcaption></figure><div class=""/><p id="d619" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Jetpack WindowManager 1.0.0稳定！</p><p id="e412" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为了支持开发人员为可折叠设备构建应用程序，我们在2019年2月推出了我们的第一个alpha版本<a class="ae jr" href="https://developer.android.com/jetpack/androidx/releases/window" rel="noopener ugc nofollow" target="_blank"> Jetpack WindowManager </a>。从那时起，这个库已经发展到包括<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/androidx/window/layout/WindowMetrics" rel="noopener ugc nofollow" target="_blank">WindowMetrics</a></code>信息和对<a class="ae jr" href="https://developer.android.com/guide/topics/large-screens/activity-embedding" rel="noopener ugc nofollow" target="_blank">活动嵌入</a>的实验支持。</p><p id="7959" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这只是开始！我们对这个图书馆有很好的计划，作为在所有类型的大屏幕设备上获得惊人体验的基础。</p><h1 id="b0bc" class="jw jx hw bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">用于可折叠设备的稳定支撑</h1><p id="eec7" class="pw-post-body-paragraph it iu hw iv b iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq ha bi translated">为了支持可折叠设备，Jetpack WindowManager提供了<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/androidx/window/layout/DisplayFeature" rel="noopener ugc nofollow" target="_blank">DisplayFeature</a></code>接口及其<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/androidx/window/layout/FoldingFeature" rel="noopener ugc nofollow" target="_blank">FoldingFeature</a></code>实现，该实现提供了诸如铰链的<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/androidx/window/layout/FoldingFeature#orientation()" rel="noopener ugc nofollow" target="_blank">orientation</a></code>和<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/androidx/window/layout/FoldingFeature#state()" rel="noopener ugc nofollow" target="_blank">state</a></code>之类的信息:</p><figure class="la lb lc ld fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kz"><img src="../Images/47c3158335f36c95efdf926d6a126d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3xTX4RyE2oAfyIsHLGn4A.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Sample state for <code class="du js jt ju jv b">FoldingFeature</code> instances</figcaption></figure><p id="b997" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">应用程序可以通过<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/androidx/window/layout/WindowLayoutInfo" rel="noopener ugc nofollow" target="_blank">WindowInfoLayout</a></code>对象注册接收更新的状态信息。这可以通过不同的方式收集，具体取决于应用的架构:</p><ul class=""><li id="766b" class="le lf hw iv b iw ix ja jb je lg ji lh jm li jq lj lk ll lm bi translated">科特林协同流程</li><li id="a6c5" class="le lf hw iv b iw ln ja lo je lp ji lq jm lr jq lj lk ll lm bi translated">复试</li><li id="ca0e" class="le lf hw iv b iw ln ja lo je lp ji lq jm lr jq lj lk ll lm bi translated">RxJava可观察或可流动</li></ul><h1 id="9002" class="jw jx hw bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">图书馆文物</h1><p id="7f1a" class="pw-post-body-paragraph it iu hw iv b iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq ha bi translated">基础库是用Kotlin构建的，并使用与当前活动相关联的<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/kotlin/androidx/window/layout/WindowInfoTracker.Companion#getOrCreate(android.content.Context)" rel="noopener ugc nofollow" target="_blank">WindowInfoTracker</a></code>为Kotlin的协程流提供现成的支持:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Sample collection of WindowInfoLayout events</figcaption></figure><p id="9ac0" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">关于如何为Jetpack WindowManager设置正确的依赖关系的分步指南，您可以查看带有Jetpack window managercodelab的<a class="ae jr" href="https://developer.android.com/codelabs/android-window-manager-dual-screen-foldables?hl=en#3" rel="noopener ugc nofollow" target="_blank">支持可折叠和双屏设备。</a></p><p id="2f54" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">另外，如果您需要从基于Java的项目中使用库，可以使用<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/androidx/window/java/layout/WindowInfoTrackerCallbackAdapter" rel="noopener ugc nofollow" target="_blank">WindowInfoTrackerCallbackAdapter</a></code>。在这种情况下，<code class="du js jt ju jv b">WindowInfoLayout</code>事件是通过回调接收的:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Setup WindowLayoutInfo collection through callbacks — onCreate</figcaption></figure><p id="b920" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然后我们可以使用生命周期回调<code class="du js jt ju jv b">onStart</code>和<code class="du js jt ju jv b">onStop</code>来注册我们的<code class="du js jt ju jv b">WindowLayoutInfo</code>监听器:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Setup WindowLayoutInfo collection through callbacks — onStart and onStop</figcaption></figure><p id="804c" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">回调的一个示例实现可以是实现<code class="du js jt ju jv b">Consumer&lt;WindowLayoutInfo&gt;</code>接口的内部类:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Setup WindowLayoutInfo collection through callbacks</figcaption></figure><p id="9f46" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">文章<a class="ae jr" href="https://developer.android.com/guide/topics/large-screens/make-apps-fold-aware" rel="noopener ugc nofollow" target="_blank">让你的应用知道文件夹</a>介绍了如何使用这些API。一旦您添加了对可折叠设备的支持，您就可以使用文章<a class="ae jr" href="https://developer.android.com/guide/topics/large-screens/test-apps-on-foldables" rel="noopener ugc nofollow" target="_blank">在可折叠设备上测试您的应用</a>中描述的<code class="du js jt ju jv b">androidx.window.testing</code>工件来测试您的UI。</p><h1 id="6ed7" class="jw jx hw bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">支持响应性用户界面</h1><p id="ee1a" class="pw-post-body-paragraph it iu hw iv b iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq ha bi translated">由于Android上的屏幕尺寸经常变化，开始设计完全响应和自适应的用户界面很重要。WindowManager库中包含的另一个特性是检索当前和最大窗口度量信息的能力。这类似于API级别30中包含的框架<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/android/view/WindowMetrics" rel="noopener ugc nofollow" target="_blank">WindowMetrics</a></code> API提供的信息，但是它向下向后兼容到API级别14。</p><p id="a048" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Jetpack WindowManager包含了用于检索这些信息的<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/androidx/window/layout/WindowMetricsCalculator" rel="noopener ugc nofollow" target="_blank">WindowMetricsCalculator</a></code>类:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">WindowMetricsCalculator — current and maximum</figcaption></figure><blockquote class="lu lv lw"><p id="6d58" class="it iu lx iv b iw ix iy iz ja jb jc jd ly jf jg jh lz jj jk jl ma jn jo jp jq ha bi translated"><strong class="iv hx">注意:</strong>如果您过去使用过这个库(直到beta02)，您可能已经使用过<code class="du js jt ju jv b">WindowMetrics</code>流来收集窗口大小变化事件。我们已经删除了这个API，因为我们遇到了一些可靠性问题。我们将在未来重新审视这一决定。</p></blockquote><p id="2dd8" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您的应用程序需要监控窗口大小的所有变化，最好的方法是使用一个<code class="du js jt ju jv b">View.onConfigurationChanged</code>监听器。我们不能使用<code class="du js jt ju jv b">Activity.onConfigurationChanged</code>，因为有些情况下，当配置改变时，它不会被调用。</p><p id="a3d6" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您还可以在容器中添加一个实用视图，并在您的<code class="du js jt ju jv b">Activity.onCreate</code>方法中附加这个监听器:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">WindowMetrics — View.onConfigurationChanged workaround</figcaption></figure><blockquote class="lu lv lw"><p id="1821" class="it iu lx iv b iw ix iy iz ja jb jc jd ly jf jg jh lz jj jk jl ma jn jo jp jq ha bi translated"><strong class="iv hx">注意:</strong>即使您的活动不处理配置更改，如果您对正确的窗口尺寸感兴趣，我们建议您注册一个<code class="du js jt ju jv b">View.onConfigurationChanged</code>监听器，因为在某些情况下，窗口大小可能会在您的活动不重新启动的情况下发生变化。</p></blockquote><h1 id="403b" class="jw jx hw bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">Jetpack WindowManager是响应式用户界面的基础</h1><p id="f340" class="pw-post-body-paragraph it iu hw iv b iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq ha bi translated">Jetpack WindowManager可以直接集成到您的应用程序中，但它也是更高级组件和库的构建块。</p><p id="2f53" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在Jetpack中，我们已经有了三个包含WindowManager的库，随着今天第一个稳定版本的发布，我们将为所有这些库发布稳定版本:</p><ul class=""><li id="b41a" class="le lf hw iv b iw ix ja jb je lg ji lh jm li jq lj lk ll lm bi translated"><a class="ae jr" href="https://d.android.com/jetpack/androidx/releases/slidingpanelayout#1.2.0" rel="noopener ugc nofollow" target="_blank">滑动面板布局1.2.0 </a></li><li id="39a0" class="le lf hw iv b iw ln ja lo je lp ji lq jm lr jq lj lk ll lm bi translated"><a class="ae jr" href="https://developer.android.com/jetpack/androidx/releases/navigation#2.4.0" rel="noopener ugc nofollow" target="_blank">导航2.4.0 </a></li><li id="0a90" class="le lf hw iv b iw ln ja lo je lp ji lq jm lr jq lj lk ll lm bi translated"><a class="ae jr" href="https://d.android.com/jetpack/androidx/releases/preference#1.2.0" rel="noopener ugc nofollow" target="_blank">首选项1.2.0 </a></li></ul><p id="31e5" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">作为补充，<code class="du js jt ju jv b">SlidingPaneLayout</code>组件支持在较大的设备和可折叠设备上并排显示两个窗格，同时自动适应在较小的设备(如手机)上一次只显示一个窗格。</p><figure class="la lb lc ld fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mb"><img src="../Images/f2c9b81a1c1f37b26f9d832e907d6411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qLlinMUk3VJFsdXj"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">SlidingPaneLayout sample</figcaption></figure><h1 id="1554" class="jw jx hw bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">支持基于活动的应用程序</h1><p id="71c7" class="pw-post-body-paragraph it iu hw iv b iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq ha bi translated">去年，我们从开发人员那里收集了许多关于将现有应用程序应用于大屏幕设备所面临的挑战的反馈，其中最大的担忧来自于开发代码库的开发人员仍然严重依赖于多种活动。在这种情况下，采用一个处理片段的解决方案(比如<code class="du js jt ju jv b">SlidingPaneLayout</code>)或者迁移到Compose，可能需要大量的工作。</p><p id="97a8" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为此，我们研究了在屏幕上并排显示两个活动的可能性。这项研究最终在Android 12的12L功能下降中提供了一个新功能，通过新的Jetpack WindowManager实验API暴露出来，允许开发人员在屏幕上并排显示两个活动。</p><p id="66e7" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这种情况下的主要需求是一个新的XML配置，在最简单的情况下，如果窗口足够大，它会指定一个主要活动和一个辅助活动放在屏幕上:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Split configuration</figcaption></figure><p id="eb94" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">600dp的最小宽度是<a class="ae jr" href="https://m3.material.io/foundations/adaptive-design/large-screens/overview" rel="noopener ugc nofollow" target="_blank"> Material Design </a>的推荐值，以确保在通用设备尺寸上有足够的空间用于两种活动。</p><p id="2cd7" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">另一个必需的步骤是初始化Jetpack WindowManager的<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/androidx/window/embedding/SplitController" rel="noopener ugc nofollow" target="_blank">SplitController</a></code>。</p><p id="5b3c" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为此，我们可以使用<a class="ae jr" href="https://developer.android.com/jetpack/androidx/releases/startup" rel="noopener ugc nofollow" target="_blank"> Jetpack Startup </a>在应用程序的其他组件加载和活动开始之前执行初始化。</p><p id="edb0" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">要启用初始化，请执行以下操作:</p><ol class=""><li id="b398" class="le lf hw iv b iw ix ja jb je lg ji lh jm li jq mc lk ll lm bi translated">添加库依赖项</li></ol><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Activity embedding — dependencies</figcaption></figure><p id="66de" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">2.通知库我们在<code class="du js jt ju jv b">AndroidManifest.xml</code>中的初始化器</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Activity embedding — Initialization provider</figcaption></figure><p id="707d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">3.实现SplitController初始化器</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Activity embedding — SplitController initialization</figcaption></figure><p id="72fa" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您可以查看<a class="ae jr" href="https://developer.android.com/guide/topics/large-screens/activity-embedding" rel="noopener ugc nofollow" target="_blank">活动嵌入</a>指南，了解所有可用的特性。</p><p id="c2ad" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">活动嵌入是Android 12L (API level 32)的一项功能，但它将在一些早期平台版本的设备上可用。要在运行时检查特性的可用性，使用<code class="du js jt ju jv b"><a class="ae jr" href="https://developer.android.com/reference/androidx/window/embedding/SplitController#isSplitSupported()" rel="noopener ugc nofollow" target="_blank">SplitController.isSplitSupported()</a></code>方法:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Check for activity embedding availability</figcaption></figure><h1 id="774c" class="jw jx hw bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">查看它的运行情况:代码示例</h1><p id="87fc" class="pw-post-body-paragraph it iu hw iv b iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq ha bi translated">GitHub上最新的<a class="ae jr" href="https://github.com/android/user-interface-samples/tree/main/WindowManager" rel="noopener ugc nofollow" target="_blank">示例</a>展示了如何使用Jetpack WindowManager库来:</p><ul class=""><li id="4b08" class="le lf hw iv b iw ix ja jb je lg ji lh jm li jq lj lk ll lm bi translated">检索显示姿势信息</li><li id="f50a" class="le lf hw iv b iw ln ja lo je lp ji lq jm lr jq lj lk ll lm bi translated">从<code class="du js jt ju jv b">WindowLayoutInfo</code>流程中收集信息</li><li id="e30d" class="le lf hw iv b iw ln ja lo je lp ji lq jm lr jq lj lk ll lm bi translated">通过<code class="du js jt ju jv b">WindowInfoTrackerCallbackAdapter</code>注册回拨</li><li id="7b4b" class="le lf hw iv b iw ln ja lo je lp ji lq jm lr jq lj lk ll lm bi translated">尝试活动嵌入API</li></ul><p id="1c16" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">该示例还包括一些可以在任何设备或模拟器上运行的测试。</p><h1 id="b7bd" class="jw jx hw bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">在你的应用中采用WindowManager</h1><p id="a3b6" class="pw-post-body-paragraph it iu hw iv b iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ky jo jp jq ha bi translated">Jetpack WindowManager现在是稳定的，我们有一个很好的路线图来构建下一步，包括根据您的反馈改进活动嵌入API，添加窗口大小类API来标准化响应ui断点，等等。</p><p id="a18c" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们也很高兴看到Android社区采用Jetpack WindowManager作为其他库的基础，如微软的<a class="ae jr" href="https://devblogs.microsoft.com/surface-duo/jetpack-compose-windowstate-preview/" rel="noopener ugc nofollow" target="_blank"> WindowState </a>或Stream的<a class="ae jr" href="https://github.com/getStream/butterfly" rel="noopener ugc nofollow" target="_blank"> Butterfly </a>。</p><p id="c65f" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但是现在轮到你来构建惊人的折叠感知、响应的Android应用程序了！</p><p id="dfa9" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">访问<a class="ae jr" href="https://developer.android.com/large-screens" rel="noopener ugc nofollow" target="_blank">面向大屏幕开发的响应式布局</a>，了解更多关于优化可折叠和其他大屏幕设备的信息。</p></div></div>    
</body>
</html>