<html>
<head>
<title>Breaking up with your MonoRail</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">和你的单轨铁路分手</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/breaking-up-with-your-monorail-780927542097?source=collection_archive---------1-----------------------#2016-01-13">https://medium.com/square-corner-blog/breaking-up-with-your-monorail-780927542097?source=collection_archive---------1-----------------------#2016-01-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="f463" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">计划从一个完整的Rails应用程序中提取。</h2></div><p id="42c9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">由</em> <a class="jt ju ge" href="https://medium.com/u/a29cf9bf448c?source=post_page-----780927542097--------------------------------" rel="noopener" target="_blank">撰写<em class="js">扎克瑞</em> </a> <em class="js">。</em></p><blockquote class="jv"><p id="7fd2" class="jw jx hh bd jy jz ka kb kc kd ke jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae kf" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="5d39" class="pw-post-body-paragraph iw ix hh iy b iz kg ii jb jc kh il je jf ki jh ji jj kj jl jm jn kk jp jq jr ha bi translated">在Square，我在我们的支付可扩展性团队工作。2015年，我们的任务是通过从Square/Web中提取支付基础设施来实现支付基础设施的现代化，Square/Web是我们由单个MySQL实例支持的单片Rails应用程序。自2009年公司成立以来，Square/Web一直是处理交易的核心组件。</p><p id="eb4a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">认真的规划始于2014年底，当时我们已经开始触及运营管理的极限。</p><p id="b6ac" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们面临三种选择:</p><h1 id="0177" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">纵向扩展:购买更多磁盘</h1><p id="21fa" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">这需要花钱购买昂贵的企业闪存卡。纵向扩展是一种短期解决方案，随着时间的推移，跟上增长的成本会越来越高。从操作上来说，重建和备份大型数据库要困难得多。我们放弃了这个长期的选择。</p><h1 id="e124" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">横向扩展:Shard Square/Web的MySQL数据库</h1><p id="d7f7" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">除了管理单个MySQL实例，我们还可以对其进行分片以帮助水平扩展。我们评估了一些gem，如<a class="ae kf" href="https://github.com/tchandy/octopus" rel="noopener ugc nofollow" target="_blank"> Octopus </a>和<a class="ae kf" href="https://github.com/kovyrin/db-charmer" rel="noopener ugc nofollow" target="_blank"> db_charmer </a>，并构建了一个概念验证分片系统。我们决定改装分片将是更多的工作，并没有让我们远离简化整体；事实上，这让事情变得更加复杂。</p><h1 id="3934" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">打破僵局:从Square/Web上榨取全部报酬</h1><p id="e90b" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">这最终成为我们的首选方法。我们决定将Square/Web中的支付功能和数据提取到一个单独的服务中。这也符合Square避免使用独石的整体建筑哲学。</p><h1 id="90f6" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">搭建舞台</h1><p id="ebd0" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">虽然Square/Web已经多年没有处理收费支付，但Register应用程序的其他部分依赖它来处理交易数据。为了减少破坏任何东西的机会，我们需要把工作分成小块。下面，我将介绍我们如何在active record(Rail的ORM)之上构建一个中间API，然后逐步构建功能以脱离直接SQL调用。</p><p id="4943" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在构建中介API之前，我们需要弄清楚支付是如何被访问的。不幸的是，Rails并没有让审计查询变得非常容易，我们的monolith包含了大约100，000行Ruby代码，不包括200，000行测试。因此，我们创建了一个新的gem，<a class="ae kf" href="https://github.com/square/active_record-sql_analyzer" rel="noopener ugc nofollow" target="_blank">active _ record-sql _ analyzer</a>，它可以对来自Ruby的SQL查询和标记调用站点进行重复删除，以获得访问模式的概念。</p><p id="ca06" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们最初的运行给了我们一个500个不同SQL查询的列表，我们用它产生了7个protobuf APIs。这些最终成为我们新的支付搜索服务Spot的基础。我们选择用MySQL来支持它，用商户密钥来分片，因为我们知道我们的大多数访问模式都局限于单个商户。</p><h1 id="23c9" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">对数据库进行抽象</h1><p id="c0be" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">当我们编写SQL查询时，ActiveRecord的灵活性很好；当我们试图将它转换成protobuf API时，就没那么多了。我们还需要一个地方来传递电话，逐步推出新服务。</p><p id="983f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们想出了一个简单的抽象层，就像这样:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="198f" class="lr km hh ln b fi ls lt l lu lv"><em class="js"># This is a dramatic simplification from our actual code, but it’s a demonstration of concept.</em><br/><strong class="ln hi">module</strong> PaymentApi<br/>  <strong class="ln hi">class</strong> <strong class="ln hi">NotFoundError</strong> <strong class="ln hi">&lt;</strong> StandardError; <strong class="ln hi">end</strong></span><span id="74f7" class="lr km hh ln b fi lw lt l lu lv">  <strong class="ln hi">def</strong> <strong class="ln hi">self.lookup</strong>(payment_token: <strong class="ln hi">nil</strong>, includes: <strong class="ln hi">nil</strong>)<br/>    criteria <strong class="ln hi">=</strong> Payment<strong class="ln hi">.</strong>where(token: payment_token)<br/>    criteria <strong class="ln hi">=</strong> criteria<strong class="ln hi">.</strong>includes(includes)<br/>    <em class="js"># with_tag is provided by active_record-sql_analyzer</em><br/>    criteria<strong class="ln hi">.</strong>with_tag(:api)<strong class="ln hi">.</strong>first<br/>  <strong class="ln hi">end</strong></span><span id="1e72" class="lr km hh ln b fi lw lt l lu lv">  <strong class="ln hi">def</strong> <strong class="ln hi">self.lookup!</strong>(payment_token: <strong class="ln hi">nil</strong>, includes: <strong class="ln hi">nil</strong>)<br/>    payment <strong class="ln hi">=</strong> lookup(payment_token: payment_token, includes: includes)<br/>    <strong class="ln hi">raise</strong> NotFoundError, "Could not find payment #{payment_token}" <strong class="ln hi">unless</strong> payment</span><span id="6c4d" class="lr km hh ln b fi lw lt l lu lv">    payment<br/>  <strong class="ln hi">end</strong><br/><strong class="ln hi">end</strong></span></pre><p id="74c6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，我们可以开始将ActiveRecord调用移植到PaymentApi类，并将迁移调用站点的工作分配给多个工程师。</p><h1 id="1dbd" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">提取活动记录</h1><p id="8903" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">Spot通过RPC API返回protobufs，我们需要一种在protobufs支持的数据和MySQL支持的数据之间切换的方法，而不必重写每个调用站点。</p><p id="7e0c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们决定编写一个转换器，将ActiveRecord模型转换成Spot使用的protobuf，然后编写一个类，将ActiveRecord模型转换成proto buf。这不是最有效的，但是它给了我们Spot和ActiveRecord之间的一致性。</p><p id="0c7e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">扩展我们的<em class="js"> PaymentApi </em>类，我们添加了一个<em class="js"> PaymentApi::Converter </em>和<em class="js"> PaymentApi::Wrapper </em>:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="34ef" class="lr km hh ln b fi ls lt l lu lv"><em class="js"># This is a dramatic simplification from our actual code, but it’s a demonstration of concept.</em><br/><strong class="ln hi">class</strong> <strong class="ln hi">PaymentApi</strong><br/>  <strong class="ln hi">class</strong> <strong class="ln hi">Converter</strong><br/>    <strong class="ln hi">def</strong> <strong class="ln hi">to_proto</strong>(payment)<br/>      Proto<strong class="ln hi">::</strong>Spot<strong class="ln hi">::</strong>Payment<strong class="ln hi">.</strong>new(<br/>        card: {<br/>          auth: {<br/>            amount: payment<strong class="ln hi">.</strong>card_authorization<strong class="ln hi">.</strong>amount,<br/>            authed_at: payment<strong class="ln hi">.</strong>card_authorization<strong class="ln hi">.</strong>created_at<br/>          },<br/>          captures: <strong class="ln hi">[</strong><br/>            {<br/>              success: <strong class="ln hi">true</strong>,<br/>              amount: payment<strong class="ln hi">.</strong>card_capture<strong class="ln hi">.</strong>amount<br/>              captured_at: payment<strong class="ln hi">.</strong>card_capture<strong class="ln hi">.</strong>amount<br/>            }<br/>          <strong class="ln hi">]</strong><br/>        }<br/>      )<br/>    <strong class="ln hi">end</strong><br/>  <strong class="ln hi">end</strong></span><span id="8872" class="lr km hh ln b fi lw lt l lu lv">  <strong class="ln hi">class</strong> <strong class="ln hi">Wrapper</strong><br/>    <strong class="ln hi">def</strong> <strong class="ln hi">self.wrap</strong>(proto)<br/>      <strong class="ln hi">new</strong>(proto)<br/>    <strong class="ln hi">end</strong></span><span id="5a1f" class="lr km hh ln b fi lw lt l lu lv">    <strong class="ln hi">def</strong> <strong class="ln hi">initialize</strong>(proto)<br/>      @proto <strong class="ln hi">=</strong> proto<br/>    <strong class="ln hi">end</strong></span><span id="390e" class="lr km hh ln b fi lw lt l lu lv">    <strong class="ln hi">def</strong> <strong class="ln hi">auth_created_at</strong><br/>      @proto<strong class="ln hi">.</strong>try(:card)<strong class="ln hi">.</strong>try(:auth)<strong class="ln hi">.</strong>try(:authed_at)<br/>    <strong class="ln hi">end</strong></span><span id="c94b" class="lr km hh ln b fi lw lt l lu lv">    <strong class="ln hi">def</strong> <strong class="ln hi">auth_amount</strong><br/>      @proto<strong class="ln hi">.</strong>try(:card)<strong class="ln hi">.</strong>try(:auth)<strong class="ln hi">.</strong>try(:amount)<br/>    <strong class="ln hi">end</strong></span><span id="1282" class="lr km hh ln b fi lw lt l lu lv">    <strong class="ln hi">def</strong> <strong class="ln hi">successful_capture</strong><br/>      <strong class="ln hi">if</strong> @proto<strong class="ln hi">.</strong>captures<br/>        @proto<strong class="ln hi">.</strong>captures<strong class="ln hi">.</strong>select { <strong class="ln hi">|</strong>capture<strong class="ln hi">|</strong> capture<strong class="ln hi">[</strong>:success<strong class="ln hi">]</strong> }<strong class="ln hi">.</strong>first<br/>      <strong class="ln hi">end</strong><br/>    <strong class="ln hi">end</strong><br/>  <strong class="ln hi">end</strong><br/><strong class="ln hi">end</strong></span></pre><p id="422d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们有了一个转换器，我们可以扩展我们的<em class="js">查找</em>调用:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="d68f" class="lr km hh ln b fi ls lt l lu lv"><em class="js"># This is a dramatic simplification from our actual code, but it’s a demonstration of concept.</em><br/><strong class="ln hi">class</strong> <strong class="ln hi">PaymentApi</strong><br/>  <strong class="ln hi">def</strong> <strong class="ln hi">self.lookup</strong>(payment_token: <strong class="ln hi">nil</strong>, includes: <strong class="ln hi">nil</strong>, proto: <strong class="ln hi">false</strong>)<br/>    criteria <strong class="ln hi">=</strong> Payment<strong class="ln hi">.</strong>where(token: payment_token)<br/>    criteria <strong class="ln hi">=</strong> criteria<strong class="ln hi">.</strong>includes(includes)<br/>    payment <strong class="ln hi">=</strong> criteria<strong class="ln hi">.</strong>with_tag(:api)<strong class="ln hi">.</strong>first</span><span id="2e50" class="lr km hh ln b fi lw lt l lu lv">    <strong class="ln hi">if</strong> proto <strong class="ln hi">&amp;&amp;</strong> payment<br/>      Wrapper<strong class="ln hi">.</strong>wrap(Converter<strong class="ln hi">.</strong>to_proto(payment))<br/>    <strong class="ln hi">else</strong><br/>     payment<br/>    <strong class="ln hi">end</strong><br/>  <strong class="ln hi">end</strong><br/><strong class="ln hi">end</strong></span></pre><p id="3e7a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然Spot还没有准备好，但我们已经完成了我们的原型API，可以开始迁移代码，而不必担心底层API的不断变化。最终完成原型API也有助于推广的顺利进行，因为如果我们在生产中发现了一个bug，我们可以把这个标志关掉。</p><p id="05ef" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此时，我们也开始双运行我们的整个测试套件，打开和关闭proto包装器标志。这防止了任何其他工程团队发布破坏我们提取工作的代码，并确保我们知道旧的代码路径仍然有效。</p><h1 id="8a74" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">现场审计与广场/网络审计</h1><p id="f49f" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">Square/Web的数据库模式可以追溯到2010年，而Spot的是2013年，基于protobufs。由于显著的差异，我们确认我们的包装器以Square/Web预期的方式返回数据:</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="8004" class="lr km hh ln b fi ls lt l lu lv"><em class="js"># This is a dramatic simplification from our actual code, but it’s a demonstration of concept.</em><br/>COMPARE_FIELDS <strong class="ln hi">=</strong> <strong class="ln hi">%</strong>i(auth_created_at auth_amount capture_amount currency_code)<br/>Payment<strong class="ln hi">.</strong>order("id DESC")<strong class="ln hi">.</strong>limit(1000)<strong class="ln hi">.</strong>each <strong class="ln hi">do</strong> <strong class="ln hi">|</strong>payment<strong class="ln hi">|</strong><br/>   wrapped_payment <strong class="ln hi">=</strong> PaymentApi<strong class="ln hi">::</strong>Wrapper<strong class="ln hi">.</strong>wrap(Converter<strong class="ln hi">.</strong>to_proto(payment))<br/>   spot_payment <strong class="ln hi">=</strong> HTTP<strong class="ln hi">::</strong>Rpc<strong class="ln hi">::</strong>Spot<strong class="ln hi">.</strong>load_payment(payment<strong class="ln hi">.</strong>token)</span><span id="8928" class="lr km hh ln b fi lw lt l lu lv">   puts "#{payment<strong class="ln hi">.</strong>token}"<br/>   COMPARE_FIELDS<strong class="ln hi">.</strong>each <strong class="ln hi">do</strong> <strong class="ln hi">|</strong>field<strong class="ln hi">|</strong><br/>     spot_value <strong class="ln hi">=</strong> spot_payment<strong class="ln hi">.</strong>send(field)<br/>     wrapped_value <strong class="ln hi">=</strong> wrapped_payment<strong class="ln hi">.</strong>send(field)</span><span id="7fd7" class="lr km hh ln b fi lw lt l lu lv">     <strong class="ln hi">unless</strong> spot_value <strong class="ln hi">==</strong> wrapped_value<br/>       puts "- Mismatch, #{field}, found #{spot_value}, expected #{wrapped_value}"<br/>     <strong class="ln hi">end</strong><br/>  <strong class="ln hi">end</strong><br/><strong class="ln hi">end</strong></span></pre><p id="41f7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们手动运行它，直到我们修复了它发现的所有差异，这实际上捕获了许多微妙的错误。</p><h1 id="a9ce" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">呼叫点</h1><p id="a1ec" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">现在，是时候把它们绑在一起了！我们对包装器有足够的信心，可以开始通过Spot发送请求。这只需要另一个标志和几行额外的代码。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="cf87" class="lr km hh ln b fi ls lt l lu lv"><em class="js"># This is a dramatic simplification from our actual code, but it’s a demonstration of concept.</em><br/><strong class="ln hi">class</strong> <strong class="ln hi">PaymentApi</strong><br/>  <strong class="ln hi">def</strong> <strong class="ln hi">lookup</strong>(payment_token: <strong class="ln hi">nil</strong>, includes: <strong class="ln hi">nil</strong>, proto: <strong class="ln hi">false</strong>, via_spot: <strong class="ln hi">nil</strong>)<br/>    <strong class="ln hi">if</strong> via_spot<br/>      <strong class="ln hi">return</strong> Wrapper<strong class="ln hi">.</strong>wrap(HTTP<strong class="ln hi">::</strong>Rpc<strong class="ln hi">::</strong>Spot<strong class="ln hi">.</strong>load_payment(payment_token))<br/>    <strong class="ln hi">end</strong></span><span id="3c05" class="lr km hh ln b fi lw lt l lu lv">    criteria <strong class="ln hi">=</strong> Payment<strong class="ln hi">.</strong>where(token: payment_token)<br/>    criteria <strong class="ln hi">=</strong> criteria<strong class="ln hi">.</strong>includes(includes)<br/>    payment <strong class="ln hi">=</strong> criteria<strong class="ln hi">.</strong>first</span><span id="1b9a" class="lr km hh ln b fi lw lt l lu lv">    <strong class="ln hi">if</strong> proto <strong class="ln hi">&amp;&amp;</strong> payment<br/>      Wrapper<strong class="ln hi">.</strong>wrap(Converter<strong class="ln hi">.</strong>to_proto(payment))<br/>    <strong class="ln hi">else</strong><br/>      payment<br/>    <strong class="ln hi">end</strong><br/>  <strong class="ln hi">end</strong><br/><strong class="ln hi">end</strong></span></pre><p id="37af" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们完了！我们开始将流量转移到Spot，重新运行SQL分析器，观察查询数量的减少。</p><p id="4682" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了简单起见，我省略了如何将搜索移植到Spot中。我上面概述的是我们搜索遵循的相同过程。主要的区别是它需要对搜索参数进行更多的验证。</p><h1 id="84bc" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">本可以变得更好的事情</h1><p id="5854" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">在迁移任何东西之前，我们对与支付相关的代码进行了审计，以找到我们可以删除的任何东西。在提取过程中，我们总共提取了大约56，000行代码。</p><p id="9772" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了给我们的商家提供最好的体验，Square尽可能避免贬低注册客户。我们在Android和iOS上都有两年前的活跃版本。每当我们删除返回到Register应用程序的字段时，我们最终不得不审核六个不同的代码库(iOS和Android上的三个版本)。</p><p id="8b49" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们有一些API使用了<a class="ae kf" href="https://github.com/rails/activeresource" rel="noopener ugc nofollow" target="_blank"> ActiveResource </a>模式，这使得审计和迁移变得很困难。因为它提供了一个HTTP - &gt; SQL层，所以很容易引入新的调用，使迁移成为一个移动的目标。</p><p id="c565" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">服务之间缺乏可靠的API契约，这使得很难确定使用了哪些数据，以及它们依赖于哪些Square/Web特有的特性。</p><h1 id="4df7" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">我们会有什么不同的做法？</h1><p id="c87d" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">我们现有的Square/Web中其他服务的API主要使用JSON。用protobufs之类的东西定义一个清晰的契约会更容易准确地理解需要哪些列和数据。</p><p id="7166" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然我们不能对现有的Register客户机做任何事情，但是从一开始就使用protobufs会提供一个更清晰的审计线索，说明哪个版本需要什么数据。在构建基于各种支付状态的复杂层次结构时，无法审计JSON字段。</p><p id="92af" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，我们犯了一个事后看来很明显的错误，那就是使用了随机推出，而不是对商家稳定。我们最终发现了一个回归错误，这个错误只在同时使用Register的六个月前的版本和最新版本时出现。在随机推出的情况下，这一点并不明显，因为在较低的百分比下，商家更有可能只是刷新一个页面，然后看到它工作。</p><p id="0a33" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">两者都不是好的用户体验，但稳定的推出减轻了Register应用程序对少数商家的持续破坏，而不是对更多商家的持续破坏。</p><h1 id="a46f" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">结束语</h1><p id="b4eb" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">最终结果是在2016年1月成功提取，在关闭本地写入之前，所有读取将持续大约六周。如果有必要的话，我们可以更快地关闭写入，但我们认为没有必要在假期前对基础架构进行重大更改。</p><p id="1149" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我要感谢我的同事们:<a class="ae kf" href="https://twitter.com/arpohahau" rel="noopener ugc nofollow" target="_blank">艾丽莎·波哈乌</a>、<a class="ae kf" href="https://twitter.com/nerdrew" rel="noopener ugc nofollow" target="_blank">安德鲁·拉扎勒斯</a>、<a class="ae kf" href="https://twitter.com/_gjg_" rel="noopener ugc nofollow" target="_blank">加布里埃尔·吉尔德</a>、<a class="ae kf" href="https://www.linkedin.com/in/johnpongsajapan" rel="noopener ugc nofollow" target="_blank">约翰·彭萨加潘</a>、<a class="ae kf" href="https://github.com/embark" rel="noopener ugc nofollow" target="_blank">凯西·斯普拉德林</a>和<a class="ae kf" href="https://twitter.com/maniksurtani" rel="noopener ugc nofollow" target="_blank">马尼克·苏尔塔尼</a>，他们都对计划和提取工作做出了贡献。有太多的人也为Square/Web的数据库和其他部分的稳定性做出了早期分析。这最终成为公司范围内的努力，直接涉及大多数产品工程团队和非工程团队。</p></div><div class="ab cl lx ly go lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ha hb hc hd he"><div class="li lj lk ll fd me"><a href="https://twitter.com/zachanker" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab dw"><div class="mg ab mh cl cj mi"><h2 class="bd hi fi z dy mj ea eb mk ed ef hg bi translated">扎卡里·安克尔(@zachanker) |推特</h2><div class="ml l"><h3 class="bd b fi z dy mj ea eb mk ed ef dx translated">Zachary Anker的最新推文(@zachanker)。广场的工程师。旧金山</h3></div><div class="mm l"><p class="bd b fp z dy mj ea eb mk ed ef dx translated">twitter.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms mt me"/></div></div></a></div></div></div>    
</body>
</html>