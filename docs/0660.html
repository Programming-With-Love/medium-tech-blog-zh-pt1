<html>
<head>
<title>Introduction to Hilt in the MAD Skills series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">疯狂技能系列之剑柄介绍</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/introduction-to-hilt-in-the-mad-skills-series-40f0908f2fc0?source=collection_archive---------0-----------------------#2021-08-23">https://medium.com/androiddevelopers/introduction-to-hilt-in-the-mad-skills-series-40f0908f2fc0?source=collection_archive---------0-----------------------#2021-08-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/40a32095d9b12cba4199dd9379510100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idmMVvLYKDsb3yMLP6HQvg.png"/></div></div></figure><div class=""/><div class=""><h2 id="bb1b" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">剑柄狂技能系列第一集</h2></div><p id="1680" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">这是剑柄上的狂技能篇系列！</strong>在这篇文章中，我们将了解为什么依赖注入(DI)对你的应用和Hilt很重要，这是Jetpack推荐的Android上的依赖注入解决方案。</p><p id="802d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果您喜欢以视频格式观看这些内容，请点击此处查看:</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="ecdb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">通过在你的Android应用中遵循依赖注入的原则，你为一个好的应用架构打下了基础。它有助于代码的可重用性、易于重构和易于测试！点击了解更多关于DI福利<a class="ae kj" href="http://d.android.com/dependency-injection" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="ec4c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当在您的项目中创建类的实例时，您可以通过满足类所需的依赖关系和传递依赖关系来手动练习依赖图。</p><p id="9923" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">但是每次手动这样做都会涉及一些样板代码，并且容易出错。例如，我们在开源Google I/O应用程序<a class="ae kj" href="https://github.com/google/iosched" rel="noopener ugc nofollow" target="_blank">中的一个视图模型。您能想象创建一个<code class="du kk kl km kn b"><a class="ae kj" href="https://github.com/google/iosched/blob/main/mobile/src/main/java/com/google/samples/apps/iosched/ui/feed/FeedViewModel.kt" rel="noopener ugc nofollow" target="_blank">FeedViewModel</a></code>及其依赖项和可传递依赖项需要多少代码吗？</a></p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><p id="aad3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这很难，重复，而且我们很容易弄错依赖关系。通过使用依赖注入库，我们可以获得DI的好处，而不必手动提供依赖，因为该库会为您生成所有必要的代码。这就是希尔特发挥作用的地方。</p><h1 id="54e0" class="kp kq hs bd kr ks kt ku kv kw kx ky kz iy la iz lb jb lc jc ld je le jf lf lg bi translated">柄</h1><p id="0398" class="pw-post-body-paragraph jh ji hs jj b jk lh it jm jn li iw jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated"><a class="ae kj" href="http://d.android.com/hilt" rel="noopener ugc nofollow" target="_blank"> Hilt </a>是一个由Google开发的依赖注入库，通过努力工作并生成所有你需要编写的样板文件，帮助你在你的应用程序中充分利用DI最佳实践。</p><p id="e9fc" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">通过使用注释，Hilt在编译时为您生成代码，使它在运行时非常快。这是通过使用<a class="ae kj" href="https://developer.android.com/training/dependency-injection/dagger-basics" rel="noopener ugc nofollow" target="_blank"> Dagger </a>的能力完成的，它是在其上构建的JVM DI库。</p><blockquote class="lm"><p id="5433" class="ln lo hs bd lp lq lr ls lt lu lv kc dx translated">Hilt是Jetpack推荐的用于Android应用的DI解决方案，它带有工具和其他Jetpack库支持。</p></blockquote><h1 id="4c7b" class="kp kq hs bd kr ks kt ku kv kw kx ky kz iy lw iz lb jb lx jc ld je ly jf lf lg bi translated">快速启动</h1><p id="543d" class="pw-post-body-paragraph jh ji hs jj b jk lh it jm jn li iw jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">所有使用Hilt的应用程序都必须包含一个用<code class="du kk kl km kn b">@HiltAndroidApp</code>标注的应用程序类，因为它会在编译时触发Hilt的代码生成。为了让Hilt能够将依赖注入到活动中，活动需要用<code class="du kk kl km kn b">@AndroidEntryPoint</code>进行注释。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><p id="d7a2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">要注入一个依赖项，用<code class="du kk kl km kn b">@Inject</code>来注释你希望Hilt注入的变量。当<code class="du kk kl km kn b">super.onCreate</code>被调用时，所有注入的变量都将可用。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><p id="1733" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这个例子中，我们将一个<code class="du kk kl km kn b">MusicPlayer</code>注入到<code class="du kk kl km kn b">PlayActivity</code>中。但是Hilt怎么知道如何提供类型<code class="du kk kl km kn b">MusicPlayer</code>的实例呢？嗯，目前没有！我们需要让希尔特知道如何做…使用注释！当然了。</p><p id="3a75" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">用<code class="du kk kl km kn b">@Inject</code>注释一个类的构造函数告诉Hilt如何创建该类的实例。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><p id="e53b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这就是将依赖注入到活动中所需要的一切！那很容易！我们从一个简单的例子开始，因为MusicPlayer不依赖于任何其他类型。但是如果我们有其他依赖项作为参数传递，当提供一个MusicPlayer实例时，Hilt会处理这些依赖项并满足它们。</p><p id="345e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">事实上，这是一个非常简单和天真的例子。但是，如果您必须手动完成我们到目前为止所做的工作，您会如何做呢？</p><h1 id="ea49" class="kp kq hs bd kr ks kt ku kv kw kx ky kz iy la iz lb jb lc jc ld je le jf lf lg bi translated">手动操作</h1><p id="cef7" class="pw-post-body-paragraph jh ji hs jj b jk lh it jm jn li iw jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">当手动执行DI时，您可以让<em class="lz">依赖容器</em>类负责提供类型，并管理它所提供的实例的生命周期。这里有点过于简单了，这就是希尔特在引擎盖下做的事情！</p><p id="24ff" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当您用<code class="du kk kl km kn b">@AndroidEntryPoint</code>注释活动时，会自动创建、管理一个依赖容器，并将其关联到<code class="du kk kl km kn b">PlayActivity</code>。姑且称我们的手动实现为<code class="du kk kl km kn b">PlayActivityContainer</code>。通过用<code class="du kk kl km kn b">@Inject</code>注释<code class="du kk kl km kn b">MusicPlayer</code>，我们基本上是在告诉容器如何提供类型<code class="du kk kl km kn b">MusicPlayer</code>的实例。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><p id="a101" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在活动中，我们需要创建容器的实例，并使用它填充活动的依赖项。在用<code class="du kk kl km kn b">@AndroidEntryPoint</code>注释活动时，这也是由Hilt完成的。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><h1 id="d78a" class="kp kq hs bd kr ks kt ku kv kw kx ky kz iy la iz lb jb lc jc ld je le jf lf lg bi translated">注释摘要</h1><p id="71dd" class="pw-post-body-paragraph jh ji hs jj b jk lh it jm jn li iw jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">到目前为止，我们已经看到当<code class="du kk kl km kn b"><strong class="jj ht">@Inject</strong></code>被用来注释一个类的构造函数时，它告诉Hilt如何提供那个类的实例。当它在一个<code class="du kk kl km kn b">@AndroidEntryPoint</code>注释类中注释一个变量时，Hilt会将该类型的一个实例注入到该类中。</p><p id="0f25" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du kk kl km kn b"><strong class="jj ht">@AndroidEntryPoint</strong></code>可以注释大多数Android框架类，而不仅仅是活动，它为该类创建一个依赖容器实例，并填充所有<code class="du kk kl km kn b">@Inject</code>注释变量。</p><p id="21e5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du kk kl km kn b"><strong class="jj ht">@HiltAndroidApp</strong></code>注释了<code class="du kk kl km kn b">Application</code>类，除了触发Hilt的代码生成，它还创建了一个与Application类关联的依赖容器。</p><h1 id="03c1" class="kp kq hs bd kr ks kt ku kv kw kx ky kz iy la iz lb jb lc jc ld je le jf lf lg bi translated">手柄模块</h1><p id="5a28" class="pw-post-body-paragraph jh ji hs jj b jk lh it jm jn li iw jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">既然我们已经了解了刀柄的基本知识，让我们把例子复杂化。现在，<code class="du kk kl km kn b">MusicPlayer</code>在其构造函数<code class="du kk kl km kn b">MusicDatabase</code>中获取一个依赖项。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><p id="419c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因此，我们需要告诉Hilt如何提供<code class="du kk kl km kn b">MusicDatabase</code>的实例。例如，当类型是一个接口或者你不拥有这个类，因为它来自一个库，你不能用<code class="du kk kl km kn b">@Inject</code>注释它的构造函数！</p><p id="47d0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">假设我们在应用程序中使用Room作为持久性库。回到我们的手动实现<code class="du kk kl km kn b">PlayActivityContainer</code>，当提供<code class="du kk kl km kn b">MusicDatabase</code>时，这将是一个抽象类，我们希望在提供依赖时运行一些代码。然后，在提供<code class="du kk kl km kn b">MusicPlayer</code>的实例时，我们需要调用提供或者满足<code class="du kk kl km kn b">MusicDatabase</code>依赖的方法。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><p id="66eb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们不需要担心Hilt中的传递依赖，因为它会自动连接所有的传递依赖。然而，我们需要让它知道如何提供类型<code class="du kk kl km kn b">MusicDatabase</code>的实例。为此，我们使用刀柄模块。</p><p id="68a4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">一个句柄模块是一个用<code class="du kk kl km kn b">@Module</code>标注的类。在类中，我们可以有一些函数告诉Hilt如何提供某些类型的实例。刀柄所知道的这些信息在刀柄行话中也被称为<em class="lz">绑定</em>。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><p id="b476" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">用<code class="du kk kl km kn b">@Provides</code>标注的函数告诉Hilt如何提供<code class="du kk kl km kn b">MusicDatabase</code>类型的实例。主体包含了Hilt需要执行的代码块，这和我们手动实现它的时候完全一样。</p><p id="6184" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">返回类型<code class="du kk kl km kn b">MusicDatabase</code>，通知Hilt这个函数提供什么类型。而函数参数告诉Hilt对应类型的依赖关系，在本例中，是在Hilt中已经可用的<code class="du kk kl km kn b">ApplicationContext</code>。这段代码告诉Hilt如何提供<code class="du kk kl km kn b">MusicDatabase</code>类型的实例，或者换句话说，我们有一个<code class="du kk kl km kn b">MusicDatabase</code>的<em class="lz">绑定</em>。</p><p id="8d76" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">希尔特模块也用<code class="du kk kl km kn b">@InstallIn</code>注释进行了注释，该注释指出在哪些依赖容器或组件中可以获得该信息。但是什么是组件呢？让我们更详细地讨论这个问题。</p><h1 id="df98" class="kp kq hs bd kr ks kt ku kv kw kx ky kz iy la iz lb jb lc jc ld je le jf lf lg bi translated">刀柄组件</h1><p id="3572" class="pw-post-body-paragraph jh ji hs jj b jk lh it jm jn li iw jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">组件是Hilt生成的一个类，负责提供类型的实例，就像我们一直手动编程的容器。在编译时，Hilt遍历应用程序的依赖图并生成代码，为所有类型提供它们的可传递依赖关系。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ma"><img src="../Images/432b0d728134d6c6da20c6c47f7e328f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tLeCLrTp5jr1vrRrHCfQ1w.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx"><em class="mf">A Component is a class that Hilt generates that is responsible for providing instances of types</em></figcaption></figure><p id="50ce" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Hilt为大多数Android框架类生成一个组件或依赖容器。每个组件的信息或绑定通过组件层次结构传播。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mg"><img src="../Images/ec66289b5b4ddd40e0ba97c66e2ca3e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1yEgD8OWgjGfrSHtLQ_Ovw.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx"><em class="mf">Hilt’s components hierarchy</em></figcaption></figure><p id="4b6d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果<code class="du kk kl km kn b">MusicDatabase</code>绑定在<code class="du kk kl km kn b">SingletonComponent</code>中可用，对应于<code class="du kk kl km kn b">Application</code>类，它也将在其余组件中可用。</p><p id="2eb0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这些组件由Hilt在编译时自动生成，当您用<code class="du kk kl km kn b">@AndroidEntryPoint</code>注释这些类时，它们被创建、管理并与相应的Android框架类相关联。</p><p id="674c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">模块的<code class="du kk kl km kn b">@InstallIn</code>注释有助于控制这些绑定在哪里可用，以及它们可以使用哪些其他绑定。</p><h1 id="fdd5" class="kp kq hs bd kr ks kt ku kv kw kx ky kz iy la iz lb jb lc jc ld je le jf lf lg bi translated">辖域</h1><p id="4c6b" class="pw-post-body-paragraph jh ji hs jj b jk lh it jm jn li iw jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">回到我们手动创建的<code class="du kk kl km kn b">PlayActivityContainer</code>代码，我不确定你是否意识到了，但是每次需要<code class="du kk kl km kn b">MusicDatabase</code>依赖时，我们都会创建一个不同的实例。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><p id="1e0f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这并不理想，因为我们可能希望在整个应用程序中重用同一个<code class="du kk kl km kn b">MusicDatabase</code>实例。我们可以共享同一个实例，而不是一个函数，方法是将所有内容放在一个变量中。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><p id="b4bb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">基本上，我们将<code class="du kk kl km kn b">MusicDatabase</code>类型限定到这个容器中，因为我们总是提供相同的实例作为依赖。如何用刀柄做到这一点？好吧，这没什么好奇怪的…还有另一个注释！</p><p id="d77e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">通过在<code class="du kk kl km kn b">@Provides</code>方法中使用<code class="du kk kl km kn b">@Singleton</code>注释，我们告诉Hilt总是在那个组件中共享这个类型的同一个实例。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><p id="d8bb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><code class="du kk kl km kn b">@Singleton</code>是范围标注。并且每个句柄组件都有一个相关的范围注释。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mh"><img src="../Images/5753c1ced5f3d8ede189e452668b0b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZBmgk86cx6V-eAvWUtzBuA.png"/></div></div><figcaption class="mb mc et er es md me bd b be z dx"><em class="mf">Scope annotations for each Hilt component</em></figcaption></figure><p id="3860" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你想把一个类型的范围扩大到<code class="du kk kl km kn b">ActivityComponent</code>，你可以使用<code class="du kk kl km kn b">ActivityScoped</code>注释。这些注释可以在模块中使用，但是它们也可以注释构造函数用<code class="du kk kl km kn b">@Inject</code>注释的类。</p><h1 id="9d69" class="kp kq hs bd kr ks kt ku kv kw kx ky kz iy la iz lb jb lc jc ld je le jf lf lg bi translated">粘合剂</h1><p id="b3fd" class="pw-post-body-paragraph jh ji hs jj b jk lh it jm jn li iw jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">有两种类型的绑定:</p><ul class=""><li id="1447" class="mi mj hs jj b jk jl jn jo jq mk ju ml jy mm kc mn mo mp mq bi translated">没有用作用域注释进行注释的绑定被称为<strong class="jj ht">未作用域绑定</strong>，就像<code class="du kk kl km kn b">MusicPlayer</code>一样，如果没有安装在模块中，这些绑定对所有组件都可用。</li><li id="b957" class="mi mj hs jj b jk mr jn ms jq mt ju mu jy mv kc mn mo mp mq bi translated"><strong class="jj ht">用作用域注释注释的作用域绑定</strong>，如<code class="du kk kl km kn b">MusicDatabase</code>，或者安装在模块中的未作用域绑定，在相应的组件和组件层次结构中它下面的组件中都是可用的。</li></ul><h1 id="c352" class="kp kq hs bd kr ks kt ku kv kw kx ky kz iy la iz lb jb lc jc ld je le jf lf lg bi translated">Jetpack扩展</h1><blockquote class="lm"><p id="be7e" class="ln lo hs bd lp lq lr ls lt lu lv kc dx translated">Hilt提供了与最流行的Jetpack库的集成:ViewModel、Navigation、Compose和WorkManager。</p></blockquote><p id="082c" class="pw-post-body-paragraph jh ji hs jj b jk mw it jm jn mx iw jp jq my js jt ju mz jw jx jy na ka kb kc ha bi translated">除了ViewModel，每个集成都需要不同的库来添加到您的项目中。查看<a class="ae kj" href="http://goo.gle/hilt-jetpack" rel="noopener ugc nofollow" target="_blank">文档</a>了解更多相关信息。你还记得我们在博文开头看到的来自<a class="ae kj" href="https://github.com/google/iosched" rel="noopener ugc nofollow" target="_blank"> iosched </a>的<code class="du kk kl km kn b"><a class="ae kj" href="https://github.com/google/iosched/blob/main/mobile/src/main/java/com/google/samples/apps/iosched/ui/feed/FeedViewModel.kt" rel="noopener ugc nofollow" target="_blank">FeedViewModel</a></code>代码吗？想看看有刀柄支撑的样子吗？</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="ko ki l"/></div></figure><p id="7f67" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">除了用<code class="du kk kl km kn b">@Inject</code>注释构造函数，为了让Hilt知道如何提供这个ViewModel的实例，我们需要用<code class="du kk kl km kn b">@HiltViewModel</code>注释这个类。</p><p id="42e2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">就是这样！您不需要为此手动创建一个ViewModel提供程序，Hilt会处理好的。</p><h1 id="91d1" class="kp kq hs bd kr ks kt ku kv kw kx ky kz iy la iz lb jb lc jc ld je le jf lf lg bi translated">了解更多！</h1><p id="bfc1" class="pw-post-body-paragraph jh ji hs jj b jk lh it jm jn li iw jp jq lj js jt ju lk jw jx jy ll ka kb kc ha bi translated">Hilt建立在另一个流行的依赖注入库之上:<a class="ae kj" href="https://developer.android.com/training/dependency-injection/dagger-basics" rel="noopener ugc nofollow" target="_blank"> Dagger </a>！匕首在接下来的几集里会经常被提起！如果你使用匕首，匕首和刀柄可以一起工作。在<a class="ae kj" href="http://dagger.dev/hilt/migration-guide" rel="noopener ugc nofollow" target="_blank">指南</a>中阅读更多关于迁移API的信息。</p><p id="a4ca" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">关于Hilt的更多信息，我们有一个<a class="ae kj" href="http://goo.gle/hilt-cheatsheet" rel="noopener ugc nofollow" target="_blank">备忘单</a>,上面有最流行的注释，它们做什么，以及如何使用它们。除了我们关于Hilt的<a class="ae kj" href="http://d.android.com/hilt" rel="noopener ugc nofollow" target="_blank">文档</a>之外，我们还有<a class="ae kj" href="http://d.android.com/codelabs/android-hilt" rel="noopener ugc nofollow" target="_blank">代码实验室</a>来学习更多的实践经验。</p><p id="ad6d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这一集就到这里！但这还没有结束！我们将有更多的疯狂技能集，所以请关注Android开发者媒体出版物，看看它们何时发布。</p></div></div>    
</body>
</html>