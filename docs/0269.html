<html>
<head>
<title>Building a DocumentsProvider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建文档提供程序</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/building-a-documentsprovider-f7f2fb38e86a?source=collection_archive---------2-----------------------#2016-09-08">https://medium.com/androiddevelopers/building-a-documentsprovider-f7f2fb38e86a?source=collection_archive---------2-----------------------#2016-09-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="ff7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Android的优势之一一直是它的意图系统:你可以依靠定义应用程序可以注册处理的标准<em class="jd">动作</em>的<a class="ae jc" href="https://developer.android.com/guide/components/intents-common.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">通用意图</a>，而不是只将你的应用程序工作的特定应用程序列入白名单。这些常见的操作之一是<a class="ae jc" href="https://developer.android.com/guide/components/intents-common.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#GetFile" rel="noopener ugc nofollow" target="_blank">检索特定类型的文件</a>，通常用<a class="ae jc" href="https://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#ACTION_GET_CONTENT" rel="noopener ugc nofollow" target="_blank"><em class="jd">ACTION _ GET _ CONTENT</em></a>来实现。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jj jk l"/></div></figure><p id="b8da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在KitKat之前，这意味着构建一个具有<em class="jd"> ACTION_GET_CONTENT </em>意图过滤器的活动，编写一个允许选择由您的应用程序管理的文件的UI，并处理多种标志，如多选和仅本地。然后用户必须学习每个应用的用户界面。文件选择的狂野西部。所以在KitKat中，我们引入了一个新的标准，它带有<a class="ae jc" href="https://developer.android.com/guide/topics/providers/document-provider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">存储访问框架</a>和支撑整个系统的类:<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jd">documents provider</em></a>。</p><p id="d294" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这使得用户可以通过一个标准的用户界面访问任何应用程序中的文件——无论这些文件是来自附带的本地存储<em class="jd">文档提供程序</em>的本地文件，还是来自您构建的自定义<em class="jd">文档提供程序</em>的文件。</p><h1 id="f2e1" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">什么是文档提供者？</h1><p id="7956" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">旧系统和存储访问框架之间的一个关键区别是<strong class="ig hi">UI是由系统</strong>提供的，而不是直接由您的应用程序提供的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ko"><img src="../Images/7309d5f4d824d650ab0cce2c28b05e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*g6x5sZEosxakadHmAB6SGg.png"/></div><figcaption class="kr ks et er es kt ku bd b be z dx">The system provides the UI for all DocumentsProviders</figcaption></figure><p id="2fa5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jd">文档提供者</em> </a>只有一个目的:提供用你的应用程序管理的目录和文件(统称为“文档”)填充用户界面所需的信息。</p><p id="c4a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可能已经猜到了，但是一个<em class="jd">文档提供者</em>扩展了<em class="jd">内容提供者</em>——Android上可用的高级组件之一，特别适合于允许其他应用程序(或者，在这种情况下，系统)从你的应用程序读取信息，并提供对你拥有的文件的访问。</p><p id="9258" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就像任何<em class="jd">内容提供者</em>一样，这意味着您的<em class="jd">文档提供者</em>需要在您的清单中注册:</p><pre class="je jf jg jh fd kv kw kx ky aw kz bi"><span id="ec1b" class="la jm hh kw b fi lb lc l ld le">&lt;provider<br/>    android:name="com.example.YourDocumentProvider"<br/>    android:authorities="com.example.documents"<br/>    android:exported="true"<br/>    android:grantUriPermissions="true"<br/>    android:permission="android.permission.MANAGE_DOCUMENTS"&gt;<br/>  &lt;intent-filter&gt;<br/>    &lt;action<br/>      android:name="android.content.action.DOCUMENTS_PROVIDER"/&gt;<br/>  &lt;/intent-filter&gt;<br/>&lt;/provider&gt;</span></pre><p id="33f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您会注意到<em class="jd"> authorities </em>属性——这需要是一个唯一的字符串，您可以将它视为您的<em class="jd"> DocumentsProvider </em>构建的所有URIs的前缀。我们也将在代码中提到这一点，因此有时使用一些Gradle magic来确保它们始终保持同步更有意义:</p><pre class="je jf jg jh fd kv kw kx ky aw kz bi"><span id="9c1c" class="la jm hh kw b fi lb lc l ld le">// build.gradle<br/>defaultConfig {<br/>  def documentsAuthorityValue = applicationId + ".documents"<br/>  <br/>  // Now we can use ${documentsAuthority} in our Manifest<br/>  manifestPlaceholders =<br/>    [documentsAuthority: documentsAuthorityValue]</span><span id="179f" class="la jm hh kw b fi lf lc l ld le">  // Now we can use BuildConfig.DOCUMENTS_AUTHORITY in our code<br/>  buildConfigField "String",<br/>    "DOCUMENTS_AUTHORITY",<br/>    "\"${documentsAuthorityValue}\""</span><span id="a219" class="la jm hh kw b fi lf lc l ld le">}</span></pre><p id="780e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们可以更新我们的提供者来使用<em class="jd">Android:authorities = " $ { documents authority } "</em>并使用<em class="jd"> BuildConfig。DOCUMENTS_AUTHORITY </em>在我们代码的任何地方引用同一个常量。</p><blockquote class="lg lh li"><p id="f415" class="ie if jd ig b ih ii ij ik il im in io lj iq ir is lk iu iv iw ll iy iz ja jb ha bi translated">注意:<em class="hh"> applicationId </em>在库模块中将为<em class="hh"> null </em>，所以只有当<em class="hh"> DocumentsProvider </em>在应用模块中时，这种技术才有效。</p></blockquote><p id="c241" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">幸运的是，<em class="jd"> DocumentsProvider </em>负责高层次的<em class="jd">content provider</em>API，给你一个非常特定于文档的API来实现。</p><h1 id="49ac" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">这一切都从根源开始</h1><p id="c679" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">且该文档特定API以<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#queryRoots(java.lang.String[])" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="jd">query roots()</em></strong></a>开头。“根”是出现在文档UI中的最顶端的条目，包括诸如唯一的根ID、根的“显示名称”(用户可见的名称)、图标、可选摘要以及最重要的该根的最顶端目录的文档ID(这是它将用来实际枚举其余内容的信息)。</p><p id="1fc5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于大多数应用程序来说，这是非常简单的——你的应用程序有一个根，但这并不是必须的。例如，上图中的<em class="jd"> UsbDocProvider </em>对于每个连接的USB驱动器都有一个根目录(这实际上意味着大多数时候它根本没有根目录，也不会出现在列表中——正如您所料)。您还可以考虑支持多个帐户的情况:您可以并且应该为每个用户帐户设置一个单独的根目录。</p><h2 id="3431" class="la jm hh bd jn lm ln lo jr lp lq lr jv ip ls lt jz it lu lv kd ix lw lx kh ly bi translated">在文档提供程序中使用光标</h2><p id="fb37" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">当您实际查看<em class="jd"> queryRoots() </em>的完整定义时，您会从一开始就遇到两个概念:一个<em class="jd">光标</em>和一个投影。这些是使用数据库时的常用术语(实际上是一个<em class="jd"> ContentProvider </em>背后的基础)，但这并不意味着您需要了解数据库的细节才能编写一个<em class="jd"> DocumentsProvider </em>。</p><p id="06bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，就像传统数据库有许多行，每一行由许多列组成一样，<em class="jd"> queryRoots() </em>期待一个<em class="jd">游标</em>，它为您想要返回的每个根都有一行，每个根都有许多列，表示各种信息。传入的投影是一个数组，其中包含被请求的列，如果您可以选择要返回的列，则该投影为null。</p><p id="356f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在文档根的情况下，有效列在<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Root.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> DocumentsContract中找到。Root </em> </a> —这个“契约”是系统和您的<em class="jd">文档提供者</em>需要达成一致的。在根的情况下，有许多必需的列:</p><ul class=""><li id="67d6" class="lz ma hh ig b ih ii il im ip mb it mc ix md jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Root.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_ROOT_ID" rel="noopener ugc nofollow" target="_blank"><em class="jd">COLUMN _ ROOT _ ID</em></a>—定义根的唯一字符串。只要它在你的应用中是唯一的，它可以是你想要的任何东西</li><li id="e313" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Root.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_ICON" rel="noopener ugc nofollow" target="_blank"><em class="jd">COLUMN _ ICON</em></a>—为根显示的图标的资源ID。理想情况下，这应该是一些品牌，这样就可以清楚地知道根是什么应用程序相关联</li><li id="8e53" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Root.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_TITLE" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> COLUMN_TITLE </em> </a> —根的标题—这应该是一个用户友好的名称(记住这里有一个单独的、可选的<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Root.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_SUMMARY" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> COLUMN_SUMMARY </em> </a>用于类似帐户名的东西)</li><li id="c9de" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Root.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_FLAGS" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> COLUMN_FLAGS </em> </a> —一个整数，表示您的根支持哪些可选行为，例如它是否仅表示本地数据，或者您是否支持创建新文件、按新近度排序或搜索。如果你不支持任何东西，这可以只是0</li><li id="e4f3" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Root.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_DOCUMENT_ID" rel="noopener ugc nofollow" target="_blank"/></li></ul><p id="d5a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，构建一个至少包含这些字段的默认根投影是有意义的:</p><pre class="je jf jg jh fd kv kw kx ky aw kz bi"><span id="00b5" class="la jm hh kw b fi lb lc l ld le">private final static String[] DEFAULT_ROOT_PROJECTION =<br/>  new String[]{<br/>    Root.COLUMN_ROOT_ID,<br/>    Root.COLUMN_ICON, Root.COLUMN_TITLE,<br/>    Root.COLUMN_FLAGS, Root.COLUMN_DOCUMENT_ID};</span></pre><p id="3155" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在您可以使用一个<a class="ae jc" href="https://developer.android.com/reference/android/database/MatrixCursor.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> MatrixCursor </em> </a>手动构建一个包含所需列的游标:</p><pre class="je jf jg jh fd kv kw kx ky aw kz bi"><span id="3ae1" class="la jm hh kw b fi lb lc l ld le">MatrixCursor result = new MatrixCursor(projection != null ?<br/>  projection : DEFAULT_ROOT_PROJECTION);</span></pre><p id="fa01" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于您想要添加的每个根，调用<a class="ae jc" href="https://developer.android.com/reference/android/database/MatrixCursor.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#newRow()" rel="noopener ugc nofollow" target="_blank"><em class="jd">【newRow()</em></a>:</p><pre class="je jf jg jh fd kv kw kx ky aw kz bi"><span id="57d8" class="la jm hh kw b fi lb lc l ld le">MatrixCursor.RowBuilder row = result.newRow();<br/>row.add(Root.COLUMN_ROOT_ID, rootId);<br/>row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher);<br/>row.add(Root.COLUMN_TITLE,<br/>  getContext().getString(R.string.app_name));<br/>row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY |<br/>  Root.FLAG_SUPPORTS_CREATE);<br/>row.add(Root.COLUMN_DOCUMENT_ID, rootDocumentId);</span></pre><p id="a6cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不要担心检查投影是否包括您想要添加的每一列——如果不需要它们，它们将被忽略。</p><h2 id="6aca" class="la jm hh bd jn lm ln lo jr lp lq lr jv ip ls lt jz it lu lv kd ix lw lx kh ly bi translated">动态根</h2><p id="233d" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">如果你做的不仅仅是一组静态的根，那么文档UI保持同步是很关键的——用户不应该看到已经断开的USB设备或注销的帐户。幸运的是，构建在一个<em class="jd"> ContentProvider </em>之上给了我们一个预先构建的机制，通过<a class="ae jc" href="https://developer.android.com/reference/android/content/ContentResolver.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#notifyChange(android.net.Uri,%20android.database.ContentObserver)" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> notifyChange() </em> </a>通知监听器发生了变化:</p><pre class="je jf jg jh fd kv kw kx ky aw kz bi"><span id="31b9" class="la jm hh kw b fi lb lc l ld le">Uri rootsUri =<br/>  DocumentsContract.buildRootsUri(BuildConfig.DOCUMENTS_AUTHORITY);<br/>context.getContentResolver().notifyChange(rootsUri, null);</span></pre><h1 id="0863" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">放到文件上</h1><p id="3666" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">一旦用户看到并选择了您的根，您将希望从<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#queryChildDocuments(java.lang.String,%20java.lang.String[],%20java.lang.String)" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="jd">query childdocuments()</em></strong></a>中返回一些文档。这可以采取在分层结构中该级别的更多目录(然后将由用户递归浏览)或文件的形式。</p><p id="5532" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就像<em class="jd"> queryRoots() </em>一样，这需要一个投影并返回一个<em class="jd">光标</em>。这些功能相同，但是将使用<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank">文档合同<em class="jd">中定义的列。文档</em> </a>，其中也有许多必填栏:</p><ul class=""><li id="2ab7" class="lz ma hh ig b ih ii il im ip mb it mc ix md jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_DOCUMENT_ID" rel="noopener ugc nofollow" target="_blank"><em class="jd">COLUMN _ DOCUMENT _ ID</em></a>—标识该文档的唯一字符串</li><li id="683a" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_DISPLAY_NAME" rel="noopener ugc nofollow" target="_blank"> <em class="jd">列_显示_名称</em> </a> —用户可见的文档名称</li><li id="b36a" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_MIME_TYPE" rel="noopener ugc nofollow" target="_blank"><em class="jd">COLUMN _ MIME _ TYPE</em></a>—文档的MIME类型，如“image/png”或“application/pdf”——用<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#MIME_TYPE_DIR" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> MIME_TYPE_DIR </em> </a>表示一个目录</li><li id="ebf7" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_FLAGS" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> COLUMN_FLAGS </em> </a> —表示该特定文档支持什么可选行为<em class="jd">的整数。</em></li><li id="070f" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_SIZE" rel="noopener ugc nofollow" target="_blank"><em class="jd">COLUMN _ SIZE</em></a>—long，以字节表示文档的大小(如果不知道，可以加上<em class="jd"> null </em>)</li><li id="f22d" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_LAST_MODIFIED" rel="noopener ugc nofollow" target="_blank"><em class="jd">COLUMN _ LAST _ MODIFIED</em></a></li></ul><p id="1235" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样的基于MatrixCursor的方法在这里也有效。</p><p id="db04" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请记住，<em class="jd"> COLUMN_DOCUMENT_ID </em>必须唯一地描述单个文档，<strong class="ig hi">一个文档可以有多个父文档</strong>——让同一个文档出现在目录结构中的多个位置是完全有效的。例如，您的<em class="jd"> DocumentsProvider </em>可以让其目录的一个分支按用户定义的标签对图像进行排序，而另一个分支按年份进行排序——同一图像可能会出现在多个标签下以及一个年份目录下。</p><p id="8fe8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然<em class="jd"> queryChildDocuments() </em>是当用户浏览您的<em class="jd">文档提供者</em>时将被调用的主要方法，但是您还必须实现<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#queryDocument(java.lang.String,%20java.lang.String[])" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="jd">query document()</em></strong></a>——该方法应该返回与您在<em class="jd"> queryChildDocuments() </em>中返回的完全相同的关于单个文档的元数据。(这是对您的代码进行重复数据删除的好机会，并且有一组代码为<em class="jd"> queryChildDocuments() </em>和<em class="jd"> queryDocument() </em>构建一行)。</p><h2 id="abf9" class="la jm hh bd jn lm ln lo jr lp lq lr jv ip ls lt jz it lu lv kd ix lw lx kh ly bi translated">从网络加载</h2><p id="e735" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">当然，如果您正在处理用户的文件，一个用户最终将拥有一个包含数万个文件的目录。如果您通过网络加载文件元数据，用户可能会在那里坐很长时间。<em class="jd"> DocumentsProvider </em>允许您指定<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#EXTRA_LOADING" rel="noopener ugc nofollow" target="_blank"><em class="jd">EXTRA _ LOADING</em></a>来指示有更多的文档到来，而不是一次加载整个集合:</p><pre class="je jf jg jh fd kv kw kx ky aw kz bi"><span id="3599" class="la jm hh kw b fi lb lc l ld le">MatrixCursor result = new MatrixCursor(projection != null ?<br/>  projection : DEFAULT_DOCUMENT_PROJECTION) {<br/>    @Override<br/>    public Bundle getExtras() {<br/>      Bundle bundle = new Bundle();<br/>      bundle.putBoolean(DocumentsContract.EXTRA_LOADING, true);<br/>      return bundle;<br/>    }<br/>  };</span></pre><p id="db7d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">是的，您需要扩展您的<em class="jd">游标</em>类来覆盖<em class="jd"> getExtras() </em>。(还有<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#EXTRA_INFO" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> EXTRA_INFO </em> </a>和<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#EXTRA_ERROR" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> EXTRA_ERROR </em> </a>，您可能会发现它们在使用相同的技术向用户显示信息时很有用)。</p><p id="2fec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我们可以使用与动态根相同的基于<em class="jd"> notifyChange() </em>的方法，但是这里我们需要在我们的<em class="jd">游标</em>上设置一个特定的通知Uri(因为对于文档有很多游标):</p><pre class="je jf jg jh fd kv kw kx ky aw kz bi"><span id="f9fc" class="la jm hh kw b fi lb lc l ld le">result.setNotificationUri(DocumentsContract.buildChildDocumentsUri(<br/>  BuildConfig.DOCUMENTS_AUTHORITY, parentDocumentUri);</span><span id="9e2c" class="la jm hh kw b fi lf lc l ld le">// When we’ve loaded our data<br/>Uri updatedUri = DocumentsContract.buildChildDocumentsUri(<br/>  BuildConfig.DOCUMENTS_AUTHORITY, parentDocumentUri);<br/>getContentResolver().notifyChange(updatedUri, null);</span></pre><h2 id="4a80" class="la jm hh bd jn lm ln lo jr lp lq lr jv ip ls lt jz it lu lv kd ix lw lx kh ly bi translated">最近通话和搜索</h2><p id="67ce" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">当返回您的<strong class="ig hi">根</strong>时，您可以包括的两个可选标志是<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Root.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_SUPPORTS_RECENTS" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ SUPPORTS _ RECENTS</em></a>和<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Root.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_SUPPORTS_SEARCH" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ SUPPORTS _ SEARCH</em></a>。这些标志表示用户可以分别获得最近修改的文档列表和搜索根目录。在这两种情况下，您将使用与<em class="jd"> queryChildDocuments() </em>相同的技术。</p><p id="5bcc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最近的文档通过<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#queryRecentDocuments(java.lang.String,%20java.lang.String[])" rel="noopener ugc nofollow" target="_blank"><em class="jd">queryRecentDocuments()</em></a>返回，按照<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_LAST_MODIFIED" rel="noopener ugc nofollow" target="_blank"><em class="jd">COLUMN _ LAST _ MODIFIED</em></a>降序排列，最多不超过64个文档。您在此处返回的文档将与系统提供的“最近”根目录下的其他文档合并，允许用户在所有已安装的<em class="jd">文档提供者</em>中查看他们最近的文档</p><blockquote class="lg lh li"><p id="d283" class="ie if jd ig b ih ii ij ik il im in io lj iq ir is lk iu iv iw ll iy iz ja jb ha bi translated"><strong class="ig hi">注意:</strong>最近的文档不支持<em class="hh"> notifyChange() </em>，这与<em class="hh"> queryChildDocuments() </em>和<em class="hh"> querySearchDocuments() </em>不同，因为默认情况下，结果是跨多个<em class="hh"> DocumentProvider </em>组合的(如果它们都是在不同时间更新的，则移动太多！).</p></blockquote><p id="1572" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">搜索一个根需要你实现<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#querySearchDocuments(java.lang.String,%20java.lang.String,%20java.lang.String[])" rel="noopener ugc nofollow" target="_blank"><em class="jd">query search documents()</em></a>。这里给出了一个特定的查询字符串，需要返回最相关的文档。虽然至少应该尝试匹配<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_DISPLAY_NAME" rel="noopener ugc nofollow" target="_blank"><em class="jd">COLUMN _ DISPLAY _ NAME</em></a>(不区分大小写)，但是它当然可以查看其他元数据——文件上的标签、图像的OCR等。只要确保它确实返回相关的结果！</p><h1 id="3326" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">进入文档的核心:字节！</h1><p id="1faa" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">在大多数情况下，用户经历这整个过程来实际选择和打开文件的原因。所以有意义的是，你必须实现的最后一个方法是<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#openDocument(java.lang.String,%20java.lang.String,%20android.os.CancellationSignal)" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="jd">open document()</em></strong></a>——你实际上是如何提供文档的原始字节的。</p><p id="8ef1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，你的任务是返回一个<a class="ae jc" href="https://developer.android.com/reference/android/os/ParcelFileDescriptor.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jd">parcel file descriptor</em></a>——比你的标准<em class="jd"> OutputStream </em>多一点，当然，但令人惊讶的是更灵活一点，支持读和写。如果您已经有了一个表示文档的本地文件，这就变成了一个相当简单的编写方法:</p><pre class="je jf jg jh fd kv kw kx ky aw kz bi"><span id="3c05" class="la jm hh kw b fi lb lc l ld le">public ParcelFileDescriptor openDocument(final String documentId,<br/>    final String mode,<br/>    final CancellationSignal signal) throws FileNotFoundException {<br/>  // Get a File from your documentId,<br/>  // downloading the file if necessary<br/>  File file = …;</span><span id="6d16" class="la jm hh kw b fi lf lc l ld le">  return ParcelFileDescriptor.open(file,<br/>    ParcelFileDescriptor.parseMode(mode));<br/>}</span></pre><blockquote class="lg lh li"><p id="1ce9" class="ie if jd ig b ih ii ij ik il im in io lj iq ir is lk iu iv iw ll iy iz ja jb ha bi translated"><strong class="ig hi">注意</strong>:如果你正在其他地方同步文件，并且需要知道文件关闭的时间，可以考虑使用<a class="ae jc" href="https://developer.android.com/reference/android/os/ParcelFileDescriptor.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#open(java.io.File,%20int,%20android.os.Handler,%20android.os.ParcelFileDescriptor.OnCloseListener)" rel="noopener ugc nofollow" target="_blank"> open() </a>调用，这个调用需要一个<a class="ae jc" href="https://developer.android.com/reference/android/os/ParcelFileDescriptor.OnCloseListener.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> <em class="hh"> OnCloseListener </em> </a>来准确地知道其他应用程序完成写入文件的时间——一定要检查<em class="hh"> IOException </em>来知道远程端是实际成功了还是遇到了错误。</p></blockquote><p id="eeb1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，如果你有一个更复杂的结构或者正在流式传输文件，你会想要查看<a class="ae jc" href="https://developer.android.com/reference/android/os/ParcelFileDescriptor.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#createReliablePipe()" rel="noopener ugc nofollow" target="_blank"><em class="jd">createreliable pipe()</em></a>或者<a class="ae jc" href="https://developer.android.com/reference/android/os/ParcelFileDescriptor.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#createReliableSocketPair()" rel="noopener ugc nofollow" target="_blank"><em class="jd">createReliableSocketPair()</em></a>，它们允许你创建一对<em class="jd">parcelfiledescripter</em>来返回其中一个并通过<a class="ae jc" href="https://developer.android.com/reference/android/os/ParcelFileDescriptor.AutoCloseOutputStream.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="jd">AutoCloseOutputStream</em></a>(用于发送数据)或者这些情况不支持“rw”读+写状态——这种情况假设随机访问和本地文件。</p><blockquote class="lg lh li"><p id="0022" class="ie if jd ig b ih ii ij ik il im in io lj iq ir is lk iu iv iw ll iy iz ja jb ha bi translated"><strong class="ig hi">注意</strong>:如果<a class="ae jc" href="https://developer.android.com/reference/android/os/CancellationSignal.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"><em class="hh">cancellation signal</em></a>不为空，偶尔要检查一下它的<a class="ae jc" href="https://developer.android.com/reference/android/os/CancellationSignal.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#isCanceled()" rel="noopener ugc nofollow" target="_blank"><em class="hh">is cancelled()</em></a>方法，放弃长时间运行的操作。</p></blockquote><h2 id="afbf" class="la jm hh bd jn lm ln lo jr lp lq lr jv ip ls lt jz it lu lv kd ix lw lx kh ly bi translated">提供缩略图</h2><p id="c9ec" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">默认情况下，每个文档使用基于其mime类型的默认图标。这可以通过包含<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_ICON" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> COLUMN_ICON </em> </a>提供自定义图标来覆盖，但是对于图像或视频(甚至文档/pdf)之类的文档，缩略图可以让用户判断出哪个是要选择的正确文档。</p><p id="b9b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当您将<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_SUPPORTS_THUMBNAIL" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ SUPPORTS _ THUMBNAIL</em></a>添加到文档中时，系统将调用<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#openDocumentThumbnail(java.lang.String,%20android.graphics.Point,%20android.os.CancellationSignal)" rel="noopener ugc nofollow" target="_blank">openDocumentThumbnail()</a>，传入大小提示—缩略图的建议大小(如前所述，图像不应超过提示大小的两倍)。由于这些将作为浏览过程的一部分可见，强烈建议缓存这些缩略图(比如在<a class="ae jc" href="https://developer.android.com/reference/android/content/Context.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#getCacheDir()" rel="noopener ugc nofollow" target="_blank"> getCacheDir() </a>)。</p><blockquote class="lg lh li"><p id="dc1b" class="ie if jd ig b ih ii ij ik il im in io lj iq ir is lk iu iv iw ll iy iz ja jb ha bi translated"><strong class="ig hi">注意</strong>:你会发现可以通过使用<em class="hh">new AssetFileDescriptor(ParcelFileDescriptor，0，AssetFileDescriptor)从parcel file descriptor创建asset file descriptor。【未知_长度)</em></p></blockquote><p id="c6aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你有一个完整的支持缩略图的文档目录，如果你在父目录上设置<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_DIR_PREFERS_GRID" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ DIR _ PREFERS _ GRID</em></a>来默认获得更大的缩略图，你的用户可能会很高兴。</p><h2 id="160f" class="la jm hh bd jn lm ln lo jr lp lq lr jv ip ls lt jz it lu lv kd ix lw lx kh ly bi translated">虚拟文件</h2><p id="2acb" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">虽然带有<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#MIME_TYPE_DIR" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> MIME_TYPE_DIR </em> </a>的文档是不可打开的(毕竟它们是目录！)，还有另一类文档实际上不能直接打开——这些被称为虚拟文件。对于Android Nougat和API 24来说，一个虚拟文件被标记为<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_VIRTUAL_DOCUMENT" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ VIRTUAL _ DOCUMENT</em></a>。当应用程序的意图中包含<a class="ae jc" href="https://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#CATEGORY_OPENABLE" rel="noopener ugc nofollow" target="_blank"><em class="jd">CATEGORY _ open</em></a>类别时，这些文件<strong class="ig hi">将不会被选择，并且永远不会调用<em class="jd"> openDocument() </em>。</strong></p><p id="c57a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那为什么还要包括他们呢？那么，当用户在附带的文件浏览器(Nexus设备上的设置- &gt;存储- &gt;浏览)中点击文件时发送的<a class="ae jc" href="https://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#ACTION_VIEW" rel="noopener ugc nofollow" target="_blank"> <em class="jd">动作_查看</em> </a>意图仍将与这些文件一起工作，允许用户在自己的应用程序中打开文件。</p><p id="9964" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虚拟文件还特别受益于API 24中添加的其他特性之一——备用文件格式。这允许虚拟文件具有替代的可打开的文件导出格式(例如用于云文档的PDF文件)。</p><h2 id="c35e" class="la jm hh bd jn lm ln lo jr lp lq lr jv ip ls lt jz it lu lv kd ix lw lx kh ly bi translated">替代文件格式</h2><p id="6e05" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">你返回的<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_MIME_TYPE" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> COLUMN_MIME_TYPE </em> </a>和你在<em class="jd"> openDocument() </em>中返回的内容之间有一个隐含的联系——如果你说你是一个<em class="jd"> "image/png" </em>，你最好是在传递一个png文件。在API 24+设备上，还有一个额外的选项:允许应用程序通过其他mime类型访问你的文档。例如，您可能正在提供<em class="jd"> "image/svg+xml" </em>文件，并希望允许应用程序使用固定分辨率的<em class="jd"> "image/png" </em>，因为缺少原生svg解析通常会使<em class="jd"> image/svg+xml </em>文件变得不太有用。</p><p id="e28a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，您的<em class="jd"> DocumentsProvider </em>可以实现<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#getDocumentStreamTypes(java.lang.String,%20java.lang.String)" rel="noopener ugc nofollow" target="_blank"><em class="jd">getDocumentStreamTypes()</em></a>来返回与给定文档id支持的给定mime类型过滤器(例如，“image/*”或“*/*”)相匹配的mime类型的完整列表。请记住，如果您的默认mime类型代表一个可打开的mime类型，那么您应该包括它。</p><p id="3676" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，当客户端将<a class="ae jc" href="https://developer.android.com/reference/android/content/ContentResolver.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#openTypedAssetFileDescriptor(android.net.Uri,%20java.lang.String,%20android.os.Bundle,%20android.os.CancellationSignal)" rel="noopener ugc nofollow" target="_blank"><em class="jd">opentypedasetfile descriptor()</em></a>与这些mime类型之一一起使用时，将触发对<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#openTypedDocument(java.lang.String,%20java.lang.String,%20android.os.Bundle,%20android.os.CancellationSignal)" rel="noopener ugc nofollow" target="_blank"><em class="jd">openTypedDocument()</em></a>的调用，该mime类型相当于<em class="jd"> openDocument() </em>。</p><h1 id="7827" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">超越动作获取内容</h1><p id="d950" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">我们讨论的大部分内容都是使用<em class="jd"> ACTION_GET_CONTENT </em>在KitKat设备上为客户端应用程序构建最佳体验，而客户端可以使用<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#isDocumentUri(android.content.Context,%20android.net.Uri)" rel="noopener ugc nofollow" target="_blank"><em class="jd">documentscontract . isdocumenturi()</em></a>来确定他们是否确实在接收文档Uri(一种有条件地使用所提供的更高级功能的好方法)，通过实现<em class="jd"> DocumentsProvider </em>，您还将允许客户端使用<a class="ae jc" href="https://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#ACTION_OPEN_DOCUMENT" rel="noopener ugc nofollow" target="_blank"><em class="jd">ACTION _ OPEN _ DOCUMENT</em></a>，这确保所有您的<em class="jd">文档提供者</em>还可以选择处理另外两个动作:<a class="ae jc" href="https://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#ACTION_OPEN_DOCUMENT_TREE" rel="noopener ugc nofollow" target="_blank"><em class="jd">ACTION _ OPEN _ DOCUMENT _ TREE</em></a>和<a class="ae jc" href="https://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#ACTION_CREATE_DOCUMENT" rel="noopener ugc nofollow" target="_blank"><em class="jd">ACTION _ CREATE _ DOCUMENT</em></a>。</p><blockquote class="lg lh li"><p id="7cd1" class="ie if jd ig b ih ii ij ik il im in io lj iq ir is lk iu iv iw ll iy iz ja jb ha bi translated"><strong class="ig hi">注意:</strong>如果你的应用程序包含一个<em class="hh">文档提供者</em>并且还持久化从<em class="hh"> ACTION_OPEN_DOCUMENT </em>、<em class="hh">ACTION _ OPEN _ DOCUMENT _ TREE</em>或<em class="hh"> ACTION_CREATE_DOCUMENT </em>返回的URIs，请注意<strong class="ig hi">你将无法持久化通过</strong><a class="ae jc" href="https://developer.android.com/reference/android/content/ContentResolver.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#takePersistableUriPermission(android.net.Uri,%20int)" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="hh">takespersistableuripermission()</em></strong></a>访问你自己的URIs——尽管它以一个如果您想在API 23+设备上隐藏您自己的文档提供者，您可以将布尔型<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#EXTRA_EXCLUDE_SELF" rel="noopener ugc nofollow" target="_blank"><em class="hh">EXTRA _ EXCLUDE _ SELF</em></a>添加到您的意图中。</p></blockquote><h2 id="0458" class="la jm hh bd jn lm ln lo jr lp lq lr jv ip ls lt jz it lu lv kd ix lw lx kh ly bi translated">动作_打开_文档_树</h2><p id="378b" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">虽然<em class="jd"> ACTION_GET_CONTENT </em>和<em class="jd"> ACTION_OPEN_DOCUMENT </em>专注于提供对一个或多个单独文档的访问，但是在API 21中添加了<a class="ae jc" href="https://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#ACTION_OPEN_DOCUMENT_TREE" rel="noopener ugc nofollow" target="_blank"><em class="jd">ACTION _ OPEN _ DOCUMENT _ TREE</em></a>以允许用户选择整个目录，从而给予其他应用对整个目录的持久访问。</p><p id="d727" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">支持<em class="jd">ACTION _ OPEN _ DOCUMENT _ TREE</em>包括将<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Root.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_SUPPORTS_IS_CHILD" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ SUPPORTS _ IS _ CHILD</em></a>添加到你的根，实现<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#isChildDocument(java.lang.String,%20java.lang.String)" rel="noopener ugc nofollow" target="_blank"><em class="jd">isChildDocument()</em></a>。这允许框架确认给定的文档ID是某个文档树的一部分:记住一个文档可以在你的层次结构中的多个位置，所以这是从父文档到潜在子文档(子文档、孙文档等)的“向下”检查。</p><p id="7153" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">理想情况下，这个请求不应该依赖于网络，因为它可以被频繁地快速连续调用，所以如果您想要支持这个用例，请确保您可以在本地处理这个请求。</p><h2 id="0229" class="la jm hh bd jn lm ln lo jr lp lq lr jv ip ls lt jz it lu lv kd ix lw lx kh ly bi translated">动作_创建_文档</h2><p id="b648" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">如果<em class="jd"> ACTION_OPEN_DOCUMENT </em>是传统操作系统的“打开文件”，<a class="ae jc" href="https://developer.android.com/reference/android/content/Intent.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#ACTION_CREATE_DOCUMENT" rel="noopener ugc nofollow" target="_blank"><em class="jd">ACTION _ CREATE _ DOCUMENT</em></a>是“保存文件”对话框，允许客户端在具有<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_DIR_SUPPORTS_CREATE" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ DIR _ SUPPORTS _ CREATE</em></a>的目录中，在具有<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Root.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_SUPPORTS_CREATE" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ SUPPORTS _ CREATE</em></a>的任何根目录下创建全新的文档(可以将根目录标志视为是否应该在<em class="jd">的UI中显示根目录的标志</em></p><p id="8485" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当用户选择一个目录来放置新文档时，您会收到一个对<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#createDocument(java.lang.String,%20java.lang.String,%20java.lang.String)" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> createDocument() </em> </a>的调用，其中包含所选目录的父文档ID、客户端应用程序指定的mime类型和显示名称(理想情况下，您应该设置为<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_DISPLAY_NAME" rel="noopener ugc nofollow" target="_blank"><em class="jd">COLUMN _ DISPLAY _ NAME</em></a>，但是您当然可以编辑它、添加扩展名等。如果需要)。您所要做的就是生成一个新的<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_DOCUMENT_ID" rel="noopener ugc nofollow" target="_blank"><em class="jd">COLUMN _ DOCUMENT _ ID</em></a>，然后客户端应用程序可以使用它来调用<em class="jd"> openDocument() </em>以实际写入文档的内容。</p><h2 id="e557" class="la jm hh bd jn lm ln lo jr lp lq lr jv ip ls lt jz it lu lv kd ix lw lx kh ly bi translated">资料管理</h2><p id="5f74" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">虽然核心体验总是由读取、写入和创建文档来驱动，但传统的文件管理器有更多的功能，其中许多功能在构建您的<em class="jd">文档提供者</em>时都受到<em class="jd">的支持，允许系统UI为那些想要浏览或管理您的文档的人提供额外的功能。</em></p><p id="a1c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个功能都有一个您需要添加到文档的<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_FLAGS" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> COLUMN_FLAGS </em> </a>的标志，以及一个您需要实现来执行操作的相关方法:</p><ul class=""><li id="9cd5" class="lz ma hh ig b ih ii il im ip mb it mc ix md jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_SUPPORTS_DELETE" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ SUPPORTS _ DELETE</em></a>(API 19)全部删除文档。实现<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#deleteDocument(java.lang.String)" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> deleteDocument() </em> </a>。</li><li id="c253" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_SUPPORTS_RENAME" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ SUPPORTS _ RENAME</em></a>(API 21)对文档进行重命名(更改其<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_DISPLAY_NAME" rel="noopener ugc nofollow" target="_blank"><em class="jd">COLUMN _ DISPLAY _ NAME</em></a>以及可选地更改其<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#COLUMN_DOCUMENT_ID" rel="noopener ugc nofollow" target="_blank"><em class="jd">COLUMN _ DOCUMENT _ ID</em></a>)。实现<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#renameDocument(java.lang.String,%20java.lang.String)" rel="noopener ugc nofollow" target="_blank"><em class="jd">rename document()</em></a>。</li><li id="6572" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_SUPPORTS_COPY" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ SUPPORTS _ COPY</em></a>(API 24)在您的<em class="jd"> DocumentsProvider </em>中的一个新的父目录下创建文档的副本。实现<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#copyDocument(java.lang.String,%20java.lang.String)" rel="noopener ugc nofollow" target="_blank"><em class="jd">copy document()</em></a>。</li><li id="1ed9" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_SUPPORTS_MOVE" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ SUPPORTS _ MOVE</em></a>(API 24)将文档从现有的父目录移动到您的<em class="jd"> DocumentsProvider </em>中的新父目录。实现<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#moveDocument(java.lang.String,%20java.lang.String,%20java.lang.String)" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> moveDocument() </em> </a>。</li><li id="3085" class="lz ma hh ig b ih mi il mj ip mk it ml ix mm jb me mf mg mh bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsContract.Document.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#FLAG_SUPPORTS_REMOVE" rel="noopener ugc nofollow" target="_blank"><em class="jd">FLAG _ SUPPORTS _ REMOVE</em></a>(API 24)从父目录中删除一个文档。实现<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#removeDocument(java.lang.String,%20java.lang.String)" rel="noopener ugc nofollow" target="_blank"><em class="jd">remove document()</em></a>。</li></ul><p id="6586" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请记住delete和remove之间的细微差别:<strong class="ig hi"> remove更关注文档和其父目录之间的关系</strong>。在文档只有一个<em class="jd">父文档的情况下，一个单独的删除会使文档成为孤儿，你通常想要触发与删除相同的代码(因为没有办法再导航到那个文档)。但是在单个文档有多个父目录的情况下，删除将影响每个父目录，而移除将是仅影响单个父目录的本地操作。</em></p><p id="1df7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当涉及到可以删除现有文档id的操作(如删除、移动和从最后一个父文档中删除)时，请确保您调用了<a class="ae jc" href="https://developer.android.com/reference/android/provider/DocumentsProvider.html?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog#revokeDocumentPermission(java.lang.String)" rel="noopener ugc nofollow" target="_blank"><em class="jd">【revokeDocumentPermission()</em></a>——这是告诉系统该文档ID不再有效，应从所有其他应用中撤销访问。</p><h1 id="6d5a" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">文档提供商:现代存储</h1><p id="a491" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">本地存储当然仍然非常重要，这也是系统为内部存储、SD卡和USB连接存储设备提供<em class="jd">文档提供者</em>的原因。借助存储访问框架，<strong class="ig hi">您的应用</strong>和您代表用户存储的数据现在就像在设备上一样可访问。</p><p id="21e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"># BuildBetterApps</p><p id="eeb6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关注<a class="ae jc" href="https://plus.google.com/collection/sLR0p?utm_campaign=android_series_adp_documentsprovider_blog_090716&amp;utm_source=medium&amp;utm_medium=blog" rel="noopener ugc nofollow" target="_blank"> Android开发模式集</a>了解更多！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/ede78edee0069962aa0daa7cc8c85f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6K7IYkWhCzkS6YAgxLfXw.png"/></div></div></figure></div></div>    
</body>
</html>