<html>
<head>
<title>Experimenting with the background fetch API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">尝试后台获取API</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/experimenting-with-the-background-fetch-api-ffc5bc1f55c5?source=collection_archive---------1-----------------------#2017-07-03">https://medium.com/google-developer-experts/experimenting-with-the-background-fetch-api-ffc5bc1f55c5?source=collection_archive---------1-----------------------#2017-07-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ad0289e4bde57c60cd728944960b6509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrRGHC_WNa4crOrM-wwzhg.png"/></div></div></figure><p id="419b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随着更多使用后台驻留工作器的方法的出现，服务工作器API正在扩展。我以前写过关于<a class="ae jn" href="https://www.twilio.com/blog/2016/02/web-powered-sms-inbox-with-service-worker-push-notifications.html" rel="noopener ugc nofollow" target="_blank">推送通知</a>和<a class="ae jn" href="https://www.twilio.com/blog/2017/02/send-messages-when-youre-back-online-with-service-workers-and-background-sync.html" rel="noopener ugc nofollow" target="_blank">后台同步</a>的文章，最近我探索了非常新的<a class="ae jn" href="https://github.com/WICG/background-fetch" rel="noopener ugc nofollow" target="_blank">后台获取API </a>。以下是我对它的了解。</p><h1 id="8be9" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">下载和上传</h1><p id="2f09" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">后台获取API试图解决两个问题:</p><ul class=""><li id="6c5c" class="kr ks hh ir b is it iw ix ja kt je ku ji kv jm kw kx ky kz bi translated">当服务人员正在下载大文件到缓存，而用户导航离开时，即使使用<code class="du la lb lc ld b">event.waitUntil</code>服务人员也可能最终被杀死</li><li id="3ef7" class="kr ks hh ir b is le iw lf ja lg je lh ji li jm kw kx ky kz bi translated">当上传文件并且用户导航离开时，上传被中断并且将失败</li></ul><p id="5f7a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">后台获取API允许开发人员在单个页面的上下文之外执行和控制对大文件或文件列表的获取。这可以增加成功上传和下载的可能性，并允许服务人员缓存结果。</p><p id="725f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在编写本文时，这个API可以在chrome://flags设置中打开了实验性web平台功能标志的情况下在Chrome中进行测试。</p><h1 id="e76f" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">测试一个例子</h1><p id="7a22" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">为了试图理解API是如何工作的，我决定构建一个简单的概念证明。在Glitch 上可以找到<a class="ae jn" href="https://fan-hubcap.glitch.me/" rel="noopener ugc nofollow" target="_blank">示例，或者您也可以</a><a class="ae jn" href="https://github.com/philnash/service-worker-background-fetch" rel="noopener ugc nofollow" target="_blank">从GitHub </a>检查并运行源代码。我不想处理大文件，所以这个例子试图加载一个有10秒延迟的图像(毛刺为4.5秒)。</p><p id="479e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有一个服务工作器被设置为直接从缓存中提供图像(如果存在的话),否则它会转到网络。</p><pre class="lj lk ll lm fd ln ld lo lp aw lq bi"><span id="b76f" class="lr jp hh ld b fi ls lt l lu lv">// sw.js<br/>self.addEventListener('fetch', function(event) {<br/>  if (event.request.url.match(/images/)) {<br/>    event.respondWith(<br/>      caches.open('downloads').then(cache =&gt; {<br/>        return cache.match(event.request).then(response =&gt; {<br/>          return response || fetch(event.request);<br/>        });<br/>      })<br/>    );<br/>  } else {<br/>    event.respondWith(caches.match(event.request));<br/>  }<br/>});</span></pre><p id="9301" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">相当标准的服务人员的东西到目前为止，这里是新的东西。</p><p id="4ed3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">点击“开始下载”按钮将启动后台获取。提取被标记为“大文件”(我觉得很有创意)。当后台获取正在进行时，您可以离开页面，下载将继续在后台进行。</p><pre class="lj lk ll lm fd ln ld lo lp aw lq bi"><span id="6473" class="lr jp hh ld b fi ls lt l lu lv">// index.html<br/>if ('serviceWorker' in navigator) {<br/>  navigator.serviceWorker.register('/sw.js').then(function(reg) {<br/>    const button = document.getElementById('download');<br/>    if ('backgroundFetch' in reg) {<br/>      button.addEventListener('click', function(event) {<br/>        reg.backgroundFetch.fetch('large-file', [new Request('/images/twilio.png')], {<br/>          title: 'Downloading large image'<br/>        }).then(function(backgroundFetch) { console.log(backgroundFetch) });<br/>      })<br/>    }<br/>  });<br/>}</span></pre><p id="c226" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下载完成后，服务人员会收到<code class="du la lb lc ld b">backgroundfetched</code>事件。该事件有一个<code class="du la lb lc ld b">fetches</code>属性，它指向包含每个请求和响应的对象数组。代码循环通过<code class="du la lb lc ld b">fetches</code>(尽管在这种情况下我们知道只有一个)并将响应放入缓存。</p><pre class="lj lk ll lm fd ln ld lo lp aw lq bi"><span id="5951" class="lr jp hh ld b fi ls lt l lu lv">self.addEventListener('backgroundfetched', function(event) {<br/>  event.waitUntil(<br/>    caches.open('downloads').then(function(cache) {<br/>      event.updateUI('Large file downloaded');<br/>      registration.showNotification('File downloaded!');<br/>      const promises = event.fetches.map(({ request, response }) =&gt; {<br/>        if (response &amp;&amp; response.ok) {<br/>          return cache.put(request, response.clone());<br/>        }<br/>      });<br/>      return Promise.all(promises);<br/>    })<br/>  );<br/>});</span></pre><p id="8bfa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，当请求映像时，它将直接从服务工作者缓存中提供，不再有缓慢的下载。</p><h1 id="3efc" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">关于后台取数API的思考</h1><p id="292b" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">如你所见，实现后台获取API并不困难。在这次初步探索中，有一些事件我没有实现，即<code class="du la lb lc ld b">backgroundfetchfail</code>、<code class="du la lb lc ld b">backgroundfetchabort</code>和<code class="du la lb lc ld b">backgroundfetchclick</code>事件。在一个功能齐全的应用程序中，您会期望这样做。</p><h2 id="3b5c" class="lr jp hh bd jq lw lx ly ju lz ma mb jy ja mc md kc je me mf kg ji mg mh kk mi bi translated">音频困难</h2><p id="677d" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我最初用一个音频文件开始这个实验，但是发现很难证明我已经成功地将音频文件存储在缓存中。我并不为此责怪后台获取API，而是在服务工作者获取事件中处理范围请求的<a class="ae jn" href="https://samdutton.github.io/samples/service-worker/prefetch-video/" rel="noopener ugc nofollow" target="_blank">问题。鉴于该API对于下载丰富应用程序的大型音频和视频资源非常有用，让开发人员更容易地使用该API应该是任何从事该功能的服务人员讨论的重要部分。</a></p><h2 id="89a7" class="lr jp hh bd jq lw lx ly ju lz ma mb jy ja mc md kc je me mf kg ji mg mh kk mi bi translated">出现在下载中</h2><p id="ac49" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">当我在桌面上用Chrome测试时，我惊讶地发现文件是以用户可见的方式下载的。我的期望是，该文件将留给服务人员来处理和缓存。相反，它出现在我的下载文件夹中。例如，如果您使用后台获取API来获取游戏的资源，我不希望在用户的下载文件夹中丢弃只在应用程序中使用的资源。不过，当我在Android设备上测试时，这种情况并没有发生。</p><h2 id="9d66" class="lr jp hh bd jq lw lx ly ju lz ma mb jy ja mc md kc je me mf kg ji mg mh kk mi bi translated">什么UI？</h2><p id="f55f" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在API中，有一些地方会影响浏览器UI，您可以为获取设置标题和图标，并使用<code class="du la lb lc ld b">event.updateUI</code>方法更新标题。然而，在我的桌面或移动测试中，我在任何地方都看不到这个UI。我只能假设这是正在工作，并将与另一个版本的金丝雀。</p><h1 id="278b" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">敬未来</h1><p id="9e1e" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我喜欢玩这些早期的API，它们有很大的潜力(我也很期待<a class="ae jn" href="https://philna.sh/blog/2017/03/14/the-web-share-api/" rel="noopener ugc nofollow" target="_blank"> Web Share API </a>的回归！).对于需要下载大文件或大量文件的应用程序来说，后台获取API将是一个很好的选择，比仅仅使用服务工作者缓存有更多的控制。它显然会对视频和音频应用有用，但游戏和虚拟现实体验肯定也会从中受益。</p><p id="9eb0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我认为在浏览器方面仍有工作要做，以使这种体验对开发者和用户都是好的，但看到服务人员的进步是令人兴奋的。我的下一个计划是构建一个应用程序，在现实世界中充分利用后台获取API，以及其他服务工作者特性。关注<a class="ae jn" href="http://github.com/philnash/" rel="noopener ugc nofollow" target="_blank">我的GitHub简介</a>跟踪进展。</p><p id="ea59" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你对后台获取API感兴趣，GitHub 上有<a class="ae jn" href="https://github.com/WICG/background-fetch" rel="noopener ugc nofollow" target="_blank">更多关于这个提议的例子和讨论。如果你也对浏览器即将推出这样的功能感到兴奋，请在Twitter上给我留言。</a></p></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><p id="e7b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://philna.sh/blog/2017/07/04/experimenting-with-the-background-fetch-api/" rel="noopener ugc nofollow" target="_blank"> <em class="mq">试验后台取API </em> </a> <em class="mq">原载于2017年7月4日</em><a class="ae jn" href="https://philna.sh/blog/2017/07/04/experimenting-with-the-background-fetch-api/" rel="noopener ugc nofollow" target="_blank"><em class="mq">philna . sh</em></a><em class="mq">。</em></p></div></div>    
</body>
</html>