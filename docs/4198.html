<html>
<head>
<title>Who’s afraid of Machine Learning? Part 5 : Running ML-Kit On Device</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谁害怕机器学习？第5部分:在设备上运行ML-Kit</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/whos-afraid-of-machine-learning-part-5-running-ml-kit-on-device-394b6c19f00f?source=collection_archive---------5-----------------------#2018-10-05">https://medium.com/google-developer-experts/whos-afraid-of-machine-learning-part-5-running-ml-kit-on-device-394b6c19f00f?source=collection_archive---------5-----------------------#2018-10-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="f8e1" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">面向移动开发者的ML &amp; ML-Kit简介</h2></div><p id="071c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上一篇帖子给出了一个<a class="ae js" rel="noopener" href="/google-developer-experts/https-medium-com-britt-barak-whos-afraid-of-ml-part1-e464264c3cf0"> <strong class="iy hi"> <em class="jt">介绍ML </em> </strong> </a>，to<a class="ae js" rel="noopener" href="/google-developer-experts/whos-afraid-of-machine-learning-part-4-going-mobile-ml-kit-why-how-200f245ef8f8"><strong class="iy hi"><em class="jt">ML kit</em></strong></a>，并讨论了为什么我们需要一个<a class="ae js" rel="noopener" href="/google-developer-experts/whos-afraid-of-machine-learning-part-4-going-mobile-ml-kit-why-how-200f245ef8f8"> <strong class="iy hi"> <em class="jt">移动的具体解决方案</em> </strong> </a>用于ML功能。</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ju"><img src="../Images/83f93e67ce315008de73254724b90cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1C_qMpeBTQnpdFpv"/></div></div></figure><p id="f78a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在…是时候写一些代码了！</p><h2 id="937c" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">开始之前:</h2><ol class=""><li id="861e" class="lb lc hh iy b iz ld jc le jf lf jj lg jn lh jr li lj lk ll bi translated">克隆这个项目与代码开始，并执行每一步<a class="ae js" href="https://github.com/brittBarak/MLKitDemo" rel="noopener ugc nofollow" target="_blank">https://github.com/brittBarak/MLKitDemo</a></li><li id="206a" class="lb lc hh iy b iz lm jc ln jf lo jj lp jn lq jr li lj lk ll bi translated">将Firebase添加到您的应用程序:</li></ol><ul class=""><li id="04b1" class="lb lc hh iy b iz ja jc jd jf lr jj ls jn lt jr lu lj lk ll bi translated">登录消防基地控制台:【https://console.firebase.google.com T21】</li><li id="d5da" class="lb lc hh iy b iz lm jc ln jf lo jj lp jn lq jr lu lj lk ll bi translated">创建一个新项目，或选择一个现有项目</li><li id="bca7" class="lb lc hh iy b iz lm jc ln jf lo jj lp jn lq jr lu lj lk ll bi translated">在左侧菜单中，转到设置→</li></ul><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es lv"><img src="../Images/9191cce3fbc4ef3016a4167894252dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/0*jkZfeP8OXpYDLg_W"/></div></figure><ul class=""><li id="1fde" class="lb lc hh iy b iz ja jc jd jf lr jj ls jn lt jr lu lj lk ll bi translated">在<em class="jt">常规</em>选项卡下→在<em class="jt">你的应用</em>部分下，选择“添加应用”。</li></ul><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lw"><img src="../Images/18f9dd3e7c69998add73d075abdf368b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*72RBdmrVz1_CRjhJ"/></div></div></figure><ul class=""><li id="be2a" class="lb lc hh iy b iz ja jc jd jf lr jj ls jn lt jr lu lj lk ll bi translated">按照Firebase教程中的步骤，将Firebase添加到您的应用程序中。</li></ul><figure class="jv jw jx jy fd jz er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lx"><img src="../Images/c034bed205b49bda28ed61fcf35599bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AKfV3I1sA6p3xOUH"/></div></div></figure><p id="156a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">3.将<em class="jt"> firebase-ml-vision </em>库添加到您的app:在您的<em class="jt"> app级</em> <code class="du ly lz ma mb b"><em class="jt">buid.gradle</em></code>文件上添加:</p><pre class="jv jw jx jy fd mc mb md me aw mf bi"><span id="78f6" class="kg kh hh mb b fi mg mh l mi mj">dependencies {<br/>   // …<br/>   <br/>   implementation ‘com.google.firebase:firebase-ml-vision:17.0.0’<br/>}</span></pre><p id="27a7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi"/></p><p id="8a11" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如上所述，我们将使用一个本地、一个on设备和一个自定义检测器。每个都有4个步骤:</p><p id="54b1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">0.设置(不是出轨:)真的不算一步…)</p><ol class=""><li id="2fb2" class="lb lc hh iy b iz ja jc jd jf lr jj ls jn lt jr li lj lk ll bi translated">设置分类器</li><li id="5534" class="lb lc hh iy b iz lm jc ln jf lo jj lp jn lq jr li lj lk ll bi translated">处理输入</li><li id="6a2f" class="lb lc hh iy b iz lm jc ln jf lo jj lp jn lq jr li lj lk ll bi translated">运行模型</li><li id="f8a6" class="lb lc hh iy b iz lm jc ln jf lo jj lp jn lq jr li lj lk ll bi translated">处理输出</li></ol><ul class=""><li id="2dbe" class="lb lc hh iy b iz ja jc jd jf lr jj ls jn lt jr lu lj lk ll bi translated"><strong class="iy hi">注</strong>:如果你更喜欢跟随long的最终代码，你可以在demo的<a class="ae js" href="https://github.com/brittBarak/MLKitDemo" rel="noopener ugc nofollow" target="_blank"> repo </a>的分支<a class="ae js" href="https://github.com/brittBarak/MLKitDemo/tree/1.run_local_model" rel="noopener ugc nofollow" target="_blank"> 1.run_local_model </a>中找到。</li></ul><h1 id="e790" class="mk kh hh bd ki ml mm mn km mo mp mq kq in mr io kt iq ms ir kw it mt iu kz mu bi translated">运行本地(设备上)模型</h1><p id="3c38" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf mv jh ji jj mw jl jm jn mx jp jq jr ha bi translated">选择本地模型是轻量级和离线支持的选项。反过来，它的准确性是有限的，这一点我们必须考虑到。</p><p id="0ba7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du ly lz ma mb b">UI</code>取位图→调用<code class="du ly lz ma mb b">ImageClassifier.executeLocal(bitmap)</code> → <code class="du ly lz ma mb b">ImageClassifier</code>调用<code class="du ly lz ma mb b">LocalClassifier.execute()</code></p><h2 id="b1ca" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">步骤0:设置</h2><ol class=""><li id="57c8" class="lb lc hh iy b iz ld jc le jf lf jj lg jn lh jr li lj lk ll bi translated">通过Firebase MLKit为您的应用添加本地检测器:</li></ol><p id="20d0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在你的应用级<code class="du ly lz ma mb b">build.gradle</code>文件上添加:</p><pre class="jv jw jx jy fd mc mb md me aw mf bi"><span id="54cb" class="kg kh hh mb b fi mg mh l mi mj">dependencies {<br/>  // ...</span><span id="1eb3" class="kg kh hh mb b fi my mh l mi mj">  implementation 'com.google.firebase:firebase-ml-vision-image-label-model:15.0.0'<br/>}</span></pre><p id="2f25" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">可选，但推荐</strong>:默认情况下，只有执行<em class="jt">检测器</em>后，ML模型本身才会被下载。这意味着在第一次执行时会有一些延迟，并且需要网络访问。要绕过这一点，并在应用程序从Play Store安装时下载ML模型，只需将以下声明添加到应用程序的<code class="du ly lz ma mb b">AndroidManifest.xml</code>文件中:</p><pre class="jv jw jx jy fd mc mb md me aw mf bi"><span id="e5f0" class="kg kh hh mb b fi mg mh l mi mj">&lt;application ...&gt;<br/>  ...<br/>  <strong class="mb hi">&lt;meta-data<br/>      android:name="com.google.firebase.ml.vision.DEPENDENCIES"<br/>      android:value="label" /&gt;</strong></span><span id="d4be" class="kg kh hh mb b fi my mh l mi mj">  &lt;!-- To use multiple models: android:value="label,barcode,face..." --&gt;</span><span id="f948" class="kg kh hh mb b fi my mh l mi mj">&lt;/application&gt;</span></pre><h2 id="ef2c" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">步骤1:设置分类器</h2><p id="c76c" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf mv jh ji jj mw jl jm jn mx jp jq jr ha bi translated">创建保存<strong class="iy hi"> <em class="jt">检测器</em> </strong>对象的<strong class="iy hi"><em class="jt">local classifier</em></strong>类:</p><pre class="jv jw jx jy fd mc mb md me aw mf bi"><span id="9d43" class="kg kh hh mb b fi mg mh l mi mj"><strong class="mb hi">public class </strong>LocalClassifier {</span><span id="00f2" class="kg kh hh mb b fi my mh l mi mj"><em class="jt">    </em><strong class="mb hi">detector </strong>= FirebaseVision.<em class="jt">getInstance</em>().<strong class="mb hi">getVisionLabelDetector</strong>();<br/>}</span></pre><p id="eb5e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是基本的<em class="jt">探测器</em>实例。可以对返回的输出更加挑剔，增加<strong class="iy hi"> <em class="jt">置信度阈值</em> </strong> <em class="jt"> </em>，在0–1之间，默认为0.5。</p><pre class="jv jw jx jy fd mc mb md me aw mf bi"><span id="9ee7" class="kg kh hh mb b fi mg mh l mi mj"><strong class="mb hi">public class </strong>LocalClassifier {</span><span id="469e" class="kg kh hh mb b fi my mh l mi mj">    FirebaseVisionLabelDetectorOptions <strong class="mb hi">localDetectorOptions </strong>=<br/>            <strong class="mb hi">new </strong>FirebaseVisionLabelDetectorOptions.Builder()<br/>                    .setConfidenceThreshold(ImageClassifier.<strong class="mb hi"><em class="jt">CONFIDENCE_THRESHOLD</em></strong>)<br/>                    .build();</span><span id="4d32" class="kg kh hh mb b fi my mh l mi mj"><em class="jt">    </em><strong class="mb hi">private </strong>FirebaseVisionLabelDetector <strong class="mb hi">classifier </strong>= FirebaseVision.<em class="jt">getInstance</em>().getVisionLabelDetector(<strong class="mb hi">localDetectorOptions</strong>);</span><span id="b3c2" class="kg kh hh mb b fi my mh l mi mj">}</span></pre><h2 id="730e" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">步骤2:处理输入</h2><p id="5ac7" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf mv jh ji jj mw jl jm jn mx jp jq jr ha bi translated"><code class="du ly lz ma mb b">FirebaseVisionLabelDetector </code>知道如何处理<code class="du ly lz ma mb b">FirebaseVisionImage</code>类型的输入。您可以从以下任一途径获得一个<code class="du ly lz ma mb b">FirebaseVisionImage</code>实例:</p><ul class=""><li id="0f44" class="lb lc hh iy b iz ja jc jd jf lr jj ls jn lt jr lu lj lk ll bi translated"><strong class="iy hi"> <em class="jt">位图</em></strong>——这就是我们在这个演示应用程序中要做的。为了简单起见，我将图像作为静态文件保存在assets文件夹中。</li><li id="124b" class="lb lc hh iy b iz lm jc ln jf lo jj lp jn lq jr lu lj lk ll bi translated"><strong class="iy hi"/></li><li id="f508" class="lb lc hh iy b iz lm jc ln jf lo jj lp jn lq jr lu lj lk ll bi translated"><strong class="iy hi"> <em class="jt">媒体</em> </strong> <a class="ae js" href="https://developer.android.com/reference/android/media/Image.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iy hi"> <em class="jt">图像</em></strong></a>——如果我们从媒体中获得输入图像，例如，从设备摄像机中。</li><li id="3dc2" class="lb lc hh iy b iz lm jc ln jf lo jj lp jn lq jr lu lj lk ll bi translated"><strong class="iy hi"> <em class="jt">字节数组</em> </strong></li><li id="aa80" class="lb lc hh iy b iz lm jc ln jf lo jj lp jn lq jr lu lj lk ll bi translated"><strong class="iy hi"> <em class="jt"> ByteBuffer </em> </strong></li></ul><p id="c220" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于我们使用的是<strong class="iy hi"> <em class="jt">位图</em> </strong>，输入处理简单如下:</p><pre class="jv jw jx jy fd mc mb md me aw mf bi"><span id="28bb" class="kg kh hh mb b fi mg mh l mi mj">class<strong class="mb hi"> LocalClassifier</strong> {<br/>    //...<br/>    <br/>    FirebaseVisionImage <strong class="mb hi">image</strong>;<br/>    public void<strong class="mb hi"> execute</strong>(Bitmap bitmap) {</span><span id="392d" class="kg kh hh mb b fi my mh l mi mj"><em class="jt">        </em><strong class="mb hi">image </strong>= FirebaseVisionImage.<em class="jt">fromBitmap</em>(bitmap);<br/>    }<br/>}</span></pre><ul class=""><li id="6d41" class="lb lc hh iy b iz ja jc jd jf lr jj ls jn lt jr lu lj lk ll bi translated"><strong class="iy hi"> <em class="jt">提示</em> </strong>:我们想使用局部模型的原因之一是因为它的执行速度更快。但是，执行任何模型都需要一些时间。如果您在实时应用程序中使用该模型，您可能需要更快的结果。<strong class="iy hi">在移动到下一步</strong>之前减小位图尺寸，可以改善模型的处理时间。</li></ul><h2 id="d7fd" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">步骤3:运行模型</h2><p id="3b69" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf mv jh ji jj mw jl jm jn mx jp jq jr ha bi translated">这就是奇迹发生的地方！🔮由于模型确实需要一些计算时间，我们应该让模型异步运行，并使用侦听器返回成功或失败的结果。</p><pre class="jv jw jx jy fd mc mb md me aw mf bi"><span id="3cc5" class="kg kh hh mb b fi mg mh l mi mj"><strong class="mb hi">public class </strong>LocalClassifier {</span><span id="114d" class="kg kh hh mb b fi my mh l mi mj">    //...</span><span id="486b" class="kg kh hh mb b fi my mh l mi mj">    public void<strong class="mb hi"> execute</strong>(Bitmap bitmap, <strong class="mb hi">OnSuccessListener</strong>     successListener, <strong class="mb hi">OnFailureListener</strong> failureListener) {<br/>        <em class="jt">//...</em></span><span id="7c54" class="kg kh hh mb b fi my mh l mi mj"><strong class="mb hi">        detector</strong>.detectInImage(<strong class="mb hi">image</strong>)<br/>                .addOnSuccessListener(successListener)<br/>                .addOnFailureListener(failureListener);</span><span id="e861" class="kg kh hh mb b fi my mh l mi mj">    }<br/>}</span></pre><h2 id="ee7c" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">步骤4:处理输出</h2><p id="bde7" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf mv jh ji jj mw jl jm jn mx jp jq jr ha bi translated">检测输出在<code class="du ly lz ma mb b"><strong class="iy hi"><em class="jt">OnSuccessListener</em></strong></code>上提供。我更喜欢将<code class="du ly lz ma mb b">OnSuccessListener</code> <strong class="iy hi"> </strong>从<code class="du ly lz ma mb b"><em class="jt">ImageClassifier</em></code>传递到<code class="du ly lz ma mb b"><em class="jt">LocalClassifier</em></code>，处理<code class="du ly lz ma mb b"><em class="jt">UI</em></code>和<code class="du ly lz ma mb b"><em class="jt">LocalClassifier</em></code> <em class="jt">之间的通信。</em></p><p id="4657" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">UI调用<code class="du ly lz ma mb b"> <strong class="iy hi"><em class="jt">ImageClassifier.executeLocal()</em></strong></code> <strong class="iy hi"> <em class="jt">，</em> </strong>应该是这样的:</p><p id="9e5c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<code class="du ly lz ma mb b"><strong class="iy hi">ImageClassifier.java :</strong></code></p><pre class="jv jw jx jy fd mc mb md me aw mf bi"><span id="6bd8" class="kg kh hh mb b fi mg mh l mi mj"><strong class="mb hi">localClassifier </strong>= new<strong class="mb hi"> </strong>LocalClassifier();</span><span id="4357" class="kg kh hh mb b fi my mh l mi mj">public void <strong class="mb hi">executeLocal</strong>(Bitmap bitmap, ClassifierCallback callback) {</span><span id="e40e" class="kg kh hh mb b fi my mh l mi mj"><strong class="mb hi">    successListener</strong> = new<strong class="mb hi"> </strong>OnSuccessListener&lt;List&lt;FirebaseVisionLabel&gt;&gt;() {</span><span id="780a" class="kg kh hh mb b fi my mh l mi mj">        public void<strong class="mb hi"> </strong>onSuccess(List&lt;FirebaseVisionLabel&gt; labels) {<br/>            <strong class="mb hi">processLocalResult</strong>(labels, callback, start);<br/>        }</span><span id="d8f7" class="kg kh hh mb b fi my mh l mi mj">   };</span><span id="c88f" class="kg kh hh mb b fi my mh l mi mj"><strong class="mb hi">    localClassifier</strong>.execute(bitmap, successListener, failureListener);</span><span id="efaf" class="kg kh hh mb b fi my mh l mi mj">}</span></pre><p id="bfd6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du ly lz ma mb b"><strong class="iy hi">processLocalResult()</strong></code> <strong class="iy hi"> </strong>只是准备输出<em class="jt">标签</em>显示在UI上。</p><p id="975c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我的具体例子中，我选择显示概率最高的3个结果。您可以选择任何其他格式类型。为了完成这幅图，这是我的实现:</p><p id="2f9e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<code class="du ly lz ma mb b"><strong class="iy hi">ImageClassifier.java :</strong></code>上</p><pre class="jv jw jx jy fd mc mb md me aw mf bi"><span id="e911" class="kg kh hh mb b fi mg mh l mi mj">void<strong class="mb hi"> </strong>processLocalResult(List&lt;FirebaseVisionLabel&gt; labels, ClassifierCallback callback) {</span><span id="c68c" class="kg kh hh mb b fi my mh l mi mj">    labels.sort(<strong class="mb hi">localLabelComparator</strong>);</span><span id="45f6" class="kg kh hh mb b fi my mh l mi mj"><strong class="mb hi">    resultLabels</strong>.clear();</span><span id="b78a" class="kg kh hh mb b fi my mh l mi mj">    FirebaseVisionLabel label;</span><span id="e338" class="kg kh hh mb b fi my mh l mi mj">    for<strong class="mb hi"> </strong>(<strong class="mb hi">int </strong>i = 0; i &lt; Math.<em class="jt">min</em>(<em class="jt">3</em>, labels.size()); ++i) {</span><span id="c891" class="kg kh hh mb b fi my mh l mi mj">        label = labels.get(i);</span><span id="12b8" class="kg kh hh mb b fi my mh l mi mj"><strong class="mb hi">        resultLabels</strong>.add(label.getLabel() + <strong class="mb hi">“:” </strong>+ label.getConfidence());</span><span id="2fab" class="kg kh hh mb b fi my mh l mi mj">    }</span><span id="d64f" class="kg kh hh mb b fi my mh l mi mj">    callback.onClassified(<strong class="mb hi">“Local Model”</strong>, <strong class="mb hi">resultLabels</strong>);</span><span id="8043" class="kg kh hh mb b fi my mh l mi mj">}</span></pre><p id="b3dd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du ly lz ma mb b"><em class="jt">ClassifierCallback</em></code>是我创建的一个简单界面，目的是将结果反馈给UI显示。当然，我们可以使用任何其他方法。</p><pre class="jv jw jx jy fd mc mb md me aw mf bi"><span id="321e" class="kg kh hh mb b fi mg mh l mi mj">interface<strong class="mb hi"> ClassifierCallback</strong> {<br/>    void<strong class="mb hi"> onClassified</strong>(String modelTitle, List&lt;String&gt; topLabels);<br/>}</span></pre></div><div class="ab cl mz na go nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ha hb hc hd he"><h2 id="2768" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">就是这样！</h2><p id="287d" class="pw-post-body-paragraph iw ix hh iy b iz ld ii jb jc le il je jf mv jh ji jj mw jl jm jn mx jp jq jr ha bi translated">你用你的第一个ML模型对一幅图像进行了分类！🎉有多简单？！</p><p id="52c4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们运行应用程序，看看一些结果！</p><figure class="jv jw jx jy fd jz er es paragraph-image"><div class="er es ng"><img src="../Images/f0f659b5056c0b54c33518aa96a2787a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*wkIqjlaDyX0f6ZP3LZ9-cQ.gif"/></div></figure><p id="e16e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">相当不错！！！我们有一些通用的标签，如“食物”或“水果”，这肯定符合图像，但我希望模型能够告诉我这是什么水果..</p><p id="69e6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本演示的<a class="ae js" href="https://github.com/brittBarak/MLKitDemo" rel="noopener ugc nofollow" target="_blank">回购</a>分支<a class="ae js" href="https://github.com/brittBarak/MLKitDemo/tree/1.run_local_model" rel="noopener ugc nofollow" target="_blank"> 1.run_local_model </a>上获取该零件的最终代码</p><p id="8f37" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来:让我们在下一篇文章中，通过使用基于云的探测器，尝试获得一些更具指示性和更准确的标签！</p></div></div>    
</body>
</html>