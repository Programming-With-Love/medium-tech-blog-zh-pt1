<html>
<head>
<title>Room 🔗 Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">房间🔗协同程序</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/room-coroutines-422b786dc4c5?source=collection_archive---------1-----------------------#2019-02-06">https://medium.com/androiddevelopers/room-coroutines-422b786dc4c5?source=collection_archive---------1-----------------------#2019-02-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/922aac9373cefb037b18d992d11d7277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6RyWETnyL2sG7wVUST49YQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/vpoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="49c7" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">给你的数据库增加一些悬念</h2></div><p id="b16b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Room 2.1 <a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/room" rel="noopener ugc nofollow" target="_blank">增加了</a>对Kotlin协程的支持。现在可以将DAO方法标记为挂起，以确保它们不会在主线程上执行。请继续阅读，了解如何使用它，它是如何工作的，以及如何测试这个新功能。</p><h1 id="9106" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">给你的数据库增加一些悬念</h1><p id="f40e" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">要在您的应用程序中使用协程和Room，请更新到Room 2.1并将新的依赖项添加到您的<code class="du lf lg lh li b">build.gradle</code>文件中:</p><pre class="lj lk ll lm fd ln li lo lp aw lq bi"><span id="f0fa" class="lr kj hx li b fi ls lt l lu lv">implementation "androidx.room:room-coroutines:${versions.room}"</span></pre><p id="5329" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">你还需要Kotlin 1.3.0和<a class="ae hu" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">协程</a> 1.0.0或更新版本。</p><p id="a93a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">现在，您可以更新您的DAO方法以使用挂起函数:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">DAO with <code class="du lf lg lh li b">suspend</code> methods</figcaption></figure><p id="f7c3" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><code class="du lf lg lh li b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/Transaction" rel="noopener ugc nofollow" target="_blank">@Transaction</a></code>方法也可以是挂起的，它们可以调用其他挂起的DAO函数:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">DAO with suspend transaction function</figcaption></figure><p id="dda7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">您还可以在一个事务中从不同的Dao调用挂起函数:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Calling different DAO suspending functions in a transaction</figcaption></figure><p id="51d9" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">您可以提供执行器(在构建数据库时通过调用<code class="du lf lg lh li b"><a class="ae hu" href="https://developer.android.com/reference/androidx/room/RoomDatabase.Builder#setTransactionExecutor(java.util.concurrent.Executor)" rel="noopener ugc nofollow" target="_blank">setTransactionExecutor</a></code>或<code class="du lf lg lh li b"><a class="ae hu" href="https://developer.android.com/reference/androidx/room/RoomDatabase.Builder#setQueryExecutor(java.util.concurrent.Executor)" rel="noopener ugc nofollow" target="_blank">setQueryExecutor</a></code>来控制它们运行的线程)。默认情况下，这将是用于在后台线程上运行查询的同一个执行器。</p><h1 id="5fa5" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">测试DAO悬挂功能</h1><p id="2f68" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">测试DAO挂起函数与测试任何其他挂起函数没有什么不同。例如，为了检查在插入一个用户后我们是否能够检索它，我们将测试包装在一个<code class="du lf lg lh li b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html" rel="noopener ugc nofollow" target="_blank">runBlocking</a></code>块中:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Testing DAO suspend functions</figcaption></figure><h1 id="4eb1" class="ki kj hx bd kk kl km kn ko kp kq kr ks jd kt je ku jg kv jh kw jj kx jk ky kz bi translated">在后台</h1><p id="1e74" class="pw-post-body-paragraph jm jn hx jo b jp la iy jr js lb jb ju jv lc jx jy jz ld kb kc kd le kf kg kh ha bi translated">为了了解幕后的情况，让我们看一下实现室为同步插入和挂起插入生成的DAO类:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Synchronous and suspending insert functions</figcaption></figure><p id="3ec6" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">对于同步插入，生成的代码启动一个事务，执行插入，将事务标记为成功，然后结束它。同步方法将只在调用它的线程上执行插入。</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Room synchronous insert generated implementation</figcaption></figure><p id="76cf" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">现在让我们看看添加suspend修改器是如何改变事情的:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Room suspending insert generated implementation</figcaption></figure><p id="aa2f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">生成的代码确保插入发生在UI线程之外。在我们的挂起函数实现中，来自同步插入方法的相同逻辑被包装在一个“可调用”中。Room调用“CoroutinesRoom.execute”挂起函数，该函数根据数据库是否打开以及我们是否在事务中切换到后台调度程序。下面是该函数的实现:</p><figure class="lj lk ll lm fd hj"><div class="bz dy l di"><div class="lw lx l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">CoroutinesRoom.execute implementation</figcaption></figure><p id="d06d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy">案例一。数据库被打开，我们在一个交易</strong></p><p id="979f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这里我们只是立即执行callable——即用户在数据库中的实际插入</p><p id="5090" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy">案例二。否则</strong></p><p id="2109" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Room确保在Callable#call方法中完成的工作是在后台线程上执行的。</p><p id="bd64" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">房间将使用不同的调度员进行交易和查询。这些是从您在构建数据库时提供的执行器派生出来的，或者默认情况下将使用架构组件IO执行器。这是LiveData用来做后台工作的同一个执行器。</p><p id="3333" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果您有兴趣查看实现，请查看<a class="ae hu" href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/room/ktx/src/main/java/androidx/room/CoroutinesRoom.kt" rel="noopener ugc nofollow" target="_blank">CoroutinesRoom.java</a>和<a class="ae hu" href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/room/ktx/src/main/java/androidx/room/RoomDatabase.kt" rel="noopener ugc nofollow" target="_blank"> RoomDatabase.kt </a></p></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><p id="c7e4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">开始在你的应用程序中使用Room和coroutines，数据库工作保证在非UI调度程序上运行。用<code class="du lf lg lh li b">suspend</code>修饰符标记您的DAO方法，并从其他挂起函数或协程中调用它们！</p></div></div>    
</body>
</html>