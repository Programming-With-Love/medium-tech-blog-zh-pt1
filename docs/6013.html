<html>
<head>
<title>Rock-Solid K3s on OCI — Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚如磐石的Solid K3s第四部分</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/rock-solid-k3s-on-oci-part-4-bc47b20e38a6?source=collection_archive---------1-----------------------#2022-12-13">https://medium.com/oracledevs/rock-solid-k3s-on-oci-part-4-bc47b20e38a6?source=collection_archive---------1-----------------------#2022-12-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/f8eb589e0aa097294030f3b7d53848c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*UzlQsF0lA1Y06fMWA9hQ5w.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">Photo by eberhard grossgasteiger: <a class="ae ip" href="https://www.pexels.com/photo/low-angle-shot-of-rock-formation-1366909/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/low-angle-shot-of-rock-formation-1366909/</a></figcaption></figure><p id="658f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这是本系列的第四篇也是最后一篇文章(至少目前如此)。这是一个有趣的旅程，第一部分关注于建立所需的OCI资源。<a class="ae ip" rel="noopener" href="/oracledevs/rock-solid-k3s-on-oci-part-2-4f7b95faca88">第二部分</a>发现我们正在进行K3s安装，然后在<a class="ae ip" rel="noopener" href="/oracledevs/rock-solid-k3s-on-oci-part-3-129efce08b81">第三部分</a>我们安装了OCI云控制器管理器和nginx入口控制器。</p><p id="77ff" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">让我们使用这个新创建的环境，在K3s环境中部署一些应用程序。我们将部署两个应用程序:</p><ul class=""><li id="a8b1" class="jo jp hh is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">Jupyter </li><li id="d815" class="jo jp hh is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw bi translated"><a class="ae ip" href="https://nodered.org/" rel="noopener ugc nofollow" target="_blank">红色节点</a></li></ul><h1 id="6ae7" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">设置TLS</h1><p id="9591" class="pw-post-body-paragraph iq ir hh is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn ha bi translated">首先创建一个自签名证书，我们将在访问应用程序时使用它。接下来的几个命令直接取自<a class="ae ip" href="https://docs.oracle.com/en-us/iaas/Content/ContEng/Tasks/contengsettingupingresscontroller.htm" rel="noopener ugc nofollow" target="_blank"> OCI文档</a>(参见<em class="lf">创建TLS秘密</em>一节):</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="dbf5" class="lp kd hh ll b be lq lr l ls lt"># Run in: K3s Server SSH session<br/><br/>$ openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=nginxsvc/O=nginxsvc"<br/><br/>$ kubectl create secret tls tls-secret --key tls.key --cert tls.crt</span></pre><p id="eb28" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">尽管这不是您在“真实”(生产)环境中想要做的事情，但这将允许我们至少加密来往于我们的应用程序的流量。</p><h1 id="3197" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">朱皮特</h1><p id="2a9b" class="pw-post-body-paragraph iq ir hh is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn ha bi translated">Jupyter是一个数据科学平台，通常用于人工智能/人工智能工作。我已经写了一篇文章，描述了如何使用你的网络浏览器在OCI上运行Jupyter。按照<a class="ae ip" rel="noopener" href="/oracledevs/launching-jupyterlab-jupyter-on-oci-using-your-web-browser-dddbb01f4a0e">文章</a>中的步骤创建Jupyter容器，并将容器推送到<a class="ae ip" href="https://docs.oracle.com/en-us/iaas/Content/Registry/Tasks/registryviewingimagedetails.htm" rel="noopener ugc nofollow" target="_blank"> OCI容器注册处</a> (OCIR)。确保获得OCIR容器的完整路径…您马上就会需要它！要获得完整路径，请单击存储库(它将展开以显示标签)。点击你的标签(如果你按照我给的指示，它将是<em class="lf"> v1.0.0-ol8 </em>)。详细信息将显示在屏幕右侧)，其中<em class="lf">完整路径</em>是属性之一。</p><p id="ebc1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">从可以访问K3s API的系统(我选择了SSH到K3s服务器)，复制并粘贴以下内容到一个文件中(我选择将其命名为<em class="lf"> jupyter.yml </em>):</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="b254" class="lp kd hh ll b be lq lr l ls lt">---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: jupyter<br/>  namespace: default<br/>  labels:<br/>    app: jupyter<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: jupyter<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: jupyter<br/>        ver: v1.0.0<br/>    spec:<br/>      containers:<br/>      - name: jupyter<br/>        image: &lt;region&gt;.ocir.io/&lt;namespace&gt;/jupyter:v1.0.0-ol8<br/>        imagePullPolicy: Always<br/>        ports:<br/>        - containerPort: 8888<br/>          protocol: TCP<br/>        command:<br/>          - jupyter<br/>          - lab<br/>          - --allow-root<br/>          - --notebook-dir<br/>          - /jupyter<br/>          - --no-browser<br/>          - --autoreload<br/>          - --ip=0.0.0.0<br/>          - --NotebookApp.base_url=/jupyter<br/>      imagePullSecrets:<br/>      - name: ocirsecret<br/>      nodeSelector:<br/>        kubernetes.io/arch: arm64<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: jupyter-svc<br/>spec:<br/>  selector:<br/>    app: jupyter<br/>  ports:<br/>    - port: 8888<br/>      targetPort: 8888<br/>  type: ClusterIP<br/>---<br/>apiVersion: networking.k8s.io/v1<br/>kind: Ingress<br/>metadata:<br/>  name: jupyter-ing<br/>  annotations:<br/>    kubernetes.io/ingress.class: "nginx"<br/>    nginx.ingress.kubernetes.io/app-root: /jupyter<br/>spec:<br/>  tls:<br/>  - secretName: tls-secret<br/>  rules:<br/>  - http:<br/>      paths:<br/>        - path: /jupyter<br/>          pathType: Prefix<br/>          backend:<br/>            service:<br/>              name: jupyter-svc<br/>              port:<br/>                number: 8888</span></pre><p id="c622" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">注意</strong>:注意我们如何使用一个服务名<em class="lf"> jupyter-svc </em>而不是<em class="lf"> jupyter </em>，就像deployment(以及许多其他应用程序引用)一样？有几个环境变量被注入到Jupyter pod中，其中一些可能被Jupyter用于设置配置(如<em class="lf"> JUPYTER_PORT </em>，它已被设置)。通过使用<em class="lf"> jupyter-svc </em>，变量<em class="lf"> JUPYTERLAB_PORT </em>由K8s设置，jupyter不看(默认)。</p><p id="32ed" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">继续并应用它:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="a09a" class="lp kd hh ll b be lq lr l ls lt"># Run in: K3s Server SSH session<br/><br/>$ kubectl apply -f jupyter.yml</span></pre><p id="4a38" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">如果您查看我在运行Jupyter上写的前一篇文章<a class="ae ip" rel="noopener" href="/oracledevs/launching-jupyterlab-jupyter-on-oci-using-your-web-browser-dddbb01f4a0e">中的示例清单，就会发现有一些不同之处。这和文章清单都声明了一个部署和一个服务，但是服务类型是不同的…我们使用了一种类型的<em class="lf"> ClusterIP </em>，而不是一种类型的<em class="lf"> LoadBalancer </em>。因为我们使用了一个入口，所以我们也为Jupyter定义了一个入口。入口使用TLS(使用我们之前配置的自签名证书)并将<em class="lf"> /jupyter </em>路径与我们定义的服务相关联。</a></p><p id="8eb1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">通过执行“kubectl get pods ”,确保Jupyter pod正在运行。您应该会看到如下所示的内容:</p><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/5cb056fa3f1d3e01155615c8c8de841f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OY43wuX7DWJ8nAC7PFXaFg.png"/></div></div></figure><p id="24a7" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在确保Jupyter pod正在运行之后，我们还可以查看几个命令。查看以下命令(和输出):</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="ae8d" class="lp kd hh ll b be lq lr l ls lt"># Run in: K3s Server SSH session<br/><br/>$ kubectl get deployments<br/>NAME      READY   UP-TO-DATE   AVAILABLE   AGE<br/>jupyter   1/1     1            1           77d<br/><br/>$ kubectl get ingress<br/>NAME          CLASS    HOSTS   ADDRESS          PORTS     AGE<br/>jupyter-ing   &lt;none&gt;   *       &lt;pub_ip&gt;         80, 443   74d</span></pre><p id="9f5b" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">部署正在运行，可以通过入口(命令输出中显示的公共IP地址)进行访问。</p><p id="a4ad" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">入口将显示OCI负载平衡器(LB)的IP地址。还有另一种方法来查看LB IP地址:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="a146" class="lp kd hh ll b be lq lr l ls lt"># Run in: K3s Server SSH session<br/><br/>$ kubectl get services --no-headers -l app.kubernetes.io/component=controller -n ingress-nginx -o custom-columns=:status.loadBalancer.ingress[0].ip | grep -v '&lt;none&gt;'<br/>&lt;pub_ip&gt;</span></pre><p id="5690" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">打开一个网页浏览器到:https: <pub_ip> /jupyter</pub_ip></p><p id="c520" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">您将被带到Jupyter登录屏幕。您的浏览器(如果它正在工作的话)会提醒您正在使用不可信的(自签名)证书。在确保您的浏览器继续运行后，您将看到熟悉的Jupyter登录屏幕。请输入您的密码。成功！让我们将Node-RED添加到组合中。</p><h1 id="82df" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">红色节点</h1><p id="f27d" class="pw-post-body-paragraph iq ir hh is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn ha bi translated">现在是我们设置第二个应用程序的时候了:<a class="ae ip" href="https://nodered.org/" rel="noopener ugc nofollow" target="_blank"> Node-RED </a>。Node-RED允许“低代码、事件驱动的编程”(几乎一字不差地抄袭他们的网站)。本质上，您可以配置当给定的触发器被激活时将运行的操作。这对于将不同的API(系统)缝合在一起特别方便。这是一个试验物联网系统的绝佳平台。让我们开始设置它。</p><p id="758e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">因为我们只为K3s代理节点(那些运行pods的节点)使用A1 (arm)计算，所以我们不需要构建容器的amd64(又名x86_64)变体。我们只需要节点红色容器的arm64 (aka aarch64)版本。为了加快速度，我建议您SSH到您的堡垒，然后SSH到其中一个代理并在那里构建容器:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="bd26" class="lp kd hh ll b be lq lr l ls lt">$ ssh -A &lt;bastion_pub_ip&gt;<br/>$ ssh agent1.k3s.k3s.oraclevcn.com</span></pre><p id="0093" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为我们的工作创建一个新目录(尽量保持整洁)并输入它:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="6d16" class="lp kd hh ll b be lq lr l ls lt"># Run in: K3s Agent1 SSH session<br/><br/>$ mkdir node-red<br/>$ cd node-red</span></pre><p id="5d9c" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">将以下内容放入名为<em class="lf"> Dockerfile </em>的新文件中:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="ce09" class="lp kd hh ll b be lq lr l ls lt">FROM container-registry.oracle.com/os/oraclelinux:8-slim<br/>ARG NODEREDPASSWORD<br/><br/>RUN microdnf install oraclelinux-developer-release-el8 dnf &amp;&amp; dnf groupinstall "Development Tools" -y &amp;&amp; dnf install -y nano python39-pip python39-numpy python39-devel wget &amp;&amp; dnf clean all -y<br/>RUN pip3 install wheel cython pandas scikit-learn bcrypt &amp;&amp; pip3 install tensorflow<br/>RUN wget https://nodejs.org/dist/v18.10.0/node-v18.10.0-linux-arm64.tar.xz<br/><br/>RUN mkdir -p /usr/local/lib/nodejs<br/>RUN tar -xJvf node-v18.10.0-linux-arm64.tar.xz -C /usr/local/lib/nodejs<br/>ENV PATH="/usr/local/lib/nodejs/node-v18.10.0-linux-arm64/bin:$PATH"<br/>RUN npm install -g --unsafe-perm node-red<br/>RUN mkdir -p ~/.node-red<br/><br/>COPY settings_template.js /.<br/>RUN echo $NODEREDPASSWORD &gt;&gt; /provided_password.txt &amp;&amp; \<br/>  settings_file=$(&lt; /settings_template.js) &amp;&amp; \<br/>  source /dev/stdin  &lt;&lt;&lt;"$(echo 'cat &lt;&lt;EOF'; echo "$settings_file"; printf '\nEOF';)" &gt; /root/.node-red/settings.js &amp;&amp; \<br/>  rm /provided_password.txt &amp;&amp; \<br/>  rm /settings_template.js<br/><br/>EXPOSE 1880/tcp<br/>CMD node-red</span></pre><p id="cc5c" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在同一个目录下创建另一个名为<em class="lf"> settings_template.js </em>的新文件，并将以下内容放入其中(如果没有找到settings.js文件，则从Node-RED生成的默认设置文件复制并稍作修改):</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="16b0" class="lp kd hh ll b be lq lr l ls lt">module.exports = {<br/>      flowFile: 'flows.json',<br/>      credentialSecret: "$(yes `cat /provided_password.txt` | node-red admin hash-pw | awk '{print $2}')",<br/>      flowFilePretty: true,<br/>  <br/>      adminAuth: {<br/>         type: "credentials",<br/>         users: [{<br/>             username: "admin",<br/>             password: "$(yes `cat /provided_password.txt` | node-red admin hash-pw | awk '{print $2}')",<br/>             permissions: "*"<br/>         }]<br/>      },<br/>      uiPort: process.env.PORT || 1880,<br/>      apiMaxLength: '5mb',<br/>      httpNodeRoot: '/nodered/',<br/>      httpAdminRoot: ‘/nodered/’,<br/>      diagnostics: {<br/>          enabled: true,<br/>          ui: true,<br/>      },<br/>      runtimeState: {<br/>          enabled: false,<br/>          ui: false,<br/>      },<br/>      logging: {<br/>          console: {<br/>              level: "info",<br/>              metrics: false,<br/>              audit: false<br/>          }<br/>      },<br/>      editorTheme: {<br/>          projects: {<br/>              enabled: true,<br/>              workflow: {<br/>                  mode: "manual"<br/>              }<br/>          },<br/>  <br/>          codeEditor: {<br/>              lib: "monaco",<br/>              options: {<br/>              }<br/>          }<br/>      },<br/>      functionExternalModules: true,<br/>      debugMaxLength: 1000,<br/>      mqttReconnectTime: 15000,<br/>      serialReconnectTime: 15000,<br/>  }</span></pre><p id="84e4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">如果您没有在agent1上安装podman，那么现在就安装吧(<em class="lf"> sudo dnf install podman </em>)。继续在agent1上创建容器(确保使用正确的密码):</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="3eea" class="lp kd hh ll b be lq lr l ls lt"># Run in: K3s Agent1 SSH session<br/><br/>$ NODEREDPASSWORD=&lt;your_password_here&gt; podman build --pull --build-arg NODEREDPASSWORD -t nodered:ol8-arm64-v8 .</span></pre><p id="7b09" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在容器映像已经构建好了，是时候把它推送到OCI容器注册中心(OCIR)了:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="323e" class="lp kd hh ll b be lq lr l ls lt"># Run in: K3s Agent1 SSH session<br/><br/>$ podman login &lt;region&gt;.ocir.io<br/>$ podman image tag nodered:ol8-arm64-v8 &lt;region&gt;.ocir.io/&lt;namespace&gt;/nodered:v1.0.0-ol8-arm64-v8<br/>$ podman push &lt;region&gt;.ocir.io/&lt;namespace&gt;/nodered:v1.0.0-ol8-arm64-v8</span></pre><p id="4dab" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">OCIR文档有不同地区的可用URL。请确定您使用的是您所在地区的正确URL。</p><p id="d1f1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">另一个警告:确保使用正确的用户名格式(<em class="lf"> &lt;名称空间&gt; / &lt;用户名&gt; </em>或者如果您使用IDCS、<em class="lf"> &lt;名称空间&gt;/oracleidentitycloudservice/&lt;用户名&gt; </em>)。密码将是与您的帐户相关联的身份验证令牌。查看<a class="ae ip" href="https://docs.oracle.com/en-us/iaas/Content/Registry/Tasks/registrypushingimagesusingthedockercli.htm" rel="noopener ugc nofollow" target="_blank"> OCI文档</a>了解更多信息。</p><p id="33c7" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">随着我们的容器成功构建并推送到OCIR，是时候在我们的K3s集群上创建部署并运行Node-RED了！SSH回到K3s服务器(或者任何可以运行kubectl并访问K3s API的机器)。从那里，创建一个名为<em class="lf"> node-red.yml </em>的新文件，将以下内容放入其中(确保在您的环境中更新值的占位符):</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="62c7" class="lp kd hh ll b be lq lr l ls lt">---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: nodered<br/>  namespace: default<br/>  labels:<br/>    app: nodered<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: nodered<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nodered<br/>        ver: v1.0.0<br/>    spec:<br/>      containers:<br/>      - name: nodered<br/>        image: &lt;region&gt;.ocir.io/&lt;namespace&gt;/nodered:v1.0.0-ol8-arm64-v8<br/>        imagePullPolicy: Always<br/>        ports:<br/>        - containerPort: 1880<br/>          protocol: TCP<br/>      imagePullSecrets:<br/>      - name: ocirsecret<br/>      nodeSelector:<br/>        kubernetes.io/arch: arm64<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: nodered-svc<br/>spec:<br/>  selector:<br/>    app: nodered<br/>  ports:<br/>    - port: 1880<br/>      targetPort: 1880<br/>  type: ClusterIP<br/>---<br/>apiVersion: networking.k8s.io/v1<br/>kind: Ingress<br/>metadata:<br/>  name: nodered-ing<br/>  annotations:<br/>    kubernetes.io/ingress.class: "nginx"<br/>spec:<br/>  tls:<br/>  - secretName: tls-secret<br/>  rules:<br/>  - http:<br/>      paths:<br/>        - path: /nodered<br/>          pathType: Prefix<br/>          backend:<br/>            service:<br/>              name: nodered-svc<br/>              port:<br/>                number: 1880</span></pre><p id="9f66" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在确保使用正确的区域、名称空间和任何其他可能与您的环境不同的内容后，应用节点红色清单:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="64d7" class="lp kd hh ll b be lq lr l ls lt"># Run in: K3s Server SSH session<br/><br/>$ kubectl apply -f node-red.yml<br/>deployment.apps/nodered created<br/>service/nodered-svc created<br/>ingress.networking.k8s.io/nodered-ing created</span></pre><p id="3cdd" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">让我们检查以确保部署和入口准备就绪:</p><pre class="lg lh li lj fd lk ll lm bn ln lo bi"><span id="87f5" class="lp kd hh ll b be lq lr l ls lt"># Run in: K3s Server SSH session<br/><br/>$ kubectl get deployment nodered<br/>NAME      READY   UP-TO-DATE   AVAILABLE   AGE<br/>nodered   1/1     1            1           119s<br/><br/>$ kubectl get ingress nodered-ing<br/>NAME          CLASS    HOSTS   ADDRESS          PORTS     AGE<br/>nodered-ing   &lt;none&gt;   *       &lt;pub_ip&gt;         80, 443   2m25s</span></pre><p id="6904" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">让我们在网页浏览器中进入https:// <pub_ip> /nodered查看一下吧！在让您的浏览器平静下来之后(由于使用了自签名证书),您应该会看到登录屏幕，然后是主节点——登录后的红色屏幕。</pub_ip></p><h1 id="9a9d" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="82d6" class="pw-post-body-paragraph iq ir hh is b it la iv iw ix lb iz ja jb lc jd je jf ld jh ji jj le jl jm jn ha bi translated">对我来说，这是一次有趣的旅程。我希望它对你有帮助和有趣！虽然这不是我在生产环境中考虑的解决方案，但我认为这是开发和测试的绝佳场所。</p><p id="ac65" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">因为K3s提供了丰富的K8s API和体验，所以从这样的轻量级K3s实现迁移到成熟的、功能丰富的企业级K8s实现，如用于Kubernetes (OKE) 的<a class="ae ip" href="https://docs.oracle.com/en-us/iaas/Content/ContEng/home.htm" rel="noopener ugc nofollow" target="_blank"> OCI容器引擎，是一件轻而易举的事情。这种“前进路径”是我认为K3s优于其他轻量级容器编排引擎(尤其是那些不基于K8s的引擎)的主要优势之一。</a></p><p id="499e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在我看来，OCI负载平衡器和(可选)OCI块卷的紧密集成和管理是一大优势。这是由OCI云控制器管理器(以及可选的CSI，如果您选择安装它)实现的。</p><p id="2303" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">至此，我们已经在构建K3s环境上投入了相当多的时间。另一方面，部署新的<a class="ae ip" href="https://docs.oracle.com/en-us/iaas/Content/ContEng/home.htm" rel="noopener ugc nofollow" target="_blank"> OKE </a>集群非常容易(也非常快),这使它成为我首选的K8s。尽管如此，对于一个非常轻量级的实现来说，这个解决方案可以满足目的。</p><p id="61a9" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">直到下一次，愿你所有的清单都能成功应用！</p><p id="43a2" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">加入我们在Slack 上的<a class="ae ip" href="https://bit.ly/odevrel_slack" rel="noopener ugc nofollow" target="_blank">甲骨文开发者频道，讨论其他话题！</a></p><p id="acbf" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">免费在Oracle云上构建、测试和部署您的应用！访问<a class="ae ip" href="https://www.oracle.com/cloud/free/" rel="noopener ugc nofollow" target="_blank"> OCI云免费层</a>！</p></div></div>    
</body>
</html>