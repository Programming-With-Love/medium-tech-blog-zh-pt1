<html>
<head>
<title>When LiveData and Kotlin don’t play well together</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当LiveData和Kotlin不能很好地合作时</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/when-livedata-and-kotlin-dont-play-hand-in-hand-30149aa794ec?source=collection_archive---------0-----------------------#2020-12-15">https://medium.com/google-developer-experts/when-livedata-and-kotlin-dont-play-hand-in-hand-30149aa794ec?source=collection_archive---------0-----------------------#2020-12-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/0e1051f32f9ee7e55dca59837cb102a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*63TjCLzIvsR8aKbwKFNEkQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Playing well together</figcaption></figure><p id="48cc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这个想法很有趣。基于反应流的想法，在RxJava plus增加自动生命周期处理的时候达到了顶峰——这是Android上的一个问题。尽管时机不佳。它是在Kotlin在Android社区产生影响之前到来的，有时两者不能很好地合作。让我们来探讨一下为什么会这样，会发生什么！</p><h1 id="56fe" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">好的和坏的</h1><p id="5ab7" class="pw-post-body-paragraph it iu hh iv b iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ha bi translated"><code class="du jr js jt ju b">LiveData</code>的想法非常简单:可观察模式的生命周期感知实现。此外，如果您重新订阅，您将再次获得上次发出的值。这可以比作带有粘性消息的<code class="du jr js jt ju b">EventBus</code>的类型化版本。</p><p id="cf49" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是<code class="du jr js jt ju b">LiveData</code>的核心特征之一。但是很快，包括作者在内的开发人员发现，你并不总是想要那种行为。假设你有一个误差值。然后，您可能不想在重新订阅后再次显示该错误值，例如在设备旋转后。</p><p id="6629" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">解决这个问题的一个方法是<code class="du jr js jt ju b"><a class="ae ky" href="https://github.com/android/architecture-samples/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java" rel="noopener ugc nofollow" target="_blank">SingleLiveEvent</a></code>，对于像错误这样的一次性事件，这是一个很好的选择。</p><h1 id="fc47" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">两个世界</h1><p id="2028" class="pw-post-body-paragraph it iu hh iv b iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ha bi translated">但是如果你两者都想要一点呢？您希望最后一个值“粘性”加上不显示潜在的错误多次！<br/>在这种情况下，在它们被消耗后，从<code class="du jr js jt ju b">LiveData</code>中删除我们的错误值会很好，对吗？</p><p id="5b0b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们来看看<code class="du jr js jt ju b">LiveData</code>的实现:</p><p id="2177" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当前值保存在字段中:</p><pre class="kz la lb lc fd ld ju le lf aw lg bi"><span id="5f80" class="lh jw hh ju b fi li lj l lk ll">private volatile Object mData;</span></pre><p id="8b69" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">最初，它被设置为<code class="du jr js jt ju b">NOT_SET</code>。</p><pre class="kz la lb lc fd ld ju le lf aw lg bi"><span id="3c84" class="lh jw hh ju b fi li lj l lk ll">static final Object <em class="lm">NOT_SET </em>= new Object();</span></pre><p id="4e37" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">不幸的是，不是<code class="du jr js jt ju b">public</code>否则，我们可以用它来重置值。</p><h1 id="a534" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">现在怎么办？</h1><p id="dcbf" class="pw-post-body-paragraph it iu hh iv b iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ha bi translated">如果您搜索这个问题，最建议的解决方案之一是简单地将其设置为<code class="du jr js jt ju b">null</code>。</p><p id="e864" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们来探索一下:</p><pre class="kz la lb lc fd ld ju le lf aw lg bi"><span id="b561" class="lh jw hh ju b fi li lj l lk ll">viewModel.results.observe(lifecycleOwner) <strong class="ju hi">{ </strong>result <strong class="ju hi">-&gt;<br/>    </strong>when (result) {<br/>        SomeResult.Error -&gt; {<br/>            handleError()<br/>            <strong class="ju hi">viewModel.results.<em class="lm">reset</em>()</strong><br/>        }<br/>        SomeResult.Result -&gt; { handleResult(result) }<br/>    }<br/><strong class="ju hi">}</strong></span></pre><p id="d35c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">其中ViewModel的实现是:</p><pre class="kz la lb lc fd ld ju le lf aw lg bi"><span id="50c9" class="lh jw hh ju b fi li lj l lk ll">class MyViewModel: ViewModel() {<br/><br/>    private val mutableResults = <strong class="ju hi">MutableLiveData&lt;SomeResult&gt;()</strong><br/><br/>    <strong class="ju hi">val results: LiveData&lt;SomeResult&gt;</strong><br/>        get() = mutableResults<br/><br/><strong class="ju hi">    fun reset() {<br/>        mutableResults.<em class="lm">value </em>= null<br/>    }</strong><br/>}</span></pre><p id="f542" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这个管用，对吧？</p><p id="da52" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">恭喜你！您刚刚在代码中引入了崩溃！</p><h1 id="28b9" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">但是为什么呢？</h1><p id="e805" class="pw-post-body-paragraph it iu hh iv b iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ha bi translated">你甚至可能没有注意到，并可能推出它。(如果是，请下次添加单元测试)。</p><p id="7bc9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这里的问题是我们声明了<code class="du jr js jt ju b">LiveData</code>对于编译器是不可空的！</p><p id="7432" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您的观察者将得到这个<code class="du jr js jt ju b">null</code>值的通知，然后一旦它得到一个带有<code class="du jr js jt ju b">KotlinNullPointerException</code>的值，就会立即崩溃。你已经无能为力了！这是科特林工作方式的一部分！</p><p id="bd18" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du jr js jt ju b">LiveData</code>是用Java写的。它允许将其值设置为<code class="du jr js jt ju b">null</code>。所以作者可以添加<code class="du jr js jt ju b">@Nullable</code>注释，就像我们在其他Jetpack库上一样，对吗？不，因为那样你总是需要在<code class="du jr js jt ju b">getValue</code>或<code class="du jr js jt ju b">Observer</code>中处理可空类型，尽管你可能已经明确地将<code class="du jr js jt ju b">LiveData</code>声明为非空。泛型是运行时信息(对于Java)，注释是编译时信息，它们不能为我们解决这个问题。而Java在类型系统中根本没有null。</p><p id="a426" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这不是一个bug——这是一个特性！</p><h1 id="b649" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">你如何解决这个问题？</h1><p id="982b" class="pw-post-body-paragraph it iu hh iv b iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ha bi translated">一个简单的方法是将您的<code class="du jr js jt ju b">LiveData</code>标记为可空:</p><pre class="kz la lb lc fd ld ju le lf aw lg bi"><span id="15bf" class="lh jw hh ju b fi li lj l lk ll">private val mutableResults = MutableLiveData&lt;<strong class="ju hi">SomeResult?</strong>&gt;()<br/><br/>    val results: LiveData&lt;<strong class="ju hi">SomeResult?</strong>&gt;<br/>        get() = mutableResults</span></pre><p id="2cd4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在我们可以在观察器中处理它，只对非空值做出反应。更重要的是:编译器强迫我们这么做！</p><h1 id="e322" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">还有别的办法吗？</h1><p id="8de2" class="pw-post-body-paragraph it iu hh iv b iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ha bi translated">我之前说过我们不能访问原始的<code class="du jr js jt ju b">NOT_SET</code>值。不完全是真的。我们可以通过在jetpack包中设置一些东西来暴露它:</p><pre class="kz la lb lc fd ld ju le lf aw lg bi"><span id="09e7" class="lh jw hh ju b fi li lj l lk ll"><strong class="ju hi">package androidx.lifecycle</strong><br/><br/>fun &lt;T&gt; LiveData&lt;T&gt;.reset(){<br/><strong class="ju hi">    this.<em class="lm">value </em>= LiveData.<em class="lm">NOT_SET</em></strong><em class="lm"> </em>as T?<br/>}</span></pre><p id="e022" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">虽然有点脏。</p><p id="3e30" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">但除此之外，这实际上是允许的吗？<br/>至少不禁止！即使根据新的更严格的关于Google Play应用程序私有API的规则，这应该没问题。</p><p id="e3ce" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">实际问题是另一个问题，但最重要的是，您依赖于<code class="du jr js jt ju b">LiveData</code>的实现细节，它不是公共API的一部分，因此可能随时改变！</p><h1 id="7a2c" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">好了，现在怎么办？</h1><p id="dfc5" class="pw-post-body-paragraph it iu hh iv b iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ha bi translated">另一种方法是将结果打包，这样您就可以拥有自己的<code class="du jr js jt ju b">NOT_SET</code>:</p><pre class="kz la lb lc fd ld ju le lf aw lg bi"><span id="9124" class="lh jw hh ju b fi li lj l lk ll"><strong class="ju hi">sealed class</strong> ViewModelResult {<br/>    data class <strong class="ju hi">Result</strong>(val result: SomeResult): ViewModelResult()<br/>    object <strong class="ju hi">NotSet</strong>: ViewModelResult()<br/>}</span></pre><p id="92f0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们将使用<code class="du jr js jt ju b">NotSet</code>清除以前的值，然后可以忽略<code class="du jr js jt ju b">Observer</code>中的值。</p><p id="45d5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这不是最好的解决方法，但可能是最干净的。<br/>这也是<a class="ln lo ge" href="https://medium.com/u/e0a4c9469bb5?source=post_page-----30149aa794ec--------------------------------" rel="noopener" target="_blank"> Jose Alcérreca </a>在这篇<a class="ae ky" rel="noopener" href="/androiddevelopers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150">文章</a>中推荐的。</p><h1 id="f1a6" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">还有别的吗？</h1><p id="f580" class="pw-post-body-paragraph it iu hh iv b iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ha bi translated">此外，试着重新考虑你是否首先需要LiveData。有了<code class="du jr js jt ju b">S<a class="ae ky" href="https://blog.jetbrains.com/kotlin/2020/10/kotlinx-coroutines-1-4-0-introducing-stateflow-and-sharedflow/" rel="noopener ugc nofollow" target="_blank">tateFlow</a></code> <a class="ae ky" href="https://blog.jetbrains.com/kotlin/2020/10/kotlinx-coroutines-1-4-0-introducing-stateflow-and-sharedflow/" rel="noopener ugc nofollow" target="_blank">和</a> <code class="du jr js jt ju b"><a class="ae ky" href="https://blog.jetbrains.com/kotlin/2020/10/kotlinx-coroutines-1-4-0-introducing-stateflow-and-sharedflow/" rel="noopener ugc nofollow" target="_blank">ShareFlow</a></code>科特林提供了一个绝佳的选择。</p><p id="3bc9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果你想坚持使用LiveData，想一想是否有一种方法可以让你有粘性或非粘性事件，而不是混合？</p><p id="048c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在这种情况下，考虑更新您的Linter来添加一个定制的Lint检查，其中我们的不可空的活动数据不能设置为空，并且在这种情况下编译器会导致错误。</p><p id="bb2e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">保持警惕！这不是LiveData的问题，其他库也可能发生这种情况。我们已经习惯了Kotlin编译器的警告。但是如果它不能，它可能会给你带来麻烦，如果没有它你就不会有这些麻烦。</p></div></div>    
</body>
</html>