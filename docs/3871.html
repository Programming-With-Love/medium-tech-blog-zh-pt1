<html>
<head>
<title>Spread operator use cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">传播运算符用例</h1>
<blockquote>原文：<a href="https://medium.com/globant/spread-operator-use-cases-69ea4b16fc02?source=collection_archive---------0-----------------------#2022-05-02">https://medium.com/globant/spread-operator-use-cases-69ea4b16fc02?source=collection_archive---------0-----------------------#2022-05-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7345" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated">在工作或理解Javascript时，他有三个著名的点(…)。嗯，这些点不过是扩展操作符，<strong class="ig hi">接受对象，</strong> <strong class="ig hi">使其迭代，按需复制到另一个对象</strong>。</p><p id="9d85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对象可以是任何东西，数组[]或文字对象{}。spread运算符的使用不限于数组或对象，还可以用于函数、节点列表和字符串。</p><h1 id="7871" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">现在你问我为什么我们需要它？</h1><p id="c701" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">当我们以浅层复制的方式将数据从一个变量复制到另一个变量时，为了使代码简洁易读。</p><p id="927a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们有多种方法来使用(…) spread运算符。</p><ol class=""><li id="aa55" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kt ku kv kw bi translated"><strong class="ig hi">阵列使用案例</strong></li></ol><ul class=""><li id="d8bf" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kx ku kv kw bi translated"><em class="ky">浅抄</em></li></ul><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es kz"><img src="../Images/1779e22f696c3edf14077683f67a04c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*uLRKY0Ey03pBKE4hJf8Wcg.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Shallow Copy of an array</figcaption></figure><ul class=""><li id="5b71" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kx ku kv kw bi translated">把单词分开</li></ul><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ll"><img src="../Images/6d7ad182986c23ca307acedade29ce48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*vDuoBUcdsKMhGexlAdFwpw.png"/></div></figure><ul class=""><li id="5ee1" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kx ku kv kw bi translated"><em class="ky">2个或更多数组的组合</em></li></ul><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lm"><img src="../Images/22eb8a544f26bb3da6adf52eb2593fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*8uWD6KJGD8TdbcEUSRha4Q.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Combining 2 arrays</figcaption></figure><ul class=""><li id="7bd5" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kx ku kv kw bi translated"><em class="ky">添加附加值</em></li></ul><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es ln"><img src="../Images/3c0d355fd1665925c425df52e6319878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*qy75Efh0r8vL6qhCytCXXw.png"/></div><figcaption class="lh li et er es lj lk bd b be z dx">Adding additional value to an array</figcaption></figure><p id="d36d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。对象用例</strong></p><ul class=""><li id="7d11" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kx ku kv kw bi translated">向对象添加额外的属性</li></ul><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lo"><img src="../Images/f39b1a1323a05ca4c4efa09127b622b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZSHygqWSSNQDM1sA2sXLw.png"/></div></div></figure><ul class=""><li id="0062" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kx ku kv kw bi translated">对象析构</li></ul><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lt"><img src="../Images/71597bd10ad096391fdc40fa45ca65fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*haVdIIdR7VHkLZfjbsgK3A.png"/></div></div></figure><p id="8ec3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.<strong class="ig hi">功能用例</strong></p><ul class=""><li id="c07c" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kx ku kv kw bi translated">Math.min()</li></ul><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es lu"><img src="../Images/7e1cbac9355d9992d76e2c69d61c44a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*iZ8YAzzLJ8BNh3tnOv6zhQ.png"/></div></figure><ul class=""><li id="0e6f" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kx ku kv kw bi translated">数组中的节点列表</li></ul><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lv"><img src="../Images/2081c55acf001d764a18a312c33be300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lO-MBodDnA3qgQKRt4_teg.png"/></div></div></figure><h1 id="08c6" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">执行的好处</strong></h1><p id="b558" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">当我们使用spread操作符时，我们有执行代码的速度优势。它在早期版本(ES8之前)中有很大的时间差，尽管现在它有些简洁，但我们仍然可以看到concat方法在组合2个数组时与spread运算符相比的滞后。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="er es lw"><img src="../Images/4aa936ee42f0bf9ba7a8051788311fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*koLbU0u5JfIaaIW-PEc29A.png"/></div></div></figure><p id="d002" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据上面的网络选项卡数据，我们可以看到spread操作符花费了311毫秒，而concat函数花费了461毫秒。</p><p id="7023" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这看起来是一个很小的差别，但是在大的应用中，如果我们倾向于避免在传统方法上扩展操作符，我们可能会增加这个差别。</p><h1 id="c8ed" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">不管是不是骗局。！</h1><p id="ca83" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">当我们传播一个变量时，它将一个对象引用到另一个对象中，这需要解释器查找变量引用的内容，然后查找作为新对象传播的对象的所有可枚举的自身属性(以及相关值)。这需要处理能力。</p><p id="178c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是有了现代Javascript引擎和先进的计算机，我们可以在一秒钟内处理数百万条指令，所以传播一堆键值对所需的处理能力真的没什么好担心的。</p><h1 id="bbb9" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated"><strong class="ak">传播算子的替代方案。</strong></h1><p id="878b" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">我们有多种选择。让我们看看他们中的一些人</p><ul class=""><li id="5f17" class="ko kp hh ig b ih ii il im ip kq it kr ix ks jb kx ku kv kw bi translated">对象.分配()</li><li id="ac51" class="ko kp hh ig b ih lx il ly ip lz it ma ix mb jb kx ku kv kw bi translated">arr.concat()</li></ul></div></div>    
</body>
</html>