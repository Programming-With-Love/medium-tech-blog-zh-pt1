<html>
<head>
<title>Hot Database Connections for Serverless Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无服务器功能的热数据库连接</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/hot-database-connections-for-serverless-functions-9f9e8a681df6?source=collection_archive---------1-----------------------#2020-03-23">https://medium.com/oracledevs/hot-database-connections-for-serverless-functions-9f9e8a681df6?source=collection_archive---------1-----------------------#2020-03-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/53cd72fe1347542d61f7bfef0e7d61ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Va4WdLt3F2vxSBovP0WQdQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Illustration: Oracle Function instances connecting to an Autonomous Database (ATP-S) instance</figcaption></figure><h1 id="f714" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">序言—要解决的问题</h1><p id="e067" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">启动新的无服务器容器——也称为冷启动——需要一到几秒钟(时间因平台而异)；为了消除这种成本/延迟，无服务器框架在一段时间内保持已经启动的容器温暖(持续时间因提供商而异)。</p><p id="4290" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">无服务器功能可以访问数据库。尽管成本比启动新的无服务器容器要低，但数据库连接的创建和拆除可能要花费几十甚至几百毫秒，这取决于您的DBMS环境。这个问题随着无服务器功能而加剧，无服务器功能是短命的，并且不能在每次调用时都负担这样的成本。要解决的第一个问题是避免连接创建和断开。</p><p id="37e6" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">另一个需要解决的问题是，由于连接不能跨容器进行池化/共享，面对固定数量的数据库连接，自动伸缩和高并发性(即成千上万的并发无服务器函数调用)的影响。</p><p id="4d92" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">本文中的讨论、解决方案和最佳实践基于Java，但适用于您的无服务器基础设施支持的所有语言(例如Oracle Functions支持Java、Go、Node.js、Python和Ruby)。</p><h1 id="30f3" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">避免连接创建/拆除</h1><p id="029b" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">重用现有的连接只需要几毫秒的时间，但是，无服务器功能的每个实例都在一个单独的容器中运行，只有一个数据库连接，因此，这些连接不能在容器之间共享。</p><p id="d463" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">幸运的是，在函数调用结束后，无服务器容器会保留几分钟；此外，无服务器编程模型允许重用在每次调用时调用的入口方法<em class="ku"> handleRequest() </em>之外声明的执行上下文和状态。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Class states declared outside of the handleRequest() method.</figcaption></figure><p id="a0e0" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">我们可以在类构造函数中缓存单个数据库连接(即大小为1的池),只要容器还在，下次调用就可以重用。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lb"><img src="../Images/c0375737fc507cc2df0984adf5df9d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gsqqSItwRRskQJVUQeau3A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">A conn cache <strong class="bd iv">per</strong> container</figcaption></figure><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Setting up a UCP pool of size 1, in the class constructor, outside of the handleRequest() method</figcaption></figure><p id="bc86" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">我的<em class="ku"> adb-ucp </em>函数的完整Java代码改编自Todd Sharp关于“<em class="ku"> Oracle函数—连接到ATP数据库”的<a class="ae lc" href="https://blogs.oracle.com/developers/oracle-functions-connecting-to-an-atp-database-revisited" rel="noopener ugc nofollow" target="_blank">帖子</a>。</em></p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">The complete Serverless function Java code.</figcaption></figure><p id="c5b1" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">Todd的帖子<em class="ku"> </em>包含了配置、部署和调用Oracle函数和ATP-S数据库的所有步骤(这里不再重复),包括连接字符串、云凭证等等。我已经用对<em class="ku"> ALL_TABLE ( </em>一个字典表)的查询替换了对<em class="ku"> EMPLOYEES </em>表的查询，从而消除了在运行示例之前创建表的需要。我将应用程序和函数都命名为“adb-ucp ”,并测量了从池中检索一个连接的时间，即<em class="ku"> getConnection() </em>方法调用。<br/>以下命令允许您部署和调用该功能:</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Deploying and invoking adb-ucp</figcaption></figure><p id="f52c" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">由于无服务器功能仅显示返回的数据，要查看日志和打印输出，您需要订阅日志服务，如<a class="ae lc" href="https://blogs.oracle.com/cloud-infrastructure/announcing-limited-availability-of-oracle-cloud-infrastructure-logging-service" rel="noopener ugc nofollow" target="_blank"> Oracle云基础架构日志服务</a>或<a class="ae lc" href="https://www.papertrail.com/" rel="noopener ugc nofollow" target="_blank"> PaperTrail </a>。</p><p id="7271" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">在每个容器中设置一个大小为1的池可以避免连接的创建和拆除，但是这会导致函数实例和数据库会话之间的一对一映射；一些非活动/热功能甚至可能占用数据库连接。这种解决方案适用于小规模部署，但最终会在大规模部署中导致等待或异常，在大规模部署中，并发活动或热功能实例的数量大于可用数据库会话的有限数量。</p><h1 id="20e9" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">支持自动扩展/高并发性</h1><p id="b002" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">正如在序言中所指出的，在每个容器中设置一个专用连接的池防止了跨容器的池化/共享连接；容器和RDBMS会话之间的这种一对一映射将不会也不能支持具有无服务器功能的高并发性的大规模部署。这里的假设是，并非所有这些功能都同时进行数据库访问，当不再需要时，它们会放弃连接——否则，这将使共享失败。</p><p id="a7c4" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">存在几种解决方案，包括代理连接服务器，如Oracle的CMAN-TDM(流量定向器模式下的连接管理器，该功能目前不是云服务)和MySQL路由器；还有RDBMS端的连接池，比如Oracle的数据库常驻连接池(DRCP)。</p><p id="59fa" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">这些解决方案都具有跨中间层和容器池化数据库会话的能力。</p><h2 id="5c0f" class="ld iu hh bd iv le lf lg iz lh li lj jd kc lk ll jh kg lm ln jl kk lo lp jp lq bi translated">无服务器功能和数据库驻留连接池</h2><p id="6d42" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">ATP-S默认启用DRCP。客户端、中间层和容器“连接”到连接代理，该代理按需分配空闲的数据库会话。在将请求者与空闲数据库会话相关联时，连接代理不停留在循环中；关闭的连接将返回到池中。</p><figure class="kv kw kx ky fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lr"><img src="../Images/8d48598d676ea344291c6e673d4694b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnIGTPDIwMxXuEoVtrAjRw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">DRCP — Sharing connection across containers</figcaption></figure><p id="3979" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">ATP-S数据库提供开箱即用的5种服务配置文件:<em class="ku">高、中、</em>和<em class="ku">低</em>用于报告或批量<em class="ku">；用于OLTP的tp </em>和<em class="ku">t紧急</em>。这些<em class="ku"> tnsnames.ora </em>别名或入口点类似于JNDI名称，隐藏/虚拟化了数据库服务的细节。</p><p id="ab9e" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">让我们通过上面一对一映射中使用的同一个Oracle函数来配置和使用DRCP的步骤。</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Aliases of my tnsnames.ora generated for my ATP-S database (named OFunctions)</figcaption></figure><ol class=""><li id="8f5c" class="ls lt hh jt b ju kp jy kq kc lu kg lv kk lw ko lx ly lz ma bi translated">下载云客户端凭证(参见Todd的<a class="ae lc" href="https://blogs.oracle.com/developers/oracle-functions-connecting-to-an-atp-database-revisited" rel="noopener ugc nofollow" target="_blank">帖子</a>中的步骤1 " <em class="ku">下载ATP钱包</em>)并将它们解压缩到本地文件夹中</li><li id="b651" class="ls lt hh jt b ju mb jy mc kc md kg me kk mf ko lx ly lz ma bi translated">编辑<em class="ku"> tnsnames.ora </em>文件，添加一个带有DRCP引用的新别名(或者，您可以修改5个原始别名中的一个)。在我的测试中，我已经创建了一个名为<em class="ku">of functions _ TP urgent-DRCP</em>的新条目，方法是复制<em class="ku">of unations _ TP urgent</em>描述，并向<em class="ku"> CONNECT_DATA </em>部分添加“<em class="ku">(SERVER = POOLED)”</em>，然后保存tnsnames.ora文件。</li></ol><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">New alias for using DRCP and tpurgent</figcaption></figure><p id="7008" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">3.上传wallet(如果已经上传，则再次上传)，包括更新的tnsnames.ora，如中所述。步骤#2 " <em class="ku">在Todd的<a class="ae lc" href="https://blogs.oracle.com/developers/oracle-functions-connecting-to-an-atp-database-revisited" rel="noopener ugc nofollow" target="_blank">帖子</a>中，将钱包上传到对象存储</em>中的私有存储桶。事实上，我在上一节/解决方案(添加了一个新条目)中上传钱包之前就已经做了更改，所以我不需要重新上传。</p><p id="f210" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">4.在函数配置中更新DB_URL以使用新的别名，如下所示</p><figure class="kv kw kx ky fd ii"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="ccee" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">因为已经部署了该函数，所以对配置进行更改将获得新的URL和DRCP。下一步是简单地调用上一节中的函数。您仍然在每个容器中使用大小为1的池，但是，这些池附加到连接代理，而不是数据库会话。与专门使用大小为1的池相比，DRCP有额外的(或两个)毫秒延迟，这是通过连接代理的代价。但是，您可以在连接到同一ATP-S实例的所有容器之间共享数据库会话，从而保持高并发性。不像在非DRCP的情况下，温暖的容器保持空闲连接。</p><h1 id="f5ab" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">摘要</h1><p id="89f3" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">我已经向你介绍了序言中提到的要解决的问题的解决方案:(I)避免在每次函数调用时创建和拆除连接；以及(ii)面对有限数量的数据库会话维持高并发性。</p><p id="0e44" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">很明显，容器生命周期中的第一个数据库连接请求将会付出更高的代价，但是随后的调用会得到免费的午餐，或者几乎是免费的午餐！！。</p></div></div>    
</body>
</html>