<html>
<head>
<title>Better Android Testing at Airbnb — Part 4: Testing ViewModels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Airbnb更好的Android测试——第4部分:测试视图模型</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/better-android-testing-at-airbnb-part-4-testing-viewmodels-550d929126c8?source=collection_archive---------2-----------------------#2019-12-13">https://medium.com/airbnb-engineering/better-android-testing-at-airbnb-part-4-testing-viewmodels-550d929126c8?source=collection_archive---------2-----------------------#2019-12-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2b68" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们Airbnb Android测试系列的第四部分中，我们来看看ViewModels中单元测试逻辑的框架。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f37aff38ac07d1a2fe508c81b73f3ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SzUfC_eUHmH-O9CZwUDMtQ.jpeg"/></div></div></figure><p id="6cc5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-1d1e91e489b4">在本系列的第三部分</a>中，我们看到了自动化交互测试如何通过记录状态变化来覆盖视图模型中的一些代码路径。然而，这不能测试我们逻辑的所有边缘情况。ViewModel逻辑对于每个屏幕的正确行为至关重要，因此值得更深入地测试。</p><h1 id="b3f3" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">单元测试视图模型</h1><p id="0f85" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">视图模型是我们支持手动编写测试的一个例子，但是像往常一样，我们通过为我们的开发人员提供一个单元测试框架来最小化手动测试的开销。这包括一个简化测试语句的DSL，与我们的网络堆栈集成以对执行的请求进行断言，以及与我们的状态模拟系统结合以轻松设置测试的ViewModel状态。</p><p id="0b4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们基于几个核心原则开发了单元测试框架:</p><ul class=""><li id="060d" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">视图模型函数应该是独立可测试的。视图模型的设计不应该依赖于多个函数调用之间的交互。</li><li id="e814" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">函数调用的行为应该完全由调用函数时ViewModel的状态以及传递给它的参数来定义。</li><li id="1f98" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">该函数的输出应该是ViewModel上设置的新状态，或者是对依赖项的调用。</li></ul><p id="148a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">鉴于这些原则，我们的框架采用了以下方法:</p><ul class=""><li id="5e20" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">每个单元测试调用一个视图模型函数</li><li id="7576" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">测试的输入是ViewModel的初始状态，加上传递给函数的参数</li><li id="6f56" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">测试的输出是关于状态中发生了什么变化的断言，和/或对依赖项的预期调用的验证(通过Mockito)。</li></ul><h1 id="7366" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">一个基本例子</h1><p id="c094" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">让我们看一个存储可更新字符串的基本视图模型。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="0467" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">测试<strong class="ig hi"> <em class="jc"> setText </em> </strong>函数的代码如下所示:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="6566" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这指定了对我们正在测试的函数的引用、调用该函数的参数以及我们预期的结果是什么状态变化。这里我们测试调用<strong class="ig hi"><em class="jc">setText(" hello ")</em></strong>导致文本状态被更新为" hello "。</p><p id="8a32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc"> expectState </em> </strong>函数将初始状态作为接收方，返回期望的输出状态。这个返回的状态必须与输出完全匹配，否则测试会失败，框架会打印出哪些属性不相等。实际上，<strong class="ig hi"> <em class="jc"> expectState </em> </strong>定义了哪些属性需要更改以及新的值应该是什么。这可以防止副作用被遗漏。</p><h1 id="61b2" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">测试设置</h1><p id="91e1" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">测试框架负责初始化视图模型、收集测试语句和检查断言。</p><p id="2757" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">测试使用普通的JUnit和Robolectric设置运行，每个测试类对应一个视图模型。该类实现了一个接口，测试框架使用该接口为每个测试初始化一个新的ViewModel。</p><p id="7f56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，上述ViewModel的完整测试类如下所示:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="4b72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">测试框架使用<strong class="ig hi"> <em class="jc"> buildViewModel() </em> </strong>函数为每个测试创建一个新的ViewModel。</p><p id="3985" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">视图模型的初始状态可以是从屏幕的现有模拟中重用的模拟状态。这允许屏幕截图测试、交互测试和ViewModel单元测试共享相同的底层模拟实例。这极大地减少了设置测试所涉及的工作，并且如果状态数据结构发生变化，只需要在一个地方更新mock。</p><h1 id="18c6" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">修改状态</h1><p id="cc91" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">如果测试需要使用默认状态的修改版本，它可以利用我们之前提到的数据类DSL来轻松地对嵌套状态进行更改。</p><p id="d5f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了演示，让我们把例子扩展得更复杂一点。现在它有了一些额外的状态，允许我们跟踪文本是否加粗。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="6bf1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们检查<strong class="ig hi"> <em class="jc"> setBold </em> </strong>函数的测试语法如下:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="8cb8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将执行以下操作:</p><ol class=""><li id="8bfa" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb lj kz la lb bi translated">将嵌套的<strong class="ig hi"> <em class="jc"> bold </em> </strong>布尔属性初始化为false</li><li id="13ad" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lj kz la lb bi translated">用参数值<strong class="ig hi"> <em class="jc">真</em> </strong>调用<strong class="ig hi"> <em class="jc"> setBold </em> </strong></li><li id="e45f" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lj kz la lb bi translated">验证ViewModel的最终状态是否将<strong class="ig hi"> <em class="jc">粗体</em> </strong>属性设置为true</li></ol><h1 id="e842" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">展开性</h1><p id="6cd3" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">DSL使用可插拔系统，以便第三方扩展功能可以添加自定义语句和断言。我们自己用它来检查对我们的网络堆栈的预期调用。</p><p id="9eeb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的示例ViewModel中，让我们添加一个从网络请求中加载文本的函数。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="01d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">测试它的函数如下所示:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="20a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这项测试:</p><ol class=""><li id="ff39" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb lj kz la lb bi translated">调用id参数为“1”的<strong class="ig hi"> <em class="jc"> loadText </em> </strong>函数</li><li id="b1dd" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lj kz la lb bi translated">断言我们期望ViewModel使用id作为查询参数对给定的API路径执行网络GET请求</li><li id="53e6" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lj kz la lb bi translated">指定模拟响应值“服务器结果”</li><li id="fe31" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lj kz la lb bi translated">断言文本的最终状态值匹配我们模拟的响应值“服务器结果”</li></ol><p id="cac9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这允许我们用网络层测试我们的视图模型的边界，容易地检查期望的请求是否被发出并模拟返回值。</p><p id="4fc8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"><em class="jc">expect requests</em></strong>函数是单元测试框架的扩展函数。这允许我们开源核心库，但仍然在Airbnb测试我们的内部库。</p><p id="4293" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样值得注意的是，在单元测试和集成测试中，我们从不在JSON层模拟网络请求。我们发现维护JSON文件模拟很困难，也没有必要。相反，我们采用GraphQL来保证每个请求模式的编译时间。这意味着我们只需要断言进行了正确的查询，并且我们可以相信响应将是有效的、预期的格式。</p><p id="14e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这简化了我们的测试范围，提高了可维护性，并且仍然为我们的网络层功能提供了保证。</p><h1 id="6992" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">高级用法</h1><p id="dc2a" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">单元测试框架提供了其他一些测试通用ViewModel模式的实用工具。</p><h2 id="339d" class="lk jr hh bd js ll lm ln jw lo lp lq ka ip lr ls ke it lt lu ki ix lv lw km lx bi translated">自动验证</h2><p id="fd54" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">一个常见的例子是ViewModel函数，它更新状态的单个属性，比如我们上面的例子切换“bold”布尔值。该框架为这种情况提供了特殊的处理，使它只需几行代码就可以测试。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="8c12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用此语法，测试:</p><ol class=""><li id="b5a9" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb lj kz la lb bi translated">表示正在测试<strong class="ig hi"> <em class="jc"> setBold </em> </strong>功能</li><li id="2561" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lj kz la lb bi translated">指定对将因此而更改的嵌套状态属性的引用</li><li id="bfe6" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lj kz la lb bi translated">检测<strong class="ig hi"> <em class="jc"> setBold </em> </strong>函数的参数类型(本例中为布尔值)</li><li id="663e" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lj kz la lb bi translated">基于参数类型生成测试输入。对于布尔值，这将是真和假。如果它是可空的，它还将测试一个"<strong class="ig hi"> <em class="jc"> null </em> </strong>"输入。</li><li id="60a3" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lj kz la lb bi translated">使用生成的输入值调用<strong class="ig hi"> <em class="jc"> setBold </em> </strong>函数，并在每次调用后检查状态中的“Bold”属性是否已更新为相同的值。</li></ol><p id="4b1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这适用于任何具有单一原始类型的函数——类型通过反射检测，函数通过各种测试值调用。然后检查状态的属性值，以确保它等于预期的测试值。</p><p id="1be6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在更一般的情况下，我们也支持多参数函数以及状态属性类型不同于函数参数类型的情况。</p><p id="5034" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，下面测试一个函数，该函数对输入进行平方，并设置状态的“result”属性值。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="8335" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这使得列出输入到输出的映射变得容易；它自动调用每个输入的函数，并检查状态的相应输出。</p><h2 id="51b7" class="lk jr hh bd js ll lm ln jw lo lp lq ka ip lr ls ke it lt lu ki ix lv lw km lx bi translated">测试初始化</h2><p id="6e4f" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">ViewModel在初始化期间执行网络请求或其他任务也很常见；也就是说，当实例化一个新实例并调用构造函数时。</p><p id="1950" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，假设我们上面的TextViewModel被修改为在创建时从网络请求中加载文本。我们可以用这个语法测试这个行为。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="fc50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这断言当ViewModel被实例化时，它:</p><ol class=""><li id="b9b8" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb lj kz la lb bi translated">向预期的API路径发出网络GET请求</li><li id="0541" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lj kz la lb bi translated">将文本属性设置为“正在加载”状态</li></ol><p id="ca5d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">与正常的函数测试语法相比，这种语法是必需的，因为它必须包装视图模型的实例化并隔离那里的行为。另一方面，当测试函数时，我们排除了实例化过程中的行为，以免将它们合并。</p><h2 id="0b27" class="lk jr hh bd js ll lm ln jw lo lp lq ka ip lr ls ke it lt lu ki ix lv lw km lx bi translated">生成测试脚手架</h2><p id="ee22" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">最后，在一个多模块的世界里，为每一个新创建的模块建立一个单元测试环境可能是乏味的(我们有数百个模块！).对于每个模块，我们需要:</p><ul class=""><li id="4156" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">一个机器人测试跑步者</li><li id="a719" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">测试类要扩展的基本测试，以便应用runner</li><li id="ea28" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">支持匕首测试覆盖的支架(一个新的匕首模块加上一个测试应用程序来设置匕首模块的注射)。</li><li id="96e4" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">一个支持模拟最终类和函数的mockito插件(用于Kotlin用法)</li></ul><p id="660d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们已经创建了自动为模块生成所有这些测试框架的工具，因此开发人员可以立即开始编写单元测试，而无需处理任何繁琐的配置。</p><p id="b3f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，我们还创建了一个Intellij IDEA插件，可以为我们生成新的MvRx ViewModels。这允许我们为我们添加的每个新视图模型自动创建一个测试文件。</p><h1 id="ee96" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">下一步:我们的自动化基础设施</h1><p id="fb5c" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">总的来说，我们这个单元测试框架的目标是:</p><ol class=""><li id="cc6d" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb lj kz la lb bi translated">消除测试视图模型逻辑的摩擦，同时；</li><li id="a313" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb lj kz la lb bi translated">提供了一个简单而灵活的API，可以覆盖ViewModel的所有用例。</li></ol><p id="d695" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，我们将该库设计为可扩展的，这样我们就可以对其进行开源，允许团队轻松地将他们自己的断言添加到DSL中。</p><p id="7538" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然这对我们来说很棒，而且是全面测试业务逻辑所必需的，但是最好的测试是我们可以自动生成的！接下来，在系列文章的<a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b">第5部分，我们将重新审视我们的自动化集成测试框架，看看它如何为我们的交互和屏幕截图测试提供动力。</a></p><h2 id="41bb" class="lk jr hh bd js ll lm ln jw lo lp lq ka ip lr ls ke it lt lu ki ix lv lw km lx bi translated">系列索引</h2><p id="18cd" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">这是关于Airbnb测试的七篇系列文章。</p><p id="c733" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一部分-<a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-3f5b90b9c40a">测试哲学和模拟系统</a></p><p id="221c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第2部分-<a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-a77ac9531cab">MvRx和Happo截图测试</a></p><p id="3c1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第3部分-<a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-1d1e91e489b4">自动化交互测试</a></p><p id="992a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第4部分(本文)</strong> — <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-part-4-testing-viewmodels-550d929126c8">单元测试视图模型框架</a></p><p id="6103" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第5部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b">我们的自动化测试框架的体系结构</a></p><p id="c39d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第6部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-a11f6832773f">持续嘲讽的障碍</a></p><p id="461f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第7部分— <a class="ae jp" rel="noopener" href="/airbnb-engineering/better-android-testing-at-airbnb-eacec3a8a72f">测试生成和CI配置</a></p><h2 id="f73d" class="lk jr hh bd js ll lm ln jw lo lp lq ka ip lr ls ke it lt lu ki ix lv lw km lx bi translated">我们在招人！</h2><p id="e896" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">想和我们一起在这些和其他大规模的Android项目上合作吗？Airbnb正在全公司招聘几个Android工程师职位！当前空缺见https://careers.airbnb.com<a class="ae jp" href="https://careers.airbnb.com/" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>