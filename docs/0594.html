<html>
<head>
<title>Using KTX libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用KTX库</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/using-ktx-libraries-da1dc81c6ecf?source=collection_archive---------2-----------------------#2020-12-15">https://medium.com/androiddevelopers/using-ktx-libraries-da1dc81c6ecf?source=collection_archive---------2-----------------------#2020-12-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f54d5257763f1249e0482b52c4b4c9b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D2aKnfPkmj71LZWVghXjcQ.png"/></div></div></figure><div class=""/><p id="3371" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当在Kotlin中使用Android Java APIs时，您很快就会意识到您错过了一些Kotlin特性，这些特性使编码变得如此简单和愉快。与其为这些API编写自己的包装器和扩展函数，不如看看Jetpack KTX库。目前，超过20个库拥有KTX版本，创建了Java APIs的甜蜜惯用版本，从Android平台API到ViewModels、SQLite甚至Play Core。在这篇文章中，我们将看看一些可用的API，看看它们是如何制作的。</p><p id="f6ed" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你更喜欢看视频而不是看博客，请点击这里:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="jr js l"/></div></figure><h1 id="0c92" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">可发现性</h1><p id="f170" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">作为一个最佳实践，为了减轻ktx功能的可发现性，总是在可用时导入<code class="du kw kx ky kz b">-ktx</code>工件。由于<code class="du kw kx ky kz b">-ktx</code>工件暂时依赖于非ktx版本，所以不需要包含其他工件。例如，对于<code class="du kw kx ky kz b">viewmodel</code>，你得到两个神器:<code class="du kw kx ky kz b">viewmodel</code>和<code class="du kw kx ky kz b">viewmodel-ktx</code>。<code class="du kw kx ky kz b">-ktx</code>工件将包含Kotlin扩展:</p><pre class="jn jo jp jq fd la kz lb lc aw ld bi"><span id="95c8" class="le ju hs kz b fi lf lg l lh li">// Java language implementation<br/>implementation "androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version"</span><span id="c228" class="le ju hs kz b fi lj lg l lh li">// Kotlin implementation<br/>implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"</span></pre><h2 id="be7f" class="le ju hs bd jv lk ll lm jz ln lo lp kd ja lq lr kh je ls lt kl ji lu lv kp lw bi translated">总是导入-ktx工件</h2><p id="074a" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">对于Android平台API上的扩展，导入<code class="du kw kx ky kz b">core-ktx</code>工件。</p><pre class="jn jo jp jq fd la kz lb lc aw ld bi"><span id="15a9" class="le ju hs kz b fi lf lg l lh li">implementation "androidx.core:core-ktx:$corektx_version"</span></pre><p id="6125" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">ktx的大部分功能都是作为<a class="ae lx" rel="noopener" href="/androiddevelopers/extend-your-code-readability-with-kotlin-extensions-542bf702aa36">扩展函数</a>实现的，所以你可以通过使用Android Studio中的自动完成功能轻松找到它们。</p><p id="63ed" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">其他功能，比如像<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/kotlin/ktx/extensions-list#for_androidgraphicscolor" rel="noopener ugc nofollow" target="_blank">Color</a></code>类上可用的析构和操作符重载，可以通过查看<a class="ae lx" href="https://developer.android.com/kotlin/ktx/extensions-list#androidxactivity" rel="noopener ugc nofollow" target="_blank"> KTX扩展</a>的列表来发现。</p><h1 id="67c3" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">平台API—core-ktx</h1><p id="9ece" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated"><code class="du kw kx ky kz b">core-ktx</code>为来自Android平台的API提供惯用的Kotlin功能。</p><p id="4629" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，如果您正在使用<code class="du kw kx ky kz b">SharedPreferences</code>，当您想要更新一个值时，不需要执行3个不同的调用，您只需执行一个即可:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="ly js l"/></div></figure><p id="80b0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在幕后，<a class="ae lx" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:core/core-ktx/src/main/java/androidx/core/content/SharedPreferences.kt;l=39" rel="noopener ugc nofollow" target="_blank">ktx编辑方法</a>调用相同的功能，提供了一个很好的提交默认选项:<code class="du kw kx ky kz b">apply()</code>。<code class="du kw kx ky kz b">apply()</code>与<code class="du kw kx ky kz b">commit()</code>不同，异步提交磁盘上的更改:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="ly js l"/></div></figure><p id="96f6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du kw kx ky kz b">core-ktx</code>中，您还会发现一种处理常用平台监听器的更简单的方法。例如，如果您想在<code class="du kw kx ky kz b">EditText</code>中的文本被更改时触发一个动作，您必须实现<code class="du kw kx ky kz b">TextWatcher</code>的所有方法，即使您只对<code class="du kw kx ky kz b">onTextChanged()</code>感兴趣。<code class="du kw kx ky kz b">core-ktx</code>创建相应的<code class="du kw kx ky kz b">TextWatcher</code>方法:<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/core/widget/package-summary#doontextchanged" rel="noopener ugc nofollow" target="_blank">doOnTextChanged</a></code>、<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/core/widget/package-summary#doaftertextchanged" rel="noopener ugc nofollow" target="_blank">doAfterTextChanged</a></code>和<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/core/widget/package-summary#dobeforetextchanged" rel="noopener ugc nofollow" target="_blank">doBeforeTextChanged</a></code>，但是在你的Kotlin代码中，你只使用你需要的那个:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="ly js l"/></div></figure><p id="d604" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这带来了几个好处:您的代码变得更容易阅读，因为它更简洁，并且您可以获得更好的命名和可空性注释。</p><p id="bcde" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您会发现<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/core/animation/package-summary#(android.animation.Animator).addListener(kotlin.Function1,%20kotlin.Function1,%20kotlin.Function1,%20kotlin.Function1)" rel="noopener ugc nofollow" target="_blank">AnimatorListener</a></code>和<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/core/transition/package-summary#(android.transition.Transition).addListener(kotlin.Function1,%20kotlin.Function1,%20kotlin.Function1,%20kotlin.Function1,%20kotlin.Function1)" rel="noopener ugc nofollow" target="_blank">TransitionListener</a></code>有相似的监听器API。</p><p id="16d3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在幕后，<code class="du kw kx ky kz b"><a class="ae lx" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:core/core-ktx/src/main/java/androidx/core/widget/TextView.kt;l=42?q=doOnTextChanged" rel="noopener ugc nofollow" target="_blank">doOnTextChanged</a></code>是作为<code class="du kw kx ky kz b">TextView</code>上的扩展函数实现的——这个类也有<code class="du kw kx ky kz b">addTextChangedListener</code>方法。<code class="du kw kx ky kz b">doOnTextChanged</code>为<code class="du kw kx ky kz b">TextWatcher</code>的其他函数创建<a class="ae lx" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:core/core-ktx/src/main/java/androidx/core/widget/TextView.kt;l=65" rel="noopener ugc nofollow" target="_blank">空实现</a>。</p><h1 id="1751" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Jetpack APIs</h1><p id="a050" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">大多数可用的扩展是针对Jetpack APIs的。在这里，我将回顾一下我发现自己最常用的一些。</p><h1 id="36ec" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">LiveData</h1><p id="1b40" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">许多LiveData功能也是作为扩展函数实现的:像<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#map" rel="noopener ugc nofollow" target="_blank">map</a></code>、<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#switchmap" rel="noopener ugc nofollow" target="_blank">switchMap</a></code>或<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#distinctuntilchanged" rel="noopener ugc nofollow" target="_blank">distinctUntilChanged</a></code> ( <a class="ae lx" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-livedata-ktx/src/main/java/androidx/lifecycle/Transformations.kt;l=35" rel="noopener ugc nofollow" target="_blank">源</a>)这样的方法。</p><p id="b5c7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，使用<code class="du kw kx ky kz b">livedata-ktx</code>中的<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#map" rel="noopener ugc nofollow" target="_blank">map</a></code>可以消除调用<code class="du kw kx ky kz b">Transformations.map(livedata) { /* map function */ }</code>的需要，并允许我们以更符合Kotlin习惯的方式直接调用<code class="du kw kx ky kz b">liveData.map</code>。</p><p id="d7a5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当你观察一个<code class="du kw kx ky kz b">LiveData</code>对象时，你必须实现一个<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/Observer" rel="noopener ugc nofollow" target="_blank">Observer</a></code>。但是使用来自<code class="du kw kx ky kz b">lifecycle-ktx</code>的observe，代码变得更简单。如果没有找到方法，确保调用import <code class="du kw kx ky kz b">androidx.lifecycle.observe</code>。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="ly js l"/></div></figure><p id="7b98" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kw kx ky kz b">LiveData</code>非常适合暴露数据供用户界面使用，因此，为了从<code class="du kw kx ky kz b">Flow</code>转换到<code class="du kw kx ky kz b">LiveData</code>以及从<code class="du kw kx ky kz b">LiveData</code>转换到<code class="du kw kx ky kz b">Flow</code>,<code class="du kw kx ky kz b">lifecycle-livedata-ktx</code>工件提供了两个方便的扩展函数:<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#aslivedata" rel="noopener ugc nofollow" target="_blank">Flow.asLiveData()</a></code>和<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#asflow" rel="noopener ugc nofollow" target="_blank">LiveData.asFlow()</a></code>。</p><h1 id="0d2e" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">活动/片段和视图模型</h1><p id="6064" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">为了构造一个视图模型，如果你的<code class="du kw kx ky kz b">ViewModel</code>有依赖关系，你可以扩展<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" rel="noopener ugc nofollow" target="_blank">ViewModel</a></code>类并实现<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/androidx/lifecycle/ViewModelProvider.Factory" rel="noopener ugc nofollow" target="_blank">ViewModelProvider.Factory</a></code>。要实例化它，使用<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/activity/package-summary#(androidx.activity.ComponentActivity).viewModels(kotlin.Function0)" rel="noopener ugc nofollow" target="_blank">viewModels</a></code>委托(点击阅读更多关于委托<a class="ae lx" rel="noopener" href="/androiddevelopers/delegating-delegates-to-kotlin-ee0a0b21c52b">):<code class="du kw kx ky kz b">by viewModels(factory)</code>:</a></p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="ly js l"/></div></figure><p id="9d2e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kw kx ky kz b">viewModels</code>在<code class="du kw kx ky kz b">activity</code>和<code class="du kw kx ky kz b">fragment</code>的<code class="du kw kx ky kz b">-ktx</code>神器中有。</p><p id="a7c3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用协程时，您会发现自己需要在ViewModel中启动一个协程。当ViewModel被销毁时，协程所做的工作应该被取消。不要实现你自己的<code class="du kw kx ky kz b">CoroutineScope</code>，使用<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#viewmodelscope" rel="noopener ugc nofollow" target="_blank">viewModelScope</a></code>。取消将在<code class="du kw kx ky kz b"><a class="ae lx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/ViewModel#oncleared" rel="noopener ugc nofollow" target="_blank">ViewModel.onCleared()</a></code>为您自动完成。从<a class="ae lx" rel="noopener" href="/androiddevelopers/easy-coroutines-in-android-viewmodelscope-25bffb605471">这篇博文</a>中找出<code class="du kw kx ky kz b">viewModelScope</code>的来龙去脉。</p><h1 id="3841" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">房间和工作经理</h1><p id="54f1" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">Room和WorkManager都通过它们的<code class="du kw kx ky kz b">-ktx</code>构件提供协程支持。因为我们认为更深入地讨论这些是值得的，所以请继续关注专注于这些特定库的MAD技能文章！</p><h1 id="6a9c" class="jt ju hs bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">其他KTX模块</h1><p id="bd8a" class="pw-post-body-paragraph ip iq hs ir b is kr iu iv iw ks iy iz ja kt jc jd je ku jg jh ji kv jk jl jm ha bi translated">AndroidX神器不是唯一提供KTX版本的:</p><ul class=""><li id="fc81" class="lz ma hs ir b is it iw ix ja mb je mc ji md jm me mf mg mh bi translated">Firebase创建了<a class="ae lx" href="https://firebaseopensource.com/projects/firebase/firebase-android-sdk/docs/ktx/common.md" rel="noopener ugc nofollow" target="_blank">通用Kotlin扩展</a></li><li id="156d" class="lz ma hs ir b is mi iw mj ja mk je ml ji mm jm me mf mg mh bi translated">谷歌地图提供<a class="ae lx" href="https://developers.google.com/maps/documentation/android-sdk/ktx" rel="noopener ugc nofollow" target="_blank">地图</a>和<a class="ae lx" href="https://developers.google.com/places/android-sdk/ktx" rel="noopener ugc nofollow" target="_blank">地点</a> ktx图书馆</li><li id="a4d9" class="lz ma hs ir b is mi iw mj ja mk je ml ji mm jm me mf mg mh bi translated">Play Core有一个core-ktx工件，为监控应用内更新提供协程支持</li></ul></div><div class="ab cl mn mo go mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ha hb hc hd he"><p id="70c3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">简洁、易读和Kotlin惯用——一旦你开始使用<code class="du kw kx ky kz b">-ktx</code>扩展，这些特性将使你的代码受益。敬请关注更多在应用中利用Kotlin和Jetpack的方式！</p></div></div>    
</body>
</html>