<html>
<head>
<title>Tapping into the Interceptor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">接入拦截器</h1>
<blockquote>原文：<a href="https://medium.com/globant/tapping-into-the-interceptor-8b40980ba436?source=collection_archive---------1-----------------------#2020-07-17">https://medium.com/globant/tapping-into-the-interceptor-8b40980ba436?source=collection_archive---------1-----------------------#2020-07-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e56ae950bf0a628e8d8d5ea3ca8201aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jAoXPY8n2nYmw3SgpYB1Uw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The presentational flow for Interceptor</figcaption></figure></div><div class="ab cl it iu go iv" role="separator"><span class="iw bw bk ix iy iz"/><span class="iw bw bk ix iy iz"/><span class="iw bw bk ix iy"/></div><div class="ha hb hc hd he"><p id="8307" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi jy translated">这里有很多在angular中使用拦截器的方法。您可以使用它们来操作URL、显示加载程序、改变API响应、操作标题，咻！这个清单还在继续。我相信我们大多数人只看到了它的一小部分。</p><p id="3288" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">我打算展示角度拦截器的扩展功能，除了基本的用途，比如将承载令牌传递给请求的API。我最常用的是错误处理、缓存和链接。我将在这篇文章中解释这一点。</p><blockquote class="kh ki kj"><p id="e3c7" class="ja jb kk jc b jd je jf jg jh ji jj jk kl jm jn jo km jq jr js kn ju jv jw jx ha bi translated"><em class="hh">先决条件:</em>角度4+，API请求流模式</p></blockquote><h1 id="2869" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">错误处理</strong></h1><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lm"><img src="../Images/3b45300797fe8ec1c6e086f1d3b9ef87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwuzLugwjN2lp7gUeAKb5A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">borrowed from <a class="ae lr" href="https://in.pinterest.com/pin/432627107954879374/" rel="noopener ugc nofollow" target="_blank">https://in.pinterest.com/pin/432627107954879374/</a></figcaption></figure><blockquote class="kh ki kj"><p id="5dcc" class="ja jb kk jc b jd je jf jg jh ji jj jk kl jm jn jo km jq jr js kn ju jv jw jx ha bi translated">作为一个用户，你在加载页面时遇到过多少次错误。盯着写着“过一段时间再试一次”的错误页面可能会令人沮丧，或者还记得过去在网吧反复点击刷新图标吗？？</p></blockquote><p id="25e8" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">截击机来拯救我们，同时在一定程度上处理这个问题。</p><p id="4bde" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">处理错误是任何应用程序的重要和关键部分。Angular为此提供了<a class="ae lr" href="https://angular.io/api/core/ErrorHandler#errorhandler" rel="noopener ugc nofollow" target="_blank"> ErrorHandler </a>类。可以扩展该类来创建一个全局错误处理程序。基本上，您可以处理发生的所有错误，但它主要用于跟踪错误日志。</p><p id="76d5" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">有时，如果不能像ErrorHandler类那样根据错误采取行动，仅仅跟踪错误是不够的。很多时候，应用程序会因为网络相关的问题或中断而失败。由于现在移动设备的使用越来越多，这种情况经常发生，因此故障保护解决方案变得不可避免。</p><p id="1781" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">因此，重试请求变得很重要，如果仍然失败，则在必要时根据具体情况处理错误。</p><p id="6c2f" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><strong class="jc hi">我们可以将请求重试作为下面代码片段</strong>中的示例</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="9361" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><strong class="jc hi">处理错误&amp;API请求成功</strong></p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="bcac" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">这里，自定义类<strong class="jc hi"> APICallsInterceptor </strong>扩展了处理API请求的<a class="ae lr" href="https://angular.io/api/common/http/HttpInterceptor" rel="noopener ugc nofollow" target="_blank"> HttpInterceptor </a>。一旦在将响应发送到原始资源点之前捕获到响应，就会在<strong class="jc hi"> intercept </strong>方法中对其进行处理，我们可以在自己的自定义函数中触发所需的操作，如<strong class="jc hi"> myCustomFunc </strong>()所示。</p><p id="b4dc" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">但并不局限于此。您可以添加一个函数来解析响应字符串，并通过函数将其显示为一条消息。此外，让我们在应用程序级别扩展一个全局服务，我们也可以手动触发它来显示一些消息。</p><blockquote class="kh ki kj"><p id="225c" class="ja jb kk jc b jd je jf jg jh ji jj jk kl jm jn jo km jq jr js kn ju jv jw jx ha bi translated">拦截器可以改变请求和响应，但有趣的是<a class="ae lr" href="https://angular.io/api/common/http/HttpRequest" rel="noopener ugc nofollow" target="_blank"> HttpRequest </a>和<a class="ae lr" href="https://angular.io/api/common/http/HttpResponse" rel="noopener ugc nofollow" target="_blank"> HttpResponse </a>类是只读的，应该被克隆。所以这使得这些类基本上是不可变的。—角度IO</p></blockquote><h1 id="6eed" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">贮藏</h1><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lu"><img src="../Images/577e560551dcacc223cd45a85ee165c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkmelGkmImdjBkOBF2iApA.png"/></div></div></figure><p id="09bb" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">考虑这样一个场景，您正在开发一个像“我的个人资料”和“名字”这样的功能，应用程序中的所有页面都需要来自个人资料的响应。每次调用API来获取信息都会降低性能。</p><p id="81c0" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">所以<a class="ae lr" href="https://angular.io/api/common/http/HttpInterceptor" rel="noopener ugc nofollow" target="_blank"> HttpInterceptor </a>又来救我们了！在拦截器的范围内操纵和处理请求是可能的，而无需将其传递给<strong class="jc hi"> next.handle() </strong>。这正是我们可以用来缓存请求的东西。我们可以创建一个键-值映射，其中请求URL是键。在键值映射中搜索响应，一旦找到，就通过下一个函数返回该响应的可观察值。</p><p id="27e5" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">这对性能有积极的影响，因为响应已被缓存，不再需要访问后端。</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="ls lt l"/></div></figure><blockquote class="kh ki kj"><p id="6a3d" class="ja jb kk jc b jd je jf jg jh ji jj jk kl jm jn jo km jq jr js kn ju jv jw jx ha bi translated">是的，很明显，在实现时，必须考虑时间戳，并在响应数据更新时使缓存失效。为此，我们可以使用来自RxJS的方法，但这是另一个时间的讨论！！</p></blockquote><h1 id="7583" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">链接</h1><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lv"><img src="../Images/b89a34adb7e30036e6130cb1bc0a7c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VHYk3zKRP_Bz2GdK"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae lr" href="https://unsplash.com/@bmowinkel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brandon Mowinkel</a> on <a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a5fc" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">您可以在您的应用程序中为不同的目的使用多个拦截器。就像上面的例子，我们刚刚经历了。但是，如果您需要从错误拦截器中的身份验证拦截器获得身份验证信息，或者从概要分析拦截器中的缓存拦截器获得缓存信息，该怎么办呢？</p><p id="7fac" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">Angular为拦截器提供了链接支持。因此，您需要做的就是使用<strong class="jc hi"><em class="kk">HTTP _ INTERCEPTORS</em></strong>来注册所有的拦截器，这是一个多提供者令牌，它表示已注册的HttpInterceptors的数组。瞧啊。！</p><p id="3a7c" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><strong class="jc hi"> next.handle() </strong>将控制传递给链中的下一个拦截器。</p><p id="4e94" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">创建一个拦截器数组并在应用程序模块中使用它也是清理代码的好方法。</p><p id="d556" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">在下面的例子中<strong class="jc hi">拦截器数组</strong>包含了所有需要的拦截器。然后，这个文件被导入到app模块文件中，数组被传递到提供者中，用于注册拦截器。</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="8303" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><strong class="jc hi">提供</strong>:HTTP _ INTERCEPTORS——它是用于识别的角度令牌</p><p id="caa9" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><strong class="jc hi"> useClass </strong>:应该添加到HttpInterceptors数组中的类</p><p id="6d82" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><strong class="jc hi"> multi </strong> : true —这是必需的设置，告诉angular令牌是多提供者。如果为false，应用程序将抛出一个错误。</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="ls lt l"/></div></figure><blockquote class="kh ki kj"><p id="766b" class="ja jb kk jc b jd je jf jg jh ji jj jk kl jm jn jo km jq jr js kn ju jv jw jx ha bi translated">拦截器的角度链适用于它们被创建和注册的顺序。如果它们被注册——X，然后Y，然后Z，请求将按照X后Y后Z的顺序，而响应将是——Z后Y后X。</p></blockquote><p id="6178" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">这是理解拦截器的一个重要的关键概念，因为它也可以消除许多不必要的冲突问题。</p><h1 id="0a04" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">闭幕词</strong></h1><p id="0c02" class="pw-post-body-paragraph ja jb hh jc b jd lw jf jg jh lx jj jk jl ly jn jo jp lz jr js jt ma jv jw jx ha bi translated">我们讨论了拦截器的3种常用方式。理解和实现起来非常简单，不是吗？</p><p id="93d8" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">我希望这能让你对拦截器有更多的了解，你会发现这些内容很有用。请随时提供您的反馈或您在示例中发现的任何改进之处。感谢阅读:)</p><p id="5d8c" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">下面列出了一些我认为是Angular的好读物，如果你感兴趣的话。快乐阅读！！！</p><p id="6de5" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><a class="ae lr" href="https://blog.angular-university.io/angular-jwt-authentication/" rel="noopener ugc nofollow" target="_blank">https://blog . angular-university . io/angular-jwt-authentic ation/</a></p><p id="6984" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><a class="ae lr" href="https://www.udemy.com/course/angular-authentication-tutorial-mastering-the-basics/" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/course/angular-authentic ation-tutorial-mastering-the-basics/</a></p><p id="e254" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><a class="ae lr" rel="noopener" href="/@zeljkoradic/loader-bar-on-every-http-request-in-angular-6-60d8572a21a9">https://medium . com/@ zeljkoradic/loader-bar-on-every-http-request-in-angular-6-60d 8572 a 21 a9</a></p><p id="995c" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><a class="ae lr" href="https://indepth.dev/insiders-guide-into-interceptors-and-httpclient-mechanics-in-angular/" rel="noopener ugc nofollow" target="_blank">https://indepth . dev/insiders-guide-into-interceptors-and-http client-mechanics-in-angular/</a></p><blockquote class="kh ki kj"><p id="b004" class="ja jb kk jc b jd je jf jg jh ji jj jk kl jm jn jo km jq jr js kn ju jv jw jx ha bi translated">“让它工作，让它正确，让它快。”—肯特·贝克</p></blockquote></div></div>    
</body>
</html>