<html>
<head>
<title>A toast to ES2015 destructuring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为ES2015解构主义干杯</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/a-toast-to-es2015-destructuring-5ac639a666cf?source=collection_archive---------2-----------------------#2017-02-09">https://medium.com/google-developer-experts/a-toast-to-es2015-destructuring-5ac639a666cf?source=collection_archive---------2-----------------------#2017-02-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/08b824e33f4572faf5dd79c77721bf65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A45ygxmUKM-AeltQtCq4fA.jpeg"/></div></div></figure><p id="058a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我认为<a class="ae jn" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> ES2015析构语法</a>非常酷。它可能不会像承诺、生成器或类语法那样占据头条，但我发现它真的很有用。当你仔细阅读时，它也是<a class="ae jn" href="http://exploringjs.com/es6/ch_destructuring.html" rel="noopener ugc nofollow" target="_blank">惊人的详细。</a></p><p id="1bdc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">唯一遗憾的是，我发现的大多数例子都只关注语法，而不是现实生活中的用法。比如这个来自<a class="ae jn" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>的:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="c190" class="jx jy hh jt b fi jz ka l kb kc">var a, b;<br/>[a, b] = [10, 20];<br/>console.log(a); // 10<br/>console.log(b); // 20</span></pre><p id="b72a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">幸运的是，我这里有一个真实生活中的用例，可以给你解构。</p><h1 id="36a2" class="kd jy hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">信守承诺</h1><p id="a2b8" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">我最喜欢的析构用法之一是在使用<code class="du lf lg lh jt b">Promise.all</code>等待大量异步任务完成的时候。<code class="du lf lg lh jt b">Promise.all</code>的结果作为一个数组返回，你通常可以迭代它或者手工挑选出你需要的结果。</p><p id="6a7d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是，如果您知道您期望接收什么对象，那么您可以使用参数析构来简化您的工作，并且通过预先命名参数来使您的代码更漂亮、更具描述性。让我们看一个例子。</p><h1 id="93d6" class="kd jy hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">比较啤酒</h1><p id="fd2f" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">假设你想比较两种<a class="ae jn" href="https://www.brewdog.com/beer/headliners" rel="noopener ugc nofollow" target="_blank"> BrewDog的美味啤酒</a>，这是我发现自己在现实生活中一直在做的事情<a class="ae jn" href="https://untappd.com/user/philnash" rel="noopener ugc nofollow" target="_blank"/>。我们可以从山姆·梅森的名为<a class="ae jn" href="https://punkapi.com/" rel="noopener ugc nofollow" target="_blank">的朋克API </a>中获得关于他们的信息。为了实现这一点，我们使用<code class="du lf lg lh jt b">fetch</code> API从API中获取每种啤酒的数据。我们需要先解决这两个请求，然后才能比较啤酒。</p><p id="2ff4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看一下代码:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="4f60" class="jx jy hh jt b fi jz ka l kb kc">const punkAPIUrl = "<a class="ae jn" href="https://api.punkapi.com/v2/beers/106" rel="noopener ugc nofollow" target="_blank">https://api.punkapi.com/v2/beers/106</a>";<br/>const deadPonyClubUrl = "<a class="ae jn" href="https://api.punkapi.com/v2/beers/91" rel="noopener ugc nofollow" target="_blank">https://api.punkapi.com/v2/beers/91</a>";<br/>const punkAPIPromise = fetch(punkAPIUrl)<br/>  .then(res =&gt; res.json())<br/>  .then(data =&gt; Promise.resolve(data[0]));<br/>const deadPonyClubPromise = fetch(deadPonyClubUrl)<br/>  .then(res =&gt; res.json())<br/>  .then(data =&gt; Promise.resolve(data[0]));</span><span id="838d" class="jx jy hh jt b fi li ka l kb kc">Promise.all([punkAPIPromise, deadPonyClubPromise])<br/>  .then(beers =&gt; {<br/>    const punkIPA = beers[0];<br/>    const deadPonyClub = beers[1];<br/>    const stronger = (punkIPA.abv &lt; deadPonyClub.abv ? deadPonyClub.name : punkIPA.name) + " is stronger";<br/>    console.log(stronger);<br/>  });</span></pre><p id="bfb9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以用参数析构来整理这个承诺:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="9ea1" class="jx jy hh jt b fi jz ka l kb kc">Promise.all([punkAPIPromise, deadPonyClubPromise])<br/>  .then(([punkIPA, deadPonyClub]) =&gt; {<br/>    const stronger = (punkIPA.abv &lt; deadPonyClub.abv ? deadPonyClub.name : punkIPA.name) + " is stronger";<br/>    console.log(stronger);<br/>  });</span></pre><p id="2b96" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们知道我们得到了两种啤酒，这个例子的构造方式，我们甚至知道哪种啤酒是哪种。因此，我们可以使用参数析构来命名数组中的啤酒，而不是取出它们。</p><h1 id="a45f" class="kd jy hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">更多示例</h1><p id="f2ba" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">好吧，这看起来仍然像是一个虚构的例子，但它确实更接近现实生活。我第一次发现自己使用这种技巧是在为圣诞节的12个dev写关于服务人员的文章时。当编写使用<code class="du lf lg lh jt b">caches</code>和<code class="du lf lg lh jt b">fetch</code>API实现“在重新验证时过时”缓存方法的方法<code class="du lf lg lh jt b">returnFromCacheOrFetch</code>时，它就派上了用场。</p><p id="7df5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该方法打开一个命名的缓存，并尝试将当前请求与缓存进行匹配。在返回之前，它启动对所请求资源的<code class="du lf lg lh jt b">fetch</code>请求，缓存结果。最后，如果在缓存中找到请求，则返回缓存的响应，否则返回新的获取请求。你可以在<a class="ae jn" href="http://12devsofxmas.co.uk/2016/01/day-9-service-worker-santas-little-performance-helper/" rel="noopener ugc nofollow" target="_blank">原博文</a>中了解更多。</p><p id="6f21" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最终的代码如下所示:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="ebe1" class="jx jy hh jt b fi jz ka l kb kc">function returnFromCacheOrFetch(request, cacheName) {<br/>  const cachePromise = caches.open(cacheName);<br/>  const matchPromise = cachePromise<br/>    .then((cache) =&gt; cache.match(request));</span><span id="7e83" class="jx jy hh jt b fi li ka l kb kc">  // Use the result of both the above Promises to return the <br/>  // Response. Promise.all returns an array, but we destructure that<br/>  // in the callback. <br/>  return Promise.all([cachePromise, matchPromise])<br/>    .then(([cache, cacheResponse]) =&gt; { <br/>      // Kick off the update request<br/>      const fetchPromise = fetch(request)<br/>        .then((fetchResponse) =&gt; {<br/>          // Cache the updated file and then return the response<br/>          cache.put(request, fetchResponse.clone());<br/>          return fetchResponse; <br/>        }); <br/>      // return the cached response if we have it, otherwise the <br/>      // result of the fetch. <br/>      return cacheResponse || fetchPromise;<br/>    });<br/>}</span></pre><p id="34b8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种情况下，我需要<code class="du lf lg lh jt b">caches.open</code>和<code class="du lf lg lh jt b">cache.match(request)</code>的结果来执行后台获取并返回缓存的响应。我用<code class="du lf lg lh jt b">Promise.all</code>把它们画在一起，然后解构得到的数组，保持代码的整洁和描述性。</p><h1 id="1ac8" class="kd jy hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">命名事物</h1><p id="8750" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">在这些例子中，参数析构允许我们命名我们期望从传递给<code class="du lf lg lh jt b">Promise.all</code>的解析承诺中得到的结果。事实上，在任何我们使用参数析构的地方，特别是数组，它允许我们更早更好地命名对象。从长远来看，这反过来又使代码更具可读性和可维护性。</p><p id="d0f3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您发现ES2015析构语法在代码的其他地方有用吗？我也很想知道你是如何使用这个特性的，所以请在Twitter上与我分享你的析构技巧。</p></div><div class="ab cl lj lk go ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ha hb hc hd he"><p id="b330" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="http://philna.sh/blog/2017/02/09/toast-to-es2015-destructuring/" rel="noopener ugc nofollow" target="_blank"> <em class="lq">干杯ES2015解构</em> </a> <em class="lq">原载于2017年2月9日</em><a class="ae jn" href="http://philna.sh/blog/2017/02/09/toast-to-es2015-destructuring/" rel="noopener ugc nofollow" target="_blank"><em class="lq">philna . sh</em></a><em class="lq">。</em></p></div></div>    
</body>
</html>