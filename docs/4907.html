<html>
<head>
<title>Enum vs Sealed class — which one to choose?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">枚举与密封类——选择哪一个？</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/enum-vs-sealed-class-which-one-to-choose-dc92ce7a4df5?source=collection_archive---------0-----------------------#2020-03-16">https://blog.kotlin-academy.com/enum-vs-sealed-class-which-one-to-choose-dc92ce7a4df5?source=collection_archive---------0-----------------------#2020-03-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/99c7fefd737af88c8ec5646f91b205ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L5V03i_otLjw0iir.jpg"/></div></div></figure><div class=""/><p id="b101" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">更新:</strong> <a class="ae kt" href="https://kt.academy/article/ek-enum" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz">这里的</strong> </a> <strong class="jx iz">是本文的最新版本。</strong></p><p id="e4ec" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TL；DR:enum有类似于<code class="fe ku kv kw kx b">valueOf</code>、<code class="fe ku kv kw kx b">values</code>或<code class="fe ku kv kw kx b">enumValues</code>的支持函数，这使得它们更容易迭代或序列化。就像类一样，它们可以有自定义方法或保存数据，但每个枚举值总是有一个。它们非常适合表示一组常量值。密封类可以保存特定于实例的数据。它们非常适合用一组具体的子类来表示消息或类。</p><figure class="kz la lb lc gt ip gh gi paragraph-image"><a href="https://kt.academy/workshop"><div class="gh gi ky"><img src="../Images/3a56ace9079f060f9ee79ad3ed6b6756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HxsEmnZGeKgLuGPFgNaLzA.png"/></div></a></figure><h1 id="3fef" class="ld le iy bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">列举型别</h1><p id="a07b" class="pw-post-body-paragraph jv jw iy jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">当我们必须表示一组恒定的可能选项时，一个经典的选择是使用Enum。例如，如果我们的网站提供了一组具体的支付方式，我们可以使用下面的enum类在我们的服务中表示它们:</p><figure class="kz la lb lc gt ip"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="c817" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">枚举可以保存始终特定于项目的值:</p><figure class="kz la lb lc gt ip"><div class="bz fp l di"><div class="mg mh l"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk"><a class="ae kt" href="https://play.kotlinlang.org/#eyJ2ZXJzaW9uIjoiMS4zLjYxIiwicGxhdGZvcm0iOiJqYXZhIiwiYXJncyI6IiIsImpzQ29kZSI6IiIsIm5vbmVNYXJrZXJzIjp0cnVlLCJ0aGVtZSI6ImlkZWEiLCJjb2RlIjoiaW1wb3J0IGphdmEubWF0aC5CaWdEZWNpbWFsXG5cbmVudW0gY2xhc3MgUGF5bWVudE9wdGlvbiB7XG4gICAgQ0FTSCxcbiAgICBDQVJELFxuICAgIFRSQU5TRkVSO1xuXG4gICAgdmFyIGNvbW1pc3Npb246IEJpZ0RlY2ltYWwgPSBCaWdEZWNpbWFsLlpFUk9cbn1cblxuZnVuIG1haW4oKSB7XG4gICAgdmFsIGMxID0gUGF5bWVudE9wdGlvbi5DQVJEXG4gICAgdmFsIGMyID0gUGF5bWVudE9wdGlvbi5DQVJEXG4gICAgcHJpbnRsbihjMSA9PSBjMikgLy8gdHJ1ZSwgYmVjYXVzZSBpdCBpcyB0aGUgc2FtZSBvYmplY3RcblxuICAgIGMxLmNvbW1pc3Npb24gPSBCaWdEZWNpbWFsLlRFTlxuICAgIHByaW50bG4oYzIuY29tbWlzc2lvbikgLy8gMTBcblxuICAgIHZhbCB0ID0gUGF5bWVudE9wdGlvbi5UUkFOU0ZFUlxuICAgIHByaW50bG4odC5jb21taXNzaW9uKSAvLyAwLCBiZWNhdXNlIGBjb21taXNzaW9uYCBpcyBwZXItaXRlbVxufSJ9" rel="noopener ugc nofollow" target="_blank">Playground</a></figcaption></figure><p id="a6e1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让这样的值可变是不好的，因为它们在每个项目中都是静态的。尽管该功能通常用于为每个项目附加一些常量值。这些常量值可以在每个项创建期间使用主构造函数附加:</p><figure class="kz la lb lc gt ip"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9da9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">科特林枚举甚至可以有方法。它们的实现也是特定于项目的。当我们定义它们时，enum类本身(像这里的<code class="fe ku kv kw kx b">PaymentOption</code>一样)需要定义一个抽象方法，并且每一项都必须覆盖它:</p><figure class="kz la lb lc gt ip"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="b269" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然此选项很少使用，因为使用函数类型的主构造函数参数更方便:</p><figure class="kz la lb lc gt ip"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="593d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更方便的选择是定义一个扩展函数:</p><figure class="kz la lb lc gt ip"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="417b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">enum的强大之处在于那些项目是特定的和不变的。因此，我们可以使用<code class="fe ku kv kw kx b">values()</code>功能获取所有项目，或者使用<code class="fe ku kv kw kx b">enumValueOf</code>功能按类型获取。我们也可以使用<code class="fe ku kv kw kx b">valueOf(String)</code>从<code class="fe ku kv kw kx b">String</code>读取enum，或者使用<code class="fe ku kv kw kx b">enumValueOf</code>按类型读取。</p><figure class="kz la lb lc gt ip"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="bb58" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，遍历枚举值是容易的，它们的序列化/反序列化是简单而有效的(因为它们通常只由名称表示),并且被大多数序列化库自动支持(如Gson、Jackson、Kotlin序列化等)。).它们也有序数，并自动实现<code class="fe ku kv kw kx b">toString</code>、<code class="fe ku kv kw kx b">hashCode</code>和<code class="fe ku kv kw kx b">equals</code>。因此，枚举非常适合表示一组具体的常量值。</p><figure class="kz la lb lc gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi mm"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h1 id="5060" class="ld le iy bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">密封类</h1><p id="f922" class="pw-post-body-paragraph jv jw iy jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">表示一组具体值的另一种方式是密封类。密封类是抽象类，在同一个文件中定义了具体数量的子类。</p><p id="a919" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">sealed modifier所做的是不可能在文件之外定义这个类的另一个子类。由于这个原因，我们可以通过分析单个文件来确定一个密封类的子类。Kotlin编译器也知道这一点，因此在某些情况下，如<code class="fe ku kv kw kx b">when</code>，它可以建议选项，并理解所有的可能性都包括在内。(要了解<code class="fe ku kv kw kx b">out</code>修改器，参见<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/kotlin-generics-variance-modifiers-36b82c7caa39">这篇文章</a>。<code class="fe ku kv kw kx b">Nothing</code>是此处所述<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/the-beauty-of-kotlin-typing-system-7a2804fe6cf0">所有类型的一个子类型。)</a></p><figure class="kz la lb lc gt ip"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8916" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">密封类非常适合表示和类型(范畴理论中的余积)——一组选择，就像最普通的一个:<code class="fe ku kv kw kx b">Either</code>，它有<code class="fe ku kv kw kx b">Left</code>或<code class="fe ku kv kw kx b">Right</code>，但不能两者都有。</p><figure class="kz la lb lc gt ip"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="e5b2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的应用程序中，当我们处理一组可选类时，我们使用密封类。例如，API告诉我们应该显示哪种广告:</p><figure class="kz la lb lc gt ip"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="65cf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，<code class="fe ku kv kw kx b">FacebookAd</code>和<code class="fe ku kv kw kx b">GoogleAd</code>都不保存数据，所以为了不在每次需要时都创建新的实例，我们对它们进行了对象声明并重用它们。密封类只能有对象声明子类，当以这种方式使用时，它非常类似于枚举:</p><figure class="kz la lb lc gt ip"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="32c0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然<strong class="jx iz">我们不这样使用密封类</strong>因为枚举更适合这种情况。</p><p id="53fd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相对于enum，密封类的优势在于子类可以保存特定于实例的数据。例如，当我们向应用程序的另一部分通知所选择的支付选项时，我们可以传递所选择的支付类型和特定于支付的数据，这些数据是后续处理所需要的。</p><figure class="kz la lb lc gt ip"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="7144" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">密封类的一个很好的例子是表示各种各样的事件或消息，因为我们既有事件是什么的信息，又有每个事件可以保存的数据。</p><h1 id="0bf0" class="ld le iy bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">摘要</h1><ul class=""><li id="1c6b" class="mn mo iy jx b jy mb kc mc kg mp kk mq ko mr ks ms mt mu mv bi translated">枚举类表示一组具体的值，而密封类表示一组具体的类。由于那些类可以是对象声明，我们可以在一定程度上使用密封类来代替枚举，但不能反过来。</li><li id="6ce1" class="mn mo iy jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">枚举类的优点是它们可以被序列化和反序列化。他们有方法<code class="fe ku kv kw kx b">values()</code>和<code class="fe ku kv kw kx b">valueOf</code>。我们还可以使用<code class="fe ku kv kw kx b">enumValues</code>和<code class="fe ku kv kw kx b">enumValueOf</code>函数按类型获取枚举值。枚举有序数，我们可以通过每一项来保存常量数据。它们非常适合表示一组恒定的可能值。</li><li id="1a79" class="mn mo iy jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">密封类的优点是它们可以保存特定于实例的数据。每个项目可以是一个类，也可以是一个对象(使用对象声明创建)。它们代表一组可选类(和类型、余积)。它们对定义替代项很有用，<code class="fe ku kv kw kx b">Result</code>要么是<code class="fe ku kv kw kx b">Success</code>要么是<code class="fe ku kv kw kx b">Failure</code>，<code class="fe ku kv kw kx b">Tree</code>要么是<code class="fe ku kv kw kx b">Leaf</code>要么是<code class="fe ku kv kw kx b">Node</code>，或者JSON值要么是列表、对象、字符串、布尔、int或null。它们对于定义一组可能发生的事件或消息也非常有用。</li></ul></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><h1 id="2fa9" class="ld le iy bd lf lg ni li lj lk nj lm ln lo nk lq lr ls nl lu lv lw nm ly lz ma bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="6cab" class="pw-post-body-paragraph jv jw iy jx b jy mb ka kb kc mc ke kf kg md ki kj kk me km kn ko mf kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kt" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kt" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><p id="f387" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您需要Kotlin工作室，请查看我们如何帮助您:<a class="ae kt" href="https://kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="kz la lb lc gt ip gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi mm"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>