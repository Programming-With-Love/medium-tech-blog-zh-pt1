<html>
<head>
<title>Google Santa Tracker — moving to an Android App Bundle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌圣诞老人追踪器——转向安卓应用捆绑包</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/google-santa-tracker-moving-to-an-android-app-bundle-dde180716096?source=collection_archive---------5-----------------------#2019-01-29">https://medium.com/androiddevelopers/google-santa-tracker-moving-to-an-android-app-bundle-dde180716096?source=collection_archive---------5-----------------------#2019-01-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/0604f47d3377165b28b1c53e64ab7cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ksxyyNT2V-A2N626DZ9D7A.png"/></div></div></figure><p id="4b52" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">本文是探索2018年谷歌圣诞老人追踪安卓应用改进的系列文章中的第一篇。</em></p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="c498" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">圣诞老人追踪器是谷歌每年发布的一款应用，允许用户在圣诞老人环游世界时追踪他。不幸的是，圣诞老人追踪器近年来规模急剧增长，导致2017年下载量高达60MB<strong class="ir hi">。我们最近假日季的目标是大幅减少这种情况，这篇文章讲述了我们是如何做到的。</strong></p><p id="665e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你使用过<a class="ae jv" href="https://play.google.com/store/apps/details?id=com.google.android.apps.santatracker" rel="noopener ugc nofollow" target="_blank">谷歌圣诞老人追踪器安卓应用</a>，你会知道它有两个主要功能,“追踪器”允许用户追踪圣诞老人在世界各地的旅程，以及一系列小游戏，可在整个12月玩，旨在帮助用户融入节日气氛🎄。</p><p id="dade" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">“追踪器”是这款应用的主要功能，也是我们使用最多的地方。该功能实际上只在圣诞节(12月24日)前的26小时*内可用，在此期间，追踪器是使用最多的功能。给你一个数字的概念，37%的屏幕浏览(12月)发生在12月24日，超过65%的屏幕浏览发生在当天。</p><p id="a0ff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么为什么这很重要呢？了解了我们的主要功能后，我们就可以思考应用程序的哪些部分在初始安装中是至关重要的，哪些部分是次要的，可以被拆分成独立的模块，这些模块可以动态安装，从而使我们的初始安装变得更小。2017年的应用程序是作为一个单一的APK发布的，它包含了一切，包括所有的游戏，即使用户没有玩它们。</p><p id="2b18" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们知道圣诞老人追踪者是时候节食了，所以我们设定了一个目标，将我们的初始下载大小缩小到仅仅10MB😥。</p><p id="05ad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你为什么问这个尺寸？事实证明，它的转化率比100MB大小的应用程序高30%。圣诞老人追踪器不是一个我们可以追踪转化率的应用程序，但是很多应用程序都可以。10MB也是一个很低的尝试和实现的目标，看看它是否可能。关于这背后的统计数据的更多信息，请阅读来自<a class="ae jv" href="https://medium.com/googleplaydev" rel="noopener"> Google Play团队</a>的文章:</p><div class="jw jx ez fb jy jz"><a rel="noopener follow" target="_blank" href="/googleplaydev/shrinking-apks-growing-installs-5d3fcba23ce2"><div class="ka ab dw"><div class="kb ab kc cl cj kd"><h2 class="bd hi fi z dy ke ea eb kf ed ef hg bi translated">缩减apk，增加安装</h2><div class="kg l"><h3 class="bd b fi z dy ke ea eb kf ed ef dx translated">你的应用的APK大小如何影响安装转化率</h3></div><div class="kh l"><p class="bd b fp z dy ke ea eb kf ed ef dx translated">medium.com</p></div></div><div class="ki l"><div class="kj l kk kl km ki kn in jz"/></div></div></a></div><h1 id="b701" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">动态交付</h1><p id="5f74" class="pw-post-body-paragraph ip iq hh ir b is lm iu iv iw ln iy iz ja lo jc jd je lp jg jh ji lq jk jl jm ha bi translated">你可能听说过新的<a class="ae jv" href="https://developer.android.com/platform/technology/app-bundle/" rel="noopener ugc nofollow" target="_blank"> Android应用捆绑</a>格式，它允许Google Play商店动态提供一个定制的应用，只包含与设备相关的部分。这对我们来说是容易的第一步。通过简单地上传AAB (Android应用捆绑包)而不是APK，我们立即设法将下载大小减少了近<strong class="ir hi"> 20% </strong>到<strong class="ir hi"> 48.5MB </strong>(从60MB)。对于我们不得不做的少量工作来说，这是一笔巨大的节省！</p><blockquote class="lr"><p id="47c5" class="ls lt hh bd lu lv lw lx ly lz ma jm dx translated">如果你从这篇文章中只学到一件事，那就是为你的应用上传一个AAB而不是APK。这个小小的改变很有可能会为你的用户节省时间和金钱。</p></blockquote><p id="d6f5" class="pw-post-body-paragraph ip iq hh ir b is mb iu iv iw mc iy iz ja md jc jd je me jg jh ji mf jk jl jm ha bi translated">那么Google Play是如何实现这种节约的呢？通过能够提供针对单个设备优化的内容，基础架构可以移除所有不适用于该设备的语言资源、密度资源和本地库。例如，如果您的设备设置为<code class="du mg mh mi mj b">fr-FR</code>，有一个<code class="du mg mh mi mj b">xxhdpi</code>显示屏，有一个<code class="du mg mh mi mj b">arm64-v8a</code> CPU，则交付的APK将只包括必要的资源，而不包括任何本地化为西班牙语的字符串。像本地化字符串这样的东西能占用多少空间，你会感到惊讶。</p><p id="abe3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请务必观看“<a class="ae jv" href="https://www.youtube.com/watch?v=QdoEcfibG-s" rel="noopener ugc nofollow" target="_blank">优化您的应用程序大小</a>”来自<a class="ae jv" href="https://developer.android.com/dev-summit/" rel="noopener ugc nofollow" target="_blank">Android Dev Summit’18</a>的演讲，了解更多信息:</p><figure class="mk ml mm mn fd ii"><div class="bz dy l di"><div class="mo mp l"/></div><figcaption class="mq mr et er es ms mt bd b be z dx">‘Optimize Your App Size’ talk from ADS ‘18</figcaption></figure><h1 id="7d36" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">功能模块</h1><p id="2668" class="pw-post-body-paragraph ip iq hh ir b is lm iu iv iw ln iy iz ja lo jc jd je lp jg jh ji lq jk jl jm ha bi translated">虽然我们有了一个良好的开端，但我们离10MB的目标还很远！因此，我们开始思考应用程序的哪些功能可以拆分为动态功能模块，在那里可以使用<a class="ae jv" href="https://developer.android.com/guide/app-bundle/playcore" rel="noopener ugc nofollow" target="_blank"> Play核心库</a>按需获取它们。幸运的是，我们的应用程序已经被逻辑地分成了很好的独立模块:游戏🎮。</p><p id="b117" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将每个游戏转换成一个独立的功能模块，并且仅在用户第一次选择玩该特定游戏时安装它们的计划。听起来很棒，对吧？虽然从逻辑上来说，游戏都是独立的，但代码库是… <em class="jn">而不是</em>。经过几年的发展，它已经变成了一堆错综复杂的相互依赖的模块，每样东西下面都是一层层的库模块，到处都是重复的资源。</p><p id="b727" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的第一项工作是修复游戏模块之间的紧密耦合并断言一些清晰的分离。我们使用新的<code class="du mg mh mi mj b">com.android.dynamic-feature</code> Gradle插件，煞费苦心地解开所有的游戏模块，使每个都是一个完全独立的模块。对于任何共享依赖关系的游戏(例如，“企鹅游泳”和“精灵喷射背包”游戏共享大量代码)，依赖关系被添加到“基础”模块中，这样它们将只安装一次。</p><h2 id="9ae3" class="mu kp hh bd kq mv mw mx ku my mz na ky ja nb nc lc je nd ne lg ji nf ng lk nh bi translated">实现功能模块</h2><p id="7ce5" class="pw-post-body-paragraph ip iq hh ir b is lm iu iv iw ln iy iz ja lo jc jd je lp jg jh ji lq jk jl jm ha bi translated">如上所述，转移到功能模块的大部分工作实际上是组织现有的代码，但仍然需要与<a class="ae jv" href="https://developer.android.com/guide/app-bundle/playcore" rel="noopener ugc nofollow" target="_blank"> Play核心库</a>进行一些集成，以便将它们连接起来。</p><p id="33a2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先让我们来讨论一下用户启动游戏时的UX。我们开始一个“闪屏”活动，显示游戏的标志和标题，然后在一段短暂的时间后，它启动游戏。关于要启动的游戏的所有信息都作为额外的意图传递给splash活动。这种行为在应用程序中已经持续了很多年，我们不想改变。然而，它为获取动态特性模块提供了一个非常好的集成点。</p><p id="85a1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在2018年，我们更新了splash行为，以便我们发送四个关键信息，游戏标题，游戏图标，要启动的活动类别，以及它所在的功能模块的ID。一旦显示了splash活动，它将检查是否安装了相关的功能模块。如果是，它只是正常启动游戏。如果没有，它会通过Play Core库请求安装，并显示一个进度条，指示正在进行的下载:</p><figure class="mk ml mm mn fd ii er es paragraph-image"><div class="er es ni"><img src="../Images/a78a1bf7d7f43cbf85ff1d36bd15fa18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*KPoBN-zNlJPVmjrIy8A8jQ.gif"/></div></figure><p id="1f1b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们在测试的早期就发现，您需要小心安装特性模块的条件。我们不希望用户在移动网络上安装功能模块时，无意中花费了他们的钱。为了解决这个问题，我们在检测到设备连接到计量网络(如移动网络)时添加了一个确认对话框:</p><figure class="mk ml mm mn fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nj"><img src="../Images/c6a28df9b3e407c21ff23b4d5b24832c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qCP_mHG0gr4eKJ0Md0H1A.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx">Confirmation dialog shown when the device is connected to a metered network</figcaption></figure><p id="1fb6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">其整体逻辑如下所示:</p><figure class="mk ml mm mn fd ii"><div class="bz dy l di"><div class="nk mp l"/></div></figure><p id="9156" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于Play核心API的工作方式，<code class="du mg mh mi mj b">startModuleInstall()</code>方法稍微复杂一些。您需要连接一个将在安装过程中调用的监听器，然后请求安装，如下所示:</p><figure class="mk ml mm mn fd ii"><div class="bz dy l di"><div class="nk mp l"/></div></figure><p id="b699" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">听众稍后会收到一个安装完成的信号，最后我们启动游戏。你可以在这里找到完整的代码<a class="ae jv" href="https://github.com/google/santa-tracker-android/tree/master/santa-tracker/src/main/java/com/google/android/apps/santatracker/games/SplashActivity.kt" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="41ca" class="ko kp hh bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结果</h1><p id="d4a4" class="pw-post-body-paragraph ip iq hh ir b is lm iu iv iw ln iy iz ja lo jc jd je lp jg jh ji lq jk jl jm ha bi translated">如果你已经读到这里，你可能想看看我们做得怎么样…</p><p id="7ef8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Android Studio有一个很好的方法来分析你的应用包(和apk)，深入查看每个功能模块的下载大小值。使用它，我们可以看到我们的初始下载大小是11.6MB(没有达到10MB的目标)，我们的总下载大小是25.5MB</p><figure class="mk ml mm mn fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nl"><img src="../Images/92bb695f49074e78001d899be2493509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z6BiUOLlfqpwx58ywfSsVw.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx"><em class="nm">* Download size calculated using Analyze Bundle feature in Android Studio</em></figcaption></figure><figure class="mk ml mm mn fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nn"><img src="../Images/af9580fc92ade84c5c6484fe108563fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aamb-oJ9fhE-7VPpvHh-bA.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx">Chart showing how the module sizes compare</figcaption></figure><p id="134a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是…这些值只是查看生成的Android应用捆绑包归档，并没有考虑Google Play通过动态交付(我们在上面讨论过)可以提供的任何节省。查看特定设备下载量的最可靠方法是查看Google Play开发者控制台。上传应用捆绑包后，您可以在“发布管理”- &gt;“工件库”下查看典型设备的交付尺寸:</p><figure class="mk ml mm mn fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es no"><img src="../Images/f194f2b69c61d63a7a0b1c67c456054b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yno3GA8adiZ14mVoxpwTVw.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx">And the survey says…</figcaption></figure><p id="f9a2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以看到我们达到了10MB的目标，下载量只有<strong class="ir hi"> 9.21MB </strong>！与2017年的应用程序相比，60MB，我们已经设法将大小减少了<strong class="ir hi"> 85% </strong>！🎉🎆</p><figure class="mk ml mm mn fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es np"><img src="../Images/a0520dcff1625faa54e13a5da62b0c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UT_XNkjswxZIyvLT2l-nyg.gif"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx">Actual footage from Santa HQ</figcaption></figure><h2 id="11ee" class="mu kp hh bd kq mv mw mx ku my mz na ky ja nb nc lc je nd ne lg ji nf ng lk nh bi translated">所有人的利益</h2><p id="2598" class="pw-post-body-paragraph ip iq hh ir b is lm iu iv iw ln iy iz ja lo jc jd je lp jg jh ji lq jk jl jm ha bi translated">希望这篇文章向你展示了迁移到应用捆绑包可以给你的用户带来巨大的好处。是的，拆分所有的模块是一项不小的工作，但是这项工作的好处也是实施良好的代码实践，比如内聚和去耦的模块。</p><p id="b5de" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对上面的数字有一点需要注意的是，它们还包含了我们使用的其他缩减规模技术的结果，包括资产压缩和转移到R8。我们将在下一篇博文中对此进行更多讨论。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="8057" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可能想知道为什么是26小时而不是24小时？这是因为国际日期变更线 <a class="ae jv" href="https://en.wikipedia.org/wiki/International_Date_Line#/media/File:International_Date_Line.png" rel="noopener ugc nofollow" target="_blank"> <em class="jn">不是直线</em> </a> <em class="jn">。基里巴斯的时区为</em><a class="ae jv" href="https://www.timeanddate.com/worldclock/difference.html?p1=274" rel="noopener ugc nofollow" target="_blank"><em class="jn">UTC+14</em></a><em class="jn">，这意味着与使用UTC-12的豪兰岛和贝克岛有26小时的时差。</em></p></div></div>    
</body>
</html>