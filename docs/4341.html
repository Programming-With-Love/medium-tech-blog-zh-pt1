<html>
<head>
<title>Considerations when creating Android libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建Android库时的注意事项</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/considerations-when-creating-android-libraries-c80940d79ae?source=collection_archive---------1-----------------------#2021-02-18">https://medium.com/google-developer-experts/considerations-when-creating-android-libraries-c80940d79ae?source=collection_archive---------1-----------------------#2021-02-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/4bd0a85317c4f737b82a0ec194bd50c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oNyt6MhfmOlWS84oWE8SOA.png"/></div></div></figure><div class=""/><p id="5d1e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你是一个Android开发者，你可能已经在开发你自己的Android库了。库是创建需要通过不同应用程序(甚至不同库)集成的可重用功能集的有用方式。</p><p id="3417" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">库是一个自包含的包，包括执行某些功能所需的代码和资源。在我们的Android应用程序中导入一个库的过程与在Java应用程序中导入一个. JAR文件的过程是一样的，除了Android的库文件具有扩展名。AAR，它为Android archive进行了扩展(但是，Android应用程序也可以导入扩展名为. JAR的库)。互联网上有关于如何创建Android库的详细指南，但在这篇文章中，我想集中讨论一些更主观的方面，而不是在每个指南中都有定义。我们今天将讨论以下几个方面:</p><ul class=""><li id="37ad" class="jn jo hs ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">记住公开的功能</li><li id="448e" class="jn jo hs ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Kotlin/Java交互</li><li id="f14a" class="jn jo hs ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">公开资源</li><li id="2db5" class="jn jo hs ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">传递依赖及其解决策略</li></ul><h1 id="fd52" class="kb kc hs bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">请记住哪些功能将被公开</h1><p id="d1f1" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">一个库很可能向用户提供一个接口来访问它的功能。不管特定的库是否封装了UX功能、某个面向API的接口……也会有一些与最终用户无关的类和方法，它们很可能会被公开。如何防止这种情况？</p><ul class=""><li id="9718" class="jn jo hs ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">正确使用可见性修饰符。如果你使用Java，倾向于优先使用默认修饰符<strong class="ir ht">包私有</strong>。如果您使用的是Kotlin，则向<a class="ae le" href="https://kotlinlang.org/docs/reference/visibility-modifiers.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">内部</strong> </a> <strong class="ir ht"> </strong>(这意味着它将对模块可见)。</li><li id="8085" class="jn jo hs ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">有时，包需要被传递性地公开。例如，考虑我们正在使用的库的以下设置:</li></ul><figure class="lg lh li lj fd hj er es paragraph-image"><div class="er es lf"><img src="../Images/fdd85262736a994dadd0f0916bdd52b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/1*uqxcKItR64dYVOHM-kWyvg.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">Library structure including a module using an internal model</figcaption></figure><p id="601b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">我的库</strong>对<strong class="ir ht">我的模块</strong>有依赖关系，我的模块是库使用的内部模块。我的库需要从模块中访问一些数据(比如说，一些内部模型)。我们需要将它们声明为公共的。但是，每个集成了库的类都将能够访问那些模型，这是相当不舒服的。</p><p id="4e4a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以将模型的包命名为internal(例如，<strong class="ir ht">my . package . internal . models</strong>)。这是一种常见的行业惯例，并且应该不鼓励使用这些类。例如，<a class="ae le" href="https://github.com/square/retrofit/search?q=internal" rel="noopener ugc nofollow" target="_blank">改型</a>或<a class="ae le" href="https://github.com/square/okhttp/search?q=internal" rel="noopener ugc nofollow" target="_blank"> OkHttp </a>对它们的内部类有相同的命名。</p><p id="0268" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为Kotlin 1.4有一个明确的API模式，它强制在一个短的库模式上操作。为了激活它，在你的Gradle文件上写下以下内容:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="eefb" class="lt kc hs lp b fi lu lv l lw lx">kotlin {    <br/>    // for strict mode     <br/>    explicitApi()     <br/>    // or   <br/>    explicitApi = <strong class="lp ht">'strict'</strong>     <br/> <br/>    // for warning mode    <br/>     explicitApiWarning()     <br/>    // or<br/>   explicitApi = <strong class="lp ht">'warning'</strong> <br/>}</span></pre><p id="6bc1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">设置相当简单:一种模式是严格模式并触发错误，不太严格的模式将触发警告。</p><p id="d509" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当显式API模式被激活时，如果默认的可见性意味着它们将是公共的，那么声明需要可见性修饰符。这将强制明确声明可见性。</p><h1 id="18ba" class="kb kc hs bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Kotlin/Java交互</h1><p id="924e" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">科特林对你来说应该不再是一个陌生的词了。这意味着你应该知道Kotlin和Java是如何相互作用的，并记住这一点以确保库可以被无缝调用。这意味着:您可能从Java代码库调用您的Kotlin库，或者从Kotlin代码库调用您的Java库。在这种情况下，你需要投入额外的精力来改善用户实现你的库的体验。</p><h2 id="8796" class="lt kc hs bd kd ly lz ma kh mb mc md kl ja me mf kp je mg mh kt ji mi mj kx mk bi translated">包装级功能</h2><p id="61b4" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">因为Java不允许类之外的独立函数，所以您在文件<strong class="ir ht"> file.kt </strong>中声明的所有独立函数或属性都将被编译为名为org.file.FileKt的类的静态方法:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="9786" class="lt kc hs lp b fi lu lv l lw lx">// file.kt<br/>package org.file</span><span id="d4f6" class="lt kc hs lp b fi ml lv l lw lx">class MyUtils</span><span id="5d77" class="lt kc hs lp b fi ml lv l lw lx">fun getLocale()</span></pre><p id="4930" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将在Java类中编译，如下所示:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="939e" class="lt kc hs lp b fi lu lv l lw lx">new org.file.MyUtils();<br/>org.file.AppKt.getLocale();</span></pre><p id="5714" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当然，让类自动命名是我们想要避免的事情。通过使用注释<code class="du mm mn mo lp b"><a class="ae le" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/index.html" rel="noopener ugc nofollow" target="_blank">@JvmName</a> </code>,我们可以指定目标类的名称:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">Using JvmName annotation</figcaption></figure><p id="0d47" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您还可以使用<code class="du mm mn mo lp b">file:JvmMultifileClass</code>将多个文件中的顶级成员合并到一个类中。</p><h2 id="c74b" class="lt kc hs bd kd ly lz ma kh mb mc md kl ja me mf kp je mg mh kt ji mi mj kx mk bi translated">实例字段</h2><p id="4c33" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">如果需要将Kotlin中的任何底层属性暴露给Java类，可以使用注释<code class="du mm mn mo lp b"><a class="ae le" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/index.html" rel="noopener ugc nofollow" target="_blank">@JvmField</a></code>。这将使您的Java类可以访问该属性。</p><h2 id="5f77" class="lt kc hs bd kd ly lz ma kh mb mc md kl ja me mf kp je mg mh kt ji mi mj kx mk bi translated">带有默认参数的函数</h2><p id="00ab" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">当在Kotlin中用默认参数定义一个函数时，在调用该函数时不需要连续传递这些参数。如果未指定，则采用默认值。</p><p id="572c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Java不支持默认参数，那么当我们在Java中调用这些函数时会发生什么呢？默认情况下，我们需要指定所有的参数，如果您在Kotlin中一直使用默认参数，这就不太好了。这就是我们可以使用<code class="du mm mn mo lp b">@JvmOverloads</code>的地方</p><p id="cb27" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们考虑Kotlin中的以下虚构函数:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">Using JvmOverloads annotation</figcaption></figure><p id="a32a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个函数使用了注释<code class="du mm mn mo lp b">@JvmOverloads,</code>，它也有两个默认参数作为参数。从Java的角度来看，这个函数将编译如下:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">How the function compiles in Java when using JvmOverloads</figcaption></figure><p id="fc1f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们处理使用一些默认参数的长构造函数时，优势是显而易见的，我们不需要在Java类中再次指定。</p><h2 id="b34b" class="lt kc hs bd kd ly lz ma kh mb mc md kl ja me mf kp je mg mh kt ji mi mj kx mk bi translated">Kotlin中没有泛型</h2><p id="3c4f" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">带有泛型参数<code class="du mm mn mo lp b">Nothing</code>的Kotlin类型在Java中被公开为原始类型。应该避免这种情况，因为Java中很少使用原始类型。</p><h2 id="c89a" class="lt kc hs bd kd ly lz ma kh mb mc md kl ja me mf kp je mg mh kt ji mi mj kx mk bi translated">伴随函数和常数</h2><p id="dc9a" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">当从Java中编译和访问伴随函数和常量时，它们只能作为静态伴随字段上的实例方法。例如，下面的Kotlin类:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="8f4f" class="lt kc hs lp b fi lu lv l lw lx">class KotlinClass {<br/>    companion object {<br/>        fun function() {</span><span id="9b7a" class="lt kc hs lp b fi ml lv l lw lx">        }<br/>    }<br/>}</span></pre><p id="0498" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Java中公开如下:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="82f2" class="lt kc hs lp b fi lu lv l lw lx">public final class JavaClass {<br/>    public static void main(String... args) {<br/>        KotlinClass.Companion.function();<br/>    }<br/>}</span></pre><p id="24a1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对函数使用<code class="du mm mn mo lp b">@JvmStatic</code>注释会使编译后的代码更加整洁:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="6b13" class="lt kc hs lp b fi lu lv l lw lx">public final class JavaClass {<br/>    public static void main(String... args) {<br/>        KotlinClass.function();<br/>    }<br/>}</span></pre><p id="b659" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于伴随常数，最好使用注释<code class="du mm mn mo lp b">@JvmField</code>，因为<code class="du mm mn mo lp b">@JvmStatic</code>创建了一个奇怪的getter。例如，考虑下面的伴随常数:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="fa96" class="lt kc hs lp b fi lu lv l lw lx">class KotlinClass {<br/>    companion object {<br/>        const val PI = 3.14<br/>    }<br/>}</span></pre><p id="b30b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用<code class="du mm mn mo lp b">@JvmField</code>注释伴随值将再次产生更加全面的Java代码:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="15c7" class="lt kc hs lp b fi lu lv l lw lx">public final class JavaClass {<br/>    public static void main(String... args) {<br/>        System.out.println(KotlinClass.PI);<br/>    }<br/>}</span></pre><h1 id="e7f4" class="kb kc hs bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">公开资源</h1><p id="21a2" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">一些人没有意识到的是，默认情况下，Android库中的所有资源都是公开的！这意味着包含在你的<strong class="ir ht"> res </strong>文件夹中的所有东西(图片、可绘制的图片、字符串……)。这在某种程度上是一种令人费解且违反直觉的方法，但是为了使您的所有资源都是私有的，您应该至少将一个资源定义为公共的。</p><p id="7a53" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个好的做法是只公开指定库名的字符串。当你开始开发你的应用程序时，这样做，你将不必再担心你的资源的外部可见性(也就是说，除非你真的想把它们公开)。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="mp mq l"/></div><figcaption class="lk ll et er es lm ln bd b be z dx">Exposing resources via XML</figcaption></figure><h1 id="75fa" class="kb kc hs bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">注意传递依赖</strong></h1><p id="84b8" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">库可能依赖于外部依赖项，理想情况下，您希望在同一个. AAR中交付所有的库。否则，用户将需要手动包含它们，这很难处理。</p><p id="f7a2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一方面，我们可能会强迫用户包含某些库，这些库可能会与他们应用程序级别包含的库相冲突。</p><p id="5e76" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里没有灵丹妙药，有几个策略可以解决这个问题。</p><h2 id="c9a9" class="lt kc hs bd kd ly lz ma kh mb mc md kl ja me mf kp je mg mh kt ji mi mj kx mk bi translated">包括所有可传递的依赖关系</h2><p id="cd10" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">A.可以生成AAR文件，包括它需要的所有依赖项。这不是由自动完成的。AAR文件，需要被黑掉。</p><p id="0d1b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以添加并调用一个Gradle任务，将所有依赖项复制到。AAR包装时:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="dc58" class="lt kc hs lp b fi lu lv l lw lx">task copyLibs(type: Copy) {<br/>    from configurations.compile<br/>    into 'libs'<br/>}</span></pre><p id="adbf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有一个促进插件，<a class="ae le" href="https://github.com/kezong/fat-aar-android" rel="noopener ugc nofollow" target="_blank"> fat-aar </a>，可以改善这个任务。它做了更多的事情，但我发现它有点不稳定(当我不得不发布一个新的库版本时，一个新的Gradle版本也可用，它通常会破坏插件)。</p><h2 id="2a01" class="lt kc hs bd kd ly lz ma kh mb mc md kl ja me mf kp je mg mh kt ji mi mj kx mk bi translated">强制或移除依赖性的策略</h2><p id="7e50" class="pw-post-body-paragraph ip iq hs ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">也被称为地狱。假设你的主应用包含一个2.1版本的随机库。该应用程序需要包括你的<strong class="ir ht"> FancyLibrary </strong>，其中包括<strong class="ir ht"> RandomLibrary </strong>的3.1版本，有很多突破性的变化。您可能需要强制解析特定版本，或者从构建中移除一些库。在高度模块化的项目中，这会成倍增加构建脚本的复杂性。</p><p id="1d97" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下Gradle行将库从构建中排除:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="7b6f" class="lt kc hs lp b fi lu lv l lw lx">implementation('com.package.fancylibrary:1.0.0') {<br/>  exclude group: 'com.package.randomlibrary', module: 'randommodule'<br/>}</span></pre><p id="1e5e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">总结</strong></p><p id="1689" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">设计和编写一个库不仅仅是打包几个类。理想情况下，需要在设计阶段考虑结构和类的组织。你的公司结构也会严重影响这一点(你有不同的团队在不同的模块上工作吗？你有开放存储库政策吗？使用外部库有什么限制吗？政治对你的开发工作有多大影响？)</p><p id="28f3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">感谢<a class="mr ms ge" href="https://medium.com/u/d5885adb1ddf?source=post_page-----c80940d79ae--------------------------------" rel="noopener" target="_blank">弗洛里纳·蒙特内斯库</a>、<a class="mr ms ge" href="https://medium.com/u/ec2087b3c81f?source=post_page-----c80940d79ae--------------------------------" rel="noopener" target="_blank">马顿·布劳恩</a>和<a class="mr ms ge" href="https://medium.com/u/a8c7d12ff9c1?source=post_page-----c80940d79ae--------------------------------" rel="noopener" target="_blank">马里乌斯·巴丁</a>的点评，摇滚吧。</p><p id="162f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在我的推特账户上写下我对软件工程和生活的想法。如果你喜欢这篇文章或者它对你有帮助，请随意分享，👏和/或发表评论。这是给业余作家加油的货币。</p></div></div>    
</body>
</html>