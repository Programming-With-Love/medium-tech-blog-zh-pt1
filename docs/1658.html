<html>
<head>
<title>Slaying the UI AngularJS Monolith Using Micro Frontends Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用微前端架构杀死UI AngularJS Monolith</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/slaying-the-ui-angularjs-monolith-using-a-micro-frontend-architecture-f6c6332652d3?source=collection_archive---------2-----------------------#2019-03-12">https://medium.com/capital-one-tech/slaying-the-ui-angularjs-monolith-using-a-micro-frontend-architecture-f6c6332652d3?source=collection_archive---------2-----------------------#2019-03-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="e036" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><em class="iw">一种框架不可知的模块化UI架构的微前端方法</em></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/1b0fecfd0e24e8f8fb5e267f931d74d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5xt0JQ4M5Xa5qT7moVXG0g.gif"/></div></div></figure><blockquote class="jj"><p id="4209" class="jk jl hh bd jm jn jo jp jq jr js jt dx translated">快速变化的web开发世界的简短旅程…</p></blockquote><p id="ce42" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc kd ke kf kg kh ki kj kk kl km kn ko jt ha bi translated">在过去的十年里，AngularJS已经成为“街区的新成员”，取代了基于jQuery的web工程解决方案的许多弱点。许多企业非常乐意用AngularJS构建他们的前沿门户网站，随着网络业务的指数级增长，AngularJS让许多开发人员的生活变得更加轻松。</p><p id="db6e" class="pw-post-body-paragraph ju jv hh jw b jx kp ii jz ka kq il kc kd kr kf kg kh ks kj kk kl kt kn ko jt ha bi translated">在web开发世界里，每个人都很快乐，但是这种快乐并没有持续很久。</p><p id="15bf" class="pw-post-body-paragraph ju jv hh jw b jx kp ii jz ka kq il kc kd kr kf kg kh ks kj kk kl kt kn ko jt ha bi translated"><em class="ku">(注:在本博客中，AngularJS将被称为AngularJS，Angular 2及以上将被称为Angular。Angular在代码可重用性、性能、代码组织、模块性、结构、进化的依赖管理等方面比AngularJS领先了一大步。简而言之，Angular的基于组件的架构和可取消的异步操作支持，改变了底层结构，需要相当长的学习曲线才能升级到)</em></p><p id="13d6" class="pw-post-body-paragraph ju jv hh jw b jx kp ii jz ka kq il kc kd kr kf kg kh ks kj kk kl kt kn ko jt ha bi translated">更新的、更具破坏性的前端框架开始接管web开发世界，将AngularJS投入到被视为阻碍业务发展的遗留软件堆中。但是替换AngularJS不是一件容易的事情。随着更快的增长，基于AngularJS的项目的复杂性也增加了，大型企业代码库通常跨越多个团队。</p><p id="a9df" class="pw-post-body-paragraph ju jv hh jw b jx kp ii jz ka kq il kc kd kr kf kg kh ks kj kk kl kt kn ko jt ha bi translated">结果是一个巨大的整体AngularJS怪兽伪装成前端应用程序，不缺乏性能和部署瓶颈。在像这样的单一应用程序可能导致的几个缺点中，企业面临的一些主要挑战是:</p><ul class=""><li id="4677" class="kv kw hh jw b jx kp ka kq kd kx kh ky kl kz jt la lb lc ld bi translated"><strong class="jw hi">跟不上业务增长的技术架构:</strong>随着应用程序的增长，团队需要支持的功能也在增长。多个团队共同开发一个单一的应用程序，开发和发布协调是一场噩梦。</li><li id="71d3" class="kv kw hh jw b jx le ka lf kd lg kh lh kl li jt la lb lc ld bi translated"><strong class="jw hi">创新受阻:【Angular 2、React、Vue等更新的框架和库在前端领域提供了可观的性能改进和创新。然而，升级单一应用程序和/或使其与这些新框架和库互操作的繁重任务通常无法在不损害以现有发布速度发布新功能的情况下完成。</strong></li><li id="03af" class="kv kw hh jw b jx le ka lf kd lg kh lh kl li jt la lb lc ld bi translated"><strong class="jw hi">吸引和留住顶尖人才:</strong>谁愿意在一个过时的框架中工作，因为这种框架被视为削弱了一个人的市场技能？因此，当工程团队被迫解决对他们的技术技能没有太大价值的问题时，员工的积极性会受到打击，导致员工流失。</li></ul><p id="3f20" class="pw-post-body-paragraph ju jv hh jw b jx kp ii jz ka kq il kc kd kr kf kg kh ks kj kk kl kt kn ko jt ha bi translated">克服所有这些挑战的一个可行的解决方案是迁移到称为<a class="ae lj" href="https://micro-frontends.org/" rel="noopener ugc nofollow" target="_blank">微前端</a>的模块化前端架构风格。通过这种架构，人们可以帮助<em class="ku">应对</em>不断变化的网络技术格局带来的中断和风险，同时在利用这些技术方面保持领先。</p><blockquote class="jj"><p id="81fb" class="jk jl hh bd jm jn lk ll lm ln lo jt dx translated"><em class="iw">简单来说，微前端相当于前端世界的微服务。</em></p></blockquote><figure class="lq lr ls lt lu jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lp"><img src="../Images/70855960986b60563e557d1747ba46a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FOzcfo-P-GvUHASb-hwIA.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Figure 1: Application Development Journey</figcaption></figure><h1 id="111d" class="lz ma hh bd mb mc md me mf mg mh mi mj in mk io ml iq mm ir mn it mo iu mp mq bi translated">微前端方法</h1><p id="5a86" class="pw-post-body-paragraph ju jv hh jw b jx mr ii jz ka ms il kc kd mt kf kg kh mu kj kk kl mv kn ko jt ha bi translated">微前端方法将加载到浏览器中的前端代码分成多个独立的web应用程序。这些能够由不同的团队管理，并允许框架不可知论(应用和功能在Vue、Angular、React中构建)。</p><p id="a1ad" class="pw-post-body-paragraph ju jv hh jw b jx kp ii jz ka kq il kc kd kr kf kg kh ks kj kk kl kt kn ko jt ha bi translated">图2说明了单页面应用程序的框架无关的微前端架构。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mw"><img src="../Images/2a2127cd5cab67133b50816387b9d9c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xX06VTe26V42qE9y6Ooj-Q.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Figure 2: Micro Frontend Architecture</figcaption></figure><h1 id="a541" class="lz ma hh bd mb mc md me mf mg mh mi mj in mk io ml iq mm ir mn it mo iu mp mq bi translated">微前端架构的优势</h1><p id="31b6" class="pw-post-body-paragraph ju jv hh jw b jx mr ii jz ka ms il kc kd mt kf kg kh mu kj kk kl mv kn ko jt ha bi translated">微前端架构相对于整体架构的主要优势在于:</p><ul class=""><li id="105b" class="kv kw hh jw b jx kp ka kq kd kx kh ky kl kz jt la lb lc ld bi translated"><strong class="jw hi">给予团队他们的发布自主权和时间回溯</strong>:通过将功能从整体分割成独立的微前端，团队在发布产品/功能时享有更大的自主权和灵活性。不发布的团队不再需要熬夜参加发布电话会议，试图回归测试其他团队在产品中的变化。真是如释重负，对吧！</li><li id="5d12" class="kv kw hh jw b jx le ka lf kd lg kh lh kl li jt la lb lc ld bi translated"><strong class="jw hi">让工程师开心</strong>:不必依赖整个代码库，减少了依赖性和范围，使团队能够快速参与和交付。这为花费在创新上的时间创造了空间，而不用担心破坏其他团队的功能</li><li id="dede" class="kv kw hh jw b jx le ka lf kd lg kh lh kl li jt la lb lc ld bi translated"><strong class="jw hi">产生一个可扩展的、性能更好的web应用</strong>:一个具有既定全球标准的松散耦合架构使得在需要时添加新功能或组建团队变得更加容易。由于每个应用都被分割成自己的微前端，如果企业应用上的单个功能(一个微前端)加载速度不快，也不会影响整个应用的性能。它还使得网页的某些部分可以更快地加载，允许用户在加载或需要所有功能之前与页面进行交互。</li></ul><h1 id="1e63" class="lz ma hh bd mb mc md me mf mg mh mi mj in mk io ml iq mm ir mn it mo iu mp mq bi translated">微前端架构面临的挑战</h1><p id="a442" class="pw-post-body-paragraph ju jv hh jw b jx mr ii jz ka ms il kc kd mt kf kg kh mu kj kk kl mv kn ko jt ha bi translated">正如所有好事都伴随着挑战一样，实现微前端架构也面临着一些挑战:</p><ul class=""><li id="601f" class="kv kw hh jw b jx kp ka kq kd kx kh ky kl kz jt la lb lc ld bi translated"><strong class="jw hi">部署策略:</strong>一个主要的实施考虑是决定是否应该使用大爆炸或分阶段的方法将他们的单片应用程序转换为微前端。</li><li id="80e6" class="kv kw hh jw b jx le ka lf kd lg kh lh kl li jt la lb lc ld bi translated"><strong class="jw hi">有效的测试策略</strong>:虽然monolith创建了一个所有团队都参与的发布方法，但是微前端只允许有贡献的团队参与给定的发布。这种方法要求团队实现同类最佳的回归测试实践，以确保不将损坏的特性发布给客户。</li><li id="640b" class="kv kw hh jw b jx le ka lf kd lg kh lh kl li jt la lb lc ld bi translated"><strong class="jw hi">为升级准备遗留应用程序:</strong>一个现有的整体应用程序可能是在一个近乎过时的框架上(比如AngularJS 1.3)。可能需要大量的工作和时间来使其做好升级准备，为此应用程序应该至少是Angular 2及以上。</li><li id="d839" class="kv kw hh jw b jx le ka lf kd lg kh lh kl li jt la lb lc ld bi translated"><strong class="jw hi">治理:</strong>在组织和技术策略方面，组织中的团队可能被拉向多个方向，从而导致糟糕的变更管理。</li><li id="6956" class="kv kw hh jw b jx le ka lf kd lg kh lh kl li jt la lb lc ld bi translated"><strong class="jw hi">遗留前端框架:</strong>随着框架和更新的库以指数速度发布，在框架之间创建可互操作的UI组件的能力需要构建可重用的基础元素。这也很耗时。</li><li id="a0c4" class="kv kw hh jw b jx le ka lf kd lg kh lh kl li jt la lb lc ld bi translated"><strong class="jw hi">上市速度与优化的技术:</strong>持续的业务增长需要催生新的应用程序，与monolith共存或在monolith内部共存。在这种情况下，需要不断努力平衡市场速度和优化技术。</li></ul><h1 id="3fa3" class="lz ma hh bd mb mc md me mf mg mh mi mj in mk io ml iq mm ir mn it mo iu mp mq bi translated">使当前代码升级友好的注意事项</h1><p id="b4c1" class="pw-post-body-paragraph ju jv hh jw b jx mr ii jz ka ms il kc kd mt kf kg kh mu kj kk kl mv kn ko jt ha bi translated">开始升级之旅的第一步是让您现有的AngularJS代码准备好升级到Angular。下面描述了准备正在进行的AngularJS开发的方法，只需要最少的重构。</p><ul class=""><li id="4acf" class="kv kw hh jw b jx kp ka kq kd kx kh ky kl kz jt la lb lc ld bi translated">将您的项目从传统的模型-视图-控制器架构转移到基于组件的架构。自包含指令中的每个视图。</li><li id="3ab5" class="kv kw hh jw b jx le ka lf kd lg kh lh kl li jt la lb lc ld bi translated">用restrict: <code class="du mx my mz na b">E</code>，一个隔离范围和controllerAs: <code class="du mx my mz na b">$ctrl</code>配置您的指令。这将使您的指令更容易转换成角度分量语法。</li><li id="9ac4" class="kv kw hh jw b jx le ka lf kd lg kh lh kl li jt la lb lc ld bi translated">尝试将常用功能提取到服务中，而不是放在控制器中。减少工厂的使用，而是将您的服务定义为Typescript类中的服务。</li></ul><h1 id="0444" class="lz ma hh bd mb mc md me mf mg mh mi mj in mk io ml iq mm ir mn it mo iu mp mq bi translated">更新旧应用程序</h1><p id="f277" class="pw-post-body-paragraph ju jv hh jw b jx mr ii jz ka ms il kc kd mt kf kg kh mu kj kk kl mv kn ko jt ha bi translated">您当前的旧版应用程序可能是以下版本之一。如果是这样的话，迁移到微前端架构的路径可以采用下面的一个或多个路径。</p><h2 id="889d" class="nb ma hh bd mb nc nd ne mf nf ng nh mj kd ni nj ml kh nk nl mn kl nm nn mp no bi translated">版本早于1.5</h2><p id="21b5" class="pw-post-body-paragraph ju jv hh jw b jx mr ii jz ka ms il kc kd mt kf kg kh mu kj kk kl mv kn ko jt ha bi translated">假设您已经有了一个遗留的AngularJS应用程序。您可以从Angular 2和更高版本开始构建组件，使其与现有的AngularJS应用程序互操作，以便您当前的功能在升级到微前端完成时不会暂停。</p><p id="e573" class="pw-post-body-paragraph ju jv hh jw b jx kp ii jz ka kq il kc kd kr kf kg kh ks kj kk kl kt kn ko jt ha bi translated">怎么会？简单。Angular开发了UpgradeModule，提供升级和降级提供程序来帮助实现这一点。您可以在AngularJS应用程序中引导Angular应用程序，并将两个代码库放在一个存储库中，让组件可以互操作。注意——请关注下一篇关于如何做到这一点的博客！</p><p id="861f" class="pw-post-body-paragraph ju jv hh jw b jx kp ii jz ka kq il kc kd kr kf kg kh ks kj kk kl kt kn ko jt ha bi translated">通过这种方式，您可以在AngularJS应用程序中一次删除一个功能/模块，同时在Angular 2或更高版本中构建更新的组件。当您最终将所有AngularJS组件升级到Angular时，可以将代码提取到它自己的存储库中，使用Angular元素制作成一个微前端。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es np"><img src="../Images/a430a1fc4bad80c11d4d61684697f1c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9QdWglET4Amatjt_R8mB6A.png"/></div></div><figcaption class="lv lw et er es lx ly bd b be z dx">Figure 3: Demonstrating an incremental approach to moving from monolith to micro frontends implementation</figcaption></figure><h2 id="81da" class="nb ma hh bd mb nc nd ne mf nf ng nh mj kd ni nj ml kh nk nl mn kl nm nn mp no bi translated">版本介于1.5和2之间</h2><p id="bf4f" class="pw-post-body-paragraph ju jv hh jw b jx mr ii jz ka ms il kc kd mt kf kg kh mu kj kk kl mv kn ko jt ha bi translated">如果您认为您的大多数AngularJS指令和服务已经是升级友好的，那么另一个极好的策略是本文中详述的<a class="ae lj" href="https://single-spa.js.org/" rel="noopener ugc nofollow" target="_blank">单spa方法</a>。单一spa方法创建了一个适配器，使应用程序能够互操作，并能够在彼此之间路由。这种策略最适合用大爆炸的方法将整块石头分割成微小的前端。它需要重构您现有的整体父AngularJS应用程序，使其升级友好，然后才能删除功能以创建微前端。考虑到单片应用程序复杂性的多样性，人们可能要花相当多的时间来变得易于升级。</p><h2 id="100b" class="nb ma hh bd mb nc nd ne mf nf ng nh mj kd ni nj ml kh nk nl mn kl nm nn mp no bi translated">年轻版2 (Angular 2及以上)</h2><p id="06c2" class="pw-post-body-paragraph ju jv hh jw b jx mr ii jz ka ms il kc kd mt kf kg kh mu kj kk kl mv kn ko jt ha bi translated">如果您已经完成了将应用程序从AngularJS升级到Angular 2的惊人壮举，那么恭喜您！给自己一个鼓励，因为实现框架不可知的微前端的大部分基础工作(有些人可能称之为繁重的工作)已经完成了。虽然有多种方法来实现微前端——单SPA元框架，多个SPA舒适地驻留在不同的URL，通过iFrames隔离的微前端，与Angular 6一起发布的Angular元素，但我认为这是实现框架无关的微前端的最有效和最干净的方法。</p><p id="86e0" class="pw-post-body-paragraph ju jv hh jw b jx kp ii jz ka kq il kc kd kr kf kg kh ks kj kk kl kt kn ko jt ha bi translated"><em class="ku">在我的下一篇博客中，我将介绍每种方法的优缺点，以及一个示例实现——敬请期待！</em></p><h1 id="db6d" class="lz ma hh bd mb mc md me mf mg mh mi mj in mk io ml iq mm ir mn it mo iu mp mq bi translated">结论</h1><p id="e09f" class="pw-post-body-paragraph ju jv hh jw b jx mr ii jz ka ms il kc kd mt kf kg kh mu kj kk kl mv kn ko jt ha bi translated">杀死这个庞然大物可不是在公园里散步，快速发展的网络技术领域加剧了这一事实。在本文中，我们详细介绍了所面临的挑战，以及使这种步行(更确切地说，是铁人三项)变得更容易的技巧和策略。终点线是一个微前端架构，它使你能够正面处理破坏性的web技术或框架。希望这篇文章能帮你达到！</p></div><div class="ab cl nq nr go ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ha hb hc hd he"><p id="6f69" class="pw-post-body-paragraph ju jv hh jw b jx kp ii jz ka kq il kc kd kr kf kg kh ks kj kk kl kt kn ko jt ha bi translated"><em class="ku">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2019首都一。</em></p></div></div>    
</body>
</html>