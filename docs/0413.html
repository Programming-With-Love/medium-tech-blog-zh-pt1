<html>
<head>
<title>Dagger in Kotlin: gotchas and Optimizations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin的匕首:陷阱和优化</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/dagger-in-kotlin-gotchas-and-optimizations-7446d8dfd7dc?source=collection_archive---------1-----------------------#2019-07-30">https://medium.com/androiddevelopers/dagger-in-kotlin-gotchas-and-optimizations-7446d8dfd7dc?source=collection_archive---------1-----------------------#2019-07-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c61db2768a4f123bc454778bbce7005a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTtrehfbA7rzps4mPSNM8A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Illustration by <a class="ae it" href="https://twitter.com/vpoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><p id="0fdb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" href="https://dagger.dev/" rel="noopener ugc nofollow" target="_blank"> Dagger </a>是Android中常用的一个流行的依赖注入框架。它提供了完全静态和编译时的依赖，解决了许多基于反射的解决方案的开发和性能问题。</p><p id="cbfe" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个月，一个新的<a class="ae it" href="https://dagger.dev/tutorial/" rel="noopener ugc nofollow" target="_blank">教程</a>发布了，以帮助你更好地理解它是如何工作的。本文重点介绍如何将<strong class="iw hi"> Dagger与Kotlin </strong>结合使用，包括优化构建时间的<strong class="iw hi">最佳实践</strong>以及您可能遇到的<strong class="iw hi">陷阱</strong>。</p><p id="7cb8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Dagger是使用Java的注释模型实现的，Kotlin中的注释并不总是与如何编写等价的Java代码直接并行。这篇文章将重点介绍它们的不同之处，以及如何在Kotlin上使用Dagger而不会头痛。</p><p id="824b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这篇文章的灵感来自于这个<a class="ae it" href="https://github.com/google/dagger/issues/900" rel="noopener ugc nofollow" target="_blank"> Dagger问题</a>中的一些建议，这个问题讨论了Kotlin中Dagger的最佳实践和痛点。感谢所有在那里发表评论的贡献者！</p><h1 id="7adb" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">kapt构建改进</h1><p id="00ee" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">为了改善你的构建时间，Dagger在<a class="ae it" href="https://github.com/google/dagger/releases/tag/dagger-2.18" rel="noopener ugc nofollow" target="_blank"> v2.18 </a>中增加了对<strong class="iw hi"> gradle的增量注释处理</strong>的支持！这在Dagger <a class="ae it" href="https://github.com/google/dagger/releases/tag/dagger-2.24" rel="noopener ugc nofollow" target="_blank"> v2.24 </a>中默认启用。如果您正在使用一个较低的版本，如果您想从中受益，您需要添加几行代码(如下所示)。</p><p id="df66" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另外，您可以告诉Dagger不要格式化生成的代码。这个选项是在Dagger <a class="ae it" href="https://github.com/google/dagger/releases/tag/dagger-2.18" rel="noopener ugc nofollow" target="_blank"> v2.18 </a>中添加的，它是<a class="ae it" href="https://github.com/google/dagger/releases/tag/dagger-2.23" rel="noopener ugc nofollow" target="_blank"> v2.23 </a>中的默认行为(不生成格式化代码)。如果您使用的是较低版本，请禁用代码格式以缩短构建时间(参见下面的代码)。</p><p id="ba3b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在您的<code class="du kv kw kx ky b">build.gradle</code>文件中包含这些编译器参数，以使Dagger在构建时更有性能:</p><figure class="kz la lb lc fd ii"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="cc7d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">或者，如果您使用Kotlin DSL脚本文件，将它们包含在使用Dagger的模块的<code class="du kv kw kx ky b">build.gradle.kts</code>文件中，如下所示:</p><figure class="kz la lb lc fd ii"><div class="bz dy l di"><div class="ld le l"/></div></figure><h1 id="6a93" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">字段属性的限定符</h1><p id="febe" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">当在Kotlin的属性上放置注释时，不清楚Java是否会在属性的<em class="lf">字段</em>或属性的<em class="lf">方法</em>上看到注释。在注释上设置前缀<code class="du kv kw kx ky b">field:</code>确保限定符在正确的位置结束(<a class="ae it" href="https://kotlinlang.org/docs/reference/annotations.html#annotation-use-site-targets" rel="noopener ugc nofollow" target="_blank">更多细节见文档</a>)。</p><p id="02f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">✅对注入字段应用限定符的方法是:</p><pre class="kz la lb lc fd lg ky lh li aw lj bi"><span id="b81d" class="lk jt hh ky b fi ll lm l ln lo">@Inject <strong class="ky hi">@field:MinimumBalance</strong> lateinit var minimumBalance: BigDecimal</span></pre><p id="5b53" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">❌反对:</p><pre class="kz la lb lc fd lg ky lh li aw lj bi"><span id="ba80" class="lk jt hh ky b fi ll lm l ln lo">@Inject @MinimumBalance lateinit var minimumBalance: BigDecimal <br/><strong class="ky hi">// @MinimumBalance is ignored!</strong></span></pre><p id="7d6c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果Dagger图中存在该类型的不合格实例，忘记添加<code class="du kv kw kx ky b">field:</code>可能会导致注入错误的对象。</p><p id="d9f3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">10/28/19</strong>更新:这个问题在Dagger v2.25中得到修复。如果你使用这个版本，你可以只键入以前不起作用的内容:</p><pre class="kz la lb lc fd lg ky lh li aw lj bi"><span id="75ab" class="lk jt hh ky b fi ll lm l ln lo">@Inject @MinimumBalance lateinit var minimumBalance: BigDecimal <br/><strong class="ky hi">// FIXED: @MinimumBalance is NOT ignored!</strong></span></pre><h1 id="6cef" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Static @提供函数优化</h1><p id="e60f" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">如果<code class="du kv kw kx ky b">@Provides</code>方法是<code class="du kv kw kx ky b">static</code>，Dagger生成的代码会更有性能。为了在Kotlin中实现这一点，使用Kotlin <code class="du kv kw kx ky b">object</code>而不是<code class="du kv kw kx ky b">class</code>，并用<code class="du kv kw kx ky b">@JvmStatic</code>注释您的方法。这是一个<strong class="iw hi"> <em class="lf">最佳实践</em> </strong>，你应该尽可能地遵循。</p><figure class="kz la lb lc fd ii"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="ce28" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您需要一个抽象方法，您需要将<code class="du kv kw kx ky b">@JvmStatic</code>方法添加到一个伴随对象中，并用<code class="du kv kw kx ky b">@Module</code>对其进行注释。</p><figure class="kz la lb lc fd ii"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="64b8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">或者，您可以将目标模块提取出来，并将其包含在抽象模块中:</p><figure class="kz la lb lc fd ii"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="7781" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">更新10/28/19 </strong>:有了Dagger v2.25.2，就不需要用<code class="du kv kw kx ky b">@JvmStatic</code>标记<code class="du kv kw kx ky b">@Provides</code>函数了。匕首会正确理解的。</p><h1 id="1e38" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">注入仿制药</h1><p id="c514" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">Kotlin编译带有通配符的泛型，以使Kotlin APIs与Java一起工作。当一个类型作为参数(<a class="ae it" href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#variant-generics" rel="noopener ugc nofollow" target="_blank">更多信息在这里</a>)或作为字段出现时，就会产生这些。例如，一个Kotlin <code class="du kv kw kx ky b">List&lt;Foo&gt;</code>参数在Java中显示为<code class="du kv kw kx ky b">List&lt;? super Foo&gt;</code>。</p><p id="4a44" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这导致了Dagger的问题，因为它期望精确的(又名<a class="ae it" href="https://en.wikipedia.org/wiki/Class_invariant" rel="noopener ugc nofollow" target="_blank">不变的</a>)类型匹配。使用<code class="du kv kw kx ky b">@<a class="ae it" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-suppress-wildcards/index.html" rel="noopener ugc nofollow" target="_blank">JvmSuppressWildcards</a></code>将确保Dagger看到没有通配符的类型。</p><p id="2d89" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您使用<a class="ae it" href="https://dagger.dev/multibindings.html" rel="noopener ugc nofollow" target="_blank"> Dagger的多绑定特性</a>注入集合时，这是一个常见的问题，例如:</p><pre class="kz la lb lc fd lg ky lh li aw lj bi"><span id="1478" class="lk jt hh ky b fi ll lm l ln lo">class MyVMFactory @Inject constructor(<br/>  private val vmMap: Map&lt;String, <strong class="ky hi">@JvmSuppressWildcards</strong> Provider&lt;ViewModel&gt;&gt;<br/>) { <br/>    ... <br/>}</span></pre><h1 id="ff64" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">内联方法体</h1><p id="4b60" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">Dagger通过检查返回类型来确定由<code class="du kv kw kx ky b">@Provides</code>方法配置的类型。在Kotlin函数中指定返回类型是可选的，甚至IDE有时也鼓励您重构代码，使内联方法体隐藏返回类型声明。</p><p id="71b4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果推断的类型不同于您想要的类型，这可能会导致错误。让我们看一些例子:</p><p id="d455" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您想要将特定类型添加到图形中，内联会按预期工作。查看在Kotlin中做同样事情的不同方式:</p><figure class="kz la lb lc fd ii"><div class="bz dy l di"><div class="ld le l"/></div></figure><p id="b7e0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您想要提供接口的实现，那么您必须显式指定返回类型。不这样做可能会导致问题和错误:</p><figure class="kz la lb lc fd ii"><div class="bz dy l di"><div class="ld le l"/></div></figure></div><div class="ab cl lp lq go lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ha hb hc hd he"><p id="1550" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Dagger通常在Kotlin开箱后使用。然而，您必须注意一些事情，以确保您正在做您真正想做的事情:字段属性上的限定符的<code class="du kv kw kx ky b">@field:</code>，内联方法体，以及注入集合时的<code class="du kv kw kx ky b">@JvmSuppressWildcards</code>。</p><p id="5895" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Dagger优化是免费的，添加它们并遵循最佳实践来改进您的构建时间:启用增量注释处理，禁用格式化并在Dagger模块中使用静态<code class="du kv kw kx ky b">@Provides</code>方法。</p></div></div>    
</body>
</html>