<html>
<head>
<title>Query Sniper</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">查询狙击手</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/query-sniper-b4be1912c1f6?source=collection_archive---------3-----------------------#2016-01-27">https://medium.com/square-corner-blog/query-sniper-b4be1912c1f6?source=collection_archive---------3-----------------------#2016-01-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="c4ad" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">控制失控查询。</h2></div><blockquote class="iw"><p id="2d4a" class="ix iy hh bd iz ja jb jc jd je jf jg dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jh" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="bfaf" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc jg ha bi translated">想象一下:您的服务接收到一个请求并启动一个数据库查询；请求超时，查询仍在运行，导致不必要的数据库负载，并可能导致数据库资源不足。当服务自动重试请求时，问题只会加剧，并会使最强大的数据库服务器屈服。</p><p id="0d68" class="pw-post-body-paragraph ji jj hh jk b jl kd ii jn jo ke il jq jr kf jt ju jv kg jx jy jz kh kb kc jg ha bi translated">那么，如何防范这种情况呢？</p><p id="7702" class="pw-post-body-paragraph ji jj hh jk b jl kd ii jn jo ke il jq jr kf jt ju jv kg jx jy jz kh kb kc jg ha bi translated">虽然这是许多平台的一个相当普遍的问题，但我们只涉及运行在<a class="ae jh" href="http://www.mysql.com/" rel="noopener ugc nofollow" target="_blank"> MySQL </a>后端的<a class="ae jh" href="http://java.sun.com/" rel="noopener ugc nofollow" target="_blank"> Java </a>和<a class="ae jh" href="http://www.oracle.com/technetwork/java/javase/jdbc/index.html" rel="noopener ugc nofollow" target="_blank"> JDBC </a>。然而，通篇讨论的思想应该适用于其他平台和数据库。</p><h1 id="4b1c" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">数据库超时</h1><p id="d587" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc jg ha bi translated">MySQL的最新版本允许设置全局超时，这样任何查询的运行时间都不会超过预定义的时间。这是一种相当粗粒度的方法，因为必须为可能运行时间最长的查询设置限制。所以，这种方法被排除了。(另外，我们没有在生产中运行MySQL的最新版本。)</p><h1 id="4523" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">应用程序级超时</h1><p id="113a" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc jg ha bi translated">您可以在MySQL的JDBC驱动程序上设置超时。我们使用<a class="ae jh" href="https://github.com/brettwooldridge/HikariCP" rel="noopener ugc nofollow" target="_blank"> HikariCP </a>进行连接池；它还允许您相应地配置池，委托驱动程序设置超时。这听起来很有希望。</p><h1 id="c08e" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">MySQL的JDBC驱动程序</h1><p id="14b4" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc jg ha bi translated">对于任何读过MySQL的JDBC驱动程序<a class="ae jh" href="https://dev.mysql.com/downloads/connector/j/" rel="noopener ugc nofollow" target="_blank"> Connector/J </a>的源代码的人来说，在这一点上你可能会感到害怕。这个驱动是在Java 1.3风靡一时的时候写的，只收到了一些小的更新。代码是意大利面条；充斥着粗糙的同步，通常不够灵活，不太具有可扩展性。</p><figure class="lg lh li lj fd lk er es paragraph-image"><div class="er es lf"><img src="../Images/469cb0c7878a6d971fa996e6e345e926.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*M-uiLMI6yUXYBFjVZ_tg7Q.jpeg"/></div></figure><p id="3c5d" class="pw-post-body-paragraph ji jj hh jk b jl kd ii jn jo ke il jq jr kf jt ju jv kg jx jy jz kh kb kc jg ha bi translated">哦好吧。</p><p id="c1b0" class="pw-post-body-paragraph ji jj hh jk b jl kd ii jn jo ke il jq jr kf jt ju jv kg jx jy jz kh kb kc jg ha bi translated">深入到驱动程序中，我看到为每个连接实例启动了一个JDK <a class="ae jh" href="https://docs.oracle.com/javase/8/docs/api/java/util/Timer.html" rel="noopener ugc nofollow" target="_blank">计时器</a>,并计划在预定义的时间过后运行一个清理任务。在<em class="ln">com . MySQL . JDBC . statement impl</em>中我们看到:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="af5d" class="lt kj hh lp b fi lu lv l lw lx"><strong class="lp hi">public</strong> <strong class="lp hi">class</strong> <strong class="lp hi">StatementImpl</strong> <strong class="lp hi">implements</strong> Statement <strong class="lp hi">{</strong>  <br/>  <strong class="lp hi">...</strong><br/>  <strong class="lp hi">class</strong> <strong class="lp hi">CancelTask</strong> <strong class="lp hi">extends</strong> TimerTask <strong class="lp hi">{</strong>    <br/>    <strong class="lp hi">...</strong>    <br/>    @Override<br/>    <strong class="lp hi">public</strong> <strong class="lp hi">void</strong> <strong class="lp hi">run()</strong> <strong class="lp hi">{</strong><br/>        Thread cancelThread <strong class="lp hi">=</strong> <strong class="lp hi">new</strong> <strong class="lp hi">Thread()</strong> <strong class="lp hi">{</strong><br/>            @Override<br/>            <strong class="lp hi">public</strong> <strong class="lp hi">void</strong> <strong class="lp hi">run()</strong> <strong class="lp hi">{</strong><br/>  <strong class="lp hi">...</strong><br/><strong class="lp hi">}</strong></span></pre><h1 id="afaf" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">清理任务</h1><p id="07e4" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc jg ha bi translated">驱动程序安排的清理任务很简单(也在<em class="ln">com . MySQL . JDBC . statement impl</em>中):</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="caee" class="lt kj hh lp b fi lu lv l lw lx"><strong class="lp hi">..</strong><br/>cancelConn <strong class="lp hi">=</strong> StatementImpl<strong class="lp hi">.</strong>this<strong class="lp hi">.</strong>connection<strong class="lp hi">.</strong>duplicate<strong class="lp hi">();</strong><br/>cancelStmt <strong class="lp hi">=</strong> cancelConn<strong class="lp hi">.</strong>createStatement<strong class="lp hi">();</strong><br/>cancelStmt<strong class="lp hi">.</strong>execute<strong class="lp hi">(</strong>"KILL QUERY " <strong class="lp hi">+</strong> CancelTask<strong class="lp hi">.</strong>this<strong class="lp hi">.</strong>connectionId<strong class="lp hi">);</strong><br/><strong class="lp hi">...</strong></span></pre><p id="e430" class="pw-post-body-paragraph ji jj hh jk b jl kd ii jn jo ke il jq jr kf jt ju jv kg jx jy jz kh kb kc jg ha bi translated">除了清除语句实例上的状态(在一些非常糟糕的同步块中)，该任务还执行两个关键操作:</p><ol class=""><li id="166f" class="ly lz hh jk b jl kd jo ke jr ma jv mb jz mc jg md me mf mg bi translated">克隆JDBC连接以建立到数据库的新的<em class="ln">连接。</em></li><li id="1b3c" class="ly lz hh jk b jl mh jo mi jr mj jv mk jz ml jg md me mf mg bi translated">对新连接发出<em class="ln">终止查询&lt; connection_id &gt; </em>查询，传入原始连接的id。</li></ol><h1 id="1114" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">缺点</h1><p id="4f21" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc jg ha bi translated">除了两个问题之外，这样做很好:</p><h2 id="6dc0" class="lt kj hh bd kk mm mn mo ko mp mq mr ks jr ms mt ku jv mu mv kw jz mw mx ky my bi translated">定时器</h2><p id="af65" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc jg ha bi translated">JDK的计时器又旧又笨重，而且很贵。每个线程创建一个新线程。(即使是Javadocs on <em class="ln"> Timer </em> s也推荐使用<a class="ae jh" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html" rel="noopener ugc nofollow" target="_blank"><em class="ln">ScheduledExecutorService</em>s</a>代替。)</p><h2 id="7e8c" class="lt kj hh bd kk mm mn mo ko mp mq mr ks jr ms mt ku jv mu mv kw jz mw mx ky my bi translated">克隆连接</h2><p id="2fcc" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc jg ha bi translated">每次克隆JDBC连接都会导致数据库服务器可用的连接数量出现问题——尤其是在处理占用资源的失控查询时。这样的超时任务可能无法连接到数据库来终止失控的查询。</p><h1 id="7bd2" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">质疑狙击手</h1><p id="fe59" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc jg ha bi translated">由于这些缺点，我们决定编写自己的查询狙击程序，而不是简单地设置JDBC超时。query sniper实际上做的事情与在JDBC连接上设置超时完全相同，只是它被实现为JOOQ<a class="ae jh" href="http://www.jooq.org/doc/3.7/manual/sql-execution/execute-listeners/" rel="noopener ugc nofollow" target="_blank"><em class="ln">execute listener</em></a>并向单个<em class="ln">scheduled executorservice</em>提交任务。每次执行查询时，整个系统只配置一个维护线程。这是这个想法的一个简化版本:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="8d91" class="lt kj hh lp b fi lu lv l lw lx">package querysniper<strong class="lp hi">;</strong></span><span id="3661" class="lt kj hh lp b fi mz lv l lw lx">import java.util.concurrent.ScheduledExecutorService<strong class="lp hi">;</strong><br/>import org.jooq.ExecuteContext<strong class="lp hi">;</strong><br/>import org.jooq.ExecuteListenerProvider<strong class="lp hi">;</strong><br/>import org.jooq.Query<strong class="lp hi">;</strong><br/>import org.jooq.impl.DefaultExecuteListener<strong class="lp hi">;</strong></span><span id="1f74" class="lt kj hh lp b fi mz lv l lw lx">import static java<strong class="lp hi">.</strong>util<strong class="lp hi">.</strong>concurrent<strong class="lp hi">.</strong>TimeUnit<strong class="lp hi">.</strong>MILLISECONDS<strong class="lp hi">;</strong></span><span id="6014" class="lt kj hh lp b fi mz lv l lw lx"><strong class="lp hi">public</strong> <strong class="lp hi">class</strong> <strong class="lp hi">QuerySniper</strong> <strong class="lp hi">extends</strong> DefaultExecuteListener <strong class="lp hi">{</strong><br/>  <strong class="lp hi">private</strong> <strong class="lp hi">static</strong> <strong class="lp hi">final</strong> <strong class="lp hi">int</strong> MAX_QUERY_TIME <strong class="lp hi">=</strong> 10_000L<strong class="lp hi">;</strong> <em class="ln">// 10 seconds</em></span><span id="1b96" class="lt kj hh lp b fi mz lv l lw lx"><strong class="lp hi">private</strong> <strong class="lp hi">final</strong> ScheduledExecutorService scheduledExecutorService<strong class="lp hi">;</strong><br/>  <strong class="lp hi">private</strong> <strong class="lp hi">volatile</strong> <strong class="lp hi">boolean</strong> queryRunning <strong class="lp hi">=</strong> <strong class="lp hi">false;</strong></span><span id="821e" class="lt kj hh lp b fi mz lv l lw lx"><strong class="lp hi">public</strong> <strong class="lp hi">QuerySniper(</strong>ScheduledExecutorService scheduledExecutorService<strong class="lp hi">)</strong> <strong class="lp hi">{</strong><br/>    <strong class="lp hi">this.</strong>scheduledExecutorService <strong class="lp hi">=</strong> scheduledExecutorService<strong class="lp hi">;</strong><br/>  <strong class="lp hi">}</strong></span><span id="4d19" class="lt kj hh lp b fi mz lv l lw lx">@Override<br/>  <strong class="lp hi">public</strong> <strong class="lp hi">void</strong> <strong class="lp hi">executeStart(</strong>ExecuteContext ctx<strong class="lp hi">)</strong> <strong class="lp hi">{</strong><br/>    <em class="ln">// Start a timer</em><br/>    queryRunning <strong class="lp hi">=</strong> <strong class="lp hi">true;</strong></span><span id="709f" class="lt kj hh lp b fi mz lv l lw lx"><em class="ln">// You'd typically have this hook into your system to understand how much</em><br/>    <em class="ln">// time to let your query run for</em><br/>    <strong class="lp hi">long</strong> timeBudget <strong class="lp hi">=</strong> MAX_QUERY_TIME<strong class="lp hi">;</strong></span><span id="360b" class="lt kj hh lp b fi mz lv l lw lx">scheduledExecutorService<strong class="lp hi">.</strong>schedule<strong class="lp hi">(()</strong> <strong class="lp hi">-&gt;</strong> <strong class="lp hi">{</strong><br/>      <strong class="lp hi">if</strong> <strong class="lp hi">(</strong>queryRunning<strong class="lp hi">)</strong> <strong class="lp hi">{</strong><br/>        log<strong class="lp hi">(</strong>ctx<strong class="lp hi">,</strong> timeBudget<strong class="lp hi">);</strong><br/>        <strong class="lp hi">if</strong> <strong class="lp hi">(</strong>ctx<strong class="lp hi">.</strong>query<strong class="lp hi">()</strong> <strong class="lp hi">!=</strong> <strong class="lp hi">null)</strong> <strong class="lp hi">{</strong><br/>          ctx<strong class="lp hi">.</strong>query<strong class="lp hi">().</strong>cancel<strong class="lp hi">();</strong><br/>        <strong class="lp hi">}</strong><br/>        queryRunning <strong class="lp hi">=</strong> <strong class="lp hi">false;</strong><br/>      <strong class="lp hi">}</strong><br/>    <strong class="lp hi">},</strong> timeBudget<strong class="lp hi">,</strong> MILLISECONDS<strong class="lp hi">);</strong><br/>  <strong class="lp hi">}</strong></span><span id="c7f1" class="lt kj hh lp b fi mz lv l lw lx">@Override<br/>  <strong class="lp hi">public</strong> <strong class="lp hi">void</strong> <strong class="lp hi">executeEnd(</strong>ExecuteContext ctx<strong class="lp hi">)</strong> <strong class="lp hi">{</strong><br/>    <em class="ln">// Stop timer</em><br/>    queryRunning <strong class="lp hi">=</strong> <strong class="lp hi">false;</strong><br/>  <strong class="lp hi">}</strong></span><span id="8919" class="lt kj hh lp b fi mz lv l lw lx">@Override<br/>  <strong class="lp hi">public</strong> <strong class="lp hi">void</strong> <strong class="lp hi">exception(</strong>ExecuteContext ctx<strong class="lp hi">)</strong> <strong class="lp hi">{</strong><br/>    <em class="ln">// Stop timer on exception as well</em><br/>    queryRunning <strong class="lp hi">=</strong> <strong class="lp hi">false;</strong><br/>  <strong class="lp hi">}</strong></span><span id="b15c" class="lt kj hh lp b fi mz lv l lw lx"><strong class="lp hi">private</strong> <strong class="lp hi">void</strong> <strong class="lp hi">log(</strong>ExecuteContext ctx<strong class="lp hi">,</strong> <strong class="lp hi">long</strong> timeBudget<strong class="lp hi">)</strong> <strong class="lp hi">{</strong><br/>    System<strong class="lp hi">.</strong>out<strong class="lp hi">.</strong>println<strong class="lp hi">(</strong>"Query exceeded %s ms. Killing it!"<strong class="lp hi">,</strong> timeBudget<strong class="lp hi">);</strong><br/>    System<strong class="lp hi">.</strong>out<strong class="lp hi">.</strong>println<strong class="lp hi">(</strong>"Query: %s"<strong class="lp hi">,</strong> ctx<strong class="lp hi">.</strong>sql<strong class="lp hi">());</strong><br/>  <strong class="lp hi">}</strong><br/><strong class="lp hi">}</strong></span></pre><p id="a601" class="pw-post-body-paragraph ji jj hh jk b jl kd ii jn jo ke il jq jr kf jt ju jv kg jx jy jz kh kb kc jg ha bi translated">使用JOOQ的<a class="ae jh" href="http://www.jooq.org/javadoc/3.7.0/org/jooq/Configuration.html#set-org.jooq.ExecuteListenerProvider...-" rel="noopener ugc nofollow" target="_blank"><em class="ln">configuration . set()</em></a>API将查询狙击手添加到所有JOOQ DSL会话中:</p><pre class="lg lh li lj fd lo lp lq lr aw ls bi"><span id="7a62" class="lt kj hh lp b fi lu lv l lw lx">DefaultConfiguration cfg <strong class="lp hi">=</strong> getDefaultConfiguration<strong class="lp hi">();</strong><br/>ScheduledExecutorService executor <strong class="lp hi">=</strong> getScheduledExecutorService<strong class="lp hi">();</strong><br/>cfg<strong class="lp hi">.</strong>set<strong class="lp hi">(()</strong> <strong class="lp hi">-&gt;</strong> <strong class="lp hi">new</strong> <strong class="lp hi">QuerySniper(</strong>executor<strong class="lp hi">));</strong></span></pre><h1 id="69e0" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">细粒度超时</h1><p id="01f1" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc jg ha bi translated">为了额外的好处，查询狙击手检查请求上下文，并确定在请求超时之前还有多少时间来运行查询；因此，在每个查询的基础上设置细粒度的超时。</p><h1 id="1d79" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">再次克隆连接</h1><p id="6400" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc jg ha bi translated">我们希望维护一个单独的、预先建立的由单个连接组成的连接池，专门用于让查询狙击手杀死长时间运行的查询。这样，我们就克服了无法建立新的数据库连接的问题。但是，我们遇到了阻碍。为了维护我们自己的连接池，我们必须手工创建我们自己的<em class="ln">KILL QUERY&lt;connection _ id&gt;</em>语句。MySQL的JDBC驱动程序不公开事务ID来允许我们这样做。</p><p id="2dbf" class="pw-post-body-paragraph ji jj hh jk b jl kd ii jn jo ke il jq jr kf jt ju jv kg jx jy jz kh kb kc jg ha bi translated">遗憾的是，查询狙击手最终只是在它想要终止的运行语句上调用了<a class="ae jh" href="https://docs.oracle.com/javase/8/docs/api/java/sql/Statement.html#cancel--" rel="noopener ugc nofollow" target="_blank"><em class="ln">statement . cancel()</em></a>。这仍然会导致连接被克隆，等等。就像以前一样。</p><figure class="lg lh li lj fd lk er es paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="er es na"><img src="../Images/34a09478f5b93fb69f059869efbfbbd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKQpU65BgD-sp_omQWt4Bg.jpeg"/></div></div></figure><h1 id="ee19" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">结论</h1><p id="f014" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc jg ha bi translated">有了我们的查询狙击手，并在许多系统上运行于生产环境中，我们为自己节省了相当多的停机时间——这些停机时间我们以前在测试我们构建的有一些流氓查询的新系统时见过。如果不是it击落了这些被放弃的查询，这些中断还会继续发生(根据查询狙击手记录的活动来判断)。</p><h1 id="ac63" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">下一步是什么？</h1><p id="52e9" class="pw-post-body-paragraph ji jj hh jk b jl la ii jn jo lb il jq jr lc jt ju jv ld jx jy jz le kb kc jg ha bi translated">尽管我们很想开源这段代码，但它与Square的基础设施联系太紧密，无法提取到一个单独的库中。(如果你想看更多，你可以随时<a class="ae jh" href="https://squareup.com/careers" rel="noopener ugc nofollow" target="_blank">加入我们的团队</a>。)但是，我希望上面描述的模式和包含的代码片段对其他人有用。</p><p id="f55c" class="pw-post-body-paragraph ji jj hh jk b jl kd ii jn jo ke il jq jr kf jt ju jv kg jx jy jz kh kb kc jg ha bi translated">我真的希望能够保持与数据库的持久连接。为此，我希望修补MySQL的驱动程序，以暴露其事务ID，允许手工制作的<em class="ln"> KILL QUERY </em> …语句。</p><p id="a4e7" class="pw-post-body-paragraph ji jj hh jk b jl kd ii jn jo ke il jq jr kf jt ju jv kg jx jy jz kh kb kc jg ha bi translated">或者，也许我真正需要做的，是使用并发和线程安全、资源管理、可配置性和可扩展性的现代理念重写MySQL JDBC驱动程序？；)</p></div></div>    
</body>
</html>