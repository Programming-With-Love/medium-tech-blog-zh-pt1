<html>
<head>
<title>Accelerating Services at Airbnb by Building — and Open Sourcing — a Blazing Fast Thrift Binding for Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过构建——和开源Ruby的快速节俭绑定，加速Airbnb的服务</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/accelerating-services-at-airbnb-by-building-a-blazing-fast-thrift-binding-for-ruby-8f63044ba149?source=collection_archive---------3-----------------------#2017-07-31">https://medium.com/airbnb-engineering/accelerating-services-at-airbnb-by-building-a-blazing-fast-thrift-binding-for-ruby-8f63044ba149?source=collection_archive---------3-----------------------#2017-07-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="5e48" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">介绍<a class="ae iw" href="https://github.com/airbnb/sparsam" rel="noopener ugc nofollow" target="_blank"> Sparsam </a>，Airbnb在Ruby中实现的节俭序列化器。<a class="ae iw" href="https://github.com/airbnb/sparsam" rel="noopener ugc nofollow" target="_blank"> Sparsam </a>在序列化方面比旧的Thrift Ruby绑定快25倍，在反序列化方面快8倍。</h2></div></div><div class="ab cl ix iy go iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="ha hb hc hd he"><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/4897156cb55cdb3c853659f097916328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sDqaokrqiCcsPDYchwF3ZQ.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">The evolution of Sparsam’s performance over time. Higher is better, with the leftmost being the original Thrift implementation in Ruby.</figcaption></figure><p id="be02" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">在设计服务和它们之间的交互时，一致性和可伸缩性是我们追求的两个最重要的品质。实现这些品质的一个重要方面是用于服务间通信的序列化协议。在Airbnb，我们使用<a class="ae iw" href="https://thrift.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Thrift </a>就是为了这个目的。Thrift是一个优秀的序列化协议，简单而强大。想想JSON，但它是二进制的，速度更快，模式和生成的模型类有助于提高生产率。节俭一直是扩展Airbnb架构的重要工具，以实现我们的使命:创造一个人人共享的世界。随着越来越多的人在Airbnb上寻找奇妙的旅程，我们应用程序的性能变得越来越重要。我们的性能工程团队的任务是通过优化Airbnb的性能来改善Airbnb社区的体验。在我们的一次分析会话中，我们惊讶地发现Ruby Thrift绑定可能非常低效:在某些情况下，仅仅序列化一条消息就可能花费完成一次调用所需时间的80%。事实上，在我们的基准测试中，Ruby Thrift甚至比JSON还要慢。因为在Airbnb，Thrift不用于RPC，而仅用于序列化和反序列化(实际上是Thrift-over-HTTP)，所以我们决定构建自己的快速Thrift绑定:<a class="ae iw" href="https://github.com/airbnb/sparsam" rel="noopener ugc nofollow" target="_blank"> Sparsam </a>。</p></div><div class="ab cl ix iy go iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="ha hb hc hd he"><h1 id="18ff" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">在Ruby中实现裸机性能</h1><p id="d25e" class="pw-post-body-paragraph ju jv hh jw b jx li ii jz ka lj il kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">由于Ruby的动态特性，用Ruby编写高性能代码可能很困难:与习语是零成本抽象的低级语言不同，<a class="ae iw" href="http://gjmurakami-10gen.github.io/talks/call_operation_cost_in_cpu_ticks_ruby/" rel="noopener ugc nofollow" target="_blank">动态语言中的几乎所有东西都很昂贵</a>。因此，毫不奇怪Ruby Thrift绑定利用了一个重要的工具来提高动态语言库的性能:<a class="ae iw" href="http://guides.rubygems.org/gems-with-extensions/" rel="noopener ugc nofollow" target="_blank"> C扩展</a>。作为一种抽象，C扩展用一种高级语言中优雅的接口隐藏了所有性能实现的细节。然而，简单地使用C扩展并不能保证高性能。事实上，我们在Ruby Thrift绑定中观察到的许多模式都严重损害了它的性能。我们将讨论其中的一些模式，并展示Sparsam如何避免这些模式。</p><h2 id="7ba6" class="ln kr hh bd ks lo lp lq kw lr ls lt la kd lu lv lc kh lw lx le kl ly lz lg ma bi translated">避免昂贵的字符串分配</h2><p id="0257" class="pw-post-body-paragraph ju jv hh jw b jx li ii jz ka lj il kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">创建一个新的Ruby字符串是很慢的，用C语言创建也快不了多少。Thrift Ruby绑定速度慢的原因之一是它在反序列化数据时分配了过多的对象。对于它读取/写入的每个字段，需要通过<code class="du mb mc md me b">rb_iv_set/get</code>分配和保留一个ruby字符串。这种模式是有问题的，并且会显著增加访问每个字段的开销。在我们的一个实验中，简单地缓存一个字符串的内部ID可以获得25%的加速。在Sparsam的早期版本中，我们将每个字段存储在一个<code class="du mb mc md me b">{FieldID =&gt; Value}</code>的哈希映射中。这样，我们完全避免了创建字符串和字符串实习的成本。</p><h2 id="225c" class="ln kr hh bd ks lo lp lq kw lr ls lt la kd lu lv lc kh lw lx le kl ly lz lg ma bi translated">消除过多的跨语言函数调用</h2><p id="5fca" class="pw-post-body-paragraph ju jv hh jw b jx li ii jz ka lj il kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">C扩展速度快的一个重要原因是它们避开了Ruby VM。通过这样做，C扩展不需要分担动态语言的开销。跨越语言障碍的调用是不自由的，尤其是当从C调用ruby函数时，所以最佳实践是在一个大的C函数中尽可能多地处理。</p><p id="07dc" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">尽管Thrift Ruby绑定处理了C内部的大部分序列化，但它也依赖于Ruby VM在运行时的动态调度。结果，大量的时间都花在了解析Ruby VM中调用的正确方法上。当消息包含大量字段或者具有深度嵌套的结构时，这种特性减少了使用C扩展的意义，并可能导致性能下降。另一方面，Sparsam不依赖Ruby VM进行调度。通过这样做，我们最小化了序列化中Ruby VM调用的数量，并极大地提高了性能。</p><h2 id="3d67" class="ln kr hh bd ks lo lp lq kw lr ls lt la kd lu lv lc kh lw lx le kl ly lz lg ma bi translated">在C++容器中缓存模式信息</h2><p id="45f8" class="pw-post-body-paragraph ju jv hh jw b jx li ii jz ka lj il kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">我们发现的一个瓶颈是在序列化器中访问Thrift的结构定义。Thrift的高度紧凑的二进制格式要求通信的两端都拥有被序列化的结构的模式。例如，在ruby中，thrift将结构的定义编译成Ruby哈希，如下所示:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="e177" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">模式存储在<code class="du mb mc md me b">FIELDS</code>中，这是一个在Ruby类下定义的常量，这样的对象只能通过Ruby VM访问。这意味着对于一个字段的每次读/写，C扩展都需要访问这样的模式，并在Ruby和C数据类型之间执行类型转换，以确定使用哪种方法。由于Thrift的嵌套结构支持，这个问题变得更加严重，因为嵌套结构会导致嵌套散列对象。为了减轻这种影响，我们在C++ <code class="du mb mc md me b">map&lt;FieldID, FieldType&gt;</code>中缓存结构的模式信息。除了本身更快，我们还避免了在Ruby VM中调用函数和类型转换的成本。</p><h2 id="b0bc" class="ln kr hh bd ks lo lp lq kw lr ls lt la kd lu lv lc kh lw lx le kl ly lz lg ma bi translated">使用实例变量删除间接层</h2><p id="4e7e" class="pw-post-body-paragraph ju jv hh jw b jx li ii jz ka lj il kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">使用我们的<code class="du mb mc md me b">{FieldID =&gt; Value}</code>映射的一个问题是，ruby必须不断地增加哈希映射:每次读取一个值，哈希映射的容量都需要扩展以存储另一对数据，这导致了一个昂贵的<code class="du mb mc md me b">realloc</code>调用。此外，当访问一个字段时，需要进行两次散列查找:从字段名到字段ID，以及从字段ID到值。因此，我们将这种设计替换为直接使用实例变量来存储数据。这种方法有三个好处:ruby对实例变量的哈希增长行为不同于哈希映射，这使得它更适合存储反序列化的数据；访问数据时避免了间接层；Sparsam创建的对象更接近于PORO(普通的老式Ruby对象)。这种优化使我们的读取路径速度提高了近3倍，而对写入性能没有任何影响。</p><h1 id="dd73" class="kq kr hh bd ks kt mh kv kw kx mi kz la in mj io lc iq mk ir le it ml iu lg lh bi translated">基准</h1><p id="4211" class="pw-post-body-paragraph ju jv hh jw b jx li ii jz ka lj il kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">为了测试Sparsam的速度，我们将几个序列化器的速度与我们在Airbnb生产中使用的一个简单模式进行了比较:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="89aa" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">这个模式很简单，但是足够复杂，既有必需的字段又有容器类型。项目/秒的结果如下所示(越高越好):</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es mm"><img src="../Images/631fc11581f5457cbdd45a180bba40bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TepkvRVoMEzw4P8vS50h8w.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">QPS Comparison for Different Serializers in Ruby. Higher is better.</figcaption></figure><p id="e2fa" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">通过优化，Sparsam在写入路径上实现了25倍的加速，在读取路径上实现了8倍的加速，将Ruby中的Thrift加速到与MessagePack一样快，并且明显快于JSON，允许我们将更多的端点从传统的JSON端点移动到新的Thrift端点，而不会影响性能。</p><h1 id="f8c5" class="kq kr hh bd ks kt mh kv kw kx mi kz la in mj io lc iq mk ir le it ml iu lg lh bi translated">节俭结构的严格而强大的验证</h1><p id="e69d" class="pw-post-body-paragraph ju jv hh jw b jx li ii jz ka lj il kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">除了速度快之外，Sparsam还提供了对节约结构的广泛验证。默认情况下，Thrift只检查必填字段；在Sparsam中，我们提供了两种额外的验证模式:“严格”和“递归”。</p><ul class=""><li id="58c7" class="mn mo hh jw b jx jy ka kb kd mp kh mq kl mr kp ms mt mu mv bi translated">Strict:除了检查必填字段，strict模式还检查结构中的字段类型。但是，如果其中一个字段是struct类型，它将只检查这个struct是否具有正确的ruby struct，而不会检查其嵌套字段的类型。</li><li id="89d8" class="mn mo hh jw b jx mw ka mx kd my kh mz kl na kp ms mt mu mv bi translated">递归:检查必填字段、字段类型，并进入每个嵌套结构以检查嵌套结构中的字段类型。</li></ul><h1 id="019d" class="kq kr hh bd ks kt mh kv kw kx mi kz la in mj io lc iq mk ir le it ml iu lg lh bi translated">结论</h1><p id="7034" class="pw-post-body-paragraph ju jv hh jw b jx li ii jz ka lj il kc kd lk kf kg kh ll kj kk kl lm kn ko kp ha bi translated">开源软件在Airbnb发挥着重要作用。更快的序列化减少了面向服务架构的开销，从而改善了Airbnb社区的体验。通过开源Sparsam，我们希望能够回馈社区。</p></div><div class="ab cl ix iy go iz" role="separator"><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc jd"/><span class="ja bw bk jb jc"/></div><div class="ha hb hc hd he"><p id="eafe" class="pw-post-body-paragraph ju jv hh jw b jx jy ii jz ka kb il kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">我们鼓励您试用<a class="ae iw" href="https://github.com/airbnb/sparsam" rel="noopener ugc nofollow" target="_blank"> Sparsam </a>，并通过<a class="ae iw" href="https://github.com/airbnb/sparsam" rel="noopener ugc nofollow" target="_blank"> GitHub </a>向我们提供反馈。如果你喜欢从事性能工程工作，喜欢从应用程序中挤出最后一点性能，<a class="ae iw" href="https://www.airbnb.com/careers/departments/position/729187" rel="noopener ugc nofollow" target="_blank">我们将雇佣</a>。</p></div></div>    
</body>
</html>