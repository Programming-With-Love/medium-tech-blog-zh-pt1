<html>
<head>
<title>Building Feature Toggles into Terraform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建筑特征切换成地形</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/building-feature-toggles-into-terraform-d75806217647?source=collection_archive---------0-----------------------#2019-01-14">https://medium.com/capital-one-tech/building-feature-toggles-into-terraform-d75806217647?source=collection_archive---------0-----------------------#2019-01-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ae64b10366b8f00cf5c739f305061753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZkFDDTaCjKssFKYw"/></div></div></figure><p id="3f19" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如你从我之前的两篇文章中所知道的，分别是<a class="ae jn" rel="noopener" href="/capital-one-tech/deploying-multiple-environments-with-terraform-kubernetes-7b7f389e622">使用Terraform部署多个环境</a>和<a class="ae jn" rel="noopener" href="/capital-one-tech/multi-region-deployments-with-terraform-kubernetes-a1f51bb96974">使用Terraform进行多区域部署</a>，我们项目的最终目标是能够使用Terraform将Kubernetes集群部署到任何环境和/或具有单一代码库的区域。到目前为止，在这个系列中，我们已经成功地解决了部署到多个环境和多个地区的问题。随着我们旅程的继续，我们会遇到更复杂的挑战；<strong class="ir hi"> <em class="jo">并非所有环境都需要相同的特性。</em>T12】</strong></p><p id="d2d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">输入特征切换…</p><h1 id="f246" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">什么需要拨动开关？</h1><p id="18ea" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">传统上，功能切换已经在软件开发中用于打开和关闭软件功能。因为我们正在部署一个Kubernetes集群并为我们的用户运行一个平台，所以我们的特性切换有一个稍微不同的用例。我们维护着一套与每个Kubernetes集群一起部署的掌舵图。然而，并非我们支持的每个环境都需要所有这些舵图。因此，根据我们部署Kubernetes的位置，我们希望能够部署或不部署给定的舵图。</p><p id="4d46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除了掌舵图之外，我们还有一些额外的基础架构(更像是一种特殊的使用情形)需要部署到一些选定的环境中。因为我们部署的大多数Kubernetes集群都不需要这个基础设施，所以我们希望能够部署或不部署给定的基础设施。</p><h1 id="95c5" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">Terraform计数参数</h1><p id="ce1d" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">正如您可能从标题中猜到的那样，从0.11.x开始，Terraform不具备围绕特定资源或资源组编写切换的能力。Terraform附带了一个可以在所有资源上使用的<code class="du ks kt ku kv b">count</code>参数。<code class="du ks kt ku kv b">count</code>参数告诉Terraform要构建多少个资源；是的，零被接受，在这种情况下，它不会建立任何东西。作为第一步，您可能决定只添加<code class="du ks kt ku kv b"><em class="jo">count</em></code>参数，并根据需要在<code class="du ks kt ku kv b">0</code>和<code class="du ks kt ku kv b"><em class="jo">1</em></code>之间翻转值。</p><p id="c66d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jo">这样不会创建S3桶对象:</em> </strong></p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="dd30" class="le jq hh kv b fi lf lg l lh li"><em class="jo">resource “aws_s3_bucket_object” “some_s3_objct” {<br/> count = 0<br/> bucket = “${aws_s3_bucket.bucket.id}”<br/> key = “some_s3_object_path/some_s3_object”<br/> content = “This is an S3 object”<br/> server_side_encryption = “AES256”<br/>}</em></span></pre><p id="d29f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jo">这将创建S3桶对象:</em> </strong></p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="e24f" class="le jq hh kv b fi lf lg l lh li"><em class="jo">resource “aws_s3_bucket_object” “some_s3_objct” {<br/> count                  = 1<br/> bucket                 = “${aws_s3_bucket.bucket.id}”<br/> key                    = “some_s3_object_path/some_s3_object”<br/> content                = “This is an S3 object”<br/> server_side_encryption = “AES256”<br/>}</em></span></pre><p id="248e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过简单地添加<code class="du ks kt ku kv b"><em class="jo">count</em></code>参数，我们可以得到我们想要的行为，但是我们没有得到功能。为了让这种模式工作，每次资源的存在发生变化时，都需要对代码进行修改。幸运的是，<code class="du ks kt ku kv b"><em class="jo">count</em></code>参数允许插值，这为决定是否应该创建资源提供了一些更健壮的选项。</p><h1 id="fc54" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">插值计数参数</h1><p id="4311" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">通过内插<code class="du ks kt ku kv b"><em class="jo">count</em></code>参数，你可以潜在地将该值链接到你的代码库中其他变量的值；<code class="du ks kt ku kv b"><em class="jo">environment</em></code>比如。这将允许您基于您正在构建的环境来动态地决定是否构建资源。这里需要注意的是，插值比普通的字符串插值稍微复杂一些，不适合多种使用情况。为了让这个模式工作，你必须实现一个<code class="du ks kt ku kv b"><em class="jo">ternary</em></code>来做决定。</p><p id="4a04" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jo">如果var.environment等于some_env: </em> </strong>这将创建S3桶对象</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="f21b" class="le jq hh kv b fi lf lg l lh li"><em class="jo">resource “aws_s3_bucket_object” “some_s3_objct” {<br/> count                  = “${var.environment == “some_env” ? 1 : 0}”<br/> bucket                 = “${aws_s3_bucket.bucket.id}”<br/> key                    = “some_s3_object_path/some_s3_object”<br/> content                = “This is an S3 object”<br/> server_side_encryption = “AES256”<br/>}</em></span></pre><p id="fa75" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种模式似乎给了我们想要的行为和功能，允许我们在不改变代码的情况下动态地创建或不创建S3桶对象——但前提是逻辑不太复杂。例如，如果需要在多个环境中创建<code class="du ks kt ku kv b"><em class="jo">some_s3_object</em></code> <em class="jo"> </em>，或者如果不止一个变量有特定的值，那么这个<code class="du ks kt ku kv b"><em class="jo">ternary</em></code>仍然可以完成工作，但是不干净。</p><h1 id="2c71" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">构建切换</h1><p id="37d3" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">既然我们已经看到了更简单的实现所面临的限制，我们可以专注于构建一个由输入外部管理的完整的特性切换。<code class="du ks kt ku kv b"><em class="jo">count</em></code>参数和<code class="du ks kt ku kv b"><em class="jo">ternary</em></code>仍然会被使用，但是我们添加了一个输入变量和一个可选的输出。输入变量本质上只是一个接受“真”或“假”字符串的“使能”变量。输出是一个可选的资源，它向用户提供信息，告诉用户是否已经创建了什么。我们可以保持单个资源的代码基本相同，但是我们确实需要在它周围添加一些额外的代码。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="e122" class="le jq hh kv b fi lf lg l lh li"><em class="jo">variable “create_s3_object” {<br/> description = “Whether or not to create the S3 object”<br/> value = “true”<br/>}</em></span><span id="80c0" class="le jq hh kv b fi lj lg l lh li"><em class="jo">output “s3_object_created” {<br/> value = ${var.create_s3_object == “true” ? “S3 object created” : “S3 object not created”}<br/>}</em></span><span id="f3e5" class="le jq hh kv b fi lj lg l lh li"><em class="jo">resource “aws_s3_bucket_object” “some_s3_objct” {<br/> count                 = “${var.create_s3_object == “true” ? 1 : 0}”<br/> bucket                 = “${aws_s3_bucket.bucket.id}”<br/> key                    = “some_s3_object_path/some_s3_object”<br/> content                = “This is an S3 object”<br/> server_side_encryption = “AES256”<br/>}</em></span></pre><p id="8b33" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面的代码块现在有了为一个资源创建一个特性切换所必需的两个东西，以及一个选项输出，为用户提供一些关于所部署内容的上下文。输入变量有一个缺省值，在这个例子中是“true ”,但是如果需要的话可以设置为“false”。</p><h1 id="0a05" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用切换</h1><p id="cf98" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">现在，我们已经为Terraform构建了一个合适的功能切换，我们可以在任何环境中使用这个新功能作为我们部署的一部分。即使输入变量有默认值，我们也可以根据需要轻松地覆盖它，而不必更改底层代码。我们可以直接在命令行或者通过使用一个<code class="du ks kt ku kv b"><em class="jo">auto.tfvars</em></code>文件将输入变量及其值传递给Terraform。</p><p id="1d81" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">根据您的使用情况，这两种方式都可能是首选的，重要的是这种模式非常适合本地部署，以及通过CI/CD工具的自动化部署。</p><p id="335f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下示例说明了如何在命令行将输入变量传递给Terraform。在我们的简单例子中，这似乎是合理的；然而，随着切换次数的增加，<code class="du ks kt ku kv b"><em class="jo">-var</em></code>参数的数量也会增加。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="048b" class="le jq hh kv b fi lf lg l lh li"><em class="jo">terraform apply -var create_s3_object=true</em></span></pre><p id="420c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">创建一个<code class="du ks kt ku kv b"><em class="jo">auto.tfvars</em></code>文件非常简单。您可以随意命名它(在本例中为<code class="du ks kt ku kv b"><em class="jo">toggles.auto.tfvars</em></code>)，Terraform会在运行时自动读入它。内容也非常简单，因为它只是一个键/值对的列表，其中键是变量名，值显然是您想要传递的值。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="32ab" class="le jq hh kv b fi lf lg l lh li"><em class="jo"># toggles.auto.tfvars<br/>create_s3_object = false</em></span></pre><h1 id="93c1" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">判决</h1><p id="db21" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">使用这种模式，我的团队目前正在跨九个环境和两个地区向我们的Kubernetes集群部署31个独立的特性切换。个人平台开发人员能够根据本地开发的需要打开和关闭特性，我们的CI/CD充分利用渲染的<code class="du ks kt ku kv b"><em class="jo">auto.tfvars</em></code>文件来管理部署的切换。</p><p id="3fae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，这并不是我们旅程的终点；只是第一站。未来的开发将实现依赖切换，这将允许我们为我们的平台提供的所有功能创建一个依赖关系树，以及关闭以前打开的功能的能力。</p><h1 id="2ff3" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">相关:</h1><ul class=""><li id="552d" class="lk ll hh ir b is kn iw ko ja lm je ln ji lo jm lp lq lr ls bi translated"><a class="ae jn" rel="noopener" href="/capital-one-tech/deploying-multiple-environments-with-terraform-kubernetes-7b7f389e622">使用Terraform部署多个环境</a></li><li id="81ce" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><a class="ae jn" rel="noopener" href="/capital-one-tech/multi-region-deployments-with-terraform-kubernetes-a1f51bb96974">使用Terraform进行多区域部署</a></li><li id="be0e" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">像对待应用程序一样对待Terraform:第1部分——为什么要在Docker容器中使用Terraform？</li><li id="d5e8" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><a class="ae jn" rel="noopener" href="/capital-one-tech/treating-your-terraform-like-an-application-how-to-dockerize-terraform-5d7edac741fc">像对待应用程序一样对待地形:第2部分——如何将地形码头化</a></li></ul></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><p id="9f11" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jo">披露声明:这些观点是作者的观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权均为其各自所有者所有。本文为2019首都一。</em></p></div></div>    
</body>
</html>