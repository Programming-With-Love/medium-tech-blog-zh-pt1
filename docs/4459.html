<html>
<head>
<title>Sharing typography and color palette as SASS mixins through NPM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在NPM分享排版和调色板</h1>
<blockquote>原文：<a href="https://medium.com/compendium/sharing-typography-and-color-palette-as-sass-mixins-through-npm-4944e7bc25a6?source=collection_archive---------2-----------------------#2018-04-05">https://medium.com/compendium/sharing-typography-and-color-palette-as-sass-mixins-through-npm-4944e7bc25a6?source=collection_archive---------2-----------------------#2018-04-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5e7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随着公司web应用程序数量的增长，在应用程序之间保持一致的排版和调色板所需的工作也在增加。这个问题的一个好的解决方案是创建一个共享的设计包来处理最基本的设计配置。通过将它从GUI组件中分离出来，该库就前端框架而言变得不独立，因为它没有耦合到例如React或Angular。在本文中，我们将制作一个简单的NPM包，包含一个调色板和一个排版配置，作为SASS mixin提供给消费者。如果你想了解更多关于共享可复用代码的内容，可以查看Magnus Stuhr关于 <a class="ae jd" rel="noopener" href="/grensesnittet/my-previous-blog-post-argued-that-one-of-the-most-important-principles-of-programming-is-to-avoid-4944735c5fd9"> <em class="jc">构建可复用有角度的NPM包</em> </a> <em class="jc">的文章。</em></p><h2 id="3187" class="je jf hh bd jg jh ji jj jk jl jm jn jo ip jp jq jr it js jt ju ix jv jw jx jy bi translated">小贴士:</h2><p id="3883" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">阅读时看看<a class="ae jd" href="https://github.com/eTallang/shared-design-demo" rel="noopener ugc nofollow" target="_blank">范例库</a>可能是个好主意，因为这样更容易理解。</p></div><div class="ab cl ke kf go kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="ha hb hc hd he"><h1 id="d988" class="kl jf hh bd jg km kn ko jk kp kq kr jo ks kt ku jr kv kw kx ju ky kz la jx lb bi translated">设置结构</h1><p id="86ad" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">由于共享设计包的用途很窄，存储库中的文件数量非常少。本质上，唯一需要的是一个./src文件夹来包含所有的样式，以及一个<a class="ae jd" href="https://gulpjs.com/" rel="noopener ugc nofollow" target="_blank">gupp</a>-脚本来在我们想要<a class="ae jd" href="https://docs.npmjs.com/getting-started/publishing-npm-packages" rel="noopener ugc nofollow" target="_blank">发布NPM包</a>时将它们合并在一起。我们将回到为什么合并文件，以及本文后面的另一种方法。</p><h1 id="5e36" class="kl jf hh bd jg km lc ko jk kp ld kr jo ks le ku jr kv lf kx ju ky lg la jx lb bi translated">定义颜色</h1><p id="02c2" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">在我们的例子中，我们将在调色板中创建四种颜色和两种灰色。首先在。/src文件夹包含我们所有的颜色和色调:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="41c7" class="je jf hh lm b fi lq lr l ls lt">// Colors<br/>$calm-blue: #2196F3;<br/>$teal: #009688;<br/>$amber: #FFC107;<br/>$red: #D32F2F;<br/><br/>// Greys<br/>$dark-grey: #282828;<br/>$light-grey: #dedede;</span></pre><p id="19df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些都被定义为SASS变量，这样就可以从依赖于我们共享设计包的项目中引用它们。</p><h1 id="9edc" class="kl jf hh bd jg km lc ko jk kp ld kr jo ks le ku jr kv lf kx ju ky lg la jx lb bi translated">定义排版</h1><p id="a931" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">前面描述的调色板由SASS变量组成，无论如何，只要消费者愿意，就可以使用这些变量。另一方面，字体设计并不是这样工作的。</p><p id="a4b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为我们的排版配置将是全局的，所以将它实现为SASS mixin是一个很好的实践，这样我们的包的消费者可以决定他/她是否或者何时想要使用它。这也是防止污染全局样式表的一个很好的防护措施，因为我们的主题文件的每次导入都会将排版配置添加到应用程序中。出于本文篇幅的考虑，我只展示一部分排版配置。要查看完整的配置，请参见<a class="ae jd" href="https://github.com/eTallang/shared-design-demo" rel="noopener ugc nofollow" target="_blank">示例-存储库</a>。</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="286c" class="je jf hh lm b fi lq lr l ls lt">@import './palette.scss';<br/><br/>@mixin demo-typography() {<br/>  * {<br/>    font-family: 'Montserrat', sans-serif;<br/>    font-style: normal;<br/>    font-weight: normal;<br/>  }<br/><br/>  h1, h2, h3, h4, h5, p, b, strong, i, em, mark, small, del, ins, sub, sup {<br/>    color: $dark-grey;<br/>  }<br/><br/>  h1 {<br/>    font-weight: bold;<br/>    font-size: 3rem;<br/>    line-height: 4rem;<br/>  }<br/><br/>  p, b, strong, i, em, mark, del, ins {<br/>    font-size: 1.2rem;<br/>    line-height: 2rem;<br/>  }<br/><br/>  .small-typography {<br/>    h1 {<br/>      font-size: 3.1rem;<br/>      line-height: 2.6rem;<br/>    }<br/><br/>    h2 {<br/>      font-size: 2rem;<br/>      line-height: 2.7rem;<br/>    }<br/><br/>    p, b, strong, i, em, mark, del, ins {<br/>      font-size: 1rem;<br/>      line-height: 2rem;<br/>    }<br/>  }<br/>}</span></pre><p id="1c7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如你可能注意到的，我们还没有使用媒体查询来为我们的移动排版定义断点。这自然是你在自己的项目中可以做到的事情。在我们的例子中，我们已经将移动排版实现为一个CSS类，因此可以使用<a class="ae jd" href="https://github.com/angular/flex-layout" rel="noopener ugc nofollow" target="_blank"> @angular/flex-layout </a>轻松地将其切换为一个根级CSS类。这是防止在应用程序中重复相同媒体查询断点的好方法:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="2be9" class="je jf hh lm b fi lq lr l ls lt">&lt;div ngClass.xs=”small-typography”&gt; // Root element</span></pre><p id="e635" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ngClass.xs-attribute是围绕Angular ngClass属性的flex-layout包装器，如果屏幕的宽度在<a class="ae jd" href="https://github.com/angular/flex-layout/wiki/Responsive-API" rel="noopener ugc nofollow" target="_blank">超小(xs)范围</a>内，它会将“小字体”CSS-class添加到div-element中。</p><h1 id="f2aa" class="kl jf hh bd jg km lc ko jk kp ld kr jo ks le ku jr kv lf kx ju ky lg la jx lb bi translated">融合在一起</h1><p id="c9ee" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">到目前为止，我们的项目在。/src文件夹，即。/src/palette.scss和。让我们的库对消费者来说更加用户友好的一个很好的方法是让它更容易使用软件包的不同部分，而不必直接引用不同的文件:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="6edd" class="je jf hh lm b fi lq lr l ls lt">@import '~@my-package/shared-design-demo/typography';<br/>@import '~@my-package/shared-design-demo/palette';</span></pre><p id="7427" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随着我们设计库的增长，这种方法不能很好地扩展，因为包中的每个新文件都需要一个新的导入行给消费者。通过我们的包暴露我们的内部文件结构也不是一个好主意。这阻止了我们重命名或重构我们的样式，因为这将在我们的消费者应用程序中引入一个突破性的变化。因此，我们将创建一个用作公共访问点的文件，其中包含我们“私有”文件中的所有样式。</p><p id="c48f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对此有两种方法。我们可以创建一个“index”SASS文件，它简单地导入。/src文件夹。这是最简单的方法，因为它允许我们直接发布我们的包，不需要任何进一步的构建步骤。缺点是，如果在。/src-folder。另一种方法是使用Gulp创建一个简单的构建脚本，将。/src-folder，然后发布我们的包。我们将选择后者，只是为了让这篇文章更有趣一些。该脚本放在gulpfile.js中，要求我们在项目中添加gulp和几个gulp扩展:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="8bb4" class="je jf hh lm b fi lq lr l ls lt">npm install gulp gulp-concat gulp-scss-combine --save-dev</span></pre><p id="f50d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">脚本如下:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="4911" class="je jf hh lm b fi lq lr l ls lt">'use strict';<br/><br/>var gulp = require('gulp');<br/>var sass = require('gulp-scss-combine');<br/>var concat = require('gulp-concat');<br/><br/>gulp.task('default', mergeSass);<br/><br/>function mergeSass(done) {<br/>  return gulp.src(['src/palette.scss', 'src/*.scss']) // Reads all files in src<br/>    .pipe(concat('theme.scss')) // Merges all of the files into theme.scss<br/>    .pipe(sass()) // Serves to remove @import statements from the output<br/>    .pipe(gulp.dest('./')); // Writes the file to root<br/>}</span></pre><p id="9347" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它所做的就是从我们的。/src文件夹，从我们的调色板开始。这只是为了确保调色板变量被放在我们文件的顶部，因为它们被用于例如排版。该脚本还确保删除@import语句，例如排版顶部调色板的@import。这是必要的，因为我们库的输出文件夹将不包含palette.scss文件，因此库会抛出一个错误。</p><h1 id="4fe7" class="kl jf hh bd jg km lc ko jk kp ld kr jo ks le ku jr kv lf kx ju ky lg la jx lb bi translated">准备发布</h1><p id="b8f9" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">我们的共享设计包所需的几乎所有部分现在都已就绪。剩下的工作就是创建一个NPM脚本来使用我们新创建的Gulp脚本，并确保我们的theme.scss文件包含在我们的NPM包中。为了处理这个问题，我们的package.json是这样的:</p><pre class="lh li lj lk fd ll lm ln lo aw lp bi"><span id="efd3" class="je jf hh lm b fi lq lr l ls lt">{<br/>  "name": "@my-package/shared-design-demo",<br/>  ...<br/>  "scripts": {<br/>    "merge": "gulp"<br/>  },<br/>  "files": [<br/>    "theme.scss"<br/>  ],<br/>  "devDependencies": {<br/>    "gulp": "^3.9.1",<br/>    "gulp-concat": "^2.6.1",<br/>    "gulp-scss-combine": "^1.0.0"<br/>  }<br/>}</span></pre><p id="8931" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过“npm run merge”运行我们的脚本，现在应该会在我们的根文件夹中生成一个名为theme.scss的文件。现在剩下的就是运行“npm publish–access = public”来将我们的包发布到NPM！</p></div><div class="ab cl ke kf go kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="ha hb hc hd he"><h1 id="7574" class="kl jf hh bd jg km kn ko jk kp kq kr jo ks kt ku jr kv kw kx ju ky kz la jx lb bi translated">最后的想法</h1><p id="a28b" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">通过使用一个共享的NPM包来定义web应用程序中的通用设计元素，我们可以在改变应用程序中应该相同的设计时节省大量时间。值得一提的是，我们的排版配置为我们的排版外观的每个方面提供了一种自以为是的方法。如果更具可配置性的方法是首选，可以改变排版混合以接受输入参数。例如，这些可以包括字体系列或您希望可配置的排版的其他方面。</p></div></div>    
</body>
</html>