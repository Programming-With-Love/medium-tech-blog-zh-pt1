<html>
<head>
<title>Pumped-up logging with Fluent Bit and Splunk</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Fluent Bit和Splunk进行泵送测井</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/pumped-up-logging-with-fluent-bit-and-splunk-6c1c8fc19fd7?source=collection_archive---------3-----------------------#2021-09-29">https://medium.com/walmartglobaltech/pumped-up-logging-with-fluent-bit-and-splunk-6c1c8fc19fd7?source=collection_archive---------3-----------------------#2021-09-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="06c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您不熟悉<a class="ae jc" href="https://fluentbit.io/documentation" rel="noopener ugc nofollow" target="_blank"> Fluent Bit </a>，这是一个用C语言编写的开源应用程序，可以帮助将数据从多个来源运送到多个目的地，比如虚拟机、集装箱和物联网设备。Fluent Bit非常轻量级、高性能和有弹性，这使得它非常适合于Kubernetes环境。<br/>要向<a class="ae jc" href="https://docs.splunk.com/Documentation" rel="noopener ugc nofollow" target="_blank"> Splunk </a>发送数据，我们需要在Fluent Bit配置中定义一个输出。我们将屏蔽主机和Splunk_token参数，并使用“tls”验证，以允许我们暂时跳过添加证书。<br/>我们还在Splunk中为属于<a class="ae jc" href="https://kubernetes.io/docs/home/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群的应用程序配置了每个命名空间的动态索引创建。</p><h1 id="bc5f" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">挑战</h1><p id="6064" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">为了Kubernetes的稳定运行，我们需要通过从所有应用程序/pod/容器/作业等收集日志信息来捕获正在运行的应用程序中发生的事件。由于在Kubernetes上运行的应用程序基于Docker容器，因此需要考虑日志记录:</p><ul class=""><li id="5e93" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">日志信息本地存储在主机操作系统中，没有相关的Kubernetes元数据，如名称空间、pod名称、标签和注释名称。</li><li id="8d17" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">当容器被终止时，日志信息被删除。Kubernetes通过执行“kubectl logs”命令提供了捕获日志消息的本机功能，但在高度扩展和分布式环境中无法工作。这就是流畅比特的发挥作用的地方；Fluent Bit通过Kubernetes元数据帮助您集中运行应用程序的日志信息，并将信息路由到期望的目的地，如Splunk。在本文中，我们将分享Fluent Bit是如何工作的，例如，Kubernetes和Splunk，动态索引创建，索引映射，对Splunk配置的多集群支持。</li><li id="1a6c" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">我们可以在<a class="ae jc" href="https://kubernetes.io/docs/concepts/cluster-administration/logging/" rel="noopener ugc nofollow" target="_blank">日志架构</a>中了解更多关于Kubernetes的日志概念。</li><li id="cf9c" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">基于标签或注释的多租户Splunk集群上应用程序的动态索引映射。</li><li id="bccc" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">在Splunk集群上创建命名空间时的动态索引创建。</li><li id="9737" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">应用团队专用Splunk集群的动态流程。</li></ul><h1 id="f091" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">流利比特是如何工作的</h1><p id="d892" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">Fluent Bit提供了“Fluent Bit DaemonSet”，使您能够轻松地从容器化的应用程序中收集日志信息。使用DaemonSet，您可以确保所有(或一些)节点运行一个pod的副本。Fluent Bit提供了<a class="ae jc" href="https://docs.fluentbit.io/manual/pipeline/filters/kubernetes" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>过滤器插件，通过添加带有Kubernetes元数据的记录来丰富pod日志信息。这样，我们可以识别日志信息的来源，并通过标记记录轻松过滤信息。我们可以在<a class="ae jc" href="https://docs.fluentbit.io/manual/" rel="noopener ugc nofollow" target="_blank">流畅钻头文档</a>中了解更多关于流畅钻头DaemonSet的信息。我们可以在<a class="ae jc" href="https://github.com/fluent/fluent-bit" rel="noopener ugc nofollow" target="_blank">为Kubernetes </a>找到用于部署的Fluent Bit DaemonSet容器映像和示例配置文件。</p><h1 id="f508" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">Splunk上的动态索引创建</h1><p id="d747" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">由于我们有多租户集群，我们要求应用程序将应用程序日志保存到其专用的Splunk索引和集群中。<br/>因此，我们使用JSON Store和Lua为fluent bit配置添加了动态索引创建和映射支持。<br/>在创建名称空间的时候(通过API发生)，我们已经注入了一个新的API来将索引数据推送到所有Kubernetes集群的专用JSON存储中。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/0f5807bf8e66b9f7decb992224441c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LY19a9MO__syupHe0IvEeA.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Splunk index store for dynamic creation</figcaption></figure><p id="ae1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Splunk索引的默认配置，以后的应用程序可以通过ansible行动手册或API更新属性，以便在JSON商店中进行更新。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="50b4" class="lp je hh ll b fi lq lr l ls lt"><br/>{<br/>  "name": "splunk-test",<br/>  "delete": 1,<br/>  "cluster-id": "splunk-1",<br/>  "misc_props": [<br/>    {<br/>      "value": 1,<br/>      "attribute": "maxWarmDBCount"<br/>    },<br/>    {<br/>      "value": 1000,<br/>      "attribute": "maxTotalDataSizeMB"<br/>    },<br/>    {<br/>      "value": 604800,<br/>      "attribute": "maxHotSpanSecs"<br/>    },<br/>    {<br/>      "value": 1209600,<br/>      "attribute": "frozenTimePeriodInSecs"<br/>    }<br/>  ],<br/>  "maxDataSize": "auto",<br/>  "maxHotBuckets": 1<br/>}</span><span id="983a" class="lp je hh ll b fi lu lr l ls lt">{% for index in splunk_index | default(default_indexes) %}<br/>{% if index.delete is not defined and index.deleteProd is not defined %}<br/># Adding index {{index.name}}<br/>[{{index.name}}]<br/>{% if index.internal is not defined or index.internal!=true %}<br/>repFactor = auto<br/>homePath = {{volume_dirs.1}}/{{ index.name }}/db<br/>coldPath = {{volume_dirs.2}}/{{ index.name }}/colddb<br/>thawedPath = $SPLUNK_DB/{{ index.name }}/thaweddb<br/>maxDataSize = {{ index.maxDataSize | default(default_maxDataSize) }}<br/>maxHotBuckets = {{ index.maxHotBuckets | default(default_maxHotBuckets) }}<br/>{% endif %}<br/>{% if index.datatype is defined %}<br/>datatype = {{index.datatype}}<br/>{% endif %}<br/>{% if index.misc_props is defined %}<br/>{% for prop in index.misc_props %}<br/>{{ prop.attribute }} = {{ prop.value }}<br/>{% endfor %}<br/>{% endif %}<br/>{% endif %}<br/>{% endfor %}</span></pre><p id="9486" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Splunk cluster-master上创建index.conf后，我们将有一个角色配置来应用集群捆绑包。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="9128" class="lp je hh ll b fi lq lr l ls lt">- name: apply cluster-bundle<br/>  become: true<br/>  become_user: "{{splunk_user_name}}"<br/>  command: "{{splunk_install_dir}}/splunk/bin/splunk apply cluster-bundle --answer-yes -auth {{web_username}}:{{web_password}}"</span></pre><h1 id="0fcd" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">使用Splunk记录日志</h1><p id="4175" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">让我们通过Splunk的一个用例来看看Fluent Bit在Kubernetes中是如何工作的。在本例中，我们部署了应用程序单元和服务，并查看了Fluent Bit如何处理日志消息，以及如何使用Splunk可视化日志消息。通过这个例子，我们可以了解Kubernetes日志记录中流畅的Bit行为以及如何入门。下图描述了示例用例的概述。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lv"><img src="../Images/e0673a4e7ffba0ca0f5de880954ae703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FsIFvavglThcuWPTO6bAFA.png"/></div></div></figure><p id="969b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们使用内部Splunk。</p><p id="7222" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们在下面看到的，Fluent Bit在日志命名空间中被配置为daemonset。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="a99e" class="lp je hh ll b fi lq lr l ls lt">a0d00qf@m-c02dj3hfmd6n ~ % kubectl get ds -n logging<br/>NAME         DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE<br/>fluent-bit   12        12        12      12           12          &lt;none&gt;          27h<br/>a0d00qf@m-c02dj3hfmd6n ~ %<br/>a0d00qf@m-c02dj3hfmd6n ~ % kubectl get nodes<br/>NAME                                 STATUS   ROLES        AGE    VERSION<br/>cp2-scus-dev-amls01-vmss000000       Ready    master       348d   v1.18.18<br/>cp2-scus-dev-amls01-vmss000001       Ready    master       348d   v1.18.18<br/>cp2-scus-dev-amls01-vmss000002       Ready    master       348d   v1.18.18<br/>etcd2-scus-dev-amls01-vmss000000     Ready    etcd         348d   v1.18.18<br/>etcd2-scus-dev-amls01-vmss000001     Ready    etcd         348d   v1.18.18<br/>etcd2-scus-dev-amls01-vmss000002     Ready    etcd         348d   v1.18.18<br/>istio2-scus-dev-amls01-vmss00001d    Ready    istio,node   64d    v1.18.18<br/>istio2-scus-dev-amls01-vmss00001f    Ready    istio,node   64d    v1.18.18<br/>istio2-scus-dev-amls01-vmss00001g    Ready    istio,node   64d    v1.18.18<br/>worker2-scus-dev-amls01-vmss000017   Ready    node         64d    v1.18.18<br/>worker2-scus-dev-amls01-vmss000018   Ready    node         64d    v1.18.18<br/>worker2-scus-dev-amls01-vmss00001a   Ready    node         64d    v1.18.18<br/>a0d00qf@m-c02dj3hfmd6n ~ %</span></pre><p id="4323" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下是Fluent位配置图中Splunk输出的配置。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="e5fc" class="lp je hh ll b fi lq lr l ls lt">[OUTPUT]<br/>        Name       splunk<br/>        Match       loggingApp1<br/>        host       splunk-1.xyz.net<br/>        port       80<br/>        Retry_Limit 3<br/>        Splunk_Send_Raw On<br/>        splunk_token e42f79e4-xxxx-xxxx-xxxx-xxxx-xxx<br/>        tls false<br/>        tls.verify false<br/>        Alias App1<br/>        net.keepalive true<br/>        net.keepalive_idle_timeout 5<br/>        net.keepalive_max_recycle 12096<br/>        net.connect_timeout 30<br/>[OUTPUT]<br/>        Name       splunk<br/>        Match       loggingApp2<br/>        host       splunk-2.xyz.net<br/>        port       80<br/>        Retry_Limit 3<br/>        Splunk_Send_Raw On<br/>        splunk_token e42f79e4-yyyy-xxxx-yyyy-xxxx-xxx<br/>        tls false<br/>        tls.verify false<br/>        Alias App2<br/>        net.keepalive true<br/>        net.keepalive_idle_timeout 5<br/>        net.keepalive_max_recycle 12096<br/>        net.connect_timeout 30</span></pre><p id="277b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如本文前面提到的，我们有一个动态的索引映射，它依赖于事件标签的post-Kubernetes过滤器(添加到事件中的post元数据)。我们已经配置了Lua脚本来读取和映射标签。Lua脚本将把key (index)和value作为标签值插入到每个事件的index字段中。<br/>如果应用程序没有为Splunk索引设置任何标签，Lua脚本会将其配置为将名称索引到名称空间名称。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="13c3" class="lp je hh ll b fi lq lr l ls lt">[FILTER]<br/>    Name                kubernetes<br/>    Match              loggingApp.*<br/>    Kube_URL            <a class="ae jc" href="https://kubernetes.default.svc:443" rel="noopener ugc nofollow" target="_blank">https://kubernetes.default.svc:443</a><br/>    Kube_CA_File        /var/run/secrets/kubernetes.io/serviceaccount/ca.crt<br/>    Kube_Token_File     /var/run/secrets/kubernetes.io/serviceaccount/token<br/>    Annotations Off<br/>    Merge_Log      On<br/>    Merge_log_key       log<br/>    K8S-Logging.Exclude On<br/>    Keep_Log false<br/>[FILTER]<br/>    Name rewrite_tag<br/>    Match loggingApp.*<br/>    Emitter_Mem_Buf_Limit 1G<br/>    Emitter_Name kube<br/>    Alias emiiter_kube<br/>    Rule $event['kubernetes']['labels']['splunk-cluster'] ^([(a-z)(A-Z)(0-9)]+)$ $event['kubernetes']['labels']['splunk-cluster'] false<br/>[FILTER]<br/>    Name      lua<br/>    Match      kube.*<br/>    script rename_index.lua #name to a script in ConfigMap<br/>    Protected_mode true<br/>    call splunk_index</span></pre><p id="8003" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">索引映射的Lua函数:</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="110b" class="lp je hh ll b fi lq lr l ls lt">function splunk_index(tag, timestamp, record)<br/>  local updated_log = {}local k8s_metadata<br/>  local extracted_value = ""<br/>  log = record<br/>  if type(log) == 'table'<br/>  then<br/>    k8s_metadata = log["kubernetes"]<br/>    if type(k8s_metadata) == 'table'<br/>    then<br/>      extrLabels = k8s_metadata["labels"]<br/>      if (extrLabels ~= nil)<br/>      then<br/>        extracted_label = k8s_metadata["labels"]["splunk-index"]<br/>        if (extracted_label ~= nil)<br/>        then<br/>          new_index = extracted_label<br/>          updated_log = log<br/>          updated_log["index"] = new_index<br/>        else<br/>          extracted_value = k8s_metadata["namespace_name"]<br/>          extracted_value = .. extracted_value<br/>          updated_log = log<br/>          updated_log["index"] = extracted_value<br/>        end<br/>      else<br/>        extracted_value = k8s_metadata["namespace_name"]<br/>        extracted_value = .. extracted_value<br/>        updated_log = log<br/>        updated_log["index"] = extracted_value<br/>      end<br/>    else<br/>      return -1, timestamp, updated_log<br/>    end<br/>  else<br/>    return -1, timestamp, updated_log<br/>  end<br/>return 2, timestamp, updated_log<br/>end</span></pre><p id="06ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在配置中，如我们所见，我们使用了重写标记过滤器，这是为了根据标签中提供的Splunk群集配置重写标记，通过该过滤器，我们将通过支持具有动态映射的多Splunk群集日志记录，将日志转发到指定的Splunk群集。</p><pre class="kv kw kx ky fd lk ll lm ln aw lo bi"><span id="1a85" class="lp je hh ll b fi lq lr l ls lt">[FILTER]<br/>    Name rewrite_tag<br/>    Match loggingApp.*<br/>    Emitter_Mem_Buf_Limit 1G<br/>    Emitter_Name kube<br/>    Alias emiiter_kube<br/>    Rule $event['kubernetes']['labels']['splunk-cluster'] ^([(a-z)(A-Z)(0-9)]+)$ $event['kubernetes']['labels']['splunk-cluster'] false</span></pre><h1 id="aa9b" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">在Splunk中检查事件</h1><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lw"><img src="../Images/0628ce63e3845c0bc29b709734ca6e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzsrMnLkBNwWrbxEorYUQQ.png"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx">Sample event in Splunk</figcaption></figure><h1 id="9d49" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">限制</h1><ol class=""><li id="6a4d" class="kg kh hh ig b ih kb il kc ip lx it ly ix lz jb ma km kn ko bi translated">Splunk支持有限数量的索引，具体取决于群集的大小和运行状况。</li><li id="7ddf" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb ma km kn ko bi translated">长时间运行后创建动态索引可能会导致Splunk群集不稳定。为了减轻这种情况，我们可以设置每个集群固定的索引数量，如果需要，我们将添加一个带有索引器的新集群主服务器，以支持在同一个搜索头下创建新的索引。</li><li id="d6f3" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb ma km kn ko bi translated">如果Splunk群集和索引的数量增加，Fluent Bit可能会由于过滤器的数量而出现资源问题和性能影响。</li><li id="0c69" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb ma km kn ko bi translated">事件格式和大小也会影响流畅的Bit性能。</li></ol><h1 id="1ced" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="6a40" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">这篇文章展示了如何将Fluent Bit配置为通过Splunk索引和集群的动态映射将日志发送到多个Splunk集群和Splunk索引。</p></div></div>    
</body>
</html>