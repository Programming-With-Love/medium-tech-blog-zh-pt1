<html>
<head>
<title>#SmallerAPK, Part 5: Multi-APK through product flavors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">#SmallerAPK，第5部分:产品风味的多重APK</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/smallerapk-part-5-multi-apk-through-product-flavors-e069759f19cd?source=collection_archive---------5-----------------------#2016-02-19">https://medium.com/androiddevelopers/smallerapk-part-5-multi-apk-through-product-flavors-e069759f19cd?source=collection_archive---------5-----------------------#2016-02-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/16742a27007b85054b45771a39fbd376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6OvLVi-G5Ldze7Novm7M0w.jpeg"/></div></div></figure><div class=""/><p id="4d37" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<a class="ae jn" rel="noopener" href="/@wkalicinski/smallerapk-part-4-multi-apk-through-abi-and-density-splits-477083989006">之前的文章</a>中，我解释了如何在Android Studio中使用<em class="jo">分割</em>机制来创建基于ABI和密度的多APK。还有另一种更灵活的方法来为你的应用程序创建多APK配置，那就是使用产品风格。首先，快速回顾一下<a class="ae jn" href="http://developer.android.com/tools/building/configuring-gradle.html#workBuildVariants" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="jp jq jr"><p id="a4df" class="ip iq jo ir b is it iu iv iw ix iy iz js jb jc jd jt jf jg jh ju jj jk jl jm ha bi translated">构建系统使用产品风格来创建应用程序的不同产品版本。您的应用程序的每个产品版本可以有不同的功能或设备要求。</p></blockquote><p id="d58d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这似乎正是我们多APK所需要的！通过对不同风格的清单和资源进行小的更改，您可以从单个项目中获得许多版本(我们称之为构建变体)的应用程序。</p><p id="e016" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">实际上，使用香料来再造分裂是可能的。我们可以为每个密度桶创建一个风格，并使用<a class="ae jn" href="http://google.github.io/android-gradle-dsl/current/com.android.build.gradle.internal.dsl.ProductFlavor.html#com.android.build.gradle.internal.dsl.ProductFlavor:resConfigs(java.lang.String[])" rel="noopener ugc nofollow" target="_blank"> <em class="jo"> resConfigs </em> </a>选项来指定应该为每个风格保留哪些可抽牌。</p><blockquote class="jp jq jr"><p id="22ae" class="ip iq jo ir b is it iu iv iw ix iy iz js jb jc jd jt jf jg jh ju jj jk jl jm ha bi translated"><strong class="ir ht">注意</strong>:从构建工具v21开始，resConfigs的行为已经改变。您只能指定<strong class="ir ht">一个</strong>密度桶，AAPT工具将自动计算出哪些抽屉需要进入APK。为一个变量指定多个密度桶是错误的。</p></blockquote><h2 id="a8a3" class="jv jw hs bd jx jy jz ka kb kc kd ke kf ja kg kh ki je kj kk kl ji km kn ko kp bi translated">Build.gradle</h2><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="65c6" class="jv jw hs kv b fi kz la l lb lc">android {<br/>    ...<br/>    productFlavors {<br/>        xhdpi {<br/>            resConfigs "xhdpi"<br/>            versionCode 300001<br/>        }<br/>        hdpi {<br/>            resConfigs "hdpi"<br/>            versionCode 200001<br/>        }<br/>        mdpi {<br/>            resConfigs "mdpi"<br/>            versionCode 100001<br/>        }<br/>        anydpi {<br/>            versionCode 1<br/>        }<br/>    }<br/>}</span></pre><p id="1aa0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，在<em class="jo">app/src/[flavor name]/androidmanifest . XML</em>下为每种风格创建一个新的<em class="jo"> AndroidManifest.xml </em>，并用正确的屏幕过滤指令填充它。因为我们是手动完成的，所以我们可以克服在<em class="jo">分割</em>中缺乏对数字密度桶的支持。您可以选择将它们与下一个更高的存储桶结合起来，例如，像下面的代码片段(<em class="jo"> xhdpi </em>是320 dpi屏幕的名称):</p><h2 id="da0c" class="jv jw hs bd jx jy jz ka kb kc kd ke kf ja kg kh ki je kj kk kl ji km kn ko kp bi translated">app/src/xhdpi/Android manifest . XML</h2><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="c7c3" class="jv jw hs kv b fi kz la l lb lc">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"&gt;<br/>&lt;compatible-screens&gt;<br/>&lt;screen android:screenSize="small" android:screenDensity="xhdpi” /&gt;<br/>&lt;screen android:screenSize="normal" android:screenDensity="xhdpi" /&gt;<br/>&lt;screen android:screenSize="large" android:screenDensity="xhdpi" /&gt;<br/>&lt;screen android:screenSize="xlarge" android:screenDensity="xhdpi" /&gt;</span><span id="e9f1" class="jv jw hs kv b fi ld la l lb lc">&lt;screen android:screenSize="small" android:screenDensity="280" /&gt;<br/>&lt;screen android:screenSize="normal" android:screenDensity="280" /&gt;<br/>&lt;screen android:screenSize="large" android:screenDensity="280" /&gt;<br/>&lt;screen android:screenSize="xlarge" android:screenDensity="280" /&gt;&lt;/compatible-screens&gt;<br/>&lt;/manifest&gt;</span></pre><p id="c791" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">记住还要构建和发布一个通用的(<em class="jo"> anydpi </em>风格，在上面的例子中)APK，没有额外的清单条目和最低的<em class="jo">版本代码</em>，以支持未来的设备。</p><h1 id="2bba" class="le jw hs bd jx lf lg lh kb li lj lk kf ll lm ln ki lo lp lq kl lr ls lt ko lu bi translated">基于MinSdkVersion的多APK</h1><p id="df33" class="pw-post-body-paragraph ip iq hs ir b is lv iu iv iw lw iy iz ja lx jc jd je ly jg jh ji lz jk jl jm ha bi translated">我将在#smallerAPK文章的后续章节中讨论的许多优化都依赖于新的压缩格式或矢量图像支持，这些只是在最近的Android版本中引入的。如果我们想利用这些优势，同时仍然保持与旧设备的兼容性，通常我们必须多次包含相同的资源。</p><p id="d52b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过使用flavors，我们可以创建多APK配置，而使用splits是不可能的。让我们考虑创建一个单独的应用程序版本，只针对较新的Android版本和一个支持旧设备的版本。</p><h2 id="9369" class="jv jw hs bd jx jy jz ka kb kc kd ke kf ja kg kh ki je kj kk kl ji km kn ko kp bi translated">Build.gradle</h2><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="3d73" class="jv jw hs kv b fi kz la l lb lc">android {<br/>    productFlavors {<br/>        prelollipop {<br/>            versionCode 1<br/>        }<br/>        lollipop {<br/>            minSdkVersion 21<br/>            versionCode 2<br/>        }<br/>    }<br/>}</span></pre><p id="7c58" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，通过将资源放置在<em class="jo">app/src/preroll pop/RES/</em>或<em class="jo"> app/src/lollipop/res </em>中，您可以控制每个版本将打包哪些文件，例如，您可以仅针对Android 5.0+版本包含您的<a class="ae jn" rel="noopener" href="/@wkalicinski/smallerapk-part-7-image-optimization-shape-and-vectordrawables-ed6be3dca3f#4cb7"> VectorDrawables </a>，针对lollipop之前的版本包含PNG/ <a class="ae jn" rel="noopener" href="/@wkalicinski/smallerapk-part-6-image-optimization-zopfli-webp-4c462955647d#2de9"> WebP </a>。</p><p id="f7e3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您需要二维或多维的产品风格，如屏幕密度和<em class="jo">最小版本</em>，您可以这样设置:</p><h2 id="f674" class="jv jw hs bd jx jy jz ka kb kc kd ke kf ja kg kh ki je kj kk kl ji km kn ko kp bi translated">Build.gradle</h2><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="d6b7" class="jv jw hs kv b fi kz la l lb lc">android {<br/>    ...<br/>    flavorDimensions “density”, “version”<br/>    productFlavors {<br/>        xhdpi {<br/>            dimension "density"<br/>            resConfigs "xhdpi"<br/>            versionCode 4<br/>        }</span><span id="040f" class="jv jw hs kv b fi ld la l lb lc">        //other densities here...</span><span id="b6a8" class="jv jw hs kv b fi ld la l lb lc">        anydpi {<br/>            dimension "density"<br/>            versionCode 1<br/>        }</span><span id="80e0" class="jv jw hs kv b fi ld la l lb lc">        prelollipop {<br/>            dimension "version"<br/>            versionCode 1<br/>        }<br/>        lollipop {<br/>            dimension "version"<br/>            minSdkVersion 21<br/>            versionCode 2<br/>        }<br/>    }<br/>}</span></pre><p id="b696" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这使得设置正确的版本号变得有点复杂，因为我们需要为每种组合风格计算版本号。请始终记住，可以安装在设备上的最高版本的APK(即匹配minSdkVersion和其他过滤器)始终从Play Store下载。你可以找到一个方便的脚本，你可以适应你的需要<a class="ae jn" href="http://tools.android.com/tech-docs/new-build-system/tips" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="2059" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，为了一些完全不同的东西… <a class="ae jn" rel="noopener" href="/@wkalicinski/smallerapk-part-6-image-optimization-zopfli-webp-4c462955647d">第6部分:图像优化，Zopfli &amp; WebP </a></p></div></div>    
</body>
</html>