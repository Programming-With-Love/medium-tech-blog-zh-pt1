<html>
<head>
<title>Create Your Own Java PubSub Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建自己的Java PubSub库</h1>
<blockquote>原文：<a href="https://medium.easyread.co/create-your-own-java-pubsub-library-fbee21d0bb44?source=collection_archive---------0-----------------------#2019-02-03">https://medium.easyread.co/create-your-own-java-pubsub-library-fbee21d0bb44?source=collection_archive---------0-----------------------#2019-02-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/5bf0263c51dce192d5856d91d98dbdd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*eyVWUDy9kDXVGDGv1Ev4iA.png"/></div></figure><p id="89c6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你听说过发布-订阅模式吗？你试过使用它吗？<br/>在<a class="ae kp" href="https://en.wikipedia.org/wiki/Software_architecture" rel="noopener ugc nofollow" target="_blank">软件架构</a>、<strong class="jt io">发布-订阅</strong>是一种消息传递模式，消息的发送者(称为发布者)不将消息直接发送给特定的接收者(称为订阅者)，而是将发布的消息分类，而不知道可能有哪些订阅者(如果有的话)。类似地，订阅者表达对一个或多个类别的兴趣，并且仅接收感兴趣的消息，而不知道存在哪些发布者(如果有的话)。我知道你一定对所有这些解释感到厌烦。因此，让我们立即讨论实施。</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/a140573c34e39a5c185508d88f094532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*8y3Z3b49SaLT1ziQRZcKlA.jpeg"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">People said Mark Zuckerberg drink alcohol while creating facebook</figcaption></figure><h1 id="032e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">编码时间</h1><p id="4021" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated">所以我们想建立一个简单的pubsub库。<br/>在此之前，我要解释一些术语:</p><ul class=""><li id="54a5" class="mc md in jt b ju jv jy jz kc me kg mf kk mg ko mh mi mj mk bi translated"><strong class="jt io"> Channel </strong>:表示可调用的订户集合的概念。</li><li id="9d73" class="mc md in jt b ju ml jy mm kc mn kg mo kk mp ko mh mi mj mk bi translated"><strong class="jt io">订阅者:</strong>代表消息的接收者</li><li id="5615" class="mc md in jt b ju ml jy mm kc mn kg mo kk mp ko mh mi mj mk bi translated"><strong class="jt io">发布者:</strong>代表消息的发送者</li></ul><p id="ddf6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这里我没有介绍多线程和消息队列。</p><p id="5187" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">感谢等待，这是我们强大而简单的pubsub:</p><pre class="kr ks kt ku gt mq mr ms mt aw mu bi"><span id="773a" class="mv la in mr b gy mw mx l my mz">import java.lang.ref.WeakReference;<br/>import java.util.concurrent.ConcurrentHashMap;<br/><br/>public class Event {<br/>    static {<br/>        <em class="na">init</em>();<br/>    }<br/><br/>    static Operation <em class="na">operation</em>;<br/><br/>    static ConcurrentHashMap&lt;String, ConcurrentHashMap&lt;Integer, WeakReference&lt;Object&gt;&gt;&gt; <em class="na">channels</em>;<br/><br/>    static void init() {<br/>        <em class="na">channels </em>= new ConcurrentHashMap&lt;&gt;();<br/>        <em class="na">operation </em>= new Operation();<br/>    }<br/>}</span></pre></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><pre class="mq mr ms mt aw mu bi"><span id="6475" class="mv la in mr b gy ni nj nk nl nm mx l my mz">import java.lang.annotation.Annotation;<br/>import java.lang.ref.WeakReference;<br/>import java.lang.reflect.Method;<br/>import java.util.Map;<br/>import java.util.concurrent.ConcurrentHashMap;<br/><br/>public class Operation extends Event {<br/>    void subscribe(String channelName, Object subscriber) {<br/>        if (!<em class="na">channels</em>.containsKey(channelName)) {<br/>            <em class="na">channels</em>.put(channelName, new ConcurrentHashMap&lt;&gt;());<br/>        }<br/><br/>        <em class="na">channels</em>.get(channelName).put(subscriber.hashCode(), new WeakReference&lt;&gt;(subscriber));<br/>    }<br/><br/>    void publish(String channelName, Post message) {<br/>        for(Map.Entry&lt;Integer, WeakReference&lt;Object&gt;&gt; subs : <em class="na">channels</em>.get(channelName).entrySet()) {<br/>            WeakReference&lt;Object&gt; subscriberRef = subs.getValue();<br/><br/>            Object subscriberObj = subscriberRef.get();<br/><br/>            for (final Method method : subscriberObj.getClass().getDeclaredMethods()) {<br/>                Annotation annotation = method.getAnnotation(OnMessage.class);<br/>                if (annotation != null) {<br/>                    deliverMessage(subscriberObj, method, message);<br/>                }<br/>            }<br/>        }<br/>    }<br/><br/>    &lt;T, P extends Post&gt; boolean deliverMessage(T subscriber, Method method, Post message) {<br/>        try {<br/>            boolean methodFound = false;<br/>            for (final Class paramClass : method.getParameterTypes()) {<br/>                if (paramClass.equals(message.getClass())) {<br/>                    methodFound = true;<br/>                    break;<br/>                }<br/>            }<br/>            if (methodFound) {<br/>                method.setAccessible(true);<br/>                method.invoke(subscriber, message);<br/>            }<br/><br/>            return true;<br/>        } catch (Exception e) {<br/>            e.printStackTrace();<br/>        }<br/><br/>        return false;<br/>    }<br/>}</span></pre></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><pre class="mq mr ms mt aw mu bi"><span id="b1ae" class="mv la in mr b gy ni nj nk nl nm mx l my mz">import java.lang.annotation.ElementType;<br/>import java.lang.annotation.Retention;<br/>import java.lang.annotation.RetentionPolicy;<br/>import java.lang.annotation.Target;<br/><br/>@Retention(RetentionPolicy.<em class="na">RUNTIME</em>)<br/>@Target(ElementType.<em class="na">METHOD</em>)<br/>public @interface OnMessage {<br/>}</span></pre></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><pre class="mq mr ms mt aw mu bi"><span id="5c01" class="mv la in mr b gy ni nj nk nl nm mx l my mz">abstract class Post {<br/>    String message;<br/><br/>    Post(String message) {<br/>        this.message = message;<br/>    }<br/>}</span></pre></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="c634" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如何使用所有这些代码？下面是用法示例:</p><p id="9e77" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您应该创建一个订户类。这样你就能收到发布的消息。非常简单，只需将OnMessage注释放在方法上。</p><pre class="kr ks kt ku gt mq mr ms mt aw mu bi"><span id="650b" class="mv la in mr b gy mw mx l my mz">class Subscriber {<br/>    int id;<br/>    public Subscriber(int id) {<br/>        this.id = id;<br/>    }<br/><br/>    @OnMessage<br/>    private void onMessage(Message message) {<br/>        System.<em class="na">out</em>.println(message.message);<br/>    }<br/>}</span></pre><p id="3d8c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后，您需要创建一个表示您发送的消息的类。</p><pre class="kr ks kt ku gt mq mr ms mt aw mu bi"><span id="7de9" class="mv la in mr b gy mw mx l my mz">class Message extends Post {<br/>    String message;<br/><br/>    public Message(String message) {<br/>        super(message);<br/>    }<br/>}</span></pre><p id="d622" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">初始化subscriber类，这样就可以拥有一个subscriber对象。</p><pre class="kr ks kt ku gt mq mr ms mt aw mu bi"><span id="7cac" class="mv la in mr b gy mw mx l my mz">Subscriber subscriber = new Subscriber(1);<br/>Subscriber subscriber2 = new Subscriber(2);<br/><br/>Subscriber subscriber3 = new Subscriber(3);<br/>Subscriber subscriber4 = new Subscriber(4);<br/></span></pre><p id="bf95" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">使用subscriber对象订阅特定的频道。假设您订阅了3个不同频道，每个频道有不同的订户。</p><pre class="kr ks kt ku gt mq mr ms mt aw mu bi"><span id="5708" class="mv la in mr b gy mw mx l my mz">Event.<em class="na">operation</em>.subscribe("action#create", subscriber);<br/>Event.<em class="na">operation</em>.subscribe("action#create", subscriber2);<br/><br/>Event.<em class="na">operation</em>.subscribe("action#update", subscriber3);<br/>Event.<em class="na">operation</em>.subscribe("action#delete", subscriber4);<br/></span></pre><p id="79d0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后创建一个消息对象并发布它。</p><pre class="kr ks kt ku gt mq mr ms mt aw mu bi"><span id="09b6" class="mv la in mr b gy mw mx l my mz">Message message = new Message("Create Action");<br/>Message message2 = new Message("Update Action");<br/><br/>Event.<em class="na">operation</em>.publish("action#create", message);<br/>Event.<em class="na">operation</em>.publish("action#update", message2);</span></pre><h1 id="6c0e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">魔法是如何运作的？</h1><p id="3884" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated">我只是使用一个简单的ConcurrentHashMap来存储频道。每个频道将包含不止一个用户。</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/d1203dd4c91a3dca56454eb018398832.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*yL442HcOzp72L6hBrEIYFA.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">The illustration of ConcurrentHashMap of channel and subscriber</figcaption></figure><p id="e227" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当您订阅特定频道时，订阅者对象引用将与该频道配对。假设您将3个subscribe对象订阅到通道a中，情况如下:</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/2c2c2d22fcb1d12f010d0cba981aab01.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*C4ZfsoZmAFIa0uL0Ig3Nag.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">When you try to subscribe into a Channel with 3 subscriber object</figcaption></figure><p id="2a04" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Publish是一个功能，它通过查找存储在特定通道中的所有订户对象，并使用订户对象引用来调用它。假设你在b频道发布了一条消息，大概是这样的:</p><figure class="kr ks kt ku gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/3bb12c8cc6578d4d01c587ad9ec39fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cnlIFMEjaeIG-9_QK0JQcg.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">When you try to publish into specific channel</figcaption></figure><p id="f9a1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">上图与该类相关:</p><pre class="kr ks kt ku gt mq mr ms mt aw mu bi"><span id="a6f6" class="mv la in mr b gy mw mx l my mz">import java.lang.annotation.Annotation;<br/>import java.lang.ref.WeakReference;<br/>import java.lang.reflect.Method;<br/>import java.util.Map;<br/>import java.util.concurrent.ConcurrentHashMap;<br/><br/>public class Operation extends Event {<br/>    .........<br/>    void publish(String channelName, Post message) {<br/>        for(Map.Entry&lt;Integer, WeakReference&lt;Object&gt;&gt; subs : <em class="na">channels</em>.get(channelName).entrySet()) {<br/>            WeakReference&lt;Object&gt; subscriberRef = subs.getValue();<br/><br/>            Object subscriberObj = subscriberRef.get();<br/><br/>            for (final Method method : subscriberObj.getClass().getDeclaredMethods()) {<br/>                Annotation annotation = method.getAnnotation(OnMessage.class);<br/>                if (annotation != null) {<br/>                    deliverMessage(subscriberObj, method, message);<br/>                }<br/>            }<br/>        }<br/>    }<br/><br/>    &lt;T, P extends Post&gt; boolean deliverMessage(T subscriber, Method method, Post message) {<br/>        try {<br/>            boolean methodFound = false;<br/>            for (final Class paramClass : method.getParameterTypes()) {<br/>                if (paramClass.equals(message.getClass())) {<br/>                    methodFound = true;<br/>                    break;<br/>                }<br/>            }<br/>            if (methodFound) {<br/>                method.setAccessible(true);<br/>                method.invoke(subscriber, message);<br/>            }<br/><br/>            return true;<br/>        } catch (Exception e) {<br/>            e.printStackTrace();<br/>        }<br/><br/>        return false;<br/>    }<br/>}</span></pre><h1 id="9183" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">结论</strong></h1><p id="1ca4" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated">构建一个真正简单的发布-订阅模式真的很容易，你甚至可以毫不费力地扩展它。事实上，我创造了这个。我把它叫做<a class="ae kp" href="https://github.com/jonathannatanaelsiahaan/jnrx" rel="noopener ugc nofollow" target="_blank"> jnrx </a>。运行在android平台上。将来我会让它在iOS和JavaScript平台上运行。</p><h1 id="3d83" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">由于</h1><p id="9948" class="pw-post-body-paragraph jr js in jt b ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko ig bi translated">感谢我的猫和我的两个朋友，<a class="ae kp" href="https://www.facebook.com/hierony.manurung" rel="noopener ugc nofollow" target="_blank"> Hierony </a>和<a class="ae kp" href="https://www.facebook.com/pandu.siregar" rel="noopener ugc nofollow" target="_blank"> Pandu </a>，他们总是支持我开源项目的每一项工作。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><figure class="kr ks kt ku gt jo"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div></div>    
</body>
</html>