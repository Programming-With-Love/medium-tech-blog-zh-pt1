<html>
<head>
<title>Trying Clean Architecture on Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang尝试干净的建筑</h1>
<blockquote>原文：<a href="https://medium.easyread.co/golang-clean-archithecture-efd6d7c43047?source=collection_archive---------0-----------------------#2017-07-07">https://medium.easyread.co/golang-clean-archithecture-efd6d7c43047?source=collection_archive---------0-----------------------#2017-07-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="091f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">独立的、可测试的和干净的</h2></div><p id="d949" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在阅读了鲍勃大叔的清洁建筑概念后，我正试图在Golang中实现它。这是我们公司使用的类似架构，<a class="ae ky" href="https://kurio.co.id/" rel="noopener ugc nofollow" target="_blank"><strong class="ke io">Kurio-App Berita Indonesi</strong></a><strong class="ke io">a，</strong>但结构略有不同。没有太大的不同，相同的概念，但不同的文件夹结构。</p><p id="8717" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在这里找到一个示例项目<a class="ae ky" href="https://github.com/bxcodec/go-clean-arch" rel="noopener ugc nofollow" target="_blank">https://github.com/bxcodec/go-clean-arch</a>，一篇示例CRUD管理文章。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/391b1a085927c7ca2dbb553413ea39b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CyteJRpIHC-DFE23UtlZfQ.png"/></div></div></figure><ul class=""><li id="61cf" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx lq lr ls lt bi translated">免责声明:<br/>我不推荐这里使用的任何库或框架。你可以用你自己的或第三方的具有相同功能的东西来替换这里的任何东西。</li></ul><h1 id="4e99" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">基础</h1><p id="31b7" class="pw-post-body-paragraph kc kd in ke b kf mm jo kh ki mn jr kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">正如我们所知，设计干净架构之前的约束条件是:</p><ol class=""><li id="03f2" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx mr lr ls lt bi translated">独立于框架。该体系结构不依赖于某些功能丰富的软件库的存在。这允许您将这样的框架用作工具，而不是将您的系统塞进它们有限的约束中。</li><li id="d14f" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx mr lr ls lt bi translated">可测试。可以在没有UI、数据库、Web服务器或任何其他外部元素的情况下测试业务规则。</li><li id="8bcf" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx mr lr ls lt bi translated">独立于UI。用户界面可以很容易地改变，而不需要改变系统的其他部分。例如，Web用户界面可以用控制台用户界面代替，而不需要改变业务规则。</li><li id="6585" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx mr lr ls lt bi translated">独立于数据库。您可以将Oracle或SQL Server换成Mongo、BigTable、CouchDB或其他。您的业务规则没有绑定到数据库。</li><li id="35b6" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx mr lr ls lt bi translated">独立于任何外部机构。实际上，你的商业规则根本就对外界一无所知。</li></ol><p id="ec8f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更多信息请访问<a class="ae ky" href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">https://8 thlight . com/blog/uncle-bob/2012/08/13/the-clean-architecture . html</a></p><p id="9799" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，基于这个约束，每一层都必须是独立的和可测试的。</p><p id="3075" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果鲍勃叔叔的建筑有4层:</p><ul class=""><li id="f866" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx lq lr ls lt bi translated">实体</li><li id="58b4" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">用例</li><li id="01d5" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">控制器</li><li id="4e36" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">框架和驱动程序</li></ul><p id="825e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的项目中，我也使用4:</p><ul class=""><li id="1746" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx lq lr ls lt bi translated">模型</li><li id="b86c" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">贮藏室ˌ仓库</li><li id="e1cc" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">用例</li><li id="9987" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">交付</li></ul><h2 id="3056" class="mx lv in bd lw my mz dn ma na nb dp me kl nc nd mg kp ne nf mi kt ng nh mk ni bi translated"><strong class="ak">型号</strong></h2><p id="4321" class="pw-post-body-paragraph kc kd in ke b kf mm jo kh ki mn jr kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">与实体相同，它将用于所有层。这一层将存储任何对象的结构及其方法。例子:文章，学生，书。<br/>示例结构:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="0458" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">任何实体或模型都将存储在这里。</p><h2 id="dc69" class="mx lv in bd lw my mz dn ma na nb dp me kl nc nd mg kp ne nf mi kt ng nh mk ni bi translated"><strong class="ak">储存库</strong></h2><p id="cd7a" class="pw-post-body-paragraph kc kd in ke b kf mm jo kh ki mn jr kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">存储库将存储任何数据库处理程序。查询，或创建/插入任何数据库将存储在这里。这一层将只作为数据库的CRUD。这里没有业务流程发生。只有普通的数据库功能。</p><p id="e0ca" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这一层还负责选择DB将在应用程序中使用什么。可能是Mysql，MongoDB，MariaDB，Postgresql什么的，在这里决定。</p><p id="c9cc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果使用ORM，这一层将控制输入，并将它直接提供给ORM服务。</p><p id="0b48" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果调用微服务，会在这里处理。为其他服务创建HTTP请求，并整理数据。这一层必须完全充当存储库。处理所有数据输入输出没有特定的逻辑发生。</p><p id="64cd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该存储库层将依赖于连接的数据库或其他微服务(如果存在)。</p><h2 id="15e0" class="mx lv in bd lw my mz dn ma na nb dp me kl nc nd mg kp ne nf mi kt ng nh mk ni bi translated"><strong class="ak">用例</strong></h2><p id="8453" class="pw-post-body-paragraph kc kd in ke b kf mm jo kh ki mn jr kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">这一层将充当业务流程处理程序。任何流程都会在这里处理。这一层将决定使用哪个存储库层。并且有责任提供用于交付的数据。处理数据，做计算或任何事情都会在这里完成。</p><p id="7408" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用例层将接受来自交付层的任何输入，这些输入已经被清理，然后处理输入，可以存储到数据库中，或者从数据库中提取，等等。</p><p id="f439" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个用例层将依赖于存储库层</p><h2 id="f25e" class="mx lv in bd lw my mz dn ma na nb dp me kl nc nd mg kp ne nf mi kt ng nh mk ni bi translated"><strong class="ak">交货</strong></h2><p id="fc0c" class="pw-post-body-paragraph kc kd in ke b kf mm jo kh ki mn jr kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">这一层将作为演示者。决定数据将如何呈现。可以是REST API、HTML文件或gRPC，无论交付类型如何。<br/>这一层也将接受来自用户的输入。净化输入，并将其发送到用例层。</p><p id="53db" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于我的示例项目，我使用REST API作为交付方法。<br/>客户端通过网络调用资源端点，交付层获取输入或请求，并发送给用例层。</p><p id="c1d3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该层将取决于用例层。</p><h2 id="21a3" class="mx lv in bd lw my mz dn ma na nb dp me kl nc nd mg kp ne nf mi kt ng nh mk ni bi translated"><strong class="ak">层间通信</strong></h2><p id="eb2d" class="pw-post-body-paragraph kc kd in ke b kf mm jo kh ki mn jr kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">除了模型之外，每一层都将通过一个接口进行通信。例如，Usecase层需要Repository层，那么它们如何通信呢？存储库将提供一个接口作为它们的契约和通信。</p><p id="f256" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">存储库界面示例</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a03b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用例层将使用此契约与存储库通信，存储库层<strong class="ke io">必须</strong>实现此接口，以便用例可以使用</p><p id="9424" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用例的接口示例</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="41b5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与用例相同，交付层将使用这个契约接口。并且用例层<strong class="ke io">必须</strong>实现这个接口。</p><h1 id="8444" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated"><strong class="ak">测试各层</strong></h1><p id="da79" class="pw-post-body-paragraph kc kd in ke b kf mm jo kh ki mn jr kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">我们知道，干净意味着独立。每一层都是可测试的，即使其他层还不存在。</p><ul class=""><li id="149d" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx lq lr ls lt bi translated">模型层<br/>该层仅测试是否在任何结构中声明了任何函数/方法。<br/>并能方便独立地对其他层进行测试。</li><li id="8b02" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">为了测试这一层，更好的方法是进行集成测试。但是你也可以对每个测试进行模仿。我使用github.com/DATA-DOG/go-sqlmock作为我的助手来模拟查询过程msyql。</li><li id="daff" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">用例<br/>因为这一层依赖于存储库层，意味着这一层需要一个存储库层来进行测试。因此，我们必须基于之前定义的契约接口，制作一个库<br/>的模型，该库使用mocking进行模拟。</li><li id="4b82" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">交付<br/>与用例相同，因为这一层依赖于用例层，意味着我们需要用例层进行测试。基于之前定义的契约接口，用例层也必须被嘲弄</li></ul><p id="63b3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于嘲讽，我用vektra的《嘲讽戈朗》可以在这里看到<a class="ae ky" href="https://github.com/vektra/mockery" rel="noopener ugc nofollow" target="_blank">https://github.com/vektra/mockery</a></p><h2 id="dc60" class="mx lv in bd lw my mz dn ma na nb dp me kl nc nd mg kp ne nf mi kt ng nh mk ni bi translated"><strong class="ak">储存库测试</strong></h2><p id="60f2" class="pw-post-body-paragraph kc kd in ke b kf mm jo kh ki mn jr kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">如前所述，为了测试这一层，我使用sql-mock来模拟我的查询过程。你可以用像我在这里所用的github.com/DATA-DOG/go-sqlmock，或另一个有类似功能的</p><pre class="la lb lc ld gt nl nm nn no aw np bi"><span id="1e4f" class="mx lv in nm b gy nq nr l ns nt">func TestGetByID(t *testing.T) {<br/> db, mock, err := sqlmock.New() <br/> if err != nil { <br/>    t.Fatalf(“an error ‘%s’ was not expected when opening a stub  <br/>        database connection”, err) <br/>  } </span><span id="ab0c" class="mx lv in nm b gy nu nr l ns nt"> defer db.Close() <br/> rows := sqlmock.NewRows([]string{<br/>        “id”, “title”, “content”, “updated_at”, “created_at”}).   <br/>        AddRow(1, “title 1”, “Content 1”, time.Now(), time.Now()) </span><span id="378c" class="mx lv in nm b gy nu nr l ns nt"> query := “SELECT id,title,content,updated_at, created_at FROM <br/>          article WHERE ID = \\?” </span><span id="84e8" class="mx lv in nm b gy nu nr l ns nt"> mock.ExpectQuery(query).WillReturnRows(rows) </span><span id="505f" class="mx lv in nm b gy nu nr l ns nt"> a := articleRepo.NewMysqlArticleRepository(db) </span><span id="6431" class="mx lv in nm b gy nu nr l ns nt"> num := int64(1) </span><span id="20ec" class="mx lv in nm b gy nu nr l ns nt"> anArticle, err := a.GetByID(num) </span><span id="4594" class="mx lv in nm b gy nu nr l ns nt"> assert.NoError(t, err) <br/> assert.NotNil(t, anArticle)<br/>}</span></pre><h2 id="ef35" class="mx lv in bd lw my mz dn ma na nb dp me kl nc nd mg kp ne nf mi kt ng nh mk ni bi translated"><strong class="ak">用例测试</strong></h2><p id="2ce1" class="pw-post-body-paragraph kc kd in ke b kf mm jo kh ki mn jr kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">用例层的示例测试，依赖于存储库层。</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f9ba" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嘲弄将为我生成一个存储库层的模型。所以我不需要先完成我的存储库层。我可以先完成我的用例，即使我的存储库层还没有实现。</p><h2 id="26a7" class="mx lv in bd lw my mz dn ma na nb dp me kl nc nd mg kp ne nf mi kt ng nh mk ni bi translated"><strong class="ak">交付测试</strong></h2><p id="0c0d" class="pw-post-body-paragraph kc kd in ke b kf mm jo kh ki mn jr kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">交付测试将取决于您如何交付数据。如果使用HTTP REST API，我们可以在golang中使用httptest的内置包httptest。</p><p id="6fda" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为它依赖于用例，所以我们需要一个用例的模拟。对于Repository也是一样，我也使用mocking来模拟我的用例，用于交付测试。</p><pre class="la lb lc ld gt nl nm nn no aw np bi"><span id="88b3" class="mx lv in nm b gy nq nr l ns nt">func TestGetByID(t *testing.T) {<br/> var mockArticle models.Article <br/> err := faker.FakeData(&amp;mockArticle) <br/> assert.NoError(t, err) <br/> mockUCase := new(mocks.ArticleUsecase) <br/> num := int(mockArticle.ID) <br/> mockUCase.On(“GetByID”, int64(num)).Return(&amp;mockArticle, nil) <br/> e := echo.New() <br/> req, err := http.NewRequest(echo.GET, “/article/” +  <br/>             strconv.Itoa(int(num)), strings.NewReader(“”)) </span><span id="ccbd" class="mx lv in nm b gy nu nr l ns nt"> assert.NoError(t, err) </span><span id="b13a" class="mx lv in nm b gy nu nr l ns nt"> rec := httptest.NewRecorder() <br/> c := e.NewContext(req, rec) <br/> c.SetPath(“article/:id”) <br/> c.SetParamNames(“id”) <br/> c.SetParamValues(strconv.Itoa(num)) </span><span id="6cbe" class="mx lv in nm b gy nu nr l ns nt"> handler:= articleHttp.ArticleHandler{<br/>            AUsecase: mockUCase,<br/>            Helper: httpHelper.HttpHelper{}<br/> } <br/> handler.GetByID(c) </span><span id="b8e4" class="mx lv in nm b gy nu nr l ns nt"> assert.Equal(t, http.StatusOK, rec.Code) <br/> mockUCase.AssertCalled(t, “GetByID”, int64(num))<br/>}</span></pre><h1 id="c5ff" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated"><strong class="ak">最终输出和合并</strong></h1><p id="8065" class="pw-post-body-paragraph kc kd in ke b kf mm jo kh ki mn jr kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">完成所有层并通过测试后。您应该在根项目的main.go中合并到一个系统中。<br/>在这里您将定义和创建环境的每一个需求，并将所有层合并成一个。</p><p id="073c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">找我的main.go为例:</p><figure class="la lb lc ld gt le"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d702" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以看到，每一层合并成一个依赖关系。</p><h1 id="f7a6" class="lu lv in bd lw lx ly lz ma mb mc md me jt mf ju mg jw mh jx mi jz mj ka mk ml bi translated">结论:</h1><ul class=""><li id="1ea1" class="ll lm in ke b kf mm ki mn kl nv kp nw kt nx kx lq lr ls lt bi translated">简而言之，如果画在一张图中，可以看到下图</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ny"><img src="../Images/719cc8cfa596a24c09002567d3de310a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GQdkAd7IwIwOWW-WLG5ikQ.png"/></div></div></figure><ul class=""><li id="701f" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx lq lr ls lt bi translated">这里使用的每个库都可以自己修改。因为干净架构的要点是:不管你的库是什么，你的架构是干净的，可测试的，也是独立的</li><li id="ead5" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">这是我如何组织我的项目的，你可以争论，或者同意，或者可能改进它使之更好，只需留下评论并分享它</li></ul><h2 id="0317" class="mx lv in bd lw my mz dn ma na nb dp me kl nc nd mg kp ne nf mi kt ng nh mk ni bi translated"><strong class="ak">样本项目</strong></h2><p id="3e15" class="pw-post-body-paragraph kc kd in ke b kf mm jo kh ki mn jr kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">在这里可以看到示例项目<a class="ae ky" href="https://github.com/bxcodec/go-clean-arch" rel="noopener ugc nofollow" target="_blank">https://github.com/bxcodec/go-clean-arch</a></p><p id="ac9a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用于我的项目的库:</p><ul class=""><li id="23f1" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx lq lr ls lt bi translated">Glide:用于包管理</li><li id="5516" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">来自github.com/DATA-DOG/go-sqlmock的go-sqlmock</li><li id="406e" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">作证:为了测试</li><li id="3b74" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">用于交付层的Echo Labstack (Golang Web框架)</li><li id="dc0f" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated">Viper:用于环境配置</li></ul><p id="33be" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于清洁建筑的进一步阅读:</p><ul class=""><li id="498f" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx lq lr ls lt bi translated">本文第二部分:<a class="ae ky" href="https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/trying-clean-architecture-on-golang-2-44d 615 BF 8 fdf</a></li><li id="6dbd" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated"><a class="ae ky" href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">https://8 thlight . com/blog/uncle-bob/2012/08/13/the-clean-architecture . html</a></li><li id="3f4e" class="ll lm in ke b kf ms ki mt kl mu kp mv kt mw kx lq lr ls lt bi translated"><a class="ae ky" href="http://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/" rel="noopener ugc nofollow" target="_blank">http://manuel . kiesling . net/2012/09/28/applying-the-clean-architecture-to-go-applications/</a>。另一个版本的戈朗清洁建筑</li></ul><p id="e2ae" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nz">如果你有问题，或者需要更多的解释，或者有什么东西，我在这里不好解释，你可以从我的</em><a class="ae ky" href="https://www.linkedin.com/in/imantumorang/" rel="noopener ugc nofollow" target="_blank"><em class="nz">LinkedIn</em></a><em class="nz">或者</em><a class="ae ky" href="mailto:iman.tumorang@gmail.com" rel="noopener ugc nofollow" target="_blank"><em class="nz">email</em></a><em class="nz">问我。谢谢</em></p></div></div>    
</body>
</html>