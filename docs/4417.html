<html>
<head>
<title>Crash course on the Kotlin compiler | 1. Frontend: Parsing phase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin编译器速成班| 1。前端:解析阶段</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/crash-course-on-the-kotlin-compiler-1-frontend-parsing-phase-9898490d922b?source=collection_archive---------3-----------------------#2022-03-28">https://medium.com/google-developer-experts/crash-course-on-the-kotlin-compiler-1-frontend-parsing-phase-9898490d922b?source=collection_archive---------3-----------------------#2022-03-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="aaa2" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">词法分析器、解析器、PSI、AST v. CST和其他帮助理解编写IDE/编译器插件的基本概念</h2></div><p id="60d1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作为程序员，我们喜欢谈论技术是一个“黑匣子”。不管是好是坏，Kotlin编译器感觉有点像。有关于Kotlin <a class="ae js" href="https://plugins.jetbrains.com/docs/intellij/psi-elements.html" rel="noopener ugc nofollow" target="_blank"> PSI </a> use for IDE插件的文档，但是除了源代码中留下的注释之外，没有太多其他的了。我希望我能帮助其他人学到足够的信息，让他们自己动手(甚至鼓励其他人分享他们的发现)。</p><p id="3f03" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这部迷你剧将分两部分发行:</p><ul class=""><li id="fa00" class="jt ju hh iy b iz ja jc jd jf jv jj jw jn jx jr jy jz ka kb bi translated"><a class="ae js" href="https://hinchman-amanda.medium.com/crash-course-on-the-kotlin-compiler-1-frontend-parsing-phase-9898490d922bhttps://hinchman-amanda.medium.com/crash-course-on-the-kotlin-compiler-1-frontend-parsing-phase-9898490d922b" rel="noopener"> 1。前端:解析阶段</a></li><li id="c9cb" class="jt ju hh iy b iz kc jc kd jf ke jj kf jn kg jr jy jz ka kb bi translated">2.前端:解决阶段<em class="kh">(即将推出)</em></li></ul><p id="5499" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Kotlin编译器是独一无二的，因为它的前端是建立在它之上的，这使得它很容易与编译器插件和IDE插件共享前端。对于Kotlin来说，前端的目标是解析编写的代码并分析其解释的结构，以便生成<em class="kh">中间表示(IR)。</em>然后，这个IR连同生成的附加信息被馈送到编译器的后端，编译器在IR最终成为机器代码之前进一步分析、扩充和优化它。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/b20c4a5f9813aa26adfa8488757daed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f43DzixrIZTPQKZlVtZnUg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">Frontend portion of the Kotlin compiler. A Kotlin file is fed into the compiler, which is then analyzed and broken down into AST/PSI so that it can be further analyzed in the resolution for correctness.</figcaption></figure><p id="b886" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本系列观察了通过Kotlin编译器输入代码时会发生什么:这是理解编译器在每个阶段做什么的最简单的方法。这篇文章涵盖了前端的第一部分，即<em class="kh">解析阶段。</em></p><h1 id="b35a" class="ky kz hh bd la lb lc ld le lf lg lh li in lj io lk iq ll ir lm it ln iu lo lp bi translated">解析阶段</h1><p id="2863" class="pw-post-body-paragraph iw ix hh iy b iz lq ii jb jc lr il je jf ls jh ji jj lt jl jm jn lu jp jq jr ha bi translated">当源代码编译时，编译器必须做的第一件事就是找出开发者到底写了什么。假设我们通过编译器发送以下文件:</p><pre class="kj kk kl km fd lv lw lx ly aw lz bi"><span id="9a29" class="ma kz hh lw b fi mb mc l md me">fun main() {<br/>    1 + 2<br/>    1.plus(2)<br/>}</span></pre><p id="5aa9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">编译器可以“理解”开发人员写的东西，方法是解析人类可读的代码，然后将其翻译成编译器自己可以理解的格式。在下图中，一个Kotlin文件首先进入解析阶段。创建一个lexer来最初解析源文件并生成令牌。然后，这些标记通过语法分析，进而创建一个PSI结构(在<em class="kh">语法分析</em>阶段有更多解释和限定)。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mf"><img src="../Images/e71d8450c47710c89d346223ec55d6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VkTlFJSsZkaAuLpxrSwCSg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">A Kotlin file is first fed into the Parsing phase in the compiler. Lexer analysis generates KtTokens and Kt. Those tokens are then fed through Syntax Analysis, which creates an AST</figcaption></figure><p id="2502" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此时，编译器并不关心<em class="kh">代码是否工作</em>——它只关心计算出<em class="kh">文件中写了什么</em>。<strong class="iy hi">解析阶段</strong>负责创建语法树，以便编译器能够稍后在<strong class="iy hi">解析阶段分析和验证代码。</strong></p><p id="3c6e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">解析的基础可以在下面的两阶段过程中看到:</p><ol class=""><li id="84a7" class="jt ju hh iy b iz ja jc jd jf jv jj jw jn jx jr mg jz ka kb bi translated"><em class="kh">词法分析:</em>文本文件被解析成记号。</li><li id="5ab9" class="jt ju hh iy b iz kc jc kd jf ke jj kf jn kg jr mg jz ka kb bi translated"><em class="kh">语法分析:</em>对标记进行解析并组织成语法树。</li></ol><h2 id="5e9e" class="ma kz hh bd la mh mi mj le mk ml mm li jf mn mo lk jj mp mq lm jn mr ms lo mt bi translated">词汇分析</h2><p id="b74e" class="pw-post-body-paragraph iw ix hh iy b iz lq ii jb jc lr il je jf ls jh ji jj lt jl jm jn lu jp jq jr ha bi translated">在词法分析期间，Kotlin解析器首先创建一个<a class="ae js" href="https://github.com/JetBrains/kotlin/blob/92d200e093c693b3c06e53a39e0b0973b84c7ec5/compiler/psi/src/org/jetbrains/kotlin/lexer/KotlinLexer.java" rel="noopener ugc nofollow" target="_blank"> KotlinLexer </a>。这个lexer扫描Kotlin文件并将文本分解成一组名为<a class="ae js" href="https://github.com/JetBrains/kotlin/blob/master/compiler/psi/src/org/jetbrains/kotlin/lexer/KtTokens.java" rel="noopener ugc nofollow" target="_blank"> KtTokens </a>的<em class="kh">标记</em>。例如，<a class="ae js" href="https://github.com/JetBrains/kotlin/blob/master/compiler/psi/src/org/jetbrains/kotlin/lexer/KtTokens.java" rel="noopener ugc nofollow" target="_blank"> KtTokens </a>将符号<code class="du mu mv mw lw b">(</code>和<code class="du mu mv mw lw b">)</code>表示为:</p><pre class="kj kk kl km fd lv lw lx ly aw lz bi"><span id="0c60" class="ma kz hh lw b fi mb mc l md me">KtSingleValueToken LPAR = new KtSingleValueToken("LPAR", "(");<br/>KtSingleValueToken RPAR = new KtSingleValueToken("RPAR", ")");</span></pre><p id="27f3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae js" href="https://github.com/gigliovale/kotlin/blob/master/compiler/frontend/src/org/jetbrains/kotlin/parsing/KotlinExpressionParsing.java" rel="noopener ugc nofollow" target="_blank">KotlinExpressionParsing</a>将设置一个访问者来将这些令牌排列成表达式节点集。然后通过<a class="ae js" href="https://github.com/JetBrains/intellij-community/blob/master/platform/core-api/src/com/intellij/lang/ASTNode.java" rel="noopener ugc nofollow" target="_blank"> ASTNode </a>将这些表达式节点追加到PSI树中。</p><p id="6b24" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae js" href="https://plugins.jetbrains.com/docs/intellij/psi-elements.html#how-do-i-get-a-psi-element" rel="noopener ugc nofollow" target="_blank"> <em class="kh">编程结构接口</em> ( <em class="kh"> PSI) </em> </a>是JetBrains搭建的一个抽象。它有点像一棵重量级的通用语法树，在ide中处理文本/代码/语言。这些树是在语法分析期间生成的内存中的表示形式，编译器需要它们来生成额外的数据并递归地分析自身，以便在后面的阶段进行代码验证。PSI对于编译器插件<em class="kh">和</em> IDEA插件都很有用，因为你可以过滤PSI来截取特定的代码片段。</p><p id="7229" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简而言之，Kotlin解析器创建了以层次关系连接节点的结构。例如，如果<a class="ae js" href="https://github.com/gigliovale/kotlin/blob/master/compiler/frontend/src/org/jetbrains/kotlin/parsing/KotlinExpressionParsing.java" rel="noopener ugc nofollow" target="_blank">KotlinExpressionParsing</a>选择关键字<code class="du mu mv mw lw b">throw</code>，那么另一个元素将被解析并转换为PSI元素，以添加到树中:</p><pre class="kj kk kl km fd lv lw lx ly aw lz bi"><span id="fbab" class="ma kz hh lw b fi mb mc l md me">/*<br/> * : "throw" element<br/> */<br/><strong class="lw hi">private</strong> <strong class="lw hi">void</strong> <strong class="lw hi">parseThrow() {</strong><br/>    assert _at(THROW_KEYWORD)</span><span id="b7fe" class="ma kz hh lw b fi mx mc l md me">    PsiBuilder.Marker marker = mark();</span><span id="95a8" class="ma kz hh lw b fi mx mc l md me">    advance(); // THROW_KEYWORD</span><span id="0c12" class="ma kz hh lw b fi mx mc l md me">    parseExpression(); </span><span id="8937" class="ma kz hh lw b fi mx mc l md me">    marker.done(THROW);<br/><strong class="lw hi">}</strong></span></pre><p id="fd7c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在下一节中，语法分析将创建一个PSI解析器，它将标记包装为<code class="du mu mv mw lw b">PsiElements</code>。每个节点都有一个递归描述源代码语法结构的描述。</p><h2 id="f895" class="ma kz hh bd la mh mi mj le mk ml mm li jf mn mo lk jj mp mq lm jn mr ms lo mt bi translated">语法分析</h2><p id="8fa5" class="pw-post-body-paragraph iw ix hh iy b iz lq ii jb jc lr il je jf ls jh ji jj lt jl jm jn lu jp jq jr ha bi translated">生成的PSI文件描述了构建语法和语义代码模型的<code class="du mu mv mw lw b">PsiElements</code>(所谓的<em class="kh"> PSI树</em>)的层次结构。PSI树更像是<em class="kh">抽象语法树</em> <em class="kh"> (AST) </em>还是<em class="kh">具体语法树(CST) </em>？嗯，看起来生成的PSI树具有两种<em class="kh">的特征。</em></p><p id="3a24" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Eli Bendersky关于<a class="ae js" href="https://eli.thegreenplace.net/2009/02/16/abstract-vs-concrete-syntax-trees/" rel="noopener ugc nofollow" target="_blank"> <em class="kh">抽象vs .具体语法树</em> </a>的博客很好地解释了两者之间的区别。像CST树一样，PSI结构包含了书写内容的更正式的表示，包括符号。然而，像AST一样，PSI树在每个节点本身中保存额外的有用信息。</p><p id="425c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在IntelliJ IDEA中，你可以下载插件<a class="ae js" href="https://www.jetbrains.com/help/idea/psi-viewer.html?source=google&amp;medium=cpc&amp;campaign=9731470771&amp;gclid=CjwKCAjwloCSBhAeEiwA3hVo_cQTYJhHEDWhh_ccKnmyMvMlRSJExE3lJ9KpDSx0rzHyY-CyZ9fBwhoCEnMQAvD_BwE" rel="noopener ugc nofollow" target="_blank"> PSIViewer </a>来检查你写的代码的PSI。您还可以突出显示您的部分代码，以查看PSIViewer在其渲染树中选择了什么。</p><p id="bfc7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下图显示了<a class="ae js" href="https://www.jetbrains.com/help/idea/psi-viewer.html?source=google&amp;medium=cpc&amp;campaign=9731470771&amp;gclid=CjwKCAjwloCSBhAeEiwA3hVo_cQTYJhHEDWhh_ccKnmyMvMlRSJExE3lJ9KpDSx0rzHyY-CyZ9fBwhoCEnMQAvD_BwE" rel="noopener ugc nofollow" target="_blank"> PSIViewer </a>如何将<code class="du mu mv mw lw b">5.minus(2)</code>解释为<code class="du mu mv mw lw b">DOT_QUALIFIED_EXPRESSION</code>，其第一个孩子是<code class="du mu mv mw lw b">INTEGER_CONSTANT</code>为<code class="du mu mv mw lw b">5</code>，第二个孩子<code class="du mu mv mw lw b">DOT</code>为<code class="du mu mv mw lw b">.</code>，第三个孩子<code class="du mu mv mw lw b">CALL_EXPRESSION</code>为<code class="du mu mv mw lw b">minus(2)</code>。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es my"><img src="../Images/80a3f51641ed48ccc294adb8187cf608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmllyWqIVX1p6HZVzl-FGA.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">PSIViewer allows you to inspect the properties a PSI node holds.</figcaption></figure><p id="ceff" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些PSI元素包含标记，并且能够保存可能与之相关的子元素和父元素的信息。这些PSI结构变得更加复杂，因为编译器会构建并从中生成额外的信息。PSI结构具有CST和AST的共同特征，尽管它们的结构随着时间的推移变得更像AST。为了讨论和方便起见，我们用AST来指代这些树。</p><p id="fa48" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">考虑一下表达式<code class="du mu mv mw lw b">5 — 2</code>。生成的AST如下，其中树中较暗的节点表示为元素，较亮的节点表示为标记。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es mz"><img src="../Images/2ddb9099a573d3d1073a698dc7a4c63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdUH6lf1FpZa3DNsespWTw.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">The tool PSIViewer renders a similar tree right in your IntelliJ IDE, where all elements are defined as PsiElement types. For simplicity, this image differentiates <em class="na">tokens</em> with lighter nodes denoted “Token.${psiElement}” and elements with darker nodes denoted “Element.${psiElement)”.</figcaption></figure><p id="a2a3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">表达式<code class="du mu mv mw lw b">5 – 2</code>可以分解成一个二进制表达式，由两个整数常量作为操作数和一个<code class="du mu mv mw lw b">OPERATION_REFERENCE</code>作为运算符组成。但是表达式<code class="du mu mv mw lw b">5.minus(2)</code>，即使它的结果与<code class="du mu mv mw lw b">5 — 2</code>相同，也会有完全不同的AST结构。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es nb"><img src="../Images/52d257fb6b4cd08f2cdc779dc11ebcd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TIfIQLqxem1ZPu0BhbS_ng.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">Unlike a BINARY_EXRPRESSION that defines 5–2, a DOT_QUALITIFIED EXPRESSION found in 5.minus(2) contains a CALL_EXPRESSION, whose REFERENCE_EXPRESSION is “minus” and VALUE_ARGUMENT_LIST is “(2)”</figcaption></figure><p id="ec73" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">PSI树告诉我们最终用户是如何编写代码的，但是在这个阶段没有太多其他的信息。这意味着此时，编译器只能告诉我们<em class="kh">代码是如何编写的</em>，但不知道<em class="kh">代码是否编译。</em></p><p id="826b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">无论代码是否正确，都可以构建PSI树。考虑下面IntelliJ想法的截图。窗格的左边部分显示了<strong class="iy hi"> Utils.kt </strong>中的代码。在<code class="du mu mv mw lw b">main</code>函数内部，有两条语句，函数的第二行是<code class="du mu mv mw lw b">5.((2)</code>而不是<code class="du mu mv mw lw b">5.minus(2)</code>。我们知道(IDE也知道)像<code class="du mu mv mw lw b">5.((2)</code>这样的语句不会被编译。但是记住，PSI树不需要知道这些。不管怎样，它都会生成元素，尽管它可能无法准确地解释内部的层次关系。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es nc"><img src="../Images/9af24eb488e92427d3b6c88648ff7531.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pw5lzaBbMf15ZPtyLpnSRg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">PSIViewer Captures the LPAR LPAR elements.</figcaption></figure><p id="0384" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">IDE如何能够在屏幕截图的左侧窗格中显示红色曲线？这正是<strong class="iy hi">解决阶段</strong>所负责的，这为我们下一篇文章的主题提供了完美的继续。下一篇文章将研究<strong class="iy hi">解析阶段</strong>，它创建必要的分析来帮助判断代码是否可以编译。敬请期待！</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/b20c4a5f9813aa26adfa8488757daed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f43DzixrIZTPQKZlVtZnUg.png"/></div></div><figcaption class="ku kv et er es kw kx bd b be z dx">In the next section, we cover the “Resolution” portion of the frontend of the Kotlin compiler.</figcaption></figure><p id="5bc1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="kh">非常感谢</em><a class="nd ne ge" href="https://medium.com/u/41a8b1601c59?source=post_page-----9898490d922b--------------------------------" rel="noopener" target="_blank"><em class="kh">Leland Richardson</em></a><em class="kh">为他的评论提供了围绕编译器细节的反馈以及</em><a class="nd ne ge" href="https://medium.com/u/9862bd834329?source=post_page-----9898490d922b--------------------------------" rel="noopener" target="_blank"><em class="kh">Louis CAD</em></a><em class="kh">为他的评论和围绕文章/图表的反馈。</em></p><p id="ea78" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后后端获取这个IR，优化它，再次优化它，并将其全部生成为字节码。这将在下一篇文章中讨论。</p></div></div>    
</body>
</html>