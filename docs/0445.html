<html>
<head>
<title>Suspending over views — example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在视图上暂停—示例</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/suspending-over-views-example-260ce3dc9100?source=collection_archive---------2-----------------------#2019-12-02">https://medium.com/androiddevelopers/suspending-over-views-example-260ce3dc9100?source=collection_archive---------2-----------------------#2019-12-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/564886a62904576426e22bf54cdaf057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNsWjHpaQaS_yNNQ3ZyHpw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" rel="noopener" href="/@VPoltrack">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="08d8" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">一个来自<a class="ae hu" href="https://tivi.app" rel="noopener ugc nofollow" target="_blank"> Tivi </a>应用的工作示例</h2></div><p id="27e4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这篇博客文章是探索协程如何让您以更简单的方式编写复杂的异步UI操作的两篇文章中的第二篇。第一篇文章介绍了理论，而这篇文章展示了他们是如何解决问题的。</p><p id="bea4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你想回顾第一篇文章，你可以在这里找到:</p><div class="hg hh ez fb hi ki"><a rel="noopener follow" target="_blank" href="/androiddevelopers/suspending-over-views-19de9ebd7020"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hy fi z dy kn ea eb ko ed ef hw bi translated">在视图上暂停</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">Android view系统爱回调；喜欢试镜。给你一个想法，目前有80+…</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">medium.com</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw ho ki"/></div></div></a></div></div><div class="ab cl kx ky go kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ha hb hc hd he"><p id="6241" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">让我们把我们在上一篇文章中学到的东西应用到一个真实的应用用例中。</p><h1 id="4a09" class="le lf hx bd lg lh li lj lk ll lm ln lo jd lp je lq jg lr jh ls jj lt jk lu lv bi translated">问题是</h1><p id="e5ff" class="pw-post-body-paragraph jm jn hx jo b jp lw iy jr js lx jb ju jv ly jx jy jz lz kb kc kd ma kf kg kh ha bi translated">这里我们有来自<a class="ae hu" href="https://tivi.app/" rel="noopener ugc nofollow" target="_blank"> Tivi </a>示例应用程序的电视节目细节用户界面。除了关于这部剧的信息，它还列出了该剧的季节和剧集。当用户单击其中一集时，该集的详细信息会使用动画显示，该动画会展开所单击的项目:</p><figure class="mc md me mf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mb"><img src="../Images/ba46e3b6c50a7000f3c0324c8eced2a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EsI9PnKr_ilUWvco"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Episode expanding (20% speed)</figcaption></figure><p id="445e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">应用程序使用<a class="ae hu" href="https://github.com/saket/InboxRecyclerView" rel="noopener ugc nofollow" target="_blank"><strong class="jo hy">InboxRecyclerView</strong></a>库来处理上面展开的动画:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="424a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><code class="du mi mj mk ml b">InboxRecyclerView</code>由我们提供项目ID的工作视图来展开。然后，它从<code class="du mi mj mk ml b">RecyclerView</code>项中找到匹配的视图，并在其上执行动画。</p><p id="b4df" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">现在让我们来看看我们试图解决的问题。在同一个用户界面的顶部附近是一个不同的项目，它向用户显示他们要观看的下一集。它使用与上面显示的单个剧集项目相同的视图类型，但具有不同的项目ID。</p><p id="6eae" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了帮助开发，我很懒，对这个项目使用了同样的<code class="du mi mj mk ml b">onEpisodeItemClicked()</code>。不幸的是，这导致点击时动画中断。</p><figure class="mc md me mf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mb"><img src="../Images/0ffc2c3d6062d31ed8c71d0deee3ac63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*i_oNV5lx9HgxCuYPFspoNA.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Wrong item expanding (20% speed)</figcaption></figure><p id="26af" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">库不会展开被点击的项目，而是在顶部展开一个看似随机的项目。这不是我们想要的效果，是由一些潜在的问题造成的:</p><ol class=""><li id="8e0c" class="mm mn hx jo b jp jq js jt jv mo jz mp kd mq kh mr ms mt mu bi translated">我们在click listener中使用的ID直接取自<code class="du mi mj mk ml b">Episode</code>类。该ID映射到季节列表中的单个剧集项目。</li><li id="ce30" class="mm mn hx jo b jp mv js mw jv mx jz my kd mz kh mr ms mt mu bi translated">剧集条目可能不附属于<code class="du mi mj mk ml b">RecyclerView</code>。用户将需要扩展季节<em class="na">和</em>滚动，以便项目在视口中，视图存在于<code class="du mi mj mk ml b">RecyclerView</code>中。</li></ol><p id="626c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">由于这些问题，库退回到扩展第一项。</p><h1 id="b218" class="le lf hx bd lg lh li lj lk ll lm ln lo jd lp je lq jg lr jh ls jj lt jk lu lv bi translated">理想溶液</h1><p id="a98e" class="pw-post-body-paragraph jm jn hx jo b jp lw iy jr js lx jb ju jv ly jx jy jz lz kb kc kd ma kf kg kh ha bi translated">那么什么是预期的行为呢？理想情况下，我们应该有这样的东西(放慢速度:</p><figure class="mc md me mf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mb"><img src="../Images/64907c9dca61d55421d00e61bba85505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fq3dnDwt9_m-0k0S"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">The ideal result (20% speed)</figcaption></figure><p id="ce89" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在伪代码中，它可能看起来有点像这样:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="0fa1" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">然而在现实中，它需要看起来更像这样:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="6d7d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">正如您所看到的，我们一直在等待异步事件的发生！⏳</p><p id="bdf6" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这里的伪代码看起来并不复杂，但是当你开始实现它时，我们很快就陷入了回调地狱。下面是一个使用链式回调编写框架解决方案的尝试:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="ee30" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这段代码并不是特别好，可能也不起作用，但是它很好地说明了回调是如何让UI编程变得非常复杂的。通常，此代码有几个问题:</p><h2 id="b10d" class="nb lf hx bd lg nc nd ne lk nf ng nh lo jv ni nj lq jz nk nl ls kd nm nn lu no bi translated">紧密耦合</h2><p id="1d5d" class="pw-post-body-paragraph jm jn hx jo b jp lw iy jr js lx jb ju jv ly jx jy jz lz kb kc kd ma kf kg kh ha bi translated">因为我们必须使用回调来编写过渡，所以每个“动画”必须知道接下来要调用什么:回调#1调用动画2，回调#2调用动画#3，等等。这些动画彼此没有关系，但我们不得不将它们结合在一起。</p><h2 id="440e" class="nb lf hx bd lg nc nd ne lk nf ng nh lo jv ni nj lq jz nk nl ls kd nm nn lu no bi translated">难以维护/更新</h2><p id="4f2f" class="pw-post-body-paragraph jm jn hx jo b jp lw iy jr js lx jb ju jv ly jx jy jz lz kb kc kd ma kf kg kh ha bi translated">写完这篇文章的两个月后，你的动作设计师要求你在中间添加淡入淡出过渡。您需要跟踪过渡，检查每个回调以找到触发新动画的正确回调。那么你需要测试它…</p><h2 id="59cf" class="nb lf hx bd lg nc nd ne lk nf ng nh lo jv ni nj lq jz nk nl ls kd nm nn lu no bi translated">测试</h2><p id="7523" class="pw-post-body-paragraph jm jn hx jo b jp lw iy jr js lx jb ju jv ly jx jy jz lz kb kc kd ma kf kg kh ha bi translated">无论如何，测试动画是很难的，但是依赖这种混乱的回调会使它变得更加困难。你的测试需要考虑所有不同的动画类型，回调它自己来断言某个东西运行了。在本文中，我们并没有真正触及测试，但是协程使测试变得更加容易。</p><h1 id="b9cb" class="le lf hx bd lg lh li lj lk ll lm ln lo jd lp je lq jg lr jh ls jj lt jk lu lv bi translated">营救🦸的协管员</h1><p id="ae4e" class="pw-post-body-paragraph jm jn hx jo b jp lw iy jr js lx jb ju jv ly jx jy jz lz kb kc kd ma kf kg kh ha bi translated">在第一篇文章中，我们学习了如何将回调API封装到挂起函数中。让我们利用这些知识将我们丑陋的回调代码变成这样:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="00d4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这有多大的可读性？！💘</p><p id="734a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">新的await挂起函数隐藏了所有的复杂性，产生了一个函数调用的顺序列表。让我们深入了解细节…</p><h1 id="fad3" class="le lf hx bd lg lh li lj lk ll lm ln lo jd lp je lq jg lr jh ls jj lt jk lu lv bi translated">motion layout . awaittranspotioncomplete()</h1><p id="567a" class="pw-post-body-paragraph jm jn hx jo b jp lw iy jr js lx jb ju jv ly jx jy jz lz kb kc kd ma kf kg kh ha bi translated">目前没有可用的<a class="ae hu" href="https://developer.android.com/reference/android/support/constraint/motion/MotionLayout" rel="noopener ugc nofollow" target="_blank"> MotionLayout </a> ktx扩展，<code class="du mi mj mk ml b"><a class="ae hu" href="https://developer.android.com/reference/android/support/constraint/motion/MotionLayout" rel="noopener ugc nofollow" target="_blank">MotionLayout</a></code>也缺少一次添加多个监听器的能力(<a class="ae hu" href="https://issuetracker.google.com/issues/144714753" rel="noopener ugc nofollow" target="_blank">特性请求</a>)。这意味着<code class="du mi mj mk ml b">awaitTransitionComplete()</code>函数的实现比其他一些函数要复杂一些。</p><p id="0e44" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们使用了<code class="du mi mj mk ml b"><a class="ae hu" href="https://developer.android.com/reference/android/support/constraint/motion/MotionLayout" rel="noopener ugc nofollow" target="_blank">MotionLayout</a></code>的一个子类，它增加了对多个监听器的支持:<code class="du mi mj mk ml b"><a class="ae hu" href="https://gist.github.com/chrisbanes/a7371683c224464bf6bda5a25491aee0" rel="noopener ugc nofollow" target="_blank">MultiListenerMotionLayout</a></code>。</p><p id="e784" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们的<code class="du mi mj mk ml b">awaitTransitionComplete()</code>函数被定义为:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h1 id="a883" class="le lf hx bd lg lh li lj lk ll lm ln lo jd lp je lq jg lr jh ls jj lt jk lu lv bi translated">Adapter.awaitItemIdExists()</h1><p id="b5b3" class="pw-post-body-paragraph jm jn hx jo b jp lw iy jr js lx jb ju jv ly jx jy jz lz kb kc kd ma kf kg kh ha bi translated">这个功能可能很小众，但也很有用。在上面的电视节目示例中，它实际上处理几种不同的异步状态:</p><pre class="mc md me mf fd np ml nq nr aw ns bi"><span id="4f6a" class="nb lf hx ml b fi nt nu l nv nw">// Make sure that the season is expanded, with the episode attached<br/>viewModel.expandSeason(nextEpisodeToWatch.seasonId)</span><span id="12e9" class="nb lf hx ml b fi nx nu l nv nw"><strong class="ml hy">// 1. Wait for new data dispatch<br/>// 2. Wait for RecyclerView adapter to diff new data set</strong></span><span id="83d3" class="nb lf hx ml b fi nx nu l nv nw">// Scroll the RecyclerView so that the episode is displayed<br/>recyclerView.scrollToItemId(nextEpisodeToWatch.id)</span></pre><p id="701a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">该函数使用RecyclerView的<a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.AdapterDataObserver.html" rel="noopener ugc nofollow" target="_blank"> AdapterDataObserver </a>实现，每当适配器的数据集发生变化时都会调用该函数:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h1 id="d014" class="le lf hx bd lg lh li lj lk ll lm ln lo jd lp je lq jg lr jh ls jj lt jk lu lv bi translated">RecyclerView.awaitScrollEnd()</h1><p id="df49" class="pw-post-body-paragraph jm jn hx jo b jp lw iy jr js lx jb ju jv ly jx jy jz lz kb kc kd ma kf kg kh ha bi translated">最后一个要突出显示的函数是<code class="du mi mj mk ml b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.html" rel="noopener ugc nofollow" target="_blank">RecyclerView</a>.awaitScrollEnd()</code>函数，它等待任何滚动完成:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="cc6c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">希望现在这段代码看起来很普通。这个函数的棘手之处在于在执行快速失效检查之前需要使用<code class="du mi mj mk ml b">awaitAnimationFrame()</code>。正如评论中提到的，这是因为一个<code class="du mi mj mk ml b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.SmoothScroller.html" rel="noopener ugc nofollow" target="_blank">SmoothScroller</a></code>实际上在下一个动画帧开始，所以我们需要在检查滚动状态之前等待它发生。</p><p id="880f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><code class="du mi mj mk ml b">awaitAnimationFrame()</code>是<code class="du mi mj mk ml b"><a class="ae hu" href="https://developer.android.com/reference/android/view/View.html#postOnAnimation(java.lang.Runnable)" rel="noopener ugc nofollow" target="_blank">postOnAnimation()</a></code>的包装器，它允许我们等待下一个动画时间步，这通常发生在下一次显示渲染时。它的实现类似于第一篇文章中的<code class="du mi mj mk ml b">doOnNextLayout()</code>示例:</p><figure class="mc md me mf fd hj"><div class="bz dy l di"><div class="mg mh l"/></div></figure><h1 id="53fb" class="le lf hx bd lg lh li lj lk ll lm ln lo jd lp je lq jg lr jh ls jj lt jk lu lv bi translated">决赛成绩</h1><p id="bbfc" class="pw-post-body-paragraph jm jn hx jo b jp lw iy jr js lx jb ju jv ly jx jy jz lz kb kc kd ma kf kg kh ha bi translated">最后，操作序列如下所示:</p><figure class="mc md me mf fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mb"><img src="../Images/93e7e7ae175077f224d056e1c78009c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*91F1ef4ZWLOzSRfp"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Solution, broken down into steps (20% speed)</figcaption></figure><h1 id="2c19" class="le lf hx bd lg lh li lj lk ll lm ln lo jd lp je lq jg lr jh ls jj lt jk lu lv bi translated">打破回调链⛓️</h1><p id="1cb9" class="pw-post-body-paragraph jm jn hx jo b jp lw iy jr js lx jb ju jv ly jx jy jz lz kb kc kd ma kf kg kh ha bi translated">转移到协程导致我们的代码能够脱离庞大的回调链，这很难维护和测试。</p><p id="5ebf" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">将回调/监听器/观察器API包装成一个挂起函数的方法对于所有API来说基本上都是一样的。希望我们在这篇文章中展示的函数现在看起来很重复。因此，向前迈进，释放回调链的UI代码🔨。</p></div></div>    
</body>
</html>