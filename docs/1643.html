<html>
<head>
<title>Conquering Statefulness on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">征服Kubernetes上的国家</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/conquering-statefulness-on-kubernetes-26336d5f4f17?source=collection_archive---------0-----------------------#2019-01-16">https://medium.com/capital-one-tech/conquering-statefulness-on-kubernetes-26336d5f4f17?source=collection_archive---------0-----------------------#2019-01-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/45e159872161c917cb4b610844eb1928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kDgL200kGfaFam7D2tXJeg.png"/></div></div></figure><p id="297a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">容器化彻底改变了我们对应用程序开发的整体看法。有很多好处:开发和生产之间的一致环境，使用共享资源与其他容器隔离，云环境之间的可移植性，快速部署。这个清单还在继续。然而，你不能指望在没有某些折衷的情况下获得所有这些好处。集装箱固有的短暂性是集装箱化伟大的核心；不可变的、相同的容器可以在一瞬间快速旋转起来。但是容器短暂的本质也有不利的一面；缺乏持久存储。</p><p id="beb9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">输入Kubernetes。</em>T3】</strong></p><p id="4c22" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/Persistence_(computer_science)" rel="noopener ugc nofollow" target="_blank">持久状态</a>一般较大，不易移动；就像必须在数据中心的SAN设备上安装额外的存储一样。这个概念与容器快速、轻量、易于随时部署到任何需要的地方的想法有很大不同。正是因为这个原因，持久状态被有意地排除在容器规范之外，容器规范选择了存储插件；将管理持久状态的责任转移给另一方。</p><p id="c89d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">开源容器编排框架Kubernetes已经加快步伐，为这个问题提供了一个解决方案。在这篇文章中，我将带您了解Kubernetes的组件，它们有助于解决容器化环境中的持久状态问题。</p><h1 id="3824" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">有状态问题</h1><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kn"><img src="../Images/1b3d983e93401dcb83cd1889a62323e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VwjMDqAXbUJTBH6h"/></div></div></figure><p id="6dfa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">管理持久状态的最大问题是决定它应该驻留在哪里。在决定持久存储应该放在哪里时，有三个选项可用，每个选项都有自己的优点:</p><ol class=""><li id="ff8a" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm kx ky kz la bi translated"><strong class="ir hi">你的持久存储生活在容器内。如果数据是可复制的和非关键的，这可能是有用的，但是每当容器重新启动时，您将丢失数据。</strong></li><li id="b9be" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">您的持久存储位于主机节点上。</strong>这绕过了临时容器问题，但是您会遇到类似的问题，因为您的主机节点很容易出现故障。</li><li id="003e" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi">您的持久存储位于远程存储选项</strong>中。这消除了容器和主机上存储的不可靠性，但需要仔细考虑如何配置和管理远程存储。</li></ol><h1 id="600d" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">何时考虑状态？</h1><p id="156d" class="pw-post-body-paragraph ip iq hh ir b is lg iu iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">需要持久状态的应用程序有两个关键特性:需要在应用程序停机和重启之后持久保存数据<em class="jn">，以及需要在</em>相同的停机和重启期间管理应用程序状态<em class="jn">。这种类型的应用程序的例子可以是数据库及其副本、某种日志记录应用程序或需要远程存储的分布式应用程序。</em></p><p id="223f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是，即使是这些类型的应用程序也不需要相同级别的持久性，因为不同的应用程序显然有不同的关键程度。因此，在设计有状态应用程序时，我想出了一个简短的问题列表来问自己:</p><ul class=""><li id="b5c4" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm ll ky kz la bi translated">我们要管理多少数据？</li><li id="d1e3" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">从最新的快照开始是否足够，或者我们是否需要绝对最新的可用数据？</li><li id="4932" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">从快照重启是否需要太长时间，或者对于此应用程序是否足够？</li><li id="0170" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">数据复制有多容易？</li><li id="3288" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">这些数据的任务关键程度如何？我们能承受容器或主机终止吗，或者我们需要远程存储吗？</li><li id="e365" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">该应用程序中的不同pod可以互换吗？</li></ul><h1 id="7de9" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">存储解决方案</h1><p id="4673" class="pw-post-body-paragraph ip iq hh ir b is lg iu iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">许多应用程序要求数据在容器和主机重启后都保持不变，这就需要远程存储选项。幸运的是，Kubernetes已经意识到了这种需求，并提供了一种Pods与远程存储交互的方式:<em class="jn"> Volumes </em></p><h2 id="8752" class="lm jq hh bd jr ln lo lp jv lq lr ls jz ja lt lu kd je lv lw kh ji lx ly kl lz bi translated">库伯内特卷</h2><p id="6fd1" class="pw-post-body-paragraph ip iq hh ir b is lg iu iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated"><a class="ae jo" href="https://kubernetes.io/docs/concepts/storage/volumes/" rel="noopener ugc nofollow" target="_blank"> Kubernetes Volumes </a>提供了一种与远程(或本地)存储选项进行交互的方式。这些卷可以被视为在封装Pod的整个生命周期内持续存在的挂载存储。卷将比任何在容器中上下旋转的容器寿命长，这给了我们一个很好的解决容器短暂本质的方法。下面是一个利用卷的Pod定义示例。</p><pre class="ko kp kq kr fd ma mb mc md aw me bi"><span id="e858" class="lm jq hh mb b fi mf mg l mh mi">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>   name: test-pod<br/>spec:<br/>  containers:<br/>    — name: test-container<br/>      image: nginx<br/>      volumeMounts:<br/>        — mountPath: /data<br/>          name: testvolume<br/>  volumes:<br/>    — name: testvolume<br/>      # This AWS EBS Volume must already exist.<br/>      awsElasticBlockStore:<br/>        volumeID: &lt;volume-id&gt;<br/>        fsType: ext4</span></pre><p id="c625" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们从上面的Pod定义中看到的那样,. spec.volumes部分指定了卷的名称和已经创建的存储(在本例中是EBS卷)的ID。要使用该卷，容器定义必须在. spec.container.volumeMounts字段中指定要装入的卷。</p><p id="da1b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">利用卷时需要记住的一些要点:</p><ul class=""><li id="c7f6" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm ll ky kz la bi translated">Kubernetes提供多种类型的卷，一个Pod可以同时使用任意数量的卷。</li><li id="40e8" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">卷的持续时间仅与封装的Pod一样长。当圆荚体不再存在时，体积也会消失。</li><li id="2b89" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">永久存储配置不由卷或Pod本身处理。卷背后的永久存储需要以某种其他方式进行配置。</li></ul><p id="60d8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然卷解决了集装箱化应用的一个大问题，但是某些应用要求附加卷的寿命超过Pod的寿命。对于这个用例，持久卷和持久卷声明将非常有用。</p><p id="aff8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> Kubernetes持久卷和持久卷声明</strong> — Kubernetes <a class="ae jo" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">持久卷</a>和<a class="ae jo" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">持久卷声明</a>提供了一种从存储使用方式中抽象出存储供应方式细节的方法。永久卷(PV)是由管理员调配的群集中的可用永久存储。这些PV作为集群资源存在，就像节点一样，它们的生命周期独立于任何单独的Pod。持久卷声明(PVC)是用户对存储(PVs)的请求。与pod消耗内存和CPU等节点资源的方式类似，PVC消耗存储等PV资源。</p><p id="935e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">PVs的生命周期由四个阶段组成:<em class="jn">供应、绑定、使用和回收。</em></p><p id="d725" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">供应</strong> —供应PVs有两种方式:静态或动态。</p><ul class=""><li id="8ccf" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm ll ky kz la bi translated">静态配置要求集群管理员手动创建大量要使用的PV。</li><li id="ca7e" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">当PVC请求PV时，无需集群管理员的任何手动干预，即可进行动态配置。</li><li id="00e0" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">动态预配置需要以存储类的形式进行一些预先配置(我们稍后会谈到)。</li></ul><p id="ea3f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">绑定</strong> —创建时，PVC具有特定的存储量和与之相关的特定访问模式。当匹配的PV可用时，无论PVC需要多长时间，它都将被专门绑定到发出请求的PVC。如果不存在匹配的PV，PVC将无限期保持未绑定状态。在动态提供PV的情况下，控制循环将总是将PV绑定到请求的PVC。否则，PVC将至少获得他们要求的存储容量，但容量可能会超出他们的要求。</p><p id="7087" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">使用</strong> —一旦PVC申请了PV，它就可以在封装盒中作为已挂载卷使用。用户可以为连接的卷指定特定模式(例如ReadWriteOnce、ReadOnlymany等)。)以及其他安装的存储选项。只要用户需要，已安装的PV就可以使用。</p><p id="50ff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">回收</strong> —一旦用户利用完存储，他们需要决定如何处理正在释放的PV。决定回收政策时有三个选项:保留、删除和回收。</p><ul class=""><li id="fcf2" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm ll ky kz la bi translated">保留一个PV将简单地释放该PV，而不修改或删除任何包含的数据，并允许同一PVC在以后手动回收该PV。</li><li id="b43b" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">删除PV将会完全删除该PV，同时删除底层存储资源。</li><li id="47ec" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">回收PV将擦除存储资源中的数据，并使该PV可供任何其他PVC申请。</li></ul><p id="4e96" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是一个持久卷(利用静态配置)和附带的持久卷声明定义的示例。</p><pre class="ko kp kq kr fd ma mb mc md aw me bi"><span id="b917" class="lm jq hh mb b fi mf mg l mh mi">apiVersion: v1<br/>kind: PersistentVolume<br/>metadata:<br/>   name: mypv<br/>spec:<br/>  storageClassName: mysc<br/>  capacity:<br/>    storage: 8Gi<br/>  accessModes:<br/>    — ReadWriteOnce<br/>  persistentVolumeReclaimPolicy: Recycle<br/>  awsElasticBlockStore:<br/>    volumeID: &lt;volume-id&gt; # This AWS EBS Volume must already exist.</span></pre><p id="91b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">持久卷</p><pre class="ko kp kq kr fd ma mb mc md aw me bi"><span id="c7f3" class="lm jq hh mb b fi mf mg l mh mi">apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: mypvc<br/>spec:<br/>  storageClassName: mysc<br/>  accessModes:<br/>    — ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 8Gi</span></pre><p id="d16f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">持续量索赔</p><p id="d71b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">永久卷定义指定存储资源的容量，以及一些其他特定于卷的属性，如回收策略和访问模式。. spec.storageClassName可用于将PV分类为某一类存储，PVC可以利用它来指定要申请的特定存储类。上面的永久卷声明定义指定了它试图声明的永久卷的属性；其中一些是存储容量和访问模式。PVC可以通过指定. spec.storageClassName字段来请求特定的PV。特定类的PV只能绑定到请求该类的PVCs没有指定类的PV只能绑定到没有请求特定类的PVC。选择器还可以用来指定要申请的PV的具体类型；关于这方面的更多文档可以在这里找到<a class="ae jo" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/#selector" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a11b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是一个利用持久卷声明来请求存储的Pod定义示例:</p><pre class="ko kp kq kr fd ma mb mc md aw me bi"><span id="0e66" class="lm jq hh mb b fi mf mg l mh mi">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: test-pod<br/>spec:<br/>  containers:<br/>    — name: test-container<br/>      image: nginx<br/>      volumeMounts:<br/>    — mountPath: /data<br/>      name: myvolume<br/>  volumes:<br/>    — name: myvolume<br/>      persistentVolumeClaim:<br/>        claimName: mypvc</span></pre><p id="1821" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当将这个Pod定义与前面使用卷的定义进行比较时，我们可以看到它们几乎是相同的。永久卷声明不是直接与存储资源交互，而是用于从Pod中提取存储细节。</p><blockquote class="mj mk ml"><p id="3a08" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated"><strong class="ir hi">关于永久卷和永久卷声明的一些要点:</strong></p><p id="8e5e" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">*永久卷的生命周期独立于Pod的生命周期。</p><p id="1cc4" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">*持久卷声明从pod的存储消耗中抽象出存储配置的细节。</p><p id="c1cd" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">*与卷类似，永久卷和永久卷声明不直接处理存储资源的配置。</p></blockquote><h2 id="c5e7" class="lm jq hh bd jr ln lo lp jv lq lr ls jz ja lt lu kd je lv lw kh ji lx ly kl lz bi translated">Kubernetes存储类别和持久卷声明</h2><p id="cbc0" class="pw-post-body-paragraph ip iq hh ir b is lg iu iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">Kubernetes存储类别和持久卷声明提供了一种在请求时动态配置存储资源的方法，消除了集群管理员为满足需求而过度配置/手动配置存储资源的必要性。存储类别允许集群管理员描述他们提供的存储“类别”,并在动态创建存储资源和持久卷时利用这些“类别”作为模板。可以根据特定的应用程序要求(如所需的服务质量级别和备份策略)定义不同的存储类别。</p><p id="074e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">存储类别定义围绕三个特定领域:</p><ul class=""><li id="5ad0" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm ll ky kz la bi translated">回收政策</li><li id="fbd4" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">供给商</li><li id="a0fe" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated">因素</li></ul><p id="8b75" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">回收策略— </strong>如果持久卷是由存储类创建的，则只有保留或删除可用作回收策略，而由存储类管理的手动创建的持久卷将保留创建时为其分配的回收策略。</p><p id="289f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">置备程序— </strong>存储类置备程序负责决定在置备PVs时需要使用哪个卷插件(例如，用于AWS EBS的AWSElasticBlockStore或用于Portworx卷的PortworxVolume)。provisioner字段不仅限于内部可用的provisioner类型列表；任何遵循明确定义的规范的独立外部供应器都可以用来创建新的持久卷类型。</p><p id="cd3b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">参数— </strong>定义存储类的最后一部分，也可以说是最重要的一部分是参数部分。不同的资源调配器可以使用不同的参数，这些参数用于描述特定“类别”存储的规范。</p><p id="3f61" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下面，您可以找到永久卷声明和存储类别定义。</p><pre class="ko kp kq kr fd ma mb mc md aw me bi"><span id="2b3e" class="lm jq hh mb b fi mf mg l mh mi">apiVersion: v1<br/>kind: StorageClass<br/>metadata:<br/>  name: myscz<br/>provisioner: kubernetes.io/aws-ebs<br/>parameters:<br/>  type: io1<br/>  iopsPerGB: “10”<br/>  fsType: ext4</span></pre><p id="b752" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">持续量索赔</p><pre class="ko kp kq kr fd ma mb mc md aw me bi"><span id="880b" class="lm jq hh mb b fi mf mg l mh mi">apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: mypvc<br/>spec:<br/>  storageClassName: mysc<br/>  accessModes:<br/>    — ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 8Gi</span></pre><p id="7007" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">存储类</p><p id="8f03" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们将PVC定义与上面静态调配用例中使用的定义进行比较，我们会发现它们是相同的。</p><p id="b110" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是由于存储<em class="jn">供应</em>和存储<em class="jn">消耗</em>之间的明确分离。当比较使用存储类创建的持久卷与静态创建的持久卷的消耗时，我们看到了一些巨大的优势。最大的优势之一是能够操纵仅在资源创建时可用的存储资源值。这意味着我们可以准确调配用户请求的存储量，而无需群集管理员的任何手动干预。由于存储类别需要由群集管理员提前定义，因此他们仍然可以控制终端用户可以使用哪些类型的存储，同时还可以抽象出所有配置逻辑。</p><blockquote class="mj mk ml"><p id="f090" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated"><strong class="ir hi">存储类别和永久卷声明的要点:</strong></p><p id="2265" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">*存储类别和永久卷声明支持最终用户动态配置存储资源，无需集群管理员进行任何手动干预。</p><p id="1ded" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">*存储类抽象了存储配置的细节，而是依赖指定的配置程序来处理配置逻辑。</p></blockquote><h1 id="9b52" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">应用状态</h1><p id="0ff4" class="pw-post-body-paragraph ip iq hh ir b is lg iu iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">当我们考虑状态时，持久存储是至关重要的；当我的应用程序出现故障时，我的数据在哪里，如何保存？然而，某些应用程序本身需要的状态管理不仅仅是持久化数据。这在利用多个不可互换的Pod的应用程序中最容易看到(例如，主数据库Pod及其某些分布式应用程序的副本，如<a class="ae jo" href="https://github.com/helm/charts/tree/master/incubator/zookeeper" rel="noopener ugc nofollow" target="_blank"> Zookeeper </a>或<a class="ae jo" href="https://github.com/helm/charts/tree/master/incubator/elasticsearch" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>)。诸如此类的应用程序需要能够为每个Pod分配唯一的标识符，该标识符在任何重新调度中都保持不变。Kubernetes通过使用StatefulSets提供了这种功能。</p><h2 id="76bb" class="lm jq hh bd jr ln lo lp jv lq lr ls jz ja lt lu kd je lv lw kh ji lx ly kl lz bi translated">Kubernetes状态集</h2><p id="855b" class="pw-post-body-paragraph ip iq hh ir b is lg iu iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated"><a class="ae jo" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/" rel="noopener ugc nofollow" target="_blank"> Kubernetes StatefulSets </a>提供了类似于复制集和部署的功能，但是具有稳定的重新调度。对于需要稳定标识符和有序部署、扩展和删除的应用程序来说，这种差异非常重要。有几种不同质量的状态集有助于提供这些必要的功能。</p><p id="2e4e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">唯一网络标识符—</strong>StatefulSet中的每个Pod都从stateful set的名称和Pod的序号中导出其主机名。无论该Pod被调度到哪个节点，或者它被重新调度了多少次，该Pod的标识都是粘性的。该功能对于形成不可互换的pod的逻辑“组”的应用程序特别有用。这些应用程序的例子是分布式系统中的数据库副本和代理。识别单个pod的能力是StatefulSets的核心优势。</p><p id="a858" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">有序部署、扩展和删除</strong> —状态集中的Pod标识符不仅是唯一的，而且是有序的。StatefulSets中的Pod是按顺序创建的，等待前一个Pod处于健康状态，然后再继续下一个Pod。这种行为也扩展到窗格的缩放和删除。在所有前置单元都处于健康状态之前，任何单元都不会发生更新或扩展。同样，在一个Pod终止之前，它的所有后继者必须已经关闭。这些功能允许对状态集进行稳定的、可预测的更改。</p><p id="f0ff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是一个StatefulSet定义的例子。</p><pre class="ko kp kq kr fd ma mb mc md aw me bi"><span id="706b" class="lm jq hh mb b fi mf mg l mh mi">apiVersion: v1<br/>kind: StatefulSet<br/>metadata:<br/>  name: web<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: nginx # has to match .spec.template.metadata.labels<br/>  replicas: 3<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: nginx # has to match .spec.selector.matchLabels<br/>    spec:<br/>      terminationGracePeriodSeconds: 10<br/>      containers:<br/>      — name: nginx<br/>        image: nginx<br/>        ports:<br/>        — containerPort: 80<br/>          name: web<br/>        volumeMounts:<br/>        — name: www<br/>          mountPath: /usr/share/nginx/html<br/>  volumeClaimTemplates:<br/>    — metadata:<br/>        name: www<br/>      spec:<br/>        storageClassName: mysc<br/>        resources:<br/>          requests:<br/>            storage: 1Gi</span></pre><p id="9073" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如上所述，StatefulSet的名称是在. metadata.name中指定的，它将在创建封闭的pod时使用。这个StatefulSet定义将产生三个名为web-0、web-1和web-2的pod。</p><p id="2b45" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个特定的StatefulSet通过. spec.volumeClaimTemplates字段利用PVC，以便将持久性卷附加到每个Pod。</p><blockquote class="mj mk ml"><p id="2b1c" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated"><strong class="ir hi">状态集的关键要点:</strong></p><p id="abc4" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">*状态集唯一地命名它们的封闭单元，允许需要不可互换单元的应用程序存在</p><p id="513e" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">*状态集的部署、扩展和删除以有序的方式处理</p></blockquote><p id="5b6a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然StatefulSets提供了部署和管理不可互换的pod的能力，但仍然存在一个问题:<em class="jn">我如何找到并使用它们</em>。这就是无头服务的亮点。</p><h2 id="1034" class="lm jq hh bd jr ln lo lp jv lq lr ls jz ja lt lu kd je lv lw kh ji lx ly kl lz bi translated">Kubernetes无头服务</h2><p id="9f4f" class="pw-post-body-paragraph ip iq hh ir b is lg iu iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">有时，我们的应用程序不希望或不需要负载平衡或单一服务IP。诸如此类的应用程序(主数据库和副本数据库、分布式应用程序中的代理等。)需要一种方法将流量路由到支持某项服务的各个pod。<a class="ae jo" href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" rel="noopener ugc nofollow" target="_blank">无头服务</a>和具有唯一网络标识符的pod(比如那些用StatefulSets创建的)可以一起用于这个用例。能够直接路由到单个Pod将许多权力放回到开发人员手中；从处理服务发现到直接路由到主数据库单元。</p><p id="387e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是一个无头服务的例子。</p><pre class="ko kp kq kr fd ma mb mc md aw me bi"><span id="c3a5" class="lm jq hh mb b fi mf mg l mh mi">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: nginx-svc<br/>spec:<br/>  clusterIP: None<br/>  selector:<br/>    app: nginx<br/>  ports:<br/>    — name: http<br/>      protocol: TCP<br/>      port: 80<br/>      targetPort: 30001<br/>    — name: https<br/>      protocol: TCP<br/>      port: 443<br/>      targetPort: 30002</span></pre><p id="8839" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使这个规范真正“无头”的属性是将. spec.clusterIP设置为None。这个特定的示例使用. spec.selectors字段来指定应该如何配置DNS。在本例中，所有匹配app: nginx选择器的Pod都将创建一个A记录，直接指向支持服务的Pod。关于如何为无头服务自动配置DNS的更多信息可以在<a class="ae jo" href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" rel="noopener ugc nofollow" target="_blank">这里</a>找到。这个特定的规范将创建端点nginx-svc-0、nginx-svc-1、nginx-svc-2，它们将分别直接路由到web-0、web-1和we b-2 pod。</p><blockquote class="mj mk ml"><p id="0250" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated"><strong class="ir hi">无头服务的关键要点:</strong></p><p id="7497" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">*无头服务允许直接路由到特定的pod</p><p id="b70b" class="ip iq jn ir b is it iu iv iw ix iy iz mm jb jc jd mn jf jg jh mo jj jk jl jm ha bi translated">*支持应用程序开发人员以他们认为合适的方式处理服务发现</p></blockquote><h1 id="ca54" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="fe91" class="pw-post-body-paragraph ip iq hh ir b is lg iu iv iw lh iy iz ja li jc jd je lj jg jh ji lk jk jl jm ha bi translated">Kubernetes使有状态应用程序开发在容器化的世界中成为现实；尤其是在管理应用程序状态和持久数据时。持久卷和持久卷声明建立在卷的基础上，以实现持久数据存储，从而在大多数短暂的环境中实现数据持久性。存储类进一步扩展了这一思想，允许按需提供存储资源。有状态集提供了Pod唯一性和粘性身份，为每个Pod提供了一个有状态的身份，该身份在Pod停机和重新启动后仍然存在。可以将Headless服务与StatefulSets一起使用，为应用程序开发人员提供利用pod的独特性来满足其应用程序需求的能力。</p><p id="cd20" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这篇文章介绍了Kubernetes中有状态应用程序所必需的基本元素。随着Kubernetes的不断发展，围绕有状态应用程序的功能将会不断出现。这些基本元素的知识对于有状态应用程序开发人员和集群管理员都是非常宝贵的。</p><h1 id="b878" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">相关:</h1><ul class=""><li id="1407" class="ks kt hh ir b is lg iw lh ja mp je mq ji mr jm ll ky kz la bi translated"><a class="ae jo" rel="noopener" href="/capital-one-tech/using-kubernetes-configmap-resources-for-dynamic-apps-9e23ef589121">将Kubernetes ConfigMap资源用于动态应用</a></li><li id="ec97" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated"><a class="ae jo" rel="noopener" href="/capital-one-tech/deploying-multiple-environments-with-terraform-kubernetes-7b7f389e622">使用Terraform部署多个环境</a></li><li id="cae4" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm ll ky kz la bi translated"><a class="ae jo" rel="noopener" href="/capital-one-tech/policy-enabled-kubernetes-with-open-policy-agent-3b612b3f0203">策略使Kubernetes具备开放策略代理</a></li></ul></div><div class="ab cl ms mt go mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ha hb hc hd he"><p id="676c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>