<html>
<head>
<title>Using Navigation Architecture Component in a large banking app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在大型银行应用程序中使用导航架构组件</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/using-navigation-architecture-component-in-a-large-banking-app-ac84936a42c2?source=collection_archive---------0-----------------------#2019-02-23">https://medium.com/google-developer-experts/using-navigation-architecture-component-in-a-large-banking-app-ac84936a42c2?source=collection_archive---------0-----------------------#2019-02-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="dffb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">来自<a class="ae jc" href="https://developer.android.com/jetpack" rel="noopener ugc nofollow" target="_blank"> Jetpack </a>的导航库最近到达RC1，所有Android开发者应该开始考虑在新应用中使用它。我负责<a class="ae jc" href="https://www.airbank.net/" rel="noopener ugc nofollow" target="_blank">德国航空银行</a>的应用架构，这是一家新的移动优先的德国银行。我们的应用程序有一个多模块、单活动的架构，包含来自架构组件的视图模型。集成导航组件是一个合乎逻辑的步骤，但也存在一些问题。在这篇博文中，我想分享我们是如何解决这些问题的。这是一篇更高级的文章，所以我假设读者了解<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/navigation/" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><h1 id="2f04" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">在多模块项目中，将导航XML文件放在哪里？</h1><p id="11cd" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">多模块项目是构建新应用程序的推荐方式。优点是更快的构建时间和代码库中更好的关注点分离。这是我们Gradle模块的简图:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/82b3cafd7aeab1575d6594ce937ae9f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*jH4EPys4NVsN-GC_9BK-bg.png"/></div></figure><p id="4e98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有几个放置导航XML文件的选项:</p><h2 id="d3fe" class="ko je hh bd jf kp kq kr jj ks kt ku jn ip kv kw jr it kx ky jv ix kz la jz lb bi translated">“应用”模块</h2><p id="21ea" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">官方文档和Android Studio假设了这一点。但是你需要能够从一个特性导航到另一个特性(并且特性不依赖于‘app’模块)。这可以通过将导航目的地的所有id放入“common-android”模块内的ids.xml文件中来解决。然后导航工作，但你不能使用安全的参数。您需要手动构造向目的地传递参数的包。</p><h2 id="47a1" class="ko je hh bd jf kp kq kr jj ks kt ku jn ip kv kw jr it kx ky jv ix kz la jz lb bi translated">“应用”模块中的主图形，功能模块中的子图形</h2><p id="6c89" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">这类似于在“应用程序”模块中有一个大图表，但更具结构性。您可以在功能中使用安全参数，但不能在导航到不同功能时使用。也可以使用“common-android”模块中的id。</p><h2 id="cdba" class="ko je hh bd jf kp kq kr jj ks kt ku jn ip kv kw jr it kx ky jv ix kz la jz lb bi translated">“通用安卓”模块</h2><p id="49cb" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">所有功能都依赖于“common-android ”,因此您可以使用安全的参数在任何地方导航。然而，它有两个缺点:</p><ul class=""><li id="bb12" class="lc ld hh ig b ih ii il im ip le it lf ix lg jb lh li lj lk bi translated">因为‘common-Android’模块不依赖于特性，所以片段类在Android Studio中是红色的。您没有片段类的自动完成功能，但是它编译起来没有任何问题。</li><li id="70f5" class="lc ld hh ig b ih ll il lm ip ln it lo ix lp jb lh li lj lk bi translated">有一个错误阻止了深度链接的意图过滤器的生成。它已经被分配了，所以希望它能在最终版本中被修复。</li></ul><p id="7dc6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这两个问题对我们来说并不是障碍，在任何地方使用安全参数确实是一个很大的优势。因此，我们的首选是将文件放在“common-android”模块中。</p><h1 id="7a7f" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">如何从视图模型中导航？</h1><p id="f89f" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">我们的应用程序使用了从<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture" rel="noopener ugc nofollow" target="_blank"> Android架构组件</a>推荐的MVVM架构。文档显示了如何从片段开始导航，但是这个逻辑应该在视图模型中。我们试图将所有样板代码放到BaseFragment和BaseViewModel中，以简化所有其他片段/视图模型的代码。</p><h2 id="5e3c" class="ko je hh bd jf kp kq kr jj ks kt ku jn ip kv kw jr it kx ky jv ix kz la jz lb bi translated">命令</h2><p id="c734" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">我们使用命令模式在视图模型和片段之间进行通信。这些是我们用于导航的命令:</p><pre class="kh ki kj kk fd lq lr ls lt aw lu bi"><span id="18dc" class="ko je hh lr b fi lv lw l lx ly">sealed class NavigationCommand {<br/>  data class To(val directions: NavDirections): NavigationCommand()<br/>  object Back: NavigationCommand()<br/>  data class BackTo(val destinationId: Int): NavigationCommand()<br/>  object ToRoot: NavigationCommand()<br/>}</span></pre><p id="20b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ViewModel将它们发布到片段监听的LiveData对象中。但这必须是一次性的事件。为此，我们使用建筑蓝图中的<a class="ae jc" href="https://github.com/googlesamples/android-architecture/blob/dev-todo-mvvm-live/todoapp/app/src/main/java/com/example/android/architecture/blueprints/todoapp/SingleLiveEvent.java" rel="noopener ugc nofollow" target="_blank"> SingleLiveEvent。</a></p><h2 id="5028" class="ko je hh bd jf kp kq kr jj ks kt ku jn ip kv kw jr it kx ky jv ix kz la jz lb bi translated">碱基片段</h2><p id="9efc" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">BaseFragment从视图模型中监听导航命令，如下所示:</p><pre class="kh ki kj kk fd lq lr ls lt aw lu bi"><span id="758c" class="ko je hh lr b fi lv lw l lx ly">override fun onActivityCreated(savedInstanceState: Bundle?) {<br/>  super.onActivityCreated(savedInstanceState)<br/>  vm?.navigationCommands?.observe { command -&gt;<br/>    when (command) {<br/>      is NavigationCommand.To -&gt;      <br/>        findNavController().navigate(command.directions)<br/>        …</span></pre><h2 id="3aa1" class="ko je hh bd jf kp kq kr jj ks kt ku jn ip kv kw jr it kx ky jv ix kz la jz lb bi translated">视图模型</h2><p id="887c" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">BaseViewModel有以下助手方法:</p><pre class="kh ki kj kk fd lq lr ls lt aw lu bi"><span id="4ce0" class="ko je hh lr b fi lv lw l lx ly">fun navigate(directions: NavDirections) {<br/>  navigationCommands.postValue(NavigationCommand.To(directions))<br/>}</span></pre><p id="cec2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后从ViewModel导航非常简单，就像这样:</p><pre class="kh ki kj kk fd lq lr ls lt aw lu bi"><span id="9560" class="ko je hh lr b fi lv lw l lx ly">navigate(CardListFragmentDirections.cardDetail(cardId))</span></pre><h1 id="a1cb" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">如何在视图模型中使用参数？</h1><p id="90be" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">视图模型通常需要导航参数来加载一些数据。我们的BaseFragment自动将参数传递给视图模型，如下所示:</p><pre class="kh ki kj kk fd lq lr ls lt aw lu bi"><span id="8153" class="ko je hh lr b fi lv lw l lx ly">override fun onCreate(savedInstanceState: Bundle?) {<br/>  super.onCreate(savedInstanceState)<br/>  if (savedInstanceState == null) {<br/>    vm?.setArguments(arguments)<br/>    vm?.loadData()<br/>  }<br/>}</span></pre><p id="f9f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，ViewModel可以像这样轻松地使用参数:</p><pre class="kh ki kj kk fd lq lr ls lt aw lu bi"><span id="4cc9" class="ko je hh lr b fi lv lw l lx ly">override fun loadData() {<br/>  val cardId = CardDetailFragmentArgs.fromBundle(args).cardId<br/>  load(cardsRepository.getCard(cardId)) {<br/>  …</span></pre><h1 id="87e7" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">如何显示带有深层链接的登录屏幕？</h1><p id="8dea" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">官方文档没有足够详细地描述<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/navigation/navigation-conditional" rel="noopener ugc nofollow" target="_blank">条件导航</a>。它基本上建议在最终目的地处理条件导航。例如，转到个人资料屏幕，然后转到登录屏幕，当用户登录时弹出它。我们不喜欢这种方法，原因如下:</p><ul class=""><li id="0a00" class="lc ld hh ig b ih ii il im ip le it lf ix lg jb lh li lj lk bi translated">登录屏幕应该像另一个根目的地一样。当用户按下登录屏幕上的后退按钮时，应用程序应该会关闭。用户不应该转到上一个屏幕——因为上一个屏幕需要登录，所以用户会陷入无限循环。</li><li id="b36c" class="lc ld hh ig b ih ll il lm ip ln it lo ix lp jb lh li lj lk bi translated">尤其是对于深度链接，当用户没有登录时，根本不应该创建目标片段。创建片段需要一些资源，它开始进行一些网络调用，这些调用由于用户没有登录而失败，等等。如果在这一切发生之前显示登录信息会更好。</li></ul><p id="ce54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们尝试替换NavHostFragment中的导航图，并为登录屏幕创建一个不同的根目录。但在配置改变后，这并不奏效。最后，我们决定使用不同的登录活动。我们的应用程序不再是严格意义上的单一活动，但是登录是一个独立的流程，在这种情况下是有意义的。登录可以有自己的导航图，并且它像我们想要的那样工作——作为另一个导航根。</p><p id="de3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该应用程序直接启动或通过MainActivity的深层链接启动。我们可以通过尽快完成MainActivity并显示LoginActivity来防止加载任何片段:</p><pre class="kh ki kj kk fd lq lr ls lt aw lu bi"><span id="3b30" class="ko je hh lr b fi lv lw l lx ly">override fun onStart() {<br/>  super.onStart()  <br/>  if (sessionRepository.isLoggedOut()) {<br/>    startActivity&lt;LoginActivity&gt;()<br/>    finish()<br/>  }<br/>}</span></pre><p id="c79f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是深度链接呢？幸运的是，我们可以将所有意图参数传递给LoginActivity:</p><pre class="kh ki kj kk fd lq lr ls lt aw lu bi"><span id="2932" class="ko je hh lr b fi lv lw l lx ly">val intent = Intent(this, LoginActivity::class.java)<br/>intent.putExtra("deepLinkExtras", this.intent.extras)<br/>startActivity(intent)<br/>finish()</span></pre><p id="b1a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当用户登录时，我们可以将参数传递回MainActivity:</p><pre class="kh ki kj kk fd lq lr ls lt aw lu bi"><span id="95d5" class="ko je hh lr b fi lv lw l lx ly">val intent = Intent(this, MainActivity::class.java)<br/>intent.putExtras(this.intent.getBundleExtra("deepLinkExtras"))<br/>startActivity(intent)<br/>finish()</span></pre><p id="e2d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这样，我们总是在需要时显示登录，深层链接在两种情况下都有效(用户注销或登录),后退按钮按预期工作。</p><p id="a005" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种方法有一个问题:从深层链接登录后，根目的地没有添加到MainActivity的backstack中。我们通过将所有活动的启动模式改为“singleTask”解决了这个问题。</p><h1 id="98b6" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">如何导航到对话框？</h1><p id="c77a" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">我们的设计有很多<a class="ae jc" href="https://material.io/develop/android/components/bottom-sheet-behavior/" rel="noopener ugc nofollow" target="_blank">底层对话框</a>。它们包含一些像激活卡这样的多步骤流程。我们需要向对话框传递参数，这样可以方便地将它们作为其他片段保存在导航图中。有一个<a class="ae jc" href="https://issuetracker.google.com/issues/80267254" rel="noopener ugc nofollow" target="_blank">特性请求</a>给予官方支持，但是它没有多大优先权。幸运的是，这个库是非常可扩展的，其他导航目的地类型也是可能的。我们使用了这个要点来实现DialogNavigator。</p><p id="55af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，您可以像这样指定对话片段:</p><pre class="kh ki kj kk fd lq lr ls lt aw lu bi"><span id="b655" class="ko je hh lr b fi lv lw l lx ly">&lt;dialog<br/>  android:id="@+id/nav_close_account"<br/>  android:name="de.innoble.abx.closeacc.AccountCloseConfirmDialog"<br/>    &lt;argument<br/>      android:name="iban"<br/>      app:argType="string" /&gt;<br/>&lt;/dialog&gt;</span></pre><p id="d55b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">安全参数和其他任何东西的工作方式都和常规片段一样。</p><p id="2e44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，有一个很大的区别——对话框没有被添加到后台堆栈中。当有多个对话框并且后退按钮被按下时，用户希望看到下面的片段，而不是上一个对话框。它有一个恼人的副作用:当从一个对话框导航时，你需要使用下面片段的FragmentDirections，而不是对话框。这有点违背直觉，但在开发过程中很快就被发现了(应用程序崩溃时会出现异常“导航目的地对此NavController未知”)。</p><h1 id="8e30" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">如何返回一个结果？</h1><p id="a0de" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">类似于<code class="du lz ma mb lr b">startActivityForResult()</code>的东西会非常方便。Google推荐使用一个<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/viewmodel#sharing" rel="noopener ugc nofollow" target="_blank">共享视图模型</a>来实现这一点，但是这个API并不直观。有一个关于这个的特性请求，但是它的优先级很低。在官方支持到来之前，我们一直在使用自己的解决方案。首先定义这个接口:</p><pre class="kh ki kj kk fd lq lr ls lt aw lu bi"><span id="7a3d" class="ko je hh lr b fi lv lw l lx ly">interface NavigationResult {<br/>    fun onNavigationResult(result: Bundle)<br/>}</span></pre><p id="9ad1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在您想要接收结果的片段中实现这个接口。从另一个片段发送结果必须通过一个活动来路由。将此方法添加到您的活动中:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="22be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，这个解决方案仅适用于片段导航目的地。</p><h1 id="c3b5" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">TLDR；</h1><ul class=""><li id="e9b2" class="lc ld hh ig b ih kb il kc ip me it mf ix mg jb lh li lj lk bi translated">在多模块项目中，将导航XML放入“common-android”模块。</li><li id="ea0f" class="lc ld hh ig b ih ll il lm ip ln it lo ix lp jb lh li lj lk bi translated">通过单个LiveEvents命令从视图模型导航。将所有样板文件放入BaseFragment/BaseViewModel。</li><li id="40fb" class="lc ld hh ig b ih ll il lm ip ln it lo ix lp jb lh li lj lk bi translated">使用安全参数并将片段参数自动传递给ViewModel。</li><li id="9bf6" class="lc ld hh ig b ih ll il lm ip ln it lo ix lp jb lh li lj lk bi translated">对登录屏幕使用不同的活动。来回传递额外意图以支持深层链接。</li><li id="64a3" class="lc ld hh ig b ih ll il lm ip ln it lo ix lp jb lh li lj lk bi translated">在这个要点的帮助下，在导航图中包含对话框。注意不要将对话框添加到后台堆栈中。</li><li id="5b01" class="lc ld hh ig b ih ll il lm ip ln it lo ix lp jb lh li lj lk bi translated">使用我们的解决方案导航返回结果，直到官方支持到达。</li></ul></div></div>    
</body>
</html>