<html>
<head>
<title>Kotlin: should I define Function or Property?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林:我应该定义功能还是属性？</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/kotlin-should-i-define-function-or-property-6786951da909?source=collection_archive---------0-----------------------#2018-04-11">https://blog.kotlin-academy.com/kotlin-should-i-define-function-or-property-6786951da909?source=collection_archive---------0-----------------------#2018-04-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2c53677ad3284253a5686669d4ffba5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYb1hkNkuwIeH-q2gGjpjw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/photos/zGEaKWQqYY4?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">grafixart grafixart_photo</a> on <a class="ae jz" href="https://unsplash.com/search/photos/close?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e1fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近，我意识到在属性和函数的使用上存在混淆。科特林引入属性的概念是有充分理由的。问题出现了——什么时候使用一个而不是另一个？我建议你遵循的最简单的规则是:</p><ul class=""><li id="5581" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">属性描述状态</li><li id="d1f1" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="kc io">功能</strong>描述行为</li></ul><p id="58e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们仔细看看他们两个。<strong class="kc io">属性</strong>代表一种可以描述对象状态的数据结构，例如:<strong class="kc io"> Person </strong> object可以有<strong class="kc io"> <em class="lm"> name </em> </strong>、<strong class="kc io"> <em class="lm"> lastName </em> </strong>和<strong class="kc io"> <em class="lm"> weight </em> </strong>属性。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="0dd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还可以拥有<a class="ae jz" href="https://www.uml-diagrams.org/derived-property.html" rel="noopener ugc nofollow" target="_blank">派生属性</a>——通过组合<strong class="kc io"> <em class="lm">名称</em> </strong>和<strong class="kc io"> <em class="lm">姓氏</em> </strong>创建的动态计算的属性，例如<strong class="kc io"> <em class="lm">全名</em> </strong>。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="9261" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，属性值只被评估一次——在<em class="lm"> Person </em> object创建期间。有时这是一种可取的行为，但在这种情况下，当我们改变一个<em class="lm"> name </em>或<em class="lm"> lastName </em>属性的值时，存储在<em class="lm"> fullName </em>中的值将不会被更新。幸运的是，Kotlin还让我们能够使用<em class="lm"> getter </em>或<em class="lm"> setter </em>来定义属性。在下面的例子中，<em class="lm"> fullName </em>属性的值将在每次访问时被评估。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="4b8f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">功能</strong>，<strong class="kc io"> </strong>另一方面，都是关于对象可以执行的行为或动作。我们的<strong class="kc io">人</strong>类本来可以有<strong class="kc io"><em class="lm"/></strong><em class="lm"/><strong class="kc io"><em class="lm">走()</em> </strong> <em class="lm"> </em>和<strong class="kc io">跳()</strong>的方法。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="25fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">重要的是要注意，方法可能(并且经常会)间接地修改对象的状态，作为执行动作的副作用，例如，每次我们调用<strong class="kc io">jump()</strong>person<strong class="kc io">weight</strong>减少0.1。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="8004" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您仍然不清楚何时使用属性来运行，那么从外部客户的角度来考虑它们可能会有所帮助。我们应该暂时忘记内部实现(属性存储在哪里或者行为是如何实现的),而只看外部API(类似于将第三方库添加到我们的项目中，我们只访问API)。</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="de94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">科特林引入属性有几个很好的理由。其中之一是<em class="lm">属性访问语法</em>(我们使用<em class="lm">高度</em>而不是<em class="lm">getHeight</em>/<em class="lm">setHeight</em>)更简洁，另一个是getter和setter更接近于属性声明，不像Java通常将property放在类的顶部，getter/setter放在底部。我最喜欢的特性是<em class="lm">属性委托</em>，它增加了重用代码的能力。我们可以在需要的时候初始化一个变量(<a class="ae jz" href="https://kotlinlang.org/docs/reference/delegated-properties.html#lazy" rel="noopener ugc nofollow" target="_blank">惰性委托</a>)，在属性值改变的时候执行一些动作<a class="ae jz" href="https://kotlinlang.org/docs/reference/delegated-properties.html#observable" rel="noopener ugc nofollow" target="_blank">(可观察委托</a>)或者使用一个自定义委托将我们的属性存储在另一个对象中(Android共享首选项、地图、浏览器会话、数据库……)。</p><blockquote class="lt lu lv"><p id="a5f9" class="ka kb lm kc b kd ke kf kg kh ki kj kk lw km kn ko lx kq kr ks ly ku kv kw kx ig bi translated">好的一面是Kotlin允许我们在接口中使用函数(技术上的方法)和属性。</p></blockquote><p id="ec55" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">需要注意的是，来自Java的开发人员(在Java中我们没有属性的概念)倾向于过度使用函数。这里有一个很好的重构到属性的候选者:</p><figure class="ln lo lp lq gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="6666" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们看到一个以<strong class="kc io"> set </strong>前缀开始的方法(例如<em class="lm"> setWeight </em>)有一个参数，并将其分配给私有字段，或者以<strong class="kc io"> get </strong>开始的方法返回私有字段值(getWeight)时，我们可能应该定义property。</p><h2 id="0cf2" class="lz ma in bd mb mc md dn me mf mg dp mh kl mi mj mk kp ml mm mn kt mo mp mq mr bi translated">指导方针:如何做决定？</h2><p id="4d95" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">每次你想声明新函数的时候，问自己两个问题:</p><ul class=""><li id="3c6b" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">“它描述了一种行为吗？”—描述行为的<strong class="kc io">函数</strong>的候选函数，例如<strong class="kc io"> <em class="lm"> run() </em> </strong> <em class="lm">、</em><strong class="kc io"><em class="lm">walk()</em></strong><em class="lm"/>和<strong class="kc io"> jump() </strong></li><li id="9ce0" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">“它描述了一种状态吗？”—<strong class="kc io">属性的候选项</strong>描述状态，如<strong class="kc io"> <em class="lm">姓名</em> </strong>、<strong class="kc io"> <em class="lm">姓氏</em> </strong>、<strong class="kc io"> <em class="lm">体重</em> </strong></li></ul><p id="4d5e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有一组额外的指导原则(如果我没记错的话，来自Effective Java)帮助我们判断属性是否优于功能:</p><ul class=""><li id="0c91" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">不引发异常</li><li id="ef23" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">计算成本低(或在第一次运行时缓存)</li><li id="ca5e" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">多次调用后返回相同的结果</li></ul><p id="60c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的指导方针应该给你一个很好的主意，不管特定的成员应该是函数还是属性。在开始的时候，定义属性可能有点不自然(特别是对于Java开发人员来说)，但是相信我——过一段时间，这个决定就会很明显了。</p></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="5bb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢这篇文章，请在这里和twitter上关注我👏。我很想在评论区听到你的想法。</p><p id="310e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要了解最新的精彩文章，你还可以<a class="ae jz" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>。</p><figure class="ln lo lp lq gt jo gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi ne"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure></div></div>    
</body>
</html>