<html>
<head>
<title>Plugging in additional auth mechanism to Django admin login</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Django管理员登录中插入额外的认证机制</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/pluging-in-additional-auth-mechanism-to-django-admin-login-ae22d0bd0da1?source=collection_archive---------0-----------------------#2018-01-22">https://medium.com/walmartglobaltech/pluging-in-additional-auth-mechanism-to-django-admin-login-ae22d0bd0da1?source=collection_archive---------0-----------------------#2018-01-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b0d049bf432fed44da9173aaf9349212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aVzJTznRRfP1lM7AXe9yLw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Image credits : <a class="ae it" href="https://unsplash.com/photos/aiyBwbrWWlo" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/aiyBwbrWWlo</a></figcaption></figure><p id="6eaa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们都非常喜欢Django的管理界面。对于对异步UI知之甚少的开发人员来说，它简化了部署应用程序的大量工作。Django管理界面的美妙之处在于，通过一个非常简单的UI编码(甚至不涉及HTML、CSS、JavaScript)，你可以调出一个web界面，为用户提供丰富的交互。访问管理界面的认证基于表<strong class="iw hi">Django _ auth _ users</strong>of<strong class="iw hi"/>Django中的users对象。该表上的CRUD操作只能通过使用<strong class="iw hi"> python </strong>脚本“<strong class="iw hi"> manage.py </strong>”来执行。在这篇文章中，我将介绍自定义管理界面后端逻辑访问的步骤。这将允许用户将管理员登录界面集成到任何其他身份验证方法，如IAM。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="c3a8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我将在下面的Django项目目录的帮助下演示这个过程。</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="fb75" class="ki kj hh ke b fi kk kl l km kn">project_name/<br/>├── project_name/<br/>│   ├── admin.py<br/>│   ├── urls.py<br/>│   ├── uwsgi.py<br/>│   └── __init__.py<br/>└── app/<br/>    ├── admin.py<br/>    ├── urls.py<br/>    ├── models.py<br/>    └── ...</span></pre><p id="c6e6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设您的应用程序的<strong class="iw hi"> models.py </strong>中有一个非常简单的模型。</p><figure class="jz ka kb kc fd ii"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><strong class="ak">app/models.py</strong></figcaption></figure><p id="64f2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">那么默认的<strong class="iw hi"> admin.py </strong>将看起来像这样。</p><figure class="jz ka kb kc fd ii"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><strong class="ak">app/admin.py</strong></figcaption></figure><p id="840e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个管理文件我们将注册一个模型，<strong class="iw hi">我的模型</strong>到管理界面，这将使模型可见，用于直接添加/更新/删除数据库的<strong class="iw hi">我的模型</strong>对象。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="464b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们将开始使用Django的定制认证后端来挂钩管理登录页面的过程。</p><ol class=""><li id="4792" class="kq kr hh iw b ix iy jb jc jf ks jj kt jn ku jr kv kw kx ky bi translated">首先，我们将在应用程序文件夹中创建一个文件名为<strong class="iw hi"> backend.py </strong>的文件。这将为我们的应用程序存储自定义后端逻辑，并将包含以下内容。</li></ol><figure class="jz ka kb kc fd ii"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><strong class="ak">backend.py</strong></figcaption></figure><p id="7067" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个文件包含定义两个方法<strong class="iw hi"> get_user的类的定义。</strong>和<strong class="iw hi">认证。</strong>一旦在任何类中定义了这些方法，该类就成为认证后端的合适候选。我还有一个全局方法<strong class="iw hi"> my_portal_authenticate </strong>，它是Django登录机制如何认证用户输入的用户名和密码的核心实现，并将在整个会话中维护。这里需要注意的一点是，如果用户第一次登录，我会将新用户保存到<strong class="iw hi"> django_auth_user </strong>表中。这很重要，因为Django管理后端(默认的)与Django <strong class="iw hi">用户</strong>模型是严格耦合的，我们正在覆盖默认后端的行为。这也允许服务后端检索会话用户。我们的解决方法是将管理默认站点与自定义django <strong class="iw hi"> AdminSite </strong>对象挂钩，然后允许这个<strong class="iw hi"> AdminSite </strong>对象使用我们刚刚在<strong class="iw hi"> backend.py </strong>中编码的自定义后端。</p><p id="4610" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">2.创建一个登录表单来调用定制的后端功能，该功能稍后将被转换为Admin登录表单，在你的应用程序目录中的文件say <strong class="iw hi"> login.py </strong>。这个文件将实现一个类，该类将创建Django表单来覆盖默认的登录验证方法。</p><figure class="jz ka kb kc fd ii"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><strong class="ak">app/login.py</strong></figcaption></figure><p id="7dc3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">3.使用Django <strong class="iw hi"> AdminSite </strong>更改默认的管理员登录表单。</p><figure class="jz ka kb kc fd ii"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><strong class="ak">New Version of admin.py</strong></figcaption></figure><p id="a7c3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">4.最后一步是通知Django urls使用定制的登录AdminSite对象，而不是默认对象。去<strong class="iw hi"> urls.py </strong>在你的项目设置中，而不是在应用程序设置中，添加以下内容。</p><figure class="jz ka kb kc fd ii"><div class="bz dy l di"><div class="ko kp l"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><strong class="ak">urls.py</strong></figcaption></figure><p id="5d31" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们还必须更新<strong class="iw hi">authentic ation _ BACKENDS</strong>来将自定义后端更新到我们已经实现的后端。用新变量更新<strong class="iw hi">项目名称/设置. py </strong>。</p><figure class="jz ka kb kc fd ii"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="e63b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，所需的更改已经完成。</p><p id="785b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">照常访问您的管理站点。如果是在localhost上运行，那就玩<a class="ae it" href="http://localhost:8000." rel="noopener ugc nofollow" target="_blank"><strong class="iw hi">http://localhost:8000</strong></a></p></div></div>    
</body>
</html>