<html>
<head>
<title>Deploy Neo4j on Kubernetes using Helm Chart and Azure DevOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Helm Chart和Azure DevOps在Kubernetes上部署Neo4j</h1>
<blockquote>原文：<a href="https://medium.com/globant/deploy-neo4j-on-kubernetes-using-helm-chart-and-azure-devops-615f3190ea96?source=collection_archive---------0-----------------------#2022-08-26">https://medium.com/globant/deploy-neo4j-on-kubernetes-using-helm-chart-and-azure-devops-615f3190ea96?source=collection_archive---------0-----------------------#2022-08-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/9ce56b4654210fc8b8d053ba581f006a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hhuGWHmUFa3w2APj"/></div></div></figure><p id="0cf5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文旨在记录如何使用K8s中的舵图部署Neo4J因果集群。如果用户对在AKS中部署neo4j感兴趣，可以关注这篇文章，在这个过程中学习理论。</p><p id="19c6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本指南中，您将看到:</p><ol class=""><li id="034e" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">Neo4j简介</li><li id="39af" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">运行在Kubernetes上的Neo4J</li><li id="3701" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">舵图表包构建</li><li id="f96e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">舵图表包部署(CD —继续部署)</li><li id="876c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">结论</li></ol><p id="cfd8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">Neo4j简介</strong></p><p id="f08d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> a. Neo4j图形平台</strong></p><p id="682c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Neo4j Graph平台包括一些组件，使开发人员能够创建支持图形的应用程序。开发人员、管理员、数据分析师和数据科学家使用它来访问应用程序数据。开发人员通过将数据导入到图表中或者使用Cypher语言实现数据模型来创建图表中的数据。此外，开发人员负责将图形与其他系统和DBMS安装集成在一起。管理员管理与Neo4j安装相关的流程和文件。数据科学家和数据分析师通常结合使用密码查询和工具来分析数据。最终用户通常使用开发人员编写的应用程序来访问图形数据。</p><p id="1826" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要查看更多详情，请前往https://neo4j.com/docs/getting-started/current/<a class="ae kb" href="https://neo4j.com/docs/getting-started/current/" rel="noopener ugc nofollow" target="_blank"/></p><figure class="kd ke kf kg fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kc"><img src="../Images/270b861882be4a72e5bbe3b2d679a00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3r5OqKenq6yL31wz"/></div></div></figure><p id="eb59" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> b. Raft协议</strong></p><p id="cc37" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">无论是独立安装还是docker-Kubernetes安装，neo4j都使用一个或多个核心服务器来工作(取决于设置)。neo4j使用的另一个策略是Raft协议。Raft的主要设计目标之一是易于理解，以便在实现中隐藏更少的棘手错误。Raft协议描述了一个实例可以扮演的三个角色:<strong class="ir hi">领导者</strong>、<strong class="ir hi">跟随者</strong>和候选者。这些都是暂时的角色，任何核心服务器都可以在集群的整个生命周期中扮演这些角色。虽然从计算科学的角度来看理解这些状态很有趣，但是操作者不应该过分担心:它们是实现的细节。由于每个数据库都在逻辑上独立的Raft组中运行，所以核心服务器可以有多个角色:每个数据库一个角色。例如，它可以是数据库系统的领导者，同时也是数据库neo4j的追随者。</p><p id="9526" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦启动，每个核心服务器就花时间处理数据库事务。通过Raft协议在核心服务器周围可靠地复制更新。更新以包含事务命令的(提交的)Raft日志条目的形式出现，这些事务命令随后被应用来更新数据库。</p><p id="599f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了安全起见，在任何Raft协议实例中，只有一个<strong class="ir hi">领导者</strong>能够在任何给定的期限内向前推进。对于<strong class="ir hi">的跟随者</strong>，由<strong class="ir hi">的领导</strong>负责对木排日志条目下达命令，并推动日志前进。<strong class="ir hi">追随者</strong>根据当前<strong class="ir hi">领导者</strong>的日志维护他们的日志。如果集群中的任何参与者怀疑<strong class="ir hi">领导者</strong>已经失败(没有接收到新的条目或心跳)，那么他们可以通过进入候选状态来发起领导者选举。在Neo4j核心服务器中，此故障检测窗口默认设置为20秒以上，以支持更稳定的领导者。</p><p id="3a77" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是非阻塞共识协议的本质，它允许Neo4j因果集群为应用程序提供连续可用性。</p><p id="aabb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要查看更多详细信息，请访问<a class="ae kb" href="https://neo4j.com/docs/operations-manual/current/clustering-advanced/lifecycle/#causal-clustering-transacting-via-raft-protocol" rel="noopener ugc nofollow" target="_blank">因果聚类生命周期-操作手册(neo4j.com)</a></p><p id="72e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 2。运行在Kubernetes上的Neo4J】</strong></p><figure class="kd ke kf kg fd ii er es paragraph-image"><div class="er es kh"><img src="../Images/4d22376828e4c90cf83e9d8024358440.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/0*0MWE6-DCcox2N1W6"/></div></figure><p id="79d5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> a .状态集和持久卷</strong></p><p id="f7da" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Kubernetes中的Neo4j Docker使用stateful set<strong class="ir hi">:neo4j-neo4j-core</strong>。生产环境需要核心模式，至少有三个单元，一个领导者和两个追随者。在开发环境中，您可以使用单一模式(单一实例，只有一个pod)。此外，neo4j使用两个数据库:用于管理目的的system DB和用于业务数据的neo4j数据库:</p><figure class="kd ke kf kg fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ki"><img src="../Images/b2dd269bcde94bc919ff80c7b4912cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sUO2bxQnPdQ0Djki"/></div></div></figure><p id="af4d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">转到上一个名为“<strong class="ir hi"> b. Raft protocol </strong>的点来看看关于这个的理论。</p><p id="ee09" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在体系结构级别，每个单元都有各自的卷(磁盘)用于存储持久数据:</p><figure class="kd ke kf kg fd ii er es paragraph-image"><div class="er es kj"><img src="../Images/78e34616825bad7c58c94039e30e45e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/0*4K7ftBK6PTLvRg5u"/></div></figure><p id="298f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> b .通信</strong></p><p id="1f4a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Neo4j是要和一个或者多个app进行通信的。在图像中，您可以看到与两个应用程序的通信:数据模块和报告模块。使用bolt协议(端口TCP:7687)可以做到这一点:</p><figure class="kd ke kf kg fd ii er es paragraph-image"><div class="er es kk"><img src="../Images/a529d949cb8dc321f08df73207033df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/0*gQoubfezukN4EIrV"/></div></figure><p id="c5c3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 3。舵图包构建</strong></p><p id="d8d9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> a .舵图的主要修改</strong></p><p id="67f5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于4.4.x版本，您可以从以下GitHub链接下载Helm Chart的源代码:</p><p id="0acc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae kb" href="https://github.com/neo4j-contrib/neo4j-helm/tree/4.4.3" rel="noopener ugc nofollow" target="_blank">https://github.com/neo4j-contrib/neo4j-helm/tree/4.4.3</a>。</p><p id="6823" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有必要修改舵图上的这些文件:</p><ul class=""><li id="c3d3" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kl jt ju jv bi translated">文件<strong class="ir hi">/templates/core-stateful set . YAML</strong>:</li></ul><figure class="kd ke kf kg fd ii"><div class="bz dy l di"><div class="km kn l"/></div></figure><ul class=""><li id="fe7e" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kl jt ju jv bi translated">文件<strong class="ir hi"> pv-pvc-volumes.yaml </strong>创建指向文件共享(存储帐户)的卷:</li></ul><figure class="kd ke kf kg fd ii"><div class="bz dy l di"><div class="km kn l"/></div></figure><ul class=""><li id="95fb" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kl jt ju jv bi translated">文件<strong class="ir hi">/develop-RCM/values . YAML</strong>:</li></ul><figure class="kd ke kf kg fd ii"><div class="bz dy l di"><div class="km kn l"/></div></figure><p id="c40b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">b .创建映像并准备文件以部署包(CI-持续集成)。</p><p id="e411" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Neo4j Docker映像包括一些基本的默认配置，在大多数情况下不需要调整。</p><p id="7817" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">默认情况下，Docker映像为远程访问提供了三个端口:</p><ul class=""><li id="f35a" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kl jt ju jv bi translated">HTTP的7474</li><li id="42ce" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kl jt ju jv bi translated">7473去HTTPS</li><li id="fd5d" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm kl jt ju jv bi translated">螺栓7687</li></ul><p id="af3b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将使用这些端口连接到容器内部的Neo4j，从Neo4j浏览器、应用程序或其他方法访问它。</p><p id="f1b8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它建议在k8s集群上部署映像之前创建映像，使用WhiteSource工具扫描它，并使用AquasecScanner工具检查它是否是安全的映像。</p><p id="7905" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在部署映像之前，我们使用以下简单命令添加一个docker文件:</p><figure class="kd ke kf kg fd ii"><div class="bz dy l di"><div class="km kn l"/></div></figure><p id="64d9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">更多详情，请访问<a class="ae kb" href="https://neo4j.com/developer/docker-run-neo4j/" rel="noopener ugc nofollow" target="_blank"> How-To:在Docker —开发者指南中运行Neo4j</a>和<a class="ae kb" href="https://neo4j.com/developer/docker/?_gl=1*13q1jh2*_ga*NjU5MTI4NTUyLjE2MTUyMTg4NTM.*_ga_DL38Q8KGQC*MTY1NzI5NDgyNS4xMDguMS4xNjU3Mjk2MjE4LjA." rel="noopener ugc nofollow" target="_blank">在Docker —开发者指南中运行Neo4j</a></p><p id="c99f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要在Azure DevOps中准备包，您可以创建一个构建管道来获取代码，用docker文件构建映像，用WhiteSource清理代码，用AquasecScanner工具检查映像的安全性，将映像推送到注册表，并复制和发布helm chart文件。这是用于WhiteSource和AquasecScanner工具的yml代码:</p><figure class="kd ke kf kg fd ii"><div class="bz dy l di"><div class="km kn l"/></div></figure><p id="4edf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 4。舵图表包展开(CD —继续展开)</strong></p><p id="1661" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">创建一个包含三个简单任务的Azure DevOps发布管道，使用我们在上一步中构建的工件来部署neo4j helm图表:</p><p id="e8da" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">带有Helm版本规范“3.1.0”的“Helm工具安装程序”</p><p id="18c1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">“替换令牌”用于替换变量，</p><p id="4a72" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过指定“图表路径”和“值文件”来“打包和部署舵图表”</p><figure class="kd ke kf kg fd ii er es paragraph-image"><div class="er es ko"><img src="../Images/f09f5b35d03719b516f26a4e410d0c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/0*jrdpuq9PlJuBbPNS"/></div></figure><p id="b6ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">路径:</p><figure class="kd ke kf kg fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kp"><img src="../Images/f32afcf8a92179d6482a8f7bf3331156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VaZ0EQe434JmuSJs"/></div></div></figure></div><div class="ab cl kq kr go ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ha hb hc hd he"><p id="ac78" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 5。结论</strong></p><p id="cc9f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用Docker的k8s中的Neo4j工作起来就像一个独立的安装，其优点是您拥有k8s的所有功能。基本上，你只能从Docker Hub库获取图像，并在helm图表中配置一些部分，就完成了。您可以使用Azure管道在AKS K8s中创建包和部署映像。此外，一些重要数据(如日志、Prometheus指标和备份)在集群中配置为指向文件共享(存储帐户)的永久卷，以分隔信息，防止数据丢失。</p></div></div>    
</body>
</html>