<html>
<head>
<title>How to Secure Secrets 🔑 in Android — Android Security-01</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何保护机密🔑在Android中— Android Security-01</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/how-to-secure-secrets-in-android-android-security-01-a345e97c82be?source=collection_archive---------0-----------------------#2021-07-30">https://blog.kotlin-academy.com/how-to-secure-secrets-in-android-android-security-01-a345e97c82be?source=collection_archive---------0-----------------------#2021-07-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6200" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在构建处理API、从服务器接收的令牌、在本地数据库中存储凭证、将安全数据发送到网络上以及许多其他场景的应用程序时，安全性是一个关键要求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3369a7bdcbe7947699051f451f05f53e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcYENFLfavTX07Q9XtlXRw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image from FreePik</figcaption></figure><blockquote class="ky"><p id="05fc" class="kz la in bd lb lc ld le lf lg lh kh dk translated">绝对安全是不存在的。安全是一套措施，被堆积和组合，试图减缓不可避免的。</p></blockquote></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><blockquote class="lp lq lr"><p id="58ac" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">社区参与</p></blockquote><div class="lw lx gp gr ly lz"><a href="https://dormoshe.io/newsletters/ag/android/67?utm_source=twitter&amp;utm_campaign=twitter" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd io gy z fp me fr fs mf fu fw im bi translated">Android趋势# 67-2021年8月3日- Dor Moshe的博客</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">订阅时事通讯，享受每周学习新知识的最新动态。</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">dormoshe.io</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ks lz"/></div></div></a></div></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="76bf" class="mo mp in bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">介绍</h1><p id="ecdd" class="pw-post-body-paragraph jk jl in jm b jn nm jp jq jr nn jt ju jv no jx jy jz np kb kc kd nq kf kg kh ig bi translated">无论是移动应用、web应用还是桌面应用，安全性都是关键概念。开发人员尽最大努力构建一个安全的应用程序来防止它被黑客绕过，这是一项复杂的任务。谷歌和其他一些组织正在不知疲倦地提供最好的安全工具。</p><p id="79b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">来说说我们的主要话题:<em class="ls">安卓</em>T3】</strong></p><p id="fd19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">问题出现了:我们是否可以通过使用本地<strong class="jm io">硬编码密钥</strong>加密我们的秘密/数据，并将加密的数据保存在<strong class="jm io">首选项、本地数据库中，并轻松共享给网络</strong>来轻松保护我们的秘密/数据？</p><p id="398a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">答案是</strong>黑客可以轻松反编译我们的代码，获取你的硬编码密钥，破坏你的app安全。</p><blockquote class="lp lq lr"><p id="10e2" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>我们无法创建完全安全的系统，但我们的主要目标是构建不太复杂、但黑客更难绕过的系统。</p></blockquote><p id="56a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第二个答案</strong>，如果是API密匙那么黑客很容易就可以:</p><ul class=""><li id="ef01" class="nr ns in jm b jn jo jr js jv nt jz nu kd nv kh nw nx ny nz bi translated">扰乱你的数据，</li><li id="4082" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh nw nx ny nz bi translated">生成大量的API调用，这会极大地增加您的成本。</li></ul><p id="8241" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在构建应用程序时，我们尝试保护多个端点，包括:</p><ul class=""><li id="b025" class="nr ns in jm b jn jo jr js jv nt jz nu kd nv kh nw nx ny nz bi translated">API-Key</li><li id="173b" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh nw nx ny nz bi translated">代币</li><li id="0581" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh nw nx ny nz bi translated">共享偏好</li><li id="959d" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh nw nx ny nz bi translated">文件</li><li id="1114" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh nw nx ny nz bi translated">本地数据库数据</li></ul><p id="02e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">几十年来，许多开发人员使用多种算法来保护他们的应用程序，但所有这些方法都有自己的局限性。实现加密的几种算法列举如下:</p><ul class=""><li id="bec9" class="nr ns in jm b jn jo jr js jv nt jz nu kd nv kh nw nx ny nz bi translated"><a class="ae of" href="https://en.wikipedia.org/wiki/Cipher" rel="noopener ugc nofollow" target="_blank">密码加密</a></li><li id="d280" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh nw nx ny nz bi translated"><a class="ae of" href="https://github.com/VirgilSecurity/virgil-crypto.git" rel="noopener ugc nofollow" target="_blank">维吉尔加密</a></li><li id="d009" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh nw nx ny nz bi translated"><a class="ae of" href="https://www.tutorialspoint.com/cryptography/advanced_encryption_standard.htm" rel="noopener ugc nofollow" target="_blank"> AES加密</a></li></ul><p id="76f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文将介绍加密所有上述端点的传统方法和当前首选方法。</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="294b" class="mo mp in bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">从保护最重要选项(即API-Key)的传统方法开始</h1><ul class=""><li id="33f3" class="nr ns in jm b jn nm jr nn jv og jz oh kd oi kh nw nx ny nz bi translated"><strong class="jm io">字符串|资源文件</strong></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/6635e87edac9e020c8cc17e237322a93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DI2SspkCmfFHl6vloSccyQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Store api_key in resource file</figcaption></figure><p id="e3cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在过去，我们试图使用这种方法，但它并不安全。为什么？这是因为如果你在一个字符串或资源文件中定义关键字，把它放在一个环境变量中，并生成一个<code class="fe ok ol om on b">apk</code>，Gradle把这些关键字放在一个字符串文件中，这个字符串文件可以通过<strong class="jm io">逆向工程过程</strong>轻松访问。</p><ul class=""><li id="3cad" class="nr ns in jm b jn jo jr js jv nt jz nu kd nv kh nw nx ny nz bi translated">格雷德。通过BuildConfig 的属性和访问</li></ul><blockquote class="lp lq lr"><p id="4bbb" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">gradle.properties文件</p></blockquote><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="d397" class="os mp in on b gy ot ou l ov ow">APIKEY = "c527aa8fadcb58f1cccef75e3a64a3ae"</span></pre><blockquote class="lp lq lr"><p id="c1bb" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">build.gradle文件</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/bdc79f0d3c5bd93537b558cb301166a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aK8_qNKmtQ3GJ-a8jlXbvA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Call key in build. gradle file</figcaption></figure><blockquote class="lp lq lr"><p id="fbef" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">访问任何。KT|。JAVA文件</p></blockquote><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="b4e9" class="os mp in on b gy ot ou l ov ow">val API_KEY = BuildConfig.APIKEY;</span></pre><p id="172f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也许你认为这个过程是安全的，因为我们把我们的<strong class="jm io"> api_key </strong>放在了已经被添加到<code class="fe ok ol om on b"><strong class="jm io">.gitignore</strong></code>列表中的<code class="fe ok ol om on b"><strong class="jm io">gradle.properties</strong></code>文件中？不，这个过程只是保护它不被GitHub窃取，而不是从应用程序中窃取🤔。当我们通过BuildConfig文件和<strong class="jm io">逆向工程过程</strong>获取密钥时，黑客将获得所有java类和<code class="fe ok ol om on b">.dex</code>文件中的Buildconfig类。所以，你只是在保护密钥不被破坏GitHub库的人破坏，这种情况很少发生，而不是防止更容易发生的逆向工程。</p><blockquote class="lp lq lr"><p id="e0b0" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">上面定义的传统方法没有涵盖我们的主要用例，即安全性。我得到的唯一解决方案是，开发人员将<strong class="jm io">密钥</strong>放在服务器上，并使用令牌化场景来获得那个<strong class="jm io">密钥</strong>。但是如果我们的应用程序离线工作呢？在这种情况下，我们如何管理它？<em class="in">🤷‍♀️ </em></p></blockquote></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="8600" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们认识到我们需要一个安全的密钥管理框架来处理所有的安全问题，然后我们得到了这两个有用的方法:</p><ol class=""><li id="82c2" class="nr ns in jm b jn jo jr js jv nt jz nu kd nv kh oy nx ny nz bi translated"><a class="ae of" href="https://developer.android.com/ndk" rel="noopener ugc nofollow" target="_blank"> CMake —带有NDK </a> <em class="ls">的本地库(在某些情况下，我们称之为模糊键)</em></li><li id="fa96" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh oy nx ny nz bi translated"><a class="ae of" href="https://developer.android.com/topic/security/data" rel="noopener ugc nofollow" target="_blank">安卓Jetpack安全</a></li></ol><h1 id="ee11" class="mo mp in bd mq mr oz mt mu mv pa mx my mz pb nb nc nd pc nf ng nh pd nj nk nl bi translated">CMake—NDK的本地图书馆</h1><p id="198e" class="pw-post-body-paragraph jk jl in jm b jn nm jp jq jr nn jt ju jv no jx jy jz np kb kc kd nq kf kg kh ig bi translated">根据android指南</p><blockquote class="lp lq lr"><p id="6403" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">Android NDK是一个工具集，可以让你使用C和C++等语言，用本机代码实现应用程序的一部分。对于某些类型的应用程序，这可以帮助您重用用这些语言编写的代码库。</p></blockquote><p id="b31a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi pe translated"><span class="l pf pg ph bm pi pj pk pl pm di">在</span>这个方法中，我们将在本机<strong class="jm io"> NDK C++ </strong>代码中定义我们的<code class="fe ok ol om on b">api_key</code>，与<code class="fe ok ol om on b">resource.file</code>或<code class="fe ok ol om on b">gradle.properties</code>相比，它很难被任何黑客反编译，因为NDK在<code class="fe ok ol om on b"><strong class="jm io">.so</strong></code> <strong class="jm io"> </strong>文件中编译代码，而这个文件只包含原始数据和少数几个字符串，所以在<strong class="jm io">逆向工程过程之后，</strong>黑客将很难识别密钥的位置，因为它的位置相对于PC发生了变化。</p><blockquote class="lp lq lr"><p id="a3ad" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>当你使用离线应用程序存储数据并在一天结束时将数据上传到服务器时，NDK过程也是受支持的。在这种方法中，你不能实现任何标记化概念，所以这里NDK闪耀。</p></blockquote><p id="a5cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要使用NDK(本地开发工具包)方法，您必须遵循以下步骤来保护您的密钥:</p><ul class=""><li id="5828" class="nr ns in jm b jn jo jr js jv nt jz nu kd nv kh nw nx ny nz bi translated"><strong class="jm io">使用NDK (C++模板)</strong> →提供一种在Android中使用C/C++代码的方法。</li><li id="04b8" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh nw nx ny nz bi translated"><strong class="jm io">使用ndk.build (CMAKE) </strong> →构建您的本机c++库</li></ul><blockquote class="lp lq lr"><p id="92f7" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">这是一个痛苦的事实，但我们也可以说这种方法模糊了密钥，也没有保护密钥。</p></blockquote><h2 id="e8ae" class="os mp in bd mq pn po dn mu pp pq dp my jv pr ps nc jz pt pu ng kd pv pw nk px bi translated">如何配置NDK:</h2><blockquote class="lp lq lr"><p id="f57d" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">首先，通过SDK工具安装这些:</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/6f593b8c315ed2f84e94bea5c429824c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9f6Y93CyOtK02A5TdiObyA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Install NDK and CMAKE</figcaption></figure><blockquote class="lp lq lr"><p id="9b49" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">其次，创建一个<code class="fe ok ol om on b"><em class="in">CMakeLists.txt</em></code>文件</p></blockquote><p id="be7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ok ol om on b">app/</code>目录下创建一个CMakeLists文件，并将下面的要点复制到其中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pz qa l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">CMakesList file</figcaption></figure><blockquote class="lp lq lr"><p id="44ab" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">第三，在cpp文件中保护你的密钥</p></blockquote><p id="1236" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ok ol om on b">app/src/main/</code>的根目录下创建一个文件夹<code class="fe ok ol om on b">cpp</code>，然后在同一个文件夹下创建<code class="fe ok ol om on b">lib.cpp</code>文件<em class="ls">(可以使用自己的命名约定)</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/dc7445f522596b78b2277177c9af1b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*Nk6jupsw3o6XFk_7UqAikA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Explorer view of cpp file</figcaption></figure><blockquote class="lp lq lr"><p id="7051" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated"><strong class="jm io">注意</strong>:不要在git中包含这个文件夹。或者您可以添加该文件夹路径，即<code class="fe ok ol om on b"><em class="in">app/.gitignore.</em></code>中的<code class="fe ok ol om on b"><em class="in">/src/main/cpp/lib.cpp</em></code></p></blockquote><p id="e2a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在您的<code class="fe ok ol om on b">main/java/</code>包中定义另一个文件<code class="fe ok ol om on b">Keys.kt</code>并获取您的<strong class="jm io"> api_key。</strong>该文件用于加载<strong class="jm io"> lib.cpp </strong>文件中您定义的C++代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pz qa l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Keys.kt file</figcaption></figure><p id="7a37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，打开您的cpp文件并保护您的<strong class="jm io"> api_key: </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pz qa l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">.cpp file</figcaption></figure><p id="e3d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您将要在这个文件中编写的代码是至关重要的，因为这个文件将为您提供密钥，所以您必须确保正确地生成函数。</p><p id="43a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我来定义上述函数的分解:</p><p id="84ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ok ol om on b">edu_practice</code> - &gt;包名(也要确保你的模块是<strong class="jm io"> app </strong>，否则你必须连接它)</p><p id="7cb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ok ol om on b">utils_shared_Keys</code> - &gt;是<strong class="jm io"> Keys.kt </strong>文件路径即<code class="fe ok ol om on b">java/package/utils/shared/</code></p><p id="e97e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ok ol om on b">apiKey</code> - &gt;是我们在<strong class="jm io"> Keys.kt </strong>文件中定义的外部乐趣</p><blockquote class="lp lq lr"><p id="0980" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">最后一档</p></blockquote><p id="755b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经完成了几乎所有的功能路径，剩下的唯一配置就是在<code class="fe ok ol om on b">app.gradle</code>中定义我们的<code class="fe ok ol om on b">CMakesList</code>文件:</p><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="1172" class="os mp in on b gy ot ou l ov ow">android{<br/>      .........<br/>   externalNativeBuild <strong class="on io">{<br/>          </strong>cmake <strong class="on io">{<br/>              </strong>path "CMakeLists.txt"<br/>          <strong class="on io">}<br/>    }</strong></span><span id="d5eb" class="os mp in on b gy qc ou l ov ow"><strong class="on io">}</strong></span></pre><p id="2f5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，您可以通过在代码中引用<strong class="jm io"> Keys.kt </strong>文件来获取API_Key。</p><blockquote class="lp lq lr"><p id="d765" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">在Java中</p></blockquote><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="9a84" class="os mp in on b gy ot ou l ov ow">Keys.<em class="ls">INSTANCE</em>.apiKey()</span></pre><blockquote class="lp lq lr"><p id="e491" class="jk jl ls jm b jn jo jp jq jr js jt ju lt jw jx jy lu ka kb kc lv ke kf kg kh ig bi translated">在科特林</p></blockquote><pre class="kj kk kl km gt oo on op oq aw or bi"><span id="f4be" class="os mp in on b gy ot ou l ov ow">Keys.apiKey()</span></pre><p id="5f60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你只能选择在应用程序中本地存储密钥时，通过NDK保护<code class="fe ok ol om on b">api_key</code>是非常有趣和有用的。</p><p id="0d6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果它不工作或给你一个错误，然后检查ndk路径是否填写在项目结构中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qd"><img src="../Images/9b477ede715552098879ecb1ccc894c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zp9XA42CheCvxNvCWMUzeQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">ndk-project structure</figcaption></figure><h1 id="f24b" class="mo mp in bd mq mr oz mt mu mv pa mx my mz pb nb nc nd pc nf ng nh pd nj nk nl bi translated">Android Jetpack安全性</h1><p id="5be6" class="pw-post-body-paragraph jk jl in jm b jn nm jp jq jr nn jt ju jv no jx jy jz np kb kc kd nq kf kg kh ig bi translated">在Google I/O 2019中，谷歌推出了新的安全功能，这些功能以Jetpack security的名义组合在一起，以确保上述所有问题都需要克服。</p><p id="9bdc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Jetpack security提供以下主要功能:</p><ul class=""><li id="2b48" class="nr ns in jm b jn jo jr js jv nt jz nu kd nv kh nw nx ny nz bi translated">万能钥匙</li><li id="afe8" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh nw nx ny nz bi translated">EncryptedSharedPreferences</li><li id="dd79" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh nw nx ny nz bi translated">加密文件</li></ul><p id="96d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目前，我们正在讨论存储<strong class="jm io"> api_key </strong>，这可以通过<strong class="jm io">主密钥/密钥库</strong>来完成。</p><p id="9434" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">密钥库提供:</p><ul class=""><li id="9b05" class="nr ns in jm b jn jo jr js jv nt jz nu kd nv kh nw nx ny nz bi translated">安全地存储密钥和</li><li id="c4d7" class="nr ns in jm b jn oa jr ob jv oc jz od kd oe kh nw nx ny nz bi translated">随机生成密钥</li></ul><p id="b01e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它使用公钥和对称加密技术对秘密进行加密。现在，它们之间有什么区别，我们如何使用它们？对于这一点，你已经读过我的第二篇文章《<a class="ae of" rel="noopener ugc nofollow" target="_blank" href="/secure-secrets-in-android-using-jetpack-security-in-depth-android-security-02-4026b8e012f4"> <strong class="jm io">如何保密》🔑在安卓(深入)——安卓安全——02</strong></a></p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="0a2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这篇文章对解决android安全性的基本问题有所帮助。我们还讨论了传统方法与当前方法的比较，并探讨了它们背后的优势。在Twitter上关注我，了解更多更新:</p><div class="lw lx gp gr ly lz"><a href="https://twitter.com/AliAzazAlam1" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd io gy z fp me fr fs mf fu fw im bi translated">阿里·阿扎兹·阿拉姆</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">阿里·阿扎兹·阿拉姆的最新推文(@AliAzazAlam1)。🇵🇰.企业家👱🏻‍♂️安卓应用开发者📱开源…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">twitter.com</p></div></div><div class="mi l"><div class="qe l mk ml mm mi mn ks lz"/></div></div></a></div><p id="f74c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您花时间阅读这篇文章。如果你喜欢它，请分享！</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="9415" class="mo mp in bd mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl bi translated">点击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="9e8d" class="pw-post-body-paragraph jk jl in jm b jn nm jp jq jr nn jt ju jv no jx jy jz np kb kc kd nq kf kg kh ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae of" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae of" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>在Medium上关注我们。</p><p id="f998" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您需要Kotlin工作室，请查看我们如何帮助您:<a class="ae of" href="https://kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi qf"><img src="../Images/0f75035864c8777980691ea01b2909c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V9G3D67yqAvCKwAlxLkvDQ.png"/></div></a></figure></div></div>    
</body>
</html>