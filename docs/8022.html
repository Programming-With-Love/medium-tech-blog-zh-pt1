<html>
<head>
<title>Deploying an ML-based containerised (Docker) Web application to a local Kubernetes cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将基于ML的容器化(Docker) Web应用程序部署到本地Kubernetes集群</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/deploying-an-ml-based-containerised-docker-web-application-to-a-local-kubernetes-cluster-f948824699df?source=collection_archive---------0-----------------------#2021-06-09">https://medium.com/walmartglobaltech/deploying-an-ml-based-containerised-docker-web-application-to-a-local-kubernetes-cluster-f948824699df?source=collection_archive---------0-----------------------#2021-06-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/ade34eb06dcdc59ec60a7efbb77e7d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*xrl9QKU8ckghzBBu__dR2w.png"/></div><figcaption class="il im et er es in io bd b be z dx">Photo Credit: <a class="ae ip" href="https://commons.wikimedia.org/wiki/File:Kubernetes_(container_engine).png" rel="noopener ugc nofollow" target="_blank">Model as Service Deployment on Kubernetes</a></figcaption></figure><h2 id="ec48" class="iq ir hh bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 1。</strong> <strong class="ak">简介</strong></h2><p id="244f" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki ha bi kj translated"><span class="l kk kl km bm kn ko kp kq kr di"> W </span> <em class="ks">随着机器学习</em> <strong class="jq hi"> <em class="ks">模式即服务</em> </strong> <em class="ks">的发展，一个关键的方面是能够将这种服务打包在一个容器内并进行部署，以确保</em> <strong class="jq hi"> <em class="ks">的高可移植性、可用性&amp;的可扩展性</em> </strong> <em class="ks">。一个被广泛接受的解决方案是一个</em> <strong class="jq hi"> <em class="ks">容器，该容器又可以部署在一个容器编排平台上，如</em><strong class="jq hi"><em class="ks">【Kubernetes】</em></strong><em class="ks">。</em></strong></p><p id="1849" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><em class="ks">本文主要面向熟悉Python/R编程并希望了解使用容器化方法部署模型即服务的初始阻力的数据科学受众，容器化方法是MLOps框架不可或缺的一部分。</em></p><p id="9a68" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">在数据科学团队中，我们使用一个基于Kubernetes集群的内部平台，名为Walmart Cloud-Native Platform(WCNP ),将相应的容器配置和代码文件部署到存储库中。这反过来会触发管道在Kubernetes集群上部署这个容器。</p><p id="758c" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">如图1所示，在最初的开发阶段，我们倾向于直接将它们部署到Kubernetes平台上，但我们可能会花费更多的时间来识别和调试许多ML代码相关或docker配置相关的问题。</p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es ky"><img src="../Images/225a24d2342f9b7a48130190bb7e7caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoOWFNKouVbu_N8OTPpanA.jpeg"/></div></div><figcaption class="il im et er es in io bd b be z dx">Figure 1: Directly Deploying to platform &amp; Debugging</figcaption></figure><p id="42a0" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">一个直截了当的解决方案可能是开发整个管道，直到在本地机器上存在一个功能性的容器化解决方案，类似于在本地机器上开发一个基本的ML算法/就像一个游乐场——参见图2 <strong class="jq hi">。</strong></p><p id="7b80" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">这个<strong class="jq hi"> <em class="ks"> </em> </strong>使得测试各种功能、探索配置和实验变得更加容易，我们可以简单地将这些文件移植到上面的WCNP相关管道(带有一些额外的集群配置)。总的来说，从而避免&amp;减少任何主要的代码相关、docker配置相关或集群相关问题。</p><p id="7af3" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">看，解决这个问题的方法是一个简单的基于桌面的平台工具——<strong class="jq hi"><em class="ks">Docker桌面。</em>T45】</strong></p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lh"><img src="../Images/dc2999adec32af9e5762df3c4612207c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSUgff6d1mc-ysFx8h2EIA.jpeg"/></div></div><figcaption class="il im et er es in io bd b be z dx">Figure 2: Use of Docker Desktop to debug common issues</figcaption></figure><p id="4544" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">在本地机器上研究和执行容器和Kubernetes部署的编码方面时，我发现了大量的材料(在下面的参考资料和许多问答站点中提到),包括各种代码、命令、系统/集群配置相关文件等。这涉及到几个小时的阅读和测试，只是为了让一个基本的web应用程序容器启动并运行。</p><p id="a47f" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">因此，请记住，从数据科学家的角度来看，我计划准备本教程，它将列出在几分钟内在Kubernetes集群上运行ML模型部署所需的非常基本和必要的步骤。随着配置复杂性的增加，部署在云服务上的大多数基本命令将保持不变。</p><p id="ec5e" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">下面，我们列出了构建一个<strong class="jq hi">基本ML垃圾邮件检测模型的步骤</strong> &amp;重点创建一个<strong class="jq hi"> web应用，</strong>将其打包成一个<strong class="jq hi"> Docker容器</strong> &amp;将<strong class="jq hi"> </strong>容器部署到本地的<strong class="jq hi"> Kubernetes集群</strong>(在后端运行minikube单节点集群)。</p><h2 id="a673" class="iq ir hh bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">目标</h2><ul class=""><li id="b967" class="li lj hh jq b jr js jv jw jb lk jf ll jj lm ki ln lo lp lq bi translated">打包一个基于ML的示例web应用程序</li><li id="4879" class="li lj hh jq b jr lr jv ls jb lt jf lu jj lv ki ln lo lp lq bi translated">使用REST API公开示例应用程序</li><li id="68d4" class="li lj hh jq b jr lr jv ls jb lt jf lu jj lv ki ln lo lp lq bi translated">创建、构建和运行Docker映像</li><li id="1a6f" class="li lj hh jq b jr lr jv ls jb lt jf lu jj lv ki ln lo lp lq bi translated">使用minikube在本地创建集群</li><li id="5cbf" class="li lj hh jq b jr lr jv ls jb lt jf lu jj lv ki ln lo lp lq bi translated">将容器部署到库伯内特家</li><li id="6351" class="li lj hh jq b jr lr jv ls jb lt jf lu jj lv ki ln lo lp lq bi translated">测试服务</li></ul><h2 id="90e2" class="iq ir hh bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 2。安装:</strong></h2><p id="82d5" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki ha bi translated"><strong class="jq hi"> Docker桌面</strong>可以从<a class="ae ip" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank">网站</a>下载，这将有助于使用<a class="ae ip" href="https://minikube.sigs.k8s.io/docs/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hi"> minikube </strong> </a>启动<strong class="jq hi"> Kubernetes </strong>容器编排系统(有助于运行单节点Kubernetes集群进行日常开发工作)。除此之外，我们需要一个工作的<strong class="jq hi"> Python </strong>编辑器，如<a class="ae ip" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter </a>。</p><p id="c1ae" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">Docker桌面安装后，进入<strong class="jq hi">首选项- &gt;启用Kubernetes。</strong></p><figure class="kz la lb lc fd ii er es paragraph-image"><div class="er es lw"><img src="../Images/7ae9dcace72b5656f30f26df1632cfe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*NvMfecURUjZH0hH-lTbSgA.png"/></div><figcaption class="il im et er es in io bd b be z dx">Figure 3: Docker Desktop</figcaption></figure><h2 id="a481" class="iq ir hh bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 3。开发ML模型:</strong></h2><p id="405a" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki ha bi translated">我们使用<a class="ae ip" href="https://archive.ics.uci.edu/ml/datasets/sms+spam+collection" rel="noopener ugc nofollow" target="_blank"> UCI垃圾短信收集数据集</a>开发垃圾短信检测模型，该模型使用基本计数矢量器进行特征创建，使用随机森林模型进行预测。可以使用tf-idf、基于上下文的向量等来进一步探索更复杂的模型。</p><p id="7bd7" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">任何中间输出都需要保存到一个存储空间中，这在预测阶段是必需的，比如本例中的词汇表和模型对象。</p><pre class="kz la lb lc fd lx ly lz ma aw mb bi"><span id="61ed" class="iq ir hh ly b fi mc md l me mf"><strong class="ly hi">#Save vectorizer vocabulary to storage</strong></span><span id="4374" class="iq ir hh ly b fi mg md l me mf">pickle.dump(cv.vocabulary_,open("feature.pkl","wb"))</span><span id="eb79" class="iq ir hh ly b fi mg md l me mf"><strong class="ly hi">#Save the model to storage</strong></span><span id="ed32" class="iq ir hh ly b fi mg md l me mf">filename = 'model.pkl'</span><span id="e29d" class="iq ir hh ly b fi mg md l me mf">pickle.dump(rfc, open(filename, 'wb'))</span><span id="1785" class="iq ir hh ly b fi mg md l me mf"><strong class="ly hi">#Consumables:</strong></span><span id="577b" class="iq ir hh ly b fi mg md l me mf">· feature.pkl</span><span id="adbb" class="iq ir hh ly b fi mg md l me mf">· Model.pkl</span></pre><p id="32f1" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><em class="ks">模型输出:用逗号分隔的值，如0 — ham，1 — spam </em></p><h2 id="72c0" class="iq ir hh bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 4。将ML模型部署为Flask应用程序:</strong></h2><p id="7eae" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki ha bi translated">Flask package是一个基于WSGI的web应用程序框架，经常使用REST API将模型公开为服务，我们也会使用它。</p><figure class="kz la lb lc fd ii"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="il im et er es in io bd b be z dx">Figure 4: Creating the Flask Deployment for the Spam Classifier Prediction</figcaption></figure><p id="8e81" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">如图4所示，我们为预测加载了先前保存的对象，并确保创建了用于API调用的默认IP地址(0.0.0.0)和端口5000。调试模式允许容易地检测错误。这个Python笔记本转换成*py格式进行部署(app.py)。</p><p id="7bd2" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">可以检查基址处的默认“Hello world”以确保服务启动并运行，此外，我们将使用“/predict”扩展进行预测。</p><p id="73fa" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">为了快速测试我们的应用程序，我们在同一个工作目录终端中使用下面的命令，确保app.py存在。您甚至可以使用URL，并使用我们将进一步描述的代码进行预测。</p><blockquote class="mj mk ml"><p id="6fcc" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">$ python3 -m烧瓶运行</p></blockquote><figure class="kz la lb lc fd ii er es paragraph-image"><div class="er es mp"><img src="../Images/a38e35e6f5371188a5157d7a8a4a83a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*pXVB4aQCgyc1Cd0IARsh2w.png"/></div><figcaption class="il im et er es in io bd b be z dx">Figure 5:Flask app running successfully</figcaption></figure><h2 id="f7ef" class="iq ir hh bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 5。构建&amp;运行Docker容器映像:</strong></h2><p id="88b2" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki ha bi translated">导航到与app.py相同的目录，并确保以相同的格式创建以下文件。</p><p id="6ab3" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><strong class="jq hi"> Dockerfile </strong> —在这个例子中，我们使用python的基本映像:3.6(在第一行中指定)。<strong class="jq hi"> EXPOSE </strong>关键字允许容器在运行时监听指定的端口。</p><p id="20ba" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><em class="ks">根据应用的需要，具体的docker图像请参考</em><a class="ae ip" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"><em class="ks"/></a><em class="ks">。</em></p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es mq"><img src="../Images/73c3bcec55b69e8499e1128fc7dc4a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnn2P-sqTAQ-Z5yMGc4nWg.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Figure 6: DockerFile Content</figcaption></figure><p id="8781" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><strong class="jq hi"> requirements.txt </strong> —这是一个打包库的集合，下载起来更方便。通常，使用pip freeze命令，但是<strong class="jq hi"> pipreqs </strong>包在仅捕获当前项目的依赖项方面工作得更好。</p><blockquote class="mj mk ml"><p id="bc29" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">$ pip freeze &gt; requirements.txt</p><p id="6923" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">$ pip reqs/住宅/项目/位置</p><p id="028a" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">在/home/project/location/requirements . txt中成功保存了需求文件</p></blockquote><p id="6a48" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">现在，使用<strong class="jq hi"> app.py，*导航到该目录。pkl，docker file&amp;requirements . txt</strong>并在您的终端窗口中使用以下命令。</p><p id="bf18" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><strong class="jq hi">应用名称:</strong> flaskft</p><p id="ed74" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><strong class="jq hi">版本名称:</strong>开发1</p><blockquote class="mj mk ml"><p id="b15f" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">docker build -t flaskft:develop1。</p></blockquote><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es mr"><img src="../Images/ba2465da5e3da11741ddb38d88d9b58b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZrKE4iyRTHfCwHtQvKpJA.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Figure 7: Successful Build of Container</figcaption></figure><p id="caab" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">我们现在可以使用下面的命令将我们的映像作为容器运行。</p><blockquote class="mj mk ml"><p id="00b2" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">docker run-it-d-p 5000:5000 flask ft:develop 1</p></blockquote><p id="add5" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">Docker可以使用-d在分离模式下运行容器。</p><p id="f9e7" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">为了宣布容器的端口，我们在run命令中使用-p标志，格式为[主机端口]:[容器端口]。因此，如果我们想将容器内部的端口4000暴露给容器外部的端口2000，我们可以将2000:4000传递给-p标志。</p><p id="e217" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">要检查容器的详细信息，我们可以使用ps命令。</p><blockquote class="mj mk ml"><p id="4384" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">docker ps</p></blockquote><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es ms"><img src="../Images/de47d9e71504c18b99064f0a73d9e118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4jwMmp4jSUtVdHvZ-eNbgQ.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Figure 8: Get Container Details</figcaption></figure><p id="3dc0" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">因此，每次您想要更改这个应用程序时，您可以更改版本名称并重新部署。</p><h2 id="e6e6" class="iq ir hh bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 6。在Kubernetes集群上部署Docker容器</strong></h2><p id="c227" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki ha bi translated">Kubernetes是一个用于管理容器化工作负载和服务的开源平台，然后用于部署这个容器。虽然公共领域中有多个Kubernetes版本，但我们使用本地桌面部署，这需要使用minikube来运行单节点Kubernetes集群。</p><p id="56e0" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">我们首先看一下需要的交付物。</p><p id="c7f8" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><strong class="jq hi"> yml文件:</strong>指定要创建的pod的配置。在这种配置中，我们在pod内部运行一个容器。</p><figure class="kz la lb lc fd ii er es paragraph-image"><div class="er es mt"><img src="../Images/26629532caef849fd8acaf1029836c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*_-T0_ICH7j7InYFpU8E7Xw.png"/></div><figcaption class="il im et er es in io bd b be z dx">Figure 9: spamcheck.yml File</figcaption></figure><p id="6d74" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><strong class="jq hi"> <em class="ks">名称:</em> </strong>调配集装箱的名称。</p><p id="ee4c" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><strong class="jq hi"><em class="ks">imagePullPolicy:</em></strong>Kubernetes通常会尝试从minikube docker注册表或public Docker注册表中提取指定的图像，但在这种情况下，我们没有向其中任何一个注册表注册图像，因此需要声明这是“<strong class="jq hi"> Never </strong>以防止出现错误。</p><p id="fec3" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><strong class="jq hi"> <em class="ks">图像:</em> </strong>使用与docker图像相同的图像名称。</p><p id="9ea9" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><strong class="jq hi"><em class="ks">restart policy:</em></strong>restart policy应用于pod中的所有容器，其可能值为<strong class="jq hi"> Always、OnFailure和Never </strong>。虽然默认值是活动的，但我们将其设置为“从不”,因为这仅用于测试目的。</p><p id="63ab" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated"><strong class="jq hi"><em class="ks">container port:</em></strong>这是服务定位时访问属于pod的容器的端口号。</p><p id="7be9" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">请确保正确缩进并删除多余的空格，否则可能会导致部署失败。确保这些文件存在于同一目录中。</p><p id="e5d9" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">现在，导航到包含上述文件的目录，在终端窗口中使用下面的命令。</p><blockquote class="mj mk ml"><p id="e8d4" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">迷你库启动— <em class="hh">启动迷你库服务</em></p><p id="ee25" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">eval $(minikube-p minikube docker-env)—<em class="hh">配置您的本地环境，以便在minikube实例中重用Docker守护进程。</em></p><p id="10a2" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">docker build -t flaskft。— <em class="hh">我们需要使用上述环境变量配置进行重建，确保与容器创建期间指定的应用程序名称相同。</em></p><p id="416a" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">kubectl create-f spam check . yml—<em class="hh">将创建pod作为demov1，并获得一个输出</em> <strong class="jq hi"> <em class="hh">，类似于创建的pod/demov1。</em> </strong></p><p id="a2a8" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">kubectl获取pod—<em class="hh">查看pod</em></p></blockquote><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es mu"><img src="../Images/12f0de3194b0f65dc3304a25e54313f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8TNgzTw4zdaSXzIUGKA-Q.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Figure 10: Pod Status</figcaption></figure><blockquote class="mj mk ml"><p id="785b" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">kubectl端口转发演示5000:5000 — <em class="hh">从本地机器到pod的端口转发。</em></p></blockquote><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es mu"><img src="../Images/12f0de3194b0f65dc3304a25e54313f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8TNgzTw4zdaSXzIUGKA-Q.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Figure 11:Forwarding of requests to/from port</figcaption></figure><h2 id="6ac2" class="iq ir hh bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak"> 7。测试部署</strong></h2><p id="d3ff" class="pw-post-body-paragraph jo jp hh jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki ha bi translated">为了测试这个部署，我们使用localhost URL来测试两个字符串是“ham”还是“spam”。</p><figure class="kz la lb lc fd ii"><div class="bz dy l di"><div class="mh mi l"/></div><figcaption class="il im et er es in io bd b be z dx">Figure 12: Hosted Spam Classifier Deployment Testing</figcaption></figure><p id="303c" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">如上所述，我们已经看到了如何使用容器来部署我们的机器学习解决方案，以及如何使用我们的本地机器来部署Kubernetes，这些本地机器可以在新部署的初始阶段用于<strong class="jq hi">开发/实验</strong>目的。</p><p id="d6a5" class="pw-post-body-paragraph jo jp hh jq b jr kt jt ju jv ku jx jy jb kv ka kb jf kw kd ke jj kx kg kh ki ha bi translated">总的来说，Docker桌面使我们能够在本地机器上部署各种容器并与之交互。它提供了一个用户友好的GUI界面来执行与容器部署相关的常见操作，这对新用户非常有益。此外，在深入研究基于容器的配置和问题之前，它有助于验证部署的代码是否按预期工作。</p><h2 id="4826" class="iq ir hh bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">参考资料:</h2><blockquote class="mj mk ml"><p id="49bb" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated"><a class="ae ip" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/concepts/workloads/controllers/deployment/</a></p><p id="fc41" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">https://docs.docker.com/engine/<a class="ae ip" href="https://docs.docker.com/engine/" rel="noopener ugc nofollow" target="_blank"/></p><p id="d200" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated">【https://minikube.sigs.k8s.io/docs/start/ T4】</p><p id="7a52" class="jo jp ks jq b jr kt jt ju jv ku jx jy mm kv ka kb mn kw kd ke mo kx kg kh ki ha bi translated"><a class="ae ip" href="https://pypi.org/project/pipreqs/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/pipreqs/</a></p></blockquote></div></div>    
</body>
</html>