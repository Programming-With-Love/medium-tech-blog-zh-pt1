<html>
<head>
<title>Excluded Item: Use tail recursion to achieve efficient recurrence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排除项:使用尾部递归实现高效递归</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/excluded-item-use-tail-recursion-to-achieve-efficient-recurrence-364593eed969?source=collection_archive---------0-----------------------#2019-12-02">https://blog.kotlin-academy.com/excluded-item-use-tail-recursion-to-achieve-efficient-recurrence-364593eed969?source=collection_archive---------0-----------------------#2019-12-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="ed02" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">这本来是有效的Kotlin(没有迷因)中的一个项目，尽管我决定不把它包括在最终的书中，因为有限的<code class="fe km kn ko kp b">tailrec</code>能力，以及有限的这个修饰符的效用。这本书现在已经出版并且稳定，可以作为电子书<a class="ae kq" href="https://leanpub.com/effectivekotlin/" rel="noopener ugc nofollow" target="_blank">和纸质书</a><a class="ae kq" href="https://effectivekotlin.eu/" rel="noopener ugc nofollow" target="_blank">找到。</a></p></blockquote><p id="5aca" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">递归是一种有用的技术，可以帮助我们简化一些算法。例如，考虑一个函数来计算斐波那契数列中第n个位置的元素。斐波纳契数列被定义为一个数字序列，我们从两个常数开始，然后通过将前两个常数相加来计算下一个元素。举个例子，假设我们从0和1开始。这就是我们的序列的样子:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="a10a" class="lc ld in kp b gy le lf l lg lh">Position  0   1   2   3   4   5   6   7   8   9  10  11<br/>Value     0   1   1   2   3   5   8  13  21  34  55  89</span></pre><p id="c5bd" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">我们是这样计算的:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="7e09" class="lc ld in kp b gy le lf l lg lh">0 + 1 = 1<br/>1 + 1 = 2<br/>1 + 2 = 3<br/>2 + 3 = 5<br/>3 + 5 = 8<br/>...</span></pre><p id="e7a2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">该序列在数学上定义为:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="c401" class="lc ld in kp b gy le lf l lg lh">               { f if n == 0<br/>fib(n, f, s) = { s if n == 1<br/>               { fib(n-1, f, s) + fib(n-2, f, s) otherwise</span></pre><p id="ca06" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">使用这个定义，我们可以用以下方式定义我们的函数:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="1944" class="lc ld in kp b gy le lf l lg lh"><strong class="kp io">fun </strong>fib(<br/>   n: Int,<br/>   first: BigInteger,<br/>   second: BigInteger<br/>): BigInteger = <strong class="kp io">when </strong>(n) {<br/>   0 -&gt; first<br/>   1 -&gt; second<br/>   <strong class="kp io">else </strong>-&gt; <em class="jp">fib</em>(n - 1, first, second) + <em class="jp">fib</em>(n - 2, first, second)<br/>}</span></pre><figure class="ku kv kw kx gt lj gh gi paragraph-image"><div class="gh gi li"><img src="../Images/ccbde8d7d29699104f36093c1dd9e17b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*L2TZCCZ9kfvdcrRK.gif"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Simpsons episode created using recurrence</figcaption></figure><p id="6582" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">这种解决方案是可行的，但是扩展性不好。我们通过计算一个值需要多少种操作来估计可伸缩性。在这种情况下，我们可以计算出我们需要多少补充。这个数字疯狂增长！试想一下，你需要计算<code class="fe km kn ko kp b">fib(7)</code>。你可以在下面的图片中看到它是如何计算的。为了计算<code class="fe km kn ko kp b">fib(7)</code>的答案，你需要使用加法20次。一般来说，使用上面的实现，计算<code class="fe km kn ko kp b">fib(n)</code>我们需要<code class="fe km kn ko kp b">fib(n)-1</code>加法。</p><figure class="ku kv kw kx gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lq"><img src="../Images/378b8ef6fbce16cf66102a810a8c7932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*akEu2r-DE9shCRGF"/></div></div></figure><figure class="ku kv kw kx gt lj gh gi paragraph-image"><a href="https://www.kt.academy/workshop/refactoringToCleanCode"><div class="gh gi lv"><img src="../Images/d6ba3dcb5a3de1b3ff65f2512976b60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bQv2PrHMPzjWkWZ1hjAkw.png"/></div></a></figure><p id="be75" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">不应该是那样的。如果你在纸上做同样的事情，你可以通过将前两个数相加来计算下一个数。你只需要做5次手术。这可以通过使用经典的迭代方法来实现:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="663a" class="lc ld in kp b gy le lf l lg lh"><strong class="kp io">fun </strong>fib(<br/>   n: Int,<br/>   first: BigInteger,<br/>   second: BigInteger<br/>): BigInteger {<br/>   <strong class="kp io">var </strong>l = first<br/>   <strong class="kp io">var </strong>lm1 = second<br/>   <strong class="kp io">for </strong>(i <strong class="kp io">in </strong>2..n) {<br/>      <strong class="kp io">val </strong>tmp = l<br/>      l += lm1<br/>      lm1 = tmp<br/>   }<br/>   <strong class="kp io">return </strong>l<br/>}</span></pre><p id="1a26" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">它不漂亮，但是很好用。它的复杂度最终是线性的。这个函数优化得很好。大概对于一些开发者来说，这也将是可读性最强的解决方案。对我来说不是，对许多其他开发者来说也不是。它很长，突变点很少。这也要求我们在中间定义一个临时变量。尽管我们仍然可以使用递归并模拟迭代过程。我们只需要修改参数:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="86e8" class="lc ld in kp b gy le lf l lg lh"><strong class="kp io">fun </strong>fib(<br/>   n: Long,<br/>   first: BigInteger,<br/>   second: BigInteger<br/>): BigInteger = <strong class="kp io">when </strong>(n) {<br/>   0L -&gt; first<br/>   1L -&gt; second<br/>   <strong class="kp io">else </strong>-&gt; <em class="jp">fib</em>(n - 1, second, first + second)<br/>}</span></pre><figure class="ku kv kw kx gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lw"><img src="../Images/112abb3d8a6a0af014bca9c648d0d7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HZEWEDUlv8wpZFQy.jpg"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">When you talk to functional programming passionate, do not ever say things like “Recursion doesn’t make sense” or “Why using recursion if we have perfectly working loops”. Unless you are well insured.</figcaption></figure><p id="8bde" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">这样的解决方案更简单，并且最有可能被熟悉递归的人所理解。这样的风格在函数式编程社区中也非常流行。</p><p id="e5eb" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">与基于循环的迭代方法相比，这种解决方案有一个重要的缺点。当我们使用递归时，就像在每一步中我们打开一个新函数，直到最后一个函数被计算出来，我们才能关闭它。这对性能来说并不是问题，但是我们搞乱了函数栈。问题是，如果我们打开了太多的功能，我们可能会面临一个<code class="fe km kn ko kp b">StackOverflowError</code>:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="56f2" class="lc ld in kp b gy le lf l lg lh"><em class="jp">fib</em>(Long.<strong class="kp io">MAX_VALUE</strong>, 0, 1)</span><span id="3eaa" class="lc ld in kp b gy lx lf l lg lh">Exception in thread "main" java.lang.StackOverflowError<br/>   at TestKt.fib(Test.kt:6)<br/>   at TestKt.fib(Test.kt:6)<br/>   at TestKt.fib(Test.kt:6)<br/>   at TestKt.fib(Test.kt:6)</span></pre><figure class="ku kv kw kx gt lj gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/0941d85f77a11f879a791713e2e0f844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*-bVFvKXDxH-z6u2q.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Two biggest problems with recursion are the possibility of infinite recursion and StackOverflowError.</figcaption></figure><p id="2f78" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">这一直是递归函数的一个问题。虽然Kotlin引入了一个特殊的修饰符，它可以让我们保持递归符号，并具有类似于使用循环实现的效率和行为。这个修饰符是<code class="fe km kn ko kp b">tailrec</code>，代表尾部递归。所以如果我们在函数中使用它:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="2a00" class="lc ld in kp b gy le lf l lg lh"><strong class="kp io">tailrec fun </strong>fib(<br/>   n: Long,<br/>   first: BigInteger,<br/>   second: BigInteger<br/>): BigInteger = <strong class="kp io">when </strong>(n) {<br/>   0L -&gt; first<br/>   1L -&gt; second<br/>   <strong class="kp io">else </strong>-&gt; <em class="jp">fib</em>(n - 1, second, first + second)<br/>}</span></pre><p id="7cad" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">你不会看到<code class="fe km kn ko kp b">StackOverflowError</code>。这是因为在幕后，我们的函数将被编译成一个没有实际递归的函数，而是一个循环。所以我们的函数被编译成类似这样的东西:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="6fb2" class="lc ld in kp b gy le lf l lg lh"><strong class="kp io">tailrec fun </strong>fib(<br/>   n: Long,<br/>   first: BigInteger,<br/>   second: BigInteger<br/>): BigInteger {<br/>   <strong class="kp io">var </strong>n = n<br/>   <strong class="kp io">var </strong>first = first<br/>   <strong class="kp io">var </strong>second = second<br/>   <strong class="kp io">while </strong>(<strong class="kp io">true</strong>) {<br/>      <strong class="kp io">when </strong>(n) {<br/>         0L -&gt; <strong class="kp io">return </strong>first<br/>         1L -&gt; <strong class="kp io">return </strong>second<br/>         <strong class="kp io">else </strong>-&gt; {<br/>            n--<br/>            <strong class="kp io">val </strong>prevFirst = first<br/>            first = second<br/>            second += prevFirst<br/>         }<br/>      }<br/>   }<br/>}</span></pre><p id="b9a2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">要使用<code class="fe km kn ko kp b">tailrec</code>修改器，我们需要匹配一些标准。函数必须调用自己作为它执行的最后一个操作。当递归调用后有更多代码时，不能使用尾部递归，也不能在try/catch/finally块中使用它。另外，目前只有JVM支持尾部递归。</p><figure class="ku kv kw kx gt lj gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/da72a4ae502bbfae9778325ebfb4e325.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/0*rhcoDwhavWsmZu3j.jpg"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">I wanted to use Kotlin, but islands are not so good at eating itself.</figcaption></figure><figure class="ku kv kw kx gt lj gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi lv"><img src="../Images/3860f92ecd05def9ec2568695cfc2895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVLi_vixkafibx_Rzo19dg.jpeg"/></div></a></figure><h1 id="cd69" class="ma ld in bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">使函数尾递归</h1><p id="3549" class="pw-post-body-paragraph jn jo in jq b jr mx jt ju jv my jx jy kr mz kb kc ks na kf kg kt nb kj kk kl ig bi translated">使递归函数尾递归并不总是容易的。要做到这一点，我们需要在一个论点中积累结果。假设我们需要一个函数，它给出一个集合的所有子集。这样一个函数在数学上叫做powerset，这就是我们如何给函数命名的。怎么才能算出来呢？让我们从一点观察开始。让我们计算几个集合的powerset:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="6b8a" class="lc ld in kp b gy le lf l lg lh">powerset(setOf(1)) == setOf(<br/>   setOf(), setOf(1)<br/>)</span><span id="1e3f" class="lc ld in kp b gy lx lf l lg lh">powerset(setOf(1, 2)) == setOf(<br/>   setOf(), setOf(1), setOf(2), setOf(1, 2)<br/>)</span><span id="80c2" class="lc ld in kp b gy lx lf l lg lh">powerset(setOf(1, 2, 3)) == setOf(<br/>   setOf(), setOf(1), setOf(2), setOf(1, 2),<br/>   setOf(3), setOf(1, 3), setOf(2, 3), setOf(1, 2, 3)<br/>)</span></pre><p id="4682" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">看着这个，你可能会注意到一些相似之处。可以看到<code class="fe km kn ko kp b">setOf(1, 2)</code>的动力集包含了<code class="fe km kn ko kp b">setOf(1)</code>的动力集。其余为<code class="fe km kn ko kp b">setOf(setOf(2), setOf(1, 2))</code>，与<code class="fe km kn ko kp b">setOf(1)</code>的powerset相同，每组加2。</p><p id="ca2b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">想想<code class="fe km kn ko kp b">setOf(1, 2, 3)</code>的powerset也是如此。包含<code class="fe km kn ko kp b">setOf(1, 2)</code>的powerset，其余同<code class="fe km kn ko kp b">setOf(1, 2)</code>的powerset，每组加3。这个问题可以这样定义:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="11b5" class="lc ld in kp b gy le lf l lg lh"><strong class="kp io">fun </strong>&lt;T&gt; Collection&lt;T&gt;.powerset(): Set&lt;Set&lt;T&gt;&gt; = <strong class="kp io">when </strong>{<br/>   isEmpty() -&gt; <em class="jp">setOf</em>(<em class="jp">setOf</em>())<br/>   <strong class="kp io">else </strong>-&gt; {<br/>      <strong class="kp io">val </strong>last = <em class="jp">last</em>()<br/>      <strong class="kp io">val </strong>subpowerset = <em class="jp">dropLast</em>(1).<em class="jp">powerset</em>()<br/>      subpowerset + subpowerset.<em class="jp">map </em><strong class="kp io">{ it </strong>+ last <strong class="kp io">}<br/>   </strong>}<br/>}</span></pre><p id="6973" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">这个函数工作正常:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="20ed" class="lc ld in kp b gy le lf l lg lh"><em class="jp">println</em>(<em class="jp">setOf</em>(1).<em class="jp">powerset</em>()) <em class="jp">// [[], [1]]</em></span><span id="33fa" class="lc ld in kp b gy lx lf l lg lh"><em class="jp">println</em>(<em class="jp">setOf</em>(1, 2).<em class="jp">powerset</em>()) <em class="jp">// [[], [1], [2], [1, 2]]</em></span><span id="b175" class="lc ld in kp b gy lx lf l lg lh"><em class="jp">println</em>(<em class="jp">setOf</em>(1, 2, 3).<em class="jp">powerset</em>())</span><span id="737f" class="lc ld in kp b gy lx lf l lg lh"><em class="jp">// [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]</em></span></pre><p id="77bc" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">但是它不是尾递归的，并且更难实现，因为我们在递归调用后累加结果。我们可以改进它，但这需要我们在争论中积累结果。</p><p id="e93c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">如果你想试一试，现在就停止阅读，自己修改这个函数，让它尾递归。要查看解决方案，请继续阅读。</p><p id="e0d5" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">以下是这个问题的解决方案:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="3bb2" class="lc ld in kp b gy le lf l lg lh"><strong class="kp io">fun </strong>&lt;T&gt; Collection&lt;T&gt;.powerset(): Set&lt;Set&lt;T&gt;&gt; =<br/>   <em class="jp">powerset</em>(<strong class="kp io">this</strong>, <em class="jp">setOf</em>(<em class="jp">setOf</em>()))</span><span id="d2f7" class="lc ld in kp b gy lx lf l lg lh"><strong class="kp io">private tailrec fun </strong>&lt;T&gt; powerset(<br/>   left: Collection&lt;T&gt;,<br/>   acc: Set&lt;Set&lt;T&gt;&gt;<br/>): Set&lt;Set&lt;T&gt;&gt; = <strong class="kp io">when </strong>{<br/>   left.isEmpty() -&gt; acc<br/>   <strong class="kp io">else </strong>-&gt; {<br/>      <em class="jp">powerset</em>(<br/>         left = left.<em class="jp">drop</em>(1),<br/>         acc = acc + acc.<em class="jp">map </em><strong class="kp io">{ it </strong>+ left.<em class="jp">first</em>() <strong class="kp io">}<br/>      </strong>)<br/>   }<br/>}</span></pre><p id="18ec" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">请注意，我们在一个论点中积累的结果。具体在<code class="fe km kn ko kp b">acc</code>参数中。由于这一点，尾部递归成为可能。在迭代过程中，我们获取第一个元素，并用这个元素添加到<code class="fe km kn ko kp b">acc</code>变量中。这些是<code class="fe km kn ko kp b">powerset(setOf(1,2))</code>的下一个<code class="fe km kn ko kp b">powerset</code>调用:</p><pre class="ku kv kw kx gt ky kp kz la aw lb bi"><span id="937f" class="lc ld in kp b gy le lf l lg lh">powerset({1,2,3}, {{}})<br/>powerset({2,3}, {{}, {1}})<br/>powerset({3}, {{}, {1}, {2}, {1,2}})<br/>powerset({}, {{}, {1}, {2}, {1,2}, {3}, {1,3}, {2,3}, {1,2,3}})</span></pre><p id="23e9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">请注意，我们使用head(列表的第一个元素)和tail(除第一个元素之外的所有元素)，而不是last和init(除last之外的所有元素)，但是末尾元素的顺序是相同的。就是因为操作顺序不一样。累加会立即发生，不会等待剩余计算的幂集。</p><p id="0d13" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">如你所见，尾递归是我们用来优化递归函数的一种技术。它让我们免受<code class="fe km kn ko kp b">StackOverflowError</code>的困扰，并提高了性能。尽管由于它的要求，引入它并不总是容易的。要使用它，我们需要在论点中积累结果。遗憾的是，这排除了许多我们可能需要使用递归的情况。</p><p id="b656" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">请记住，递归不是灵丹妙药。了解它是有价值的，因为它是您工具箱中的一个有用的工具，使这样的函数尾递归可能会使它们更有效，尽管它可以应用的情况有限。</p><figure class="ku kv kw kx gt lj gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/a595c8a49374c9d0071673dca896a059.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/0*iB4hEr0FxyxeeAm0.png"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">We need to get something out of life.</figcaption></figure></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="d13a" class="ma ld in bd mb mc nk me mf mg nl mi mj mk nm mm mn mo nn mq mr ms no mu mv mw bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="e39e" class="pw-post-body-paragraph jn jo in jq b jr mx jt ju jv my jx jy kr mz kb kc ks na kf kg kt nb kj kk kl ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kq" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kq" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><p id="2e5c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kr ka kb kc ks ke kf kg kt ki kj kk kl ig bi translated">如果您需要Kotlin工作室，请查看我们如何帮助您:<a class="ae kq" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="ku kv kw kx gt lj gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi lv"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>