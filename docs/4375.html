<html>
<head>
<title>Jetpack Compose: Missing piece to the MVI puzzle?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">jetpack Compose:MVI之谜的缺失部分？</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/jetpack-compose-missing-piece-to-the-mvi-puzzle-44c0e60b571?source=collection_archive---------0-----------------------#2021-07-15">https://medium.com/google-developer-experts/jetpack-compose-missing-piece-to-the-mvi-puzzle-44c0e60b571?source=collection_archive---------0-----------------------#2021-07-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/6284329ce071f2e62019561662bd38ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8sYY0lwlWMAYBw6sWVh4A.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Photo by <a class="ae hu" href="https://unsplash.com/@dewang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Dewang Gupta</a> on <a class="ae hu" href="https://unsplash.com/@dewang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="30b7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我第一次开始探索Jetpack compose时，我看到了许多将屏幕状态建模为可变属性组合的例子:</p><figure class="jt ju jv jw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es js"><img src="../Images/59ccb85d0e577ffe38e32e177b052551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JlS8u_GxAEoSFgLJNoLmNA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">state as a combination of mutable properties</figcaption></figure><p id="1b2f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在使用模型视图意图(MVI)模式几年后，作为MVI模式的坚定信徒，在查看可变状态对象后，我脑海中最迫切的问题是:</p><blockquote class="jx"><p id="3746" class="jy jz hx bd ka kb kc kd ke kf kg jr dx translated">" MVI甚至有可能与喷气背包组成？"</p></blockquote><p id="865a" class="pw-post-body-paragraph iu iv hx iw b ix kh iz ja jb ki jd je jf kj jh ji jj kk jl jm jn kl jp jq jr ha bi translated">然后，我偶然发现了一些代码示例、文章，甚至是关于MVI与Compose的谈话。我们可以公开单个状态对象，并在我们的可组合函数中使用<code class="du km kn ko kp b">mutableStateOf</code>来消费它，而不是公开多个可变状态:</p><figure class="jt ju jv jw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kq"><img src="../Images/5c9eda018314e837f39947b933ce66a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e-hsPIX9jliCqN-bwQZ4gQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Immutable State Object</figcaption></figure><p id="a1e4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看起来棒极了！但是，后来我开始怀疑:</p><blockquote class="jx"><p id="53b5" class="jy jz hx bd ka kb kc kd ke kf kg jr dx translated">"所以，MVI确实用Jetpack Compose工作，但是它工作得好吗？"</p></blockquote><p id="f2c7" class="pw-post-body-paragraph iu iv hx iw b ix kh iz ja jb ki jd je jf kj jh ji jj kk jl jm jn kl jp jq jr ha bi translated">遵循MVI的原则，这意味着我们的屏幕状态应该是不可变的，也就是说，每次我们改变状态对象的任何属性时，都会创建一个新的对象，并将其分配给我们的状态属性。然后，更多的问题出现在我的脑海里:</p><ul class=""><li id="fa25" class="kr ks hx iw b ix iy jb jc jf kt jj ku jn kv jr kw kx ky kz bi translated">如果只有一个局部视图状态发生了变异，那么重组怎么办？</li><li id="88e6" class="kr ks hx iw b ix la jb lb jf lc jj ld jn le jr kw kx ky kz bi translated">不可变状态和用Jetpack Compose分离可变属性一样好吗？</li><li id="7ffb" class="kr ks hx iw b ix la jb lb jf lc jj ld jn le jr kw kx ky kz bi translated">作曲是为MVI创作的吗？</li></ul><p id="ebae" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你和我一样，也在寻找上述问题的答案，或者只是想知道MVI是否适合Jetpack compose。希望这篇文章能帮你得到答案。</p><h1 id="def4" class="lf lg hx bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="f254" class="pw-post-body-paragraph iu iv hx iw b ix md iz ja jb me jd je jf mf jh ji jj mg jl jm jn mh jp jq jr ha bi translated">简短的回答是肯定的，MVI工作得很好，甚至比我预期的还要好。但是，请继续阅读更长的答案。</p><h1 id="c520" class="lf lg hx bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">与MVI的和解</h1><p id="e67f" class="pw-post-body-paragraph iu iv hx iw b ix md iz ja jb me jd je jf mf jh ji jj mg jl jm jn mh jp jq jr ha bi translated">基于我们的<code class="du km kn ko kp b">MovieDetailState</code>示例，这是我们简单的<code class="du km kn ko kp b">MovieDetailState</code>:</p><figure class="jt ju jv jw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/3a8603629cddfb15c8d2e5884ce12d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-37wcAYbF2wX6ptJBcKytQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">MovideDetailState, full code <a class="ae hu" href="https://github.com/ragdroid/Clayground/blob/main/shared/src/commonMain/kotlin/com/ragdroid/clayground/shared/ui/moviedetail/MovieDetailState.kt#L18" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="5599" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我不打算在这个屏幕上详细介绍MVI是如何实现的，但是如果你像我一样喜欢复杂的东西，可以在这里随意查看我的GitHub示例项目:<a class="ae hu" href="https://github.com/ragdroid/Clayground" rel="noopener ugc nofollow" target="_blank"> Clayground </a></p><h1 id="d3f5" class="lf lg hx bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">用例:投票支持一部电影</h1><figure class="jt ju jv jw fd hj er es paragraph-image"><div class="er es mj"><img src="../Images/5d38f77f97fabc4dd2a095a9a755de08.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*lMB8BZIiC8VBqJ7yJd762A.gif"/></div></figure><p id="d20d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每当用户打算执行一个动作，例如，<strong class="iw hy">投票赞成一部电影</strong>，我们触发一个intent : <code class="du km kn ko kp b">MovieDetailEvent</code>，这个事件导致视图的状态改变:<code class="du km kn ko kp b">voteCount ~&gt; voteCount + 1</code>。对于这个例子，我们只是将投票计数增加到1，但是根据用例的不同，我们可能需要将这个值与数据库或服务器保持同步(这不是本文所要求的)。</p><p id="6926" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注:<em class="mk">我们是按照从</em><a class="ae hu" href="https://github.com/spotify/mobius" rel="noopener ugc nofollow" target="_blank"><em class="mk"/></a><em class="mk"/><code class="du km kn ko kp b"><em class="mk">Event</em></code><em class="mk"/><code class="du km kn ko kp b"><em class="mk">SideEffect</em></code><em class="mk"/><code class="du km kn ko kp b"><em class="mk">Model</em></code><em class="mk"/><code class="du km kn ko kp b"><em class="mk">ViewEffect</em></code><em class="mk"/><code class="du km kn ko kp b"><em class="mk">Update…</em></code><em class="mk">的命名约定。事件可以引发副作用，只有事件可以更新我们的状态模型。副作用会引发事件。</em></p><figure class="jt ju jv jw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ml"><img src="../Images/bc5cde7b80ec424d7fde30affb11c083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wiiAqos4OjDj46t5SgRJcw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">MVI Update: Upvote, full code <a class="ae hu" href="https://github.com/ragdroid/Clayground/blob/main/shared/src/commonMain/kotlin/com/ragdroid/clayground/shared/ui/moviedetail/MovieDetailState.kt#L49" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="48bb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如前所述，根据MVI的原则，状态对象应该是不可变的。因此，如上所示，为了增加<code class="du km kn ko kp b">voteCount</code>，我们创建了状态对象的副本，并将<code class="du km kn ko kp b">voteCount</code>增加到1。</p><p id="277d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个新状态在我们的视图模型中显示为<code class="du km kn ko kp b">Flow</code>，可以在我们的<code class="du km kn ko kp b">@Composable</code>函数中收集:</p><figure class="jt ju jv jw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mm"><img src="../Images/4f08629da7638f7eece001b17e226434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GRMYxGqczg4wvsKhp3LS5A.png"/></div></div></figure><h2 id="c349" class="mn lg hx bd lh mo mp mq ll mr ms mt lp jf mu mv lt jj mw mx lx jn my mz mb na bi translated">状态<moviedetailstate/></h2><p id="f9e4" class="pw-post-body-paragraph iu iv hx iw b ix md iz ja jb me jd je jf mf jh ji jj mg jl jm jn mh jp jq jr ha bi translated"><code class="du km kn ko kp b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#(kotlinx.coroutines.flow.StateFlow).collectAsState(kotlin.coroutines.CoroutineContext)" rel="noopener ugc nofollow" target="_blank">collectAsState()</a></code>方法返回一个<code class="du km kn ko kp b">State&lt;MovieDetailState&gt;</code>对象或者说是一个<code class="du km kn ko kp b">SnapshotMutableState</code>。这个<code class="du km kn ko kp b">State</code>对象负责为我们订阅这个<code class="du km kn ko kp b">MovieDetail</code> <code class="du km kn ko kp b">@Composable</code>的状态更新(读和写)。默认情况下，变异策略被指定为<code class="du km kn ko kp b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#structuralEqualityPolicy()" rel="noopener ugc nofollow" target="_blank">structuralEqualityPolicy()</a></code>，即设置状态值为结构上相等的值(==)不被视为变更。状态对象的任何其他变化都会导致当前的可组合对象重新组合。这是因为<code class="du km kn ko kp b">SnapshotMutableState</code>向状态添加了读和写观察器，只要有变化，Compose就可以调用相应的<code class="du km kn ko kp b">RecomposeScope</code>来重组当前的可组合对象。</p><p id="7b38" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不仅如此，<code class="du km kn ko kp b">SnapshotMutableState</code> object还利用<code class="du km kn ko kp b">Snapshot</code>系统来处理写事务和冲突。你可以在Zach Klippenstein的这篇关于快照系统的博客文章中读到更多的细节。</p><p id="1c0e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以，回到我们的<code class="du km kn ko kp b">Upvote</code>动作，它导致我们的<code class="du km kn ko kp b">stateFlow</code>发出一个新的状态对象，结果导致我们的<code class="du km kn ko kp b">@Composable MovieDetail()</code>重新组合。让我们看看我们的<code class="du km kn ko kp b">@Composable MovieDetail()</code>:</p><figure class="jt ju jv jw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mm"><img src="../Images/fdc448a993d50a715fda6dffa789f15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSlCS3_5wnWxVYFptdDmRA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">MovieDetail Composable function, full code <a class="ae hu" href="https://github.com/ragdroid/Clayground/blob/main/app/src/main/java/com/ragdroid/clayground/moviedetail/MovieDetailActivity.kt#L143" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="7ca1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的<code class="du km kn ko kp b">MovieDetail</code>可组合调用一些其他的可组合函数，如<code class="du km kn ko kp b">MovieBackdrop()</code>、<code class="du km kn ko kp b">MovieVotes()</code>等。来装饰各种电影道具。问题是，<code class="du km kn ko kp b">MovieDetail</code> composable由于其状态改变而重新组合会导致其所有子composable重新组合吗？</p><p id="7dac" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">答案是否定的！。Compose使用间隙缓冲区构建的<a class="ae hu" rel="noopener" href="/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd">槽表</a>在内部智能地处理这个问题。Compose将可组合函数的参数存储在slot表中，然后可以根据这些参数在窗口小部件树中的位置，将这些参数与以前的组合值进行比较，从而Compose可以<a class="ae hu" href="https://developer.android.com/jetpack/compose/lifecycle#skipping" rel="noopener ugc nofollow" target="_blank">跳过对一个可组合函数的重新组合</a>，如果它的所有输入参数都是稳定的并且没有改变。</p><h2 id="7de9" class="mn lg hx bd lh mo mp mq ll mr ms mt lp jf mu mv lt jj mw mx lx jn my mz mb na bi translated"><a class="ae hu" href="https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md#stable-types" rel="noopener ugc nofollow" target="_blank">稳定型</a></h2><p id="07d1" class="pw-post-body-paragraph iu iv hx iw b ix md iz ja jb me jd je jf mf jh ji jj mg jl jm jn mh jp jq jr ha bi translated">Compose公开了两个注释，即<code class="du km kn ko kp b">@Stable</code>和<code class="du km kn ko kp b">@Immutable</code>，将输入参数和函数类型标记为稳定。这有助于智能重组中的组合运行时，即跳过输入类型稳定且值不变的可组合函数的重组。更多信息<a class="ae hu" href="https://developer.android.com/jetpack/compose/lifecycle#skipping" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p><p id="3e0e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Compose编译器可以推断某些类型的稳定性，如原始不可变类型、函数类型，并在默认情况下将它们视为稳定的。对于其他类型，如接口等。对于编译器不能推断出稳定性的，如果我们可以保证它们的稳定性，我们可以显式地将它们标记为稳定的，通过<code class="du km kn ko kp b">@Stable</code>即</p><ul class=""><li id="3a65" class="kr ks hx iw b ix iy jb jc jf kt jj ku jn kv jr kw kx ky kz bi translated"><code class="du km kn ko kp b">a.equals().b</code>应该总是返回相同的值</li><li id="b82e" class="kr ks hx iw b ix la jb lb jf lc jj ld jn le jr kw kx ky kz bi translated">公共属性中更改应该通知撰写器进行更改</li><li id="284e" class="kr ks hx iw b ix la jb lb jf lc jj ld jn le jr kw kx ky kz bi translated">公共财产也应该是稳定的</li></ul><p id="d17b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">或者如<code class="du km kn ko kp b">@Immutable</code>即一旦实例化，它们的属性将永远不会改变</p><p id="0f2f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">小心</strong>:“权力越大，责任越大”，所以要小心使用<code class="du km kn ko kp b">@Stable</code>和<code class="du km kn ko kp b">@Immutable</code>。<a class="ae hu" href="https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md#stable-types" rel="noopener ugc nofollow" target="_blank">编写API指南</a>很好地解释了这一点。</p><p id="8dbf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输入参数的稳定性对我们很重要，因为如果合成运行时不能推断输入的稳定性，它将总是认为输入是不稳定的，并重新合成这样的可合成函数。在探索过程中，我遇到了一个密封类的陷阱。</p><h2 id="ba8c" class="mn lg hx bd lh mo mp mq ll mr ms mt lp jf mu mv lt jj mw mx lx jn my mz mb na bi translated">作为可组合函数的输入参数类型的密封类</h2><p id="748c" class="pw-post-body-paragraph iu iv hx iw b ix md iz ja jb me jd je jf mf jh ji jj mg jl jm jn mh jp jq jr ha bi translated">通常，如果密封类是在一个支持组合的梯度模块中定义的，组合编译器插件可以推断出它们的稳定性。但是，如果您的状态包含一个在非组合模块中定义的密封类，则无法推断它的稳定性。这是需要注意的事情。我在这里为此提交了一个bug:<a class="ae hu" href="https://issuetracker.google.com/issues/191068806" rel="noopener ugc nofollow" target="_blank">https://issuetracker.google.com/issues/191068806</a></p><p id="45b7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，在我们的例子中，遵循智能重组，唯一可重组的应该是<code class="du km kn ko kp b">MovieVotes() :</code></p><figure class="jt ju jv jw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mm"><img src="../Images/fdc448a993d50a715fda6dffa789f15f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSlCS3_5wnWxVYFptdDmRA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">MovieDetail composable function, full code <a class="ae hu" href="https://github.com/ragdroid/Clayground/blob/main/app/src/main/java/com/ragdroid/clayground/moviedetail/MovieDetailActivity.kt#L143" rel="noopener ugc nofollow" target="_blank">here</a></figcaption></figure><p id="f15f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是因为唯一改变的输入是<code class="du km kn ko kp b">movieDetail.voteCount</code>。其他组件可以重用，您可以通过<a class="ae hu" href="https://github.com/chrisbanes/tivi/blob/main/common-ui-compose/src/main/java/app/tivi/common/compose/Debug.kt" rel="noopener ugc nofollow" target="_blank">记录重新组合的次数</a>来验证这一点。</p><h2 id="1123" class="mn lg hx bd lh mo mp mq ll mr ms mt lp jf mu mv lt jj mw mx lx jn my mz mb na bi translated">撰写指南</h2><p id="a6b7" class="pw-post-body-paragraph iu iv hx iw b ix md iz ja jb me jd je jf mf jh ji jj mg jl jm jn mh jp jq jr ha bi translated">如果我们在使用compose时遵循一些简单的准则，那么Compose只会通过只重组我们的部件树的所需部分来帮助我们。这些准则是:</p><ul class=""><li id="befc" class="kr ks hx iw b ix iy jb jc jf kt jj ku jn kv jr kw kx ky kz bi translated"><a class="ae hu" href="https://developer.android.com/jetpack/compose/state#state-hoisting" rel="noopener ugc nofollow" target="_blank">状态提升</a>:从可组合函数外部传递状态，使可组合函数无状态的模式，</li><li id="c779" class="kr ks hx iw b ix la jb lb jf lc jj ld jn le jr kw kx ky kz bi translated">通过传递lambdas而不是可变的状态属性来保持可组合函数的纯净和无副作用，</li><li id="7d84" class="kr ks hx iw b ix la jb lb jf lc jj ld jn le jr kw kx ky kz bi translated">使用<code class="du km kn ko kp b">key </code> composables或使用<code class="du km kn ko kp b">key</code> s的内置支持来实现<code class="du km kn ko kp b">LazyColumn</code>等可组合功能。帮助在<a class="ae hu" href="https://developer.android.com/jetpack/compose/lifecycle#add-info-smart-recomposition" rel="noopener ugc nofollow" target="_blank">智能重组</a>中构建运行时。</li><li id="4140" class="kr ks hx iw b ix la jb lb jf lc jj ld jn le jr kw kx ky kz bi translated">通过将你的模型标记为<code class="du km kn ko kp b"><a class="ae hu" href="https://developer.android.com/jetpack/compose/lifecycle#skipping" rel="noopener ugc nofollow" target="_blank">@Stable</a></code>或<code class="du km kn ko kp b">@Immutable</code>来帮助编译插件，只要能保证稳定性。</li><li id="4ea0" class="kr ks hx iw b ix la jb lb jf lc jj ld jn le jr kw kx ky kz bi translated">只向可组合的传递稳定且所需数据量最少的数据</li><li id="ae8a" class="kr ks hx iw b ix la jb lb jf lc jj ld jn le jr kw kx ky kz bi translated">遵循单向流动(UDF)模式</li></ul><h1 id="1fa9" class="lf lg hx bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">jetpack Compose:MVI之谜的缺失部分？</h1><p id="bb40" class="pw-post-body-paragraph iu iv hx iw b ix md iz ja jb me jd je jf mf jh ji jj mg jl jm jn mh jp jq jr ha bi translated">既然我们已经回答了“MVI与Compose配合得好吗？”是的，效果很好，让我们进入下一部分。这个答案在某种程度上把我们引向了这样一个方向，即Compose实际上可能是我们的MVI难题中缺失的一块。</p><p id="5d79" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了理解这一点，让我们谈谈MVI来自哪里。Android中的MVI或模型视图意图模式深受web框架的启发，如<a class="ae hu" href="https://cycle.js.org/" rel="noopener ugc nofollow" target="_blank"> Cycle.js </a>和<a class="ae hu" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> redux </a>。在网络世界里，有了<a class="ae hu" href="https://www.codecademy.com/articles/react-virtual-dom" rel="noopener ugc nofollow" target="_blank">虚拟DOM</a>，框架处理不同的东西，只改变DOM中需要的部分，而不是重新呈现整个DOM。</p><p id="7ef6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于MVI来说，如果Android有类似的东西就好了，即自动计算变化的差异，并只重新呈现变化的部分。我经常听到这个问题，即“如何通过我们的<code class="du km kn ko kp b">render() </code>函数用MVI有效地执行部分状态更新”。到目前为止，我们只对<code class="du km kn ko kp b">RecyclerView</code>和<code class="du km kn ko kp b">DiffUtil</code>做了适当的区分。否则，总是由开发人员通过使用我们自己的不同实现来有效地呈现状态对象，从而正确地处理部分状态更新。MVI确实为我们解决了国家管理问题，但观点方面总是不合适。正如<a class="nb nc ge" href="https://medium.com/u/a1e155b14711?source=post_page-----44c0e60b571--------------------------------" rel="noopener" target="_blank"> Ragunath Jawahar </a>所指出的，人们试图通过围绕它创建库来解决这个问题，在某种程度上就像Spotify的<a class="ae hu" href="https://github.com/spotify/diffuser" rel="noopener ugc nofollow" target="_blank"> diffuser </a>一样。理想情况下，如果框架本身能够只处理在我们的状态模型中发生变化的部分的无效，从而只导致视图子树对我们无效，这不是很好吗？</p><p id="8580" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Jetpack Compose来了！</p><p id="436d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它可以通过只重组部件树的一部分来为我们处理部分状态更新，因此它似乎是我们的MVI难题中缺少的一块。我不确定与Android View系统相比，它目前的表现如何，比如基准测试等等。我们都知道，它目前正在开发中，预计今年某个时候会变得稳定。但是，到目前为止，MVI在Android中的未来看起来很有希望。</p><p id="5608" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢这些人以这样或那样的方式帮助我，<a class="nb nc ge" href="https://medium.com/u/c224d46d0025?source=post_page-----44c0e60b571--------------------------------" rel="noopener" target="_blank"> Ritesh Gupta </a>，<a class="nb nc ge" href="https://medium.com/u/a1e155b14711?source=post_page-----44c0e60b571--------------------------------" rel="noopener" target="_blank"> Ragunath Jawahar </a>，<a class="nb nc ge" href="https://medium.com/u/3f9b9c30bec7?source=post_page-----44c0e60b571--------------------------------" rel="noopener" target="_blank"> Rebecca Franks </a>和<a class="nb nc ge" href="https://medium.com/u/9aefb667816f?source=post_page-----44c0e60b571--------------------------------" rel="noopener" target="_blank"> Vinay Gaba </a>。</p><p id="2c0e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你觉得有些东西可以用更好的方式表达或者没有意义，请在评论中告诉我。感谢阅读。</p><p id="e2e3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以在这里找到GitHub示例项目:<a class="ae hu" href="https://github.com/ragdroid/Clayground" rel="noopener ugc nofollow" target="_blank"> Clayground </a></p></div></div>    
</body>
</html>