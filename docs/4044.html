<html>
<head>
<title>Memory mapped files and MappedByteBuffers in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的内存映射文件和MappedByteBuffers</h1>
<blockquote>原文：<a href="https://medium.com/globant/memory-mapped-files-and-mappedbytebuffers-in-java-4e5819605b20?source=collection_archive---------1-----------------------#2022-12-12">https://medium.com/globant/memory-mapped-files-and-mappedbytebuffers-in-java-4e5819605b20?source=collection_archive---------1-----------------------#2022-12-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a7cfc176c95ec3f739e1904a3ed5231e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u0lUOCGUWiOfxq9I"/></div></div></figure><p id="1f16" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇短文中，我们将查看<code class="du jn jo jp jq b">java.nio</code>包中的内存<strong class="ir hi"> - </strong>映射文件<code class="du jn jo jp jq b">MappedByteBuffer</code>。该实用程序对于高效的文件读取非常有用。</p><h1 id="61d0" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">内存映射文件</strong></h1><p id="0360" class="pw-post-body-paragraph ip iq hh ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">内存映射文件是虚拟内存的一个段，它被分配了与文件的某个部分的直接字节对字节的相关性。</p><ul class=""><li id="2982" class="ku kv hh ir b is it iw ix ja kw je kx ji ky jm kz la lb lc bi translated">在内存映射文件中的读取和写入通常由操作系统完成，以将内容写入磁盘。</li><li id="2418" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">内存映射文件包含虚拟内存中文件的内容。文件和内存空间之间的这种映射使得应用程序(包括多个进程)能够通过直接读取和写入内存来修改文件。</li><li id="9a3e" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">对于许多程序员和开发人员来说，Java中的内存映射文件(Memory-Mapped Files)是一个相当新的Java概念，尽管它从JDK 1.4起就与软件包“java.nio”一起出现了。</li><li id="18a0" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">在引入NIO之后，Java IO已经相当快了，而内存映射文件提供了Java中最快的IO操作。<br/>这就是为什么高性能Java应用程序应该使用内存映射文件来持久化数据。</li><li id="85de" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">Memory Mapped在高频交易领域已经相当流行，因为在这个领域，电子交易系统需要超快，而交易的单向延迟必须在亚微秒级。</li></ul><p id="85a1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">内存映射文件有两种类型:</p><ul class=""><li id="7973" class="ku kv hh ir b is it iw ix ja kw je kx ji ky jm kz la lb lc bi translated"><strong class="ir hi">持久化内存映射文件</strong>:持久化文件与磁盘源文件相关联。当最后一个进程处理完该文件时，数据将保存到磁盘上的源文件中。这些内存映射文件适用于处理超大源文件。</li><li id="4754" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated"><strong class="ir hi">非持久化内存映射文件</strong>:非持久化文件是不与磁盘上的文件相关联的内存映射文件。当最后一个进程处理完文件时，数据将丢失，文件将通过垃圾回收回收。这些文件适用于为进程间通信(IPC)创建共享内存。</li></ul><h1 id="edcf" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">内存映射文件的优势</strong></h1><p id="4652" class="pw-post-body-paragraph ip iq hh ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">内存映射的主要好处是效率、更快的文件访问、在应用程序之间共享内存的能力、自动内存管理，以及下文将介绍的更多要点</p><ul class=""><li id="aa39" class="ku kv hh ir b is it iw ix ja kw je kx ji ky jm kz la lb lc bi translated">通过内存映射访问文件比使用<code class="du jn jo jp jq b">fread</code>和<code class="du jn jo jp jq b">fwrite</code>等I/O功能更快。数据的读写使用操作系统内置的虚拟内存功能，而不必分配、复制到进程拥有的数据缓冲区中，然后再解除分配。</li><li id="a575" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">随着用户进程处理映射的内存空间，将自动生成页面错误，以从磁盘引入文件数据。</li><li id="71aa" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">如果用户修改了映射的内存空间，受影响的页面会自动标记为脏，并随后刷新到磁盘以更新文件。</li><li id="05e3" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">操作系统的虚拟内存子系统将执行页面的智能缓存，根据系统负载自动管理内存。</li><li id="2758" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">数据总是页面对齐的，不需要缓冲区复制。可以映射非常大的文件，而无需消耗大量内存来复制数据。</li></ul><h1 id="41bc" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">内存映射文件的示例</strong></h1><p id="f0e3" class="pw-post-body-paragraph ip iq hh ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">下图显示了多个进程如何同时拥有同一个内存映射文件的多个重叠视图。<br/>显示内存映射文件的多个重叠视图:</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div class="er es li"><img src="../Images/cd914aea4fb722d3726cba9629be0460.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/0*eBP2xvKH2wkKp1aI.png"/></div></figure><p id="cda3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> MappedByteBuffer </strong>对于映射了相同文件的其他程序也是不可见的；相反，它们将导致创建缓冲区修改部分的私有副本。</p><pre class="lj lk ll lm fd ln jq lo bn lp lq bi"><span id="6661" class="lr js hh jq b be ls lt l lu lv">import java.io.RandomAccessFile;<br/>import java.nio.MappedByteBuffer;<br/>import java.nio.channels.FileChannel;<br/> <br/>public class MemoryMappedFile <br/>{<br/>  static int length = 0x8FFFFFF;  <br/> <br/>  public static void main(String[] args) throws Exception <br/>  {<br/>    try(RandomAccessFile file = new RandomAccessFile("test.dat", "rw")) <br/>    {<br/>      MappedByteBuffer out = file.getChannel()<br/>                    .map(FileChannel.MapMode.READ_WRITE, 0, length);<br/>       <br/>      for (int i = 0; i &lt; length; i++) <br/>      {<br/>        out.put((byte) 'x');<br/>      }<br/>       <br/>      System.out.println("Finished writing");<br/>    }<br/>  }<br/>}</span></pre><p id="d30f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用上述程序创建的文件有128 MB长，这可能比您的操作系统允许的空间要大。该文件看起来可以立即访问，因为只有部分文件被放入内存，其他部分被换出。这样，可以很容易地修改非常大的文件(高达2 GB)。</p><h1 id="ae6d" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">内存映射文件的优缺点<strong class="ak"/></h1><p id="fef6" class="pw-post-body-paragraph ip iq hh ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">内存映射文件有几个优点和缺点:</p><ul class=""><li id="77af" class="ku kv hh ir b is it iw ix ja kw je kx ji ky jm kz la lb lc bi translated">可能，内存映射IO的主要优势是性能，这对于构建高性能系统(如电子交易)非常重要。</li><li id="5c16" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">内存映射文件比通过普通IO访问标准文件要快得多。</li><li id="8880" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">内存映射IO的另一个显著优点是，它允许您加载一个潜在的更大的文件，否则是无法访问的。</li><li id="64dc" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">内存映射IO的缺点是，它可能会使您的缓存控制器变得复杂，因为设备访问的行为不同于普通的内存访问。</li></ul><h1 id="37a4" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">结论</strong></h1><p id="2f81" class="pw-post-body-paragraph ip iq hh ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">在本文中，我们了解了以下几点:</p><ul class=""><li id="57b6" class="ku kv hh ir b is it iw ix ja kw je kx ji ky jm kz la lb lc bi translated">内存映射文件比通过普通IO访问标准文件要快得多。</li><li id="36e5" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">多个进程可以拥有同一个内存映射文件的多个重叠视图。</li><li id="ddfa" class="ku kv hh ir b is ld iw le ja lf je lg ji lh jm kz la lb lc bi translated">内存映射文件的类型。</li></ul></div></div>    
</body>
</html>