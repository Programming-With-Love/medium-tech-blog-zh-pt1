<html>
<head>
<title>Unit Testing Kotlin Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试Kotlin流</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/unit-testing-kotlin-flow-76ea5f4282c5?source=collection_archive---------0-----------------------#2021-02-26">https://medium.com/google-developer-experts/unit-testing-kotlin-flow-76ea5f4282c5?source=collection_archive---------0-----------------------#2021-02-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="38e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在为我的Kotlin流编写单元测试时,“这项工作尚未完成”是一个让我做噩梦的错误消息。这篇文章描述了我在过去测试反应流(<code class="du jc jd je jf b">LiveData</code>和<code class="du jc jd je jf b">RxJava</code>)的典型方式，以及我如何尝试将这些方法应用到流中，但收效甚微。它继续试验谷歌推荐的方法，最后，展示了我迄今为止发现的最好的解决方案:<a class="ae jg" href="https://github.com/cashapp/turbine" rel="noopener ugc nofollow" target="_blank">涡轮机</a>。如果你只是在寻找解决方案，滚动到文章的结尾。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/996b9a8bede854c96a2c4dada07921f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7YUVzLKILwqR3KM74yhBRg.jpeg"/></div></div></figure><p id="f24c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我一直用于测试<code class="du jc jd je jf b">LiveData</code>和<code class="du jc jd je jf b">RxJava</code>流的方法类似于从汽车中抽取汽油:将一个容器连接到输出端，摆弄输入端，看看会有什么输出。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jt"><img src="../Images/1c69580b70c295c6d1a48df65275fdf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OdRzjkiBf7_n5GPm"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">Source: <a class="ae jg" href="https://developer.android.com/kotlin/flow/test?hl=uk" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/kotlin/flow/test</a></figcaption></figure><p id="3fdd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是我已经用了很长时间的测试平台，它是为测试<code class="du jc jd je jf b">LiveData</code>而设计的。容器是一个<code class="du jc jd je jf b">LiveDataTestObserver</code>，桶是一个<code class="du jc jd je jf b">MutableList</code>。设置一些模拟，戳测试结构(<code class="du jc jd je jf b">ViewModel</code>、<code class="du jc jd je jf b">Repository</code>、<code class="du jc jd je jf b">Service</code>)，看看<code class="du jc jd je jf b">observedValues</code>完成后是什么样子。</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="e4c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个想法对于<code class="du jc jd je jf b">RxJava</code>、<code class="du jc jd je jf b">LiveData</code>和<code class="du jc jd je jf b">Coroutines/Flow</code>都很管用。每一个都有一个全局调度器，你可以用一个<code class="du jc jd je jf b"><a class="ae jg" href="https://junit.org/junit4/javadoc/4.12/org/junit/rules/TestRule.html" rel="noopener ugc nofollow" target="_blank">TestRule</a></code>来配置它，以便在你运行单元测试的时候，让所有的东西都在一个线程上运行。<code class="du jc jd je jf b">LiveData</code>见<code class="du jc jd je jf b"><a class="ae jg" href="https://developer.android.com/reference/android/arch/core/executor/testing/InstantTaskExecutorRule" rel="noopener ugc nofollow" target="_blank">InstantTaskExecutorRule</a></code>，这里是<code class="du jc jd je jf b">RxJava</code>的类似实现:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="118f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">协程和流配备了与<code class="du jc jd je jf b">LiveData</code>和<code class="du jc jd je jf b">RxJava</code>相同的调度机制，它们可以以相同的方式使用。它允许你拦截代码中的<code class="du jc jd je jf b">delays()</code>和<code class="du jc jd je jf b">timeouts()</code>，跳过它们或者提前时间来加速你的单元测试。确保您的代码使用<code class="du jc jd je jf b"><a class="ae jg" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-dispatcher/" rel="noopener ugc nofollow" target="_blank">TestDispatcher</a></code>的聪明方法是将<code class="du jc jd je jf b">DispatcherProvider</code>注入到任何专门与<code class="du jc jd je jf b">Dispatcher</code>交互的结构中。我从Craig的帖子中了解到如何做到这一点:</p><div class="ka kb ez fb kc kd"><a href="https://craigrussell.io/2019/11/unit-testing-coroutine-suspend-functions-using-testcoroutinedispatcher/" rel="noopener  ugc nofollow" target="_blank"><div class="ke ab dw"><div class="kf ab kg cl cj kh"><h2 class="bd hi fi z dy ki ea eb kj ed ef hg bi translated">使用TestCoroutineDispatcher单元测试协程挂起函数</h2><div class="kk l"><h3 class="bd b fi z dy ki ea eb kj ed ef dx translated">Kotlin协程提供了一种编写异步代码的优雅方式，但有时协程使它很难…</h3></div><div class="kl l"><p class="bd b fp z dy ki ea eb kj ed ef dx translated">克雷格·罗素</p></div></div><div class="km l"><div class="kn l ko kp kq km kr jr kd"/></div></div></a></div><p id="86b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个简化的版本:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="0b43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你开始在互联网上寻找“这项工作尚未完成”的解决方案，你最终会在Kotlin-Coroutines项目中遇到这个Github问题。当你滚动的时候，你会注意到使用上面的<code class="du jc jd je jf b">TestCoroutineRule</code>和<code class="du jc jd je jf b">TestDispatcher</code>对一些人来说解决了问题，但对另一些人来说却不是。为什么？</p><p id="cbb8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">单元测试一个流是困难的，因为一个流不一定要完成。这是结构化并发的哲学核心特征。事实上，Flow的一些实现(即。<a class="ae jg" href="https://elizarov.medium.com/cold-flows-hot-channels-d74769805f9" rel="noopener">热流</a>被<em class="ks">设计为</em>永不完成。例如，如果你观察一个<code class="du jc jd je jf b">MutableStateFlow</code>，这个想法就是即使没有东西观察它，它也保持它的值——所以它从来没有被设计完成。所以<code class="du jc jd je jf b">TestCoroutineRule</code>对一些人有效而对另一些人无效的原因是因为每个人都以不同的方式实现他们的流程。</p><p id="e077" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么我们如何测试这些类型的流量呢？</p><p id="2854" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Android文档中有一些<a class="ae jg" href="https://developer.android.com/kotlin/flow/test" rel="noopener ugc nofollow" target="_blank">指南</a>关于如何进行与流程相关的单元测试。它提出了一个建议:</p><blockquote class="kt ku kv"><p id="c5d0" class="ie if ks ig b ih ii ij ik il im in io kw iq ir is kx iu iv iw ky iy iz ja jb ha bi translated">对于需要更复杂的项目集合或者不返回有限数量项目的数据流，您可以使用<code class="du jc jd je jf b">Flow</code> API来选择和转换项目。</p></blockquote><p id="a0e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它继续建议对这些更复杂的数据流使用某些操作符，如<code class="du jc jd je jf b">first()</code>和<code class="du jc jd je jf b">take()</code>，这在大多数情况下是可行的。我相信有更好的方法——但是官方的方法是一个好的开始，并且不涉及第三方依赖。下面我将演示如何使用官方的Android文档建议进行测试，然后使用我喜欢的方法重写测试进行比较。</p><p id="911a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看一些例子，从冷流开始，这比较容易测试:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="80b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，中间的测试成功了，但是流程的实现已经“改变”了。在我看来，虽然代码本身工作正常，但测试未能检测到实现发生了变化。想象一下，比如说,“流动”代表着<code class="du jc jd je jf b">isLoading</code>。如果它发出一个额外的值，这可能意味着加载指示器是可见的，而不是不可见的。不好。我们稍后将回到这一点。</p><p id="1878" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们来看看测试一些热流:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="6c22" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第一个测试中，测试本身挂起了…是时候进入StackOverflow了。</p><p id="ed47" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第二个测试中，我们使用了<code class="du jc jd je jf b">TestDispatcher </code>——非常聪明——但是现在我们有了著名的“这个任务还没有完成”错误消息。</p><p id="dfea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第三次测试中，<code class="du jc jd je jf b">first()</code>用官方Android文档的方式解决了我们的问题。或者看起来… <code class="du jc jd je jf b">first()</code>起作用是因为它取消了流量的收集。<code class="du jc jd je jf b">take()</code>没有，所以如果我们想做比<code class="du jc jd je jf b">first()</code>更有趣的热流，我们又回到了起点…</p><p id="2523" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">进入<a class="ae jg" href="https://github.com/cashapp/turbine" rel="noopener ugc nofollow" target="_blank">涡轮</a>。</p><p id="d6fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Turbine是一个漂亮的小测试库，它不仅解决了上面这两个问题，还使我们的单元测试更加习惯。它有一个非常容易跟随的<a class="ae jg" href="https://github.com/cashapp/turbine" rel="noopener ugc nofollow" target="_blank">自述</a>，所以我不会在这里重复它的特性集。我要做的是从上面重构我们的冷流试验，以使用涡轮:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="1ed4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，我们不仅有了更干净、更习惯的单元测试，而且我们现在正在捕捉我们以前错过的实现变化。不再有<code class="du jc jd je jf b">isLoading</code> bug。</p><p id="7b8d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们对热流做同样的处理:</p><figure class="ji jj jk jl fd jm"><div class="bz dy l di"><div class="jy jz l"/></div></figure><p id="0a72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，我们没有显式地使用<code class="du jc jd je jf b">TestDispatcher</code>，而是使用这些调用<code class="du jc jd je jf b">cancelAndConsumeRemainingEvents()</code>或<code class="du jc jd je jf b">cancelAndIgnoreRemainingEvents()</code>来明确测试应该如何结束。</p></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><p id="238d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总而言之，测试流程和协同程序需要从根本上改变您对反应式流程的思考方式。但是如果你来这里仅仅是为了寻找“作业未完成”错误消息的答案，那就是:使用<a class="ae jg" href="https://github.com/cashapp/turbine" rel="noopener ugc nofollow" target="_blank">涡轮机</a>对你的流程进行单元测试。</p></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><h2 id="8e90" class="lg lh hh bd li lj lk ll lm ln lo lp lq ip lr ls lt it lu lv lw ix lx ly lz ma bi translated">干杯和啤酒</h2><p id="af18" class="pw-post-body-paragraph ie if hh ig b ih mb ij ik il mc in io ip md ir is it me iv iw ix mf iz ja jb ha bi translated">感谢<a class="mg mh ge" href="https://medium.com/u/f08187f6a023?source=post_page-----76ea5f4282c5--------------------------------" rel="noopener" target="_blank">恩里克·洛佩斯·马斯</a>和<a class="mg mh ge" href="https://medium.com/u/3b5622dd813c?source=post_page-----76ea5f4282c5--------------------------------" rel="noopener" target="_blank">曼努埃尔·维沃</a>为我润色这篇文章。下次见面我请你喝啤酒。</p><h2 id="29d3" class="lg lh hh bd li lj lk ll lm ln lo lp lq ip lr ls lt it lu lv lw ix lx ly lz ma bi translated">资料来源和进一步阅读:</h2><div class="ka kb ez fb kc kd"><a href="https://ericniebler.com/2020/11/08/structured-concurrency/" rel="noopener  ugc nofollow" target="_blank"><div class="ke ab dw"><div class="kf ab kg cl cj kh"><h2 class="bd hi fi z dy ki ea eb kj ed ef hg bi translated">结构化并发</h2><div class="kk l"><h3 class="bd b fi z dy ki ea eb kj ed ef dx translated">TL；DR:“结构化并发”指的是一种构造异步计算的方法，这样可以保证子操作…</h3></div><div class="kl l"><p class="bd b fp z dy ki ea eb kj ed ef dx translated">ericniebler.com</p></div></div><div class="km l"><div class="mi l ko kp kq km kr jr kd"/></div></div></a></div><div class="ka kb ez fb kc kd"><a href="https://github.com/Kotlin/kotlinx.coroutines/issues/1204#issuecomment-668143287" rel="noopener  ugc nofollow" target="_blank"><div class="ke ab dw"><div class="kf ab kg cl cj kh"><h2 class="bd hi fi z dy ki ea eb kj ed ef hg bi translated">runBlockingTest失败，出现“此作业尚未完成”问题#1204 …</h2><div class="kk l"><h3 class="bd b fi z dy ki ea eb kj ed ef dx translated">这个简单的块:runBlockingTest { suspendencelablecoroutine { cont-&gt; thread { thread . sleep(1000)……</h3></div><div class="kl l"><p class="bd b fp z dy ki ea eb kj ed ef dx translated">github.com</p></div></div><div class="km l"><div class="mj l ko kp kq km kr jr kd"/></div></div></a></div><div class="ka kb ez fb kc kd"><a href="https://elizarov.medium.com/structured-concurrency-722d765aa952" rel="noopener follow" target="_blank"><div class="ke ab dw"><div class="kf ab kg cl cj kh"><h2 class="bd hi fi z dy ki ea eb kj ed ef hg bi translated">结构化并发</h2><div class="kk l"><h3 class="bd b fi z dy ki ea eb kj ed ef dx translated">今天标志着kotlinx.coroutines库0.26.0版本的发布和结构化并发的引入…</h3></div><div class="kl l"><p class="bd b fp z dy ki ea eb kj ed ef dx translated">elizarov.medium.com</p></div></div></div></a></div><div class="ka kb ez fb kc kd"><a href="https://craigrussell.io/2019/11/unit-testing-coroutine-suspend-functions-using-testcoroutinedispatcher/" rel="noopener  ugc nofollow" target="_blank"><div class="ke ab dw"><div class="kf ab kg cl cj kh"><h2 class="bd hi fi z dy ki ea eb kj ed ef hg bi translated">使用TestCoroutineDispatcher单元测试协程挂起函数</h2><div class="kk l"><h3 class="bd b fi z dy ki ea eb kj ed ef dx translated">Kotlin协程提供了一种编写异步代码的优雅方式，但有时协程使它很难…</h3></div><div class="kl l"><p class="bd b fp z dy ki ea eb kj ed ef dx translated">克雷格·罗素</p></div></div><div class="km l"><div class="mk l ko kp kq km kr jr kd"/></div></div></a></div><div class="ka kb ez fb kc kd"><a href="https://elizarov.medium.com/cold-flows-hot-channels-d74769805f9" rel="noopener follow" target="_blank"><div class="ke ab dw"><div class="kf ab kg cl cj kh"><h2 class="bd hi fi z dy ki ea eb kj ed ef hg bi translated">冷流，热通道</h2><div class="kk l"><h3 class="bd b fi z dy ki ea eb kj ed ef dx translated">Kotlin协同程序缺少一个原语来表示冷异步数据流。不再是了。欢迎科特林…</h3></div><div class="kl l"><p class="bd b fp z dy ki ea eb kj ed ef dx translated">elizarov.medium.com</p></div></div><div class="km l"><div class="ml l ko kp kq km kr jr kd"/></div></div></a></div></div></div>    
</body>
</html>