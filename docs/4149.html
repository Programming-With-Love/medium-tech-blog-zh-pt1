<html>
<head>
<title>Building Your Next Serverless Application: The Complete Guide.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建下一个无服务器应用程序:完全指南。</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/building-your-next-serverless-application-the-complete-guide-98e48f85bd3c?source=collection_archive---------0-----------------------#2017-12-27">https://medium.com/google-developer-experts/building-your-next-serverless-application-the-complete-guide-98e48f85bd3c?source=collection_archive---------0-----------------------#2017-12-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/393e79db84a31baac4bd1e202e966e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X7b6gJCWoxHOlApPaI82Rw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The overall architecture of our serverless application</figcaption></figure><p id="b359" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我打赌你已经听说过无服务器架构:云计算的下一次进化。术语“无服务器”实际上是云计算中两个领域的总称:后端即服务(BaaS)和功能即服务(FaaS)。</p><p id="1756" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">借助BaaS，我们将应用程序分解成更小的部分，并完全通过外部服务实现其中的一些部分。这通常是通过调用API(或<a class="ae jr" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>调用)来完成的。最受欢迎的后端服务之一是谷歌的<a class="ae jr" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank"> Firebase </a>，这是一个用于移动和网络应用的实时数据库(有很多其他很酷的功能)。</p><p id="2542" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">另一方面，功能即服务是计算即服务的另一种形式:FaaS是一种构建和部署服务器端代码的方式，只需在供应商提供的FaaS平台上部署单个功能(因此得名)。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="6302" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">既然我们已经就无服务器架构的正确定义达成一致，<strong class="iv hi">让我们构建一个完整的“无服务器应用程序”。</strong></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="d5c0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们要构建的应用程序是一个聊天机器人，它能够从图片中提取文本内容(可选地将其翻译成不同的语言)，并通过SMS(或电话)将结果发送回用户。这种应用程序可以用来从给定的图像甚至视频流中提取其他有用的信息，并向用户或一组用户发送SMS通知。</p><p id="e8b6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我相信你现在正在想一个更有趣的用例。如果是这样，请告诉我！</p><p id="4026" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们开始吧…</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="95a4" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">1-创建聊天机器人</h1><p id="2d07" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">对于我们的用例，我们希望与我们的代理(又名。“聊天机器人”)并向它提供一些包含一些文本的内容，以便提取和稍后分析(可能是一本书或一份报纸的一页？).</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/9b95a454a3b3cafe7a5b5b2d4ff8aeb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5OzRt3GnehKNplx28-0QA.png"/></div></div></figure><h2 id="d750" class="lg ka hh bd kb lh li lj kf lk ll lm kj je ln lo kn ji lp lq kr jm lr ls kv lt bi translated">为我们的代理创建“对话流”</h2><p id="6a86" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">由于“聊天机器人”部分不是我们在这篇文章中的主要关注点，我们将“保持简单，愚蠢”并在DialogFlow中设计一个快速对话，如下所示:</p><ol class=""><li id="fef9" class="lu lv hh iv b iw ix ja jb je lw ji lx jm ly jq lz ma mb mc bi translated">创建一个意图“阅读”。</li><li id="12ca" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated">添加几个用户的表达，例如“阅读此文本”或“提取文本”。</li><li id="6fe8" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated">添加一个“读取”动作。</li><li id="c5b6" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated">启用webhook的使用(参见下面的实现)。</li></ol><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/c481828caca768f197a6df98332cdbb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_BAWQtc8uZhIMxh-PSu-Uw.png"/></div></div></figure><h2 id="f202" class="lg ka hh bd kb lh li lj kf lk ll lm kj je ln lo kn ji lp lq kr jm lr ls kv lt bi translated">b-实现代理逻辑</h2><p id="f775" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">现在，让我们为实际拍摄照片的代理编写逻辑代码。</p><p id="f00a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">首先，我们需要两个效用函数:</p><ol class=""><li id="0616" class="lu lv hh iv b iw ix ja jb je lw ji lx jm ly jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">captureImage</code>使用用户相机拍摄图像的功能。</li><li id="5447" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">uploadImage</code>上传图片到谷歌云存储(GCS)的功能。</li></ol><p id="186b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这里实现了<code class="du mj mk ml mm b">captureImage</code>功能。该功能使用MacOS上可用的系统实用程序<code class="du mj mk ml mm b">imagesnap</code>来实际访问相机，捕捉图像并将图像文件存储在<code class="du mj mk ml mm b">/tmp/google-actions-reader-${Date.now()}.png</code>下。然后，该函数返回<code class="du mj mk ml mm b">base64</code>中的名称和文件内容:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="4956" class="lg ka hh mm b fi mr ms l mt mu">const fs = require('fs');<br/>const child_process = require('child_process');<br/>const Buffer = require('safe-buffer').Buffer;</span><span id="2e96" class="lg ka hh mm b fi mv ms l mt mu">/**<br/> * Capture the image from the user computer's camera.<br/> */<br/>function <strong class="mm hi">captureImage</strong>() {<br/>  return new Promise((res, rej) =&gt; {<br/>    const file = `/tmp/google-actions-reader-${Date.now()}.png`;<br/>    try {<br/>      child_process.execSync(`imagesnap -w 1 ${file}`);<br/>      const bitmap = fs.readFileSync(file);<br/>      res({<br/>        base64: new Buffer(bitmap).toString('base64'),<br/>        file<br/>      });<br/>    } catch (err) { rej(err); }<br/>  });<br/>}</span></pre><p id="11ff" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">下一个函数<code class="du mj mk ml mm b">uploadImage</code>将简单地把图像上传到GCS的<code class="du mj mk ml mm b">cloud-function-ocr-demo__image</code>桶中:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="29e1" class="lg ka hh mm b fi mr ms l mt mu">const child_process = require('child_process');</span><span id="d33f" class="lg ka hh mm b fi mv ms l mt mu">/**<br/> * Uploads the file to GCS.<br/> *<br/> * @param {object} data The GCP payload metadata.<br/> * @param {object} data.file The filename to read.<br/> */<br/>function <strong class="mm hi">uploadImage</strong>(data) {<br/>  child_process.execSync(<br/>    `gsutil cp ${data.file} gs://cloud-function-ocr-demo__image`<br/>  );<br/>  return data.file.split('/').pop();<br/>}</span></pre><blockquote class="mw mx my"><p id="b16b" class="it iu mz iv b iw ix iy iz ja jb jc jd na jf jg jh nb jj jk jl nc jn jo jp jq ha bi translated">请记下桶的名称<code class="du mj mk ml mm b">cloud-function-ocr-demo__image</code>，我们稍后会用到它。</p></blockquote><p id="0f8d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在我们已经准备好了两个实用函数<code class="du mj mk ml mm b">captureImage</code>和<code class="du mj mk ml mm b">uploadImage</code>，让我们在<strong class="iv hi">读取</strong>意图逻辑中使用它们(还记得上面对话框中的意图吗？):</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="3dfc" class="lg ka hh mm b fi mr ms l mt mu">/**<br/> * The "read" intent that will trigger the capturing and uploading<br/> * the image to GSC.<br/> *<br/> * @param {object} app DialogflowApp instance object.<br/> */<br/>function <strong class="mm hi">readIntent</strong>(app) {<br/>  <strong class="mm hi">captureImage</strong>()<br/>    .then(<strong class="mm hi">uploadImage</strong>)<br/>    .then(content =&gt; {<br/>      app.tell(`I sent you an SMS with your content.`);<br/>    })<br/>    .catch(e =&gt; app.ask(`[ERROR] ${e}`) );<br/>}</span></pre><p id="54f9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这个<code class="du mj mk ml mm b">readIntent</code>基本上会捕捉图像，然后上传到GCS。</p><p id="d9b8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在我们已经实现了代理的所有逻辑，让我们创建主云函数来处理DialogFlow的请求:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="44ef" class="lg ka hh mm b fi mr ms l mt mu">const aog = require('actions-on-google');<br/>const DialogflowApp = aog.DialogflowApp;</span><span id="5414" class="lg ka hh mm b fi mv ms l mt mu">/**<br/> * Handles the agent (chatbot) logic. Triggered from an HTTP call.<br/> *<br/> * @param {object} request Express.js request object.<br/> * @param {object} response Express.js response object.<br/> */<br/>module.exports.<strong class="mm hi">assistant</strong> = (request, response) =&gt; {<br/>  const app = new DialogflowApp({ request, response });<br/>  const actions = new Map();<br/>  actions.set('read', <strong class="mm hi">readIntent</strong>);<br/>  app.handleRequest(actions);<br/>};</span></pre><p id="318f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du mj mk ml mm b">assistant</code>云函数将由HTTP调用触发。例如，如果用户说“阅读此文本”(如上所述)，这是在<strong class="iv hi"> read </strong>意图中定义的一个表达式，则该调用将由DialogFlow进行。</p><h2 id="4a0b" class="lg ka hh bd kb lh li lj kf lk ll lm kj je ln lo kn ji lp lq kr jm lr ls kv lt bi translated">c-部署云助手功能</h2><blockquote class="mw mx my"><p id="a6c5" class="it iu mz iv b iw ix iy iz ja jb jc jd na jf jg jh nb jj jk jl nc jn jo jp jq ha bi translated">本节将作为本指南其余部分的示例。</p></blockquote><p id="c462" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为了部署云功能，我们可以使用带有以下参数的<code class="du mj mk ml mm b">gcloud</code>命令:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="7e48" class="lg ka hh mm b fi mr ms l mt mu">gcloud beta functions <br/>  deploy <strong class="mm hi">&lt;function-label&gt; </strong><br/>  <strong class="mm hi">&lt;trigger-type&gt;</strong> <br/>  <!-- -->--source <strong class="mm hi">&lt;source-code&gt; </strong><br/>  --entry-point <strong class="mm hi">&lt;function-name&gt;</strong></span></pre><ol class=""><li id="68a0" class="lu lv hh iv b iw ix ja jb je lw ji lx jm ly jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">&lt;function-label&gt;</code>是功能标签，可以与<code class="du mj mk ml mm b">&lt;function-name&gt;</code>相同或不同。</li><li id="2864" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">&lt;trigger-type&gt;</code>是您的功能将如何被触发(主题、http、存储…等)。</li><li id="c9fc" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">&lt;source-code&gt;</code>是托管函数源代码的Google Cloud Repository。<strong class="iv hi">这不会是其他的公共Git库吧！</strong></li><li id="78f0" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">&lt;function-name&gt;</code>是实际导出的函数名(在你的代码中)。</li></ol><blockquote class="mw mx my"><p id="aa78" class="it iu mz iv b iw ix iy iz ja jb jc jd na jf jg jh nb jj jk jl nc jn jo jp jq ha bi translated">你也可以使用Google云存储空间来存放你的函数的源代码。但是我们不会在这里讨论这个。</p></blockquote><p id="e38d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">哦，对了…</p><blockquote class="mw mx my"><p id="8e68" class="it iu mz iv b iw ix iy iz ja jb jc jd na jf jg jh nb jj jk jl nc jn jo jp jq ha bi translated">如果你的组织有一个持续交付策略，将你的源代码托管在谷歌云仓库(Git repo)是一个好主意。</p></blockquote><p id="c31f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在我们的例子中，下面是完整的命令:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="8f63" class="lg ka hh mm b fi mr ms l mt mu">gcloud beta functions <br/>  deploy ocr-assistant <br/>  --source https://source.developers.google.com/projects/...<br/>  --trigger-http<br/>  --entry-point assistant</span></pre><p id="4614" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您想知道，Google云存储库源代码有以下格式:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="5d61" class="lg ka hh mm b fi mr ms l mt mu">https://source.developers.google.com/projects/<strong class="mm hi">&lt;project-id&gt;</strong>/repos/<strong class="mm hi">&lt;repo-id&gt;</strong>/moveable-aliases/<strong class="mm hi">&lt;branch-name&gt;</strong></span></pre><p id="37ab" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一旦部署，您的功能应该准备好被触发:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nd"><img src="../Images/93c56e5aa75b157e93fb53ffc55605ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cnk60-jm3ljH2IYXRfxSsg.png"/></div></div></figure><p id="f526" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您还将获得一个公共URL，如下所示:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="e237" class="lg ka hh mm b fi mr ms l mt mu"><em class="mz">https://us-central1-</em><strong class="mm hi"><em class="mz">&lt;project-id&gt;</em></strong><em class="mz">.cloudfunctions.net/ocr-assistant</em></span></pre><p id="c67e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是我们将在DialogFlow项目中使用的URL。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h2 id="6cd5" class="lg ka hh bd kb lh li lj kf lk ll lm kj je ln lo kn ji lp lq kr jm lr ls kv lt bi translated">抓住你了。！</h2><p id="77ac" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">如果你一直在仔细观察，你可能已经注意到了<code class="du mj mk ml mm b">captureImage</code>函数需要……嗯，访问一个摄像头！这意味着我们将无法将这一特定功能部署到谷歌云平台上。相反，我们将在我们的特定硬件上托管它，比如说一个Raspberry PI(为了简单起见)，并使用不同的URL(显然)。</p><blockquote class="mw mx my"><p id="e046" class="it iu mz iv b iw ix iy iz ja jb jc jd na jf jg jh nb jj jk jl nc jn jo jp jq ha bi translated">你可以使用<a class="ae jr" href="https://cloud.google.com/functions/docs/emulator" rel="noopener ugc nofollow" target="_blank">谷歌云函数模拟器</a>在本地运行你的云函数。请记住，这只是为了开发的目的。<strong class="iv hi">不要将其用于生产应用。</strong></p></blockquote></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h2 id="e11c" class="lg ka hh bd kb lh li lj kf lk ll lm kj je ln lo kn ji lp lq kr jm lr ls kv lt bi translated">d-添加履行网址</h2><p id="e9ec" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">然后让我们添加履行URL，它指向将处理代理请求的<code class="du mj mk ml mm b">assistant</code>云函数:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/5a446719fba600494356b656e29d5b4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*415CLLOT0fVnL7IOhIh3FQ.png"/></div></div></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="93e9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在，我们已经完成了应用程序的第一部分，主要是将我们的图像上传到GCS。</p><h1 id="9880" class="jz ka hh bd kb kc ne ke kf kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw bi translated">2-处理图像</h1><p id="166a" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">到目前为止，我们只讨论了云功能—FaaS。让我们跳到后端即服务(或BaaS)部分。</p><p id="b962" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们希望能够从图像中提取一些内容，在我们的例子中是文本。我们有大量的开源库可以做到这一点，比如OpenCV或Tensorflow。不幸的是，这些库要求我们在机器学习和图像(或声音)处理方面拥有某种专业知识。雇佣这些专家并不容易！此外，理想情况下，我们不想维护这些代码，我们希望我们的解决方案能够自动伸缩，以防我们的应用程序变得流行。简单说，我们不想管理这个功能。幸运的是，谷歌云平台覆盖了我们:</p><ol class=""><li id="5580" class="lu lv hh iv b iw ix ja jb je lw ji lx jm ly jq lz ma mb mc bi translated">Google Vision API允许我们提取内容。</li><li id="766e" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated">使用<a class="ae jr" href="https://cloud.google.com/translate/" rel="noopener ugc nofollow" target="_blank">谷歌翻译API </a>允许我们……嗯，翻译内容。</li></ol><p id="14f9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">以下是该功能的子架构:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/169f2321de67786beacb18d10e545e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q4xC6HZBNPI8KLEu8bqVjA.png"/></div></div></figure><h2 id="98be" class="lg ka hh bd kb lh li lj kf lk ll lm kj je ln lo kn ji lp lq kr jm lr ls kv lt bi translated">a-从图像中提取内容</h2><p id="f9da" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">为了能够处理图像，我们需要两个函数:</p><ol class=""><li id="7e4a" class="lu lv hh iv b iw ix ja jb je lw ji lx jm ly jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">processImage</code>每当有新图像上传到GCS的桶中时触发的云功能<code class="du mj mk ml mm b">cloud-function-ocr-demo__image</code>。</li><li id="c1e8" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">detectText</code>使用谷歌视觉API从图像中提取文本的功能。</li></ol><p id="c1fa" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">下面是<code class="du mj mk ml mm b">processImage</code>的实现:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="d49f" class="lg ka hh mm b fi mr ms l mt mu">/**<br/> * Cloud Function triggered by GCS when a file is uploaded.<br/> *<br/> * @param {object} event The Cloud Functions event.<br/> * @param {object} event.data A Google Cloud Storage File object.<br/> */<br/>exports.<strong class="mm hi">processImage</strong> = function processImage(event) {<br/>  let file = event.data;<br/><br/>  return Promise.resolve()<br/>    .then(() =&gt; {<br/>      if (file.resourceState === 'not_exists') {<br/>        // This was a deletion event, we don't want to process this<br/>        return;<br/>      }<br/><br/>      return <strong class="mm hi">detectText</strong>(file.bucket, file.name);<br/>    })<br/>    .then(() =&gt; {<br/>      console.log(`File ${file.name} processed.`);<br/>    });<br/>};</span></pre><p id="4af3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du mj mk ml mm b">detectText</code>函数的实现很简单(我们后面会改进):</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="4110" class="lg ka hh mm b fi mr ms l mt mu">const vision = require('@google-cloud/vision')();</span><span id="9eb7" class="lg ka hh mm b fi mv ms l mt mu">/**<br/> * Detects the text in an image using the Google Vision API.<br/> *<br/> * @param {string} bucketName Cloud Storage bucket name.<br/> * @param {string} filename Cloud Storage file name.<br/> */<br/>function <strong class="mm hi">detectText</strong>(bucketName, filename) {<br/>  let text;<br/><br/>  return <strong class="mm hi">vision<br/>    .textDetection({ <br/>      source: { <br/>         imageUri: `gs://${bucketName}/${filename}` <br/>      }<br/>    })</strong><br/>    .then(([detections]) =&gt; {<br/>      const annotation = detections.textAnnotations[0];<br/>      text = annotation ? annotation.description : '';<br/>      return Promise.resole(text);<br/>    });<br/>}</span></pre><p id="c16f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们现在需要部署<code class="du mj mk ml mm b">processImage</code>云函数，我们希望每当有新图像上传到<code class="du mj mk ml mm b">cloud-function-ocr-demo__image</code>桶中的GCS时，它就会被触发:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="995a" class="lg ka hh mm b fi mr ms l mt mu">gcloud beta functions <br/>   deploy ocr-extract<br/>   --source https://source.developers.google.com/projects/...<br/>   --trigger-bucket cloud-function-ocr-demo__image <br/>   --entry-point processImage</span></pre><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nd"><img src="../Images/1a7306412e54f6024133d5e62703e28e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QT8uKx7bXHtmP-tj8Bldmg.png"/></div></div></figure><p id="b96e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在让我们添加一些翻译…</p><h2 id="89bb" class="lg ka hh bd kb lh li lj kf lk ll lm kj je ln lo kn ji lp lq kr jm lr ls kv lt bi translated">翻译文本</h2><p id="5ec1" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">翻译提取的文本将由特定的Google Cloud发布/订阅主题<code class="du mj mk ml mm b">TRANSLATE_TOPIC</code>触发，并将由两个操作组成:</p><ol class=""><li id="b1a7" class="lu lv hh iv b iw ix ja jb je lw ji lx jm ly jq lz ma mb mc bi translated">检测提取内容的语言。我们将在之前的<code class="du mj mk ml mm b">processImage</code>函数中完成这项工作。我们可以为此创建另一个云功能，但不要让我们的架构过于复杂！</li><li id="e7aa" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">translateText</code>:将内容翻译成给定语言。</li></ol><p id="638e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们用语言检测功能来改进我们现有的<code class="du mj mk ml mm b">processImage</code>云功能:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="18d3" class="lg ka hh mm b fi mr ms l mt mu">const vision = require('@google-cloud/vision')();<br/>const translate = require('@google-cloud/translate')();<br/>const config = require('./config.json');</span><span id="46c5" class="lg ka hh mm b fi mv ms l mt mu">/**<br/> * Detects the text in an image using the Google Vision API.<br/> *<br/> * @param {string} bucketName Cloud Storage bucket name.<br/> * @param {string} filename Cloud Storage file name.<br/> * @returns {Promise}<br/> */<br/>function <strong class="mm hi">detectText</strong>(bucketName, filename) {<br/>  let text;<br/><br/>  return vision<br/>    .textDetection({ <br/>      source: { <br/>         imageUri: `gs://${bucketName}/${filename}` <br/>      }<br/>    })</span><span id="c29e" class="lg ka hh mm b fi mv ms l mt mu">    .then(([detections]) =&gt; {<br/>      const annotation = detections.textAnnotations[0];<br/>      text = annotation ? annotation.description : '';<br/>      return <strong class="mm hi">translate.detect(text);</strong><br/>    })</span><span id="d57d" class="lg ka hh mm b fi mv ms l mt mu">    .then(([detection]) =&gt; {<br/>      if (Array.isArray(detection)) {<br/>        detection = detection[0];<br/>      }<br/><br/>      // Submit a message to the bus for each language <br/>      // we're going to translate to</span><span id="1bed" class="lg ka hh mm b fi mv ms l mt mu">      <strong class="mm hi">const tasks = config.TO_LANG.map(lang =&gt; {<br/>        let topicName = config.TRANSLATE_TOPIC;<br/>        if (detection.language === lang) {<br/>          topicName = config.RESULT_TOPIC;<br/>        }<br/>        const messageData = {<br/>          text: text,<br/>          filename: filename,<br/>          lang: lang,<br/>          from: detection.language<br/>        };<br/><br/>        return publishResult(topicName, messageData);<br/>      });<br/><br/>      </strong>return Promise.all(tasks);<br/>    });<br/>}</span></pre><p id="594d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们解释一下我们添加的新的额外代码:</p><p id="69e5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们首先添加了对Google翻译API的调用，以便检测提取文本的主要语言<code class="du mj mk ml mm b">translate.detect(text);</code>。然后，在下一个块中，我们基本上迭代配置文件中的<code class="du mj mk ml mm b">config.TO_LANG</code>数组，并发布一个具有特定有效负载的<code class="du mj mk ml mm b">TRANSLATE_TOPIC</code>，该有效负载包含文本内容(<code class="du mj mk ml mm b">text</code>)、源语言(<code class="du mj mk ml mm b">from</code>)和我们想要翻译到的目标语言(<code class="du mj mk ml mm b">lang</code>)。如果源语言和目标语言相同，我们就发布<code class="du mj mk ml mm b">RESULT_TOPIC</code>。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h2 id="154c" class="lg ka hh bd kb lh li lj kf lk ll lm kj je ln lo kn ji lp lq kr jm lr ls kv lt bi translated">关于谷歌云发布/订阅的补充说明</h2><p id="8c71" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">为了方便起见，我们还包含了一个新的实用函数<code class="du mj mk ml mm b">publishResult</code>，它负责发布一个发布/订阅主题。它基本上使用Google Cloud发布/订阅API来创建(如果需要)和发布给定的主题:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="bb94" class="lg ka hh mm b fi mr ms l mt mu">const pubsub = require('@google-cloud/pubsub')();</span><span id="6c06" class="lg ka hh mm b fi mv ms l mt mu">/**<br/> * Publishes the result to the given pub-sub topic.<br/> *<br/> * @param {string} topicName Name of the topic on which to publish.<br/> * @param {object} data The message data to publish.<br/> */<br/>function <strong class="mm hi">publishResult</strong>(topicName, data) {<br/>  return pubsub<br/>    .topic(topicName)<br/>    .get({ autoCreate: true })<br/>    .then(([topic]) =&gt; topic.publish(data));<br/>}</span></pre></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="6efe" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然后让我们创建<code class="du mj mk ml mm b">translateText</code>云函数来翻译提取的文本:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="7b0d" class="lg ka hh mm b fi mr ms l mt mu">const translate = require('@google-cloud/translate')();<br/>const Buffer = require('safe-buffer').Buffer;<br/>const config = require('./config.json');</span><span id="c6d1" class="lg ka hh mm b fi mv ms l mt mu">/**<br/> * Translates text using the Google Translate API. <br/> * Triggered from a message on a Pub/Sub topic.<br/> *<br/> * @param {object} event The Cloud Functions event.<br/> * @param {object} event.data The Cloud Pub/Sub Message object.<br/> * @param {string} event.data.data The "data" property of <br/> *    the Cloud Pub/Sub Message. <br/> *    This property will be a base64-encoded string that <br/> *    you must decode.<br/> */<br/>exports.<strong class="mm hi">translateText</strong> = function translateText(event) {<br/>  const pubsubMessage = event.data;<br/>  const jsonString = Buffer.from(<br/>                       pubsubMessage.data, 'base64'<br/>                     ).toString();<br/>  const payload = JSON.parse(jsonString);<br/><br/>  return Promise.resolve()<br/>    .then(() =&gt; {<br/><br/>      const options = {<br/>        from: payload.from,<br/>        to: payload.lang<br/>      };<br/><br/>      return <strong class="mm hi">translate.translate(payload.text, options);</strong><br/>    })<br/>    .then(([translation]) =&gt; {<br/>      const messageData = {<br/>        text: translation,<br/>        filename: payload.filename,<br/>        lang: payload.lang<br/>      };<br/><br/>      return <strong class="mm hi">publishResult(config.RESULT_TOPIC, messageData);</strong><br/>    });<br/>};</span></pre><p id="7e30" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这个函数的实现是不言自明的:我们基本上调用<code class="du mj mk ml mm b">translation.translate(payload.text, options);</code>，一旦我们得到结果，我们就发布带有翻译内容的<code class="du mj mk ml mm b">RESULT_TOPIC</code>。</p><p id="80e5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在是时候使用与之前相同的命令部署<code class="du mj mk ml mm b">translateText</code>云功能了。该函数将由<code class="du mj mk ml mm b">TRANSLATE_TOPIC</code>主题触发，因此我们确保将其用作触发类型:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="d15d" class="lg ka hh mm b fi mr ms l mt mu">gcloud beta functions <br/>   deploy ocr-translate<br/>   --source https://source.developers.google.com/projects/...<br/>   --trigger-topic TRANSLATE_TOPIC<br/>   --entry-point translateText</span></pre><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nd"><img src="../Images/b9638ce5abe32708a54ada27cccebe99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGbjXR3ISlSYpKqWra1uZQ.png"/></div></div></figure><h2 id="e777" class="lg ka hh bd kb lh li lj kf lk ll lm kj je ln lo kn ji lp lq kr jm lr ls kv lt bi translated">保存翻译的文本</h2><p id="9caf" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">到目前为止一切顺利，我们现在已经成功捕捉到图像，上传到GCS，处理它，提取文本，然后翻译它。最后一步是将翻译后的文本保存回GCS。</p><p id="3c81" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">下面是该函数的实现:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="66f1" class="lg ka hh mm b fi mr ms l mt mu">const storage = require('@google-cloud/storage')();<br/>const Buffer = require('safe-buffer').Buffer;<br/>const config = require('./config.json');</span><span id="5de6" class="lg ka hh mm b fi mv ms l mt mu">/**<br/> * Saves the data packet to a file in GCS. <br/> * Triggered from a message on a Pub/Sub topic.<br/> *<br/> * @param {object} event The Cloud Functions event.<br/> * @param {object} event.data The Cloud Pub/Sub Message object.<br/> * @param {string} event.data.data The "data" property of <br/> *    the Cloud Pub/Sub Message. <br/> *    This property will be a base64-encoded string that <br/> *    you must decode.<br/> */<br/>exports.<strong class="mm hi">saveResult</strong> = function saveResult(event) {<br/>  const pubsubMessage = event.data;<br/>  const jsonString = Buffer.from(<br/>                       pubsubMessage.data, 'base64'<br/>                     ).toString();<br/>  const payload = JSON.parse(jsonString);<br/><br/>  return Promise.resolve()<br/>    .then(() =&gt; {<br/>      const bucketName = config.RESULT_BUCKET;</span><span id="7461" class="lg ka hh mm b fi mv ms l mt mu">     // Appends a .txt suffix to the image name. <br/>     const filename = renameFile(payload.filename, payload.lang);<br/>      <br/>      <strong class="mm hi">const file = storage.bucket(bucketName).file(filename);</strong><br/><br/>      <strong class="mm hi">return file.save(payload.text)<br/>        .then(_ =&gt; publishResult(config.READ_TOPIC, payload));</strong><br/>    });<br/>};</span></pre><p id="5bd3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du mj mk ml mm b">saveResult</code>由保存翻译文本的主题<code class="du mj mk ml mm b">RESULT_TOPIC</code>触发。我们简单地使用该有效负载并调用Google云存储API来将内容存储在一个名为<code class="du mj mk ml mm b">config.RESULT_BUCKET</code>(也就是<code class="du mj mk ml mm b">cloud-functions-orc-demo</code>)的桶中。一旦完成，我们发布的<code class="du mj mk ml mm b">READ_TOPIC</code>主题将触发下一个云功能(见下一节)。</p><p id="b6a9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">是时候使用与之前相同的命令部署<code class="du mj mk ml mm b">saveResult</code>云功能了。该函数将由<code class="du mj mk ml mm b">TRANSLATE_TOPIC</code>主题触发，因此我们确保将其用作触发类型:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="d736" class="lg ka hh mm b fi mr ms l mt mu">gcloud beta functions <br/>   deploy ocr-save<br/>   --source https://source.developers.google.com/projects/...<br/>   --trigger-topic <!-- -->RESULT_TOPIC<br/>   --entry-point saveResult</span></pre><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nd"><img src="../Images/a64ca13841279e47bb1f0a88c5ec99a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*83OUW7vmVX-k7J9NTi1_Ow.png"/></div></div></figure><h1 id="48f4" class="jz ka hh bd kb kc ne ke kf kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw bi translated">3-发送短信通知</h1><p id="f460" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">最后，我们现在准备从GCS中读取翻译后的文本，并通过SMS将其发送到用户的手机上。</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/2bf0d385b5052f82b2d2771ba6657891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*InQkeVtPnpnLj1EJMEHmxA.png"/></div></div></figure><h2 id="5f72" class="lg ka hh bd kb lh li lj kf lk ll lm kj je ln lo kn ji lp lq kr jm lr ls kv lt bi translated">从GCS中阅读翻译文本</h2><p id="d588" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">从GCS中读取文件也是一个简单的操作:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="8c40" class="lg ka hh mm b fi mr ms l mt mu">const Buffer = require('safe-buffer').Buffer;</span><span id="45d0" class="lg ka hh mm b fi mv ms l mt mu">/**<br/> * Reads the data packet from a file in GCS. <br/> * Triggered from a message on a Pub/Sub topic.<br/> *<br/> * @param {object} event The Cloud Functions event.<br/> * @param {object} event.data The Cloud Pub/Sub Message object.<br/> * @param {string} event.data.data The "data" property of <br/> *    the Cloud Pub/Sub Message. <br/> *    This property will be a base64-encoded string that <br/> *    you must decode.<br/> */<br/>exports.<strong class="mm hi">readResult</strong> = function readResult(event) {<br/>  const pubsubMessage = event.data;<br/>  const jsonString = Buffer.from(<br/>                       pubsubMessage.data, 'base64'<br/>                     ).toString();<br/>  const payload = JSON.parse(jsonString);</span><span id="3ee0" class="lg ka hh mm b fi mv ms l mt mu">  return Promise.resolve()<br/>    .then(() =&gt; <strong class="mm hi">readFromBucket(payload)</strong>)<br/>    .then(content =&gt; <strong class="mm hi">sendSMS(content)</strong>.then(_ =&gt; <strong class="mm hi">call(content)</strong>));<br/>};</span></pre><p id="eff9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在<code class="du mj mk ml mm b">readResult</code>函数中，我们使用了另一个实用函数<code class="du mj mk ml mm b">readFromBucket</code>，顾名思义，它从给定的GCS桶中读取内容。下面是详细的实现:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="0f20" class="lg ka hh mm b fi mr ms l mt mu">const storage = require('@google-cloud/storage')();<br/>const config = require('./config.json');</span><span id="2cdf" class="lg ka hh mm b fi mv ms l mt mu">/**<br/> * Reads the data packet from a file in GCS. <br/> * Triggered from a message on a Pub/Sub topic.<br/> *<br/> * @param {object} payload The GCS payload metadata.<br/> * @param {object} payload.filename The filename to read.<br/> */<br/>function <strong class="mm hi">readFromBucket</strong>(payload) {</span><span id="a16c" class="lg ka hh mm b fi mv ms l mt mu">  // Appends a .txt suffix to the image name.<br/>  const filename = renameFile(payload.filename, payload.lang);</span><span id="ddfa" class="lg ka hh mm b fi mv ms l mt mu">  const bucketName = config.RESULT_BUCKET;<br/><strong class="mm hi">  const file = storage.bucket(bucketName).file(filename);<br/></strong>  const chunks = [];<br/><br/>  return new Promise((res, rej) =&gt; {<br/>    file<br/>      .createReadStream()<br/>      .on('data', chunck =&gt; {<br/>        chunks.push(chunck);<br/>      })<br/>      .on('error', err =&gt; {<br/>        rej(err);<br/>      })<br/>      .on('response', response =&gt; {<br/>        // Server connected and responded with <br/>        // the specified status and headers.<br/>      })<br/>      .on('end', () =&gt; {<br/>        // The file is fully downloaded.<br/>        res(chunks.join(''));<br/>      });<br/>  });<br/>}</span></pre><p id="18d5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">就这么简单。现在，让我们部署<code class="du mj mk ml mm b">readResult</code>云函数，并使其从<code class="du mj mk ml mm b">READ_TOPIC</code>主题触发:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="67ec" class="lg ka hh mm b fi mr ms l mt mu">gcloud beta functions <br/>   deploy ocr-read<br/>   --source https://source.developers.google.com/projects/...<br/>   --trigger-topic READ_TOPIC<br/>   --entry-point readResult</span></pre><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nd"><img src="../Images/5ef82bd69efe7cc35b1dcac2ad5a75a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5PcVVletYsz9mhBAg0zRig.png"/></div></div></figure><p id="8cff" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> b-发送短信通知</strong></p><p id="7b01" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">说到给用户的手机发送短信，我们使用的是很棒的Twilio服务，它……很好用！</p><blockquote class="mw mx my"><p id="e20d" class="it iu mz iv b iw ix iy iz ja jb jc jd na jf jg jh nb jj jk jl nc jn jo jp jq ha bi translated">使用Twilio服务需要您创建一个开发者帐户。</p></blockquote><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="18d7" class="lg ka hh mm b fi mr ms l mt mu">const Twilio = require('twilio');<br/>const TwilioClient = new Twilio(<br/>   config.TWILIO.accountSid,<br/>   config.TWILIO.authToken<br/>);</span><span id="1c1b" class="lg ka hh mm b fi mv ms l mt mu">/**<br/> * Sends an SMS using Twilio's service.<br/> *<br/> * @param {string} body The content to send via SMS.<br/> */<br/>function <strong class="mm hi">sendSMS</strong>(body) {<br/>  return TwilioClient.messages<br/>    .create({<br/>      to: '+33000000000',<br/>      from: '+33000000000',<br/>      body: body || 'MESSAGE NOT FOUND'<br/>    });<br/>}</span></pre><p id="94e9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">打电话(奖金)</strong></p><p id="70ea" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">通过电话将翻译的内容发送给用户有点棘手，因为您需要提供两个功能:</p><ol class=""><li id="7dbc" class="lu lv hh iv b iw ix ja jb je lw ji lx jm ly jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">call</code>哪个打电话:<strong class="iv hi">这实际上是打电话给用户！</strong></li><li id="07e4" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">twilioCalls</code>它是HTTP端点，将处理由<code class="du mj mk ml mm b">call</code>函数发出的传入调用。</li></ol><p id="60b0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为了演示这个过程是如何工作的，让我们先来看看<code class="du mj mk ml mm b">twilioCalls</code>的实现:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="a623" class="lg ka hh mm b fi mr ms l mt mu">const Twilio = require('twilio');<br/>const VoiceResponse = Twilio.twiml.VoiceResponse;</span><span id="910b" class="lg ka hh mm b fi mv ms l mt mu">/**<br/> * Handles the incoming Twilio call request. <br/> * Triggered from an HTTP call.<br/> *<br/> * @param {object} request Express.js request object.<br/> * @param {object} response Express.js response object.<br/> */<br/>module.exports.<strong class="mm hi">twilioCall</strong> = function(request, response) {<br/>  return readFromBucket({<br/>    filename: 'twilio_user_33000000000.txt'<br/>  }).then(content =&gt; {<br/>    const twiml = new VoiceResponse();<br/>    twiml.say(`<br/>    &lt;Say voice="woman"&gt;Hi, this is your extracted text:&lt;/Say&gt;<br/>    &lt;Pause length="1"&gt;&lt;/Pause&gt;<br/>    &lt;Say voice="woman"&gt;${content}&lt;/Say&gt;<br/>    `);<br/>    res.writeHead(200, { 'Content-Type': 'text/xml' });<br/>    res.end(twiml.toString());<br/>  });<br/>};</span></pre><p id="8527" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du mj mk ml mm b">twilioCall</code>函数负责从bucket中读取文件，并发送回一个XML响应，这要归功于Twilio标记语言(<a class="ae jr" href="https://www.twilio.com/docs/api/twiml" rel="noopener ugc nofollow" target="_blank"> TwilioML </a>)。</p><p id="cd6c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然后，您需要部署这个云函数，以便获得<code class="du mj mk ml mm b">call</code>函数所需的公共URL:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="079a" class="lg ka hh mm b fi mr ms l mt mu">gcloud beta functions <br/>   deploy ocr-twilio-call<br/>   --source https://source.developers.google.com/projects/...<br/>   --trigger-http<br/>   --entry-point twilioCall</span></pre><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nd"><img src="../Images/355ac360230bf93b216dfc939550e948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Kiz4bO-iydakdZS6tP-3Q.png"/></div></div></figure><p id="f6cf" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">部署后，您将获得一个如下所示的公共URL:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="4ecc" class="lg ka hh mm b fi mr ms l mt mu">https://us-central1-&lt;projet-id&gt;.cloudfunctions.net/ocr-twilio-call</span></pre><p id="819a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">接下来，我们将在<code class="du mj mk ml mm b">call</code>函数中使用这个URL:</p><pre class="lc ld le lf fd mn mm mo mp aw mq bi"><span id="3b22" class="lg ka hh mm b fi mr ms l mt mu">/**<br/> * Triggers a call using Twilio's service.<br/> */<br/>function call() {<br/>  return TwilioClient.api.calls<br/>    .create({<br/>      url: 'https://the-url-from-above/ocr-twilio-call',<br/>      to: '+33000000000',<br/>      from: '+33000000000'<br/>    });<br/>}</span></pre><p id="b145" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">搞定了。现在，您的Twilio HTTP端点已经为传入呼叫做好了准备。</p><h1 id="a7f0" class="jz ka hh bd kb kc ne ke kf kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw bi translated">结束了！</h1><p id="8f21" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">在本指南中，我们实现了一系列执行不同任务的云功能:</p><ol class=""><li id="b38c" class="lu lv hh iv b iw ix ja jb je lw ji lx jm ly jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">assistant</code>处理来自DialogFlow的代理请求。</li><li id="0d4d" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">processImage</code>从上传的图像中提取文本。</li><li id="647c" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">translateText</code>将提取的文本翻译成不同的语言。</li><li id="121d" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">saveResult</code>将翻译后的文本保存到GCS。</li><li id="ae58" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">readResult</code>从存储在GCS中的文件中读取翻译文本。</li><li id="d128" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><code class="du mj mk ml mm b">twilioCall</code>处理来电请求。</li></ol><p id="9886" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">以下是所有已部署的云功能的概述:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nj"><img src="../Images/eac3fe77d3f96b236a85330959eb9aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RdEKhFOkxmP21Wf66bqfGA.png"/></div></div></figure><p id="4cdd" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是完整的架构:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/393e79db84a31baac4bd1e202e966e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X7b6gJCWoxHOlApPaI82Rw.png"/></div></div></figure><h2 id="d8d5" class="lg ka hh bd kb lh li lj kf lk ll lm kj je ln lo kn ji lp lq kr jm lr ls kv lt bi translated">尝试一下</h2><p id="b2d6" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">为了测试应用程序，我们首先需要部署DialogFlow代理。我们选择在Google Assistant上部署它，因为我们的<code class="du mj mk ml mm b">assistant</code>云功能是为了处理Google Assistant的请求。如果你想部署到其他服务(Slack、脸书、Twitter等)，你只需要提供和部署其他云功能。</p><p id="c601" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">从集成选项卡中，选择Google Assistant并单击<strong class="iv hi">测试</strong>按钮:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/6e7720bf91a1d2337d3bdf0209b8055e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tq75vxc89-8Cdzc1Ua9N9g.png"/></div></div></figure><p id="d87d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这将打开Google simulator上的操作，允许您直接在bowser中测试您的代理。或者，您也可以使用手机或Google Home设备:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nk"><img src="../Images/a1439eca40079d3bf950a17e92c68659.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akk4Ia5h5dCLLIWn674ssA.png"/></div></div></figure><blockquote class="mw mx my"><p id="2652" class="it iu mz iv b iw ix iy iz ja jb jc jd na jf jg jh nb jj jk jl nc jn jo jp jq ha bi translated">注意，我们给我们的代理起了一个名字:莎士比亚。我们在同一个模拟器的总览面板中完成了这项工作。</p></blockquote><p id="217f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">作为示例文本，我们将使用以下引文(出自<a class="ae jr" href="https://twitter.com/blackhawkinc" rel="noopener ugc nofollow" target="_blank"> Ziad K. Abdelnour </a>):</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nl"><img src="../Images/09ef7d08541f895958e7055ae2de3e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTuoYNZGN-pC4XiCzohJoA.png"/></div></div></figure><p id="3900" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是我们的<code class="du mj mk ml mm b">readResult</code>函数发送的短信:</p><figure class="lc ld le lf fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nm"><img src="../Images/d31a2334244bee96df1546087842e488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIk1o1zNzRPcHY_p1gUrPg.png"/></div></div></figure><h1 id="dfe8" class="jz ka hh bd kb kc ne ke kf kg nf ki kj kk ng km kn ko nh kq kr ks ni ku kv kw bi translated">⚠️重要笔记⚠️</h1><ol class=""><li id="d03d" class="lu lv hh iv b iw kx ja ky je nn ji no jm np jq lz ma mb mc bi translated">在我的示例代码中，我没有处理任何错误。<strong class="iv hi">应该的！</strong></li><li id="2440" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated">在我的示例代码中，我没有记录任何内容。<strong class="iv hi">应该的！</strong></li><li id="7c89" class="lu lv hh iv b iw md ja me je mf ji mg jm mh jq lz ma mb mc bi translated"><strong class="iv hi">在我的样本代码中，我没有编写单元测试。你应该！</strong></li></ol><p id="1ce2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">以下是完整的源代码:</p><div class="nq nr ez fb ns nt"><a href="https://github.com/manekinekko/serverless-application-demo" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab dw"><div class="nv ab nw cl cj nx"><h2 class="bd hi fi z dy ny ea eb nz ed ef hg bi translated">manekinekko/无服务器应用程序演示</h2><div class="oa l"><h3 class="bd b fi z dy ny ea eb nz ed ef dx translated">在GitHub上创建一个帐户，为无服务器应用程序演示开发做贡献。</h3></div><div class="ob l"><p class="bd b fp z dy ny ea eb nz ed ef dx translated">github.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh in nt"/></div></div></a></div></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h2 id="cb01" class="lg ka hh bd kb lh li lj kf lk ll lm kj je ln lo kn ji lp lq kr jm lr ls kv lt bi translated">恭喜你！您刚刚构建了第一个真正的“无服务器”应用程序！还有，2018新年快乐🎉✨🎁</h2></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="c6c8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="mz">在Twitter上关注我</em><a class="ae jr" href="https://twitter.com/manekinekko" rel="noopener ugc nofollow" target="_blank"><em class="mz">@ manekinekko</em></a><em class="mz">了解更多关于网络和云平台的信息。</em></p></div></div>    
</body>
</html>