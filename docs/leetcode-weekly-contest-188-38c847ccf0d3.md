# Leetcode 每周竞赛 188 —解决方案

> 原文：<https://medium.com/quick-code/leetcode-weekly-contest-188-38c847ccf0d3?source=collection_archive---------0----------------------->

![](img/c66ed56895420ad1f15ac845b01a84cd.png)

这个星期我排名第 194，大约 55 分钟的比赛 188。我大三的最后一个学期即将结束，所以我可能会更频繁地为每个 Leetcode 竞赛创建每周解决方案。

这次比赛的特色是一些有趣的问题，包括一个数学问题，一个树的问题，和一个困难的(显然是来自日本的谷歌面试？对于谷歌问题来说，DP 问题出奇的难。我将为前 3 个简单的问题做一个中等水平的指导(假设对 Leetcode 风格或竞争性编程风格有中等水平的了解),并真正带您完成大多数人未能解决的最后一个难题。

# 问题 A: 1441。用堆栈操作构建数组(简单)

# **问题:**

[https://leet code . com/contest/weekly-contest-188/problems/build-a-array-with-stack-operations/](https://leetcode.com/contest/weekly-contest-188/problems/build-an-array-with-stack-operations/)

给定一个数组`target`和一个整数`n`。在每一次迭代中，你都会读到一个来自`list = {1,2,3..., n}`的数字。
使用以下操作构建`target`数组:
**Push** :从头`list`读取一个新元素，并将其推入数组。
**Pop** :删除数组的最后一个元素
如果目标数组已经建立，停止读取更多的元素。
保证目标数组严格递增，只包含 1 到`n`之间的数字。
**返回**构建目标阵列的操作。向您保证答案是唯一的。

# **解决方案:**

**蛮力 O(N)时间+空间:** 假设给我们一个以数字 j 结尾的目标数组，我们先把目标数组数字扔进一个集合，从数字 1，2，3…j 开始迭代，对于 1 到 j 中每一个不在集合中的数字 I，我们就写 push + pop。否则，写 push。

# 问题 B: 1442。计数可以形成两个相等 XOR 数组的三元组(中)

# **问题:**

[https://leet code . com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-array-of-equal-xor/](https://leetcode.com/contest/weekly-contest-188/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/)

给定一个整数数组`arr`。
我们要选择三个指标`i`、`j`和`k`，其中`(0 <= i < j <= k < arr.length)`。
让我们将`a`和`b`定义如下:

*   `a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]`
*   `b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]`

注意， **^** 表示**逐位异或**运算。
**返回** *三胞胎数* ( `i`、`j`、`k`)其中`a == b`。

# **解决方案:**

**前缀蛮力 O(N)时间+ O(1)空间:** 在比赛中，看输入大小总是很重要的。通常，如果输入大小在一百或一千的量级，那么一个蛮力或稍微优化的蛮力就足以被接受。我采用的解决方案是简单地对每一对 I、j、k 进行强力运算，并检查 I 和 j-1 之间的异或以及 j 和 k 之间的异或是否相等。我们需要跟踪前缀 XOR，使其成为 O(N)而不是 O(N⁴).否则，你将会超时。

**优化解:O(N)时间+ O(N)空间:**

我们可以用不同的方式来看待这个问题。请注意，该问题要求子数组[i，j-1]和子数组[j，k]相等。两个异或相等意味着如果你对这两个异或，你得到 0。实际上，这个问题的另一种观点是，我们寻找一个子数组[i，k],使得该子数组的 XOR 为 0。一旦我们这样做了，我们就可以数一数我们可以把子数组[i，k]分成多少个 j(这只是 k-i-1，因为它的长度是-1)。如果你在想，在 I，k 之间拆分任意 j，是否还会保持 I 和 j-1 之间的 XOR 和 j 和 k 之间的 XOR 相等的条件，那么放心，它们永远是相等的。你可以自己尝试一下！

让我们现在构建解决方案。我们可以先在 O(N)时间内建立前缀异或数组。然后，我们将使用这个前缀异或数组，并在 O(N)时间内检查每对前缀值，以查看是否有任何两个值相等。如果是，那么在 O(1)时间内计算其中的 j。

**最佳优化解:O(N)时间+ O(N)空间:** 如果你知道/听说过哈希，那么你大概就能算出这个。看一下子阵列和等于 k 的问题。它本质上是这里使用的相同技术。我们只是保存了一个前缀 XOR 的 hashmap，但是这次我们还需要一个对应的事件总数的 hashmap。这涉及到一些数学知识，但您可以查看详细信息:[https://leet code . com/problems/count-triplets-than-can-form-two-arrays-of-equal-xor/discuse/623747/JavaC % 2B % 2b python-One-Pass-O(N4)-to-O(N)](https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/discuss/623747/JavaC%2B%2BPython-One-Pass-O(N4)-to-O(N))

# 问题 C: 1443。收集树上所有苹果的最短时间(中等)

# 问题

[https://leet code . com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apple-in-a-tree/](https://leetcode.com/contest/weekly-contest-188/problems/minimum-time-to-collect-all-apples-in-a-tree/)

给定一棵由从 0 到 T1 的`n`个顶点组成的无向树，树的顶点中有一些苹果。你花 1 秒钟走过树的一边。*返回从* ***顶点 0*** *开始收集树上所有苹果并返回该顶点所需的最短时间(秒)。*

数组`edges`中给出了无向树的边，其中`edges[i] = [fromi, toi]`表示存在一条连接顶点`fromi`和`toi`的边。此外，还有一个布尔数组`hasApple`，其中`hasApple[i] = true`表示顶点`i`有一个苹果，否则它没有任何苹果。

# **解决方案:**

**2 DFS — O(N)时间+ O(N)空间** 我的解法很直观。请注意，我们需要访问一个节点，当且仅当该节点中有一个苹果，或者其后代中有一个苹果。这意味着我们需要一些没有给出的额外信息:节点的后代中是否有苹果。我们可以将这些数据存储在一个名为 hasDescendantApples[]的数组中。我们将使用自底向上的 DFS 在 O(N)空间和时间中获得这些信息。本质上，我们将首先向下递归到叶子，然后我们的工作将是检查孩子的 hasDesendantApples 是否为真，或者孩子本身是一个苹果。一旦我们有了这些信息，那么问题本身就简单了。让我们创建一个函数 DFS，它将返回从当前节点获取所有苹果需要多少秒。我们将递归地使用这个函数。我们将从根开始 DFS，按以下方式递归:如果当前节点的 hasDescentApples 为 false，则返回 0。否则，我们将递归到左节点和右节点，如果它们中的任何一个是苹果或者它们中的任何一个有后代苹果。我们将递归地添加 DFS(子节点)，其中 2 来自于到那个节点并返回到当前节点。

# 问题 D: 1444。切比萨饼的方法数量(硬)

# 问题

给定一个矩形披萨，表示为包含以下字符的`rows x cols`矩阵:`'A'`(一个苹果)和`'.'`(空单元格)，并给定整数`k`。你必须用`k-1`刀把披萨切成`k`块。

对于每一次切割，您选择方向:垂直或水平，然后选择单元格边界处的切割位置，将比萨饼切成两片。如果你垂直切比萨饼，把比萨饼的左边部分给一个人。如果你横着切披萨，把披萨的上半部分给一个人。把最后一块披萨给最后一个人。

*返回切披萨的方式数，使每一块包含* ***至少*** *个苹果。*由于答案可以是一个很大的数字，返回这个模 10⁹ + 7。

# 解决办法

**DFS +记忆化(更简单的动态编程)——**

这个问题求 DFS +内存化/ DP。如果你不熟悉或不擅长 DP，那你来对地方了。我将一步一步地解释如何在所有面试和大多数比赛中得出最优解并解决任何 DP 问题。让我们开始吧:

蛮力——回溯/DFS: (TLE): O(K*M^N) 在任何类似这样的问题中，当我们被要求最小化/最大化某个数字时，我的第一直觉是首先编写一个蛮力解决方案。当然，暴力解决方案会超过时间限制(TLE ),但这是最佳解决方案的垫脚石。
我们可以用下面的方式蛮力:

**陈述**:首先，我们需要一种方式来表示我们当前的进展。在这种情况下，这就是我们正在处理的比萨饼的大小。由于比萨饼是一个矩形，我们将用左上角点和右下角点来表示当前的比萨饼切片。这是编程中用两点表示矩形的常用技巧。我们还需要记录我们削减的次数。

**尝试可能的动作:**根据问题，我们可能的动作是水平和垂直分割披萨。因此，我们将这样做。我们会用许多不同的方法来分割比萨饼，并在这些比萨饼切片上递归。对于水平切割，这将简单地遍历每一行，并通过在一个较小的行上重复来“切割比萨饼”。类似于垂直，但有柱。我们也

**基本情况:**如果我们切 k-1 次，那么我们知道我们完成了。我们只需要 k 个切片，所以切割 k-1 次意味着我们划分了正确的次数。

**将所有这些放在一起:**我们从调用整个比萨饼开始，即从(0，0)到(m-1，n-1)，cut = 0。然后，我们迭代每个可能的切割，并递归这些新的比萨饼切片。我们需要跟踪的一件事是，每个切口必须包含一个苹果。要在 O(1)时间内确定一个矩形是否有一个苹果，我们可以使用另一个 DP 表。如果不使用 DP，时间复杂度会增加 O(MN)，所以需要实现这个简单的表。这被称为不可变的 2D 查询，你可以在这里查看:[https://leetcode.com/problems/range-sum-query-2d-immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/)/
一旦我们到达我们的基本情况，即我们已经进行了 k-1 次切割，我们需要检查这个矩形切片上是否有一个苹果。如果是的话，我们给全局返回变量加 1。如果没有，那么就返回并在这里完成递归分支。

**接受:O(MNK) —带记忆的 DFS:**

首先，我们需要做一些聪明的事情。注意我们的蛮力是如何跟踪状态的 5 个变量的。左上角的点，由两个变量行和列组成，右下角的点，也是另外两个变量，第五个变量，我们进行的切割次数。我们可以减少变量的数量来保持状态，通过注意到问题说，对于我们进行的每一次切割，当我们垂直切割时，我们保持右半部分，或者当我们水平切割时，保持下半部分。这意味着我们的比萨饼切片将始终包含点(m-1，n-1)，即比萨饼的右下部分。因此，没有必要再跟踪右下角的点，因为它总是(m-1，n-1)。因此，我们的新状态是左上角的点和切割数。

现在，我们只需要将我们的 DFS 暴力转化为记忆。这是通过保存每个递归调用的值，并在最后返回这些递归调用的总和来实现的。我们还需要将它存储在一个全局 DP 表中，以缓存调用。在每次递归调用的开始，我们首先检查这个状态以前是否已经解决过。如果它已经被归还了。搞定了。你刚刚解决了问题！

# 接触

如有任何问题或代码，请发电子邮件至**samatbryan@berkeley.edu**联系我！一定要给这个帖子竖起大拇指，并对未来的上传给予反馈！