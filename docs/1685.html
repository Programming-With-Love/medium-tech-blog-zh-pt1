<html>
<head>
<title>Treating Your Terraform like an Application: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像对待应用程序一样对待地形:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/treating-your-terraform-like-an-application-how-to-dockerize-terraform-5d7edac741fc?source=collection_archive---------0-----------------------#2019-05-29">https://medium.com/capital-one-tech/treating-your-terraform-like-an-application-how-to-dockerize-terraform-5d7edac741fc?source=collection_archive---------0-----------------------#2019-05-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="3443" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">如何对接Terraform</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/55bfc15a3d6df37c26576666b167fe9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UKweGFJuhNuQKG6I"/></div></div></figure><blockquote class="ji"><p id="7c65" class="jj jk hh bd jl jm jn jo jp jq jr js dx translated">关于在Docker中运行Terraform的两部分系列文章的第二部分</p></blockquote><blockquote class="ju jv jw"><p id="f4a1" class="jx jy jz ka b kb kc ii kd ke kf il kg kh ki kj kk kl km kn ko kp kq kr ks js ha bi translated"><em class="hh">注意:这篇文章涵盖了Terraform 11。Terraform 12改变了插件的工作方式，需要不同的命令和文件来构建Terraform容器。更多信息请看:</em>【https://www.terraform.io/upgrade-guides/0-12.html T4】</p></blockquote><p id="2527" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">转变团队的部署过程和文化的最基本的部分之一是从作为手动过程的基础设施到作为代码的基础设施(IaC)的转变。<a class="ae kt" rel="noopener" href="/capital-one-tech/treating-your-terraform-like-an-application-why-terraform-in-a-docker-container-31e802314b4">如本系列第1部分所述</a>，将Terraform放入Docker容器有助于缓解运行IaC带来的新问题，尤其是在像Jenkins这样的集中式构建服务器上。在这篇文章中，我们将讨论<strong class="ka hi"> <em class="jz">是如何做到的。</em>T11】</strong></p><p id="50f4" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated"><em class="jz">将Terraform放入Docker需要一些不同的步骤和背景。</em></p><h1 id="8f72" class="lc ld hh bd le lf lg lh li lj lk ll lm in ln io lo iq lp ir lq it lr iu ls lt bi translated">如何将Terraform放入容器</h1><p id="00a5" class="pw-post-body-paragraph jx jy hh ka b kb lu ii kd ke lv il kg kw lw kj kk ky lx kn ko la ly kr ks js ha bi translated">我在dockerizing Terraform中发现的两个最重要的原则是:</p><ul class=""><li id="80da" class="lz ma hh ka b kb ku ke kv kw mb ky mc la md js me mf mg mh bi translated">将构建基本docker映像的代码与构建Terraform docker映像的代码分开。</li><li id="a933" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js me mf mg mh bi translated">将应用Terraform的作业与构建Terraform的作业分开。</li></ul><p id="bd7c" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">因此，为了满足这些需求，让我们编写一个基本order文件，其中包含验证、计划和应用/销毁所需的所有部分。</p><p id="53ef" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated"><strong class="ka hi"> Dockerfile: </strong></p><pre class="ix iy iz ja fd mn mo mp mq aw mr bi"><span id="7cdc" class="ms ld hh mo b fi mt mu l mv mw"># build step to create a Terraform bundle per our included terraform-bundle.hcl<br/>FROM golang:alpine AS bundler<br/>RUN apk — no-cache add git unzip &amp;&amp; \<br/>    go get -d -v github.com/hashicorp/terraform &amp;&amp; \<br/>    git -C ./src/github.com/hashicorp/terraform checkout v0.11.11 &amp;&amp; \<br/>    go install ./src/github.com/hashicorp/terraform/tools/terraform-bundle</span><span id="5994" class="ms ld hh mo b fi mx mu l mv mw">COPY terraform-bundle.hcl .</span><span id="e30a" class="ms ld hh mo b fi mx mu l mv mw">RUN terraform-bundle package -os=linux -arch=amd64 terraform-bundle.hcl &amp;&amp; \<br/>        mkdir -p terraform-bundle &amp;&amp; \<br/>        unzip -d terraform-bundle terraform_*.zip</span></pre><p id="0847" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">这是我们文档的开始。让我们走过它的每一步。</p><ol class=""><li id="5034" class="lz ma hh ka b kb ku ke kv kw mb ky mc la md js my mf mg mh bi translated">它来自一个Golang容器。</li><li id="173a" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js my mf mg mh bi translated">它从Terraform添加检查，并安装Terraform。</li><li id="7844" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js my mf mg mh bi translated">它从一个HCL文件复制(HCL文件是一个配置，用于描述要运行的Terraform的提供者和版本)。我在这里提供了一个示例HCL文件。</li><li id="94a8" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js my mf mg mh bi translated">基于提供的HCL文件运行terraform-bundle包并下载。</li></ol><p id="52be" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">我们将在这里暂停一会儿，看看我们为什么以这种方式构建一个基本容器。将Terraform装入容器肯定有其他方法。然而，这种方法有四个优点:</p><ol class=""><li id="2d45" class="lz ma hh ka b kb ku ke kv kw mb ky mc la md js my mf mg mh bi translated"><strong class="ka hi">供应商是标准化的。</strong>与其他依赖项非常相似，维护提供者非常重要，拥有一个能够更新和推广的单一位置非常有用。如果一个团队或产品需要一个不同版本的提供者，可以通过修改这个基本容器来完成。</li><li id="6555" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js my mf mg mh bi translated"><strong class="ka hi">terra form版本是标准化的。</strong>这防止了不必要的版本冲突，因为Terraform中最令人恼火的消息之一是<code class="du mz na nb mo b">fail to read terraform_remote_state generated by tf&lt;new-version&gt; with tf&lt;old-version&gt;</code></li><li id="7a3c" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js my mf mg mh bi translated"><strong class="ka hi">它防止外部依赖项被多次拉入。</strong>你不必担心带宽，可以多次下载提供商。</li><li id="ebef" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js my mf mg mh bi translated"><strong class="ka hi">它使我们能够标准化Terraform的认证流程。</strong>这是一个我们将在稍后讨论的问题，但是拥有统一的身份验证方法可以实施最佳实践。</li></ol><p id="ba3f" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">现在，我们已经有了Terraform及其提供者的基本docker映像，我们现在可以专注于构建一个容器，它实际上获取并运行Terraform命令。</p><h1 id="f306" class="lc ld hh bd le lf lg lh li lj lk ll lm in ln io lo iq lp ir lq it lr iu ls lt bi translated">Terraform命令Docker图像</h1><p id="35d4" class="pw-post-body-paragraph jx jy hh ka b kb lu ii kd ke lv il kg kw lw kj kk ky lx kn ko la ly kr ks js ha bi translated">对于这个docker文件，我们有许多必须发生的阶段:</p><ol class=""><li id="8375" class="lz ma hh ka b kb ku ke kv kw mb ky mc la md js my mf mg mh bi translated">我们必须引入任何我们希望运行的Terraform代码。</li><li id="76df" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js my mf mg mh bi translated">我们必须传递一个ENV变量给Terraform。</li><li id="cd7c" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js my mf mg mh bi translated">Terraform必须能够自我认证。</li><li id="aedf" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js my mf mg mh bi translated">Terraform必须有存储状态文件的地方。</li></ol><p id="9f62" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">这些是按照重要性或你应该解决的问题的顺序排列的。然而，它们是按照我们将如何看待它们的<em class="jz">倒序</em>列出的。</p><p id="63a2" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated"><strong class="ka hi"> Terraform必须有存储状态文件的地方</strong></p><p id="d828" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated"><strong class="ka hi">首先，点#4。如果你打算使用Docker容器来运行你的IaC，我推荐使用远程状态。这使您不必担心卷，允许您防止多个操作同时发生，并允许您对反映实际状态的远程状态充满信心。</strong></p><p id="b6b4" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">如果您没有使用remote_state(我强烈建议您这样做)，您将需要挂载一个卷，编辑我们在本教程中使用的Terraform命令以写出一个状态文件，然后有一个单独的任务将该状态文件复制到您想要存储它的位置。<strong class="ka hi"> <em class="jz">注意—您不能将状态文件存储在Docker容器中。</em> </strong></p><p id="bfd1" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated"><strong class="ka hi"> Terraform必须能够自我认证</strong></p><p id="0efc" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated"><strong class="ka hi">第二，第三点。</strong>无论您是使用角色(如IAM)还是密钥来根据您的基础设施认证Terraform，使用单个基本容器都可以让您标准化认证方法。如果你使用访问密钥，那么你应该将它们加密存储在某个地方，并使用类似于<a class="ae kt" href="https://www.vaultproject.io" rel="noopener ugc nofollow" target="_blank"> Hashicorp Vault </a>的东西在运行时获取它们。如果您使用像IAM这样的角色，那么您需要一种方法将环境变量/元数据放入容器本身。这是通过两步过程完成的:</p><ol class=""><li id="c78c" class="lz ma hh ka b kb ku ke kv kw mb ky mc la md js my mf mg mh bi translated">通过给Docker容器提供运行Terraform的机器或从机的所有ENV变量。</li><li id="f8b9" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js my mf mg mh bi translated">通过使用这些ENV变量进行身份验证。对于AWS，在从EC2实例的ENV或运行Terraform的用户传入角色后，该步骤将使用类似AWS Assume的东西与STS对话并获取凭证。</li></ol><p id="2ad9" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated"><strong class="ka hi">将环境变量传递给地形</strong></p><p id="fa97" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">第三，第二点。这一步不仅包括用于身份验证的ENV变量，还包括Terraform init变量，以允许跨区域或帐户或变量文件的远程状态管理，这些变量可能会根据所部署的应用程序而变化。这里有一些提示:</p><ul class=""><li id="bb9d" class="lz ma hh ka b kb ku ke kv kw mb ky mc la md js me mf mg mh bi translated">使用预先构建的Terraform ENV变量，如TF_CLI_ARGS_INIT，这些变量可以在容器外部创建，然后传递运行时插入的SECRET_KEY_ID等值，尽管在构建时被告知存在。</li><li id="9d86" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js me mf mg mh bi translated">根据正在运行的命令分离出正在传递的内容，以便为验证、计划、应用和销毁传递正确的参数。</li><li id="2f2b" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js me mf mg mh bi translated">在运行init时set-get-plugins = false，这样您就不会试图从早期重新下载提供程序。</li></ul><p id="b00a" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated"><strong class="ka hi">通过要运行的平台</strong></p><p id="0ff6" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">最后，第一点。我建议将Terraform存储在正在部署的应用程序旁边，并将基础设施与应用程序部署分开。例如，如果您正在部署一个ECS集群，请将该ECS集群的所有Terraform和ALB放在一个存储库中，然后是ECS服务的Terraform，最后是ALB监听器和应用程序代码。这有两个好处:</p><ol class=""><li id="2e53" class="lz ma hh ka b kb ku ke kv kw mb ky mc la md js my mf mg mh bi translated">应用程序可以部署在任何地方，而不需要影响底层基础设施或担心它在哪里。使用Terraform数据调用来查找信息使得Terraform看起来像:</li></ol><pre class="ix iy iz ja fd mn mo mp mq aw mr bi"><span id="baac" class="ms ld hh mo b fi mt mu l mv mw">data “aws_ecs_cluster” “ecs-cluster” {<br/>   cluster_name = “${var.cluster}-cluster-${var.env}”<br/>}</span></pre><p id="b46c" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">现在，您已经消除了复杂性，并且不再需要手动更新正在部署的环境/群集。</p><p id="7fda" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">2.这允许您将您的应用程序Terraform与其代码一起版本化，允许该版本总是被部署，在功能上永远，只要数据查找被返回。</p><p id="3abb" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">我建议将Terraform代码复制到docker文件中，作为部署的一部分。这允许您构建一个包含Terraform代码的工件，该代码可以下载到任何系统并进行部署。如果您有需要，我建议您将Docker容器推送到Docker存储库中。这有助于更好的审计。这也使得自动化变得非常容易。</p><h1 id="c1d9" class="lc ld hh bd le lf lg lh li lj lk ll lm in ln io lo iq lp ir lq it lr iu ls lt bi translated">结论</h1><p id="2809" class="pw-post-body-paragraph jx jy hh ka b kb lu ii kd ke lv il kg kw lw kj kk ky lx kn ko la ly kr ks js ha bi translated">我们已经写了两个docker文件，一个显式的，一个隐式的。一个用于基本的Terraform容器，另一个用于Terraform的部署。不管您也正在部署提供者，或者您正在部署什么，在容器内标准化您的部署过程对于您的用例可能是有用的。它允许您对基础设施代码进行版本控制，从而方便回滚和审计。它还允许您确保基础架构可以从开发人员的笔记本电脑或CICD系统中部署。</p><p id="f86c" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated">这在大规模停机导致CICD系统宕机的情况下非常有用。如果这是真的，等待CICD系统恢复可能是不合理的，所以从任何地方部署都是有用的。它还允许您在一个位置管理所有的Terraform版本和提供者，同时仍然允许团队单独灵活地添加或升级。</p></div><div class="ab cl nc nd go ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ha hb hc hd he"><h2 id="f73b" class="ms ld hh bd le nj nk nl li nm nn no lm kw np nq lo ky nr ns lq la nt nu ls nv bi translated"><em class="jt">相关</em></h2><ul class=""><li id="1d81" class="lz ma hh ka b kb lu ke lv kw nw ky nx la ny js me mf mg mh bi translated"><a class="ae kt" rel="noopener" href="/capital-one-tech/building-feature-toggles-into-terraform-d75806217647">建筑特征切换成地形</a></li><li id="73f5" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js me mf mg mh bi translated"><a class="ae kt" rel="noopener" href="/capital-one-tech/deploying-multiple-environments-with-terraform-kubernetes-7b7f389e622">使用Terraform部署多个环境</a></li><li id="20ea" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js me mf mg mh bi translated"><a class="ae kt" rel="noopener" href="/capital-one-tech/multi-region-deployments-with-terraform-kubernetes-a1f51bb96974">采用地形的多区域部署</a></li><li id="8f3c" class="lz ma hh ka b kb mi ke mj kw mk ky ml la mm js me mf mg mh bi translated">像对待应用程序一样对待Terraform:第1部分——为什么要在Docker容器中使用Terraform？</li></ul></div><div class="ab cl nc nd go ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ha hb hc hd he"><p id="800e" class="pw-post-body-paragraph jx jy hh ka b kb ku ii kd ke kv il kg kw kx kj kk ky kz kn ko la lb kr ks js ha bi translated"><em class="jz">以上观点为作者个人观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2019首都一。</em></p></div></div>    
</body>
</html>