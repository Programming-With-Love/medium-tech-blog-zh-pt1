<html>
<head>
<title>Abstract class vs interface in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的抽象类vs接口</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/abstract-class-vs-interface-in-kotlin-5ab8697c3a14?source=collection_archive---------0-----------------------#2019-04-16">https://blog.kotlin-academy.com/abstract-class-vs-interface-in-kotlin-5ab8697c3a14?source=collection_archive---------0-----------------------#2019-04-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/ef30b74d484764c819a51337094961a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJHzUQ-qBYOGTg_7_Xqkeg.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Designed by katemangostar / Freepik</figcaption></figure><div class=""/><p id="9ec5" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">"抽象类和接口的区别是什么？"—这是程序员招聘过程中最常见的问题之一。流行的答案是:</p><ul class=""><li id="6204" class="kx ky jc kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">接口不能保持状态</li><li id="cc8d" class="kx ky jc kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">类可以有实际的功能</li><li id="ca76" class="kx ky jc kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们可以实现多个接口和一个类</li></ul><p id="b1b4" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我会证明那些答案不是真的。接口可以有属性，可以保存状态，但不能使用字段。只要它们不是最终的，它们就可以与实际的实体有函数关系。真正的抽象类和接口之间的显著区别是:</p><ul class=""><li id="b516" class="kx ky jc kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">接口不能有字段</li><li id="69f8" class="kx ky jc kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">我们只能扩展一个类，并实现多个接口</li><li id="3406" class="kx ky jc kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">类有构造函数</li></ul><p id="135f" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所以，让我们来谈谈神话:</p><h1 id="9a70" class="ll lm jc bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">接口可以有功能</h1><p id="0f12" class="pw-post-body-paragraph jz ka jc kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">在Kotlin中，接口可以包含带有默认主体的函数:</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e54b" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这些主体中，我们可以使用<code class="fe mu mv mw mx b">this</code>来引用类:</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="62d5" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这些函数不能是最终的，它们总是可以被覆盖。这是接口和抽象类之间的一个区别，在抽象类中我们可以使函数成为final。当我们覆盖这些函数时，我们仍然可以使用默认的body使用<code class="fe mu mv mw mx b">super</code>:</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="mo mp mq mr gt ip gh gi paragraph-image"><a href="https://kt.academy/workshop/automaticTestingForBeginners"><div class="gh gi my"><img src="../Images/3abcc7bf2c50c85e442eda42ef18d587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zMYtScxROfxxZWVgepGaug.png"/></div></a></figure><h1 id="441a" class="ll lm jc bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">接口可以有属性</h1><p id="1750" class="pw-post-body-paragraph jz ka jc kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">Kotlin中的Property表示getter ( <code class="fe mu mv mw mx b">val</code>)或getter和setter ( <code class="fe mu mv mw mx b">var</code>)的抽象。默认情况下，它们有在幕后使用的字段。这就是为什么这门课:</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c674" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">编译成类似如下的代码:</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="434a" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">虽然属性不需要在引擎盖下有字段。例如，在下面的代码中<code class="fe mu mv mw mx b">fullName</code>只是一个每次按需计算的getter:</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b8bf" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">属性只是访问器(getters和setters)，所以只要它们没有任何实际值，就可以出现在接口上:</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1dab" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这些属性也可以有默认几何体:</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="mo mp mq mr gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mz"><img src="../Images/b5e34cd436cce05da305b2e798ccdac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*toGe9O2OfUKjtvzD.png"/></div></div></figure><h1 id="f9a2" class="ll lm jc bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">接口形式上可以有状态</h1><p id="dc72" class="pw-post-body-paragraph jz ka jc kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">这有点像黑客，通常也是一种不好的做法，但我只是想说明在一个接口中保存状态是可能的。我们只需要使用默认体来存储它。我们能把它存放在哪里？有一些选择，没有一个是好的。垃圾收集者会对它们进行糟糕的管理和不恰当的清理。选择较小的邪恶，我决定将它存储在一个伴随对象属性中:</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cb1a" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请注意，这种在内存中存储的方式与我们使用字段时不同:</p><ul class=""><li id="5b43" class="kx ky jc kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">垃圾收集器没有正确管理它</li><li id="4abb" class="kx ky jc kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">属性与相等的类相关联，而不是与相同的类相关联(如果我们使用reference，这可以得到改进)</li></ul><p id="caa4" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb jd">这种解决方案是违反直觉的，除非您非常清楚自己在做什么以及会有什么后果，否则不应该在实际项目中使用！</strong>虽然知道这是可能的很好，而且它向我们展示了接口可以保存状态。这并不意味着当有人说他们不能纠正时，你应该纠正。要让他们正确地保持状态是困难和不直观的，所以我们通俗地说他们不能。让我们保持这种方式；)</p><figure class="mo mp mq mr gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi my"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h1 id="16e1" class="ll lm jc bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">差异</h1><p id="9491" class="pw-post-body-paragraph jz ka jc kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">抽象类可以拥有接口所拥有的一切，此外，它们还可以拥有字段和构造函数。因此，我们可以在抽象类中正确地保存状态:</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5a58" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">带有默认主体的函数和属性不仅可以是最终的，而且在默认情况下也是最终的。我们也可以有一个构造函数，因此将值传递给这个抽象类:</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="7d21" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当我们有一个主构造函数时，我们可以有<code class="fe mu mv mw mx b">init</code>个块:</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6aba" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">另一方面，当我们使用它们时，我们可以实现多个接口，只扩展一个类。我们总是需要调用超类的构造函数。</p><figure class="mo mp mq mr gt ip"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8fdc" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是接口相对于类的一个重要优势。在本文中，我展示了如何在称为特征或混合的模式中使用它:</p><div class="im in gp gr io na"><a rel="noopener  ugc nofollow" target="_blank" href="/inheritance-composition-delegation-and-traits-b11c64f11b27"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd jd gy z fp nf fr fs ng fu fw jb bi translated">继承、组成、授权和特征</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">共享公共行为是编程中最重要的事情之一。通过编程，我们代表知识…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no iu na"/></div></div></a></div></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><h2 id="5e37" class="nw lm jc bd ln nx ny dn lr nz oa dp lv kk ob oc lz ko od oe md ks of og mh oh bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h2><p id="be6c" class="pw-post-body-paragraph jz ka jc kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae oi" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae oi" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><p id="d9a9" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果您需要Kotlin工作室，请查看我们如何帮助您:<a class="ae oi" href="https://kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="mo mp mq mr gt ip gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi my"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>