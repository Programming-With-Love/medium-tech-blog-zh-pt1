<html>
<head>
<title>Exception Handling in Distributed Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式系统中的异常处理</h1>
<blockquote>原文：<a href="https://medium.com/mendix/exception-handling-in-distributed-systems-5a54efaeeea1?source=collection_archive---------3-----------------------#2021-12-03">https://medium.com/mendix/exception-handling-in-distributed-systems-5a54efaeeea1?source=collection_archive---------3-----------------------#2021-12-03</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/b925b7bce07f572abe3f0feb32d6bc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m-jM87-7-Ci2H6KZR_6aoA.png"/></div></div></figure><div class=""/><h1 id="459b" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">作为(Mendix)开发者，我们都经历过；与系统集成以处理数据或触发动作。通过使用Mendix平台，这变得比以往任何时候都容易。然而，在复杂的系统中，另一方可能变得不可用或不可预测，这可能很难处理。分布式系统很奇怪，因为问题可能以多种方式出现。</h1><p id="917f" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">现在，假设有三种主要类型的分布式系统。</p><ul class=""><li id="6e3c" class="kx ky if bd b kc kz kg la kk lb ko lc ks ld kw le lf lg lh dt translated">离线—主要用于批处理和数据分析。较少的用例，但最健壮的选项。高度可扩展和自我持续。更少的复杂和关键故障场景。</li><li id="78b9" class="kx ky if bd b kc li kg lj kk lk ko ll ks lm kw le lf lg lh dt translated">软实时—通常比离线更重要，并且在持续过程中进一步连接。有更多的时间执行任务。考虑更新搜索索引。如果更新过程失败，先前的索引仍然存在，并且结果将在下一个时间间隔更新。</li><li id="2d82" class="kx ky if bd b kc li kg lj kk lk ko ll ks lm kw le lf lg lh dt translated">硬实时—难以管理的架构类型。想想请求/回复和事务系统。由于等待的客户或正在运行的流程，速度通常很重要。</li></ul><h1 id="4ae8" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">方案</h1><p id="7b3d" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">假设您正在使用一个Mendix应用程序作为订单管理系统。在某一时刻，一名员工试图更新订单的状态。无中生有，系统变得非常慢，停止响应。与此同时，一个预定事件导致应用程序耗尽内存；应用程序日志显示应用程序将重新启动。虽然员工没有引起问题，但两个过程共享同一个系统，因此他们有共同的信念。</p><p id="6ff9" class="pw-post-body-paragraph ka kb if bd b kc kz ke kf kg la ki kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">当外部请求导致内存不足时，这种单一的应用程序设置会迅速变得更加复杂。假设有一个外部网站正在向同一个应用程序发送新订单。由于网站的一个漏洞，订单管理系统的更新已经不堪重负。网站仍将可用，但随机的东西会开始失败。员工可能会报告这个问题，您的监控解决方案会报告一个警报，但是如何处理面向消费者的web应用程序中的流程呢？消费者应用程序应该能够处理几种场景。“创建订单”请求是否已成功提交？如果是，订单管理系统是否处理了该请求？可能订单已经处理，但是向消费者应用程序发送响应失败。如果到目前为止一切顺利，但是消费者应用程序在收到响应时无法更新订单状态，该怎么办？</p><p id="c1b7" class="pw-post-body-paragraph ka kb if bd b kc kz ke kf kg la ki kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">总之，您可以看到复杂性在快速增加。你需要一个接一个地处理所有潜在的错误。测试架构将同样困难。甚至在消费者应用程序本身中，您可能会提出大量的测试场景。在分布式设置中测试时，由于可能出现的各种网络和处理问题，案例数量将呈指数级增长。以及发生未知错误时该怎么办？订单管理系统处理过订单吗？如果你有一个总体的图景，执行这些测试仍然是困难的。大多数情况下，迫使一个系统的系统进入某种错误状态并不容易。</p><p id="48e6" class="pw-post-body-paragraph ka kb if bd b kc kz ke kf kg la ki kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">分布式错误可能会隐藏数年，但它们会对您的生产环境产生巨大影响。最常见的是，非常具体的组合(阅读；完美风暴)可能会在一个很难查明问题发生的确切原因的环境中触发几个故障。</p><h1 id="cbd2" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">分布式异常处理</h1><p id="d698" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">当考虑在分布式系统中处理故障时，首先会想到四个类别。在这篇博客中，我们将讨论为什么其中一个不是首选，以及如何以不同的方式处理这个问题。</p><p id="45ee" class="pw-post-body-paragraph ka kb if bd b kc kz ke kf kg la ki kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">简而言之，类别包括重试、并行尝试、故障转移和回退。前三个选项在正确实施时可以使您的环境更加健壮，而回退在没有充分考虑的情况下会导致比它试图解决的问题更多的问题。</p><figure class="lr ls lt lu fq hw fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/017aeac1ed8056bdc483e6c6c501c095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*Mw_05iF9151LoIc7qLp4zQ.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">By using the Queue module from the Mendix Marketplace, it is easier to implement a retry policy. In Mendix 9 you can also use the internal Task Queue, but it is currently a bit more cumbersome to set up a retry mechanism here.</figcaption></figure><h1 id="a2f9" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">方案</h1><p id="68db" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">为了让这个故事更形象，我们从一个场景开始。您构建了一个解决方案，其中您需要将文件文档从系统A发送到系统B。您是系统A的开发人员，并且提供了一个解决方案，其中您使用系统B的web服务在流程需要时发送文件文档。不幸的是，系统B并不总是可用的。除此之外，系统B不能不定期地处理较大的文件。由于企业报告说关键文档现在丢失了，所以您实施了一个后备方案。每当系统B抛出任何类型的错误时，您通过邮件将文档发送到相关的业务单元。现在他们可以直接使用文档，自己上传到B系统。</p><figure class="lr ls lt lu fq hw fe ff paragraph-image"><div class="fe ff lq"><img src="../Images/303e137ec14cb1605da461ac7df5ca1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*mQmJBmVjEndjqgifGY9Jpg.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">A possible fallback scenario in which we send or queue an email in case the REST call fails.</figcaption></figure><h1 id="bae1" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">为什么这不是首选</h1><p id="0b6e" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">虽然这看起来是一个不错的解决方案，可以被企业接受，但是有几个理由不采用这个选项。除了可能的合规性异议(谁可以访问邮箱)，还有一些技术上的考虑。</p><h1 id="e41c" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">交易</h1><p id="bd2a" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">潜在的风险是，回退不值得冒这个险。最终，你试图通过权衡来达到同样的最终目标。这种权衡值得吗？应用程序可以决定这是否值得吗？以后还会是这种情况吗？考虑到这个场景，您将引入一个包含更多手动操作的替代流程。想象一下，随着公司的不断发展，几年后系统B的一次重大故障导致业务部门的邮箱被淹没，并且有太多的手动步骤来处理额外的工作。</p><p id="a3cd" class="pw-post-body-paragraph ka kb if bd b kc kz ke kf kg la ki kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">上面的情况告诉我们，很多时候，不值得去冒险。与最初的失败相比，回退场景(需要从邮箱中手动上传数百个文档)的影响可能更大。</p><h1 id="b77d" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">可预测性</h1><p id="a5d4" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">回退场景很可能很少触发或者根本不触发。因此，回退逻辑的影响常常被低估。再次考虑我们的邮件回退场景。由于已实现的解决方案，您可能希望文档总是在那里。但是如果回退机制也失败了呢？您的电子邮件服务器也可能不可用。此外，回退机制会给系统带来不可预知的负载。想象一下，大停电导致回退机制通过邮件发送所有文档。因为以前从未发生过这种情况，所以您没有考虑到邮箱会因大量附件而被填满。</p><figure class="lr ls lt lu fq hw fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/ddf22e4884362c9de667f8df99f1cd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*JV6WFvTPu1R8Yhk3lJjytg.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">While this isn’t a clean example, it shows the idea behind a failover scenario. In a solid architecture, this role is fulfilled by a load balancer.</figcaption></figure><h1 id="d9c4" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">测试</h1><p id="289e" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">测试回退场景很难。您需要强制系统处于一种状态，在这种状态下，您可以预测回退机制将被触发。回退场景不太可能被触发，因此它可能被视为应用程序中一个无害的逻辑。这种解决方案的性质增加了潜在错误的可能性，这些潜在错误可能隐藏多年，当它们出现时很难解决。</p><p id="ccca" class="pw-post-body-paragraph ka kb if bd b kc kz ke kf kg la ki kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">对于分布式的多个回退场景，测试会更加困难。将会出现几个压力点和潜在的瓶颈。这些组件中的一个(或它们的组合)的潜在过载可能很难模拟，并且因为可能性低而经常被丢弃。</p><blockquote class="ma"><p id="fe33" class="mb mc if bd md me mf mg mh mi mj kw ek translated">“在亚马逊，我们发现花费工程资源使主要(非后备)代码更可靠通常比投资于不常用的后备策略更能提高我们的成功几率。”-AWS高级首席工程师Jacob Gabrielson</p></blockquote><h1 id="7147" class="jc jd if bd je jf jg jh ji jj jk jl jm jn ml jp jq jr mm jt ju jv mn jx jy jz dt translated">可供选择的事物</h1><p id="1383" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">在通读了潜在的陷阱之后，您可能会寻找处理此类情况的替代方案。光这一点就可以花很多博文。希望这一节能给你一个好的开始。</p><ul class=""><li id="6dea" class="kx ky if bd b kc kz kg la kk lb ko lc ks ld kw le lf lg lh dt translated">设计并<strong class="bd mo">建立一个更具弹性和持久性的非回退场景</strong>。例如，您可以决定只使用高可用性的服务。</li><li id="d8d4" class="kx ky if bd b kc li kg lj kk lk ko ll ks lm kw le lf lg lh dt translated">让源应用程序负责处理错误。保持事情可控。</li><li id="3ed2" class="kx ky if bd b kc li kg lj kk lk ko ll ks lm kw le lf lg lh dt translated">我个人最喜欢的:<strong class="bd mo">如果可能的话创建一个重试机制</strong>。最常见的情况是，在系统之间交互时，一些小事情会出错。具有指数补偿的重试机制可以使您的架构更有弹性。</li><li id="d85d" class="kx ky if bd b kc li kg lj kk lk ko ll ks lm kw le lf lg lh dt translated"><strong class="bd mo">创建故障转移而不是回退</strong>。确保故障转移过程的输出同样可靠，并且该过程的输出是相同的，没有任何让步。通过在生产中定期使用两条路径来测试故障切换。</li><li id="443c" class="kx ky if bd b kc li kg lj kk lk ko ll ks lm kw le lf lg lh dt translated"><strong class="bd mo">一旦数据可用，主动将数据推送给监听方</strong>。当数据已经可用时，您就变得不那么依赖彼此的可用性了。这可以与适当的重试逻辑相结合。</li></ul><p id="2910" class="pw-post-body-paragraph ka kb if bd b kc kz ke kf kg la ki kj kk ln km kn ko lo kq kr ks lp ku kv kw hn dt translated">关注你的逻辑中经常出现而不是很少出现的逻辑路径。努力使您的主要系统更加健壮和可预测。尽可能用推代替拉。如果回退逻辑是必要的；确保它是可测试的，并保证替代方案和常规流程一样稳定可靠。</p><h1 id="911f" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">进一步阅读</h1><p id="a7ed" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">如果你问我，有一个好的导师在旁边可以提高你的建筑思维方式很多。除此之外，许多非Mendix的博客也非常有益。关于这个关于分布式系统的话题，我想对Amazon Builders' Library说一声。</p><h2 id="964a" class="mp jd if bd je mq mr ms ji mt mu mv jm kk mw mx jq ko my mz ju ks na nb jy nc dt translated">阅读更多</h2><div class="ht hu fm fo hv nd"><a href="https://aws.amazon.com/builders-library/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab ej"><div class="nf ab ng cl cj nh"><h2 class="bd ig fv z el ni eo ep nj er et ie dt translated">亚马逊建筑者图书馆</h2><div class="nk l"><h3 class="bd b fv z el ni eo ep nj er et ek translated">点击此处返回亚马逊网络服务主页</h3></div><div class="nl l"><p class="bd b gc z el ni eo ep nj er et ek translated">aws.amazon.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ib nd"/></div></div></a></div><div class="ht hu fm fo hv nd"><a href="https://docs.mendix.com/howto/logic-business-rules/set-up-error-handling" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab ej"><div class="nf ab ng cl cj nh"><h2 class="bd ig fv z el ni eo ep nj er et ie dt translated">设置错误处理- Studio Pro 9操作指南| Mendix文档</h2><div class="nk l"><h3 class="bd b fv z el ni eo ep nj er et ek translated">当使用微流时，重要的是要认识到总会有事务。这些交易有助于…</h3></div><div class="nl l"><p class="bd b gc z el ni eo ep nj er et ek translated">docs.mendix.com</p></div></div><div class="nm l"><div class="ns l no np nq nm nr ib nd"/></div></div></a></div></div></div>    
</body>
</html>