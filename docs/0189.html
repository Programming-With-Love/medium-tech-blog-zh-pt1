<html>
<head>
<title>Migrating Kafka transparently between Zookeeper clusters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Zookeeper集群之间透明地迁移Kafka</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/migrating-kafka-transparently-between-zookeeper-clusters-e68a75062f65?source=collection_archive---------3-----------------------#2021-10-12">https://medium.com/airbnb-engineering/migrating-kafka-transparently-between-zookeeper-clusters-e68a75062f65?source=collection_archive---------3-----------------------#2021-10-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="b2fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">了解如何在不影响用户的情况下将Kafka集群从一个Zookeeper集群迁移到另一个集群。</p><p id="bf05" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> By </strong> : <a class="ae jd" href="https://www.linkedin.com/in/edmund-mok" rel="noopener ugc nofollow" target="_blank">莫</a></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/8ace87ba7a81c3f969e6d42db118d4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rlubHQYNxZB-GWwTgIKrVQ.jpeg"/></div></div></figure><h1 id="0d54" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="34b7" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">Kafka是一个开源的分布式事件流平台。它依赖于另一个开源分布式协调系统Zookeeper来存储集群元数据。在Airbnb，Kafka构成了我们数据基础设施的支柱，为事件记录和变更数据捕获等用例提供支持，帮助我们更好地了解我们的客人和主人，并做出改进我们产品的决策。</p><p id="0a82" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们运行几个生产Kafka集群，其中最大的集群是我们最老的集群，由数百个代理组成，支持超过1GB/s的传入流量。在我们迁移之前，这个Kafka集群依赖于传统的Zookeeper设置，这是一个在许多不同的生产用例之间共享的多租户Zookeeper集群，这意味着集群上的任何事件都会影响所有依赖的服务，包括Kafka。而且，这个动物园管理员集群也缺乏一个明确的主人。我们希望将Kafka从这个Zookeeper集群中迁移到一个独立的、专用的Zookeeper集群中，该集群拥有清晰的所有权，并与其他用例更好地隔离。</p><p id="e917" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">目标是透明地完成迁移，没有任何数据丢失、停机或对Kafka用户以及其他Zookeeper用户的影响。</p><p id="d382" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最近发布的Kafka 2.8.0包括对KIP-500的更改，该社区提议删除Kafka对Zookeeper的依赖。由于Kafka 2.8.0中的这一功能尚未完成，也没有经过生产测试，所以在我们有信心在没有Zookeeper的情况下运行Kafka之前，还需要几个版本。因此，我们决定在Zookeeper集群之间迁移Kafka。</p><p id="d313" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的方法很大程度上受到了Yelp最初方法的启发，但是经过修改，在迁移中使用了Zookeeper观察者，以最小化对源Zookeeper集群的配置更改。我们还迁移了运行版本2.3.1的Kafka集群和运行版本3.5.8的Zookeeper集群。如果您也尝试迁移，请确保在您的设置上仔细测试，尤其是如果您运行的是不同的Kafka或Zookeeper版本！</p><h1 id="9eb2" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">高层战略</h1><p id="0f67" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">我们将使用zk-source来引用我们要从中迁移Kafka的原始Zookeeper集群，使用zk-dest来引用我们要将Kafka依赖项移动到的新目标Zookeeper集群。请注意，zk-dest必须是不包含任何预先存在的数据的新集群。</p><p id="5eb7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的迁移计划包括以下几个阶段:</p><ol class=""><li id="76c4" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">首先，添加zk-dest主机作为zk-source集群的观察者</li><li id="443f" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">接下来，将Kafka集群的Zookeeper连接从zk-source切换到zk-dest</li><li id="d52f" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">最后，重新配置zk-dest观测器以形成它们自己的独立系综</li></ol><h1 id="9ae9" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">阶段1:添加zk-dest主机作为zk-source的观察者</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lh"><img src="../Images/0fc6453246fb280a6e8ce49967bd6838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sdbX5HT3HPQpf19jGWwUOA.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx"><em class="lm">Phase 1: After adding zk-dest hosts as observers of zk-source, all zk-dest hosts will be connected to the leader of zk-source and begin replicating data from zk-source.</em></figcaption></figure><p id="d30f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在每个zk-dest主机的Zookeeper配置中，将所有zk-source服务器及其各自的角色(参与者或观察者)和所有zk-dest服务器作为观察者包含在服务器列表中。以这样的配置在zk-dest主机中启动Zookeeper将配置它们作为观察者加入zk-source集群，并开始复制集群中的所有Zookeeper数据。</p><p id="8f44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里使用观察者的一个好处是，在Zookeeper中，观察者不参与未决提交的投票过程，只从领导者那里了解已提交的提议。因此，可以将观察器添加到源集群来复制现有数据，而不会影响仲裁。</p><p id="13b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用观察者的另一个好处是我们不需要修改zk-source中的任何东西，比如zk-source主机中的配置文件。观察者可以加入zk-source集群，而无需出现在zk-source集群配置的服务器列表中。尽管知道这些观察者没有在原始配置中列出，但是领导者并没有拒绝它们。这对我们来说尤其重要，因为我们希望尽可能避免对源集群进行更改(或者更糟，不得不重启)。</p><h1 id="f440" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">阶段2:将Kafka连接从zk-source切换到zk-dest</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lh"><img src="../Images/185853ae1726379edc6b71f603932a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*117hDPP3WxjoI0sHOmzm9w.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx"><em class="lm">Phase 2: After switching Kafka’s Zookeeper connection over from zk-source to zk-dest, Kafka will still be operating on the original data in zk-source, but through zk-dest observers.</em></figcaption></figure><p id="b94d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个阶段包括更新每个代理上的Kafka配置，以使用只指向zk-dest观察者的Zookeeper连接字符串，然后运行每个Kafka代理的滚动重启，以获得这个新配置。在切换之前，记得确认观察器正在正确地从zk-source集群复制数据。在这个阶段的最后，Kafka集群将继续处理原始zk-source集群中的数据，但是现在是通过zk-dest观察器来处理。</p><h1 id="62fd" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">阶段3:重新配置zk-dest观测器以形成独立的集合</h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lh"><img src="../Images/74edb093160e74b69a9f37259c2c4022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjs_J80JTV3x5MeKxvzA0w.png"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx"><em class="lm">Phase 3: After restarting zk-dest observers into a separate ensemble, zk-dest hosts will form an isolated cluster with a copy of the original data from zk-source but independent from the original cluster.</em></figcaption></figure><p id="3f51" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，我们执行以下操作:</p><ol class=""><li id="d368" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">通过在zk-dest主机中插入iptables规则来阻止zk-source和zk-dest之间的网络通信，以拒绝任何传入和传出到zk-source的Zookeeper TCP数据包</li><li id="4bd7" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">检查zk-dest主机在Kafka子树中是否有最新的数据</li><li id="f637" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">更新zk-dest配置，使服务器列表中仅包含zk-dest主机作为参与者</li></ol><p id="c130" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第一次操作后，Kafka将无法使用Zookeeper，但在最后一次操作后，可用性将恢复，Kafka最终将通过重试重新连接。最后，zk-dest主机将获得新的配置，并形成一个仅由zk-dest主机组成的仲裁。Kafka将处理zk-source数据的副本，但在zk-dest集群内。</p><p id="8014" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们首先阻塞网络通信，以防止从Kafka到Zookeeper的任何进一步写入，从而最小化在迁移时丢失从zk-source复制到zk-dest的更新的机会，这可能导致不一致的数据。这一步只是额外的预防措施，因为我们已经观察到Kafka对Zookeeper的交易率很低，主要用于主题创建和更新。</p><p id="3dec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">或者，我们可以关闭所有zk-dest主机，或者直接阻止从Kafka brokers到Zookeeper的流量。阻塞zk-source和zk-dest之间的流量的一个好处是，我们发现更新iptables规则比正常重启Zookeeper进程更快。如果我们希望将zk-dest恢复为原始集群的观察者，我们可以更快地恢复Kafka的Zookeeper可用性。它还有助于保留zk-dest集群中的Zookeeper会话，因为如果zk-source leader和zk-dest观察者之间的流量没有被阻塞，则ZK-source leader可以向它们传播会话到期。在后面的部分中，我们将详细解释为什么我们希望在迁移过程中保留这些会话。</p><p id="9ae1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">即使在第一次操作后，Kafka认为Zookeeper不可用，生产者和消费者仍然可以与Kafka集群交互，并且不会经历任何中断，只要所有代理都是健康的。</p><p id="1338" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第二个操作中，我们可以通过检查zk-dest中最新事务的zxid(<a class="ae jd" href="https://zookeeper.apache.org/doc/r3.2.2/zookeeperInternals.html#sc_guaranteesPropertiesDefinitions" rel="noopener ugc nofollow" target="_blank">Zookeeper事务id </a>)是否大于或等于Kafka子树中所有ZNodes的最大czxid、mzxid或pzxid，来确认Kafka子树中的数据是最新的。这些zxid对应于:创建特定ZNode的变更、最后修改特定ZNode的变更以及最后修改特定ZNode的子节点的变更。如果这个条件成立，那么修改zk-source的Kafka子树的任何事务都将被捕获到zk-dest的事务日志中，我们确信zk-dest中的数据是最新的。</p><p id="d11f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了在迁移过程中快速执行这种检查，我们修改了Zookeeper附带的事务日志转储工具，只打印最新的事务，而不是整个日志。在我们的例子中，平均日志大约是500MB。转储整个日志大约需要20秒，尽管我们只关心最近的事务。我们还发现，使用内存映射文件I/O而不是标准文件I/O进一步略微提高了性能。这些更改将从日志中提取最新事务的时间减少到了1秒左右。</p><p id="4ee8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于迁移期间Kafka无法使用Zookeeper，控制器将无法检测到在此期间关闭的任何代理。如果代理失败，控制器将不会为在失败的代理上有领导者副本的任何分区选举新的领导者。由于消费者和生产者只能读取和写入主副本，并且副本在故障代理上处于离线状态，因此消费者和生产者将无法使用这些分区。根据您的生成器重试策略，脱机领导者副本可能会导致新的传入消息被丢弃并永远丢失。因此，监控代理指标以了解是否有代理失败是很重要的。如果在迁移期间发生这种情况，我们可以继续迁移，并允许控制器在迁移结束时恢复与zk-dest的连接后处理故障，或者我们可以将zk-dest主机恢复为zk-source的观察者，并解除zk-source和zk-dest之间的网络通信，以使Kafka恢复Zookeeper可用性，并允许控制器处理故障。</p><h1 id="a409" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">迁移期间保留Zookeeper会话</h1><p id="8a2a" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">Zookeeper客户端(如Kafka brokers)通过会话连接到Zookeeper集群。临时节点与这些会话相关联—例如在Kafka中，它们包括控制器和代理ID节点。当会话过期时，临时节点将被删除，会话通过客户端心跳保持活动状态。动物园管理员负责跟踪所有会话，并确定它们是否已过期。</p><p id="5da5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">理想情况下，我们希望在迁移过程中保留Zookeeper会话，因为Kafka依赖于这些会话和相关的临时节点。具体来说，我们希望在整个迁移过程中保留临时代理ID ZNodes(在path /brokers/ids下)。在迁移过程中，Kafka只能在短时间内无法使用Zookeeper，但如果迁移时间足够长，Zookeeper负责人可能会终止该会话。</p><p id="9f42" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Kafka控制器通过监视短暂的代理节点并识别哪些代理离线来检查离线领导者副本。如果Kafka经纪人的Zookeeper会话过期，其短暂的经纪人ID ZNode将被删除。在迁移结束时，当Zookeeper再次可用时，如果代理没有足够快地重新连接到Zookeeper，控制器将检测到丢失的代理ZNode，并假设代理已经失败。控制器将尝试将主副本重新定位到其他代理以保持分区可用性，并在重新连接时再次回到原始代理。在此期间，Kafka的消费者和生产者可能会经历中断，因为他们在持有领先复制品的经纪人之间切换。</p><p id="bd00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于我们的迁移，我们必须使用zk-source集群中现有的40秒会话超时，以避免对集群进行任何更改。由于领导者确定会话到期，通过阻止zk-source和zk-dest之间的流量，我们防止了任何现有会话在zk-dest中到期的可能性(尽管它们可能仍然在zk-source中到期),并避免了前述的竞争情况。</p><h1 id="54ed" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="65c3" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">迁移可能很难执行，特别是在Kafka和Zookeeper等复杂的分布式系统上试图确保不中断用户和不丢失数据时，但通过仔细的规划和测试，我们能够在不停机的情况下进行迁移。这种方法可以用于依赖Zookeeper的其他系统，而不仅仅是Kafka——理想情况下，这种系统对Zookeeper的事务率很低，并且能够优雅地处理Zookeeper不可用的情况。我们再次感谢Yelp的原创博文，它启发并证明了这种迁移可以在不影响用户的情况下完成。</p><h1 id="be6a" class="jq jr hh bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">承认</h1><p id="2d4b" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">非常感谢徐章、佟伟、赵、和郭墨成，他们密切合作并提供了宝贵的反馈，确保了迁移的成功。还要特别感谢Abhishek Parmar、Chandramouli Rangarajan、Chiyoung Seo、Jingwei Lu、Liuyang Li、Tang和在审核迁移策略时提供的帮助。最后，感谢布雷特·布考斯基和迪伦·赫德对这篇博文的审阅和改进。</p></div><div class="ab cl ln lo go lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ha hb hc hd he"><p id="e25c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">查看这些相关角色:</p><p id="d293" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jd" href="https://careers.airbnb.com/positions/3045137/" rel="noopener ugc nofollow" target="_blank">高级软件工程师，存储&amp;数据库</a></p><p id="5035" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jd" href="https://careers.airbnb.com/positions/1858035/" rel="noopener ugc nofollow" target="_blank">高级职员软件工程师，后台数据平台</a></p><p id="c6cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jd" href="https://careers.airbnb.com/positions/2410642/" rel="noopener ugc nofollow" target="_blank">云基础设施软件工程师</a></p><p id="f984" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jd" href="https://careers.airbnb.com/positions/3477507/" rel="noopener ugc nofollow" target="_blank">高级/员工软件工程师，分析基础设施</a></p><p id="ef8e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jd" href="https://careers.airbnb.com/positions/3069302/" rel="noopener ugc nofollow" target="_blank">员工软件工程师，服务平台</a></p><p id="84d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">所有产品名称、标识和品牌均为其各自所有者的财产。本网站中使用的所有公司、产品和服务名称仅用于识别目的。使用这些名称、标志和品牌并不意味着认可。</em></p></div></div>    
</body>
</html>