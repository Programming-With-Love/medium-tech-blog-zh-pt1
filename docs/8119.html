<html>
<head>
<title>Design and Implementation of A Reusable Forecasting Library with Extensibility and Scalability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有可扩展性和可伸缩性的可重用预测库的设计与实现</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/design-and-implementation-of-a-reusable-forecasting-library-with-extensibility-and-scalability-b59b3701b66f?source=collection_archive---------6-----------------------#2022-05-17">https://medium.com/walmartglobaltech/design-and-implementation-of-a-reusable-forecasting-library-with-extensibility-and-scalability-b59b3701b66f?source=collection_archive---------6-----------------------#2022-05-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="03db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated">预测是沃尔玛公司最常要求的机器学习功能之一。当不同的团队在竖井中构建ML模型时，他们经常使用相同的开源包，无休止地重复工作。最近，我们开发了一个可重用的预测库(<em class="jl"> RFL </em>)，通过同时关注可伸缩性和可扩展性的设计来避免这种情况。目标是为常用的建模方法(如Prophet、Xgboost、Arima等)提供一个包装器..那些重复性的工作现在由<em class="jl"> RFL </em>来完成。因此，数据科学家可以花更多的时间来评估结果和改进模型。</p><h1 id="a13b" class="jm jn hh bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated"><strong class="ak">要求</strong></h1><p id="b796" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">我们一开始要求<em class="jl"> RFL </em>必须是<strong class="ig hi">基于配置的</strong>。应用程序相关信息在JSON文件中指定，而应用程序不可知部分在核心库中实现。这是由我们的预测即服务愿景推动的，其中前端UI通过JSON文件与后端FAAS通信。</p><p id="fc1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个需求是<strong class="ig hi">扩展性</strong>。这包括添加当前库中没有的新预测模型的能力，以及扩展分类等功能的能力。<em class="jl"> RFL </em>应该让这种功能提升变得简单易行。</p><p id="cc33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后一个需求是<strong class="ig hi">可扩展性</strong>。在我们从事的项目中，有涉及几百个模型(小)、几万个模型(中)或几百万个模型(大)的项目。所有这些用例都应该得到支持，并通过翻转JSON文件中的一个标志进行理想的配置。</p><h1 id="daf9" class="jm jn hh bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">设计</h1><p id="1919" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">我们的方法是首先对预测的计算过程进行抽象。然后，我们使用面向对象设计(OOD)的概念来捕获抽象。我们的直觉是，一旦被捕获，添加新的模型/功能就变成了子类化的问题(从基类)。</p><p id="4088" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个抽象是数据和计算的分离。在图1a中，数据帧的字段包括四种类型:</p><ul class=""><li id="e195" class="kp kq hh ig b ih ii il im ip kr it ks ix kt jb ku kv kw kx bi translated">时间索引—这是数据点的时间戳。</li><li id="ee39" class="kp kq hh ig b ih ky il kz ip la it lb ix lc jb ku kv kw kx bi translated">目标-这是要预测的目标。</li><li id="2f34" class="kp kq hh ig b ih ky il kz ip la it lb ix lc jb ku kv kw kx bi translated">分区-这里的列实际上定义了一个数据网格，其每个关节都与数据框中的一个时间序列相关联。图1a示出了一些例子。分区列也称为维度。</li><li id="1979" class="kp kq hh ig b ih ky il kz ip la it lb ix lc jb ku kv kw kx bi translated">特征——被视为目标变量的驱动因素，用于辅助预测。同样，图1a示出了一些示例特征。</li></ul><p id="d760" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图1b是在关节处发生的计算的图示。在许多试验中，它由一系列连续运行的阶段组成(想想超参数调整)。所有的管道运行相同的程序，但是使用不同的数据(听起来是不是像一个程序多数据的事情？).</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ld"><img src="../Images/8992a49d8d9ef5ffe7d8b0a6da79c56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*01K-xuMZlZUubdtQy16waw.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx">Figure 1a. Abstraction of data: think of data as multiple time series at the joints of the partition grid</figcaption></figure><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lt"><img src="../Images/0f656c5eed7b1639056ca00f0c9e9f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8v6eaLZUcN17Ty4GzYz-Q.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx">Figure 1b. Abstraction of computation: parallelization happens at joints and trials</figcaption></figure><p id="3185" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个抽象进一步深入计算方面(图1b)。在这里，我们观察到在流水线中运行的功能和为执行分配的计算资源的分离。我们把后者叫做<em class="jl">后端</em>。更多内容将在下一节介绍。</p><p id="4471" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在进入详细描述之前，让我们简要介绍一下将用于表示我们的设计的UML术语:</p><ul class=""><li id="dd23" class="kp kq hh ig b ih ii il im ip kr it ks ix kt jb ku kv kw kx bi translated"><strong class="ig hi">是-A</strong>:<em class="jl">A</em>T6】是-AT8】B的意思是<em class="jl"> A </em>是基类<em class="jl"> B </em>的子类</li><li id="d4a3" class="kp kq hh ig b ih ky il kz ip la it lb ix lc jb ku kv kw kx bi translated"><strong class="ig hi">有-A</strong>:<em class="jl">A</em>T18】有-AT20】B的意思是<em class="jl"> B </em>是<em class="jl"> A </em>的成员</li><li id="a2a1" class="kp kq hh ig b ih ky il kz ip la it lb ix lc jb ku kv kw kx bi translated"><strong class="ig hi">用途-a </strong> : <em class="jl"> A </em> <strong class="ig hi">用途-a </strong> <em class="jl"> B </em>表示<em class="jl"> A </em>引用了<em class="jl"> B </em>的对象，通常作为参数传递给<em class="jl"> A </em>的成员函数</li></ul><p id="cd18" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated"><span class="l jd je jf bm jg jh ji jj jk di">D</span><strong class="ig hi"><em class="jl">ataset</em></strong>反映了前面图1a所示的数据抽象。有两部分:<em class="jl"> DataSource </em>对应的是从数据源中读取的内容；<em class="jl"> Extras </em>是由<em class="jl"> AutoPipe </em>制造的附加特征。<em class="jl">数据帧</em>最初存储从源读取的数据。后来，它增加了那些来自<em class="jl">临时演员</em>的演员。不同类型的特征具有不同的行为。最好用面向对象的设计来捕获它们，如图2所示。</p><figure class="le lf lg lh fd li er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es lu"><img src="../Images/7f2b97cb964993606e0da8bb2f055ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w54uO-uKfboj_5KeazC3_A.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx">Figure 2. Hierarchy of the <em class="lv">Dataset</em> class. Notice the reference to <em class="lv">DataFrame</em> which stores the actual data.</figcaption></figure><p id="e6bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jl">外生</em>信号是降水、失业、店铺客流量等外部变量。，它们与<em class="jl">目标</em>相关。提供了两种方法:<em class="jl"> impute() </em>和<em class="jl"> extend()。</em>前者填充任何N/A值。后者计算每个要素的未来值。</p><p id="f022" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jl">滞后</em>由一组从<em class="jl">目标</em>设计的统计特征组成，通常用于基于回归的模型，如树模型。<em class="jl">节假日</em>和<em class="jl">季节性</em>很好理解。</p><p id="bfe4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jl">时间编码</em>以每周、每月、每季度和/或每年的频率对时间周期进行编码。它们类似于在变压器型NLP神经网络中广泛使用的位置编码。同样，此功能在回归模型中也很有用，如果没有此类功能，时间顺序可能会丢失。</p><p id="a24b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated"><span class="l jd je jf bm jg jh ji jj jk di">F</span><strong class="ig hi">T5】油号 </strong>是实现可扩展性的地方。在图3中，<em class="jl">函数</em>类是功能的提供者。它完成了三件事:I)。纳入当前不在库中的新预测模型；ii)。添加新的估计器，如分类器；iii)。适应一些流行的机器学习API。目前<em class="jl"> RFL </em>已经实现了6种建模方法:Sarimax，Prophet，Greykite，Xgboost，LightGBM，Random Forest。</p><p id="3220" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">SklearnEstimator类提供了一个API适配的例子，在这个例子中是Scikit-learn——一个流行的开源ML包。该适配器的目的是允许<em class="jl"> RFL </em>函数作为遵循Scikit-learn编码约定的其他函数的阶段集成到Scikit-learn管道中。管道是一种高效的执行方式，在ML社区中被广泛认可。它消除了阶段之间的瞬时数据IO。新API的未来扩展可以类似地实现。</p><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es lw"><img src="../Images/8dbda8dd7e4f9b87cfe31f0327ae7385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*rUGCUXjeWa7v28YmyPReOg.png"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">Figure 3. Hierarchy of the Function class. In the future, <em class="lv">Classifier</em> can be added as new <em class="lv">Function.</em></figcaption></figure><p id="22e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated"><span class="l jd je jf bm jg jh ji jj jk di">C</span><strong class="ig hi"><em class="jl">compute</em></strong>是一个“把一切都拉在一起”的类。图4呈现了这样一个过程:在可伸缩的<em class="jl">后端</em>上，针对<em class="jl">数据集</em>中的多个数据运行<em class="jl">函数</em>。目前为止支持三个后端:<em class="jl"> Loop </em>、<em class="jl"> Joblib </em>和<em class="jl"> PySpark </em>。顾名思义，<em class="jl">循环</em>后端旨在以数据迭代的方式在本地计算机上运行。<em class="jl"> Joblib </em>后端使用Joblib开源库实现多线程。最后，大规模任务可以使用<em class="jl"> PySpark </em>后端在Spark集群上执行。<em class="jl"> run </em>()的工作是从被引用的<em class="jl"> Function </em>对象(本例为Prophet model)中打包相应的函数(<em class="jl"> fit_transform </em>()或<em class="jl"> predict </em>())并发送到已经预先配置好的后端。模型和后端都在配置文件中指定。</p><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es lx"><img src="../Images/54354535a37c2690401acc59eab6c041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*B7ncnvRbQc9PSlgUw1mUPw.png"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">Figure 4. Hierarchy of the Compute class. This example illustrates that a Prophet model is run on one of the three backends.</figcaption></figure><h1 id="d277" class="jm jn hh bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">履行</h1><p id="1a19" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi jc translated"><span class="l jd je jf bm jg jh ji jj jk di"> R </span> <strong class="ig hi"> <em class="jl"> untime </em> </strong>为数据科学家提供顶层功能。对于他们的大部分日常工作，与这个班级的互动是足够的。已经实现了四种模式。其中每一个都是功能的组合:<em class="jl">调</em>()、<em class="jl">练</em>()、<em class="jl">测</em>()、<em class="jl">预报</em>()，依次进行(图5)。虽然数据科学家可以通过编程API调用这些函数，但标准的使用方式是通过配置文件，通过<em class="jl">配置处理程序</em>类加载配置信息。在内部，四种模式调用<em class="jl"> Compute.run </em>()来完成它们的赋值。由于模块化设计，未来新模式的整合将变得轻而易举。在配置方面，<em class="jl">主配置</em>用于一般设置，<em class="jl">车型配置</em>用于车型特定设置。</p><figure class="le lf lg lh fd li er es paragraph-image"><div class="er es ly"><img src="../Images/00205b9f0ab1b02b11282e1a86298c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*TpMZyi1mtaw7AaVGoqo3NQ.png"/></div><figcaption class="lp lq et er es lr ls bd b be z dx">Figure 5. Runtime architecture. Four predefined modes are implemented currently. User construction of runtime pipelines (via config files) will be realized in the future.</figcaption></figure><p id="d7a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了上述四种模式，<em class="jl"> RFL </em>还有一些额外的功能值得一提:</p><p id="f4c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated"><span class="l jd je jf bm jg jh ji jj jk di">R</span>T26】广义特征生成。有必要在训练和测试中递归地产生外部信号和统计特征的未来值。目前，一个香草先知模型被用于此目的。如果数据框中有未来值，可在配置中禁用此功能。</p><p id="5593" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated"><span class="l jd je jf bm jg jh ji jj jk di">G</span>T30】肉平。在一些用例中，分区变得过于精细，时序信号变得过于稀疏。一个常见的例子是商店-部门-类别级别的预测。在这种情况下，数据科学家会希望首先对某些分区维度进行分组。<em class="jl"> RFL </em>可以配置为在组的基础上训练模型，并为组中的所有分区生成预测。</p><p id="fce2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated"><span class="l jd je jf bm jg jh ji jj jk di">E</span>T36】估价频率。对于模型的绩效评估，可以使用不同的指标，如MAPE、加权MAPE、对称MAPE、MAE等。可以对聚合的时间序列频率而不是数据集的原始频率进行评估。当未来的时间序列具有不同的频率时，这一点尤其重要，并且当未来的数据可用时，要对性能度量进行比较。</p><h1 id="24e6" class="jm jn hh bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">摘要</h1><p id="cb66" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated"><em class="jl"> RFL </em>已经在多个沃尔玛项目中被采用作为建模工具。总之，数据科学家报告的好处有两个方面:</p><ul class=""><li id="4f95" class="kp kq hh ig b ih ii il im ip kr it ks ix kt jb ku kv kw kx bi translated">低代码实验设置带来的工作节省。由于内置并行化，这相当于节省了3到4天时间，并减少了90%的执行时间。有了RFL，数据科学家可以更专注于设计实验，而不是每次都花精力去设置。</li><li id="3c19" class="kp kq hh ig b ih ky il kz ip la it lb ix lc jb ku kv kw kx bi translated">通过更广泛地探索超参数和特征空间提供质量改进。虽然提高建模质量不是库本身的目标，但由于实验的简化，数据科学家通常会在事后找到更优的模型。</li></ul><p id="7bf0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jl"> RFL </em>是一个可重用的预测库，设计时考虑了可扩展性和可伸缩性。它也是配置驱动的，这是一种设计选择，旨在支持我们预测即服务的长期愿景，以便企业作为数据所有者可以以无代码的方式尝试假设情景。未来，我们希望在公司内部提高其认知度，以增加更多的使用。</p><h1 id="71e7" class="jm jn hh bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">确认</h1><p id="a0cf" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">多个沃尔玛团队参与了<em class="jl"> RFL </em>的开发。他们的贡献在这里立刻得到承认。</p></div></div>    
</body>
</html>