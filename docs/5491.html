<html>
<head>
<title>ADF BC REST Query and SQL Nesting Control Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ADF BC REST查询和SQL嵌套控制解决方案</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/adf-bc-rest-query-and-sql-nesting-control-solution-6b6e64184950?source=collection_archive---------0-----------------------#2018-08-16">https://medium.com/oracledevs/adf-bc-rest-query-and-sql-nesting-control-solution-6b6e64184950?source=collection_archive---------0-----------------------#2018-08-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="0762" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将谈论专家模式视图对象(用手写的SQL)，这个视图对象是基于SQL连接创建的。这就是我今天例子的使用案例。我将描述与生成SQL语句相关的问题，并给出如何解决它的提示。如果您想通过ADF BC REST服务公开复杂的VO(带连接和计算总数的SQL ),然后对这个REST资源运行查询，这将特别有用。</p><p id="3d11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">代码可以在我的<a class="ae jc" href="https://github.com/abaranovskis-redsamurai/ADFBCRestApp" rel="noopener ugc nofollow" target="_blank"> GitHub </a>仓库中找到。</p><p id="2abd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是SQL join和专家模式VO(可以手动修改SQL的那个):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/072682cc442e0d55d4180ed074ae31fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33Jb7neu1g34ivYON2mwoA.png"/></div></div></figure><p id="5bdf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个VO是通过ADF BC REST曝光的，我就不赘述了，你可以在网上找到更多关于它的信息。一旦应用程序开始运行，REST资源就可以通过GET访问。ADF BC REST语法允许将查询字符串与REST请求一起传递，这里我基于StreetAddress='ABC '进行过滤:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jp"><img src="../Images/99e0756feacfe9f85be9646363e8a24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98X3L4FweeXLRZ0VavKTQA.png"/></div></div></figure><p id="b402" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在后端，默认情况下这可以正常工作，并生成嵌套查询(这是专家模式VOs的预期行为，所有附加条件子句将通过SQL包装添加)。虽然这样的查询执行得很好，但这不是我们在某些用例中想要的。如果我们在SQL中计算总计或平均聚合值，我们不希望它被包装:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jq"><img src="../Images/f28a8abdd76a4859592b007f16c70df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-S7ZcCnFGNuWWyRy3eDCA.png"/></div></div></figure><p id="d77a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了防止SQL换行，我们可以在VO构造函数中调用ADF BC API方法:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jr"><img src="../Images/2f34382c7e75123b94cb8d2fe0084adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w8Xt30_4IqaGHUKdtH1ZRg.png"/></div></div></figure><p id="fe8a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然这可能适用于常规的ADF BC，但不适用于来自ADF BC REST的标准。禁用查询嵌套后，生成的SQL查询包含两个WHERE子句:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es js"><img src="../Images/b27060240a67e9e92871139777366211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aC66vLHxkqfknzOTrgWLNQ.png"/></div></div></figure><p id="e3ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我建议的可能解决方案—覆盖executeQueryForCollection方法，进行一些解析并更改second WHERE to AND，应用更改后的查询字符串，然后执行super:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jt"><img src="../Images/1f1d4ecf8cd56e8190841475070fb456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MvTIxhshCR0o8ibdR2mFfg.png"/></div></div></figure><p id="4976" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个技巧很有帮助，查询如我们所预期的那样生成，从ADF BC REST查询调用添加的标准被附加在WHERE子句的末尾:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ju"><img src="../Images/58be31179cab85a34dc598776e01207f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqSeIwrJkMaGOmwQg0JBKA.png"/></div></div></figure></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><p id="9216" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kc">原载于2018年8月16日</em><a class="ae jc" href="https://andrejusb.blogspot.com/2018/08/adf-bc-rest-query-and-sql-nesting.html" rel="noopener ugc nofollow" target="_blank"><em class="kc">【andrejusb.blogspot.com</em></a><em class="kc">。</em></p></div></div>    
</body>
</html>