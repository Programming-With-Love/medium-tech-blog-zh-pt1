<html>
<head>
<title>Reactive Programming para Desenvolvedores Android — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适用于 Android 开发人员的 Reactive Programming — Part 2</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/reactive-programming-para-desenvolvedores-android-part-2-7cda0679b9?source=collection_archive---------1-----------------------#2017-03-14">https://medium.com/google-developer-experts/reactive-programming-para-desenvolvedores-android-part-2-7cda0679b9?source=collection_archive---------1-----------------------#2017-03-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5129" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上一篇 文章中,我介绍了反应式编程,在那里我开始谈论最初使用的“函数式反应式编程”命名法,以及为什么它没有定义这种模式,因为它与另一种称为“函数式编程”的模式混淆。</p><p id="0b61" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在澄清了命名法之后,我进一步写了关于被动思考的必要性,以及一些关于如何实现这种方法的理论例子,与编程早期使用的命令式方法相比。</p><p id="c331" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第二篇文章中,我将谈论:</p><ul class=""><li id="7711" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">如何配置项目(Android或纯Java使用Gradle)使用RxJava库</li><li id="917c" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">创建一个 Observable 以发出数据流。</li><li id="2fa5" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">创建一个订阅者以接收数据流。</li></ul><h1 id="3705" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">什么是<strong class="ak">RxJava?(T5 )</strong></strong></h1><p id="41be" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">很简单,反应性扩展作为一种模式,可以使用不同的语言来实现,并且由于一些开发人员社区的努力和承诺,已经为不同的现有语言创建了不同版本的库,例如:RxJava(Java),RxJs(JavaScript),RxPHP(Php)等可以在<a class="ae jc" href="http://reactivex.io/languages.html" rel="noopener ugc nofollow" target="_blank">这里找到。</a></p><blockquote class="ku kv kw"><p id="d50b" class="ie if kx ig b ih ii ij ik il im in io ky iq ir is kz iu iv iw la iy iz ja jb ha bi translated">“RxJava 是 Reactive Extensions 实现的 Java 库,它允许我们使用 Observers 序列创建基于事件的异步程序” — <a class="ae jc" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> WEB //github.com/ReactiveX/RxJava</a></p></blockquote><p id="3df9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有几个针对Java的Reactive Extensions实现,但RXJava是Java的“<em class="kx">官方</em>”库,并且在Android上被广泛使用(有一些特定于平台的变体,我将在后面提到),其创建和维护背后的优秀贡献者社区。</p><h1 id="0b92" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">如何在Android项目中配置RxJava?</h1><p id="1111" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">将 Android 或 Java 项目设置为使用 RXJava 非常简单,因为您只需将下面的代码添加到要使用该库的模块的 build.gradle 文件中即可导入库。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="9c4a" class="lk js hh lg b fi ll lm l ln lo">dependencies {<br/>    //outras depenedencies</span><span id="48c2" class="lk js hh lg b fi lp lm l ln lo"><strong class="lg hi">    </strong>compile <strong class="lg hi">"io.reactivex:rxjava:</strong>$rootProject.ext.rxJavaVersion<strong class="lg hi">"<br/></strong>}</span></pre><p id="66d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kx">PS:RxJava的版本在项目的build.gradle文件中被定义为一个变量,因为组织和易于在所有添加的m</em>或<em class="kx">模块中保持相同的库版本。(T15)</em></p><p id="f82f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">RxJava 有两个版本,对于这篇文章和接下来的文章将基于文档<a class="ae jc" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank">中给出的第二个版本。</a></p><h1 id="ba7b" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">创建数据发送者</h1><p id="6e96" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">在上一篇文章中,我谈到了反应式编程模式中的两个主要元素,其中一个负责发出数据流,另一个负责在接收数据时保持倾听并做出反应。</p><p id="a0c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Java RX中,负责发出数据流的组件来自以下类中实现的不同方式:</p><p id="edc1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Flowable: </strong> 发行<strong class="ig hi">零</strong>或<strong class="ig hi">N</strong>项目,并支持<strong class="ig hi">backpressure</strong>(这是一个有趣且难以理解的概念,所以我可能会在以后的帖子中讨论)</p><p id="2ec6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">可观察的</strong>:发出<strong class="ig hi">零或N</strong>项,或者在发生<strong class="ig hi">错误</strong>或<strong class="ig hi">完成</strong>数据流发送时发出信号。<br/> Observable 与 Flowable 的不同之处在于它不支持回压。</p><p id="a468" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">Single:</strong> 只发出一个带有 1 个元素或一个<strong class="ig hi">错误的数据流。(T20)</strong></p><p id="3e24" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">Completeable: </strong> 不要发出任何元素,只表示发生错误或数据流发送完成。</p><p id="0b38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">Maybe:</strong>顾名思义,这个实现可能不会发出任何项目、单个项目或错误信号。</p><p id="164e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">出于启动原因,为了让你在跑步之前学习如何小便,我将首先介绍如何使用<strong class="ig hi">Observable发送数据的示例。(T26)</strong></p><h2 id="13ab" class="lk js hh bd jt lq lr ls jx lt lu lv kb ip lw lx kf it ly lz kj ix ma mb kn mc bi translated"><strong class="ak"> 如何使用 Observable 输出数据流。(T28)</strong></h2><p id="40ba" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">Observable类公开了不同的静态方法来创建observables和组合不同的函数(我将在下一篇文章中介绍)。<br/> 创建观察值的一些最常用的方法是:</p><p id="85e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> just — </strong> 创建一个observable,它将传递的项目作为参数发出,并且当这个observable被创建时,这些项目开始发出,无论是否订阅了Observer。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="3e3e" class="lk js hh lg b fi ll lm l ln lo">List&lt;String&gt; names = <strong class="lg hi">new </strong>ArrayList&lt;&gt;();<br/>names.add(<strong class="lg hi">"Dario"</strong>);<br/><em class="kx">//Add more names to the list<br/></em>Observable.<em class="kx">just</em>(names);</span></pre><p id="f33b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> defer </strong> 创建一个 observable,只有在订阅了 Observer 之后,才会开始将传递的项目作为参数发出。正如下面的代码所示, creator <strong class="ig hi"> defer </strong> 实际上接收一个函数作为参数,这是我们创建 Observable 时要创建的函数,通过使用方法 <strong class="ig hi"> just 返回另一个带有项目的 Observable。(T37)</strong></p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="00a5" class="lk js hh lg b fi ll lm l ln lo"><strong class="lg hi">final </strong>List&lt;String&gt; names = <strong class="lg hi">new </strong>ArrayList&lt;&gt;();<br/>names.add(<strong class="lg hi">"Dario"</strong>);<br/><em class="kx">//Add more names to the list<br/></em>Observable.<em class="kx">defer</em>(<strong class="lg hi">new </strong>Func0&lt;Observable&lt;List&lt;String&gt;&gt;&gt;() {<br/>    @Override<br/>    <strong class="lg hi">public </strong>Observable&lt;List&lt;String&gt;&gt; call() {<br/>        <strong class="lg hi">return </strong>Observable.<em class="kx">just</em>(names);<br/>    }<br/>});<br/></span></pre><p id="49f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 订阅 Observable 发送的数据流</strong></p><p id="6c7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建将接收数据流的 Observables 之后,为了完成整个电路,我们必须创建一个 Observer 来监听并响应要发送的数据流。</p><p id="39c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在RxJava中,观察者是由类<strong class="ig hi"><em class="kx">Subscriber</em></strong>表示的。<br/> subscriber 类实现了 Observer 接口,该接口具有 3 种重要的回调方法:</p><p id="edc7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> onNext(T item) </strong> — 每当从 Observable 接收项目时,此方法在 Subscriber 中调用。</p><p id="3162" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">onComplete() — </strong> 在 Observable 到达数据流的末尾时调用此方法。<br/>当observable到达流的末尾,或者甚至没有发送任何项目时,可以调用此方法,并且observable仅用于发出异步操作已完成的信号。</p><p id="c455" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">onError(Throwable e) — T11 每当 Observable 遇到导致数据流中断的错误时,就会调用此方法。</p><p id="a40c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kx">(例如,如果您正在对API进行HTTP调用,并且服务器使用已经支持RxJava的Retrofit之类的库返回错误,错误将被自动截获,而不是</em>是<em class="kx">在最简单的情况下,您需要使用NetworkManager之类的组件进行检查)</em></p><h2 id="b3a4" class="lk js hh bd jt lq lr ls jx lt lu lv kb ip lw lx kf it ly lz kj ix ma mb kn mc bi translated">加入 Observable 和 Subscriber</h2><p id="fcac" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">了解了这两个主要组成部分,现在是时候将所有组成部分放在一起,并展示这两个组成部分如何从头到尾相互关联。<br/>在我看来,连接这两个组件的步骤是:</p><p id="fe05" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">1 — 拥有一个数据源(<em class="kx"> Producer </em> </strong>):正如我在上面的 Observable 创建方法中所展示和提到的那样,<strong class="ig hi">just </strong> 和<strong class="ig hi">defer </strong> 都接收要发出的元素。<br/> 考虑到这一观察,我希望你内化:</p><ul class=""><li id="7498" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">Observable 不负责生成要发出的数据,但仅限于发出转换流并通知 Observer 订阅它。</li><li id="a851" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">数据源可以是对象、原始类型、返回两者之一的方法。</li></ul><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="6a76" class="lk js hh lg b fi ll lm l ln lo"><strong class="lg hi">public </strong>List&lt;String&gt; getNamesList(){<br/>    List&lt;String&gt; names = <strong class="lg hi">new </strong>ArrayList&lt;&gt;();<br/>    names.add(<strong class="lg hi">"Dario"</strong>);<br/>    names.add(<strong class="lg hi">"Mario"</strong>);<br/>    names.add(<strong class="lg hi">"Paulo"</strong>);<br/>    <strong class="lg hi">return </strong>names;<br/>}</span></pre><p id="e7ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">2 — 使用我上面提到的方法创建一个观察表(T29)。(在这个例子中,我将使用 creator <strong class="ig hi"> just </strong> )</strong></p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="8850" class="lk js hh lg b fi ll lm l ln lo"><strong class="lg hi">public </strong>Observable&lt;List&lt;String&gt;&gt; getNames(){<br/>    <strong class="lg hi">return </strong>Observable.<em class="kx">just</em>(getNamesList());<br/>}</span></pre><p id="dba7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3 — <strong class="ig hi"> 创建一个订阅者</strong>,该订阅者与 Observable 发出的数据类型相同。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="b1a0" class="lk js hh lg b fi ll lm l ln lo">Subscriber&lt;List&lt;String&gt;&gt; subscriber = <strong class="lg hi">new </strong>Subscriber&lt;List&lt;String&gt;&gt;(){<br/>    @Override<br/>    <strong class="lg hi">public void </strong>onCompleted() {<br/>        <em class="kx">//a operacao terminou<br/>    </em>}<br/><br/>    @Override<br/>    <strong class="lg hi">public void </strong>onError(Throwable e) {<br/>        <em class="kx">//ocorreu um erro e os detalhes estao no Throwable<br/>    </em>}<br/><br/>    @Override<br/>    <strong class="lg hi">public void </strong>onNext(List&lt;String&gt; names) {<br/>        <em class="kx">//Fazer alguma coisa com a lista<br/>    </em>}<br/>};</span></pre><p id="e599" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">4 — 设置 Subscriber</strong> 以监听 Observable 发送的流,并对三种方法之一(onNext、onError 或 onComplete)做出响应。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="a6fb" class="lk js hh lg b fi ll lm l ln lo">getNames().subscribe(subscriber);</span></pre><p id="56a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第四步中,当订阅订阅者到 Observable 时,如本示例中所示,不会发生任何错误,将调用包含名称列表的 onNext 方法,然后调用 onComplete 方法。</p><p id="fb08" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">完整的示例见<a class="ae jc" href="https://gist.github.com/realdm/3c2f1f59bc3544ec87699ace8423f5f7" rel="noopener ugc nofollow" target="_blank">GIST</a> 。</p><p id="746b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中,我将停留在这里,在下一篇文章中,我将讨论我们可以应用于数据流的不同函数,以及为什么这些函数是本主题中最有趣的部分(在我看来),并使开发android应用程序时的工作变得更加容易。</p><p id="7fdd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kx">如果您发现这篇文章很有趣,请点击下面的绿色小心脏留下一个喜欢,并与您认为您也会喜欢的朋友分享:)</em></p><p id="292f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">吃下一个=)</p><p id="0cd5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">DM</p></div></div>    
</body>
</html>