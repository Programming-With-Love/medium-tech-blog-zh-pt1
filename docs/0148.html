<html>
<head>
<title>Building Services at Airbnb, Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Airbnb的建筑服务，第4部分</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/building-services-at-airbnb-part-4-23c95e428064?source=collection_archive---------1-----------------------#2020-09-30">https://medium.com/airbnb-engineering/building-services-at-airbnb-part-4-23c95e428064?source=collection_archive---------1-----------------------#2020-09-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c2a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们关于扩展服务开发系列的第四篇文章中，我们将深入探讨在Airbnb中为服务开发构建基于模式的测试基础设施。</p><p id="d834" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc"/><a class="jd je ge" href="https://medium.com/u/4f808559467d?source=post_page-----23c95e428064--------------------------------" rel="noopener" target="_blank"><em class="jc">【关】</em></a><em class="jc"/><a class="jd je ge" href="https://medium.com/u/1b89b21582d7?source=post_page-----23c95e428064--------------------------------" rel="noopener" target="_blank"><em class="jc">【戴瑞】</em></a><em class="jc"/><a class="jd je ge" href="https://medium.com/u/d02261f5687c?source=post_page-----23c95e428064--------------------------------" rel="noopener" target="_blank"><em class="jc">邢安</em> </a></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/8abbef130086f641753dc42c9a34161e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4bwCpS0yu15filjg6Hrq1A.png"/></div></div></figure><h1 id="e3b7" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">介绍</h1><p id="3b01" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">在Airbnb建筑服务系列的<a class="ae ku" rel="noopener" href="/airbnb-engineering/building-services-at-airbnb-part-1-c4c1d8fa811b">第1部分</a>、<a class="ae ku" rel="noopener" href="/airbnb-engineering/building-services-at-airbnb-part-2-142be1c5d506">第2部分</a>和<a class="ae ku" rel="noopener" href="/airbnb-engineering/building-services-at-airbnb-part-3-ac6d4972fc2d">第3部分</a>中，我们分享了我们如何围绕节俭服务IDL构建标准化服务平台，以鼓励和执行所有新服务的基础设施标准和工程最佳实践，而不会产生额外开销。</p><p id="adfe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然这种新的架构解决了一个庞大的代码库的一些基本问题，但它也带来了新的挑战，阻碍了工程生产率和质量。在这里我们很乐意分享一些我们在2019年出货的作品。</p></div><div class="ab cl kv kw go kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ha hb hc hd he"><h1 id="5307" class="jr js hh bd jt ju lc jw jx jy ld ka kb kc le ke kf kg lf ki kj kk lg km kn ko bi translated">为什么面向模式的基础设施对服务测试至关重要</h1><p id="87b3" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">在微服务架构中，API成为很多组件之间的边界和桥梁。它为服务提供者和消费者之间的交互定义了一个清晰的契约。我们观察到了一些关于微服务测试的挑战。</p><h2 id="cb1a" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated">1.突破API变化</h2><p id="de6b" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">在微服务架构中，修改API是一种常态。不幸的是，我们已经看到了一些由API变更引起的生产事故。从过去事故的尸检中引用一些话:</p><blockquote class="lv lw lx"><p id="12a4" class="ie if jc ig b ih ii ij ik il im in io ly iq ir is lz iu iv iw ma iy iz ja jb ha bi translated">“在部署相应的服务代码更改之前，添加新的数据字段破坏了列表可用性服务的API xxx。有问题的部署在错误激增后会自动回滚。”</p><p id="97cb" class="ie if jc ig b ih ii ij ik il im in io ly iq ir is lz iu iv iw ma iy iz ja jb ha bi translated">"只有在我们确定不再使用这些字段后，才应该弃用架构字段。然而，首先部署了删除xxx中使用的字段的更改，随后在xxx端没有gem升级。向后不兼容的更改中断了xxx服务。</p></blockquote><h2 id="a49c" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated">2.服务消费者缺乏可用的API模拟数据</h2><p id="df0f" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">API是<a class="ae ku" href="https://martinfowler.com/bliki/TestDouble.html" rel="noopener ugc nofollow" target="_blank">测试加倍</a>(生产对象的模仿、伪造、存根等)的热点，跨越不同的地方，如单元测试和集成测试。如果没有支持，工程师们会在不同的地方重复花费时间和精力来创建模拟数据、客户端和服务。</p><p id="6446" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这也导致工程师经历不必要的重量测试设置。例如，启动相关服务甚至虚拟数据库。这些沉重的努力会适得其反。测试应该是轻量级的，并且经常运行。</p><h2 id="b565" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated">3.缺乏对Mock语义正确性的保证</h2><p id="2266" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">除了前期成本之外，很难捕捉嘲讽数据的语义正确性，因为服务业务逻辑在不断发展，手动维护的测试数据很容易变得不同步。这导致测试随着时间的推移变得越来越没用。</p><h2 id="57b4" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated">4.缺乏对服务所有者的验证</h2><p id="d5ae" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">API是服务和它的消费者之间的边界。这是API按预期实现的最低要求。</p><p id="9955" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，如果没有框架级别的验证支持，服务所有者会发现他们自己很难针对他们的API端点设置验证，这可能与API消费者使用的验证集不同。</p><h2 id="59cf" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated">5.缺乏API测试质量的实时指标</h2><p id="b897" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">最后但同样重要的是，工程师对API测试覆盖率和测试数据质量几乎一无所知。对于API测试，没有等同于代码覆盖率的度量，代码覆盖率是一个广泛使用的度量，有助于测量单元测试的质量。</p><h2 id="f2c6" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated">6.最重要的是:以轻量级和可伸缩的方式进行测试</h2><p id="c6e4" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">鼓励工程师以单一风格构建测试是我们最不希望的。这种隐藏的巨大障碍将把我们带回起点:缓慢的测试、不可信的测试结果、紧密耦合，以及用微小的变化破坏数量惊人的测试。</p><p id="f7c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了以轻量级和可伸缩的方式应对上述挑战，我们发现服务模式是关键。</p><p id="c59a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">请注意，成功的测试故事需要很多关键的组成部分，组织层面的教育和最佳实践，可扩展的测试运行程序，持续集成基础设施(CI)，持续交付基础设施(CD)，测试环境，等等。</em> <strong class="ig hi"> <em class="jc">在这篇文章中，我们将只关注服务API测试的模式方面。</em> </strong></p></div><div class="ab cl kv kw go kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ha hb hc hd he"><h1 id="b0ad" class="jr js hh bd jt ju lc jw jx jy ld ka kb kc le ke kf kg lf ki kj kk lg km kn ko bi translated">服务所有者和消费者如何受益</h1><p id="ef98" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">在接下来的小节中，我们将深入探讨我们为服务API测试构建的面向模式的基础设施。我们为服务所有者和消费者构建了以下工具:</p><p id="fd1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">对于服务所有者:</strong></p><ol class=""><li id="2c4e" class="mb mc hh ig b ih ii il im ip md it me ix mf jb mg mh mi mj bi translated"><strong class="ig hi">静态API模式验证</strong>:自动向后兼容性检查&amp;模式链接器。尽可能早地捕捉突破性的API变更。大规模实施模式最佳实践</li><li id="3067" class="mb mc hh ig b ih mk il ml ip mm it mn ix mo jb mg mh mi mj bi translated"><strong class="ig hi"> API集成测试框架(AIT) </strong>:验证API端点行为，无需编写样板文件。它提供实时API集成测试覆盖度量</li></ol><p id="4acc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">对于服务消费者:</strong></p><ol class=""><li id="d0f1" class="mb mc hh ig b ih ii il im ip md it me ix mf jb mg mh mi mj bi translated"><strong class="ig hi"> API嘲讽框架:</strong>它在单元测试和轻量级集成测试中都透明地使用了接近真实世界的嘲讽API。不需要为上游服务创建模拟客户端或端点。</li><li id="ec66" class="mb mc hh ig b ih mk il ml ip mm it mn ix mo jb mg mh mi mj bi translated"><strong class="ig hi"> API集成测试框架(AIT): </strong>使用服务所有者使用的相同API模拟数据来确保语义与服务实现保持同步。</li></ol><p id="1d09" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们更深入地了解一下每个组件的工作原理。</p></div><div class="ab cl kv kw go kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ha hb hc hd he"><h1 id="ee7f" class="jr js hh bd jt ju lc jw jx jy ld ka kb kc le ke kf kg lf ki kj kk lg km kn ko bi translated">I .静态API模式验证</h1><p id="8d6f" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">静态API模式验证是我们构建的一个工具，用于自动检测错误的API模式更改:</p><ul class=""><li id="ee0f" class="mb mc hh ig b ih ii il im ip md it me ix mf jb mp mh mi mj bi translated">向后兼容性检查侧重于检测潜在的API突破性更改。</li><li id="405f" class="mb mc hh ig b ih mk il ml ip mm it mn ix mo jb mp mh mi mj bi translated">Schema Linter旨在加强我们的IDL最佳实践。</li></ul><p id="d817" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这两种检查非常相似，因为它们都需要为所有更改的模式构建和遍历抽象语法树(AST)。我们创建了一个linter二进制文件，可以很容易地插入到不同的构建系统中。(例如Java和Ruby)。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es mq"><img src="../Images/f9fcbbcc2edc90d7796fb45f336bc1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D92dBkFhAAl2k2Vv"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx">Figure: Flow charts that describe how Schema Validation works</figcaption></figure><p id="a494" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">检查本身的活动图如下所示。请注意，我们已经将两种检查合并到一个图表中，以更好地反映它们的差异。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es mv"><img src="../Images/e11e9e36c8485c84a732c89c5adf3b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*91IyUQAwkW6LK_1U"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx">Figure: Implementation of Schema Validation</figcaption></figure><p id="540c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了分析模式AST树的能力，现在我们能够捕获突破性的API变更以及不遵循我们的最佳实践的更新。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es mw"><img src="../Images/6b4bc0d846b3ea576f350c1121187cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R3lb-Uysz_VXbPEj"/></div></div></figure><h2 id="0dd6" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated">模式验证的好处</h2><p id="0315" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated"><strong class="ig hi"> 1。尽早发现突破性API变更</strong></p><p id="1d2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在自动化工具出现之前，这两种检查都是通过手工代码审查来进行的，这是不可伸缩的，并且可能会导致问题。</p><p id="411b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在有了静态模式验证，我们就能够检测坏的API更改，并在代码合并之前阻止它们(例如，字段类型更改、字段id更改)。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es mx"><img src="../Images/6385cea6a872225e3d8ebcaf8be0e8bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/0*wdNy7I2l1zaWo4Vc"/></div><figcaption class="mr ms et er es mt mu bd b be z dx">Figure: Dashboard of detected API breaking change</figcaption></figure><p id="8ffd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。大规模实施模式最佳实践</strong></p><p id="0e62" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们能够在无需人工干预的情况下实施API内部最佳实践。一个简单的例子是创建一个没有值的新枚举类型，这是一个定时炸弹:如果枚举名称和值无意中发生变化，就可能发生序列化错误。</p><p id="ad53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种错误很难在测试中检测出来，而且成本很高。由于静态模式验证，现在可以在CI中很早很容易地捕获它。</p></div><div class="ab cl kv kw go kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ha hb hc hd he"><h1 id="1626" class="jr js hh bd jt ju lc jw jx jy ld ka kb kc le ke kf kg lf ki kj kk lg km kn ko bi translated">二。基于模式的API数据工厂</h1><p id="7c9e" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">API数据工厂是一种机制，用于定义语言不可知的、<strong class="ig hi">模式验证的</strong>请求和响应装置，如yaml文件，以简化创建用于模拟和测试的API数据的<strong class="ig hi">繁琐的</strong>和<strong class="ig hi">易错的</strong>过程。</p><p id="7eb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果模式是一个API的轮廓，那么API数据工厂就是这个轮廓。它用有意义的数据来具体化API。它提供了两个基本功能:</p><ul class=""><li id="d361" class="mb mc hh ig b ih ii il im ip md it me ix mf jb mp mh mi mj bi translated">在单元测试和集成测试中模拟依赖服务API。</li><li id="af6d" class="mb mc hh ig b ih mk il ml ip mm it mn ix mo jb mp mh mi mj bi translated">使用具体化的API请求/响应验证API端点的正确性。</li></ul><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es my"><img src="../Images/c54c8ca4a736d55e15fd3a48a771b66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GBFVrK5vd3D7vFdZ"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx">Figure: With these fundamental abilities, we built frameworks that helps both API consumers and API producers</figcaption></figure><h2 id="e3cb" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated">夹具文件实现</h2><p id="50f3" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">每个API数据工厂fixture文件都与一个API端点相关联。为了对数据实施模式遵从性，这种关联至关重要。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es mz"><img src="../Images/f1a21bf10b61886bae4c9798a019bf5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yeOuOdrdheFOeZtx"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx">Figure: The structure of fixture files under a service</figcaption></figure><p id="8d7d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了让我们的读者对夹具数据有一个直观的理解，下面是一个简单的例子。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es na"><img src="../Images/d248c57b011958c4c7a89e9f4a91ede6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZU5oXqYf21ZKk_la"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx">Figure: simple example of what a fixture file looks like</figcaption></figure><h2 id="057c" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated">API数据工厂功能</h2><p id="e23f" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated"><strong class="ig hi"> 1。语言不可知且灵活</strong></p><p id="39a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它将与语言无关的API数据存储为yaml，可以嵌入到任何程序中，并由任何程序轻松使用。它还支持各种用途的扩展功能。(例如，共享夹具数据、灵活匹配、数据断言注释)</p><h2 id="2e5a" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated"><strong class="ak"> 2。自动化模式验证</strong></h2><p id="52c5" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">在每次API数据工厂更新时，验证可以在本地或CI中自动运行，以确保正确性。如果原始fixture数据的请求/响应不符合相应的模式，那么验证可以清楚地将错误精确到行和列。</p><p id="b04b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3。测试的共享API数据</strong></p><p id="11af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">手工制作用于测试的API数据对于服务所有者和客户来说都是困难和乏味的，尤其是当API数据被深度嵌套时。创建共享数据工厂有助于生产者和消费者之间的数据重用。</p><p id="fc3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 4。自动数据生成</strong></p><p id="81c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，我们构建了工具来基于匿名化的生产流量轻松生成夹具数据，从而消除任何手动数据创建并提高生产率。这也将有助于确保模拟数据示例具有真实的用途。</p><p id="b9c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 5。API测试数据质量指标</strong></p><p id="6670" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为数据工厂是基于模式的，我们可以潜在地测量API测试数据的质量，例如，有多少API字段被验证。这给了我们一种模拟数据充分性和API测试数据覆盖的感觉。</p></div><div class="ab cl kv kw go kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ha hb hc hd he"><h1 id="5162" class="jr js hh bd jt ju lc jw jx jy ld ka kb kc le ke kf kg lf ki kj kk lg km kn ko bi translated">三。API模拟框架</h1><p id="8a1c" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">API Mocking Framework是嵌入在核心服务框架k中的组件<strong class="ig hi">，它提供<strong class="ig hi">模拟的接近真实世界的API交互</strong>作为测试中真实服务的替代。</strong></p><p id="99b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它用在这两个地方:</p><ul class=""><li id="2ae3" class="mb mc hh ig b ih ii il im ip md it me ix mf jb mp mh mi mj bi translated">单元测试:<a class="ae ku" href="https://en.wikipedia.org/wiki/White-box_testing" rel="noopener ugc nofollow" target="_blank">白盒测试</a>一段包含调用依赖服务API的逻辑，没有设置它的依赖服务。</li><li id="7194" class="mb mc hh ig b ih mk il ml ip mm it mn ix mo jb mp mh mi mj bi translated">浅层集成测试:<a class="ae ku" href="https://en.wikipedia.org/wiki/Black-box_testing" rel="noopener ugc nofollow" target="_blank">黑盒测试</a>一个服务，不设置它的依赖服务。</li></ul><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es nb"><img src="../Images/d1b4e92d5e6e9282afab8448c410b0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O5EM__ANgzNTj4To"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx">Figure: How API Mocking is utilized in various kind of tests</figcaption></figure><h2 id="15a7" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated">API模拟框架特性</h2><p id="a911" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated"><strong class="ig hi"> 1。无处不在的API模仿:客户端还是服务端</strong></p><p id="abce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了嵌入模拟客户端之外，您还可以在“模拟模式”下与一个活动的服务应用程序进行交互，以一种可靠而廉价的方式获得假的API数据。</p><p id="ab51" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当RPC客户端不可用时，通常需要这种交互。例如，在前端/移动领域，模拟数据可以用来测试页面渲染，而不是经历一系列实时API调用的痛苦。</p><p id="eb4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">无论何时需要API模拟(单元测试或集成测试)，都不需要创建假的客户端或假的服务。测试程序可以与内部自动生成的RPC客户端进行交互，就好像它正在进行真正的服务调用一样。模拟模式是在带有配置标志或请求上下文标头的情况下启用的。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es nc"><img src="../Images/afa13bd3be004aebdcb3c0ef19f0b4fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6O-YYbAc_HIRXpzy"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx">Figure: The API Mocking transparently wrap both RPC client and Service API Layer, such that mocking can be enabled anywhere</figcaption></figure><p id="4a95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。浅层集成测试的依赖性隔离</strong></p><p id="0eba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了再次强调我们的目标，我们试图避免在我们的微服务架构中隐藏一块巨石:当测试一个服务时，我们不想测试服务本身之外的组件。我们称之为浅层整合测试。</p><p id="081c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">API Mocking框架为依赖隔离提供了一个干净的解决方案。它目前被用在诸如功能集成测试或隔离负载测试的地方，以捕捉单个服务中可能的回归。</p><p id="3852" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3。所需的各种模拟选项</strong></p><p id="b2e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">模仿模式可以通过config或HTTP头打开。</p><ul class=""><li id="0def" class="mb mc hh ig b ih ii il im ip md it me ix mf jb mp mh mi mj bi translated"><strong class="ig hi">匹配</strong>:当模拟模式开启时，从用户的角度来看，与真实服务交互是一样的。在幕后，mocking框架将找到第一个符合提交的请求的超集的fixture请求。</li><li id="9c9d" class="mb mc hh ig b ih mk il ml ip mm it mn ix mo jb mp mh mi mj bi translated"><strong class="ig hi">stub</strong>:在提交请求之前，您可以stub应该返回哪个fixture响应。</li><li id="9231" class="mb mc hh ig b ih mk il ml ip mm it mn ix mo jb mp mh mi mj bi translated"><strong class="ig hi">延迟模拟</strong>:您可以为每个模拟交互配置一个模拟延迟峰值。</li></ul></div><div class="ab cl kv kw go kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ha hb hc hd he"><h1 id="abc6" class="jr js hh bd jt ju lc jw jx jy ld ka kb kc le ke kf kg lf ki kj kk lg km kn ko bi translated">四。API集成测试框架(AIT)</h1><h2 id="7ecc" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated">什么是AIT？</h2><p id="5d1b" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">API集成测试框架(AIT)是一个框架，<strong class="ig hi">允许服务在生产环境<strong class="ig hi">中使用预定义的测试数据</strong>来验证自己，而无需编写样板文件，</strong>并且<strong class="ig hi">确保模拟数据</strong>的语义正确性。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es nd"><img src="../Images/a7e2788d248675bd5815f8216932b5ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1ZmxXcKJLkttB7wD"/></div></div><figcaption class="mr ms et er es mt mu bd b be z dx">Figure: work flow of AIT</figcaption></figure><p id="3dbc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简单的流程如下所示:</p><ol class=""><li id="ff2e" class="mb mc hh ig b ih ii il im ip md it me ix mf jb mg mh mi mj bi translated">服务所有者定义了一些配置，这些配置将验证与预定义的测试数据(在API数据工厂中定义)相关联</li><li id="ec14" class="mb mc hh ig b ih mk il ml ip mm it mn ix mo jb mg mh mi mj bi translated">目标运行服务将公开一个API验证网关作为系统端点，它将路由到相应的自动生成的端点验证请求。</li></ol><h2 id="cf48" class="lh js hh bd jt li lj lk jx ll lm ln kb ip lo lp kf it lq lr kj ix ls lt kn lu bi translated">AIT的好处</h2><p id="27a6" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated"><strong class="ig hi"> 1。无需编写样板代码即可验证生产者服务</strong></p><p id="8ca0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据<a class="ae ku" href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html" rel="noopener ugc nofollow" target="_blank">测试金字塔</a>，服务端点正确性是其他复杂端到端测试的基础。理想情况下，在这个模式驱动的世界中，测试API端点所需的干净信息应该仅仅是纯API测试数据表示，没有额外的测试设置开销。因此，</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es ne"><img src="../Images/05db6583330ead5666e5b3e4467b4b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFbS4ZmOxmhZ1wuQJMCg9g.png"/></div></div></figure><p id="c52d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，在生产者服务验证中，依赖关系仍然可以作为一个选项被模拟出来。因此，我们可以用一种超级轻量级的方式进行端点验证。</p><p id="0c35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。模拟数据经过语义验证</strong></p><p id="0025" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过利用API数据工厂，可以重用为单元测试或其他模拟场景定义的相同测试数据。</p><p id="37e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同时，生产者服务使用嵌入断言逻辑的相同预定义测试数据来验证自己，这进一步确保了语义和逻辑的正确性。如果在部署管道中捕获到意外的实时响应，提供者服务将被锁定部署，直到问题得到解决。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es nf"><img src="../Images/ad546d0aaa52404c4aa2dfed0291afac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/0*F9YbdqEB3KRhwmR-"/></div><figcaption class="mr ms et er es mt mu bd b be z dx">Figure: A simplified example of AIT</figcaption></figure><p id="38b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这样的机制帮助我们一举两得:</p><ul class=""><li id="153b" class="mb mc hh ig b ih ii il im ip md it me ix mf jb mp mh mi mj bi translated">在上面的fixture响应中，带注释的字段总是有效的，并且服从断言，这使得这段数据对于模仿目的总是有效的。</li><li id="2dbc" class="mb mc hh ig b ih mk il ml ip mm it mn ix mo jb mp mh mi mj bi translated">在真实的响应中，同样的断言逻辑也必须通过，这使得它在生产和模拟之间保持一致。</li></ul><p id="99e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3。提供实时API测试覆盖工具</strong></p><p id="37e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">AIT instruments real time API Test Coverage metrics不需要手动和重复编译，不仅可以帮助人们了解他们测试的实时健康状况，还可以为提供商服务团队成员提供清晰的见解和激励，以提高他们的API测试覆盖率。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es ng"><img src="../Images/60f31af48b588cad36d6263d96ad1001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GoYPpMIa55JVpHAc"/></div></div></figure><p id="5ff7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面是Airbnb的一个团队的真实例子，在这里我们可以看到实时统计数据和一个超清晰的轨迹，以实现更好的API测试覆盖率。有了这样的工具，我们不仅可以清楚地了解哪些服务，还可以了解哪些端点在不同的环境中正确地工作。</p><p id="85fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 4。可插拔性和轻量级</strong></p><p id="652f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于其轻量级和独立的性质，AIT可以很容易地与不同CI/CD阶段的测试跑步者集成。这样的抽象使得API验证与外部世界的耦合更少，并且使得我们的基础设施的其他部分更容易发展。</p></div><div class="ab cl kv kw go kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ha hb hc hd he"><h1 id="9c31" class="jr js hh bd jt ju lc jw jx jy ld ka kb kc le ke kf kg lf ki kj kk lg km kn ko bi translated">总结与展望</h1><p id="31da" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">强类型模式为我们构建有效的API端点测试基础设施提供了关键的杠杆点。它通过共享API测试数据和API逻辑来连接服务提供者和服务消费者，使API测试更加准确、有意义和减少冗余。</p></div><div class="ab cl kv kw go kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ha hb hc hd he"><h1 id="4425" class="jr js hh bd jt ju lc jw jx jy ld ka kb kc le ke kf kg lf ki kj kk lg km kn ko bi translated">欣赏</h1><p id="c088" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">感谢、肖恩·亚伯拉罕、哈维·拉米雷斯、曾小涵、艾哈迈德·哈利法、乔伊·叶、詹姆斯·奥斯特罗夫斯基以及所有人一路走来的支持！</p></div></div>    
</body>
</html>