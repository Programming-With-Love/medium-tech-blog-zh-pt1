<html>
<head>
<title>JWT Access and Refresh Token with Vapor 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Vapor 3的JWT访问和刷新令牌</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/jwt-access-and-refresh-token-with-vapor-3-85a0aee5291b?source=collection_archive---------1-----------------------#2019-01-30">https://medium.com/quick-code/jwt-access-and-refresh-token-with-vapor-3-85a0aee5291b?source=collection_archive---------1-----------------------#2019-01-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/75bff07826fa2f56a1a47c09bdf0c5d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjbLGOCV1IjBPKF8TUCbcA.jpeg"/></div></div></figure><h1 id="e365" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="4d9e" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们经常需要识别向服务器发送请求的用户，我们还需要确保客户端-服务器信息传输的安全性。这就是接入令牌帮助我们的地方，特别是在JWT。</p><blockquote class="kl km kn"><p id="73e2" class="jn jo ko jp b jq kp js jt ju kq jw jx kr ks ka kb kt ku ke kf kv kw ki kj kk ha bi translated"><strong class="jp hi"> JSON Web令牌(JWT) </strong>是基于JSON格式创建访问令牌的开放标准(RFC 7519)。通常，它用于在客户机-服务器应用程序中传输授权数据。令牌由服务器创建，用秘密密钥签名并传送给客户机，客户机随后使用这个令牌来确认其身份。</p></blockquote><p id="8a3c" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">为了充分的安全，我们的JWT应该有一个有限的生命周期，为了它的更新，用户必须能够确认他的真实性。在本文中，我们将研究如何在不将用户数据存储在客户机上的情况下做到这一点。</p><p id="9e57" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">我们将不详细讨论JWT，因为这超出了本文的范围。推荐阅读<a class="ae kx" rel="noopener" href="/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec"> <strong class="jp hi">这篇文章</strong> </a>来熟悉JWT。</p><h1 id="c483" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">认证和授权</h1><p id="761e" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">首先，让我们突出两个概念:<strong class="jp hi">认证</strong>和<strong class="jp hi">授权</strong>。</p><p id="63c3" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated"><strong class="jp hi">认证</strong>它是对用户凭证(通常是一个登录/密码对)的验证。</p><p id="96ea" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated"><strong class="jp hi">授权</strong> —授予某个人或某组人执行某些操作的权利，即检查用户是否有权访问特定资源的程序。</p><p id="ea0d" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">通常，身份验证和授权过程如下:</p><ol class=""><li id="e6fb" class="ky kz hh jp b jq kp ju kq jy la kc lb kg lc kk ld le lf lg bi translated">用户向服务器发送他的数据(登录/密码)。<em class="ko">认证过程</em>。</li><li id="3c91" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">如果数据正确，服务器会为用户生成一个JWT令牌，其中包含必要的数据(权限、ID、令牌生命周期)。</li><li id="2145" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">用户用收到的令牌向服务器发送请求。</li><li id="c22b" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">服务器根据令牌中的数据(权限、生存期)决定是否授予用户访问权限。<em class="ko">授权流程</em>。</li></ol><h1 id="2a1f" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">刷新令牌</h1><p id="5086" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">为了不存储用户数据并且仍然能够更新JWT，我们将得到一个新概念的帮助，例如<strong class="jp hi">刷新令牌</strong>。认证令牌将被称为<strong class="jp hi">访问令牌</strong>。<em class="ko">更新访问令牌</em>的第二个令牌是<strong class="jp hi">刷新令牌</strong>。我们将把它保存在客户端，而不是登录/密码对。</p><p id="dcaa" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">一般来说，<strong class="jp hi">刷新令牌</strong>比<strong class="jp hi">访问令牌</strong>寿命要长得多，比如一两个月。在我的一个项目中，刷新令牌的生命周期是60天。</p><p id="562b" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">我们会将刷新令牌存储在数据库中，并在客户端想要更新其访问令牌时立即对其进行验证。它本身是一个随机生成的字符串(例如lxd 6 bj 7 w 33 gex 1 gosgzczwnsmskaaumpwgg 6um)。</p><p id="e3ed" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">让我们更详细地看看更新算法。</p><h1 id="c50f" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">访问令牌更新</h1><ol class=""><li id="66e7" class="ky kz hh jp b jq jr ju jv jy lm kc ln kg lo kk ld le lf lg bi translated">通过发送登录名/密码对对客户端进行身份验证。</li><li id="6e1c" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">如果成功，服务器将创建新的访问令牌和刷新令牌。<strong class="jp hi">刷新令牌伴随着他一生的时间被记录在数据库里。</strong></li><li id="8acb" class="ky kz hh jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">服务器以如下形式向客户端发送响应:</li></ol><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="4d62" class="ly iq hh lu b fi lz ma l mb mc">{<br/>    "expired_at": ...,<br/>    "access_token": ...,<br/>    "refresh_token": ...<br/>}</span></pre><p id="d471" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">4.客户端保存这些数据。</p><p id="4580" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">5.对于每个请求，客户端检查访问令牌是否过期。如果访问令牌没有过期，它只是使用它发送请求。</p><p id="b74e" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">6.对于更新，客户端发送一个<strong class="jp hi">刷新令牌</strong>到一个特别定义的端点。(例如<code class="du md me mf lu b">/v1/account/refresh-token</code>)</p><p id="192c" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">7.服务器检查刷新令牌，该令牌位于发送的数据库中。还有，检查过期与否。</p><p id="b359" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">8.如果刷新令牌过期，或者在数据库中没有找到，那么我们向客户端返回一个<strong class="jp hi"> 401错误</strong>，以便通过<strong class="jp hi">认证</strong>。</p><p id="6cda" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">9.如果发现刷新令牌并且它仍然相关，则<strong class="jp hi">创建新的访问令牌</strong>并且<strong class="jp hi">更新刷新令牌</strong>。我们按照第3段发送这些数据。</p><p id="7ae0" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">10.现在，客户端可以继续使用新的访问令牌执行请求。</p><h1 id="8a6c" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">履行</h1><p id="d698" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">考虑在Vapor 3上的具体实现。</p><h2 id="6f59" class="ly iq hh bd ir mg mh mi iv mj mk ml iz jy mm mn jd kc mo mp jh kg mq mr jl ms bi translated">项目设置</h2><p id="f2e6" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我创建并设置了一个启动项目。这里 下载<a class="ae kx" href="https://github.com/timbaev/TokensTutorial" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi">。</strong></a></p><figure class="lp lq lr ls fd ii er es paragraph-image"><div class="er es mt"><img src="../Images/95125860a7abc8fc382dabac27b7860b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*CDq3dFHiDHZvrPUqGioljw.png"/></div><figcaption class="mu mv et er es mw mx bd b be z dx">Project Structure</figcaption></figure><p id="252c" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">文件夹<em class="ko">配置</em>包含项目设置。<em class="ko">启动</em>文件夹中有标准的Vapor文件。<code class="du md me mf lu b">ProjectServices.swift</code>包含项目中使用的服务类的实例。</p><p id="76d8" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated"><em class="ko">控制器</em>文件夹包含控制器本身，它们在请求时被调用。</p><p id="a097" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">项目中有两种ORM SQLite数据库模型:<em class="ko"> Todo </em>和<em class="ko"> User </em>。该想法将是用户可以注册，并在认证后将接收<strong class="jp hi">访问和刷新令牌</strong>。有了这个令牌，用户可以创建、获取或删除他的待办事项。<em class="ko">用户</em>和<em class="ko">待办事项</em>是一对多的关系。也就是说，一个用户可能有几个待办事项。</p><p id="9cb9" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">在<em class="ko"> DTO </em>(数据传输对象)文件夹中包含向响应体传输数据的模型。它们不应该包含任何业务逻辑。<em class="ko">响应</em>模型只响应任何消息。</p><p id="3956" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">在<em class="ko"> Services </em>文件夹中，我们存储了我们所有的服务，其中包含了主要的业务逻辑。JSON比XML更容易使用，也更容易阅读。因此，初学者可以利用<a class="ae kx" href="https://blog.coursesity.com/best-json-tutorials/" rel="noopener ugc nofollow" target="_blank">最佳JSON教程</a>。</p><h2 id="45a2" class="ly iq hh bd ir mg mh mi iv mj mk ml iz jy mm mn jd kc mo mp jh kg mq mr jl ms bi translated">创建JWT访问令牌</h2><p id="bcc5" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们需要的下一步是在认证之后，用户可以获得他们的访问令牌。</p><p id="c36b" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">为此，让我们在<em class="ko"> App </em>文件夹中创建<em class="ko"> Tools </em>文件夹。在<em class="ko">工具</em>文件夹本身中，创建另一个<em class="ko"> JWT </em>文件夹。结果是以下结构:</p><figure class="lp lq lr ls fd ii er es paragraph-image"><div class="er es my"><img src="../Images/7264ecc72c0bb17a1498ea839be36a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*g0P3PHOQWIN7D9NaVqtvSQ.png"/></div><figcaption class="mu mv et er es mw mx bd b be z dx">Creating a JWT folder</figcaption></figure><p id="a559" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">创建一个文件<code class="du md me mf lu b">JWTConfig.swift</code>，其内容将如下:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="07e5" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">这是我们的JWT访问令牌的基本配置。</p><p id="ae53" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">我们还需要处理与JWT相关的错误。为此，我们将使用已经存在的JWTError类。在一个新文件<code class="du md me mf lu b">JWTErrorExtensions.swift</code>中为它写一个<em class="ko">扩展名</em>:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="d2da" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">用以下内容创建一个<code class="du md me mf lu b">AccessTokenPayload.swift</code>文件:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="3c14" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">有效载荷是JWT的公共参数，将以base64编码。此外，JWTPayload需要实现<code class="du md me mf lu b">verify(signer:)</code>方法，如果我们的令牌不再有效，就会抛出异常。在我们的例子中，我们只检查令牌是否过期(您也可以检查<em class="ko">发布者</em>是否正确)。</p><p id="658e" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">要使用JWT，创建一个单独的类— <em class="ko"> TokenHelpers </em>:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="ccc3" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">有了这个助手，我们可以创建一个新的JWT访问令牌，找出令牌的过期时间，验证并获得用户ID。</p><p id="3903" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">要发送新令牌，在<em class="ko">模型/DTO </em>文件夹中创建一个<em class="ko">访问</em>模型:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="fa56" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">很好，现在我们已经为创建新令牌做好了一切准备。在<code class="du md me mf lu b">DefaultUserService.swift</code>上增加<code class="du md me mf lu b">signIn(request:, user:)</code>功能:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="bb21" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">我们正在通过登录寻找用户，如果成功，我们用一个特殊的函数<code class="du md me mf lu b">digest.verify(_, created:)</code>检查我们的散列密码，然后我们向我们的客户端发布一个新的访问令牌及其到期时间。</p><h2 id="0f72" class="ly iq hh bd ir mg mh mi iv mj mk ml iz jy mm mn jd kc mo mp jh kg mq mr jl ms bi translated">使用访问令牌</h2><p id="c9c9" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">为了让控制器中的每个请求不要每次都检查令牌是否有效，我们将创建自己的<em class="ko">中间件</em>。来自官方文件:</p><blockquote class="kl km kn"><p id="7b89" class="jn jo ko jp b jq kp js jt ju kq jw jx kr ks ka kb kt ku ke kf kv kw ki kj kk ha bi translated"><strong class="jp hi">中间件</strong>放在服务器和你的路由器之间。它能够改变传入的请求和传出的响应。<strong class="jp hi">中间件</strong>可以选择将请求传递给链中的下一个<strong class="jp hi">中间件</strong>，或者如果需要，它们可以短路并返回自定义的“响应”。</p></blockquote><p id="bde0" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">在请求到达控制器之前，我们验证报头中的令牌是否有效，否则，我们只是返回一个错误，让客户端知道令牌不再有效。</p><p id="8dce" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">在JWT文件夹中，创建一个<code class="du md me mf lu b">JWTMiddleware.swift</code>文件:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="d2e2" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">一切都很简单:我们检查令牌的可用性并验证它(检查令牌是否过期)。如果出现错误，我们将向客户端返回一个带有描述的错误。</p><p id="38a2" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">一个<code class="du md me mf lu b">extension Request</code>来获得一个令牌和一个授权用户也很有用(你可以把它放在<em class="ko">工具/扩展</em>):</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="d966" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">现在，让我们创建一切必要的东西，以便用户可以创建、获取或删除待办事项。</p><p id="c011" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">为此，创建<code class="du md me mf lu b">TodoDto.swift</code> ( <em class="ko">模型/DTO </em>):</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="df32" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">创建一个服务，它将包含我们处理Todo notes的业务逻辑，并用协议(<em class="ko"> Services/TodoService </em>)覆盖它:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="d470" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">更新<code class="du md me mf lu b">TodoController.swift</code>:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="ccf2" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">注意路由器的创建:<code class="du md me mf lu b">let group = router.grouped("v1/todo").grouped(JWTMiddleware())</code>。这里我们指定了端点的公共基路径，还添加了<strong class="jp hi"> JWTMiddleware </strong>，即该组的所有请求都将通过令牌的<em class="ko">验证。</em></p><p id="949c" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">将我们的新服务添加到<code class="du md me mf lu b">ProjectServices.swift</code>:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="c162" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">并更新<code class="du md me mf lu b">routes.swift</code>:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="59c3" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">太好了，现在我们可以构建一个项目，并检查一切工作正常！</p><p id="d842" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">我们通过认证(<code class="du md me mf lu b">v1/account/sign-in</code>)，作为响应，我们得到我们的<strong class="jp hi">访问令牌</strong>(如果没有用户，您可以使用端点<code class="du md me mf lu b">/v1/account/sign-up</code>创建它):</p><figure class="lp lq lr ls fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nb"><img src="../Images/18ad9aa4664a216c967af450a3ea5b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6wyqHZ7yFoDNbjHi_-RqQ.png"/></div></div></figure><p id="87fe" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">将我们的令牌复制并粘贴到<em class="ko">授权</em>头中:</p><figure class="lp lq lr ls fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nb"><img src="../Images/5d32e8dc465675e0779dd099494076d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYt2h-3N2ncPo6667HyObQ.png"/></div></div></figure><p id="0b17" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">之后，我们已经可以从授权用户那里创建、获取或删除待办事项:</p><figure class="lp lq lr ls fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nb"><img src="../Images/915e7d8b63d1cff86ed750f3f3acd9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GY6tDWsM5QjwGDTrZoYpNw.png"/></div></div></figure><figure class="lp lq lr ls fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nb"><img src="../Images/a615b0df335efaf7a64b2a8b5b86b015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DCkEoFkYbjqc36dJHx5-HQ.png"/></div></div></figure><p id="b863" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">很好，但是过了一会儿，您会得到一个错误:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="d17a" class="ly iq hh lu b fi lz ma l mb mc">{<br/>    "error": true,<br/>    "reason": "JWT verification failed"<br/>}</span></pre><p id="18e3" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">不幸的是，我们的<strong class="jp hi">访问令牌</strong>过期了，我们不再能够访问我们的待办事项(我提醒您，您可以设置一个更长的访问令牌生命周期，对于本课来说，这个时间只有100秒)。为此，我们需要重新通过认证过程。等等，不不，我们还有… <strong class="jp hi">刷新令牌！</strong></p><h2 id="1a98" class="ly iq hh bd ir mg mh mi iv mj mk ml iz jy mm mn jd kc mo mp jh kg mq mr jl ms bi translated">正在创建刷新令牌</h2><p id="b372" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">为此向<em class="ko"> TokenHelpers </em>类添加一个新函数:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="87d3" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">这个函数尽可能简单:它从变量<code class="du md me mf lu b">letters</code>中生成一个长度为40的随机字符字符串。</p><p id="0cb1" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">现在您需要创建一个模型，我们将在其中存储用户的刷新令牌(一个用户可能有几个刷新令牌):</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="c452" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">向<em class="ko">用户</em>模型添加一个关系:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="a02e" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">很好，现在登录时，我们需要创建并向客户端提供访问和刷新令牌。更新我们的<em class="ko">访问到</em>:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div><figcaption class="mu mv et er es mw mx bd b be z dx">Added new field “refreshToken”</figcaption></figure><p id="d200" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">好了，现在我们的<code class="du md me mf lu b">signIn</code>函数将看起来像这样(向响应添加了刷新标记，并将其保存在数据库中):</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="62c8" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">不要忘记将模型迁移添加到<code class="du md me mf lu b">configure.swift</code>:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="a830" class="ly iq hh lu b fi lz ma l mb mc">migrations.add(model: RefreshToken.<strong class="lu hi">self</strong>, database: .sqlite)</span></pre><p id="f734" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">现在签到可以返回<strong class="jp hi">刷新令牌！还有待学习如何使用它来更新<strong class="jp hi">访问令牌</strong>。</strong></p><figure class="lp lq lr ls fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nc"><img src="../Images/7a92b0ed417ee02f3118c88e5336b282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tToNQvm-lkli1GnIY_8IdQ.png"/></div></div></figure><h2 id="7785" class="ly iq hh bd ir mg mh mi iv mj mk ml iz jy mm mn jd kc mo mp jh kg mq mr jl ms bi translated">使用刷新令牌</h2><p id="8474" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">添加一个新函数来更新我们的令牌:</p><figure class="lp lq lr ls fd ii"><div class="bz dy l di"><div class="mz na l"/></div></figure><p id="395b" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">一切都很简单——我们在数据库中寻找带有刷新令牌的模型，否则，我们返回状态<em class="ko"> unauthorized </em>(为了通知客户端需要再次通过身份验证)。接下来，我们检查我们的刷新令牌是否过期，如果成功，在数据库中创建一个<strong class="jp hi">新访问</strong>和<strong class="jp hi">更新刷新令牌</strong>(也不要忘记日期)。</p><p id="71df" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">如果我们的刷新令牌已经过期，那么将其从数据库中删除，并将状态返回给客户端<em class="ko">未授权</em>。</p><p id="4131" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">不要忘记在协议中添加新方法:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="88cc" class="ly iq hh lu b fi lz ma l mb mc"><strong class="lu hi">protocol</strong> UserService {</span><span id="8f40" class="ly iq hh lu b fi nd ma l mb mc"><strong class="lu hi">...</strong></span><span id="57e9" class="ly iq hh lu b fi nd ma l mb mc"><strong class="lu hi"><em class="ko">    func</em></strong><em class="ko"> refreshToken(request: Request, refreshTokenDto: RefreshTokenDto) </em><strong class="lu hi"><em class="ko">throws</em></strong><em class="ko"> -&gt; Future&lt;AccessDto&gt;</em></span><span id="bd92" class="ly iq hh lu b fi nd ma l mb mc">}</span></pre><p id="2b7d" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">向<em class="ko">用户控制器</em>添加新功能:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="786e" class="ly iq hh lu b fi lz ma l mb mc"><strong class="lu hi">func</strong> refreshToken(<strong class="lu hi">_</strong> requets: Request, refreshTokenDto: RefreshTokenDto) <strong class="lu hi">throws</strong> -&gt; Future&lt;AccessDto&gt; {</span><span id="1e31" class="ly iq hh lu b fi nd ma l mb mc"><strong class="lu hi">    return</strong> <strong class="lu hi">try</strong> <strong class="lu hi">self</strong>.userService.refreshToken(request: requets, refreshTokenDto: refreshTokenDto)</span><span id="b46c" class="ly iq hh lu b fi nd ma l mb mc">}</span></pre><p id="c04c" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">注册端点以在<code class="du md me mf lu b">boot</code>函数中更新令牌:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="2b44" class="ly iq hh lu b fi lz ma l mb mc"><strong class="lu hi">func</strong> boot(router: Router) <strong class="lu hi">throws</strong> {</span><span id="4e70" class="ly iq hh lu b fi nd ma l mb mc"><strong class="lu hi">    let</strong> group = router.grouped("v1/account")</span><span id="907e" class="ly iq hh lu b fi nd ma l mb mc">    ...</span><span id="6faa" class="ly iq hh lu b fi nd ma l mb mc">    group.post(RefreshTokenDto.<strong class="lu hi">self</strong>, at: "/refresh-token", use: <strong class="lu hi">self</strong>.refreshToken)</span><span id="3df7" class="ly iq hh lu b fi nd ma l mb mc">}</span></pre><p id="09d6" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">经过身份验证后，我们保存从JSON响应中收到的刷新令牌:</p><pre class="lp lq lr ls fd lt lu lv lw aw lx bi"><span id="54ef" class="ly iq hh lu b fi lz ma l mb mc">{<br/>    "accessToken": "...",<br/>    "refreshToken": "<strong class="lu hi">AS3GZB6z59YVoJ0CLOKVzWWktxNE6SBAgTMr1K86l</strong>",<br/>    "expiredAt": "..."<br/>}</span></pre><p id="d5eb" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">现在，在我们的<em class="ko">访问令牌</em>到期后，我们可以使用端点<code class="du md me mf lu b">/v1/account/refresh-token</code>上的<em class="ko">刷新令牌</em>来更新它:</p><figure class="lp lq lr ls fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nb"><img src="../Images/c83ee51981e55065365723380345aee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vniZ1JV5OJyP1xIV7ucrVw.png"/></div></div></figure><p id="8111" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">完美！现在我们可以更新我们的<strong class="jp hi">访问令牌</strong>而不用存储用户数据！</p><h1 id="0924" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论</h1><p id="9260" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这种使用<strong class="jp hi">访问+刷新令牌</strong>的方案保证了攻击者无法发现用户的数据。</p><p id="657f" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">此外，为了提高安全性，您可以创建一个被阻止或被盗令牌的黑名单。并对存储进行优化，定期从数据库中清除过期的<strong class="jp hi">刷新令牌</strong>。</p><p id="e370" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">就这些，如果你有任何补充或建议，我随时欢迎讨论，请在评论中提问！</p><p id="fcca" class="pw-post-body-paragraph jn jo hh jp b jq kp js jt ju kq jw jx jy ks ka kb kc ku ke kf kg kw ki kj kk ha bi translated">这个项目的最终版本可以在这里找到:<a class="ae kx" href="https://github.com/timbaev/TokensTutorialFinal" rel="noopener ugc nofollow" target="_blank">https://github.com/timbaev/TokensTutorialFinal</a></p></div></div>    
</body>
</html>