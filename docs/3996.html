<html>
<head>
<title>RFC-6902 based HTTP Patch Operation on JSON Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于RFC-6902的对JSON对象的HTTP补丁操作</h1>
<blockquote>原文：<a href="https://medium.com/globant/rfc-6902-based-http-patch-operation-on-json-objects-4babab66079c?source=collection_archive---------0-----------------------#2022-09-27">https://medium.com/globant/rfc-6902-based-http-patch-operation-on-json-objects-4babab66079c?source=collection_archive---------0-----------------------#2022-09-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e60fd6b71ba16d665db7c7ff65dc8116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k1FIziobI593FyJM"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@gustavocpo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">gustavo Campos</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6e48" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">简介:</strong> <br/> <em class="js">超文本传输协议(HTTP) </em>定义了一组请求方法，也称为<em class="js"> HTTP动词</em>，用于指示要对给定资源执行的预期操作。一些最常见的方法有<code class="du jt ju jv jw b"><a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET" rel="noopener ugc nofollow" target="_blank">GET</a></code>、<code class="du jt ju jv jw b"><a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT" rel="noopener ugc nofollow" target="_blank">PUT</a></code>、<code class="du jt ju jv jw b"><a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" rel="noopener ugc nofollow" target="_blank">POST</a></code>和<code class="du jt ju jv jw b"><a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE" rel="noopener ugc nofollow" target="_blank">DELETE</a></code>。虽然大多数软件工程师都很清楚这四种方法的特点，但有时我们需要超越，比如使用<code class="du jt ju jv jw b"><a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH" rel="noopener ugc nofollow" target="_blank">PATCH</a></code>、<code class="du jt ju jv jw b"><a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD" rel="noopener ugc nofollow" target="_blank">HEAD</a></code>等方法。</p><p id="cbf2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> HTTP补丁操作:<br/></strong>HTTP<code class="du jt ju jv jw b">PUT</code>方法是用一个完整的新体覆盖一个资源，不能用来做局部的改动。为了克服这个限制并对资源进行部分修改，HTTP <code class="du jt ju jv jw b">PATCH</code>请求方法被引入到<a class="ae it" href="https://www.rfc-editor.org/rfc/rfc5789" rel="noopener ugc nofollow" target="_blank"> RFC 5789 </a>中。</p><p id="1dbc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">HTTP <code class="du jt ju jv jw b">PATCH</code>自动执行请求的更改。这意味着如果服务器不能满足所有请求的更改，它不会修改目标实体。</p><p id="5a1e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> PUT vs PATCH困境:</strong> <br/>根据定义，<code class="du jt ju jv jw b">PUT</code>方法用请求负载替换目标资源的所有当前表示，而<code class="du jt ju jv jw b">PATCH</code>方法对资源应用部分修改。可以理解的是，<code class="du jt ju jv jw b">PUT</code>和<code class="du jt ju jv jw b">PATCH</code>都有点类似于<a class="ae it" href="https://developer.mozilla.org/en-US/docs/Glossary/CRUD" rel="noopener ugc nofollow" target="_blank"> CRUD </a>中的<strong class="iw hi"> <em class="js"> update </em> </strong>概念，但主要区别在于:<code class="du jt ju jv jw b">PATCH</code>请求被认为是一组关于如何修改资源的<strong class="iw hi"> <em class="js">指令</em> </strong>。这与<code class="du jt ju jv jw b">PUT</code>形成对比；这是一个资源的完整<strong class="iw hi"> <em class="js">表示</em> </strong>。</p><p id="e67d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> RFC-6902: </strong> <br/>互联网上有无数例子说明如何以简单的方式使用<code class="du jt ju jv jw b">PATCH</code>操作。但是特别地，当我们谈论修改JSON资源时，我们经常忽略下面的事实:</p><blockquote class="jx jy jz"><p id="2ad9" class="iu iv js iw b ix iy iz ja jb jc jd je ka jg jh ji kb jk jl jm kc jo jp jq jr ha bi translated">然而，对于<code class="du jt ju jv jw b"><em class="hh">PATCH</em></code>，封闭的实体<strong class="iw hi">包含一组指令</strong>，描述当前驻留在原始服务器上的资源应该如何被修改以产生新版本。</p></blockquote><p id="1c06" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简而言之，RFC-5789指出，在请求体中，我们需要指定一组操作或指令来修改当前资源。那么我们如何在请求体中设置动作呢？应该怎么格式化？</p><p id="ee39" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这正是RFC-6902来救援的地方。该规范讨论了如何使用<strong class="iw hi"> JSON补丁</strong>格式发送<strong class="iw hi"> <em class="js">指令集</em> </strong>以对资源进行部分更新。JSON补丁是一种格式，用于表达通过HTTP <code class="du jt ju jv jw b">PATCH</code>方法应用于目标JSON文档的<em class="js">操作</em>的序列或数组。</p><p id="e5b6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请求体中的每个操作对象由3个主要属性组成:<br/>【0】<strong class="iw hi"/>—表示要执行的操作。根据规范，它的值必须是“<em class="js">添加</em>”、“<em class="js">移除</em>”、“<em class="js">替换</em>”、“<em class="js">移动</em>”、“<em class="js">复制</em>”或“<em class="js">测试</em>”、<br/>【1】<strong class="iw hi">路径</strong> —包含引用执行操作的“目标位置”<br/>【2】<strong class="iw hi">的JSON指针值的字符串之一</strong></p><p id="a74f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">考虑下面简单的JSON:</p><pre class="kd ke kf kg fd kh jw ki kj aw kk bi"><span id="5d6e" class="kl km hh jw b fi kn ko l kp kq">GET marvel/avengers/1<br/>{<br/> "name": "Tony Stark",<br/> "address": "Malibu Point"<br/>}</span></pre><p id="0fa6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设我们想通过<code class="du jt ju jv jw b">PATCH</code>操作改变地址属性。通常，我们会发送如下的HTTP <code class="du jt ju jv jw b">PATCH</code>请求:</p><pre class="kd ke kf kg fd kh jw ki kj aw kk bi"><span id="3fe7" class="kl km hh jw b fi kn ko l kp kq">PATCH marvel/avengers/1<br/>{<br/> "address": "Stark Tower LA",<br/> "addressType": "office"<br/>}</span></pre><p id="90a2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是在上面的请求中，我们没有指定指令。如果我们想根据RFC-6902发送请求，<code class="du jt ju jv jw b">PATCH</code>请求将如下所示:</p><pre class="kd ke kf kg fd kh jw ki kj aw kk bi"><span id="137a" class="kl km hh jw b fi kn ko l kp kq">PATCH marvel/avengers/1<br/>[<br/> {<br/>  "op": "replace",<br/>  "path: "/address",<br/>  "value": "Stark Tower LA"<br/> },<br/> {<br/>  "op": "add",<br/>  "path: "/addressType",<br/>  "value": "office"<br/> },<br/>]</span></pre><p id="71e0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">考虑到上述操作是成功的，我们将得到如下修改后的对象:</p><pre class="kd ke kf kg fd kh jw ki kj aw kk bi"><span id="9e7a" class="kl km hh jw b fi kn ko l kp kq">GET marvel/avengers/1<br/>{<br/> "name": "Tony Stark",<br/> "address": "Stark Tower LA",<br/> "addressType": "office"<br/>}</span></pre></div><div class="ab cl kr ks go kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ha hb hc hd he"><p id="45a5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">结论:<br/> </strong> RFC-6902声明:</p><blockquote class="jx jy jz"><p id="d71a" class="iu iv js iw b ix iy iz ja jb jc jd je ka jg jh ji kb jk jl jm kc jo jp jq jr ha bi translated">json补丁是一种格式(由媒体类型“application/ json-patch+json”标识)，用于表达应用于目标JSON文档的操作序列；<strong class="iw hi">适合与HTTP补丁方法</strong>一起使用。</p></blockquote><p id="1219" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，RFC-5892和RFC-6902之间的相关性可以用简单的话来理解，即我们可以使用JSON-PATCH作为HTTP-PATCH请求方法上的请求体。</p><p id="ca31" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，使用JSON-PATCH的优势可以在<br/> -我们必须处理具有深层属性层次结构的复杂JSON结构<br/> -我们需要限制用户并只允许修补选择性字段时观察到</p></div></div>    
</body>
</html>