<html>
<head>
<title>Shared client logic in multiplatform Kotlin project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多平台Kotlin项目中的共享客户端逻辑</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/shared-client-logic-in-multiplatform-kotlin-project-2509bc36ff51?source=collection_archive---------8-----------------------#2018-01-08">https://blog.kotlin-academy.com/shared-client-logic-in-multiplatform-kotlin-project-2509bc36ff51?source=collection_archive---------8-----------------------#2018-01-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b47f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经展示了<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/architecture-for-multiplatform-development-in-kotlin-cc770f4abdfd">多平台Kotlin项目</a>的架构。它的核心思想是我们如何定义客户端逻辑，以便它可以与所有客户端共享。这里我们用Kt来描述。学院申请示例。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/5e6e371263c9423bd8392d3bc78037a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/0*FmBvyOm4ZgOWtBJC."/></div></figure><p id="9585" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一部分，我们将描述<a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp" rel="noopener ugc nofollow" target="_blank"> Kot的<em class="kr">公共客户端</em>部分。学院申请项目</a>。接下来关于Android、web、桌面、iOS和其他的文章将强烈引用这篇文章。</p><p id="8ea4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr">公共</em> <em class="kr">模块</em>已经在<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/architecture-for-multiplatform-development-in-kotlin-cc770f4abdfd">关于整体架构的文章</a>和<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/extracting-multiplatform-common-modules-in-android-4a564cc03e0a">关于提取Android项目中公共模块的文章</a>中描述过了。</p><p id="080f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文的主要目标是:</p><ul class=""><li id="4822" class="ks kt in jm b jn jo jr js jv ku jz kv kd kw kh kx ky kz la bi translated">告诉你什么是<em class="kr">主持人</em>以及他们的目的是什么。请注意，对每个<em class="kr">演示者</em>的描述都是从一组具体的职责和一个涵盖其中每个职责的单元测试开始的。这些是那些<em class="kr">主持人</em>满足的特定商业规则。</li><li id="886a" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">让您了解如何在<em class="kr"/><em class="kr">模块中定义<em class="kr">演示者</em>。</em></li><li id="5e0c" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">呈现并描述<em class="kr">公共客户端模块</em>，这样在接下来的文章中，我们可以基于这些知识，描述我们如何在多平台Kotlin项目中定义Android、web、桌面或iOS。</li></ul><h1 id="a8e4" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">演示</h1><p id="0833" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">您可能已经看到了这个示例应用程序的样子。下面是<a class="ae ki" href="https://play.google.com/store/apps/details?id=org.kotlinacademy.mobile" rel="noopener ugc nofollow" target="_blank"> Android </a>和<a class="ae ki" href="http://portal.kotlin-academy.com/" rel="noopener ugc nofollow" target="_blank"> web </a>客户端的演示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="ab gu cl mj"><img src="../Images/fb3f495cc7c1fe5e38fb3d944f0ca0c0.png" data-original-src="https://miro.medium.com/v2/1*FLfFp81mxH1UsjIrtt_4_w.gif"/></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="ab gu cl mj"><img src="../Images/680161e3a14ce9830cda0ae403cb7013.png" data-original-src="https://miro.medium.com/v2/1*UzwbChSUMAi8yFpP8bqFWA.gif"/></div></figure><p id="72ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该应用程序目前实现了以下功能:</p><ul class=""><li id="0b72" class="ks kt in jm b jn jo jr js jv ku jz kv kd kw kh kx ky kz la bi translated">可以看到所有Kot。学院职位</li><li id="e679" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">你可以给新闻或者具体的文章添加评论</li><li id="24e3" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">应用程序正在发送推送通知</li></ul><p id="ac5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这3个核心功能在3个独立的<em class="kr">呈现者</em>中实现:<code class="fe mk ml mm mn b">NewsPresenter</code>、<code class="fe mk ml mm mn b">FeedbackPresenter</code>和<code class="fe mk ml mm mn b">RegisterNotificationTokenPresenter</code>。</p><p id="b3e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将一个接一个地(按不同的顺序)描述。</p><h1 id="e64d" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">反馈演示者</h1><p id="7b27" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated"><em class="kr">反馈</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/263ea82358fbe07658e6a089ab0c4298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1FXqU6ZaLj6clmy4N3Xxhg.png"/></div></div></figure><p id="303b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它真的很简单，因为它只决定当“发送”按钮被点击时如何反应。其业务逻辑规则如下:</p><ul class=""><li id="4710" class="ks kt in jm b jn jo jr js jv ku jz kv kd kw kh kx ky kz la bi translated">发送表单中提供的所有数据</li><li id="fb2b" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">发送反馈时，将显示加载器</li><li id="dd24" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">当存储库返回错误时，它会显示在视图上</li><li id="5cb1" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">数据发送后，视图切换回新闻列表</li></ul><p id="e5eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">检查<a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/test/kotlin/org/kotlinacademy/FeedbackPresenterUnitTest.kt" rel="noopener ugc nofollow" target="_blank">所有这些被定义为<em class="kr">演示者</em> </a>的单元测试的规则。</p><p id="5317" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">整个此逻辑在以下实现中实现:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/62e4af0c0029e8b917659540af625d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*kmXnsgzMv9LsERla3Tw2EQ.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/main/kotlin/org/kotlinacademy/presentation/feedback/FeedbackPresenter.kt" rel="noopener ugc nofollow" target="_blank">FeedbackPresenter in common-client module</a></figcaption></figure><p id="d1c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以看到，当调用<code class="fe mk ml mm mn b">onSendCommentClicked</code>时，我们将<code class="fe mk ml mm mn b">loading</code>设置为<code class="fe mk ml mm mn b">true</code>(显示加载指示器)，使用<code class="fe mk ml mm mn b">commentRepository</code>添加注释，并调用<code class="fe mk ml mm mn b">backToNewsAndShowSuccess</code>返回到之前的活动。当存储库抛出错误时，我们捕获它并显示在视图上。我们总是用隐藏负载指示器来完成这个方法。</p><p id="92a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mk ml mm mn b">FeedbackPresenter</code>使用<code class="fe mk ml mm mn b">FeedbackView</code>界面表示视图:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi my"><img src="../Images/61a499f9d6f372dfe18e751c3987daed.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*QTVVeTKDOpxRhl3ziGTv1A.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/main/kotlin/org/kotlinacademy/presentation/feedback/FeedbackView.kt" rel="noopener ugc nofollow" target="_blank">FeedbackView in common-client module</a></figcaption></figure><p id="3d6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有显示反馈表单的视图(页面、活动等)都需要实现它(在下一篇文章中，我们将看到更多具体的例子)。所有客户端的视图都需要实现<code class="fe mk ml mm mn b">BaseView</code>:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/7089f9f05884a590da2eddd570b100a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*n24Gktwnvy9MgbIk8aXWyA.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/main/kotlin/org/kotlinacademy/presentation/BaseView.kt" rel="noopener ugc nofollow" target="_blank">BaseView interface in common-client module</a></figcaption></figure><p id="d66a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数<code class="fe mk ml mm mn b">onSendCommentClicked</code>方法在<code class="fe mk ml mm mn b">launchUI</code>块中。这个块用于在协程中启动作用域。<code class="fe mk ml mm mn b">launchUI</code>是在Kt中定义的。学院项目，因为协程还不支持<em class="kr">通用模块</em>。它被定义为预期声明:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi na"><img src="../Images/22ebd5dab0b71aa2d2ecab09409b69f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*e2rd3gWMx-2nFL604wVeYw.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/main/kotlin/org/kotlinacademy/common/coroutines.kt" rel="noopener ugc nofollow" target="_blank">launchUI expected declaration in common-client module</a></figcaption></figure><p id="3f49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以像对待JVM方法<code class="fe mk ml mm mn b">launch(UI)</code>一样对待它，其中<code class="fe mk ml mm mn b">UI</code>是应用程序的UI线程。在JS中，它只使用了<code class="fe mk ml mm mn b">async</code>函数，因为web上没有主线程这种东西。查看JVM和JS的具体实现，但是记住它们很快就会改变，我们将会发表关于在通用模块T21中使用协程的整篇文章。</p><p id="d4ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mk ml mm mn b">launch(UI)</code>回报<code class="fe mk ml mm mn b">Cancellable</code>:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/3422fbf879dcecc948e46c74da8d377f.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*Q5qZZERGZ_TJG12z5kNGyw.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/main/kotlin/org/kotlinacademy/common/Cancellable.kt" rel="noopener ugc nofollow" target="_blank">Cancellable interface in common-client module</a></figcaption></figure><p id="fd5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于这一点，我们可以在用户离开屏幕时取消任务。这非常重要，因为这样我们可以防止当<em class="kr"> presenter </em>试图调用已经被销毁的活动的方法时，出现数据泄漏和错误。对于每个扩展<code class="fe mk ml mm mn b">BasePresenter</code>的类，作业取消自动发生:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/5e6fa2e03beb0e2bff5799ff0a4e45a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*RDIa9cFH56hjVzgKBsUF7A.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/main/kotlin/org/kotlinacademy/presentation/BasePresenter.kt" rel="noopener ugc nofollow" target="_blank">BasePresenter abstract class in common-client module</a></figcaption></figure><p id="1bde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中<code class="fe mk ml mm mn b">onDestroy</code>是<code class="fe mk ml mm mn b">Presenter</code>的两种生命周期方法之一:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/7f779af60d9c8978d09b04aec2a416e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*IoiTkzJypwZKAz79Vx13Zg.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/main/kotlin/org/kotlinacademy/presentation/Presenter.kt" rel="noopener ugc nofollow" target="_blank">Presenter interface in common-client module</a></figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="https://www.kt.academy/#workshops-offer"><div class="gh gi ne"><img src="../Images/018370a2476e1ce49e6d3299428b4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-f1laplrjQQAMlYKfLgHw.png"/></div></a></figure><h1 id="b1c8" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">仓库</h1><p id="9c8e" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated"><code class="fe mk ml mm mn b">FeedbackPresenter</code>使用<code class="fe mk ml mm mn b">FeedbackRepository</code>发送反馈。同样<code class="fe mk ml mm mn b">NewsPresenter</code>使用<code class="fe mk ml mm mn b">NewsRepository</code>而<code class="fe mk ml mm mn b">RegisterNotificationTokenPresenter</code>使用<code class="fe mk ml mm mn b">NotificationRepository</code>。该库的具体实现需要针对每个平台分别定义，但是它们的接口在<em class="kr">公共客户端</em>模块<em class="kr">中定义:</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nf"><img src="../Images/89fcb640207214b11804c008e791b0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0m2S8zSBTTdgacASq6ixsg.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/main/kotlin/org/kotlinacademy/respositories/FeedbackRepository.kt" rel="noopener ugc nofollow" target="_blank">FeedbackRepository in common-client module</a></figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ng"><img src="../Images/bb2bf802063339371498a08f20089b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhOVxdykvIliUpblgeBPtA.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/main/kotlin/org/kotlinacademy/respositories/NewsRepository.kt" rel="noopener ugc nofollow" target="_blank">NewsRepository in common-client module</a></figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nh"><img src="../Images/a4e58fb3dcfd66c6ade3aa947b9f920b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SpJ3ZUNjvQgSxrc1Ln1RiA.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/main/kotlin/org/kotlinacademy/respositories/NotificationRepository.kt" rel="noopener ugc nofollow" target="_blank">NotificationRepository in common-client module</a></figcaption></figure><p id="4a82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它们被注入到<em class="kr">演示者</em>中，使用轻量级依赖注入替代(尽管它可能很快会被Kodein取代)。它们都是使用<code class="fe mk ml mm mn b">RepositoriesProvider</code>预期声明创建的，该声明在平台模块中提供了特定于平台的实现:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/8ef77c2b05daa831cb186fb49e059f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*HISF81ZdN9R7oDF2tN97QQ.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">RepositoriesProvider expected declaration in common-client module</figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nj"><img src="../Images/7be1df72d72795b3dc0d723af18c1686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B46TJI_UIuI14u5tJhKjOQ.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">RepositoriesProvider actual declaration in <a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client-js/src/main/kotlin/org/kotlinacademy/respositories/RepositoriesProvider.kt" rel="noopener ugc nofollow" target="_blank">common-client-js module</a> and in <a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client-jvm/src/main/kotlin/org/kotlinacademy/respositories/RepositoriesProvider.kt" rel="noopener ugc nofollow" target="_blank">common-client-jvm module</a></figcaption></figure><p id="174d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">具体的实现使用特定于平台的方法来发出HTTP请求，并序列化/反序列化数据。</p><h1 id="1eb2" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">新闻记者</h1><p id="5224" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">下一个<em class="kr">演示者</em>要描述的是<code class="fe mk ml mm mn b">NewsPresenter</code>。它控制用于显示新闻的视图。其业务逻辑规则如下:</p><ul class=""><li id="7c87" class="ks kt in jm b jn jo jr js jv ku jz kv kd kw kh kx ky kz la bi translated">创建视图后，它加载并显示新闻列表。在新闻加载期间，加载器被显示。</li><li id="c6fa" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">当用户请求刷新时，加载新闻。在刷新期间，显示刷新指示器。</li><li id="ea00" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">新闻每60秒悄悄刷新一次。</li><li id="bcdb" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">新闻按发生的降序显示。</li><li id="f4cd" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">当任何新闻加载返回错误时，将显示loit。</li></ul><p id="41ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看该<em class="kr">演示者</em> 的<a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/test/kotlin/org/kotlinacademy/NewsPresenterUnitTest.kt" rel="noopener ugc nofollow" target="_blank">单元测试。</a></p><p id="58ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有这些逻辑都是通过以下实现来实现的:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nk"><img src="../Images/971b920d592f0a6ed741fd105b54d6df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oahjtbEoUkusggvERKxIIQ.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/e871a4a60900982b5acaaa16f6e65f627318605b/common-client/src/main/kotlin/org/kotlinacademy/presentation/news/NewsPresenter.kt" rel="noopener ugc nofollow" target="_blank">NewsPresenter in common-client module</a></figcaption></figure><p id="6478" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe mk ml mm mn b">onCreate</code>阶段，它显示加载，刷新列表并开始定期刷新。定期刷新使用<code class="fe mk ml mm mn b">periodicCaller</code>每60秒刷新一次。刷新是异步作业(因此当用户离开屏幕时它被取消)，它使用<code class="fe mk ml mm mn b">newsRepository</code>获取新闻，对它们进行排序，如果它们发生了变化，然后显示它们。毕竟，它隐藏了加载和刷新(如果它们没有显示，那么它什么也不做)。当使用请求刷新(<code class="fe mk ml mm mn b">onRefresh</code>)时，显示刷新指示灯(<code class="fe mk ml mm mn b">view.refresh = true</code>)并调用<code class="fe mk ml mm mn b">refreshList</code>。</p><p id="746d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是我们如何表示由这个<em class="kr">演示者</em>控制的<em class="kr">视图</em>:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/b9f615ca3e2ea3454cbfcc842e9f5608.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*qgA2Bp_B11sL1feElrObpw.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/e871a4a60900982b5acaaa16f6e65f627318605b/common-client/src/main/kotlin/org/kotlinacademy/presentation/news/NewsView.kt" rel="noopener ugc nofollow" target="_blank">NewsView in common-client module</a></figcaption></figure><p id="f6aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mk ml mm mn b">NewsPresenter</code>采用<code class="fe mk ml mm mn b">PeriodicCaller</code>类。它只有一个责任——在每一个具体的时间段内，从参数中调用函数。它也是<a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/9408caab2fa3431664a823e69e85dc8117b30bb6/android/common/src/test/java/org/kotlinacademy/PeriodicCallerUnitTest.kt" rel="noopener ugc nofollow" target="_blank">单独测试</a>。下面是它的实现:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nm"><img src="../Images/d77170c8dff9a9ff7361bb79660975bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GUa9pXFVFz9Mii8vfuqj2Q.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/9408caab2fa3431664a823e69e85dc8117b30bb6/common-client/src/main/kotlin/org/kotlinacademy/usecases/PeriodicCaller.kt" rel="noopener ugc nofollow" target="_blank">PeriodicCaller in common-client module</a></figcaption></figure><p id="7608" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意也是用<code class="fe mk ml mm mn b">Provider</code>注入的。这就是为什么它在<a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/test/kotlin/org/kotlinacademy/NewsPresenterUnitTest.kt" rel="noopener ugc nofollow" target="_blank">单元测试</a>中很容易被嘲笑的原因。这展示了如何从<em class="kr">演示者</em>中提取具体的功能，以便它们可以被容易地重用和单独测试。感谢它被提取的事实，我们可以在<code class="fe mk ml mm mn b"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/test/kotlin/org/kotlinacademy/NewsPresenterUnitTest.kt" rel="noopener ugc nofollow" target="_blank">NewsPresenter</a></code> <a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/7ffa651a93ec2f60144084b1f40328c5d322ca8e/common-client/src/test/kotlin/org/kotlinacademy/NewsPresenterUnitTest.kt" rel="noopener ugc nofollow" target="_blank">测试</a>中模拟它，所以我们不需要在那里处理时间。</p><h1 id="f610" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">RegisterNotificationTokenPresenter</h1><p id="a8f6" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">项目中最后一位<em class="kr">主持人</em>(目前)是<code class="fe mk ml mm mn b">RegisterNotificationTokenPresenter</code>。它用于向后端发送Firebase通知令牌。这是一个棘手的部分，因为没有用于发送令牌的单一视图。它发生在后台。对于Android和web来说，也有不同的机制用来获得这个令牌。这些是演示者的职责:</p><ul class=""><li id="efd1" class="ks kt in jm b jn jo jr js jv ku jz kv kd kw kh kx ky kz la bi translated">向后端正确发送令牌</li><li id="21e7" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">当后端返回错误时，它会被记录</li><li id="c4b2" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">已知令牌何时被正确注册</li></ul><p id="cbb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看该<em class="kr">演示者</em> 的<a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/0c6b1b80e90ab02700a4f9f9fa61c5fdf70225bb/common-client/src/test/kotlin/org/kotlinacademy/RegisterNotificationTokenPresenterUnitTest.kt" rel="noopener ugc nofollow" target="_blank">单元测试。下面是它的实现:</a></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/2cb8b18b2e8ed8c628cee726bb980b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*mVTY8V0sgvFOkl3Xy9mn7Q.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/0c6b1b80e90ab02700a4f9f9fa61c5fdf70225bb/common-client/src/main/kotlin/org/kotlinacademy/presentation/notifications/RegisterNotificationTokenPresenter.kt" rel="noopener ugc nofollow" target="_blank">RegisterNotificationTokenPresenter in common-client module</a></figcaption></figure><p id="5294" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并查看声明:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e4a6671d183217164b229e7132712f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*D17_mbZMYYxBe5loyUbS3Q.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><a class="ae ki" href="https://github.com/MarcinMoskala/KotlinAcademyApp/blob/0c6b1b80e90ab02700a4f9f9fa61c5fdf70225bb/common-client/src/main/kotlin/org/kotlinacademy/presentation/notifications/RegisterNotificationTokenView.kt" rel="noopener ugc nofollow" target="_blank">RegisterNotificationTokenView in common-client module</a></figcaption></figure><p id="8156" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意这个接口没有实现<code class="fe mk ml mm mn b">BaseView</code>。是因为我们不需要实现未使用的<code class="fe mk ml mm mn b">showError</code>，也不是平台特定的base view提供的，因为这个视图并没有真正显示出来。</p><p id="4306" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除此之外，<code class="fe mk ml mm mn b">RegisterNotificationTokenPresenter</code>的工作方式与<code class="fe mk ml mm mn b">FeedbackPresenter</code>类似。它是如何工作的更有趣，但这将在专门针对Android、iOS和web的文章中详细描述。</p><h1 id="c396" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">摘要</h1><p id="99a6" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">现在你知道了<em class="kr">公共客户端</em>模块是如何在Kt中工作的。学院申请。你应该明白这种<em class="kr">主持人</em>应该如何定义以及如何使用。</p><p id="870b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要深入了解<em class="kr">演示者</em>的目的和用途，请查看<a class="ae ki" href="https://medium.com/@marcinmoskala/mvc-vs-mvp-vs-mvvm-vs-mvi-ce72907d330" rel="noopener">本次演示</a>。如果你还没有这样做，你也应该读一下<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/architecture-for-multiplatform-development-in-kotlin-cc770f4abdfd?source=collection_detail----e57b304801ef-----10----------------">关于多平台开发的整体架构的文章</a>。</p><p id="e01f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想检查自己，那么你可以为这个项目做出贡献。仍然有大量的任务和大量的客户端需要实现。</p><p id="de9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在接下来的文章中，我们将描述如何在Android、web、桌面、iOS和其他平台上使用来自<em class="kr">公共客户端</em>的<em class="kr">演示者</em>。如果你不想错过他们，就订阅吧。</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><p id="1ce7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一篇文章:</p><div class="nw nx gp gr ny nz"><a rel="noopener  ugc nofollow" target="_blank" href="/testing-common-modules-66b39d641617"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd io gy z fp oe fr fs of fu fw im bi translated">测试通用模块</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">在具有良好架构的Kotlin多平台项目中，我们在公共-客户端公共模块中拥有完整的业务逻辑…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kp nz"/></div></div></a></div></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><h2 id="2f8c" class="oo lh in bd li op oq dn lm or os dp lq jv ot ou lu jz ov ow ly kd ox oy mc oz bi translated">学到了什么？单击👏说“谢谢！”并帮助他人找到这篇文章。</h2><p id="48bb" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">如果你认为这很重要，与他人分享。</p><p id="c6e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你需要Kotlin工作室吗？请访问我们的网站，看看我们能为您做些什么。</p><p id="a413" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要在Twitter上提到我，请使用<a class="ae ki" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank"> @marcinmoskala </a>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi pa"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi pb"><img src="../Images/77f73b2843c7321d074810231e681255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oKagsKgwb58Hot8vtthl3g.gif"/></div></div></figure></div></div>    
</body>
</html>