<html>
<head>
<title>Kotlin Demystified: Understanding Shorthand Lambda Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林揭秘:理解速记Lambda语法</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/kotlin-demystified-understanding-shorthand-lamba-syntax-74724028dcc5?source=collection_archive---------1-----------------------#2018-05-24">https://medium.com/androiddevelopers/kotlin-demystified-understanding-shorthand-lamba-syntax-74724028dcc5?source=collection_archive---------1-----------------------#2018-05-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/383fe39aa3bf5bdf1bef9e23599b4e4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNXslQsg8CYCyD5-1MkK5A.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/photos/HK8IoD-5zpg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Stefan Steinbauer</a> on <a class="ae it" href="https://unsplash.com/search/photos/secret?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c2a1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在一次奥地利之旅中，我参观了位于维也纳的奥地利国家图书馆。特别是州政府大厅，这是一个令人惊叹的空间，感觉就像是印第安纳·琼斯电影中的场景。在房间的周围是这些嵌在架子上的门，很容易想象它们背后隐藏着什么样的秘密。</p><p id="ca3c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，事实证明，它们只是阅览室。</p><p id="0258" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们想象一下，我们有一个跟踪图书馆书籍的应用程序。有一天，我们想知道藏书中最长和最短的书是什么。过了一会儿，我们编写代码，让我们找到这两个:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="94c8" class="kb kc hh jx b fi kd ke l kf kg">val shortestBook = library.minBy { it.pageCount }<br/>val longestBook = library.maxBy { it.pageCount }</span></pre><p id="6d7b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">完美！但这让我想知道，这些方法是如何工作的？<code class="du kh ki kj jx b">it</code>怎么知道，仅仅从写<code class="du kh ki kj jx b">it.pageCount</code>就知道，怎么做到这一点？</p><p id="29bc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我做的第一件事是点击进入<code class="du kh ki kj jx b">minBy</code>和<code class="du kh ki kj jx b">maxBy</code>的定义，它们都在<a class="ae it" href="https://github.com/JetBrains/kotlin/blob/1.2.50/libraries/stdlib/common/src/generated/_Collections.kt" rel="noopener ugc nofollow" target="_blank"> _Collections.kt </a>中。因为它们几乎完全相同，所以让我们把注意力集中在从第<a class="ae it" href="https://github.com/JetBrains/kotlin/blob/1.2.50/libraries/stdlib/common/src/generated/_Collections.kt#L1559" rel="noopener ugc nofollow" target="_blank">行的第1559 </a>行开始的<code class="du kh ki kj jx b">maxBy</code>上。</p><p id="74bb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里的方法是建立在<code class="du kh ki kj jx b"><a class="ae it" href="https://developer.android.com/reference/java/lang/Iterable" rel="noopener ugc nofollow" target="_blank">Iterable</a></code>接口上的，但是如果我们做一点小的重写来使用<code class="du kh ki kj jx b"><a class="ae it" href="https://developer.android.com/reference/java/util/Collection" rel="noopener ugc nofollow" target="_blank">Collection</a></code> s，并且可能重命名一些变量使其更详细一点，那么就更容易理解了:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="b3a2" class="kb kc hh jx b fi kd ke l kf kg">public inline fun &lt;T, R : Comparable&lt;R&gt;&gt; Collection&lt;T&gt;.maxBy(selector: (T) -&gt; R): T? {<br/>    if (isEmpty()) return null<br/>    var maxElement = first()<br/>    var maxValue = selector(maxElement)<br/>    for (element in this) {<br/>        val value = selector(element)<br/>        if (maxValue &lt; value) {<br/>            maxElement = element<br/>            maxValue = value<br/>        }<br/>    }<br/>    return maxElement<br/>}</span></pre><p id="49d3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以看到它只是抓取了<code class="du kh ki kj jx b">Collection</code>中的每个元素，检查来自<code class="du kh ki kj jx b">selector</code>的值是否大于它所看到的最大值。如果是，它将保存元素和值。最后，它返回找到的最大元素。相当简单。</p><p id="6339" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，<code class="du kh ki kj jx b">selector</code>看起来有点整洁，它一定是允许我们使用上面的<code class="du kh ki kj jx b">it.pageCount</code>的东西，所以让我们再深入研究一下。</p><p id="16d7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">甚至在这一行中也有相当多的语法上的好处。<code class="du kh ki kj jx b">selector: (T) -&gt; R</code>是一个函数的简称，它接受一个参数，在本例中是<code class="du kh ki kj jx b">T</code>，并返回<code class="du kh ki kj jx b">R</code>类型的结果。</p><p id="e991" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Kotlin的工作方式包括一组名为<code class="du kh ki kj jx b">FunctionN</code>的接口，其中<em class="kk"> N </em>是它接受的参数数量。因为我们有一个接口，我们可以实现<code class="du kh ki kj jx b">Function1</code>接口，然后在我们的代码中使用它:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="6f83" class="kb kc hh jx b fi kd ke l kf kg">class BookSelector : Function1&lt;Book, Int&gt; {<br/>   override fun invoke(book: Book): Int {<br/>       return book.pageCount<br/>   }<br/>}<br/> <br/>val longestBook = library.maxBy(BookSelector())</span></pre><p id="50b2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这当然说明了它是如何非常容易地工作的。<code class="du kh ki kj jx b">selector</code>是一个<code class="du kh ki kj jx b">Function1</code>，当给定一个<code class="du kh ki kj jx b">Book</code>时，它返回一个<code class="du kh ki kj jx b">Int</code>。然后，<code class="du kh ki kj jx b">maxBy</code>获取<code class="du kh ki kj jx b">Int</code>并将其与它所具有的值进行比较。</p><p id="e043" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">顺便说一下，这也解释了为什么通用参数<code class="du kh ki kj jx b">R</code>具有类型<code class="du kh ki kj jx b">R [implements] Comparable&lt;R&gt;</code>。如果<code class="du kh ki kj jx b">R</code>不是<code class="du kh ki kj jx b">Comparable</code>，我们就做不了<code class="du kh ki kj jx b">if (maxValue &lt; value)</code>。</p><p id="40a4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下一个问题是，我们如何从<a class="ae it" href="#full" rel="noopener ugc nofollow">到那个</a>，到我们开始的那个班轮？让我们一步一步地完成这个过程。</p><p id="ebdc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，代码可以用lambda替换，这已经使它缩小了不少:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="2934" class="kb kc hh jx b fi kd ke l kf kg">val longestBook = library.maxBy({<br/>    it.pageCount<br/>})</span></pre><p id="a95c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下一步是，如果方法的最后一个参数是lambda，我们可以关闭括号，然后将lambda添加到行尾，就像这样:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="6c57" class="kb kc hh jx b fi kd ke l kf kg">val longestBook = library.maxBy() {<br/>    it.pageCount<br/>}</span></pre><p id="0643" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，如果一个方法只接受一个lambda参数，我们可以完全省略掉这个方法中的<code class="du kh ki kj jx b">()</code>,这让我们回到了最初的代码:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="c2e0" class="kb kc hh jx b fi kd ke l kf kg">val longestBook = library.maxBy { it.pageCount }</span></pre><p id="2e40" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是等等！那<code class="du kh ki kj jx b">Function1</code>呢！每当我使用它时，我是在执行分配吗？</p><p id="571e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是一个很好的问题！好消息是，不，你不是。如果你再看一下，你会看到<code class="du kh ki kj jx b">maxBy</code>被标记为<code class="du kh ki kj jx b">inline</code>函数。这种情况发生在编译期间的源代码级别，因此尽管编译的代码比最初看起来的要多，但不会对性能产生任何显著影响，当然也不会有对象分配。</p><p id="96c1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">厉害！现在我们不仅知道图书馆里最短(和最长)的书是什么，我们也更好地理解了<code class="du kh ki kj jx b">maxBy</code>是如何工作的。我们看到了Kotlin如何为lambda使用<code class="du kh ki kj jx b"><a class="ae it" href="#full" rel="noopener ugc nofollow">FunctionN</a></code>接口，以及有时如何将lambda表达式移到函数的参数列表之外。最后，我们了解到，当只有一个lambda参数时，可以完全省略调用函数时通常使用的括号。</p><p id="bb97" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">查看<a class="ae it" href="https://medium.com/google-developers" rel="noopener"> Google Developers </a>博客，了解更多精彩内容，并关注更多关于Kotlin的文章！</p></div></div>    
</body>
</html>