<html>
<head>
<title>Leverage Information Chunking to scale your Java library package design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用信息分块来扩展您的Java库包设计</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/leverage-information-chunking-to-scale-your-java-library-package-design-fcedf64af434?source=collection_archive---------0-----------------------#2019-01-28">https://medium.com/oracledevs/leverage-information-chunking-to-scale-your-java-library-package-design-fcedf64af434?source=collection_archive---------0-----------------------#2019-01-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="ced3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对包进行组织和分组有助于使你的库更容易导航、理解和随时间增长。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/cf56ebb29461dce230cb68bd19390779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-Y8a6lzMw0Aqs9kM6P6ag.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Grounds for Sculpture, Hamilton Township, NJ</figcaption></figure><h1 id="922f" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">扩展Java库包设计是困难的</h1><p id="07be" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">Java给了我们组织相关类和接口的包。包非常有用，但是很难有效地利用，因为每个包都需要一个名字。给事物命名很难。将事物有效地组织成一个层次可能是一个挑战。在您的IDE中，重命名和移动内容可能很容易，但是如果您的客户端在升级您的库时不得不在代码中手动重放重命名和移动重构，那么这可能会非常困难。</p><p id="9f69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当库中的类数量少于10个或20个时，将所有东西放在同一个包和jar中似乎是一个微不足道的决定。但是，如果您拥有的类和接口的数量比这多得多，您该怎么办呢？如果您的库中有大量的接口和类，请考虑将API和实现类拆分到单独的包中。此外，如果您想让其他人实现您的API，而不必包含默认实现，那么拥有一个单独的API jar会很有帮助。</p><p id="3fb9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将解释我们在<a class="ae kv" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> Eclipse集合</a>中利用的信息分块策略。随着库的增长，我们的包层次结构也发生了显著的变化。在我们开源Eclipse集合之前，我们有意识地做出了包设计决策，这使得我们有可能在更长的时间内继续扩充库。</p><h1 id="09b5" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">信息分块是如何工作的</h1><p id="c1a1" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">人类的大脑一次可以记住7个正负两件事情。这就是为什么在美国电话号码是七位数。如果将相关的概念分成七个正负两个事物的大块，人类可以更有效地管理大量的信息。有时，如果不增加不必要的包数，严格遵守这个数字是不可能的。例如，将每个基本类型的容器组织到它自己的包中可能是多余的。接口和类名的字母排序给了我们一个包内的可视分组，因此我们可以根据前缀更快地关注或忽略一些东西。</p><p id="b352" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">推荐:</strong>不要让我滚动。如果您让我滚动查看一个包中的所有类，那就太多了。</p><h1 id="1fcf" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Eclipse集合包策略</h1><ul class=""><li id="7a52" class="kw kx hh ig b ih kq il kr ip ky it kz ix la jb lb lc ld le bi translated">将接口与实现分开</li><li id="266f" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">按容器类型组织顶级包</li><li id="1ce3" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">用容器类型组织容器类型专门化(例如，分类)</li><li id="51f7" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">按接口类型(如可变、不可变)组织impl包</li><li id="83a6" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">将基本类型组织到一个单独的包中</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lk"><img src="../Images/37722aee7796b8d037b87148e97f431b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x7tvAh5_CcaS0TZ1O62sRQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">High-level concerns in Eclipse Collections</figcaption></figure><h1 id="1a83" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">将接口与实现分开</h1><p id="760a" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">Eclipse集合为接口和实现类提供了单独的包和jar文件。这允许我们库的客户分别理解API和实现，并通过容器类型将两者归入一个相似的心智模型。</p><h2 id="de9f" class="ll jt hh bd ju lm ln lo jy lp lq lr kc ip ls lt kg it lu lv kk ix lw lx ko ly bi translated">Eclipse集合org.eclipse.collections.api/impl软件包</h2><p id="008c" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">Eclipse集合为api和实现提供了单独的模块和包名。api包在左边，impl包在右边。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lz"><img src="../Images/00ae93b2ad38758a22e977ff57d94ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9AWYqVmeltDWz8kUZXt0g.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Eclipse Collections API and Implementation Package Structures</figcaption></figure><p id="57a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Eclipse Collections是一个很大的库，但是有可管理数量的高级概念分组到包中。我们已经组织了Eclipse集合，因此可以很容易地探索受支持的容器类型，并根据需要深入了解更多细节。</p><p id="509e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将API接口从实现类中分离出来给这个库带来了额外的好处。实现类依赖于API接口，而不是反过来。当API接口和实现类在同一个包中并位于同一个jar中时，就有可能在接口和它们的实现之间引入不必要的依赖，这种依赖很难在以后消除。</p><h2 id="f87b" class="ll jt hh bd ju lm ln lo jy lp lq lr kc ip ls lt kg it lu lv kk ix lw lx ko ly bi translated">JDK java.util包</h2><p id="713f" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">JDK <code class="du ma mb mc md b">java.util</code>包中包含的接口和类如下所示。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es me"><img src="../Images/9f271371fa5a29894f4fdf84a727bb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K2Lxki2nCRj2kqD2k5ZrNA.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">JDK java.util package</figcaption></figure><p id="6714" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个包的许多类和接口。您可以通过图标来区分接口和类，但是没有办法理解这些实用程序类之间的关系。在同一个包中有集合、异常、格式化器、比较器、统计、选项、日历、日期、服务加载器、字符串相关的东西、时区、计时器类和其他实用程序。这是一个按名称字母顺序排序的接口和类包。</p><p id="c17b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个<code class="du ma mb mc md b">java.util</code>包已经变成了一个停车场，用来存放那些被松散地归类为“公用事业”的东西。理想情况下，应该有一个<code class="du ma mb mc md b">java.util.collection</code>包，其中只包含处理集合的类和接口。因为Java的向后兼容性保证，唯一合理的前进方式是在像<code class="du ma mb mc md b">java.util.stream</code>这样的新包中引入新概念。</p><h2 id="7b77" class="ll jt hh bd ju lm ln lo jy lp lq lr kc ip ls lt kg it lu lv kk ix lw lx ko ly bi translated">Google Guava com.google.collect包</h2><p id="d87b" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">这些是谷歌番石榴的<code class="du ma mb mc md b">com.google.collect</code>包中的类和接口。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mf"><img src="../Images/2f47ad17be5d98327460fab342c827c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_1jsHkSUWpix_bChGbgig.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Guava package com.google.collect</figcaption></figure><p id="e43f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个包里面有很多类，但是都和收藏有关。由于某些类的前缀(例如，过滤、转发、不可变、常规)而产生了一种视觉分组，但是很难将重点放在接口和实现上来理解库的整体重点和范围。</p><h2 id="aef8" class="ll jt hh bd ju lm ln lo jy lp lq lr kc ip ls lt kg it lu lv kk ix lw lx ko ly bi translated">Apache org . Apache . commons . collections 4包</h2><p id="9201" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">这里我要比较的最后一个库是Apache Commons Collections，它是最古老的第三方Java collections库。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mg"><img src="../Images/9f3bced35ed305d2b69432b6136c8957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*HshXa-MHHoBbs9FYk0faug.jpeg"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Apache package org.apache.commons.collections4</figcaption></figure><p id="9280" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Apache Commons Collections按照容器类型组织它的实现，但是不把它的API接口和实现分成单独的包。</p><p id="8a88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Eclipse Collections是四个Java collections库中唯一一个将其API和实现分成单独的包和单独的jar文件的库。</p><h1 id="3e6b" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">按容器类型组织包裹</h1><p id="49f5" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">当我们决定向Eclipse集合中添加不可变容器类型和实现时，我们知道我们需要重组这个库。我们知道，如果我们在一个包中有超过100个类和接口，它将不能很好地工作。我们还决定将我们的API接口分离到一个单独的包结构中。然后，我们选择“集装箱类型”作为高级包装分组。</p><p id="bd5f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我们必须弄清楚如何在我们的API和实现包中组织的一组高级容器。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mh"><img src="../Images/dad2e78119a18037d6696b962d03f736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gs6oL36CsN69d4aJPmBsag.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Eclipse Collections container types</figcaption></figure><p id="8d83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每种容器类型都有一组额外的问题需要在包层次结构中解决。</p><p id="54d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是在接口和实现包中展开<code class="du ma mb mc md b">List</code>容器类型包时的样子。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mi"><img src="../Images/8804ce58c996664b91c1875c2ba88731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UtDtuNGSw-bHJYncopKuoA.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Interfaces in API package drive the package hierarchy in implementation package</figcaption></figure><h1 id="5015" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">用容器类型组织容器类型专门化</h1><p id="4191" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">Eclipse Collections已经对<code class="du ma mb mc md b">Bag</code>、<code class="du ma mb mc md b">Set</code>和<code class="du ma mb mc md b">Map</code>的版本进行了<strong class="ig hi">排序。这些容器类型中的每一种都有一个名为<strong class="ig hi">的分类</strong>的子包。这个策略可以根据需要与其他容器类型专门化一起使用。</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mj"><img src="../Images/385be194044a4ff88e651b431653340a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBBpKrFK8lOepW1mdLyMOg.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Bag, Set and Map all have sorted versions</figcaption></figure><h1 id="07e9" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">按接口类型组织impl包</h1><p id="249c" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">对于Eclipse集合中的所有容器类型，有三种主要的接口类型。它们分别是<code class="du ma mb mc md b">Mutable</code>、<code class="du ma mb mc md b">Immutable</code>和<code class="du ma mb mc md b">Iterable</code>(又名可读)。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ml"><img src="../Images/87844a2201bd358bf927977542956733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e-ojSJgIpoWCKOE7noQkfQ.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Symmetry across container types — Iterable, Mutable, Immutable</figcaption></figure><p id="4bd0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于<code class="du ma mb mc md b">List</code>容器类型，有<code class="du ma mb mc md b">Mutable</code> <strong class="ig hi">、</strong> <code class="du ma mb mc md b">Immutable</code>和<code class="du ma mb mc md b">FixedSize</code>接口类型的实现类。<code class="du ma mb mc md b">FixedSize</code>目前仅限于<code class="du ma mb mc md b">List</code>、<code class="du ma mb mc md b">Set</code>和<code class="du ma mb mc md b">Map</code>容器类型，用于实现类似数组的<code class="du ma mb mc md b">Mutable</code>容器类型的内存效率。也就是说，它们可以被修改，但不能生长。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mm"><img src="../Images/d5cfb8314b587a1f07876140908845ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*iR1iGVCubv1NNKyangmKMA.jpeg"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Object List implementations organized by FixedSize, Immutable and Mutable</figcaption></figure><h1 id="1af1" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">将基本类型组织到一个单独的包中</h1><p id="44b6" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">原始容器被组织在API jar中的容器类型包之下，以及实现jar中的<code class="du ma mb mc md b">Mutable</code>和<code class="du ma mb mc md b">Immutable</code>包之下。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mn"><img src="../Images/8af3669685a5e2c653980a5bcc66f7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JX5H5yQR7zPSue7kwr4VuA.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">API packages (left) and Impl packages(right) for List container type and Mutable Implementations only</figcaption></figure><p id="49d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以将原始集合按照原始类型分割成单独的包。这将导致每个原始包有八个包。我们决定不这样做，因为类名及其前缀的字母排序在原语包中提供了足够的可视分组。</p><h1 id="c5f5" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">够了</h1><p id="aa6b" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">当你的层次结构中有足够多的包时，你需要最终做出决定，而考虑到神奇的数字7，它可能不会完美地工作。</p><p id="0fdf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可变集合实现有几个额外的问题需要处理— <code class="du ma mb mc md b">Synchronized</code>、<code class="du ma mb mc md b">Unmodifiable</code>和<code class="du ma mb mc md b">MultiReader</code>。我们觉得这些概念并不能保证它们有自己的包装。我们想不出一个好名字来把它们放在一起打包。像“mutable.other”这样的名字并不十分有用。所以我们在实现包的<code class="du ma mb mc md b">list.mutable</code>和<code class="du ma mb mc md b">list.mutable.primitive</code>停下来。</p><h1 id="5389" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">什么时候是重组软件包的时候？</h1><p id="1477" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">当我们向库添加不可变集合时，我们重组了Eclipse集合中的包(#10)，就在我们将库开源为GS集合之前。不可变集合大大增加了我们必须在包中管理的概念的数量。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mo"><img src="../Images/22e67a18085a6639a0efee605d4cceb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdXxdLptmbKRfhWpQ5Mxmw.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Package restructuring happened around item #10</figcaption></figure><p id="67ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一点，我们在生态系统中引入了一些必须适合我们的包层次结构的大东西，这就是原始集合(#13)。我们能够通过将<strong class="ig hi">原语</strong>包插入到其对象对应物下面的现有层次结构中来完成这一点，而不需要完全的重组。</p><p id="ae50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当库迁移到Eclipse Foundation并成为Eclipse集合时，父包再次从<code class="du ma mb mc md b">com.gs.collections</code>更改为<code class="du ma mb mc md b">org.eclipse.collections</code>。我们开源了一个独立的库来帮助GS集合的用户转换到Eclipse集合——<a class="ae kv" href="https://github.com/eclipse/gsc-ec-converter" rel="noopener ugc nofollow" target="_blank">https://github.com/eclipse/gsc-ec-converter</a></p><h1 id="5e4e" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">最后的想法</h1><p id="0a64" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">Java包是帮助解决名称间距和逻辑分组问题的解决方案。当您发展和扩大一个库时，您应该准备好优化您的包结构，以允许更好的逻辑分组和信息分块。</p><p id="c500" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="mk">我是</em><a class="ae kv" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"><em class="mk">Eclipse Collections</em></a><em class="mk">OSS项目在</em><a class="ae kv" href="https://projects.eclipse.org/projects/technology.collections" rel="noopener ugc nofollow" target="_blank"><em class="mk">Eclipse Foundation</em></a><em class="mk">的项目负责人。</em> <a class="ae kv" href="https://github.com/eclipse/eclipse-collections" rel="noopener ugc nofollow" target="_blank"> <em class="mk">月食收藏</em> </a> <em class="mk">是开投</em> <a class="ae kv" href="https://github.com/eclipse/eclipse-collections/blob/master/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank"> <em class="mk">投稿</em> </a> <em class="mk">。如果你喜欢这个库，你可以在GitHub上让我们知道。</em></p></div></div>    
</body>
</html>