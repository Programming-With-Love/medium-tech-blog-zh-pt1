<html>
<head>
<title>Functors &amp; Categories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函子和类别</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/functors-categories-61e031bac53f?source=collection_archive---------2-----------------------#2017-03-17">https://medium.com/javascript-scene/functors-categories-61e031bac53f?source=collection_archive---------2-----------------------#2017-03-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="17ac" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">编写软件</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/b5319c93f5a4237f1472d1686f5b1e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVpU7iruzXafhU2VLeH4lw.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</figcaption></figure><blockquote class="jm jn jo"><p id="dd42" class="jp jq jr js b jt ju ii jv jw jx il jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="js hi">注:</strong>这是《作曲软件》系列的一部分<strong class="js hi"> s </strong> <a class="ae km" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <strong class="js hi">(现在一本书！)</strong> </a>从基础开始学习JavaScript ES6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！<br/> <a class="ae km" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="hh">买书</em> </a> <em class="hh"> | </em> <a class="ae km" rel="noopener" href="/javascript-scene/composing-software-the-book-f31c77fc3ddc"> <em class="hh">索引</em></a>|<a class="ae km" rel="noopener" href="/javascript-scene/abstract-data-types-and-the-software-crisis-671ea7fc72e7">&lt;上一张</a> | <a class="ae km" rel="noopener" href="/javascript-scene/javascript-monads-made-simple-7856be57bfe8">下一张&gt; </a></p></blockquote><p id="e41d" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">一个<strong class="js hi">仿函数数据类型</strong>是你可以映射的。它是一个容器，有一个接口，可以用来对里面的值应用一个函数。当你看到一个函子的时候，你应该想到<em class="jr">“mapable”。</em>函子类型通常用一个<code class="du kq kr ks kt b">.map()</code>方法表示为一个对象，它从输入映射到输出，同时保留结构。实际上，“保留结构”意味着返回值是相同类型的函子(尽管容器内的值可能是不同的类型)。</p><p id="e048" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">函子提供了一个盒子，里面有零个或更多的东西，以及一个映射接口。数组是仿函数的一个很好的例子，但是许多其他类型的对象也可以被映射，包括承诺、流、树、对象等等。JavaScript的内置数组和promise对象的行为类似于函子。对于集合(数组、流等。)，<code class="du kq kr ks kt b">.map()</code>通常迭代集合，将给定的函数应用于集合中的每个值，但不是所有的函子都迭代。函子实际上是在特定的上下文中应用一个函数。</p><p id="b67c" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">承诺用名字<code class="du kq kr ks kt b">.then()</code>代替<code class="du kq kr ks kt b">.map()</code>。你通常可以认为<code class="du kq kr ks kt b">.then()</code>是一个异步的<code class="du kq kr ks kt b">.map()</code>方法，除非你有一个嵌套的承诺，在这种情况下，它会自动打开外部承诺。同样，对于不是承诺的值，<code class="du kq kr ks kt b">.then()</code>就像一个异步的<code class="du kq kr ks kt b">.map()</code>。对于承诺本身的值，<code class="du kq kr ks kt b">.then()</code>的行为类似于单子的<code class="du kq kr ks kt b">.flatMap()</code>方法(有时也称为<code class="du kq kr ks kt b">.chain()</code>)。所以，承诺不完全是函子，也不完全是单子，但在实践中，你通常可以把它们当作任一种。先不要担心单子是什么。单子是函子的一种，你需要先学习函子。</p><p id="4175" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">有很多库也可以将各种其他东西转化为函子。</p><p id="8cb5" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">在Haskell中，函子类型被定义为:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="3588" class="ky kz hh kt b fi la lb l lc ld">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span></pre><p id="4acf" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">给定一个函数，它接受一个<code class="du kq kr ks kt b">a</code>并返回一个<code class="du kq kr ks kt b">b</code>和一个内部有零个或多个<code class="du kq kr ks kt b">a</code>的函子:<code class="du kq kr ks kt b">fmap</code>返回一个内部有零个或多个<code class="du kq kr ks kt b">b</code>的盒子。<code class="du kq kr ks kt b">f a</code>和<code class="du kq kr ks kt b">f b</code>位可以读作“一个<code class="du kq kr ks kt b">a</code>的函子”和“一个<code class="du kq kr ks kt b">b</code>的函子”，意思是<code class="du kq kr ks kt b">f a</code>在盒子里面有<code class="du kq kr ks kt b">a</code> s，<code class="du kq kr ks kt b">f b</code>在盒子里面有<code class="du kq kr ks kt b">b</code> s。</p><p id="abf1" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">使用仿函数很简单——只需调用<code class="du kq kr ks kt b">map()</code>:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="69d0" class="ky kz hh kt b fi la lb l lc ld">const f = [1, 2, 3];<br/>f.map(double); // [2, 4, 6]</span></pre><h1 id="8b38" class="le kz hh bd lf lg lh li lj lk ll lm ln in lo io lp iq lq ir lr it ls iu lt lu bi translated">函子定律</h1><p id="c712" class="pw-post-body-paragraph jp jq hh js b jt lv ii jv jw lw il jy kn lx kb kc ko ly kf kg kp lz kj kk kl ha bi translated">类别有两个重要属性:</p><ol class=""><li id="0caa" class="ma mb hh js b jt ju jw jx kn mc ko md kp me kl mf mg mh mi bi translated">身份</li><li id="41a0" class="ma mb hh js b jt mj jw mk kn ml ko mm kp mn kl mf mg mh mi bi translated">作文</li></ol><p id="2b3a" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">由于函子是范畴之间的映射，所以函子必须尊重同一性和复合性。合在一起，它们被称为函子定律。</p><h1 id="faa7" class="le kz hh bd lf lg lh li lj lk ll lm ln in lo io lp iq lq ir lr it ls iu lt lu bi translated">身份</h1><p id="6d64" class="pw-post-body-paragraph jp jq hh js b jt lv ii jv jw lw il jy kn lx kb kc ko ly kf kg kp lz kj kk kl ha bi translated">如果将恒等式函数(<code class="du kq kr ks kt b">x =&gt; x</code>)传递给<code class="du kq kr ks kt b">f.map()</code>，其中<code class="du kq kr ks kt b">f</code>是任意一个函子，那么结果应该等同于<code class="du kq kr ks kt b">f</code>(具有相同的含义):</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="0ab2" class="ky kz hh kt b fi la lb l lc ld">const f = [1, 2, 3];<br/>f.map(x =&gt; x); // [1, 2, 3]</span></pre><h1 id="e36d" class="le kz hh bd lf lg lh li lj lk ll lm ln in lo io lp iq lq ir lr it ls iu lt lu bi translated">作文</h1><p id="8b7e" class="pw-post-body-paragraph jp jq hh js b jt lv ii jv jw lw il jy kn lx kb kc ko ly kf kg kp lz kj kk kl ha bi translated">函子必须服从合成定律:<code class="du kq kr ks kt b">F.map(x =&gt; f(g(x)))</code>等价于<code class="du kq kr ks kt b">F.map(g).map(f)</code>。</p><p id="a707" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">函数组合是一个函数对另一个函数的结果的应用，例如给定一个<code class="du kq kr ks kt b">x</code>和函数<code class="du kq kr ks kt b">f</code>和<code class="du kq kr ks kt b">g</code>，组合<code class="du kq kr ks kt b">(f ∘ g)(x)</code>(通常简称为<code class="du kq kr ks kt b">f ∘ g</code>-<code class="du kq kr ks kt b">(x)</code>是隐含的)就是<code class="du kq kr ks kt b">f(g(x))</code>。</p><p id="d19d" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">大量的函数式编程术语来自于范畴论，范畴论的本质是复合。范畴理论一开始很吓人，但是很简单。比如从跳水板上跳下来或者坐过山车。以下是范畴理论的几个要点:</p><ul class=""><li id="17c3" class="ma mb hh js b jt ju jw jx kn mc ko md kp me kl mo mg mh mi bi translated">类别是对象和对象之间的箭头的集合(其中“对象”可以表示字面上的任何东西)。</li><li id="a60c" class="ma mb hh js b jt mj jw mk kn ml ko mm kp mn kl mo mg mh mi bi translated">箭头被称为态射。态射可以被认为是函数，并在代码中表示为函数。</li><li id="64b8" class="ma mb hh js b jt mj jw mk kn ml ko mm kp mn kl mo mg mh mi bi translated">对于任何一组相连的对象<code class="du kq kr ks kt b">a -&gt; b -&gt; c</code>，都必须有一个直接来自<code class="du kq kr ks kt b">a -&gt; c</code>的合成。</li><li id="3fd2" class="ma mb hh js b jt mj jw mk kn ml ko mm kp mn kl mo mg mh mi bi translated">所有的箭头都可以表示为组合(即使只是带有对象标识箭头的组合)。类别中的所有对象都有标识箭头。</li></ul><p id="978b" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">假设您有一个函数<code class="du kq kr ks kt b">g</code>接受一个<code class="du kq kr ks kt b">a</code>并返回一个<code class="du kq kr ks kt b">b</code>，另一个函数<code class="du kq kr ks kt b">f</code>接受一个<code class="du kq kr ks kt b">b</code>并返回一个<code class="du kq kr ks kt b">c</code>；还必须有一个函数<code class="du kq kr ks kt b">h</code>代表<code class="du kq kr ks kt b">f</code>和<code class="du kq kr ks kt b">g</code>的组合。所以，作文出自<code class="du kq kr ks kt b">a -&gt; c</code>，就是作文<code class="du kq kr ks kt b">f ∘ g</code>(<code class="du kq kr ks kt b">f</code><em class="jr"/><code class="du kq kr ks kt b">g</code>之后)。所以，<code class="du kq kr ks kt b">h(x) = f(g(x))</code>。函数组合是从右向左工作，而不是从左向右，这也是为什么<code class="du kq kr ks kt b">f ∘ g</code>在 <code class="du kq kr ks kt b">g</code>之后又被频繁称为<code class="du kq kr ks kt b">f</code> <em class="jr">的原因。</em></p><p id="344e" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">构图是联想的。基本上，这意味着当你在编写多个函数时(如果你觉得有趣，可以使用变形)，你不需要括号:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="2cd3" class="ky kz hh kt b fi la lb l lc ld">h∘(g∘f) = (h∘g)∘f = h∘g∘f</span></pre><p id="5c46" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">让我们再来看看JavaScript中的合成法则:</p><p id="56f9" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">给定一个函子，<code class="du kq kr ks kt b">F</code>:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="a8bd" class="ky kz hh kt b fi la lb l lc ld">const F = [1, 2, 3];</span></pre><p id="d42b" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">以下内容是等效的:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="1f86" class="ky kz hh kt b fi la lb l lc ld">F.map(x =&gt; f(g(x)));</span><span id="d2be" class="ky kz hh kt b fi mp lb l lc ld">// is equivalent to...</span><span id="746a" class="ky kz hh kt b fi mp lb l lc ld">F.map(g).map(f);</span></pre><h1 id="f642" class="le kz hh bd lf lg lh li lj lk ll lm ln in lo io lp iq lq ir lr it ls iu lt lu bi translated">内函子</h1><p id="c775" class="pw-post-body-paragraph jp jq hh js b jt lv ii jv jw lw il jy kn lx kb kc ko ly kf kg kp lz kj kk kl ha bi translated">内函子是从一个范畴映射回同一范畴的函子。</p><p id="a1a5" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">函子可以从一个类别映射到另一个类别:<code class="du kq kr ks kt b">X -&gt; Y</code></p><p id="f6e7" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">内函子从一个范畴映射到同一个范畴:<code class="du kq kr ks kt b">X -&gt; X</code></p><p id="e73f" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">单子是内函子。请记住:</p><blockquote class="jm jn jo"><p id="e418" class="jp jq jr js b jt ju ii jv jw jx il jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><em class="hh">“单子就是内函子范畴中的幺半群。有什么问题？”</em></p></blockquote><p id="ac4b" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">希望这句话开始变得更有意义了。我们稍后将讨论幺半群和幺半群。</p><h1 id="9ef0" class="le kz hh bd lf lg lh li lj lk ll lm ln in lo io lp iq lq ir lr it ls iu lt lu bi translated">构建您自己的函子</h1><p id="5ce5" class="pw-post-body-paragraph jp jq hh js b jt lv ii jv jw lw il jy kn lx kb kc ko ly kf kg kp lz kj kk kl ha bi translated">这里有一个函子的简单例子:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="81d6" class="ky kz hh kt b fi la lb l lc ld">const Identity = value =&gt; ({<br/>  map: fn =&gt; Identity(fn(value))<br/>});</span></pre><p id="5426" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">如你所见，它满足函子定律:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="289f" class="ky kz hh kt b fi la lb l lc ld">// trace() is a utility to let you easily inspect<br/>// the contents.<br/>const trace = x =&gt; {<br/>  console.log(x);<br/>  return x;<br/>};</span><span id="8190" class="ky kz hh kt b fi mp lb l lc ld">const u = Identity(2);</span><span id="9c29" class="ky kz hh kt b fi mp lb l lc ld">// Identity law<br/>u.map(trace);             // 2<br/>u.map(x =&gt; x).map(trace); // 2</span><span id="d9a9" class="ky kz hh kt b fi mp lb l lc ld">const f = n =&gt; n + 1;<br/>const g = n =&gt; n * 2;</span><span id="b7e1" class="ky kz hh kt b fi mp lb l lc ld">// Composition law<br/>const r1 = u.map(x =&gt; f(g(x)));<br/>const r2 = u.map(g).map(f);</span><span id="7d11" class="ky kz hh kt b fi mp lb l lc ld">r1.map(trace); // 5<br/>r2.map(trace); // 5</span></pre><p id="3f1c" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">现在，您可以映射任何数据类型，就像您可以映射数组一样。不错！</p><p id="01f0" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">这是JavaScript中函子所能达到的最简单程度，但是它缺少了JavaScript中数据类型的一些特性。我们来补充一下。如果<code class="du kq kr ks kt b">+</code>操作符可以处理数字和字符串值，那不是很酷吗？</p><p id="6da0" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">为了实现这一点，我们需要做的就是实现<code class="du kq kr ks kt b">.valueOf()</code>——这似乎也是一种从仿函数中解开值的便捷方式:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="2f47" class="ky kz hh kt b fi la lb l lc ld">const Identity = value =&gt; ({<br/>  map: fn =&gt; Identity(fn(value)),</span><span id="b71e" class="ky kz hh kt b fi mp lb l lc ld">  valueOf: () =&gt; value,<br/>});</span><span id="7580" class="ky kz hh kt b fi mp lb l lc ld">const ints = (Identity(2) + Identity(4));<br/>trace(ints); // 6</span><span id="a97d" class="ky kz hh kt b fi mp lb l lc ld">const hi = (Identity('h') + Identity('i'));<br/>trace(hi); // "hi"</span></pre><p id="147e" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">很好。但是如果我们想在控制台中检查一个<code class="du kq kr ks kt b">Identity</code>实例呢？如果上面写着<code class="du kq kr ks kt b">"Identity(value)"</code>，那就太酷了，对吧。让我们添加一个<code class="du kq kr ks kt b">.toString()</code>方法:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="4012" class="ky kz hh kt b fi la lb l lc ld">toString: () =&gt; `Identity(${value})`,</span></pre><p id="8dd4" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">酷毙了。我们可能还应该启用标准的JS迭代协议。我们可以通过添加自定义迭代器来实现:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="27b7" class="ky kz hh kt b fi la lb l lc ld">[Symbol.iterator]: function* () {<br/>  yield value;<br/>}</span></pre><p id="d79a" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">现在这将起作用:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="b194" class="ky kz hh kt b fi la lb l lc ld">// [Symbol.iterator] enables standard JS iterations:<br/>const arr = [6, 7, ...Identity(8)];<br/>trace(arr); // [6, 7, 8]</span></pre><p id="83b2" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">如果您想获取一个<code class="du kq kr ks kt b">Identity(n)</code>并返回一个包含<code class="du kq kr ks kt b">n + 1</code>、<code class="du kq kr ks kt b">n + 2</code>等等的标识数组，该怎么办？很简单，对吧？</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="6623" class="ky kz hh kt b fi la lb l lc ld">const fRange = (<br/>  start,<br/>  end<br/>) =&gt; Array.from(<br/>  { length: end - start + 1 },<br/>  (x, i) =&gt; Identity(i + start)<br/>);</span></pre><p id="1324" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">啊，但是如果你想让它适用于任何函子呢？如果我们有一个规范，规定数据类型的每个实例都必须有一个对其构造函数的引用，那会怎么样？那么你可以这样做:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="2e02" class="ky kz hh kt b fi la lb l lc ld">const fRange = (<br/>  start,<br/>  end<br/>) =&gt; Array.from(<br/>  { length: end - start + 1 },<br/>  <br/>  // change `Identity` to `start.constructor`<br/>  (x, i) =&gt; start.constructor(i + start)<br/>);</span><span id="9985" class="ky kz hh kt b fi mp lb l lc ld">const range = fRange(Identity(2), 4);<br/>range.map(x =&gt; x.map(trace)); // 2, 3, 4</span></pre><p id="1e5f" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">如果你想测试一个值是否是函子呢？我们可以在<code class="du kq kr ks kt b">Identity</code>上添加一个静态方法来检查。我们应该加入一个静态的<code class="du kq kr ks kt b">.toString()</code>:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="882b" class="ky kz hh kt b fi la lb l lc ld">Object.assign(Identity, {<br/>  toString: () =&gt; 'Identity',<br/>  is: x =&gt; typeof x.map === 'function'<br/>});</span></pre><p id="d92d" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">让我们把这些放在一起:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="b14d" class="ky kz hh kt b fi la lb l lc ld">const Identity = value =&gt; ({<br/>  map: fn =&gt; Identity(fn(value)),<br/>  valueOf: () =&gt; value,<br/>  toString: () =&gt; `Identity(${value})`,<br/>  [Symbol.iterator]: function* () {<br/>    yield value;<br/>  },<br/>  constructor: Identity<br/>});</span><span id="15be" class="ky kz hh kt b fi mp lb l lc ld">Object.assign(Identity, {<br/>  toString: () =&gt; 'Identity',<br/>  is: x =&gt; typeof x.map === 'function'<br/>});</span></pre><p id="d9db" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">注意，你不需要所有这些额外的东西来证明某个东西是函子或者内函子。严格来说是为了方便。对于仿函数，<em class="jr">所需要的</em>就是一个满足仿函数法则的<code class="du kq kr ks kt b">.map()</code>接口。</p><h1 id="1dac" class="le kz hh bd lf lg lh li lj lk ll lm ln in lo io lp iq lq ir lr it ls iu lt lu bi translated">为什么是函子？</h1><p id="075c" class="pw-post-body-paragraph jp jq hh js b jt lv ii jv jw lw il jy kn lx kb kc ko ly kf kg kp lz kj kk kl ha bi translated">函子很棒有很多原因。最重要的是，它们是一种抽象，您可以用它来实现许多有用的东西，并且可以处理任何数据类型。例如，如果你想开始一个操作链，但是只有当仿函数中的值不是<code class="du kq kr ks kt b">undefined</code>或<code class="du kq kr ks kt b">null</code>时，该怎么办？</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="d103" class="ky kz hh kt b fi la lb l lc ld">// Create the predicate<br/>const exists = x =&gt; (x.valueOf() !== undefined &amp;&amp; x.valueOf() !== null);</span><span id="8e78" class="ky kz hh kt b fi mp lb l lc ld">const ifExists = x =&gt; ({<br/>  map: fn =&gt; exists(x) ? x.map(fn) : x<br/>});</span><span id="a82a" class="ky kz hh kt b fi mp lb l lc ld">const add1 = n =&gt; n + 1;<br/>const double = n =&gt; n * 2;</span><span id="d51e" class="ky kz hh kt b fi mp lb l lc ld">// Nothing happens...<br/>ifExists(Identity(undefined)).map(trace);<br/>// Still nothing...<br/>ifExists(Identity(null)).map(trace);</span><span id="71d4" class="ky kz hh kt b fi mp lb l lc ld">// 42<br/>ifExists(Identity(20))<br/>  .map(add1)<br/>  .map(double)<br/>  .map(trace)<br/>;</span></pre><p id="2711" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">当然，函数式编程就是组合微小的函数来创建更高层次的抽象。如果你想要一个通用的映射，可以和任何仿函数一起工作呢？这样，您可以部分应用参数来创建新函数。</p><p id="f53d" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">简单。选择你最喜欢的自动咖喱，或者使用之前的魔咒:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="cfdc" class="ky kz hh kt b fi la lb l lc ld">const curry = (<br/>  f, arr = []<br/>) =&gt; (...args) =&gt; (<br/>  a =&gt; a.length === f.length ?<br/>    f(...a) :<br/>    curry(f, a)<br/>)([...arr, ...args]);</span></pre><p id="12f0" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">现在我们可以自定义地图:</p><pre class="ix iy iz ja fd ku kt kv kw aw kx bi"><span id="a2ac" class="ky kz hh kt b fi la lb l lc ld">const map = curry((fn, F) =&gt; F.map(fn));</span><span id="94aa" class="ky kz hh kt b fi mp lb l lc ld">const double = n =&gt; n * 2;</span><span id="66eb" class="ky kz hh kt b fi mp lb l lc ld">const mdouble = map(double);<br/>mdouble(Identity(4)).map(trace); // 8</span></pre><h1 id="58f8" class="le kz hh bd lf lg lh li lj lk ll lm ln in lo io lp iq lq ir lr it ls iu lt lu bi translated">结论</h1><p id="2ac7" class="pw-post-body-paragraph jp jq hh js b jt lv ii jv jw lw il jy kn lx kb kc ko ly kf kg kp lz kj kk kl ha bi translated">函子是我们可以映射的东西。更具体地说，函子是从范畴到范畴的映射。函子甚至可以从一个类别映射回同一个类别(即<em class="jr">内函子</em>)。</p><p id="2727" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">类别是对象的集合，对象之间有箭头。箭头代表态射(又名函数，又名合成)。范畴中的每个对象都有一个同一性态射(<code class="du kq kr ks kt b">x =&gt; x</code>)。对于任何对象链<code class="du kq kr ks kt b">A -&gt; B -&gt; C</code>，一定存在一个组合<code class="du kq kr ks kt b">A -&gt; C</code>。</p><p id="dc41" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">函子是很好的高阶抽象，允许您创建各种通用函数，适用于任何数据类型。</p><p id="06d3" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated"><a class="ae km" rel="noopener" href="/javascript-scene/functional-mixins-composing-software-ffb66d5e731c"> <strong class="js hi">接下来:函数混合&gt; </strong> </a></p><h1 id="fd11" class="le kz hh bd lf lg lh li lj lk ll lm ln in lo io lp iq lq ir lr it ls iu lt lu bi translated">通过实时1:1辅导提升您的技能</h1><p id="2db8" class="pw-post-body-paragraph jp jq hh js b jt lv ii jv jw lw il jy kn lx kb kc ko ly kf kg kp lz kj kk kl ha bi translated">DevAnywhere是达到高级JavaScript技能的最快方法:</p><ul class=""><li id="5aa2" class="ma mb hh js b jt ju jw jx kn mc ko md kp me kl mo mg mh mi bi translated">现场课程</li><li id="58c2" class="ma mb hh js b jt mj jw mk kn ml ko mm kp mn kl mo mg mh mi bi translated">弹性工时</li><li id="b984" class="ma mb hh js b jt mj jw mk kn ml ko mm kp mn kl mo mg mh mi bi translated">一对一指导</li><li id="cdc0" class="ma mb hh js b jt mj jw mk kn ml ko mm kp mn kl mo mg mh mi bi translated">构建真正的生产应用</li></ul><figure class="ix iy iz ja fd jb er es paragraph-image"><a href="https://devanywhere.io/"><div class="er es mq"><img src="../Images/03504ae5b049cdb99861a7b575be3a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pskrI-ZjRX_Y0I0zZqVTcQ.png"/></div></a><figcaption class="ji jj et er es jk jl bd b be z dx"><a class="ae km" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank">https://devanywhere.io/</a></figcaption></figure></div><div class="ab cl mr ms go mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ha hb hc hd he"><p id="b215" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated"><strong class="js hi"> <em class="jr">埃里克·艾略特</em> </strong> <em class="jr">是</em> <a class="ae km" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="jr">【编程JavaScript应用】</em> </a> <em class="jr"> (O'Reilly)的作者，也是</em> <a class="ae km" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank">的联合创始人<em class="jr">devanywhere . io</em></a><em class="jr">。他为Adobe Systems的</em><strong class="js hi"><em class="jr">Adobe Systems</em></strong><em class="jr"/><strong class="js hi"><em class="jr">Zumba Fitness</em></strong><em class="jr"/><strong class="js hi"><em class="jr">华尔街日报</em></strong><em class="jr"/><strong class="js hi"><em class="jr">ESPN</em></strong><em class="jr"/><strong class="js hi"><em class="jr">BBC</em></strong><em class="jr">等顶级录音师贡献了软件经验</em></p><p id="98ef" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">他和世界上最美丽的女人一起在任何他想去的地方工作。</p></div></div>    
</body>
</html>