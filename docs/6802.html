<html>
<head>
<title>Increase performance of Angular application. Use change detection correctly.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高角度应用的性能。正确使用变更检测。</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/increase-performance-of-angular-application-use-change-detection-correctly-c43a9aad099?source=collection_archive---------0-----------------------#2020-01-19">https://medium.com/quick-code/increase-performance-of-angular-application-use-change-detection-correctly-c43a9aad099?source=collection_archive---------0-----------------------#2020-01-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><h2 id="c48d" class="hf hg hh bd b fp hi hj hk hl hm hn dx ho translated" aria-label="kicker paragraph">角度指南</h2><div class=""/><div class=""><h2 id="fb16" class="pw-subtitle-paragraph in hq hh bd b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je dx translated">角度性能</h2></div><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/fd3501cfc28453088bdef836274564b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hyiQ1gsrzVBC8Lp1W3KtLg.png"/></div></div></figure><p id="64e5" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">在我们开始讨论变化检测策略之前，我们需要讨论可变和不可变类型。</p><p id="03e2" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">可变变量是一种可以改变的变量类型(对象、数组、函数)。不可变是一种类型，一旦对象被创建，其状态就不能被改变(字符串、数字、布尔)。</p><p id="ae02" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">我们不能改变字符串值，每次当我们改变字符串值的时候，我们就产生了一个新的字符串。当我们处理对象时，我们可以改变任何属性。知道这一点很重要。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es kn"><img src="../Images/bbab17f260f6c344396e8231c5c4e12f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*GCCN6nnq23f3BbMNHkCtng.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx">Example of mutable and immutable</figcaption></figure><p id="7a93" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated"><strong class="jt hr">变化检测策略</strong></p><p id="81e1" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">在html中我们可以写“<label>用户名{{name}} </label>，如果名字已经改变了我们必须显示出来，这是怎么发生的？角形中的每一个分量都有一个变化探测器，如果有什么东西发生了变化，变化探测器是知道它的。</p><p id="7a84" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">有两种变化检测策略:默认和onPush。</p><p id="49cf" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">如果您没有在组件中设置更改检测策略，它将是“默认”的。</p><p id="b184" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">想象一下组件树，默认情况下，如果主组件发生变化，树中的每个内部组件都会被检查，它会比较以前的值和新值，如果它们不同，新值就会显示出来。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es ks"><img src="../Images/ed30756539a61d996a8466745f37afa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUFpJ8jQQSNEfhfZeaRcbg.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Default strategy</figcaption></figure><p id="6ae9" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">有时，并非所有组件都必须检查并显示新值。如果你的页面上有5-10个组件，这不会是一个大问题，但是如果你的树中有50-100个组件，这些检查将是一个巨大的时间浪费。当一个值改变时，这个循环将一遍又一遍地重复。</p><p id="72a5" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated"><strong class="jt hr"> OnPush策略</strong></p><p id="0350" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">OnPush策略的工作方式不同，如果输入对象上的链接发生了变化，它会通知组件。如果输入对象的属性被更改，树中的组件将不会得到通知。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kt"><img src="../Images/ef44d3b9e73d44be59328e6fd24064be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tAIKDaeFUaETQHwfM22KZw.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">OnPush strategy</figcaption></figure><p id="260f" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">我们来做一个小组件树。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es ku"><img src="../Images/05c8094354b1d12b1c6bc2aba6e543c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GClpdt2JznA89bTq_KuFXg.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Out component tree</figcaption></figure><p id="434b" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">我们有3个组件和1个输入对象。主组件-&gt;子组件-&gt;深度组件。在主要组件中我们有2个方法可以改变用户的姓名。</p><p id="6dee" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">如果我们选择“默认”变化检测策略，当我们点击按钮时一切正常，树中的每个组件都会得到通知。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kv"><img src="../Images/3c611088584329a8976252c7721afb79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kfx5SQPD9K6edR8pIgq5Wg.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">ChangeDetectionStrategy.Default</figcaption></figure><p id="f186" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">但是，当我们设置“OnPush”更改检测策略并开始单击按钮时，什么也没有发生，因为输入对象上的链接没有更改，我们只是更改了该对象的属性。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kw"><img src="../Images/a5183328d30ff0784e2ad711e4b1c320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ia54BWg2fHoYDuJ2FezJsA.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">ChangeDetectionStrategy.OnPush</figcaption></figure><p id="88d7" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">让我们创建另外两个改变名字和姓氏的方法，但是我们也将创建一个具有新属性的新对象。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kx"><img src="../Images/efa627db601e69bafea974245bfea041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-zNCiIHtLeUjD6C3nYCWw.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Methods where we create a new object</figcaption></figure><p id="67de" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">现在它工作了，因为我们用一个新的物体代替了旧的物体。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es ky"><img src="../Images/05fac338b2b74cdfb0097ee6b96fae80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iZ5MGhocnvX3FYZ71XTo1g.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">Create a new object with changed properties</figcaption></figure><p id="02c7" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated"><strong class="jt hr">ngdoccheck</strong></p><p id="2f61" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">如果我们不想为输入对象创建一个新的副本，因为这个对象太大了，怎么办？解决方法之一是使用一个“ngDoCheck”方法。</p><p id="c18c" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">当我们通过点击按钮来改变输入对象的属性时，我们触发了子组件的“ngDoCheck”方法。在这种方法中，我们需要手动检查变更。如果我们发现一个变化，我们需要告诉它Angular，为此我们需要使用一个ChangeDetectorRef类。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kz"><img src="../Images/a273f633c3763512901d84f21397e6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_yuaPJFesxkdVEMn_95HBQ.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">‘ngDoCheck’ method</figcaption></figure><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es la"><img src="../Images/62fa745fcd9d966e440de48a712cfe6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3uLfOKwseA8VgCyIt913iA.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">‘ngDoCheck’ result</figcaption></figure><p id="f2b7" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">如你所见，当我们更改“DeepComponent”的“ngDoCheck”姓氏时，没有调用它，因为在“SubComponent”中，我们没有处理这种情况，也没有调用“markForCheck”方法。此方法仅通知层次结构中子组件的更改。</p><p id="c5ab" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">此外，如果我们使用“setTimeout”方法或等待来自服务器的响应，则不会触发子组件中的方法“ngDoCheck”。为了处理这些情况，我们需要在“ChangeDetectorRef”类中使用“markForCheck”方法。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lb"><img src="../Images/df57fae19099177d8115af4e38aed7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8ZIqkFDCqz-fhE-a3SPqA.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">setTimeout methods</figcaption></figure><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es lc"><img src="../Images/e52cbaabc7c55f80601fbe72a3b88aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sqTULH0P9oVHCC6bm-LLmQ.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx">setTimeout result</figcaption></figure><p id="13cf" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">“OnPush”策略的另一个解决方案是创建一个观察者服务，并在其上进行订阅。</p><p id="d167" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">现在我们知道了不同的变化检测策略，以及不同的策略如何提高我们的应用程序的性能。</p><p id="ffc5" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated">如果你需要仔细看看项目<a class="ae ld" href="https://github.com/8Tesla8/change-detection" rel="noopener ugc nofollow" target="_blank">，这里有链接。</a></p></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><p id="2200" class="pw-post-body-paragraph jr js hh jt b ju jv ir jw jx jy iu jz ka kb kc kd ke kf kg kh ki kj kk kl km ha bi translated"><em class="ll">原载于2020年1月19日</em><a class="ae ld" href="https://tomorrowmeannever.com/2020/01/19/increase-performance-of-angular-application-use-change-detection-correctly/" rel="noopener ugc nofollow" target="_blank"><em class="ll">【http://tomorrowmeannever.com】</em></a><em class="ll">。</em></p></div></div>    
</body>
</html>