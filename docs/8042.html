<html>
<head>
<title>ACF: Automated Code Formation ( Engineering Excellence)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ACF:自动化代码形成(工程卓越)</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/acf-automated-code-formation-engineering-excellence-3dd77b2f39df?source=collection_archive---------1-----------------------#2021-08-04">https://medium.com/walmartglobaltech/acf-automated-code-formation-engineering-excellence-3dd77b2f39df?source=collection_archive---------1-----------------------#2021-08-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/0f3d75e915b1652579f58394e68d639d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mv9Bu7niRwJ3kZVoYvqR5g.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Figure 1: ACF custom header image</figcaption></figure><h1 id="713e" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">代码作为模板:涵盖IaaC、工作流、UI屏幕、数据库模式和后端API</h1><h1 id="4988" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated"><strong class="ak">简介</strong>:</h1><p id="a206" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated"><strong class="jt hi">代码形成</strong>和作为模板的代码发展非常迅速，随着我们向卓越工程迈进，我们需要评估IaaC(以下称为代码)和<strong class="jt hi"> CaaT </strong>(作为模板的代码)的自动部署、持续集成和管理的选项。</p><p id="13f2" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">在这篇博文中，我们的目标是谈论<strong class="jt hi">“代码形成框架”</strong>及其不同组件的设计。我们创建了这个框架来生成管理基础设施的代码。该框架包括创建web UI、后端API，然后从规范文件和资产构建器连接它们。</p><h1 id="a9f3" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">目标:</h1><p id="5b11" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">我们的目标是编排“微应用和基础设施代码”，然后将其作为自助服务平台，供用户部署和管理他们的云资源。</p><p id="00db" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">这里的微应用由微前端、绑定的后端微服务和作为代码的基础设施组成，包括Terraform模块和工作流。</p><p id="a6e8" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">要为Azure的Azure Redis Cache(云资源)等服务产品创建自助服务平台，我们需要以下组件。</p><ul class=""><li id="f45f" class="ku kv hh jt b ju kp jy kq kc kw kg kx kk ky ko kz la lb lc bi translated">用于从用户处获取规范的UI</li><li id="9395" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">后端API处理具有规范的请求并传递它</li><li id="ee9d" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">数据库来存储和获取规范</li><li id="c5f1" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">使用规范部署云资源的Terraform代码</li><li id="bc06" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">集成生态系统和所有其他组件的工作流程</li></ul><h1 id="7e2e" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated"><strong class="ak">设计:</strong></h1><p id="c5ce" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">“代码形成框架”的基本设计是基于6个重要组件创建的</p><ol class=""><li id="0901" class="ku kv hh jt b ju kp jy kq kc kw kg kx kk ky ko li la lb lc bi translated">模板</li><li id="4fed" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko li la lb lc bi translated">规格文件</li><li id="aaaf" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko li la lb lc bi translated">实体关系模型</li><li id="6752" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko li la lb lc bi translated">图书馆</li><li id="a83b" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko li la lb lc bi translated">资产生成器</li><li id="1395" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko li la lb lc bi translated">部署</li></ol><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/0042e32094abf627268f0859909921c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fBZKZ8XTYe1_04DcDyLAxw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><strong class="bd iv">Figure 2: High-level view of “Code Formation” framework. </strong>( k8 icon photo reference <a class="ae lo" href="https://commons.wikimedia.org/wiki/File:Kubernetes_(container_engine).png" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/wiki/File:Kubernetes_(container_engine).png</a>, git icon photo reference <a class="ae lo" href="https://iconscout.com/icon/git-free-opensource-distributed-version-control-system-square" rel="noopener ugc nofollow" target="_blank">https://iconscout.com/icon/git-free-opensource-distributed-version-control-system-square</a> )</figcaption></figure><p id="7e6a" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">让我们来理解上面的每一个</p><p id="7a88" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi"> 1。模板:</strong></p><p id="e77f" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">代码模板对于框架的每个部分都是非常重要的组件。<strong class="jt hi">代码模板</strong>是可重用的代码片段，允许您快速插入常用的代码片段。</p><p id="376c" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">IaaC terraform模板生成Terraform main.tf文件、variables.tf文件、provider.tf文件和outputs.tf文件。</p><p id="ed6c" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">下面以Azure Redis缓存为例，详细介绍了其中的每一项。</p><p id="2ea0" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi"> Variables.tf </strong> <em class="lp">:位置、订阅、缓存层、缓存名称、SKU、订阅详情等。</em></p><p id="0d15" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi">main . TF:</strong><em class="lp">Terraform的实际资源和模块代码，用于部署资源。</em></p><p id="9a26" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi"> provider.tf: </strong> <em class="lp">由required_providers块组成，它指定了提供者的本地名称、源地址和版本。</em></p><p id="b238" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi"> Outputs.tf: </strong> <em class="lp">它有Terraform模块的返回值。</em></p><p id="bbaf" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">类似地，工作流模板用于生成工作流Yaml文件，这些文件通过concord(<a class="ae lo" href="https://github.com/walmartlabs/concord" rel="noopener ugc nofollow" target="_blank">https://github.com/walmartlabs/concord</a>)执行。模板是用Jinja2编写的，其中一些可以定制。</p><p id="534f" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi">注</strong>:样本工作流程YAML模板</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/76ebda121071fb7c21994a88965eddba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DlsVD0WtkvQ-riFf4nbu1A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Figure 3: Snippet of an example of workflow template</figcaption></figure><p id="9683" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">目标是使该框架成为基于云资源需求的插件式应用程序。我们所要做的就是添加新模板或更改现有模板。</p><p id="cef6" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi">注意:</strong>示例application.properties模板。</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Figure 4: Example of an application.properties template.</figcaption></figure><p id="da79" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi"> 2。规格文件:</strong></p><p id="ff89" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">规格文件是决定结果、执行策略和部署顺序的框架的骨架。</p><p id="24cf" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">等级库文件放置在等级库存储库中。当开发人员对master上的新流提出pull请求时，代码形成流将在PR合并期间被触发。</p><p id="3d54" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi">注</strong>:可以分叉整个项目的Spec文件示例。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lt"><img src="../Images/e7c61664e572aea43e18de61d4ec15a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QLScu6yAENAhkXHJ5vwJwQ.png"/></div></div></figure><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lu"><img src="../Images/784a525062520a905b9cf19aded6a17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XrUZdwu-a4qAF4tDtpQN9Q.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Figure 5: Example of a Spec template.</figcaption></figure><p id="e9c1" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi"> 3。实体关系模型:</strong></p><p id="cab4" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">部署有一个已定义的ER模型，在为后端API生成代码时，该模型在整个CI流程中是同步的。</p><p id="f517" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi">注</strong>:实体数据关系示例。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lv"><img src="../Images/6175fe6d2d8e5996c9e4dc948e80f2f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FDqN_hRYXrxzK0Rkpe38g.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Figure 6: ER model</figcaption></figure><ul class=""><li id="effe" class="ku kv hh jt b ju kp jy kq kc kw kg kx kk ky ko kz la lb lc bi translated">包括客户信息在内的所有服务细节都存储在客户服务实体中。每个客户服务可以有3个服务实例—特定云服务的开发/阶段/生产。</li><li id="8be3" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">服务实例实体包含每个服务的环境细节。</li><li id="de42" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">流程实体用于在每个服务实例完成任何活动时跟踪流程的类型。通过更新服务实例实体中相应的流程id来跟踪在服务实例上完成的最后一个操作。</li><li id="74aa" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">由于多个进程可以并行运行，为了管理当前正在运行的进程上的锁，使用了Schedular锁实体。</li><li id="e4ec" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">使用区域映射实体，供应表格动态地反映当前可用的区域。</li></ul><p id="d3bc" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi"> 4。库:</strong></p><p id="2152" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">大部分代码都是可重用的，因此已经提前为构建时代码生成创建了库，例如Slack和电子邮件通知、UI映射器、自定义字段等。也有直接用于云服务代码的运行时库，如推送云资源上的RBAC控件、资源供应平台代码、资源删除平台代码等。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div class="er es lw"><img src="../Images/deada082a5f700144d37e2fbf81198d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*5D6T-WLESbBqz_cqQhPlPw.jpeg"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Figure 7: CICD for library Management</figcaption></figure><p id="a017" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">库管理的CICD:库被版本化，并作为框架包的一部分使用。对库的任何新更新都将被版本化，开发人员可以用新的lib版本更新规范，这将重新触发管道来部署代码。</p><p id="a392" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi"> 5。资产生成器:</strong></p><p id="dfd1" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">以下是资产构建器经历的步骤</p><ul class=""><li id="9d46" class="ku kv hh jt b ju kp jy kq kc kw kg kx kk ky ko kz la lb lc bi translated">步骤1:为项目创建git存储库</li><li id="b63f" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">步骤2:它解析spec文件和模板来生成代码。</li><li id="7c72" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">步骤3:它用生成的代码向新创建的repo的发布分支发出一个pull请求。</li><li id="f024" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">步骤4:它通过单元测试案例和集成测试套件运行代码。</li><li id="dcb0" class="ku kv hh jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">步骤5:它在Sonar上发布代码覆盖率</li></ul><figure class="lk ll lm ln fd ii er es paragraph-image"><div class="er es lx"><img src="../Images/feb0aecc3d74c44824cc18e5a706c8c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*PW1SVfvtR_1SffH2avtjOw.jpeg"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><strong class="bd iv">Figure 8: Asset builder flow. </strong>(git icon photo reference <a class="ae lo" href="https://iconscout.com/icon/git-free-opensource-distributed-version-control-system-square" rel="noopener ugc nofollow" target="_blank">https://iconscout.com/icon/git-free-opensource-distributed-version-control-system-square</a> )</figcaption></figure><p id="7c1e" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi"> 6。部署:</strong></p><p id="e16a" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">向git repo的发布分支创建一个pull请求，并通过框架生成代码。这带来了通过自动部署在K8运行的基本版本。为了确保没有人工干预，所有新的更改都必须通过规范更新进行。</p><p id="40aa" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">通过代码形成引擎生成的文件被标记为“受管文件”，确保开发人员遵循正确的CI流程进行重建，并且在发生任何更改的情况下，这些更改都应该经过代码形成框架。</p><p id="e54b" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">这在项目中引入了设计良好的CI和CD流程，实现了git存储库、命名约定、文件夹结构、构建管道和发布管理的标准化。</p><p id="2232" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">Kubernetes是一个用于管理容器化工作负载和服务的开源平台，用于部署该容器。</p><p id="342b" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi">注</strong>:K8 YAML部署模板示例</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Figure 9: Example snippet of K8 deployment file template</figcaption></figure><h1 id="934a" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">执行和生命周期:</h1><p id="8ddf" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">代码生成框架有两种类型的用户。</p><p id="267c" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi">自动化代码形成的开发人员</strong>:开发人员负责更新和管理库，创建模板，更新资产构建器以支持新的库，以及添加新的模板。</p><p id="0567" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><strong class="jt hi">自动化代码形成的消费者</strong>:消费者将通过编写规范文件和运行代码形成引擎，使用代码形成引擎来管理部署的应用程序。</p><figure class="lk ll lm ln fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ly"><img src="../Images/36d4c5bc51839e0f6715ed64437ccbb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hRXYF11UWOs1mLYZ2V_7pQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><strong class="bd iv">Figure 10: Overall flow of the code formation engine and the outcome. </strong>(git icon photo reference <a class="ae lo" href="https://iconscout.com/icon/git-free-opensource-distributed-version-control-system-square" rel="noopener ugc nofollow" target="_blank">https://iconscout.com/icon/git-free-opensource-distributed-version-control-system-square</a> )</figcaption></figure><h1 id="d925" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">结果是:</h1><p id="5c3d" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">我们的目标是编排“微应用和基础设施代码”，然后将其作为自助服务平台，供用户部署和管理他们的云资源。我们实现了目标，此外，我们还将引入云资源自助服务平台的MTTM(平均上市时间)从26周缩短到不到2周。</p></div><div class="ab cl lz ma go mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ha hb hc hd he"><p id="4ad9" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">本文展示的工作是由一个优秀的工程师团队完成的。</p><p id="c4d0" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">工程团队:<strong class="jt hi">杜亚·马图尔</strong>，<strong class="jt hi">安东·谢尔科诺夫，安基塔·贾斯瓦尔，穆妮卡·耶拉马拉，斯里尼迪·科拉帕蒂，马赫什·佩达瓦利</strong></p></div></div>    
</body>
</html>