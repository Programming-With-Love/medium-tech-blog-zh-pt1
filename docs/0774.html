<html>
<head>
<title>AGSL: Made in the Shade(r)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AGSL:在阴影中制造</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/agsl-made-in-the-shade-r-7d06d14fe02a?source=collection_archive---------2-----------------------#2022-11-17">https://medium.com/androiddevelopers/agsl-made-in-the-shade-r-7d06d14fe02a?source=collection_archive---------2-----------------------#2022-11-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="50b4" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">渲染效果# 2:Android 13中的像素着色器</h2></div><p id="9a79" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<a class="ae js" rel="noopener" href="/@chethaase/blurring-the-lines-4fd33821b83c">的上一篇文章</a>中，我展示了如何创建一个模糊<code class="du jt ju jv jw b">RenderEffect</code>来轻松模糊<code class="du jt ju jv jw b">View</code>中的所有东西。这种效果虽然有趣，但它本身并不十分有用。我们希望事物看得更清楚，而不是更模糊。这就是我们戴眼镜的原因。以及为什么我们要不断清理眼镜上的污渍。</p><p id="0f03" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">和上一篇文章一样，这篇文章基于(阅读:是更详细的版本)我和Sumir Kataria为最近的Android开发者峰会制作的Android图形视频的一部分。但不要相信我的话；你可以在这里观看:</p><figure class="jx jy jz ka fd kb"><div class="bz dy l di"><div class="kc kd l"/></div><figcaption class="ke kf et er es kg kh bd b be z dx">The video version of these two articles, which also includes information on Pen &amp; Stylus, and SurfaceView vs TextureView. It’s a lot to cover in a 16 minute video. We talk fast.</figcaption></figure><h1 id="254f" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">模糊推理</h1><p id="5d8e" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">模糊是一种有用的效果，可以将用户的注意力吸引到场景中的其他元素上。这是摄影中一种常见的技术，视觉效果被用来帮助观众理解该往哪里看。摄影师通过聚焦特定的对象来做到这一点，而前景或背景中的其他元素由于景深而变得模糊。被聚焦的物体的较硬的边缘会立刻吸引我们的注意力，而未聚焦的元素会逐渐消失在背景中。</p><p id="a73b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">类似地，在卡通动画中，人们希望在特定的时间将注意力吸引到关键的主题上，以确保观众跟随重要的动作。然而，实现这种效果的技术不一定涉及聚焦/模糊，所以我将动画的话题放在一边。我提到它是因为有趣的是，所有这些领域都存在相同的优先事项——快速引导有限的人类注意力范围，以帮助传递任何视觉场景的重要信息。</p><p id="e2fc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我创建上一篇文章中看到的模糊效果的原因是因为我希望模糊的图像容器成为我希望观众关注的实际事物的背景:画廊中一张图片的特写。在我的演示中，当用户点击一张图片时，会出现一个弹出窗口，显示该图片的放大图。弹出版本是清晰的，而背景是模糊的。这有助于消除所有这些不相关图像背景中的噪声信息，因此用户可以专注于他们选择的图片。</p><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/3d022602caa91cab0d9ed771f9770d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YzAFRSF4PEO5lkfUjDn2ow.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">Having the background blurred allows the viewer to focus on the larger image that is shown on top.</figcaption></figure><p id="2c6b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是在这个演示中不仅仅是背景模糊。除了<code class="du jt ju jv jw b">RenderEffect</code>提供的模糊背景，我想使用Android 13+中启用的新<code class="du jt ju jv jw b">RuntimeShader</code>效果。你可以在上图的标签中看到结果。标签是半透明的，因此您可以看到它所覆盖的图像的底部，但标签背景是磨砂的，并且(稍微)模糊，以使标题更清晰。这两种效果都是用AGSL着色器实现的。</p><h1 id="d660" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">Android中的碎片着色器！</h1><p id="6f34" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">AGSL是Android 13中的一项新功能，通过[也是新的] <code class="du jt ju jv jw b">RuntimeShader</code> API访问。我将介绍所有这些是什么以及如何使用它们。但首先，我们来谈谈碎片着色器。</p><p id="0c6f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我应该指出，<em class="lf">片段</em>基本上与<em class="lf">像素</em>相同，除了片段指的是实际出现在屏幕上的几何图形片段(并且没有被裁剪掉或忽略)。另一方面，像素就是屏幕上的每个像素(“图片元素”)。片段着色器最初(有时仍然)被称为<em class="lf">像素着色器</em>，但<em class="lf">片段着色器</em>是更通用、更正确的术语。</p><p id="4bcd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">随着冗长乏味的术语的消失…什么是着色器？</p><p id="eb24" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">片段着色器是在图像的每个片段上运行的小程序，用于计算应该出现在那里的颜色值。这是一个形象化的例子。想象一下在视图的每个像素上运行的代码产生的nean球体效果…因为这正是正在发生的事情。</p><figure class="jx jy jz ka fd kb er es paragraph-image"><div class="er es ln"><img src="../Images/6cb059497b78385d58379e9eceedd260.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*XEmIECXeoWZ3n09g1_elWg.gif"/></div><figcaption class="ke kf et er es kg kh bd b be z dx">Shader code runs on every fragment to determine the resulting colors. (shader source: <a class="ae js" href="http://twitter.com/XorDev" rel="noopener ugc nofollow" target="_blank">@XorDev</a> <a class="ae js" href="https://twitter.com/XorDev/status/1475524322785640455" rel="noopener ugc nofollow" target="_blank">https://twitter.com/XorDev/status/1475524322785640455</a>)</figcaption></figure><blockquote class="lo lp lq"><p id="78e6" class="iw ix lf iy b iz ja ii jb jc jd il je lr jg jh ji ls jk jl jm lt jo jp jq jr ha bi translated">此时你可能会想:等等，一个程序正在每一个像素上运行？工作量不是很大吗？嗯，是的。但这只是GPU的工作方式；片段着色器是计算GPU渲染的最终像素颜色的机制。自从我们的第一个硬件加速渲染器在Android 3.0 Honeycomb中出现以来，我们已经在Android上为所有渲染运行片段着色器很多年了。与AGSL的唯一区别是，我们现在允许您将自己的代码注入到着色器中，这些着色器已经由渲染器代表您进行了构建。</p></blockquote><p id="78a8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看一个例子:</p><pre class="jx jy jz ka fd lu jw lv lw aw lx bi"><span id="1e01" class="ly kj hh jw b fi lz ma l mb mc">uniform shader input;</span><span id="a3d3" class="ly kj hh jw b fi md ma l mb mc">vec4 main(vec2 coords) {<br/>    vec4 red = vec4(1, 0, 0, 1);<br/>    return mix(input.eval(coords), red, .5);</span><span id="aa48" class="ly kj hh jw b fi md ma l mb mc">}</span></pre><p id="a388" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个着色器有一个<code class="du jt ju jv jw b">input</code>变量，它是被着色的源。着色器还接收当前像素的<code class="du jt ju jv jw b">coords</code>，通过调用输入着色器上的<code class="du jt ju jv jw b">eval(coords)</code>，我们可以从中检索该(x，y)位置的当前颜色值。</p><p id="5dd5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们创建一个变量<code class="du jt ju jv jw b">red</code>来保存不透明的红色，然后通过<code class="du jt ju jv jw b">mix()</code>函数将它与当前值合并，该函数在这些颜色之间进行线性插值。在这种情况下，我们使用每种颜色的一半(. 5)来生成并返回像素的最终颜色值。结果是这样的:</p><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es me"><img src="../Images/59c27f0cc63fdf5d18bed40c667176cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EewFYZCcIb_8tZGavqXBOg.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">The result of running the shader above on every fragment of the image on the left to produce the red-tinted image on the right.</figcaption></figure><h1 id="32f3" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">AGSL:Android的碎片着色器</h1><p id="e569" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">好了，这就是着色器。什么是AGSL？</p><p id="54a2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Android图形着色语言(AGSL)是用于为Android编写着色器的语言。AGSL本质上是<a class="ae js" href="https://skia.org/docs/user/sksl/" rel="noopener ugc nofollow" target="_blank"> SkSL </a>，代表Skia Shading Language，其中<a class="ae js" href="https://skia.org/" rel="noopener ugc nofollow" target="_blank"> Skia </a>是Android(以及其他客户端平台，包括Chrome)的渲染引擎。我们将SkSL重命名为AGSL，从本质上简化API，以避免在Android API表面中间解释Skia是什么(这正是我在这里必须做的，但在文章中比在API参考文档中间更好一点)。</p><p id="de11" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">AGSL几乎(但不完全)等同于GLSL ES1.0，GLSL是OpenGL ES的着色语言。这并不完全相同，因为SkSL的着色器使用与GLSL略有不同。在OpenGL中，您可以传递决定最终像素颜色的着色器。但是使用AGSL，你可以在Skia渲染管道的中间插入一个着色器。Skia已经在创建和使用着色器，这些着色器执行诸如剪切几何体和确定(和着色)几何体的抗锯齿边界的任务。一个AGSL着色器被添加到该着色器集中，这些着色器被组合在一起以产生由GPU绘制的最终像素值。</p><p id="7944" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">SkSL着色器的例子可以在<a class="ae js" href="https://shaders.skia.org/" rel="noopener ugc nofollow" target="_blank">shaders.skia.org</a>找到，在那里你也可以在线玩和调试着色器代码。</p><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mf"><img src="../Images/3435a00cd02d9522cb1dc81587220512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YnEDtCFZHPSuheQvF5559A.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx"><a class="ae js" href="https://shaders.skia.org/" rel="noopener ugc nofollow" target="_blank">shaders.skia.org</a> has several example SkSL shaders and tools for editing and debugging shaders</figcaption></figure><h1 id="2318" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">着色器与着色器</h1><p id="9e62" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">现在你的脑海中可能正在形成一个问题:Android不是已经有了一个<code class="du jt ju jv jw b">Shader</code> API吗？其实我之前关于<code class="du jt ju jv jw b">RenderEffect</code> s的文章不是已经讲过了吗？是的，是的。没有。</p><p id="a7de" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">是的</strong>，安卓有一个<code class="du jt ju jv jw b">Shader</code> API: <code class="du jt ju jv jw b">android.graphics.Shader</code>。引用参考文档:</p><blockquote class="lo lp lq"><p id="94dc" class="iw ix lf iy b iz ja ii jb jc jd il je lr jg jh ji ls jk jl jm lt jo jp jq jr ha bi translated">Shader是在绘制过程中返回水平颜色范围的对象的基类。</p></blockquote><p id="8562" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">特别是，<code class="du jt ju jv jw b">Shader</code>是<code class="du jt ju jv jw b">LinearGradient</code>和<code class="du jt ju jv jw b">BitmapShader</code>等渐变效果的超类。这些对象，当设置在一个<code class="du jt ju jv jw b">Paint</code>对象上时，将这些“着色器”应用到绘图操作中，本质上是从着色器中采样，以产生用于渲染正在绘制的对象的颜色。例如，用一个设置了<code class="du jt ju jv jw b">BitmapShader</code>的<code class="du jt ju jv jw b">Paint</code>对象绘制一条线，将会产生一条带有位图颜色纹理的线。</p><p id="d524" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">而且<strong class="iy hi">是的</strong>，我在上一篇文章中谈到了现有的<code class="du jt ju jv jw b">Shader</code> API，具体来说就是使用<code class="du jt ju jv jw b">RenderEffect</code>捆绑绘图属性，比如应用于整体<code class="du jt ju jv jw b">View</code>的<code class="du jt ju jv jw b">Shader</code>，而不是必须使用自定义<code class="du jt ju jv jw b">View</code>中的<code class="du jt ju jv jw b">Paint</code>对象手动绘制图元。例如，可以创建上述渐变或位图着色器之一，然后将其应用于如下视图:</p><pre class="jx jy jz ka fd lu jw lv lw aw lx bi"><span id="d86d" class="ly kj hh jw b fi lz ma l mb mc">val effect = RenderEffect.createShaderEffect(shader)<br/>myView.setEffect(effect)</span></pre><p id="5efc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是<strong class="iy hi">没有</strong>，<code class="du jt ju jv jw b">android.graphics.Shader</code>并不等同于<code class="du jt ju jv jw b">RuntimeShader</code>。但它们是相关的，无论是API还是概念。在API术语中，<code class="du jt ju jv jw b">RuntimeShader</code>是那个长期存在的<code class="du jt ju jv jw b">Shader</code>类的子类，因为它毕竟是一个着色器。所有这些着色器本质上都在做相同的工作；它们提供绘制几何图形时采样的颜色值，告诉渲染引擎生成的每个片段使用的颜色值。<code class="du jt ju jv jw b">RuntimeShader</code>和现有着色器类的区别在于它们的可编程性。所有其他<code class="du jt ju jv jw b">Shader</code>类本质上都是固定功能着色器；他们用特定的算法做特定的工作，这就是你得到的全部。你可以有一个<code class="du jt ju jv jw b">LinearGradient</code>,带有用来构造它的参数。您可以从提供给<code class="du jt ju jv jw b">BitmapShader</code>的位图中取样像素。但是你不能提供定制的算法来改变这些像素的采样方式；你只需要在那些<code class="du jt ju jv jw b">Shader</code>子类的实现中得到我们给你的任何东西。</p><p id="d2f6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一方面，<code class="du jt ju jv jw b">RuntimeShader</code>给了你完全的可编程性。如果你想做一个简单的<code class="du jt ju jv jw b">LinearGradient</code>(我将在下面的代码中展示)，你可以这样做。但是你也可以根据输入的像素颜色，或者你的着色器算法，或者你的想象力的限制，做一些更加定制，复杂和动态的事情。<code class="du jt ju jv jw b">RuntimeShader</code>为Android带来完整的像素级动态编程逻辑。</p><h1 id="33e1" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">回到演示</h1><p id="dcd9" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">好吧，我们说到哪了？哦，对了，我想谈谈如何让图片标题看起来模糊/磨砂:</p><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/6c9154790b7dfb52ea14216ad71b5264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s83C5chhgZ0OsbBzm3kqHw.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">The image caption pops the text out with a shader which blurs and ‘frosts’ the underlying image</figcaption></figure><h1 id="fefd" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">磨砂字幕着色器</h1><p id="9d47" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">在我的应用程序中，视图层次结构中有三个主要组件，如下所示:</p><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mg"><img src="../Images/f6a3fbd7a5a98874626e4f224b1fb744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s9kdevlA0OYyQIHMTAiHBQ.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">Relevant view hierarchy for the overall effect of a focused, captioned picture over a blurred background</figcaption></figure><p id="e48a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">背景容器仅仅是图库的一个容器，它被我们在上一篇文章中提到的<code class="du jt ju jv jw b">RenderEffect</code>弄模糊了。当有人点击一张图片时，程序会创建一个带有<code class="du jt ju jv jw b">ImageView</code>的<code class="du jt ju jv jw b">PopupWindow</code>，其中保存了该图片的放大版本。该视图是AGSL着色器运行的地方(尽管它将其效果仅限于文本出现的标题区域)。最后，顶部有一个<code class="du jt ju jv jw b">TextView</code>，它将文本绘制到透明背景上，以便ImageView的模糊/磨砂效果显示在该标签区域的文本下。</p><p id="827f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">AGSL着色器如下。我们将一个字符串*传递给<code class="du jt ju jv jw b">RuntimeShader</code>，它在运行时被编译并缓存。</p><p id="c892" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lf"> *对，一串。着色器感觉像是编程黑暗时代的回归，在那里，您可以在穿孔卡片上编写代码，然后将它们发送给管理大型机的人。至少我们不用等几个小时或几天才发现有语法错误。</em></p><pre class="jx jy jz ka fd lu jw lv lw aw lx bi"><span id="0c3b" class="ly kj hh jw b fi lz ma l mb mc"><a class="ae js" href="http://twitter.com/RequiresApi" rel="noopener ugc nofollow" target="_blank">@RequiresApi</a>(Build.VERSION_CODES.TIRAMISU)<br/>val FROSTED_GLASS_SHADER = RuntimeShader("""<br/>    uniform shader inputShader;<br/>    uniform float height;<br/>    uniform float width;<br/>            <br/>    vec4 main(vec2 coords) {<br/>        vec4 currValue = inputShader.eval(coords);<br/>        float top = height - 100;<br/>        if (coords.y &lt; top) {<br/>            return currValue;<br/>        } else {<br/>            // Avoid blurring edges<br/>            if (coords.x &gt; 1 &amp;&amp; coords.y &gt; 1 &amp;&amp;<br/>                    coords.x &lt; (width - 1) &amp;&amp;<br/>                    coords.y &lt; (height - 1)) {<br/>                // simple box blur - average 5x5 grid around pixel<br/>                vec4 boxSum =<br/>                    inputShader.eval(coords + vec2(-2, -2)) + <br/>                    // ...<br/>                    currValue +<br/>                    // ...<br/>                    inputShader.eval(coords + vec2(2, 2));<br/>                currValue = boxSum / 25;<br/>            }<br/>            <br/>            const vec4 white = vec4(1);</span><span id="4f9f" class="ly kj hh jw b fi md ma l mb mc">            // top-left corner of label area<br/>            vec2 lefttop = vec2(0, top);<br/>            float lightenFactor = min(1.0, .6 *<br/>                    length(coords - lefttop) /<br/>                    (0.85 * length(vec2(width, 100))));<br/>            // White in upper-left, blended increasingly<br/>            // toward lower-right<br/>            return mix(currValue, white, 1 - lightenFactor);<br/>        }<br/>    }<br/>""")</span></pre><p id="944f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">(注意:这种白色磨砂玻璃效果部分基于在<a class="ae js" href="https://www.pushing-pixels.org/2022/04/09/shader-based-render-effects-in-compose-desktop-with-skia.html" rel="noopener ugc nofollow" target="_blank">pushing-pixels.org</a>的一个更复杂的例子)。</p><p id="c5de" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有三个输入变量(或“制服”)。传入的<code class="du jt ju jv jw b">width</code> / <code class="du jt ju jv jw b">height</code>变量告诉着色器该区域有多大；这允许计算底部的字幕区域。<code class="du jt ju jv jw b">inputShader</code>变量保存被着色的原始像素颜色。</p><p id="4482" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第一步是简单的拒绝:如果这个位置的像素在标题区域之外，着色器只返回原始像素值(通过调用<code class="du jt ju jv jw b">eval(coords)</code>计算并存储在<code class="du jt ju jv jw b">currValue</code>中)。</p><p id="5cb3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果<code class="du jt ju jv jw b">coords</code>处的像素在字幕边界上，我们避免模糊它，因为在模糊计算中使用源图像之外的颜色会使模糊边界像素遇到问题。所以在这种情况下，我们返回原始像素值。</p><p id="ea21" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果像素在标题区域内，那么我们使用一个简单的<a class="ae js" href="https://en.wikipedia.org/wiki/Box_blur" rel="noopener ugc nofollow" target="_blank">框模糊</a>算法对其进行模糊处理(为了简洁起见，上面大部分都被注释掉了)，它只是对我们正在处理的像素周围的所有像素进行平均。你可以用任何半径来做这件事；在这里，我使用5x5的网格作为折衷，既模糊到足以使它在视觉上明显，又不会花费太多的时间/性能(你包括的像素越多，这个操作花费的时间就越长)。</p><p id="478f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，我们通过使用从左上角的不透明白色到右下角的几乎半透明的线性渐变，在模糊的顶部“霜化”标签区域。这使得模糊的底层图像越来越向标签的右侧显示。</p><p id="715b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最终结果如下所示。请注意，标签区域下的岩石和海洋在标签区域内部比外部更模糊。同时，磨砂玻璃效果有助于创建足够的对比视觉区域，以便黑色文本清晰显示，同时仍显示底层图像。</p><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es mh"><img src="../Images/bc772a152c04639174502020322cf32d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKDxadM-agAJUNXPqxCrKA.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx">The final effect, where the caption is printed on top of a blurred, frosted-glass background.</figcaption></figure><h1 id="56f4" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">RuntimeShader + RenderEffect</h1><p id="c67a" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">一旦你有了你的<code class="du jt ju jv jw b">RuntimeShader</code>，在一个视图上设置它类似于我们看到的模糊效果；您创建一个<code class="du jt ju jv jw b">RenderEffect</code>并在视图上设置效果。对于上面定义的<code class="du jt ju jv jw b">FROSTED_GLASS_SHADER</code>，我们像这样创建<code class="du jt ju jv jw b">RenderEffect</code>:</p><pre class="jx jy jz ka fd lu jw lv lw aw lx bi"><span id="2860" class="ly kj hh jw b fi lz ma l mb mc">val effect = RenderEffect.createRuntimeShaderEffect(<br/>            FROSTED_GLASS_SHADER, "inputShader")</span></pre><p id="4d1d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">参数<code class="du jt ju jv jw b">"inputShader”</code>告诉系统在传递原始像素值时要使用的制服名称。</p><p id="ac7d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们还需要设置着色器中使用的其他制服，以便它知道目标的大小，从而知道标题区域的边界:</p><pre class="jx jy jz ka fd lu jw lv lw aw lx bi"><span id="c746" class="ly kj hh jw b fi lz ma l mb mc">FROSTED_GLASS_SHADER.setFloatUniform("height", h.toFloat())<br/>FROSTED_GLASS_SHADER.setFloatUniform("width", w.toFloat())</span></pre><p id="8da5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们已经创建并配置了我们的<code class="du jt ju jv jw b">RuntimeShader</code>，我们用<code class="du jt ju jv jw b">setEffect()</code>将它设置在<code class="du jt ju jv jw b">ImageView</code>上:</p><pre class="jx jy jz ka fd lu jw lv lw aw lx bi"><span id="106b" class="ly kj hh jw b fi lz ma l mb mc">setRenderEffect(effect)</span></pre><p id="81b4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就是这样！现在当<code class="du jt ju jv jw b">View</code>被绘制时，系统将自动调用每个像素的着色器代码，产生上面看到的结果。</p><h1 id="95fd" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">值得注意</h1><p id="02c2" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">上面的实现中有几个细节值得注意。</p><h2 id="818d" class="ly kj hh bd kk mi mj mk ko ml mm mn ks jf mo mp ku jj mq mr kw jn ms mt ky mu bi translated">虫子，虫子，虫子</h2><p id="61ff" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">首先，我在让我的应用程序工作时发现了当前版本中的一个bug:在没有设置新的<code class="du jt ju jv jw b">RenderEffect</code>的情况下，<code class="du jt ju jv jw b">View</code>不会拾取对<code class="du jt ju jv jw b">uniform</code>值的任何更改。也就是说，<em class="lf">应该</em>可以创建一个着色器，然后在不更新实际着色器的情况下改变(甚至动画化)<code class="du jt ju jv jw b">uniform</code>的值。它可以做到这一点……但是<code class="du jt ju jv jw b">RenderEffect</code>没有得到那些改变。解决方法是同时调用<code class="du jt ju jv jw b">createRuntimeShaderEffect()</code>和<code class="du jt ju jv jw b">setEffect()</code>来使这些更改生效。</p><h2 id="63c9" class="ly kj hh bd kk mi mj mk ko ml mm mn ks jf mo mp ku jj mq mr kw jn ms mt ky mu bi translated">着色器与线性渐变</h2><p id="4b59" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">熟悉Android现有图形API的观察力敏锐的读者可能已经发现，我实际上不需要AGSL着色器来获得上面的视觉效果。我可以(也应该)使用第二个模糊<code class="du jt ju jv jw b">RenderEffect</code>来模糊想要的区域，然后使用一个简单的<code class="du jt ju jv jw b">LinearGradient</code>从不透明到半透明的白色，这将会给我用更多的代码和努力(可能更多的处理时间)实现的毛玻璃一样的外观。一般来说，我会推荐其他更简单的方法；不要仅仅因为它们很简洁就使用着色器(至少在真实的应用程序中不会)。</p><p id="ffd4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是我想要一个非常简单的效果来描述，以便于理解着色器是什么，它们如何工作，以及你可以做什么，特别是在更典型的UI用例的上下文中，而不是你在着色器网站上可以看到的更奇特的例子。因此，不要只是复制上面的着色器代码，而是要尝试AGSL和着色器，以找出适合您的用例的方法。</p><h2 id="9445" class="ly kj hh bd kk mi mj mk ko ml mm mn ks jf mo mp ku jj mq mr kw jn ms mt ky mu bi translated">一种更快的模糊方法</h2><p id="f317" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">我在《T2》中使用的盒子模糊有两个问题。一个是不如后面图片库看到的<code class="du jt ju jv jw b">RenderEffect</code>模糊(之前文章有涉及)；它没有考虑足够多的周围像素，以获得真正模糊的结果。另一个问题是花费太多时间。我还没有对这些方法进行基准测试，但总的来说，<code class="du jt ju jv jw b">RenderEffect</code>模糊会更快(它经过了高度优化，使用了一些我在着色器中不容易做到的技术)，比手动进行简单的方框模糊要好。</p><p id="0f9d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不幸的是，如何使用一个<code class="du jt ju jv jw b">RenderEffect</code>模糊并不明显。我需要模糊图像所在的<code class="du jt ju jv jw b">View</code>，但我只想模糊它的一部分(标题区域)。给视图附加一个<code class="du jt ju jv jw b">RenderEffect</code>会影响整个<code class="du jt ju jv jw b">View</code>，模糊整个弹出的图像不是我们想要的。</p><p id="80d1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">幸运的是，有一种方法可以让它工作。但是您必须阅读本系列的下一篇文章才能找到答案。(又一个挑逗！这种无休止的折磨什么时候才能结束？！？！？！)</p><h1 id="629d" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">着色器资源</h1><p id="557b" class="pw-post-body-paragraph iw ix hh iy b iz la ii jb jc lb il je jf lc jh ji jj ld jl jm jn le jp jq jr ha bi translated">以下是一些网站和文档，您可以从中了解更多关于上面讨论的内容:</p><h2 id="527e" class="ly kj hh bd kk mi mj mk ko ml mm mn ks jf mo mp ku jj mq mr kw jn ms mt ky mu bi translated">Skia着色器</h2><ul class=""><li id="044d" class="mv mw hh iy b iz la jc lb jf mx jj my jn mz jr na nb nc nd bi translated">shaders.skia.org:SkSL着色器示例和编码/调试。</li><li id="7ed3" class="mv mw hh iy b iz ne jc nf jf ng jj nh jn ni jr na nb nc nd bi translated"><a class="ae js" href="https://skia.org/docs/user/sksl/" rel="noopener ugc nofollow" target="_blank"> SkSL文件</a></li></ul><h2 id="bce7" class="ly kj hh bd kk mi mj mk ko ml mm mn ks jf mo mp ku jj mq mr kw jn ms mt ky mu bi translated">AGSL</h2><ul class=""><li id="5b38" class="mv mw hh iy b iz la jc lb jf mx jj my jn mz jr na nb nc nd bi translated"><a class="ae js" href="https://developer.android.com/develop/ui/views/graphics/agsl" rel="noopener ugc nofollow" target="_blank"> AGSL概述和指南</a></li><li id="3f31" class="mv mw hh iy b iz ne jc nf jf ng jj nh jn ni jr na nb nc nd bi translated"><code class="du jt ju jv jw b"><a class="ae js" href="https://developer.android.com/reference/android/graphics/RuntimeShader" rel="noopener ugc nofollow" target="_blank">RuntimeShader</a></code></li></ul><h2 id="fae1" class="ly kj hh bd kk mi mj mk ko ml mm mn ks jf mo mp ku jj mq mr kw jn ms mt ky mu bi translated">GLSL</h2><ul class=""><li id="d52f" class="mv mw hh iy b iz la jc lb jf mx jj my jn mz jr na nb nc nd bi translated"><a class="ae js" href="https://www.khronos.org/files/opengles_shading_language.pdf" rel="noopener ugc nofollow" target="_blank"> GLSL参考</a></li></ul><p id="7141" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">很快就能找到该系列的第三篇文章。当它可用时，我将在这里更新链接。</p></div></div>    
</body>
</html>