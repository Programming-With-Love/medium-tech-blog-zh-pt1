<html>
<head>
<title>Dynamic load balancing for Docker based Java EE microservices on Oracle Container Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle容器云上基于Docker的Java EE微服务的动态负载平衡</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/dynamic-load-balancing-for-docker-based-javaee-microservices-on-oracle-container-cloud-2d04889fd2b7?source=collection_archive---------1-----------------------#2017-04-04">https://medium.com/oracledevs/dynamic-load-balancing-for-docker-based-javaee-microservices-on-oracle-container-cloud-2d04889fd2b7?source=collection_archive---------1-----------------------#2017-04-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="e76a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇博客中，我们将了解如何使用<a class="ae jc" href="http://www.haproxy.org/" rel="noopener ugc nofollow" target="_blank"> HAProxy </a>在高可用性/负载平衡模式下运行基于Docker的Java EE微服务——所有这些都在<a class="ae jc" href="http://cloud.oracle.com/container" rel="noopener ugc nofollow" target="_blank"> Oracle容器云</a>上进行。这里是一个快速概述</p><ul class=""><li id="ff1c" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated"><strong class="ig hi">使用Wildfly Swarm的Java EE微服务</strong>:一个简单的(基于JAX RS的)REST应用</li><li id="f699" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">HAProxy :我们将使用它对应用程序的多个实例进行负载平衡</li><li id="8d3f" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated"><strong class="ig hi"> Docker </strong>:我们的单个组件，即我们的微服务和负载平衡器服务，将打包为Docker映像</li><li id="1ed3" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated"><strong class="ig hi"> Oracle容器云</strong>:我们将堆叠我们的服务，并在Oracle容器云上以可扩展+负载平衡的方式运行它们</li></ul><h1 id="326a" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">应用</h1><p id="be74" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">这个应用程序是一个非常简单的使用JAX RS的REST API。它只是获取一只股票的价格</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="935c" class="ld js hh kz b fi le lf l lg lh">@GET     <br/>public String getQuote(@QueryParam("ticker") final String ticker) {         </span><span id="cbc5" class="ld js hh kz b fi li lf l lg lh"> Response response = ClientBuilder.newClient().                   target("https://www.google.com/finance/info?q=NASDAQ:" + ticker).                 request().get();         <br/>  if (response.getStatus() != 200) {             <br/>     return String.format("Could not find price for ticker %s", ticker);         <br/>      }         <br/> String tick = response.readEntity(String.class);         <br/> tick = tick.replace("// [", "");         <br/> tick = tick.replace("]", "");         <br/> return StockDataParser.parse(tick)+ " from "+ System.getenv("OCCS_CONTAINER_NAME");     </span><span id="6467" class="ld js hh kz b fi li lf l lg lh">}</span></pre><p id="15b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="http://wildfly-swarm.io/" rel="noopener ugc nofollow" target="_blank"> Wildfly Swarm </a>被用作(刚好够用的)Java EE运行时。我们构建了一个简单的基于WAR的Java EE项目，并让Swarm Maven插件编织它的魔法——它自动地检测和配置所需的部分，并从您的WAR中创建一个胖罐子。</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="7cf3" class="ld js hh kz b fi le lf l lg lh">&lt;build&gt;<br/> &lt;finalName&gt;occ-haproxy&lt;/finalName&gt;<br/> &lt;plugins&gt;<br/> &lt;plugin&gt;<br/> &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/> &lt;artifactId&gt;wildfly-swarm-plugin&lt;/artifactId&gt;<br/> &lt;version&gt;1.0.0.Final&lt;/version&gt;<br/> &lt;executions&gt;<br/> &lt;execution&gt;<br/> &lt;goals&gt;<br/> &lt;goal&gt;package&lt;/goal&gt;<br/> &lt;/goals&gt;<br/> &lt;/execution&gt;<br/> &lt;/executions&gt;<br/> &lt;/plugin&gt;<br/> &lt;plugin&gt;<br/> &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br/> &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br/> &lt;version&gt;3.1&lt;/version&gt;<br/> &lt;configuration&gt;<br/> &lt;source&gt;1.7&lt;/source&gt;<br/> &lt;target&gt;1.7&lt;/target&gt;<br/> &lt;compilerArguments&gt;<br/> &lt;endorseddirs&gt;${endorsed.dir}&lt;/endorseddirs&gt;<br/> &lt;/compilerArguments&gt;<br/> &lt;/configuration&gt;<br/> &lt;/plugin&gt;<br/> &lt;plugin&gt;<br/> &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br/> &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;<br/> &lt;version&gt;2.3&lt;/version&gt;<br/> &lt;configuration&gt;<br/> &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;<br/> &lt;/configuration&gt;<br/> &lt;/plugin&gt;<br/> &lt;plugin&gt;<br/> &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br/> &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;<br/> &lt;version&gt;2.6&lt;/version&gt;<br/> &lt;executions&gt;<br/> &lt;execution&gt;<br/> &lt;phase&gt;validate&lt;/phase&gt;<br/> &lt;goals&gt;<br/> &lt;goal&gt;copy&lt;/goal&gt;<br/> &lt;/goals&gt;<br/> &lt;configuration&gt;<br/> &lt;outputDirectory&gt;${endorsed.dir}&lt;/outputDirectory&gt;<br/> &lt;silent&gt;true&lt;/silent&gt;<br/> &lt;artifactItems&gt;<br/> &lt;artifactItem&gt;<br/> &lt;groupId&gt;javax&lt;/groupId&gt;<br/> &lt;artifactId&gt;javaee-endorsed-api&lt;/artifactId&gt;<br/> &lt;version&gt;7.0&lt;/version&gt;<br/> &lt;type&gt;jar&lt;/type&gt;<br/> &lt;/artifactItem&gt;<br/> &lt;/artifactItems&gt;<br/> &lt;/configuration&gt;<br/> &lt;/execution&gt;<br/> &lt;/executions&gt;<br/> &lt;/plugin&gt;<br/> &lt;/plugins&gt;<br/>&lt;/build&gt;</span></pre><p id="f1fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">替代方案</strong>:你也可以看看其他基于JavaEE的fat JAR风格框架，比如<a class="ae jc" href="http://www.payara.fish/payara_micro" rel="noopener ugc nofollow" target="_blank"> Payara Micro </a>、<a class="ae jc" href="https://ee.kumuluz.com/" rel="noopener ugc nofollow" target="_blank"> KumuluzEE </a>、<a class="ae jc" href="http://tomee.apache.org/advanced/tomee-embedded/index.html" rel="noopener ugc nofollow" target="_blank"> Apache TomEE embedded </a>等。</p><p id="bce2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们深入了解一下事实真相。</p><h1 id="dc0f" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">动态负载平衡</h1><p id="c0f6" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">Oracle Container Cloud的水平可伸缩性非常简单——您所需要做的就是生成应用程序的额外实例。当我们有一个负载平衡器来确保应用程序的消费者(用户或其他应用程序)不必处理单个实例的细节时，这是有效的——他们只需要知道负载平衡器的坐标(主机/端口)。问题是我们的负载平衡器不知道新产生的应用程序实例/容器。Oracle Container Cloud有助于创建一个统一的<strong class="ig hi">堆栈</strong>，其中后端(在我们的示例中为REST API)和(HAProxy)负载平衡器组件被配置为一个单元，可以轻松地进行管理和编排，并提供一个<strong class="ig hi">动态</strong> HAProxy虚拟角色的方法</p><h2 id="54ed" class="ld js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">类固醇激素</h2><p id="ce1c" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">我们将利用Oracle Container Cloud Github存储库中的<a class="ae jc" href="https://github.com/oracle/docker-images/tree/0c7f9a90e4420e313f3aeba865cd064c2d138463/ContainerCloud/images/haproxy" rel="noopener ugc nofollow" target="_blank">工件，在为</a><a class="ae jc" href="https://github.com/kelseyhightower/confd" rel="noopener ugc nofollow" target="_blank"> confd </a>和<a class="ae jc" href="http://smarden.org/runit/" rel="noopener ugc nofollow" target="_blank"> runit </a>定制的Docker映像之上构建一个专门的(Docker) HAProxy映像。confd 是一个配置管理工具，在这种情况下，它用于动态地发现我们的应用程序实例。可以把它想象成一个迷你服务发现模块，它查询Oracle Container Cloud service 中的本机<a class="ae jc" href="http://docs.oracle.com/en/cloud/iaas/container-cloud/contu/managing-entries-service-discovery-database-enable-container-communication.html" rel="noopener ugc nofollow" target="_blank">服务发现，以检测新的应用程序实例</a></p></div><div class="ab cl lw lx go ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ha hb hc hd he"><h1 id="381a" class="jr js hh bd jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko bi translated">配置我们的应用程序在Oracle Container Cloud上运行</h1><h2 id="59c8" class="ld js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">构建Docker图像</h2><p id="bae0" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">我们将首先构建所需的Docker映像。在演示中，我将使用Docker Hub上的公共注册中心(abhirockzz)。您可以选择使用自己的公共或私有注册表</p><p id="7834" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请确保Docker引擎已启动并正在运行</p><h2 id="7bc2" class="ld js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">构建应用程序Docker映像</h2><p id="3aa7" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">下面是文档</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="b4c1" class="ld js hh kz b fi le lf l lg lh">FROM anapsix/alpine-java:latest <br/>RUN mkdir app WORKDIR "/app" <br/>COPY target/occ-haproxy-swarm.jar . <br/>EXPOSE 8080 <br/>CMD ["java", "-jar", "occ-haproxy-swarm.jar"]</span></pre><p id="8f59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行以下命令</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="1905" class="ld js hh kz b fi le lf l lg lh">docker build –t &lt;registry&gt;/occ-wfly-haproxy:&lt;tag&gt; . <br/>e.g. docker build –t abhirockzz/occ-wfly-haproxy:latest .</span></pre><h2 id="48cc" class="ld js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">为runit、confd、haproxy构建Docker映像</h2><p id="4ff7" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">我们将按顺序构建图像，因为它们是相互依赖的。首先，</p><ul class=""><li id="f934" class="jd je hh ig b ih ii il im ip jf it jg ix jh jb ji jj jk jl bi translated">克隆<a class="ae jc" href="https://github.com/oracle/docker-images" rel="noopener ugc nofollow" target="_blank"> docker-images </a> Github存储库，并</li><li id="6ee4" class="jd je hh ig b ih jm il jn ip jo it jp ix jq jb ji jj jk jl bi translated">编辑ContainerCloud/images/build目录中的<a class="ae jc" href="https://github.com/oracle/docker-images/blob/0c7f9a90e4420e313f3aeba865cd064c2d138463/ContainerCloud/images/build/vars.mk" rel="noopener ugc nofollow" target="_blank"> vars.mk </a> (Makefile)以输入您的Docker Hub用户名</li></ul><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mi"><img src="../Images/09be0d5c8657a4816edbfd5a31d9cb37.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*7XijbRYSllp13Giu.png"/></div></figure><p id="e8d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在执行下面的命令</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="2a35" class="ld js hh kz b fi le lf l lg lh">cd ContainerCloud/images cd runit make image cd ../confd make image cd ../nginx-lb make image</span></pre><h2 id="76c2" class="ld js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">检查您本地的Docker存储库</h2><p id="de65" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">您的本地Docker存储库现在应该已经有了所有需要的图像</p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mm"><img src="../Images/14508cc37b98b21c2341066bb039542a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/0*2GkV6eRJ6x-K2poi.png"/></div></figure><h2 id="5c08" class="ld js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">推送Docker图像</h2><p id="9123" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">现在，我们将把Docker映像推送到一个注册中心(在本例中是我的公共Docker Hub注册中心)，以便在部署我们的应用程序堆栈期间可以从Oracle Container Cloud中提取它们。执行以下命令</p><p id="2e98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据您的设置调整名称(注册表和存储库)</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="8fe8" class="ld js hh kz b fi le lf l lg lh">docker login <br/>docker push abhirockzz/occ-wfly-haproxy <br/>docker push abhirockzz/haproxy <br/>docker logout</span></pre><h2 id="fd8e" class="ld js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">创建堆栈</h2><p id="7b8c" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">我们将利用YAML配置文件来创建堆栈。它与<strong class="ig hi"> docker-compose </strong>非常相似。在这个具体的例子中，注意服务名(<strong class="ig hi"> rest-api </strong>)是如何在<strong class="ig hi"> lb </strong> (HAProxy)服务中被引用的</p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mn"><img src="../Images/1629cf934a3912735c732584953a749b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/0*fnK4c0Z6hbXf4Pr7.png"/></div></figure><p id="224d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这进而向HAProxy服务提供关于Oracle Container Cloud service registry中的<strong class="ig hi">键</strong>的信息，该键实际上被confd服务(如前所述)用于自动发现新的应用程序实例。<strong class="ig hi"> 8080 </strong>除了暴露的端口之外什么都没有，而且它是硬编码的，因为它也是服务注册中心的密钥的一部分。</p><p id="8139" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从<strong class="ig hi">堆栈</strong>菜单中选择<strong class="ig hi">新堆栈</strong>开始该过程</p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mm"><img src="../Images/b233c8410aaf9c153aa9bc4af7774a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/0*41ID0V44lm9nqvCb.png"/></div></figure><p id="2daf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">点击<strong class="ig hi">高级编辑器</strong>，进入YAML内容</p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mm"><img src="../Images/a9d9881dc2a06e47c365044ff7c0afc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/0*VklX5pM0kUVVRRi-.png"/></div></figure><figure class="ku kv kw kx fd mj er es paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="er es mn"><img src="../Images/1eb29665199358d4d4eab856e007c994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/0*EPujnOTbjbzacRWF.png"/></div></div></figure><p id="25dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，您应该可以看到各个服务。输入<strong class="ig hi">堆栈名称</strong>并点击<strong class="ig hi">保存</strong></p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mm"><img src="../Images/4a144bcb7422ea44031017e5fa17953d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/0*eu-CPm8wriZky8zZ.png"/></div></figure><h2 id="8b92" class="ld js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">开始部署</h2><p id="e6af" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">回到<strong class="ig hi">堆栈</strong>菜单，寻找新创建的堆栈，点击<strong class="ig hi">部署</strong></p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mn"><img src="../Images/6189f59a592be0d7fe4f825dbf0c21a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/0*1PnW_Y0WYpsk0iKV.png"/></div></figure><p id="99ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了测试负载平衡能力，我们将部署<em class="ms"> 3个实例</em>我们的<strong class="ig hi"> rest-api </strong>(后端)服务，并坚持使用<strong class="ig hi"> lb </strong> (HAProxy)服务的<em class="ms">一个实例</em></p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mt"><img src="../Images/1fbce7d9a84139167a08d67ec8a91faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/0*NUMhS6cjgd2kSvx7.png"/></div></figure><p id="9293" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">几秒钟后，您应该看到所有容器都处于<strong class="ig hi">运行</strong>状态——在本例中，三个容器用于我们的服务，一个用于ha代理负载平衡器实例</p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mm"><img src="../Images/5702f521be5fa4cd9ab244fc1f266f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/0*BJcFWSKggwgJ8OTk.png"/></div></figure><p id="7f40" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">检查Service Discovery菜单，验证每个实例在此处都有条目。如前所述，这由<strong class="ig hi"> confd </strong>服务进行自省，以自动检测我们应用程序的新实例(它会自动添加到这个注册表中)</p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mm"><img src="../Images/0978554067eef502ce3a307b38646cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/0*jRVjcUU4uWVR86EU.png"/></div></figure></div><div class="ab cl lw lx go ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ha hb hc hd he"><h1 id="974f" class="jr js hh bd jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko bi translated">试验</h1><p id="cc80" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">我们可以通过HAProxy访问我们的应用程序。我们需要知道的只是运行HAProxy容器的主机的公共IP。我们已经映射了用于访问下游应用程序的端口8886(参见下面的快照)</p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mm"><img src="../Images/2c21f61f2757da296510fcfe00b0f1cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/0*WERSQT5wONii8usL.png"/></div></figure><p id="e965" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用下面的curl命令进行测试</p><pre class="ku kv kw kx fd ky kz la lb aw lc bi"><span id="3150" class="ld js hh kz b fi le lf l lg lh">for i in `seq 1 9`; do curl -w "\n" -X GET "http://&lt;haproxy-container-public-IP&gt;:8886/api/stocks?ticker=ORCL"; done</span></pre><p id="4810" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们所做的就是调用9次，只是为了查看负载平衡的运行情况(在三个实例中)。这里有一个结果。请注意，突出显示的文本指向提供响应的实例——它在三个实例中均衡负载</p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mu"><img src="../Images/698e1b03f14e51576460f0df8e2dc91e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/0*NFFF_mfs5wXDN4MS.png"/></div></figure><h1 id="4c54" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">放大…并再次检查</h1><p id="e8f4" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">您可以简单地扩大堆栈并重复同样的操作。导航到您的部署并单击<strong class="ig hi">更改缩放比例</strong></p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mm"><img src="../Images/03343a964ff177513628fc0af9776790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/0*TujHzjIstc92iq0p.png"/></div></figure><p id="1ed7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一段时间后，您将看到应用程序的其他实例(在我们的例子中是五个)。再次执行该命令，验证负载平衡是否按预期运行</p><figure class="ku kv kw kx fd mj er es paragraph-image"><div class="er es mn"><img src="../Images/89640a9cf7c33977fc48db88e7fabf2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/0*r1beapa6uZl5jOfI.png"/></div></figure><p id="34bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇博文到此为止。</p><p id="07a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">干杯！</p><blockquote class="mv mw mx"><p id="522d" class="ie if ms ig b ih ii ij ik il im in io my iq ir is mz iu iv iw na iy iz ja jb ha bi translated">本文表达的观点是我个人的观点，不一定代表甲骨文的观点。</p></blockquote></div></div>    
</body>
</html>