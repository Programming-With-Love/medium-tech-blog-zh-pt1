<html>
<head>
<title>Going deeper, paging from network and database in the MAD skills series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">继续深入，MAD技能系列中的网络和数据库分页</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/going-deeper-paging-from-network-and-database-in-the-mad-skills-series-9c98250b246b?source=collection_archive---------0-----------------------#2021-11-02">https://medium.com/androiddevelopers/going-deeper-paging-from-network-and-database-in-the-mad-skills-series-9c98250b246b?source=collection_archive---------0-----------------------#2021-11-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/ec3aed893acac649e393e9ce71ba397f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_ZJwMHs17SmEFr3uEbxDg.png"/></div></div></figure><div class=""/><p id="1c7b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">欢迎回来！在第一集<a class="ae jn" rel="noopener" href="/androiddevelopers/fetching-data-and-binding-it-to-the-ui-in-the-mad-skills-series-cea89868b3e1">最后一集</a>中，我们将一个<code class="du jo jp jq jr b">Pager</code>集成到我们的<code class="du jo jp jq jr b">ViewModel</code>中，并用它来填充使用<code class="du jo jp jq jr b">PagingDataAdapter</code>的UI。我们还考虑了添加负载状态指示器和出错时重试的问题。</p><p id="e6ca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这一次，我们要更上一层楼。到目前为止，我们一直直接从网络上获取数据，这种方式只能在最好的情况下使用。有时，我们的网络连接速度很慢，或者完全失去了连接。即使我们的连接是好的，我们当然不希望我们的应用程序成为一个数据猪，因为每次你导航到一个屏幕时重新获取数据是浪费。</p><p id="9581" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些问题的解决方案是让我们从本地缓存中取出一个<strong class="ir ht">并仅在必要时刷新。对缓存的更新应该总是首先命中缓存，然后传播到<code class="du jo jp jq jr b">ViewModel</code>。这样，本地缓存就是唯一的真实来源。对我们来说很方便，分页库在房间库的帮助下解决了这个问题！让我们开始吧！</strong></p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="jw jx l"/></div></figure><h1 id="d94e" class="jy jz hs bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">创建带有空间的分页源</h1><p id="0f7f" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">因为我们将要分页的数据源将来自我们的本地数据库，而不是直接来自API，所以我们要做的第一件事是更新我们的<code class="du jo jp jq jr b">PagingSource</code>。好消息是我们几乎不用做太多。我之前提到的那个房间的小帮手？事实证明，事情远不止如此:从房间<code class="du jo jp jq jr b">DAO</code>中获取一个<code class="du jo jp jq jr b">PagingSource</code>就像在<code class="du jo jp jq jr b">DAO</code>中为它添加一个定义一样简单！</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="0651" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du jo jp jq jr b">GitHubRepository</code>中，我们现在可以更新<code class="du jo jp jq jr b">Pager</code>的构造以使用新的<code class="du jo jp jq jr b">PagingSource</code>:</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="lb jx l"/></div></figure><h1 id="ce8d" class="jy jz hs bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">远程调解人</h1><p id="cc82" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">这很好，但我们遗漏了一些东西。本地数据库是如何填充的？进入<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/paging/RemoteMediator" rel="noopener ugc nofollow" target="_blank">RemoteMediator</a></code>；当<code class="du jo jp jq jr b">PagingSource</code>从数据库中加载的项目用完时，这个类负责从网络中获取更多的数据。让我们看看它是如何工作的。</p><p id="4cfb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于<code class="du jo jp jq jr b">RemoteMediator</code>，需要注意的一点是，它是一个回调函数。来自<code class="du jo jp jq jr b">RemoteMediator</code>的结果永远不会原样返回给UI，这只是分页通知开发人员<code class="du jo jp jq jr b">PagingSource</code>用完了数据的方式。我们的工作是更新数据库，并告诉分页，数据库中有新的数据。与<code class="du jo jp jq jr b">PagingSource</code>类似，<code class="du jo jp jq jr b">RemoteMediator</code>的查询参数和结果类型是通用的。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="99b6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们仔细看看<code class="du jo jp jq jr b">RemoteMediator</code>中的抽象方法。第一种方法是<code class="du jo jp jq jr b">initialize()</code>方法。这是在任何加载开始之前对<code class="du jo jp jq jr b">RemoteMediator</code>的第一次调用，并返回一个<code class="du jo jp jq jr b">InitializeAction</code>。<code class="du jo jp jq jr b">InitializeAction</code>或者是<code class="du jo jp jq jr b">LAUNCH_INITIAL_REFRESH</code>，这将导致用刷新加载类型调用<code class="du jo jp jq jr b">load()</code>方法，或者是<code class="du jo jp jq jr b">SKIP_INITIAL_REFRESH</code>，这将导致<code class="du jo jp jq jr b">RemoteMediator</code>不刷新，除非UI明确请求它。在我们的例子中，由于repo stats可能经常更新，所以我们返回<code class="du jo jp jq jr b">LAUNCH_INITIAL_REFRESH</code>。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="fe69" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来是<code class="du jo jp jq jr b">load</code>方法。在由<code class="du jo jp jq jr b">loadType</code>和<code class="du jo jp jq jr b">PagingState</code>定义的边界处调用<code class="du jo jp jq jr b">load</code>方法，其中负载类型可以是<code class="du jo jp jq jr b">refresh</code>、<code class="du jo jp jq jr b">append</code>或<code class="du jo jp jq jr b">prepend</code>。它负责获取数据，将数据保存到磁盘并通知结果，结果可以是<code class="du jo jp jq jr b">Error</code>或<code class="du jo jp jq jr b">Success</code>。如果是<code class="du jo jp jq jr b">Error</code>，加载状态将会反映出来，加载可能会重试。然而，如果成功，则需要通知<code class="du jo jp jq jr b">Pager</code>是否可以获取更多数据。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="7efd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为<code class="du jo jp jq jr b">load</code>方法是一个返回结果的挂起函数，所以UI能够准确地反映正在完成的工作的状态是很重要的。在上一篇<a class="ae jn" rel="noopener" href="/androiddevelopers/fetching-data-and-binding-it-to-the-ui-in-the-mad-skills-series-cea89868b3e1">文章</a>中，我们简要介绍了<code class="du jo jp jq jr b">withLoadStateHeaderAndFooter</code>扩展，并看到了如何使用它来显示加载的页眉和页脚。仔细查看扩展的名称可以发现一种类型，即<code class="du jo jp jq jr b">LoadState</code>。让我们再看一遍这种类型。</p><h1 id="b8b7" class="jy jz hs bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">加载状态、加载状态和组合加载状态</h1><p id="5a44" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">因为分页是一系列异步事件，所以UI反映正在获取的数据的当前状态非常重要。分页时，<code class="du jo jp jq jr b">Pager</code>的装载状态用<code class="du jo jp jq jr b">CombinedLoadStates</code>类型表示。</p><p id="eb96" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">顾名思义，这个类是传递加载信息的其他类型的组合。这些其他类型是:</p><p id="2f5e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">LoadState</code>:完整描述加载状态的密封类；</p><ul class=""><li id="6073" class="lc ld hs ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated"><code class="du jo jp jq jr b">Loading</code></li><li id="7699" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated"><code class="du jo jp jq jr b">NotLoading</code></li><li id="89a4" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated"><code class="du jo jp jq jr b">Error</code></li></ul><p id="a32c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">LoadStates</code>:包含<code class="du jo jp jq jr b">LoadState</code>值的数据类，用于:</p><ul class=""><li id="9bd2" class="lc ld hs ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated"><code class="du jo jp jq jr b">append</code></li><li id="da9c" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated"><code class="du jo jp jq jr b">prepend</code></li><li id="2ccb" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated"><code class="du jo jp jq jr b">refresh</code></li></ul><p id="d2da" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通常，<code class="du jo jp jq jr b">prepend</code>和<code class="du jo jp jq jr b">append</code>加载状态用于对额外的数据获取做出反应，而刷新加载状态用于对初始加载、刷新和重试做出反应。</p><p id="1fd3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于<code class="du jo jp jq jr b">Pager</code>可能从<code class="du jo jp jq jr b">PagingSource</code>或<code class="du jo jp jq jr b">RemoteMediator</code>加载，因此<code class="du jo jp jq jr b">CombinedLoadStates</code>数据类有两个<code class="du jo jp jq jr b">LoadState</code>字段，一个用于名为<code class="du jo jp jq jr b">source</code>的<code class="du jo jp jq jr b">PagingSource</code>，另一个用于名为<code class="du jo jp jq jr b">mediator</code>的<code class="du jo jp jq jr b">RemoteMediator</code>。</p><p id="f88a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了方便起见，<code class="du jo jp jq jr b">CombinedLoadStates</code>也有类似于<code class="du jo jp jq jr b">LoadStates</code>的<code class="du jo jp jq jr b">refresh</code>、<code class="du jo jp jq jr b">append</code>和<code class="du jo jp jq jr b">prepend</code>字段，这些字段将根据您的分页配置和其他语义来反映<code class="du jo jp jq jr b">RemoteMediator</code>或<code class="du jo jp jq jr b">PagingSource</code>的<code class="du jo jp jq jr b">LoadState</code>。请务必查看关于不同场景中字段行为的文档。</p><p id="99d4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用这些信息来更新我们的UI就像从由<code class="du jo jp jq jr b">PagingAdapter</code>公开的<code class="du jo jp jq jr b">loadStateFlow</code>中收集一样简单。在我们的应用程序中，我们可以使用它在第一次加载时显示一个加载微调器。</p><figure class="js jt ju jv fd hj"><div class="bz dy l di"><div class="lb jx l"/></div></figure><p id="58ee" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们从<code class="du jo jp jq jr b">Flow</code>开始收集，如果<code class="du jo jp jq jr b">Pager</code>没有加载并且现有列表为空，使用<code class="du jo jp jq jr b">CombinedLoadStates.refresh</code>字段显示进度条。我们使用<code class="du jo jp jq jr b">refresh</code>字段，因为我们只想在第一次启动应用程序时显示大进度条，或者因为我们明确触发了刷新。我们还可以检查是否有任何装载状态出错，并通知用户。</p><h1 id="7fad" class="jy jz hs bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">概述</h1><p id="b500" class="pw-post-body-paragraph ip iq hs ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">感谢您的阅读！概括地说，我们:</p><ul class=""><li id="9014" class="lc ld hs ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated">从数据库中调出，作为事实的单一来源</li><li id="a0a5" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">用一个<code class="du jo jp jq jr b">RemoteMediator</code>给房间喂食的基础<code class="du jo jp jq jr b">PagingSource</code></li><li id="ece1" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">根据<code class="du jo jp jq jr b">PagingAdapter’s</code> <code class="du jo jp jq jr b">LoadStateFlow</code>中的负载状态更新了带有进度条的用户界面</li></ul><p id="a773" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将在下一篇文章中结束这个系列，所以请继续关注，稍后见！</p></div></div>    
</body>
</html>