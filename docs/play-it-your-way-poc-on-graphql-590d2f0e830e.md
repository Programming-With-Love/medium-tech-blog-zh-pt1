# 按您的方式玩:GraphQL 上的 POC

> 原文：<https://medium.com/globant/play-it-your-way-poc-on-graphql-590d2f0e830e?source=collection_archive---------0----------------------->

# graph QL+Express+PostgreSQL+MongoDB

GraphQL 是 API 的一种查询语言，也是一种服务器端运行时，通过使用您为数据定义的类型系统来执行查询。GraphQL 不依赖于任何特定的数据库或存储引擎，而是由您现有的代码和数据提供支持。

到目前为止，我们已经在文章 [**简介:GraphQL 概述**](/@sagar.barawade/introduction-overview-of-graphql-56ac0285077b) 中看到了什么是 GraphQL，在文章 [**GraphQL:查询语言**](/@kaustubh.vyas/graphql-the-query-language-3d1b1807a1d1) 中看到了如何使用 GraphQL 查询语言从 GraphQL 运行时使用 GraphQL 用户界面查询数据。

在本次会议中，我们将使用**GraphQL+Express+PostgreSQL+MongoDB**来设置 graph QL 运行时

为了使用两个不同的数据库连接(即 PostgreSQL 和 MongoDB)建立一个 GraphQL 服务器，我们将使用 Express framework 创建一个 NodeJs 服务器。

让我们从安装依赖项开始。

## 安装依赖项:

```
npm install express express-graphql graphql mongodb pg
```

**express:** NodeJs 框架

**express-graphql:** 用于与 express 集成的 graphql 模块

**图表语言库**

**mongodb:** MongoDB 节点模块

**pg:** PostgreSQL 节点模块

## 设置 GraphQL-Express 服务器

我们只需要基本的 Express 服务器设置:

```
// ./index.js
const app = require('express')();
***const Schema = require('./schema');*** const graphqlHTTP = require('express-graphql');
const PORT = process.env.PORT || 3000;app.use('/graphql', graphqlHTTP({ schema: ***Schema***, graphiql: true}));app.listen(PORT, () => {
     console.log(`Server is listening on port ${PORT}`);
});
```

您可能对这里的模式感到疑惑，让我们看看接下来是什么。

## GraphQL 模式

GraphQL 中基本上有两种类型的 API

*   **查询:**这些是数据获取 API。
*   **突变:**这些是会有副作用的，即修改数据。

定义和区分这两个 API 的 GraphQL 对象是`GraphQLSchema`

```
// ./schema/index.js
const { GraphQLSchema } = require('graphql');
const RootQueryType = require('./rootquerytype');
const RootMutationType= require('./rootmutationtype');module.exports = new GraphQLSchema({
 query: RootQueryType,
 mutation: RootMutationType
});
```

为了定义`query`和`mutation`API，GraphQL 提供了一个助手类`GraphQLObjectType`

## GraphQLObjectType

`GraphQLObjectType`详细描述了`query`和`mutation` API 的定义。

```
new GraphQLObjectType({
  name: 'TypeName',
  description: 'Type Description',
  fields: {
    hello: {
      type: GraphQLString,
      description: 'API description',
      resolve: () => 'world'
    }
  }
});
```

`name`、`description`在 GraphiQL 接口中公开文档细节，`fields`键保存所有的`query`或`mutation` API 路径键。这反过来定义了解析器函数，该函数将有代码返回数据库中的数据`query`或`mutate`。`type`定义了 API 的返回类型。

在我们编写查询或变异查询之前，让我们创建数据库连接。

## 数据库连接

我们将演示一个具有多个数据库连接的 GraphQL 服务器。PostgreSQL 和 MongoDB。

这里，我们将使用 PostgreSQL 来存储用户数据，使用 MongoDB 来包含用户计数。

在 PostgreSQL 中的数据库和表上创建。

```
create database graphql_test;
# connect to the graphql_test databasecreate table users(
	id integer generated by default as identity,
	first_name character varying
);
insert into users(first_name) values('test_user_1'); #dummy data
```

MongoDB 将动态创建数据库。

让我们更新 GraphQL-Express 来创建和使用 PostgreSQL 和 MongoDB 连接。

这里我们考虑两个数据库都运行在您的机器上和它们各自的默认端口上。

```
// ./index.js
const app = require('express')();
const pg = require('pg');
const { MongoClient } = require('mongodb');
const Schema = require('./schema');
const graphqlHTTP = require('express-graphql');
const PORT = process.env.PORT || 3000;const pgPool = new pg.Pool({
  user: 'postgres',    
  host: 'localhost',    
  database: 'graphql_test',    
  password: 'xxxxx'
});MongoClient.connect('mongodb://localhost:27017/graphqltest', 
  (err, mongoClient) => {
     app.use('/graphql', graphqlHTTP({ 
       schema: Schema, 
       graphiql: true,
       context: { 
         pgPool : pgPool, 
	 mongo : mongoClient.db("graphql-training") 
       }
     })
  );
  app.listen(PORT, () => {
    console.log(`Server is listening on port ${PORT}`);
  });
});
```

我们已经将数据库连接传递给了`context`选项，它提供了一种在整个应用程序解析器函数中共享对象的方法。现在，在查询和变异 API 解析函数中，我们将使用这些连接。

## GraphQL 查询 API

```
// ./schema/rootquerytype.js
const { GraphQLString, GraphQLInt, GraphQLList, GraphQLObjectType } = require('graphql');const RootQueryType = new GraphQLObjectType({
  name: 'RootQueryType',
  description: 'This holds all the query APIs',
  fields: {
    users: {
      type: new GraphQLList(UserType),
      description: 'Handler for get users list',
      resolve: async ( obj, args, context) => {						
        const { pgPool } = context;
	pgPool.query(`select * from users`, [])
          .then(res => res.rows);
      }
    },
    usersCount: {			
      type: GraphQLInt,
      description: 'Handler for get usersCount',
      resolve: async ( obj, args, context) => {						
	const { mongo } = context;
	return mongo.collection('metrics').findOne({key : 
        'userCount'}).then(res => res.value);
      }
    }
  }
});
module.exports = RootQueryType;// ./schema/types/UserType.jsconst UserType = new GraphQLObjectType({
  name: 'UserType',
  description: 'User object type',
  fields:{
    id: { 
      type : GraphQLInt,
      resolve: (obj)=> obj.id	
    },
    firstName:{
      type: GraphQLString,
      resolve: (obj)=> obj.first_name
    }
  }
})module.exports = UserType;
```

解析函数接受三个参数:

*   **对象:**基本对象引用。
*   **参数:**为查询路径传递的参数。
*   **上下文:**保存数据库连接对象的 index.js 文件传递下来的上下文对象。

`RootQueryType`中的`users`字段保存带有关键字的对象:

*   **类型:**解析器函数的返回类型。
*   **解析:**获取用户列表的解析函数。

## GraphQL 突变 API

```
// ./schema/rootmutaiontype.js
const { GraphQLString, GraphQLObjectType } = require('graphql');const RootMutationType = new GraphQLObjectType({
  name: 'RootMutationType',
  description: 'this holds all the mutation APIs',
  fields: {
    user: {
      type: UserType,
      args: { input:{type : UserArg}},			
      description: 'Handler for create user',
      resolve: async ( obj, {input}, context) => {						
	const { pgPool, mongo } = context;
	const user= await pgPool.query(`insert into users(fist_name) 
          values($1) returning *`,[input.firstname])
        await mongo.collection('metrics')
          .update({ key : 'userCount' },{ $inc: { value: 1 }},{    
           upsert: 1 });
        return user 
       }
    }
  }
});
module.exports = RootMutationType;//./schema/types/UserArg.jsconst { GraphQLString, GraphQLInputObjectType } = require("graphql");let UserArg = new GraphQLInputObjectType({
  name: 'UserArg',
  fields:{
    firstname: { type : GraphQLString } 
  } 
})
module.exports = UserArg;
```

与查询 API 一样，我们需要实现一个解析器函数来添加新用户和更新计数。

为了接受输入参数，我们定义了类型为`UserArg`的`input`，它属于接受类型为`GraphQLString`的`firstname`的`GraphQLInputObjectType`。

# 结论

就是这样！现在您知道了如何设置具有多个连接的 GraphQL 服务器并使用它。

**源代码**:[https://github.com/rahulpawarglobant/graphql-training](https://github.com/rahulpawarglobant/graphql-training)