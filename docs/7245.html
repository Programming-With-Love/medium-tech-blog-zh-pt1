<html>
<head>
<title>Tips and tricks for API pagination</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">API分页的提示和技巧</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/tips-and-tricks-for-api-pagination-5cacc6f017da?source=collection_archive---------0-----------------------#2017-09-07">https://medium.com/square-corner-blog/tips-and-tricks-for-api-pagination-5cacc6f017da?source=collection_archive---------0-----------------------#2017-09-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="5dba" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">有时，您需要从API中得到比从第一组返回结果中得到的更多的东西。</h2></div><blockquote class="iw ix iy"><p id="f341" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们在https://developer.squareup.com/blog<a class="ae jw" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">的新家</a></p></blockquote><p id="347c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">欢迎来到分页的世界——将结果分散到多个页面或部分。我将概述一些基本的分页概念，并深入探讨我们在Square上是如何做事的。</p><h2 id="451a" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">分页介绍</h2><p id="6aa7" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">分页的概念最初来自书籍，但我认为用列表来描述更容易。在博客、新闻网站、图片分享网站等，你会经常看到分页。每当页面上没有足够的空间一次显示所有的文章时，文章的大列表就会被分成不同的“页面”。您可能熟悉类似于下面的帮助您在页面间导航的UI组件。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div class="er es la"><img src="../Images/2005660b96d9a5b16c70303d35e14514.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*lLBUTR-ZspBYmyKsjuD8_w.png"/></div><figcaption class="li lj et er es lk ll bd b be z dx">This is pagination!</figcaption></figure><p id="7d46" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">API分页的工作方式略有不同，但基本概念是相同的。当您试图检索一个太大的对象列表时，无论是检索(或消费)相关的计算成本，还是任何过多的网络问题(等待来自API调用的几千兆字节的数据可能会对您的应用程序产生意想不到的影响)，服务通常会响应有关如何访问下一个“页面”或结果部分的信息。</p><p id="019a" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">我将把这条信息称为“光标”，但它可能有许多名称和形式，包括:</p><ul class=""><li id="ab22" class="lm ln hh jc b jd je jg jh jx lo jy lp jz lq jv lr ls lt lu bi translated">作为URL参数或在请求头中提供给端点用于后续请求的令牌。</li><li id="b040" class="lm ln hh jc b jd lv jg lw jx lx jy ly jz lz jv lr ls lt lu bi translated">关于您正在访问/请求的页面的标准化url参数，例如<code class="du ma mb mc md b">&amp;page=3</code>或<code class="du ma mb mc md b">start=100</code></li><li id="75e5" class="lm ln hh jc b jd lv jg lw jx lx jy ly jz lz jv lr ls lt lu bi translated">链接到一个不同的URL来发出请求(这个通常有一个令牌或URL参数)</li></ul><p id="7409" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">为了更好地解释这个概念，我制作了一个动画，展示了添加到v2 List Transactions端点响应中的光标的样子。您的代码将向List Transactions端点发出请求，如果您有超过50个事务，API将返回前50个，并将另一个名为<code class="du ma mb mc md b">cursor</code>的字段附加到json响应。这是一个分页标记，将它附加到下一个请求(以URL参数的形式)会告诉API您已经看到了哪些事务，以及在返回下50个结果时从哪里开始。该响应包括一个不同的分页光标，供您获取下一个<em class="jb">50个结果。这种情况一直持续到您“翻阅”完所有请求的结果，最后一页的结果通常比预期的页面大小要少。你可以在下面的动画中看到一个概念性的例子。</em></p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es me"><img src="../Images/ae044fe72dcd0c629ddbeb7bb9c1ef30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*c9wgrnuDy1HYZfYkZHow8g.gif"/></div></div><figcaption class="li lj et er es lk ll bd b be z dx">An animation of Square’s cursor based pagination</figcaption></figure><p id="3d17" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">Square的<a class="ae jw" href="https://squareup.com/developers" rel="noopener ugc nofollow" target="_blank">支付API</a>使用基于令牌的方法，但是有两种不同的方式:<code class="du ma mb mc md b">v1</code>端点返回一个头，其中包含发送下一个请求的链接，而<code class="du ma mb mc md b">v2</code>端点将一个光标令牌添加到json响应中，并在后续请求中接受它作为URL参数。</p><p id="d4c8" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">在我们的SDK的<code class="du ma mb mc md b">2.2.1</code>版本中，我们添加了额外的函数来访问来自头部的分页标记，就像PHP中的<code class="du ma mb mc md b"><a class="ae jw" href="https://github.com/square/connect-php-sdk/blob/master/lib/ApiClient.php#L288" rel="noopener ugc nofollow" target="_blank">getV1BatchTokenFromHeaders()</a></code>。使用它们可以更容易地获得客户端库的分页标记。</p><h1 id="86ea" class="mj kb hh bd kc mk ml mm kg mn mo mp kk in mq io kn iq mr ir kq it ms iu kt mt bi translated">怎么全部搞定？</h1><p id="9d71" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">在大多数情况下，当您体验分页时，您可能想要列表中的所有项目，并且不喜欢翻阅结果所需的额外工作。以下是一些最佳实践，可以让您在获得所有结果时不那么痛苦:</p><h2 id="c56c" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated"><strong class="ak">避开它</strong></h2><p id="c341" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">虽然有点厚颜无耻，但从概念上来说，这是您能够获得最佳性能的方式。许多API允许您基于特定标准查询项目，或者只返回数据的某些子集。例如，Square的<a class="ae jw" href="https://docs.connect.squareup.com/api/connect/v2#endpoint-listtransactions" rel="noopener ugc nofollow" target="_blank">列表事务</a>端点允许您基于时间范围进行查询。如果您知道您要查找的事务只发生在特定的时间范围内，那么您可以从一开始就缩小结果集的范围，在许多情况下，与在应用程序中过度提取然后过滤相比，这样可以消除分页并提高性能。</p><h2 id="833f" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jx kl km kn jy ko kp kq jz kr ks kt ku bi translated">循环时</h2><p id="ce41" class="pw-post-body-paragraph iz ja hh jc b jd kv ii jf jg kw il ji jx kx jl jm jy ky jp jq jz kz jt ju jv ha bi translated">根据您选择的编程语言，分页可能是<code class="du ma mb mc md b">while</code>的一个很好的用例。基本的工作流程是，<em class="jb">当</em>在响应中获得分页标记时，继续发出后续请求。伪代码可能是这样的:</p><pre class="lb lc ld le fd mu md mv mw aw mx bi"><span id="b34a" class="ka kb hh md b fi my mz l na nb">Page = GetPageOfItems();<br/>//process the data from the page, or add it to a larger array, etc.</span><span id="3a87" class="ka kb hh md b fi nc mz l na nb">while( Page-&gt;cursor )<br/>    Page  = GetPageOfItems(Page-&gt;cursor);<br/>    //process the data again<br/>end</span></pre><p id="4f5a" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">一旦API停止对分页光标的响应，您就可以停止循环并继续执行完整的数据集。对于这样的方法，有几个要点需要记住:</p><ul class=""><li id="8328" class="lm ln hh jc b jd je jg jh jx lo jy lp jz lq jv lr ls lt lu bi translated">使用这种方法很容易达到速率限制，所以要注意像<code class="du ma mb mc md b">429</code>响应代码这样的东西。</li><li id="d415" class="lm ln hh jc b jd lv jg lw jx lx jy ly jz lz jv lr ls lt lu bi translated">来自API的任何不返回游标的错误都可能会过早地停止执行，所以要经常检查是否从API获得了良好的响应。</li><li id="bc5d" class="lm ln hh jc b jd lv jg lw jx lx jy ly jz lz jv lr ls lt lu bi translated">您可能希望包括一些检查，以确保您在某个上限停止引入更多的信息，以防API响应的信息比您预期的多得多，并一直分页、分页、分页…</li></ul><p id="3b33" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji jx jk jl jm jy jo jp jq jz js jt ju jv ha bi translated">希望这是一个有用的资源，下次你需要分页(或避免分页！)你从一个API得到的结果。如果您对Square的API分页有更多问题，可以看看参考资料中的<a class="ae jw" href="https://docs.connect.squareup.com/api/connect/v1/#pagination" rel="noopener ugc nofollow" target="_blank"> v1 </a> &amp; <a class="ae jw" href="https://docs.connect.squareup.com/api/connect/v2#paginatingresults" rel="noopener ugc nofollow" target="_blank"> v2 </a>。</p></div></div>    
</body>
</html>