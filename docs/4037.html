<html>
<head>
<title>IP, MAC, and Network Subnet Address Validation In RDBMS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RDBMS中的IP、MAC和网络子网地址验证</h1>
<blockquote>原文：<a href="https://medium.com/globant/ip-mac-and-network-subnet-address-validation-in-rdbms-3c1f9b7b07fb?source=collection_archive---------0-----------------------#2022-11-28">https://medium.com/globant/ip-mac-and-network-subnet-address-validation-in-rdbms-3c1f9b7b07fb?source=collection_archive---------0-----------------------#2022-11-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/0f4f0f06dc057596f956d9e4181eff13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*5bZystluWRnKVRi7XfofzA.png"/></div><figcaption class="il im et er es in io bd b be z dx">Network Addresses</figcaption></figure><p id="1b0a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">本文由合著者Kartik Garghate先生提供。</em></p><p id="82e5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可能需要使用数据库脚本从后端验证IPv4地址、IPv6地址、MAC地址或网络子网地址。在一次作业中，我们必须通过编写数据库脚本来验证网络地址。我们需要通过创建Azure数据工厂管道来处理文件，在处理的同时，验证数据文件中提到的网络地址。如果网络地址的格式正确，将这些记录保存在数据库中；否则，丢弃网络地址不正确的记录。</p><p id="5309" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在API、UI和Oracle数据库等编程领域中，可以使用<a class="ae jo" href="https://en.wikipedia.org/wiki/Regular_expression" rel="noopener ugc nofollow" target="_blank"> REGEXP </a>快速完成网络地址验证，但在SQL Server中却不行。没有现成的实现可用于验证SQL Server中的网络地址；我们需要编写一个<a class="ae jo" href="https://docs.microsoft.com/en-us/sql/relational-databases/user-defined-functions/user-defined-functions?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank">用户定义函数(UDF) </a>来实现这个解决方案。对于Oracle中的网络地址验证，我们需要修改REGEXP。</p><p id="fd08" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我们将了解如何在SQL Server中实现UDF，以及如何在Oracle中修改REGEXP来验证IPv4、IPv6、MAC地址和网络子网。撰写本文时，考虑到您在数据库函数、IP验证概念和复杂查询编写方面具有中级水平的专业知识。</p><h1 id="e291" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">地址格式</h1><p id="7231" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">让我们从考虑所有可能的地址格式开始。</p><h2 id="66d8" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/IPv4" rel="noopener ugc nofollow" target="_blank"> IPv4地址</a></h2><p id="53c2" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">IP代表互联网协议，v4代表第四版(IPv4)。IPv4地址有一种格式<code class="du lg lh li lj b">x.x.x.x</code>，其中每个<code class="du lg lh li lj b">x</code>称为一个八位字节，一个0到255之间的十进制值:例如，123.100.20.15或0.0.0.0。八位字节由句点分隔，IPv4地址必须包含三个句点和四个八位字节。</p><h2 id="b31d" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/IPv6" rel="noopener ugc nofollow" target="_blank"> IPv6地址</a></h2><p id="7964" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">IPv6地址是一个128位的字母数字值，用于标识IP版本6 (IPv6)网络中的端点设备。首选的IPv6地址表示是<code class="du lg lh li lj b">x:x:x:x:x:x:x:x</code>，其中每个<code class="du lg lh li lj b">x</code>是一个16位十六进制数。IPv6地址范围从0000:0000:0000:0000:0000:0000:0000:0000:0000到ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff。</p><p id="da3e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除了这种首选格式之外，IPv6地址还可以用另外两种缩写格式来指定:</p><ul class=""><li id="bf4a" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated"><strong class="ir hi">省略前导零:</strong>我们可以通过省略前导零来指定IPv6地址。例如，IPv6地址1050:0000:0000:0000:0005:0600:300 c:326 b可以写成1050:0:0:0:5:600:300c:326b。</li><li id="a206" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><strong class="ir hi">双冒号:</strong>我们可以使用双冒号(::)代替一系列零来指定IPv6地址。IPv6地址中只允许出现一次双冒号。例如，IPv6地址ff06:0:0:0:0:0:0:0:C3可以写成ff06::c3。</li></ul><h2 id="e974" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/MAC_address" rel="noopener ugc nofollow" target="_blank"> MAC地址</a></h2><p id="86d9" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">媒体访问控制(MAC)地址是唯一标识给定网络中每台设备的物理地址。传统的MAC地址是12位(6字节或48位)十六进制数，可以用以下方式书写:</p><ul class=""><li id="5dc4" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated">[00-FF]:[00-FF]:[00-FF]:[00-FF]:[00-FF]:[00-FF]，如96:FF:FE:12:34:56</li><li id="18bd" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">[00-FF]-[00-FF]-[00-FF]-[00-FF]-[00-FF]，如96-FF-FE-12–34–56中所示</li><li id="aafe" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">[0000-FFFF]。[0000-FFFF]。[0000-FFFF]，如在96FF。FE12.3456</li><li id="6880" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">[0000000000000-ffffffffff]，如96FFFE123456</li></ul><h2 id="cf3f" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated"><a class="ae jo" href="https://en.wikipedia.org/wiki/Subnetwork" rel="noopener ugc nofollow" target="_blank"> IPv4网络子网</a></h2><p id="042f" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">IPv4网络子网格式由IPv4地址和0到32之间的数字组成，用“/”分隔。子网有两种格式:</p><ul class=""><li id="0a2c" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated">[IP v4]/[0–32]，如10.10.10.10/11所示</li><li id="4a81" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">/[0–32]，如/10所示</li></ul><h1 id="476a" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">编写UDF</h1><p id="63e8" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在写我们的UDF之前，让我们看看为什么我们需要它们。</p><ul class=""><li id="dc19" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated"><strong class="ir hi">模块化编程:</strong>你可以一次创建一个函数，存储在数据库中，在你的程序中调用任意次。</li><li id="d054" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><strong class="ir hi">不支持REGEXP: </strong> SQL Server不支持正则表达式，而其他语言支持正则表达式。以下IPv6验证规则适用于。但在SQL Server中不受支持。</li></ul><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="cc4a" class="mg jq hh lj b be mh mi l mj mk">(?:^|(?&lt;=\s))<br/> (<br/>  ([0–9a-fA-F]{1,4}:){7,7}[0–9a-fA-F]{1,4}|<br/>  ([0–9a-fA-F]{1,4}:){1,7}:|<br/>  ([0–9a-fA-F]{1,4}:){1,6}:[0–9a-fA-F]{1,4}|<br/>  ([0–9a-fA-F]{1,4}:){1,5}(:[0–9a-fA-F]{1,4}){1,2}|<br/>  ([0–9a-fA-F]{1,4}:){1,4}(:[0–9a-fA-F]{1,4}){1,3}|<br/>  ([0–9a-fA-F]{1,4}:){1,3}(:[0–9a-fA-F]{1,4}){1,4}|<br/>  ([0–9a-fA-F]{1,4}:){1,2}(:[0–9a-fA-F]{1,4}){1,5}|<br/>  [0–9a-fA-F]{1,4}:((:[0–9a-fA-F]{1,4}){1,6})|<br/>  :((:[0–9a-fA-F]{1,4}){1,7}|:)|<br/>  fe80:(:[0–9a-fA-F]{0,4}){0,4}%[0–9a-zA-Z]{1,}|<br/>  ::(ffff(:0{1,4}){0,1}:){0,1}((25[0–5]|<br/>  (2[0–4]|1{0,1}[0–9]){0,1}[0–9])\.){3,3}(25[0–5]|(2[0–4]|1{0,1}[0–9]){0,1}[0–9])|<br/>  ([0–9a-fA-F]{1,4}:){1,4}:((25[0–5]|(2[0–4]|1{0,1}[0–9]){0,1}[0–9])\.){3,3}(25[0–5]|(2[0–4]|1{0,1}[0–9]){0,1}[0–9])<br/> )<br/>(?=\s|$)</span></pre><ul class=""><li id="edd8" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated"><strong class="ir hi">处理多种情况:</strong>正如我们提到的，几个地址可能以两种或更多种等效的格式书写。</li><li id="cb87" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><strong class="ir hi">跨平台:</strong>我们不能调用任何用。NET或Java编写的程序，但是用。NET或Java可以调用和使用数据库中定义的函数。</li></ul><p id="3b22" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看UDF来逐个验证网络地址。</p><h1 id="c2a6" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">正在验证IPv4地址</h1><p id="128a" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在本节中，让我们编写函数来验证IPv4地址。</p><h2 id="f59b" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated">IPv4地址验证— SQL Server UDF</h2><p id="3131" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">以下UDF验证SQL Server中的IPv4地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="dcad" class="mg jq hh lj b be mh mi l mj mk">CREATE FUNCTION [dbo].[fn_ipv4_validation] <br/>(<br/>   @p_ip_address NVARCHAR(300)<br/>)<br/>RETURNS BIT<br/>AS<br/>BEGIN<br/>DECLARE @counter int = 0<br/>/*<br/>  RETURN 'FALSE' - Incorrect Format<br/>  RETURN 'TRUE' - Correct Format<br/>*/<br/>-- Step 1<br/>IF ( @p_ip_address LIKE '%[a-zA-Z]%' OR REPLACE(@p_ip_address,'.','') LIKE '%[^0-9]%' )<br/>BEGIN<br/>   SET @counter = 1<br/>   RETURN 'FALSE'<br/>END<br/>-- Step 2<br/>IF <br/>   @counter = 0  <br/>   AND @p_ip_address = <br/>        ( SELECT <br/>            @p_ip_address <br/>          WHERE <br/>            (<br/>              PARSENAME(@p_ip_address , 4) BETWEEN' 0' AND '255'<br/>              AND PARSENAME(@p_ip_address , 3) BETWEEN '0' AND '255'<br/>              AND PARSENAME(@p_ip_address , 2) BETWEEN '0' AND '255'<br/>              AND PARSENAME(@p_ip_address , 1) BETWEEN '0' AND '255'<br/>            )<br/>        )<br/>BEGIN<br/>   RETURN 'TRUE'<br/>END<br/>-- Step 3<br/>RETURN 'FALSE'<br/>END<br/>GO</span></pre><p id="cf86" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编写UDF <code class="du lg lh li lj b">fn_ipv4_validation()</code>来验证IPv4地址格式，它接受IPv4地址作为参数<code class="du lg lh li lj b">@p_ip_address</code>并返回<code class="du lg lh li lj b">‘TRUE’</code>或<code class="du lg lh li lj b">‘FALSE’</code>。UDF遵循的步骤解释如下:</p><ul class=""><li id="d5cb" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated"><em class="jn">步骤1 </em>:我们将检查字符串是否包含a-z或A-Z中的任何字符，以及除了点(.)，如果是，则将计数器变量值设置为1，然后返回<code class="du lg lh li lj b">‘FALSE’</code>并退出函数。该检查在<code class="du lg lh li lj b"><a class="ae jo" href="https://learn.microsoft.com/en-us/sql/t-sql/language-elements/like-transact-sql?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank">LIKE</a></code>操作器和<code class="du lg lh li lj b"><a class="ae jo" href="https://learn.microsoft.com/en-us/sql/t-sql/functions/replace-transact-sql?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank">REPLACE</a>()</code>功能的帮助下完成。</li><li id="470f" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">第二步</em>:如果IPv4地址变量不包含a-z或A-Z中的任何字符或除点(.)并且计数器变量为0，那么将执行第二步。这里通过使用<code class="du lg lh li lj b"><a class="ae jo" href="https://docs.microsoft.com/en-us/sql/t-sql/functions/parsename-transact-sql?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank">PARSENAME(</a>)</code>函数，我们正在验证参数<code class="du lg lh li lj b">@p_ip_address</code>是否在[0–255]范围内。[0–255].[0–255].[0–255]格式。如果<code class="du lg lh li lj b">@p_ip_address</code>格式正确，将返回<code class="du lg lh li lj b">‘TRUE’</code>并从函数中出来。</li><li id="f70a" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">第三步</em>:如果前面任何一步失败，函数返回<code class="du lg lh li lj b">‘FALSE’</code>并退出。</li></ul><p id="558b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下示例显示了如何使用<code class="du lg lh li lj b">fn_ipv4_validation()</code>来验证IPv4地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="46d8" class="mg jq hh lj b be mh mi l mj mk">SELECT <br/>    '12.210.60.67' IPV4_Value, <br/>    [dbo].[fn_ipv4_validation] ('12.210.60.67') IPv4_result<br/>UNION ALL<br/>  SELECT <br/>    '0.0.0.0' IPV4_Value, <br/>    [dbo].[fn_ipv4_validation] ('0.0.0.0') IPv4_result<br/>UNION ALL<br/>  SELECT <br/>    '10.10.10.asdasd' IPV4_Value, <br/>    [dbo].[fn_ipv4_validation] ('10.10.10.asdasd') IPv4_result<br/>UNION ALL<br/>  SELECT <br/>    CAST('10.10.as.10' as Varchar ) IPV4_Value, <br/>    [dbo].[fn_ipv4_validation] ('10.10.as.10') IPv4_result<br/>UNION ALL<br/>  SELECT <br/>    '0.0.0.0.0' IPV4_Value, <br/>    [dbo].[fn_ipv4_validation] ('0.0.0.0.0') IPv4_result<br/>UNION ALL<br/>  SELECT <br/>    '10.10.10.890' IPV4_Value, <br/>    [dbo].[fn_ipv4_validation] ('10.10.10.890') IPv4_result;</span></pre><p id="3dc1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下是上述脚本的输出:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es ml"><img src="../Images/315b5bd131d9e944050a9d7e1d367cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HbYz-QRW5Xz-cMWUA71FLA.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">IPv4 Address Validation — SQL Server Implementation</figcaption></figure><h2 id="6d1b" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated">IPv4地址验证— Oracle</h2><p id="153d" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">使用<code class="du lg lh li lj b"><a class="ae jo" href="https://docs.oracle.com/cd/B12037_01/server.101/b10759/conditions018.htm" rel="noopener ugc nofollow" target="_blank">REGEXP_LIKE</a>()</code>编写的以下表达式有助于在Oracle中验证IPv4地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="edd9" class="mg jq hh lj b be mh mi l mj mk">REGEXP_LIKE(ipv4_address, '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$')</span></pre><p id="634b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下示例显示了如何使用上述表达式找出正确的IPv4地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="7140" class="mg jq hh lj b be mh mi l mj mk">WITH <br/>  data<br/>AS<br/>(<br/>    SELECT <br/>      '12.210.60.67' ipv4_address <br/>    FROM dual<br/>  UNION ALL<br/>    SELECT <br/>      '0.0.0.0' ipv4_address <br/>    FROM dual<br/>  UNION ALL<br/>    SELECT <br/>      '10.10.10.asdasd' ipv4_address <br/>    FROM dual<br/>  UNION ALL<br/>    SELECT <br/>      '10.10.as.10' ipv4_address <br/>    FROM dual<br/>  UNION ALL<br/>    SELECT <br/>      '0.0.0.0.0' ipv4_address <br/>    FROM dual<br/>  UNION ALL<br/>    SELECT <br/>      '10.10.10.890' ipv4_address <br/>    FROM dual<br/>)<br/>SELECT<br/>  ipv4_address CORRECT_IPV4<br/>FROM<br/>  data<br/>WHERE<br/>  REGEXP(ip_address, '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$');</span></pre><p id="d3fc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下图显示了上述脚本的输出:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es mq"><img src="../Images/28ccdb7d22fd458be982a2683d450350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*galJzajVQ0FWs4RqavPpiQ.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">IPv4 Address Validation — Oracle Implementation</figcaption></figure><h1 id="db3b" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">验证IPv6地址</h1><p id="bb24" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在本节中，让我们编写函数来验证IPv6地址。</p><h2 id="8ae7" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated">字符数— SQL Server UDF</h2><p id="a19b" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">SQL Server没有内置的字符计数函数，该函数返回某个字符在给定字符串中出现的次数。在IPv6地址验证UDF中，我们需要基于字符数进行一些检查。因此，与其一次又一次地编写相同的逻辑，不如让我们创建一个UDF，它接受一个字符串和一个字符，并返回字符数:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="7e26" class="mg jq hh lj b be mh mi l mj mk">CREATE FUNCTION [dbo].[fn_count_char] <br/>( <br/>   @p_input_string VARCHAR(1000), <br/>   @p_search_char CHAR(1) <br/>)<br/>RETURNS INT<br/>BEGIN<br/><br/>-- Step 1<br/>DECLARE @v_input_string_length INT<br/>DECLARE @v_index INT<br/>DECLARE @v_count INT<br/><br/>SET @v_count = 0<br/>SET @v_index = 1<br/>SET @v_input_string_length = LEN(@p_input_string)<br/><br/>-- Step 2<br/><br/>WHILE @v_index &lt;= @v_input_string_length<br/>   BEGIN<br/>      IF SUBSTRING(@p_input_string, @v_index, 1) = @p_search_char<br/>         SET @v_count = @v_count + 1<br/>         SET @v_index = @v_index + 1<br/>   END<br/><br/>RETURN @v_count<br/><br/>END<br/>GO</span></pre><p id="3391" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">UDF <code class="du lg lh li lj b">fn_count_char()</code>将向我们展示一个特定的字符串/字符在传递的字符串中出现了多少次。UDF遵循的步骤解释如下:</p><ul class=""><li id="c9c0" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated"><em class="jn">步骤1 </em>:这里我们声明并初始化变量:<code class="du lg lh li lj b">@v_input_string_length</code>存储传递的字符串长度，<code class="du lg lh li lj b">@v_index</code>检查记录的索引并置1，<code class="du lg lh li lj b">@v_count</code>存储循环内的计数器。</li><li id="4292" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">步骤2 </em>:我们将运行while循环，直到<code class="du lg lh li lj b">@v_index</code>值小于或等于<code class="du lg lh li lj b">@v_input_string_length</code>。在这个循环中，我们将首先使用substring函数检查<code class="du lg lh li lj b">@p_search_char</code>是否出现在传递的字符串<code class="du lg lh li lj b">@p_input_string</code>中，如果它匹配要搜索的字符串，那么我们将为<code class="du lg lh li lj b">@v_count</code>和<code class="du lg lh li lj b">@v_index</code>加1。如上所述，这个循环将继续，直到<code class="du lg lh li lj b">@v_index</code>值小于或等于<code class="du lg lh li lj b">@v_input_string_length</code>，最后，我们将返回字符串/字符在所传递的字符串中出现的总次数。</li></ul><p id="490d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面的例子显示了如何使用<code class="du lg lh li lj b">fn_count_char()</code>查看给定字符在字符串中出现的次数:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="d001" class="mg jq hh lj b be mh mi l mj mk">SELECT<br/>  'Welcome Home' InputString, <br/>  [dbo].[fn_count_char]('Welcome Home', 'o') CharacterCount<br/>UNION ALL<br/>SELECT<br/>  'Welcome Home' InputString, <br/>  [dbo].[fn_count_char]('Welcome Home', 'e') CharacterCount<br/>UNION ALL<br/>SELECT<br/>  'Welcome Home' InputString, <br/>  [dbo].[fn_count_char]('Welcome Home', 'l') CharacterCount</span></pre><p id="18fd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下图显示了上述脚本的输出:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es mr"><img src="../Images/a0de91457766ed2eee664584f15862d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVr0-EB6KW7oTWtoGA33fQ.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Character Count</figcaption></figure><h2 id="532f" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated">IPv6地址验证— SQL Server UDF</h2><p id="05af" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">以下UDF验证SQL Server中的IPv4地址格式:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="ddee" class="mg jq hh lj b be mh mi l mj mk">CREATE FUNCTION [dbo].[fn_ipv6_validation] <br/>(<br/>   @p_ip_address NVARCHAR(300)<br/>)<br/>RETURNS BIT<br/>AS<br/>BEGIN<br/><br/>/*<br/>  RETURN 'FALSE' - Incorrect Format<br/>  RETURN 'TRUE' - Correct Format<br/>*/<br/><br/>-- Step 1<br/>DECLARE @v_updated_p_ip_address NVARCHAR(100)<br/>DECLARE @v_char_count INT<br/><br/>-- Step 2<br/>SET @v_char_count = dbo.fn_count_char(@p_ip_address, ':')<br/><br/>-- Step 3<br/>IF ( @v_char_count &gt; 7 OR @p_ip_address LIKE '%:::%')<br/>   RETURN 'FALSE'<br/><br/>-- Step 4<br/>IF<br/> (<br/>   SELECT<br/>     COUNT(1)<br/>   FROM<br/>     STRING_SPLIT(@p_ip_address, ':')<br/>   WHERE<br/>     LEN(VALUE)&gt;4<br/> ) &gt; 0<br/>   RETURN 'FALSE'<br/><br/>-- Step 5<br/>IF<br/> (<br/>   (@p_ip_address like '%:' AND @p_ip_address NOT like '%::')<br/>   OR (@p_ip_address like ':%' AND @p_ip_address NOT like '::%')<br/> )<br/>   RETURN 'FALSE'<br/><br/>-- Step 6<br/>IF CHARINDEX('::', @p_ip_address) &gt; 0<br/>   BEGIN<br/>     IF @v_char_count BETWEEN 2 AND 6<br/>         SET @p_ip_address = REPLACE(@p_ip_address, '::', REPLICATE(':', 7-(@v_char_count-2)))<br/>   END<br/><br/>-- Step 7<br/>SET @v_updated_p_ip_address = <br/>      (<br/>        SELECT <br/>           STRING_AGG( RIGHT( REPLICATE( '0', 4) + value, 4), ':')<br/>        FROM<br/>           STRING_SPLIT( @p_ip_address,':')<br/>      )<br/><br/>-- Step 8<br/>IF @v_updated_p_ip_address LIKE STUFF( REPLICATE( ':[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]', 8), 1, 1, '')<br/>   RETURN 'TRUE'<br/><br/>-- Step 9<br/>RETURN 'FALSE'<br/>END<br/>GO</span></pre><p id="20e6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编写UDF <code class="du lg lh li lj b">fn_ipv6_validation()</code>来验证IPv6地址格式，它接受IPv6地址作为参数<code class="du lg lh li lj b">@p_ip_address</code>并返回<code class="du lg lh li lj b">‘TRUE’</code>或<code class="du lg lh li lj b">‘FALSE’</code>。UDF遵循的步骤解释如下:</p><ul class=""><li id="2e02" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated"><em class="jn">步骤1 </em>:我们将声明两个变量<code class="du lg lh li lj b">@v_updated_p_ip_address</code>和<code class="du lg lh li lj b">@v_char_count</code>。<code class="du lg lh li lj b">@v_char_count</code>用于保存<code class="du lg lh li lj b">@p_ip_address</code>中字符冒号(:)的个数，<code class="du lg lh li lj b">@v_updated_p_ip_address</code>用于保存修改后的<code class="du lg lh li lj b">@p_ip_address</code>。</li><li id="2494" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">步骤2 </em>:在步骤2中，我们计算参数<code class="du lg lh li lj b">@p_ip_address</code>中的冒号(:)的数量，并使用函数<code class="du lg lh li lj b">fn_count_char()</code>将其分配给变量<code class="du lg lh li lj b">@v_char_count</code>。</li><li id="b8f7" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">第3步</em>:这里我们检查在第2步中计算的<code class="du lg lh li lj b">@v_char_count</code>是否大于7，或者<code class="du lg lh li lj b">@p_ip_address</code>是否包含多于两个冒号的组。如果满足任何一个条件，函数返回<code class="du lg lh li lj b">‘FALSE’</code>并退出。</li><li id="2c55" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">第四步</em>:使用<code class="du lg lh li lj b"><a class="ae jo" href="https://docs.microsoft.com/en-us/sql/t-sql/functions/string-split-transact-sql?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank">STRING_SPLIT</a>()</code>函数将<code class="du lg lh li lj b">@p_ip_address</code>用冒号(:)分开。如果分割值字符串包含超过四个字符，则返回<code class="du lg lh li lj b">‘FALSE’</code>并退出该功能。</li><li id="e6ff" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">步骤5 </em> : IPv6地址的开头或结尾不应包含单个或两个以上的冒号。这部分代码检查该条件，如果<code class="du lg lh li lj b">@p_ip_address</code>通过该条件并退出函数，则返回<code class="du lg lh li lj b">‘FALSE’</code>。</li><li id="2a6a" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">步骤6 </em>:如果IPv6地址以双冒号格式书写，在步骤6我们将添加所需的冒号，因此IPv6地址中将有七个冒号，并将它分配给<code class="du lg lh li lj b">@p_ip_address</code>。这可以通过使用代码中所示的<code class="du lg lh li lj b"><a class="ae jo" href="https://docs.microsoft.com/en-us/sql/t-sql/functions/replicate-transact-sql?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank">REPLICATE</a>()</code>和<code class="du lg lh li lj b"><a class="ae jo" href="https://docs.microsoft.com/en-us/sql/t-sql/functions/replace-transact-sql?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank">REPLACE</a>()</code>函数来实现。</li><li id="d61b" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">步骤7 </em>:这里我们将确保冒号之间的数字是四位数。如果IPv6地址参数<code class="du lg lh li lj b">@p_ip_address</code>中省略了前导零，我们将按照以下步骤添加这些零，<br/> -使用<code class="du lg lh li lj b"><a class="ae jo" href="https://docs.microsoft.com/en-us/sql/t-sql/functions/string-split-transact-sql?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank">STRING_SPLIT</a>()</code>内置函数根据冒号(:)拆分字符串。<br/> -通过使用<code class="du lg lh li lj b"><a class="ae jo" href="https://learn.microsoft.com/en-us/sql/t-sql/functions/string-agg-transact-sql?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank">STRING_AGG</a>()</code>、<code class="du lg lh li lj b"><a class="ae jo" href="https://learn.microsoft.com/en-us/sql/t-sql/functions/right-transact-sql?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank">RIGHT</a>()</code>和<code class="du lg lh li lj b"><a class="ae jo" href="https://learn.microsoft.com/en-us/sql/t-sql/functions/replicate-transact-sql?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank">REPLICATE</a>()</code>，内置函数将使该IPv6地址成为完整格式。<br/>例如，如果参数<code class="du lg lh li lj b">@p_ip_address</code>的值为1050:0:0:0:5:600:300c:326b，那么会将其更新为1050:0000:0000:0000:0000:0005:0600:300 c:326 b格式，并将其赋给新变量<code class="du lg lh li lj b">@v_updated_p_ip_address</code>。</li><li id="56cc" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">第8步</em>:我们将检查传递的IPv6地址格式是否正确，即值是否在0–9或a-f或A-F之间，如前所述。如果这个条件满足，我们将返回<code class="du lg lh li lj b">‘TRUE’</code>并退出。</li><li id="5e01" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">第9步</em>:如果前面任何一步失败，函数返回<code class="du lg lh li lj b">‘FALSE’</code>并退出。</li></ul><p id="f506" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下示例显示了如何使用<code class="du lg lh li lj b">fn_ipv6_validation()</code>来验证IPv6地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="d9a5" class="mg jq hh lj b be mh mi l mj mk">SELECT<br/>  '2001:db8:3333:4444:5555:6666:7777:8888:6543' Ipv6_value,<br/>  [dbo].[fn_ipv6_validation] ('2001:db8:3333:4444:5555:6666:7777:8888:6543') IPV_Result<br/>UNION ALL<br/>SELECT <br/>  '2001:db8:3333:4444:5555:6666:7777:8888' Ipv6_value, <br/>  [dbo].[fn_ipv6_validation] ('2001:db8:3333:4444:5555:6666:7777:8888') IPV_Result<br/>UNION ALL<br/>SELECT <br/>  '2001:db8:5555::7777:8888' Ipv6_value,<br/>  [dbo].[fn_ipv6_validation] ('2001:db:5555::7777:8888') IPV_Result<br/>UNION ALL<br/>SELECT <br/>  '::7777:8888' Ipv6_value, <br/>  [dbo].[fn_ipv6_validation] ('::7777:8888') IPV_Result<br/>UNION ALL<br/>SELECT <br/>  ':2001:db8:5555:6666:7777:8888::' Ipv6_value, <br/>  [dbo].[fn_ipv6_validation] (':2001:db8:5555:6666:7777:8888::') IPV_Result<br/>UNION ALL<br/>SELECT <br/>  '2001:db8:3333:4444:5555:6666:7777:8888:' Ipv6_value, <br/>  [dbo].[fn_ipv6_validation] ('2001:db8:3333:4444:5555:6666:7777:8888:') IPV_Result<br/>UNION ALL<br/>SELECT <br/>  ':2001:db8:3333:4444:5555:6666:7777:8888' Ipv6_value, <br/>  [dbo].[fn_ipv6_validation] (':2001:db8:3333:4444:5555:6666:7777:8888') IPV_Result;</span></pre><p id="f3ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下图显示了上述脚本的输出:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es ms"><img src="../Images/958ed2aaed8675bf653352361ec4e82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B2I5OCQcYGcpm3CHUGh8Cw.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">IPv6 Address Validation — SQL Server Implementation</figcaption></figure><h2 id="0595" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated">IPv6地址验证— Oracle</h2><p id="d215" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">使用<code class="du lg lh li lj b"><a class="ae jo" href="https://docs.oracle.com/cd/B12037_01/server.101/b10759/conditions018.htm" rel="noopener ugc nofollow" target="_blank">REGEXP_LIKE</a>()</code>编写的以下表达式有助于在Oracle中验证IPv6地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="68c1" class="mg jq hh lj b be mh mi l mj mk">REGEXP_LIKE<br/> (ipv6_address, '(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|<br/>               ([0-9a-fA-F]{1,4}:){1,7}:|<br/>               ([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|<br/>               ([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|<br/>               ([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|<br/>               ([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|<br/>               ([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|<br/>               [0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|<br/>               :((:[0-9a-fA-F]{1,4}){1,7}|:))'<br/> ) </span></pre><p id="d860" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下示例显示了如何使用上述表达式来验证IPv6地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="6103" class="mg jq hh lj b be mh mi l mj mk">WITH <br/>  data <br/>AS<br/>(<br/>    SELECT <br/>      '2001:db8:3333:4444:5555:6666:7777:8888:6543' ip_address <br/>    FROM <br/>      dual <br/>  UNION ALL<br/>    SELECT <br/>      '2001:dc8:3333:4444:5555:6666:7777:8888' ip_address <br/>    FROM <br/>      dual <br/>  UNION ALL<br/>    SELECT <br/>      '2001:d18:5555::7777:8888' ip_address <br/>    FROM <br/>      dual <br/>  UNION ALL<br/>    SELECT <br/>      '::7777:8888' ip_address <br/>    FROM <br/>      dual <br/>  UNION ALL<br/>    SELECT <br/>      ':2001:d18:5555:7777:8888::' ip_address <br/>    FROM <br/>      dual <br/>  UNION ALL<br/>    SELECT <br/>      '2001:db8:3333:4444:5555:6666:7777:8888:' ip_address <br/>    FROM <br/>      dual <br/>  UNION ALL<br/>    SELECT ':2001:db8:3333:4444:5555:6666:7777:8888' ip_address <br/>    FROM <br/>      dual<br/>)<br/>SELECT <br/>  ip_address<br/>FROM <br/>  data<br/>WHERE <br/>  REGEXP_LIKE<br/>    (CASE <br/>        WHEN (ip_address LIKE '::%' AND ip_address NOT LIKE '%:') OR (ip_address LIKE '%::' AND ip_address NOT LIKE ':%')<br/>          THEN ip_address<br/>        WHEN ip_address LIKE ':%' OR ip_address LIKE '%:' <br/>          THEN '123'<br/>        ELSE ip_address<br/>      END, <br/>      '(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'<br/>    )<br/>AND ip_address NOT LIKE '%:::%'<br/>AND REGEXP_COUNT(ip_address, ':') &lt; 8<br/>AND REGEXP_COUNT(ip_address, '::') &lt; 2;</span></pre><p id="8cbd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下图显示了上述脚本的输出:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es mt"><img src="../Images/d4a53ff3ede5bd77e44f311ea2104c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7ZqVSjv66A-_g6oUqnecw.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">IPv6 Address Validation — Oracle Implementation</figcaption></figure><h1 id="3237" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">验证MAC地址</h1><h2 id="4662" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated">MAC地址验证— SQL Server UDF</h2><p id="4a17" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">下面的UDF验证SQL Server中的MAC地址格式:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="05e9" class="mg jq hh lj b be mh mi l mj mk">CREATE FUNCTION [dbo].[fn_mac_address_validation]<br/>(<br/>  @p_mac_address NVARCHAR(300)<br/>)<br/>RETURNS BIT<br/>AS<br/>BEGIN<br/><br/>/*<br/>  RETURN 'FALSE' - Incorrect Format<br/>  RETURN 'TRUE' - Correct Format<br/>*/<br/><br/>-- Step 1<br/>IF<br/>(<br/>  -- Format: [00-FF]:[00-FF]:[00-FF]:[00-FF]:[00-FF]:[00-FF]<br/>  @p_mac_address LIKE STUFF(REPLICATE(':[0-9a-fA-F][0-9a-fA-F]',6),1,1,'')<br/>  -- Format: [00-FF]-[00-FF]-[00-FF]-[00-FF]-[00-FF]-[00-FF]<br/>  OR @p_mac_address LIKE STUFF(REPLICATE('-[0-9a-fA-F][0-9a-fA-F]',6),1,1,'')<br/>  -- Format: [0000-FFFF]-[0000-FFFF]-[0000-FFFF]<br/>  OR @p_mac_address LIKE STUFF(REPLICATE('.[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]',3),1,1,'')<br/>  -- Format: [000000000000-FFFFFFFFFFFF]<br/>  OR @p_mac_address LIKE REPLICATE('[0-9a-fA-F]',12)<br/>)<br/>  RETURN 'TRUE'<br/><br/>-- Step 2<br/>RETURN 'FALSE'<br/>END<br/>GO</span></pre><p id="1da2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lg lh li lj b">fn_mac_address_validation()</code>是为验证MAC地址格式而编写的UDF，它接受一个MAC地址作为参数<code class="du lg lh li lj b">@p_mac_address</code>，并返回<code class="du lg lh li lj b">‘TRUE’</code>或<code class="du lg lh li lj b">‘FALSE’</code>。UDF遵循的步骤解释如下:</p><ul class=""><li id="7ea4" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated"><em class="jn">第一步</em> : MAC地址可以写成四种不同的格式。因此，在第一步中，我们将验证所有格式，如果参数<code class="du lg lh li lj b">@p_mac_address</code>通过任何一种格式，函数将返回<code class="du lg lh li lj b">‘TRUE’</code>。</li><li id="f080" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">第二步</em>:如果上一步失败，该功能返回<code class="du lg lh li lj b">‘FALSE’</code>并退出</li></ul><p id="640a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面的例子展示了如何使用<code class="du lg lh li lj b">fn_mac_address_validation()</code>来验证MAC地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="a235" class="mg jq hh lj b be mh mi l mj mk">SELECT <br/>  '01-23-45-67-89-AB' Mac_Value, <br/>  [dbo].[fn_mac_address_validation]('01-23-45-67-89-AB') MAC_Result<br/>UNION ALL<br/>SELECT <br/>  '01:23:45:67:-89:AB' Mac_Value, <br/>  [dbo].[fn_mac_address_validation]('01:23:45:67:-89:AB') MAC_Result<br/>UNION ALL<br/>SELECT <br/>  '01:23:45:67:89:AB' Mac_Value, <br/>  [dbo].[fn_mac_address_validation]('01:23:45:67:89:AB') MAC_Result<br/>UNION ALL<br/>SELECT <br/>  '01.23.45.67.89.AH' Mac_Value, <br/>  [dbo].[fn_mac_address_validation]('01.23.45.67.89.AH') MAC_Result<br/>UNION ALL<br/>SELECT <br/>  '0123.4567.89Aa' Mac_Value, <br/>  [dbo].[fn_mac_address_validation]('0123.4567.89Aa') MAC_Result<br/>UNION ALL<br/>SELECT <br/>  '0123456789Aa' Mac_Value, <br/>  [dbo].[fn_mac_address_validation]('0123456789Aa') MAC_Result;</span></pre><p id="359c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下图显示了上述脚本的输出:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es mu"><img src="../Images/de6869c944828f1039bf24c0b41a5bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7WpMmNJDMBn-jl5i0XdNgA.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">MAC Address Validation — SQL Server Implementation</figcaption></figure><h2 id="3472" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated">MAC地址验证— Oracle</h2><p id="96e5" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">以下使用<code class="du lg lh li lj b"><a class="ae jo" href="https://docs.oracle.com/cd/B12037_01/server.101/b10759/conditions018.htm" rel="noopener ugc nofollow" target="_blank">REGEXP_LIKE</a>()</code>的表达式有助于验证Oracle中的MAC地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="e9cb" class="mg jq hh lj b be mh mi l mj mk">-- For [00-FF]:[00-FF]:[00-FF]:[00-FF]:[00-FF]:[00-FF]<br/>REGEXP_LIKE(mac_address, '^([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2})$')<br/><br/>-- For [00-FF]-[00-FF]-[00-FF]-[00-FF]-[00-FF]-[00-FF]<br/>REGEXP_LIKE(mac_address, '^([0-9A-Fa-f]{2}[-]){5}([0-9A-Fa-f]{2})$')<br/><br/>-- For [0000-FFFF]-[0000-FFFF]-[0000-FFFF]<br/>REGEXP_LIKE(mac_address, '^([0-9A-Fa-f]{4}[.]){2}([0-9A-Fa-f]{4})$')<br/><br/>-- For [000000000000-FFFFFFFFFFFF]<br/>REGEXP_LIKE(mac_address, '^([0-9A-Fa-f]{12})$')</span></pre><p id="4c3e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面的例子显示了如何使用上述表达式找出正确的MAC地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="6af9" class="mg jq hh lj b be mh mi l mj mk">WITH <br/>  data <br/>AS<br/>(<br/>    SELECT <br/>      '01-23-45-67-89-AB' mac_address <br/>    FROM <br/>      dual <br/>  UNION ALL<br/>    SELECT <br/>      '01:23:45:67:-89:AB' mac_address <br/>    FROM <br/>      dual <br/>  UNION ALL<br/>    SELECT <br/>      '01:23:45:67:89:AB' mac_address <br/>    FROM <br/>      dual <br/>  UNION ALL<br/>    SELECT <br/>      '01.23.45.67.89.AH' mac_address <br/>    FROM <br/>      dual <br/>  UNION ALL<br/>    SELECT <br/>      '0123.4567.89Aa' mac_address <br/>    FROM <br/>      dual <br/>  UNION ALL<br/>    SELECT <br/>      '0123456789Aa' mac_address <br/>    FROM <br/>      dual<br/>)<br/>SELECT<br/>  mac_address<br/>FROM <br/>  data<br/>WHERE<br/>  (<br/>    REGEXP_LIKE(mac_address, '^([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2})$')<br/>    OR<br/>    REGEXP_LIKE(mac_address, '^([0-9A-Fa-f]{2}[-]){5}([0-9A-Fa-f]{2})$')<br/>    OR<br/>    REGEXP_LIKE(mac_address, '^([0-9A-Fa-f]{4}[.]){2}([0-9A-Fa-f]{4})$')<br/>    OR<br/>    REGEXP_LIKE(mac_address, '^([0-9A-Fa-f]{12})$')<br/>  );</span></pre><p id="bff0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下图显示了上述脚本的输出:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es mv"><img src="../Images/2614923124f532afe7ca6d28547d871a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5IsZkO7tM9bdhNHNfnzsVg.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">MAC Address Validation — Oracle Implementation</figcaption></figure><h1 id="9027" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">正在验证IPv4子网地址</h1><p id="15f7" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在本节中，让我们编写函数来验证IPv4子网地址。</p><h2 id="11f0" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated">IPv4网络子网验证— SQL Server UDF</h2><p id="42dd" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">以下UDF验证SQL Server中的IPv4网络子网格式:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="ebc2" class="mg jq hh lj b be mh mi l mj mk">CREATE FUNCTION [dbo].[fn_network_subnet_validation]<br/>(<br/>  @p_network_subnet NVARCHAR(300)<br/>)<br/>RETURNS BIT<br/>AS<br/>BEGIN<br/><br/>/*<br/>  RETURN 'FALSE' - Incorrect Format<br/>  RETURN 'TRUE' - Correct Format<br/>*/<br/><br/>-- Step 1<br/>IF<br/>  (<br/>     SUBSTRING( @p_network_subnet, CHARINDEX( '/', @p_network_subnet) + 1, 10) LIKE '%[^0-9]%'<br/>     OR LEN( SUBSTRING( @p_network_subnet, CHARINDEX( '/', @p_network_subnet) + 1, 10)) = 0<br/>     OR LEN( SUBSTRING( @p_network_subnet, CHARINDEX( '/', @p_network_subnet) + 1, 10)) &gt; 2<br/>     OR SUBSTRING( @p_network_subnet, CHARINDEX( '/', @p_network_subnet) + 1, 10) LIKE '0_%'<br/>     OR CHARINDEX( '/', @p_network_subnet) = 0<br/>  )<br/>    RETURN 'FALSE'<br/><br/>-- Step 2<br/>IF<br/>  (<br/>     @p_network_subnet NOT LIKE '%[a-zA-Z]%'<br/>     AND<br/>       ( dbo.fn_ipv4_validation( SUBSTRING( @p_network_subnet, 1,<br/>CASE WHEN CHARINDEX( '/', @p_network_subnet) = 0 THEN <br/>LEN(@p_network_subnet)<br/>ELSE CHARINDEX( '/', @p_network_subnet) - 1<br/>END )) = '1'                                             <br/>         OR CHARINDEX( '/', @p_network_subnet) = '1'<br/>       )<br/>     AND <br/>       SUBSTRING( @p_network_subnet, CHARINDEX('/', @p_network_subnet) + 1, 10) BETWEEN '0' AND '32'<br/>  )<br/>    RETURN 'TRUE'<br/> <br/>RETURN 'FALSE'<br/>END<br/>GO</span></pre><p id="7c88" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lg lh li lj b">fn_network_subnet_validation()</code>编写UDF来验证网络子网格式，它接受网络子网作为参数<code class="du lg lh li lj b">@p_network_subnet</code>并返回<code class="du lg lh li lj b">‘TRUE’</code>或<code class="du lg lh li lj b">‘FALSE’</code>。UDF遵循的步骤解释如下:</p><ul class=""><li id="4ace" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated"><em class="jn">步骤1 </em>:如果<code class="du lg lh li lj b">@p_network_subnet</code>满足以下任一条件，函数返回<code class="du lg lh li lj b">‘FALSE’</code>并退出:<br/>——检查“/”后的子串是否包含数字以外的字符。<br/> -检查“/”后的子字符串长度是否为零。<br/> -检查“/”后面的子字符串长度是否大于2。<br/> -检查“/”后的子字符串是否以零开头。<br/> -检查字符“/”是否出现在<code class="du lg lh li lj b">@p_network_subnet</code>中。</li><li id="6438" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><em class="jn">步骤2 </em>:如果满足以下所有条件，则函数返回<code class="du lg lh li lj b">‘TRUE’</code>，否则返回<code class="du lg lh li lj b">‘FALSE’</code>并退出:<br/> - <code class="du lg lh li lj b">@p_network_subnet</code>不包含a-z或A-Z中的任何字符。<br/>-<code class="du lg lh li lj b">@p_network_subnet</code>中“/”前的子部分是有效的IPv4地址，或者<code class="du lg lh li lj b">@p_network_subnet</code>的第一个字符是“/”。<br/>—“/”后的子字符串介于0-32之间。</li></ul><p id="1cb0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下示例显示了如何使用<code class="du lg lh li lj b">fn_network_subnet_validation()</code>来验证IPv4网络子网地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="ff50" class="mg jq hh lj b be mh mi l mj mk">SELECT <br/>   '10.10.10.10/' Network_value, <br/>   [dbo].[fn_network_subnet_validation] ('10.10.10.10/') Network_Result <br/>UNION ALL <br/>SELECT <br/>  '10.10.10.10' Network_value, <br/>  [dbo].[fn_network_subnet_validation] ('10.10.10.10') Network_Result <br/>UNION ALL <br/>SELECT <br/>  '10.10.10.asdasd/11' Network_value, <br/>  [dbo].[fn_network_subnet_validation] ('10.10.10.asdasd/11') Network_Result <br/>UNION ALL <br/>SELECT <br/>  '10.10.10.10/31' Network_value,<br/>  [dbo].[fn_network_subnet_validation] ('10.10.10.10/31') Network_Result <br/>UNION ALL <br/>SELECT <br/>  '10.10.10.10/ac' Network_value,<br/>  [dbo].[fn_network_subnet_validation] ('10.10.10.10/ac') Network_Result <br/>UNION ALL <br/>SELECT <br/>  '/22' Network_value,<br/>  [dbo].[fn_network_subnet_validation] ('/22') Network_Result <br/>UNION ALL <br/>SELECT <br/>  '/44' Network_value, <br/>  [dbo].[fn_network_subnet_validation] ('/44') Network_Result <br/>UNION ALL <br/>SELECT <br/>  '/' Network_value, <br/>  [dbo].[fn_network_subnet_validation] ('/') Network_Result <br/>UNION ALL <br/>SELECT <br/>  '/as' Network_value, <br/>  [dbo].[fn_network_subnet_validation] ('/as') Network_Result <br/>UNION ALL <br/>SELECT <br/>  '10.10.10.890/12' Network_value,<br/>  [dbo].[fn_network_subnet_validation] ('10.10.10.890/12') Network_Result <br/>UNION ALL <br/>SELECT <br/>  '/1b' Network_value, <br/>  [dbo].[fn_network_subnet_validation] ('/1b') Network_Result <br/>UNION ALL <br/>SELECT <br/>  '/1.2' Network_value, <br/>  [dbo].[fn_network_subnet_validation] ('/1.2') Network_Result;</span></pre><p id="36ad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下图显示了上述脚本的输出:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es mw"><img src="../Images/59e594d8137072343152b63c101db790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRA4x92bVDwBqi_ln3iWFQ.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">IPv4 Network Address Validation — SQL Server Implementation</figcaption></figure><h2 id="0701" class="ks jq hh bd jr kt ku kv jv kw kx ky jz ja kz la kd je lb lc kh ji ld le kl lf bi translated">IPv4网络子网验证— Oracle</h2><p id="4407" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">使用<code class="du lg lh li lj b"><a class="ae jo" href="https://docs.oracle.com/cd/B12037_01/server.101/b10759/conditions018.htm" rel="noopener ugc nofollow" target="_blank">REGEXP_LIKE</a>()</code>编写的以下表达式验证Oracle中的IPv4网络子网地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="24a1" class="mg jq hh lj b be mh mi l mj mk">REGEXP_LIKE(network_subnet, '^.{0}$|^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(3[0-2]|[1-2][0-9]|[0-9]))$|^(\/(3[0-2]|[1-2][0-9]|[0-9]))$')</span></pre><p id="b663" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以下示例显示了如何使用上述表达式找出正确的IPv4网络子网地址:</p><pre class="ly lz ma mb fd mc lj md bn me mf bi"><span id="8ea0" class="mg jq hh lj b be mh mi l mj mk">WITH <br/>  data <br/>AS<br/>(<br/>  SELECT <br/>    '10.10.10.10/' network_subnet <br/>  FROM <br/>    dual <br/>UNION ALL<br/>  SELECT <br/>    '10.10.10.10' network_subnet <br/>  FROM <br/>    dual <br/>UNION ALL<br/>  SELECT <br/>    '10.10.10.asdasd/11' network_subnet <br/>  FROM <br/>    dual <br/>UNION ALL<br/>  SELECT <br/>    '10.10.10.10/31' network_subnet <br/>  FROM <br/>    dual <br/>UNION ALL<br/>  SELECT <br/>    '10.10.10.10/ac' network_subnet <br/>  FROM <br/>    dual <br/>UNION ALL<br/>  SELECT <br/>    '/22' network_subnet <br/>  FROM <br/>    dual <br/>UNION ALL<br/>  SELECT <br/>    '/44' network_subnet <br/>  FROM <br/>    dual <br/>UNION ALL<br/>  SELECT <br/>    '/' network_subnet <br/>  FROM <br/>    dual <br/>UNION ALL<br/>  SELECT <br/>    '/as' network_subnet <br/>  FROM <br/>    dual <br/>UNION ALL<br/>  SELECT <br/>    '10.10.10.890/12' network_subnet <br/>  FROM <br/>    dual <br/>UNION ALL<br/>  SELECT <br/>    '/1b' network_subnet <br/>  FROM <br/>    dual <br/>UNION ALL<br/>  SELECT <br/>    '/1.2' network_subnet <br/>  FROM <br/>    dual<br/>)<br/>SELECT<br/>  network_subnet<br/>FROM <br/>  data<br/>WHERE <br/>  REGEXP_LIKE(network_subnet, '^.{0}$|^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(3[0-2]|[1-2][0-9]|[0-9]))$|^(\/(3[0-2]|[1-2][0-9]|[0-9]))$');</span></pre><p id="c511" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下图显示了上述脚本的输出:</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="er es mx"><img src="../Images/c831fdcc624faae75ef0de460e51dac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J671i7o1VAUF01BqmjBagQ.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">IPv4 Network Address Validation — Oracle Implementation</figcaption></figure><h1 id="35e1" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="4829" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">本文为您提供了在SQL Server和Oracle中验证网络子网地址的数据库脚本，否则您很难做到这一点。</p></div></div>    
</body>
</html>