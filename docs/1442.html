<html>
<head>
<title>Being Proactively Reactive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">积极应对</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/being-proactively-reactive-7e112abf1579?source=collection_archive---------3-----------------------#2017-04-19">https://medium.com/capital-one-tech/being-proactively-reactive-7e112abf1579?source=collection_archive---------3-----------------------#2017-04-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="a84b" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">抽象出代码复杂性的新范例</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/c06f679d452687c7a82660cf89a8bbbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pA05WZRqXw_Bq_sncbeTGw.png"/></div></div></figure><p id="ca07" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">实时事件无处不在——无论是UI事件还是数据事件——它们正在推动web和移动应用程序向用户提供高度互动的体验。作为一名开发人员，当试图提供高交互性时，很容易陷入实现细节的网络中。反应式编程范式在命令式回调系统上增加了一个抽象层次，帮助我们不再担心复杂的实现细节。</p><p id="0143" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，实现这种抽象可能需要编码风格的重大改变。</p><h1 id="6514" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">什么是反应式编程？</h1><p id="ee1d" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">每个人都至少有一点反应式编程的经验，因为我们大多数人以前都做过Excel电子表格。这看起来眼熟吗？</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lc"><img src="../Images/c7d2a815595915a04d76ff93f5c00493.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*17it2WLLMuNkGy4sm6ScZQ.png"/></div></figure><p id="849b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在上面的Excel表格中，如果任何数字发生变化，总和也会相应地更新。这在传统上被称为<a class="ae ld" href="https://en.wikipedia.org/wiki/Dataflow_programming" rel="noopener ugc nofollow" target="_blank">数据流编程</a><em class="ke"/>，但已经被现代化并重新命名为<em class="ke">反应式编程。</em></p><p id="8153" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这个范例中，输入数据序列可以采取多种形式；它们可以是来自文件或web服务(如Twitter feed)的数据流，也可以是一系列事件(如用户输入或鼠标点击)。人们可以将该流视为按时间顺序的事件/数据序列的<em class="ke">传输。本质上是非阻塞的异步编程使得能够将这些数据流序列委派给各种线程、系统和/或设备。</em></p><p id="bc7b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ke">反应式编程是关于数据序列异步流动的编程。</em></p><h1 id="6761" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">被动的心态…</h1><p id="5f0e" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">JavaScript诞生的时候，C、C++和Java在商业上流行于非大型机计算。像我一样，大多数Java开发人员继续呆在面向对象编程的舒适区，偶尔打破规则，比如在JSP中嵌入JavaScript片段。</p><p id="d1b7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">JavaScript社区真正腾飞是在2005年，当时杰西·詹姆斯·加勒特发布了一份白皮书，他创造了“Ajax”这个术语——JavaScript是其支柱。这导致围绕JavaScript形成了过多的开源库和社区。函数式编程没有一个公认的定义；然而，通过将函数视为第一类对象，Javascript使得面向对象的程序员改变了他们的思维。</p><p id="e146" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如今，Java8、Scala、Groovy和Clojure等JVM语言已经采用并集成了函数式编程作为其语言的关键部分。来自命令式编程的背景，从函数式编程开始可能会令人望而生畏。然而，在使用函数式编程技术的几周内，人们可以快速构建一组简单的模块化函数，并利用基于语言的并行计算。反应式思维需要类似的(如果不是更少的话)编程范式转变，以迫使您的大脑放弃旧的典型命令式和函数式编程习惯。</p><h1 id="122d" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">…导致被动反应！</h1><p id="a0aa" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">行为模式观察者和迭代器是现代UI框架和MVC模型中最流行的模式。很好地理解这两种模式是开始使用反应式编程的基础。</p><p id="431b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">迭代器模式</strong>提供了一种方法来遍历和访问或<em class="ke">拉取</em>容器(集合/数据源/生成器)对象的元素，而不暴露其底层表示。在<strong class="jk hi">观察者模式</strong>中，生产者知道新数据何时可用，并向消费者发送或<em class="ke">推送</em>该数据。</p><p id="587f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">迭代器和观察器是<em class="ke">拉</em>和<em class="ke">推</em>模型的主要例子，它们是许多反应式编程讨论的基础，与<em class="ke">同步和异步</em>风格的编程直接相关。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es le"><img src="../Images/89644cca95ef96ad440a6e62b438f380.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*y7ZFyV_3TpnD7FvAOtDmoA.png"/></div></figure><h2 id="74dd" class="lf kg hh bd kh lg lh li kl lj lk ll kp jr lm ln kr jv lo lp kt jz lq lr kv ls bi translated"><strong class="ak"> <em class="lt">拉</em> </strong></h2><p id="7b33" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">当您<em class="ke">拉动</em>时，您最终会重复数据集以检测变化。在下面的示例中，初始数据集有两个字符——A和b。第一次迭代提取并打印A和b。然后我添加了两个新字符，但除非我再次迭代相同的数据集，否则看不到变化。这是一个势在必行的T21方法。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lu"><img src="../Images/5c8307cf6b3cff208af09e4eba7d71a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mm8msVwo4wIy7CG8iYQcIQ.png"/></div></div></figure><p id="f331" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当然，可以通过使用<em class="ke">轮询</em>来实现<em class="ke">拉</em>的方法——例如每1000毫秒检查一次数组长度，如果数据有变化就遍历。换句话说，使用<em class="ke"> pull </em>让开发人员负责明确请求数据中的任何变化，这通常需要启动多个线程，并且难以维护。</p><h2 id="1e98" class="lf kg hh bd kh lg lh li kl lj lk ll kp jr lm ln kr jv lo lp kt jz lq lr kv ls bi translated"><strong class="ak"> <em class="lt">推</em> </strong></h2><p id="7756" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">为了使用<em class="ke">拉</em>的方法获得最新的变化，开发人员最终会编写复杂的代码。<em class="ke">推送</em>可以使用<em class="ke">观察者模式</em>来实现，但是那涉及到开发者需要反复编写的大量锅炉板代码。<em class="ke">推</em>的实现也可以使用<em class="ke">回调</em>的方法来实现，但是与<em class="ke">观察者模式</em>不同，在回调中只有一个回调可以被告知变化。这意味着开发人员最终会编写复杂的代码，这违背了回调的目的。为了避免编写复杂的回调或样板观察者模式，我们可以从<em class="ke"> Rx库</em>中获益。</p><p id="3198" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在这个例子中，在RX类<strong class="jk hi"> Observable </strong>和<strong class="jk hi"> PublishSubject </strong>的帮助下，我们已经为<em class="ke"> ArrayList </em>提供了向其订户推送更改的能力。人们可能仍然会争论代码是复杂的，但这正是开发人员需要范式转换的地方——随着我们的深入，它会变得越来越简单。学习Observable和PublishSubject的基础知识将有助于我们理解这个例子。</p><h2 id="3295" class="lf kg hh bd kh lg lh li kl lj lk ll kp jr lm ln kr jv lo lp kt jz lq lr kv ls bi translated"><strong class="ak"> rx。可观察的</strong></h2><p id="c820" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">在ReactiveX中，一个观察者订阅了一个<strong class="jk hi">可观察的</strong>。然后，观察者对可观察物发出的任何项目或项目序列做出反应。通过调用observers方法，可观察对象向其观察者发出项目或发送通知。一旦<a class="ae ld" href="http://reactivex.io/RxJava/javadoc/rx/Observer.html" rel="noopener ugc nofollow" target="_blank">观察者</a>订阅了，“T26】观察者有时被称为“订阅者”、“观察者”或“反应者”。</p><h2 id="2782" class="lf kg hh bd kh lg lh li kl lj lk ll kp jr lm ln kr jv lo lp kt jz lq lr kv ls bi translated"><strong class="ak">rx . subjects . publish subject；</strong></h2><p id="1bb8" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated"><strong class="jk hi">主题</strong>是一种桥或代理，在ReactiveX的一些实现中可用。它既是观察者又是被观察者。因为它是一个观察者，所以它可以订阅一个或多个观察值。因为是可观测的，所以它可以通过重新发射的方式穿过它所观测的项目，也可以发射新的项目。<strong class="jk hi">发布主题</strong>是为特定用例设计的<em class="ke">主题</em>的四个变种之一。它将所有后续观察到的项目发送给订阅者，并为观察者提供一个新的观察项目。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lv"><img src="../Images/ff6dd726a460f51d65e2b3122c495e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N0tlh21KZ_v0xK-qFProIg.png"/></div></div></figure><h2 id="b3e1" class="lf kg hh bd kh lg lh li kl lj lk ll kp jr lm ln kr jv lo lp kt jz lq lr kv ls bi translated"><strong class="ak">无功扩展(RX) </strong></h2><p id="4152" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">AJAX (Java的非阻塞I/O API)和Node.js在主流web开发中的流行确实帮助了同步/异步概念的发展。当涉及到数据结构时，大多数程序员通常使用<strong class="jk hi">有限集合</strong>如数组、映射或集合，而<strong class="jk hi">无限集合</strong>通常使用网络套接字处理。</p><p id="d109" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">反应式扩展或RX承诺为语言提供一致的API，允许它在数据序列的这四个维度上无缝工作:<strong class="jk hi">异步、同步、有限和无限。</strong></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lw"><img src="../Images/9d2ab1eecc21816d34b1f9e42459b73d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*g189nDk7I2aAXesx-6ttTA.png"/></div></figure><p id="3175" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">简而言之，</p><blockquote class="lx ly lz"><p id="5332" class="ji jj ke jk b jl jm ii jn jo jp il jq ma js jt ju mb jw jx jy mc ka kb kc kd ha bi translated">“它扩展了observer模式以支持数据和/或事件的序列，并添加了操作符，允许您以声明的方式将序列组合在一起，同时抽象出诸如低级线程、同步、线程安全、并发数据结构和非阻塞I/O等问题。”——http://reactivex.io/intro.html<a class="ae ld" href="http://reactivex.io/intro.html" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><h1 id="0fab" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">为什么不无功？</strong></h1><p id="75ec" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">如果您的代码只处理一个事件流，那么带有回调的命令式编程可能是一个不错的选择。即使您有多个独立的事件流，命令式编程可能仍然更好，因为它消除了反应式编程的抽象层，使您更接近操作系统和编译器优化。</p><p id="d539" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，提供高度交互的体验通常需要您组合事件，拥有条件逻辑，并优雅地处理失败场景——这是反应式编程真正闪光的地方。</p><h1 id="3a86" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">摘要</h1><p id="4caa" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">反应式编程是一个编程术语，专注于对变化(如数据值或事件)做出反应，这些变化通常是强制性的。反应式编程实现提供了对命令式回调的额外抽象。这个抽象层为异步和非阻塞编程提供了一个非常强大的工具。然而，它需要对你的编码风格进行重大的改变。当你实现了这种改变，反应式编程被证明是一种非常有效的工具，和它的前辈们一起——面向对象和函数式编程。在简化企业级软件复杂性的任务中，每个都有自己的重要位置。</p></div><div class="ab cl md me go mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ha hb hc hd he"><p id="72a0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="ke">披露声明:以上观点为作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2017首都一。</em>T9】</strong></p><p id="c24c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="ke">欲了解更多关于Capital One的API、开源、社区活动和开发人员文化，请访问我们的一站式开发人员门户网站DevExchange。</em></strong><a class="ae ld" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jk hi"><em class="ke">developer.capitalone.com/</em></strong></a></p></div></div>    
</body>
</html>