<html>
<head>
<title>Optimizing Ember Templates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化Ember模板</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/optimizing-ember-templates-c479d26fe58e?source=collection_archive---------1-----------------------#2016-08-31">https://medium.com/square-corner-blog/optimizing-ember-templates-c479d26fe58e?source=collection_archive---------1-----------------------#2016-08-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="0558" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">模板占你Ember应用的60%。现在怎么办？</p><blockquote class="jd"><p id="acbd" class="je jf hh bd jg jh ji jj jk jl jm jb dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们在https://developer.squareup.com/blog<a class="ae jn" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">的新家</a></p></blockquote><figure class="jp jq jr js jt ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jo"><img src="../Images/e8131abf4cc5e8ab467320bb0c9ca8e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZFCFalUhLVCZM47GpgVBw@2x.png"/></div></div></figure><p id="5c89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">更新:自从这篇文章首次发表以来，Ember的基本性能已经提高了很多！Ember 2.10附带了一个新的渲染引擎，使得一些优化变得没有必要。如果你使用的是2.9或更低版本的旧应用，请继续阅读！</em></p><p id="4fe3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当源代码通过编译器或传输器时，很容易在一段代码的感知重量和它在产品中的实际大小之间产生脱节。</p><p id="9ccd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于Ember模板来说尤其如此，微小的变化会对生成的JavaScript数量产生深远的影响。</p><blockquote class="jd"><p id="aaac" class="je jf hh bd jg jh ji jj jk jl jm jb dx translated">“每个字节都很重要。”<br/> —每一个前端Web开发者<br/>(穷尽了其他优化app启动的方法之后)</p></blockquote><h1 id="5dc3" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">条件块是昂贵的</h1><p id="74b0" class="pw-post-body-paragraph ie if hh ig b ih kz ij ik il la in io ip lb ir is it lc iv iw ix ld iz ja jb ha bi translated">考虑一个呈现两个段落的组件模板，第二个段落是使用一个<em class="jc"> #if </em>助手有条件地呈现的:</p><figure class="le lf lg lh fd ju"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="fee9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该组件生成的代码总大小为3.8 KiB，大得惊人！所有的代码都是从哪里来的？</p><p id="9fc0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个模板在构建时都被转换成一个JavaScript模块。每个模块都包含创建DOM并填充其子模块和值所需的逻辑、代码和数据(示例如下)。</p><p id="2642" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里令人惊讶的是条件IF块的编译方式。它变成了一个完整的子模板，几乎和父模板一样大，拥有自己的元数据和渲染功能(以红色显示)。</p><figure class="le lf lg lh fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es lk"><img src="../Images/e0431a94634ec9dc92c6078c94b76cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0eSd8DmOJ1Mig3qVKyNYQQ@2x.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Generated JavaScript for Template with Conditional IF</figcaption></figure><p id="f02a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">{{#if}}助手非常容易使用，从精神上来说，它是一个针对条件情况的轻量级解决方案。然而，在幕后，每个条件块实际上都由相同的基础结构表示为一个全新的模板。</p><p id="a0be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">相反，如果我们使用一个类名有条件地隐藏段落元素，它将删除一半生成的代码，并节省总应用程序大小的1.2 KiB！</p><figure class="le lf lg lh fd ju"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="eddb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这似乎是一种有争议的优化模板的方法，但它阐明了我们将继续探索的一般概念:<em class="jc">小的改变可以节省大量代码，有时是以牺牲可维护性<br/>和可读性为代价的。</em></p><figure class="le lf lg lh fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es lk"><img src="../Images/eae8e519b07881c48ce3148660ab15af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2jemmD5QRvJ-QsADxpv7bw@2x.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">Using a dynamic class removes an entire template child</figcaption></figure><h1 id="8b1f" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km lp ko kp kq lq ks kt ku lr kw kx ky bi translated">避免重复使用IF/Else循环</h1><p id="4ab7" class="pw-post-body-paragraph ie if hh ig b ih kz ij ik il la in io ip lb ir is it lc iv iw ix ld iz ja jb ha bi translated">一个包含一系列If/Else语句的更复杂的模板展示了生成的代码如何变得更大。<em class="jc">每个条件块</em>都被转换成一个子模板，其大小与上例中的红色文本相同。因此，虽然这看起来像一个模板，但实际上是八个模板。</p><figure class="le lf lg lh fd ju"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="le lf lg lh fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jo"><img src="../Images/b1d577388737408f34aef932a83499c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a54bjwoVrFkmsnHr9fvpPA@2x.png"/></div></div></figure><p id="38c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以使用#each循环重构这个组件，并将<em class="jc"> instrumentList </em>数组的创建移到javascript中:</p><figure class="le lf lg lh fd ju"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="4967" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">即使考虑到构建<strong class="ig hi">工具列表所需的额外JavaScript，</strong>新的实现也节省了12 KiB的代码。</p><h1 id="e5ff" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km lp ko kp kq lq ks kt ku lr kw kx ky bi translated">计算属性</h1><p id="9070" class="pw-post-body-paragraph ie if hh ig b ih kz ij ik il la in io ip lb ir is it lc iv iw ix ld iz ja jb ha bi translated">另一种避免模板中条件块的技术是将工作转移到计算属性中。在下面的例子中，通过计算JavaScript中显示的值，您节省了超过50%的组件大小。</p><figure class="le lf lg lh fd ju er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es jo"><img src="../Images/394391571deeb547757459ebd01119ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPjkT4hkgaGFYlrfbc0TvA@2x.png"/></div></div></figure><h1 id="024d" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km lp ko kp kq lq ks kt ku lr kw kx ky bi translated">模板中的SVG</h1><p id="2cad" class="pw-post-body-paragraph ie if hh ig b ih kz ij ik il la in io ip lb ir is it lc iv iw ix ld iz ja jb ha bi translated">当在模板中使用时，SVG的大小也会增加。这个SVG文件在一个圆内呈现一个复选标记；源代码是298字节，但是编译成JavaScript 的<a class="ae jn" href="https://gist.github.com/terrilldent/06d074e20e0b4492bc695661a7698ac7" rel="noopener ugc nofollow" target="_blank"> 2.2 KiB！</a></p><figure class="le lf lg lh fd ju er es paragraph-image"><div class="er es ls"><img src="../Images/13986c45b80825296cc2d43a344cc2c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*kL724EvMCxG6fSZJc7wUPQ.png"/></div></figure><figure class="le lf lg lh fd ju"><div class="bz dy l di"><div class="li lj l"/></div></figure><ul class=""><li id="26c9" class="lt lu hh ig b ih ii il im ip lv it lw ix lx jb ly lz ma mb bi translated">记得在把SVG添加到你的模板之前，通过一个像<a class="ae jn" href="https://github.com/svg/svgo" rel="noopener ugc nofollow" target="_blank"> SVGO </a>这样的迷你程序来运行它。</li><li id="5045" class="lt lu hh ig b ih mc il md ip me it mf ix mg jb ly lz ma mb bi translated">手动检查结果以清除任何其他未使用的属性。</li><li id="ac95" class="lt lu hh ig b ih mc il md ip me it mf ix mg jb ly lz ma mb bi translated">您可以安全地省略内联SVG上的<em class="jc"> xmlns </em>和<em class="jc"> version </em>属性。</li></ul><p id="5951" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更好的办法是，尝试将SVG移动到一个外部文件中，并将其作为背景图像或一个<img/>标签的源进行引用。这将节省整个模板的成本，如果很少使用，这是一个明智的选择。有时你甚至可以使用CSS 创建<a class="ae jn" href="http://a.singlediv.com/" rel="noopener ugc nofollow" target="_blank">相同的图像！</a></p><h1 id="990e" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km lp ko kp kq lq ks kt ku lr kw kx ky bi translated">使用组件的隐式标签</h1><p id="76ac" class="pw-post-body-paragraph ie if hh ig b ih kz ij ik il la in io ip lb ir is it lc iv iw ix ld iz ja jb ha bi translated">每个Ember组件都有一个隐式包装标签，可用于样式和布局。即使它没有在模板中定义，您也可以使用组件的JavaScript文件自定义该标记。</p><p id="29ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的循环示例中，我们可以通过修改组件来优化包装标签<br/><strong class="ig hi">&lt;section class = ' instruments-container '&gt;</strong>:</p><figure class="le lf lg lh fd ju"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="9999" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">模板中只有一个顶级元素的任何模板都是使用隐式组件标签的候选。这种技术还有助于减少DOM中的节点数量。</p><h1 id="275d" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km lp ko kp kq lq ks kt ku lr kw kx ky bi translated">扩展组件而不是包装</h1><p id="01ea" class="pw-post-body-paragraph ie if hh ig b ih kz ij ik il la in io ip lb ir is it lc iv iw ix ld iz ja jb ha bi translated">当向现有组件添加新功能时，很容易将基本组件包装在新模板中，并传递所有属性。这带来了创建新模板文件的副作用，通常可以通过扩展现有组件来完全避免:</p><figure class="le lf lg lh fd ju"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="ll lm et er es ln lo bd b be z dx">Extending an Existing Ember Component</figcaption></figure><h1 id="869f" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km lp ko kp kq lq ks kt ku lr kw kx ky bi translated">更进一步</h1><p id="2b26" class="pw-post-body-paragraph ie if hh ig b ih kz ij ik il la in io ip lb ir is it lc iv iw ix ld iz ja jb ha bi translated">理解Ember模板编译器有助于使这些技术更加直观。更深入的一个快速方法是以多种方式实现同一个模板，并比较结果。您可以使用diff工具来查看最终输出的比较结果，以及哪种方法最适合您的场景。模板快乐！</p></div></div>    
</body>
</html>