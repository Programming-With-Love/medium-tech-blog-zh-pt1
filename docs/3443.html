<html>
<head>
<title>Microfrontend — from tradition to Module Federation !!!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微前端——从传统到模块联盟！！！</h1>
<blockquote>原文：<a href="https://medium.com/globant/microfrontend-from-tradition-to-module-federation-8ed50710904b?source=collection_archive---------0-----------------------#2020-07-27">https://medium.com/globant/microfrontend-from-tradition-to-module-federation-8ed50710904b?source=collection_archive---------0-----------------------#2020-07-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1abeb74b973589c146ef33d8b182c980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQD7FFeBuRKMXNI6vZ7CRA.png"/></div></div></figure></div><div class="ab cl ip iq go ir" role="separator"><span class="is bw bk it iu iv"/><span class="is bw bk it iu iv"/><span class="is bw bk it iu"/></div><div class="ha hb hc hd he"><p id="7f27" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">微服务一直是一个需要了解和实施的奇特概念，许多组织一直在使用这种架构风格来避免大型整体后端的限制。</p><p id="611a" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><em class="ju">在这种情况下，frontend也开始遵循这一足迹，将monoliths frontend分解为更小、更简单的块，这些块可以独立开发、测试和部署，同时仍然作为单一的内聚产品出现在客户面前。我们称这种技术为</em> <strong class="iy hi"> <em class="ju">微前端</em> </strong></p><blockquote class="jv jw jx"><p id="04de" class="iw ix ju iy b iz ja jb jc jd je jf jg jy ji jj jk jz jm jn jo ka jq jr js jt ha bi translated"><strong class="iy hi"> <em class="hh">“将可独立交付的前端应用组合成一个更大整体的架构风格”</em> </strong></p></blockquote><p id="78a2" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">微前端有什么好处？</p><ul class=""><li id="570e" class="kb kc hh iy b iz ja jd je jh kd jl ke jp kf jt kg kh ki kj bi translated"><strong class="iy hi">增量升级</strong></li><li id="e0a2" class="kb kc hh iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><strong class="iy hi">解耦代码库</strong></li><li id="3c7e" class="kb kc hh iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><strong class="iy hi">独立部署</strong></li><li id="e57d" class="kb kc hh iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><strong class="iy hi">自主团队</strong></li></ul><p id="af9f" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">简而言之，microfrontend将大而可怕的东西分割成更小、更易管理的部分。</p><p id="61bd" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">在您的项目中实现微前端有多种方法，我们可以把这称为<strong class="iy hi">集成方法，</strong>让我们逐一探讨。</p><h1 id="318d" class="kp kq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">服务器端模板合成</h1><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c8ada77c5237fc43e649ba01b20f94a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTN78ttvX2sWna5TnOwj-Q.png"/></div></div></figure><p id="2281" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">这里，我们在服务器上呈现HTML，我们有index.html，它包含任何常见的页面元素，然后使用服务器端从片段HTML文件中插入特定于页面的内容。</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="693e" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">我们使用Nginx提供这个文件，通过匹配被请求的URL来配置$PAGE变量:</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="7968" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">这里我们称之为微前端，因为它以这样一种方式分割代码，每一部分代表一个独立团队可以交付的自包含领域概念。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lt"><img src="../Images/fd97059db203dc817a38e5031ced14c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*REiK0UOjtD_S7s-9ib58UA.jpeg"/></div><figcaption class="lu lv et er es lw lx bd b be z dx">ssr microfrontend approch</figcaption></figure><h1 id="14a7" class="kp kq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">构建时集成</h1><p id="373d" class="pw-post-body-paragraph iw ix hh iy b iz ly jb jc jd lz jf jg jh ma jj jk jl mb jn jo jp mc jr js jt ha bi translated">这种方法将每个微前端应用程序发布为一个包，并拥有容器应用程序，该容器应用程序将它们作为库依赖项包含在内。下面是package.json的样子</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="71c6" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">因此，它产生了单个可部署的JavaScript包，允许我们从各种应用程序中消除常见的依赖关系，但是这种方法使得重新编译和发布每个微前端，以便获得产品发布，这意味着我们再次<strong class="iy hi">锁定发布过程</strong>，这违反了microfrotnend的准则。因此，在运行时集成微前端总是比在构建时集成好</p><h1 id="88d9" class="kp kq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">通过iframes进行运行时集成</h1><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/237f799b13ce007c7a271664943bfeb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bvm39Eg3FGbN1ULcTZmTiA.png"/></div></div></figure><p id="a8df" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">在浏览器中将微应用程序组合在一起的最简单的方法之一是简单的iframe。Iframe使得从独立的子页面构建页面变得容易，它确保全局变量和样式不会相互干扰。</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="1498" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">这种基于iframe的方法并不是一种新技术，也许看起来并不令人兴奋。这项技术有其自身的成本。很难在应用程序的不同部分之间进行集成，因此它们使路由、历史和深度链接变得更加复杂，也为页面的全面响应带来了额外的挑战。</p><h1 id="92c2" class="kp kq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">通过JavaScript进行运行时集成</h1><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/36e45fb86b95e6ae58bf1f9f3b4a3740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-yYgE-rOhdv9Vwtr10z_g.png"/></div></div></figure><p id="09d9" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">另一种方法最灵活，也经常被采用。这里，每个微应用程序都使用一个<script>标签包含在页面上，并加载全局作为其入口点。然后，容器应用程序决定安装哪个微前端，并调用相关函数来告诉微应用程序何时何地进行渲染。&lt;/root&gt;</script></p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="152e" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">这是一种运行时集成方法，我们可以独立地部署每个构建文件。与iframe不同，我们有充分的灵活性来构建我们的微应用程序之间的集成，我们还可以对bundle.js文件进行lazyload，并可以在增强性能方面做出一些贡献。</p><h1 id="2db2" class="kp kq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">通过Web组件进行运行时集成</h1><p id="df92" class="pw-post-body-paragraph iw ix hh iy b iz ly jb jc jd lz jf jg jh ma jj jk jl mb jn jo jp mc jr js jt ha bi translated">每个微前端定义一个HTML自定义元素供容器实例化的方法之一，而不是定义要调用的容器的全局函数。</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="53ea" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">这是使用浏览器提供的功能的方式，可能是一个好的选择。</p><p id="2e2c" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">因此，这是以自己的方式和自己的成本集成各种微前端的常用方法。</p><p id="f331" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">接下来让我们看看微前端面临的主要挑战之一，即<strong class="iy hi">通信</strong>。</p><h1 id="164b" class="kp kq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">跨应用程序通信</h1><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e5d941bc02135e7b6258ab04e6873245.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jy9tVRiN4qp7WymmZDq0Rg.png"/></div></div></figure><p id="972f" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">脑海中出现的一个主要问题是，这些微型应用程序如何相互通信，因为我们已经将它们分离为微型应用程序，但现在通信是主要关注的问题。</p><p id="29ed" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">一种可能的方式是<a class="ae md" href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events" rel="noopener ugc nofollow" target="_blank">自定义事件</a>，它允许微应用程序之间间接通信，这是一种最小化直接耦合的好方法，但它也使得确定和执行微前端之间存在的契约变得更加困难。</p><blockquote class="jv jw jx"><p id="48ab" class="iw ix ju iy b iz ja jb jc jd je jf jg jy ji jj jk jz jm jn jo ka jq jr js jt ha bi translated">第二种方法是，如果您正在使用<strong class="iy hi"> redux </strong>，那么没有什么比这更好的了，因为通常的方法是为整个应用程序提供一个单一的、全局的和共享的存储。然而，如果每个微前端都应该是自己的独立应用程序，那么每个微前端都有自己的redux存储是有意义的。</p></blockquote><p id="2c4d" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">第三种替代方法是使用地址栏作为通信机制。</p><p id="0157" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">基本上，有几种不同的方法可以在微前端应用程序中进行通信，因此每种方法都有正反两面。</p><p id="e6b0" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi me translated"><span class="l mf mg mh bm mi mj mk ml mm di">所以</span> <strong class="iy hi"> <em class="ju">这都是关于传统的方法，这些方法已经被业界采用来实现微前端架构模式，但是现在让我们来看看游戏改变者，webpack如何加快步伐来解决微前端的挑战，并使事情变得更加简单和流畅。</em> </strong></p><h1 id="f0b9" class="kp kq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Webpack 5模块联盟来救援！！！</h1><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="mn ls l"/></div><figcaption class="lu lv et er es lw lx bd b be z dx"><a class="ae md" href="https://giphy.com/" rel="noopener ugc nofollow" target="_blank">https://giphy.com/</a></figcaption></figure><blockquote class="jv jw jx"><p id="65d8" class="iw ix ju iy b iz ja jb jc jd je jf jg jy ji jj jk jz jm jn jo ka jq jr js jt ha bi translated">模块联合允许JavaScript应用程序在客户机和服务器上动态运行来自另一个包/构建的代码。</p></blockquote><h2 id="c431" class="mo kq hh bd kr mp mq mr kv ms mt mu kz jh mv mw ld jl mx my lh jp mz na ll nb bi translated">什么是模块联合？</h2><p id="e18e" class="pw-post-body-paragraph iw ix hh iy b iz ly jb jc jd lz jf jg jh ma jj jk jl mb jn jo jp mc jr js jt ha bi translated">Zack Jackson 发明并解释得非常好，这是一个发明的javascript架构，成为Webpack 5 core最令人兴奋的特性之一。</p><blockquote class="jv jw jx"><p id="0b4c" class="iw ix ju iy b iz ja jb jc jd je jf jg jy ji jj jk jz jm jn jo ka jq jr js jt ha bi translated">它允许javascript应用程序从另一个应用程序动态加载代码，其突出的特性就好像一个应用程序正在使用联邦模块，并且没有联邦代码所需的依赖关系，那么webpack将从该联邦构建源下载缺少的依赖关系。神奇的东西…</p></blockquote><p id="c029" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><strong class="iy hi">一些术语……</strong></p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es nc"><img src="../Images/b5f354b550300f2060860a3cc0304ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*ZUl9_qSIzfy_ok61h6G3vA.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx">Borrowed from <a class="ae md" rel="noopener" href="/swlh/webpack-5-module-federation-a-game-changer-to-javascript-architecture-bcdd30e02669">webpack-5-module-federation</a></figcaption></figure><p id="d6ed" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><strong class="iy hi">模块联合:</strong>从另一个应用程序加载代码</p><p id="dcd8" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><strong class="iy hi">主机:</strong>在页面加载过程中首先初始化的webpack构建(当onLoad事件被触发时)</p><p id="8b7e" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><strong class="iy hi">远程</strong>:另一个Webpack构建，其中一部分被一个“<strong class="iy hi">主机</strong>使用</p><p id="632f" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><strong class="iy hi">双向主机</strong>:当bundle或Webpack构建可以作为主机或远程工作时。要么消费其他应用程序，要么被消费</p></div><div class="ab cl ip iq go ir" role="separator"><span class="is bw bk it iu iv"/><span class="is bw bk it iu iv"/><span class="is bw bk it iu"/></div><div class="ha hb hc hd he"><blockquote class="jv jw jx"><p id="816f" class="iw ix ju iy b iz ja jb jc jd je jf jg jy ji jj jk jz jm jn jo ka jq jr js jt ha bi translated">需要注意的是，该系统的设计使得每个完全独立的构建/应用程序都可以位于自己的存储库中，独立部署，并作为自己独立的SPA运行。</p></blockquote><p id="deaf" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">模块联合具有增值特性，基于模块联合的应用都是双向主机。因此，任何首先加载的应用程序都将成为主机，这意味着如果您移动并更改应用程序的路由，那么联邦模块将以与您实施动态加载相同的方式加载，并且如果您刷新页面，那么在该加载中首先启动的任何应用程序都将成为主机。<strong class="iy hi">终极！！！</strong></p><h1 id="9843" class="kp kq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">信息丰富的文字已经足够了！！现在让我们用代码弄脏我们的手吧！！</h1><p id="eaca" class="pw-post-body-paragraph iw ix hh iy b iz ly jb jc jd lz jf jg jh ma jj jk jl mb jn jo jp mc jr js jt ha bi translated">模块联盟的Webpack设置(双向主机)。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nd"><img src="../Images/0d8dccbe2b0a0ebda253c6a015e114b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*raet5KDAy0NBpiA4UywaFw.png"/></div></div><figcaption class="lu lv et er es lw lx bd b be z dx">Image borrowed from <a class="ae md" href="https://rangle.io/blog/module-federation-federated-application-architectures/" rel="noopener ugc nofollow" target="_blank">https://rangle.io/blog/module-federation-federated-application-architectures/</a></figcaption></figure><ul class=""><li id="7b0b" class="kb kc hh iy b iz ja jd je jh kd jl ke jp kf jt kg kh ki kj bi translated"><strong class="iy hi">文件名</strong>:定义当前应用程序的文件名，使其远程化(如localhost:3000/remoteEntry.js)</li><li id="407b" class="kb kc hh iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><strong class="iy hi">暴露</strong>:这将使“小部件”组件通过“remoteEntry.js”作为共享组件可用，然后它可以作为“从应用程序/小部件导入小部件”加载</li><li id="8c11" class="kb kc hh iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><strong class="iy hi"> remotes </strong>:远程加载应用程序主页</li><li id="c3c4" class="kb kc hh iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><strong class="iy hi">共享</strong>:将所有npm模块依赖关系添加为共享模块</li></ul><h1 id="c2ef" class="kp kq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">下面是动态远程的例子——在构建时在主机未知的远程之间动态加载和共享代码的能力！！</h1><p id="21f1" class="pw-post-body-paragraph iw ix hh iy b iz ly jb jc jd lz jf jg jh ma jj jk jl mb jn jo jp mc jr js jt ha bi translated">我们如何处理这个例子？</p><ol class=""><li id="90c1" class="kb kc hh iy b iz ja jd je jh kd jl ke jp kf jt ne kh ki kj bi translated"><strong class="iy hi"> <em class="ju">主机app的Webpack设置</em> </strong></li><li id="f2ae" class="kb kc hh iy b iz kk jd kl jh km jl kn jp ko jt ne kh ki kj bi translated"><strong class="iy hi"/></li><li id="b52b" class="kb kc hh iy b iz kk jd kl jh km jl kn jp ko jt ne kh ki kj bi translated"><strong class="iy hi"> <em class="ju">远程应用的Webpack设置</em> </strong></li><li id="c18f" class="kb kc hh iy b iz kk jd kl jh km jl kn jp ko jt ne kh ki kj bi translated"><strong class="iy hi"> <em class="ju">在远程应用程序中创建组件，该组件将远程加载到主机应用程序中</em> </strong></li></ol><p id="a7f0" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">让我们为主机应用程序设置webpack，在这里您可以找到应用程序名称和共享的react供应商模块。</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="9943" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">现在是时候定义动态联盟挂钩了，这个挂钩将延迟加载注册到主机应用程序的远程子应用程序。</p><p id="ed1d" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">让我们一个接一个地看看动态集成远程子应用程序的方法。</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="5093" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">动态脚本函数将获取远程子应用程序的url，并在运行时将该url注入现有HTML的脚本元素，以便脚本将动态加载远程子应用程序。</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="0f64" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">现在已经加载了子应用程序，是时候初始化可以提供共享模块的容器了，加载组件函数将为我们做必要的更改，它接受范围和模块，</p><ul class=""><li id="232d" class="kb kc hh iy b iz ja jd je jh kd jl ke jp kf jt kg kh ki kj bi translated"><strong class="iy hi">范围</strong>:远程子app名称</li><li id="98ba" class="kb kc hh iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><strong class="iy hi">模块</strong>:从远程子app导出的模块的名称。</li></ul><p id="606f" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">在这个参数的帮助下，load component函数将用共享模块初始化容器。</p><p id="dc5b" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">现在让我们把这些放在一起，形成动态联邦的react钩子。</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="3e6c" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">useDynamicRouteMFE()将从父应用程序获取系统对象，并将其传递给组件<System/>以呈现子应用程序。</p><p id="9092" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><strong class="iy hi">问题出现了，如何使用钩子useDynamicFederation()？</strong></p><p id="40c2" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">下面是Microfrontend组件的代码片段，这个组件借助useDynamicFederation()渲染了subApp。</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="d6b2" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">接下来，我们将了解如何准备好远程子应用程序，以便主机应用程序可以动态集成它。</p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="8618" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">这是子应用程序中的小部件组件，现在我们希望将其导出，并应导入到目标主机应用程序中，易于配置。</p><p id="5e25" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">为了让这一切发生，我们的英雄登场了，那不是别人，正是<strong class="iy hi">模块联盟</strong></p><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="bea7" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">这样，我们将配置子应用程序的webpack，在此设置的帮助下，我们可以使子应用程序对主机应用程序远程可用。</p><ul class=""><li id="27bf" class="kb kc hh iy b iz ja jd je jh kd jl ke jp kf jt kg kh ki kj bi translated"><strong class="iy hi">文件名:</strong>这里我们可以看到，我们已经添加了文件名为remoteEntry.js这个文件应该注入到目标主机app index.html。</li><li id="b0ff" class="kb kc hh iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><strong class="iy hi"> Exposes: </strong>在这里，我们导出我们的widget.js组件，并使它可以远程使用。</li><li id="00f7" class="kb kc hh iy b iz kk jd kl jh km jl kn jp ko jt kg kh ki kj bi translated"><strong class="iy hi">共享:</strong>这将共享远程子应用程序所需的所有供应商依赖关系</li></ul><h1 id="c0e7" class="kp kq hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">演示时间！！！！！</h1><figure class="ln lo lp lq fd ii"><div class="bz dy l di"><div class="nf ls l"/></div></figure><p id="7c66" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">这个演示程序演示了如何使用模块联合来动态加载和共享在构建时主机未知的远程代码。</p><blockquote class="ng"><p id="3dad" class="nh ni hh bd nj nk nl nm nn no np jt dx translated">这是前端架构的发展和游戏改变者，如果你看到我们在编译时不需要知道微前端。相反，我们可以在运行时加载配置，说明有多少微锋可用以及在哪里可以找到它们。</p></blockquote><p id="0f44" class="pw-post-body-paragraph iw ix hh iy b iz nq jb jc jd nr jf jg jh ns jj jk jl nt jn jo jp nu jr js jt ha bi translated">对于更多令人兴奋的特性，请关注模块联盟的进一步发展。</p><p id="7cb9" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">即将推出的主题…</p><p id="46f6" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><strong class="iy hi"> <em class="ju">“微前端—子app间通信，由模块联邦提供动力”</em> </strong></p><p id="a99c" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><strong class="iy hi"> <em class="ju">“微前端—具有模块联邦的Rock多框架”</em> </strong></p><p id="262f" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated"><strong class="iy hi"> <em class="ju">“微前端Next.js的模块联邦”</em> </strong></p><p id="9fcf" class="pw-post-body-paragraph iw ix hh iy b iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ha bi translated">参考</p><div class="nv nw ez fb nx ny"><a rel="noopener follow" target="_blank" href="/swlh/webpack-5-module-federation-a-game-changer-to-javascript-architecture-bcdd30e02669"><div class="nz ab dw"><div class="oa ab ob cl cj oc"><h2 class="bd hi fi z dy od ea eb oe ed ef hg bi translated">Webpack 5联盟:JavaScript架构的游戏改变者</h2><div class="of l"><h3 class="bd b fi z dy od ea eb oe ed ef dx translated">多个Webpack构建一起工作，就像一个整体。运行时轻松、可扩展的编排，在两个客户端上…</h3></div><div class="og l"><p class="bd b fp z dy od ea eb oe ed ef dx translated">medium.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om in ny"/></div></div></a></div></div></div>    
</body>
</html>