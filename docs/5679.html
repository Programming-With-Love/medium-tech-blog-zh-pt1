<html>
<head>
<title>Bpf — a tour of program types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Bpf —程序类型之旅</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/bpf-a-tour-of-program-types-75778c90ea2?source=collection_archive---------0-----------------------#2019-12-10">https://medium.com/oracledevs/bpf-a-tour-of-program-types-75778c90ea2?source=collection_archive---------0-----------------------#2019-12-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="b149" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><strong class="ak"> <em class="iw"> Oracle Linux内核开发人员Alan Maguire介绍了这个由六部分组成的关于BPF的系列文章，其中他深入介绍了内核的“Berkeley包过滤”——这是一个有用的、可扩展的内核功能，不仅仅用于包过滤。</em>T3】</strong></h2></div><p id="07c2" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如果你关注Linux内核开发的讨论和博客文章，你可能最近经常听到BPF提到。它正被用于高性能负载平衡、DDoS缓解和防火墙、内核和用户空间代码的安全检测等等！BPF通过在许多不同的上下文中支持安全灵活的编程环境来做到这一点；网络数据路径、内核探测、性能事件等等。安全是关键——在大多数环境中，添加内核模块会带来巨大的风险。然而，BPF程序在程序加载时被验证，以确保不发生越界访问等。此外，BPF支持即时将其字节码编译成本机指令集，因此BPF程序也很快。如果你对快速数据包处理和可观测性感兴趣，学习BPF绝对应该在你的任务清单上。</p><p id="a016" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在这里，我们试图给BPF一个指南，涵盖一系列的主题，希望能帮助开发人员努力抓住写BPF程序。本指南基于Linux 4.14(这是Oracle Linux UEK5的内核)，所以请记住这一点，因为自那以后，BPF已经进行了大量的更改，并且一些软件包名称等可能会因其他发行版而有所不同。</p><p id="8aeb" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">因为Linux中的BPF是一个快速移动的目标，所以我将试着把您指向内核代码库中的相关位置，这可能有助于您了解该技术能做什么。samples/bpf目录是一个很好的地方，可以看看其他人做了什么，但是这里我们也将深入研究实现作为参考，因为它可能会给你一些关于如何创建新的bpf程序的想法。这里的目的不是深入探究BPF的内部，而是给出代码中揭示BPF功能的一些地方。我用来参考的源代码树是我们的UEK5版本，基于Linux 4.14.35。参见https://github.com/oracle/linux-uek/tree/uek5/master<a class="ae jt" href="https://github.com/oracle/linux-uek/tree/uek5/master" rel="noopener ugc nofollow" target="_blank">。所描述的大多数功能都可以在任何最新的内核中找到。bpf-next树(bpf内核开发发生的地方)可以在</a></p><p id="6263" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><a class="ae jt" href="https://git.kernel.org/pub/scm/linux/kernel/git/bpf/bpf-next.git" rel="noopener ugc nofollow" target="_blank">https://git . kernel . org/pub/SCM/Linux/kernel/git/bpf/bpf-next . git</a></p><p id="c616" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">一个重要的警告；同样，下面描述的是4.14内核的状态。从那以后发生了很多变化；但是希望有了指向代码的指针，您将能够更好地理解这些变化是什么！</p><p id="a7e6" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">这里的目的是能够开始和BPF一起研究有趣的问题。然而，在我们到达那里之前，让我们看看各种各样的部分，以及它们是如何组合在一起的。</p><p id="17fc" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">首先要问的问题是，我们能拿BPF怎么办？我们能写什么样的程序？</p><p id="2eb6" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">为了对此有所了解，让我们检查一下include/uapi/Linux/bpf . h<a class="ae jt" href="https://github.com/oracle/linux-uek/blob/uek5/master/include/uapi/linux/bpf.h#L117" rel="noopener ugc nofollow" target="_blank">https://github . com/Oracle/Linux-uek/blob/uek 5/master/include/uapi/Linux/bpf . h # L117</a>中的枚举类型定义</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="ec1e" class="kd ke hh jz b fi kf kg l kh ki">enum bpf_prog_type {<br/> BPF_PROG_TYPE_UNSPEC,<br/> BPF_PROG_TYPE_SOCKET_FILTER,<br/> BPF_PROG_TYPE_KPROBE,<br/> BPF_PROG_TYPE_SCHED_CLS,<br/> BPF_PROG_TYPE_SCHED_ACT,<br/> BPF_PROG_TYPE_TRACEPOINT,<br/> BPF_PROG_TYPE_XDP,<br/> BPF_PROG_TYPE_PERF_EVENT,<br/> BPF_PROG_TYPE_CGROUP_SKB,<br/> BPF_PROG_TYPE_CGROUP_SOCK,<br/> BPF_PROG_TYPE_LWT_IN,<br/> BPF_PROG_TYPE_LWT_OUT,<br/> BPF_PROG_TYPE_LWT_XMIT,<br/> BPF_PROG_TYPE_SOCK_OPS,<br/> BPF_PROG_TYPE_SK_SKB,<br/>};</span></pre><p id="1f0b" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">所有这些程序类型是什么？为了理解这一点，我们将针对每种计划类型提出同样的问题:</p><ul class=""><li id="2394" class="kj kk hh iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">我该如何处理这种程序类型？</li><li id="b0b8" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何为这种项目类型附加我的BPF项目？</li><li id="762a" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">向我的程序提供了什么上下文？这里我们指的是提供给我们工作的论据和数据。</li><li id="3894" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">附加程序什么时候开始运行？理解这一点很重要，因为它给出了过滤器在网络堆栈中的应用位置。</li></ul><p id="97c2" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我们现在不会担心你如何创建程序；在各种程序类型中，这方面的情况相对来说是一致的。</p><h2 id="f9f5" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">1.与套接字相关的程序类型—套接字_过滤器、SK_SKB、SOCK_OPS</h2><p id="96d8" class="pw-post-body-paragraph ix iy hh iz b ja lq ii jc jd lr il jf jg ls ji jj jk lt jm jn jo lu jq jr js ha bi translated">首先，让我们考虑与套接字相关的程序类型，它们允许我们过滤、重定向套接字数据和监视套接字事件。过滤用例与BPF的起源有关。在观察网络时，我们只想看到网络流量的一部分，例如，来自一个有问题的系统的所有流量。过滤器用于描述我们希望看到的流量，理想情况下，我们希望它很快，我们希望给用户一个开放式的过滤选项集。但是我们有一个问题:我们希望尽早丢弃不需要的数据，为此我们需要在内核环境中进行过滤。考虑内核解决方案的替代方案——产生将数据包复制到用户空间并在那里过滤的成本。这将非常昂贵，尤其是如果我们只想看到网络流量的一部分，而丢弃其余部分。为了实现这一点，发明了一种安全的迷你语言来将高级过滤器翻译成内核可以使用的字节码程序(称为经典BPF，c BPF)。该语言的目标是支持一组灵活的过滤选项，同时又快速安全。用这种类似汇编语言编写的过滤器可以由tcpdump之类的用户空间程序来完成内核过滤。https://www.tcpdump.org/papers/bpf-usenix93.pdf见<a class="ae jt" href="https://www.tcpdump.org/papers/bpf-usenix93.pdf" rel="noopener ugc nofollow" target="_blank"/></p><p id="21e9" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">…关于描述这项工作的经典论文。现代eBPF采用了这些概念，扩展了寄存器和指令集，增加了称为映射的数据结构，极大地扩展了我们可以附加的事件种类，等等！</p><p id="ed95" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">对于套接字过滤，常见的情况是附加到原始套接字(SOCK_RAW ),事实上，您会注意到大多数进行套接字过滤的程序都有这样一行:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="df38" class="kd ke hh jz b fi kf kg l kh ki">s = socket(AF_PACKET,SOCK_RAW,htons(ETH_P_ALL));</span></pre><p id="babf" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">创建这样一个套接字，我们指定域(AF_PACKET)、套接字类型(SOCK_RAW)和协议(所有包类型)。在Linux内核中，原始数据包的接收是由raw_local_deliver()函数实现的。它由ip_local_deliver_finish()调用，就在调用相关ip协议的处理程序之前，在那里数据包被传递到TCP、UDP、ICMP等。所以在这一点上，流量还没有与特定的套接字相关联；这发生在稍后，当IP堆栈找出从数据包到第4层协议，然后到相关套接字(如果有的话)的映射时。通过使用-d选项，可以看到tcpdump生成的cBPF字节码。这里我想在wlp4s0接口上运行tcpdump，只过滤TCP流量:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="a20f" class="kd ke hh jz b fi kf kg l kh ki"># tcpdump -i wlp4s0 -d 'tcp'<br/>(000) ldh      [12]<br/>(001) jeq      #0x86dd          jt 2    jf 7<br/>(002) ldb      [20]<br/>(003) jeq      #0x6             jt 10    jf 4<br/>(004) jeq      #0x2c            jt 5    jf 11<br/>(005) ldb      [54]<br/>(006) jeq      #0x6             jt 10    jf 11<br/>(007) jeq      #0x800           jt 8    jf 11<br/>(008) ldb      [23]<br/>(009) jeq      #0x6             jt 10    jf 11<br/>(010) ret      #65535<br/>(011) ret      #0</span></pre><p id="3ac3" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">没有深入的知识，我们也能感觉到这里发生了什么。在行000上，我们加载以太网报头的偏移+12；以太网报头协议类型。在第001行，如果匹配ETH_P_IPv6 (0x86dd) (jt 2)，我们跳转到002，否则跳转到007，如果不匹配(jf 7)(处理IPv4的情况)。</p><p id="13ce" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">让我们先看看IPv6案例。在第003行，我们跳到010 —成功—如果IPv6协议(偏移量+ 20)是6 (IPPROTO_TCP) —第010行返回65535，这是最大长度，因此我们接受数据包。否则我们跳到004。这里我们与0x2c进行比较，这表明有一个IPv6片段头。如果是这样，我们检查片段头(偏移量54)是否将下一个协议值指定为IPPROTO_TCP，如果是，我们跳到10(成功)或11(失败)。返回0表示出于过滤目的丢弃数据包。</p><p id="a5c7" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">处理IPv4更简单；在007上(通过001上的“jf”到达)，我们检查ETH_P_IPV4，如果找到，我们验证IPPROTO是TCP。我们完事了。请记住，虽然这是cBPFeBPF有一个类似x86_64的扩展指令/操作集和额外的寄存器。</p><p id="c1f6" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">另一件需要注意的事情是——套接字过滤不同于基于netfilter的过滤。Netfilter使用NF_HOOK()定义定义了自己的一组钩子，基于netfilter的技术(如ipfilter)也可以使用这些钩子来过滤流量。你可能会想——我们不能在那里也使用eBPF吗？你是对的！在更新的Linux内核中，bpfilter正在取代ipfilter。</p><p id="8f89" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">记住所有这些，让我们回到检查与套接字相关的程序类型。</p><h2 id="43cd" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">1.1 BPF _程序_类型_套接字_过滤器</h2><ul class=""><li id="f05c" class="kj kk hh iz b ja lq jd lr jg lv jk lw jo lx js ko kp kq kr bi translated">我该拿它怎么办？过滤操作包括丢弃数据包(如果程序返回0)或修剪数据包(如果程序返回的长度小于原始长度)。见sk_filter_trim_cap()及其对bpf_prog_run_save_cb()的调用。请注意，我们没有修剪或丢弃原始数据包，它仍然会完整地到达预期的套接字；我们正在处理数据包元数据的副本，原始套接字可以访问该副本以实现可观察性。除了过滤流向我们套接字的数据包，我们还可以做一些有副作用的事情；例如在BPF地图中收集统计数据。</li><li id="6eff" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？可以通过SO_ATTACH_BPF setsockopt()将BPF程序附加到套接字上，该函数向程序传递一个文件描述符。</li><li id="e88d" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">提供了什么语境？指向包含数据包元数据/数据的struct __sk_buff的指针。这个结构是在include/linux/bpf.h中定义的，包含了来自真实sk_buff的关键字段。bpf验证器将对有效__sk_buff字段的访问转换成“真实”sk_buff的偏移量，更多细节参见<a class="ae jt" href="https://lwn.net/Articles/636647/" rel="noopener ugc nofollow" target="_blank">https://lwn.net/Articles/636647/</a>。</li><li id="5495" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">它什么时候运行？套接字过滤器为sock_queue_rcv_skb()中的receive运行，它由各种协议(TCP、UDP、ICMP、原始套接字等)调用，可用于过滤入站流量。</li></ul><p id="c81a" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">为了给程序看起来像什么的感觉，这里我们将创建一个过滤器，它根据协议类型修剪我们过滤的数据包数据；对于IPv4 TCP，我们只获取IPv4 + TCP报头，而对于UDP，我们只获取IPv4和UDP报头。我们不会处理IPv4选项，因为这是一个简单的例子，所以在所有其他情况下，我们返回0(丢弃数据包)。</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="501b" class="kd ke hh jz b fi kf kg l kh ki">#include &lt;linux/bpf.h&gt;<br/>#include &lt;linux/in.h&gt;<br/>#include &lt;linux/types.h&gt;<br/>#include &lt;linux/string.h&gt;<br/>#include &lt;linux/if_ether.h&gt;<br/>#include &lt;linux/if_packet.h&gt;<br/>#include &lt;linux/ip.h&gt;<br/>#include &lt;linux/tcp.h&gt;<br/>#include &lt;linux/udp.h&gt;<br/>#include "bpf_helpers.h"</span><span id="d388" class="kd ke hh jz b fi ly kg l kh ki">#ifndef offsetof<br/>#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)<br/>#endif</span><span id="a56c" class="kd ke hh jz b fi ly kg l kh ki">/*<br/> * We are only interested in TCP/UDP headers, so drop every other protocol<br/> * and trim packets after the TCP/UDP header by returning length of<br/> * ether header + IPv4 header + TCP/UDP header.<br/> */</span><span id="e740" class="kd ke hh jz b fi ly kg l kh ki">SEC("socket")<br/>int bpf_prog1(struct __sk_buff *skb)<br/>{<br/>        int proto = load_byte(skb, ETH_HLEN + offsetof(struct iphdr, protocol));<br/>        int size = ETH_HLEN + sizeof(struct iphdr);</span><span id="4d0a" class="kd ke hh jz b fi ly kg l kh ki">switch (proto) {<br/>        case IPPROTO_TCP:<br/>             size += sizeof(struct tcphdr);<br/>             break;<br/>        case IPPROTO_UDP:<br/>             size += sizeof(struct udphdr);<br/>             break;<br/>        default:<br/>             size = 0;<br/>             break;<br/>        }<br/>        return size;<br/>}</span><span id="aeca" class="kd ke hh jz b fi ly kg l kh ki">char _license[] SEC("license") = "GPL";</span></pre><p id="3e6f" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">通过指定“bpf”的arch，可以使用LLVM/clang将该程序编译成BPF字节码，一旦完成，它将包含一个带有称为“socket”的ELF部分的对象。这是我们的节目。下一步是使用BPF系统调用为程序分配一个文件描述符，然后将它附加到套接字上。在samples/bpf中，可以看到bpf_load.c扫描的是ELF部分，名称以“socket”为前缀的部分被识别为BPF_PROG_TYPE_SOCKET_FILTER程序。如果你要添加一个样本，我建议你加入bpf_load.h，这样你就可以在你的bpf程序中调用load_bpf_file()。例如，在samples/bpf/sockex1_user.c中，我们获取程序的文件名(sockex1)并加载sockex1 _ kern.o相关的BPF计划。然后，我们打开一个原始套接字到loopback (lo)并将程序附加到那里:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="6f8e" class="kd ke hh jz b fi kf kg l kh ki">snprintf(filename, sizeof(filename), "%s_kern.o", argv[0]);<br/>        if (load_bpf_file(filename)) {<br/>                printf("%s", bpf_log_buf);<br/>                return 1;<br/>        }<br/>        sock = open_raw_sock("lo");<br/>        assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, prog_fd,<br/>                          sizeof(prog_fd[0])) == 0);</span></pre><ul class=""><li id="2979" class="kj kk hh iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">我该拿它怎么办？附加一个BPF程序来捕捉套接字操作，如连接建立，重新传输超时等。一旦捕获选项也可以通过bpf_setsockopt()设置，例如，从不在同一子网上的系统被动建立连接时，我们可以降低MTU，这样我们就不必担心中间路由器分割数据包。程序可以返回成功(0)或失败(负值)，并且可以设置一个应答值来指示套接字选项的期望值(例如TCP rwnd)。参见<a class="ae jt" href="https://lwn.net/Articles/727189/" rel="noopener ugc nofollow" target="_blank">https://lwn.net/Articles/727189/</a>了解全部细节，并在include/net/tcp.h中查找tcp_call_bpf()的内联定义，以了解tcp如何处理此类程序的执行。另一个用例是与BPF_PROG_TYPE_SK_SKB程序结合使用的sockmap更新；传递到BPF_PROG_TYPE_SOCK_OPS程序中的bpf_sock_ops结构指针用于更新sockmap，为该套接字关联一个值。稍后的sk_skb程序可以引用这些值来指定通过bpf_sk_redirect_map()调用重定向到哪个套接字。如果这听起来令人困惑，我建议看看samples/sockmap中的代码。</li><li id="e670" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？它使用BPF组操作附加类型附加到组文件描述符。</li><li id="1789" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">提供了什么语境？提供的参数是上下文，struct bpf_sock_ops *..Op字段指定操作，BPF _袜子_OPS_RWND_INIT，BPF _袜子_OPS_TCP_CONNECT_CB等。回复字段可用于向呼叫者指示参数集的新值。</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="5e83" class="kd ke hh jz b fi kf kg l kh ki">/* User bpf_sock_ops struct to access socket values and specify request ops<br/> * and their replies.<br/> * Some of this fields are in network (bigendian) byte order and may need<br/> * to be converted before use (bpf_ntohl() defined in samples/bpf/bpf_endian.h).<br/> * New fields can only be added at the end of this structure<br/> */<br/>struct bpf_sock_ops {<br/>    __u32 op;<br/>    union {<br/>        __u32 reply;<br/>        __u32 replylong[4];<br/>    };<br/>    __u32 family;<br/>    __u32 remote_ip4;    /* Stored in network byte order */<br/>    __u32 local_ip4;    /* Stored in network byte order */<br/>    __u32 remote_ip6[4];    /* Stored in network byte order */<br/>    __u32 local_ip6[4];    /* Stored in network byte order */<br/>    __u32 remote_port;    /* Stored in network byte order */<br/>    __u32 local_port;    /* stored in host byte order */<br/>};</span></pre><ul class=""><li id="4b67" class="kj kk hh iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">它什么时候运行？根据上面的文章，与期望在代码库中的特定位置被调用的其他BPF程序类型不同，SOCK_OPS程序可以在不同的位置被调用，并使用“op”字段来指示该上下文。请参见include/uapi/linux/bpf.h，了解列举的BPF_SOCK_OPS_*定义，但它们包括像重新传输超时、连接建立等事件。</li></ul><h2 id="1616" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">1.3 BPF_PROG_TYPE_SK_SKB</h2><ul class=""><li id="fbb4" class="kj kk hh iz b ja lq jd lr jg lv jk lw jo lx js ko kp kq kr bi translated">我该拿它怎么办？允许用户访问skb和套接字详细信息，如端口和IP地址，以支持skb在套接字之间的重定向。参见<a class="ae jt" href="https://lwn.net/Articles/731133/" rel="noopener ugc nofollow" target="_blank">https://lwn.net/Articles/731133/</a>。此功能与sockmap结合使用，sock map是一种特殊用途的BPF地图，包含对套接字结构和相关值的引用。sockmaps用于支持重定向。程序被附加，bpf_sk_redirect_map()助手可用于执行重定向。一般方法是，我们用sock_ops BPF程序捕获套接字创建事件，将这些事件的值与sockmap相关联，然后使用sk_skb检测点的数据来通知套接字重定向——这称为裁决，该程序通过BPF _ SK _ SKB _流_裁决附加到sockmap。判断可以是__SK_DROP、__SK_PASS或__SK_REDIRECT。这种程序类型的另一个用例是在strparser框架中(<a class="ae jt" href="https://www.kernel.org/doc/Documentation/networking/strparser.txt" rel="noopener ugc nofollow" target="_blank">https://www . kernel . org/doc/Documentation/networking/strparser . txt</a>)。BPF程序可用于通过读操作、判断和读完成的回调来解析消息流。TLS和KCM使用流解析。</li><li id="64d8" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？重定向程序作为BPF _ SKB _流_判决附加到一个sockmap它应该返回bpf_sk_redirect_map()的结果。strparser程序通过BPF _ SK _ SKB _流_解析器连接，应该返回解析的数据长度。</li><li id="47ea" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">提供了什么语境？指向包含数据包元数据/数据的struct __sk_buff的指针。然而，sk_skb程序类型可以访问更多的字段。include/linux/bpf.h中记录了一组额外的可用字段，如下所示:</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="4b7f" class="kd ke hh jz b fi kf kg l kh ki">/* Accessed by BPF_PROG_TYPE_sk_skb types from here to ... */<br/>__u32 family;<br/>__u32 remote_ip4;   /* Stored in network byte order */<br/>__u32 local_ip4;    /* Stored in network byte order */<br/>__u32 remote_ip6[4];    /* Stored in network byte order */<br/>__u32 local_ip6[4]; /* Stored in network byte order */<br/>__u32 remote_port;  /* Stored in network byte order */<br/>__u32 local_port;   /* stored in host byte order */<br/>/* ... here. */</span></pre><p id="ab28" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">因此，从上面我们可以看到，我们可以收集关于套接字的信息，因为上面代表了唯一标识套接字的关键信息(协议已经在struct __sk_buff的全局可访问部分中可用)。</p><ul class=""><li id="d94f" class="kj kk hh iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">它什么时候运行？流解析器可以通过sockmap的BPF _ SKB _流解析器附件连接到套接字，解析器通过kernel/bpf/sockmap.c中的smap_parse_func_strparser()在套接字接收上运行。BPF_SK_SKB_STREAM_VERDICT也连接到sockmap，并通过smap_verdict_func()运行。</li></ul><h2 id="89ae" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">2.交通控制子系统程序</h2><p id="3f7e" class="pw-post-body-paragraph ix iy hh iz b ja lq ii jc jd lr il jf jg ls ji jj jk lt jm jn jo lu jq jr js ha bi translated">接下来让我们检查一下与TC内核包调度子系统相关的程序类型。有关一般介绍，请参见tc(8)联机帮助页，有关bpf的详细信息，请参见tc-bpf(8)。</p><h2 id="35ff" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">2.1 tc_cls_act : qdisc分类器</h2><ul class=""><li id="cd0d" class="kj kk hh iz b ja lq jd lr jg lv jk lw jo lx js ko kp kq kr bi translated">我该拿它怎么办？tc_cls_act允许我们使用BPF程序作为Linux QoS子系统tc中的分类器和动作。更好的是，tc(8)命令还支持eBPF，因此我们可以直接加载BPF程序作为入站(入口)和出站(出口)流量的分类器和操作。参见<a class="ae jt" href="http://man7.org/linux/man-pages/man8/tc-bpf.8.html" rel="noopener ugc nofollow" target="_blank">http://man7.org/linux/man-pages/man8/tc-bpf.8.html</a>了解如何使用tc的BPF功能。tc程序可以分类、修改、重定向或丢弃数据包。</li><li id="4d3d" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？可以使用TC(8)；详见tc-bpf(8)。基础是我们为网络设备创建一个“cls act”qdisc，并通过指定BPF对象和相关的ELF部分来添加入口和出口分类器/操作。例如，从myprog _ kernel . o(bpf-字节码编译的目标文件)向ELF节my_elf_sec中的eth0添加入口分类器:</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="fb49" class="kd ke hh jz b fi kf kg l kh ki"># tc qdisc add dev eth0 clsact<br/># tc filter add dev eth0 ingress bpf da obj myprog_kernel.o sec my_elf_sec</span></pre><ul class=""><li id="6a93" class="kj kk hh iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">提供了什么语境？指向struct __sk_buff数据包元数据/数据的指针。</li><li id="383b" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">它什么时候开始运行？如上所述，分类器qdisc必须添加，一旦它是我们可以附加BPF程序来分类入站和出站流量。在实现方面，act_bpf.c和cls_bpf.c实现动作/分类器模块。在ingress/gress sch _ handle _ ingress()/egress()上调用tcf_classify()。在入口的情况下，我们通过核心网络接口接收功能进行分类，因此我们在驱动程序处理数据包之后，但在IP等看到它之前获取数据包。在出口端，过滤在提交到设备队列进行传输之前完成。</li></ul><h2 id="36e0" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">3.xdp:Xpress数据路径</h2><p id="191e" class="pw-post-body-paragraph ix iy hh iz b ja lq ii jc jd lr il jf jg ls ji jj jk lt jm jn jo lu jq jr js ha bi translated">XDP的主要设计目标是在网络数据路径中引入可编程性。目的是提供尽可能靠近设备的XDP挂钩(在操作系统创建sk_buff元数据之前),以最大化性能，同时支持跨设备的公共基础设施。要像这样支持XDP，需要改变驱动程序。有关示例，请参见drivers/net/Ethernet/Broadcom/bnxt/bnxt _ xdp . c，添加了一个bpf网络设备op (ndo_bpf)。对于bnxt，它支持XDP _设置_程序和XDP _查询_程序操作；前者为XDP配置设备，保留振铃并将程序设置为活动。后者返回BPF程序id。如果需要，实际的发送/接收函数提供并调用特定于BPF的发送和接收函数。</p><h2 id="9c06" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">3.1 BPF_PROG_TYPE_XDP</h2><ul class=""><li id="cd52" class="kj kk hh iz b ja lq jd lr jg lv jk lw jo lx js ko kp kq kr bi translated">我该拿它怎么办？XDP允许在分配数据包元数据(struct sk_buff)之前尽早访问数据包数据。因此，这是一个进行DDoS缓解或负载平衡的有用地方，因为这样的活动通常可以避免sk_buff分配的昂贵开销。XDP通过BPF钩子支持内核的运行时编程，但是通过与内核本身协同工作；即不是内核旁路机制。支持的操作包括XDP _传递(照常传递到网络处理)、XDP _丢弃(丢弃)、XDP _发送(传输)和XDP _重定向。有关“enum xdp_action”，请参见include/uapi/linux/bpf.h。</li><li id="c9be" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？通过netlink套接字消息。创建并绑定一个netlink套接字socket(AF_NETLINK，SOCK_RAW，NETLINK_ROUTE)，然后我们发送一个NLA _ F _ NESTED | 43；类型的NETLINK消息。这指定了XDP消息。该消息包含BPF fd、接口索引(ifindex)。有关示例，请参见samples/bpf/bpf_load.c。</li><li id="555a" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">提供了什么语境？xdp元数据指针；结构xdp_md *。XDP元数据是故意轻量级的；来自include/uapi/linux/bpf.h:</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="2e3e" class="kd ke hh jz b fi kf kg l kh ki">/* user accessible metadata for XDP packet hook<br/> * new fields must be added to the end of this structure<br/> */<br/>struct xdp_md {<br/> __u32 data;<br/> __u32 data_end;<br/>};</span></pre><ul class=""><li id="eb52" class="kj kk hh iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">它什么时候开始运行？“真正的”XDP是在驱动程序级别实现的，发送/接收环资源被预留给XDP使用。对于驱动程序不支持XDP的情况，可以选择使用“通用”XDP，它在net/core/dev.c中实现。这样做的缺点是我们不能绕过skb分配，它只允许我们对这样的设备使用XDP。</li></ul><h2 id="5053" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">4.k探测器、跟踪点和性能事件</h2><p id="5d7b" class="pw-post-body-paragraph ix iy hh iz b ja lq ii jc jd lr il jf jg ls ji jj jk lt jm jn jo lu jq jr js ha bi translated">kprobes、tracepoints和perf事件都提供了内核工具。</p><p id="5dbc" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">kprobes—<a class="ae jt" href="https://www.kernel.org/doc/Documentation/kprobes.txt" rel="noopener ugc nofollow" target="_blank">https://www.kernel.org/doc/Documentation/kprobes.txt</a>—允许插装特定的函数—可以通过k probes监控函数的进入，以及函数中的大多数指令，或者可以通过kretprobe插装进入/返回。当这些探测器中的一个被启用时，启用点处的代码被保存，并用断点指令替换。当这个断点被命中时，一个trap指令被生成，寄存器被保存，我们转移到相关的检测处理程序。例如，kprobe由kprobe_dispatcher()处理，它获取kprobe和register上下文的地址作为参数。kretprobes通过kprobes实现；kprobe在进入时触发并修改返回地址，保存原始地址并用检测处理程序的位置替换它。</p><p id="d53b" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><strong class="iz hi">跟踪点</strong>—<a class="ae jt" href="https://www.kernel.org/doc/Documentation/trace/tracepoints.rst" rel="noopener ugc nofollow" target="_blank">https://www . kernel . org/doc/Documentation/trace/trace points . rst</a>—类似，但不同于在特定指令处被启用，它们在代码中的站点处被显式标记，并且如果被启用，可以用于收集那些感兴趣的站点处的调试信息。同一个跟踪点可以在多个地方声明；例如，在net/mac80211/driver-ops.c中的多个地方调用了trace_drv_return_int()。</p><p id="d8d1" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">性能事件—<a class="ae jt" href="https://perf.wiki.kernel.org/index.php/Main_Page" rel="noopener ugc nofollow" target="_blank">https://perf.wiki.kernel.org/index.php/Main_Page</a>——是eBPF支持这些程序类型的基础。BPF本质上是在现有的基础设施上进行事件采样，允许我们将程序附加到感兴趣的性能事件，包括kprobes、uprobes、tracepoints等，以及其他软件事件，实际上也可以监控硬件事件。</p><p id="3112" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">正是这些插装点赋予了BPF成为通用跟踪工具的能力，以及支持最初以网络为中心的用例(如套接字过滤)的手段。</p><h2 id="64c8" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">4.1 BPF _程序_类型_ k探针</h2><ul class=""><li id="ca23" class="kj kk hh iz b ja lq jd lr jg lv jk lw jo lx js ko kp kq kr bi translated">我该拿它怎么办？通过kprobe的任何内核函数(除了少数例外)中的工具代码，或者通过kretprobe的工具进入/返回。k[ret]probe_perf_func()执行一个附加到探测点的BPF程序。请注意，该程序类型也可用于附加到u[ret]探测器——详情请参见<a class="ae jt" href="https://www.kernel.org/doc/Documentation/trace/uprobetracer.txt" rel="noopener ugc nofollow" target="_blank">https://www . kernel . org/doc/Documentation/trace/uprobetracer . txt</a></li><li id="251e" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？当kprobe通过sysfs创建时，它有一个与之关联的id，存储在/sys/kernel/debug/tracing/events/[uk]probe//id，/sys/kernel/debug/tracing/events/[uk]ret probe/probe name/id中。<a class="ae jt" href="https://www.kernel.org/doc/Documentation/trace/kprobetrace.txt" rel="noopener ugc nofollow" target="_blank">https://www . kernel . org/doc/Documentation/trace/kprobetrace . txt</a>包含如何使用sysfs创建kprobe的详细信息。例如，要在TCP _ return _ skb()的入口创建一个名为“myprobe”的探测器并检索其id:</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="40c4" class="kd ke hh jz b fi kf kg l kh ki"># echo 'p:myprobe tcp_retransmit_skb' &gt; /sys/kernel/debug/tracing/kprobe_events<br/># cat /sys/kernel/debug/tracing/events/kprobes/myprobe/id<br/>2266</span></pre><p id="28a2" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我们可以使用该探测器id打开一个性能事件，启用它，并将该性能事件的BPF程序设置为我们的程序。请参阅load_and_attach()函数中的samples/bpf/bpf_load.c，了解如何对k[ret]探测器执行此操作。代码可能看起来像这样:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="3440" class="kd ke hh jz b fi kf kg l kh ki">struct perf_event_attr attr;<br/>int eventfd, programfd;<br/>int probeid;</span><span id="3150" class="kd ke hh jz b fi ly kg l kh ki">/* Load BPF program and assign programfd to it; and get probeid of probe from sysfs */<br/>attr.type = PERF_TYPE_TRACEPOINT;<br/>attr.sample_type = PERF_SAMPLE_RAW;<br/>attr.sample_period = 1;<br/>attr.wakeup_events = 1;<br/>attr.config = probeid;<br/>eventfd = sys_perf_event_open(&amp;attr, -1, 0, programfd, 0);<br/>if (eventfd &lt; 0)<br/>        return -errno;<br/>if (ioctl(eventfd, PERF_EVENT_IOC_ENABLE, 0)) {<br/>        close(eventfd);<br/>        return -errno;<br/>}<br/>if (ioctl(eventfd, PERF_EVENT_IOC_SET_BPF, programfd)) {<br/>        close(eventfd);<br/>        return -errno;<br/>}</span></pre><ul class=""><li id="53bc" class="kj kk hh iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">提供了什么语境？一个结构pt_regs *ctx，可以通过它访问寄存器。其中大部分是特定于平台的，但也存在一些通用函数，如regs_return_value(regs)，它返回寄存器的值，而不是保存函数返回值(x86上的regs→ax)。</li><li id="ef1c" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">它什么时候开始运行？当探测器被启用并且命中断点时，k[ret]probe_perf_func()执行一个通过trace_call_bpf()附加到探测点的BPF程序。u[ret]probe_perf_func()的情况类似。</li></ul><h2 id="2d7e" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">4.2 BPF _程序_类型_跟踪点</h2><ul class=""><li id="6814" class="kj kk hh iz b ja lq jd lr jg lv jk lw jo lx js ko kp kq kr bi translated">我该拿它怎么办？内核代码中的工具跟踪点。跟踪点可以像kprobes一样通过sysfs以类似的方式启用。可以在/sys/kernel/debug/tracing/events下看到跟踪事件的列表。</li><li id="dc06" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？正如我们在上面看到的，当跟踪点通过sysfs创建时，它有一个与之相关联的id。我们可以使用该探测器id打开一个性能事件，启用它，并将该性能事件的BPF程序设置为我们的程序。有关如何对跟踪点执行此操作的信息，请参见load_and_attach()函数中的samples/bpf/bpf _ load . c；上面的kprobes代码片段也适用于跟踪点。作为显示如何启用跟踪点的示例，我们在这里将net/net_dev_xmit跟踪点启用为“myprobe2 ”,并检索其id:</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="1e71" class="kd ke hh jz b fi kf kg l kh ki"># echo ‘p:myprobe2 trace:net/net_dev_xmit’ &gt; /sys/kernel/debug/tracing/kprobe_events<br/># cat /sys/kernel/debug/tracing/events/kprobes/myprobe2/id<br/>2270</span></pre><ul class=""><li id="1e55" class="kj kk hh iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">提供了什么语境？特定跟踪点提供的上下文；参数和数据类型与跟踪点定义相关联。</li><li id="26f5" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">它什么时候开始运行？当启用并命中跟踪点时，perf_trace_()(参见include/trace/perf.h中的定义)调用perf_trace_run_bpf_submit()，该函数将通过trace_call_bpf()调用bpf程序。</li></ul><h2 id="58eb" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">4.3 BPF _程序_类型_ PROG _事件</h2><ul class=""><li id="2b3b" class="kj kk hh iz b ja lq jd lr jg lv jk lw jo lx js ko kp kq kr bi translated">我该拿它怎么办？仪器软件和硬件性能事件。这些事件包括系统调用、定时器到期、硬件事件采样等。硬件事件包括PMU事件(处理器监控单元),它告诉我们完成了多少条指令等。性能事件监视可以针对特定的进程或组、处理器，并且可以为分析指定一个采样周期。</li><li id="14fb" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？与上述相似的模型；我们用属性集调用perf_event_open()，通过PERF_EVENT_IOC_ENABLE ioctl()启用perf事件，通过PERF_EVENT_IOC_SET_BPF ioctl()设置bpf程序。有关PMU(处理器监控单元)性能事件示例，请参见samples/bpf/sampleip_user.c中的这些片段:</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="7bbf" class="kd ke hh jz b fi kf kg l kh ki">...<br/>struct perf_event_attr pe_sample_attr = {<br/>        .type = PERF_TYPE_SOFTWARE,<br/>        .freq = 1,<br/>        .sample_period = freq,<br/>        .config = PERF_COUNT_SW_CPU_CLOCK,<br/>        .inherit = 1,<br/>};<br/>        ...<br/>pmu_fd[i] = sys_perf_event_open(&amp;pe_sample_attr, -1 /* pid */, i,<br/>                                -1 /* group_fd */, 0 /* flags */);<br/>if (pmu_fd[i] &lt; 0) {<br/>        fprintf(stderr, "ERROR: Initializing perf sampling\n");<br/>        return 1;<br/>}</span><span id="14b3" class="kd ke hh jz b fi ly kg l kh ki">assert(ioctl(pmu_fd[i], PERF_EVENT_IOC_SET_BPF,<br/>             prog_fd[0]) == 0);<br/>assert(ioctl(pmu_fd[i], PERF_EVENT_IOC_ENABLE, 0) == 0);<br/>...</span></pre><ul class=""><li id="847b" class="kj kk hh iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">它什么时候开始运行？取决于性能事件触发和选择的采样速率，由性能事件属性结构中的freq和sample_period字段指定。</li></ul><h2 id="fa41" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">5.与cgroups相关的程序类型</h2><p id="9e1b" class="pw-post-body-paragraph ix iy hh iz b ja lq ii jc jd lr il jf jg ls ji jj jk lt jm jn jo lu jq jr js ha bi translated">CGroups用于处理资源分配，允许或拒绝进程组访问系统资源，如CPU、网络带宽等。cgroups的一个关键用例是容器；容器的资源访问是通过cgroups来限制的，而它的活动是通过不同类别的名称空间(网络名称空间、进程ID名称空间等)来隔离的。在BPF的环境中，我们可以创建允许或拒绝访问的e BPF程序。在include/linux/bpf-cgroup.h中，我们可以看到执行socket/skb程序的定义，其中__cgroup_bpf_run_filter_skb被调用，并被包装在检查cgroup BPF是否已启用中:</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="130e" class="kd ke hh jz b fi kf kg l kh ki">#define BPF_CGROUP_RUN_PROG_INET_INGRESS(sk, skb)                  \<br/>({                                                                 \<br/>    int __ret = 0;                                                 \<br/>    if (cgroup_bpf_enabled)                                        \<br/>        __ret = __cgroup_bpf_run_filter_skb(sk, skb,               \<br/>                            BPF_CGROUP_INET_INGRESS);              \<br/>                                                                   \<br/>    __ret;                                                         \<br/>})</span><span id="2482" class="kd ke hh jz b fi ly kg l kh ki">#define BPF_CGROUP_RUN_SK_PROG(sk, type)                           \<br/>({                                                                 \<br/>    int __ret = 0;                                                 \<br/>    if (cgroup_bpf_enabled) {                                      \<br/>        __ret = __cgroup_bpf_run_filter_sk(sk, type);              \<br/>    }                                                              \<br/>    __ret;                                                         \<br/>})</span></pre><p id="2b4d" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如果启用了cgroups，我们将我们的程序附加到cgroup，它将在相关的钩子点执行。要了解钩子的完整列表，请参考include/uapi/linux/bpf.h，并检查BPF_CGROUP_*定义的枚举类型“bpf_attach_type”。</p><h2 id="5f5d" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">5.1 BPF _程序_类型_群组_SKB</h2><ul class=""><li id="0746" class="kj kk hh iz b ja lq jd lr jg lv jk lw jo lx js ko kp kq kr bi translated">我该拿它怎么办？允许或拒绝IP出口/入口(BPF _群组_网络_入口/BPF _群组_网络_出口)上的网络访问。BPF程序应该返回1以允许访问。任何其他值都会导致函数__cgroup_bpf_run_filter_skb()返回-EPERM，这将传播到调用者，从而丢弃数据包。</li><li id="7289" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？程序被附加到一个特定的cgroup的文件描述符上。</li><li id="f61d" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">提供了什么语境？相关的skb。</li><li id="4a57" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">它什么时候开始运行？对于inet ingress，sk_filter_trim_cap()(见上)包含对BPF _ CGROUP _ RUN _ PROG _ INET _ INGRESS(sk，skb)的调用；如果返回非零值，则将错误传播给调用者(例如__sk_receive_skb())，并丢弃和释放数据包。在egress上采取了类似的方法，但是在ip[6]_finish_output()中。</li></ul><h2 id="3083" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">5.2 BPF _程序_类型_群组_袜子</h2><ul class=""><li id="c4cd" class="kj kk hh iz b ja lq jd lr jg lv jk lw jo lx js ko kp kq kr bi translated">我该拿它怎么办？在各种与套接字相关的事件中允许或拒绝网络访问(BPF_CGROUP_INET_SOCK_CREATE，BPF_CGROUP_SOCK_OPS)。如上所述，BPF程序应该返回1以允许访问。任何其他值都会导致函数__cgroup_bpf_run_filter_sk()返回-EPERM，这将传播到调用者，从而丢弃数据包。</li><li id="fac1" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？程序被附加到一个特定的cgroup的文件描述符上。</li><li id="5582" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">提供了什么语境？相关插座(sk)。</li><li id="f6d7" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">它什么时候开始运行？在套接字创建时，在inet_create()中，我们用套接字作为参数调用BPF_CGROUP_RUN_PROG_INET_SOCK()，如果该函数失败，套接字将被释放。</li></ul><h2 id="8ba6" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">6.轻量级隧道程序类型。</h2><p id="6a9c" class="pw-post-body-paragraph ix iy hh iz b ja lq ii jc jd lr il jf jg ls ji jj jk lt jm jn jo lu jq jr js ha bi translated">轻量级隧道<a class="ae jt" href="https://lwn.net/Articles/650778/" rel="noopener ugc nofollow" target="_blank">https://lwn.net/Articles/650778/</a>是一种通过将封装指令附加到路由上来实现隧道的简单方法。补丁描述中的例子让事情更清楚:iproute示例(不含BPF):</p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="8068" class="kd ke hh jz b fi kf kg l kh ki">VXLAN:<br/>  ip route add 40.1.1.1/32 encap vxlan id 10 dst 50.1.1.2 dev vxlan0</span><span id="e940" class="kd ke hh jz b fi ly kg l kh ki">MPLS:<br/>  ip route add 10.1.1.0/30 encap mpls 200 via inet 10.1.1.1 dev swp1</span></pre><p id="a07f" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">例如，我们告诉Linux，对于发往40.1.1.1/32地址的流量，我们希望使用VXLAN ID 10和目的IPv4地址50.1.1.2进行封装。BPF程序可以在出站/传输时进行封装(入站数据包是只读的)。详见https://lwn.net/Articles/705609/的<a class="ae jt" href="https://lwn.net/Articles/705609/" rel="noopener ugc nofollow" target="_blank">。与tc类似，iproute eBPF支持允许我们直接附加eBPF程序ELF部分:</a></p><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="81cb" class="kd ke hh jz b fi kf kg l kh ki">ip route add 192.168.253.2/32 \<br/>     encap bpf out obj lwt_len_hist_kern.o section len_hist \<br/>     dev veth0</span></pre><h2 id="5079" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">6.1 BPF_PROG_TYPE_LWT_IN</h2><ul class=""><li id="5f2e" class="kj kk hh iz b ja lq jd lr jg lv jk lw jo lx js ko kp kq kr bi translated">我该拿它怎么办？检查入站数据包的轻量级隧道解封装。</li><li id="dbe6" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？通过“ip路由添加”。</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="ed5b" class="kd ke hh jz b fi kf kg l kh ki"># ip route add &lt;route+prefix&gt; encap bpf in obj &lt;bpf object file.o&gt; section &lt;ELF section&gt; dev &lt;device&gt;</span></pre><ul class=""><li id="425d" class="kj kk hh iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">提供了什么语境？指向sk_buff的指针。</li><li id="5d5c" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">它什么时候开始运行？via lw tunnel _ input()；该函数支持多种封装类型，包括BPF。BPF案例在net/core/lwt_bpf.c中运行bpf_input，不允许重定向。</li></ul><h2 id="fb7c" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">6.2 BPF_PROG_TYPE_LWT_OUT</h2><ul class=""><li id="93db" class="kj kk hh iz b ja lq jd lr jg lv jk lw jo lx js ko kp kq kr bi translated">我该拿它怎么办？为出站的特定目的地路由实现轻量级隧道封装。禁止封装</li><li id="dc2d" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？通过“ip路由添加”:</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="3f44" class="kd ke hh jz b fi kf kg l kh ki"># ip route add &lt;route+prefix&gt; encap bpf out obj &lt;bpf object file.o&gt; section &lt;ELF section&gt; dev &lt;device&gt;</span></pre><ul class=""><li id="e578" class="kj kk hh iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">提供了什么语境？指向结构__sk_buff的指针</li><li id="6001" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">它什么时候开始运行？通过lwtunnel_output()。</li></ul><h2 id="f04e" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">6.3 BPF _程序_类型_LWT_XMIT</h2><ul class=""><li id="703f" class="kj kk hh iz b ja lq jd lr jg lv jk lw jo lx js ko kp kq kr bi translated">我该拿它怎么办？在传输时为轻量级隧道实现封装/重定向。</li><li id="4d64" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">我如何附加我的程序？通过“ip路由添加”</li></ul><pre class="ju jv jw jx fd jy jz ka kb aw kc bi"><span id="b140" class="kd ke hh jz b fi kf kg l kh ki"># ip route add &lt;route+prefix&gt; encap bpf xmit obj &lt;bpf object file.o&gt; section &lt;ELF section&gt; dev &lt;device&gt;</span></pre><ul class=""><li id="4d4e" class="kj kk hh iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated">提供了什么语境？指向结构__sk_buff的指针</li><li id="a3ac" class="kj kk hh iz b ja ks jd kt jg ku jk kv jo kw js ko kp kq kr bi translated">它什么时候开始运行？通过lwtunnel_xmit()。</li></ul><h2 id="096c" class="kd ke hh bd kx ky kz la lb lc ld le lf jg lg lh li jk lj lk ll jo lm ln lo lp bi translated">摘要</h2><p id="52e8" class="pw-post-body-paragraph ix iy hh iz b ja lq ii jc jd lr il jf jg ls ji jj jk lt jm jn jo lu jq jr js ha bi translated">希望这个程序类型的总结是有用的。您已经看到了BPF安全的内核可编程环境可以以各种有趣的方式使用！在下一期文章中，我将讲述在各种程序类型中有哪些<a class="ae jt" href="http://blogs.oracle.com/linux/notes-on-bpf-2" rel="noopener ugc nofollow" target="_blank"> BPF助手函数可用。</a></p><p id="0de5" class="pw-post-body-paragraph ix iy hh iz b ja jb ii jc jd je il jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated"><em class="lz">本帖原载于blogs.oracle.com/linuxkernel</em><a class="ae jt" href="https://blogs.oracle.com/linux/notes-on-bpf-1" rel="noopener ugc nofollow" target="_blank"><em class="lz"/></a><em class="lz">…</em></p></div></div>    
</body>
</html>