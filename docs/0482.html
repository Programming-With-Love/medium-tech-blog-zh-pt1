<html>
<head>
<title>Concatenate adapters sequentially with ConcatAdapter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用ConcatAdapter按顺序连接适配器</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/merge-adapters-sequentially-with-mergeadapter-294d2942127a?source=collection_archive---------0-----------------------#2020-04-02">https://medium.com/androiddevelopers/merge-adapters-sequentially-with-mergeadapter-294d2942127a?source=collection_archive---------0-----------------------#2020-04-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/0c578e010a4ec9aced8cfa43c6c554aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWQqtcW9WJaGcOv-kRtkSA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/vpoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="d6fc" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">用例示例:显示列表页眉和页脚</h2></div><p id="4975" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/ConcatAdapter" rel="noopener ugc nofollow" target="_blank">ConcatAdapter</a></code>是<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/recyclerview" rel="noopener ugc nofollow" target="_blank">recyclerview:1.2.0-alpha02</a></code>中的一个新类，它可以让你连续组合多个<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter" rel="noopener ugc nofollow" target="_blank">adapters</a></code>显示在一个<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView" rel="noopener ugc nofollow" target="_blank">RecyclerView</a></code>中。这使您能够更好地封装适配器，而不是将许多数据源组合到一个适配器中，从而保持它们的集中性和可重用性。</p><p id="0d9e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这方面的一个用例是在页眉或页脚中显示列表加载状态:当列表从网络检索数据时，我们希望显示一个进度微调器；如果出现错误，我们希望显示错误和一个重试按钮。</p><figure class="kn ko kp kq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es km"><img src="../Images/b86fc13d888bff898a871776b25108c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQA9GWiXVbjI5VR9y3Co1Q.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">A RecyclerView with a footer displaying the loading state: progress or error</figcaption></figure><h1 id="c245" class="kr ks hx bd kt ku kv kw kx ky kz la lb jd lc je ld jg le jh lf jj lg jk lh li bi translated">介绍Concat <code class="du ki kj kk kl b">Adapter</code></h1><p id="a2b8" class="pw-post-body-paragraph jm jn hx jo b jp lj iy jr js lk jb ju jv ll jx jy jz lm kb kc kd ln kf kg kh ha bi translated"><code class="du ki kj kk kl b">ConcatAdapter</code>允许我们按顺序显示多个适配器的内容。例如，假设我们有以下3个适配器:</p><pre class="kn ko kp kq fd lo kl lp lq aw lr bi"><span id="c2cb" class="ls ks hx kl b fi lt lu l lv lw">val firstAdapter: FirstAdapter = …<br/>val secondAdapter: SecondAdapter = …<br/>val thirdAdapter: ThirdAdapter = …</span><span id="0480" class="ls ks hx kl b fi lx lu l lv lw">val concatAdapter = ConcatAdapter(firstAdapter, secondAdapter, <br/>     thirdAdapter)</span><span id="99d7" class="ls ks hx kl b fi lx lu l lv lw">recyclerView.adapter = concatAdapter</span></pre><p id="94f2" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><code class="du ki kj kk kl b">recyclerView</code>将依次显示来自每个适配器的项目。</p><p id="14f4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">拥有不同的适配器允许您更好地分离列表中每个连续部分的关注点。例如，如果您想要显示一个标题，您不需要将与标题显示相关的逻辑放在处理列表显示的同一个适配器中，而是可以将它封装在它自己的适配器中。</p><figure class="kn ko kp kq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ly"><img src="../Images/edc5cd949cfea65370b75011ae18c324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dVXw_ylmIfbVvZkQ"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">RecyclerView and Adapter data</figcaption></figure><h1 id="3175" class="kr ks hx bd kt ku kv kw kx ky kz la lb jd lc je ld jg le jh lf jj lg jk lh li bi translated">在页眉和页脚中显示加载状态</h1><p id="32d2" class="pw-post-body-paragraph jm jn hx jo b jp lj iy jr js lk jb ju jv ll jx jy jz lm kb kc kd ln kf kg kh ha bi translated">我们的页眉/页脚要么显示进度指示器，要么报告错误。当列表成功完成加载时，页眉/页脚不应该显示任何内容。因此，它们可以被表示为具有0或1个项目的列表，并且具有它们自己的适配器:</p><pre class="kn ko kp kq fd lo kl lp lq aw lr bi"><span id="aa16" class="ls ks hx kl b fi lt lu l lv lw">val concatAdapter = ConcatAdapter(headerAdapter, listAdapter, <br/>    footerAdapter)</span><span id="edc1" class="ls ks hx kl b fi lx lu l lv lw">recyclerView.adapter = concatAdapter</span></pre><p id="1408" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果页眉和页脚使用相同的布局、<code class="du ki kj kk kl b">ViewHolder</code>和UI逻辑(例如，何时显示进度以及如何显示)，你可以只实现一个<code class="du ki kj kk kl b">Adapter</code>类并创建它的两个实例:一个用于页眉，一个用于页脚。</p><p id="eff4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">要获得完整的实现，请查看这个<a class="ae hu" href="https://github.com/googlecodelabs/android-paging/pull/46/files" rel="noopener ugc nofollow" target="_blank">拉请求</a>，它增加了:</p><ul class=""><li id="cf11" class="lz ma hx jo b jp jq js jt jv mb jz mc kd md kh me mf mg mh bi translated">一个<code class="du ki kj kk kl b"><a class="ae hu" href="https://github.com/googlecodelabs/android-paging/blob/step1_mergeadapter/app/src/main/java/com/example/android/codelabs/paging/ui/LoadState.kt" rel="noopener ugc nofollow" target="_blank">LoadState</a></code>，从<code class="du ki kj kk kl b"><a class="ae hu" href="https://github.com/googlecodelabs/android-paging/blob/step1_mergeadapter/app/src/main/java/com/example/android/codelabs/paging/ui/SearchRepositoriesViewModel.kt" rel="noopener ugc nofollow" target="_blank">ViewModel</a></code>中暴露出来</li><li id="3308" class="lz ma hx jo b jp mi js mj jv mk jz ml kd mm kh me mf mg mh bi translated">加载状态页眉和页脚布局</li><li id="5882" class="lz ma hx jo b jp mi js mj jv mk jz ml kd mm kh me mf mg mh bi translated">一个用于页眉和页脚的<code class="du ki kj kk kl b"><a class="ae hu" href="https://github.com/googlecodelabs/android-paging/blob/step1_mergeadapter/app/src/main/java/com/example/android/codelabs/paging/ui/ReposLoadStateViewHolder.kt" rel="noopener ugc nofollow" target="_blank">ViewHolder</a></code>对象</li><li id="d477" class="lz ma hx jo b jp mi js mj jv mk jz ml kd mm kh me mf mg mh bi translated">根据<code class="du ki kj kk kl b">LoadState</code>显示0或1项的<code class="du ki kj kk kl b"><a class="ae hu" href="https://github.com/googlecodelabs/android-paging/blob/step1_mergeadapter/app/src/main/java/com/example/android/codelabs/paging/ui/ReposLoadStateAdapter.kt" rel="noopener ugc nofollow" target="_blank">ListAdapter</a></code>。每次<code class="du ki kj kk kl b">LoadState</code>改变时，我们通知该项目需要改变、插入或移除(见<a class="ae hu" href="https://github.com/googlecodelabs/android-paging/blob/step1_mergeadapter/app/src/main/java/com/example/android/codelabs/paging/ui/ReposLoadStateAdapter.kt#L30" rel="noopener ugc nofollow" target="_blank">代码</a>)。</li></ul><h1 id="e076" class="kr ks hx bd kt ku kv kw kx ky kz la lb jd lc je ld jg le jh lf jj lg jk lh li bi translated">🔎关于ConcatAdapter的更多信息</h1><h2 id="d613" class="ls ks hx bd kt mn mo mp kx mq mr ms lb jv mt mu ld jz mv mw lf kd mx my lh mz bi translated">观众</h2><p id="2f93" class="pw-post-body-paragraph jm jn hx jo b jp lj iy jr js lk jb ju jv ll jx jy jz lm kb kc kd ln kf kg kh ha bi translated">默认情况下，每个适配器维护自己的<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder" rel="noopener ugc nofollow" target="_blank">ViewHolder</a></code>池，适配器之间没有重用。如果多个适配器显示相同的<code class="du ki kj kk kl b">ViewHolder</code>，我们可能希望在它们之间重用实例。我们可以通过用一个<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/ConcatAdapter.Config" rel="noopener ugc nofollow" target="_blank">ConcatAdapter.Config</a></code>对象构造我们的<code class="du ki kj kk kl b">ConcatAdapter</code>来实现这一点，其中<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/ConcatAdapter.Config#isolateViewTypes" rel="noopener ugc nofollow" target="_blank">isolateViewTypes</a> = false</code>。像这样，所有合并的适配器将使用相同的视图池。在加载状态页眉和页脚示例中，两个<code class="du ki kj kk kl b">ViewHolders</code>实际上将显示相同的内容，因此我们可以重用它们。</p><p id="ca1b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">⚠️要支持不同的<code class="du ki kj kk kl b">ViewHolder</code>类型，就应该实现<code class="du ki kj kk kl b">Adapter.<a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter#getItemViewType(int)" rel="noopener ugc nofollow" target="_blank">getItemViewType</a></code>。当你重用<code class="du ki kj kk kl b">ViewHolders</code>时，确保相同的视图类型不会指向不同的<code class="du ki kj kk kl b">ViewHolders</code>！这方面的一个最佳实践是返回布局ID作为视图类型。</p><figure class="kn ko kp kq fd hj"><div class="bz dy l di"><div class="na nb l"/></div></figure><h2 id="3af9" class="ls ks hx bd kt mn mo mp kx mq mr ms lb jv mt mu ld jz mv mw lf kd mx my lh mz bi translated">使用稳定的id</h2><p id="ae70" class="pw-post-body-paragraph jm jn hx jo b jp lj iy jr js lk jb ju jv ll jx jy jz lm kb kc kd ln kf kg kh ha bi translated">不要将稳定的id与<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter#notifyDataSetChanged()" rel="noopener ugc nofollow" target="_blank">notifyDataSetChanged</a></code>一起使用，建议使用适配器的特定notify事件，这些事件给<code class="du ki kj kk kl b">RecyclerView</code>更多关于数据集中变化的信息。这使得<code class="du ki kj kk kl b">RecyclerView</code>可以更有效地更新UI，并有更好的动画效果。如果您使用的是<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/android/widget/ListAdapter" rel="noopener ugc nofollow" target="_blank">ListAdapter</a></code>，那么在<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil" rel="noopener ugc nofollow" target="_blank">DiffUtil</a></code>回调的帮助下，通知事件会在幕后为您处理。但是如果你确实需要使用稳定id，<code class="du ki kj kk kl b">ConcatAdapter.Config</code>为稳定id提供了3种不同的配置:<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/ConcatAdapter.Config.StableIdMode#NO_STABLE_IDS" rel="noopener ugc nofollow" target="_blank">NO_STABLE_IDS</a></code>、<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/ConcatAdapter.Config.StableIdMode#ISOLATED_STABLE_IDS" rel="noopener ugc nofollow" target="_blank">ISOLATED_STABLE_IDS</a></code>和<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/ConcatAdapter.Config.StableIdMode#SHARED_STABLE_IDS" rel="noopener ugc nofollow" target="_blank">SHARED_STABLE_IDS</a></code>。最后两个要求您在适配器中处理稳定的id。查看<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/ConcatAdapter.Config.StableIdMode" rel="noopener ugc nofollow" target="_blank">StableIdMode</a></code>文档，了解它们如何工作的更多信息。</p><h2 id="7ed5" class="ls ks hx bd kt mn mo mp kx mq mr ms lb jv mt mu ld jz mv mw lf kd mx my lh mz bi translated">数据更改通知</h2><p id="5092" class="pw-post-body-paragraph jm jn hx jo b jp lj iy jr js lk jb ju jv ll jx jy jz lm kb kc kd ln kf kg kh ha bi translated">当<code class="du ki kj kk kl b">ConcatAdapter</code>的适配器部分调用一个通知函数时，<code class="du ki kj kk kl b">ConcatAdapter</code>在更新<code class="du ki kj kk kl b">RecyclerView</code>之前计算新的项目位置。</p><p id="77cf" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">从<code class="du ki kj kk kl b">RecyclerView</code>的角度来看，<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter#notifyItemRangeChanged(int,%20int)" rel="noopener ugc nofollow" target="_blank">notifyItemRangeChanged</a></code>的意思是物品是一样的，只是内容变了。<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter#notifyDataSetChanged()" rel="noopener ugc nofollow" target="_blank">notifyDataSetChanged</a></code>表示前后没有关系。因此，我们不能将<code class="du ki kj kk kl b">notifyDataSetChanged</code>映射到<code class="du ki kj kk kl b">notifyItemRangeChanged</code>。</p><p id="3c38" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果一个适配器调用<code class="du ki kj kk kl b">Adapter.notifyDataSetChanged</code>，那么<code class="du ki kj kk kl b">ConcatAdapter</code>也会调用<code class="du ki kj kk kl b">Adapter.notifyDataSetChanged</code>，而不是<code class="du ki kj kk kl b">Adapter.notifyItemRangeChanged</code>。像往常一样，使用<code class="du ki kj kk kl b">RecyclerViews</code>避免调用<code class="du ki kj kk kl b">Adapter.notifyDataSetChanged()</code>，更喜欢更细粒度的更新，或者使用自动完成此任务的<code class="du ki kj kk kl b">Adapter</code>实现，如<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/recyclerview/widget/ListAdapter" rel="noopener ugc nofollow" target="_blank">ListAdapter</a></code>或<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/SortedList" rel="noopener ugc nofollow" target="_blank">SortedList</a></code>。</p><h2 id="2942" class="ls ks hx bd kt mn mo mp kx mq mr ms lb jv mt mu ld jz mv mw lf kd mx my lh mz bi translated">寻找取景框位置</h2><p id="8fb1" class="pw-post-body-paragraph jm jn hx jo b jp lj iy jr js lk jb ju jv ll jx jy jz lm kb kc kd ln kf kg kh ha bi translated">您过去可能使用过<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder#getAdapterPosition()" rel="noopener ugc nofollow" target="_blank">ViewHolder.getAdapterPosition</a></code>来获得适配器中<code class="du ki kj kk kl b">ViewHolder</code>的位置。现在，因为我们正在合并多个适配器，所以使用<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder#getBindingAdapterPosition()" rel="noopener ugc nofollow" target="_blank">ViewHolder.getBindingAdapterPosition()</a></code>。如果你想得到最后绑定一个<code class="du ki kj kk kl b">ViewHolder</code>的适配器，在你共享<code class="du ki kj kk kl b">ViewHolders</code>的情况下，使用<code class="du ki kj kk kl b"><a class="ae hu" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder#getBindingAdapter()" rel="noopener ugc nofollow" target="_blank">ViewHolder.getBindingAdapter()</a></code>。</p></div><div class="ab cl nc nd go ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ha hb hc hd he"><p id="52e6" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">仅此而已！如果您想要顺序显示不同类型的数据，这些数据将受益于封装在它们自己的适配器中，那么开始使用<code class="du ki kj kk kl b">ConcatAdapter</code>。对于<code class="du ki kj kk kl b">ViewHolder</code>池和稳定ids的高级控制，使用<code class="du ki kj kk kl b">ConcatAdapter.Config</code>。</p></div></div>    
</body>
</html>