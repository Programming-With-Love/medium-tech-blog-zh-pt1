<html>
<head>
<title>Java: On The Benefits of Treating DTOs as Magic Cookies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java:将dto视为神奇饼干的好处</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/java-on-the-benefits-of-treating-dtos-as-magic-cookies-fd7d2e0207a5?source=collection_archive---------3-----------------------#2018-08-31">https://medium.com/walmartglobaltech/java-on-the-benefits-of-treating-dtos-as-magic-cookies-fd7d2e0207a5?source=collection_archive---------3-----------------------#2018-08-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="94e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对复杂数据处理和健壮Java应用程序开发的研究。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/ed4db8565eb2b2cb53c4dc1364a5bb23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGZnikD9VSBAlClaTJ9LvA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">My View</figcaption></figure><p id="b77e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae js" href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="noopener ugc nofollow" target="_blank">数据传输对象</a>(dto)没什么神奇的；在最纯粹的Java语言形式中，它们包含一组类型化的数据字段，除了聚合之外没有任何责任。作为JavaBeans 的最简单形式，DTO方法由它们的字段的getters和setters组成，可能还有定制的<code class="du jt ju jv jw b"><a class="ae js" href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#equals-java.lang.Object-" rel="noopener ugc nofollow" target="_blank">equals</a></code>、<code class="du jt ju jv jw b"><a class="ae js" href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#hashCode--" rel="noopener ugc nofollow" target="_blank">hashCode</a></code>和<code class="du jt ju jv jw b"><a class="ae js" href="https://docs.oracle.com/javase/9/docs/api/java/lang/Object.html#toString--" rel="noopener ugc nofollow" target="_blank">toString</a></code>实现。</p><p id="b4a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用计算机科学的术语来说，魔法cookies比dto更简单:魔法cookies是不透明的数据块，没有字段，没有getters和setters。虽然在一种情况下几乎没有意义，但在另一种情况下它们可能很有意义。因此，魔法饼干是一种人格分裂的DTO:在这里没有意义，在其他地方有很多意义。</p><h1 id="4724" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">问题陈述</h1><p id="1a9c" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">在分布式应用程序体系结构中，dto在应用层之间传送信息。由于这些层之间的每个单独通信的资源成本很高(例如，延迟、带宽)，因此生成的dto通常包含大量表示复杂信息模型的数据。这些模型在结构上可能是高度分层的，也称为“深度”:例如，包含一个或多个<em class="la">事物的<em class="la">集合</em>和包含更多事物的其他事物的</em>列表等等。</p><p id="1f7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决情境化的业务查询(例如，该产品是否可在线交易？)可能需要遍历这些DTO层次结构的许多层。并且，给定基于时间的事务的性质，在那些遍历的每个阶段，层级中的下一级可能整体或部分不完整。当在Java中工作时，如果不仔细编程，这些遍历会导致运行时异常；例如一个<code class="du jt ju jv jw b"><a class="ae js" href="https://docs.oracle.com/javase/9/docs/api/java/lang/NullPointerException.html" rel="noopener ugc nofollow" target="_blank">NullPointerException</a></code>。</p><p id="d269" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">单元测试是最小化应用程序实现风险的策略；这些测试需要输入数据，这些数据将测试应用程序代码中的关键路径以及生产环境中可能出现的各种可能的输入。构建和维护这些复杂的DTO层级输入很快变得繁琐，并导致复杂的测试设置超过应用代码本身；并且，这可能会掩盖测试结果实际上提供了全面的应用程序代码覆盖的任何保证。</p><h2 id="53c5" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码</h2><p id="5fb8" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">对象<code class="du jt ju jv jw b">Alpha</code>有一个字段<code class="du jt ju jv jw b">beta</code>，该字段有一个字段<code class="du jt ju jv jw b">gamma</code>，该字段有一个包含描述的<code class="du jt ju jv jw b">String</code>字段。这是一个简单的DTO等级体系，自然界中存在更复杂的东西。</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="a852" class="lb jy hh jw b fi lt lu l lv lw">public class Alpha {<br/>    private Beta beta;</span><span id="9a01" class="lb jy hh jw b fi lx lu l lv lw">    public Beta getBeta() {<br/>        return beta;<br/>    }</span><span id="b335" class="lb jy hh jw b fi lx lu l lv lw">    public void setBeta(Beta beta) {<br/>        this.beta = beta;<br/>    }<br/>}</span><span id="2f9b" class="lb jy hh jw b fi lx lu l lv lw">public class Beta {<br/>    private Gamma gamma;</span><span id="5e94" class="lb jy hh jw b fi lx lu l lv lw">    public Gamma getGamma() {<br/>        return gamma;<br/>    }</span><span id="c41e" class="lb jy hh jw b fi lx lu l lv lw">    public void setGamma(Gamma gamma) {<br/>        this.gamma = gamma;<br/>    }<br/>}</span><span id="3464" class="lb jy hh jw b fi lx lu l lv lw">public class Gamma {<br/>    private String description;</span><span id="609b" class="lb jy hh jw b fi lx lu l lv lw">    public String getDescription() {<br/>        return description;<br/>    }</span><span id="3a54" class="lb jy hh jw b fi lx lu l lv lw">    public void setDescription(String description) {<br/>        this.description = description;<br/>    }<br/>}</span></pre><p id="359d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">给定<code class="du jt ju jv jw b">alpha</code>输入对象，访问<code class="du jt ju jv jw b">description</code>字段的“安全”或“防弹”Java代码实现看起来会像这样:</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="35e2" class="lb jy hh jw b fi lt lu l lv lw">if (alpha != null &amp;&amp;<br/>        alpha.getBeta() != null &amp;&amp;<br/>        alpha.getBeta().getGamma() != null &amp;&amp;<br/>        alpha.getBeta().getGamma().getDescription() != null) {<br/>    // ...<br/>}</span></pre><h1 id="929d" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">一些常见的[痛苦的]单元测试解决方案</h1><p id="84e5" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">访问复杂DTO层次结构的单元测试应用程序的常见策略包括模仿测试数据层次结构和组装一个罐装测试数据输入的目录。这两种解决方案在目的上都是成功的，但是在实施和维护方面花费相当大，并且都不能提供真正全面覆盖的保证。</p><h2 id="4033" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">模拟测试数据</h2><p id="ac7a" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">模拟复杂的dto为验证任何应用程序测试场景提供了一种通用的方法。构建这些模拟的dto本身可能需要大量的测试设置代码。并且，随着DTO层次结构的复杂性增加，测试场景的数量也同样增加。</p><h2 id="8cbe" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码</h2><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="04c4" class="lb jy hh jw b fi lt lu l lv lw">@Mock<br/>private Alpha alpha;<br/>@Mock<br/>private Beta beta;<br/>@Mock<br/>private Gamma gamma;</span><span id="1385" class="lb jy hh jw b fi lx lu l lv lw">@BeforeMethod<br/>public void setUp() {<br/>    initMocks(this);</span><span id="88ce" class="lb jy hh jw b fi lx lu l lv lw">    doReturn(beta).when(alpha).getBeta();<br/>    doReturn(gamma).when(beta).getGamma();<br/>    doReturn("description").when(gamma.getDescription());<br/>}</span></pre><p id="468c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这涵盖了快乐的路径，但是，人们必须考虑其他场景:<code class="du jt ju jv jw b">alpha</code>是<code class="du jt ju jv jw b">null</code> , <code class="du jt ju jv jw b">beta</code>是<code class="du jt ju jv jw b">null</code> , <code class="du jt ju jv jw b">gamma</code>是<code class="du jt ju jv jw b">null</code>，或者<code class="du jt ju jv jw b">description</code>是<code class="du jt ju jv jw b">null</code>。</p><h2 id="45c1" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">罐装测试数据</h2><p id="c29f" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">以序列化形式保存dto(例如，<a class="ae js" href="https://www.json.org/" rel="noopener ugc nofollow" target="_blank"> JSON </a>)作为测试输入，限制了mocking所需的测试设置代码的数量。相反，这种方法需要识别和保存测试输入，然后长时间维护它们。当数据输入复杂时，这些序列化版本可能会非常大；而且，随着更多的场景被识别，可能需要维护许多副本。</p><h2 id="ba03" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码</h2><p id="4f64" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">在<code class="du jt ju jv jw b">alpha.json</code>中发现JSON。</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="4d3d" class="lb jy hh jw b fi lt lu l lv lw">{<br/>  "beta": {<br/>    "gamma": {<br/>      "description": "..."<br/>    }<br/>  }<br/>}</span></pre><p id="7355" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这又一次涵盖了“快乐之路”的场景。</p><h1 id="0df5" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">神奇的饼干方法</h1><p id="7731" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">通过将dto视为不透明的东西，即神奇的cookies，解决了访问数据及其评估的复杂性。以下步骤描述了如何操作。</p><h2 id="9be5" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">步骤1:分离关注点:访问与评估</h2><p id="6393" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">将访问数据的逻辑与评估访问结果的逻辑分开，提供了一种全面验证这两种不同类型的逻辑的方法。然后，访问功能被封装在一个单独的类中，其中的方法在相应的DTO类型上实现不同类型的访问。</p><h2 id="cdd5" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码</h2><p id="ab83" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">一个<code class="du jt ju jv jw b">AlphaAccess</code>类对<code class="du jt ju jv jw b">Alpha</code>“神奇cookie”上的访问类型进行建模。是独生子。</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="8da8" class="lb jy hh jw b fi lt lu l lv lw">public class AlphaAccess {<br/>    private static final AlphaAccess INSTANCE = new AlphaAccess();</span><span id="6956" class="lb jy hh jw b fi lx lu l lv lw">    protected AlphaAccess() {<br/>    }</span><span id="7713" class="lb jy hh jw b fi lx lu l lv lw">    public static AlphaAccess getInstance() {<br/>        return INSTANCE;<br/>    }</span><span id="6d86" class="lb jy hh jw b fi lx lu l lv lw">    public Beta getBeta(Alpha alpha) {<br/>        return alpha != null ? alpha.getBeta() : null;<br/>    }<br/>}</span></pre><h2 id="b7a5" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">步骤2:对“安全”访问建模</h2><p id="fc29" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">返回空值的访问类方法不会降低程序员在访问数据时出错的风险。<a class="ae js" href="http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html" rel="noopener ugc nofollow" target="_blank"> Java 8引入了</a> <code class="du jt ju jv jw b"><a class="ae js" href="http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html" rel="noopener ugc nofollow" target="_blank">Optional</a></code> <a class="ae js" href="http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html" rel="noopener ugc nofollow" target="_blank">类</a>，可以用来消除访问方法上的<code class="du jt ju jv jw b">null</code>返回值。</p><h2 id="452e" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码</h2><p id="ec2d" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">使用<code class="du jt ju jv jw b"><a class="ae js" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" rel="noopener ugc nofollow" target="_blank">Optional</a></code>返回值实现的<code class="du jt ju jv jw b">getBeta</code>方法的更新版本:</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="d6a9" class="lb jy hh jw b fi lt lu l lv lw">public Optional&lt;Beta&gt; getBeta(Alpha alpha) {<br/>        return alpha != null ?<br/>                Optional.ofNullable(alpha.getBeta()) :<br/>                Optional.empty();<br/>    }</span></pre><h2 id="eada" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">步骤3:重构访问:重磅炸弹超类</h2><p id="324d" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">访问方法是“go-fer”风格的方法，由于Java 8 <a class="ae js" href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" rel="noopener ugc nofollow" target="_blank">方法引用</a>，可以使用抽象超类来极大地简化访问方法:</p><h2 id="b432" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码</h2><p id="0f93" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">特定DTO访问类的抽象超类提供了“获取”字段值的通用实现:</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="6906" class="lb jy hh jw b fi lt lu l lv lw">public abstract class AbstractAccess&lt;T&gt; {</span><span id="9bda" class="lb jy hh jw b fi lx lu l lv lw">    protected &lt;R&gt; Optional&lt;R&gt; get(T o, Function&lt;T, R&gt; getter) {<br/>        return o != null ?<br/>                Optional.ofNullable(getter.apply(o)) :<br/>                Optional.empty();<br/>    }<br/>}</span></pre><p id="28eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后将<code class="du jt ju jv jw b">AlphaAccess</code>子类实现为:</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="8d7c" class="lb jy hh jw b fi lt lu l lv lw">public class AlphaAccess extends AbstractAccess&lt;Alpha&gt; {<br/>    ...</span><span id="25e5" class="lb jy hh jw b fi lx lu l lv lw">    public Optional&lt;Beta&gt; getBeta(Alpha alpha) {<br/>        return get(alpha, Alpha::getBeta);<br/>    }<br/>}</span></pre><p id="c58c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并且，给定一个针对<code class="du jt ju jv jw b">AbstractAccess</code>类的独立单元测试，针对<code class="du jt ju jv jw b">AlphaAccess</code>类的单元测试也很简单:</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="6cc0" class="lb jy hh jw b fi lt lu l lv lw">public class AlphaAccessTest {<br/>    <br/>    private AlphaAccess alphaAccess;<br/>    <br/>    @Mock<br/>    private Alpha alpha;<br/>    @Mock<br/>    private Beta beta;</span><span id="14b5" class="lb jy hh jw b fi lx lu l lv lw">    @BeforeMethod<br/>    public void setUp() {<br/>        initMocks(this);<br/>        <br/>        alphaAccess = new AlphaAccess();<br/>    }</span><span id="53e1" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testGetBeta() {<br/>        // given<br/>        doReturn(beta).when(alpha).getBeta();<br/>        <br/>        // when<br/>        Optional&lt;Beta&gt; actual = alphaAccess.getBeta(alpha);<br/>        <br/>        // then<br/>        assertEquals(actual, Optional.of(beta));<br/>    }<br/>}</span></pre><p id="2e04" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这为包含在<code class="du jt ju jv jw b">AlphaAccess</code>中的访问逻辑提供了100%的代码覆盖率。</p><h2 id="7d62" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">步骤4:委托访问:强制范围</h2><p id="570f" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">在顶级字段上创建了访问方法后，还可以在顶级创建通过那些下一级对象访问的字段的其他方法，从而简化应用程序访问和验证代码。</p><h2 id="b2ba" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码</h2><p id="51b2" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated"><code class="du jt ju jv jw b">AlphaAccess</code>有一个新的注入依赖项<code class="du jt ju jv jw b">BetaAccess</code>，它将把对其数据的责任委托给它，<code class="du jt ju jv jw b">BetaAccess</code>也有一个注入依赖项<code class="du jt ju jv jw b">GammaAccess</code>，它将把对其<code class="du jt ju jv jw b">description </code>字段的访问责任委托给它:</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="4199" class="lb jy hh jw b fi lt lu l lv lw">private static final AlphaAccess INSTANCE =<br/>        new AlphaAccess(BetaAccess.getInstance());</span><span id="b6d7" class="lb jy hh jw b fi lx lu l lv lw">// injected dependency<br/>private final BetaAccess betaAccess;</span><span id="8f48" class="lb jy hh jw b fi lx lu l lv lw">protected AlphaAccess(BetaAccess betaAccess) {<br/>    this.betaAccess = betaAccess;<br/>}</span><span id="856d" class="lb jy hh jw b fi lx lu l lv lw">...</span><span id="429f" class="lb jy hh jw b fi lx lu l lv lw">public Optional&lt;String&gt; getDescription(Alpha alpha) {<br/>    return getBeta(alpha).flatMap(betaAccess::getDescription);<br/>}</span></pre><p id="4d18" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<code class="du jt ju jv jw b">BetaAccess</code>中也有类似的实现:</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="a6b5" class="lb jy hh jw b fi lt lu l lv lw">public Optional&lt;String&gt; getDescription(Beta beta) {<br/>    return getGamma(beta).flatMap(gammaAccess::getDescription);<br/>}</span></pre><p id="6ea9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，在<code class="du jt ju jv jw b">GammaAccess</code>中，我们有:</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="a50e" class="lb jy hh jw b fi lt lu l lv lw">public Optional&lt;String&gt; getDescription(Gamma gamma) {<br/>    return get(gamma, Gamma::getDescription);<br/>}</span></pre><p id="a45e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，<code class="du jt ju jv jw b">AlphaAccess</code>的单元测试将包括:</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="c361" class="lb jy hh jw b fi lt lu l lv lw">    @Test<br/>    public void testGetDescription() {<br/>        // given<br/>        doReturn(beta).when(alpha).getBeta();<br/>        doReturn(Optional.of("description")).when(betaAccess)<br/>                .getDescription(beta);<br/>        <br/>        // when<br/>        Optional&lt;String&gt; actual = alphaAccess.getDescription(alpha);<br/>        <br/>        // then<br/>        assertEquals(actual, Optional.of("description"));<br/>    }</span></pre><p id="f54b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，<code class="du jt ju jv jw b">betaAccess</code>是一个类型为<code class="du jt ju jv jw b">BetaAccess</code>的模拟对象，在<code class="du jt ju jv jw b">AlphaAccess</code>构造时被注入，并在这里被存根化以返回一个<code class="du jt ju jv jw b">description</code>字段“描述”<code class="du jt ju jv jw b">String</code>值的<code class="du jt ju jv jw b">Optional</code>对象。这种存根不是单元测试欺骗，因为这种行为超出了<code class="du jt ju jv jw b">AlphaAccess</code>类本身的范围，而<code class="du jt ju jv jw b">AlphaAccess</code>类的唯一职责是检索<code class="du jt ju jv jw b">beta</code>对象，并将获取包含<code class="du jt ju jv jw b">description</code>字段值的<code class="du jt ju jv jw b">Optional</code>对象的职责委托给它的访问类<code class="du jt ju jv jw b">BetaAccess</code>。</p><h2 id="b637" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">第五步:大回报:如果有价值，就做点什么</h2><p id="a14d" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">现在，当一个值存在时，我们的应用程序代码可以安全地实现它的功能，而不需要合并与获取该值相关的所有复杂性。</p><h2 id="7e36" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码</h2><p id="3fe8" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated"><code class="du jt ju jv jw b">Optional</code>对象启用<code class="du jt ju jv jw b">NullPointerException</code>自由访问代码。</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="a4e7" class="lb jy hh jw b fi lt lu l lv lw">public class App {<br/>    // injected dependency<br/>    private final AlphaAccess alphaAccess;</span><span id="fef6" class="lb jy hh jw b fi lx lu l lv lw">    private final Alpha alpha;</span><span id="abde" class="lb jy hh jw b fi lx lu l lv lw">    public App(Alpha alpha) {<br/>        this(AlphaAccess.getInstance(), alpha);<br/>    }</span><span id="a27e" class="lb jy hh jw b fi lx lu l lv lw">    protected App(AlphaAccess alphaAccess, Alpha alpha) {<br/>        this.alphaAccess = alphaAccess;<br/>        this.alpha = alpha;<br/>    }</span><span id="768b" class="lb jy hh jw b fi lx lu l lv lw">    public void doSomething() {<br/>        alphaAccess.getDescription(alpha).ifPresent(description -&gt; {<br/>            // ...<br/>        });<br/>    }<br/>}</span></pre><p id="3228" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并且应用程序单元测试被简化了，因为只有alpha“魔法cookie”及其相应的访问类需要被模仿和清除。</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="b078" class="lb jy hh jw b fi lt lu l lv lw">public class AppTest {<br/>    private App app;</span><span id="8085" class="lb jy hh jw b fi lx lu l lv lw">    @Mock<br/>    private AlphaAccess alphaAccess;<br/>    @Mock<br/>    private Alpha alpha;</span><span id="2da2" class="lb jy hh jw b fi lx lu l lv lw">    @BeforeMethod<br/>    public void setUp() {<br/>        initMocks(this);</span><span id="a60d" class="lb jy hh jw b fi lx lu l lv lw">        app = new App(alphaAccess, alpha);<br/>    }</span><span id="fda3" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testDoSomething() {<br/>        // given<br/>        doReturn(Optional.of("description")).when(alphaAccess)<br/>                .getDescription(alpha);<br/>        <br/>        // when<br/>        app.doSomething();<br/>        <br/>        // then ...<br/>    }<br/>}</span></pre><p id="9e9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实现100%的应用程序代码覆盖率更容易实现，因为<code class="du jt ju jv jw b">AlphaAccess</code>类封装了如何检索<code class="du jt ju jv jw b">description</code>字段值的底层细节；单元测试可以关注结果的评估，而不是构建复杂的DTO输入的复杂性。</p><h2 id="b07c" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">步骤6: Postscript:过滤结果</h2><p id="14c8" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">将空的<code class="du jt ju jv jw b">Collection</code>子类和<code class="du jt ju jv jw b">Map</code>实现以及空的<code class="du jt ju jv jw b">String</code>对象视为缺失(<code class="du jt ju jv jw b">Optional.empty()</code>)可能是有用的。这可以在Access超类中轻松完成。</p><h2 id="a5e1" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码</h2><p id="601f" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">更新<code class="du jt ju jv jw b">AbstractAccess</code>类以过滤出空的<code class="du jt ju jv jw b">Collection</code>和<code class="du jt ju jv jw b">Map</code>实例以及空白的<code class="du jt ju jv jw b">String</code>实例:</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="66f6" class="lb jy hh jw b fi lt lu l lv lw">public abstract class AbstractAccess&lt;T&gt; {</span><span id="2218" class="lb jy hh jw b fi lx lu l lv lw">    protected &lt;R&gt; Optional&lt;R&gt; get(T o, Function&lt;T, R&gt; getter) {<br/>        return o != null ?<br/>                Optional.ofNullable(getter.apply(o))<br/>                        .filter(r -&gt; !(r instanceof String) || <br/>                            StringUtils.isNotBlank((String) r))<br/>                        .filter(r -&gt; !(r instanceof Collection) ||<br/>                            CollectionUtils<br/>                                .isNotEmpty((Collection&lt;?&gt;) r))<br/>                        .filter(r -&gt; !(r instanceof Map) ||<br/>                            MapUtils.isNotEmpty((Map&lt;?, ?&gt;) r)) :<br/>                Optional.empty();<br/>    }<br/>}</span></pre><h2 id="93d8" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">步骤7: Postscript:附加集合支持</h2><p id="2b8d" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">最后，支持不同的面向<code class="du jt ju jv jw b">Collection</code>的过滤器通常很有用。测试一个<code class="du jt ju jv jw b">Collection</code>的所有成员是否匹配一个特定的标准(<code class="du jt ju jv jw b">Predicate</code>)或任何do或no do，找到一个匹配的或找到第一个匹配的</p><h2 id="c3a7" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码</h2><p id="7ac0" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">再次更新<code class="du jt ju jv jw b">AbstractAccess</code>超类，为不同类型的<code class="du jt ju jv jw b">Stream</code>导向的访问类型提供支持:<code class="du jt ju jv jw b">allMatch</code>、<code class="du jt ju jv jw b">anyMatch</code>、<code class="du jt ju jv jw b">findAny</code>、<code class="du jt ju jv jw b">findFirst,</code>、<code class="du jt ju jv jw b">noneMatch</code>。</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="c75a" class="lb jy hh jw b fi lt lu l lv lw">public abstract class AbstractAccess&lt;T&gt; {</span><span id="afd2" class="lb jy hh jw b fi lx lu l lv lw">    protected boolean allMatch(Collection&lt;T&gt; collection,<br/>                               Predicate&lt;T&gt; predicate) {<br/>        return isNotEmpty(collection) &amp;&amp;<br/>                collection.stream().allMatch(predicate);<br/>    }</span><span id="9eb0" class="lb jy hh jw b fi lx lu l lv lw">    protected boolean anyMatch(Collection&lt;T&gt; collection,<br/>                               Predicate&lt;T&gt; predicate) {<br/>        return isNotEmpty(collection) &amp;&amp;<br/>                collection.stream().anyMatch(predicate);<br/>    }</span><span id="b044" class="lb jy hh jw b fi lx lu l lv lw">    protected Optional&lt;T&gt; findAny(Collection&lt;T&gt; collection,<br/>                                  Predicate&lt;T&gt; predicate) {<br/>        return isNotEmpty(collection) ?<br/>                collection.stream().filter(predicate).findAny() :<br/>                Optional.empty();<br/>    }</span><span id="d632" class="lb jy hh jw b fi lx lu l lv lw">    protected Optional&lt;T&gt; findFirst(Collection&lt;T&gt; collection,<br/>                                    Predicate&lt;T&gt; predicate) {<br/>        return isNotEmpty(collection) ?<br/>                collection.stream().filter(predicate).findFirst() :<br/>                Optional.empty();<br/>    }</span><span id="ca30" class="lb jy hh jw b fi lx lu l lv lw">    protected &lt;R&gt; Optional&lt;R&gt; get(T o, Function&lt;T, R&gt; getter) {<br/>        // ...<br/>    }</span><span id="f8bc" class="lb jy hh jw b fi lx lu l lv lw">    protected boolean noneMatch(Collection&lt;T&gt; collection,<br/>                                Predicate&lt;T&gt; predicate) {<br/>        return isNotEmpty(collection) &amp;&amp;<br/>                collection.stream().noneMatch(predicate);<br/>    }<br/>}</span></pre><h2 id="fd2c" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">结论:更好的应用</h2><p id="8539" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">通过将数据访问逻辑从数据评估逻辑中分离出来，我们能够实现更加可靠和可维护的软件。数据模型的复杂性不再掩盖应用程序本身的复杂性。此外，隔离地验证这两种类型的逻辑允许全面检查在访问和评估这两个领域中需要处理的重要场景。</p><h1 id="da25" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">下一步:Java 10扩展</h1><p id="4b42" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">在Java 10中，<code class="du jt ju jv jw b"><a class="ae js" href="https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html" rel="noopener ugc nofollow" target="_blank">Optional</a></code>类有一些重要的扩展，结合这里描述的访问类策略将非常有用；具体来说，<code class="du jt ju jv jw b"><a class="ae js" href="https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html#ifPresentOrElse(java.util.function.Consumer,java.lang.Runnable)" rel="noopener ugc nofollow" target="_blank">ifPresentOrElse</a></code>、<code class="du jt ju jv jw b"><a class="ae js" href="https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html#or(java.util.function.Supplier)" rel="noopener ugc nofollow" target="_blank">or</a></code>和<code class="du jt ju jv jw b"><a class="ae js" href="https://docs.oracle.com/javase/10/docs/api/java/util/Optional.html#stream()" rel="noopener ugc nofollow" target="_blank">stream</a></code>方法将帮助数据评估代码处理常见场景。</p><h2 id="52b1" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码:可选#ifPresentOrElse(消费者，可运行)</h2><p id="ccef" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">某些应用程序代码中，特定值的缺失和它的存在一样重要。</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="7005" class="lb jy hh jw b fi lt lu l lv lw">alphaAccess.getDescription(alpha).ifPresentOrElse(description -&gt; {<br/>            // do something with the description ...<br/>        }, () -&gt; {<br/>            // do something when there is no description ...<br/>        });</span></pre><h2 id="c66b" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码:可选#或(供应商)</h2><p id="b4ec" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">一些数据场景具有替代的解决策略，这些策略可以封装在访问类本身中。在具有两个字段<code class="du jt ju jv jw b">description</code>和<code class="du jt ju jv jw b">backupDescription</code>的<code class="du jt ju jv jw b">Gamma</code>类的情况下。</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="c646" class="lb jy hh jw b fi lt lu l lv lw">public class Gamma {<br/>    private String description;<br/>    private String backupDescription;</span><span id="e71f" class="lb jy hh jw b fi lx lu l lv lw">    // ...<br/>}</span></pre><p id="b291" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果规则是:当<code class="du jt ju jv jw b">description</code>字段为空时，则应使用<code class="du jt ju jv jw b">backupDescription</code>字段；然后，<code class="du jt ju jv jw b">GammaAccess</code>类可以通过实现以下内容来封装这条规则:</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="dff8" class="lb jy hh jw b fi lt lu l lv lw">    public Optional&lt;String&gt; getDescription(Gamma gamma) {<br/>        return get(gamma, Gamma::getDescription)<br/>                .or(() -&gt; get(gamma, Gamma::getBackupDescription));<br/>    }</span></pre><h2 id="f1d8" class="lb jy hh bd jz lc ld le kd lf lg lh kh ip li lj kl it lk ll kp ix lm ln kt lo bi translated">示例代码:可选的#stream()</h2><p id="ef3b" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">当处理集合时，我们经常必须处理<code class="du jt ju jv jw b">Optionals</code>中的<code class="du jt ju jv jw b">Stream</code>，Java 10通过解引用非空实例来帮助简化:</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="d108" class="lb jy hh jw b fi lt lu l lv lw">Stream&lt;Optional&lt;Alpha&gt;&gt; alphaStream = ...;<br/>List&lt;String&gt; descriptions =<br/>                alphaStream<br/>                        .flatMap(Optional::stream)<br/>                        .map(alphaAccess::getDescription)<br/>                        .flatMap(Optional::stream)<br/>                        .collect(Collectors.toList());</span></pre><h1 id="7aa4" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">附录:抽象访问单元测试</h1><p id="7cc7" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">这里是<code class="du jt ju jv jw b">AbstractAccess</code>超类的源代码，它为其helper方法提供了100%的代码覆盖率，因此Access子类可以在很大程度上专注于它们自己的“快乐之路”场景。</p><pre class="jd je jf jg fd lp jw lq lr aw ls bi"><span id="7aef" class="lb jy hh jw b fi lt lu l lv lw">import java.util.List;<br/>import java.util.Map;<br/>import java.util.Optional;</span><span id="d284" class="lb jy hh jw b fi lx lu l lv lw">import org.mockito.Mock;<br/>import org.testng.annotations.BeforeMethod;<br/>import org.testng.annotations.Test;</span><span id="e3ad" class="lb jy hh jw b fi lx lu l lv lw">import com.google.common.collect.ImmutableList;<br/>import com.walmart.terrene.TerreneTestCase;</span><span id="126b" class="lb jy hh jw b fi lx lu l lv lw">import static org.mockito.Mockito.doReturn;<br/>import static org.mockito.MockitoAnnotations.initMocks;<br/>import static org.testng.Assert.assertEquals;<br/>import static org.testng.Assert.assertFalse;<br/>import static org.testng.Assert.assertTrue;</span><span id="7d18" class="lb jy hh jw b fi lx lu l lv lw">public class AbstractAccessTest extends TerreneTestCase {</span><span id="9e49" class="lb jy hh jw b fi lx lu l lv lw">    protected interface TestObject {<br/>        List&lt;Object&gt; getList();</span><span id="1ca6" class="lb jy hh jw b fi lx lu l lv lw">        Map&lt;Object, Object&gt; getMap();</span><span id="f9a1" class="lb jy hh jw b fi lx lu l lv lw">        Object getObject();</span><span id="4a86" class="lb jy hh jw b fi lx lu l lv lw">        String getString();<br/>    }<br/>    private static final String BLANK = "";<br/>    private static final String NOT_BLANK = "not-blank";<br/>    <br/>    private AbstractAccess&lt;TestObject&gt; abstractAccess;<br/>    <br/>    @Mock<br/>    private TestObject testObject;<br/>    @Mock<br/>    private Object object;<br/>    @Mock<br/>    private List&lt;Object&gt; objects;<br/>    @Mock<br/>    private Map&lt;Object, Object&gt; objectMap;</span><span id="a4e2" class="lb jy hh jw b fi lx lu l lv lw">    @BeforeMethod<br/>    public void setUp() {<br/>        initMocks(this);</span><span id="0d2e" class="lb jy hh jw b fi lx lu l lv lw">        abstractAccess = new AbstractAccess&lt;TestObject&gt;() {<br/>        };<br/>    }</span><span id="2ec3" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testAllMatch() {<br/>        // then<br/>        assertTrue(abstractAccess.allMatch(<br/>                           ImmutableList.of(testObject),<br/>                           o -&gt; true));<br/>    }</span><span id="b682" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testAllMatchEmpty() {<br/>        // then<br/>        assertFalse(abstractAccess.allMatch(<br/>                        ImmutableList.of(),<br/>                        o -&gt; true));<br/>    }</span><span id="a328" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testAllMatchFalse() {<br/>        // then<br/>        assertFalse(abstractAccess.allMatch(<br/>                        ImmutableList.of(testObject),<br/>                        o -&gt; false));<br/>    }</span><span id="41ec" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testAnyMatch() {<br/>        // then<br/>        assertTrue(abstractAccess.anyMatch(<br/>                        ImmutableList.of(testObject),<br/>                        o -&gt; true));<br/>    }</span><span id="a512" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testAnyMatchFalse() {<br/>        // then<br/>        assertFalse(abstractAccess.anyMatch(<br/>                        ImmutableList.of(testObject),<br/>                        o -&gt; false));<br/>    }</span><span id="3e95" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testAnyMatchNull() {<br/>        // then<br/>        assertFalse(abstractAccess.anyMatch(<br/>                        null,<br/>                        o -&gt; true));<br/>    }</span><span id="4304" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testFindAny() {<br/>        // then<br/>        assertEquals(abstractAccess.findAny(<br/>                        ImmutableList.of(testObject),<br/>                        o -&gt; true),<br/>                Optional.of(testObject));<br/>    }</span><span id="c4e0" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testFindAnyEmpty() {<br/>        // then<br/>        assertEquals(abstractAccess.findAny(<br/>                        null,<br/>                        o -&gt; true),<br/>                Optional.empty());<br/>    }</span><span id="8060" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testFindFirst() {<br/>        // then<br/>        assertEquals(abstractAccess.findFirst(<br/>                        ImmutableList.of(testObject),<br/>                        o -&gt; true),<br/>                Optional.of(testObject));<br/>    }</span><span id="06dd" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testFindFirstEmpty() {<br/>        // then<br/>        assertEquals(abstractAccess.findFirst(<br/>                        null,<br/>                        o -&gt; true),<br/>                Optional.empty());<br/>    }</span><span id="2032" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testGetBlank() {<br/>        // given<br/>        doReturn(BLANK).when(testObject).getString();</span><span id="7df9" class="lb jy hh jw b fi lx lu l lv lw">        // then<br/>        assertEquals(abstractAccess.get(<br/>                        testObject,<br/>                        TestObject::getString),<br/>                Optional.empty());<br/>    }</span><span id="f124" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testGetEmptyMap() {<br/>        // then<br/>        assertEquals(abstractAccess.get(<br/>                        testObject,<br/>                        TestObject::getMap),<br/>                Optional.empty());<br/>    }</span><span id="bd1a" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testGetNotBlank() {<br/>        // given<br/>        doReturn(NOT_BLANK).when(testObject).getString();</span><span id="b3ac" class="lb jy hh jw b fi lx lu l lv lw">        // then<br/>        assertEquals(abstractAccess.get(<br/>                        testObject,<br/>                        TestObject::getString),<br/>                Optional.of(NOT_BLANK));<br/>    }</span><span id="dd94" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testGetNotEmptyList() {<br/>        // given<br/>        doReturn(objects).when(testObject).getList();</span><span id="7b00" class="lb jy hh jw b fi lx lu l lv lw">        // then<br/>        assertEquals(abstractAccess.get(<br/>                        testObject,<br/>                        TestObject::getList),<br/>                Optional.of(objects));<br/>    }</span><span id="4318" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testGetNotEmptyMap() {<br/>        // given<br/>        doReturn(objectMap).when(testObject).getMap();</span><span id="33c6" class="lb jy hh jw b fi lx lu l lv lw">        // then<br/>        assertEquals(abstractAccess.get(<br/>                        testObject,<br/>                        TestObject::getMap),<br/>                Optional.of(objectMap));<br/>    }</span><span id="d308" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testGetNotNull() {<br/>        // given<br/>        doReturn(object).when(testObject).getObject();</span><span id="cfaf" class="lb jy hh jw b fi lx lu l lv lw">        // then<br/>        assertEquals(abstractAccess.get(<br/>                        testObject,<br/>                        TestObject::getObject),<br/>                Optional.of(object));<br/>    }</span><span id="b77b" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testGetNotNullWhenNull() {<br/>        // then<br/>        assertEquals(abstractAccess.get(<br/>                        null,<br/>                        TestObject::getObject),<br/>                Optional.empty());<br/>    }</span><span id="77d0" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testNoneMatch() {<br/>        // then<br/>        assertTrue(abstractAccess.noneMatch(<br/>                        ImmutableList.of(testObject),<br/>                        o -&gt; false));<br/>    }</span><span id="7376" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testNoneMatchEmpty() {<br/>        // then<br/>        assertFalse(abstractAccess.noneMatch(<br/>                        ImmutableList.of(),<br/>                        o -&gt; false));<br/>    }</span><span id="22c1" class="lb jy hh jw b fi lx lu l lv lw">    @Test<br/>    public void testNoneMatchFalse() {<br/>        // then<br/>        assertFalse(abstractAccess.noneMatch(<br/>                        ImmutableList.of(testObject),<br/>                        o -&gt; true));<br/>    }<br/>}</span></pre></div></div>    
</body>
</html>