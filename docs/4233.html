<html>
<head>
<title>Stepping into Activity tests with ActivityScenarios</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用活动场景步入活动测试</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/stepping-into-activity-tests-with-activityscenarios-5db98d5311e6?source=collection_archive---------1-----------------------#2019-03-12">https://medium.com/google-developer-experts/stepping-into-activity-tests-with-activityscenarios-5db98d5311e6?source=collection_archive---------1-----------------------#2019-03-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/641b6522a948a8410e765dc272cb7f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hMi9JpxpoSpJPR_pW2vtIA.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Photo by <a class="ae hu" href="https://www.pexels.com/@monicore?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">monicore</a> from <a class="ae hu" href="https://www.pexels.com/photo/mountain-and-lake-at-sunset-135157/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><div class=""/><p id="088a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不久前，谷歌的测试团队推出了<a class="ae hu" href="https://developer.android.com/training/testing/set-up-project" rel="noopener ugc nofollow" target="_blank"> Android X测试库</a>，其中我们可以找到<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/guide/components/activities/testing" rel="noopener ugc nofollow" target="_blank">ActivityScenario</a></code>，一种测试<code class="du js jt ju jv b">Activities</code>及其相关代码的新方法。这些API在几周前发布了稳定版本，日常使用完全安全。</p><p id="b93c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个工具的主要思想是驱动<code class="du js jt ju jv b">Activity</code>的状态，这样我们可以模拟应用程序通过<code class="du js jt ju jv b">onCreate()</code>、<code class="du js jt ju jv b">onResume()</code>和其他生命周期方法；这有助于开发人员测试这些状态之间的流程。</p><p id="6794" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同一个套件中的<code class="du js jt ju jv b">ActivityScenario</code>和其他API的一个非常特殊的方面是可以在JVM ( <a class="ae hu" href="https://developer.android.com/training/testing/fundamentals#robolectric" rel="noopener ugc nofollow" target="_blank">使用Robolectric </a>)或设备上运行测试。这种方法的唯一警告是，需要根据我们希望它们运行的位置，将所有需要的测试文件移动到<code class="du js jt ju jv b">test</code>或<code class="du js jt ju jv b">androidTest</code>文件夹中。</p><p id="9ef0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用Robolectric在JVM上运行测试将极大地改善执行时间。相反，当我们在设备或仿真器上运行测试时，<code class="du js jt ju jv b">Activity</code>在设备上启动，使得测试与现实生活场景更加一致。</p><blockquote class="jw jx jy"><p id="e599" class="iu iv jz iw b ix iy iz ja jb jc jd je ka jg jh ji kb jk jl jm kc jo jp jq jr ha bi translated"><strong class="iw hy">注意:</strong>对于本文的目的来说，在哪里运行测试并不重要。我们不会展示如何包含在特定环境中运行测试的库，相反可以在这里找到<a class="ae hu" rel="noopener" href="/androiddevelopers/write-once-run-everywhere-tests-on-android-88adb2ba20c5"/>。</p></blockquote><p id="5e0a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du js jt ju jv b">ActivityScenario</code>和<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/support/test/rule/ActivityTestRule" rel="noopener ugc nofollow" target="_blank">ActivityTestRule</a></code>的主要区别在于，我们对目标<code class="du js jt ju jv b">Activity.</code> <code class="du js jt ju jv b">ActivityScenario</code>的<code class="du js jt ju jv b">Lifecycle</code>的控制可以轻松驱动组件的每个状态，甚至决定重启它并测试在那种情况下会发生什么。</p><h2 id="2ae9" class="kd ke hx bd kf kg kh ki kj kk kl km kn jf ko kp kq jj kr ks kt jn ku kv kw kx bi translated">介绍场景</h2><p id="ede1" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">假设我们有一个<code class="du js jt ju jv b">Lifecycle</code>感知组件，它是闪屏的一部分。超时后，如果用户没有登录，该组件会将用户重定向到登录屏幕，或者重定向到应用程序的主屏幕。</p><p id="1669" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果用户在倒计时完成前决定退出应用程序，我们使用<code class="du js jt ju jv b">Lifecycle</code>来停止我们可能采取的所有行动。因为我们使用这个API，所以我们需要一个<code class="du js jt ju jv b">LifecycleOwner</code>，我们可以在其中添加组件作为观察者，而一个<code class="du js jt ju jv b">AppCompatActivity</code>是实现这个的最简单的方法。</p><h2 id="5ac2" class="kd ke hx bd kf kg kh ki kj kk kl km kn jf ko kp kq jj kr ks kt jn ku kv kw kx bi translated">组件代码</h2><p id="75e1" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">组件本身非常小，这一点我们可以从它的源代码中看出:</p><figure class="ld le lf lg fd hj"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="22fa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<code class="du js jt ju jv b">SplashScreenManager</code>的构造函数中，我们传递目标<code class="du js jt ju jv b">Activity boundActivity</code>、<code class="du js jt ju jv b">IntentFactory</code>和以毫秒为单位的持续时间。然后，我们从<code class="du js jt ju jv b">boundActivity</code>中获取<code class="du js jt ju jv b">Lifecycle</code>，并将我们的组件添加为观察者。</p><p id="133e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们到达<code class="du js jt ju jv b">Activity</code>的<code class="du js jt ju jv b">onStart()</code>状态时，我们使用一个协程来产生一个异步操作，该操作在给定的时间内暂停，然后将用户转到下一个步骤，在该步骤之后立即关闭<code class="du js jt ju jv b">boundActivity</code>。</p><p id="3e2c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们在倒计时结束前到达<code class="du js jt ju jv b">onStop</code>，我们将取消它，用户不会进入下一步。</p><p id="8973" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于我们想要编写的测试来说,<code class="du js jt ju jv b">IntentFactory</code>并不重要，唯一重要的是它以这样的方式工作:</p><ul class=""><li id="517f" class="lj lk hx iw b ix iy jb jc jf ll jj lm jn ln jr lo lp lq lr bi translated">它加载令牌，为了方便起见保存在<code class="du js jt ju jv b">SharedPreferences</code>中；</li><li id="601c" class="lj lk hx iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated">如果该令牌不可用，它会将用户转到登录屏幕；</li><li id="f9e8" class="lj lk hx iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated">如果它可用，它将打开应用程序的主屏幕。</li></ul><h2 id="f8ca" class="kd ke hx bd kf kg kh ki kj kk kl km kn jf ko kp kq jj kr ks kt jn ku kv kw kx bi translated">编写测试用例</h2><p id="906b" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">现在，我们知道我们期望这个组件如何工作，我们想围绕它编写测试，这样我们可以确保它按预期工作。</p><p id="0a41" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，我们将编写一个测试来检查未登录的场景，因此我们希望调用登录屏幕:</p><figure class="ld le lf lg fd hj"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="9fb0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们做的第一件事是从<a class="ae hu" href="https://developer.android.com/training/testing/espresso/intents" rel="noopener ugc nofollow" target="_blank"> Espresso Intent </a>库中调用<code class="du js jt ju jv b">Intents.init()</code>。这样，我们可以捕获任何<code class="du js jt ju jv b">Intent</code>并在以后检查它们的内容。</p><p id="8ef0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后我们创建测试<code class="du js jt ju jv b">Activity</code>的<code class="du js jt ju jv b">ActivityScenario</code>，创建它是为了能够真实地驱动<code class="du js jt ju jv b">Lifecycle</code>。</p><p id="5422" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此时，这样的<code class="du js jt ju jv b">Activity</code> <a class="ae hu" href="https://developer.android.com/reference/androidx/test/core/app/ActivityScenario.html#launch(java.lang.Class%3CA%3E)" rel="noopener ugc nofollow" target="_blank">应该处于</a> <code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/androidx/test/core/app/ActivityScenario.html#launch(java.lang.Class%3CA%3E)" rel="noopener ugc nofollow" target="_blank">onResume</a></code> <a class="ae hu" href="https://developer.android.com/reference/androidx/test/core/app/ActivityScenario.html#launch(java.lang.Class%3CA%3E)" rel="noopener ugc nofollow" target="_blank">状态</a>，我们在它的主线程上调用一个lambda，创建我们需要的对象，包括<code class="du js jt ju jv b">SplashScreenManager</code>，使用<code class="du js jt ju jv b">Activity</code>本身，它作为<code class="du js jt ju jv b">it</code>参数传递给lambda。</p><blockquote class="jw jx jy"><p id="99d4" class="iu iv jz iw b ix iy iz ja jb jc jd je ka jg jh ji kb jk jl jm kc jo jp jq jr ha bi translated">注意:我们确保删除了令牌，所以我们将处于需要登录的情况。</p></blockquote><p id="036c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下一步是将活动转移到<code class="du js jt ju jv b">STARTED</code>状态，这样我们的协程就会运行并启动新的屏幕。我们将测试的等待时间设置为0，以避免由于计时造成的任何延迟或剥落。</p><p id="2f6f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦我们的异步代码运行，我们就使用Espresso Intent库中的另一个函数，<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/support/test/espresso/intent/Intents.html#intended(org.hamcrest.Matcher%3Candroid.content.Intent%3E,%20android.support.test.espresso.intent.VerificationMode)" rel="noopener ugc nofollow" target="_blank">intended()</a></code>这是一种理解<code class="du js jt ju jv b">Intent</code>内容的方式，或多或少类似于<code class="du js jt ju jv b"><a class="ae hu" href="https://developer.android.com/reference/android/support/test/espresso/Espresso.html#onView(org.hamcrest.Matcher%3Candroid.view.View%3E)" rel="noopener ugc nofollow" target="_blank">onView()</a></code>对<code class="du js jt ju jv b">View</code>的作用。在这种情况下，我们检查<code class="du js jt ju jv b">Intent</code>是否意味着启动登录屏幕。</p><p id="c391" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后但同样重要的是，我们需要调用<code class="du js jt ju jv b">Intents.release()</code>来停止记录<code class="du js jt ju jv b">Intent</code>和<code class="du js jt ju jv b">ActivityScenario</code>上的<code class="du js jt ju jv b">close()</code>，以便我们释放所有的资源，并将我们的测试恢复到它们的初始状态。如果没有这些步骤，我们的测试用例将会处于一个不可预料的(并且潜在地不可复制的)状态，这违背了拥有稳定测试套件的想法。</p><blockquote class="jw jx jy"><p id="4a85" class="iu iv jz iw b ix iy iz ja jb jc jd je ka jg jh ji kb jk jl jm kc jo jp jq jr ha bi translated"><strong class="iw hy">注:</strong>组件的完整测试套件可以在<a class="ae hu" href="https://gist.github.com/tiwiz/989c74f5d63e8340fee67df7a5fac100" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></blockquote><h2 id="e9ff" class="kd ke hx bd kf kg kh ki kj kk kl km kn jf ko kp kq jj kr ks kt jn ku kv kw kx bi translated">为什么要用？</h2><p id="0da9" class="pw-post-body-paragraph iu iv hx iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">编写小而快速的单元测试无疑是验证我们编写的代码的最简单和最可靠的方式，但是，当我们构建一个功能或一个屏幕时，我们需要验证这些小部分是如何在Android系统中组合在一起的。大多数情况下，我们可以使用集成测试来确保不同的单元很好地配合在一起，但是在某些时候，我们发现自己处于这样一种情况，我们需要确保我们编写的所有代码都按照平台的预期工作。在这种情况下，能够驱动每个组件的<code class="du js jt ju jv b">Lifecycle</code>并一步一步地验证，无疑是编写测试套件的最好和最不痛苦的方式之一，这也是<code class="du js jt ju jv b">ActivityScenario</code>成为一个必要工具的地方。</p><p id="201a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="jz">特别感谢我的朋友</em> <a class="ae hu" href="https://twitter.com/@johnson_cor" rel="noopener ugc nofollow" target="_blank"> <em class="jz">科里</em></a><em class="jz"/><a class="ae hu" href="https://twitter.com/danybony_" rel="noopener ugc nofollow" target="_blank"><em class="jz">丹尼尔</em></a><em class="jz"/><a class="ae hu" href="https://twitter.com/fabioCollini" rel="noopener ugc nofollow" target="_blank"><em class="jz">法比奥</em> </a> <em class="jz">，以及</em> <a class="ae hu" href="https://twitter.com/wdziemia" rel="noopener ugc nofollow" target="_blank"> <em class="jz">沃尔特</em> </a> <em class="jz">对这篇博文进行校对。</em></p></div></div>    
</body>
</html>