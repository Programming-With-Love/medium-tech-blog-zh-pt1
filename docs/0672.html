<html>
<head>
<title>Room &amp; Kotlin Symbol Processing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">房间和科特林符号处理</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/room-kotlin-symbol-processing-24808528a28e?source=collection_archive---------0-----------------------#2021-10-10">https://medium.com/androiddevelopers/room-kotlin-symbol-processing-24808528a28e?source=collection_archive---------0-----------------------#2021-10-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/317f5bd344fb56c196f16b2b1769cbb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yM7Lf4dC_hwse6YmoCO4uQ.png"/></div></div></figure><div class=""/><figure class="ev ex iq ir is hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ip"><img src="../Images/9f6856a00fb93ce7867672ef17ae2e09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7NeAcUe0TeLm_rAH"/></div></div><figcaption class="it iu et er es iv iw bd b be z dx">Photo by <a class="ae ix" href="https://unsplash.com/@mreichelt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marc Reichelt</a> on <a class="ae ix" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b77e" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><a class="ae ix" href="https://developer.android.com/training/data-storage/room" rel="noopener ugc nofollow" target="_blank"> Room </a>是Jetpack的数据库抽象库，它提供了在没有任何样板文件的情况下编写编译时验证的SQL查询的能力。它通过处理代码中的注释和生成Java源代码来实现这一点。</p><p id="eb64" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">注释处理器非常强大，但是会导致构建时间的损失。对于用Java编写的代码来说，这通常是可以接受的，但是对于Kotlin来说，这种代价是相当大的，因为Kotlin没有内置的注释处理管道。相反，它通过从Kotlin代码生成存根Java代码来支持注释处理器，然后通过管道将其传送到Java编译器进行处理。</p><p id="c626" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">因为不是Kotlin源代码中的所有东西都可以用Java表示，所以有些信息会在翻译中丢失。类似地，Kotlin是一种多平台语言，但是KAPT只在你的目标是Java字节码时才有效。</p><p id="d7c5" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja ht">满足:</strong> <a class="ae ix" href="https://github.com/google/ksp" rel="noopener ugc nofollow" target="_blank"> <strong class="ja ht">科特林符号处理</strong> </a></p><p id="ac46" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">随着注释处理器在Android上的广泛使用，KAPT成为了构建性能的瓶颈。为了解决这个问题，Google Kotlin编译器团队开始研究一种替代方案，为Kotlin提供一流的注释处理支持。当这个项目诞生时，我们为Room感到非常兴奋，因为它将为Room提供更好的支持。从Room 2.4开始，它对KSP提供了实验性支持，我们观察到编译速度提高了2倍，尤其是干净编译。</p></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><p id="dedc" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">这篇文章不是关于教授注释处理、房间或KSP的。相反，它是关于我们所面临的挑战和我们在增加KSP支持时所做的权衡。你不需要知道房间或KSP来理解它，但熟悉注释处理是必要的。</p><blockquote class="kd ke kf"><p id="e8c7" class="iy iz kg ja b jb jc jd je jf jg jh ji kh jk jl jm ki jo jp jq kj js jt ju jv ha bi translated">注意，我们在KSP变得稳定之前很久就开始使用它了。因此，我们做出的一些决定在今天可能适用，也可能不适用。</p></blockquote><p id="c898" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">这篇文章的目的是给注释处理器作者一个良好的开端，告诉他们在项目中添加KSP支持时应该注意什么。</p><p id="6d1f" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja ht">房间工作原理简介</strong></p><p id="5606" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">房间的标注处理涉及两个步骤。有些“处理器”类遍历用户代码，验证并提取必要的信息到“值对象”中。这些值对象被传递给“Writer”类，后者将它们转换成代码。和许多其他注释处理器一样，Room严重依赖于<a class="ae ix" href="https://github.com/google/auto/tree/master/common" rel="noopener ugc nofollow" target="_blank">自动公共</a>和<code class="du kk kl km kn b"><em class="kg">javax.lang.model</em></code>包(Java注释处理API包)中频繁引用的类。</p></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><p id="b145" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">为了支持KSP，我们有三个选择:</p><p id="4c5c" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">a)为JavaAP和KSP复制每个“处理器”类，它们将具有相同的值对象作为输出，我们可以将它们输入到编写器中。</p><p id="a2c8" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">b)在KSP / JavaAP上创建一个抽象，这样处理器可以有一个使用该抽象的实现。</p><p id="bfc0" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">c)用KSP替换JavaAP，并要求开发人员也使用KSP来处理Java代码。</p><p id="b971" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">选项C实际上并不可行，因为这会对Java用户造成很大的干扰。随着房间数的采用，这种破坏性的变化是不可能的。在“A”和“B”之间，我们决定选择“B ”,因为处理器具有重要的业务逻辑，要把它拆开并不容易。</p><p id="09b2" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja ht">满足:</strong><a class="ae ix" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:room/room-compiler-processing/" rel="noopener ugc nofollow" target="_blank"><strong class="ja ht"/></a></p><p id="e68e" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">在JavaAP和KSP上创建一个通用的抽象并不容易。Kotlin和Java可以互操作，但是它们有不同的模型。例如，有一些特殊的类类型，比如Kotlin中的值类或Java中的静态方法。此外，Java在类中有字段和方法，而Kotlin有属性和函数。</p><p id="a953" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">我们没有试图追求完美的抽象，而是决定实现<em class="kg">“房间需要什么”</em>。这实际上意味着，找到导入了<code class="du kk kl km kn b">javax.lang.model</code>的房间中的每一个文件，并将其移动到X处理中的一个抽象中。于是<code class="du kk kl km kn b">TypeElement</code>变成了<code class="du kk kl km kn b">XTypeElement</code>，<code class="du kk kl km kn b">ExecutableElement</code>变成了<code class="du kk kl km kn b">XExecutableElement</code>等等。</p><p id="a056" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">不幸的是，<code class="du kk kl km kn b">javax.lang.model</code>房间里到处都是API。一次性创建这些X类会给评审者带来不可恢复的精神负担。因此，我们需要一种迭代实现的方法。</p><p id="71b7" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">另一方面，我们需要证明这是可行的。所以我们首先<a class="ae ix" href="https://android-review.googlesource.com/c/platform/frameworks/support/+/1362062" rel="noopener ugc nofollow" target="_blank">原型化</a>它，一旦我们确信这是一个合理的选择，我们就<a class="ae ix" href="https://android-review.googlesource.com/c/platform/frameworks/support/+/1362102" rel="noopener ugc nofollow" target="_blank">用他们自己的测试一个接一个地重新实现所有的X类</a>。</p></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><p id="be04" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">我所说的实现<em class="kg">“what Room needs”</em>的一个很好的例子可以在关于类中字段的<a class="ae ix" href="https://android-review.googlesource.com/c/platform/frameworks/support/+/1362165/6/room/compiler-xprocessing/src/main/java/androidx/room/processing/javac/JavacTypeElement.kt" rel="noopener ugc nofollow" target="_blank">这个变化</a>中看到。当Room处理一个类的字段时，它总是对它的所有字段感兴趣，包括超类中的字段。所以当我们创建相应的X-Processing API时，我们<strong class="ja ht">只添加了</strong>获取所有字段的能力。</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="1ebe" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">如果我们正在设计一个通用库，这将永远不会通过API审查。但是因为我们的目标只是一个空间，并且它已经有了一个与<code class="du kk kl km kn b">TypeElement</code>具有相同功能的helper方法，复制它会降低项目的风险。</p></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><p id="9cbc" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">一旦我们有了基本的X处理API和它们自己的测试，下一步就是移动空间来使用这个抽象。这也是“实现房间需求”获得良好回报的地方。Room已经在通用功能的<code class="du kk kl km kn b">javax.lang.model</code>API上有了扩展功能/属性(例如，获取<code class="du kk kl km kn b">TypeElement</code>的方法)。我们首先更新这些扩展，使其看起来像X处理API，然后在<a class="ae ix" href="https://android-review.googlesource.com/c/platform/frameworks/support/+/1361181/21/room/compiler/src/main/kotlin/androidx/room/preconditions/Checks.kt" rel="noopener ugc nofollow" target="_blank"> 1 CL </a>中将空间迁移到X处理。</p><p id="ebfb" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja ht"> API可用性改进</strong></p><p id="1a6f" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">保持JavaAP像API一样并不意味着我们不能改进。在将Room迁移到X-Processing之后，我们跟进了一系列API改进。</p><p id="d03b" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">例如，Room多次调用<code class="du kk kl km kn b">MoreElement/MoreTypes</code>在<code class="du kk kl km kn b">javax.lang.model</code>类型之间转换(例如<a class="ae ix" href="https://github.com/google/auto/blob/master/common/src/main/java/com/google/auto/common/MoreElements.java#L131" rel="noopener ugc nofollow" target="_blank"> MoreElements.asType </a>)。对它的调用通常类似于:</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="b441" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">我们将所有这些调用转移到<a class="ae ix" href="https://kotlinlang.org/docs/whatsnew13.html#contracts" rel="noopener ugc nofollow" target="_blank"> Kotlin契约</a>中，这样就足以编写:</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="240c" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">另一个很好的例子是在<code class="du kk kl km kn b">TypeElement</code>中寻找方法。通常在JavaAP中，你需要调用<code class="du kk kl km kn b"><a class="ae ix" href="https://docs.oracle.com/javase/7/docs/api/javax/lang/model/util/ElementFilter.html" rel="noopener ugc nofollow" target="_blank">ElementFilter</a></code>类来获得<code class="du kk kl km kn b">TypeElement</code>中的方法。相反，我们在<code class="du kk kl km kn b">XTypeElement</code>中把它变成了一个属性。</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="f247" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">最后一个例子，也许是我最喜欢的一个，是可分配性。在JavaAP中，如果你想检查一个给定的<code class="du kk kl km kn b">TypeMirror</code>是否可以从另一个<code class="du kk kl km kn b">TypeMirror</code>赋值，你需要调用<code class="du kk kl km kn b"><a class="ae ix" href="https://docs.oracle.com/javase/8/docs/api/javax/lang/model/util/Types.html#isAssignable-javax.lang.model.type.TypeMirror-javax.lang.model.type.TypeMirror-" rel="noopener ugc nofollow" target="_blank">Types.isAssignable</a></code>。</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="0c83" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">这段代码真的很难读，因为你甚至无法猜测它是否验证了<code class="du kk kl km kn b">type1</code>可以从<code class="du kk kl km kn b">type2</code>赋值，或者相反。我们已经有了一个类似如下的扩展函数:</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="b803" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">在X-Processing中，我们能够将它转换成<code class="du kk kl km kn b">XType</code>上的一个常规函数，看起来很简单:</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="452c" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja ht">为X处理实现KSP后端</strong></p><p id="313f" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">每个X处理接口都有自己的测试套件。我们没有编写它们来测试<a class="ae ix" href="https://github.com/google/auto/tree/master/common" rel="noopener ugc nofollow" target="_blank"> AutoCommon </a>或JavaAP。相反，它们是这样编写的，一旦我们有了它们的KSP实现，我们就可以运行测试套件来验证它是否符合Room的期望。</p><p id="6636" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">由于最初的X处理API是在<code class="du kk kl km kn b">javax.lang.model</code>之后建模的，它们并不总是适合KSP，所以我们也改进了API以在需要时提供更好的Kotlin支持。</p><p id="3399" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">这也提出了一个新问题。现有的房间代码库编写了处理Java源代码。当应用程序用Kotlin编写时，Room只知道Kotlin在Java存根中的样子。我们决定在X处理的KSP实现中保持它的相似性。</p><p id="1589" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">例如，Kotlin中的<code class="du kk kl km kn b">suspend</code>函数在编译时具有以下签名:</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="963d" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">为了保持相同的行为，<code class="du kk kl km kn b">XMethodElement</code>KSP的实现为suspend方法合成了一个新的参数，以及新的返回类型。(<code class="du kk kl km kn b"><a class="ae ix" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:room/room-compiler-processing/src/main/java/androidx/room/compiler/processing/ksp/KspMethodElement.kt;l=108?q=KspSuspendMethodElement&amp;ss=androidx" rel="noopener ugc nofollow" target="_blank">KspMethodElement.kt</a></code>)</p><blockquote class="kd ke kf"><p id="27c5" class="iy iz kg ja b jb jc jd je jf jg jh ji kh jk jl jm ki jo jp jq kj js jt ju jv ha bi translated">注意，这工作得很好，因为即使在KSP，Room也会生成Java代码。当我们添加对Kotlin代码生成的支持时，这种情况可能会改变。</p></blockquote><p id="65c7" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">另一个例子是属性。一个Kotlin属性也可能有一个基于其签名的合成的<code class="du kk kl km kn b">getter/setter</code>(访问器)。<code class="du kk kl km kn b">XTypeElement</code>实现为它们合成了方法，因为Room期望将它们作为方法(<a class="ae ix" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:room/room-compiler-processing/src/main/java/androidx/room/compiler/processing/ksp/KspTypeElement.kt;l=144" rel="noopener ugc nofollow" target="_blank"> KspTypeElement.kt </a>)找到。</p><blockquote class="kd ke kf"><p id="7b26" class="iy iz kg ja b jb jc jd je jf jg jh ji kh jk jl jm ki jo jp jq kj js jt ju jv ha bi translated"><strong class="ja ht">注意:</strong>我们实际上已经计划改变<code class="du kk kl km kn b">XTypeElement</code> API来提供<code class="du kk kl km kn b">properties</code>而不是<code class="du kk kl km kn b">fields</code>，因为这是Room真正想知道的。您可能已经猜到了，我们决定“暂时”不这样做，以减少空间的变化。希望有一天我们会实现它，当我们实现的时候,<code class="du kk kl km kn b">XTypeElement</code>的JavaAP实现将改变为捆绑方法，将字段作为属性。</p></blockquote></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><p id="570b" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">在为X处理添加KSP实现时，最后一个有趣的问题是API耦合。这些处理器API频繁地相互访问，因此如果不实现<code class="du kk kl km kn b">XField</code> / <code class="du kk kl km kn b">XMethod</code>(它们本身引用<code class="du kk kl km kn b">XType</code>等)，就无法在KSP实现<code class="du kk kl km kn b">XTypeElement</code>。在添加这些KSP实现时，我们为它们的实现部分编写了单独的测试。当KSP的实现变得更加完整时，我们逐渐启用了KSP后端的所有X处理测试。</p><p id="b8cd" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">请注意，我们在这个阶段只在X-Processing项目中运行测试，所以即使我们知道我们测试的是好的，我们也不知道是否所有的Room测试都会通过(称之为单元与集成测试:)。我们需要一种用KSP后端运行所有房间测试的方法。而这就是“X处理-测试”神器诞生的时候。</p><p id="5cdd" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja ht">满足:</strong><a class="ae ix" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:room/room-compiler-processing-testing/" rel="noopener ugc nofollow" target="_blank"><strong class="ja ht">X-处理-测试</strong> </a></p><p id="dd83" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">编写注释处理器20%是处理器代码，80%是测试代码。您需要考虑各种可能的开发人员错误，并确保报告适当的错误消息。为了编写这些测试，Room已经有了一个如下所示的helper方法:</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="5ed8" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">在幕后，<code class="du kk kl km kn b">runTest</code>使用了<a class="ae ix" href="https://github.com/google/compile-testing" rel="noopener ugc nofollow" target="_blank"> Google编译测试</a>库，并允许我们简单地进行单元测试<code class="du kk kl km kn b">Processors</code>。它合成了一个Java注释处理器，并在其中调用给定的<code class="du kk kl km kn b">process</code>方法。</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="8d17" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">遗憾的是，Google编译测试只支持Java源代码。为了测试Kotlin，我们需要另一个库，幸运的是有<a class="ae ix" href="https://github.com/tschuchortdev/kotlin-compile-testing" rel="noopener ugc nofollow" target="_blank"> Kotlin编译测试</a>。它确实允许我们编写针对Kotlin的测试，并且我们已经向该库提供了KSP支持。</p><blockquote class="kd ke kf"><p id="56a9" class="iy iz kg ja b jb jc jd je jf jg jh ji kh jk jl jm ki jo jp jq kj js jt ju jv ha bi translated"><strong class="ja ht">注意:</strong>我们后来用一个<a class="ae ix" href="https://android-review.googlesource.com/c/platform/frameworks/support/+/1779266" rel="noopener ugc nofollow" target="_blank">内部实现</a>替换了Kotlin编译测试，以简化AndroidX Repo中的Kotlin/KSP更新。我们还添加了更好的断言API，这将需要针对KCT进行突破性的API更改。</p></blockquote><p id="2fb3" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">作为能够使用KSP运行所有测试的最后一步，我们创建了以下测试API:</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="ca23" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">这个版本和最初版本的主要区别在于，它同时用KSP和JavaAP(或者KAPT，取决于来源)运行测试。因为它多次运行测试，所以它不能返回一个结果，因为KSP和JavaAP之间的断言可能不同。</p><p id="48e4" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">相反，我们想到了:</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="31b6" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">每次编译后，它调用结果断言(如果没有失败断言，检查编译是否成功)。我们重构了每个房间测试，看起来像:</p><figure class="ko kp kq kr fd hj"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="887f" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">剩下的很简单。将每个房间编译测试迁移到新的API，发现新的KSP / X处理错误，报告，实施解决方案；冲洗并重复。由于KSP处于繁重的开发中，我们确实遇到了相当多的错误。每一次，我们都报告这个错误，从Room source链接到它，然后继续前进(或者贡献一个补丁)。每次KSP发布后，我们都会在代码库中搜索已修复的问题，并移除变通方法/已启用的测试。</p><p id="e60e" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">一旦我们在编译测试中获得了良好的覆盖，下一步也是运行Room的与KSP的<a class="ae ix" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:room/integration-tests/" rel="noopener ugc nofollow" target="_blank">集成测试</a>。这些是实际的Android测试应用程序，也测试运行时的行为。幸运的是，Android支持Gradle变体，所以在KSP和KAPT运行我们的<a class="ae ix" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:room/integration-tests/kotlintestapp/build.gradle" rel="noopener ugc nofollow" target="_blank"> Kotlin集成测试</a>相当容易。</p><p id="f78e" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja ht">接下来是什么？</strong></p><p id="2a5a" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">为Room添加KSP支持只是第一步。现在，我们需要更新空间来利用它。例如，房间中的所有类型检查都忽略了<code class="du kk kl km kn b">nullability</code>，因为<code class="du kk kl km kn b">javax.lang.model</code>的<code class="du kk kl km kn b">TypeMirror</code>不理解<code class="du kk kl km kn b">nullability</code>。因此，当调用Kotlin代码时，Room有时会在运行时触发<code class="du kk kl km kn b">NullPointerException</code>。有了KSP，这些检查现在可以在房间里产生新的KSP错误(例如<a class="ae ix" href="https://issuetracker.google.com/issues/193437407" rel="noopener ugc nofollow" target="_blank"> b/193437407 </a>)。我们添加了一些变通办法，但理想情况下，我们希望<a class="ae ix" href="https://android-review.googlesource.com/c/platform/frameworks/support/+/1844471" rel="noopener ugc nofollow" target="_blank">改善</a>空间，以正确处理这些情况。</p><p id="ec2f" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">类似地，即使我们支持KSP，Room仍然只生成Java代码。这个限制阻止我们添加对某些Kotlin特性的支持，比如<a class="ae ix" href="https://kotlinlang.org/docs/inline-classes.html" rel="noopener ugc nofollow" target="_blank">值类</a>。希望在未来，我们将增加对生成Kotlin代码的支持，并在Room中为Kotlin提供一流的支持。然后，可能更多:)。</p><p id="c208" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja ht">我可以在我的项目中使用X处理吗？</strong></p><p id="14e9" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">嗯，不尽然；至少不像使用其他任何Jetpack库那样。如前所述，我们只实现了房间需要的东西。编写一个真正的Jetpack库有很大的开销，比如文档、API稳定性、Codelabs等等，而我们并没有做这些工作。话虽如此，Dagger和Airbnb ( <a class="ae ix" href="https://github.com/airbnb/paris" rel="noopener ugc nofollow" target="_blank"> Paris </a>，<a class="ae ix" href="https://github.com/airbnb/DeepLinkDispatch" rel="noopener ugc nofollow" target="_blank"> DeeplinkDispatch </a>)都开始使用X-Processing来支持KSP(并贡献他们需要的东西🙏).也许有一天我们会把它从房间里分离出来。从技术上来说，你仍然可以像在<a class="ae ix" href="https://maven.google.com/web/index.html#androidx.room" rel="noopener ugc nofollow" target="_blank">谷歌的Maven仓库</a>中的工件一样使用它，但是没有API保证你一定要<a class="ae ix" href="https://github.com/johnrengelman/shadow" rel="noopener ugc nofollow" target="_blank">遮蔽</a>它。</p></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><p id="807a" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja ht">TL；dr；</strong></p><p id="f649" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">我们为Room添加了KSP支持，尽管这并不容易，但绝对值得。如果您维护一个注释处理器，请添加对KSP的支持，以提供更好的Kotlin开发人员体验。</p><p id="6f1f" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">特别感谢<a class="ku kv ge" href="https://medium.com/u/2de084182d58?source=post_page-----24808528a28e--------------------------------" rel="noopener" target="_blank"> Zac Sweers </a>和<a class="ku kv ge" href="https://medium.com/u/9f3427a69792?source=post_page-----24808528a28e--------------------------------" rel="noopener" target="_blank"> Eli Hart </a>审阅了这篇文章的早期版本，他们也是了不起的KSP贡献者。</p></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><p id="33e2" class="pw-post-body-paragraph iy iz hs ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja ht">资源:</strong></p><ul class=""><li id="f344" class="kw kx hs ja b jb jc jf jg jj ky jn kz jr la jv lb lc ld le bi translated"><a class="ae ix" href="https://issuetracker.google.com/issues/160322705" rel="noopener ugc nofollow" target="_blank">为会议室的KSP支持发布跟踪器</a>(您可以在这里找到提交的链接)</li><li id="92c5" class="kw kx hs ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le bi translated"><a class="ae ix" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:room/room-compiler-processing/" rel="noopener ugc nofollow" target="_blank">X-加工</a>和<a class="ae ix" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:room/room-compiler-processing-testing/" rel="noopener ugc nofollow" target="_blank">X-加工-测试</a>源代码</li><li id="dd2c" class="kw kx hs ja b jb lf jf lg jj lh jn li jr lj jv lb lc ld le bi translated"><a class="ae ix" href="https://github.com/google/ksp" rel="noopener ugc nofollow" target="_blank"> KSP源代码</a></li></ul></div></div>    
</body>
</html>