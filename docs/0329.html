<html>
<head>
<title>Loaders in Support Library 27.1.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">支持库27.1.0中的加载程序</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/loaders-in-support-library-27-1-0-b1a1f0fee638?source=collection_archive---------2-----------------------#2018-02-27">https://medium.com/androiddevelopers/loaders-in-support-library-27-1-0-b1a1f0fee638?source=collection_archive---------2-----------------------#2018-02-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4082" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于<a class="ae jc" href="https://developer.android.com/topic/libraries/support-library/revisions.html#27-1-0" rel="noopener ugc nofollow" target="_blank">支持库27.1.0 </a>，我重写了<code class="du jd je jf jg b"><a class="ae jc" href="https://developer.android.com/reference/android/support/v4/app/LoaderManager.html" rel="noopener ugc nofollow" target="_blank">LoaderManager</a></code>的内部，驱动<a class="ae jc" href="https://developer.android.com/guide/components/loaders.html" rel="noopener ugc nofollow" target="_blank">加载器API </a>的类，我想解释这些变化背后的原因以及未来会发生什么。</p><h2 id="aadf" class="jh ji hh bd jj jk jl jm jn jo jp jq jr ip js jt ju it jv jw jx ix jy jz ka kb bi translated">装载机和碎片，历史</h2><p id="1fdb" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">从一开始，装载器和碎片就紧密地联系在一起。这意味着<code class="du jd je jf jg b"><a class="ae jc" href="https://developer.android.com/reference/android/support/v4/app/FragmentActivity.html" rel="noopener ugc nofollow" target="_blank">FragmentActivity</a></code>和<code class="du jd je jf jg b"><a class="ae jc" href="https://developer.android.com/reference/android/support/v4/app/Fragment.html" rel="noopener ugc nofollow" target="_blank">Fragment</a></code>中的许多代码都是为了支持加载器，尽管事实上它们确实是相当独立的。这也意味着，与活动、片段和架构组件<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/lifecycle.html" rel="noopener ugc nofollow" target="_blank">生命周期</a>相比，加载器的生命周期和保证是完全独特的，并且受制于它们自己的一套有趣和令人兴奋的行为差异和缺陷。</p><h2 id="6fb1" class="jh ji hh bd jj jk jl jm jn jo jp jq jr ip js jt ju it jv jw jx ix jy jz ka kb bi translated">27.1.0中有什么变化</h2><p id="28ff" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">有了27.1.0，加载器的技术负担已经大大减少:实现<code class="du jd je jf jg b">LoaderManager</code>所需的代码行减少到原来的三分之一，并且有更多的测试要回填，以确保加载器在前进中保持良好的状态。</p><p id="5a15" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这在很大程度上要归功于架构组件。更具体地说，<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" rel="noopener ugc nofollow" target="_blank"> ViewModels </a>(用于跨配置更改保留状态)和<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/livedata.html" rel="noopener ugc nofollow" target="_blank"> LiveData </a>(用于提供生命周期感知回调)。装载机现在受益于这些同样更高水平、经过良好测试的组件作为基础，减少了持续的位损坏，并允许在可靠性/保证方面的改进自动传播到装载机。</p><h2 id="a623" class="jh ji hh bd jj jk jl jm jn jo jp jq jr ip js jt ju it jv jw jx ix jy jz ka kb bi translated">行为改变</h2><p id="a99b" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">这确实意味着一些行为上的改变。</p><p id="8a7f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，现在必须在主线程上调用<code class="du jd je jf jg b"><a class="ae jc" href="https://developer.android.com/reference/android/support/v4/app/LoaderManager.html#initLoader(int, android.os.Bundle, android.support.v4.app.LoaderManager.LoaderCallbacks&lt;D&gt;)" rel="noopener ugc nofollow" target="_blank">initLoader</a></code>、<code class="du jd je jf jg b"><a class="ae jc" href="https://developer.android.com/reference/android/support/v4/app/LoaderManager.html#restartLoader(int, android.os.Bundle, android.support.v4.app.LoaderManager.LoaderCallbacks&lt;D&gt;)" rel="noopener ugc nofollow" target="_blank">restartLoader</a></code>和<code class="du jd je jf jg b"><a class="ae jc" href="https://developer.android.com/reference/android/support/v4/app/LoaderManager.html#destroyLoader(int)" rel="noopener ugc nofollow" target="_blank">destroyLoader</a></code>。这为回调何时停止或开始提供了一些非常具体的保证——例如，在销毁一个加载程序后，您将永远不会得到对<code class="du jd je jf jg b"><a class="ae jc" href="https://developer.android.com/reference/android/support/v4/app/LoaderManager.LoaderCallbacks.html#onLoadFinished(android.support.v4.content.Loader&lt;D&gt;, D)" rel="noopener ugc nofollow" target="_blank">onLoadFinished</a></code>的回调。</p><blockquote class="kh ki kj"><p id="debb" class="ie if kk ig b ih ii ij ik il im in io kl iq ir is km iu iv iw kn iy iz ja jb ha bi translated">注意:虽然在这个版本之前，技术上你可以在其他线程上进行加载操作，但是<code class="du jd je jf jg b">LoaderManager</code>从来都不是线程安全的，导致经常出现未定义的行为。</p></blockquote><p id="27d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最重要的是，<code class="du jd je jf jg b"><a class="ae jc" href="https://developer.android.com/reference/android/support/v4/app/LoaderManager.LoaderCallbacks.html#onLoadFinished(android.support.v4.content.Loader&lt;D&gt;, D)" rel="noopener ugc nofollow" target="_blank">onLoadFinished</a></code>现在遵循与LiveData观察者相同的规则来决定何时被调用——总是在<code class="du jd je jf jg b">onStart</code>和<code class="du jd je jf jg b">onStop</code>之间，从不在<code class="du jd je jf jg b">onSaveInstanceState</code>之后。这允许您在<code class="du jd je jf jg b">onLoadFinished</code>中安全地执行<a class="ae jc" href="https://developer.android.com/guide/components/fragments.html#Transactions" rel="noopener ugc nofollow" target="_blank">片段事务</a>。</p><h2 id="fad0" class="jh ji hh bd jj jk jl jm jn jo jp jq jr ip js jt ju it jv jw jx ix jy jz ka kb bi translated">我应该使用什么，装载机要去哪里？</h2><p id="5265" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">正如我在以前的博客文章中提到的，<a class="ae jc" rel="noopener" href="/google-developers/lifecycle-aware-data-loading-with-android-architecture-components-f95484159de4"> <em class="kk">使用架构组件加载生命周期感知数据</em> </a>，我觉得ViewModels+LiveData绝对是一个更灵活、更易于理解的系统，我强烈推荐给开发人员。但是，如果您已经有了围绕加载器构建的API，这些变化应该会极大地提高组件的可靠性和稳定性。</p><p id="e558" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里的许多变化为使加载器成为一个更加可选的依赖项打下了基础，它不需要深入到<a class="ae jc" href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner.html" rel="noopener ugc nofollow" target="_blank">生命周期所有者</a> / <a class="ae jc" href="https://developer.android.com/reference/android/arch/lifecycle/ViewModelStoreOwner.html" rel="noopener ugc nofollow" target="_blank">视图模型存储所有者</a>中就能运行。</p><h2 id="dbff" class="jh ji hh bd jj jk jl jm jn jo jp jq jr ip js jt ju it jv jw jx ix jy jz ka kb bi translated">试试吧！</h2><p id="7931" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">如果您正在使用加载器，请尽早仔细查看，并注意在<a class="ae jc" href="https://developer.android.com/topic/libraries/support-library/revisions.html#27-1-0" rel="noopener ugc nofollow" target="_blank">发行说明</a>中列出的行为变化。</p><blockquote class="kh ki kj"><p id="12f1" class="ie if kk ig b ih ii ij ik il im in io kl iq ir is km iu iv iw kn iy iz ja jb ha bi translated">注意:显然，这些更改只适用于支持库加载器。如果您正在使用Android框架加载器，请尽快切换到支持库加载器。没有为框架加载器API计划错误修复或改进。</p></blockquote></div></div>    
</body>
</html>