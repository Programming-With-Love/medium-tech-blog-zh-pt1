<html>
<head>
<title>Performance Considerations for Memory Leaks: An Android Cookbook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内存泄漏的性能考虑:Android食谱</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/performance-considerations-for-memory-leaks-an-android-cookbook-4de35f240292?source=collection_archive---------0-----------------------#2022-07-05">https://medium.com/google-developer-experts/performance-considerations-for-memory-leaks-an-android-cookbook-4de35f240292?source=collection_archive---------0-----------------------#2022-07-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="4c3e" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">基于“用Android编程Kotlin:用Android编程Kotlin”的快速参考指南<em class="iw"/></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/a6bf23fc15f9ba109c3dae7f6060f250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*80DMzAO9Ukgc6us4.jpg"/></div></div></figure><p id="1d24" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在野外，Android面临着影响性能和电池寿命的现实挑战。例如，并不是每个人的移动计划中都有无限的数据，或者可靠的连接。Android应用程序必须相互竞争有限的资源。</p><p id="6dae" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">性能考虑允许您检查可能影响应用程序伸缩能力的问题。如果您可以在代码库中使用这些策略中的任何一种作为“易得之果”,那么非常值得进行一些简单的改进，从而大大减少整体内存消耗。</p><p id="a8c0" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在以下情况下会发生内存泄漏:</p><ul class=""><li id="84e1" class="kf kg hh jl b jm jn jp jq js kh jw ki ka kj ke kk kl km kn bi translated">当堆占用分配的内存<strong class="jl hi">的时间比需要的时间</strong>长时</li><li id="0a16" class="kf kg hh jl b jm ko jp kp js kq jw kr ka ks ke kk kl km kn bi translated">当一个对象在内存中被分配，但是对于正在运行的程序来说<strong class="jl hi">是不可到达的</strong></li></ul><p id="64c1" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">内存泄漏可以在应用程序代码、依赖项、Android操作系统甚至JVM中找到。很难提供Android中可能的内存泄漏的详尽列表，但显示广泛的范围可以帮助我们更好地描述内存泄漏的情况(以及快速改进/修复)。</p><h1 id="3c56" class="kt ku hh bd kv kw kx ky kz la lb lc ld in le io lf iq lg ir lh it li iu lj lk bi translated">Android组件和冲突的生命周期</h1><p id="6689" class="pw-post-body-paragraph jj jk hh jl b jm ll ii jo jp lm il jr js ln ju jv jw lo jy jz ka lp kc kd ke ha bi translated">Android由一个运行组件库组成。<a class="ae lq" href="https://developer.android.com/guide/components/fundamentals#Components" rel="noopener ugc nofollow" target="_blank"> Android应用程序组件</a>每个都有自己的生命周期，由Android框架创建、管理和销毁，而不是由应用程序代码创建、管理和销毁。这使得Android操作系统与其他操作系统的工作方式不同，也使得Android中的内存泄漏如此…..很特别。下面是相关示例以及如何处理这些示例的快速记分卡:</p><pre class="iy iz ja jb fd lr ls lt lu aw lv bi"><span id="027e" class="lw ku hh ls b fi lx ly l lz ma"><strong class="ls hi">1. Statically-saved Android UI components </strong>→ remove<br/><strong class="ls hi">2. Android UI interaction/DI within non-Android classes</strong> → remove<br/><strong class="ls hi">3. Playing with Bitmaps </strong>→ reduce, reuse, recycle!</span></pre><h2 id="7355" class="lw ku hh bd kv mb mc md kz me mf mg ld js mh mi lf jw mj mk lh ka ml mm lj mn bi translated"><strong class="ak"> 1。静态保存的Android UI组件</strong> →移除</h2><p id="d8c2" class="pw-post-body-paragraph jj jk hh jl b jm ll ii jo jp lm il jr js ln ju jv jw lo jy jz ka lp kc kd ke ha bi translated">静态保存的引用被永久存储在JVM中，这意味着在应用程序的整个生命周期中，它不会被垃圾收集。避免在Java中使用静态关键字或者在Kotlin的伴随对象中意外保存Android <code class="du mo mp mq ls b">Activity</code> / <code class="du mo mp mq ls b">View</code>。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="1396" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">Android中的一个<code class="du mo mp mq ls b">View</code>通过<code class="du mo mp mq ls b">getContext()</code>隐式引用了与之关联的<code class="du mo mp mq ls b">Activity</code>，并且也能够引用它自己的子节点。如果任何对象在被销毁时碰巧持有对一个<code class="du mo mp mq ls b">Activity</code>、它的<code class="du mo mp mq ls b">Context</code>或它的任何视图的引用，那么<code class="du mo mp mq ls b">Activity</code>将连同它的整个<code class="du mo mp mq ls b">View</code>树一起泄漏。大泄漏。</p><p id="ecf5" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">所以去掉那些对UI组件的静态引用！</p><h2 id="2744" class="lw ku hh bd kv mb mc md kz me mf mg ld js mh mi lf jw mj mk lh ka ml mm lj mn bi translated"><strong class="ak"> 2。来自非Android类的Android UI交互/DI</strong>→移除</h2><p id="e954" class="pw-post-body-paragraph jj jk hh jl b jm ll ii jo jp lm il jr js ln ju jv jw lo jy jz ka lp kc kd ke ha bi translated">开发人员通常会在非组件类中注入Android组件。然而，这样做的问题是，这也要求开发人员试图自己管理Android组件的生命周期。这并不是不可能做到，更多的是考虑到生命周期中所有可能的情况是非常困难的。这也包括Android Jetpack组件，如<code class="du mo mp mq ls b">Navigation</code>和<code class="du mo mp mq ls b">Composable</code>视图！</p><p id="52b3" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">只在Android组件类中保留Android组件和交互:这样，处理生命周期问题就不是你工作的一部分了。</p><p id="9de9" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">一个常见的错误——永远不要将an <code class="du mo mp mq ls b">Activity</code> / <code class="du mo mp mq ls b">Fragment</code>(或其<code class="du mo mp mq ls b">Context</code>)直接注入到您的presenter类中！</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="c73d" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">使用一个接口绑定到相关的<code class="du mo mp mq ls b">Activity</code> / <code class="du mo mp mq ls b">Fragment</code>就是我们如何发送一个回调来更新UI，同时将UI交互的责任保留在<code class="du mo mp mq ls b">Activity</code> / <code class="du mo mp mq ls b">Fragment</code>中。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="fe8c" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">业务逻辑旨在保持状态，即使在活动本身死亡之后…但仅仅是状态！</p><h2 id="800a" class="lw ku hh bd kv mb mc md kz me mf mg ld js mh mi lf jw mj mk lh ka ml mm lj mn bi translated">3.玩位图→减量化，再利用，再循环！</h2><p id="dc6d" class="pw-post-body-paragraph jj jk hh jl b jm ll ii jo jp lm il jr js ln ju jv jw lo jy jz ka lp kc kd ke ha bi translated">位图很容易耗尽应用程序的内存预算。例如，Pixel手机上的摄像头拍摄的照片高达4048 x 3036像素(1200万像素)。如果使用的位图配置是<code class="du mo mp mq ls b">ARGB_8888</code>，从内存中解压缩和加载一张照片需要大约48MB内存(4048 x 3036 x 4字节)。如此大的内存需求会立即耗尽应用程序的所有可用内存，这对用户没有好处！</p><p id="e86c" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">这就是为什么尽可能减少、重复使用和回收位图是很重要的。降低你的图像质量如果你把它作为一个小的AVI，缓存和重复使用已经绘制好的位图。</p><p id="46d9" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">位图不仅是可能消耗的主要来源，而且如果你忘记回收，它们也是可能的内存泄漏的来源。</p><p id="81f7" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">当不再使用位图时，使用<code class="du mo mp mq ls b">bitmap.recycle()</code>来回收内存。如果你的应用程序显示大量的位图数据，很可能会遇到<code class="du mo mp mq ls b"><a class="ae lq" href="https://developer.android.com/reference/java/lang/OutOfMemoryError" rel="noopener ugc nofollow" target="_blank">OutOfMemoryError</a></code>。<code class="du mo mp mq ls b"><a class="ae lq" href="https://developer.android.com/reference/android/graphics/Bitmap#recycle()" rel="noopener ugc nofollow" target="_blank">recycle()</a></code>方法帮助应用程序尽快回收内存。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mr ms l"/></div></figure><h1 id="a67e" class="kt ku hh bd kv kw kx ky kz la lb lc ld in le io lf iq lg ir lh it li iu lj lk bi translated">冲突的生命周期…但是使用线程:(</h1><p id="0182" class="pw-post-body-paragraph jj jk hh jl b jm ll ii jo jp lm il jr js ln ju jv jw lo jy jz ka lp kc kd ke ha bi translated">使用线程已经很复杂了，需要理解线程安全规则。一个线程有自己的生命周期，独立于任何Android组件的生命周期:一个线程启动，做一些工作，当工作完成时，线程死亡。如果工作没有完成/取消，那么线程就不能死。</p><p id="010b" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">下面是并发内存泄漏的可能来源以及如何处理它们的快速记分卡示例:</p><pre class="iy iz ja jb fd lr ls lt lu aw lv bi"><span id="7463" class="lw ku hh ls b fi lx ly l lz ma"><strong class="ls hi">4. Android UI references in background threads</strong> <!-- -->→<!-- --> remove<strong class="ls hi"><br/>5. Non-static inner classes within Views/Activities</strong> <!-- -->→<!-- --> remove</span></pre><h2 id="9686" class="lw ku hh bd kv mb mc md kz me mf mg ld js mh mi lf jw mj mk lh ka ml mm lj mn bi translated">4.后台线程中的Android UI引用→移除</h2><p id="1fdc" class="pw-post-body-paragraph jj jk hh jl b jm ll ii jo jp lm il jr js ln ju jv jw lo jy jz ka lp kc kd ke ha bi translated">假设创建了一个工作线程，它在活动本身创建后不久就在后台线程中保存了对某个活动的引用。在Android内存管理中，每个线程都由堆中的“区域”来表示。没有一个区域可以访问另一个“区域”中的对象。</p><p id="605d" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">当用户运行应用程序并旋转设备时，活动被破坏。从活动创建的工作线程将继续运行，直到其工作完成。不幸的是，这项工作永远不会完成，这是由于最近无法访问对先前活动实例的引用。</p><p id="d564" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">GC可能无法处理死的活动引用，更糟糕的是:当线程结束时，它试图更新对活动的引用，但没有什么可更新的，导致应用程序崩溃。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/dce0d985d3743dfb1771cba5e0bd9e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTUbPIzsjMEfVcaO0ZTn-w.png"/></div></div></figure><p id="7df7" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">所以Android UI组件不是线程安全的。可以终止一个活动，但这不一定会终止一个后台线程。由于这种易变的复杂性，内存泄漏是可能的，因为组件的任何实例都很容易变成死负载。</p><p id="c27e" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我们应该如何从线程工作中更新UI？这里的技巧是强制顶级活动或片段成为负责更新UI对象的唯一系统。</p><p id="29ef" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">开发人员有责任确保繁重的工作被发送到后台线程。如果UI必须更新，那么在更新UI之前，结果被返回给主线程<em class="mu">。</em></p><h2 id="fb5a" class="lw ku hh bd kv mb mc md kz me mf mg ld js mh mi lf jw mj mk lh ka ml mm lj mn bi translated">5.视图/活动中的非静态内部类→删除</h2><p id="97d1" class="pw-post-body-paragraph jj jk hh jl b jm ll ii jo jp lm il jr js ln ju jv jw lo jy jz ka lp kc kd ke ha bi translated">内的内部类保存对封闭类的隐式引用，直到对象被销毁。这是一个棘手且常见的内存泄漏源，尤其是在线程方面:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="055e" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">如果<code class="du mo mp mq ls b">TileImageView</code>的实例被破坏，一个隐式引用将被任何一个保持<code class="du mo mp mq ls b">TileImageLoadedCallback</code>存活的线程所劫持。</p><p id="c168" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">用<code class="du mo mp mq ls b">static</code>关键字<em class="mu">标记内部类可能是</em>的一种解决方案，因为静态类在没有显式引用的情况下可能不会引用包含类的成员，并且被认为是顶级声明。</p><p id="715c" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">这个问题也可以通过传递如下所示的侦听器模式来解决:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mr ms l"/></div></figure><p id="88fd" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">现在我们传递一个监听器来触发<code class="du mo mp mq ls b">onSuccess</code>调用，这个调用现在在它的父类中实现。当<code class="du mo mp mq ls b">onSuccess</code>启动一个新线程时，它不再持有对父类的隐式引用(在本例中是<code class="du mo mp mq ls b">MapTileActivity</code>)。</p><p id="963e" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">您在代码库中发现了这些简单的变化吗？如果是这样，您可以通过使用Android studio中的内存分析器进行<code class="du mo mp mq ls b">.hprof</code>记录来修复您自己的内存泄漏并检查内存消耗的差异！您还可以导入您的<code class="du mo mp mq ls b">.hprof</code>记录，以便使用Eclipse的<a class="ae lq" href="https://www.eclipse.org/mat/" rel="noopener ugc nofollow" target="_blank">内存分析器</a>更深入地研究，或者使用其他开源性能工具，例如<a class="ae lq" href="https://perfetto.dev/" rel="noopener ugc nofollow" target="_blank"> Perfetto </a>。</p><h1 id="5a95" class="kt ku hh bd kv kw kx ky kz la lb lc ld in le io lf iq lg ir lh it li iu lj lk bi translated">我如何发现Android中其他类型的内存泄漏？</h1><p id="99b3" class="pw-post-body-paragraph jj jk hh jl b jm ll ii jo jp lm il jr js ln ju jv jw lo jy jz ka lp kc kd ke ha bi translated">你需要两件事:1)内存分析，2)深入了解Android组件生命周期和内存管理。如果你喜欢这篇文章，你可以在新出版的<a class="ae lq" href="https://www.oreilly.com/library/view/programming-android-with/9781492062998/" rel="noopener ugc nofollow" target="_blank"> <em class="mu">用Kotlin编程Android:用协程</em> </a> <em class="mu">实现结构化并发中找到更多关于Android性能和内存管理的深入考虑。</em></p><p id="d5ee" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">你也可以看看这个迷你系列的<a class="ae lq" href="https://hinchman-amanda.medium.com/performance-considerations-for-memory-leaks-an-android-cookbook-part-2-b797a6e6b6e2" rel="noopener">第二部分</a>来看看另一组快速的低投入大回报的胜利！</p></div></div>    
</body>
</html>