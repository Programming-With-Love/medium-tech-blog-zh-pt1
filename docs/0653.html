<html>
<head>
<title>Animations in Navigation Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">导航合成中的动画</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/animations-in-navigation-compose-36d48870776b?source=collection_archive---------0-----------------------#2021-08-04">https://medium.com/androiddevelopers/animations-in-navigation-compose-36d48870776b?source=collection_archive---------0-----------------------#2021-08-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/a20f2587a3ebee85850b5a77818aa2e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DlSgi-8GaQdn8E13nilcbw.png"/></div></div></figure><div class=""/><p id="7ac6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Jetpack Compose将动画的标准从“波兰，如果我们有时间”提高到“如此简单，没有理由不做”，其中很大一部分是屏幕级别的过渡。这就是为什么<a class="ae jn" href="https://developer.android.com/jetpack/compose/navigation" rel="noopener ugc nofollow" target="_blank">导航组合</a>一直致力于开发一套解决三种特定情况的解决方案:</p><ul class=""><li id="8a2c" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">在Compose 1.0.0中仅使用稳定的动画API</li><li id="6493" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">启用Compose 1.0.0中的实验动画API支持</li><li id="40a9" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">构建面向未来的动画API(共享元素转换！！！)在Compose 1.1.0及更高版本中</li></ul><p id="2ad8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每一个都需要稍微不同的方法，我们将在这里讨论。</p><h1 id="31b3" class="kc kd hs bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">构成💚动画片</h1><p id="04f6" class="pw-post-body-paragraph ip iq hs ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">从第一个0.1.0-dev01发行版到新的Compose 1.0.1发行版，Jetpack Compose走过了漫长的道路。与视图世界相比，动画和过渡是一个巨大的进步。在追求完美的动画API的过程中，Compose向1.0.0迈进时做了很多改变。</p><p id="e80e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然一些低级别的动画API，如非常强大的<code class="du lf lg lh li b">animateTo()</code>和<code class="du lf lg lh li b">animate*AsState()</code>在这一点上是稳定的，Compose的基础部分，但在标有<code class="du lf lg lh li b">@ExperimentalAnimationApi</code>的构建块之上还有一整类API。</p><h1 id="ba0f" class="kc kd hs bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">实验性API和语义版本控制</h1><p id="3b8b" class="pw-post-body-paragraph ip iq hs ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">一个实验性的API(在Kotlin land使用<code class="du lf lg lh li b">@RequiresOptIn</code> API的任何API)意味着这些API随时都可能发生变化。这意味着这些API可能会在任何未来的版本中被更改、改进或替换——可能是Compose 1.1.0-alpha04或1.2.0-alpha08。因此，如果您要更新您正在使用的Compose版本，而不是同时<em class="lj">和</em>更新该库，任何基于这些实验性API构建的库都会立即崩溃和失败。(如果你是早期Compose发行版的跟随者，你就会知道这种痛苦。)</p><p id="b624" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所有AndroidX库，包括导航和合成，都遵循<a class="ae jn" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">严格的语义版本</a>，正如在<a class="ae jn" href="https://developer.android.com/jetpack/androidx/versions" rel="noopener ugc nofollow" target="_blank"> AndroidX发布页面</a>上所解释的。这意味着一旦一个库进入发布候选(RC)阶段，任何非实验性的API都是一成不变的。要对这些稳定的API做出突破性的改变，需要一个主要的版本提升(即“2.0”)。</p><p id="5418" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这对于向前和向后兼容性来说非常好——例如，您可以升级您的片段版本来尝试新的alpha版本，同时保持您的其他依赖于它们的稳定版本，一切都正常工作。</p><p id="822c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，这也意味着实验性的API，即可以从你下面转移出来的API，在不同的工件组之间是严格禁止的——同样，升级你的版本<code class="du lf lg lh li b">androidx.fragment</code>不应该破坏<code class="du lf lg lh li b">androidx.appcompat</code>。这也适用于<code class="du lf lg lh li b">androidx.navigation</code>和<code class="du lf lg lh li b">androidx.compose.animation</code>。</p><h1 id="5e28" class="kc kd hs bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">让导航2.4稳定</h1><p id="3582" class="pw-post-body-paragraph ip iq hs ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">Navigation 2.4是一个大版本，它既是第一个Navigation Compose版本，也是第一个对Navigation Compose和Navigation with Fragments提供多种支持的版本。这意味着我们正在包装剩余的相关API请求，为通过beta、RC和stable做准备。</p><p id="e42a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于Navigation Compose，这意味着我们在Compose 1.0.1的基础上构建，目标是向前兼容那些想要(或者已经！)根据Compose 1.1.0-alpha01及更高版本移动到start。</p><p id="2ec6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该向前兼容性要求意味着Navigation Compose 2.4.0中的任何代码都只能依赖于稳定的合成动画API。这就是我们如何能够在<a class="ae jn" href="https://developer.android.com/jetpack/androidx/releases/navigation#2.4.0-alpha05" rel="noopener ugc nofollow" target="_blank">导航2.4.0-alpha05 </a>中添加交叉渐变支持——在作曲的世界中，跳转切换应该是你的列表中第一个要完全消除的东西。</p><p id="1e14" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种只使用稳定合成动画API的限制意味着像<code class="du lf lg lh li b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedContent(kotlin.Any,androidx.compose.ui.Modifier,kotlin.Function1,androidx.compose.ui.Alignment,kotlin.Function2)" rel="noopener ugc nofollow" target="_blank">AnimatedContent</a></code>这样的API不是导航2.4可以直接用来提供丰富的动画控制的东西，而这种控制正是你想要的导航2.4的一部分。然而，导航的可扩展本质意味着底层框架已经构建并可用。</p><h1 id="9a94" class="kc kd hs bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">简介:伴奏导航动画！</h1><p id="9248" class="pw-post-body-paragraph ip iq hs ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">这种对目的地之间动画的潜在支持是我们能够发布<a class="ae jn" href="https://google.github.io/accompanist/navigation-animation/" rel="noopener ugc nofollow" target="_blank">伴奏导航动画</a>的原因，该动画基于今天发布的<a class="ae jn" href="https://developer.android.com/jetpack/androidx/releases/navigation#2.4.0-alpha06" rel="noopener ugc nofollow" target="_blank">导航2.4.0-alpha06 </a>。导航动画构件提供了您一直在使用的导航合成API的自己的动画启用版本集:</p><ul class=""><li id="b43a" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">用<code class="du lf lg lh li b">rememberAnimatedNavController()</code>替换<code class="du lf lg lh li b">rememberNavController()</code></li><li id="de89" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">将<code class="du lf lg lh li b">NavHost</code>替换为<code class="du lf lg lh li b">AnimatedNavHost</code></li><li id="5131" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">将<code class="du lf lg lh li b">import androidx.navigation.compose.navigation</code>替换为<code class="du lf lg lh li b">import com.google.accompanist.navigation.animation.navigation</code></li><li id="ce54" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">将<code class="du lf lg lh li b">import androidx.navigation.compose.composable</code>替换为<code class="du lf lg lh li b">import com.google.accompanist.navigation.animation.composable</code></li></ul><p id="422e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">乍一看，你的应用程序的外观没有改变:默认动画仍然是导航2.4中的交叉渐变为你做的相同类型的<code class="du lf lg lh li b">fadeIn</code>和<code class="du lf lg lh li b">fadeOut</code>。然而，你将获得一个至关重要的新特性:<strong class="ir ht">能够配置那些动画，并在你自己的屏幕之间进行替换。</strong></p><p id="a099" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种控制以四种新参数的形式出现在每个可组合目标上:</p><ul class=""><li id="1461" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><code class="du lf lg lh li b">enterTransition</code>:指定当你<code class="du lf lg lh li b">navigate()</code>到这个目的地时运行的动画。</li><li id="1828" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><code class="du lf lg lh li b">exitTransition</code>:指定当您通过导航到另一个目的地而离开该目的地时运行的动画。</li><li id="9ae8" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><code class="du lf lg lh li b">popEnterTransition</code>:指定该目的地经过<code class="du lf lg lh li b">popBackStack()</code>后重新进入屏幕时运行的动画。这默认为<code class="du lf lg lh li b">enterTransition</code>。</li><li id="6c71" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><code class="du lf lg lh li b">popExitTransition</code>:指定当您将此目的地弹出后离开屏幕时运行的动画。这默认为<code class="du lf lg lh li b">exitTransition</code>。</li></ul><p id="bab9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在每种情况下，这些参数都具有相同的格式:</p><pre class="lk ll lm ln fd lo li lp lq aw lr bi"><span id="96f4" class="ls kd hs li b fi lt lu l lv lw">enterTransition: (<br/>  AnimatedContentScope&lt;NavBackStackEntry&gt;.() -&gt; EnterTransition?<br/>)? = null,</span></pre><p id="3d7d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个都需要一个λ。lambda使用<code class="du lf lg lh li b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/animation/AnimatedContentScope" rel="noopener ugc nofollow" target="_blank">AnimatedContentScope</a></code>为您提供来自哪里的<code class="du lf lg lh li b">NavBackStackEntry</code>(<code class="du lf lg lh li b">initialState</code>)和去往哪里的<code class="du lf lg lh li b">targetState</code>。例如，对于<code class="du lf lg lh li b">enterTransition</code>，进入目的地是<code class="du lf lg lh li b">targetState</code>——您正在应用<code class="du lf lg lh li b">enterTransition</code>的那个。相反的情况也适用于<code class="du lf lg lh li b">exitTransition</code>:屏幕<code class="du lf lg lh li b">initialState</code>是您应用退出过渡的屏幕。</p><p id="ae66" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这允许你写下你的目的地，例如:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="ce6a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者，根据您的来源/目的地控制您的动画:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="b09b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，朋友列表屏幕控制其从朋友列表到简档屏幕的退出转变，简档屏幕控制其从朋友列表的进入转变，允许在这两个目的地之间的定制滑动动画。我们也看到了使用<code class="du lf lg lh li b">null</code>来表示“使用默认值”。这些缺省值来自父导航图，然后是父导航图的父导航图，一直到根<code class="du lf lg lh li b">AnimatedNavHost</code>。这意味着设置默认动画(比如交叉渐变的时间)只需要改变你的<code class="du lf lg lh li b">AnimatedNavHost</code>上的全局<code class="du lf lg lh li b">enterTransition</code>和<code class="du lf lg lh li b">exitTransition</code>就可以了。</p><p id="574b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您只想更改一个子图的默认值(比如，您的登录流总是在动画中使用水平幻灯片)，您也可以在嵌套图级别上设置该动画:</p><figure class="lk ll lm ln fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="1fba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意我们如何使用<code class="du lf lg lh li b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/navigation/NavDestination#(androidx.navigation.NavDestination).hierarchy()" rel="noopener ugc nofollow" target="_blank">hierarchy</a></code> <a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/navigation/NavDestination#(androidx.navigation.NavDestination).hierarchy()" rel="noopener ugc nofollow" target="_blank">扩展方法</a>来确定目的地是否实际上是登录图的一部分——这样，我们从<em class="lj">到</em>登录图的转换和从到<em class="lj">登录图的转换就使用默认转换(或者您在更高级别设置的任何转换)。</em></p><p id="9a3d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每当你有一个方向转换，比如水平滑动，这就是<code class="du lf lg lh li b">enterTransition</code>和<code class="du lf lg lh li b">popEnterTransition</code>之间的区别变得非常方便的地方——你将能够避免一个屏幕向右滑动而另一个屏幕向左滑动的情况。</p><p id="84c1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">伴奏者是Jetpack库的助推火箭，随着Compose 1.1工作的进展，现在让我们发布实验特性<em class="lj">。</em></p><p id="b02b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过以下方式添加<a class="ae jn" href="https://google.github.io/accompanist/navigation-animation/" rel="noopener ugc nofollow" target="_blank">伴奏导航动画</a>:</p><pre class="lk ll lm ln fd lo li lp lq aw lr bi"><span id="5d48" class="ls kd hs li b fi lt lu l lv lw">implementation<br/>    "com.google.accompanist:accompanist-navigation-animation:0.16.1"</span></pre><h1 id="c8c7" class="kc kd hs bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">导航合成和动画未来</h1><p id="7a71" class="pw-post-body-paragraph ip iq hs ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">随着基于Compose 1.0.1的导航2.4和伴奏导航动画通过实验API扩展了Compose 1.0的限制，还有其他东西即将出现:Compose 1.1。查看<a class="ae jn" href="https://developer.android.com/jetpack/androidx/compose-roadmap" rel="noopener ugc nofollow" target="_blank">撰写路线图</a>，有一个真正重要的即将到来的特性令人兴奋不已:</p><blockquote class="lz"><p id="49ad" class="ma mb hs bd mc md me mf mg mh mi jm dx translated">支持共享元素转换</p></blockquote><p id="37da" class="pw-post-body-paragraph ip iq hs ir b is mj iu iv iw mk iy iz ja ml jc jd je mm jg jh ji mn jk jl jm ha bi translated">我们对导航2.5的目标是把所有的好的组合1.1带到导航组合。这意味着当动画API失去它们的实验状态时，我们可以将它们直接合并到导航组合中。这也意味着我们可以构建这样的API，我们知道它将在共享元素转换可用时支持它们。</p><p id="cd8c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这也意味着伴奏导航动画应该被视为一种临时措施:一旦导航组合本身提供了相同级别的动画API(根据您的反馈定制！)，您将能够直接依赖它，并完全删除伴奏导航动画。</p><h1 id="c747" class="kc kd hs bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">往前走，做动画</h1><p id="d648" class="pw-post-body-paragraph ip iq hs ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">平衡稳定性和我们作为Jetpack库对自己提出的向前和向后兼容性要求，以及快速发布特性的能力，意味着这并不像我们希望的那样简单。随着Jetpack Compose获得动力并加速超过对那些助推火箭的需求，伴奏已经成为一个巨大的福音。我要感谢<a class="mo mp ge" href="https://medium.com/u/9303277cb6db?source=post_page-----36d48870776b--------------------------------" rel="noopener" target="_blank"> Chris Banes </a>和所有投入时间的开发人员，Compose背后的整个团队，以及所有帮助塑造Android开发未来的人们。</p><p id="2ecd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">PS:如果你正在寻找更多的导航+伴奏的好东西，看看全新的<a class="ae jn" href="https://google.github.io/accompanist/navigation-material/" rel="noopener ugc nofollow" target="_blank">伴奏导航材料</a>！</p><div class="hg hh ez fb hi mq"><a href="https://jossiwolf.medium.com/introducing-navigation-material-%EF%B8%8F-a19ed5cc33fd" rel="noopener follow" target="_blank"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd ht fi z dy mv ea eb mw ed ef hr bi translated">介绍导航材料🧭🎨️</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">导航-撰写(嗯，有点)有一个令人兴奋的新功能:支持底部表目的地！</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">jossiwolf.medium.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ho mq"/></div></div></a></div></div></div>    
</body>
</html>