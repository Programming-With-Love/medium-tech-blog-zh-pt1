<html>
<head>
<title>Deprecation of Object.finalize()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Object.finalize()的弃用</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/deprecation-of-object-finalize-5e40022cb69?source=collection_archive---------0-----------------------#2017-04-18">https://medium.com/oracledevs/deprecation-of-object-finalize-5e40022cb69?source=collection_archive---------0-----------------------#2017-04-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="731b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Java离堆播客的第23集的第一部分介绍了Java 9中对<code class="du jd je jf jg b">Object.finalize</code>的弃用以及弃用和终结。反对是我最关心的话题。主持人甚至提到了我的名字。谢谢你们的大声呼喊，伙计们！</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/5c451a1268d2722f4f92895d076b8b30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pgkznru-839l6Ttm9zavqQ.png"/></div></div></figure><p id="cc4b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我想澄清几个观点，并回答一些在节目的这一部分没有解决的问题。</p><h1 id="15e6" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Java终结器与C++析构器</h1><p id="eec0" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">Java的终结器的角色不同于C++的析构器。在C++中(在引入像<code class="du jd je jf jg b">shared_ptr</code>这样的机制之前)，每当你在构造函数中用<code class="du jd je jf jg b">new</code>创建东西时，你都需要在析构函数中对它调用<code class="du jd je jf jg b">delete</code>。人们错误地将这种想法带到了Java，他们认为有必要编写<code class="du jd je jf jg b">finalize</code>方法来消除对其他对象的引用。(这从来就没有必要，幸运的是，这种做法似乎在很久以前就已经消失了。)在Java中，垃圾收集器会清理驻留在堆上的任何东西，因此很少需要编写终结器。</p><p id="19b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果一个对象创建了不受垃圾收集器管理的资源，那么终结器就很有用。例如文件描述符或本机分配的(“堆外”)内存。垃圾收集器不清理这些，所以其他东西必须清理。在Java的早期，终结是清理非堆资源的唯一可用机制。</p><h1 id="9690" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">幻像引用</h1><p id="19dd" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">终结的意义在于，它允许在一个对象变得不可访问之后，但在它被实际收集之前，有最后一次清理的机会。终结的一个问题是它允许对象的“复活”。当一个对象的<code class="du jd je jf jg b">finalize</code>方法被调用时，它有一个对<code class="du jd je jf jg b">this</code>的引用——即将被收集的对象。它可以将<code class="du jd je jf jg b">this</code>引用挂回到对象图中，防止对象被收集。因此，在<code class="du jd je jf jg b">finalize</code>方法返回后，对象不能简单地被收集。相反，垃圾收集器必须再次运行<em class="kw"/>以确定该对象是否真的不可到达并因此可以被收集。</p><p id="2af8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参考包<code class="du jd je jf jg b">java.lang.ref</code>在JDK 1.2中就被引入了。这个包包括几个不同的引用类型，包括<code class="du jd je jf jg b">PhantomReference</code>。<code class="du jd je jf jg b">PhantomReference</code>的显著特征是它不允许对象“复活”它通过使包含的引用不可访问来做到这一点。虚引用的持有者得到通知，被引用对象变得不可达(严格地说，<em class="kw">虚可达</em>)，但是没有办法把被引用对象取出来并把它挂回到对象图中。这使得垃圾收集器的工作更容易。</p><p id="be7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jd je jf jg b">PhantomReference</code>的另一个优点是，像其他引用类型一样，它可以被显式清除。假设有一个对象保存了一些外部资源，比如文件描述符。通常，这样的对象有一个应用程序应该调用的<code class="du jd je jf jg b">close</code>方法来释放描述符。在引入引用类型之前，这些对象还需要一个<code class="du jd je jf jg b">finalize</code>方法，以便在应用程序调用<code class="du jd je jf jg b">close</code>失败时进行清理。问题是，即使应用程序已经调用了<code class="du jd je jf jg b">close</code>，收集器也需要进行终结处理，然后再次运行<em class="kw"/>，如上所述，以便收集对象。</p><p id="4419" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jd je jf jg b">PhantomReference</code>和其他引用类型有一个<code class="du jd je jf jg b">clear</code>方法，它显式地清除包含的引用。通过对<code class="du jd je jf jg b">close</code>方法的显式调用释放其本机资源的对象将调用<code class="du jd je jf jg b">PhantomReference.clear</code>。这避免了后续的引用处理步骤，允许在对象变得不可访问时立即收集它。</p><h1 id="23dd" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">为什么现在弃用Object.finalize？</h1><p id="66fe" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">一些事情已经改变了。首先，<a class="ae jc" href="http://openjdk.java.net/jeps/277" rel="noopener ugc nofollow" target="_blank"> JEP 277 </a>已经阐明了Java 9中弃用的含义，因此它并不意味着API将被移除，除非<code class="du jd je jf jg b">forRemoval=true</code>被指定。对<code class="du jd je jf jg b">Object.finalize</code>的弃用是一种“普通”的弃用，因为它不会因为移除而被弃用。(至少，现在还没有。)</p><p id="0899" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Java 9中的第二个变化是引入了一个类<code class="du jd je jf jg b">java.lang.ref.Cleaner</code>。引用处理通常相当微妙，创建一个引用队列和一个线程来处理来自该队列的引用需要做大量的工作。<code class="du jd je jf jg b">Cleaner</code>基本上是围绕<code class="du jd je jf jg b">ReferenceQueue</code>和<code class="du jd je jf jg b">PhantomReference</code>的包装器，使得引用处理更容易。</p><p id="54b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">没有改变的是，多年来，不鼓励使用终结化一直是Java知识的一部分。是时候正式声明了，方法就是弃用。</p><h1 id="cb09" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Java SE中删除过什么吗？</h1><p id="f26a" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">播客中提到了卡梅隆·波弟写于2014年的<a class="ae jc" href="https://www.quora.com/Has-Sun-or-Oracle-ever-removed-a-deprecated-Java-method-in-an-official-API/answer/Cameron-Purdy?srid=vDdR" rel="noopener ugc nofollow" target="_blank"> Quora回答，他说没有任何东西从Java中移除。他写的时候，陈述是正确的。JDK的各种<em class="kw">特性</em>已经被移除(比如<strong class="ig hi"> apt </strong>，注释处理工具)，但是公共API从未被移除。</a></p><p id="7eab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，以下六个API在Java SE 8中已被弃用，并且已从Java SE 9中删除:</p><ol class=""><li id="a036" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated"><code class="du jd je jf jg b">java.util.jar.Pack200.Packer.addPropertyChangeListener</code></li><li id="5b93" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><code class="du jd je jf jg b">java.util.jar.Pack200.Unpacker.addPropertyChangeListener</code></li><li id="494c" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><code class="du jd je jf jg b">java.util.logging.LogManager.addPropertyChangeListener</code></li><li id="2df0" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><code class="du jd je jf jg b">java.util.jar.Pack200.Packer.removePropertyChangeListener</code></li><li id="310e" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><code class="du jd je jf jg b">java.util.jar.Pack200.Unpacker.removePropertyChangeListener</code></li><li id="d121" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><code class="du jd je jf jg b">java.util.logging.LogManager.removePropertyChangeListener</code></li></ol><p id="0461" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，在Java SE 9中，大约20个方法和6个模块已经被弃用，这表明我们打算在下一个主要的Java SE版本中删除它们。要删除的一些类和方法包括:</p><ul class=""><li id="c83c" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb ll ld le lf bi translated"><code class="du jd je jf jg b">java.lang.Compiler</code></li><li id="35aa" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb ll ld le lf bi translated"><code class="du jd je jf jg b">Thread.destroy</code></li><li id="e6a1" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb ll ld le lf bi translated"><code class="du jd je jf jg b">System.runFinalizersOnExit</code></li><li id="f021" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb ll ld le lf bi translated"><code class="du jd je jf jg b">Thread.stop(Throwable)</code></li></ul><p id="fe6d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不赞成删除的模块如下:</p><ol class=""><li id="8ddf" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated"><code class="du jd je jf jg b">java.activation</code></li><li id="e100" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><code class="du jd je jf jg b">java.corba</code></li><li id="fe64" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><code class="du jd je jf jg b">java.transaction</code></li><li id="2389" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><code class="du jd je jf jg b">java.xml.bind</code></li><li id="5873" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><code class="du jd je jf jg b">java.xml.ws</code></li><li id="abc1" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated"><code class="du jd je jf jg b">java.xml.ws.annotation</code></li></ol><p id="e5c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，是的，我们正在认真对待移除物品！</p><h1 id="5c68" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">定案会被移除吗？</h1><p id="971a" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">如前所述，<code class="du jd je jf jg b">Object.finalize</code>目前不建议删除。因此，对它的反对仅仅是建议开发人员考虑迁移到替代的清理机制。推荐替换的是<code class="du jd je jf jg b">PhantomReference</code>和新的<code class="du jd je jf jg b">Cleaner</code>级。</p><p id="e325" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">也就是说，我们最终想要摆脱终结化。它给垃圾收集器增加了额外的复杂性，并且经常会导致性能问题。</p><p id="0c89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，在我们能够摆脱它之前，我们需要从JDK中去除它的用途。这不仅仅是移除<code class="du jd je jf jg b">finalize</code>的覆盖并重写代码以使用<code class="du jd je jf jg b">Cleaner</code>来代替。问题是JDK中有一些公共API类覆盖了<code class="du jd je jf jg b">finalize</code>并指定了它的行为。反过来，<em class="kw">的子类</em>可能会覆盖<code class="du jd je jf jg b">finalize</code>并依赖于<code class="du jd je jf jg b">super.finalize()</code>的现有行为。移除<code class="du jd je jf jg b">finalize</code>方法会将这些子类暴露给潜在的不兼容的行为变化。这需要仔细调查。</p><p id="292d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可能还会有一个过渡期，在此期间对<code class="du jd je jf jg b">finalize</code>方法的调用由命令行选项控制。这将允许对应用程序进行测试，看它们是否能在没有终结的情况下处理。只有经过一段过渡期后，我们才会考虑完全取消敲定机制。出于二进制兼容性的目的，我们甚至可以保留<code class="du jd je jf jg b">finalize</code>方法声明，即使调用它的机制已经被移除。</p><p id="3792" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如你所看到的，移除终结化需要一个跨越几个JDK版本的漫长的过渡期，需要几年时间。这就更有理由开始反对了。</p></div><div class="ab cl lm ln go lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ha hb hc hd he"><p id="9005" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kw">原载于2017年4月18日</em><a class="ae jc" href="https://stuartmarks.wordpress.com/2017/04/17/deprecation-of-object-finalize/" rel="noopener ugc nofollow" target="_blank"><em class="kw">stuartmarks.wordpress.com</em></a><em class="kw">。</em></p></div></div>    
</body>
</html>