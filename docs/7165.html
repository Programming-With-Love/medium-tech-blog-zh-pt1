<html>
<head>
<title>Upgrading a Reverse Proxy from Netty 3 to 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将反向代理从Netty 3升级到4</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/upgrading-a-reverse-proxy-from-netty-3-to-4-878ec407665a?source=collection_archive---------2-----------------------#2016-08-09">https://medium.com/square-corner-blog/upgrading-a-reverse-proxy-from-netty-3-to-4-878ec407665a?source=collection_archive---------2-----------------------#2016-08-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="e7d7" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">Tracon是由Netty支持的反向HTTP代理。我们最近完成了对Netty 4的升级，希望分享我们的经验。</h2></div><p id="3bc8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由克里斯·康罗伊和马特·达文波特撰写。</p><blockquote class="js"><p id="be98" class="jt ju hh bd jv jw jx jy jz ka kb jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae kc" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><h1 id="6b82" class="kd ke hh bd kf kg kh ki kj kk kl km kn in ko io kp iq kq ir kr it ks iu kt ku bi translated">Tracon: Square的反向代理</h1><p id="863a" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">Tracon是我们的反向HTTP代理，由<a class="ae kc" href="http://netty.io/" rel="noopener ugc nofollow" target="_blank"> Netty </a>提供支持。几年前，当我们开始转向微服务架构时，我们意识到我们需要一个反向代理来协调API从我们遗留的monolith到我们快速扩展的微服务集的迁移。</p><p id="f4f3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们选择在Netty的基础上构建Tracon，是为了获得高效的性能以及进行安全和复杂定制的能力。我们还能够利用大量的共享Java代码与我们的堆栈的其余部分，以提供坚如磐石的服务发现，配置和生命周期管理，以及更多！</p><p id="a0f7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Tracon是用Netty 3写的，已经生产了三年。在其生命周期中，代码库已经增长到20，000行代码和测试。很大程度上要感谢Netty库，这个代理应用程序的核心已经被证明是如此可靠，以至于我们已经将其应用扩展到了其他应用程序中。同一个库支持我们的内部认证公司代理。Tracon与我们内部动态服务发现系统的集成将很快为Square的所有服务对服务通信提供动力。除了路由逻辑之外，我们还可以捕获大量关于流入数据中心的流量的统计数据。</p><h1 id="6cc4" class="kd ke hh bd kf kg kh ki kj kk kl km kn in la io kp iq lb ir kr it lc iu kt ku bi translated">为什么现在升级到Netty 4？</h1><p id="314b" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">Netty 4是三年前发布的。与Netty 3相比，线程和内存模型已经进行了彻底的改进，以提高性能。也许更重要的是，它还为HTTP/2提供了一流的支持。虽然我们对迁移到这个库很感兴趣，但我们已经推迟了升级，因为这是一个引入了一些重大突破性变化的重大升级。</p><p id="bb09" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，Netty 4已经存在了一段时间，Netty 3也已经走到了生命的尽头，我们认为对这一关键基础设施进行彻底检查的时机已经成熟。我们希望允许我们的移动客户端使用<a class="ae kc" href="https://github.com/netty/netty/blob/4.1/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2Codec.java" rel="noopener ugc nofollow" target="_blank"> HTTP/2 </a>，并且正在重组我们的RPC基础设施以使用<a class="ae kc" href="http://www.grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>，这将要求我们的基础设施代理HTTP/2。我们知道这将是一项历时数月的努力，而且在前进的道路上会有坎坷。现在升级已经完成，我们想分享一下我们遇到的一些问题以及我们是如何解决它们的。</p><h1 id="ef42" class="kd ke hh bd kf kg kh ki kj kk kl km kn in la io kp iq lb ir kr it lc iu kt ku bi translated">遇到的问题</h1><h1 id="b318" class="kd ke hh bd kf kg kh ki kj kk kl km kn in la io kp iq lb ir kr it lc iu kt ku bi translated">单线程通道:这应该很简单！</h1><p id="0aa8" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">与Netty 3不同，在Netty 4中，出站事件与入站事件发生在同一个线程上。这允许我们通过删除确保线程安全的代码来简化一些出站处理程序。然而，由于这种变化，我们也遇到了意外的竞争情况。</p><p id="2ea8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的许多测试都是在echo服务器上运行的，我们断言客户机接收的正是它发送的内容。在我们的一个涉及分块消息的测试中，我们发现我们偶尔会收到除了一个块之外的所有块。丢失的部分从来不在消息的开头，但是它从中间到结尾是变化的。</p><p id="9c50" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Netty 3中，所有与管道的交互都是线程安全的。但是，在Netty 4中，所有管道事件都必须发生在事件循环中。因此，源自事件循环之外的事件由Netty异步调度。</p><p id="1c5a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Tracon中，我们将流量从入站服务器通道代理到单独的出站通道。因为我们将出站连接放在一起，所以出站通道不会绑定到入站事件循环。来自每个事件循环的事件导致这个代理试图同时对<em class="ld">写</em>。这段代码在Netty 3中是安全的，因为每个<em class="ld">写</em>调用都会在返回之前完成。在Netty 4中，我们必须更加小心地控制什么事件循环可以调用<em class="ld">写</em>来防止乱序写。</p><p id="1044" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">当从Netty 3升级一个应用程序时，仔细审计任何可能从事件循环之外触发的事件代码:这些事件现在将被异步调度。</strong></p><h1 id="c63a" class="kd ke hh bd kf kg kh ki kj kk kl km kn in la io kp iq lb ir kr it lc iu kt ku bi translated">什么时候一个渠道是真正连通的？</h1><p id="e539" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">在Netty 3中，<em class="ld"> SslHandler </em>“重新定义”一个<em class="ld"> channelConnected </em>事件，在TLS握手而不是套接字上的TCP握手完成时进行门控。在Netty 4中，处理程序不会阻塞<em class="ld"> channelConnected </em>事件，而是触发一个更细粒度的用户<em class="ld">事件:SSL handshakecompletionevent</em>。注意Netty 4将<em class="ld">通道连接的</em>替换为<em class="ld">通道活动的</em>。</p><p id="8dcb" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于大多数应用程序来说，这是一个无关紧要的变化，但是Tracon使用相互认证的TLS来验证它与之对话的服务的身份。当我们第一次升级时，我们发现在相互认证<em class="ld">通道活动</em>处理程序中缺少预期的<em class="ld"> SSLSession </em>。<strong class="iy hi">解决方法很简单:监听握手完成事件，而不是假设TLS设置在<em class="ld">通道活动</em> </strong>完成</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="1977" class="ln ke hh lj b fi lo lp l lq lr">@Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws<br/> if (evt.equals(SslHandshakeCompletionEvent.SUCCESS)) {<br/>     Principal peerPrincipal = engine.getSession().getPeerPrincipal();<br/>     // Validate the principal<br/>     // ...<br/> }<br/> super.userEventTriggered(ctx, evt);</span><span id="4d5f" class="ln ke hh lj b fi ls lp l lq lr">}</span></pre><h1 id="cb54" class="kd ke hh bd kf kg kh ki kj kk kl km kn in la io kp iq lb ir kr it lc iu kt ku bi translated">回收的缓冲区泄漏NIO内存</h1><p id="8dda" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">除了正常的JVM监控之外，我们通过导出JMX bean<em class="ld">Java . NIO:type = buffer pool，name=direct </em>添加了对NIO分配的大小和数量的监控，因为我们希望能够了解新的池化分配器的直接内存使用情况并发出警报。</p><p id="a5d1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在一个集群中，我们能够使用这些数据观察到NIO内存泄漏。Netty提供了一个泄漏检测框架来帮助捕获管理缓冲区引用计数中的错误。我们没有得到任何泄漏检测错误，因为这个泄漏实际上不是一个<a class="ae kc" href="http://netty.io/wiki/reference-counted-objects.html" rel="noopener ugc nofollow" target="_blank">引用计数</a>错误！</p><p id="4867" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Netty 4引入了一个线程本地回收器<em class="ld">作为通用对象池。默认情况下，回收程序最多可以保留262k个对象。<em class="ld">如果小于64kb，ByteBufs </em>默认情况下会被池化:这意味着每个缓冲区回收器最多有17GB的NIO内存。</em></p><p id="1c7e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在正常情况下，很少会分配足够的NIO缓冲区。然而，如果没有足够的背压，一个慢速的阅读器就可能导致内存使用膨胀。即使在写入了慢速读取器的缓冲数据之后，回收器也不会使旧对象过期:属于该线程的NIO内存永远不会被释放出来供另一个线程使用。我们发现回收器完全耗尽了我们的NIO内存空间。</p><p id="3fc8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们已经将这些问题通知了Netty项目，并且有几个即将到来的修复提供了<a class="ae kc" href="https://github.com/netty/netty/pull/5589" rel="noopener ugc nofollow" target="_blank"> saner默认值</a>并限制了对象的增长:</p><ul class=""><li id="c777" class="lt lu hh iy b iz ja jc jd jf lv jj lw jn lx jr ly lz ma mb bi translated"><a class="ae kc" href="https://github.com/netty/netty/pull/5592" rel="noopener ugc nofollow" target="_blank">允许限制每个线程WeakOrderQueue实例的最大数量</a></li><li id="1f9a" class="lt lu hh iy b iz mc jc md jf me jj mf jn mg jr ly lz ma mb bi translated"><a class="ae kc" href="https://github.com/netty/netty/pull/5594" rel="noopener ugc nofollow" target="_blank">在回收器中引入分配/汇集比率</a></li><li id="4c18" class="lt lu hh iy b iz mc jc md jf me jj mf jn mg jr ly lz ma mb bi translated"><a class="ae kc" href="https://github.com/netty/netty/pull/5642" rel="noopener ugc nofollow" target="_blank">端口SendBufferPooled来自netty 3.10，如果使用非池化ByteBufAllocator，则使用该端口。</a></li></ul><p id="4cb2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">我们鼓励Netty的所有用户根据可用内存、线程数量和应用程序配置来配置他们的回收器设置。</strong>通过设置<em class="ld">-dio . netty . recycler . max capacity</em>可以配置每个回收器的对象数量，池的最大缓冲区大小由-<em class="ld">dio . netty . threadlocaldirdbuffersize</em>配置。通过将<em class="ld">-dio . netty . recycler . max capacity</em>设置为0来完全禁用回收器是安全的，对于我们的应用程序，我们没有观察到使用回收器有任何性能优势。</p><p id="c774" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了应对这个问题，我们做了另一个小但非常重要的改变:我们修改了我们的全局<em class="ld"> UncaughtExceptionHandler </em>以在进程遇到错误时终止进程，因为一旦遇到<em class="ld"> OutOfMemoryError </em>错误，我们就无法合理地恢复。这将有助于减轻未来任何潜在泄漏的影响。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="475d" class="ln ke hh lj b fi lo lp l lq lr">class LoggingExceptionHandler implements Thread.UncaughtExceptionHandler {</span><span id="78db" class="ln ke hh lj b fi ls lp l lq lr"> private static final Logger logger = Logger.getLogger(LoggingExceptionHandler.class);</span><span id="f569" class="ln ke hh lj b fi ls lp l lq lr"> /** Registers this as the default handler. */<br/> static void registerAsDefault() {<br/>   Thread.setDefaultUncaughtExceptionHandler(new LoggingExceptionHandler());<br/> }</span><span id="c08b" class="ln ke hh lj b fi ls lp l lq lr"> @Override public void uncaughtException(Thread t, Throwable e) {<br/>   if (e instanceof Exception) {<br/>     logger.error("Uncaught exception killed thread named '" + t.getName() + "'.", e);<br/>   } else {<br/>     logger.fatal("Uncaught error killed thread named '" + t.getName() + "'." + " Exiting now.", e);<br/>     System.exit(1);<br/>   }<br/> }<br/>}</span></pre><p id="2820" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">限制回收器修复了漏洞，但这也揭示了单个慢速读取器会消耗多少内存。这对于Netty 4来说并不新鲜，但是我们能够使用<em class="ld">channelwritalitchanged</em>事件轻松地添加背压。每当我们将两个通道绑定在一起时，我们只需添加这个处理程序，当通道解除链接时，我们只需移除它。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="2bae" class="ln ke hh lj b fi lo lp l lq lr">/**</span><span id="fd73" class="ln ke hh lj b fi ls lp l lq lr">* Observe the writability of the given inbound pipeline and set the {@link ChannelOption#AUTO_READ}<br/>* of the other channel to match. This allows our proxy to signal to the other side of a proxy<br/>* connection that a channel has a slow consumer and therefore should stop reading from the<br/>* other side of the proxy until that consumer is ready.<br/>*/</span><span id="513a" class="ln ke hh lj b fi ls lp l lq lr">public class WritabilityHandler extends ChannelInboundHandlerAdapter {</span><span id="7762" class="ln ke hh lj b fi ls lp l lq lr"> private final Channel otherChannel;</span><span id="ded8" class="ln ke hh lj b fi ls lp l lq lr"> public WritabilityHandler(Channel otherChannel) {<br/>   this.otherChannel = otherChannel;<br/> }</span><span id="6366" class="ln ke hh lj b fi ls lp l lq lr"> @Override public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {<br/>   boolean writable = ctx.channel().isWritable();<br/>   otherChannel.config().setOption(ChannelOption.AUTO_READ, writable);<br/>   super.channelWritabilityChanged(ctx);<br/> }<br/>}</span></pre><p id="6ad9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在发送缓冲区填充到高水位线后，通道的可写性将变为不可写，并且在低于低水位线之前，它不会再次被标记为可写。默认情况下，高水位线为64kb，低水位线为32kb。根据您的流量模式，您可能需要调整这些值。</p><h1 id="3ed2" class="kd ke hh bd kf kg kh ki kj kk kl km kn in la io kp iq lb ir kr it lc iu kt ku bi translated">如果一个承诺被打破了，而且没有监听器，你刚才是把/dev/null构建成一个服务吗？</h1><p id="6eed" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">在调试一些测试失败时，我们意识到一些写操作正在无声地失败。出站操作会将任何失败通知给它们的未来，但是如果每个写入失败都有共享的失败处理，您可以改为连接一个处理程序来覆盖所有写入。我们添加了一个简单的处理程序来记录任何失败的写操作:</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="fe1f" class="ln ke hh lj b fi lo lp l lq lr">@Singleton<br/>@Sharable<br/>public class PromiseFailureHandler extends ChannelOutboundHandlerAdapter {</span><span id="da02" class="ln ke hh lj b fi ls lp l lq lr"> private final Logger logger = Logger.getLogger(PromiseFailureHandler.class);</span><span id="99de" class="ln ke hh lj b fi ls lp l lq lr"> @Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)<br/>     throws Exception {<br/>   promise.addListener(future -&gt; {<br/>     if (!future.isSuccess()) {<br/>       logger.info("Write on channel %s failed", promise.cause(), ctx.channel());<br/>     }<br/>   });</span><span id="5fa9" class="ln ke hh lj b fi ls lp l lq lr">   super.write(ctx, msg, promise);<br/> }<br/>}</span></pre><h1 id="6c27" class="kd ke hh bd kf kg kh ki kj kk kl km kn in la io kp iq lb ir kr it lc iu kt ku bi translated">HTTPCodec更改</h1><p id="c742" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">Netty 4有一个改进的HTTP编解码器，它有一个更好的API来管理分块消息内容。我们能够删除一些自定义的块处理代码，但是在这个过程中我们也发现了一些惊喜！</p><p id="0070" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Netty 4中，每个HTTP消息都被转换成一个分块消息。即使对于零长度的消息也是如此。虽然从技术上讲，长度为0的分块消息是有效的，但这确实有点傻！我们安装了对象聚合器，将这些消息转换成非分块编码。Netty只为入站管道提供了一个聚合器:我们为出站管道添加了一个自定义聚合器，并将为其他Netty用户提供这个聚合器。</p><p id="2fbe" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">新的编解码器模型有一些细微差别。值得注意的是，<em class="ld">lashttpcontent</em>也是一个<em class="ld"> HttpContent </em>。这听起来很明显，但是如果你不小心的话，你可能会两次处理一条消息！此外，一个<em class="ld"> FullHttpResponse </em>也是一个<em class="ld"> HttpResponse </em>、一个<em class="ld"> HttpContent </em>和一个<em class="ld">lashttpcontent</em>。我们发现，我们通常希望将它作为一个<em class="ld"> HttpResponse </em>和一个<em class="ld">lastttpcontent</em>来处理，但是我们必须小心确保不会通过管道转发消息两次。</p><p id="d7f9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">不要这样做</strong></p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="893a" class="ln ke hh lj b fi lo lp l lq lr">if (msg instanceof HttpResponse) {<br/>  ...<br/>}</span><span id="7c33" class="ln ke hh lj b fi ls lp l lq lr">if (msg instanceof HttpContent) {<br/>  ...<br/>}</span><span id="6c6f" class="ln ke hh lj b fi ls lp l lq lr">if (msg instanceof LastHttpContent) {<br/>  … // Duplicate handling! This was already handled above!<br/>}</span></pre><p id="699d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们在一些测试代码中发现的另一个细微差别:<em class="ld">lashttpcontent</em>可能在接收方已经收到完整的响应之后触发，如果没有主体的话。在这种情况下，最后的内容是作为一个哨兵，但最后的字节已经出去了！</p><h1 id="65af" class="kd ke hh bd kf kg kh ki kj kk kl km kn in la io kp iq lb ir kr it lc iu kt ku bi translated">当飞机在空中时更换发动机</h1><p id="399e" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">总的来说，我们迁移到Netty 4的更改涉及了100多个文件和8k多行代码。如此大的变化再加上新的线程和内存模型，必然会遇到一些问题。由于我们100%的外部流量都流经该系统，我们需要一个流程来验证这些更改的安全性。</p><p id="eb92" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的大型单元和集成测试套件在验证初始实现方面非常有价值。</p><p id="bbc4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦我们在测试中建立了信心，我们就从“黑暗部署”开始，在这个部署中，我们在禁用状态下部署代理。虽然它没有占用任何流量，但我们能够通过Netty管道运行健康检查来检查下游服务的状态，从而测试大量的新代码。我们强烈推荐这种技术来安全地推出任何大的变更。</p><p id="eac0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们慢慢地将新代码推广到产品中时，我们还依赖大量的指标来比较新代码的性能。一旦我们解决了所有的问题，我们发现使用<em class="ld">unpoedbytebufallocator</em>的Netty 4性能实际上与Netty 3相同。我们期待在不久的将来使用池式分配器来获得更好的性能。</p><h1 id="e59f" class="kd ke hh bd kf kg kh ki kj kk kl km kn in la io kp iq lb ir kr it lc iu kt ku bi translated">谢谢</h1><p id="bc46" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">我们要感谢所有参与Netty项目的人。我们要特别感谢诺曼·莫勒/<a class="ae kc" href="https://twitter.com/normanmaurer" rel="noopener ugc nofollow" target="_blank">@诺曼·莫勒</a>的帮助和回应！</p><h1 id="338f" class="kd ke hh bd kf kg kh ki kj kk kl km kn in la io kp iq lb ir kr it lc iu kt ku bi translated">参考</h1><ul class=""><li id="f546" class="lt lu hh iy b iz kv jc kw jf mh jj mi jn mj jr ly lz ma mb bi translated">Netty 4.0中新的和值得注意的:<a class="ae kc" href="http://netty.io/wiki/new-and-noteworthy-in-4.0.html" rel="noopener ugc nofollow" target="_blank">http://netty.io/wiki/new-and-noteworthy-in-4.0.html</a></li><li id="39a3" class="lt lu hh iy b iz mc jc md jf me jj mf jn mg jr ly lz ma mb bi translated">Netty最佳实践更快==更好:<a class="ae kc" href="http://normanmaurer.me/presentations/2014-facebook-eng-netty/slides.html" rel="noopener ugc nofollow" target="_blank">http://Norman Maurer . me/presentations/2014-Facebook-eng-netty/slides . html</a></li><li id="6fc0" class="lt lu hh iy b iz mc jc md jf me jj mf jn mg jr ly lz ma mb bi translated">Netty in Action:<a class="ae kc" href="https://www.amazon.com/Netty-Action-Norman-Maurer/dp/1617291471/qid=1470353221" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . com/Netty-Action-Norman-Maurer/DP/1617291471/qid = 1470353221</a></li></ul></div></div>    
</body>
</html>