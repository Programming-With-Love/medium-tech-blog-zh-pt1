<html>
<head>
<title>Using Hilt’s ViewModelComponent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Hilt的视图模型组件</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/using-hilts-viewmodelcomponent-53b46515c4f4?source=collection_archive---------2-----------------------#2021-01-21">https://medium.com/androiddevelopers/using-hilts-viewmodelcomponent-53b46515c4f4?source=collection_archive---------2-----------------------#2021-01-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/38b1505128fae79877ac8816d93ce29a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4yrsbMOQnVXEe4PITqTpEA.png"/></div></div></figure><div class=""/><p id="ce68" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">ViewModelComponent</code>是<a class="ae jr" href="https://developer.android.com/training/dependency-injection/hilt-android#component-hierarchy" rel="noopener ugc nofollow" target="_blank">柄的组件层次结构</a>中的一个组件，它遵循视图模型的生命周期，并允许对其类型进行限定。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="0a02" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du jn jo jp jq b">ViewModelComponent</code>被添加到Hilt之前，视图模型类是由<code class="du jn jo jp jq b">ActivityRetainedComponent</code>创建和注入的。因此，视图模型的依赖项只能使用未划分的类型或作用于<code class="du jn jo jp jq b">SingletonComponent</code>或<code class="du jn jo jp jq b">ActivityRetainedComponent</code>的类型，它们的实例由所有视图模型共享。</p><p id="06d9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果应用程序的每个屏幕都是一个活动，那么上面的问题可能不会出现，因为将一个类型的范围限定为<code class="du jn jo jp jq b">ActivityRetainedComponent</code>将意味着每个ViewModel类将接收该类型的不同实例。然而，对于大多数应用程序来说，每个屏幕都有一个活动并不是这样。</p><p id="3b0b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，<code class="du jn jo jp jq b">SavedStateHandle</code>类型在<code class="du jn jo jp jq b">ActivityRetainedComponent</code>中不能作为默认绑定使用。</p><p id="f723" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，视图模型是由遵循视图模型生命周期的<code class="du jn jo jp jq b">ViewModelComponent</code>创建和注入的。每个ViewModel实例都有一个不同的<code class="du jn jo jp jq b">ViewModelComponent</code>实例，为了给它确定一个类型的范围，可以使用<code class="du jn jo jp jq b">@ViewModelScoped</code>注释。</p><figure class="ka kb kc kd fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jz"><img src="../Images/109df6f71d86aa3847212751d1edc6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pHaHd50ZCJaC0e4T"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx"><em class="ki">Position of the ViewModelComponent in a simplified Hilt’s component hierarchy</em></figcaption></figure><p id="74cf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">ViewModelComponent</code>从<code class="du jn jo jp jq b">ActivityRetainedComponent</code>伸出。因此，作用域为<code class="du jn jo jp jq b">ViewModelComponent</code>的类型可以依赖作用域为<code class="du jn jo jp jq b">ActivityRetainedComponent</code>和<code class="du jn jo jp jq b">SingletonComponent</code>的类型。除此之外，ViewModelComponent还包含一个与其ViewModel相关联的<code class="du jn jo jp jq b"><a class="ae jr" href="https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle" rel="noopener ugc nofollow" target="_blank">SavedStateHandle</a></code>的默认绑定。</p><h1 id="3543" class="kj kk hs bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">ViewModelComponent的范围</h1><p id="e82e" class="pw-post-body-paragraph ip iq hs ir b is lh iu iv iw li iy iz ja lj jc jd je lk jg jh ji ll jk jl jm ha bi translated">与其他组件相比，使用<code class="du jn jo jp jq b">@ViewModelScoped</code>来确定<code class="du jn jo jp jq b">ViewModelComponent</code>的作用域，从而确定ViewModel的作用域，可以为您提供更大的灵活性和粒度。视图模型经受住了配置的变化，它的生命周期可以由一个活动、片段甚至一个<a class="ae jr" href="https://developer.android.com/reference/androidx/navigation/NavBackStackEntry" rel="noopener ugc nofollow" target="_blank">导航图</a>来控制！</p><p id="e05b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管如此，<code class="du jn jo jp jq b">ActivityComponent</code>和<code class="du jn jo jp jq b">FragmentComponent</code>的作用域仍然是有用的，因为这些组件不能经受住在某些场景中可能需要的配置更改。此外，<code class="du jn jo jp jq b">FragmentComponent</code>扩展了<code class="du jn jo jp jq b">ActivityComponent</code>，这是多个<code class="du jn jo jp jq b">ViewModelComponent</code>无法实现的行为</p><p id="0175" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此:</p><ul class=""><li id="5635" class="lm ln hs ir b is it iw ix ja lo je lp ji lq jm lr ls lt lu bi translated">为了让所有的视图模型共享同一个类型的实例，用<code class="du jn jo jp jq b">@ActivityRetainedScoped.</code>对其进行注释</li><li id="270d" class="lm ln hs ir b is lv iw lw ja lx je ly ji lz jm lr ls lt lu bi translated">要将一个类型限定在一个ViewModel中，使其在配置更改后仍然存在，并且/或者由导航图控制，可以用<code class="du jn jo jp jq b">@ViewModelScoped</code>对其进行注释。</li><li id="9595" class="lm ln hs ir b is lv iw lw ja lx je ly ji lz jm lr ls lt lu bi translated">要将某个类型的范围限定到活动中，并且不使它在配置更改后继续存在，那么可以用<code class="du jn jo jp jq b">@ActivityScoped</code>或<code class="du jn jo jp jq b">@FragmentScoped</code>进行注释，如果您希望将该行为的范围限定到片段中的话。</li></ul><h1 id="e315" class="kj kk hs bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">使用@ViewModelScoped</h1><p id="0b19" class="pw-post-body-paragraph ip iq hs ir b is lh iu iv iw li iy iz ja lj jc jd je lk jg jh ji ll jk jl jm ha bi translated">该注释允许您将类型的范围限定为ViewModel的实例。相同的实例将被注入ViewModel及其依赖项拥有的所有依赖项中。</p><p id="5284" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下面的例子中，<code class="du jn jo jp jq b">LoginViewModel</code>和<code class="du jn jo jp jq b">RegistrationViewModel</code>使用了包含可变状态的<code class="du jn jo jp jq b">@ViewModelScoped UserInputAuthData</code>类型。</p><figure class="ka kb kc kd fd hj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="2eb9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于<code class="du jn jo jp jq b">UserInputAuthData</code>的作用域是ViewModel，<code class="du jn jo jp jq b">RegistrationViewModel</code>和<code class="du jn jo jp jq b">LoginViewModel</code>将接收到<code class="du jn jo jp jq b">UserInputAuthData</code>的<em class="mc">不同实例</em>。然而，每个视图模型的未划分的用例依赖使用其视图模型使用的<em class="mc">相同的实例</em>。</p><h1 id="63d8" class="kj kk hs bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">向ViewModelComponent添加绑定</h1><p id="297e" class="pw-post-body-paragraph ip iq hs ir b is lh iu iv iw li iy iz ja lj jc jd je lk jg jh ji ll jk jl jm ha bi translated">您可以像添加任何其他组件一样将绑定添加到<code class="du jn jo jp jq b">ViewModelComponent</code>。如果在上面的代码片段中，<code class="du jn jo jp jq b">ValidateUsernameUseCase</code>是一个接口，您可以告诉Hilt使用如下的实现:</p><figure class="ka kb kc kd fd hj"><div class="bz dy l di"><div class="ma mb l"/></div></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="ae0c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">ViewModelComponent</code>遵循视图模型的生命周期，并允许对其类型进行范围界定。由于ViewModel的生命周期可以由一个活动、片段或者甚至一个<a class="ae jr" href="https://developer.android.com/reference/androidx/navigation/NavBackStackEntry" rel="noopener ugc nofollow" target="_blank">导航图</a>来控制，所以在您可以确定范围的地方的数量上，您获得了更多的灵活性和粒度。</p><p id="9c5b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要将一个类型限定在一个视图模型中，可以用<code class="du jn jo jp jq b">@ViewModelScoped</code>对其进行注释。为了让所有的视图模型共享同一个类型的实例，用<code class="du jn jo jp jq b">@ActivityRetainedScoped</code>对其进行注释。</p></div></div>    
</body>
</html>