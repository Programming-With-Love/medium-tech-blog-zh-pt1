<html>
<head>
<title>Elements of Successful Massive Scale Automated Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成功的大规模自动化测试的要素</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/elements-of-successful-massive-scale-automated-testing-f071c17f2907?source=collection_archive---------1-----------------------#2016-08-18">https://medium.com/walmartglobaltech/elements-of-successful-massive-scale-automated-testing-f071c17f2907?source=collection_archive---------1-----------------------#2016-08-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/b55e7ac7646a53a7073d8a8b57042959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-qdCzneVOeswbz3Owb9pOw.png"/></div></div></figure><div class=""/><p id="023f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">仅仅提到“前端自动化测试”这个术语就足以让一个经验丰富的web开发人员不寒而栗。远程驱动网络浏览器是一门不精确的科学。它昂贵、缓慢，并且充满了破坏交易的不稳定性。与此同时，我们仍然希望在将我们的应用和网站部署到生产或应用商店之前，验证它们是否工作正常。事实上，忘记部署吧——部署已经太迟了。我们希望在合并代码之前能够完全验证我们的代码，以最小化我们的影响。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="1fa8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在合并之前进行验证，对于那些从事主分支或开发分支受单元测试保护的项目的人来说，应该是很熟悉的。开发人员喜欢单元测试，因为它们:</p><ul class=""><li id="34c9" class="ju jv hs ir b is it iw ix ja jw je jx ji jy jm jz ka kb kc bi translated">快速执行，</li><li id="52cd" class="ju jv hs ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated">是完全隔离的，只受提交更改的影响，</li><li id="e874" class="ju jv hs ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated">和在代码合并之前运行。</li></ul><p id="da1c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">大多数基于协议(如Selenium、Appium等)的测试套件不具备这些特征。它们通常以服务器部署的代码为目标，受许多随机环境因素的影响，运行缓慢，并且在代码合并后很久才被触发。</p><p id="2222" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">自动化UI测试简直糟透了。我们以巨大的时间或计算资源成本获得了非常低的信息价值。高价值的潜力是存在的，但是典型的过程被打破了。我们如何解决这个问题？</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h2 id="4d68" class="ki kj hs bd kk kl km kn ko kp kq kr ks ja kt ku kv je kw kx ky ji kz la lb lc bi translated">拖延的代价:航行于红海</h2><p id="801d" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">当我们第一次在WalmartLabs开始调查这个问题时，我们通过Selenium运行了成千上万的客户流，但在这个过程中为时已晚，经常导致测试矩阵充满失败。我们亲切地称之为“<strong class="ir ht">红色海洋</strong>”。</p><p id="6bb3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当回归被发现的时候，它们已经存在了几个小时到几天，与其他的bug混杂在一起，导致了无数的失败。然后，bug的生命周期经历了一个痛苦的过程:重新测试、质量工程师的调查、吉拉的罚单，然后开发人员努力重现并确定问题。</p><p id="a2fa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这似乎是显而易见的，但在软件开发团队的过程中经常没有考虑到:代码编写后运行的测试越晚，丢失的信息就越多，从坏代码中恢复的代价就越大。</p><p id="0989" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">欣赏单元测试效用的团队矛盾地将自动化UI测试视为“集成测试”活动，在代码合并后很久才完成。将集成测试拖到游戏后期是一个代价极其高昂的错误，因为以客户为中心的测试(执行真实客户行为的测试)揭示了单元测试没有的<em class="lj">整个回归类别</em>。</p><p id="9518" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">解决这个问题的唯一方法是在合并代码之前<em class="lj">运行测试——包括自动化UI测试。</em></p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h2 id="db0e" class="ki kj hs bd kk kl km kn ko kp kq kr ks ja kt ku kv je kw kx ky ji kz la lb lc bi translated">实时测试圣杯:快速实时验证</h2><figure class="ll lm ln lo fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lk"><img src="../Images/e07cd9fc571d5a2ba727315589ef59be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m0r3vvMqSRbgyD0kcV9KQw.jpeg"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx">Elements of fast realtime verify</figcaption></figure><p id="749d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如今，WalmartLabs测试自动化流程依赖于三个基本假设:</p><ul class=""><li id="a2d3" class="ju jv hs ir b is it iw ix ja jw je jx ji jy jm jz ka kb kc bi translated"><strong class="ir ht">大规模并行</strong>:测试由数百甚至数千个工作人员(虚拟机、浏览器或设备)并行运行。</li><li id="a675" class="ju jv hs ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir ht">“实时”测试</strong>:在合并代码之前，尽可能快地、尽可能频繁地运行测试，并且在合并代码之前总是绿色的。实际上，这意味着在每次提交pull请求时触发测试，并且不允许代码被合并，除非那个提交是绿色的。</li><li id="5a1b" class="ju jv hs ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir ht">确定性行为</strong>:整个测试堆栈都是确定性的。这意味着完全模拟的服务器、完全可预测的数据库条目、对终端行为的完全控制，以及对随机应用行为的精细控制(例如:促销飞出)。</li></ul><p id="6981" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果是快速实时验证，如上图所示，这是我们基本假设的理想组合。在每一次PR和随后的PR提交中，我们使用完全确定的模拟应用程序后端，乘以一系列浏览器或设备，运行大规模并行自动化UI测试。</p><p id="97fa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是相当雄心勃勃的。有没有更简单的方法可以达到同样的效果？碰巧的是，对这三个基本假设做出妥协会产生过程，其中一些过程起初看起来有用，但以破坏交易的方式失败了。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><figure class="ll lm ln lo fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lt"><img src="../Images/764e6daca6d2146109a017d4734a7077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*inhhzP6mY08BqgRUw0oPug.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx">Chaotic Verify: a high performance code verification process mired in uncertainty</figcaption></figure><h2 id="bf56" class="ki kj hs bd kk kl km kn ko kp kq kr ks ja kt ku kv je kw kx ky ji kz la lb lc bi translated">混沌验证</h2><p id="7325" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">根据我们的经验，团队发现快速实时验证中最难复制的部分是确定性。用一个令人信服的可以独立运行的mock来修改现有的应用程序并不容易。然而，不这样做的代价也很高:即使有大规模并行，在PRs中运行测试也会产生不可预测的结果，这实际上会让开发人员的日子很难过。对团队之外的外部服务或模块的更改意味着开发人员可以看到与其更新无关的测试失败。<strong class="ir ht">混乱的验证</strong>模式侵蚀了对CI基础设施和测试工具本身的信任。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><figure class="ll lm ln lo fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lu"><img src="../Images/b81422b922d75ffa73197ea80201e7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vi7lrHxKUf8qRaFVwVtcmQ.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx">Late Verify: a high performance verification strategy executed too long after regressions have crept into code</figcaption></figure><h2 id="0d56" class="ki kj hs bd kk kl km kn ko kp kq kr ks ja kt ku kv je kw kx ky ji kz la lb lc bi translated">延迟验证</h2><p id="21ed" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">虽然许多开发团队对在每个PR上运行大规模自动化套件的想法感到满意，但有些团队并不满意。这些团队更喜欢在后期的“集成”阶段运行UI测试。这种妥协允许回归悄悄进入代码库，并在很长一段时间内不被发现。当它们被发现时，回归恢复的成本会显著增加。很容易理解为什么我们称这种形式的验证为“<strong class="ir ht">后期验证</strong>”。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><figure class="ll lm ln lo fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lv"><img src="../Images/fd272eec121d976f4a7135dee76916e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VACpq_BYa-JGWd-YlcOpZQ.png"/></div></div></figure><h2 id="161f" class="ki kj hs bd kk kl km kn ko kp kq kr ks ja kt ku kv je kw kx ky ji kz la lb lc bi translated">慢速验证</h2><p id="35fa" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">省去大量的并行性给了我们非常可靠，但也是缓慢的验证。如果我们有一个小的应用程序，或者UI测试运行得非常快，或者支持的客户环境(浏览器、版本、设备等)非常少，这可能是一个可以接受的折衷。如果您的扩展预算很小，这可能是您唯一的选择。另一方面，即使是中等规模的应用程序的自动化UI测试也要花费很多时间，尤其是在许多客户环境中进行测试的时候。当验证一个PR需要很长时间时，开发人员开始忽略结果并合并代码而不等待。如果验证被认为是“永远”进行的，开发人员将开始反对自动化测试。<strong class="ir ht"> Slow Verify </strong>强调了为什么可用性和便利性是大规模测试自动化的关键元素:开发人员的接受度对于选择一个经得起时间考验的工作流至关重要。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h2 id="86c3" class="ki kj hs bd kk kl km kn ko kp kq kr ks ja kt ku kv je kw kx ky ji kz la lb lc bi translated">绿色很便宜，红色很贵</h2><p id="099b" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">为了让自动化UI测试向开发人员提供有用的信息，它必须在代码合并之前运行，必须是完全确定的，并且必须运行得非常快。移除这些难题中的任何一个都会导致开发团队感到沮丧，浪费时间和金钱。</p><p id="b1df" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">大规模自动化测试只有在永远不被允许陷入“红色海洋”的情况下才能正常工作。当一个测试套件被允许进入这种状态时，在自动化基础设施上花费大量的金钱突然看起来非常愚蠢。<strong class="ir ht">以失败测试为主的自动化基础设施极其昂贵，而运行大多数通过测试的相同基础设施是相对明智的投资</strong>。这一指导原则告知了WalmartLabs如何组织其测试基础设施，以及我们如何编写自动化工具来智能地利用时间和硬件。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h2 id="8473" class="ki kj hs bd kk kl km kn ko kp kq kr ks ja kt ku kv je kw kx ky ji kz la lb lc bi translated">工具</h2><p id="6f04" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">到目前为止，我们没有提到任何特定的工具。在创建有效的测试自动化过程中，本文中描述的工作流模式比所选择的特定软件更重要。</p><p id="36d8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">也就是说，我们一直在努力开发一个工具集，使我们能够在内部实现快速实时验证，它采用了Github、Jenkins、Docker和我们的<a class="ae li" href="https://github.com/TestArmada" rel="noopener ugc nofollow" target="_blank"> TestArmada套件</a>，包括<a class="ae li" href="https://github.com/TestArmada/magellan" rel="noopener ugc nofollow" target="_blank"> Magellan </a>。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><h2 id="250a" class="ki kj hs bd kk kl km kn ko kp kq kr ks ja kt ku kv je kw kx ky ji kz la lb lc bi translated">结论</h2><p id="6cda" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">我们不再害怕大量自动化前端测试的前景，你也不应该害怕。事实上，我们确保我们的前端测试集在深度和全面性上有所增长。这为我们的开发人员提供了对问题点的洞察，并在他们部署时增加了他们的信心。</p><p id="b61b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">敬请关注我们如何在@WalmartLabs实施这些关键要素的一系列深度探讨，以及这些要素如何融入我们的持续交付渠道。</p></div></div>    
</body>
</html>