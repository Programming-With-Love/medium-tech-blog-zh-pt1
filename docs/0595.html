<html>
<head>
<title>Simplifying APIs with coroutines and Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用协程和流程简化API</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/simplifying-apis-with-coroutines-and-flow-a6fb65338765?source=collection_archive---------0-----------------------#2020-12-16">https://medium.com/androiddevelopers/simplifying-apis-with-coroutines-and-flow-a6fb65338765?source=collection_archive---------0-----------------------#2020-12-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f1f064469350b2336414178de85f7e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0QJqxE7mPdvAWzGCdat6g.png"/></div></div></figure><div class=""/><p id="f08c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您是一个库作者，您可能希望使用协程和流使您的基于Java或基于回调的库更容易从Kotlin中使用。或者，如果你是一个API消费者，你可能愿意让第三方API表面适应协程，使它们对Kotlin更友好。</p><p id="ba69" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文涵盖了如何使用协程和流程简化API，以及如何使用<code class="du jn jo jp jq b">suspendCancellableCoroutine</code>和<code class="du jn jo jp jq b">callbackFlow</code>API构建自己的适配器。对于最好奇的人来说，这些API将被剖析，您将看到它们是如何工作的。</p><p id="0a79" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你更喜欢看关于这个话题的视频。看看这个:</p><figure class="jr js jt ju fd hj"><div class="bz dy l di"><div class="jv jw l"/></div></figure><h1 id="a76f" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">检查现有的协程适配器</h1><p id="e067" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">在为现有API编写自己的包装器之前，检查适配器或<a class="ae la" rel="noopener" href="/androiddevelopers/extend-your-code-readability-with-kotlin-extensions-542bf702aa36">扩展函数</a>是否可用于您的用例。对于常见的类型，已经有了带有协程适配器的库。</p><h2 id="123e" class="lb jy hs bd jz lc ld le kd lf lg lh kh ja li lj kl je lk ll kp ji lm ln kt lo bi translated">未来类型</h2><p id="22eb" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">对于未来类型，有Java 8的<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/integration/kotlinx-coroutines-jdk8/src/future/Future.kt" rel="noopener ugc nofollow" target="_blank"> CompletableFuture </a>和Guava的<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/integration/kotlinx-coroutines-guava/src/ListenableFuture.kt" rel="noopener ugc nofollow" target="_blank"> ListenableFuture </a>的集成。这不是一个详尽的列表，如果您未来类型的适配器已经存在，请在线搜索。</p><pre class="jr js jt ju fd lp jq lq lr aw ls bi"><span id="65a2" class="lb jy hs jq b fi lt lu l lv lw">// Awaits completion of CompletionStage without blocking a thread<br/>suspend fun &lt;T&gt; <strong class="jq ht">CompletionStage&lt;T&gt;.await(): T</strong> </span><span id="6c10" class="lb jy hs jq b fi lx lu l lv lw">// Awaits completion of ListenableFuture without blocking a thread<br/>suspend fun &lt;T&gt; <strong class="jq ht">ListenableFuture&lt;T&gt;.await(): T</strong></span></pre><p id="99d6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了这些函数，您可以摆脱回调，只需挂起协程，直到将来的结果返回。</p><h2 id="e324" class="lb jy hs bd jz lc ld le kd lf lg lh kh ja li lj kl je lk ll kp ji lm ln kt lo bi translated">反应流</h2><p id="bb6d" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">对于反应流库，有对<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-rx3" rel="noopener ugc nofollow" target="_blank"> RxJava </a>、<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-jdk9" rel="noopener ugc nofollow" target="_blank">Java 9 API</a>和<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/reactive/kotlinx-coroutines-reactive" rel="noopener ugc nofollow" target="_blank">反应流</a>库的集成。</p><pre class="jr js jt ju fd lp jq lq lr aw ls bi"><span id="4579" class="lb jy hs jq b fi lt lu l lv lw">// Transforms the given reactive Publisher into Flow.<br/>fun &lt;T : Any&gt; <strong class="jq ht">Publisher&lt;T&gt;.asFlow(): Flow&lt;T&gt;</strong></span></pre><p id="bb8d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些功能将反应流转化为流动。</p><h2 id="6ac9" class="lb jy hs bd jz lc ld le kd lf lg lh kh ja li lj kl je lk ll kp ji lm ln kt lo bi translated">Android特定API</h2><p id="43e6" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">对于Jetpack库或Android平台API，请看一下<a class="ae la" href="https://developer.android.com/kotlin/ktx/extensions-list" rel="noopener ugc nofollow" target="_blank"> Jetpack KTX库</a>列表。目前，超过20个库拥有KTX版本，创建了Java APIs的甜蜜惯用版本，从SharedPreferences到ViewModels、SQLite甚至Play Core。</p><h2 id="a244" class="lb jy hs bd jz lc ld le kd lf lg lh kh ja li lj kl je lk ll kp ji lm ln kt lo bi translated">复试</h2><p id="a53f" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">回调是异步通信的一种非常常见的解决方案。事实上，我们在后台线程指南中的<a class="ae la" href="https://developer.android.com/guide/background/threading" rel="noopener ugc nofollow" target="_blank">运行任务中使用它们作为Java编程语言解决方案。然而，它们也有一些缺点:这种设计会导致嵌套的回调，最终导致不可理解的代码。此外，错误处理更加复杂，因为没有简单的方法来传播它们。</a></p><p id="e08d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Kotlin中，您可以使用协程来简化回调的调用，但是为此，您需要构建自己的适配器。</p><h1 id="e972" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">构建您自己的适配器</h1><p id="8a28" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">如果你没有为你的用例找到一个适配器，通常你可以自己写一个。<strong class="ir ht">对于一次性异步调用，使用</strong> <code class="du jn jo jp jq b"><a class="ae la" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">suspendCancellableCoroutine</strong></a></code> <strong class="ir ht"> API。对于流数据，使用</strong> <code class="du jn jo jp jq b"><a class="ae la" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">callbackFlow</strong></a></code> <strong class="ir ht"> API。</strong></p><p id="d5ae" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为练习，下面的例子将使用来自Google Play服务的<a class="ae la" href="https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient.html" rel="noopener ugc nofollow" target="_blank">融合位置提供者</a> API来获取位置数据。API表面很简单，但是它使用回调来执行异步操作。有了协程，我们可以摆脱那些在逻辑变得复杂时会很快使我们的代码不可读的回调。</p><p id="6674" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您想探索其他解决方案，可以从上面链接的所有函数的源代码中获得灵感。</p><h2 id="e840" class="lb jy hs bd jz lc ld le kd lf lg lh kh ja li lj kl je lk ll kp ji lm ln kt lo bi translated">一次性异步调用</h2><p id="a949" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated"><a class="ae la" href="https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient.html" rel="noopener ugc nofollow" target="_blank">融合位置提供者</a> API提供了<code class="du jn jo jp jq b"><a class="ae la" href="https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient#getLastLocation()" rel="noopener ugc nofollow" target="_blank">getLastLocation</a></code>方法来获取<a class="ae la" href="https://developer.android.com/training/location/retrieve-current" rel="noopener ugc nofollow" target="_blank">最后已知位置</a>。协程的理想API是一个suspend函数，它返回的正是这个函数。</p><blockquote class="ly lz ma"><p id="8667" class="ip iq mb ir b is it iu iv iw ix iy iz mc jb jc jd md jf jg jh me jj jk jl jm ha bi translated">注意，这个API返回一个<a class="ae la" href="https://developers.google.com/android/reference/com/google/android/gms/tasks/Task" rel="noopener ugc nofollow" target="_blank">任务</a>，并且已经有一个<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/integration/kotlinx-coroutines-play-services/src/Tasks.kt" rel="noopener ugc nofollow" target="_blank">适配器</a>可供它使用。然而，出于学习的目的，我们将把它作为一个例子。</p></blockquote><p id="c644" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过在<code class="du jn jo jp jq b">FusedLocationProviderClient</code>上创建一个扩展函数，我们可以有一个更好的API:</p><pre class="jr js jt ju fd lp jq lq lr aw ls bi"><span id="2a7b" class="lb jy hs jq b fi lt lu l lv lw">suspend fun FusedLocationProviderClient.<strong class="jq ht">awaitLastLocation(): Location</strong></span></pre><p id="cbdc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为这是一个一次性的异步操作，所以我们使用了<code class="du jn jo jp jq b">suspendCancellableCoroutine</code>函数:一个从协程库中创建挂起函数的底层构建块。</p><p id="dbd2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jn jo jp jq b">suspendCancellableCoroutine</code>执行作为参数传递给它的代码块，然后暂停协程执行，同时等待信号继续。当在协程的<a class="ae la" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation/" rel="noopener ugc nofollow" target="_blank">延续</a>对象中调用<code class="du jn jo jp jq b">resume</code>或<code class="du jn jo jp jq b">resumeWithException</code>方法时，协程将恢复执行。关于延续的更多信息，请查看<a class="ae la" rel="noopener" href="/androiddevelopers/the-suspend-modifier-under-the-hood-b7ce46af624f">文章</a>下的<em class="mb">暂停修改器。</em></p><p id="60b2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用可以添加到<code class="du jn jo jp jq b">getLastLocation</code>方法的回调来适当地恢复协程。请参见下面的实现:</p><figure class="jr js jt ju fd hj"><div class="bz dy l di"><div class="mf jw l"/></div></figure><p id="0fc6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意:虽然您也可以在协程库(即<code class="du jn jo jp jq b"><a class="ae la" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/suspend-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCoroutine</a></code>)中找到这个协程构建器的不可取消版本，但是最好总是选择<code class="du jn jo jp jq b"><a class="ae la" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCancellableCoroutine</a></code>来处理协程作用域的取消，或者从底层API传播取消。</p><h2 id="706d" class="lb jy hs bd jz lc ld le kd lf lg lh kh ja li lj kl je lk ll kp ji lm ln kt lo bi translated">引擎盖下的suspendCancellableCoroutine</h2><p id="c16d" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">在内部，<code class="du jn jo jp jq b"><a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CancellableContinuation.kt#L305" rel="noopener ugc nofollow" target="_blank">suspendCancellableCoroutine</a></code>使用<code class="du jn jo jp jq b"><a class="ae la" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/intrinsics/Intrinsics.kt#L41" rel="noopener ugc nofollow" target="_blank">suspendCoroutineUninterceptedOrReturn</a></code>获取挂起函数中协程的<code class="du jn jo jp jq b">Continuation</code>。那个<code class="du jn jo jp jq b">Continuation</code>对象被一个<code class="du jn jo jp jq b"><a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CancellableContinuation.kt" rel="noopener ugc nofollow" target="_blank">CancellableContinuation</a></code>拦截，它将从那一点开始控制那个协程的生命周期(它的<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CancellableContinuationImpl.kt" rel="noopener ugc nofollow" target="_blank">实现</a>具有带一些限制的<code class="du jn jo jp jq b">Job</code>的功能)。</p><p id="b031" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后，传递给<code class="du jn jo jp jq b">suspendCancellableCoroutine</code>的lambda将被执行，如果lambda返回结果，协程将立即恢复，或者将被挂起，直到从lambda手动恢复<code class="du jn jo jp jq b">CancellableContinuation</code>。</p><p id="f1d5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">参见下面代码片段中我自己的注释(遵循<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/CancellableContinuation.kt#L305" rel="noopener ugc nofollow" target="_blank">原始实现</a>)来理解发生了什么:</p><figure class="jr js jt ju fd hj"><div class="bz dy l di"><div class="mf jw l"/></div></figure><p id="ba8d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要了解更多关于挂起功能如何工作的信息，请查看<a class="ae la" rel="noopener" href="/androiddevelopers/the-suspend-modifier-under-the-hood-b7ce46af624f"> <em class="mb">挂起修改器</em>文章</a>。</p><h2 id="d62a" class="lb jy hs bd jz lc ld le kd lf lg lh kh ja li lj kl je lk ll kp ji lm ln kt lo bi translated">流式数据</h2><p id="08b3" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">相反，如果我们希望每当用户的设备在现实世界中移动时都接收定期的位置更新(使用<code class="du jn jo jp jq b"><a class="ae la" href="https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient#requestLocationUpdates(com.google.android.gms.location.LocationRequest,%20com.google.android.gms.location.LocationCallback,%20android.os.Looper)" rel="noopener ugc nofollow" target="_blank">requestLocationUpdates</a></code>函数)，我们需要使用<a class="ae la" href="https://kotlinlang.org/docs/reference/coroutines/flow.html" rel="noopener ugc nofollow" target="_blank"> Flow </a>创建一个数据流。理想的API应该是这样的:</p><pre class="jr js jt ju fd lp jq lq lr aw ls bi"><span id="cdea" class="lb jy hs jq b fi lt lu l lv lw">fun FusedLocationProviderClient.<strong class="jq ht">locationFlow(): Flow&lt;Location&gt;</strong></span></pre><p id="0bb9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要将基于流回调的API转换为流，请使用创建新流的<code class="du jn jo jp jq b"><a class="ae la" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html" rel="noopener ugc nofollow" target="_blank">callbackFlow</a></code>流构建器。在<code class="du jn jo jp jq b">callbackFlow</code> lambda中，我们在协程的上下文中，因此，可以调用暂停函数。与<code class="du jn jo jp jq b"><a class="ae la" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html" rel="noopener ugc nofollow" target="_blank">flow</a></code>流构建器不同，<code class="du jn jo jp jq b">channelFlow</code>允许使用<code class="du jn jo jp jq b"><a class="ae la" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/offer.html" rel="noopener ugc nofollow" target="_blank">offer</a></code>方法从不同的<code class="du jn jo jp jq b">CoroutineContext</code>或协程外部发出值。</p><p id="fffc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通常，使用<code class="du jn jo jp jq b">callbackFlow</code>的流量适配器遵循以下三个通用步骤:</p><ol class=""><li id="26ae" class="mg mh hs ir b is it iw ix ja mi je mj ji mk jm ml mm mn mo bi translated">使用<code class="du jn jo jp jq b">offer</code>创建将元素添加到流中的回调。</li><li id="5433" class="mg mh hs ir b is mp iw mq ja mr je ms ji mt jm ml mm mn mo bi translated">注册回拨。</li><li id="5e24" class="mg mh hs ir b is mp iw mq ja mr je ms ji mt jm ml mm mn mo bi translated">等待使用者取消协程并注销回调。</li></ol><p id="959b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将这个方法应用于这个用例，我们得到了下面的实现:</p><figure class="jr js jt ju fd hj"><div class="bz dy l di"><div class="mf jw l"/></div></figure><h2 id="c5be" class="lb jy hs bd jz lc ld le kd lf lg lh kh ja li lj kl je lk ll kp ji lm ln kt lo bi translated">呼叫引擎盖下的回流</h2><p id="58dc" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">在内部，<code class="du jn jo jp jq b">callbackFlow</code>使用一个<a class="ae la" href="https://kotlinlang.org/docs/reference/coroutines/channels.html" rel="noopener ugc nofollow" target="_blank">通道</a>，这在概念上与阻塞<a class="ae la" href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">队列</a>非常相似。用<code class="du jn jo jp jq b">capacity</code>配置一个通道:可以缓冲的元素数量。在<code class="du jn jo jp jq b">callbackFlow</code>中创建的通道具有64个元件的默认容量。当向已满的通道添加新元素时，<code class="du jn jo jp jq b">send</code>将暂停生成器，直到通道中有空间容纳新元素，而<code class="du jn jo jp jq b">offer</code>不会向通道添加元素，并将立即返回<code class="du jn jo jp jq b">false</code>。</p><h2 id="0c5a" class="lb jy hs bd jz lc ld le kd lf lg lh kh ja li lj kl je lk ll kp ji lm ln kt lo bi translated">引擎盖下的一个陷阱</h2><p id="ac91" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">有趣的是，<code class="du jn jo jp jq b">awaitClose</code>在引擎盖下使用<code class="du jn jo jp jq b">suspendCancellableCoroutine</code>。参见下面代码片段中我自己的注释(遵循<a class="ae la" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/channels/Produce.kt#L49" rel="noopener ugc nofollow" target="_blank">原始实现</a>)来理解发生了什么:</p><figure class="jr js jt ju fd hj"><div class="bz dy l di"><div class="mf jw l"/></div></figure><h2 id="3e48" class="lb jy hs bd jz lc ld le kd lf lg lh kh ja li lj kl je lk ll kp ji lm ln kt lo bi translated">重用流程</h2><p id="80d1" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">流动是冷的和懒惰的，除非有中间操作者如<code class="du jn jo jp jq b"><a class="ae la" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html" rel="noopener ugc nofollow" target="_blank">conflate</a></code>另有说明。这意味着每次在流上调用终端操作符时，都会执行构建器块。在我们的例子中，这可能不是一个大问题，因为添加新的位置侦听器成本很低，但是，在其他实现中，这可能会有所不同。</p><p id="6ee3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<code class="du jn jo jp jq b"><a class="ae la" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html" rel="noopener ugc nofollow" target="_blank">shareIn</a></code>中间操作器在多个收集器之间重复使用相同的流量，并使冷流量变热。</p><figure class="jr js jt ju fd hj"><div class="bz dy l di"><div class="mf jw l"/></div></figure><p id="4b33" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要了解更多关于在应用程序中添加<code class="du jn jo jp jq b">applicationScope</code>的最佳实践，请查看这篇<a class="ae la" rel="noopener" href="/androiddevelopers/coroutines-patterns-for-work-that-shouldnt-be-cancelled-e26c40f142ad">文章</a>。</p></div><div class="ab cl mu mv go mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ha hb hc hd he"><p id="1d27" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">考虑创建协程适配器，使您的API或现有的API简洁、易读且符合Kotlin习惯。首先检查适配器是否已经可用，如果不可用，使用<code class="du jn jo jp jq b">suspendCancellableCoroutine</code>创建自己的适配器进行一次性调用，使用<code class="du jn jo jp jq b">callbackFlow</code>创建流数据。</p><p id="4142" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要获得这个主题的实践经验，请查看构建Kotlin扩展库的<a class="ae la" href="https://codelabs.developers.google.com/codelabs/building-kotlin-extensions-library" rel="noopener ugc nofollow" target="_blank"> <em class="mb">代码实验室</em></a>。</p></div></div>    
</body>
</html>