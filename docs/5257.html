<html>
<head>
<title>Profiling a Java + JDBC Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">剖析Java + JDBC应用程序</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/profiling-a-java-jdbc-application-ed7d8a1b2077?source=collection_archive---------0-----------------------#2017-07-12">https://medium.com/oracledevs/profiling-a-java-jdbc-application-ed7d8a1b2077?source=collection_archive---------0-----------------------#2017-07-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8c3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，以这种方式分析Java程序不需要Java编码，也不需要Java源代码。NetBeans不久前添加了这个备份，我最近才发现它。能够连接到任何Java程序，并分析整个JDBC的SQL。开发团队关于它的博客在这里:<a class="ae jc" href="http://jj-blogger.blogspot.nl/2016/05/netbeans-sql-profiler-take-it-for-spin.html" rel="noopener ugc nofollow" target="_blank">http://jj-blogger . blogspot . nl/2016/05/netbeans-SQL-profiler-take-it-for-spin . html</a></p><h1 id="1bbc" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">SQLcl</h1><p id="c517" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">SQLcl是我们用于编写sql/sql脚本的Java库，从05/06年的第0天起就在SQLDev中了。我们考虑了这一点，并在它周围加了一条cmd线。这使得测试特性、回归、性能等变得更加容易。以及提供具有扩展特征的新cmd线。这个库也是执行Oracle数据库网格基础设施安装的库，并且嵌入在<a class="ae jc" href="http://oracle.com/rest" rel="noopener ugc nofollow" target="_blank"> Oracle REST数据服务</a>中。这是经过验证和测试的。这是所有使用普通JDBC与数据库对话的Java库。它与任何基于java的应用程序没有什么不同，这意味着它适用于任何java程序，例如sqldeveloper、ords、自定义jdbc、任何java程序。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/77ec7daecd94118ef8dbb2df1f00f020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*-5ZZ9RX_7VpYGajk.png"/></div></figure><h1 id="f8c2" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">压型</h1><p id="81f5" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">Netbeans中的这个新特性使用起来非常简单，并且不需要jsvs代码的源代码。关闭配置文件菜单→附加到外部进程</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ko"><img src="../Images/2074f1dd17a1499d9edf89df91ed194c.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*cqDijHXrJvjbpSkr.png"/></div></figure><p id="886a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后将配置文件设置为SQL查询</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kp"><img src="../Images/dbf9ae76d932de21893c19eff5134dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/0*vgVc_kSgfRYOf5en.png"/></div></figure><p id="6589" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">单击Attach，显示正在运行的java进程列表。这就是SQL的样子。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/8bfe6c1dab4809b3e5541548bb635d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*keQwni_da9QsIsKC.png"/></div></figure><h1 id="b6ac" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">运行程序</h1><p id="a7b3" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">现在，一旦JDBC流量开始发出，就可以捕获该语句的计时和出现时间，以及发出调用的Java堆栈。接下来是最难的部分，这些数据到底意味着什么？什么时候才算快，够快？</p><h1 id="afcf" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">要改什么？</h1><p id="95ef" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">下面是APEX安装在我的笔记本电脑上进行到一半时的样子。有很多数据要看。最慢的语句是dbms注册表验证。很糟糕吗，可以加速吗？大概不会。调用最多的是对DBMS _ OUPUT的检查。那能减少吗？还有，大概不会。</p><p id="912b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是代码和预期动作的知识至关重要的时候。对我来说，将SQL程序从19m压缩到7m已经足够快了。这是通过对APEX安装脚本的<strong class="ig hi">零</strong>更改完成的，但只是通过观察流向数据库的流量并对其进行分析。</p><p id="4292" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">变化# 1:SQL被命名为解析每一个create或replace <plsql object="">,然后检查该对象上的错误。更快的方法是直接从user_errors中检查count(1 ),而不进行名称解析。当user_errors表中没有错误时，不需要命名resolve。所以整个路径被缩短了。它在这个堆栈中是可见的，调用了1，106次“select count(1)CNT from user _ errors”。变化#2: DBMS_OUTPUT在对数据库的任何/所有命令之后被调用。这减少到只能调用一些输出。例如，不需要检查alter session。这一变化减少了发出的db调用的数量。最快的电话是那些你没有打的电话。等等等等。</plsql></p><p id="ad51" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">没有什么比了解预期结果更重要的了。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/1b744a99041bba42ab9bfad64283d923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*nUWEy_CUcSU0ykvX.png"/></div></figure></div><div class="ab cl kq kr go ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ha hb hc hd he"><p id="72d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kx">原载于2017年7月12日</em><a class="ae jc" href="http://krisrice.io/2017-07-12-profiling-java-jdbc-application/" rel="noopener ugc nofollow" target="_blank"><em class="kx">Kris rice . io</em></a><em class="kx">。</em></p></div></div>    
</body>
</html>