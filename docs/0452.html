<html>
<head>
<title>Alter type with typealias</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用typealias改变类型</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/alter-type-with-typealias-4c03302fbe43?source=collection_archive---------2-----------------------#2020-01-16">https://medium.com/androiddevelopers/alter-type-with-typealias-4c03302fbe43?source=collection_archive---------2-----------------------#2020-01-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/32f9975fd0c3198a5203e0e15df3b9e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3V2U8qG7bua3PGlA5t_KA.png"/></div></div></figure><div class=""/><div class=""><h2 id="ab8c" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">科特林词汇:<code class="du jh ji jj jk b">typealias</code></h2></div><p id="739a" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">当类型定义因为不可读、不具表达性或者太长而偏离了代码的含义时，Kotlin正好有适合你的特性:<code class="du jh ji jj jk b"><a class="ae kh" href="https://kotlinlang.org/docs/reference/type-aliases.html" rel="noopener ugc nofollow" target="_blank">typealias</a></code>！Typealias允许您在不引入新类型的情况下为类或函数类型提供替换名称。</p><h1 id="3967" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">Typealias用法</h1><p id="4672" class="pw-post-body-paragraph jl jm hs jn b jo la it jq jr lb iw jt ju lc jw jx jy ld ka kb kc le ke kf kg ha bi translated">您可以使用类型别名来命名函数类型:</p><pre class="lf lg lh li fd lj jk lk ll aw lm bi"><span id="eac0" class="ln kj hs jk b fi lo lp l lq lr">typealias TeardownLogic = () -&gt; Unit<br/>fun onCancel(teardown : TeardownLogic){ }</span><span id="4c57" class="ln kj hs jk b fi ls lp l lq lr">private typealias OnDoggoClick = (dog: Pet.GoodDoggo) -&gt; Unit<br/>val onClick: OnDoggoClick</span></pre><p id="31da" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">这样做的缺点是名称隐藏了传递给函数的参数，降低了可读性:</p><pre class="lf lg lh li fd lj jk lk ll aw lm bi"><span id="3a1c" class="ln kj hs jk b fi lo lp l lq lr">typealias TeardownLogic = () -&gt; Unit //or<br/>typealias TeardownLogic = (exception: Exception) -&gt; Unit</span><span id="009e" class="ln kj hs jk b fi ls lp l lq lr">fun onCancel(teardown : TeardownLogic){<br/>// can’t easily see what information we have <br/>// available in TeardownLogic<br/>}</span></pre><p id="cd87" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated"><code class="du jh ji jj jk b">Typealias</code>允许您缩短长的通用名称:</p><pre class="lf lg lh li fd lj jk lk ll aw lm bi"><span id="d9e1" class="ln kj hs jk b fi lo lp l lq lr">typealias Doggos = List&lt;Pet.GoodDoggo&gt;</span><span id="1ef5" class="ln kj hs jk b fi ls lp l lq lr">fun train(dogs: Doggos){ … }</span></pre><p id="4919" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">虽然这是可能的，但是问问你自己你是否真的应该做这件事。使用类型别名真的能让你的代码更有意义和可读性吗？</p><blockquote class="lu"><p id="ebc3" class="lv lw hs bd lx ly lz ma mb mc md kg dx translated">问问自己，使用类型别名是否会让代码更容易理解。</p></blockquote><p id="5757" class="pw-post-body-paragraph jl jm hs jn b jo me it jq jr mf iw jt ju mg jw jx jy mh ka kb kc mi ke kf kg ha bi translated">如果您正在使用一个长类名，您可以使用<code class="du jh ji jj jk b">typealias</code>来缩短它:</p><pre class="lf lg lh li fd lj jk lk ll aw lm bi"><span id="f8eb" class="ln kj hs jk b fi lo lp l lq lr">typealias AVD = AnimatedVectorDrawable</span></pre><p id="f20c" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">但是对于这个用例，更好的选择是使用<a class="ae kh" href="https://kotlinlang.org/docs/reference/packages.html#imports" rel="noopener ugc nofollow" target="_blank"> <strong class="jn ht">导入别名</strong> </a>:</p><pre class="lf lg lh li fd lj jk lk ll aw lm bi"><span id="f53d" class="ln kj hs jk b fi lo lp l lq lr">import android.graphics.drawable.AnimatedVectorDrawable <strong class="jk ht">as</strong> AVD</span></pre><p id="57a4" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">在这种情况下，使用快捷方式并不能真正提高可读性，IDE可以帮助自动完成类名。</p><p id="001e" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">但是，当您需要区分来自不同包的同名类时，导入别名变得特别有用:</p><pre class="lf lg lh li fd lj jk lk ll aw lm bi"><span id="3677" class="ln kj hs jk b fi lo lp l lq lr">import io.plaidapp.R <strong class="jk ht">as</strong> appR</span><span id="628c" class="ln kj hs jk b fi ls lp l lq lr">import io.plaidapp.<strong class="jk ht">about</strong>.R</span></pre><p id="499f" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">类型别名是在类之外定义的，所以在使用它们的时候一定要考虑它们的可见性。</p><h1 id="9413" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated"><code class="du jh ji jj jk b">Typealias</code>用于多平台项目</h1><p id="5a50" class="pw-post-body-paragraph jl jm hs jn b jo la it jq jr lb iw jt ju lc jw jx jy ld ka kb kc le ke kf kg ha bi translated">当使用<a class="ae kh" href="https://kotlinlang.org/docs/reference/platform-specific-declarations.html" rel="noopener ugc nofollow" target="_blank">多平台项目</a>时，您可以在公共代码中指定接口，然后在平台代码中实现这些接口。为了使这更容易，Kotlin提供了一种预期和实际声明的机制。</p><p id="1b0f" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">公共代码中的接口是预期的声明，使用<code class="du jh ji jj jk b">expect</code>关键字定义。平台代码中的实现使用<code class="du jh ji jj jk b">actual</code>关键字定义。如果实现已经存在于其中一个平台中，并且所有期望的方法都具有完全相同的签名，那么您可以使用<code class="du jh ji jj jk b">typealias</code>将类名映射到期望的名称。</p><pre class="lf lg lh li fd lj jk lk ll aw lm bi"><span id="b0a1" class="ln kj hs jk b fi lo lp l lq lr">expect annotation class Test</span><span id="3cfb" class="ln kj hs jk b fi ls lp l lq lr">actual typealias Test = org.junit.Test</span></pre><h1 id="1155" class="ki kj hs bd kk kl km kn ko kp kq kr ks iy kt iz ku jb kv jc kw je kx jf ky kz bi translated">在后台</h1><p id="e566" class="pw-post-body-paragraph jl jm hs jn b jo la it jq jr lb iw jt ju lc jw jx jy ld ka kb kc le ke kf kg ha bi translated">类型别名不会引入新类型。例如，<code class="du jh ji jj jk b">train</code>函数的反编译代码将只使用一个列表:</p><pre class="lf lg lh li fd lj jk lk ll aw lm bi"><span id="e6b2" class="ln kj hs jk b fi lo lp l lq lr">// Kotlin<br/>typealias Doggos = List&lt;Pet.GoodDoggo&gt;<br/>fun train(dogs: Doggos) { … }</span><span id="414a" class="ln kj hs jk b fi ls lp l lq lr">// Decompiled Java code<br/>public static final void train(@NotNull List dogs) { … }</span></pre><blockquote class="lu"><p id="1afc" class="lv lw hs bd lx ly mj mk ml mm mn kg dx translated">类型别名不会引入新类型。</p></blockquote><p id="d5a7" class="pw-post-body-paragraph jl jm hs jn b jo me it jq jr mf iw jt ju mg jw jx jy mh ka kb kc mi ke kf kg ha bi translated">您不应该依赖类型别名来进行编译时类型检查。相反，您应该考虑使用不同的类型或内联类。例如，假设我们有以下函数:</p><pre class="lf lg lh li fd lj jk lk ll aw lm bi"><span id="11a1" class="ln kj hs jk b fi lo lp l lq lr">fun play(dogId: Long)</span></pre><p id="356f" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">当我们试图传递错误的id时，为<code class="du jh ji jj jk b">Long</code>创建类型别名不会帮助我们防止错误:</p><pre class="lf lg lh li fd lj jk lk ll aw lm bi"><span id="b02c" class="ln kj hs jk b fi lo lp l lq lr">typealias DogId = Long</span><span id="d26c" class="ln kj hs jk b fi ls lp l lq lr">fun pet(dogId: DogId) { … }</span><span id="7718" class="ln kj hs jk b fi ls lp l lq lr">fun usage() {<br/>    val cat = Cat(1L)<br/>    pet(cat.catId) // compiles<br/>}</span></pre></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><p id="058d" class="pw-post-body-paragraph jl jm hs jn b jo jp it jq jr js iw jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">类型别名是为现有类型提供更短或更有意义的名称的一种方式。如果你正在寻找的是额外的安全性，你可能想创造一种新的类型。</p></div></div>    
</body>
</html>