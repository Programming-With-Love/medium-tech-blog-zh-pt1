<html>
<head>
<title>Evolving MySQL Compression — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">发展MySQL压缩—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/evolving-mysql-compression-part-2-2c3eb0101205?source=collection_archive---------1-----------------------#2017-01-30">https://medium.com/pinterest-engineering/evolving-mysql-compression-part-2-2c3eb0101205?source=collection_archive---------1-----------------------#2017-01-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d989" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">本帖接续上一篇，</em> <a class="ae jd" href="https://engineering.pinterest.com/blog/evolving-mysql-compression-part-1" rel="noopener ugc nofollow" target="_blank"> <em class="jc">进化MySQL压缩</em> </a> <em class="jc">。</em></p><p id="70f5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">威廉·汤姆| Pinterest工程师</p><p id="fbab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pinterest的主要数据源——Pin数据——在我们的MySQL集群中存储为中等大小(~1.2kb)的JSON blobs。这些blobs是非常可压缩的，但是MySQL中现有的压缩系统并不是最佳的，只能实现2:1的压缩。在<a class="ae jd" href="https://engineering.pinterest.com/blog/evolving-mysql-compression-part-1" rel="noopener ugc nofollow" target="_blank">之前的文章</a>中，我们讨论了为什么列压缩是更理想的压缩系统。为了使用列压缩并获得显著的节省，我们需要使用一个压缩和可选的预定义压缩字典(即回看窗口)。在这里，我们将介绍如何将Pin数据的压缩率从大约3:1提高到3.47:1。</p><h2 id="2153" class="je jf hh bd jg jh ji jj jk jl jm jn jo ip jp jq jr it js jt ju ix jv jw jx jy bi translated">背景</h2><p id="0279" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">首先，让我们看看InnoDB使用的底层压缩库，<a class="ae jd" href="http://zlib.net/" rel="noopener ugc nofollow" target="_blank"> Zlib </a>，一个最初用于PNG文件格式的压缩库。Zlib的压缩遵循由两个主要阶段组成的<a class="ae jd" href="http://www.zlib.net/feldspar.html" rel="noopener ugc nofollow" target="_blank"> DEFLATE </a>压缩算法。首先，LZ77用指向该字符串的前一个实例的指针以及要重复的字符串的长度来替换重复出现的字符串。然后对结果数据进行霍夫曼编码。我们通过使用预定义的字典来优化LZ77阶段，该字典预加载具有公共子串的回看窗口。由于每个压缩的数据对象都比滑动窗口小得多，这种方法特别有效，允许每个Pin对象的整体回顾预定义窗口的大部分。我们受到了由<a class="ae jd" href="https://blog.cloudflare.com/improving-compression-with-preset-deflate-dictionary/" rel="noopener ugc nofollow" target="_blank"> Cloudflare </a>完成的类似工作的启发。</p><h2 id="2f29" class="je jf hh bd jg jh ji jj jk jl jm jn jo ip jp jq jr it js jt ju ix jv jw jx jy bi translated">初始测试</h2><p id="7a4c" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">在开始这个项目之前，预定义的字典由一个单一的Pin对象填充。压缩比大约是3:1，这是很好的，因为所有Pin对象共享大致相同的方案，允许重用密钥。然而，我们知道我们可以做得更好。</p><p id="61a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">pin共享某些JSON字段或这些字段的子字符串是很常见的。通过只使用一个Pin，我们没有利用那些JSON值带来的额外节省。这类字段的例子有通常以“http://”开头的链接，或者需要布尔值的字段。我进行了几次快速按压，以确保有节余。我取了大约10，000个pin，将它们连接起来，并使用最大的窗口大小(32kb)和最高的压缩级别(Z_BEST_COMPRESSION，9)对它们进行压缩。这允许每个管脚回顾以前的25个左右的管脚来寻找公共串，同时尽可能地压缩数据。然后，我做了同样的事情，但是，在连接之前打乱了每个引脚的字节。因为每个字节的相对频率仍然相同(忽略用LZ77回看元组替换的字符串)，DEFLATE的霍夫曼编码部分产生了大致相同的节省。压缩率的差异将提供预期节省的近似值。另一种选择是使用<a class="ae jd" href="https://refspecs.linuxbase.org/LSB_3.0.0/LSB-PDA/LSB-PDA/zlib-deflatesetdictionary-1.html" rel="noopener ugc nofollow" target="_blank"> deflateSetDictionary </a>用一些引脚填充预定义的字典，但是第一种方法允许大致相同的结果，而不必编写代码。不管怎样，结果显示有节省，所以我继续这个项目。</p><h2 id="1ad4" class="je jf hh bd jg jh ji jj jk jl jm jn jo ip jp jq jr it js jt ju ix jv jw jx jy bi translated">该过程</h2><p id="5386" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">最初，我试图修改Zlib源代码，以确定LZ77部分压缩了哪些公共字符串，以便在预定义的字典中使用。用C语言编程并不是我最快的编码语言，所以大约一周后，我决定写自己的实用程序来为Pin对象生成一个像样的预定义字典，这比花我的实习时间来精通高度优化的K&amp;R风格的C语言要痛苦得多</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ke"><img src="../Images/fd48bd0f227c6ef888716cd1ce31580b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WNDOOuw6ffrrMCAJ.png"/></div></div></figure><p id="8240" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我从两个不同的碎片数据库和两个不同的生成时代取了大量的pin(~ 200k)。我们基于userID进行分片，所以早期的分片数据库包含许多旧的pin，与最近添加的pin相比，它们的模式有些不同。</p><p id="9ed4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了为所有pin生成一个更通用的预定义字典，我以三种不同的方式混合输入数据:</p><ol class=""><li id="5aed" class="kq kr hh ig b ih ii il im ip ks it kt ix ku jb kv kw kx ky bi translated">旧碎片上的随机密码对。</li><li id="0b89" class="kq kr hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated">新碎片上的随机密码对。</li><li id="3d74" class="kq kr hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated">来自旧碎片的随机pin与来自新碎片的随机pin配对。</li></ol><p id="2304" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我分批处理这些管脚对，同时在批中的每个管脚对之间寻找公共子串(在回看窗口和前瞻缓冲区中，都大于3个字节)。</p><p id="34a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为这是一个<em class="jc">长</em>的运行过程，所以我在每个完成的批处理结束时维护了持久状态，这允许脚本在失败时从最后一个完成的批处理开始。然后，来自每一批的子串频率被聚集并传递到下一步，即字典生成。</p><h2 id="6662" class="je jf hh bd jg jh ji jj jk jl jm jn jo ip jp jq jr it js jt ju ix jv jw jx jy bi translated">字典生成</h2><p id="d896" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">批处理后，根据子串的长度和出现频率对子串进行评分。为了避免在输出字典中出现重复的子字符串，我们将完全包含的子字符串进行吞咽，并将分数合并到吞咽子字符串的分数中。符合定义的字典大小的最高<em class="jc"> n </em>得分字符串被连接在一起，这样得分较高的字符串位于字典的末尾(根据<a class="ae jd" href="http://www.zlib.net/manual.html" rel="noopener ugc nofollow" target="_blank"> zlib手册</a>)。然后，任何突出部分被截断，结果作为预定义的字典交给用户。</p><p id="309e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管实现速度很慢，但我们发现100，000对管脚之间的公共子串的频率只需要400多CPU天。我们没有花时间来提高性能，因为生成字典本身并不是一项经常运行的任务。此外，尽管我很想提出一个有效的最短公共超序列解决方案，以便在预定义的字典中更合适，但它是<a class="ae jd" href="http://www.sciencedirect.com/science/article/pii/030439758190075X" rel="noopener ugc nofollow" target="_blank"> NP-complete </a>。</p><p id="537a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些工具已经被添加到我们的开源工具库中，希望对其他人有用。</p><h2 id="47cd" class="je jf hh bd jg jh ji jj jk jl jm jn jo ip jp jq jr it js jt ju ix jv jw jx jy bi translated">基准</h2><p id="b89f" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">使用这个预定义字典的基准看起来很有前途。就空间节省而言，计算字典比使用单个Pin作为预定义字典节省了10%以上，此外还比现有的InnoDB页面压缩节省了40%。我们考虑使用8kb或16KB的字典，而不是32KB (32506B)的字典，作为提高性能的折衷，但是因为这不是必需的，所以我们没有提高zlib压缩级别来最大化压缩节省。</p><figure class="kf kg kh ki fd kj er es paragraph-image"><div class="er es le"><img src="../Images/1ca77558143bb7211425c230944a0bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/0*5px3AxfA9Bk3vwX8.png"/></div></figure><h2 id="4286" class="je jf hh bd jg jh ji jj jk jl jm jn jo ip jp jq jr it js jt ju ix jv jw jx jy bi translated">后续步骤</h2><p id="77c6" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip kb ir is it kc iv iw ix kd iz ja jb ha bi translated">当撰写关于列压缩的第一篇博文<a class="ae jd" href="https://engineering.pinterest.com/blog/evolving-mysql-compression-part-1" rel="noopener ugc nofollow" target="_blank">时，我们还没有将这种变化部署到生产中。从那以后，我们已经顺利地推出了列压缩。</a></p><p id="ad60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在未来，我们计划测试一个Pin管理的静态Huffman树，作为额外节省的潜在途径。目前，zlib不支持这种功能，将根据大小使用一般的静态代码或动态代码。</p><p id="26a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">鸣谢:感谢Rob Wultsch的指导和教导。感谢Pinterest让我的实习成为一次难忘的经历。</em></p></div></div>    
</body>
</html>