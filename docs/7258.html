<html>
<head>
<title>Keeping the Daggers Sharp ⚔️</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保持匕首锋利⚔️</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/keeping-the-daggers-sharp-%EF%B8%8F-230b3191c3f?source=collection_archive---------0-----------------------#2017-10-11">https://medium.com/square-corner-blog/keeping-the-daggers-sharp-%EF%B8%8F-230b3191c3f?source=collection_archive---------0-----------------------#2017-10-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie if ig"><p id="0d9f" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jg" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="fc27" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jh iu iv iw ji iy iz ja jj jc jd je jf ha bi translated">Dagger 2是一个很好的依赖注入库，但是它的锐利边缘可能很难处理。让我们回顾一下Square遵循的一些最佳实践，以防止移动工程师伤害自己！</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jk"><img src="../Images/cf985b6f5343a6aa599fdb38b7daf804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fsp9x_JcuJijFVotF1NQA.png"/></div></div></figure><h1 id="6afd" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">支持构造注入，而不是现场注入</h1><ul class=""><li id="ebb0" class="ku kv hh ik b il kw ip kx jh ky ji kz jj la jf lb lc ld le bi translated">字段注入要求字段是非最终的和非私有的。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="3abb" class="lk jx hh lg b fi ll lm l ln lo">// BAD<br/>class CardConverter {</span><span id="a2c5" class="lk jx hh lg b fi lp lm l ln lo">  <strong class="lg hi">@Inject</strong> PublicKeyManager publicKeyManager;</span><span id="5ad6" class="lk jx hh lg b fi lp lm l ln lo">  <strong class="lg hi">@Inject</strong> public CardConverter() {}<br/>}</span></pre><ul class=""><li id="a936" class="ku kv hh ik b il im ip iq jh lq ji lr jj ls jf lb lc ld le bi translated">在字段上忘记一个<code class="du lt lu lv lg b">@Inject</code>会引入一个<code class="du lt lu lv lg b">NullPointerException</code>。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="adda" class="lk jx hh lg b fi ll lm l ln lo">// BAD<br/>class CardConverter {</span><span id="9f60" class="lk jx hh lg b fi lp lm l ln lo"><strong class="lg hi">  @Inject</strong> PublicKeyManager publicKeyManager;<br/>  Analytics analytics; // Oops, forgot to @Inject</span><span id="bbdc" class="lk jx hh lg b fi lp lm l ln lo"><strong class="lg hi">  @Inject</strong> public CardConverter() {}<br/>}</span></pre><ul class=""><li id="402f" class="ku kv hh ik b il im ip iq jh lq ji lr jj ls jf lb lc ld le bi translated">构造函数注入更好，因为它允许<strong class="ik hi">不可变的</strong>，因此<strong class="ik hi">线程安全的</strong>对象没有部分构造的状态。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="3aa3" class="lk jx hh lg b fi ll lm l ln lo">// GOOD<br/>class CardConverter {</span><span id="2d9f" class="lk jx hh lg b fi lp lm l ln lo">  private final PublicKeyManager publicKeyManager;</span><span id="628b" class="lk jx hh lg b fi lp lm l ln lo">  <strong class="lg hi">@Inject</strong> public CardConverter(PublicKeyManager publicKeyManager) {<br/>    this.publicKeyManager = publicKeyManager;<br/>  }<br/>}</span></pre><ul class=""><li id="f0a7" class="ku kv hh ik b il im ip iq jh lq ji lr jj ls jf lb lc ld le bi translated">Kotlin消除了构造函数注入样板文件:</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="260b" class="lk jx hh lg b fi ll lm l ln lo">class CardConverter<br/><strong class="lg hi">@Inject</strong> <strong class="lg hi">constructor</strong>(<br/>  private val publicKeyManager: PublicKeyManager<br/>)</span></pre><ul class=""><li id="e693" class="ku kv hh ik b il im ip iq jh lq ji lr jj ls jf lb lc ld le bi translated">我们仍然对系统构造的对象使用字段注入，比如Android活动:</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="5366" class="lk jx hh lg b fi ll lm l ln lo">public class MainActivity extends Activity {</span><span id="27e6" class="lk jx hh lg b fi lp lm l ln lo">  public interface Component {<br/>    <strong class="lg hi">void inject(MainActivity activity);</strong><br/>  }</span><span id="be3a" class="lk jx hh lg b fi lp lm l ln lo">  <strong class="lg hi">@Inject</strong> ToastFactory toastFactory;</span><span id="7290" class="lk jx hh lg b fi lp lm l ln lo">  @Override protected void onCreate(Bundle savedInstanceState) {<br/>    super.onCreate(savedInstanceState);<br/>    Component component = SquareApplication.component(this);<br/>    component.<strong class="lg hi">inject</strong>(this);<br/>  }<br/>}</span></pre><h1 id="a530" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">单身应该是极其罕见的</h1><ul class=""><li id="af41" class="ku kv hh ik b il kw ip kx jh ky ji kz jj la jf lb lc ld le bi translated">当我们需要对可变状态的集中访问时，单例是有用的。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="5c54" class="lk jx hh lg b fi ll lm l ln lo">// GOOD<strong class="lg hi"><br/>@Singleton</strong><br/>public class BadgeCounter {</span><span id="02bf" class="lk jx hh lg b fi lp lm l ln lo">  public final <strong class="lg hi">Observable&lt;Integer&gt; badgeCount</strong>;</span><span id="c1ae" class="lk jx hh lg b fi lp lm l ln lo">  @Inject public BadgeCounter(...) {<br/>     badgeCount = ...<br/>  }  <br/>}</span></pre><ul class=""><li id="067f" class="ku kv hh ik b il im ip iq jh lq ji lr jj ls jf lb lc ld le bi translated">如果一个对象没有可变状态，它不需要是单例的。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="fd9f" class="lk jx hh lg b fi ll lm l ln lo"><strong class="lg hi">// </strong>BAD<strong class="lg hi">,</strong> should not be a singleton!<strong class="lg hi">  <br/>@Singleton</strong><br/>class RealToastFactory implements ToastFactory {<br/>  private <strong class="lg hi">final</strong> Application context;</span><span id="e0e3" class="lk jx hh lg b fi lp lm l ln lo">  @Inject public RealToastFactory(Application context) {<br/>    this.context = context;<br/>  }</span><span id="b4e0" class="lk jx hh lg b fi lp lm l ln lo">  @Override public Toast makeText(int resId, int duration) {<br/>    return Toast.makeText(context, resId, duration);<br/>  }<br/>}</span></pre><ul class=""><li id="12ab" class="ku kv hh ik b il im ip iq jh lq ji lr jj ls jf lb lc ld le bi translated">在极少数情况下，我们使用作用域来缓存创建成本高的实例，或者重复创建并丢弃的实例。</li></ul><h1 id="0a33" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">更喜欢“注入”而不是“提供”</h1><ul class=""><li id="62d2" class="ku kv hh ik b il kw ip kx jh ky ji kz jj la jf lb lc ld le bi translated"><code class="du lt lu lv lg b">@Provides</code>方法不应该复制构造函数样本。</li><li id="804f" class="ku kv hh ik b il lw ip lx jh ly ji lz jj ma jf lb lc ld le bi translated">当耦合的关注点在一个地方时，代码更容易理解。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="811c" class="lk jx hh lg b fi ll lm l ln lo">@Module<br/>class ToastModule {<br/>  // BAD, remove this binding and add @Inject to RealToastFactory<br/>  <strong class="lg hi">@Provides</strong> RealToastFactory realToastFactory(Application context) {<br/>    return <strong class="lg hi">new RealToastFactory(context)</strong>;<br/>  }<br/>}</span></pre><ul class=""><li id="e8ca" class="ku kv hh ik b il im ip iq jh lq ji lr jj ls jf lb lc ld le bi translated">这对<strong class="ik hi">单身族</strong>尤其重要；这是一个关键的<strong class="ik hi">实现细节</strong>，你需要在阅读这个类的时候知道。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="8e56" class="lk jx hh lg b fi ll lm l ln lo">// GOOD, I have all the details I need in one place.<strong class="lg hi"><br/>@Singleton</strong><br/>public class BadgeCounter {</span><span id="84cd" class="lk jx hh lg b fi lp lm l ln lo"><strong class="lg hi">  @Inject</strong> public BadgeCounter(...) {}  <br/>}</span></pre><h1 id="792c" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">偏爱static @Provides方法</h1><ul class=""><li id="aaae" class="ku kv hh ik b il kw ip kx jh ky ji kz jj la jf lb lc ld le bi translated">匕首<code class="du lt lu lv lg b">@Provides</code>的方法可以是静态的。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="d1b4" class="lk jx hh lg b fi ll lm l ln lo">@Module<br/>class ToastModule {<br/>  @Provides<br/>  <strong class="lg hi">static</strong> ToastFactory toastFactory(RealToastFactory factory) {<br/>    return factory;<br/>  }<br/>}</span></pre><ul class=""><li id="896e" class="ku kv hh ik b il im ip iq jh lq ji lr jj ls jf lb lc ld le bi translated">生成的代码可以直接调用该方法，而不必创建模块实例。该方法调用可以由编译器内联。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="8ad1" class="lk jx hh lg b fi ll lm l ln lo">@Generated<br/>public final class DaggerAppComponent extends AppComponent {<br/>  // ...</span><span id="6b18" class="lk jx hh lg b fi lp lm l ln lo">  @Override public ToastFactory toastFactory() {<br/>    return <strong class="lg hi">ToastModule.toastFactory</strong>(realToastFactoryProvider.get())<br/>  }<br/>}</span></pre><ul class=""><li id="60db" class="ku kv hh ik b il im ip iq jh lq ji lr jj ls jf lb lc ld le bi translated">一个静态方法不会改变太多，但是所有绑定都是静态的将会导致相当大的性能提升。</li><li id="6dba" class="ku kv hh ik b il lw ip lx jh ly ji lz jj ma jf lb lc ld le bi translated">使你的模块抽象，如果其中一个<code class="du lt lu lv lg b">@Provides</code>方法不是静态的，那么<a class="ae jg" href="https://github.com/google/dagger/issues/621#issuecomment-321868005" rel="noopener ugc nofollow" target="_blank">将在编译时失败</a>。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="efd7" class="lk jx hh lg b fi ll lm l ln lo">@Module<br/><strong class="lg hi">abstract</strong> class ToastModule {<br/>  @Provides<br/>  <strong class="lg hi">static</strong> ToastFactory toastFactory(RealToastFactory factory) {<br/>    return factory;<br/>  }<br/>}</span></pre><h1 id="f487" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">偏爱“约束”提供</h1><ul class=""><li id="0c97" class="ku kv hh ik b il kw ip kx jh ky ji kz jj la jf lb lc ld le bi translated">当您将一种类型映射到另一种类型时,<code class="du lt lu lv lg b">@Binds</code>会替换<code class="du lt lu lv lg b">@Provides</code>。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="7965" class="lk jx hh lg b fi ll lm l ln lo">@Module<br/>abstract class ToastModule {<br/>  <strong class="lg hi">@Binds</strong><br/>  <strong class="lg hi">abstract</strong> <strong class="lg hi">ToastFactory</strong> toastFactory(<strong class="lg hi">RealToastFactory</strong> factory);<br/>}</span></pre><ul class=""><li id="f857" class="ku kv hh ik b il im ip iq jh lq ji lr jj ls jf lb lc ld le bi translated">该方法必须是抽象的。它永远不会被调用；生成的代码将知道直接使用实现。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="361d" class="lk jx hh lg b fi ll lm l ln lo">@Generated<br/>public final class DaggerAppComponent extends AppComponent {<br/>  // ...</span><span id="507b" class="lk jx hh lg b fi lp lm l ln lo">  private DaggerAppComponent() {<br/>    // ...<br/>    this.<strong class="lg hi">toastFactoryProvider = </strong>(Provider)<strong class="lg hi"> realToastFactoryProvider;</strong><br/>  }</span><span id="b9c6" class="lk jx hh lg b fi lp lm l ln lo">  @Override public ToastFactory toastFactory() {<br/>    return toastFactoryProvider.get();<br/>  }<br/>}</span></pre><h1 id="b498" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">避免在接口绑定上使用@Singleton</h1><blockquote class="mb"><p id="77f9" class="mc md hh bd me mf mg mh mi mj mk jf dx translated">有状态是一个实现细节</p></blockquote><ul class=""><li id="4436" class="ku kv hh ik b il ml ip mm jh mn ji mo jj mp jf lb lc ld le bi translated">只有实现知道他们是否需要确保对可变状态的集中访问。</li><li id="429a" class="ku kv hh ik b il lw ip lx jh ly ji lz jj ma jf lb lc ld le bi translated">当将一个实现绑定到一个接口时，不应该有任何范围注释。</li></ul><pre class="jl jm jn jo fd lf lg lh li aw lj bi"><span id="70e6" class="lk jx hh lg b fi ll lm l ln lo">@Module<br/>abstract class ToastModule {<br/>  // BAD, remove @Singleton<br/>  @Binds <strong class="lg hi">@Singleton</strong><br/>  abstract <strong class="lg hi">ToastFactory</strong> toastFactory(<strong class="lg hi">RealToastFactory</strong> factory);<br/>}</span></pre><h1 id="200e" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">启用易出错</h1><p id="406b" class="pw-post-body-paragraph ih ii hh ik b il kw in io ip kx ir is jh mq iv iw ji mr iz ja jj ms jd je jf ha bi translated">几个方队正在用它来检测常见的匕首错误，<a class="ae jg" href="https://github.com/google/error-prone" rel="noopener ugc nofollow" target="_blank">来看看</a>。</p><h1 id="c08a" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h1><p id="7019" class="pw-post-body-paragraph ih ii hh ik b il kw in io ip kx ir is jh mq iv iw ji mr iz ja jj ms jd je jf ha bi translated">这些指导原则很适合我们的环境:小型异构团队在大型共享Android代码库上工作。由于您的环境可能不同，您应该应用对您的团队最有意义的东西。</p><h2 id="78db" class="lk jx hh bd jy mt mu mv kc mw mx my kg jh mz na kk ji nb nc ko jj nd ne ks nf bi translated">轮到你了！你遵循什么好的实践来保持你的匕首代码锋利？</h2></div></div>    
</body>
</html>