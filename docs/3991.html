<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/globant/kotlin-coroutines-part-2-scope-dispatchers-4d67e17eae82?source=collection_archive---------1-----------------------#2022-09-22">https://medium.com/globant/kotlin-coroutines-part-2-scope-dispatchers-4d67e17eae82?source=collection_archive---------1-----------------------#2022-09-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><h2 id="a5dd" class="hf hg hh bd hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id bi translated">Kotlin协程第2部分:范围和调度程序</h2><p id="e7f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io hr ip iq ir hv is it iu hz iv iw ix iy ha bi translated">使用移动应用程序时，我们总是需要执行后台操作，如通过网络发送详细信息或在后台执行长时间运行的操作。我们有许多库来实现这一点，但是今天我们将讨论Kotlin-Coroutines。我们总是需要管理后台线程的生命周期以及并发性。所以科特林正在为它提供scopes&amp;dispatcher。<br/>让我们讨论一下<strong class="ig iz">为什么我们需要使用范围和调度程序？<br/> </strong>传统的方法是执行异步或长时间运行的操作，我们会面临内存泄漏和管理生命周期等问题。为了解决这个问题，引入了协程作用域。</p><p id="caaf" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">协程的范围是什么？</strong></p><p id="82ba" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">顾名思义，它有助于定义协程的范围，也就是说，它基本上定义了协程的生命周期。作用域跟踪所有的协程，这有助于我们当作用域取消时，协程也被取消。每个协程构建器，如launch、async等。是CoroutineScope的扩展。协程不能在没有作用域的情况下启动。</p><p id="d3b1" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">协程作用域有助于结构并发的约定，所以基本上，作用域的上下文包含了帮助我们实施结构并发的作业实例。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/d478ae97c18f9cac90c7d0e44cd35bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8o-QWBOC4JLjFD6UuGsSg.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx">Image referred from <a class="ae jv" href="https://www.freepik.com/premium-vector/digital-marketing-infographic_4510149.htm" rel="noopener ugc nofollow" target="_blank">https://www.freepik.com/premium-vector/digital-marketing-infographic_4510149.htm</a></figcaption></figure><p id="b2a0" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">当我们看到每个范围时，我们会有一个清晰的想法。让我们看看下一个主题:我们有哪些作用域？这些人都听到了</p><ul class=""><li id="8825" class="jw jx hh ig b ih ja il jb hr jy hv jz hz ka iy kb kc kd ke bi translated"><strong class="ig iz">全球范围</strong></li><li id="26e8" class="jw jx hh ig b ih kf il kg hr kh hv ki hz kj iy kb kc kd ke bi translated"><strong class="ig iz">生命周期范围</strong></li><li id="b1ce" class="jw jx hh ig b ih kf il kg hr kh hv ki hz kj iy kb kc kd ke bi translated"><strong class="ig iz"> ViewModelScope </strong></li><li id="5921" class="jw jx hh ig b ih kf il kg hr kh hv ki hz kj iy kb kc kd ke bi translated"><strong class="ig iz">验光仪</strong></li><li id="3eda" class="jw jx hh ig b ih kf il kg hr kh hv ki hz kj iy kb kc kd ke bi translated"><strong class="ig iz">主镜</strong></li></ul><p id="5668" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz"> 1。全球范围</strong></p><p id="5dc7" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">当协同程序与全局作用域一起启动时，协同程序的生命周期就与应用程序的生命周期绑定在一起。这意味着只要应用程序被销毁，用全局作用域启动的协程就仍然有效。</p><p id="0b8a" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">实时用例:</strong></p><p id="3f42" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">当我们想要执行一个在整个应用程序的生命周期中运行的任务时。例如，从服务器获取配置或获取用户配置文件。</p><p id="e27c" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">注意:</strong>global scope类现在用@ DelicateCoroutinesApi注释标记。从现在开始，不推荐使用GlobalScope。全局作用域用于启动顶级协程，这些协程在整个应用程序生存期内运行，并且不会被临时取消。例如，考虑以下代码:</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kk"><img src="../Images/bfcbb6e0921600ced68f5389e35c8b46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QZNtspTl_-ROkYObj8ZbQA.png"/></div></div></figure><p id="c367" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">上面在GlobalScope中创建了一个协程，它在后台工作，没有任何取消它或等待它完成的规定。如果网络很慢，它会一直在后台等待，消耗资源，因此很容易意外地造成资源或内存泄漏。</p><p id="ce12" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz"> 2。生命周期范围:</strong></p><p id="2d5b" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">当协程与生命周期范围一起启动时，协程的生命周期与活动或片段的生命周期联系在一起。这意味着当活动或片段被破坏时，协程也随之死亡。</p><p id="57f8" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">若要访问活动生命周期的协同作用域，请使用lifecycle.coroutineScope，对于片段，请使用lifecycleOwner.lifecycleScope。</p><p id="2545" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">实时用例:</strong></p><p id="caad" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">1.我们可以使用lifecycleScope来执行一些UI任务，例如预计算文本和显示工具屏幕(成功、错误或介绍滑块屏幕)。</p><p id="046e" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">2.我们可能有其他的用例，我们希望在特定的生命周期状态下执行一个功能，并在该状态之外停止或取消，例如，LiveData Observer。</p><p id="c53e" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">举例:</strong></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kl"><img src="../Images/328095318eb6b0ebb5ffe1b361bb4448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTzHu1M53NBQACFGADX2OQ.png"/></div></div></figure><p id="a2a1" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz"> 3。ViewModel范围</strong></p><p id="5248" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">ViewModelScope是为每个视图模型定义的。当存在只应在ViewModel活动时完成的工作时，此范围内的协程非常有用。如果清除了ViewModel，将自动取消使用viewModelScope协程。</p><p id="ab43" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">我们可以使用viewModelScope来执行操作，比如从服务器获取数据，在数据库中保存记录，等等。</p><p id="a9f2" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">实时用例:</strong></p><p id="8d97" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">1.如果我们使用的是ViewModel，并且我们想在后台执行一个任务，比如执行一个网络请求调用。对于这些类型的任务，我们将使用viewModelScope。</p><p id="9cad" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">2.我正在使用MVVM架构，并在ViewModel中执行一些后台任务，如执行网络请求调用。因此，我们可以在启动协程时使用viewModelScope。</p><p id="4079" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">举例:</strong></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es km"><img src="../Images/b8859c59d93461dd8139ec5482fc1dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdwckcUH0SIyoZCpUZADbg.png"/></div></div></figure><p id="b6a1" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">在android中，我们在KTX库中有内置的作用域。这些是生命周期感知组件，如viewModelScope和lifecycleScope。当使用这些作用域时，我们需要添加适当的依赖项。</p><p id="a415" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz"> 4。验光仪</strong></p><p id="3dd3" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">这将允许您使用自己的协程上下文来定义自定义范围。</p><p id="59d4" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">所以基本上启动一个协程需要一个协程作用域，这将把协程上下文作为一个参数。</p><p id="eda6" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">实时用例:</strong></p><p id="2574" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">在某些情况下，当我们想要控制协程的生命周期时，我们启动它们，以便我们可以取消它们并处理任何异常。</p><p id="fe93" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">例如:</strong></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kl"><img src="../Images/8043b325af36f38c89d730246727d344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDfCy8HfKvoe-D2oZZVShg.png"/></div></div></figure><p id="37c2" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">5.主镜</p><p id="0f88" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">它将在主线程即UI线程中启动协程。它使用<strong class="ig iz">调度器。Main </strong>为其协程。</p><p id="916d" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">例如:</strong></p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kn"><img src="../Images/c095353f8a65fe390a2b177fd9482b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tOIbD-gPx46CsvLgiuBMiw.png"/></div></div></figure><p id="6b76" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">是时候进入下一个话题了，即调度员。</p><p id="2dca" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">协程中的Dispatcher是什么？</strong></p><p id="7cee" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">调度程序基本上决定了协程在哪个线程上运行。如果不指定dispatcher，那么就很难预测协程在哪个线程上运行。这里有一个例子。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es ko"><img src="../Images/f4c61f1ab78132b714c1ffac4a563af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kkx7M9kCDWnuwGQdl94MGg.png"/></div></div></figure><p id="6be3" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">如果我们在协程之上启动，我们可以看到协程在其中启动的线程是无法预测的，有时它是DefaultDispatcher-worker-1，或DefaultDispatcher-worker-2，或DefaultDispatcher-worker-3，或DefaultDispatcher-worker-4。</p><p id="ee1e" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">但是，如果您想更精确地了解您的协程如何运行，您可以指定一个调度程序。在android中，应用程序调度器在管理不同类型的任务中扮演着重要的角色。</p><p id="bc30" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">协程中调度程序的类型。</p><p id="1b7a" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">所以我们在协程中有一些常用的调度程序。这些已在此列出。</p><ul class=""><li id="39fe" class="jw jx hh ig b ih ja il jb hr jy hv jz hz ka iy kb kc kd ke bi translated">主要调度员</li><li id="827c" class="jw jx hh ig b ih kf il kg hr kh hv ki hz kj iy kb kc kd ke bi translated">默认调度程序</li><li id="23fc" class="jw jx hh ig b ih kf il kg hr kh hv ki hz kj iy kb kc kd ke bi translated">IO调度程序</li><li id="dfc8" class="jw jx hh ig b ih kf il kg hr kh hv ki hz kj iy kb kc kd ke bi translated">不受限制的调度员</li></ul><p id="7c57" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">主要调度员:</strong></p><p id="0b35" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">主要的。Dispatcher主要用在我们要更新或者执行UI操作的时候。正如我们已经知道的，UI不能被更新，除非你在UI线程上，这意味着主线程。</p><p id="b70d" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">因此，为了更好地理解，让我们举一个例子。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kk"><img src="../Images/1d4b0bc4d1ba3b3dcee85adf06acdc80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wx4ixn35iptl82mG5m3DgA.png"/></div></div></figure><p id="ce2f" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">默认调度员:</strong></p><p id="b79c" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">默认调度程序对于CPU密集型工作非常有用。比如数据处理，图像处理。这种工作通常应该由默认的调度程序来完成。</p><p id="336f" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">举例:</strong></p><p id="7f72" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">假设我们有一个银行交易列表，而您想要过滤掉交易列表。因此，此后应用过滤器，我们需要做数据处理，并得到一个过滤列表。对于这种任务，我们使用默认的调度程序。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kk"><img src="../Images/8aae598ec429e0dc7afbf502c798911b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mL5weECkckZoM9wsiSrCwA.png"/></div></div></figure><p id="e93f" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz"> IO调度程序:</strong></p><p id="401b" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">它对于执行网络操作、读/写文件和数据库操作非常有用。所以任何输入输出操作都应该通过这些IO分配器。</p><p id="b9bc" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">让我们继续举一个例子。考虑从服务器获取数据，并将其保存在本地存储上。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kk"><img src="../Images/c0548060c8f02bfa9c44c72f481ffdd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dKXMuGwyeUTO8vD-roOuvA.png"/></div></div></figure><p id="4b77" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">不受限制的调度员</strong></p><p id="d6ac" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">调度员。Unconfined启动从直接父协程继承的中的协程，但只到第一个暂停点。挂起后，它在另一个线程中恢复协程。</p><p id="81d9" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">举例</strong>。</p><pre class="jg jh ji jj fd kp kq kr ks aw kt bi"><span id="d495" class="hf hg hh kq b fi ku kv l kw kx">runBlocking {<br/> launch(Dispatchers.Unconfined) {<br/> Log.i(“Dispatcher”, “Before suspension Thread <br/> ${Thread.currentThread().name}”)<br/> delay(300L)<br/> Log.i(Dispatcher, “After suspension Thread : ${Thread.currentThread().name}”)<br/>   }<br/> }</span></pre><p id="7c47" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">输出:</strong></p><p id="8e56" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">调度程序:挂起前线程:主线程</p><p id="ce22" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">调度程序:挂起后线程:kot linx . coroutines . default executor</p><p id="b23d" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated">如果我们执行上面的代码，我们可以看到在挂起之前，一号正在主线程上运行。然而，我们延迟了300毫秒，在暂停之后，实际上运行的是一个不同的线程。</p><p id="cc0a" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">要点/结论:</strong> <br/>通过这篇博客，你了解了不同的调度员&amp;的工作范围。因此，现在您可以根据您的使用情形来使用它们。作用域有助于管理协程的生命周期，其主要好处是避免内存泄漏。Dispatcher将帮助决定协程在哪个线程中运行。因此，在我们的任务中，我们可以为网络操作提供一个特定的线程，并分配IO线程。</p><p id="ea37" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><strong class="ig iz">信用标签<br/></strong><a class="ae jv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/" rel="noopener ugc nofollow" target="_blank">https://kot Lin . github . io/kot linx . coroutines/kot linx-coroutines-core/kot linx . coroutines/-coroutine-scope/</a></p><p id="799a" class="pw-post-body-paragraph ie if hh ig b ih ja ij ik il jb in io hr jc iq ir hv jd it iu hz je iw ix iy ha bi translated"><a class="ae jv" href="https://developer.android.com/topic/libraries/architecture/coroutines" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/topic/libraries/architecture/coroutines</a></p></div></div>    
</body>
</html>