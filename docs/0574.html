<html>
<head>
<title>Extend your code readability with Kotlin extensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin扩展扩展您的代码可读性</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/extend-your-code-readability-with-kotlin-extensions-542bf702aa36?source=collection_archive---------0-----------------------#2020-10-23">https://medium.com/androiddevelopers/extend-your-code-readability-with-kotlin-extensions-542bf702aa36?source=collection_archive---------0-----------------------#2020-10-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f1f064469350b2336414178de85f7e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0QJqxE7mPdvAWzGCdat6g.png"/></div></div></figure><div class=""/><div class=""><h2 id="449d" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">科特林词汇表:扩展函数和属性</h2></div><p id="671f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">你是否曾经使用过一个API，并想给它添加功能或属性？</p><p id="3025" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您可以从类继承，或者创建一个接受类实例的函数来解决这个问题。Java编程语言通常用一个Utils类来解决这个问题，但这在autocomplete中并没有显示出来，这使得查找起来更困难，使用起来也不直观。这两种方法都是解决方案，但都不提倡简单易读的代码。</p><p id="2767" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">谢天谢地，Kotlin用<a class="ae kd" href="https://kotlinlang.org/docs/reference/extensions.html" rel="noopener ugc nofollow" target="_blank">扩展函数和属性</a>来拯救我们。这些使您可以向类中添加功能，而无需继承或创建接受该类的函数。与Java编程语言的等效语言不同，扩展出现在Android Studio的自动完成功能中。扩展可以用于第三方库、Android SDK或用户定义的类。</p><p id="5ddd" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">请继续阅读，了解如何使用扩展来扩展代码的可读性！</p><h1 id="196e" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">扩展功能—用途</h1><p id="1f2f" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">假设您有一个名为<code class="du lb lc ld le b">Dog</code>的类，它有一个名字、品种和年龄。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="30b6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果有人对收养感兴趣，收养机构可能希望扩展<code class="du lb lc ld le b">Dog</code>类，使其具有打印狗的信息的功能。为了做到这一点，我们实现了一个<code class="du lb lc ld le b">extension function</code>，它的设置就像一个普通的函数，只是有一点不同:在函数名之前添加要扩展的类，并在函数名之间加一个点。在函数实现中，您可以使用它来引用receiver对象，并且可以访问您的函数块中receiver类的所有成员。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="4f03" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您可以像调用<code class="du lb lc ld le b">Dog</code>类中的任何其他函数一样调用<code class="du lb lc ld le b">printDogInformation()</code>。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h2 id="d22b" class="ll kf hs bd kg lm ln lo kk lp lq lr ko jq ls lt kq ju lu lv ks jy lw lx ku ly bi translated">从Java代码中调用扩展函数</h2><p id="ee75" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">扩展函数不是我们正在扩展的类的一部分，所以当试图从Java编程语言中调用它们时，我们不会在该类的其他方法中找到它们。正如我们将在后面看到的，扩展反编译成你定义它们的文件的静态方法，并作为参数接收我们正在扩展的类的一个实例。这就是从Java中调用<code class="du lb lc ld le b">printDogInformation()</code>扩展的样子。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h2 id="d99c" class="ll kf hs bd kg lm ln lo kk lp lq lr ko jq ls lt kq ju lu lv ks jy lw lx ku ly bi translated">可空类型上的扩展函数</h2><p id="70ec" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">您甚至可以在可空类型上使用扩展。我们可以在可空类型上创建扩展函数，并使空检查成为函数实现的一部分，而不是在调用扩展函数之前进行空检查。这就是使用可空类型的<code class="du lb lc ld le b">printInformation()</code>的样子。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="b7b1" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如您所见，在调用<code class="du lb lc ld le b">printInformation()</code>之前，您不需要进行null检查。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="fda6" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">扩展属性—用法</h1><p id="b2ac" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">收养机构可能也想知道狗是否足够大可以被收养。为此，我们实现了一个名为<code class="du lb lc ld le b">isReadyToAdopt</code>的扩展属性，它检查狗的年龄是否超过1岁。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="9e8f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">您可以像调用<code class="du lb lc ld le b">Dog</code>类中的任何其他属性一样调用这个扩展属性。</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="f8cb" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">扩展功能覆盖</h1><p id="c791" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">您不能重写现有的成员函数。如果你定义一个扩展函数和一个已经存在的成员函数有相同的签名，那么这个成员函数总是会被调用，因为被调用的函数依赖于变量声明的静态类型，而不是依赖于变量中存储的值的运行时类型。比如不能在String上扩展<code class="du lb lc ld le b">toUppercase()</code>，但是可以扩展<code class="du lb lc ld le b">convertToUppercase()</code>。</p><p id="bf01" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">当您扩展一个不属于您的类型，并且库所有者向他们的库中添加了一个与您的扩展具有相同签名的方法时，就会显示出这种行为的后果。在这种情况下，将调用库扩展。您将得到的唯一信息是您的扩展函数变成了一个未使用的方法。</p><h1 id="8fd5" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">在后台</h1><p id="9918" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">我们可以通过进入<strong class="jj ht">Tools/kot Lin/Show kot Lin Bytecode</strong>，然后按下<strong class="jj ht"> Decompile </strong>按钮，在Android Studio中对<code class="du lb lc ld le b">printDogInformation()</code>进行反编译。如果我们将<code class="du lb lc ld le b">printDogInformation()</code>方法视为反编译代码，我们会得到这样的结果:</p><figure class="lf lg lh li fd hj"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="38ce" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在幕后，扩展函数只是常规的静态函数，它接受receiver类的一个实例。它们与接收器类没有任何其他联系。这就是为什么没有支持字段——它们实际上并没有将成员插入到类中。</p><h1 id="765c" class="ke kf hs bd kg kh ki kj kk kl km kn ko iy kp iz kq jb kr jc ks je kt jf ku kv bi translated">结论</h1><p id="1c01" class="pw-post-body-paragraph jh ji hs jj b jk kw it jm jn kx iw jp jq ky js jt ju kz jw jx jy la ka kb kc ha bi translated">总的来说，扩展是一个需要慎重使用的有用工具，当你使用它们来使你的代码更加直观和可读时，记住下面的提示。</p><p id="6e4b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">请记住:</p><ul class=""><li id="7f0c" class="lz ma hs jj b jk jl jn jo jq mb ju mc jy md kc me mf mg mh bi translated">扩展是静态解析的。</li><li id="ba88" class="lz ma hs jj b jk mi jn mj jq mk ju ml jy mm kc me mf mg mh bi translated">成员函数总是会赢。</li><li id="bdde" class="lz ma hs jj b jk mi jn mj jq mk ju ml jy mm kc me mf mg mh bi translated">领养一只狗！</li></ul><p id="25d2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">编码快乐！</p></div></div>    
</body>
</html>