<html>
<head>
<title>Understanding Kotlin limitations for type parameter positions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Kotlin对类型参数位置的限制</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/understanding-kotlin-limitations-for-type-parameter-positions-15527b916034?source=collection_archive---------2-----------------------#2018-05-28">https://blog.kotlin-academy.com/understanding-kotlin-limitations-for-type-parameter-positions-15527b916034?source=collection_archive---------2-----------------------#2018-05-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="cf6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">科特林方差修改器对<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929">类型参数</a>的使用施加限制。协变类型参数(带有<code class="fe kj kk kl km b">out</code>修饰符)不能用于公共in位置，逆变类型参数(带有<code class="fe kj kk kl km b">in</code>修饰符)不能用于公共out位置。但是为什么要实行这种限制呢？</p><p id="d46f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们来了解一下。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/6dc7cb1e74d425d9f9a5a02ede0c3022.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c4hgCaaf-OugDPL-.jpg"/></div></div></figure><h1 id="ee1d" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">方差修改量</h1><p id="021f" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我们已经发表了一篇文章，深入解释了方差修正因子。这里可以找到<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-generics-variance-modifiers-36b82c7caa39">这里有</a>。可以简单概括为:</p><p id="1395" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当一个泛型类型是不变的，像<code class="fe kj kk kl km b">class Box&lt;T&gt;</code>一样，任何<code class="fe kj kk kl km b">Box&lt;SomeType&gt;</code>和<code class="fe kj kk kl km b">Box&lt;AnotherType&gt;</code>之间都没有关系。所以<code class="fe kj kk kl km b">Box&lt;Number&gt;</code>和<code class="fe kj kk kl km b">Box&lt;Int&gt;</code>没有关系。</p><p id="3c7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当一个泛型类型是协变的，比如<code class="fe kj kk kl km b">class Box&lt;out T&gt;</code>，当<code class="fe kj kk kl km b">A</code>是<code class="fe kj kk kl km b">B</code>的子类型，那么<code class="fe kj kk kl km b">Box&lt;A&gt;</code>是<code class="fe kj kk kl km b">Box&lt;B&gt;</code>的子类型。所以<code class="fe kj kk kl km b">Box&lt;Int&gt;</code>是<code class="fe kj kk kl km b">Box&lt;Number&gt;</code>的一个子类型。</p><p id="9ffb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当一个泛型类型是逆变的，比如<code class="fe kj kk kl km b">class Box&lt;in T&gt;</code>，当<code class="fe kj kk kl km b">A</code>是<code class="fe kj kk kl km b">B</code>的子类型，那么<code class="fe kj kk kl km b">Box&lt;B&gt;</code>就是<code class="fe kj kk kl km b">Box&lt;A&gt;</code>的子类型。所以<code class="fe kj kk kl km b">Box&lt;Number&gt;</code>是<code class="fe kj kk kl km b">Box&lt;Int&gt;</code>的一个子类型。</p><p id="371f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简短摘要:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mc"><img src="../Images/650f5ba8608d1eb6c7ecc21cffc918b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oFKDtdy5ebXieskcYulZjw.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Taken from <a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-cheat-sheet-1137588c75a">Kt. Academy cheat sheet</a>.</figcaption></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi mh"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h1 id="7ad5" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">审查限制</h1><p id="b573" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">尽管Kotlin引入了一些对使用方差修饰符的类型参数的限制。以下类别完全正确:</p><pre class="ko kp kq kr gt mi km mj mk aw ml bi"><span id="09cc" class="mm la in km b gy mn mo l mp mq"><strong class="km io">class </strong>SomeClass&lt;T&gt; {<br/>    <strong class="km io">var t</strong>: T? = <strong class="km io">null<br/><br/>    fun </strong>functionReturningT(): T? = <strong class="km io">t<br/><br/>    fun </strong>functionAcceptingT(t: T) {}<br/><br/>    <strong class="km io">private fun </strong>privateFunctionReturningT(): T? = <strong class="km io">t<br/><br/>    private fun </strong>privateFunctionAcceptingT(t: T) {}<br/>}</span></pre><p id="2539" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管如果我们引入任何方差修饰符，它将不会编译:</p><pre class="ko kp kq kr gt mi km mj mk aw ml bi"><span id="eaa9" class="mm la in km b gy mn mo l mp mq"><strong class="km io">class </strong>SomeClass&lt;<strong class="km io">out </strong>T&gt; {<br/>    <strong class="km io">var t</strong>: T? = <strong class="km io">null </strong><em class="mr">// Error<br/>    <br/>    </em><strong class="km io">private var pt</strong>: T? = <strong class="km io">null<br/><br/>    fun </strong>functionReturningT(): T? = <strong class="km io">t<br/><br/>    fun </strong>functionAcceptingT(t: T) {} <em class="mr">// Error<br/><br/>    </em><strong class="km io">private fun </strong>privateFunctionReturningT(): T? = <strong class="km io">t<br/><br/>    private fun </strong>privateFunctionAcceptingT(t: T) {}<br/>}</span><span id="59e5" class="mm la in km b gy ms mo l mp mq"><strong class="km io">class </strong>SomeClass&lt;<strong class="km io">in </strong>T&gt; {<br/>    <strong class="km io">var t</strong>: T? = <strong class="km io">null </strong><em class="mr">// Error<br/><br/>    </em><strong class="km io">private var pt</strong>: T? = <strong class="km io">null<br/><br/>    fun </strong>functionReturningT(): T? = <strong class="km io">t </strong><em class="mr">// Error<br/><br/>    </em><strong class="km io">fun </strong>functionAcceptingT(t: T) {} <br/><br/>    <strong class="km io">private fun </strong>privateFunctionReturningT(): T? = <strong class="km io">t<br/><br/>    private fun </strong>privateFunctionAcceptingT(t: T) {}<br/>}</span></pre><p id="f108" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，协变类型不能作为参数类型用于公共方法，也不能用于公共读写属性。只读是可以的，因为它们只暴露我们的位置:</p><pre class="ko kp kq kr gt mi km mj mk aw ml bi"><span id="721a" class="mm la in km b gy mn mo l mp mq"><strong class="km io">class </strong>SomeClass&lt;<strong class="km io">out </strong>T&gt; {<br/>    <strong class="km io">val t</strong>: T? = <strong class="km io">null<br/><br/>    private var pt</strong>: T? = <strong class="km io">null<br/><br/>    fun </strong>functionReturningT(): T? = <strong class="km io">t<br/><br/>    private fun </strong>privateFunctionReturningT(): T? = <strong class="km io">t<br/><br/>    private fun </strong>privateFunctionAcceptingT(t: T) {}<br/>}</span></pre><p id="71ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Contravariance不能用作方法的返回类型，也不能用于所有方法(getter可见性必须与属性可见性相同)。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><a href="https://blog.kotlin-academy.com/write-for-kotlin-academy-abebd70937ce"><div class="gh gi mh"><img src="../Images/87c508a2627eaa3d0e472518952dc75a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEoIe6R-7DJyXGh8tYeqjA.jpeg"/></div></a></figure><h1 id="558e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">示例问题</h1><p id="f606" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">要理解这些限制背后的问题，请考虑Java数组。它们是协变的，同时，它们允许设定值(在位置上)。因此，您可以调用下面的代码，从编译的角度来看，这些代码是完全正确的，但总是会导致运行时错误:</p><pre class="ko kp kq kr gt mi km mj mk aw ml bi"><span id="3cfa" class="mm la in km b gy mn mo l mp mq"><em class="mr">// Java<br/></em>Integer[] ints = { 1,2,3 };<br/>Object[] objects = ints;<br/>objects[2] = <strong class="km io">"AAA"</strong>;</span></pre><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/e7e0ac48bf156615146c272a06dbef47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/0*RAr74RDWKN9Bmfaw."/></div></figure><p id="a183" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那里发生了什么？我们向上铸造阵列，然后设置向下铸造类型和繁荣！我们有一个错误。它与职位有什么关系？</p><h1 id="6f55" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">位置和类型</h1><p id="bb01" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">场内和场外都有一些默认的合约。请参见以下类型层次结构:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/1bf93b3032336f5d3b70f8e8266cc2b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*LbeE_z0swSXjEMWoIrB6wA.png"/></div></figure><p id="6ce9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们需要将<code class="fe kj kk kl km b">Dog</code>传递到in-position时，每个子类型都被接受:</p><pre class="ko kp kq kr gt mi km mj mk aw ml bi"><span id="9b23" class="mm la in km b gy mn mo l mp mq"><strong class="km io">fun </strong>takeDog(dog: Dog) {}</span><span id="7ffa" class="mm la in km b gy ms mo l mp mq">takeDog(Dog())<br/>takeDog(Puppy())<br/>takeDog(Hund())</span></pre><p id="a0b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们将<code class="fe kj kk kl km b">Dog</code>从外部位置取出时，接受的值是<code class="fe kj kk kl km b">Dog</code>和所有超类型:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/030e4450eef9d48713b9e4435083641d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*wg60LOh5Ep9EGCuwRgAgqA.png"/></div></figure><pre class="ko kp kq kr gt mi km mj mk aw ml bi"><span id="acf4" class="mm la in km b gy mn mo l mp mq"><strong class="km io">fun </strong>makeDog(): Dog = Dog()</span><span id="556d" class="mm la in km b gy ms mo l mp mq"><strong class="km io">val </strong>any: Any = makeDog()<br/><strong class="km io">val </strong>animal: Animal = makeDog()<br/><strong class="km io">val </strong>wild: Wild = makeDog()</span></pre><p id="76a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，一旦元素处于“内”或“外”位置，不同类型的转换是默认的，并且不能停止。</p><p id="f1a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是在我们的数组示例中发生的情况。协方差允许向上转换，而在位置中允许向下转换。将这两种机制结合起来使用，我们可以对任何事物进行转换。与逆变和外部位置类似。一起可以帮助开发人员将任何类型转换为任何其他类型。唯一的问题是，如果一个实际的类型不能以这种方式转换，那么我们就有一个运行时错误。</p><p id="dd3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">防止这种情况的唯一方法是禁止公开的内部位置和矛盾，以及公开的我们的位置和矛盾。这就是为什么科特林有这个限制。科特林还通过使所有数组不变来解决数组问题。这是另一个例子，Kotlin是比Java更安全的语言(见<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-next-level-of-android-development-95bce2f43a24">这个演讲</a>)。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="f7d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你需要Kotlin工作室吗？请访问我们的网站,看看我们能为您做些什么。</p><p id="74d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae ki" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae ki" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi mh"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure><h2 id="f248" class="mm la in bd lb nd ne dn lf nf ng dp lj jv nh ni ln jz nj nk lr kd nl nm lv nn bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h2><p id="0347" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi no"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>