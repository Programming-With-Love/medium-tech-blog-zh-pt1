<html>
<head>
<title>The Whale in the Grocery Store — An Introduction to Dockerfiles and Docker Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">杂货店中的鲸鱼Docker文件和Docker图像介绍</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/whale-in-the-grocery-store-an-introduction-to-docker-and-docker-images-311319688692?source=collection_archive---------0-----------------------#2019-05-20">https://medium.com/capital-one-tech/whale-in-the-grocery-store-an-introduction-to-docker-and-docker-images-311319688692?source=collection_archive---------0-----------------------#2019-05-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/32b24ed154a04bab52a0c8b047cd36df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GjB8_O2qmlFoU65w"/></div></div></figure><p id="bd4e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我的上一篇文章<a class="ae jn" rel="noopener" href="/capital-one-tech/the-whale-in-the-refrigerator-80f659fea1a4"> <em class="jo">冰箱里的鲸鱼</em> </a>中，我介绍了Docker，并介绍了从Docker注册表中提取图像和运行基本web服务器的基础知识。但愿那篇教程会让你问，<em class="jo">“那个码头工人的形象到底是从哪里来的？”</em>这就是我们将在本文中讨论的，构建并使用Docker图像。</p><h1 id="e548" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">更多鲸语</h1><p id="7cc1" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在上一篇文章中，我介绍了Docker词典的两个部分，<strong class="ir hi">图像</strong>(或<strong class="ir hi">容器图像</strong>)和<strong class="ir hi">容器</strong>。为了建立我们自己的码头工人形象，我们必须学习更多的术语。</p><ul class=""><li id="f3f1" class="ks kt hh ir b is it iw ix ja ku je kv ji kw jm kx ky kz la bi translated"><strong class="ir hi"> Dockerfile </strong>:包含构建Docker映像所需的一组指令的文本文件。</li><li id="0425" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi"> Docker Registry </strong>:用于存储和分发Docker图像的存储库。</li><li id="0047" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><strong class="ir hi"> Docker Hub </strong> : Docker Inc .官方<a class="ae jn" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker图片注册</a>。</li></ul><p id="1382" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些是相当简单的定义，但是它们的简单掩盖了它们的力量。</p><h1 id="2d17" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">形象就是一切</h1><p id="f0ad" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">Docker容器图像是你可以用Docker做任何事情的基础，但是什么，<em class="jo">真正的</em>，是Docker图像呢？好吧，码头工人的形象是你想要的任何形象…但这仍然不是一个好的答案。</p><p id="4cf9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上一篇文章中，我将运行Docker的计算机比作冰箱，指出了将食品容器放入冰箱和用Docker运行容器之间的相似之处。坚持食物的比喻，让我们从厨房转移到杂货店。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es lg"><img src="../Images/ad79db563546b4518ef1d594be49fb06.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*wWa_9zkguwVpVMYxj-VURQ.png"/></div></figure><p id="0e3b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在杂货店，你通常从货架上买食物。所有相似类型的食物和/或配料被分组在一起(牛奶与牛奶、鸡蛋与鸡蛋、啤酒与啤酒等)。)然后你选择你想要的选项。当你站在一个特定的货架前时，你可能会拉下一个食物容器，看看它是否是你想要的东西，检查它是否有损坏，检查保质期，检查腐败，检查成分(有人对食物过敏吗？)，查看营养信息，甚至检查容器内是否有缺失的物品(谁想带着11个鸡蛋而不是12个回家？).如果商品符合您的标准，您可以将其放入购物车。当你找到所有你想要的东西时，你购买它们，把它们带回家，并最终把它们组合成一顿饭。</p><p id="459a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所有这些想法都适用于Docker图像。您可以使用Docker Hub购买Docker映像的基本成分。一旦你找到了一些合适的基础图片，你就把它们拉出来检查。明智的做法是检查Docker映像，看看它是否适合您的用例，检查潜在的安全漏洞，看看您需要添加什么来使您的用例工作，并确保映像中包含的软件是最新的。一旦你决定了一个基本图像，你就可以根据这些成分来构建你的Docker图像。</p><h1 id="56d0" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">建造鲸鱼…成为鲸鱼</h1><p id="de5f" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">要建立一个新的码头工人形象，你需要几样东西。你首先需要的是Docker(咄！).命令<code class="du ll lm ln lo b">docker image build…</code>用于构建实际的映像，但是首先您需要一个Dockerfile文件。</p><h1 id="427a" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">深度文档</h1><p id="52f3" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">Dockerfile文件非常简单。它使用领域特定语言(DSL)来指示Docker在新生的Docker映像中做一些事情，例如将文件从主机复制到映像中的某个位置，或者运行shell命令。尽管如此，展示docker文件可能比描述一个docker文件更容易。</p><h2 id="f9af" class="lp jq hh bd jr lq lr ls jv lt lu lv jz ja lw lx kd je ly lz kh ji ma mb kl mc bi translated">基本Dockerfile文件</h2><pre class="lh li lj lk fd md lo me mf aw mg bi"><span id="3a7e" class="lp jq hh lo b fi mh mi l mj mk">FROM nginx:latest<br/>ENV build_date='2019–03–29'<br/>RUN mkdir -p /usr/share/nginx/html/<br/>COPY index.html /usr/share/nginx/html/<br/>EXPOSE 80<br/>CMD ["nginx", "-g", "daemon off;"]</span></pre><p id="6424" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要处理的代码太多了，所以让我们一行一行地看一遍。</p><h2 id="e5e2" class="lp jq hh bd jr lq lr ls jv lt lu lv jz ja lw lx kd je ly lz kh ji ma mb kl mc bi translated"><code class="du ll lm ln lo b">FROM nginx:latest</code></h2><p id="37bd" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">FROM命令对于每个Docker文件都是必需的，它告诉Docker新Docker映像的基础映像是什么——它实际上告诉Docker从哪里开始。这可以是您作为用户可以访问的任何以前存在的映像，包括您以前构建的映像。还有一种称为<code class="du ll lm ln lo b"><a class="ae jn" href="https://hub.docker.com/_/scratch" rel="noopener ugc nofollow" target="_blank">scratch</a></code>的保留虚拟基础映像，它几乎不包含任何内容，用于构建基础映像或最小映像。</p><p id="b3ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果<code class="du ll lm ln lo b">FROM …</code>行中指定的映像不在构建Docker映像的系统中，Docker将尝试从Docker Hub或指定的Docker注册表中<code class="du ll lm ln lo b">pull</code>该映像(稍后将详细介绍注册表)。如果Docker无法提取指示的图像，构建将会失败。出于这个原因，我发现在编写Docker映像构建脚本时预提取我的<code class="du ll lm ln lo b">FROM …</code>映像很方便。</p><h2 id="d96e" class="lp jq hh bd jr lq lr ls jv lt lu lv jz ja lw lx kd je ly lz kh ji ma mb kl mc bi translated">ENV build _ date = ' 2019–03–29 '</h2><p id="80c8" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">运行时,<code class="du ll lm ln lo b">ENV</code>命令在Dockerfile的上下文中和容器中设置一个环境变量。在这种情况下，如果我运行一个基于这个图像的容器并执行<code class="du ll lm ln lo b">echo $build_date</code>，它将返回<code class="du ll lm ln lo b">2019–03–29</code>。</p><p id="c1af" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jo">安全说明</em> </strong> <em class="jo">:在构建时，不要使用</em> <code class="du ll lm ln lo b"><em class="jo">ENV</em></code> <em class="jo">命令</em><strong class="ir hi"><em class="jo"/></strong><em class="jo">将密码或其他秘密插入Docker映像，因为很容易从映像中检索到。有一些模式和工具可以在运行时检索Docker容器的秘密，但是这些超出了本文的范围。</em> <a class="ae jn" rel="noopener" href="/capital-one-tech/secure-docker-containers-require-secure-applications-75eb358abef9"> <em class="jo">如果你想了解更多关于集装箱安全的知识，这里有一篇极好的文章</em> </a> <em class="jo">。</em></p><h2 id="0ba3" class="lp jq hh bd jr lq lr ls jv lt lu lv jz ja lw lx kd je ly lz kh ji ma mb kl mc bi translated">运行mkdir -p /usr/share/nginx/html/</h2><p id="a1c8" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated"><code class="du ll lm ln lo b">RUN</code>命令可能是docker文件中最有用的命令之一。该命令在新生映像中执行shell命令。这个特殊的命令创建了一个目录<code class="du ll lm ln lo b">/usr/share/nginx/html/</code>，但是它的用途远不止于此。Docker映像中可用的任何命令都可以在这里执行。</p><p id="17be" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了保持最终Docker映像的大小尽可能小，建议您使用<code class="du ll lm ln lo b">&amp;&amp;</code>或<code class="du ll lm ln lo b">;</code>将shell命令链接在一起，并尽量减少Docker文件中的<code class="du ll lm ln lo b">RUN</code>行。关于你为什么要这么做的更多细节，Docker官方文档有一篇关于Docker文件最佳实践的文章。下面是一个示例运行行，显示了链接的命令:</p><pre class="lh li lj lk fd md lo me mf aw mg bi"><span id="4d57" class="lp jq hh lo b fi mh mi l mj mk">RUN mkdir -p /usr/share/nginx/html/ &amp;&amp; \<br/>    adduser user &amp;&amp; \<br/>    chown -R user /usr/share/nginx/html</span></pre><p id="25d2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个<code class="du ll lm ln lo b">RUN</code>命令非常强大，我仅仅触及了它的皮毛。你可以从<a class="ae jn" href="https://docs.docker.com/engine/reference/builder/#run" rel="noopener ugc nofollow" target="_blank">官方文档</a>中了解更多关于<code class="du ll lm ln lo b">RUN</code>命令的信息。</p><h2 id="dfe0" class="lp jq hh bd jr lq lr ls jv lt lu lv jz ja lw lx kd je ly lz kh ji ma mb kl mc bi translated">复制index.html/usr/share/nginx/html/</h2><p id="860f" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">这一行告诉Docker将文件<code class="du ll lm ln lo b">index.html</code>从主机文件系统复制到我们正在构建的映像中的<code class="du ll lm ln lo b">/usr/share/nginx/html/</code> <em class="jo">。在这个例子中，我们将一个html文件(index.html)复制到默认Nginx图像中的默认网站代码位置。<code class="du ll lm ln lo b">COPY</code>指令也支持通配符和目录的递归复制。要使用通配符模式进行复制，请使用如下的<code class="du ll lm ln lo b">*.pattern</code>符号:<code class="du ll lm ln lo b">COPY *.html /usr/share/nginx/html/</code>。要复制一个目录及其所有内容，请确保目录名后面有一个斜杠(/)，如下所示:<code class="du ll lm ln lo b">COPY html/ /usr/share/nginx/html/</code>。</em></p><h2 id="cf22" class="lp jq hh bd jr lq lr ls jv lt lu lv jz ja lw lx kd je ly lz kh ji ma mb kl mc bi translated">暴露80</h2><p id="cdba" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated"><code class="du ll lm ln lo b">EXPOSE</code>指令是一个有趣的例子。根据<a class="ae jn" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">官方Docker文件引用</a>，<code class="du ll lm ln lo b">EXPOSE</code>通知Docker，当这个镜像被实例化为容器时，<em class="jo">将在引用的端口上监听</em>，在本例中是80。但是，当容器运行时，该端口不会自动<em class="jo">发布</em>(即对外开放)。您可能还记得在第一篇文章中，端口的实际发布是在执行<code class="du ll lm ln lo b">docker run</code>时用<code class="du ll lm ln lo b">-p</code>标志完成的。</p><p id="a766" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">相反，<code class="du ll lm ln lo b">EXPOSE</code>指令充当了映像构建者和从该映像运行容器的人之间的一种文档。换句话说，如果我在other文件中看到一个图像的<code class="du ll lm ln lo b">EXPOSE 80</code>，我知道在运行该容器时要在命令行中包含一个<code class="du ll lm ln lo b">-p 80:80</code>。</p><p id="1a53" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du ll lm ln lo b">EXPOSE</code>默认为TCP，但也可以像这样指定UDP<code class="du ll lm ln lo b">EXPOSE 10000/udp</code>。</p><h2 id="b5b9" class="lp jq hh bd jr lq lr ls jv lt lu lv jz ja lw lx kd je ly lz kh ji ma mb kl mc bi translated">CMD ["nginx "，"-g "，"守护程序关闭；"]</h2><p id="0702" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">Dockerfile的最后一行是在实例化容器时，默认情况下应该在容器中运行的命令。在这个例子中，我们对<code class="du ll lm ln lo b">CMD</code>命令使用了所谓的<em class="jo"> exec </em>表单。在exec形式中，我们为CMD命令提供了一个命令、命令行开关和参数的数组(<code class="du ll lm ln lo b">["nginx", "-g", "daemon off;"]</code>)。这种形式的优点是它<em class="jo">不执行命令周围的shell </em>，它直接执行命令。换句话说，它在运行时实际上执行<code class="du ll lm ln lo b">nginx -g daemon off;</code>。</p><p id="d9ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该命令还有另一种形式，称为<em class="jo">外壳</em>形式。上面命令的shell形式类似于这样:<code class="du ll lm ln lo b">CMD nginx -g daemon off;</code>。这里的区别是Docker实际上是在你运行容器的时候执行<code class="du ll lm ln lo b">sh nginx -g daemon off;</code>，因此得名<em class="jo"> shell </em> form。使用shell形式的主要原因是，如果您需要将环境变量作为CMD命令的一部分进行评估。</p><h1 id="291e" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">但是等等，还有呢！</h1><p id="ecf8" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">这只是对Dockerfiles的一点尝试，我鼓励你学习更多。你可以随时查阅官方Dockerfile文档，但是了解Dockerfiles的另一个很好的资源是看看其他人用它们做了什么。如果你在<a class="ae jn" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>上找到一个有趣的Docker图片，通常会有一个链接指向用来构建该图片的Docker文件，以及它所属的GitHub库。此外，在这种情况下，谷歌确实是你的朋友。</p><h1 id="55b0" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">建立形象</h1><p id="817d" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">现在我们有了一个docker文件，但是我们用它做什么呢？为了实际构建一个Docker映像，我们使用了<code class="du ll lm ln lo b">docker image build…</code>命令。在这种情况下，该命令类似于:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7e234681433fdb6581dc25c14b0a87c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mnv9x6n92oz_OE8y"/></div></div></figure><p id="878f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种情况下，我们指示Docker构建一个名为<code class="du ll lm ln lo b">image-name</code>的映像，其版本<code class="du ll lm ln lo b">tag</code>可以被推送到存储库<code class="du ll lm ln lo b">repository</code>中的<code class="du ll lm ln lo b">some.registry.com</code>。这就是<code class="du ll lm ln lo b">-t</code>标志所指示的，上面的示例命令演示了正确的命名方案。</p><p id="9d3c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里有几个细节需要我们强调。首先出场的是<code class="du ll lm ln lo b">some.registry.com</code>。图像名称的这一部分是可选的。如果您关闭它并尝试推送图像，Docker将尝试将图像推送到Docker Hub，如前所述，Docker Hub是Docker Inc .的官方图像注册表。</p><p id="9ef6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来是名字的<code class="du ll lm ln lo b">/repository/</code>部分。如果您要将映像推送到Docker Hub，这应该是您的Docker Hub用户名，也称为DockerID，除非您有意将映像推送到共享存储库，在这种情况下，这应该是共享存储库的名称。如果您正在推进到另一个注册中心，比如一个内部托管的注册中心，您应该遵循该注册中心的Docker映像组织指南。</p><p id="ba42" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du ll lm ln lo b">image-name:</code>部分是你实际“命名”你的图像的地方。请务必注意，每个<em class="jo">Docker映像都有一个唯一的映像ID，它是在构建映像时生成的。然而，你可以给一个Docker图像起一个你想要的名字。我建议这个名称应该描述Docker图像的功能，但是如果您想将您的图像命名为Bob，那就继续吧。</em></p><p id="9a47" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du ll lm ln lo b">:tag</code>部分是Docker术语中更强大的特性之一。名称的这一部分是自由格式文本，就像<code class="du ll lm ln lo b">image-name:</code>部分一样，但是通常用于跟踪某种版本。给定的Docker图像可以有许多标签。例如，我可以有一个标题为<code class="du ll lm ln lo b">my-repository/web-app:2019–02–06_0915</code>的图像，该图像的另一个版本标题为<code class="du ll lm ln lo b">my-repository/web-app:2019–02–15_1350</code>，第三个版本标题为<code class="du ll lm ln lo b">my-repository/web-app:2019–02–16_1500</code>。这些Docker映像中的每一个都有不同的映像id，因为正如标签所暗示的，它们是不同的构建。</p><p id="778b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Docker允许给定的图像ID有多个名称——可以把它们想象成别名。我有我的官方建筑名称<code class="du ll lm ln lo b">my-repository/web-app:2019–02–16_1500</code>，但我可以给这个图像命名为<code class="du ll lm ln lo b">my-repository/web-app:latest</code>。这两个名称将具有完全相同的图像ID，并且根据定义还将包含完全相同的代码(事实上，图像数据在磁盘上没有复制，这两个图像名称指向磁盘上的相同位)。这里的巧妙之处在于Docker将<code class="du ll lm ln lo b">latest</code>标签视为默认标签，因此如果我<code class="du ll lm ln lo b">docker pull my-repository/web-app</code>，它将拉取<code class="du ll lm ln lo b">my-repository/web-app:latest</code>，即当前与<code class="du ll lm ln lo b">my-repository/web-app:2019–02–16_1500</code>相同的。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lg"><img src="../Images/798bc3887f5ed45c307deaaa17a9eaa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*zTr1154Lg4IHyaO48RUJsg.png"/></div></div></figure><p id="4966" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，假设我重新构建了我的web应用程序。构建系统创建映像<code class="du ll lm ln lo b">my-repository/web-app:2019–02–27_0950</code>和<em class="jo">，同时</em>将该映像重新标记(别名)为<code class="du ll lm ln lo b">my-repository/web-app:latest</code>，并将这两个映像名称推送到注册表中。这将覆盖图像<code class="du ll lm ln lo b">my-repository/web-app:latest</code>以指向<code class="du ll lm ln lo b">my-repository/web-app:2019–02–27_0950</code>的图像ID，因此如果我<code class="du ll lm ln lo b">docker pull my-repository/web-app:latest</code>，我将得到<code class="du ll lm ln lo b">my-repository/web-app:2019–02–27_0950</code>。您还可以使用其他标签，如<code class="du ll lm ln lo b">:release</code>或<code class="du ll lm ln lo b">:qa</code>，它们也是最新版本的别名。这允许非常强大的发布自动化，包括非常容易的发布回滚以及金丝雀测试之类的事情。</p><p id="00c6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该命令中另一个需要注意的细节是最后的<code class="du ll lm ln lo b">.</code>。最后一部分是“构建环境”——如果你喜欢的话，是“来自”。这将是Docker映像构建过程的根目录。非常重要的一点是，构建上下文<em class="jo">下的任何文件或目录都有可能在您的Docker映像</em>中结束。正是因为这个原因，你应该<strong class="ir hi">永远不要</strong>将<code class="du ll lm ln lo b">/</code>作为构建上下文，否则你可能会将整个硬盘复制到Docker镜像中！您甚至可能希望将docker文件保存在源目录之上的目录中。例如，假设您将Docker文件保存在存储库的根目录中，将实际的源代码保存在<code class="du ll lm ln lo b">./src</code>中，您将把<code class="du ll lm ln lo b">./src</code>作为构建的上下文，并传递命令行开关<code class="du ll lm ln lo b">-f ./Dockerfile</code>(以明确地告诉Docker在哪里可以找到您的Docker文件)。至少，这避免了意外地将Docker文件复制到Docker映像中。</p><h1 id="c127" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">注册推送</h1><p id="0c32" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">这个链条的最后一环是Docker注册中心。我前面提到了注册表，但是需要注意的是Docker注册表是你分发Docker图片的方式。</p><h1 id="868f" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">码头枢纽</h1><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es ml"><img src="../Images/a191b95c66c58c1bbf9cdb0807281596.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*Sq015rnKvBYU8zy58GXTHw.png"/></div></figure><p id="355d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Docker Inc .运营着一个名为<a class="ae jn" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>的注册中心。Docker Hub是你可以找到软件开发者发布的“官方”Docker图片的地方。这些官方映像分为几个类别，包括基础操作系统(Ubuntu、Debian、Alpine、CentOS、Fedora等)、基础设施(Apache、Nginx、Registry、Kafka、RabbitMQ等)。)，以语言为中心(Python，Go，Node.js，Java等。)和数据库(MongoDB、Couchbase、Redis、PostgreSQL等)。还有无数<em class="jo">非官方</em> Docker图片可用。出于安全原因，我个人不建议使用非官方的图片。或者，我建议，如果你找到一个你喜欢的非官方图片，而不是拉图片，你应该找到基础Github repo，看看他们的Dockerfile。然后根据您的需要修改docker文件，并自己运行<code class="du ll lm ln lo b">docker image build…</code>。</p><p id="fe9f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想把自己的图片推送到Docker Hub，你必须注册一个账户，就像你在GitHub或其他类似服务上注册一个账户一样。注册后，您应该发出命令<code class="du ll lm ln lo b">docker login</code>,提示您输入Docker Hub用户名和密码。</p><p id="631c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">登录Docker Hub后，您可以将图像推送到自己的存储库中。你还记得我说过，如果你要推Docker Hub，你的Docker Hub用户名应该是你创建的任何Docker图片的<code class="du ll lm ln lo b">/repository/</code>部分吗？这就是为什么。</p><blockquote class="mm"><p id="f9ba" class="mn mo hh bd mp mq mr ms mt mu mv jm dx translated"><em class="mw">如果您在映像名称的这一部分添加了Docker Hub用户名以外的内容，当您尝试推送您的映像时，可能会出现“拒绝访问”错误，因为您实际上是在尝试将Docker映像推送到其他人的存储库中。</em></p></blockquote><p id="f23b" class="pw-post-body-paragraph ip iq hh ir b is mx iu iv iw my iy iz ja mz jc jd je na jg jh ji nb jk jl jm ha bi translated"><code class="du ll lm ln lo b">docker login</code>命令还有另一个用途。如果您或您的工作场所拥有一个内部Docker注册中心，您可以使用命令<code class="du ll lm ln lo b">docker login my.dockerregistry.com</code>登录该注册中心。然后，它将通过相同的用户名/密码提示，让您登录到您的内部Docker注册表。</p><h1 id="9606" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使劲推</h1><p id="5af6" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">现在我们已经完成了所有这些，我们终于可以将我们闪亮的新Docker图像推送到Docker注册中心了。执行<code class="du ll lm ln lo b">docker image push some.registry.com/repository/image-name:tag</code>。假设您已经登录并拥有推送权限，您将看到Docker连接到注册表并推送图像。真的没有更多的<code class="du ll lm ln lo b">docker push</code>。</p><p id="6344" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦推送完成，您可以通过运行<code class="du ll lm ln lo b">docker image pull some.registry.com/repository/image-name:tag</code>将相同的映像拉至另一台计算机。</p><h1 id="8e01" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">我们建立了这个图像</h1><p id="fbbd" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在这篇文章和我的前一篇文章之间，我已经向你展示了所有基本的Docker函数。这包括<code class="du ll lm ln lo b">image pull</code>、<code class="du ll lm ln lo b">image push</code>、<code class="du ll lm ln lo b">image build</code>、<code class="du ll lm ln lo b">image rm</code>、<code class="du ll lm ln lo b">container run</code>、<code class="du ll lm ln lo b">container stop</code>和<code class="du ll lm ln lo b">container rm</code>。虽然关于Docker还有很多内容需要了解，但是您现在应该已经掌握了运行Docker容器和构建自己的定制容器映像的技能和足够的知识。如果你想继续学习更多关于Docker的知识，我建议你阅读关于优化Docker图像大小的文章，并开始研究多容器应用程序和Docker合成。另外，请关注我的下一篇文章！</p><blockquote class="mm"><p id="8f0f" class="mn mo hh bd mp mq mr ms mt mu mv jm dx translated">献给我的父亲尤金·穆恰罗内，在我写这篇文章的时候，他去世了。你总是推动我去超越，这就是结果。</p></blockquote></div><div class="ab cl nc nd go ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ha hb hc hd he"><h2 id="5aaa" class="lp jq hh bd jr lq lr ls jv lt lu lv jz ja lw lx kd je ly lz kh ji ma mb kl mc bi translated">相关:</h2><ul class=""><li id="253f" class="ks kt hh ir b is kn iw ko ja nj je nk ji nl jm kx ky kz la bi translated"><a class="ae jn" rel="noopener" href="/capital-one-tech/secure-docker-containers-require-secure-applications-75eb358abef9">安全Docker容器需要安全应用</a></li><li id="3d25" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><a class="ae jn" rel="noopener" href="/capital-one-tech/multi-stage-builds-and-dockerfile-b5866d9e2f84">使用多阶段构建来简化和标准化构建流程</a></li><li id="d76f" class="ks kt hh ir b is lb iw lc ja ld je le ji lf jm kx ky kz la bi translated"><a class="ae jn" rel="noopener" href="/capital-one-tech/the-whale-in-the-refrigerator-80f659fea1a4">冰箱里的鲸鱼Docker简介</a></li></ul></div><div class="ab cl nc nd go ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ha hb hc hd he"><p id="19b7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">披露声明:2019首创一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</p></div></div>    
</body>
</html>