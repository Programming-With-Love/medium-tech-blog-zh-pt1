<html>
<head>
<title>Using a Custom Runtime for Go-Based Lambda Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为基于Go的Lambda函数使用自定义运行时</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/using-a-custom-runtime-for-go-based-lambda-functions-9d6f6c8911eb?source=collection_archive---------1-----------------------#2022-01-12">https://medium.com/capital-one-tech/using-a-custom-runtime-for-go-based-lambda-functions-9d6f6c8911eb?source=collection_archive---------1-----------------------#2022-01-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="423c" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">尽管Go在AWS Lambda中有原生支持，但切换到自定义运行时也有其优势</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/aeebe0f25af085fb393e08c1a5c731a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oUWnrAydLuj1OGDb"/></div></div></figure><p id="5856" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Go是AWS Lambda 支持的语言，所以你可能会觉得这篇教程的标题有点矛盾。毕竟，你为什么想要使用一个传统的特性来运行你的基于Go的函数不支持的语言呢？事实证明，与其他本地支持的语言相比，Lambda中的Go支持有一些差距，可以通过使用自定义运行时来弥补。</p><p id="57fe" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">然而，我们正在超越自己。在我们深入之前，我们需要讨论Lambda支持语言的机制，以及本机支持如何寻找Go。</p><h1 id="76bf" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">Lambda运行时:本机与自定义</h1><p id="3ae3" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated"><a class="ae ke" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html" rel="noopener ugc nofollow" target="_blank">运行时</a>是在你创建Lambda函数时呈现给你的一个选项。它定义了Lambda函数将如何调用您的处理程序。就本文的讨论而言，它们分为两类——<strong class="jk hi"><em class="lc">本土和习俗。</em> </strong></p><ul class=""><li id="fd74" class="ld le hh jk b jl jm jo jp jr lf jv lg jz lh kd li lj lk ll bi translated"><strong class="jk hi">本地运行时</strong> —定义调用给定语言的处理函数所需的一切。例如，Python 的本机<a class="ae ke" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-python.html" rel="noopener ugc nofollow" target="_blank">运行时包括用于运行处理程序代码的Python解释器。对于支持本地运行时的语言来说，使用Lambda就像打包并上传代码一样简单。</a></li><li id="0877" class="ld le hh jk b jl lm jo ln jr lo jv lp jz lq kd li lj lk ll bi translated"><strong class="jk hi">自定义运行时</strong> —要求用户提供调用处理程序代码所需的逻辑。这个逻辑必须作为名为<em class="lc"> bootstrap </em>的可执行文件包含在您的Lambda代码包中。在Lambda函数的初始化过程中，会调用bootstrap来执行所提供的处理程序的所有初始化逻辑。这样做之后，它与Lambda运行时API 交互，以获取事件并转发给你的处理程序。自定义运行时是向不提供本机运行时的语言添加支持的一种方式。Rust是当前必须在自定义运行时中运行的语言的一个例子。</li></ul><h1 id="fcc4" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">Go的本地运行时</h1><p id="a214" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">AWS为Go提供了一个名为go1.x 的<a class="ae ke" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-golang.html" rel="noopener ugc nofollow" target="_blank">原生运行时。与其他本机运行时相比，这个本机运行时是独一无二的，因为它要求您用AWS提供的库来包装处理程序代码。</a></p><pre class="ix iy iz ja fd lr ls lt lu aw lv bi"><span id="737e" class="lw kg hh ls b fi lx ly l lz ma">package main</span><span id="b113" class="lw kg hh ls b fi mb ly l lz ma">import (<br/>        "fmt"<br/>        "context"<br/>        "github.com/aws/aws-lambda-go/lambda"<br/>)</span><span id="1fc1" class="lw kg hh ls b fi mb ly l lz ma">type Event struct {<br/>        Name string `json:"name"`<br/>}</span><span id="fa15" class="lw kg hh ls b fi mb ly l lz ma">func main() {<br/>        h := func HandleRequest(ctx context.Context, e Event) (string, error) {<br/>            return fmt.Sprintf("Invoked by: %s", e.Name ), nil<br/>        }<br/>        lambda.Start(h)<br/>}</span></pre><p id="a6bb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><code class="du mc md me ls b">lambda.Start</code>函数获取您的处理程序并将其包装在一个<code class="du mc md me ls b">net/rpc</code>服务器中。在冷启动期间，该服务器将其自身绑定到本地套接字，并侦听运行时内置的程序向其发送事件。</p><h1 id="e747" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">为Go使用定制运行时的三个优点</h1><p id="bb43" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">鉴于AWS已经为基于Go的Lambdas提供了原生运行时，您可能想知道为什么要使用自定义运行时。在我看来，构建自定义运行时有三个优点:</p><h2 id="3895" class="lw kg hh bd kh mf mg mh kl mi mj mk kp jr ml mm kr jv mn mo kt jz mp mq kv mr bi translated">1.支持Lambda扩展</h2><p id="be9b" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated"><a class="ae ke" href="https://aws.amazon.com/blogs/compute/introducing-aws-lambda-extensions-in-preview/" rel="noopener ugc nofollow" target="_blank"> Lambda扩展</a>是一种在处理程序代码之外提供扩展功能的方式。一个例子是<a class="ae ke" href="https://github.com/hashicorp/vault-lambda-extension" rel="noopener ugc nofollow" target="_blank"> Hashicorp的Vault扩展</a>，它允许你获取存储在Vault中的秘密，并将它们添加到你的Lambda函数的环境中。扩展的主要好处之一是它们可以用一种语言编写，并且可以在所有运行时之间共享。</p><p id="3970" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Go的本地运行时是唯一不支持Lambda扩展的运行时。假设扩展的目标是<em class="lc">写一次，到处使用</em>，这种支持的缺乏意味着必须使用本地运行时为Lambda函数开发变通解决方案。如果你想为你的通用Lambda任务使用Lambda扩展，为go使用一个定制的运行时将提供一个跨所有语言运行时的统一体验。</p><h2 id="c986" class="lw kg hh bd kh mf mg mh kl mi mj mk kp jr ml mm kr jv mn mo kt jz mp mq kv mr bi translated">2.提供Amazon Linux 2执行环境</h2><p id="40b4" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">AWS正在转移较新的Lambda运行时，以使用<a class="ae ke" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html" rel="noopener ugc nofollow" target="_blank"> Amazon Linux 2 (AL2)执行环境</a>。除了Go之外，所有具有本地运行时的语言都有一个基于AL2的运行时。升级到AL2是确保您拥有最新执行环境的关键，因为<a class="ae ke" href="https://aws.amazon.com/blogs/aws/update-on-amazon-linux-ami-end-of-life/" rel="noopener ugc nofollow" target="_blank"> Amazon Linux (AL1)已经过渡到生命周期结束支持</a>。</p><p id="5c07" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">那么围棋的计划是什么？根据<a class="ae ke" href="https://aws.amazon.com/blogs/compute/migrating-aws-lambda-functions-to-al2/" rel="noopener ugc nofollow" target="_blank"> AL2迁移指南</a>，AWS还没有计划更新原生运行时，并建议切换到名为<code class="du mc md me ls b">provided.al2</code>的自定义运行时的AL2版本。</p><h2 id="f86b" class="lw kg hh bd kh mf mg mh kl mi mj mk kp jr ml mm kr jv mn mo kt jz mp mq kv mr bi translated">3.统一运行时和处理程序代码</h2><p id="3dce" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">如前所述，Go的本地运行时分为两个程序，它们通过RPC调用进行通信。自定义运行时提供了一个优势，因为您的处理程序代码被编译成与运行时代码相同的二进制文件。好处是所有的RPC逻辑都被删除了，可以直接调用处理程序代码。这有助于减少将事件从运行时传输到本机运行时的处理程序所需的多次编码/解码，从而缩短执行时间。</p><p id="52ca" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">此外，用于RPC <a class="ae ke" href="https://pkg.go.dev/net/rpc" rel="noopener ugc nofollow" target="_blank">的库被Go团队</a>置于代码冻结状态，不接受新特性或错误修复。在生产代码中消除对这个包的依赖是值得考虑的。</p><h1 id="4e63" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">从Go native运行时迁移到自定义运行时</h1><p id="134c" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">如果上面提到的任何优点听起来很吸引人，那么本节将帮助您从本机运行时迁移到自定义运行时。</p><h2 id="7221" class="lw kg hh bd kh mf mg mh kl mi mj mk kp jr ml mm kr jv mn mo kt jz mp mq kv mr bi translated">变化#1 —构建引导二进制文件</h2><p id="d663" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">为了让您的处理程序代码在自定义运行时中运行，您需要将它与处理Lambda运行时API的代码打包成一个名为bootstrap的二进制文件。您已经在使用的aws-lambda-go库提供了现成的自定义运行时模式。该库有逻辑来确定它是运行在本机运行时还是自定义运行时。这意味着您需要做的只是更改您的构建过程，将生成的二进制文件重命名为bootstrap，它将在自定义运行时工作，无需对处理程序代码进行任何更改。</p><p id="53af" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">示例:</p><pre class="ix iy iz ja fd lr ls lt lu aw lv bi"><span id="0ff0" class="lw kg hh ls b fi lx ly l lz ma">GOOS=linux go build -o ./bootstrap ./...</span></pre><h2 id="dfb6" class="lw kg hh bd kh mf mg mh kl mi mj mk kp jr ml mm kr jv mn mo kt jz mp mq kv mr bi translated">变化#2 —移除RPC以实现更快的冷启动</h2><p id="1478" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">aws-lambda-go库提供了一个名为<code class="du mc md me ls b">lambda.norpc</code>的构建标签，用于从构建的二进制文件中移除所有RPC逻辑，从而减小其大小。二进制大小有助于Lambda冷启动时间，因此我们所做的任何减少都将有助于改善这一指标。</p><p id="c919" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">示例:</p><pre class="ix iy iz ja fd lr ls lt lu aw lv bi"><span id="384f" class="lw kg hh ls b fi lx ly l lz ma">GOOS=linux go build -o ./bootstrap ./... -tags lambda.norpc</span></pre><h2 id="0d8b" class="lw kg hh bd kh mf mg mh kl mi mj mk kp jr ml mm kr jv mn mo kt jz mp mq kv mr bi translated">变更#3 —更新Lambda配置</h2><p id="f050" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">最后一个变化是更新Lambda配置中的运行时和处理程序属性，以便在自定义运行时中使用新的引导二进制文件。对于运行时，您将从go1.x切换到<code class="du mc md me ls b">provided.al2</code>。<code class="du mc md me ls b">provided.al2</code>设置表明我们将“提供”定制的运行时代码来运行在Amazon Linux 2执行环境中。对于处理程序，从当前值切换到bootstrap。</p><p id="d7ea" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">示例(云形成):</p><pre class="ix iy iz ja fd lr ls lt lu aw lv bi"><span id="16e4" class="lw kg hh ls b fi lx ly l lz ma">Resources:<br/>  Function:<br/>    Type: AWS::Serverless::Function<br/>    Properties:<br/>      Handler: bootstrap<br/>      Runtime: provided.al2<br/>      ... # Other required properties</span></pre><h1 id="715e" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">把所有的放在一起</h1><p id="867a" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">有了这三个变化，您应该能够利用定制运行时给基于Go的Lambdas带来的所有优势。所以下次你写一个基于Go的Lambda时，考虑使用一个定制的运行时！</p></div><div class="ab cl ms mt go mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ha hb hc hd he"><p id="5039" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lc">披露声明:2022资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>