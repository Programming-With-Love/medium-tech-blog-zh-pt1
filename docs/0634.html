<html>
<head>
<title>Migrating from LiveData to Kotlin’s Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从LiveData迁移到Kotlin流</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/migrating-from-livedata-to-kotlins-flow-379292f419fb?source=collection_archive---------0-----------------------#2021-05-17">https://medium.com/androiddevelopers/migrating-from-livedata-to-kotlins-flow-379292f419fb?source=collection_archive---------0-----------------------#2021-05-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/7cd35f7db9ec0f77dae654a85dd5b22e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gh2Ttj_yiu1SeYVETlvog.jpeg"/></div></div></figure><div class=""/><p id="af86" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"> LiveData </strong>是我们在2017年就需要的东西。观察者模式让我们的生活变得更容易，但是像RxJava这样的选项在当时对于初学者来说太复杂了。架构组件团队创建了<strong class="ir ht"> LiveData </strong>:一个非常固执己见的可观察数据持有者类，为Android设计。它保持简单，以便于入门，建议将RxJava用于更复杂的反应流情况，利用两者之间的集成。</p><h1 id="b672" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">DeadData？</h1><p id="4c51" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">LiveData仍然是我们针对Java开发人员、初学者和简单情况的<strong class="ir ht">解决方案</strong>。对于其余的，一个好的选择是转移到<strong class="ir ht">科特林流</strong>。心流仍然有一个陡峭的学习曲线，但它们是由Jetbrains支持的Kotlin语言的一部分；Compose即将到来，它非常适合反应式模型。</p><p id="6a15" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们已经<a class="ae kq" rel="noopener" href="/androiddevelopers/lessons-learnt-using-coroutines-flow-4a6b285c0d06">讨论过使用</a>流来连接除视图和视图模型之外的应用程序的不同部分。现在我们有了一种更安全的方法从Android UIs收集流，我们可以创建一个完整的迁移指南。</p><p id="9d4b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，您将学习如何向视图展示流，如何收集它们，以及如何对其进行微调以满足特定的需求。</p><h1 id="d925" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">心流:简单的事情更难，复杂的事情更容易</h1><p id="3f12" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">LiveData做了一件事，而且做得很好:它<a class="ae kq" rel="noopener" href="/androiddevelopers/livedata-with-coroutines-and-flow-part-i-reactive-uis-b20f676d25d7">公开数据，同时缓存最新值</a>并了解Android的生命周期。后来我们了解到它也可以<a class="ae kq" rel="noopener" href="/androiddevelopers/livedata-with-coroutines-and-flow-part-ii-launching-coroutines-with-architecture-components-337909f37ae7">启动协程</a>和<a class="ae kq" rel="noopener" href="/androiddevelopers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7#:~:text=The%20observable%20paradigm%20works%20really,take%20advantage%20of%20lifecycle%20awareness.&amp;text=Observe%20changes%20in%20SharedPreferences,document%20or%20collection%20in%20Firestore">创建复杂的转换</a>，但是这有点复杂。</p><p id="1763" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看一些LiveData模式及其流等价物:</p><h2 id="0d6e" class="kr jo hs bd jp ks kt ku jt kv kw kx jx ja ky kz kb je la lb kf ji lc ld kj le bi translated">#1:用可变数据容器暴露一次性操作的结果</h2><p id="67b7" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">这是一个经典的模式，您通过协程的结果改变了一个状态保持器:</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lf"><img src="../Images/f91747c31f7ca5cb0ba27fa90b373d97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uEwETJ80kXERy4bJ"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Expose the result of a one-shot operation with a Mutable data holder (LiveData)</figcaption></figure><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="2615" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了对流做同样的事情，我们使用(可变的)StateFlow:</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/943611613a9c2233085fe215b77c9d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hf3EmJ8gchpSy6nd"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Expose the result of a one-shot operation with a Mutable data holder (StateFlow)</figcaption></figure><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="af1d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae kq" href="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow#stateflow" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> StateFlow </strong> </a>是一种特殊的<a class="ae kq" href="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow#sharedflow" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht"> SharedFlow </strong> </a>(是一种特殊类型的流)，最接近LiveData:</p><ul class=""><li id="b68a" class="lr ls hs ir b is it iw ix ja lt je lu ji lv jm lw lx ly lz bi translated">它总是有价值的。</li><li id="1539" class="lr ls hs ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">它只有一个值。</li><li id="8391" class="lr ls hs ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">它支持多个观察者(因此流是<em class="mf">共享的</em>)。</li><li id="2554" class="lr ls hs ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">它总是重放订阅的最新值，与活动观察者的数量无关。</li></ul><blockquote class="mg mh mi"><p id="afba" class="ip iq mf ir b is it iu iv iw ix iy iz mj jb jc jd mk jf jg jh ml jj jk jl jm ha bi translated">当向视图显示UI状态时，使用<strong class="ir ht"> StateFlow </strong>。它是一个安全高效的观察器，用于保持UI状态。</p></blockquote><h2 id="59e6" class="kr jo hs bd jp ks kt ku jt kv kw kx jx ja ky kz kb je la lb kf ji lc ld kj le bi translated">#2:暴露一次性操作的结果</h2><p id="b45d" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">这相当于前面的代码片段，公开了没有可变支持属性的协程调用的结果。</p><p id="0e24" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于LiveData，我们使用了<code class="du mm mn mo mp b"><a class="ae kq" href="https://developer.android.com/topic/libraries/architecture/coroutines#livedata" rel="noopener ugc nofollow" target="_blank">liveData</a></code>协程构建器:</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/80c8ebce8107daef8f475236e3c9cdea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HKl0HDnxMxlYbZb_"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Expose the result of a one-shot operation (LiveData)</figcaption></figure><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="5162" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为状态持有者总是有一个值，所以将我们的UI状态包装在某种支持诸如<code class="du mm mn mo mp b">Loading</code>、<code class="du mm mn mo mp b">Success</code>和<code class="du mm mn mo mp b">Error</code>等状态的<strong class="ir ht">结果</strong>类中是一个好主意。</p><p id="93d5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">流量当量有点复杂，因为您必须做一些<em class="mf">配置</em>:</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/5ba783e9340ee4b9fb574582cd60a708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sFoX0pbnLijOPaiy"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Expose the result of a one-shot operation (StateFlow)</figcaption></figure><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="191f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du mm mn mo mp b"><strong class="ir ht">stateIn</strong></code>是一个流操作符，它将一个流转换成<strong class="ir ht">状态流</strong>。现在让我们相信这些参数，因为我们需要更多的复杂性来解释它。</p><h2 id="fe02" class="kr jo hs bd jp ks kt ku jt kv kw kx jx ja ky kz kb je la lb kf ji lc ld kj le bi translated">#3:带参数的一次性数据加载</h2><p id="22af" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">假设您想要加载一些依赖于用户ID的数据，并且您从一个公开流的<code class="du mm mn mo mp b">AuthManager</code>中获得该信息:</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/3b11228ccae023910093ddd1c8b60260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NkfiDL2ko9lkKPTh"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">One-shot data load with parameters (LiveData)</figcaption></figure><p id="e0e1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用LiveData，您可以做类似的事情:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="fa60" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du mm mn mo mp b">switchMap</code>是一个转换，当<code class="du mm mn mo mp b">userId</code>改变时，其主体被执行，结果被订阅。</p><p id="fa02" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果没有理由让<code class="du mm mn mo mp b">userId</code>成为LiveData，一个更好的替代方法是将streams和Flow结合起来，最后将公开的结果转换成LiveData。</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="ca25" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对流执行此操作看起来非常相似:</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/4f170c126de7ab95ccfeb5a3422a4f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IGFPV_i3vBpPQKsA"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">One-shot data load with parameters (StateFlow)</figcaption></figure><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="0a9b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，如果您需要更多的灵活性，您也可以显式使用<code class="du mm mn mo mp b">transformLatest</code>和<code class="du mm mn mo mp b">emit</code>项:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h2 id="94e2" class="kr jo hs bd jp ks kt ku jt kv kw kx jx ja ky kz kb je la lb kf ji lc ld kj le bi translated">#4:观察带参数的数据流</h2><p id="669f" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">现在让我们让这个例子更具反应性。数据没有被获取，但是<strong class="ir ht">观察到了</strong>，所以我们将数据源中的变化自动传播到UI。</p><p id="54c3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">继续我们的例子:我们没有在数据源上调用<code class="du mm mn mo mp b">fetchItem</code>,而是使用一个假设的返回流的<code class="du mm mn mo mp b">observeItem</code>操作符。</p><p id="ddb7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用LiveData，您可以将流转换为LiveData和<code class="du mm mn mo mp b">emitSource</code>所有更新:</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/1f4774e8ad9b8709e6a060aca9a9b7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gieCVtPGDY0GLmSW"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Observing a stream with parameters (LiveData)</figcaption></figure><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="b13c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者，最好使用<code class="du mm mn mo mp b"><a class="ae kq" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html" rel="noopener ugc nofollow" target="_blank">flatMapLatest</a></code>合并两个流，并且只将输出转换为LiveData:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="7fd4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">流实现类似，但它没有LiveData转换:</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/8b6415007110c01c0c73b81d34c4fa80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T-S2IXEmR2RL308f"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Observing a stream with parameters (StateFlow)</figcaption></figure><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="aee8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每当用户发生变化或者存储库中的用户数据发生变化时，公开的StateFlow都会收到更新。</p><h2 id="16fa" class="kr jo hs bd jp ks kt ku jt kv kw kx jx ja ky kz kb je la lb kf ji lc ld kj le bi translated">#5组合多个来源:MediatorLiveData -&gt; Flow.combine</h2><p id="6ac6" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">MediatorLiveData允许您观察一个或多个更新源(LiveData observables ),并在它们获得新数据时采取措施。通常，您会更新MediatorLiveData的值:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="4951" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">流量当量要简单得多:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="eb36" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您也可以使用<a class="ae kq" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine-transform.html" rel="noopener ugc nofollow" target="_blank">组合转换</a>功能，或<a class="ae kq" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html" rel="noopener ugc nofollow" target="_blank">压缩</a>。</p><h1 id="1b73" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">配置公开的状态流(stateIn操作符)</h1><p id="6212" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">我们之前使用了<code class="du mm mn mo mp b">stateIn</code>将常规流转换为状态流，但是这需要一些配置。如果你现在不想深入细节，只需要复制粘贴，我推荐以下组合:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="09bd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，如果你不确定那个看似随机的5秒<code class="du mm mn mo mp b">started </code>参数，请继续阅读。</p><p id="8b04" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du mm mn mo mp b">stateIn</code>有3个参数(来自文档):</p><pre class="lg lh li lj fd mq mp mr ms aw mt bi"><span id="4f62" class="kr jo hs mp b fi mu mv l mw mx">@param <strong class="mp ht">scope</strong> the coroutine scope in which sharing is started.</span><span id="66a3" class="kr jo hs mp b fi my mv l mw mx">@param <strong class="mp ht">started</strong> the strategy that controls when sharing is started and stopped.</span><span id="054c" class="kr jo hs mp b fi my mv l mw mx">@param <strong class="mp ht">initialValue</strong> the initial value of the state flow.</span><span id="42b3" class="kr jo hs mp b fi my mv l mw mx">This value is also used when the state flow is reset using the [SharingStarted.WhileSubscribed] strategy with the `replayExpirationMillis` parameter.</span></pre><p id="7684" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du mm mn mo mp b">started</code>可以取3个值:</p><ul class=""><li id="53c8" class="lr ls hs ir b is it iw ix ja lt je lu ji lv jm lw lx ly lz bi translated"><code class="du mm mn mo mp b">Lazily</code>:第一个用户出现时开始，取消<code class="du mm mn mo mp b">scope</code>时停止。</li><li id="cd23" class="lr ls hs ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated"><code class="du mm mn mo mp b">Eagerly</code>:立即启动，取消<code class="du mm mn mo mp b">scope</code>时停止</li><li id="7b57" class="lr ls hs ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated"><code class="du mm mn mo mp b">WhileSubscribed</code>:<strong class="ir ht">T22】很复杂。T24】</strong></li></ul><p id="a38f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于单次操作，您可以使用<code class="du mm mn mo mp b">Lazily</code>或<code class="du mm mn mo mp b">Eagerly</code>。然而，如果你在观察其他的流，你应该使用<code class="du mm mn mo mp b">WhileSubscribed</code>来做一些小但重要的优化，如下所述。</p><h1 id="0387" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">while订阅策略</h1><p id="3ca3" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">当没有收集器时，WhileSubscribed取消<strong class="ir ht"> <em class="mf">上游流</em> </strong>。使用<code class="du mm mn mo mp b">stateIn</code>创建的StateFlow向视图公开数据，但它也观察来自其他层或应用程序(上游)的流。让这些流保持活动状态可能会导致资源浪费，例如，如果它们继续从数据库连接、硬件传感器等其他来源读取数据。<strong class="ir ht">当你的app去后台的时候，你要做一个好公民，阻止这些协程。</strong></p><p id="cc10" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du mm mn mo mp b">WhileSubscribed</code>需要两个参数:</p><pre class="lg lh li lj fd mq mp mr ms aw mt bi"><span id="bba9" class="kr jo hs mp b fi mu mv l mw mx">public fun WhileSubscribed(<br/>    stopTimeoutMillis: Long = 0,<br/>    replayExpirationMillis: Long = Long.MAX_VALUE<br/>)</span></pre><h2 id="6e9c" class="kr jo hs bd jp ks kt ku jt kv kw kx jx ja ky kz kb je la lb kf ji lc ld kj le bi translated">停止超时</h2><p id="3c5d" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">从其文档来看:</p><blockquote class="mg mh mi"><p id="1c37" class="ip iq mf ir b is it iu iv iw ix iy iz mj jb jc jd mk jf jg jh ml jj jk jl jm ha bi translated"><code class="du mm mn mo mp b"><strong class="ir ht"><em class="hs">stopTimeoutMillis</em></strong></code> <em class="hs">配置最后一个用户消失和上游流量停止之间的延迟(毫秒)。默认为零(立即停止)。</em></p></blockquote><p id="5857" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这很有用，因为如果视图停止监听几分之一秒，您就不想取消上游流。这种情况时有发生，例如，当用户旋转设备时，视图会被快速连续地破坏和重新创建。</p><p id="890d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du mm mn mo mp b">liveData</code>协程构建器中的解决方案是<a class="ae kq" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-livedata-ktx/src/main/java/androidx/lifecycle/CoroutineLiveData.kt;l=356" rel="noopener ugc nofollow" target="_blank">添加一个5秒的延迟</a>,在此之后，如果没有用户出现，协程将被停止。<code class="du mm mn mo mp b">WhileSubscribed(5000)</code>确实如此:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="fded" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种方法检查所有的框:</p><ul class=""><li id="9d78" class="lr ls hs ir b is it iw ix ja lt je lu ji lv jm lw lx ly lz bi translated">当用户将你的应用程序发送到后台时，来自其他层的更新将在五秒钟后停止，以节省电池。</li><li id="68fa" class="lr ls hs ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">最新的值仍将被缓存，这样当用户返回时，视图将立即拥有一些数据。</li><li id="099f" class="lr ls hs ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">订阅将重新启动，新值将进入，可用时刷新屏幕。</li></ul><h2 id="0086" class="kr jo hs bd jp ks kt ku jt kv kw kx jx ja ky kz kb je la lb kf ji lc ld kj le bi translated">重播过期</h2><p id="ee61" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">如果你不希望用户在离开太久的时候看到陈旧的数据，并且你更喜欢显示一个加载屏幕，检查一下<code class="du mm mn mo mp b">WhileSubscribed</code>中的<code class="du mm mn mo mp b">replayExpirationMillis</code>参数。这在这种情况下非常方便，而且还节省了一些内存，因为缓存的值被恢复到了在<code class="du mm mn mo mp b">stateIn</code>中定义的初始值。回到应用程序不会很快，但你不会显示旧数据。</p><blockquote class="mg mh mi"><p id="172e" class="ip iq mf ir b is it iu iv iw ix iy iz mj jb jc jd mk jf jg jh ml jj jk jl jm ha bi translated"><code class="du mm mn mo mp b"><strong class="ir ht"><em class="hs">replayExpirationMillis</em></strong></code> <em class="hs"> —配置共享协程停止和重放缓存重置之间的延迟(以毫秒为单位)(这将使</em> <code class="du mm mn mo mp b"><em class="hs">shareIn</em></code> <em class="hs">操作符的缓存为空，并将</em> <code class="du mm mn mo mp b"><em class="hs">stateIn</em></code> <em class="hs">操作符的缓存值重置为原来的</em> <code class="du mm mn mo mp b"><em class="hs">initialValue</em></code>】)。默认为 <code class="du mm mn mo mp b"><em class="hs">Long.MAX_VALUE</em></code> <em class="hs">(永远保留重播缓存，从不重置缓冲)。使用零值将使缓存立即过期。</em></p></blockquote><h1 id="1cdf" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">从视图观察状态流</h1><p id="ef00" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">正如我们到目前为止所看到的，视图让视图模型中的状态流知道它们不再监听是非常重要的。然而，就像所有与生命周期相关的事情一样，事情并没有那么简单。</p><p id="f78e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了收集流，您需要一个协程。活动和片段提供了一堆协程构建器:</p><ul class=""><li id="ea7a" class="lr ls hs ir b is it iw ix ja lt je lu ji lv jm lw lx ly lz bi translated"><code class="du mm mn mo mp b"><strong class="ir ht">Activity.lifecycleScope.launch</strong></code>:立即启动协程，并在活动被销毁时取消它。</li><li id="af09" class="lr ls hs ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated"><code class="du mm mn mo mp b"><strong class="ir ht">Fragment.lifecycleScope.launch</strong></code>:立即启动协程，当片段被销毁时取消。</li><li id="f4b8" class="lr ls hs ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated"><code class="du mm mn mo mp b"><strong class="ir ht">Fragment.viewLifecycleOwner.lifecycleScope.launch</strong></code>:当片段的视图生命周期被破坏时，立即启动协程并取消它。如果要修改UI，应该使用视图生命周期。</li></ul><h1 id="d6dd" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">启动时开始，启动时恢复…</h1><p id="b794" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">称为<code class="du mm mn mo mp b">launchWhenX</code>的<code class="du mm mn mo mp b">launch</code>的特殊版本将等待，直到<code class="du mm mn mo mp b">lifecycleOwner</code>处于X状态，并且当<code class="du mm mn mo mp b">lifecycleOwner</code>低于X状态时暂停协程。值得注意的是<strong class="ir ht">他们不会取消协程，直到他们的生命周期所有者被销毁</strong>。</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mz"><img src="../Images/a11233fd799e5ff5dca1996c38d042a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rlKJkDx0aSQrdhDO"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Collecting Flows with <code class="du mm mn mo mp b">launch/launchWhenX</code> is unsafe</figcaption></figure><p id="fc9e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">应用程序在后台接收更新可能会导致崩溃，这可以通过在视图中暂停集合来解决。然而，当应用程序在后台时，上游流量保持活跃，这可能会浪费资源。</p><p id="dc1e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这意味着到目前为止我们为配置StateFlow所做的一切都是无用的；然而，镇上有一个新的API。</p><h1 id="8adc" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">lifecycle.repeatOnLifecycle来拯救</h1><p id="c1cc" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">这个新的协程构建器(可从<a class="ae kq" href="https://developer.android.com/jetpack/androidx/releases/lifecycle#2.4.0-alpha01" rel="noopener ugc nofollow" target="_blank">life cycle-runtime-ktx 2 . 4 . 0-alpha 01</a>获得)做了我们需要的事情:它在特定的状态启动协程，当生命周期所有者低于该状态时，它停止协程。</p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mz"><img src="../Images/ff26589b6805f2b0e5732503629d06e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pDKnvDJ9FzaCgXCd"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">Different Flow collection methods</figcaption></figure><p id="83d7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，在一个片段中:</p><figure class="lg lh li lj fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="0ac0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将在片段的视图为<code class="du mm mn mo mp b">STARTED</code>时开始收集，将持续到<code class="du mm mn mo mp b">RESUMED</code>，并在返回到<code class="du mm mn mo mp b">STOPPED</code>时停止。阅读<a class="ae kq" rel="noopener" href="/androiddevelopers/a-safer-way-to-collect-flows-from-android-uis-23080b1f8bda">从Android用户界面收集流量的更安全的方法</a>中的相关内容。</p><p id="479c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">将</strong> <code class="du mm mn mo mp b"><strong class="ir ht"><em class="mf">repeatOnLifecycle</em></strong></code> <strong class="ir ht"> API与上面的StateFlow指南结合使用，可以在充分利用设备资源的同时获得最佳性能。</strong></p><figure class="lg lh li lj fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mz"><img src="../Images/f2cd98b9ad96c10b802d5d6cd4d2ce07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AJokESYOHI4uxfWs"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx">StateFlow exposed with WhileSubscribed(5000) and collected with repeatOnLifecycle(STARTED)</figcaption></figure><blockquote class="mg mh mi"><p id="7a92" class="ip iq mf ir b is it iu iv iw ix iy iz mj jb jc jd mk jf jg jh ml jj jk jl jm ha bi translated">警告:最近添加到<strong class="ir ht">数据绑定</strong> 中的<a class="ae kq" href="https://developer.android.com/topic/libraries/data-binding/observability#stateflow" rel="noopener ugc nofollow" target="_blank"> StateFlow支持使用<code class="du mm mn mo mp b">launchWhenCreated</code>来收集更新，当它达到稳定时将开始使用<code class="du mm mn mo mp b">repeatOnLifecycle</code>来代替。</a></p><p id="bbf1" class="ip iq mf ir b is it iu iv iw ix iy iz mj jb jc jd mk jf jg jh ml jj jk jl jm ha bi translated">对于<strong class="ir ht">数据绑定</strong>，您应该在任何地方使用流，并且简单地添加<code class="du mm mn mo mp b">asLiveData()</code>来将它们暴露给视图。当<code class="du mm mn mo mp b">lifecycle-runtime-ktx 2.4.0</code>稳定时，数据绑定将被更新。</p></blockquote><h1 id="fc16" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="462b" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">从视图模型中公开数据并从视图中收集数据的最佳方式是:</p><ul class=""><li id="10a7" class="lr ls hs ir b is it iw ix ja lt je lu ji lv jm lw lx ly lz bi translated">✔️暴露了一个<code class="du mm mn mo mp b">StateFlow</code>，使用了<code class="du mm mn mo mp b">WhileSubscribed</code>策略，超时了。[ <a class="ae kq" href="https://gist.github.com/JoseAlcerreca/4eb0be817d8f94880dab279d1c27a4af" rel="noopener ugc nofollow" target="_blank">示例</a></li><li id="4927" class="lr ls hs ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">✔️用<code class="du mm mn mo mp b">repeatOnLifecycle</code>收集。[ <a class="ae kq" href="https://gist.github.com/JoseAlcerreca/6e2620b5615425a516635744ba59892e" rel="noopener ugc nofollow" target="_blank">示例</a></li></ul><p id="a2fb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">任何其他组合将保持上游流动活跃，浪费资源:</p><ul class=""><li id="8c2e" class="lr ls hs ir b is it iw ix ja lt je lu ji lv jm lw lx ly lz bi translated">❌使用<code class="du mm mn mo mp b">WhileSubscribed</code>曝光，并在<code class="du mm mn mo mp b">lifecycleScope.launch</code> / <code class="du mm mn mo mp b">launchWhenX</code>内收集</li><li id="e300" class="lr ls hs ir b is ma iw mb ja mc je md ji me jm lw lx ly lz bi translated">❌用<code class="du mm mn mo mp b">Lazily</code> / <code class="du mm mn mo mp b">Eagerly</code>曝光，用<code class="du mm mn mo mp b">repeatOnLifecycle</code>收集</li></ul><p id="1ce6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当然，如果你不需要流的全部力量…就用LiveData。:)</p><p id="16c4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="mf">感谢</em> <a class="ae kq" rel="noopener" href="/@manuelvicnt"> <em class="mf">曼努埃尔</em><em class="mf"/></a><a class="ae kq" rel="noopener" href="/@wkalicinski"><em class="mf">沃伊泰克</em></a><em class="mf"/><a class="ae kq" rel="noopener" href="/@yigit/"><em class="mf">伊吉特</em> </a> <em class="mf">，亚历克斯库克</em> <a class="ae kq" rel="noopener" href="/@florina.muntenescu"> <em class="mf">【弗洛里纳</em> </a> <em class="mf">和</em> <a class="ae kq" href="https://chrisbanes.medium.com/" rel="noopener">克里斯 </a>！</p></div></div>    
</body>
</html>