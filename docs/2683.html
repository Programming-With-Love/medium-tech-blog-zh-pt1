<html>
<head>
<title>Object-Oriented Programming in Java — Java OOPs Concepts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java面向对象编程— Java OOPs概念</h1>
<blockquote>原文：<a href="https://medium.com/edureka/object-oriented-programming-b29cfd50eca0?source=collection_archive---------0-----------------------#2017-05-03">https://medium.com/edureka/object-oriented-programming-b29cfd50eca0?source=collection_archive---------0-----------------------#2017-05-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/6fb546a7c37da8d286b59d251c68c8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*vY4pkH1Ky9PEK92HGhNCKg.png"/></div><figcaption class="il im et er es in io bd b be z dx">Object-Oriented Programming - Edureka</figcaption></figure><p id="4456" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">面向对象编程是一种编程风格，与类、对象、继承、封装、抽象、多态等概念相关联。大多数流行的编程语言，如Java、C++、C#、Ruby等。遵循面向对象的编程范式。在这篇博客中，我将谈论Java中面向对象的编程概念。Java中基于对象的应用程序是基于声明类、从类创建对象以及这些对象之间的交互。在这篇博客中，我们将按以下顺序理解面向对象编程的核心概念:</p><ol class=""><li id="8387" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">遗产</li><li id="a426" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">包装</li><li id="83f7" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">抽象</li><li id="2c13" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">多态性</li></ol><p id="245e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从第一个面向对象编程概念开始，即<strong class="ir hi">继承</strong>。</p><h1 id="ff32" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">遗产</h1><p id="f887" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">在面向对象的程序设计中，计算机程序是以这样一种方式设计的，在这种方式中，一切都是一个相互作用的对象。继承就是这样一个概念，其中一个类的属性可以被另一个类继承。它有助于重用代码和建立不同类之间的关系。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es le"><img src="../Images/11e54160bb368cfe1d2b21c6dccf9979.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*yG7ik5NlMj1Oy9VFHneeHA.png"/></div></figure><p id="c92f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们在图中看到的，一个孩子继承了他父亲的财产。类似地，在Java中，有两个类:</p><p id="ee66" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lj"> 1。</em>父类(超类或基类)</strong></p><p id="ae1e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lj"> 2。</em>子类(子类或派生类)</strong></p><p id="c13c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">继承属性的类称为子类，而属性被继承的类称为父类。</p><p id="156f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lj">继承又分为4种:</em> </strong></p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lk"><img src="../Images/cb3e39c571439cf42c3e8a0a64825d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Y8g1TPvM1x-0Iv5cfshWQ.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Inheritance Types — Object-Oriented Programming</figcaption></figure><p id="711e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以让我们从第一种类型的继承开始，即<strong class="ir hi">单一继承</strong>:</p><h2 id="8d9b" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak">单一继承:</strong></h2><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es md"><img src="../Images/c76c26da4889be55d79ab3d904fcc210.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/format:webp/1*d7KPjhqLgWdw5G_gJnZOeA.png"/></div></figure><p id="80d3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在单一继承中，一个类继承另一个类的属性。它使派生类能够继承单个父类的属性和行为。反过来，这将实现代码的可重用性，并为现有的代码添加新的特性。</p><p id="4994" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，A类是你的父类，B类是你的子类，继承了父类的属性和行为。</p><p id="a5da" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看单一继承的语法:</p><pre class="lf lg lh li fd me mf mg mh aw mi bi"><span id="a275" class="lp kc hh mf b fi mj mk l ml mm">Class A<br/>{<br/>---<br/>}<br/>Class B extends A {<br/>---<br/>}</span></pre><h2 id="21c8" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak">多级继承:</strong></h2><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es mn"><img src="../Images/ee8336ad0fefb3d21c88a39a01f38fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*amFcGRdYEj0ddCDj9gqp7Q.png"/></div></figure><p id="a12d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当一个类从另一个类派生的类派生时，即一个类具有一个以上的父类但在不同的级别，这种类型的继承称为多级继承。</p><p id="72f0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们讨论流程图，B类继承A类的属性和行为，C类继承B类的属性。这里A是B的父类，B类是C的父类。所以在这种情况下，C类隐式继承A类和B类的属性和方法。这就是多级继承。</p><p id="6d75" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看Java中多级继承的语法:</p><pre class="lf lg lh li fd me mf mg mh aw mi bi"><span id="0073" class="lp kc hh mf b fi mj mk l ml mm">Class A{<br/>---<br/>}<br/>Class B extends A{<br/>---<br/>}<br/>Class C extends B{<br/>---<br/>}</span></pre><h2 id="8911" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak">等级继承:</strong></h2><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es mo"><img src="../Images/9a88554d7ade0bd3e9da446c388b9c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*aBOtNdCin5k6iiT03-P_OA.png"/></div></figure><p id="9908" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当一个类有不止一个子类(子类)时，或者换句话说，不止一个子类有相同的父类，那么这种继承称为<strong class="ir hi">层次</strong>。</p><p id="32f0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们讨论流程图，B类和C类是继承自父类即a类的子类。</p><p id="3111" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看Java中层次继承的语法:</p><pre class="lf lg lh li fd me mf mg mh aw mi bi"><span id="935b" class="lp kc hh mf b fi mj mk l ml mm">Class A{<br/>---<br/>}<br/>Class B extends A{<br/>---<br/>}<br/>Class C extends A{<br/>---<br/>}</span></pre><h2 id="ece1" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak">杂交遗传:</strong></h2><p id="f009" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">混合<strong class="ir hi"> </strong>继承是<em class="lj">多重</em>继承和<em class="lj">多级</em>继承的结合。由于Java不支持多重继承，这会导致歧义，所以这种类型的继承只能通过使用接口来实现。</p><p id="3ee4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们讨论流程图，A类是B类和C类的父类，而B类和C类是D的父类，D是B类和C的唯一子类。</p><p id="a9f4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们已经了解了继承和它们的不同类型。让我们切换到另一个面向对象的编程概念，即<strong class="ir hi">封装</strong>。</p><h1 id="807c" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">包装</h1><p id="6c67" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">封装是一种将数据和代码作为一个单元绑定在一起的机制。这也意味着隐藏您的数据，以使其免受任何修改。这是什么意思？理解胶囊化的最好方法是看一个医用胶囊的例子，药物在胶囊里总是安全的。同样，通过封装，一个类的方法和变量被很好地隐藏和安全。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es mp"><img src="../Images/8449dd169c599153a10f4ce389baf02b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*zOZ7ScAI_TA5RTV9SCx6FQ.png"/></div><figcaption class="il im et er es in io bd b be z dx">Encapsulation in Java - Object Oriented Programming</figcaption></figure><p id="f1fa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lj">我们可以通过</em> </strong>来实现Java中的封装</p><ul class=""><li id="4059" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm mq jt ju jv bi translated">将类的变量声明为私有。</li><li id="7307" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mq jt ju jv bi translated">提供公共setter和getter方法来修改和查看变量值。</li></ul><p id="ddbf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看下面的代码，以便更好地理解封装:</p><pre class="lf lg lh li fd me mf mg mh aw mi bi"><span id="0be6" class="lp kc hh mf b fi mj mk l ml mm">public class Employee {<br/> private String name;<br/> public String getName() {<br/> return name;<br/> }<br/> public void setName(String name) {<br/> this.name = name;<br/> }<br/> public static void main(String[] args) {<br/> }<br/>}</span></pre><p id="fb35" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们试着理解上面的代码。我创建了一个Employee类，它有一个私有变量<strong class="ir hi">名。</strong>然后我们创建了一个<strong class="ir hi"> getter </strong>和<strong class="ir hi"> setter方法</strong>，通过它们我们可以获取并设置一个雇员的名字。通过这些方法，任何希望访问name变量的类都必须使用这些getter和setter方法。</p><p id="233c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们前进到第三个面向对象的编程概念，即<strong class="ir hi">抽象</strong>。</p><h1 id="c945" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">抽象</h1><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es mr"><img src="../Images/659b396ccb026ef3224e5e102bda7841.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/format:webp/1*cogJQ8sshc3XpXOHjZ9sgQ.png"/></div></figure><p id="64e1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">抽象是指处理思想而不是事件的品质。它基本上处理的是隐藏细节，向用户展示本质的东西。如果你看这里的图像，每当我们接到一个电话，我们可以选择接听或拒绝。但实际上，有很多代码在后台运行。所以你不知道一个调用是如何产生的内部处理，这就是抽象的美妙之处。因此，抽象有助于降低复杂性。<strong class="ir hi"> <em class="lj">你可以通过两种方式实现抽象</em> </strong>:</p><p id="4a40" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">a)抽象类</p><p id="88c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">b)接口</p><p id="d194" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们更详细地理解这些概念。</p><h2 id="c4ec" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak">抽象类:</strong></h2><p id="877a" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">Java中的抽象类包含了'<strong class="ir hi"> <em class="lj">抽象</em> </strong>'关键字。那么，abstract关键字是什么意思？如果一个类被声明为抽象的，它就不能被实例化，这意味着你不能创建一个抽象类的对象。此外，抽象类可以包含抽象和具体的方法。</p><p id="5c31" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意:你可以使用一个抽象类实现0-100%的抽象。T9】</p><p id="9886" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要使用一个抽象类，你必须从另一个类继承它，在那里你必须提供抽象方法的实现，否则它也将成为一个抽象类。</p><p id="af34" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看抽象类的语法:</p><pre class="lf lg lh li fd me mf mg mh aw mi bi"><span id="c329" class="lp kc hh mf b fi mj mk l ml mm">Abstract class Mobile {   // abstract class mobile<br/>Abstract void run();      // abstract method</span></pre><h2 id="aac4" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak">接口:</strong></h2><p id="a58f" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">Java中的接口是一个类的蓝图，或者你可以说它是抽象方法和静态常量的集合。在接口中，每个方法都是公共的和抽象的，但是它不包含任何构造函数。除了抽象，接口还有助于在Java中实现多重继承。</p><p id="51c7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lj">注意</em>:使用接口可以实现100%的抽象。</strong></p><p id="1581" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以一个接口基本上是一组相关的空方法。让我们通过一个“ParentCar”接口及其相关方法的例子来更好地理解接口。</p><pre class="lf lg lh li fd me mf mg mh aw mi bi"><span id="859b" class="lp kc hh mf b fi mj mk l ml mm">public interface ParentCar {<br/>public void changeGear( int newValue);<br/>public void speedUp(int increment);<br/>public void applyBrakes(int decrement);<br/>}</span></pre><p id="5a28" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每辆车都需要这些方法，对吗？但是他们的工作会有所不同。</p><p id="35e3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">比方说，你驾驶的是一辆手动挡汽车，你必须一个接一个地增加档位，但是如果你驾驶的是一辆自动挡汽车，那时候你的系统会决定如何根据速度改变档位。所以，不是我所有的子类都为<em class="lj">变速杆</em>写了同样的逻辑。同样的情况也适用于<em class="lj">加速</em>，现在我们假设当你按下一个加速器时，它以10公里或15公里的速度加速。但假设，有人驾驶一辆超级跑车，它增加了30公里或50公里。逻辑又变了。类似的还有<em class="lj">应用刹车</em>，一个人可能有强大的刹车，另一个人可能没有。</p><p id="336d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为所有的功能对我所有的子类都是通用的，所以我创建了一个接口‘parent car ’,所有的功能都在这里。之后，我将创建一个实现这个接口的子类，其中所有这些方法的定义都不同。</p><p id="16f2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，让我们看看如何实现这个接口的功能。所以要实现这个接口，你的类的名字可以改成任何特定品牌的汽车，比如说我开一辆“奥迪”。为了实现类接口，我将使用“implement”关键字，如下所示:</p><pre class="lf lg lh li fd me mf mg mh aw mi bi"><span id="3ef6" class="lp kc hh mf b fi mj mk l ml mm">public class Audi implements ParentCar {<br/>int speed=0;<br/>int gear=1;<br/>public void changeGear( int value){<br/>gear=value;<br/>}<br/>public void speedUp( int increment)<br/>{<br/>speed=speed+increment;<br/>}<br/>public void applyBrakes(int decrement)<br/>{<br/>speed=speed-decrement;<br/>}<br/>void printStates(){<br/>System.out.println("speed:"+speed+"gear:"+gear);<br/>}<br/>public static void main(String[] args) {<br/>// TODO Auto-generated method stub<br/>Audi A6= new Audi();<br/>A6.speedUp(50);<br/>A6.printStates();<br/>A6.changeGear(4);<br/>A6.SpeedUp(100);<br/>A6.printStates();<br/>}<br/>}</span></pre><p id="d884" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如你所见，我已经为我在接口类中声明的不同方法提供了功能。实现一个接口允许一个类对它承诺提供的行为变得更加正式。你也可以创建另一个类，比如说BMW类，它可以继承相同的接口“car ”,但具有不同的功能。</p><p id="049f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以我希望你们清楚这个接口，以及如何使用它实现抽象。</p><p id="bccf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，最后一个面向对象的编程概念是<strong class="ir hi">多态</strong>。</p><h1 id="e392" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">多态性</h1><p id="bd5d" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">多态性意味着采取多种形式，其中'<strong class="ir hi"> poly </strong>'意味着许多，而' morph '意味着多种形式。它是变量、函数或对象呈现多种形式的能力。换句话说，多态性允许您定义一个接口或方法，并拥有多个实现。</p><p id="2f7f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们通过一个真实的例子来理解这一点，以及这个概念如何适合面向对象编程。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es ms"><img src="../Images/2051cdc14fed73704f6a14640c12aa73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRFuzb9tHetJIV2LDjuxuA.png"/></div></div><figcaption class="il im et er es in io bd b be z dx">Example of Polymorphism - Object Oriented Programming</figcaption></figure><p id="3938" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们考虑一下板球中的真实场景，我们知道有不同类型的投球手，即快速投球手、中速投球手和旋转球手。如上图所示，有一个父类-<strong class="ir hi">bowl rclass</strong>，它有三个子类:<strong class="ir hi"> FastPacer </strong>、<strong class="ir hi"> MediumPacer、</strong>和<strong class="ir hi"> Spinner </strong>。Bowler类有<strong class="ir hi"> bowlingMethod() </strong>，其中所有的子类都继承了这个方法。众所周知，在保龄球速度、长距离助跑和保龄球方式等方面，快速投球手与中速投球手和旋转投球手有所不同。类似地，一个中等步行者对<strong class="ir hi"> bowlingMethod() </strong>的实现也将与其他投球手不同。spinner类也是如此。<br/>上面讨论的观点简单来说就是同一个名字倾向于多种形式。以上三个类都继承了<strong class="ir hi"> bowlingMethod() </strong>但是它们的实现完全不同。</p><p id="8ba3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"><em class="lj">Java中的多态性有两种:</em> </strong></p><ol class=""><li id="c619" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">运行时多态性</li><li id="01d0" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">编译时多态性</li></ol><h2 id="b948" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak">运行时多态性:</strong></h2><p id="3bbc" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">在Java中，运行时多态性指的是在运行时而不是编译时解决对被覆盖方法的调用的过程。在这种情况下，引用变量用于在运行时调用超类的覆盖方法。方法重写是运行时多态性的一个例子。让我们看看下面的代码来理解方法重写是如何工作的:</p><pre class="lf lg lh li fd me mf mg mh aw mi bi"><span id="27bd" class="lp kc hh mf b fi mj mk l ml mm">public Class BowlerClass{<br/>void bowlingMethod()<br/>{<br/>System.out.println(" bowler ");<br/>}<br/>public Class FastPacer{<br/>void bowlingMethod()<br/>{<br/>System.out.println(" fast bowler ");<br/>}<br/>Public static void main(String[] args)<br/>{<br/>FastPacer obj= new FastPacer();<br/>obj.bowlingMethod();<br/>}<br/>}</span></pre><h2 id="b51d" class="lp kc hh bd kd lq lr ls kh lt lu lv kl ja lw lx kp je ly lz kt ji ma mb kx mc bi translated"><strong class="ak">编译时多态性:</strong></h2><p id="9560" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">在Java中，编译时多态性指的是在编译时而不是运行时解决对重载方法的调用的过程。方法重载是编译时多态性的一个例子。<strong class="ir hi"> </strong>方法重载是一个特性，它允许一个类拥有两个或更多同名的方法，但是传递给这些方法的参数是不同的。</p><p id="36bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lj">与方法凌驾不同，论据可以不同于:</em> </strong></p><ol class=""><li id="4e04" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">传递给方法的参数数量</li><li id="77ea" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">参数的数据类型</li><li id="be27" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">传递给方法时的数据类型序列。</li></ol><p id="5642" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看下面的代码来理解方法重载是如何工作的:</p><pre class="lf lg lh li fd me mf mg mh aw mi bi"><span id="47bd" class="lp kc hh mf b fi mj mk l ml mm">class Adder {<br/>Static int add(int a, int b)<br/>{<br/>return a+b;<br/>}<br/>static double add( double a, double b)<br/>{<br/>return a+b;<br/>}<br/> <br/>public static void main(String args[])<br/>{<br/>System.out.println(Adder.add(11,11));<br/>System.out.println(Adder.add(12.3,12.6));<br/>}<br/>}</span></pre><p id="8dd2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望你们清楚我们上面讨论的所有面向对象的编程概念，即继承、封装、抽象和多态。现在，您可以使用Java OOPs概念使您的Java应用程序更加安全、简单和可重用。</p><p id="17f7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到此，我们结束了这个博客。如果你想查看更多关于人工智能、DevOps、道德黑客等市场最热门技术的文章，你可以参考Edureka的官方网站。</p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释Java的各个方面。</p><blockquote class="mt mu mv"><p id="f1b5" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">1.<a class="ae mz" rel="noopener" href="/edureka/java-tutorial-bbdd28a2acd7"> Java教程</a></p><p id="1e78" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">2.<a class="ae mz" rel="noopener" href="/edureka/inheritance-in-java-f638d3ed559e">Java中的继承</a></p><p id="f357" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">3.<a class="ae mz" rel="noopener" href="/edureka/polymorphism-in-java-9559e3641b9b">Java中的多态性</a></p><p id="dfc0" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">4.<a class="ae mz" rel="noopener" href="/edureka/java-abstraction-d2d790c09037">Java中的抽象</a></p><p id="7573" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">5.<a class="ae mz" rel="noopener" href="/edureka/java-string-68e5d0ca331f"> Java字符串</a></p><p id="68e3" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">6.<a class="ae mz" rel="noopener" href="/edureka/java-array-tutorial-50299ef85e5"> Java数组</a></p><p id="5e4b" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">7.<a class="ae mz" rel="noopener" href="/edureka/java-collections-6d50b013aef8"> Java集合</a></p><p id="1b4c" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">8.<a class="ae mz" rel="noopener" href="/edureka/java-thread-bfb08e4eb691"> Java线程</a></p><p id="d2f7" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">9.<a class="ae mz" rel="noopener" href="/edureka/java-servlets-62f583d69c7e">Java servlet简介</a></p><p id="3464" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">10.<a class="ae mz" rel="noopener" href="/edureka/servlet-and-jsp-tutorial-ef2e2ab9ee2a"> Servlet和JSP教程</a></p><p id="2e44" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">11.<a class="ae mz" rel="noopener" href="/edureka/java-exception-handling-7bd07435508c">Java中的异常处理</a></p><p id="2c04" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">12.<a class="ae mz" rel="noopener" href="/edureka/advanced-java-tutorial-f6ebac5175ec">高级Java教程</a></p><p id="73ee" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">13.<a class="ae mz" rel="noopener" href="/edureka/java-interview-questions-1d59b9c53973"> Java面试问题</a></p><p id="e797" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">14.<a class="ae mz" rel="noopener" href="/edureka/java-programs-1e3220df2e76"> Java程序</a></p><p id="61bd" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">15.<a class="ae mz" rel="noopener" href="/edureka/kotlin-vs-java-4f8653f38c04">科特林vs Java </a></p><p id="8670" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">16.<a class="ae mz" rel="noopener" href="/edureka/what-is-dependency-injection-5006b53af782">依赖注入使用Spring Boot </a></p><p id="6dd9" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">17.<a class="ae mz" rel="noopener" href="/edureka/comparable-in-java-e9cfa7be7ff7">Java中的可比</a></p><p id="e7af" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">18.<a class="ae mz" rel="noopener" href="/edureka/java-frameworks-5d52f3211f39">十大Java框架</a></p><p id="f58a" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">19.<a class="ae mz" rel="noopener" href="/edureka/java-reflection-api-d38f3f5513fc"> Java反射API </a></p><p id="f8f0" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">20.<a class="ae mz" rel="noopener" href="/edureka/pattern-programs-in-java-f33186c711c8">Java中的30大模式</a></p><p id="b9b2" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">21.<a class="ae mz" rel="noopener" href="/edureka/java-cheat-sheet-3ad4d174012c">核心Java备忘单</a></p><p id="cdac" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">22.<a class="ae mz" rel="noopener" href="/edureka/socket-programming-in-java-f09b82facd0">Java中的套接字编程</a></p><p id="1258" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">23.<a class="ae mz" rel="noopener" href="/edureka/java-oop-cheat-sheet-9c6ebb5e1175"> Java OOP备忘单</a></p><p id="04aa" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">24.<a class="ae mz" rel="noopener" href="/edureka/annotations-in-java-9847d531d2bb">Java中的注释</a></p><p id="e6ce" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">25.<a class="ae mz" rel="noopener" href="/edureka/library-management-system-project-in-java-b003acba7f17">Java中的图书管理系统项目</a></p><p id="eaaa" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">26.<a class="ae mz" rel="noopener" href="/edureka/java-binary-tree-caede8dfada5">Java中的树</a></p><p id="4fd7" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">27.<a class="ae mz" rel="noopener" href="/edureka/machine-learning-in-java-db872998f368">Java中的机器学习</a></p><p id="5222" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">28.<a class="ae mz" rel="noopener" href="/edureka/data-structures-algorithms-in-java-d27e915db1c5">Java中的顶级数据结构&amp;算法</a></p><p id="2952" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">29.<a class="ae mz" rel="noopener" href="/edureka/java-developer-skills-83983e3d3b92"> Java开发人员技能</a></p><p id="0b3e" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">30.<a class="ae mz" rel="noopener" href="/edureka/servlet-interview-questions-266b8fbb4b2d">前55个Servlet面试问题</a></p><p id="b609" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">31.<a class="ae mz" rel="noopener" href="/edureka/java-exception-handling-7bd07435508c"> </a> <a class="ae mz" rel="noopener" href="/edureka/java-projects-db51097281e3">顶级Java项目</a></p><p id="2b29" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">32.<a class="ae mz" rel="noopener" href="/edureka/java-string-cheat-sheet-9a91a6b46540"> Java字符串备忘单</a></p><p id="4797" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">33.<a class="ae mz" rel="noopener" href="/edureka/nested-classes-java-f1987805e7e3">Java中的嵌套类</a></p><p id="3d55" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">34.<a class="ae mz" rel="noopener" href="/edureka/java-collections-interview-questions-162c5d7ef078"> Java集合面试问答</a></p><p id="4e79" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">35.<a class="ae mz" rel="noopener" href="/edureka/deadlock-in-java-5d1e4f0338d5">Java中如何处理死锁？</a></p><p id="158c" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">36.<a class="ae mz" rel="noopener" href="/edureka/java-collections-interview-questions-6d20f552773e">你需要知道的50大Java集合面试问题</a></p><p id="e394" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">37.<a class="ae mz" rel="noopener" href="/edureka/java-string-pool-5b5b3b327bdf">Java中的字符串池是什么概念？</a></p><p id="3073" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">38.<a class="ae mz" rel="noopener" href="/edureka/difference-between-c-cpp-and-java-625c4e91fb95">C、C++和Java有什么区别？</a></p><p id="88c4" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">39.<a class="ae mz" rel="noopener" href="/edureka/palindrome-in-java-5d116eb8755a">Java中的回文——如何检查一个数字或字符串？</a></p><p id="74b8" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">40.<a class="ae mz" rel="noopener" href="/edureka/mvc-interview-questions-cd568f6d7c2e">你需要知道的顶级MVC面试问答</a></p><p id="9ccf" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">41.<a class="ae mz" rel="noopener" href="/edureka/applications-of-java-11e64f9588b0">Java编程语言十大应用</a></p><p id="3efd" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">42.<a class="ae mz" rel="noopener" href="/edureka/deadlock-in-java-5d1e4f0338d5">Java中的死锁</a></p><p id="c6d7" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">43.<a class="ae mz" rel="noopener" href="/edureka/java-sqrt-method-59354a700571">Java中的平方和平方根</a></p><p id="0263" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">44.<a class="ae mz" rel="noopener" href="/edureka/type-casting-in-java-ac4cd7e0bbe1">Java中的类型转换</a></p><p id="b93e" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">45.<a class="ae mz" rel="noopener" href="/edureka/operators-in-java-fd05a7445c0a">Java中的运算符及其类型</a></p><p id="836c" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">46.<a class="ae mz" rel="noopener" href="/edureka/destructor-in-java-21cc46ed48fc">Java中的析构函数</a></p><p id="ce21" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">47.<a class="ae mz" rel="noopener" href="/edureka/binary-search-in-java-cf40e927a8d3">Java中的二分搜索法</a></p><p id="7708" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">48.<a class="ae mz" rel="noopener" href="/edureka/mvc-architecture-in-java-a85952ae2684">Java中的MVC架构</a></p><p id="fa9e" class="ip iq lj ir b is it iu iv iw ix iy iz mw jb jc jd mx jf jg jh my jj jk jl jm ha bi translated">49.<a class="ae mz" rel="noopener" href="/edureka/hibernate-interview-questions-78b45ec5cce8"> Hibernate面试问答</a></p></blockquote></div><div class="ab cl na nb go nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ha hb hc hd he"><p id="e419" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lj">原载于2017年5月3日www.edureka.co</em><em class="lj">的</em> <a class="ae mz" href="https://www.edureka.co/blog/object-oriented-programming" rel="noopener ugc nofollow" target="_blank"> <em class="lj">。</em></a></p></div></div>    
</body>
</html>