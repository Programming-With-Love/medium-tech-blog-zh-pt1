<html>
<head>
<title>Practical ProGuard rules examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实用程序规则示例</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/practical-proguard-rules-examples-5640a3907dc9?source=collection_archive---------0-----------------------#2018-02-20">https://medium.com/androiddevelopers/practical-proguard-rules-examples-5640a3907dc9?source=collection_archive---------0-----------------------#2018-02-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="1e0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我之前的文章中，我解释了<a class="ae jc" rel="noopener" href="/google-developers/troubleshooting-proguard-issues-on-android-bce9de4f8a74">为什么每个人都应该为他们的Android应用程序</a>使用ProGuard，如何启用它，以及这样做时你可能会遇到什么样的错误。这涉及到很多理论，因为我认为为了准备好处理任何潜在的问题，理解潜在的原则是很重要的。</p><p id="df5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我还在另一篇文章中谈到了为即时应用构建配置ProGuard的具体问题。</p><p id="b23a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一部分，我想谈谈在一个中等大小的示例应用程序上ProGuard规则的实际例子:<a class="ae jc" href="https://github.com/nickbutcher/plaid" rel="noopener ugc nofollow" target="_blank">格子</a>作者<a class="jd je ge" href="https://medium.com/u/22c02a30ae04?source=post_page-----5640a3907dc9--------------------------------" rel="noopener" target="_blank">尼克·布彻</a>。</p><h1 id="94aa" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">格子呢的经验教训</h1><p id="47d1" class="pw-post-body-paragraph ie if hh ig b ih kd ij ik il ke in io ip kf ir is it kg iv iw ix kh iz ja jb ha bi translated">事实证明，Plaid是研究ProGuard问题的一个很好的主题，因为它包含了使用注释处理和代码生成、反射、java资源加载和本地代码(JNI)的第三方库。我提取并记下了一些实用的建议，这些建议应该普遍适用于其他应用程序:</p><h1 id="7f21" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">数据类别</h1><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="c5b6" class="kr jg hh kn b fi ks kt l ku kv">public class User {<br/>  String name;<br/>  int age;<br/>  ...<br/>}</span></pre><p id="280b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大概每个app都有某种数据类(也叫DMO，models等。取决于上下文以及它们在应用程序架构中的位置)。数据对象通常会在某个时候被加载或保存(序列化)到其他介质中，比如网络(HTTP请求)、数据库(通过ORM)、磁盘上的JSON文件或Firebase数据存储中。</p><p id="9606" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">许多简化序列化和反序列化这些字段的工具都依赖于反射。GSON、Retrofit、Firebase——它们都检查数据类中的字段名，并将它们转换成另一种表示形式(例如:<code class="du kw kx ky kn b">{“name”: “Sue”, “age”: 28}</code>),用于传输或存储。当他们将数据读入Java对象时，也会发生同样的事情——他们看到一个键值对<code class="du kw kx ky kn b">“name”:”John”</code>,并试图通过查找一个<code class="du kw kx ky kn b">String name </code>字段将其应用到Java对象。</p><p id="33f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论</strong>:我们不能让ProGuard重命名或删除这些数据类上的任何字段，因为它们必须匹配序列化格式。在整个类上添加一个<code class="du kw kx ky kn b">@Keep</code>注释或者在所有模型上添加一个通配符规则是一个稳妥的选择:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="9c47" class="kr jg hh kn b fi ks kt l ku kv">-keep class io.plaidapp.data.api.dribbble.model.** { *; }</span></pre><blockquote class="kz la lb"><p id="1d7f" class="ie if lc ig b ih ii ij ik il im in io ld iq ir is le iu iv iw lf iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh">警告</em> </strong> <em class="hh">:如果你的app易受此问题影响，测试时可能会出错。例如，如果您将一个对象序列化为JSON，并在没有适当的keep规则的情况下将其保存到您的应用程序版本N中的磁盘，则保存的数据可能如下所示:</em> <code class="du kw kx ky kn b"><em class="hh">{“a”: “Sue”, “b”: 28}</em></code> <em class="hh">。因为ProGuard将您的字段重命名为</em> <code class="du kw kx ky kn b"><em class="hh">a</em></code> <em class="hh">和</em> <code class="du kw kx ky kn b"><em class="hh">b</em></code> <em class="hh">，一切似乎都正常，数据将被正确保存和加载。</em></p><p id="31ea" class="ie if lc ig b ih ii ij ik il im in io ld iq ir is le iu iv iw lf iy iz ja jb ha bi translated"><em class="hh">然而，当你再次构建你的应用程序并发布版本</em> N+1 <em class="hh">时，ProGuard可能会决定将你的字段重命名为不同的名称，比如</em> <code class="du kw kx ky kn b"><em class="hh">c</em></code> <em class="hh">和</em> <code class="du kw kx ky kn b"><em class="hh">d</em></code> <em class="hh">。因此，先前保存的数据将无法加载。</em></p><p id="e011" class="ie if lc ig b ih ii ij ik il im in io ld iq ir is le iu iv iw lf iy iz ja jb ha bi translated"><em class="hh">你</em> <strong class="ig hi"> <em class="hh">必须</em> </strong> <em class="hh">首先保证你有正当的守规。</em></p></blockquote><h1 id="61ab" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">从本机调用Java代码(JNI)</h1><p id="34e4" class="pw-post-body-paragraph ie if hh ig b ih kd ij ik il ke in io ip kf ir is it kg iv iw ix kh iz ja jb ha bi translated">Android的<a class="ae jc" href="https://developer.android.com/studio/build/shrink-code.html#shrink-code" rel="noopener ugc nofollow" target="_blank">默认ProGuard文件</a>(你应该总是包含它们，它们有一些真正有用的规则)已经包含了一个用于在本机端<em class="lc">实现</em>(<code class="du kw kx ky kn b">-keepclasseswithmembernames class * { native &lt;methods&gt;; }</code>)的方法的规则。不幸的是，没有一种万能的方法来保持代码在相反的方向被调用:从JNI到Java。</p><p id="b784" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用JNI，完全有可能从C/C++代码中构造一个JVM对象或在JVM句柄上找到并调用一个方法，事实上，<a class="ae jc" href="https://github.com/Uncodin/bypass/blob/master/platform/android/library/jni/bypass.cpp#L61" rel="noopener ugc nofollow" target="_blank">Plaid中使用的一个库就是这么做的</a>。</p><p id="19e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论</strong>:因为ProGuard只能检查Java类，它不会知道任何发生在本机代码中的用法。我们必须通过一个<code class="du kw kx ky kn b">@Keep</code>注释或者<code class="du kw kx ky kn b">-keep</code>规则明确地保留类和成员的这种用法。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="fefe" class="kr jg hh kn b fi ks kt l ku kv">-keep, includedescriptorclasses <br/>            class in.uncod.android.bypass.Document { *; }<br/>-keep, includedescriptorclasses <br/>            class in.uncod.android.bypass.Element { *; }</span></pre><h1 id="38a2" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">从JAR/APK打开资源</h1><p id="fc3d" class="pw-post-body-paragraph ie if hh ig b ih kd ij ik il ke in io ip kf ir is it kg iv iw ix kh iz ja jb ha bi translated">Android有自己的资源和资产系统，这对于ProGuard来说应该不是问题。然而，在普通Java中，有另一种直接从JAR文件加载资源的<a class="ae jc" href="https://docs.oracle.com/javase/8/docs/technotes/guides/lang/resources.html" rel="noopener ugc nofollow" target="_blank">机制，一些第三方库可能会使用它，即使是在Android应用程序中编译时(在这种情况下，他们会尝试从APK加载)。</a></p><p id="c263" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">问题是，通常这些类会在它们自己的包名下寻找资源(这转化为JAR或APK中的文件路径)。ProGuard可以在混淆时重命名包名，所以在编译后，在最终的APK中，类和它的资源文件可能不再在同一个包中。</p><p id="bc4b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了以这种方式识别加载资源，您可以在您的代码和您所依赖的任何第三方库中寻找对<code class="du kw kx ky kn b">Class.getResourceAsStream / getResource</code>和<code class="du kw kx ky kn b">ClassLoader.getResourceAsStream / getResource</code>的调用。</p><p id="af76" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论</strong>:我们应该保留任何使用这种机制从APK加载资源的类的名称。</p><p id="e0d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Plaid中，实际上有两个——一个在<em class="lc"> OkHttp </em>库中，一个在<em class="lc"> Jsoup </em>中:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="cd43" class="kr jg hh kn b fi ks kt l ku kv">-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase<br/>-keepnames class org.jsoup.nodes.Entities</span></pre><h1 id="482a" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">如何为第三方库制定规则</h1><p id="87d0" class="pw-post-body-paragraph ie if hh ig b ih kd ij ik il ke in io ip kf ir is it kg iv iw ix kh iz ja jb ha bi translated">在理想的情况下，您使用的每个依赖项都会在AAR中提供它们所需的ProGuard规则。有时他们会忘记这样做，或者只发布jar，这些jar没有标准化的方式来提供ProGuard规则。</p><p id="76ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，在你开始调试你的应用程序和制定规则之前，记得查看文档。一些库的作者提供了推荐的ProGuard规则(比如在Plaid中使用的reform ),这可以为您节省大量的时间和精力。不幸的是，许多库并没有这样做(比如本文中提到的Jsoup和Bypass)。还要注意，在某些情况下，库提供的配置只能在禁用优化的情况下工作，所以如果您打开了优化，您可能会处于未知的领域。</p><p id="7aff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么在图书馆不供应的情况下，如何想出规则呢？<br/>我只能给你一些指点:</p><ol class=""><li id="495e" class="lg lh hh ig b ih ii il im ip li it lj ix lk jb ll lm ln lo bi translated">读取构建输出和logcat！</li><li id="d9a5" class="lg lh hh ig b ih lp il lq ip lr it ls ix lt jb ll lm ln lo bi translated">构建警告会告诉你添加哪些<code class="du kw kx ky kn b">-dontwarn</code>规则</li><li id="273a" class="lg lh hh ig b ih lp il lq ip lr it ls ix lt jb ll lm ln lo bi translated"><code class="du kw kx ky kn b">ClassNotFoundException</code>、<code class="du kw kx ky kn b">MethodNotFoundException</code>和<code class="du kw kx ky kn b">FieldNotFoundException</code>会告诉你要添加哪些<code class="du kw kx ky kn b">-keep</code>规则</li></ol><blockquote class="kz la lb"><p id="0180" class="ie if lc ig b ih ii ij ik il im in io ld iq ir is le iu iv iw lf iy iz ja jb ha bi translated">当你的应用在启用ProGuard的情况下崩溃时，你应该感到高兴——你将有地方开始你的调查:)</p><p id="abc5" class="ie if lc ig b ih ii ij ik il im in io ld iq ir is le iu iv iw lf iy iz ja jb ha bi translated">最糟糕的一类问题是当你的应用程序工作时，例如，不显示屏幕或不从网络加载数据。</p><p id="656f" class="ie if lc ig b ih ii ij ik il im in io ld iq ir is le iu iv iw lf iy iz ja jb ha bi translated">这就是你需要考虑我在本文中描述的一些场景并动手的地方，甚至是深入第三方代码并理解它为什么可能失败，比如当它使用反射、内省或JNI时。</p></blockquote><h1 id="bb40" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">调试和堆栈跟踪</h1><p id="59ef" class="pw-post-body-paragraph ie if hh ig b ih kd ij ik il ke in io ip kf ir is it kg iv iw ix kh iz ja jb ha bi translated">默认情况下，ProGuard将删除许多程序执行不需要的代码属性和隐藏的元数据。其中一些对开发人员非常有用，例如，您可能希望保留源文件名和堆栈跟踪的行号，以便于调试:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="19fc" class="kr jg hh kn b fi ks kt l ku kv">-keepattributes SourceFile, LineNumberTable</span></pre><blockquote class="kz la lb"><p id="8daf" class="ie if lc ig b ih ii ij ik il im in io ld iq ir is le iu iv iw lf iy iz ja jb ha bi translated">您还应该记得<a class="ae jc" href="https://developer.android.com/studio/build/shrink-code.html#decode-stack-trace" rel="noopener ugc nofollow" target="_blank">保存您构建发布版本时生成的ProGuard映射文件，并将它们上传到Play </a>以从您的用户遇到的任何崩溃中获得反混淆的堆栈跟踪。</p></blockquote><p id="ed61" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您打算在应用程序的受保护版本中附加一个调试器来逐句通过方法代码，您还应该保留以下属性来保留一些关于局部变量的调试信息(您只需要在您的<code class="du kw kx ky kn b">debug</code>版本类型中使用这一行):</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="72d7" class="kr jg hh kn b fi ks kt l ku kv">-keepattributes LocalVariableTable, LocalVariableTypeTable</span></pre><h1 id="10cb" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">缩小的调试版本类型</h1><p id="4e60" class="pw-post-body-paragraph ie if hh ig b ih kd ij ik il ke in io ip kf ir is it kg iv iw ix kh iz ja jb ha bi translated">默认的构建类型被配置为<em class="lc"> debug </em>不运行ProGuard。这是有意义的，因为我们希望在开发时快速迭代和编译，但仍然希望使用ProGuard的发布版本尽可能小并优化。</p><p id="4837" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，为了全面测试和调试任何ProGuard问题，最好建立一个单独的小型调试版本，如下所示:</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="216d" class="kr jg hh kn b fi ks kt l ku kv">buildTypes {<br/>  debugMini {<br/>    initWith debug<br/>    minifyEnabled true<br/>    shrinkResources true<br/>    proguardFiles getDefaultProguardFile('proguard-android.txt'), <br/>                  'proguard-rules.pro'<br/>    matchingFallbacks = ['debug']<br/>  }<br/>}</span></pre><p id="c98e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了这种构建类型，您将能够<a class="ae jc" href="https://developer.android.com/studio/debug/index.html" rel="noopener ugc nofollow" target="_blank">连接调试器</a>，<a class="ae jc" href="https://developer.android.com/training/testing/ui-testing/espresso-testing.html" rel="noopener ugc nofollow" target="_blank">运行UI测试</a>(也在CI服务器上)或者<a class="ae jc" href="https://developer.android.com/studio/test/monkey.html" rel="noopener ugc nofollow" target="_blank">猴子测试</a>您的应用程序，在尽可能接近您的发布版本的构建上寻找可能的问题。</p><p id="91a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论</strong>:当你使用ProGuard时，你应该对你的发布版本进行全面的质量保证，要么进行端到端测试，要么手动检查你的应用程序的所有屏幕，看看是否有任何东西丢失或崩溃。</p><h1 id="3cb2" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">运行时批注，类型自省</h1><p id="8a1e" class="pw-post-body-paragraph ie if hh ig b ih kd ij ik il ke in io ip kf ir is it kg iv iw ix kh iz ja jb ha bi translated">默认情况下，ProGuard会从代码中移除所有注释，甚至一些多余的类型信息。对于一些库来说，这不是问题——那些在编译时处理注释和生成代码的库(比如<em class="lc"> Dagger 2 </em>或<em class="lc"> Glide </em>等等)在程序运行时可能不需要这些注释。</p><p id="1001" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还有另一类工具在运行时实际检查注释或查看参数和异常的类型信息。例如，通过使用一个<code class="du kw kx ky kn b">Proxy</code>对象拦截您的方法调用，然后查看注释和类型信息来决定在HTTP请求中放入或读取什么内容，从而实现这一点。</p><p id="ae75" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论</strong>:与编译时相反，有时需要保留在运行时读取的类型信息和注释。您可以查看ProGuard手册中的<a class="ae jc" href="https://www.guardsquare.com/en/proguard/manual/attributes" rel="noopener ugc nofollow" target="_blank">属性列表。</a></p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="6c2a" class="kr jg hh kn b fi ks kt l ku kv">-keepattributes *Annotation*, Signature, Exception</span></pre><blockquote class="kz la lb"><p id="b913" class="ie if lc ig b ih ii ij ik il im in io ld iq ir is le iu iv iw lf iy iz ja jb ha bi translated">如果您使用的是默认的Android ProGuard配置文件(<code class="du kw kx ky kn b"><em class="hh">getDefaultProguardFile('proguard-android.txt')</em></code>)，那么前两个选项——注释和签名——是为您指定的。如果你没有使用默认设置，你必须确保自己添加它们(如果你知道你的应用程序需要它们，复制它们也无妨)。</p></blockquote><h1 id="2fda" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">将所有内容移动到默认包中</h1><p id="5eb5" class="pw-post-body-paragraph ie if hh ig b ih kd ij ik il ke in io ip kf ir is it kg iv iw ix kh iz ja jb ha bi translated">ProGuard配置中默认不添加<code class="du kw kx ky kn b"><a class="ae jc" href="https://www.guardsquare.com/en/proguard/manual/usage#repackageclasses" rel="noopener ugc nofollow" target="_blank">-repackageclasses</a></code>选项。如果您已经对代码进行了模糊处理，并且已经修复了任何与适当的keep规则有关的问题，那么您可以添加这个选项来进一步减小DEX的大小。它的工作方式是将所有类移动到默认(根)包中，实质上释放了由类似于"<em class="lc">com . example . myapp . some package</em>"的字符串所占用的空间。</p><pre class="ki kj kk kl fd km kn ko kp aw kq bi"><span id="f08c" class="kr jg hh kn b fi ks kt l ku kv">-repackageclasses</span></pre><h1 id="fc54" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">何时使用<code class="du kw kx ky kn b">@Keep</code>和<code class="du kw kx ky kn b">-keep</code></h1><p id="b7b5" class="pw-post-body-paragraph ie if hh ig b ih kd ij ik il ke in io ip kf ir is it kg iv iw ix kh iz ja jb ha bi translated"><code class="du kw kx ky kn b">@Keep</code>支持实际上是作为默认Android ProGuard规则文件中的一堆<code class="du kw kx ky kn b">-keep</code>规则实现的，所以它们本质上是等价的。指定<code class="du kw kx ky kn b">-keep</code>规则更加灵活，因为它提供了通配符，您还可以使用不同的变量来做稍微不同的事情(<code class="du kw kx ky kn b">-keepnames</code>、<code class="du kw kx ky kn b">-keepclasseswithmembers</code>、<a class="ae jc" href="https://www.guardsquare.com/en/proguard/manual/usage#keepoverview" rel="noopener ugc nofollow" target="_blank">和更多的</a>)。</p><p id="b3e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，每当需要一个简单的“保留这个类”或“保留这个方法”规则时，我实际上更喜欢在类或成员上添加一个<code class="du kw kx ky kn b">@Keep</code>注释的简单性，因为它接近代码，就像文档一样。</p><p id="7c38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果在我之后的某个开发人员想要重构代码，他们会立即知道标有<code class="du kw kx ky kn b">@Keep</code>的类/成员需要特殊处理，而不必记得查阅ProGuard配置并冒着破坏某些东西的风险。此外，IDE中的大多数代码重构应该自动保留类的<code class="du kw kx ky kn b">@Keep</code>注释。</p><h1 id="012e" class="jf jg hh bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">格子统计</h1><p id="d14d" class="pw-post-body-paragraph ie if hh ig b ih kd ij ik il ke in io ip kf ir is it kg iv iw ix kh iz ja jb ha bi translated">这里有一些来自Plaid的统计数据，显示了我使用ProGuard删除了多少代码。对于依赖关系更多、索引更大的更复杂的应用程序，节省的成本可能更大。</p><figure class="ki kj kk kl fd lv er es paragraph-image"><div class="er es lu"><img src="../Images/ef9797c3d8b7781adcc3d5cf12537e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*SMf2Q7j5sL_iu3bcsiLBYw.png"/></div></figure></div></div>    
</body>
</html>