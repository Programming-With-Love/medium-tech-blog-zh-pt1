<html>
<head>
<title>Android Jetpack Compose Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android Jetpack Compose解释</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/android-jetpack-compose-explained-a9539715ca36?source=collection_archive---------5-----------------------#2021-05-17">https://medium.com/quick-code/android-jetpack-compose-explained-a9539715ca36?source=collection_archive---------5-----------------------#2021-05-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/3b71350a01deb94c3a161ad0286ac734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*De6NJBt2hXywgL9WBaMmnQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="http://unsplash.com/&amp;utm_source=slidescarnival" rel="noopener ugc nofollow" target="_blank">http://unsplash.com/&amp;utm_source=slidescarnival</a></figcaption></figure><p id="cb9b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">android应用程序中关于视图更改的业务逻辑一直都是关于手动更改有状态视图。这意味着随着应用程序的变化，UI层次结构会手动更新以显示当前数据。通常称为更改小部件的内部状态。</p><p id="4fe9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">进一步来说，<a class="ae it" href="https://blog.mindorks.com/state-management-in-jetpack-compose" rel="noopener ugc nofollow" target="_blank"> Singh的文章</a>将<strong class="iw hi">状态</strong>解释为一个对象，该对象包含映射到一个或多个小部件的某些数据。使用state对象的值，我们可以更新小部件中显示的数据。状态的值可以在运行时改变，这将帮助我们用更新的数据更新小部件。</p><p id="0828" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是一个将TextView小部件(状态小部件)手动更改为不同背景的示例。</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="230f" class="kb kc hh jx b fi kd ke l kf kg">class MainActivity : AppCompatActivity() {<br/>   lateinit var textView: TextView<br/>   override fun onCreate(savedInstanceState: Bundle?) {<br/>      super.onCreate(savedInstanceState)<br/>      setContentView(R.layout.activity_main)<br/>      title = "KotlinApp"<br/>      textView = findViewById(R.id.textView)<br/><strong class="jx hi">      textView.setOnClickListener {<br/></strong>         if (Build.VERSION.SDK_INT &lt; 23) {<br/><strong class="jx hi">            textView.setTextAppearance(applicationContext,     R.style.boldText)<br/>         }<br/></strong>         else {<br/><strong class="jx hi">            textView.setTextAppearance(R.style.boldText)<br/></strong>         }<br/><strong class="jx hi">      textView.setBackgroundResource(R.color.highlightedTextViewColor)<br/></strong>      }<br/><strong class="jx hi">   }</strong><br/>}</span></pre><p id="0c08" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们现在看到了一种反应式编程的最新趋势，它解决了在Android应用程序中手动更改有状态视图的特殊挑战。此外，解释为什么从传统的系统设计架构如<a class="ae it" href="https://www.geeksforgeeks.org/mvc-model-view-controller-architecture-pattern-in-android-with-example/" rel="noopener ugc nofollow" target="_blank"> MVC </a> / <a class="ae it" href="https://www.raywenderlich.com/7026-getting-started-with-mvp-model-view-presenter-on-android" rel="noopener ugc nofollow" target="_blank"> MVP </a>转变为更具反应性的<a class="ae it" href="https://blog.mindorks.com/mvvm-architecture-android-tutorial-for-beginners-step-by-step-guide" rel="noopener ugc nofollow" target="_blank"> MVVM </a>和<a class="ae it" href="https://www.raywenderlich.com/817602-mvi-architecture-for-android-tutorial-getting-started" rel="noopener ugc nofollow" target="_blank"> MVI </a>方法。</p><p id="630a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Jetpack Compose简介… Jetpack Compose是作为一种改进Android工程师设计用户界面的方式而开发的，使他们更容易、更快速地编写和运行。</p><p id="99a4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> PS: </strong> Jetpack Compose不是Jetpack——Jetpack附带了几个独立的库和资源，可以帮助Android开发人员设计应用程序，并处理它使用的数据和显示。</p><h1 id="b1db" class="kh kc hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">为什么选择Jetpack Compose？</h1><p id="4d89" class="pw-post-body-paragraph iu iv hh iw b ix le iz ja jb lf jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">一个<a class="ae it" href="https://developer.android.com/jetpack/compose/state#composition-and-recomposition" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi">组合</strong> </a>是一个树形结构的用户界面组合集。运行composables会产生一个组合，它定义了用户界面。因此，当响应状态变化而改变的组件被重组时，这个事件就是动作<strong class="iw hi">重组</strong>。</p><p id="ffc2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，当一个可组合的函数显示一个按钮，并且每次单击该按钮时，调用者都会更新单击次数的值。<br/>意思是，每次点击事件发生时，text函数被重用来显示带有更新值的新文本。</p><p id="1561" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从长远来看，重新组合整个UI树在计算上可能是昂贵的，这会使用计算能力和电池寿命。因此，Jetpack Compose使用智能重组树来解决这个问题。一个可组合的函数可以用于多个状态视图。</p><h1 id="7dfd" class="kh kc hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">使用Jetpack Compose的3个理由</h1><ol class=""><li id="a963" class="lj lk hh iw b ix le jb lf jf ll jj lm jn ln jr lo lp lq lr bi translated">单一解决方案的冗余选项更少。创建整个布局的代码更少</li><li id="fe16" class="lj lk hh iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated">UI模型中所有权和事件流的清晰状态。</li><li id="58bb" class="lj lk hh iw b ix ls jb lt jf lu jj lv jn lw jr lo lp lq lr bi translated">很容易更新(都是Kotlin)也很容易测试。</li></ol><p id="c12a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里有一些简单的步骤让你开始。您还可以在这里找到其他使用Jetpack Compose <a class="ae it" href="https://github.com/android/compose-samples" rel="noopener ugc nofollow" target="_blank">的示例应用程序。</a></p><h1 id="ec84" class="kh kc hh bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">入门</strong></h1><ul class=""><li id="0867" class="lj lk hh iw b ix le jb lf jf ll jj lm jn ln jr lx lp lq lr bi translated">安装<a class="ae it" href="https://developer.android.com/studio/preview" rel="noopener ugc nofollow" target="_blank"> Android Studio金丝雀</a> -金丝雀版本获得所有最新版本(包括稳定版)。</li><li id="9a1f" class="lj lk hh iw b ix ls jb lt jf lu jj lv jn lw jr lx lp lq lr bi translated">打开<strong class="iw hi"> app/build.gradle </strong>文件，并在每个块中添加如下代码行，如图所示。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="b2dd" class="kb kc hh jx b fi kd ke l kf kg"><strong class="jx hi">buildFeatures {</strong></span><span id="0f82" class="kb kc hh jx b fi ly ke l kf kg"><strong class="jx hi">    compose true</strong></span><span id="40a8" class="kb kc hh jx b fi ly ke l kf kg"><strong class="jx hi">}</strong></span><span id="a7ab" class="kb kc hh jx b fi ly ke l kf kg"><strong class="jx hi">composeOptions {</strong></span><span id="9bcd" class="kb kc hh jx b fi ly ke l kf kg"><strong class="jx hi">     kotlinCompilerExtensionVersion "${compose_version}"</strong></span><span id="25d0" class="kb kc hh jx b fi ly ke l kf kg"><strong class="jx hi">}</strong></span><span id="8db7" class="kb kc hh jx b fi ly ke l kf kg"><strong class="jx hi">dependencies {</strong></span><span id="84f9" class="kb kc hh jx b fi ly ke l kf kg"><strong class="jx hi">implementation "androidx.compose.ui:ui:$compose_version"</strong></span><span id="e4ca" class="kb kc hh jx b fi ly ke l kf kg"><strong class="jx hi">implementation "androidx.activity:activity-compose:1.3.0-alpha05"</strong></span><span id="451c" class="kb kc hh jx b fi ly ke l kf kg"><strong class="jx hi">implementation "androidx.compose.material:material:$compose_version"</strong></span><span id="182e" class="kb kc hh jx b fi ly ke l kf kg"><strong class="jx hi">implementation "androidx.compose.ui:ui-tooling:$compose_version"</strong></span><span id="5469" class="kb kc hh jx b fi ly ke l kf kg"><strong class="jx hi">}</strong></span></pre><ul class=""><li id="3daa" class="lj lk hh iw b ix iy jb jc jf lz jj ma jn mb jr lx lp lq lr bi translated">替换<strong class="iw hi"> MainActivity.kt </strong>中的现有调用<em class="mc"> setContentView() </em>，以引用可组合函数。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="3488" class="kb kc hh jx b fi kd ke l kf kg"><strong class="jx hi">setContent {<br/>    MaterialTheme {<br/>     Greeting(name = "compose")<br/>    }<br/>}</strong></span></pre><ul class=""><li id="57cb" class="lj lk hh iw b ix iy jb jc jf lz jj ma jn mb jr lx lp lq lr bi translated">最后，对特性名称应用@Composable注释，使其成为可组合的。</li></ul><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="ebfd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">关于设置过程的更详细的解释，请使用Google的官方文档。</p><p id="772e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">祝您探索Jetpack Compose时一切顺利！</p></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><p id="63f6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">谢谢你<a class="mm mn ge" href="https://medium.com/u/69202beeb59c?source=post_page-----a9539715ca36--------------------------------" rel="noopener" target="_blank">大卫·奥达里</a>为我们提供的所有帮助。</p></div></div>    
</body>
</html>