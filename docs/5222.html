<html>
<head>
<title>The Problem with SQL Calling PL/SQL Calling SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL调用PL/SQL调用SQL的问题</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/the-problem-with-sql-calling-pl-sql-calling-sql-de9ddd92d188?source=collection_archive---------0-----------------------#2015-08-04">https://medium.com/oracledevs/the-problem-with-sql-calling-pl-sql-calling-sql-de9ddd92d188?source=collection_archive---------0-----------------------#2015-08-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/73a78b93c95dbfbe21840e1f95b4fe73.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/0*e_oVZEjoPKNVeUCB.png"/></div></figure><p id="efde" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在<a class="ae jj" href="https://blogs.oracle.com/sql/entry/optimizing_the_pl_sql_challenge6" rel="noopener ugc nofollow" target="_blank">之前的帖子</a>中，我们重构了一个关于<a class="ae jj" href="https://plsqlchallenge.oracle.com/" rel="noopener ugc nofollow" target="_blank"> PL/SQL挑战</a>的SQL查询，因此它不再调用PL/SQL函数。这通过消除上下文切换提高了性能。</p><p id="c3e7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">查询执行时间减少了10秒。你们中观察力敏锐的人会注意到该语句处理了60，000多行。每行节省不到200微秒。</p><p id="4f14" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于单个行来说，这是一个很小的开销。此时你可能会说:</p><p id="8716" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">“大不了。我在top-N查询中调用函数。最坏的情况是返回10行，运行时间增加2毫秒。开销微不足道。我更喜欢将我的SQL查询保存在PL/SQL函数中，因为这有助于代码重用”。</p><p id="3751" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们暂时把表演放在一边。如果有常见的查询，为什么不把它们放在PL/SQL中，并在select语句中调用这些函数呢？如果您需要更改它们，这使得将来的维护更加容易。</p><p id="a3c5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因为对于调用PL/SQL的SQL有一个重要的警告。你可能会得到意想不到的结果。</p><p id="4826" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们看一个例子。您的应用程序有一个典型的用户表，其中有一个用户:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="5898" class="jt ju hh jp b fi jv jw l jx jy">create table app_users (<br/>  user_id     integer not null primary key,<br/>  given_name  varchar2(100) not null,<br/>  family_name varchar2(100) not null<br/>);</span><span id="5946" class="jt ju hh jp b fi jz jw l jx jy">insert into app_users values (1, 'Chris', 'Saxon');</span><span id="5036" class="jt ju hh jp b fi jz jw l jx jy">commit;</span></pre><p id="d37a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">您已经分别存储了名称的各个组成部分。为了确保您在构建函数的应用程序中一致地显示全名，请使用get_full_name。这将返回基于user_id的格式化名称。执行此操作的查询是:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="bcc9" class="jt ju hh jp b fi jv jw l jx jy">select given_name || ' ' || family_name<br/>from   app_users usr<br/>where  usr.user_id = :user_id;</span></pre><p id="b136" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">到目前为止一切顺利。但是，如果我们从SQL调用它，就会出现问题。</p><p id="af0a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">以下查询应为name_fn和name_sql返回相同的值:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="427b" class="jt ju hh jp b fi jv jw l jx jy">select get_full_name ( user_id ) name_fn, <br/>       given_name || ' ' || family_name name_sql<br/>from   app_users;</span></pre><p id="c4bf" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然而，当我执行它时，我看到以下内容:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="fa05" class="jt ju hh jp b fi jv jw l jx jy">NAME_FN       NAME_SQL<br/>------------- -----------<br/>Harvey Saxon  Chris Saxon</span></pre><p id="6fac" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">它们返回了不同的值！！这是怎么发生的？！</p><p id="ff10" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我没有做任何事情来修改函数中的结果。这是调用在SQL语句中执行查询的PL/SQL函数的预期结果。您可以(也将会)看到这种影响在您的环境中发生。</p><p id="af1f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为什么？</p><p id="fe33" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">原因在于Oracle的读取一致性模型。每个SQL语句在开始执行时都会获得数据的读取一致性视图。函数中的查询开始于主语句之后的某个时间点。这意味着函数内部的语句可以拥有与调用它的SQL查询不同的数据视图。它可以看到从父查询开始到它自己开始之间提交的更改。</p><p id="469e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这种情况下，在执行上述查询时，我在一个单独的会话中发出了以下命令:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="2f89" class="jt ju hh jp b fi jv jw l jx jy">update app_users<br/>set    given_name = 'Harvey'<br/>where  user_id = 1;<br/><br/>commit;</span></pre><p id="18b5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了确保主查询和函数返回不同的结果，我不得不稍微作弊。我不够快，无法在一个会话中运行查询，在另一个会话中运行更新。所以在查询之前，我还在get_full_name中放置了一个十秒钟的睡眠。这确保了在函数内部的查询开始之前，我有足够的时间提交更改。</p><p id="5460" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这是一个关键点。如果调用PL/SQL的查询执行得很快，就很难重现上面的异常。因此，你不太可能在测试中发现这种错误。这导致在生产中“随机”出现错误报告，而您无法重现。这些错误的影响可能介于轻微的烦恼和彻底的灾难之间。如果您不熟悉读取一致性模型，跟踪和解决它们可能会很困难。</p><p id="7744" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">幸运的是，解决方案很简单:</p><p id="5761" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">复制PL/SQL中的所有SQL，并将其直接粘贴到调用语句中。</p><p id="2bec" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这是否意味着没有办法让可重用的查询既正确又高效？</p><p id="4028" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当然不是！</p><p id="3861" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">有更好的方法。有风景。</p><p id="2647" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，您可以创建以下视图:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="f822" class="jt ju hh jp b fi jv jw l jx jy">create or replace view app_users_formatted as<br/>  select user_id, given_name || ' ' || family_name full_name<br/>  from   app_users;</span></pre><p id="b0a3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">用它代替原始查询中的PL/SQL，我们得到:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="a9ca" class="jt ju hh jp b fi jv jw l jx jy">select (select full_name <br/>        from   app_users_formatted apuf<br/>        where  apus.user_id = apuf.user_id<br/>       ) name_view, <br/>       given_name || ' ' || family_name name_sql<br/>from   app_users apus;</span></pre><p id="2fd2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Name_sql和Name_view现在是同一个语句的一部分。这意味着它们在同一时间点被一致读取。无论查询执行多长时间，都将返回相同的值。</p><p id="f2ba" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当然，对于这种简单的格式问题，您可以创建一个<a class="ae jj" href="https://youtu.be/bEgUVAahlCs" rel="noopener ugc nofollow" target="_blank">虚拟列</a>，得到您想要的结果:</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="2c26" class="jt ju hh jp b fi jv jw l jx jy">alter table app_users add (<br/>  full_name as (given_name || ' ' || family_name)<br/>);</span></pre><p id="84c4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">结论</strong></p><p id="fb67" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">从SQL调用PL/SQL时，需要注意两件事:</p><ul class=""><li id="e2f5" class="ka kb hh in b io ip is it iw kc ja kd je ke ji kf kg kh ki bi translated">上下文切换的性能开销</li><li id="b40a" class="ka kb hh in b io kj is kk iw kl ja km je kn ji kf kg kh ki bi translated">如果PL/SQL本身调用SQL，结果可能不正确</li></ul><p id="531f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">您可以通过提取PL/SQL的SQL查询并将其直接放在调用语句中来避免这两种情况。如果您取出的查询是您想要重用的查询，请将其保存在视图中。然后在SQL中引用视图而不是PL/SQL函数。</p><p id="504c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用视图代替PL/SQL还使优化器能够将SQL包含在<a class="ae jj" href="https://blogs.oracle.com/optimizer/entry/optimizer_transformations_view_merging_part_1" rel="noopener ugc nofollow" target="_blank">查询转换</a>中。这可以产生更有效的执行计划。新计划带来的性能提升甚至比上下文切换节省的时间还要多。</p><p id="74f4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">代码清单</strong></p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="64ad" class="jt ju hh jp b fi jv jw l jx jy">-- note: requires execute privileges on dbms_lock.</span><span id="23e6" class="jt ju hh jp b fi jz jw l jx jy">create table app_users (<br/>  user_id     integer not null primary key,<br/>  given_name  varchar2(100) not null,<br/>  family_name varchar2(100) not null<br/>);</span><span id="041b" class="jt ju hh jp b fi jz jw l jx jy">insert into app_users values (1, 'Chris', 'Saxon');</span><span id="2091" class="jt ju hh jp b fi jz jw l jx jy">commit;  <br/><br/>create or replace function get_full_name ( user_id app_users.user_id%type )<br/>  return varchar2 as<br/>  full_name varchar2(200);<br/>begin<br/><br/>  dbms_lock.sleep(10);<br/><br/>  select given_name || ' ' || family_name<br/>  into   full_name<br/>  from   app_users usr<br/>  where  usr.user_id = get_full_name.user_id;<br/>  <br/>  return full_name;<br/>  <br/>end get_full_name; <br/>/ <br/><br/>-- in session 1:<br/>select get_full_name ( user_id ) name_fn, <br/>       given_name || ' ' || family_name name_sql<br/>from   app_users;<br/><br/>-- in session 2, while query is still executing in session 1:<br/>update app_users<br/>set    given_name = 'Harvey'<br/>where  user_id = 1;<br/><br/>commit;</span></pre></div><div class="ab cl ko kp go kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ha hb hc hd he"><p id="9944" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="kv">原载于2015年8月4日blogs.oracle.com</em><em class="kv">的</em> <a class="ae jj" href="https://blogs.oracle.com/sql/the-problem-with-sql-calling-plsql-calling-sql" rel="noopener ugc nofollow" target="_blank"> <em class="kv">。</em></a></p></div></div>    
</body>
</html>