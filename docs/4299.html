<html>
<head>
<title>Coroutines: Suspending State Machines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协程:挂起状态机</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/coroutines-suspending-state-machines-36b189f8aa60?source=collection_archive---------0-----------------------#2020-06-03">https://medium.com/google-developer-experts/coroutines-suspending-state-machines-36b189f8aa60?source=collection_archive---------0-----------------------#2020-06-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/01120075204005da3b24be9b2a73dffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9S-kvWmwFU0Q6213NP44g.jpeg"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Photo by <a class="ae hu" href="https://unsplash.com/@dewang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Dewang Gupta</a> on <a class="ae hu" href="https://unsplash.com/@dewang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="fc6c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">协程使我们的异步代码看起来是顺序的。协程帮助我们逃离回调地狱。协程将我们从复杂的反应链中拯救出来。</p><p id="7980" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一切都很好，但是你有没有想过在幕后发生了什么样的魔法？一段特定的代码实际上是如何在幕后异步执行操作的，同时又给我们一种一切都在按顺序进行的感觉？是魔法吗？(当然是，但在其他一些平行宇宙中)对我们<a class="ae hu" href="https://en.wikipedia.org/wiki/Muggle" rel="noopener ugc nofollow" target="_blank">麻瓜</a>来说，都是围绕着状态机，悬挂点，延续传球。</p><p id="fedd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果这是你第一次听到所有这些术语，那么不要担心，这篇文章将帮助你理解它们。我们会谈到<strong class="iw hy">暂停点，CPS(延续传球方式)，状态机</strong>。如果您已经知道这些术语，那么我希望您仍然喜欢阅读本文中提到的代码示例和各种概念。</p><p id="d69c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将首先看一个使用协程实现的小代码片段。然后，我们将尝试识别代码片段中的暂停点。然后，我们将看到代码如何通过使用暂停点提取各种状态来编译成状态机。最后，我们将了解一个作为状态机实现的<code class="du jt ju jv jw b">Continuation</code>是如何传递的，以实现一些神奇的东西。</p><h2 id="0c8e" class="jx jy hx bd jz ka kb kc kd ke kf kg kh jf ki kj kk jj kl km kn jn ko kp kq kr bi translated">问题陈述:</h2><p id="14e8" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr ha bi translated"><em class="js">我们需要用用户详细信息填充用户的个人资料屏幕。为此，我们需要进行两次API调用。我们首先调用的API是</em> <code class="du jt ju jv jw b"><em class="js">fetchUser()</em></code> <em class="js">，在我们得到</em> <code class="du jt ju jv jw b"><em class="js">User</em></code> <em class="js">之后，我们再调用另一个API来获取用户</em> <code class="du jt ju jv jw b"><em class="js">Profile</em></code> <em class="js">。使用我们所拥有的信息，我们继续填充UI，最后，我们从</em> <code class="du jt ju jv jw b"><em class="js">user</em></code> <em class="js">和</em> <code class="du jt ju jv jw b"><em class="js">profile</em></code> <em class="js">创建一个</em> <code class="du jt ju jv jw b"><em class="js">Account</em></code> <em class="js">对象来持久化。</em></p><p id="c583" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看API调用的伪代码:</p><figure class="ky kz la lb fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kx"><img src="../Images/2c0405b05cabad5201296ff460f26309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hGwe7EZX_J8P6HbtB-g0EQ.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Snippet 1: Fetching User and Profile using async coroutine builders</figcaption></figure><p id="544e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们在上面的代码片段中使用<code class="du jt ju jv jw b"><a class="ae hu" href="https://kotlinlang.org/docs/reference/coroutines/composing-suspending-functions.html#concurrent-using-async" rel="noopener ugc nofollow" target="_blank">async</a></code>协程构建器从API中获取<code class="du jt ju jv jw b">User</code>和<code class="du jt ju jv jw b">Profile</code>。<code class="du jt ju jv jw b">async</code>协程构建器返回一个<code class="du jt ju jv jw b">Deferred&lt;T&gt;</code>协程，这样我们就可以调用它的<code class="du jt ju jv jw b">.await()</code>以在稍后得到结果。</p><p id="097b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们的例子中，<code class="du jt ju jv jw b">fetchUser()</code>函数返回协程的一个<code class="du jt ju jv jw b">Deferred&lt;User&gt;</code>对象，该对象从API获取<code class="du jt ju jv jw b">User</code>。然后我们可以在<code class="du jt ju jv jw b">Deferred</code>协程上调用<code class="du jt ju jv jw b">await()</code>来获得<code class="du jt ju jv jw b">User</code>结果。</p><p id="d0ce" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">类似地，<code class="du jt ju jv jw b">fetchProfile(userId)</code>函数返回一个<code class="du jt ju jv jw b">Deferred&lt;Profile&gt;</code>，稍后我们可以调用<code class="du jt ju jv jw b">await()</code>来获取<code class="du jt ju jv jw b">User</code>的<code class="du jt ju jv jw b">Profile</code>。</p><p id="6068" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来让我们看看将“顺序”执行上述功能的协程:</p><figure class="ky kz la lb fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lc"><img src="../Images/55cb864554e3c45323a91a9a19f6b326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6wTcDScnkmRdxCM-mZhkA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Snippet 2: fetch User and Profile using coroutines</figcaption></figure><p id="6e62" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">第1行</em>:我们首先将loader设置为visible，表示我们正在获取数据。</p><p id="1eaf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">第2行:</em>然后我们调用，<code class="du jt ju jv jw b">fetchUser()</code>，它返回一个<code class="du jt ju jv jw b">Deferred&lt;User&gt;</code>，我们也立即对它调用<code class="du jt ju jv jw b">.await()</code>。<code class="du jt ju jv jw b"><strong class="iw hy">await()</strong></code>是一个<code class="du jt ju jv jw b">suspend</code>函数，因此，我们在IDE的左边看到一个暂停函数指示器，如代码片段2的第2行所示。我们的协程将在此时暂停，直到返回<code class="du jt ju jv jw b">User</code>。</p><p id="9188" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，这是我们代码中的第一个<strong class="iw hy">暂停点</strong>，在异步协程完成并返回结果(即<code class="du jt ju jv jw b">User</code>)后，协程的执行可以在这里暂停，然后恢复。</p><p id="6aab" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们的<code class="du jt ju jv jw b">user</code>从网络中被获取时，让我们谈论一些术语。</p><h2 id="19dd" class="jx jy hx bd jz ka kb kc kd ke kf kg kh jf ki kj kk jj kl km kn jn ko kp kq kr bi translated">暂停点和CPS(连续传球方式)</h2><p id="371c" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr ha bi translated">每个<code class="du jt ju jv jw b">suspend</code>函数都被编译器转换成一个<code class="du jt ju jv jw b">Continuation </code>对象。在上面的例子中，<code class="du jt ju jv jw b">.await()</code>暂停函数在编译时会被转换成带一个<code class="du jt ju jv jw b">Continuation</code>对象，即<code class="du jt ju jv jw b">.await(continuation)</code>。所以，我们保存所有的状态(比如局部变量等等。)并将其传递给<code class="du jt ju jv jw b">.await(continuation)</code>暂停函数。类似地，所有其他挂起函数和块也被转换为接受一个<code class="du jt ju jv jw b">Continuation</code>对象。</p><figure class="ky kz la lb fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ld"><img src="../Images/6b9fad109a86b239475c377fa1fa7468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8rS-P3qKmsmMEsOiWu54g.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">All suspend functions are compiled to take Continuation implementation</figcaption></figure><p id="9e72" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du jt ju jv jw b"><a class="ae hu" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">Continuation</strong></a></code>，顾名思义，封装了当前状态以及关于如何从特定暂停点继续的信息。</p><p id="1f63" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">代码中的一个<strong class="iw hy">暂停点</strong>就像一个检查点，在这里当前状态(像局部变量等。)可以被保存(在一个<code class="du jt ju jv jw b">Continuation</code>中)以便稍后从我们停止的地方继续。特定暂停点之后的所有内容(暂停点之后的代码行)也保存在<code class="du jt ju jv jw b">Continuation</code>对象中，并传递给编译后的<code class="du jt ju jv jw b">suspend</code>函数以供以后执行。使用<code class="du jt ju jv jw b">delay</code>、<code class="du jt ju jv jw b">yield</code>、<code class="du jt ju jv jw b">suspendCancellableCoroutine</code>等暂停功能创建暂停点。</p><p id="7a92" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，所有的挂起函数在转换时都会得到一个作为参数传递给它们的<code class="du jt ju jv jw b">Continuation</code>对象，以便稍后恢复执行。这就是所谓的<strong class="iw hy"> CPS(延续传球方式)</strong>。这种模式类似于传递回调并在工作完成时得到通知。不同之处在于，有了协程，这些“回调”(确切地说是延续)由编译器为我们处理，我们获得了顺序代码执行的外观和感觉。</p><p id="111a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在让我们从最后一个暂停点继续我们的代码片段😉，即第2行:</p><figure class="ky kz la lb fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lc"><img src="../Images/55cb864554e3c45323a91a9a19f6b326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6wTcDScnkmRdxCM-mZhkA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Snippet 2: fetch User and Profile using coroutines</figcaption></figure><p id="e20d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">第2行:</em>现在，当从API中获取<code class="du jt ju jv jw b">User</code>时，执行在我们的第一个暂停点之后立即恢复</p><p id="71a7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第3行:然后我们可以在UI上设置<code class="du jt ju jv jw b">user.name</code>。</p><p id="eb2c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">第4行:</em>接下来，我们有<code class="du jt ju jv jw b">user.id</code>可以用来从API中获取用户的<code class="du jt ju jv jw b">Profile</code>。因此，我们呼叫<code class="du jt ju jv jw b">fetchProfile(user.id)</code>，然后立即再次呼叫<code class="du jt ju jv jw b">.await()</code>。由于<code class="du jt ju jv jw b">.await()</code>暂停功能，这是我们到达第二个暂停点的时候。执行在这一点再次暂停，稍后当从API获取<code class="du jt ju jv jw b">Profile</code>时继续。</p><p id="42a1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">第5行到第8行:</em>一旦用户配置文件可用并从<code class="du jt ju jv jw b">.await()</code>函数返回，我们就可以在UI上设置所需的信息，并创建一个<code class="du jt ju jv jw b">Account</code>对象来持久化会话，最后，一旦完成，我们就隐藏我们的<code class="du jt ju jv jw b">progress</code>指示器。</p><h2 id="b490" class="jx jy hx bd jz ka kb kc kd ke kf kg kh jf ki kj kk jj kl km kn jn ko kp kq kr bi translated">暂停指向状态</h2><p id="a4a4" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr ha bi translated">现在我们已经确定了代码中的两个暂停点，让我们看看这些暂停点是如何使用标签转换成不同状态的。</p><figure class="ky kz la lb fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lc"><img src="../Images/8dd7455d846c73c5973dd82ef76bd0ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1jCKzsYkqfJPGnmMQJyAA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Snippet 3: Identifying states for the state machine</figcaption></figure><p id="a90a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">高于并包括一个暂停点的所有东西都被编译器转换成一个状态。在下一个暂停点或暂停函数结束之前，暂停点以下的所有内容都会转换为另一种状态。</p><p id="22b2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，在上面的代码片段3中，我们将有三种状态，即</p><ul class=""><li id="a8a7" class="le lf hx iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated"><strong class="iw hy"> L0 </strong>:直到第一个暂停点</li><li id="2182" class="le lf hx iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><strong class="iw hy"> L1 </strong>:直到第二个悬挂点</li><li id="44df" class="le lf hx iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><strong class="iw hy"> L2: </strong>直到结束</li></ul><h2 id="a953" class="jx jy hx bd jz ka kb kc kd ke kf kg kh jf ki kj kk jj kl km kn jn ko kp kq kr bi translated">生成状态机</h2><p id="0d3b" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr ha bi translated">现在，使用这三个状态作为标签，生成了一个<code class="du jt ju jv jw b"><a class="ae hu" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation/" rel="noopener ugc nofollow" target="_blank">Continuation</a></code>状态机，它可以从任何状态恢复执行。下面是<code class="du jt ju jv jw b">Continuation</code>界面的样子:</p><figure class="ky kz la lb fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/43b648c4d8f2af9382c404810c8b4b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fm74DO79qeqHdzWlHWi8eA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Continuation interface</figcaption></figure><p id="5af0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们看看编译器生成的<code class="du jt ju jv jw b">Continuation</code>状态机实现的伪代码:</p><figure class="ky kz la lb fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lt"><img src="../Images/ceab98aaabea6a548611c87a51762804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORHI9eISe1y1YAtCI6w6FA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Snippet 4: Continuation state-machine implementation pseudo-code</figcaption></figure><p id="880a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每个状态被生成为一个标签，当继续执行时，执行可以<code class="du jt ju jv jw b">goto</code>一个特定的标签。生成的<code class="du jt ju jv jw b">Continuation</code>状态机实现包含一个保存当前状态的字段，即<code class="du jt ju jv jw b">label,</code>，所有中间数据，即不同状态之间共享的局部变量，如<code class="du jt ju jv jw b">v1: User</code>、<code class="du jt ju jv jw b">v2: Profile</code>也存储为字段。</p><h2 id="2712" class="jx jy hx bd jz ka kb kc kd ke kf kg kh jf ki kj kk jj kl km kn jn ko kp kq kr bi translated">状态机的执行</h2><p id="d169" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr ha bi translated"><strong class="iw hy"> <em class="js">状态L0: </em> </strong>当协程启动后，<code class="du jt ju jv jw b">resumeWith()</code>被<code class="du jt ju jv jw b">label = 0</code>调用，我们进入<strong class="iw hy"> L0 </strong>状态如下图所示:</p><figure class="ky kz la lb fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lu"><img src="../Images/9639d756272862e0d92ed00c97612566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4116tixMpWo4vngINfzcDA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">State Machine Diagram for fetching User Profile</figcaption></figure><p id="071a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后我们做一些工作，比如显示一个进度指示器，并在调用<code class="du jt ju jv jw b">.await()</code>之前将<code class="du jt ju jv jw b">label</code>设置为<code class="du jt ju jv jw b">1</code>，这将挂起协程。当一个协同程序被挂起时，<code class="du jt ju jv jw b">.await()</code>函数在此时返回名为<code class="du jt ju jv jw b">COROUTINE_SUSPENDED.</code>的结果，我们将这个状态机传递给<code class="du jt ju jv jw b">.await(continuation)</code>函数，以便能够稍后从我们停止的地方恢复状态，并且协同程序进入<code class="du jt ju jv jw b">SUSPENDED</code>状态。</p><p id="c978" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> <em class="js">状态L1: </em> </strong>一旦从API中获取了<code class="du jt ju jv jw b">User</code>，我们将在我们保存的<code class="du jt ju jv jw b">continuation</code>对象上调用<code class="du jt ju jv jw b">continuation.resumeWith(user), label=1</code>，并直接进入状态<strong class="iw hy"> L1。</strong>此时，我们已经获取了<code class="du jt ju jv jw b">User</code>，我们可以用它来填充UI等。然后，我们将<code class="du jt ju jv jw b">label</code>设置为<code class="du jt ju jv jw b">2</code>并暂停<code class="du jt ju jv jw b">profile.await(continuation)</code>上的执行，同时等待用户配置文件并再次传入<code class="du jt ju jv jw b">continuation</code>对象以便稍后恢复控制。</p><p id="c6c0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"> <em class="js">状态L2: </em> </strong>最后，当<code class="du jt ju jv jw b">Profile</code>被取出时，我们再次调用保存的<code class="du jt ju jv jw b">continuation</code>上的<code class="du jt ju jv jw b">continuation.resumeWith(profile), label=2</code>并到达状态<strong class="iw hy"> L2。</strong>至此，我们已经把<code class="du jt ju jv jw b">user</code>和<code class="du jt ju jv jw b">profile</code>都拿来了。然后我们可以使用<code class="du jt ju jv jw b">user</code>和<code class="du jt ju jv jw b">profile,</code>创建一个<code class="du jt ju jv jw b">Account</code>对象，设置UI上获取的数据，隐藏加载器，持久化会话，跳一会儿舞，等等。最后将<code class="du jt ju jv jw b">label</code>置为<code class="du jt ju jv jw b">-1</code>，表示协程结束。</p><p id="97eb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，我们已经看到了暂停点如何帮助确定状态机的各种状态。这个状态机允许我们从不同的暂停点恢复执行。</p><p id="180b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">代码在我们看来是连续的，在幕后，它利用状态机在需要时在不同的暂停点暂停和恢复执行。</p><h2 id="1438" class="jx jy hx bd jz ka kb kc kd ke kf kg kh jf ki kj kk jj kl km kn jn ko kp kq kr bi translated">单悬挂点</h2><p id="e2db" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr ha bi translated">前面的例子在协程中有多个暂停点。如果一个暂停函数仅在末尾，即尾部位置调用另一个暂停函数，在暂停函数仅包含单个暂停点并且也在尾部位置的这种简单情况下，则不需要生成状态机，因为只涉及单个状态。这样的挂起函数被编译成只接受一个<code class="du jt ju jv jw b">Continuation</code>参数来挂起和恢复执行。</p><p id="6ddc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就把我们带到了本文的结尾。请注意，了解这些实施细节并不是强制性的。但我相信它肯定有助于创建一个更好的各种问题的心理模型，并更好地利用手头的工具。</p><h2 id="f89d" class="jx jy hx bd jz ka kb kc kd ke kf kg kh jf ki kj kk jj kl km kn jn ko kp kq kr bi translated">延伸阅读:</h2><p id="cf9d" class="pw-post-body-paragraph iu iv hx iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr ha bi translated"><a class="ae hu" rel="noopener" href="/androiddevelopers/the-suspend-modifier-under-the-hood-b7ce46af624f">悬浮修改器——引擎盖下</a>Manuel Vivo著</p><p id="9673" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae hu" href="https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md#implementation-details" rel="noopener ugc nofollow" target="_blank"> Kotlin coroutines提案文档</a>:我发现这个官方文档有助于理解很多概念。</p><p id="fb17" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">特别感谢<a class="lv lw ge" href="https://medium.com/u/3b5622dd813c?source=post_page-----36b189f8aa60--------------------------------" rel="noopener" target="_blank"> Manuel Vivo </a>的点评:)</p><p id="5320" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你学到了什么，请留下一些掌声，并与你的朋友分享。如果您发现了改进，请留下评论，这样我们可以一起学习:)</p></div></div>    
</body>
</html>