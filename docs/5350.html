<html>
<head>
<title>Does the Oracle Explain Plan command really show the execution plan that will be used?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Oracle Explain Plan命令真的显示了将要使用的执行计划吗？</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/does-the-oracle-explain-plan-command-really-show-the-execution-plan-that-will-be-used-eeb59dc9ed4?source=collection_archive---------0-----------------------#2017-11-22">https://medium.com/oracledevs/does-the-oracle-explain-plan-command-really-show-the-execution-plan-that-will-be-used-eeb59dc9ed4?source=collection_archive---------0-----------------------#2017-11-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="ab14" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">谈到SQL调优，我们经常需要查看SQL语句的执行计划，以确定大部分时间花在了哪里。但是我们如何生成执行计划会对我们正在查看的计划是否真的是被使用的计划有很大的影响。</p><p id="0ad2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为SQL语句生成执行计划最常用的两种方法是:</p><p id="4060" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://docs.oracle.com/cd/E25178_01/server.1111/e16638/ex_plan.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">解释计划命令</strong> </a> —显示SQL语句的执行计划，但不实际执行该语句。</p><p id="4f3b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://docs.oracle.com/cd/B28359_01/server.111/b28320/dynviews_3050.htm#REFRN30250" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">V＄SQL _ PLAN</strong></a><strong class="ig hi"/>—Oracle 9i中引入的动态性能视图，显示已编译到游标中并存储在游标高速缓存中的SQL语句的执行计划。</p><p id="b0cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我的首选方法是始终使用V$SQL_PLAN(即使它要求语句至少开始执行),因为在某些情况下，EXPLAIN PLAN命令显示的计划可能与查询执行时实际使用的计划不同。</p><p id="01be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么，是什么导致了计划的不同呢？</p><p id="2dcf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">绑定变量</strong></p><p id="a44f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当SQL语句包含<a class="ae jc" href="https://docs.oracle.com/database/121/TGSQL/tgsql_cursor.htm#GUID-042A85BF-D96E-44AB-9312-4EB115CCE7B0" rel="noopener ugc nofollow" target="_blank">绑定变量</a>时，使用EXPLAIN PLAN显示的计划不知道绑定变量值，而V$SQL_PLAN中显示的计划在计划生成过程中将绑定变量值考虑在内。让我们看一个简单的例子，使用customers表，它有1，018行，在C_ZIPCODE列上有一个索引。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="8a19" class="jm jn hh ji b fi jo jp l jq jr">SELECT count(*) <br/>FROM   customers;</span><span id="b0e9" class="jm jn hh ji b fi js jp l jq jr">  COUNT(*)<br/>----------<br/>      1018</span><span id="c648" class="jm jn hh ji b fi js jp l jq jr">SELECT   c_zipcode, count(*) <br/>FROM     customers <br/>GROUP BY c_zipcode;</span><span id="36cc" class="jm jn hh ji b fi js jp l jq jr"> C_ZIPCODE   COUNT(*)<br/>---------- ----------<br/>     20001	  290<br/>      2111	   81<br/>     10018	  180<br/>     90034	  225<br/>     94102	  225<br/>     94065	   17<br/></span><span id="1ed3" class="jm jn hh ji b fi js jp l jq jr">var n number;<br/>exec :n :=94065;</span><span id="9311" class="jm jn hh ji b fi js jp l jq jr">PL/SQL procedure successfully completed.</span><span id="cc29" class="jm jn hh ji b fi js jp l jq jr">SELECT count(c_email) <br/>FROM   customers <br/>WHERE  c_zipcode=:n;</span><span id="92aa" class="jm jn hh ji b fi js jp l jq jr">COUNT(C_EMAIL)<br/>--------------<br/>	    17</span><span id="29af" class="jm jn hh ji b fi js jp l jq jr">SELECT * <br/>FROM table(dbms_xplan.display_cursor(format=&gt;'typical +peeked_binds'));</span><span id="dfc7" class="jm jn hh ji b fi js jp l jq jr">PLAN_TABLE_OUTPUT<br/>---------------------------------------------------------------------<br/>SQL_ID	bjj643zga3mfu, child number 0<br/>-------------------------------------<br/>SELECT count(c_email) FROM customers WHERE c_zipcode=:n</span><span id="83ea" class="jm jn hh ji b fi js jp l jq jr">Plan hash value: 4213764942</span><span id="c054" class="jm jn hh ji b fi js jp l jq jr">----------------------------------------------------------------------<br/>| Id  | Operation		      | Name	    | Rows  |  Bytes| <br/>----------------------------------------------------------------------<br/>|   0 | SELECT STATEMENT	      |		    |	    |       |	  <br/>|   1 |  SORT AGGREGATE               |		    |	  1 |   24  |	<br/>|   2 |   TABLE ACCESS BY INDEX ROWID | CUSTOMERS   |	 17 |       | <br/>|*  3 |    INDEX RANGE SCAN	      | IND_CUST_ZIP|	 17 |	    |	  <br/>----------------------------------------------------------------------</span><span id="f6c1" class="jm jn hh ji b fi js jp l jq jr">Peeked Binds (identified by position):<br/>--------------------------------------<br/>   1 - :N (NUMBER): 94065 </span><span id="ba45" class="jm jn hh ji b fi js jp l jq jr">Predicate Information (identified by operation id):<br/>---------------------------------------------------<br/>   3 - access("C_ZIPCODE"=:N)</span><span id="05a6" class="jm jn hh ji b fi js jp l jq jr">20 rows selected.</span><span id="d280" class="jm jn hh ji b fi js jp l jq jr">EXPLAIN PLAN FOR <br/>SELECT count(c_email) <br/>FROM customers <br/>WHERE c_zipcode=:n;</span><span id="045f" class="jm jn hh ji b fi js jp l jq jr">Explained.</span><span id="e4a4" class="jm jn hh ji b fi js jp l jq jr">SQL&gt; <br/>SQL&gt; SELECT * FROM table(dbms_xplan.display());</span><span id="ec21" class="jm jn hh ji b fi js jp l jq jr">PLAN_TABLE_OUTPUT<br/>----------------------------------------------------------------<br/>Plan hash value: 296924608<br/>----------------------------------------------------------------<br/>| Id  | Operation	   | Name      | Rows  | Bytes | Cost |<br/>----------------------------------------------------------------<br/>|   0 | SELECT STATEMENT   |	       |     1 |    24 |  7   | <br/>|   1 |  SORT AGGREGATE    |	       |     1 |    24 |      |	  <br/>|*  2 |   TABLE ACCESS FULL| CUSTOMERS |   170 |  4080 |  7   | <br/>-----------------------------------------------------------------</span><span id="0af9" class="jm jn hh ji b fi js jp l jq jr">Predicate Information (identified by operation id):<br/>---------------------------------------------------<br/>   2 - filter("C_ZIPCODE"=TO_NUMBER(:N))</span></pre><p id="631e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们通过DBMS_XPLAN从V$SQL_PLAN查询执行时使用的实际计划时。DISPLAY_CURSOR命令我们得到一个索引访问计划，基数估计值(估计返回的行数)精确到17行。</p><p id="5d0d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，当我们在语句中使用EXPLAIN PLAN命令时，我们得到了一个全表扫描计划和170行的基数估计。</p><p id="b794" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解释计划命令不支持绑定的第一个迹象可以在计划下的谓词信息中看到。在这里，您将看到我们的绑定变量N增加了一个TO_NUMBER函数，尽管我们将变量声明为一个数字。</p><p id="2ff3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为没有发生绑定扫视，所以优化器不能使用c_zipcode列上的直方图。因此，优化器必须假设c_zipcode列中的数据分布是均匀的，它将基数估计值计算为NUM_ROWS / NDV或1018/6 = 169.66，向上舍入为170行。</p><p id="cc17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Cursor_Sharing = FORCE </strong></p><p id="7e12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过将初始化参数<a class="ae jc" href="https://docs.oracle.com/database/121/REFRN/GUID-455358F8-D657-49A2-B32B-13A1DC53E7D2.htm#REFRN10025" rel="noopener ugc nofollow" target="_blank"> CURSOR_SHARING </a>设置为FORCE，您要求Oracle用系统生成的绑定变量替换SQL语句中的文字值(通常称为文字替换)。文字替换的目的是减少共享池中生成的游标数量。在最好的情况下，只为所有语句构建一个游标，这些语句只在使用的文字值上有所不同。</p><p id="e708" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们以最初的例子为例，用文字值94065替换我们的绑定变量:N，看看当CURSOR_SHARING设置为FORCE并使用EXPLAIN PLAN命令时会发生什么。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="087b" class="jm jn hh ji b fi jo jp l jq jr">ALTER SYSTEM SET cursor_sharing = force;</span><span id="5459" class="jm jn hh ji b fi js jp l jq jr">System altered.</span><span id="6da9" class="jm jn hh ji b fi js jp l jq jr">SELECT count(c_email) <br/>FROM   customers <br/>WHERE  c_zipcode=94065;</span><span id="a424" class="jm jn hh ji b fi js jp l jq jr">COUNT(C_EMAIL)<br/>--------------<br/>	    17</span><span id="4f59" class="jm jn hh ji b fi js jp l jq jr">SELECT * <br/>FROM table(dbms_xplan.display_cursor(format=&gt;'typical +peeked_binds'));</span><span id="ccd5" class="jm jn hh ji b fi js jp l jq jr">PLAN_TABLE_OUTPUT<br/>-----------------------------------------------------------------<br/>SQL_ID	djn0jckqvy2gk, child number 0<br/>-------------------------------------<br/>SELECT count(c_email) FROM customers WHERE c_zipcode=:"SYS_B_0"</span><span id="6c50" class="jm jn hh ji b fi js jp l jq jr">Plan hash value: 4213764942</span><span id="ef88" class="jm jn hh ji b fi js jp l jq jr">---------------------------------------------------------------------<br/>| Id  | Operation		     | Name	     | Rows  |Bytes | <br/>---------------------------------------------------------------------<br/>|   0 | SELECT STATEMENT	     |		    |	    |	    |	  <br/>|   1 |  SORT AGGREGATE 	     |		    |	  1 |	 24 |	<br/>|   2 |   TABLE ACCESS BY INDEX ROWID| CUSTOMERS    |	 17 |	408 |	  <br/>|*  3 |    INDEX RANGE SCAN	     | IND_CUST_ZIP |	 17 |	    |	  <br/>---------------------------------------------------------------------</span><span id="928c" class="jm jn hh ji b fi js jp l jq jr">Peeked Binds (identified by position):<br/>--------------------------------------<br/>   1 - :SYS_B_0 (NUMBER): 94065</span><span id="dbdf" class="jm jn hh ji b fi js jp l jq jr">Predicate Information (identified by operation id):<br/>---------------------------------------------------<br/>   3 - access("C_ZIPCODE"=:SYS_B_0)</span><span id="7206" class="jm jn hh ji b fi js jp l jq jr">25 rows selected.</span><span id="4f74" class="jm jn hh ji b fi js jp l jq jr">EXPLAIN PLAN FOR <br/>SELECT count(c_email) <br/>FROM customers <br/>WHERE c_zipcode=94065;</span><span id="00d0" class="jm jn hh ji b fi js jp l jq jr">Explained.</span><span id="b7a2" class="jm jn hh ji b fi js jp l jq jr">SELECT * FROM table(dbms_xplan.display());</span><span id="b9c4" class="jm jn hh ji b fi js jp l jq jr">PLAN_TABLE_OUTPUT<br/>--------------------------------------------------------------------<br/>Plan hash value: 4213764942<br/>--------------------------------------------------------------------<br/>| Id  | Operation		     | Name	     | Rows  |Bytes| <br/>--------------------------------------------------------------------<br/>|   0 | SELECT STATEMENT	     |		    |	    |	   |	  <br/>|   1 |  SORT AGGREGATE              |		    |	  1 |	 24|	<br/>|   2 |   TABLE ACCESS BY INDEX ROWID| CUSTOMERS    |	 17 |	408|	  <br/>|*  3 |    INDEX RANGE SCAN	     | IND_CUST_ZIP |	 17 |	   |	  <br/>--------------------------------------------------------------------<br/>Predicate Information (identified by operation id):<br/>---------------------------------------------------<br/>   3 - access("C_ZIPCODE"=94065)</span></pre><p id="fcaf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一次，两种情况下的计划是相同的，但是如果您查看两种计划下的谓词信息，您会注意到explain plan命令没有进行文字替换。它仍然将谓词显示为C_ZIPCODE=94065，而不是C_ZIPCODE=:SYS_B_0。</p><p id="fdd8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么，为什么explain plan命令没有进行文字替换呢？</p><p id="3431" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据设计，由解释计划命令生成的游标是不可共享的。因为游标不是共享的，所以进行允许游标共享的文字替换是没有意义的。因此，explain plan命令不会替换文字。</p><p id="ae1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了证明EXPLAIN PLAN命令游标不是共享的，我又运行了两次示例查询，然后查询了V$SQL。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="ecf3" class="jm jn hh ji b fi jo jp l jq jr">SELECT sql_id, sql_text, executions, child_number<br/>FROM   v$sql<br/>WHERE  sql_text like '%SELECT count(c_email)%';</span><span id="276e" class="jm jn hh ji b fi js jp l jq jr">SQL_ID        SQL_TEXT                               EXECUTIONS CHILD_NUMBER<br/>------------- -------------------------------------- ---------- ------------<br/>djn0jckqvy2gk SELECT count(c_email) FROM customers            3            0<br/>              WHERE c_zipcode=:"SYS_B_0"</span><span id="482d" class="jm jn hh ji b fi js jp l jq jr">78h277aadmkku EXPLAIN PLAN FOR SELECT count(c_email)          1            0<br/>               FROM customers WHERE c_zipcode=94065</span><span id="8662" class="jm jn hh ji b fi js jp l jq jr">78h277aadmkku EXPLAIN PLAN FOR SELECT count(c_email)          1            1<br/>               FROM customers WHERE c_zipcode=94065</span><span id="cb0b" class="jm jn hh ji b fi js jp l jq jr">78h277aadmkku EXPLAIN PLAN FOR SELECT count(c_email)          1            2</span><span id="89ee" class="jm jn hh ji b fi js jp l jq jr">4 rows selected.</span></pre><p id="e51f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您会注意到，实际的查询用系统生成的bind :SYS_B_0替换了它的文字值，并且只生成了一个游标(child_number 0 ),执行了3次。</p><p id="990d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于该语句的解释计划版本，没有发生文字替换，每次执行都会创建一个新的子游标(0，1，2)。演示使用explain plan命令不会发生游标共享。</p><p id="a4cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我有一些额外的光标。有什么大不了的？</p><p id="770d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重要的是，如果您想要使用任何计划稳定性特性，如<a class="ae jc" href="http://www.oracle.com/technetwork/database/bi-datawarehousing/twp-sql-plan-mgmt-12c-1963237.pdf" rel="noopener ugc nofollow" target="_blank"> SQL计划基线</a>，那么当CURSOR_SHARING设置为FORCE时，您将看不到这些特性对解释计划的影响。假设您使用系统生成的bind :SYS_B_0为该语句创建了SQL计划基线，但是检查哪个计划将与EXPLAIN PLAN一起使用，而不是发生文字替换，因此将不会为该语句找到相应的基线。你可以在最近我回答的<a class="ae jc" href="https://asktom.oracle.com/pls/apex/asktom.search%3Ftag=how-spm-works-with-cursor-sharingforce" rel="noopener ugc nofollow" target="_blank"> AskTOM问题</a>中看到这样的例子。</p><p id="4017" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">适应性计划</strong></p><p id="ba08" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Oracle Database 12c中，自适应计划使优化器能够将语句的最终计划决策推迟到执行时。</p><p id="8e4f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">优化器使用统计信息收集器检测它所选择的计划(默认计划)，以便在运行时，它可以检测出它的基数估计值是否与计划中的操作所看到的实际行数有很大差异。如果有显著的差异，那么计划或计划的一部分可以自动调整，以避免SQL语句第一次执行时的次优性能。</p><p id="ca50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">目前只有连接方法或并行查询分布方法可以适应。</p><figure class="jd je jf jg fd ju er es paragraph-image"><div class="er es jt"><img src="../Images/ae7736350498c96d83d59ca524955454.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*VSToesQ53eyj4qdN.png"/></div><figcaption class="jx jy et er es jz ka bd b be z dx">Adaptive Plans in Oracle 12c — final plan not decided until execution</figcaption></figure><p id="e901" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">默认情况下，explain plan命令将只显示优化器选择的初始或默认计划。而DBMS_XPLAN。DISPLAY_CURSOR函数显示查询使用的最终计划或带有附加格式参数'+adaptive '的完整自适应计划。</p><p id="4add" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看一个具有自适应计划的两个表连接的简单示例，以了解您将看到的解释计划和DBMS_XPLAN之间的差异。显示_光标函数。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="5257" class="jm jn hh ji b fi jo jp l jq jr">EXPLAIN PLAN FOR<br/>SELECT /*+ gather_plan_statistics*/ p.product_name<br/>FROM   order_items2 o, product_information p<br/>WHERE  o.unit_price = 15<br/>AND    o.quantity &gt; 1<br/>AND    p.product_id = o.product_id;</span><span id="7a1c" class="jm jn hh ji b fi js jp l jq jr">Explained.</span><span id="2bf4" class="jm jn hh ji b fi js jp l jq jr">SELECT * FROM table(dbms_xplan.display());</span><span id="4222" class="jm jn hh ji b fi js jp l jq jr">PLAN_TABLE_OUTPUT<br/>-----------------------------------------------------------------------<br/>Plan hash value: 983807676<br/>-----------------------------------------------------------------------<br/>| Id  | Operation		     | Name		      | Rows  | <br/>-----------------------------------------------------------------------<br/>|   0 | SELECT STATEMENT	     |			      |     4 |   <br/>|   1 |  NESTED LOOPS		     |			      |     4 |   <br/>|   2 |   NESTED LOOPS		     |			      |     4 |   <br/>|*  3 |    TABLE ACCESS FULL	     | ORDER_ITEMS2	      |     4 |    <br/>|*  4 |    INDEX UNIQUE SCAN	     | PRODUCT_INFORMATION_PK |     1 |       <br/>|   5 |   TABLE ACCESS BY INDEX ROWID| PRODUCT_INFORMATION    |     1 |    <br/>-----------------------------------------------------------------------</span><span id="89dc" class="jm jn hh ji b fi js jp l jq jr">Predicate Information (identified by operation id):<br/>---------------------------------------------------</span><span id="9d2a" class="jm jn hh ji b fi js jp l jq jr">   3 - filter("O"."UNIT_PRICE"=15 AND "O"."QUANTITY"&gt;1)<br/>   4 - access("P"."PRODUCT_ID"="O"."PRODUCT_ID")</span><span id="0742" class="jm jn hh ji b fi js jp l jq jr">Note<br/>-----<br/>   - this is an adaptive plan</span><span id="c010" class="jm jn hh ji b fi js jp l jq jr">22 rows selected.</span><span id="7b9d" class="jm jn hh ji b fi js jp l jq jr">SELECT /*+ gather_plan_statistics*/ p.product_name<br/>FROM   order_items2 o, product_information p<br/>WHERE  o.unit_price = 15<br/>AND    o.quantity &gt; 1<br/>AND    p.product_id = o.product_id;</span><span id="869c" class="jm jn hh ji b fi js jp l jq jr">SELECT * FROM table(dbms_xplan.display_cursor());</span><span id="79e5" class="jm jn hh ji b fi js jp l jq jr">PLAN_TABLE_OUTPUT<br/>-----------------------------------------------------------------------<br/>SQL_ID	d3mzkmzxn264d, child number 0<br/>-------------------------------------<br/>select /*+ gather_plan_statistics */ p.product_name from order_items2<br/>o, product_information p where o.unit_price = 15   and o.quantity &gt; 1<br/>and p.product_id = o.product_id</span><span id="c02c" class="jm jn hh ji b fi js jp l jq jr">Plan hash value: 2886494722</span><span id="7e72" class="jm jn hh ji b fi js jp l jq jr">------------------------------------------------------------------<br/>| Id  | Operation	   | Name		 | Rows  | Bytes | <br/>------------------------------------------------------------------<br/>|   0 | SELECT STATEMENT   |			 |	 |	 |     <br/>|*  1 |  HASH JOIN	   |			 |     4 |   128 |     <br/>|*  2 |   TABLE ACCESS FULL| ORDER_ITEMS2	 |     4 |    48 |<br/>|   3 |   TABLE ACCESS FULL| PRODUCT_INFORMATION |     1 |    20 |     <br/>------------------------------------------------------------------</span><span id="8cb6" class="jm jn hh ji b fi js jp l jq jr">Predicate Information (identified by operation id):<br/>---------------------------------------------------</span><span id="75e7" class="jm jn hh ji b fi js jp l jq jr">   1 - access("P"."PRODUCT_ID"="O"."PRODUCT_ID")<br/>   2 - filter(("O"."UNIT_PRICE"=15 AND "O"."QUANTITY"&gt;1))</span><span id="ba97" class="jm jn hh ji b fi js jp l jq jr">Note<br/>-----<br/>   - this is an adaptive plan<br/></span><span id="3a91" class="jm jn hh ji b fi js jp l jq jr">27 rows selected.</span></pre><p id="7f11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如您所看到的，优化器提出的初始计划是一个嵌套循环连接，而最终计划实际上是一个散列连接。如果您只使用EXPLAIN PLAN命令，您永远不会知道使用了完全不同的连接方法。</p><p id="b45b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我的建议是在检查SQL语句的执行计划时使用use V$SQL_PLAN，因为它还会显示该语句实际使用的策略。</p></div></div>    
</body>
</html>