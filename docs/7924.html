<html>
<head>
<title>Yellow Couch: Tale of Two Solr Indexes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">黄色沙发:两个Solr指数的故事</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/yellow-couch-tale-of-two-solr-indexes-9c39e635cf71?source=collection_archive---------0-----------------------#2020-10-27">https://medium.com/walmartglobaltech/yellow-couch-tale-of-two-solr-indexes-9c39e635cf71?source=collection_archive---------0-----------------------#2020-10-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6d1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用另一个Solr作为前向索引来解决Andromeda式搜索索引中的颜色和大小查询</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/399679e6e11bdc3ea8cd53c248c68495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEJz2volKn-3uJtyElLAWA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 1: A typical yellow chair from <a class="ae js" href="https://www.walmart.com/ip/Modern-Accent-Chair-Single-Sofa-Comfy-Fabric-Upholstered-Arm-Chair-Living-Room-Yellow/122173882?variantFieldId=actual_color" rel="noopener ugc nofollow" target="_blank">Walmart Catalog</a></figcaption></figure><p id="cb69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本帖中，我们将讨论如何解决颜色/尺寸查询和过滤器在搜索和项目页面中的可用性/合格性/价格差异问题。</p><h1 id="3989" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">问题陈述</h1><p id="c42d" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">当顾客对颜色或尺寸有意向时[例如，黄色沙发、特大床垫等]，我们在第一页上的结果从一开始就看起来非常相关。但是当我们转到商品页面时，有些商品可能没有我们想要的特定颜色的商品。</p><h1 id="dd03" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">为什么会这样</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kw"><img src="../Images/d551e78d7fdef17d10e742f8ea2c55f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*wPtaS8qwng1noSJQYyRSlA.jpeg"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 2: 10..00 Feet Overview of Search Architecture</figcaption></figure><p id="ff39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图2显示了任何电子商务搜索系统中的典型搜索查询路径。</p><p id="6409" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个查询首先命中我们的一个微服务，并经历搜索查询的所有动作[查询理解、重构、修正等]。]然后最后点击Solr Index，它是从一个正在运行的索引管道中填充的。</p><blockquote class="kx ky kz"><p id="dc7b" class="ie if la ig b ih ii ij ik il im in io lb iq ir is lc iu iv iw ld iy iz ja jb ha bi translated">现在，我们故事中的罪魁祸首是Solr索引或Solr中的数据模型。我们将一个项目所有可能的颜色或大小组合分组到一个文档中，并将其以非规范化格式[如下所示]存储在该索引中。因此，如果有任何彩色沙发可用，那么我们将该文档标记为可用，但我们不知道黄色是否可用。这是通过对我们的实时可用性服务API(一个不同的服务)的另一个调用在项目页面上标识的。</p></blockquote><pre class="jd je jf jg fd le lf lg lh aw li bi"><span id="87ba" class="lj ju hh lf b fi lk ll l lm ln">Denormalized Format for presentation purpose:</span><span id="783f" class="lj ju hh lf b fi lo ll l lm ln">{id: 1,  color: [red, blue, green], available: true }</span></pre><p id="cda9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="la">问题:为什么不将所有项目组合的所有数据存储在搜索索引内的一个文档中？</em></p><p id="54db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回答:沃尔玛在美国有5000多家商店，每家商店都有自己的供货情况、价格和资格信息。将所有信息存储在一个文档中对于索引来说是非常复杂和爆炸性的。</p><p id="b79a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="la">问:为什么不分解索引并将每个变体存储为不同的文档</em></p><p id="e94b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">答:这是我们尝试过的，但它给我们带来了巨大的延迟峰值，而且由于数据重复，索引大小也增加了。</p><h1 id="8e8f" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">系统设计</h1><p id="e1f8" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我们用一个前向索引解决了这个问题，细节如下。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lp"><img src="../Images/59360d1f6245159b4a80fbdb4298a32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*RFIV0TnS4Z7hdPEfsH8U2g.jpeg"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 3: What is better than 1 Solr Index: 2 Solr Index</figcaption></figure><p id="1521" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图3显示了新的搜索设计，我们引入了一个新的数据存储[Forward Index]和它的另一个<a class="ae js" href="https://lucene.apache.org/solr/" rel="noopener ugc nofollow" target="_blank">Solr</a>。</p><p id="f16a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个前向索引只有作为不同文档的变量项。因此，通过我们的编排层，我们在第一次调用Primary Solr之后进行另一次调用，以获取组中的相关项目。主solr返回最相关的组，第二Solr只计算出该组中最相关的颜色/尺寸项目。</p><pre class="jd je jf jg fd le lf lg lh aw li bi"><span id="6803" class="lj ju hh lf b fi lk ll l lm ln">Data Format in Forward Index:</span><span id="2fff" class="lj ju hh lf b fi lo ll l lm ln">{parent_id: 1, id: 11,  color: red, available: true, price.....}<br/>{parent_id: 1, id: 12,  color: yellow, available: false, price... }</span></pre><p id="2066" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们对前向索引的查询主要是针对店铺可用性、资格、颜色和大小属性的<a class="ae js" href="https://lucene.apache.org/solr/guide/6_6/common-query-parameters.html#CommonQueryParameters-Thefq_FilterQuery_Parameter" rel="noopener ugc nofollow" target="_blank">过滤查询</a>【FQ】。因此，我们充分利用文档缓存和过滤器缓存。下图显示了我们如何最大限度地利用Solr缓存。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lq"><img src="../Images/842b85dfae6cc6ffd8f7de28fa430eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29wBUmp161Oo-C1KPt5NCw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 4: <a class="ae js" href="https://lucene.apache.org/solr/guide/8_3/query-settings-in-solrconfig.html#filtercache" rel="noopener ugc nofollow" target="_blank">Filter Cache</a> during the performance test</figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lr"><img src="../Images/2b6f7e4e2b7ed17ea0fe2bcca1abd056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uo6LIeq7Y5RtgA8J9PNtPw.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 5: <a class="ae js" href="https://lucene.apache.org/solr/guide/6_6/query-settings-in-solrconfig.html#QuerySettingsinSolrConfig-documentCache" rel="noopener ugc nofollow" target="_blank">Document Cache </a>during the performance test</figcaption></figure><p id="a43b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对搜索查询延迟的整体延迟影响是最小的，因为这个调用与另一个微服务调用并行发生，后者发生在文档的后处理过程中，如图6所示。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ls"><img src="../Images/e1beecf2d8b9de5dd299ce19c6b6d839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JctSdvPFELAo_rDCdbnn3A.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Figure 6: Impact on Latency through various approaches</figcaption></figure><h1 id="5e58" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="af46" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我们的搜索路径中现在有两个Solr索引，其中一个有一个文档子集，用于过滤掉不相关的项目，并将相关的项目放在顶部。我们还有一个替代的索引管道来保持这个前向索引是最新的。因此，对于任何搜索查询，我们首先从主索引中获取前N个条目，然后基于二级调用进行过滤/提升/降级/交换。总而言之，颜色大小的查询现在工作得很好。</p><p id="f08b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Solr参考文件:</p><p id="ec3b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">https://lucene.apache.org/solr/<a class="ae js" href="https://lucene.apache.org/solr/" rel="noopener ugc nofollow" target="_blank"/></p><p id="975c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我很想知道您是否想到了任何其他解决上述问题的创新和最佳方案，同样欢迎发表评论。:-)</p></div></div>    
</body>
</html>