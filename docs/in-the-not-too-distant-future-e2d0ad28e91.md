# 在不太遥远的将来…

> 原文：<https://medium.com/capital-one-tech/in-the-not-too-distant-future-e2d0ad28e91?source=collection_archive---------3----------------------->

## 建立一个包含频道、Goroutines 和选择的期货库

![](img/26887a33a055716e6a424fe51774ebf4.png)

[***一系列帖子中的第 4 张***](/@jon_43067)

[在之前的博客文章](/@jon_43067)中，我们已经了解了如何使用通道来构建无限队列、池以及管理多个并行请求。我们能够用通道做所有这些事情，在这些情况下，抽象是有意义的，但有时，我们希望以不同的方式来处理并发问题。例如，Node.js 开发人员使用未来(有时称为承诺)的概念来组织回调和后台任务。如何在 Go 中构建 futures 来实现同样的工作流程？

如果你对期货不熟悉，[下面是基本思路](http://dist-prog-book.com/chapter/2/futures.html)。它们是一种编程抽象，允许您在后台运行一点代码，并立即获得对结果的引用。当您最终尝试从引用中读取结果时，future 会检查结果是否已经计算出来。如果有，它会立即返回。如果没有，您要等到结果被填充。

期货有两个重要的属性。首先，您不必等到实际需要结果时才等待后台进程的结果。第二，使用 futures 隐藏了并发编程中经常涉及的许多混乱的样板文件，使您的源代码更容易理解。

[![](img/a94559d31aeb80a7fd55aff68f92d34c.png)](https://twitter.com/CapitalOneDevEx)

# 设计 API

所以，让我们弄清楚一个基本未来的 API 会是什么样子。我们希望:

*   传入要运行的代码
*   返回一个引用，该引用最终将包含由代码计算的值

我们先来看返回类型。因为这是 Go，所以我们有一些特定于语言的细节需要注意。

首先，再一次，Go 中没有泛型，所以我们需要尽可能用最通用的术语来写东西，并让我们的客户端代码将响应转换成正确的数据类型。这意味着使用`interface{}`作为返回的数据类型。

第二，在 Go 中处理错误的惯用方法是返回一个`error`作为最终参数，所以我们也需要返回一个`error`，以防将来出现错误。

我们不能只返回一个填充了值的`struct`，因为我们会立即返回引用，稍后再填充数据。这意味着我们需要调用一个可能会等待数据出现的方法。与其使用具体的类型，不如公开一个`interface`更有意义，给我们最大的灵活性。因此，我们的返回类型将看起来像:

现在，我们传入的函数呢？因为 Go 有闭包，所以我们可以用一个闭包来包装我们真正想运行的代码。这意味着我们不需要担心向函数传递参数；我们将从环境中捕捉它们。我们确实需要从闭包中返回值，以便填充我们的`future.Interface` 实现，所以我们的函数必须返回`(interface{}, error)`。

现在我们已经定义了输入和输出类型，下面是我们的 API 的第一遍:

我们将很快填充实现。下面是创建未来时客户端代码的样子:

# 首次实施

现在我们知道了代码对外界应该是什么样子，我们可以开始考虑它将如何做它需要做的事情。让我们看看我们是否可以只用标准的 Go 并发机制来实现我们的未来:`select`、通道和 goroutines。

首先，我们需要一个结构来保存数据和实现接口。我们不想向我们的客户公开它，因为他们应该只使用接口和工厂函数。这意味着它的名字的第一个字符应该是小写字母。

您可能会对类型为`struct{}`的 done 通道感到惊讶。我们将利用围棋中的一种模式，这种模式用于在工作完成时发出信号。当通道无缓冲时，试图从通道中读取将暂停读取程序，直到发生以下两种情况之一:向通道写入值或关闭通道。我们的`done`通道永远不会写入值；它的存在只是为了在工作完成时关闭。这允许你使用一个封闭的通道作为一个永久的信号，从一个 goroutine 到另一个 go routine，它可以继续下去。

现在我们需要实现`New`:

在我们的代码中，`New`创建一个`futureImpl`，然后启动一个 goroutine 来运行传入函数，将函数返回的值和错误赋给我们的`futureImpl`中的字段，并关闭`done`通道。同时，`Get`方法等待，直到`done`通道关闭，然后返回值和错误。如果再调用`Get`，关闭的`done`通道会立即返回，我们会不等待的取回值和错误。

我们已经用大约 20 行代码得到了未来工作的基本结构；一点也不坏。

*如果你想看到它工作，在 Go Playground 上查看* [*这个链接*](https://play.golang.org/p/9gNEkgQihl) *。*

# 不要永远等待

现在基础工作已经完成，是时候为我们的未来添加更多的功能了。你可能想到的第一件事是，不必永远等待未来的完成是件好事。毕竟，未来可能比我们想要等待的时间更长。我们应该在我们的接口中添加第二个方法，这样我们就可以限制我们愿意等待的时间:

调用`GetUntil`而不是`Get`只会等待指定的`Duration`。如果结果在超时前返回，我们希望在那个点返回。如果结果在那个点之后回来，我们想要停止等待。为了知道请求是否超时，除了值和错误之外，我们还返回一个布尔标志。如果标志设置为真，则请求超时。如果是 false，返回的值和误差就是我们的函数计算的值和误差。

为了支持`GetUntil`，我们不需要修改`New`或者`Get`。我们只需要添加以下方法实现:

`select`语句等待`f`中的`done`通道和`time.After`返回的通道。哪个先返回将决定返回哪个结果。

还要注意，如果`GetUntil`超时，您还没有丢失您的工作。可以再调用`Get`或者`GetUntil`得到未来的结果。`GetUntil`所做的只是防止你等待结果被计算出来。

下面是使用`GetUntil`的示例客户端代码:

*如果你想看到它工作，请在 Go Playground 上查看* [*这个链接*](https://play.golang.org/p/8CnYCaEpLR) *。*

# 建立一个链条

很好，我们未来的实现正在向前推进。再补充点别的吧。

期货通常具有的另一个特征是被链接在一起的能力。如果你有几个相互依赖的长时间运行的进程，让未来自动从一个进程调用另一个进程会很好。如果链中的一个调用失败，我们希望停止处理链中的工作，并返回导致失败的错误。这意味着需要向我们的接口添加一个新方法:

我们的新方法叫做`Then`。它接受一个函数并返回一个新的未来接口。传递给`Then`的函数与传递给`New`的函数略有不同。这个函数只有一个输入参数，它是链中上一步的输出，因此得名。

同样，我们可以在不修改任何现有代码的情况下添加新方法实现。我们将调用现有的`New`函数来创建一个新的未来。由于`New`函数需要一个没有输入参数的函数，我们将传递给它一个闭包，它做三件事:

1.对链中的前一个未来调用 Get 方法。

2.检查前一个未来是否返回错误。如果是的话，退回去。

3.否则，用前一个未来的结果调用下一个函数。

向未来添加一个`Then`步骤相当简单:

有了这个补充，我们有了一个相当完整的未来实现。我们可以在后台运行作业，选择我们希望等待它们完成的时间，并用非常简洁的语法将作业链接在一起。但是添加未来链接意味着还有一件更好的事情:取消。

*你可以在 Go Playground 上的* [*这个链接*](https://play.golang.org/p/yphIk3BJ4W) *看到这个执行的样本代码。*

# 对抗未来

取消和超时之间的区别很微妙，但是很重要。超时意味着我现在不想等待工作完成，但是工作会在后台继续进行，以防您稍后想要回来查看结果。

取消意味着我不关心结果，如果在当前步骤完成后还有任何额外的步骤，不要运行它们。

与我们的其他添加不同，添加取消支持需要修改我们现有的代码。这有道理；我们正在添加一种方法来中断以前无法中断的事情。幸运的是，Go 的并发特性使得添加这种支持变得很容易。

首先，我们需要在未来的界面中增加取消功能:

有一点要明确的是`Cancel`不能阻止当前运行的函数完成；一旦一个函数开始执行，在函数之外你无法阻止它。我们所能做的就是立即停止等待它的结果，并阻止`Then`链中任何额外的项目运行。

接下来，我们将修改`futureImpl`，并添加我们的`Cancel`和`IsCancelled`实现:

我们需要向`futureImpl`添加一个字段，这样我们就可以跟踪取消状态。`Cancel`和`IsCancelled`的实现非常简单。在`Cancel`中，我们仅在`cancel`通道尚未关闭且`done`尚未首先关闭的情况下关闭该通道。这两种方法都利用了`select`中的`default`子句来确保有立即的响应。

您可能会注意到`futureImpl`中添加了另一个新字段。Go 对频道的一个规则是多次关闭一个频道会导致恐慌。由于死机会杀死正在运行的应用程序，我们需要确保我们的`cancel`通道只关闭一次。如果多个 goroutines 都同时在同一个未来调用`Cancel`，那么有可能不止一个 goroutines 会在 select 中成为默认情况。

Go 标准库有解决这个问题的方法。它包括一个名为 sync.Once 的类型，将取消通道关闭包装在一个由 sync 调用的闭包中。Once.Do 方法确保只有一个 goroutine 会真正关闭通道，不管是否有许多 go routine 同时尝试这样做。

为了填充和使用`cancel`通道，我们需要修改`New`、`Then`、`Get`和`GetUntil`:

对`Get`和`GetUntil`的更改只是增加了对`cancel`通道的检查。对`New`的改动稍微复杂一些。我们想取消一次，影响未来整个链条。最简单的方法是让所有的期货都监听同一个取消频道。链中的初始条目没有取消通道，所以我们需要创建它。在`Then`中添加的所有后续`Steps`将使用为第一个未来创建的取消通道。

共享对同一通道的引用会将取消通道的状态广播给未来链中的所有步骤。因为关闭的通道总是立即返回，所以所有的 goroutines 都能够读取一个值而不会发生冲突。

下面是一些演示取消的示例代码:

*你可以在 Go 游乐场的* [*这个链接*](https://play.golang.org/p/JtdclgBHGc) *运行这个代码。*

# 将未来置于背景中

如果我们想要我们的直接功能之外的东西来触发取消呢？也许我们有一个请求应该只运行一定的时间。在这种情况下，我们应该使用上下文。Go 1.7 将上下文添加到了 1.7 的标准库中。但这是什么呢？

上下文是围棋中两个重叠问题的解决方案:

1.  如何支持 goroutine 局部变量？

2.我如何给 goroutine 发信号让它停止工作？

上下文是一个接口，提供对以下内容的访问:

*   从请求的早期阶段传递到后期阶段的键/值对(例如将用户放入身份验证处理程序中，并将其用作数据库查询的一部分)。
*   一个 done 通道，当到了停止处理当前请求的时间或者当上下文被显式取消时关闭。
*   一个截止日期，告诉你什么时候完成通道将关闭。
*   一个告诉你为什么 done 通道被关闭的错误。context 包包含创建带有期限和值的上下文的函数，以及访问上下文的 cancel 函数。

我们可以利用上下文的取消支持来为我们的未来创建定时取消。只需为期货添加一个新的工厂函数，NewWithContext:

如果为我们提供了一个设置了取消通道的上下文，我们需要设置一个 goroutine，在未来完成它的工作之前，等待查看上下文是否被取消。如果是的话，我们就触发未来的取消。

使用它的代码如下所示:

*你可以在 Go 游乐场的* [*这个链接*](https://play.golang.org/p/1yZppI2E50) *运行这个代码。*

# 未来扩展

在其他未来的实现中还会发现其他的特性。有许多选项，但其中一些包括:

*   获取值和错误，并立即返回是否完成。
*   只在出错时运行的阶段。
*   指定未来要运行的多个函数，并等待其中任何一个函数完成。
*   指定未来要运行的多个函数，并等待所有函数完成。
*   将多个未来的值合并到一个未来。

添加这些特性超出了本文的范围，但是所有这些特性都可以通过使用我已经概述的构建模块来构建。通道、goroutines 和 selects 允许我们使用简单的代码来构建这些复杂的结构，这些代码比大多数其他语言提供的线程和互斥体的集合更容易理解。

如果有人对使用这个未来图书馆感兴趣，Capital One 已经开源了一个更高级的版本，可以在 https://github.com/capitalone/go-future-context 找到。请随意分叉它，并提交带有附加功能和错误修复的拉请求。

***披露声明:以上观点仅代表作者个人观点。除非本帖中另有说明，否则 Capital One 不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权是其各自所有者的所有权。本文为 2017 首都一。***

**附加链接**

*   [缓冲通道——它们有什么用？](/capital-one-developers/buffered-channels-in-go-what-are-they-good-for-43703871828)
*   [闭包是 Go 的泛型](/capital-one-developers/closures-are-the-generics-for-go-cb32021fb5b5)
*   [在 Go 中构建无界通道](/capital-one-developers/building-an-unbounded-channel-in-go-789e175cd2cd)
*   [在 Go 中构建 REST API](https://developer.capitalone.com/blog-post/building-a-serverless-rest-api-in-go/)