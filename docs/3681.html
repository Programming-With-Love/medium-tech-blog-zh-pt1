<html>
<head>
<title>Azure Durable Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure持久功能</h1>
<blockquote>原文：<a href="https://medium.com/globant/azure-durable-functions-610291c1123a?source=collection_archive---------0-----------------------#2021-05-24">https://medium.com/globant/azure-durable-functions-610291c1123a?source=collection_archive---------0-----------------------#2021-05-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="53ae" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">概观</h1><p id="081b" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">Azure函数是Azure中的无服务器解决方案。在亚马逊网络服务中，它被称为AWS Lambda。Azure函数以两种重要的方式提供按需计算。</p><blockquote class="kh ki kj"><p id="d393" class="jj jk kk jl b jm kl jo jp jq km js jt kn ko jw jx kp kq ka kb kr ks ke kf kg ha bi translated">首先，Azure functions允许你将系统的逻辑实现到现成的代码块中。这些代码块被称为函数。</p><p id="e4aa" class="jj jk kk jl b jm kl jo jp jq km js jt kn ko jw jx kp kq ka kb kr ks ke kf kg ha bi translated">第二，随着请求的增加，Azure函数会根据需要使用许多资源和函数实例来满足需求——但只是在需要的时候。随着请求的减少，任何额外的资源和应用程序实例都会自动减少。这就是所谓的放大和缩小。用于相同目的的组件称为缩放控制器，它监视事件的速率并确定是向外扩展还是向内扩展。</p></blockquote><h1 id="4c22" class="il im hh bd in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji bi translated">Azure中的持久功能是什么</h1><p id="9634" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">持久函数是Azure Function的扩展，它允许我们编写有状态的函数。耐久功能建立在<a class="ae ky" href="https://github.com/Azure/durabletask" rel="noopener ugc nofollow" target="_blank"> <strong class="jl hi">耐久任务框架</strong> </a> <strong class="jl hi">之上。</strong>当我们等待<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.webjobs.durableorchestrationcontext?view=azure-dotnet-legacy" rel="noopener ugc nofollow" target="_blank"><strong class="jl hi"><em class="kk">DurableOrchestrationContext</em></strong></a><strong class="jl hi"><em class="kk">，</em> </strong>时，它写入一个历史表并退出该函数。当输出准备就绪时，它重新运行函数到await(检查点)点，并将值注入。</p><h1 id="5251" class="il im hh bd in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji bi translated">持久功能模式:</h1><p id="9d74" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">它简化了无服务器应用程序中复杂的有状态协调需求。</p><p id="d1c7" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated"><strong class="jl hi"> 1。<em class="kk">异步HTTP API:</em>T19】</strong></p><p id="785d" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">aysnc HTTP API模式解决了与外部客户机协调长时间运行的操作状态的问题。实现这种模式的方法是让HTTP端点触发长时间运行的操作。然后，重定向到客户端轮询以了解执行何时完成的状态端点。</p><p id="a9b1" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">Durable Function为这种模式提供了内置支持，简化甚至删除了与长时间运行的函数执行进行交互所需的代码。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es kz"><img src="../Images/54035bffa3f92d865a50f01433933028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w9eW4bSuJ_DyIqiW46lqdQ.png"/></div></div></figure><p id="0228" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">一个简单的REST命令，我们可以用它来启动新的orchestrator函数实例。实例启动后，扩展会公开查询orchestrator功能状态的webhook HTTP APIs。作为持久函数，运行时为我们管理状态。我们不需要实现自己的状态跟踪机制。</p><p id="fa41" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated"><strong class="jl hi"> 2。<em class="kk">功能链接:</em> </strong></p><p id="57e2" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">函数链是指以特定顺序执行一系列函数的模式。通常，一个函数的输出需要应用于另一个函数的输入。持久函数允许我们用代码简洁地实现这种模式。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ll"><img src="../Images/330ed2ad2b5194a23e9dba21727d70fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvwIYKnLe-bUZd4Y8fmfpw.png"/></div></div></figure><p id="065b" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated"><strong class="jl hi"> <em class="kk"> 3。扇出/扇入:</em> </strong></p><p id="3aad" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">扇出/扇入是指并行执行多个功能，然后等待所有功能完成的模式。通常会对函数返回的结果进行一些聚合工作。对于普通函数，可以通过让函数向一个队列发送多条消息来实现扇出。然而，扇回更具挑战性。持久函数扩展用相对简单的代码处理这种模式。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lm"><img src="../Images/cb0bf6069ca4f5cf55bec9be766e12cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hdOI41s1NslW3ewe8jJyLA.png"/></div></div></figure><p id="f886" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated"><strong class="jl hi"> <em class="kk"> 4。监控:</em> </strong></p><p id="d946" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">监控模式指的是工作流中灵活的循环过程，例如，在满足某些条件之前进行轮询。常规的计时器触发器可以处理一个简单的场景，比如定期清理作业，但是它的时间间隔是静态的，管理实例生存期变得复杂。持久功能支持灵活的重复间隔、任务生命周期管理，以及从单个编排创建多个监控流程的能力。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ln"><img src="../Images/72d54d88d75d2735080e7ce17b629177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QLAyd-y2l4Ugzl1hfF-b6Q.png"/></div></div></figure><p id="bc22" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated"><strong class="jl hi"> <em class="kk"> 5。人际互动:</em> </strong></p><p id="23f2" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">许多过程都涉及到某种人类互动。让人类参与自动化过程的棘手之处在于，人们并不总是像云服务那样高度可用和响应迅速。自动化流程必须考虑到这一点，它们通常通过使用超时和补偿逻辑来实现这一点。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lo"><img src="../Images/2d33482e3fdb7ed2be452eab1a7ef60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlVUEhxh0cNwwHJtEz-i7w.png"/></div></div></figure><p id="e47b" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated"><strong class="jl hi"> 6。<em class="kk">聚合器:</em> </strong></p><p id="c517" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">在这种模式中，被聚合的数据可能来自多个来源，可能是成批交付的，也可能是长时间分散的。聚集器可能需要在事件数据到达时对其采取行动，并且外部客户端可能需要查询聚集的数据。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lp"><img src="../Images/ae863a6be8e15f08fa94e71d10575e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4XsJwjVSEB6Zd6DHox4JQ.png"/></div></div></figure><h1 id="fe83" class="il im hh bd in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji bi translated">持久功能的概念</h1><p id="6f50" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">Orchestrator函数只有一个角色，即定义工作流。它本身不执行任何操作，比如调用API或写入数据库。相反，它将工作流中的所有实际步骤委托给活动功能。当第一个活动完成时，Orchestrator函数会唤醒并从它停止的地方继续，调用工作流中的下一个活动。因此，一个Orchestrator函数调用一个Activity函数，Activity函数就是一个普通的Azure函数，它参与工作流。活动函数可以从Orchestrator函数接收输入数据，并可以向其返回数据。</p><h1 id="d1b1" class="il im hh bd in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji bi translated">持久功能的缺点:</h1><ul class=""><li id="611f" class="lq lr hh jl b jm jn jq jr ju ls jy lt kc lu kg lv lw lx ly bi translated">由于orchestrator函数运行多次，因此orchestrator函数具有确定性非常重要。(即代码必须为相同的输入返回相同的值。)</li><li id="5c6a" class="lq lr hh jl b jm lz jq ma ju mb jy mc kc md kg lv lw lx ly bi translated">消费计划的扩展有一些限制，即使是高级计划也有100个应用程序功能的上限。</li></ul><p id="9d00" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated"><strong class="jl hi">持久功能所需的库</strong></p><figure class="la lb lc ld fd le er es paragraph-image"><div class="er es me"><img src="../Images/942285b68e7b9a348d3a0b1783409d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*HoFuLM-8qRlV6Jhru0A3Aw.png"/></div></figure><p id="630a" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated"><strong class="jl hi">使用Visual Studio 2019创建持久函数的步骤</strong></p><ol class=""><li id="d0f4" class="lq lr hh jl b jm kl jq km ju mf jy mg kc mh kg mi lw lx ly bi translated">打开Visual Studio 2019，选择<strong class="jl hi"> <em class="kk">新建一个新项目。</em>T19】</strong></li></ol><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mj"><img src="../Images/3cf9bfacbf3a024667c96772eebe05bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HfhS0TXFKHkmgUMcUV5mA.png"/></div></div></figure><p id="f2d3" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">2.搜索<strong class="jl hi"> <em class="kk"> Azure Functions </em> </strong>模板，点击下一步。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mk"><img src="../Images/10c028988f6dc18cdba2b17b4e8e5cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IV3b4ipcQRagKEQaya6kfA.png"/></div></div></figure><p id="af32" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">3.输入<strong class="jl hi"> <em class="kk">项目名称</em> </strong>，点击<strong class="jl hi"> <em class="kk">创建</em> </strong>在配置您的新项目屏幕下</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mk"><img src="../Images/4b278da73734070a80da648afd44c6a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Den4USlWLgqRJPo9e6JDnw.png"/></div></div></figure><p id="7218" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">4.选择<strong class="jl hi"> <em class="kk">清空</em> </strong>申请类型，点击<strong class="jl hi"> <em class="kk">创建</em> </strong></p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ml"><img src="../Images/ea044fa6c626a3e1c960d074e7c4f65c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IO6WyDEkNz8l1p3JCaz7w.png"/></div></div></figure><p id="ea8f" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">5.在解决方案浏览器中右击项目名称，选择<strong class="jl hi"> <em class="kk">添加</em> </strong>，选择<strong class="jl hi"> <em class="kk">新Azure函数</em> </strong></p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mm"><img src="../Images/bd25886fc3b1ae8d780e86fb4d5b79b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWqdD1dz4ttzEIasjZG6YA.png"/></div></div></figure><p id="fd4c" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">6.选择Azure函数，输入类文件Function1.cs的名称，点击<strong class="jl hi"> <em class="kk">添加</em> </strong></p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mn"><img src="../Images/505d2550eb35d10c4941793b6d66eb7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bn_cIjwtpvFCP8FsxlrLUg.png"/></div></div></figure><p id="8181" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">7.选择<strong class="jl hi"> <em class="kk">持久功能编排</em> </strong>并点击确定按钮</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mo"><img src="../Images/d014b3fad203de3fd8cea5db287fd03b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YBoN7-_XgXLZ2-8jVeEflg.png"/></div></div></figure><p id="b888" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated"><strong class="jl hi">样本代码</strong></p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mp"><img src="../Images/668c70359f2efcb1eb27dbbf718d4215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BN_VpINI9-y28HSslTT1BA.png"/></div></div></figure><p id="04c9" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">当我们执行上述持久函数时，它将提供URL<em class="kk">http://localhost:7071/API/orchestrators/{ Function name }</em></p><p id="c40d" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">现在我们可以使用<a class="ae ky" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank"> <em class="kk"> postman </em> </a>工具测试url，{ <em class="kk"> functionName </em> }将被替换为test，因为我们已经提供了函数名作为测试。一旦我们点击URL，它将返回如下的<strong class="jl hi"> JSON </strong>数据，标签id被称为实例id。基于每个请求，这个id被生成。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mq"><img src="../Images/69c6224cde551f0e63a12c66ce1e9ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EEU8tlM5fjYlML2YMsVCbg.png"/></div></div></figure><p id="0448" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">在标签<strong class="jl hi"> <em class="kk">中，statusQueryGetUri </em> </strong>被进一步用于通过id/实例id获取特定请求的状态，一旦该id的执行完成，则<strong class="jl hi"> <em class="kk">运行时间状态</em> </strong>被标记为完成。下面是我们点击浏览器时<strong class="jl hi"><em class="kk">statusQueryGetUri</em></strong>的回应。</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mr"><img src="../Images/b0c48faa3d328e32986ca87de687f27a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RY-moAcLUe_5nxlNlUUZ3Q.png"/></div></div></figure><p id="053b" class="pw-post-body-paragraph jj jk hh jl b jm kl jo jp jq km js jt ju ko jw jx jy kq ka kb kc ks ke kf kg ha bi translated">上面写的持久函数的输出如下，</p><figure class="la lb lc ld fd le er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ms"><img src="../Images/b385d71ad2729e94642d9979731dd09a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9_7nI23kFYooWVxv763QWA.png"/></div></div></figure><h1 id="a3bd" class="il im hh bd in io kt iq ir is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji bi translated">结论:</h1><p id="166c" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">Azure持久功能为我们提供了对运行工作流的更多控制。这个框架为我们管理可靠性、状态管理和跟踪。</p></div></div>    
</body>
</html>