<html>
<head>
<title>Valet Beats the OS X Keychain Access Control List Zero-Day Vulnerability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代客击败OS X钥匙链访问控制列表零日漏洞</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/valet-beats-the-os-x-keychain-access-control-list-zero-day-vulnerability-3c45840c5b7f?source=collection_archive---------2-----------------------#2016-06-19">https://medium.com/square-corner-blog/valet-beats-the-os-x-keychain-access-control-list-zero-day-vulnerability-3c45840c5b7f?source=collection_archive---------2-----------------------#2016-06-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="eea5" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">我们如何使用测试驱动开发来复制攻击媒介并强化我们的代码来对抗它</h2></div><blockquote class="iw"><p id="19ff" class="ix iy hh bd iz ja jb jc jd je jf jg dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jh" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="da3b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc jg ha bi translated"><em class="kd">写的</em> <a class="ke kf ge" href="https://medium.com/u/5755ab427632?source=post_page-----3c45840c5b7f--------------------------------" rel="noopener" target="_blank">写的<em class="kd">丹费德曼</em> </a> <em class="kd">。</em></p><h1 id="d691" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">世界着火了</h1><p id="f6ea" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc jg ha bi translated"><a class="ae jh" href="http://www.theregister.co.uk/2015/06/17/apple_hosed_boffins_drop_0day_mac_ios_research_blitzkrieg" rel="noopener ugc nofollow" target="_blank">6月17日，The Register报告</a>iOS和OS X钥匙链中存在一个零日漏洞，危及储存在钥匙链中的安全数据。这篇文章声称，写入钥匙链的数据可能会被恶意应用程序读取。在Square，我们编写移动资金的iOS代码。<a class="ae jh" href="https://squareup.com/security" rel="noopener ugc nofollow" target="_blank">安全性</a>始终是我们的第一要务，我们非常重视这些声明。如果这篇文章的断言是正确的，世界正在着火。</p><p id="675b" class="pw-post-body-paragraph ji jj hh jk b jl ld ii jn jo le il jq jr lf jt ju jv lg jx jy jz lh kb kc jg ha bi translated">当我们在太平洋时间上午8点后意识到这个漏洞时，我们立即打开了描述攻击的<a class="ae jh" href="https://drive.google.com/file/d/0BxxXk1d3yyuZOFlsdkNMSGswSGs/view" rel="noopener ugc nofollow" target="_blank">文件。我们发现攻击的工作原理如下:</a></p><ol class=""><li id="af53" class="li lj hh jk b jl ld jo le jr lk jv ll jz lm jg ln lo lp lq bi translated">恶意应用程序会在钥匙串中搜索良性应用程序写入的密钥。恶意应用程序可以看到密钥的存在，但无法读取相关的秘密值。</li><li id="03c1" class="li lj hh jk b jl lr jo ls jr lt jv lu jz lv jg ln lo lp lq bi translated">恶意应用程序会删除良性应用程序写入的密钥。</li><li id="5115" class="li lj hh jk b jl lr jo ls jr lt jv lu jz lv jg ln lo lp lq bi translated">然后，恶意应用程序将密钥添加回不带值的钥匙串，并将自己和良性应用程序添加到密钥的<a class="ae jh" href="https://developer.apple.com/library/mac/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html#//apple_ref/doc/uid/TP30000897-CH204-CJBIBIBC" rel="noopener ugc nofollow" target="_blank">访问控制列表</a> (ACL)，从而允许恶意应用程序读取良性应用程序后来写入这些密钥的任何秘密。</li></ol><p id="13b3" class="pw-post-body-paragraph ji jj hh jk b jl ld ii jn jo le il jq jr lf jt ju jv lg jx jy jz lh kb kc jg ha bi translated">在这一点上，我们可以松一口气了:访问控制列表只存在于Mac OS X——不存在于iOS——所以尽管标题如此，<strong class="jk hi">我们的应用程序并不容易受到攻击。然而，两周前我们刚刚开源了<a class="ae jh" href="https://corner.squareup.com/2015/06/valet.html" rel="noopener ugc nofollow" target="_blank">代客</a>，一个跨平台的钥匙链包装器，它的OS X组件很容易受到攻击。这对我们来说是不可接受的，所以我们加强了对这次攻击的防范。</strong></p><h1 id="e992" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">有毒的工具</h1><p id="2022" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc jg ha bi translated">Apple的钥匙串只提供三种更新钥匙串的工具:添加、更新和删除。但我们现在知道，在OS X，更新本身就不安全。我们不能相信Keychain中的现有密钥没有被破坏的访问控制列表。因此，我们只剩下添加和删除。</p><p id="5e30" class="pw-post-body-paragraph ji jj hh jk b jl ld ii jn jo le il jq jr lf jt ju jv lg jx jy jz lh kb kc jg ha bi translated">解决方案似乎显而易见。当更改钥匙串中某个项目的值时，不要更新现有的钥匙串条目，而是删除现有的项目，然后添加一个新项目。</p><p id="58e6" class="pw-post-body-paragraph ji jj hh jk b jl ld ii jn jo le il jq jr lf jt ju jv lg jx jy jz lh kb kc jg ha bi translated">但是<a class="ae jh" href="https://developer.apple.com/library/mac/documentation/Security/Reference/keychainservices/index.html#//apple_ref/c/func/SecKeychainItemDelete" rel="noopener ugc nofollow" target="_blank">苹果的文档</a>说得很清楚:不要先删除再添加——永远更新。为什么？因为“当您删除钥匙串项目时，您会丢失用户或其他应用程序添加的任何访问控制和信任设置。”虽然这听起来不吉利，但这正是我们想要的效果。更好的是，这个警告不适用于Valet，它使用安全的<a class="ae jh" href="https://github.com/square/Valet/blob/master/README.md#sharing-secrets-among-multiple-applications" rel="noopener ugc nofollow" target="_blank">共享访问组</a>而不是ACL来共享OS X和iOS上的钥匙串值。</p><h1 id="f257" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">检验假设</h1><p id="226d" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc jg ha bi translated">我们的第一步是编写一个单元测试来检验我们的假设。我们希望测试尽可能模拟攻击；因此，我们首先将一个密钥插入在ACL中有多个应用程序的钥匙链中。使用与我们的测试VALValet相同的基本查询来添加这个受损的密钥，以便我们的Valet能够读取和写入受损的密钥。</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="5f11" class="mf kh hh mb b fi mg mh l mi mj">VALValet <strong class="mb hi">*</strong>valet <strong class="mb hi">=</strong> [[VALValet alloc] initWithIdentifier:@"MacOSVulnTest" accessibility:VALAccessibilityWhenUnlocked];<br/>    <br/>NSString <strong class="mb hi">*const</strong> vulnKey <strong class="mb hi">=</strong> @"AccessControlListVulnTestKey";<br/>NSString <strong class="mb hi">*const</strong> vulnKeyValue <strong class="mb hi">=</strong> @"AccessControlListVulnTestValue";</span><span id="44f4" class="mf kh hh mb b fi mk mh l mi mj"><em class="kd">// Add an entry to the keychain with an access control list.</em><br/>NSMutableDictionary <strong class="mb hi">*</strong>keychainData <strong class="mb hi">=</strong> [valet.baseQuery mutableCopy];<br/>keychainData[(<strong class="mb hi">__bridge</strong> <strong class="mb hi">id</strong>)kSecAttrAccount] <strong class="mb hi">=</strong> vulnKey;<br/>keychainData[(<strong class="mb hi">__bridge</strong> <strong class="mb hi">id</strong>)kSecValueData] <strong class="mb hi">=</strong> [vulnKeyValue dataUsingEncoding:NSUTF8StringEncoding];<br/>    <br/>SecAccessRef accessList <strong class="mb hi">=</strong> NULL;<br/>SecTrustedApplicationRef trustedAppSelf <strong class="mb hi">=</strong> NULL;<br/>SecTrustedApplicationRef trustedAppSystemUIServer <strong class="mb hi">=</strong> NULL;<br/>XCTAssertEqual(SecTrustedApplicationCreateFromPath(NULL, <strong class="mb hi">&amp;</strong>trustedAppSelf), errSecSuccess);<br/>XCTAssertEqual(SecTrustedApplicationCreateFromPath("/System/Library/CoreServices/SystemUIServer.app", <strong class="mb hi">&amp;</strong>trustedAppSystemUIServer), errSecSuccess);<br/>XCTAssertEqual(SecAccessCreate((<strong class="mb hi">__bridge</strong> CFStringRef)@"Access Control List",<br/>                               (<strong class="mb hi">__bridge</strong> CFArrayRef)@[ (<strong class="mb hi">__bridge</strong> <strong class="mb hi">id</strong>)trustedAppSelf, (<strong class="mb hi">__bridge</strong> <strong class="mb hi">id</strong>)trustedAppSystemUIServer ],<br/>                               <strong class="mb hi">&amp;</strong>accessList),<br/>               errSecSuccess);<br/>    <br/>keychainData[(<strong class="mb hi">__bridge</strong> <strong class="mb hi">id</strong>)kSecAttrAccess] <strong class="mb hi">=</strong> (<strong class="mb hi">__bridge</strong> <strong class="mb hi">id</strong>)accessList;<br/>XCTAssertEqual(SecItemAdd((<strong class="mb hi">__bridge</strong> CFDictionaryRef)keychainData, NULL), errSecSuccess);</span></pre><p id="9d29" class="pw-post-body-paragraph ji jj hh jk b jl ld ii jn jo le il jq jr lf jt ju jv lg jx jy jz lh kb kc jg ha bi translated">一旦我们运行了这段代码，我们就会在钥匙链中看到受损的值。</p><figure class="lw lx ly lz fd mm er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es ml"><img src="../Images/ce407628ec378779edb5987e4ec1d0cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d73JM7ugbNOzkXWV.png"/></div></div></figure><p id="f50a" class="pw-post-body-paragraph ji jj hh jk b jl ld ii jn jo le il jq jr lf jt ju jv lg jx jy jz lh kb kc jg ha bi translated">现在我们有了一个折衷的值，我们更改了OS X上的代客代码，在setObject:forKey:上调用SecItemDelete，然后调用SecItemAdd。然后，我们在测试中添加了以下几行:</p><pre class="lw lx ly lz fd ma mb mc md aw me bi"><span id="3952" class="mf kh hh mb b fi mg mh l mi mj"><em class="kd">// Update the vulnerable keychain value with Valet, and see that we have deleted the existing keychain item (rather than updating it) are therefore no longer vulnerable.</em><br/>NSString <strong class="mb hi">*const</strong> vulnKeyOtherValue <strong class="mb hi">=</strong> @"AccessControlListVulnOtherTestValue";<br/>[valet setString:vulnKeyOtherValue forKey:vulnKey];</span></pre><p id="7875" class="pw-post-body-paragraph ji jj hh jk b jl ld ii jn jo le il jq jr lf jt ju jv lg jx jy jz lh kb kc jg ha bi translated">运行该代码后，我们看到该值不再受到损害。</p><figure class="lw lx ly lz fd mm er es paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="er es ml"><img src="../Images/f97b6b4810b5512e6432c3ce5ad3a975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HnB43BMwPz1ZXKKo.png"/></div></div></figure><p id="b0e5" class="pw-post-body-paragraph ji jj hh jk b jl ld ii jn jo le il jq jr lf jt ju jv lg jx jy jz lh kb kc jg ha bi translated">然后我们添加了<a class="ae jh" href="https://github.com/square/Valet/blob/master/ValetTests/ValetTests.m#L324" rel="noopener ugc nofollow" target="_blank">几行代码</a>以编程方式测试受损的keychain条目确实在setString:forKey上被删除了。我们在我们的Mac OS X Yosemite机器上本地运行了测试——它通过了，我们推了！</p><h1 id="6f32" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">还不清楚</h1><p id="bf45" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc jg ha bi translated">然后令人惊讶的事情发生了。我们的CI测试失败了。具体来说，以编程方式测试受损的钥匙串条目是否已被删除的那一行出现了故障。我们的开发环境和CI环境之间最大的区别是<a class="ae jh" href="https://travis-ci.org/" rel="noopener ugc nofollow" target="_blank">Travis CI</a>——我们为公共GitHub项目提供的CI解决方案——运行的是Mac OS X Mavericks (10.9)而不是Yosemite (10.10)。所以我们在办公室里找到一台还没有升级到Yosemite的机器，在本地运行测试，瞧！我们的测试在同一个地方失败了。</p><p id="a106" class="pw-post-body-paragraph ji jj hh jk b jl ld ii jn jo le il jq jr lf jt ju jv lg jx jy jz lh kb kc jg ha bi translated">经过一些实验和谷歌搜索，我们发现在Yosemite之前，SecItemDelete实际上并没有删除与ACL相关联的钥匙串项目，尽管返回代码表明它已经成功。这意味着我们的补丁无法在10.9上运行，因为当有人恶意地将ACL添加到您的钥匙串项目时，就会出现漏洞。</p><p id="18c9" class="pw-post-body-paragraph ji jj hh jk b jl ld ii jn jo le il jq jr lf jt ju jv lg jx jy jz lh kb kc jg ha bi translated">我们在10.9版本的机器上简单地试验了使用SecKeychainItemDelete(它确实能够删除带有ACL的项目)，但是随后发现SecKeychainItem*和SecItem*不能很好地配合使用。因此，我们没有使用SecKeychainItem*为10.9重写所有的代客，而是将代客的最低版本提升到10.10。</p><h1 id="70b6" class="kg kh hh bd ki kj kk kl km kn ko kp kq in kr io ks iq kt ir ku it kv iu kw kx bi translated">打补丁了！</h1><p id="f5ba" class="pw-post-body-paragraph ji jj hh jk b jl ky ii jn jo kz il jq jr la jt ju jv lb jx jy jz lc kb kc jg ha bi translated">在意识到这个漏洞后仅仅8个小时，我们就成功地为代客打了补丁。在Mac OS X上使用代客服务的开发者对黑客攻击免疫。</p><p id="f43b" class="pw-post-body-paragraph ji jj hh jk b jl ld ii jn jo le il jq jr lf jt ju jv lg jx jy jz lh kb kc jg ha bi translated">你觉得我们错过了什么吗？通过向<a class="ae jh" href="https://github.com/square/Valet/issues" rel="noopener ugc nofollow" target="_blank">提交问题</a>或向<a class="ae jh" href="https://github.com/square/Valet/pulls" rel="noopener ugc nofollow" target="_blank">提交针对<a class="ae jh" href="https://github.com/square/Valet" rel="noopener ugc nofollow" target="_blank">代客</a>的公关</a>来通知我们。如果您有兴趣为10.9版本创建SecKeychainItem*解决方案，我们希望收到您的来信！</p></div><div class="ab cl mt mu go mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ha hb hc hd he"><div class="lw lx ly lz fd na"><a rel="noopener follow" target="_blank" href="/@dfed"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hi fi z dy nf ea eb ng ed ef hg bi translated">丹·费德曼</h2><div class="nh l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">请关注丹·费德曼在Medium上的最新活动。57个人在关注丹·费德曼，看看他们的故事…</h3></div><div class="ni l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">medium.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no mr na"/></div></div></a></div></div></div>    
</body>
</html>