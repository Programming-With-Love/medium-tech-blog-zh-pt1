<html>
<head>
<title>Understanding Program Memories — from exploitation point of view</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从利用的角度理解程序存储器</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/understanding-program-memories-from-exploitation-point-of-view-822a1496dc26?source=collection_archive---------4-----------------------#2018-07-30">https://medium.com/walmartglobaltech/understanding-program-memories-from-exploitation-point-of-view-822a1496dc26?source=collection_archive---------4-----------------------#2018-07-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/db6ca1c8d35d3891e5ffb2bb8017d5a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tTiWl4ATPrvvc04k"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@hopehousepress?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hope House Press</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e085" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从内存中二进制文件的组织和这些二进制文件的汇编代码开始。我们需要理解ELF的概念。所以我将首先提到小精灵，然后我将移动到集合。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="edf9" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">极低频</h1><blockquote class="kx ky kz"><p id="0ac1" class="iu iv la iw b ix iy iz ja jb jc jd je lb jg jh ji lc jk jl jm ld jo jp jq jr ha bi translated"><em class="hh">在计算中，可执行和可链接格式(ELF，以前称为可扩展链接格式)，是可执行文件、目标代码、共享库和核心转储的通用标准文件格式。</em></p></blockquote><p id="5edb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你没想到吗？别担心。我来简化一下。</p><p id="4998" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">ELF基本上是一种指定代码(可执行或可链接的二进制代码)如何进入内存的格式。ELF头包含了很多关于ELF文件内容的信息。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="0245" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可以使用下面的命令来查看编译上述代码生成的ELF文件的头文件。<br/> <code class="du lk ll lm ln b">readelf -h ./function_call</code></p><pre class="le lf lg lh fd lo ln lp lq aw lr bi"><span id="0232" class="ls ka hh ln b fi lt lu l lv lw">ELF Header:<br/>  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00<br/>  Class:                             ELF32<br/>  Data:                              2's complement, little endian<br/>  Version:                           1 (current)<br/>  OS/ABI:                            UNIX - System V<br/>  ABI Version:                       0<br/>  Type:                              EXEC (Executable file)<br/>  Machine:                           Intel 80386<br/>  Version:                           0x1<br/>  Entry point address:               0x8048310<br/>  Start of program headers:          52 (bytes into file)<br/>  Start of section headers:          6860 (bytes into file)<br/>  Flags:                             0x0<br/>  Size of this header:               52 (bytes)<br/>  Size of program headers:           32 (bytes)<br/>  Number of program headers:         9<br/>  Size of section headers:           40 (bytes)<br/>  Number of section headers:         36<br/>  Section header string table index: 33</span></pre><p id="fb88" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在请注意两件事，它们对开发也很重要:</p><ol class=""><li id="66ff" class="lx ly hh iw b ix iy jb jc jf lz jj ma jn mb jr mc md me mf bi translated"><strong class="iw hi">类型:</strong> EXEC，意思是这个特殊的二进制文件是可执行的，而不是可链接的。</li><li id="e524" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated"><strong class="iw hi"> Data: </strong> 2的补码，<strong class="iw hi"> little endian </strong>，意思是这个文件是为使用little endian表示法的机器编译的。<a class="ae it" href="https://en.wikipedia.org/wiki/Endianness" rel="noopener ugc nofollow" target="_blank">它们是什么？</a></li></ol><h1 id="89a5" class="jz ka hh bd kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw bi translated">ELF文件如何在内存中查找？</h1><pre class="le lf lg lh fd lo ln lp lq aw lr bi"><span id="bc0f" class="ls ka hh ln b fi lt lu l lv lw">                        +---------------+ Highest Address 0xffffffff<br/>                        | cmd line args |<br/>                        | env Variable  |<br/>                        +---------------+<br/>                        |     STACK     |<br/>                        +--+------------+<br/>                        |  |            |<br/>                        |  |            |<br/>                        |  v         ^  |<br/>                        |            |  |<br/>                        |            |  |<br/>                        +------------+--+<br/>                        |     HEAP      |<br/>                        +---------------+<br/>                        | Uninitialized |<br/>                        |   Data(BSS)   |<br/>                        +---------------+<br/>                        |  Initialized  |<br/>                        |     Data      |<br/>                        +---------------+<br/>                        |   Read Only   |<br/>                        |     data      |<br/>                        |       +       |<br/>                        |     code      |<br/>                        +---------------+ Lowest Address 0X00000000</span></pre><p id="4360" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上图显示了任何32位二进制文件的4GB虚拟地址空间在加载到内存中时的样子。为了便于理解，我按照自上而下的顺序绘制了堆栈，即最高地址在顶部，最低地址在底部。让我们了解不同的部分(从上往下):</p><ol class=""><li id="4b07" class="lx ly hh iw b ix iy jb jc jf lz jj ma jn mb jr mc md me mf bi translated">第一部分存储命令行参数和在程序执行期间传递给程序的环境变量。</li><li id="cb39" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated"><strong class="iw hi">堆栈</strong>:存储函数内部创建的动态变量。<strong class="iw hi">不要把自己和*alloc函数族生成的动态变量搞混了。</strong>程序中的每个变量都是动态的，也就是说，每个变量只在运行时被分配内存。函数中通常声明的变量被存储到堆栈中。这是以相反的顺序生长的。从最高地址到最低地址。</li><li id="08de" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated"><strong class="iw hi">堆</strong>:由<strong class="iw hi"> *alloc </strong>函数族创建的动态变量。</li><li id="585f" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated"><strong class="iw hi"> BSS </strong>:这个部分存储未初始化的<strong class="iw hi">(全局+静态)</strong>变量。它们被自动初始化为<strong class="iw hi"> 0 </strong>。</li><li id="90ab" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated">下一部分存储变量(<strong class="iw hi">全局+静态</strong>)，它们被初始化为某个值。</li><li id="c8d3" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated">最后一段用二进制语言存储程序的所有<strong class="iw hi">只读</strong>变量和<strong class="iw hi">代码。</strong></li></ol><h1 id="9b2d" class="jz ka hh bd kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw bi translated">函数调用期间堆栈的组织。</h1><p id="849c" class="pw-post-body-paragraph iu iv hh iw b ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn mu jp jq jr ha bi translated">在函数调用过程中使用堆栈来保存调用函数的状态，这样当它从被调用函数返回时就可以继续正常执行。这是函数调用后堆栈的样子。</p><pre class="le lf lg lh fd lo ln lp lq aw lr bi"><span id="f9c9" class="ls ka hh ln b fi lt lu l lv lw">                        +   Previous function  |<br/>                        |     Stack frame      |<br/>                        |                      |<br/>                        +----------------------+ &lt;--- previous stack<br/>                        |Space for return value|<br/>                        +----------------------+<br/>                        |Arguments for function|<br/>                        +----------------------+<br/>                        |    return address    |<br/>                        +----------------------+<br/>                        |     saved $ebp       |<br/>                        +----------------------+<br/>                        |                      | &lt;---  padding <br/>                        +----------------------+<br/>                        |    local variables   |<br/>                        |                      |<br/>                        |                      |<br/>                        |                      |<br/>                        |                      |<br/>                        +----------------------+<br/>                        |                      |<br/>                        |                      |<br/>                        |     unused space     |<br/>                        +                      +<!-- --> </span></pre></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="48e3" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">堆栈如何增长:</h1><p id="965f" class="pw-post-body-paragraph iu iv hh iw b ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn mu jp jq jr ha bi translated">现在让我们试着理解一下<code class="du lk ll lm ln b">$ebp</code>和<code class="du lk ll lm ln b">$esp</code>的用途。以及函数调用如何在堆栈中增长。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="mv lj l"/></div></figure><ol class=""><li id="c11e" class="lx ly hh iw b ix iy jb jc jf lz jj ma jn mb jr mc md me mf bi translated"><strong class="iw hi"> esp </strong>:如图所示，堆栈指针或<strong class="iw hi"> esp </strong>会在每次堆栈推送操作后不断变化。它用于保持堆栈顶部的指针(顶部向下移动)。</li><li id="570d" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated"><strong class="iw hi"> ebp </strong>:在运行时，变量没有名字。它们被存储为对堆栈帧底部的引用。这个基数由ebp寄存器指向。这就是为什么当函数调用另一个函数时，<strong class="iw hi"> ebp </strong>寄存器的值被保存到堆栈中，并且<strong class="iw hi"> ebp </strong>寄存器可用于存储新的堆栈帧。</li></ol><h1 id="4e1d" class="jz ka hh bd kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw bi translated">函数调用的汇编代码</h1><p id="4fbc" class="pw-post-body-paragraph iu iv hh iw b ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn mu jp jq jr ha bi translated"><strong class="iw hi">汇编语言</strong>可以想象就在机器语言之上。像C这样的高级语言首先被编译成汇编语言，然后用汇编程序翻译成机器语言。</p><p id="491c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看一个函数调用代码的例子。您可以使用下面的命令来查看上面编译的C程序的汇编代码。<br/> <code class="du lk ll lm ln b">objdump -d ./function_call</code></p><pre class="le lf lg lh fd lo ln lp lq aw lr bi"><span id="827d" class="ls ka hh ln b fi lt lu l lv lw">0804840b &lt;foo&gt;:<br/> 804840b:	55                   	push   %ebp<br/> 804840c:	89 e5                	mov    %esp,%ebp<br/> 804840e:	83 ec 08             	sub    $0x8,%esp<br/> 8048411:	83 ec 0c             	sub    $0xc,%esp<br/> 8048414:	68 d0 84 04 08       	push   $0x80484d0<br/> 8048419:	e8 c2 fe ff ff       	call   80482e0 &lt;printf@plt&gt;<br/> 804841e:	83 c4 10             	add    $0x10,%esp<br/> 8048421:	90                   	nop<br/> 8048422:	c9                   	leave  <br/> 8048423:	c3                   	ret    </span><span id="88ea" class="ls ka hh ln b fi mw lu l lv lw">08048424 &lt;main&gt;:<br/> 8048424:	8d 4c 24 04          	lea    0x4(%esp),%ecx<br/> 8048428:	83 e4 f0             	and    $0xfffffff0,%esp<br/> 804842b:	ff 71 fc             	pushl  -0x4(%ecx)<br/> 804842e:	55                   	push   %ebp<br/> 804842f:	89 e5                	mov    %esp,%ebp<br/> 8048431:	51                   	push   %ecx<br/> 8048432:	83 ec 04             	sub    $0x4,%esp<br/> 8048435:	e8 d1 ff ff ff       	call   804840b &lt;foo&gt;<br/> 804843a:	b8 00 00 00 00       	mov    $0x0,%eax<br/> 804843f:	83 c4 04             	add    $0x4,%esp<br/> 8048442:	59                   	pop    %ecx<br/> 8048443:	5d                   	pop    %ebp<br/> 8048444:	8d 61 fc             	lea    -0x4(%ecx),%esp<br/> 8048447:	c3                   	ret    <br/> 8048448:	66 90                	xchg   %ax,%ax<br/> 804844a:	66 90                	xchg   %ax,%ax<br/> 804844c:	66 90                	xchg   %ax,%ax<br/> 804844e:	66 90                	xchg   %ax,%ax</span></pre><p id="656f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里我只复制了main和foo函数的代码。观察main对foo函数的调用。</p><ol class=""><li id="fe4e" class="lx ly hh iw b ix iy jb jc jf lz jj ma jn mb jr mc md me mf bi translated">Main似乎在函数调用前什么都不推。这意味着foo不接受任何参数。</li><li id="7b67" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated">Call指令会要求CPU将返回地址(指令指针旁边的地址)保存到堆栈中。这是由<strong class="iw hi">调用</strong>指令完成的，所以在代码中是不可见的。</li><li id="e9e9" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated"><strong class="iw hi"> foo </strong>的第一条指令是将<strong class="iw hi"> $ebp </strong>推入堆栈。</li><li id="9b8c" class="lx ly hh iw b ix mg jb mh jf mi jj mj jn mk jr mc md me mf bi translated">直接指令将是指向<strong class="iw hi"> $ebp </strong>以指向<strong class="iw hi"> $esp </strong>。<br/>这些指令可以分为三个部分，在下面的流程中解释。</li></ol><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="li lj l"/></div></figure><h1 id="ad55" class="jz ka hh bd kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks mp ku kv kw bi translated">缓冲器的汇编代码</h1><p id="bc98" class="pw-post-body-paragraph iu iv hh iw b ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn mu jp jq jr ha bi translated">在前面的<strong class="iw hi">汇编语言</strong>小节代码中，我提到了简单函数调用的代码是什么样子的。在本节中，我们将展示缓冲区在<strong class="iw hi"> asm </strong>代码中的样子。</p><figure class="le lf lg lh fd ii"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="d48c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">装配中相应的<strong class="iw hi"> foo </strong>功能。</p><pre class="le lf lg lh fd lo ln lp lq aw lr bi"><span id="5a33" class="ls ka hh ln b fi lt lu l lv lw">0804840b &lt;foo&gt;:<br/> 804840b:	55                   	push   %ebp<br/> 804840c:	89 e5                	mov    %esp,%ebp<br/> 804840e:	83 ec 18             	sub    $0x18,%esp<br/> 8048411:	83 ec 0c             	sub    $0xc,%esp<br/> 8048414:	68 d0 84 04 08       	push   $0x80484d0<br/> 8048419:	e8 c2 fe ff ff       	call   80482e0 &lt;printf@plt&gt;<br/> 804841e:	83 c4 10             	add    $0x10,%esp<br/> 8048421:	90                   	nop<br/> 8048422:	c9                   	leave  <br/> 8048423:	c3                   	ret</span></pre><p id="6999" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意，两个<strong class="iw hi">子</strong>调用。</p><pre class="le lf lg lh fd lo ln lp lq aw lr bi"><span id="2220" class="ls ka hh ln b fi lt lu l lv lw">804840e:	83 ec 18             	sub    $0x18,%esp<br/>8048411:	83 ec 0c             	sub    $0xc,%esp</span></pre><p id="7c37" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们可以忽略第一个<strong class="iw hi"> sub </strong>调用，但是<strong class="iw hi">第二个</strong>调用是重要的。来自esp的第二个子调用实际上更新了堆栈，为<strong class="iw hi"> ch </strong>缓冲区分配空间。注意，正如我提到的，名称在<strong class="iw hi"> asm </strong>中什么都不是。它们只是来自$ <strong class="iw hi"> esp </strong>或$ <strong class="iw hi"> ebp </strong>的引用。</p></div></div>    
</body>
</html>