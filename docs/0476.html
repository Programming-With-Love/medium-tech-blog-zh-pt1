<html>
<head>
<title>The suspend modifier — under the hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“暂停”修改器—在引擎盖下</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/the-suspend-modifier-under-the-hood-b7ce46af624f?source=collection_archive---------0-----------------------#2020-03-24">https://medium.com/androiddevelopers/the-suspend-modifier-under-the-hood-b7ce46af624f?source=collection_archive---------0-----------------------#2020-03-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/7dbdff2f6243de6e06b0425e311eb83b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5QpP21pn8EmDouGf0jAK_Q.png"/></div></div></figure><div class=""/><div class=""><h2 id="0cad" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated">科特林词汇:协程</h2></div><p id="069d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">科特林协同程序在我们作为Android开发者的日常生活中引入了<strong class="jj ht"> <em class="kd">暂停修饰符</em> </strong>。你想知道引擎盖下发生了什么吗？编译器如何转换代码以能够暂停和恢复协程的执行？</p><p id="f25b" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">了解这一点将有助于您更好地理解为什么挂起函数在它启动的所有工作完成之前不会返回，以及代码如何在不阻塞线程的情况下挂起。</p><blockquote class="ke kf kg"><p id="58c1" class="jh ji kd jj b jk jl it jm jn jo iw jp kh jr js jt ki jv jw jx kj jz ka kb kc ha bi translated"><strong class="jj ht">TL；DR；Kotlin编译器将为每个挂起函数创建一个状态机，为我们管理协程的执行！</strong></p></blockquote><p id="334a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">📚不熟悉Android上的协程？查看这些协同程序代码实验室:</p><ul class=""><li id="e443" class="kk kl hs jj b jk jl jn jo jq km ju kn jy ko kc kp kq kr ks bi translated"><a class="ae kt" href="https://codelabs.developers.google.com/codelabs/kotlin-coroutines/#0" rel="noopener ugc nofollow" target="_blank">在你的Android应用中使用协程</a></li><li id="9c82" class="kk kl hs jj b jk ku jn kv jq kw ju kx jy ky kc kp kq kr ks bi translated"><a class="ae kt" href="https://codelabs.developers.google.com/codelabs/advanced-kotlin-coroutines/#0" rel="noopener ugc nofollow" target="_blank">具有Kotlin流和实时数据的高级协同程序</a></li></ul><p id="37c5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果你喜欢看关于这个的视频，看看这个:</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="ld le l"/></div></figure><h1 id="96c0" class="lf lg hs bd lh li lj lk ll lm ln lo lp iy lq iz lr jb ls jc lt je lu jf lv lw bi translated">协程101</h1><p id="41a4" class="pw-post-body-paragraph jh ji hs jj b jk lx it jm jn ly iw jp jq lz js jt ju ma jw jx jy mb ka kb kc ha bi translated">协程简化了Android上的异步操作。正如在<a class="ae kt" href="https://developer.android.com/kotlin/coroutines" rel="noopener ugc nofollow" target="_blank">文档</a>中所解释的，我们可以使用它们来管理异步任务，否则这些任务可能会阻塞主线程并导致应用程序冻结。</p><p id="f542" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">协程也有助于用命令式代码替换基于回调的API。例如，看看这个使用回调的异步代码:</p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="0b5b" class="mh lg hs md b fi mi mj l mk ml">// Simplified code that only considers the happy path<br/>fun loginUser(userId: String, password: String, userResult: Callback&lt;User&gt;) {<br/>  // Async callbacks<br/>  userRemoteDataSource.logUserIn { user -&gt;<br/>    // Successful network request<br/>    userLocalDataSource.logUserIn(user) { userDb -&gt;<br/>      // Result saved in DB<br/>      userResult.success(userDb)<br/>    }<br/>  }<br/>}</span></pre><p id="0ecc" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">可以使用协程将这些回调转换为顺序函数调用:</p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="7921" class="mh lg hs md b fi mi mj l mk ml"><strong class="md ht">suspend</strong> fun loginUser(userId: String, password: String): User {<br/>  val user = userRemoteDataSource.logUserIn(userId, password)<br/>  val userDb = userLocalDataSource.logUserIn(user)<br/>  return userDb<br/>}</span></pre><p id="4ee1" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在协程代码中，我们向函数添加了<strong class="jj ht"> suspend </strong>修饰符。这告诉编译器这个函数需要在协程中执行。作为一名开发人员，您可以将挂起函数视为一个常规函数，它的执行可能会被挂起，并在某个时候恢复。</p><p id="f52e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">与回调不同，协程提供了一种在线程间交换和处理异常的简单方法。</p><p id="2d21" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">但是，当我们将函数标记为<em class="kd">暂停</em>时，编译器实际上在做什么呢？</p><h1 id="21c1" class="lf lg hs bd lh li lj lk ll lm ln lo lp iy lq iz lr jb ls jc lt je lu jf lv lw bi translated">悬挂在引擎盖下</h1><p id="758d" class="pw-post-body-paragraph jh ji hs jj b jk lx it jm jn ly iw jp jq lz js jt ju ma jw jx jy mb ka kb kc ha bi translated">回到<code class="du mm mn mo md b">loginUser</code>暂停函数，注意它调用的其他函数也是暂停函数:</p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="f844" class="mh lg hs md b fi mi mj l mk ml"><strong class="md ht">suspend</strong> fun loginUser(userId: String, password: String): User {<br/>  val user = userRemoteDataSource.logUserIn(userId, password)<br/>  val userDb = userLocalDataSource.logUserIn(user)<br/>  return userDb<br/>}</span><span id="9a58" class="mh lg hs md b fi mp mj l mk ml">// UserRemoteDataSource.kt<br/><strong class="md ht">suspend</strong> fun logUserIn(userId: String, password: String): User</span><span id="9bd3" class="mh lg hs md b fi mp mj l mk ml">// UserLocalDataSource.kt<br/><strong class="md ht">suspend</strong> fun logUserIn(userId: String): UserDb</span></pre><p id="46d7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">简而言之，Kotlin编译器会使用一个<a class="ae kt" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank"> <strong class="jj ht">有限状态机</strong> </a>(我们将在后面介绍)将挂起函数转换成回调的优化版本。</p><p id="da04" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">你答对了，<strong class="jj ht">编译器会为你写那些回调函数</strong>！</p><h2 id="210f" class="mh lg hs bd lh mq mr ms ll mt mu mv lp jq mw mx lr ju my mz lt jy na nb lv nc bi translated">延续接口</h2><p id="2dbd" class="pw-post-body-paragraph jh ji hs jj b jk lx it jm jn ly iw jp jq lz js jt ju ma jw jx jy mb ka kb kc ha bi translated">挂起函数相互通信的方式是通过<code class="du mm mn mo md b"><a class="ae kt" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation/index.html" rel="noopener ugc nofollow" target="_blank">Continuation</a></code>对象。一个<code class="du mm mn mo md b"><a class="ae kt" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/coroutines/Continuation.kt" rel="noopener ugc nofollow" target="_blank">Continuation</a></code>只是一个带有一些额外信息的通用回调接口。正如我们将在后面看到的，它将代表一个挂起函数的生成状态机。</p><p id="a3a8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">让我们来看看它的定义:</p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="69c7" class="mh lg hs md b fi mi mj l mk ml">interface Continuation&lt;in T&gt; {<br/>  public val context: CoroutineContext<br/>  public fun resumeWith(value: Result&lt;T&gt;)<br/>}</span></pre><ul class=""><li id="437d" class="kk kl hs jj b jk jl jn jo jq km ju kn jy ko kc kp kq kr ks bi translated"><code class="du mm mn mo md b">context</code>将是在该延续中使用的<code class="du mm mn mo md b">CoroutineContext</code>。</li><li id="a98f" class="kk kl hs jj b jk ku jn kv jq kw ju kx jy ky kc kp kq kr ks bi translated"><code class="du mm mn mo md b">resumeWith</code>用<code class="du mm mn mo md b"><a class="ae kt" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/stdlib-stubs/src/Result.kt" rel="noopener ugc nofollow" target="_blank">Result</a></code>恢复协程的执行，它可以包含一个导致挂起的计算结果值，也可以包含一个异常。</li></ul><p id="fa26" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">注意:从Kotlin 1.3开始，你也可以使用扩展函数<code class="du mm mn mo md b"><a class="ae kt" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/resume.html" rel="noopener ugc nofollow" target="_blank">resume</a>(value: T)</code>和<code class="du mm mn mo md b"><a class="ae kt" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/resume-with-exception.html" rel="noopener ugc nofollow" target="_blank">resumeWithException</a>(exception: Throwable)</code>，它们是<code class="du mm mn mo md b">resumeWith</code>调用的特殊版本。</p><p id="ddfc" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">编译器将在函数签名中用额外的参数<code class="du mm mn mo md b">completion</code>(类型<code class="du mm mn mo md b">Continuation</code>)替换suspend修饰符，该函数签名将用于将挂起函数的结果传递给调用它的协程:</p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="eff2" class="mh lg hs md b fi mi mj l mk ml">fun loginUser(userId: String, password: String, <strong class="md ht">completion: Continuation&lt;Any?&gt;</strong>) {<br/>  val user = userRemoteDataSource.logUserIn(userId, password)<br/>  val userDb = userLocalDataSource.logUserIn(user)<br/>  <strong class="md ht">completion.resume(userDb)</strong><br/>}</span></pre><p id="c8c5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了简单起见，我们的例子将返回<code class="du mm mn mo md b">Unit</code>而不是<code class="du mm mn mo md b">User</code>。<code class="du mm mn mo md b">User</code>对象将被“返回”到添加的<code class="du mm mn mo md b">Continuation</code>参数中。</p><p id="c82c" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">挂起函数的字节码实际上返回了<code class="du mm mn mo md b">Any?</code>，因为它是<code class="du mm mn mo md b">T | COROUTINE_SUSPENDED</code>的联合类型。这允许函数在可能的时候同步返回。</p><blockquote class="ke kf kg"><p id="286b" class="jh ji kd jj b jk jl it jm jn jo iw jp kh jr js jt ki jv jw jx kj jz ka kb kc ha bi translated"><strong class="jj ht">注意</strong>:如果你用suspend修饰符标记一个不调用其他suspend函数的函数，编译器会添加额外的Continuation参数，但不会对它做任何事情，函数体的字节码看起来就像一个常规函数。</p></blockquote><p id="dda2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在其他地方也可以看到<code class="du mm mn mo md b">Continuation</code>界面:</p><ul class=""><li id="bcb3" class="kk kl hs jj b jk jl jn jo jq km ju kn jy ko kc kp kq kr ks bi translated">当使用<code class="du mm mn mo md b"><a class="ae kt" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/suspend-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCoroutine</a></code>或<code class="du mm mn mo md b"><a class="ae kt" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCancellableCoroutine</a></code>将基于回调的API转换为协同程序时(您应该总是更喜欢使用这两种方法)，您可以直接与<code class="du mm mn mo md b">Continuation</code>对象交互，以恢复在运行作为参数传递的代码块后被挂起的协同程序。</li><li id="08c0" class="kk kl hs jj b jk ku jn kv jq kw ju kx jy ky kc kp kq kr ks bi translated">您可以在挂起函数上使用<code class="du mm mn mo md b"><a class="ae kt" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/start-coroutine.html" rel="noopener ugc nofollow" target="_blank">startCoroutine</a></code>扩展函数来启动协程。它将一个<code class="du mm mn mo md b">Continuation</code>对象作为参数，当新的协程以结果或异常结束时，该对象将被调用。</li></ul><h2 id="f006" class="mh lg hs bd lh mq mr ms ll mt mu mv lp jq mw mx lr ju my mz lt jy na nb lv nc bi translated">使用不同的调度程序</h2><p id="38da" class="pw-post-body-paragraph jh ji hs jj b jk lx it jm jn ly iw jp jq lz js jt ju ma jw jx jy mb ka kb kc ha bi translated">您可以在不同的调度程序之间切换，以便在不同的线程上执行计算。Kotlin如何知道在哪里恢复挂起的计算？</p><p id="297a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">有一个名为<code class="du mm mn mo md b"><a class="ae kt" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/internal/DispatchedContinuation.kt" rel="noopener ugc nofollow" target="_blank">DispatchedContinuation</a></code>的<code class="du mm mn mo md b">Continuation</code>子类型，它的resume函数调用<code class="du mm mn mo md b">CoroutineContext</code>中可用的<code class="du mm mn mo md b">Dispatcher</code>。除了<code class="du mm mn mo md b">Dispatchers.Unconfined</code>之外，所有调度程序都将调用dispatch，其<code class="du mm mn mo md b">isDispatchNeeded</code>函数覆盖(在<code class="du mm mn mo md b">dispatch</code>之前调用)总是返回<code class="du mm mn mo md b">false</code>。</p><h1 id="1359" class="lf lg hs bd lh li lj lk ll lm ln lo lp iy lq iz lr jb ls jc lt je lu jf lv lw bi translated">生成的状态机</h1><blockquote class="ke kf kg"><p id="12d2" class="jh ji kd jj b jk jl it jm jn jo iw jp kh jr js jt ki jv jw jx kj jz ka kb kc ha bi translated"><strong class="jj ht">免责声明</strong>:本文剩余部分显示的代码不会与编译器生成的字节码完全匹配。它将是足够精确的Kotlin代码，使您能够理解内部真正发生了什么。这种表示是由Coroutines 1 . 3 . 3版生成的，可能会在库的未来版本中发生变化。</p></blockquote><p id="2414" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Kotlin编译器将识别函数何时可以内部挂起。每个悬挂点将被表示为有限状态机中的一个状态。这些状态由编译器用标签表示:</p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="3df7" class="mh lg hs md b fi mi mj l mk ml">fun loginUser(userId: String, password: String, completion: Continuation&lt;Any?&gt;) {<br/>  // <strong class="md ht">Label 0</strong> -&gt; first execution<br/>  val user = userRemoteDataSource.logUserIn(userId, password)</span><span id="b5f4" class="mh lg hs md b fi mp mj l mk ml">  // <strong class="md ht">Label 1</strong> -&gt; resumes from userRemoteDataSource<br/>  val userDb = userLocalDataSource.logUserIn(user)</span><span id="7a51" class="mh lg hs md b fi mp mj l mk ml">  // <strong class="md ht">Label 2</strong> -&gt; resumes from userLocalDataSource<br/>  completion.resume(userDb)<br/>}</span></pre><p id="10b2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了更好地表示状态机，编译器将使用一个<code class="du mm mn mo md b">when</code>语句来实现不同的状态:</p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="c2ac" class="mh lg hs md b fi mi mj l mk ml">fun loginUser(userId: String, password: String, completion: Continuation&lt;Any?&gt;) {<br/>  when(label) {<br/>    <strong class="md ht">0 -&gt; { // Label 0 -&gt; first execution</strong><br/>        userRemoteDataSource.logUserIn(userId, password)<br/>    }<br/><strong class="md ht">    1 -&gt; { // Label 1 -&gt; resumes from userRemoteDataSource</strong><br/>        userLocalDataSource.logUserIn(user)<br/>    }<br/><strong class="md ht">    2 -&gt; { // Label 2 -&gt; resumes from userLocalDataSource</strong><br/>        completion.resume(userDb)<br/>    }<br/>    else -&gt; throw IllegalStateException(...)<br/>  }<br/>}</span></pre><p id="f74e" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">这个代码是不完整的，因为不同的州没有办法共享信息。编译器将在函数中使用相同的<code class="du mm mn mo md b">Continuation</code>对象来实现。这就是为什么<code class="du mm mn mo md b">Continuation</code>的泛型是<code class="du mm mn mo md b">Any?</code>而不是原函数的返回类型(即<code class="du mm mn mo md b">User</code>)。</p><p id="81a5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">此外，编译器将创建一个私有类，1)保存所需的数据，2)递归调用<code class="du mm mn mo md b">loginUser</code>函数以恢复执行。您可以查看下面生成的类的近似值。</p><blockquote class="ke kf kg"><p id="cb51" class="jh ji kd jj b jk jl it jm jn jo iw jp kh jr js jt ki jv jw jx kj jz ka kb kc ha bi translated"><strong class="jj ht">免责声明</strong>:注释不是由编译器生成的。我添加它们是为了解释它们做什么，并使遵循代码更容易。</p></blockquote><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="cf21" class="mh lg hs md b fi mi mj l mk ml">fun loginUser(<strong class="md ht">userId: String?, password: String?, completion: Continuation&lt;Any?&gt;</strong>) {</span><span id="51d1" class="mh lg hs md b fi mp mj l mk ml">  class <strong class="md ht">LoginUserStateMachine</strong>(<br/>    // completion parameter is the callback to the function <br/>    // that called loginUser<br/>    completion: Continuation&lt;Any?&gt;<br/>  ): <strong class="md ht">CoroutineImpl(completion)</strong> {</span><span id="c091" class="mh lg hs md b fi mp mj l mk ml">    // Local variables of the suspend function<br/>    var user: User? = null<br/>    var userDb: UserDb? = null</span><span id="1448" class="mh lg hs md b fi mp mj l mk ml">    // Common objects for all CoroutineImpls<br/>    var result: Any? = null<br/>    var label: Int = 0</span><span id="f77b" class="mh lg hs md b fi mp mj l mk ml">    // this function calls the loginUser again to trigger the<br/>    // state machine (label will be already in the next state) and<br/>    // result will be the result of the previous state's computation<br/>    override fun invokeSuspend(result: Any?) {<br/>      this.result = result<br/>      <strong class="md ht">loginUser(null, null, this)</strong><br/>    }<br/>  }<br/>  ...<br/>}</span></pre><p id="b9db" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">由于<code class="du mm mn mo md b">invokeSuspend</code>将仅使用<code class="du mm mn mo md b">Continuation</code>对象的信息再次调用<code class="du mm mn mo md b">loginUser</code>，所以<code class="du mm mn mo md b">loginUser</code>函数签名中的其余参数变得可空。此时，编译器只需要添加如何在状态之间移动的信息。</p><p id="ace8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">它需要做的第一件事是知道1)这是第一次调用该函数，还是2)该函数已经从先前的状态恢复。它通过检查传入的延续是否属于类型<code class="du mm mn mo md b">LoginUserStateMachine</code>来实现:</p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="1064" class="mh lg hs md b fi mi mj l mk ml">fun loginUser(userId: String?, password: String?, completion: Continuation&lt;Any?&gt;) {<br/>  ...</span><span id="bcbe" class="mh lg hs md b fi mp mj l mk ml">  val <strong class="md ht">continuation</strong> = completion as? LoginUserStateMachine ?: LoginUserStateMachine(completion)</span><span id="9a86" class="mh lg hs md b fi mp mj l mk ml">  ...<br/>}</span></pre><p id="05e5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果是第一次，它将创建一个新的<code class="du mm mn mo md b">LoginUserStateMachine</code>实例，并将接收到的<code class="du mm mn mo md b">completion</code>实例存储为一个参数，以便它记住如何恢复调用这个实例的函数。如果不是，它将继续执行状态机(挂起功能)。</p><p id="98d9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，让我们看看编译器为在状态之间移动和共享信息而生成的代码。</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="nd le l"/></div></figure><p id="a436" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">花些时间浏览上面的代码，看看是否能发现与前面代码片段的不同之处。让我们看看编译器生成了什么:</p><ul class=""><li id="b3dc" class="kk kl hs jj b jk jl jn jo jq km ju kn jy ko kc kp kq kr ks bi translated"><code class="du mm mn mo md b">when</code>语句的参数是来自<code class="du mm mn mo md b">LoginUserStateMachine</code>实例内部的<code class="du mm mn mo md b">label</code>。</li><li id="f1e7" class="kk kl hs jj b jk ku jn kv jq kw ju kx jy ky kc kp kq kr ks bi translated">每次处理一个新状态时，都会进行一次检查，以防这个函数被挂起时出现故障。</li><li id="fc29" class="kk kl hs jj b jk ku jn kv jq kw ju kx jy ky kc kp kq kr ks bi translated">在调用下一个挂起函数(即<code class="du mm mn mo md b">logUserIn</code>)之前，<code class="du mm mn mo md b">LoginUserStateMachine</code>实例的<code class="du mm mn mo md b">label</code>更新到下一个状态。</li><li id="406c" class="kk kl hs jj b jk ku jn kv jq kw ju kx jy ky kc kp kq kr ks bi translated">当这个状态机内部调用另一个挂起函数时，<code class="du mm mn mo md b">continuation</code>(类型为<code class="du mm mn mo md b">LoginUserStateMachine</code>)的实例作为参数传递。要调用的suspend函数也已经被编译器转换了，它是另一个像这样的状态机，它接受一个continuation对象作为参数！当该挂起功能的状态机完成时，它将恢复该状态机的执行。</li></ul><p id="36c9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">最后一个状态是不同的，因为它必须继续执行调用这个状态的函数，正如您在代码中看到的，它调用存储在<code class="du mm mn mo md b">LoginUserStateMachine</code>中的<code class="du mm mn mo md b">cont</code>变量上的resume(在构造时):</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="nd le l"/></div></figure><p id="ebf6" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如您所见，Kotlin编译器为我们做了很多事情！从这个暂停功能:</p><pre class="kz la lb lc fd mc md me mf aw mg bi"><span id="7fe9" class="mh lg hs md b fi mi mj l mk ml">suspend fun loginUser(userId: String, password: String): User {<br/>  val user = userRemoteDataSource.logUserIn(userId, password)<br/>  val userDb = userLocalDataSource.logUserIn(user)<br/>  return userDb<br/>}</span></pre><p id="2813" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">编译器为我们生成了这一切:</p><figure class="kz la lb lc fd hj"><div class="bz dy l di"><div class="nd le l"/></div></figure></div><div class="ab cl ne nf go ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ha hb hc hd he"><p id="fbd8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">Kotlin编译器将每个挂起函数转换为状态机，每次函数需要挂起时使用回调进行优化。</p><p id="8cd7" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在知道了编译器在幕后做什么，你就能更好地理解为什么一个挂起函数在它启动的所有工作完成之前不会返回。还有，代码如何在不阻塞线程的情况下挂起:函数恢复时需要执行什么的信息存储在<code class="du mm mn mo md b">Continuation</code>对象中！</p></div></div>    
</body>
</html>