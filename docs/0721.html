<html>
<head>
<title>ViewModel: One-off event antipatterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ViewModel:一次性事件反模式</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/viewmodel-one-off-event-antipatterns-16a1da869b95?source=collection_archive---------0-----------------------#2022-06-01">https://medium.com/androiddevelopers/viewmodel-one-off-event-antipatterns-16a1da869b95?source=collection_archive---------0-----------------------#2022-06-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/66972da9cbb417786acf0abc7e4bd731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ROW1i16idpH-rHO-.png"/></div></div></figure><div class=""/><p id="e11e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://developer.android.com/topic/architecture/ui-layer/events#handle-viewmodel-events" rel="noopener ugc nofollow" target="_blank"> ViewModel事件</a>是UI应该执行的源自ViewModel的动作。例如，向用户显示信息性消息，或者在应用程序状态改变时导航到不同的屏幕。</p><p id="d942" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们对ViewModel事件的指导以两种不同的方式坚持己见:</p><ol class=""><li id="9ce4" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">每当ViewModel中出现一次性事件时，<strong class="ir ht">ViewModel应该立即处理该事件，从而导致状态更新</strong>。ViewModel应该只公开应用程序状态。从ViewModel中暴露未被<em class="jx">还原</em>为状态的事件意味着ViewModel不是从这些事件中导出的状态的<a class="ae jn" href="https://en.wikipedia.org/wiki/Single_source_of_truth" rel="noopener ugc nofollow" target="_blank">真值来源</a>；<a class="ae jn" href="https://developer.android.com/jetpack/compose/architecture#udf" rel="noopener ugc nofollow" target="_blank">单向数据流</a> (UDF)描述了只将事件发送给比其生产者寿命更长的消费者的优势。</li><li id="aee5" class="jo jp hs ir b is jy iw jz ja ka je kb ji kc jm jt ju jv jw bi translated">应该使用可观察的数据容器类型公开状态。</li></ol><figure class="ke kf kg kh fd hj er es paragraph-image"><div class="er es kd"><img src="../Images/ee071290563cac9e76edf3592adb18f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*xcdyjos7ZUtZTKb0Tq_glQ.png"/></div><figcaption class="ki kj et er es kk kl bd b be z dx">Following UDF, state flows down from the ViewModel to the UI, and events go up from the UI to the ViewModel</figcaption></figure><p id="9402" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在您的应用程序中，您可能会使用<a class="ae jn" href="https://kotlinlang.org/docs/channels.html" rel="noopener ugc nofollow" target="_blank"> Kotlin通道</a>或其他反应流(如<code class="du km kn ko kp b"><a class="ae jn" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/" rel="noopener ugc nofollow" target="_blank">SharedFlow</a></code>)向UI公开ViewModel事件，或者这可能是您在其他项目中见过的模式。当生产者(<code class="du km kn ko kp b">ViewModel</code>)比消费者(UI—组合或视图)活得长时，这可能是ViewModel事件的情况，<strong class="ir ht">这些API</strong><a class="ae jn" href="https://github.com/Kotlin/kotlinx.coroutines/issues/2886" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">不保证</strong> </a> <strong class="ir ht">这些事件的交付和处理。这对开发者来说会导致错误和未来的问题，而且对大多数应用来说这也是一个不可接受的用户体验</strong>。</p><blockquote class="kq"><p id="84c7" class="kr ks hs bd kt ku kv kw kx ky kz jm dx translated">您应该立即处理ViewModel事件，从而导致UI状态更新。试图使用其他反应式解决方案(如Channel或SharedFlow)将事件公开为对象并不能保证事件的交付和处理。</p></blockquote><h1 id="5a14" class="la lb hs bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">个案研究</h1><p id="b834" class="pw-post-body-paragraph ip iq hs ir b is ly iu iv iw lz iy iz ja ma jc jd je mb jg jh ji mc jk jl jm ha bi translated">这里有一个在应用程序的典型支付流程中实现视图模型的例子。在下面的代码片段中，<code class="du km kn ko kp b">MakePaymentViewModel</code>直接告诉UI在支付请求的结果返回时导航到支付结果屏幕。我们将使用这个例子来探索为什么像这样处理一次性ViewModel事件会带来问题和更高的工程成本。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="dc43" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，用户界面将使用该事件并相应地导航:</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="6dec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上面看到的<code class="du km kn ko kp b">navigateToPaymentResultScreen</code>实现有多个设计缺陷。</p><h1 id="e561" class="la lb hs bd lc ld le lf lg lh li lj lk ll mf ln lo lp mg lr ls lt mh lv lw lx bi translated">反模式1:关于支付完成的状态可能会丢失</h1><p id="b61d" class="pw-post-body-paragraph ip iq hs ir b is ly iu iv iw lz iy iz ja ma jc jd je mb jg jh ji mc jk jl jm ha bi translated">通道<a class="ae jn" href="https://github.com/Kotlin/kotlinx.coroutines/issues/2886" rel="noopener ugc nofollow" target="_blank">不保证</a>事件的交付和处理。因此，<strong class="ir ht">事件可能会丢失，使UI处于不一致的状态</strong>。当UI(消费者)在<code class="du km kn ko kp b">ViewModel</code>(生产者)发送一个事件后立即进入后台并停止<code class="du km kn ko kp b">Channel</code>收集时，就会发生这种情况。对于其他不属于可观察数据持有者类型的API也是如此，比如<code class="du km kn ko kp b">SharedFlow</code>，即使没有消费者监听它们，它们也可以发出事件。</p><p id="5c37" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个反模式，因为在UI层中建模的<em class="jx">支付结果状态</em>不是<strong class="ir ht">持久的</strong>或<strong class="ir ht">原子的</strong>，如果我们从<a class="ae jn" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank"> ACID事务</a>的角度来考虑的话。就存储库而言，支付可能已经成功，但是我们从未进入下一个屏幕。</p><p id="4317" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jx">注意:在发送和接收事件时，可以通过使用</em> <code class="du km kn ko kp b"><em class="jx">Dispatchers.Main.immediate</em></code> <em class="jx">来减轻这种反模式。然而，如果没有通过lint检查强制执行，这个解决方案可能容易出错，因为开发人员很容易忘记它。</em></p><h1 id="b762" class="la lb hs bd lc ld le lf lg lh li lj lk ll mf ln lo lp mg lr ls lt mh lv lw lx bi translated">反模式2:告诉UI采取行动</h1><p id="aa4e" class="pw-post-body-paragraph ip iq hs ir b is ly iu iv iw lz iy iz ja ma jc jd je mb jg jh ji mc jk jl jm ha bi translated">对于支持多种屏幕大小的应用程序，给定ViewModel事件时要执行的UI操作可能会因屏幕大小而异。比如案例分析app在手机上运行时要导航到支付结果屏幕；但如果这款应用在平板电脑上运行，这个动作可以在同一个屏幕的不同部分显示结果。</p><p id="1a1c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">ViewModel应该告诉UI <em class="jx">什么是</em>应用程序状态，UI应该决定<em class="jx">如何</em>反映这一点。视图模型不应该告诉用户界面它应该采取什么动作。</strong></p><h1 id="185e" class="la lb hs bd lc ld le lf lg lh li lj lk ll mf ln lo lp mg lr ls lt mh lv lw lx bi translated">反模式3:不立即处理一次性事件</h1><p id="07d8" class="pw-post-body-paragraph ip iq hs ir b is ly iu iv iw lz iy iz ja ma jc jd je mb jg jh ji mc jk jl jm ha bi translated"><strong class="ir ht">将事件建模为<em class="jx">开火然后忘记</em>——在飞行中——会导致问题。</strong>更难符合<a class="ae jn" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank">酸性属性</a>，因此无法确保尽可能高的数据可靠性和完整性。状态<em class="jx">为</em>，事件<em class="jx">发生</em>。事件处理得越久，问题就变得越难。<strong class="ir ht">对于ViewModel事件，尽快处理事件，并从中生成新的UI状态。</strong></p><p id="dad2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在案例研究中，我们为事件创建了一个对象——表示为一个<code class="du km kn ko kp b">Boolean</code>——并使用一个<code class="du km kn ko kp b">Channel</code>来公开它:</p><pre class="ke kf kg kh fd mi kp mj mk aw ml bi"><span id="e6e1" class="mm lb hs kp b fi mn mo l mp mq"><strong class="kp ht">// Create Channel with the event modeled as a Boolean</strong><br/>val _navigateToPaymentResultScreen = Channel&lt;Boolean&gt;()</span><span id="9bc3" class="mm lb hs kp b fi mr mo l mp mq"><strong class="kp ht">// Trigger event</strong><br/>_navigateToPaymentResultScreen.send(isPaymentSuccessful)</span></pre><p id="ef12" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦你做到了这一点，你就承担了确保一次性交付和处理的责任。如果出于某种原因，您必须将事件建模为对象，请将它的生命周期限制为尽可能短，这样它就不会有机会丢失。</p><p id="e167" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在视图模型中处理一次性事件通常归结为一个方法调用——例如，更新UI状态。一旦你调用了这个方法，你就知道它是成功完成了还是抛出了一个异常，你也知道它只发生了一次。</p><h1 id="d3be" class="la lb hs bd lc ld le lf lg lh li lj lk ll mf ln lo lp mg lr ls lt mh lv lw lx bi translated">案例研究改进</h1><p id="7b9a" class="pw-post-body-paragraph ip iq hs ir b is ly iu iv iw lz iy iz ja ma jc jd je mb jg jh ji mc jk jl jm ha bi translated">如果你处于这些情况中的一种，<strong class="ir ht">重新考虑<em class="jx">那个一次性的ViewModel事件对于你的UI </em></strong>实际上意味着什么。立即处理它们，并将其还原为UI状态，使用一个可观察的数据容器(如<code class="du km kn ko kp b">StateFlow</code>或<code class="du km kn ko kp b">mutableStateOf</code>)公开该状态。</p><p id="52da" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">UI状态更好地代表了给定时间点的UI，它为您提供了更多的交付和处理保证，通常更容易测试，并且它与您的应用程序的其余部分集成一致。</p><blockquote class="kq"><p id="5d43" class="kr ks hs bd kt ku kv kw kx ky kz jm dx translated">如果您很难找到将一次性ViewModel事件减少到state的方法，请重新考虑该事件对您的UI的实际意义。</p></blockquote><p id="846e" class="pw-post-body-paragraph ip iq hs ir b is ms iu iv iw mt iy iz ja mu jc jd je mv jg jh ji mw jk jl jm ha bi translated">在上面的例子中，ViewModel <em class="jx">应该</em>公开什么是实际的应用程序数据——在本例中是支付数据——而不是告诉UI要采取什么行动。下面是ViewModel事件的一个更好的表示，该事件被处理并简化为状态，并使用可观察的数据容器类型公开。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="72ca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的代码中，<strong class="ir ht">事件通过用新的<code class="du km kn ko kp b">paymentResult</code>数据(#L31)调用</strong> <code class="du km kn ko kp b"><strong class="ir ht">_uiState.update</strong></code> (#L28)来立即处理；这个事件现在不可能被遗忘。事件已经还原为状态，<code class="du km kn ko kp b">MakePaymentUiState</code>中的<code class="du km kn ko kp b">paymentResult</code>字段反映<em class="jx">支付结果</em>申请数据。</p><p id="6485" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样，UI将对<code class="du km kn ko kp b">paymentResult</code>的变化做出反应，并相应地采取行动。</p><figure class="ke kf kg kh fd hj"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="c41a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">注意:</strong>如果在您的用例中，活动没有<code class="du km kn ko kp b">finish()</code>并被保留在backstack中，那么您的ViewModel将需要公开一个函数来从UiState中清除<code class="du km kn ko kp b">paymentResult</code>(即将字段设置为<code class="du km kn ko kp b">null</code>)，该函数将在活动启动另一个活动后被调用。这方面的一个例子可以在文档的<a class="ae jn" href="https://developer.android.com/topic/architecture/ui-layer/events#consuming-trigger-updates" rel="noopener ugc nofollow" target="_blank">消费事件可以触发状态更新</a>部分找到。</p><p id="99ca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如在<a class="ae jn" href="https://developer.android.com/topic/architecture/ui-layer#additional-considerations" rel="noopener ugc nofollow" target="_blank"> UI层的附加考虑</a>部分中提到的，如果您的用例需要，您可以使用多个流来公开您的屏幕的UI状态。重要的是，这些流是可观察的数据持有者类型。在上面的例子中，因为<code class="du km kn ko kp b">isLoading</code>标志和<code class="du km kn ko kp b">paymentResult</code>属性高度交织在一起，所以暴露了一个独特的UI状态流。将它们分开可能会导致UI不一致——例如，如果<code class="du km kn ko kp b">isLoading</code>是<code class="du km kn ko kp b">true</code>而<code class="du km kn ko kp b">paymentResult</code>不是<code class="du km kn ko kp b">null</code>。通过将它们放在同一个UiState类中，我们可以更好地了解构成屏幕UI状态的不同字段，从而减少错误。</p></div><div class="ab cl mx my go mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ha hb hc hd he"><p id="3d93" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">希望这篇博文能帮助你理解为什么我们建议1)立即处理一次性的ViewModel事件，并把它们简化为状态，以及2)使用一个可观察的数据容器类型来公开状态。我们相信这种方法可以为您提供更多的交付和处理保证，它通常更容易测试，并且可以与您的应用程序的其他部分保持一致的集成。</p><p id="8f5f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jx">免责声明:与我们的架构指南的其余部分一样，将此视为指导方针，并根据需要调整它以适应您的需求。</em></p><p id="9133" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于这个主题的更多信息，请查看<a class="ae jn" href="https://developer.android.com/topic/architecture/ui-layer/events" rel="noopener ugc nofollow" target="_blank"> UI事件文档</a>。</p></div><div class="ab cl mx my go mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ha hb hc hd he"><p id="5d46" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">特别感谢<a class="ae jn" href="https://twitter.com/adamwp" rel="noopener ugc nofollow" target="_blank"> Adam Powell </a>为这篇博文提供的无尽的讨论、知识和意见。同样，感谢<a class="ae jn" href="https://twitter.com/astamatok" rel="noopener ugc nofollow" target="_blank"> Ale Stamato </a>和<a class="ae jn" href="https://twitter.com/ppvi" rel="noopener ugc nofollow" target="_blank"> Jose Alcérreca </a>的全面评论。</p></div></div>    
</body>
</html>