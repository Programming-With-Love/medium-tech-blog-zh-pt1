<html>
<head>
<title>Embedding Tribuo ML library as a JUnit extension</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嵌入Tribuo ML库作为JUnit扩展</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/embedding-tribuo-ml-library-as-a-junit-extension-7541f843d1ea?source=collection_archive---------0-----------------------#2022-01-31">https://medium.com/oracledevs/embedding-tribuo-ml-library-as-a-junit-extension-7541f843d1ea?source=collection_archive---------0-----------------------#2022-01-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/6d727088dfc9020daafa72ebd00be151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*8WwnnFFgyJuabv_Ny6XUQg.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">Alina Constantin / Better Images of AI / Handmade A.I / CC-BY 4.0</figcaption></figure><p id="6f67" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个思想实验中，我们在一个定制的JUnit扩展中利用Tribuo来了解使用机器学习(ML)来潜在地获得对给定服务或产品有用的质量保证(QA)洞察的可行性。</p><p id="17ea" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">JUnit ，JVM上最流行的测试框架，是一个模块化和可扩展的测试框架。JUnit提供了一些扩展点来挂钩到它的生命周期中，并向它添加定制的特性。</p><p id="c313" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Tribuo 是一个开源的机器学习Java库，提供分类、回归、聚类等工具。</p><p id="72dd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">出于本文的目的，我将假设读者熟悉JUnit扩展模型。如果您有兴趣了解更多关于JUnit扩展模型以及如何创建自定义扩展的信息，您可以参考InfoQ上的<a class="ae jn" href="https://www.infoq.com/articles/deep-dive-junit5-extensions/" rel="noopener ugc nofollow" target="_blank">我的文章</a>。此外，我还将假设读者熟悉ML概念。</p><p id="4888" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设我们有一个单元测试来验证返回base64编码字符串的哈希函数。它通常看起来像这样:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="8395" class="jx jy hh jt b fi jz ka l kb kc">public class HashUtilsTest {</span><span id="c8e3" class="jx jy hh jt b fi kd ka l kb kc">  @Test<br/>  public void validHashTest() {<br/>    var valueToHash = "JUnit with Tribuo is fun";<br/>    var actualHash = HashUtils.hash(valueToHash);<br/>    ...<br/>    assertEquals(expectedHash, actualHash);<br/>  }<br/>}</span></pre><p id="861b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们假设底层的散列函数已经被改变，它仍然执行工作，但是运行时间更长了。因为函数仍然产生正确的散列，所以单元测试继续通过。然而，更长的时间可能会被忽视。</p><p id="d078" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以构建一个定制的JUnit <a class="ae jn" href="https://github.com/udaychandra/junit-tribuo/blob/main/src/main/java/io/github/udaychandra/jt/JTExtension.java" rel="noopener ugc nofollow" target="_blank">扩展</a>来计算执行一个测试类所花费的总时间，并运行Tribuo的异常检测ML模型来发现测试执行期间的任何异常。为了做到这一点，扩展一直在CSV文件中记录计时数据。为了简单起见，所有记录的数据都被天真地解释为<code class="du ke kf kg jt b">EXPECTED</code>观察。Java的内置文件方法可以用来实现这一点:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="65b0" class="jx jy hh jt b fi jz ka l kb kc">var csvPath = ...<br/>var time = ...<br/>Files.writeString(<br/>    csvPath,<br/>    time + ",EXPECTED\n",<br/>    StandardCharsets.UTF_8,<br/>    StandardOpenOption.APPEND<br/>);</span></pre><p id="8cb8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦记录了足够的数据，扩展就会构建一个ML模型，并在测试运行时使用它来发现任何不寻常的观察结果。Tribuo的<a class="ae jn" href="https://tribuo.org/learn/4.2/docs/packageoverview.html#anomaly-detection" rel="noopener ugc nofollow" target="_blank">强类型类</a>可用于实现这一点，如以下示例代码所示:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="f570" class="jx jy hh jt b fi jz ka l kb kc">var oneClass = new SVMAnomalyType(SVMAnomalyType.SVMMode.ONE_CLASS); <br/>var params = new SVMParameters&lt;&gt;(oneClass, KernelType.RBF);<br/>params.setGamma(MODEL_GAMMA);<br/>params.setNu(MODEL_NU);</span><span id="b0b5" class="jx jy hh jt b fi kd ka l kb kc">var trainer = new LibSVMAnomalyTrainer(params);<br/>var model = trainer.train(trainingDataset);</span><span id="7fb6" class="jx jy hh jt b fi kd ka l kb kc">var newRow = Map.of(<br/>    "name", clazz.getName(),<br/>    "duration", String.valueOf(durationInSec)<br/>);<br/>var headers = java.util.List.copyOf(newRow.keySet());<br/>var row = new ColumnarIterator.Row(trainingDataset.size(), headers, newRow);<br/>var example = sRowProcessor.generateExample(row,false).get();</span><span id="adc2" class="jx jy hh jt b fi kd ka l kb kc">prediction = model.predict(example);</span><span id="35c7" class="jx jy hh jt b fi kd ka l kb kc">// This is where you would generate an actual report.<br/>System.out.println(example);<br/>System.out.println(prediction);</span></pre><p id="a220" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们所要做的就是在我们的测试类中使用这个新的扩展，如下所示:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="d301" class="jx jy hh jt b fi jz ka l kb kc">@AnomalyDetector<br/>public class HashUtilsTest {</span><span id="2662" class="jx jy hh jt b fi kd ka l kb kc">  @Test<br/>  public void validHashTest() {<br/>    ...<br/>    assertEquals(expectedHash, actualHash);<br/>  }<br/>}</span></pre><p id="f162" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的例子中，假设成功运行测试通常需要0.5-1秒。但是，在哈希函数发生变化后，现在只需3秒钟就可以成功运行测试。这可能会导致潜在的性能退化(当然，这是一种过度简化)。如果经过训练的模型工作正常，那么这种不寻常的行为现在应该被标记为问题。</p><p id="df64" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当测试类运行的时间符合预期时，我们从模型的预测中看到类似这样的东西:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="7216" class="jx jy hh jt b fi jz ka l kb kc">Prediction(maxLabel=(EXPECTED,...</span></pre><p id="2852" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当模型检测到异常时，我们会看到这样的情况:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="d70a" class="jx jy hh jt b fi jz ka l kb kc">Prediction(maxLabel=(ANOMALOUS,...</span></pre><p id="695b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这只是一个开始。在测试框架中利用ML来自动分析测试并提供更好的QA可能会有更有用的应用。感谢像JUnit和Tribuo这样优秀的开源库，我们可以很容易地探索这样的用例！</p><p id="0a4f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以在<a class="ae jn" href="https://github.com/udaychandra/junit-tribuo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看实验代码。</p><h2 id="a417" class="jx jy hh bd kh ki kj kk kl km kn ko kp ja kq kr ks je kt ku kv ji kw kx ky kz bi translated">加入对话！</h2><p id="5024" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">如果你对甲骨文开发人员在他们的自然栖息地发生的事情感到好奇，来加入我们的<a class="ae jn" href="https://oracledevrel.slack.com/join/shared_invite/zt-uffjmwh3-ksmv2ii9YxSkc6IpbokL1g#/shared-invite/email" rel="noopener ugc nofollow" target="_blank">公共休闲频道</a>！我们不介意成为你的鱼缸🐠</p></div></div>    
</body>
</html>