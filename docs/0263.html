<html>
<head>
<title>A better underline for Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的Android下划线</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/a-better-underline-for-android-90ba3a2e4fb?source=collection_archive---------3-----------------------#2016-06-29">https://medium.com/androiddevelopers/a-better-underline-for-android-90ba3a2e4fb?source=collection_archive---------3-----------------------#2016-06-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="559a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在过去的两年里，我经常看到试图改善下划线文本装饰在网页上呈现方式的文章和T2图书馆。同样的问题也存在于Android上:下划线文本装饰跨越了下行线。比较Android如何绘制下划线文本(上图)和如何绘制下划线文本(下图):</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/96d46dbd25a7c521006b1540455c1bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*3EvJmIY8EtinFZsvNbcMgQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Which do you prefer?</figcaption></figure><p id="193f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然我完全赞同这些努力，但我从来没有喜欢过公开的解决方案。目前的技术水平——不可否认是CSS的局限性迫使开发人员——似乎依赖于绘制线性渐变和多重阴影(我见过多达12个！).这些解决方案具有不可否认的工作质量，但绘制如此多的阴影，甚至没有模糊它们的想法，让我的图形程序员畏缩。他们也只能在纯色背景下工作。</p><p id="e3f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">今天下午，我突发奇想，着手寻找其他解决方案，以满足以下要求:</p><ul class=""><li id="e67b" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">在旧版本的Android上工作</li><li id="d18c" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">仅使用标准视图和画布API</li><li id="9a4b" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">不需要过度绘制或昂贵的阴影</li><li id="cfaa" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">在任何背景下工作，不仅仅是纯色</li><li id="3c25" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">不要依赖渲染管道中的操作顺序(下划线前/后绘制的文本无关紧要)</li></ul><p id="512b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我确实有两个解决方案，并且我已经在GitHub 上发布了<a class="ae jc" href="https://github.com/romainguy/elegant-underline" rel="noopener ugc nofollow" target="_blank">。一种解决方案适用于</a><a class="ae jc" href="https://www.android.com/versions/kit-kat-4-4/" rel="noopener ugc nofollow" target="_blank"> API等级19 </a>及以上，另一种适用于<a class="ae jc" href="http://arstechnica.com/gadgets/2014/06/building-android-a-40000-word-history-of-googles-mobile-os/6/" rel="noopener ugc nofollow" target="_blank"> API等级1 </a>及以上。或者至少它<em class="kd">应该</em>在API级别1和以上工作，我还没有完全尝试过。我相信文件。</p><p id="0faa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下面的截图中，您可以观察和比较这两种方法，称为<em class="kd">路径</em>和<em class="kd">区域</em>:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/4a5c5a6562b396b5508bab5ae7326d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*b9-pyeMNFZq1NklRvT5EMw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Two possible implementations for better underline text decorations on Android</figcaption></figure><h1 id="42e7" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">它是如何工作的？</h1><p id="0493" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">这些实现背后的思想与前面提到的CSS方法惊人地相似。我们有一条由一条直线代表的下划线，我们需要做的就是为下行线腾出空间…</p><h2 id="c0df" class="li kg hh bd kh lj lk ll kl lm ln lo kp ip lp lq kt it lr ls kx ix lt lu lb lv bi translated">使用路径</h2><p id="0e69" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">API level 19(更好地称为KitKat)引入了一个奇妙的新API，用于路径操作调用<a class="ae jc" href="https://developer.android.com/reference/android/graphics/Path.html#op(android.graphics.Path, android.graphics.Path.Op)" rel="noopener ugc nofollow" target="_blank">路径操作</a>。这个API允许你建立两条路径的交集或者从另一条路径中减去一条路径。</p><p id="291c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用这个API，制作下划线变得很简单。第一步是<a class="ae jc" href="https://developer.android.com/reference/android/graphics/Paint.html#getTextPath(java.lang.String, int, int, float, float, android.graphics.Path)" rel="noopener ugc nofollow" target="_blank">得到我们文本的大纲</a>:</p><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="80e5" class="li kg hh lx b fi mb mc l md me">mPaint.getTextPath(mText, 0, mText.length(), 0.0f, 0.0f, mOutline);</span></pre><p id="be33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，生成的路径可用于使用填充样式呈现原始文本。相反，我们将把它用于进一步的操作。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es mf"><img src="../Images/d9f93797548d735bc1e93c90485b582d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XeHT_EQexshwJT50p-H5RQ.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">Text outline</figcaption></figure><p id="943d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一步是用代表下划线的矩形裁剪轮廓。这一步不是完全必要的，但是可以避免在下一步中可能出现的假象和其他近似。为此，我们只需使用相交路径操作:</p><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="04a9" class="li kg hh lx b fi mb mc l md me">mOutline.op(mUnderline, Path.Op.INTERSECT);</span></pre><p id="ab64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">轮廓路径现在只包含穿过下划线的下行位:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es mk"><img src="../Images/fded5a07a8baa947c5d0d2addb2ffd45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0dZJW6GcrL2Xc2v3eNtMg.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">Only the black regions are part of the path, the rest is drawn for visualization purpose only</figcaption></figure><p id="eadd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">剩下要做的就是从下划线中减去下行位。在这样做之前，我们必须扩大原始文本的大小，以便在下行线和下划线之间创建间隙。这可以通过描边我们裁剪的轮廓并创建一个新的填充路径来实现:</p><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="010a" class="li kg hh lx b fi mb mc l md me">mStroke.setStyle(Paint.Style.FILL_AND_STROKE);        mStroke.setStrokeWidth(UNDERLINE_CLEAR_GAP);<br/>mStroke.getFillPath(mOutline, strokedOutline);</span></pre><p id="2c54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">笔画宽度决定了下行线和下划线之间的间距。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="er es ml"><img src="../Images/7cd113100d214ed42f2fc531bb198d68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9H8uUmW1dvPaZl5TWKcww.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx">Stroking the clipped outline</figcaption></figure><p id="2b7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后一步是使用另一个路径操作，从下划线矩形中减去描边、剪切的轮廓:</p><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="79d0" class="li kg hh lx b fi mb mc l md me">mUnderline.op(strokedOutline, Path.Op.DIFFERENCE);</span></pre><p id="c8b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最终的下划线路径可以使用填充颜料绘制:</p><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="845a" class="li kg hh lx b fi mb mc l md me">canvas.drawPath(mUnderline, mPaint);</span></pre><h2 id="9509" class="li kg hh bd kh lj lk ll kl lm ln lo kp ip lp lq kt it lr ls kx ix lt lu lb lv bi translated">使用区域</h2><p id="8c73" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated"><a class="ae jc" href="https://developer.android.com/reference/android/graphics/Region.html" rel="noopener ugc nofollow" target="_blank">区域</a>是表示屏幕非矩形区域的有效方式。您可以将区域想象为与渲染缓冲区的像素边界对齐的矩形集合。区域可以用作路径的<em class="kd">栅格化</em>表示。这意味着，如果我们将一个路径转换成一个区域，我们将获得像素坐标的集合，如果绘制路径，这些坐标将受到路径的影响。</p><p id="c6a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让区域特别有趣的是，它们<a class="ae jc" href="https://developer.android.com/reference/android/graphics/Region.html#op(android.graphics.Region, android.graphics.Region.Op)" rel="noopener ugc nofollow" target="_blank">提供了类似于路径操作</a>的操作。两个区域可以相交、相减等。更重要的是，从第一个版本开始，区域就是Android API的一部分。</p><p id="871c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">区域实现几乎与路径实现完全相同。主要区别在于何时以及如何裁剪轮廓路径。</p><pre class="je jf jg jh fd lw lx ly lz aw ma bi"><span id="f9a9" class="li kg hh lx b fi mb mc l md me">Region underlineRegion = new Region(underlineRect);</span><span id="cb1e" class="li kg hh lx b fi mm mc l md me">// Create a region for the text outline and clip<br/>// it with the underline<br/>Region outlineRegion = new Region();<br/>outlineRegion.setPath(mOutline, underlineRegion);</span><span id="cf74" class="li kg hh lx b fi mm mc l md me">// Extract the resulting region's path, we now have a clipped<br/>// copy of the text outline<br/>mOutline.rewind();<br/>outlineRegion.getBoundaryPath(mOutline);</span><span id="ff33" class="li kg hh lx b fi mm mc l md me">// Stroke the clipped text and get the result as a fill path<br/>mStroke.getFillPath(mOutline, strokedOutline);</span><span id="0348" class="li kg hh lx b fi mm mc l md me">// Create a region from the clipped stroked outline<br/>outlineRegion = new Region();<br/>outlineRegion.setPath(strokedOutline, new Region(mBounds));</span><span id="d068" class="li kg hh lx b fi mm mc l md me">// Subtracts the clipped, stroked outline region from the underline<br/>underlineRegion.op(outlineRegion, Region.Op.DIFFERENCE);</span><span id="b261" class="li kg hh lx b fi mm mc l md me">// Create a path from the underline region<br/>underlineRegion.getBoundaryPath(mUnderline);</span></pre><h2 id="4417" class="li kg hh bd kh lj lk ll kl lm ln lo kp ip lp lq kt it lr ls kx ix lt lu lb lv bi translated">两种方法之间的差异</h2><p id="747c" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">由于路径和区域的性质，这两种实现之间存在细微的差异。因为路径操作只对曲线起作用，所以当我们从下划线中减去下行线时，它们保持下行线的倾斜度。这会产生平行于曲线坡度的间隙。这可能是也可能不是想要的效果。</p><p id="6077" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一方面，区域在整个像素上操作，并且将通过下划线创建干净的垂直切割(只要你的下划线足够细)。下面是两种实现之间的比较:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mn"><img src="../Images/a0444ff9aac7e343cb13254c9907be32.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*98qBNgT8sGBy6nTLUrk0Dw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx">Top: paths. Bottom: regions. Notice the slant? If not, you should. Look harder.</figcaption></figure><h1 id="c8e3" class="kf kg hh bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">我应该在生产中使用这个吗？</h1><p id="0b84" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">在您尝试在您的应用程序中使用这些技术之前，请注意我目前还没有进行任何性能测量。请记住，这个练习主要是一个有趣的编程挑战。所提供的代码并不试图根据字体大小来正确定位下划线文本修饰。它也不会根据字体大小改变间隙的宽度。也可能存在字体相关的问题，因为我只在Android的一些默认字体上尝试过这种效果。让我们称这些问题为留给读者的练习。</p><p id="d5c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您尝试在您的应用程序中使用这些代码，我必须承认我很乐意看到<a class="ae jc" href="http://flavienlaurent.com/blog/2014/01/31/spans/" rel="noopener ugc nofollow" target="_blank"> spans </a>的实现，我会鼓励您至少缓存最终的填充路径。由于缓存只依赖于字体、字体大小和字符串，所以实现起来应该很简单。</p><p id="ef92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，本文中描述的两个实现受到公共SDK APIs的限制，这是可以理解的。如果将这种效果直接实现到Android框架中，我对如何更有效地实现这种效果有一些想法。</p><p id="3790" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，<em class="kd">区域</em>变体可以通过渲染区域本身来优化，而无需返回到<em class="kd">路径</em>(这会导致软件光栅化和GPU纹理更新)。区域在内部被表示为矩形的集合，并且对于渲染管道来说，绘制一系列线或矩形而不是光栅化路径是微不足道的。</p><p id="e29d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你想知道更多关于Android上的文本吗？了解Android的硬件加速字体渲染器如何工作。</p><p id="c7fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在GitHub上获取演示的<a class="ae jc" href="https://github.com/romainguy/elegant-underline" rel="noopener ugc nofollow" target="_blank">源。</a></p></div></div>    
</body>
</html>