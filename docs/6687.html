<html>
<head>
<title>Organizing Unstructured Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组织非结构化数据</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/organizing-unstructured-data-eab8ad6b0e46?source=collection_archive---------6-----------------------#2019-08-27">https://medium.com/quick-code/organizing-unstructured-data-eab8ad6b0e46?source=collection_archive---------6-----------------------#2019-08-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6857" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://vorakl.com/articles/data-structure/" rel="noopener ugc nofollow" target="_blank">使用类型、结构、ADT和对象管理数据复杂性</a></p></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><p id="c15c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">计算机的主要目的，如果不是唯一的目的，是计算信息。它不一定总是数学公式的计算。一般来说，它是一个信息块到另一个信息块的转换。计算机只处理可以用离散数据表示的信息。计算引擎的输入和输出总是<a class="ae jc" href="https://vorakl.com/articles/numbers/" rel="noopener ugc nofollow" target="_blank">自然数</a>或文本(字典中对应于某些自然数的符号序列)。</p><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jk"><img src="../Images/f776566b18d7c4c695d73c4fa3bdc65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E0h9PdVVo8Q4EKa3.png"/></div></div></figure><p id="48e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然数据是<em class="jw">非结构化的</em>，但很难从中发现一些意义。但是一旦数据得到任何一种<em class="jw">结构化的</em>形式，它就变得有意义并适合于进一步的转换。</p><h1 id="d900" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">类型</h1><p id="96f8" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">最简单的数据组织形式是<strong class="ig hi">类型</strong>。一般来说，<em class="jw">数据类型</em>决定了一组具有特定特征的值。通常，它以字节为单位定义大小。<strong class="ig hi">原始数据类型</strong>是<em class="jw">有序的字节组</em>。当某种原始数据类型的变量只有一个值(只保存一条信息)时，它被称为<strong class="ig hi">标量</strong>和一种类型— <strong class="ig hi">标量数据类型</strong>。众所周知的例子有<em class="jw">整数</em>、<em class="jw">浮点</em>、<em class="jw">指针</em>、<em class="jw">字符串</em>。原始数据类型的<em class="jw">集合被称为<strong class="ig hi">结构化数据类型</strong>，它可以存储多个值。这种类型的好例子有<em class="jw">数组</em>、<em class="jw">结构</em>、<em class="jw">记录</em>和<em class="jw">文件</em>。关键属性是有序字节的组。内部组织简单明了，所有操作(例如读取、修改)都是直接在数据上执行的，符合定义内存中字节顺序的硬件架构(小端/大端)。</em></p><h1 id="ad4c" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">数据结构</h1><p id="9e73" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">数据抽象的下一层叫做<strong class="ig hi">数据结构</strong>。它带来了更多的复杂性，但也带来了在访问速度、增长能力、修改速度等之间做出正确选择的更多灵活性。在内部，它由标量或结构化数据类型的集合来表示。主要焦点是内部组织的<em class="jw">细节和控制这个组织的一套规则</em>。有两种类型的数据结构，它们来自底层元素在内存中的位置差异:</p><ul class=""><li id="3b61" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated"><strong class="ig hi">数组数据结构</strong>(静态)，基于内存中物理上连续的元素，中间没有间隙。</li><li id="1a70" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><strong class="ig hi">链接数据结构</strong>(动态)，基于元素，在内存中动态分配，并使用指针(通常一个或两个)链接成线性结构</li></ul><p id="3bb9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">众所周知的例子有<em class="jw">链表</em>、<em class="jw">哈希</em> ( <em class="jw">字典</em>)、<em class="jw">集合</em>、<em class="jw">列表</em>。内部组织仍然是开放的，对数据的所有操作也是直接执行的。</p><h1 id="8945" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">抽象数据类型(ADT)</h1><p id="4cff" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">更高层次的数据抽象由<strong class="ig hi">抽象数据类型(ADT) </strong>表示，它将主要焦点从“<em class="jw">如何存储数据</em>”转移到“<em class="jw">如何处理数据</em>”。ADT由用于操作数据和控制其一致性的<em class="jw">操作</em>(函数)和用于实际存储信息的<em class="jw">数据结构</em>定义。内部数据表示对用户是隐藏的，不应该直接访问(根据设计)。所有与数据的交互都是通过<em class="jw">接口</em>完成的(操作暴露给用户)。通常，对于每个ADT，都定义了一些<em class="jw">原语操作</em>，比如</p><ul class=""><li id="4ece" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated"><strong class="ig hi">创建</strong> —新实例的构造器</li><li id="e0f4" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><strong class="ig hi">销毁</strong> —一个现有实例的析构函数</li><li id="1059" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><strong class="ig hi"> add </strong>，<strong class="ig hi"> get </strong> —用于添加和删除实例元素的set-get函数</li><li id="1e42" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><strong class="ig hi"> is_empty </strong>，<strong class="ig hi"> size </strong> —管理实例中现有数据的有用函数</li></ul><p id="59d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ADT最著名的例子是<em class="jw">堆栈</em>和<em class="jw">队列</em>。这两种ADT都可以使用数组或链接数据结构来实现，并且都有添加和删除元素的特定规则。所有这些细节都被抽象为函数，这些函数反过来对内部数据执行适当的操作。将ADT划分为操作和数据结构创建了一个<em class="jw">抽象障碍</em>，并允许保持一个坚实的接口，灵活地改变内部结构，而不会对使用该ADT的代码产生副作用。</p><h1 id="4202" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">目标</h1><p id="c8a7" class="pw-post-body-paragraph ie if hh ig b ih kv ij ik il kw in io ip kx ir is it ky iv iw ix kz iz ja jb ha bi translated">一种更全面的抽象数据的方式由<strong class="ig hi">对象</strong>表示。一个对象可以被认为是一个具有某些属性的数据块的容器。与ADT类似，这些数据是不可直接访问的(称为<em class="jw">封装</em>或隔离)，而是每个对象都有一组紧密连接的<em class="jw">方法</em>，适用于对其数据进行操作以产生该对象的预期行为(称为<em class="jw">多态</em>)。事实上，所有这样的方法都只是收集在<em class="jw">类</em>下的函数，但是当它们被调用来对某个对象进行操作时，它们就变成了方法。方法也可以从另一个类<em class="jw">继承</em>，这个类在这种情况下被称为<em class="jw">超类</em>。与ADT相反，一个对象并不代表一种特定类型的数据，而是一种本质，它有许多<em class="jw">属性</em>，当它的方法被调用时，它的行为就像它应该做的那样。属性无非是任何类型(包括ADT)的变量，也集合在一个类下。从形式上讲，类充当所有对象属性和方法的规范，可以调用这些方法来处理这些属性。</p><p id="8133" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">面向对象编程</strong>范例(OOP)使用对象作为程序设计的中心元素。与<strong class="ig hi">过程化编程</strong>范例相反，在这种范例中，主要的焦点是将项目分割成大部分独立的任务，在OOP中，程序由许多对象组成。每个对象都被看作是定义其行为的某个类的实例。在一般的OOP设计中，对象用于:</p><ul class=""><li id="4236" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated">将程序的数据存储为它们的独立属性</li><li id="dac7" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">保持程序的逻辑作为他们的方法</li><li id="5ae1" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">通过消息传递(通过调用对象的方法)来实现主程序的目标。</li></ul><figure class="jl jm jn jo fd jp er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es lo"><img src="../Images/074eea2077f3901861faeaacf41b0dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwoMYtCH8Bv5vYtgnzeG5Q.png"/></div></div></figure></div></div>    
</body>
</html>