<html>
<head>
<title>A follow-up on how to store tokens securely in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于如何在Android中安全存储令牌的后续文章</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/a-follow-up-on-how-to-store-tokens-securely-in-android-e84ac5f15f17?source=collection_archive---------0-----------------------#2017-04-30">https://medium.com/google-developer-experts/a-follow-up-on-how-to-store-tokens-securely-in-android-e84ac5f15f17?source=collection_archive---------0-----------------------#2017-04-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/72e82971d594ea639abfb3082762e5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWjJ7GKUSVEQMC0srKK-9Q.jpeg"/></div></div></figure><div class=""/><p id="80b3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为这篇文章的序言，我想为名义上的读者提一个简短的句子。这句话在我们前进的过程中非常重要。</p><blockquote class="jn jo jp"><p id="66d6" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">绝对安全是不存在的。安全是一套措施，被堆积和组合，试图减缓不可避免的。</p></blockquote><p id="1961" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">大约三年前，我写了一篇文章,给出了一些保护字符串令牌免受一个假想的攻击者反编译我们的Android应用的想法。为了纪念，也为了避开互联网不可避免的死亡，我在这里复制一些章节。</p><p id="7560" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最常见的一个用例发生在我们的应用程序需要与web服务通信以交换数据的时候。这种数据交换可以从不太敏感到更敏感，并且在登录请求、用户数据变更请求等之间变化。</p><p id="1cd9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先要应用的措施是在客户端和服务器之间使用一个<a class="ae ju" href="http://info.ssl.com/article.aspx?id=10241" rel="noopener ugc nofollow" target="_blank"> SSL </a>(安全套接字层)连接。再次回到最初的报价。这并不能确保绝对的隐私和安全，尽管这是一个很好的开始。</p><p id="84ae" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您使用SSL连接时(就像您在浏览器中看到的锁)，这表明您和服务器之间的连接是加密的。在理论层面上，没有任何东西可以访问此请求中包含的信息<strong class="ir ht"> (*) </strong></p><p id="7e35" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"> (*) </strong>我有没有说过绝对的安全是不存在的？SSL连接仍然可能受到威胁。本文并不打算提供所有可能的攻击的详细列表，但是我想让您知道一些可能性。可以使用伪造的SSL证书，以及中间人攻击。</p><p id="0c10" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们继续前进。我们假设我们的客户端通过一个加密的SSL通道与我们的后端进行通信。他们在交换有用的数据，做生意，开心。但是我们想提供一个额外的安全层。</p><p id="0652" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现今使用的下一个逻辑步骤是提供将在通信中使用的认证令牌或API密钥。它是这样工作的。我们的后台收到一份请愿书。我们怎么知道这个请求来自我们的一个经过验证的客户，而不是一个试图访问我们API的普通人呢？后端将检查客户端是否提供了有效的API密钥。如果前面的陈述恰好是真的，那么我们继续请求。否则，我们否认它，并根据我们业务的性质采取一些纠正措施(当这种情况发生时，我特别喜欢存储来自客户端的IP和id，以查看这种情况发生的频率。当频率膨胀超过我的品味所期望的时候，我确实会考虑禁止或者密切观察这个不礼貌的互联网人想要达到的目的。</p><p id="551c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从地面开始建造我们的城堡。在我们的应用程序中，我们可能会添加一个名为API_KEY的变量，该变量会在每个请求中自动注入(如果您使用的是Android，可能会在您的改型客户端中)。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="340b" class="ke kf hs ka b fi kg kh l ki kj">private final static String API_KEY = “67a5af7f89ah3katf7m20fdj202”</span></pre><p id="da02" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这很棒，如果我们想验证我们的客户，这很有用。问题是它本身并不能提供一个非常有效的层。</p><p id="68bc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您使用<a class="ae ju" href="https://ibotpeaches.github.io/Apktool/" rel="noopener ugc nofollow" target="_blank"> apktool </a>来反编译应用程序并执行查找字符串的搜索，您将在结果中找到一个。smali提交了以下文件:</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="ec36" class="ke kf hs ka b fi kg kh l ki kj">const-string v1, “67a5af7f89ah3katf7m20fdj202”</span></pre><p id="4312" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">是啊，当然。它没有说这是一个验证令牌，所以我们仍然需要进行细致的验证，以决定如何到达这个字符串，以及它是否可以用于身份验证目的。但是你知道我要去哪里:这主要是时间和资源的问题。</p><p id="a814" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Proguard能帮助我们保护这个字符串吗，这样我们就不用担心了？不完全是。Proguard在<a class="ae ju" href="http://proguard.sourceforge.net/FAQ.html#encrypt" rel="noopener ugc nofollow" target="_blank">的FAQ </a>中声明字符串加密并不是完全可能的。</p><p id="6b2f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如何将这个字符串保存在Android提供的其他机制中，比如SharedPreferences？这几乎不是一个好主意。SharedPreferences可以从模拟器或任何根设备轻松访问。几年前，一个叫<a class="ae ju" href="http://resources.infosecinstitute.com/android-hacking-security-part-9-insecure-local-storage-shared-preferences/" rel="noopener ugc nofollow" target="_blank">斯里尼瓦斯</a>的家伙证明了分数可以在电子游戏中被改变。我们已经别无选择了！</p><h2 id="0a5a" class="ke kf hs bd kk kl km kn ko kp kq kr ks ja kt ku kv je kw kx ky ji kz la lb lc bi translated">本地开发工具包(NDK)</h2><p id="5e9b" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">我将在这里更新我提出的初始模型，以及我们如何迭代它以提供更安全的替代方案。让我们想象两个可以用来加密和解密数据的函数:</p><figure class="jv jw jx jy fd hj"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="2a8f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里没什么特别的。这两个函数将接受一个键值和一个要编码或解码的字符串。它们将分别返回加密或解密的令牌。我们将调用如下函数:</p><figure class="jv jw jx jy fd hj"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="6456" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你在猜测方向吗？没错。我们可以按需加密和解密我们的令牌。这提供了额外的安全层:当代码变得模糊时，它不再像执行字符串搜索和检查该字符串周围的环境那样简单。但是你还能想出一个需要解决的问题吗？</p><p id="b47f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以吗？</p><p id="2569" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你还没想出来，多给它几秒钟。</p><p id="d624" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">是的，你是对的。我们有一个也以字符串形式存储的加密密钥。这通过模糊性增加了更多的安全层，但是我们仍然有一个明文令牌，不管这个令牌是用于加密还是令牌本身。</p><p id="ff45" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们现在使用NDK，并不断迭代我们的安全机制。</p><p id="9db6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">NDK允许我们从我们的Android代码中访问C++代码库。作为第一种方法，让我们花一分钟时间想想该做什么。我们可以有一个原生的C++函数来存储一个API键或者我们试图存储的任何敏感数据。这个函数以后可以从代码中调用，任何Java文件中都不会存储任何字符串。这将提供针对反编译技术的自动保护。</p><p id="9561" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的C++函数如下所示:</p><figure class="jv jw jx jy fd hj"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="37ff" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Java代码中很容易调用它:</p><figure class="jv jw jx jy fd hj"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="7160" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">加密/解密函数将在下一个代码片段中调用:</p><figure class="jv jw jx jy fd hj"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="676f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们知道生成一个APK，混淆它，反编译它，并试图访问包含在本机函数getSecretKey()中的字符串，我们将无法找到它！胜利？</p><p id="bf1e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不完全是。NDK代码实际上可以被分解和检查。这变得越来越困难，你开始需要更先进的工具和技术。您摆脱了95%的脚本小子，但是一个拥有足够资源和动力的团队仍然能够访问令牌。还记得这句话吗？</p><blockquote class="jn jo jp"><p id="4fa9" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">绝对安全是不存在的。安全是一套措施，被堆积和组合，试图减缓不可避免的。</p></blockquote><figure class="jv jw jx jy fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lk"><img src="../Images/44bc013dce3ff5690be893f715c43aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JPErsmBbKjKbFoQYJAoUkg.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx">You can still access in disassembled code String literals!</figcaption></figure><p id="5d0f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，Hex Rays 在反编译原生文件方面做得非常好。我相信也有很多工具可以解构Android生成的任何本机代码(我与Hex Rays没有任何关系，也没有从他们那里获得任何形式的金钱补偿)。</p><p id="9d2f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么，我们可以使用哪种解决方案在后端和客户端之间进行通信而不被标记呢？</p><p id="f424" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">在设备上实时生成密钥。</strong></p><p id="a94e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您的设备不需要存储任何类型的密钥，也不需要处理保护字符串文字的所有麻烦！这是远程密钥验证等服务使用的一种非常古老的技术。</p><ol class=""><li id="131a" class="lp lq hs ir b is it iw ix ja lr je ls ji lt jm lu lv lw lx bi translated">客户端知道一个返回密钥的函数()。</li><li id="7915" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated">后端知道客户机中实现的函数()</li><li id="eb48" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated">客户端通过函数()生成一个密钥，并将其传递给服务器。</li><li id="93a3" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated">服务器验证它，并继续处理请求。</li></ol><p id="f16a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你把这些点联系起来了吗？与其有一个返回字符串(容易识别)的原生函数，为什么没有一个返回1到100之间三个随机素数之和的函数呢？或者是一个用unixtime表示的当前日期并在每个不同的数字上加1的函数？如何从设备中获取一些上下文信息，例如正在使用的内存量，以提供更高程度的熵呢？</p><p id="eadd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后一段包括了一系列的想法，但是我们假设的读者希望已经抓住了要点。</p><h1 id="42fc" class="md kf hs bd kk me mf mg ko mh mi mj ks mk ml mm kv mn mo mp ky mq mr ms lb mt bi translated"><strong class="ak">总结</strong></h1><ol class=""><li id="3d0a" class="lp lq hs ir b is ld iw le ja mu je mv ji mw jm lu lv lw lx bi translated">绝对安全是不存在的。</li><li id="a249" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated">组合一套保护措施是实现高度安全性的关键。</li><li id="106f" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated">不要在代码中存储字符串。</li><li id="38ef" class="lp lq hs ir b is ly iw lz ja ma je mb ji mc jm lu lv lw lx bi translated">使用NDK创建一个自己生成的密钥。</li></ol><p id="9963" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">还记得第一句话吗？</p><blockquote class="jn jo jp"><p id="c148" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">绝对安全是不存在的。安全是一套措施，被堆积和组合，试图减缓不可避免的。</p></blockquote><p id="08db" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我想再次指出，你的目标是尽可能多地保护你的代码，同时不要忘记100%的安全性是无法实现的。但是，如果您能够以一种需要大量资源来解密您拥有的任何敏感信息的方式来保护您的代码，您将能够睡得安稳。</p><h1 id="f207" class="md kf hs bd kk me mf mg ko mh mi mj ks mk ml mm kv mn mo mp ky mq mr ms lb mt bi translated">一个小小的免责声明</h1><p id="0b18" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">我知道。直到这里，你一直在思考整篇文章“这家伙怎么不提<a class="ae ju" href="https://www.guardsquare.com/en/dexguard" rel="noopener ugc nofollow" target="_blank">德克斯加德</a>，还经历了这么多麻烦？”。你是对的。Dexguard实际上可以混淆字符串，他们在这方面做得非常好。然而，Dexguard的定价<a class="ae ju" href="http://thinkdiff.net/mobile/dexguard-480-eur-to-10313-eur-the-worst-software-do-not-use/" rel="noopener ugc nofollow" target="_blank">可能会令人望而却步</a>。我在以前的公司使用过Dexguard的关键安全系统，但这可能不是每个人的选择。而且，在软件开发和生活中，你拥有的选择越多，世界就越丰富。</p><p id="317b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编码快乐！</p><p id="ae3d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在我的<a class="ae ju" href="https://twitter.com/eenriquelopez" rel="noopener ugc nofollow" target="_blank"> Twitter账户</a>中写下我对软件工程和生活的想法。如果你喜欢这篇文章或者它确实帮助了你，请随意分享它，♥它和/或留下评论。这是给业余作家加油的货币。</p></div></div>    
</body>
</html>