<html>
<head>
<title>True power of Optional in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中可选的真正力量</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/true-power-of-optional-in-java-306a77c62d00?source=collection_archive---------0-----------------------#2021-07-18">https://medium.com/walmartglobaltech/true-power-of-optional-in-java-306a77c62d00?source=collection_archive---------0-----------------------#2021-07-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ad958e632ce16eabbdec2282320463d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B6iUkFKUjfzRYp0P"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Emile Perron</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="50f7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Java中可选的是一个对象的容器，它可能包含也可能不包含值。这是Java工程师很少理解的一个事实，他们使用Optional作为执行空检查和避免NullPointerException场景的“奇特方式”。</p><blockquote class="js jt ju"><p id="3e1c" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr ha bi translated">null——十亿美元的错误？</p></blockquote><p id="70d5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">null是一个特殊的值，在Java中可以作为文字使用，可以用来表示无值。它的行为对于它被赋给的任何引用类型都是相同的和中立的。null的概念是由英国计算机科学家东尼·霍尔在20世纪60年代初提出的，但他后来创造了他的十亿美元的错误，因为在某种程度上，它为C语言的get实用程序首次引入的恶意软件的创建奠定了基础。因此，现代编程语言用快速失效方法处理null要有效得多。</p><blockquote class="js jt ju"><p id="4349" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr ha bi translated">但是用老方法执行空检查有什么问题呢？</p></blockquote><p id="822a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我看来——在需要的地方添加空检查没有错。Java 8中添加的新的可选类并不是要取代每一个空引用。还要注意，Optional的不当使用会在代码中引入NullPointerException，我们将在后面的部分中看到这一点。</p><p id="4987" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">记住，Optional是一个对象的容器，它可能包含也可能不包含值。这基本上意味着，可选的概念用于表示特定的实体或对象可以包含值，也可以不包含值。因此，<strong class="iw hi"> Optional给出了区分缺少值和空引用的能力。</strong>因此，Null可用于指示在该点之前程序流程中出现的错误。</p><p id="5ee6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我用一个例子来说明这一点:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="879f" class="ki kj hh ke b fi kk kl l km kn">Optional&lt;String&gt; name = Optional.<em class="jv">of</em>("John Smith"); /* with a valid value */</span></pre><p id="c7fd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这用提供的值声明了一个可选容器。或者，您也可以使用<em class="jv"> empty() </em>方法来表示容器中没有值，如下所示。</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="1f77" class="ki kj hh ke b fi kk kl l km kn">Optional&lt;String&gt; name = Optional.<em class="jv">empty</em>(); /* shows the absence of a value */</span></pre><p id="86cd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Optional类还提供了一个方法<em class="jv"> ofNullable() </em>来创建带有空值的可选容器。</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="d11e" class="ki kj hh ke b fi kk kl l km kn">Optional&lt;String&gt; name = Optional.<em class="jv">ofNullable</em>(null); /* can be a null value */</span></pre><p id="faa2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设您需要在名称存在时打印名称，在名称不存在时打印默认值。您可以使用传统的空值检查来实现这一点:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="60ce" class="ki kj hh ke b fi kk kl l km kn">String patronName = .... ; /* may or may not be null */<br/>if(patronName != null) {<br/>    System.<em class="jv">out</em>.println(patronName);<br/>} else {<br/>    System.<em class="jv">out</em>.println("Anonymous");<br/>}</span></pre><p id="10c1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样，也可以使用可选的实现，如下所示:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="c207" class="ki kj hh ke b fi kk kl l km kn">Optional&lt;String&gt; patronName = Optional.<em class="jv">ofNullable</em>("John Smith");<br/>System.<em class="jv">out</em>.println(patronName.orElse("anonymous"));</span></pre><p id="9077" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，如果<em class="jv">父名</em>包含一个非空值，将打印该值，否则，将打印字符串‘Anonymous’。</p><blockquote class="js jt ju"><p id="972d" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr ha bi translated">这难道不比null-check方式更简洁吗？</p></blockquote><p id="5670" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以在web上找到更多使用Optional的例子，所以让我在这里重点介绍一些使用Optional的反模式。</p><h2 id="4b6c" class="ki kj hh bd ko kp kq kr ks kt ku kv kw jf kx ky kz jj la lb lc jn ld le lf lg bi translated">1)使用可选的而不是普通的空检查。</h2><p id="6426" class="pw-post-body-paragraph iu iv hh iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr ha bi translated">示例:不必要的包装为可选的，而不是普通的空检查。</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="4380" class="ki kj hh ke b fi kk kl l km kn">if (Optional.<em class="jv">ofNullable</em>(customer.getMiddleName()).isPresent())</span></pre><p id="64d5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">代替</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="bf2b" class="ki kj hh ke b fi kk kl l km kn">if (customer.getMiddleName()!= null) /* one can also use the StringUtils class methods for a wider range of validations. */</span></pre><p id="c785" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一个例子:使用<em class="jv"> isPresent() </em>的嵌套空检查</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="245b" class="ki kj hh ke b fi kk kl l km kn">if (Optional.<em class="jv">ofNullable</em>(customer).isPresent() &amp;&amp; Optional.<em class="jv">ofNullable</em>(customer.getPhoneNumber()).isPresent()) {</span><span id="20ff" class="ki kj hh ke b fi lm kl l km kn">    savePhoneNumber(customer.getPhoneNumber());</span><span id="2ef1" class="ki kj hh ke b fi lm kl l km kn">....</span><span id="c76e" class="ki kj hh ke b fi lm kl l km kn">}</span></pre><h2 id="b474" class="ki kj hh bd ko kp kq kr ks kt ku kv kw jf kx ky kz jj la lb lc jn ld le lf lg bi translated">2)is present()—get()模式</h2><p id="b2b6" class="pw-post-body-paragraph iu iv hh iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr ha bi translated">在代码审查过程中，我经常看到人们结合使用<em class="jv"> ifPresent() </em>和<em class="jv"> get() </em>方法来安全地从可选对象中获取值。虽然这在Java中是合法的，但这是对Optional的低效使用，这通常是由于对我们为什么使用Optional缺乏深入的理解。例如:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="8c13" class="ki kj hh ke b fi kk kl l km kn">if(patronName.isPresent()){</span><span id="0ed7" class="ki kj hh ke b fi lm kl l km kn">    String fullName = patronName.get();</span><span id="e011" class="ki kj hh ke b fi lm kl l km kn">....</span><span id="4d07" class="ki kj hh ke b fi lm kl l km kn">}</span></pre><p id="8f94" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以使用普通的空支票来代替<em class="jv"> isPresent()-get() </em>组合。</p><h2 id="b806" class="ki kj hh bd ko kp kq kr ks kt ku kv kw jf kx ky kz jj la lb lc jn ld le lf lg bi translated">3)使用isPresent()-get()而不是ifPresent()</h2><p id="0503" class="pw-post-body-paragraph iu iv hh iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr ha bi translated"><em class="jv"> ifPresent() </em>方法是一种基于值的存在来执行操作的强大方法。然而，这一点有时会被误用的<em class="jv"> isPresent()-get() </em>组合所忽略。</p><p id="d4a6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如:使用下面的代码片段</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="1520" class="ki kj hh ke b fi kk kl l km kn">List&lt;CustomerAddress&gt; addresses = new ArrayList&lt;&gt;();<br/>if (customerAddressOptional.isPresent()) {<br/>    addresses.add(customerAddressOptional.get());<br/>....<br/>}</span></pre><p id="f248" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">而不是下面简洁的片段:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="75ba" class="ki kj hh ke b fi kk kl l km kn">customerAddressOptional.ifPresent(addresses::add);</span></pre><p id="67df" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，这可能乍一看很明显，但是当许多年轻的Java工程师习惯了if-else范式时，他们会陷入一个常见的陷阱。</p><h2 id="fcaa" class="ki kj hh bd ko kp kq kr ks kt ku kv kw jf kx ky kz jj la lb lc jn ld le lf lg bi translated">4)必要时使用orElse()而不是orElseGet()</h2><p id="1ccb" class="pw-post-body-paragraph iu iv hh iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr ha bi translated">请记住，<em class="jv"> orElse() </em>方法总是执行它的参数，而<em class="jv"> orElseGet() </em>将一个供应商作为它的参数，并且只在可选参数为空时执行。理解它们之间的区别可能会改变游戏规则，特别是当正在执行的操作是资源密集型的，比如web服务调用、数据库查询等。</p><p id="e8a4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">示例:假设我们有一个<em class="jv"> getDefaultValue() </em>方法，定义如下:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="3997" class="ki kj hh ke b fi kk kl l km kn">public String getDefaultValue() {<br/> System.<em class="jv">out</em>.println(“Inside getDefaultValue() method”);<br/> return “Anonymous”;<br/> }</span></pre><p id="0b5c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们在这里看看<em class="jv"> orElse() </em>和<em class="jv"> orElseGet() </em>的行为:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="aed7" class="ki kj hh ke b fi kk kl l km kn">/* getDefaultValue() is always executed in this case. */<br/>Optional&lt;String&gt; patronName = Optional.<em class="jv">of</em>("John Smith");<br/>System.<em class="jv">out</em>.println(patronName.orElse(getDefaultValue()));</span><span id="a534" class="ki kj hh ke b fi lm kl l km kn">/* getDefaultValue() is not executed since patronName is present. */<br/>Optional&lt;String&gt; patronName = Optional.<em class="jv">of</em>(“John Smith”);<br/>System.<em class="jv">out</em>.println(patronName.orElseGet(() -&gt; <em class="jv">getDefaultValue</em>()));</span></pre><p id="e92b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在执行上面的代码片段时，您可以看到，当与<em class="jv"> orElse() </em>一起使用时，无论<em class="jv"> patronName </em>是否存在，都会打印出“<em class="jv">Inside get default value()method”</em>。</p><h2 id="2d08" class="ki kj hh bd ko kp kq kr ks kt ku kv kw jf kx ky kz jj la lb lc jn ld le lf lg bi translated">5)没有利用FlatMap来检查嵌套的可选对象。</h2><p id="d311" class="pw-post-body-paragraph iu iv hh iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr ha bi translated">例如:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="d30b" class="ki kj hh ke b fi kk kl l km kn">Customer customer = null;</span><span id="ae1c" class="ki kj hh ke b fi lm kl l km kn">String lastname = Optional.<em class="jv">ofNullable</em>(customer)<br/>.flatMap(c -&gt; c.lastname)<br/>.orElse(“Not available”);</span><span id="d4db" class="ki kj hh ke b fi lm kl l km kn">System.<em class="jv">out</em>.println(lastname);</span></pre><h2 id="5ea2" class="ki kj hh bd ko kp kq kr ks kt ku kv kw jf kx ky kz jj la lb lc jn ld le lf lg bi translated">6)将方法的参数声明为可选的</h2><p id="6722" class="pw-post-body-paragraph iu iv hh iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr ha bi translated">虽然严格来说这不是一个坏主意，但它可能会导致调用者端不必要的复杂代码。使用重载方法来指定非强制参数要容易得多。</p><p id="70d7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">示例:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="65ae" class="ki kj hh ke b fi kk kl l km kn">public void findNewCustomers(String city, Optional&lt;Integer&gt; numberOfOrders) {<br/> List&lt;Customer&gt; allCustomers = .... ;<br/> allCustomers.stream()<br/> .filter(customer -&gt; customer.city.equals(city))<br/> .filter(customer -&gt; customer.numOrders &gt;=numberOfOrders.orElse(0))<br/> .collect(Collectors.<em class="jv">toList</em>());<br/> }</span></pre><p id="a0eb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种方法的问题是，可以通过将<em class="jv"> null </em>作为第二个参数来调用<em class="jv"> findNewCustomer() </em>方法，这将导致在<em class="jv">number of orders . or else(0)</em>处出现<strong class="iw hi"><em class="jv">NullPointerException</em></strong></p><p id="1b37" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了克服这个异常，我们必须在city属性中加入一个null检查，这就违背了使用Optional的初衷。相反，我们可以将<em class="jv"> numberOfOrders </em>参数声明为一个<em class="jv">整数</em>，如果它在方法执行期间不存在，则执行空值检查来默认它的值。</p><p id="0c0a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请参见下面的片段:</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="83c5" class="ki kj hh ke b fi kk kl l km kn">public void findNewCustomers(String city, Integer numberOfOrders) {<br/> List&lt;Customer&gt; allCustomers = .... ;<br/> <br/> Integer numOfOrders = numberOfOrders !=0 ? numberOfOrders : 0;<br/> allCustomers.stream()<br/> .filter(customer -&gt; customer.city.equals(city))<br/> .filter(customer -&gt; customer.numOrders &gt;=numOfOrders)<br/> .collect(Collectors.<em class="jv">toList</em>());<br/> }</span></pre><h2 id="7564" class="ki kj hh bd ko kp kq kr ks kt ku kv kw jf kx ky kz jj la lb lc jn ld le lf lg bi translated"><strong class="ak">结论:</strong></h2><p id="dcd4" class="pw-post-body-paragraph iu iv hh iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr ha bi translated">Java 8中引入的可选类提供了一个容器来表示引用的可选值。因此，它可以用来更好地处理值的存在或不存在，而不是使用空引用。因此，可以保留空引用来指示程序流中的中断或异常。请记住，引入Optional类并不是为了避免Java中的NullPointerException，使用Optional并不是执行空检查的花哨的糖衣方式。</p><p id="1408" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这些例子基于Java 8版本的可选实现。</p><p id="db53" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最近的Java版本中增加了更多的方法如<em class="jv">或()</em>、<em class="jv"> ifPresentOrElse()、</em>和<em class="jv"> stream() </em>供大家探索…</p></div></div>    
</body>
</html>