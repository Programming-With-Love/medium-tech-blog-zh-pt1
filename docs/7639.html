<html>
<head>
<title>Accelerate Web Test Automation, Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速Web测试自动化，第1部分</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/accelerate-web-test-automation-part-1-e574f31938d1?source=collection_archive---------6-----------------------#2016-09-19">https://medium.com/walmartglobaltech/accelerate-web-test-automation-part-1-e574f31938d1?source=collection_archive---------6-----------------------#2016-09-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/8af18c0acca0d8faa7eccd79de7a66ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JNK7QNwrW9svq7FtXqXO7g.gif"/></div></div></figure><div class=""/><p id="7704" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在开发测试自动化时，性能可能是最后要考虑的事情。然而，有时测试的性能会变得如此重要，以至于测试结果可能会恶化。在这个<strong class="ir ht">加速web测试自动化</strong>系列中，我们将讨论我们对Web测试自动化代码基础设施所做的各种性能改进。</p><h1 id="e021" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">从简单开始</h1><p id="e5aa" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">我们(<a class="ae kq" href="http://testarmada.github.io/" rel="noopener ugc nofollow" target="_blank"> Testarmada </a>团队)在2014年宣布了<a class="ae kq" href="https://github.com/TestArmada/magellan-nightwatch" rel="noopener ugc nofollow" target="_blank"> Magellan-Nightwatch </a> (MN)，Nightwatch.js 适配器。通过将jQuery注入到将要通过selenium的<a class="ae kq" href="https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol#sessionsessionidexecute" rel="noopener ugc nofollow" target="_blank"> execute </a> api执行命令/断言的页面中，MN将始终确保您想要操作的元素是安全的。</p><p id="e5dc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，如果你想通过MN的clickEl api点击一个id为‘submit’的按钮，MN不会点击，除非这个按钮被连续三次检查证明是可见的，每次检查都在这个按钮上执行一个jQuery <em class="kr"> :visible </em>，如果这个按钮是可见的，返回true。</p><p id="e82f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">自从MN被发明的那一天起，它就被用作我们在<a class="ae kq" href="http://www.walmartlabs.com/" rel="noopener ugc nofollow" target="_blank"> WalmartLabs </a>的nightwatch.js的主要补丁。我们的测试自动化团队被jQuery出色的选择器宠坏了，比如<em class="kr"> :visible </em>、<em class="kr"> :eq </em>等等。他们不必担心添加冗余命令来检查他们想要操作的元素是否可操作以避免剥落。在2015年末，<a class="ae kq" href="http://testarmada.github.io" rel="noopener ugc nofollow" target="_blank">http://testar mada . github . io</a>被选为Walmart labs React平台的标准自动化解决方案。所有git pull请求都需要完全通过冒烟测试才能继续。事情好得不像真的。</p><h1 id="f9fd" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><em class="ks">随着流量的增长，总有一些性能需要改进</em></h1><p id="1b2e" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">2016年初，第一个性能问题找上了我们。其中一个团队贡献了超过170个“冒烟”测试，因此套件执行时间超过了1个小时，这意味着对于该团队来说，人们必须等待至少1个小时才能审查和合并代码。嗯…</p><h2 id="1641" class="kt jo hs bd jp ku kv kw jt kx ky kz jx ja la lb kb je lc ld kf ji le lf kj lg bi translated">为什么慢？</h2><p id="bbbe" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">MN进行可见性检查的方式是，它不断发送selenium请求来执行jQuery的<em class="kr"> :visible </em>选择器，直到响应中连续出现三个true。让我们算一下。如果用户想要呼叫clickEl，MN将一起进行至少4次selenium呼叫(3次具有肯定响应的可见性检查和1次click)。这种4-selenium-call模式发生在所有MN命令和断言上，因为它们遵循相同的处理<em class="kr"> :visible </em>检查的方式。硒的含量导致了缓慢。更糟糕的是，较慢的网络连接会加剧这种缓慢。</p><p id="4626" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们做高层次的抽象。假设所有的selenium调用花费相同的时间，比如说<em class="kr"> n </em>毫秒。给定一个测试套件，selenium调用的数量将是(<em class="kr"> m + 4) </em>，其中<em class="kr"> m </em>是可见性检查的否定响应数。此外，还有另一个因素<em class="kr"> w </em>，即每次执行的并发数。这是一个等式</p><blockquote class="lh"><p id="764b" class="li lj hs bd lk ll lm ln lo lp lq jm dx translated"><em class="ks"> t(总套件执行时间)= (n * (m+4)) / w </em></p></blockquote><p id="9e04" class="pw-post-body-paragraph ip iq hs ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">对于固定的<em class="kr"> n，</em>我们可以通过既不增加<em class="kr"> w也不减少</em>(<em class="kr">m+4)来缩短<em class="kr"> t </em>。</em>为了增加<em class="kr"> w </em>，我们引入了分片，这意味着每次执行我们可以有更多的并发性。分片将不在第1部分中讨论。</p><p id="987b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要减少(<em class="kr"> m+4) </em>，我们需要尽可能的摆脱硒召唤。</p><h2 id="a109" class="kt jo hs bd jp ku kv kw jt kx ky kz jx ja la lb kb je lc ld kf ji le lf kj lg bi translated">我们能减少m吗？</h2><p id="4f59" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">几个不确定因素会影响<em class="kr"> m </em>，比如网络速度(网络越慢，<em class="kr"> m </em>可能越大)，或者被测应用服务器的处理速度(处理速度越慢，<em class="kr"> m </em>可能越大)。鉴于执行环境的上下文较少，我们无法真正预测<em class="kr"> m </em>会如何。</p><h2 id="385d" class="kt jo hs bd jp ku kv kw jt kx ky kz jx ja la lb kb je lc ld kf ji le lf kj lg bi translated"><em class="ks">4-硒调用模式可以改变吗？</em></h2><p id="20e1" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">在回答上面的问题之前，让我们仔细看看4-selenium-call模式。四个调用中的三个实际上在做同样的事情，<em class="kr">在需要的时候注入jQuery</em>和<em class="kr">执行jQuery选择器。</em>但最重要的是，注入是通过selenium的同步<a class="ae kq" href="https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol#sessionsessionidexecute" rel="noopener ugc nofollow" target="_blank"> execute </a> api进行的，这意味着每个jQuery注入和选择器操作将占用一个selenium调用。然而，事情不一定非要这样。</p><h2 id="1d83" class="kt jo hs bd jp ku kv kw jt kx ky kz jx ja la lb kb je lc ld kf ji le lf kj lg bi translated"><em class="ks">我们能在一次硒调用中做更多的事情吗？</em></h2><p id="fa1b" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">答案肯定是<strong class="ir ht">是</strong>。但这并不意味着我们可以用selenium的同步执行API来实现。如果注入发生在页面还在加载的时候呢？如果所有的注射都发生在那一刻呢？因为我们无法假设页面完全加载需要多长时间，所以每次注入之间必然会有延迟。然而，execute API不会等待延迟，它总是立即返回。为了在一个selenium调用中做更多的事情，我们不能再使用同步执行api了。</p><p id="5029" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如大多数人可能已经发现的，答案是使用异步版本的执行API，<a class="ae kq" href="https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol#sessionsessionidexecute_async" rel="noopener ugc nofollow" target="_blank"> executeAsync </a>。这个想法是正确的。与立即返回不同，executeAsync将在完成所有事情后调用回调。因此，3个selenium调用可以减少为1个selenium调用，在这里我们可以通过执行jQuery selector并使用<em class="kr"> setTimeout </em>在每个步骤之间延迟来检查元素的可见性。听起来正是我们需要的，对吧？这个解决方案可行吗？</p><p id="e209" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用同步执行API的潜在好处是，无论页面是否准备好了JavaScript注入，它总是会返回。然而，executeAsync不能保证这一点。executeAsync API看起来不错，但还不够好。</p><p id="88ba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们混合同步和异步的优点会怎么样？如果页面不可操作(仍在加载资源、呈现或错误页面)，该函数将立即返回，并仅在页面准备就绪时进行异步可见性检查(JavaScript injectable)。</p><p id="038a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">耶！就是这个！</p><h2 id="08fc" class="kt jo hs bd jp ku kv kw jt kx ky kz jx ja la lb kb je lc ld kf ji le lf kj lg bi translated"><em class="ks">该解决方案有什么帮助？</em></h2><p id="3fce" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">当页面准备好时，优化来自元素的可见性检查。</p><ol class=""><li id="0fab" class="lw lx hs ir b is it iw ix ja ly je lz ji ma jm mb mc md me bi translated">如果页面没有准备好，executeAsync API的工作方式与execute api相同。</li><li id="49a8" class="lw lx hs ir b is mf iw mg ja mh je mi ji mj jm mb mc md me bi translated">如果页面准备好了，3-selenium-API调用现在可以打包成一个调用。</li></ol><h2 id="e4b4" class="kt jo hs bd jp ku kv kw jt kx ky kz jx ja la lb kb je lc ld kf ji le lf kj lg bi translated"><em class="ks">测量</em></h2><p id="ebbb" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">测试改进的时间到了。通过使用electrode checkout在三个浏览器中运行两个每两小时一次的任务，共171个测试(总共513个测试)，一个使用性能改进库，一个使用旧库，持续10天，我们得到以下数据。</p><figure class="ml mm mn mo fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mk"><img src="../Images/76f11cd15fe7290ec42ca5809ccc4471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omueTUZ5a4cGsODEHy1uVw.png"/></div></div></figure><ul class=""><li id="1d2f" class="lw lx hs ir b is it iw ix ja ly je lz ji ma jm mp mc md me bi translated"><strong class="ir ht">非优化</strong>:Magellan测试平均41分钟完成(35个样本的平均值)</li><li id="167e" class="lw lx hs ir b is mf iw mg ja mh je mi ji mj jm mp mc md me bi translated"><strong class="ir ht">优化</strong>:麦哲伦测试平均28分钟完成(35个样本的平均值)</li></ul><p id="0366" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">改进</strong>:(41–28)/41 =<strong class="ir ht">31.7%</strong></p><h1 id="41eb" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="46ff" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">随着第一次性能改进，情况变得越来越好。如果您的测试自动化基础设施与我们的相似，并且您的执行速度很慢，请尝试一下，看看是否有帮助。请在评论里给我留言分享你的经历，这样我就可以回应了。关于这篇文章或者web测试自动化，如果你有什么特别的事情想让我写的话，请告诉我，我会尽力分享我所学到的。</p><p id="7013" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们仍在学习和成长。和我们在一起。</p><p id="76f1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kr">未完待续……</em></p></div></div>    
</body>
</html>