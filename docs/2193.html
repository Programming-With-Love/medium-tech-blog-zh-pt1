<html>
<head>
<title>Konsep Service pada Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Konsep Service pada Android</h1>
<blockquote>原文：<a href="https://medium.easyread.co/konsep-service-pada-android-4b37b2402a9e?source=collection_archive---------1-----------------------#2018-01-08">https://medium.easyread.co/konsep-service-pada-android-4b37b2402a9e?source=collection_archive---------1-----------------------#2018-01-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1f5a41bd93f47f86b5085724242c71ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZNDf9D0utlRpxRqTBmOxA.png"/></div></div></figure><p id="58ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> Hello Coders! </em> pada kesempatan yang kali ini, saya ingin <em class="kt"> sharing </em> lagi tentang <em class="kt"> service </em> pada Android.</p><h1 id="ad48" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Apa itu Service pada Android?</h1><p id="be02" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated"><em class="kt"> Service </em> adalah komponen aplikasi yang menjalankan operasi tertentu yang bisa berjalan lama pada sistem Android, biasanya <em class="kt"> service </em> itu berjalan di latar belakang. <em class="kt"> Service </em> ini tidak menyediakan antarmuka pengguna (UI).</p><p id="908b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Ada dua macam <em class="kt"> service </em> pada Android, yaitu :</p><ul class=""><li id="1a79" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><strong class="jx io"> <em class="kt"> Started </em> </strong></li></ul><p id="014e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> Service </em> yang komponen aplikasinya dimulai dengan memanggil <em class="kt"> startService() </em> . <em class="kt"> Service </em> ini akan berjalan selama belum dimatikan atau proses yang dijalankan selesai. <em class="kt"> Service </em> akan tetap berjalan walaupun komponen yang lain dimatikan oleh sistem Android. <em class="kt"> Service </em> ini digunakan untuk melakukan proses yang tidak memberikan nilai balik ke komponen yang memanggil. Contohnya seperti mengunduh atau mengunggah berkas.</p><ul class=""><li id="7306" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><strong class="jx io"> <em class="kt"> Bound </em> </strong></li></ul><p id="dde4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> Service </em> jenis ini merupakan tipe <em class="kt"> service </em> yang dijalankan oleh komponen lain, namun saling mengikat satu sama lain. Hubungan yang terjadi antar kedua komponen tersebut seperti <em class="kt"> client-server </em> . Bisa saling menerima <em class="kt"> response </em> dan menerima <em class="kt"> request </em> yang ada. Pada <em class="kt"> service </em> ini dimungkinkan terjadi proses IPC ( <em class="kt"> Interprocess Communication </em> ). <em class="kt"> Service </em> ini akan tetap berjalan di background selama masih ada komponen lain yang mengikatnya. Jika tidak, maka <em class="kt"> Service </em> akan dimatikan oleh sistem. Aplikasi pemutar musik merupakan salah satu jenis aplikasi yang mengimplementasikan <em class="kt"> Service </em> jenis ini.</p><p id="391a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Perlu diingat, <em class="kt"> Service </em> berjalan di <em class="kt"> Thread </em> Utama dari proses hostingnya. <em class="kt"> Service </em> tidak membuat <em class="kt"> Thread </em> sendiri dan tidak berjalan di proses terpisah. Kecuali jika anda menetapkannya.</p><p id="5844" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Jika <em class="kt"> service </em> anda akan melakukan pekerjaan yang banyak membutuhkan <em class="kt"> CPU </em> atau operasi pemblokiran (seperti pemutaran MP3 atau jaringan), buat <em class="kt"> Thread </em> baru dalam layanan untuk melakukan pekerjaan itu. Dengan menggunakan <em class="kt"> Thread </em> terpisah, anda akan mengurangi risiko kesalahan Aplikasi Tidak Merespons (Application Not Responding/ANR) dan <em class="kt"> Thread </em> utama aplikasi bisa terus disediakan untuk interaksi pengguna.</p><h1 id="d894" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Deklarasikan Service di AndroidManifest.xml</h1><p id="c093" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Sebagaimana dengan <em class="kt"> activity </em> dan komponen lainnya, Anda harus mendeklarasikan semua <em class="kt"> service </em> dalam file <em class="kt"> AndroidManifest.xml </em> . Untuk mendeklarasikan <em class="kt"> service </em> , tambahkan elemen <em class="kt"> &lt; service &gt; </em> sebagai anak dari elemen <em class="kt"> &lt; application &gt; </em> . Contohnya :</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="1248" class="mp kv in ml b gy mq mr l ms mt"><em class="kt">&lt;?</em><strong class="ml io">xml version="1.0" encoding="utf-8"</strong><em class="kt">?&gt;<br/></em>&lt;<strong class="ml io">manifest ...</strong>&gt;<br/><br/>    &lt;<strong class="ml io">application ... &gt;<br/>        ...</strong><br/>        <strong class="ml io">&lt;service<br/>            android:name=".DownloadIntentService"<br/>            android:exported="false"/&gt;</strong><br/>    &lt;/<strong class="ml io">application</strong>&gt;<br/><br/>&lt;/<strong class="ml io">manifest</strong>&gt;</span></pre><p id="ab8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Untuk memblokir akses ke <em class="kt"> service </em> dari aplikasi lainnya, deklarasikan <em class="kt"> service </em> sebagai privat. Caranya, setel atribut <em class="kt"> android:exported </em> ke <em class="kt"> false </em> . Ini akan menghentikan aplikasi lain dari memulai layanan anda, bahkan bila menggunakan <em class="kt"> Intent </em> eksplisit.</p><h1 id="ed8f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> Started Services </strong></h1><ol class=""><li id="4a4d" class="lx ly in jx b jy ls kc lt kg mu kk mv ko mw ks mx md me mf bi translated">Komponen aplikasi seperti <em class="kt"> activity </em> memanggil <em class="kt"> startService() </em> dan meneruskannya di <em class="kt"> Intent </em> . Dalam hal ini <em class="kt"> Intent </em> menetapkan <em class="kt"> service </em> dan menyertakan data yang akan digunakan oleh <em class="kt"> service </em> .</li><li id="7b2d" class="lx ly in jx b jy my kc mz kg na kk nb ko nc ks mx md me mf bi translated">Sistem akan memanggil metode <em class="kt"> onCreate() </em> dan <em class="kt"> callback </em> lainnya yang sesuai di <em class="kt"> thread </em> utama. Tergantung <em class="kt"> service </em> untuk mengimplementasikan <em class="kt"> callback </em> tersebut dengan perilaku yang sesuai, seperti membuat <em class="kt"> thread </em> sekunder yang akan digunakan.</li><li id="7ffa" class="lx ly in jx b jy my kc mz kg na kk nb ko nc ks mx md me mf bi translated">Sistem akan memanggil metode <em class="kt"> onStartCommand() </em> , dengan meneruskan <em class="kt"> Intent </em> yang disediakan oleh klien di langkah 1. (Klien dalam konteks ini adalah komponen aplikasi yang memanggil <em class="kt"> service </em> ).</li></ol><p id="e49b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Setelah dimulai, <em class="kt"> service </em> bisa berjalan di latar belakang tanpa dibatasi waktu, bahkan jika komponen yang memulainya telah dimusnahkan. Biasanya, <em class="kt"> service </em> yang dimulai menjalankan operasi tunggal dan tidak mengembalikan hasil ke pemanggil. Misalnya, layanan dapat mengunduh atau mengunggah file melalui jaringan. Bila operasi selesai, <em class="kt"> service </em> harus berhenti sendiri dengan memanggil <em class="kt"> stopSelf() </em> , atau komponen lain bisa menghentikannya dengan memanggil <em class="kt"> stopService() </em> .</p><p id="c53f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Misalnya, anggaplah aktivitas perlu menyimpan data ke database online. Aktivitas akan memulai layanan pendamping dengan meneruskan Intent ke <em class="kt"> startService() </em> . Layanan menerima maksud di <em class="kt"> onStartCommand() </em> , menghubungkan ke Internet, dan menjalankan transaksi database. Bila transaksi selesai, layanan akan menggunakan <em class="kt"> stopSelf() </em> untuk menghentikan dirinya sendiri dan dimusnahkan. (Ini adalah contoh layanan yang ingin Anda jalankan di <em class="kt"> thread pekerja/worker thread </em> , sebagai ganti <em class="kt"> thread utama </em> ).</p><p id="280c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> IntentService </strong></p><p id="ec86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Sebagian besar <em class="kt"> service </em> yang dimulai tidak perlu menangani beberapa permintaan secara bersamaan, dan jika <em class="kt"> service </em> melakukannya, maka akan mengakibatkan skenario multi-threading yang berbahaya. Karena itu, sebaiknya Anda mengimplementasikan <em class="kt"> service </em> menggunakan kelas <em class="kt"> IntentService </em> .</p><p id="d050" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> IntentService </em> adalah subkelas yang berguna dari <em class="kt"> Service </em> :</p><ul class=""><li id="6beb" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><em class="kt"> IntentService </em> secara otomatis menyediakan <em class="kt"> thread pekerja/worker thread </em> untuk menangani <em class="kt"> Intent </em> .</li><li id="ed80" class="lx ly in jx b jy my kc mz kg na kk nb ko nc ks mc md me mf bi translated"><em class="kt"> IntentService </em> menangani beberapa kode <em class="kt"> boilerplate </em> yang diperlukan layanan umum (seperti memulai dan menghentikan layanan).</li><li id="b1f7" class="lx ly in jx b jy my kc mz kg na kk nb ko nc ks mc md me mf bi translated"><em class="kt"> IntentService </em> bisa membuat antrian pekerjaan yang meneruskan satu <em class="kt"> intent </em> untuk setiap kalinya ke implementasi <em class="kt"> onHandleIntent() </em> , sehingga Anda tidak perlu mengkhawatirkan multi-threading.</li></ul><p id="97d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Untuk mengimplementasikan <em class="kt"> IntentService </em> :</p><ol class=""><li id="140b" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mx md me mf bi translated">Sediakan konstruktor untuk <em class="kt"> service </em> .</li><li id="153f" class="lx ly in jx b jy my kc mz kg na kk nb ko nc ks mx md me mf bi translated">Buat implementasi <em class="kt"> onHandleIntent() </em> untuk melakukan pekerjaan yang disediakan <em class="kt"> client </em> .</li></ol><p id="99a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Inilah contoh dari implementasi <em class="kt"> IntentService </em> :</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="942a" class="mp kv in ml b gy mq mr l ms mt"><strong class="ml io">public class </strong>HelloIntentService <strong class="ml io">extends </strong>IntentService {<br/>    <em class="kt">/**<br/>     * A constructor is required, and must call the super IntentService(String)<br/>     * constructor with a name for the worker thread.<br/>     */<br/>    </em><strong class="ml io">public </strong>HelloIntentService() {<br/>        <strong class="ml io">super</strong>(<strong class="ml io">"HelloIntentService"</strong>);<br/>    }<br/>    <em class="kt">/**<br/>     * The IntentService calls this method from the default worker thread with<br/>     * the intent that started the service. When this method returns, IntentService<br/>     * stops the service, as appropriate.<br/>     */<br/>    </em>@Override<br/>    <strong class="ml io">protected void </strong>onHandleIntent(Intent intent) {<br/>        <em class="kt">// Normally we would do some work here, like download a file.<br/>        // For our sample, we just sleep for 5 seconds.<br/>        </em><strong class="ml io">try </strong>{<br/>            Thread.<em class="kt">sleep</em>(5000);<br/>        } <strong class="ml io">catch </strong>(InterruptedException e) {<br/>            <em class="kt">// Restore interrupt status.<br/>            </em>Thread.<em class="kt">currentThread</em>().interrupt();<br/>        }<br/>    }<br/>}</span></pre><h1 id="54fc" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Bound Services</h1><p id="17ad" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">“ <em class="kt"> Bound </em> ” <em class="kt"> Services </em> bila komponen aplikasi mengikatnya dengan memanggil <em class="kt"> bindService() </em> . Bound Servicesmenawarkan antarmuka <em class="kt"> client-server </em> yang memungkinkan komponen berinteraksi dengan <em class="kt"> service </em> , mengirim <em class="kt"> request </em> , dan mendapatkan <em class="kt"> response </em> , kadang-kadang menggunakan komunikasi interproses (IPC) untuk mengirim dan menerima informasi di seluruh proses. <em class="kt"> Service </em> ini hanya berjalan selama komponen aplikasi terikat padanya. Beberapa komponen bisa diikat ke <em class="kt"> service </em> sekaligus, namun bila semuanya telah dilepas, <em class="kt"> service </em> akan dimusnahkan. <em class="kt"> Service </em> ini umumnya tidak mengizinkan memulai komponen dengan memanggil <em class="kt"> startService() </em> .</p><p id="1558" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Implementasi Bound Services </strong></p><p id="e48c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Untuk mengimplementasikan <em class="kt"> Bound Services </em> , definisikan antarmuka yang menetapkan cara klien bisa berkomunikasi dengan <em class="kt"> service </em> . Antarmuka ini, yang dikembalikan <em class="kt"> service </em> Anda dari metode callback <em class="kt"> onBind() </em> , harus berupa implementasi <em class="kt"> IBinder </em> . Untuk mengambil antarmuka <em class="kt"> IBinder </em> , komponen aplikasi klien memanggil <em class="kt"> bindService() </em> . Setelah klien menerima <em class="kt"> IBinder </em> , klien berinteraksi dengan <em class="kt"> service </em> melalui antarmuka itu.</p><p id="e2ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Ada sejumlah cara untuk mengimplementasikan <em class="kt"> Bound Services </em> , dan implementasi tersebut lebih rumit daripada <em class="kt"> Started Services </em> . Untuk detail selengkapnya tentang <em class="kt"> Bound Services </em> , lihat <a class="ae nd" href="https://developer.android.com/guide/components/bound-services.html" rel="noopener ugc nofollow" target="_blank"> <em class="kt"> Bound Services </em> </a> .</p><p id="e7d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Mengikat ke Service </strong></p><p id="1d11" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Untuk mengikat ke <em class="kt"> service </em> yang dideklarasikan di file <em class="kt"> AndroidManifest.xml </em> dan diimplementasikan oleh komponen aplikasi, gunakan <em class="kt"> bindService() </em> dengan <em class="kt"> Explicit </em> <em class="kt"> Intent </em> .</p><p id="73dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Perhatian </strong> : Jangan gunakan <em class="kt"> Implicit Intent </em> untuk mengikat ke <em class="kt"> service </em> . Melakukannya adalah bahaya keamanan, karena Anda tidak bisa memastikan <em class="kt"> service </em> yang akan merespons <em class="kt"> Intent </em> tersebut, dan pengguna tidak bisa melihat <em class="kt"> service </em> mana yang dimulai. Mulai dengan Android 5.0 ( <em class="kt"> API level 21 </em> ), sistem membuat <em class="kt"> exception </em> jika Anda memanggil <em class="kt"> bindService() </em> dengan <em class="kt"> Implicit Intent </em> .</p><h1 id="1a4a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Life Cycle Service</h1><p id="39bc" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Daur hidup <em class="kt"> service </em> lebih sederhana daripada <em class="kt"> activity </em> . Akan tetapi, ini jauh lebih penting karena Anda memerhatikan dari dekat cara <em class="kt"> service </em> dibuat dan dimusnahkan. Karena tidak memiliki <em class="kt"> UI </em> , <em class="kt"> service </em> bisa terus berjalan di latar belakang tanpa diketahui pengguna, bahkan jika pengguna beralih ke aplikasi lain. Ini menghabiskan sumber daya dan menguras baterai. Seperti <em class="kt"> activity </em> , <em class="kt"> service </em> memiliki metode callback daur hidup yang bisa Anda implementasikan untuk memantau perubahan keadaan <em class="kt"> service </em> dan melakukan pekerjaan pada waktu yang sesuai. Berikut kerangka <em class="kt"> service </em> yang memperagakan setiap metode daur hidup :</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="4485" class="mp kv in ml b gy mq mr l ms mt"><strong class="ml io">public class </strong>ExampleService <strong class="ml io">extends </strong>Service {<br/>    <strong class="ml io">int mStartMode</strong>; <em class="kt">// indicates how to behave if the service is killed<br/>    </em>IBinder <strong class="ml io">mBinder</strong>; <em class="kt">// interface for clients that bind<br/>    </em><strong class="ml io">boolean mAllowRebind</strong>; <em class="kt">// indicates whether onRebind should be used<br/>    </em>@Override<br/>    <strong class="ml io">public void </strong>onCreate() {<br/>        <em class="kt">// The service is being created<br/>    </em>}<br/>    @Override<br/>    <strong class="ml io">public int </strong>onStartCommand(Intent intent, <strong class="ml io">int </strong>flags, <strong class="ml io">int </strong>startId) {<br/>        <em class="kt">// The service is starting, due to a call to startService()<br/>        </em><strong class="ml io">return mStartMode</strong>;<br/>    }<br/>    @Override<br/>    <strong class="ml io">public </strong>IBinder onBind(Intent intent) {<br/>        <em class="kt">// A client is binding to the service with bindService()<br/>        </em><strong class="ml io">return mBinder</strong>;<br/>    }<br/>    @Override<br/>    <strong class="ml io">public boolean </strong>onUnbind(Intent intent) {<br/>        <em class="kt">// All clients have unbound with unbindService()<br/>        </em><strong class="ml io">return mAllowRebind</strong>;<br/>    }<br/>    @Override<br/>    <strong class="ml io">public void </strong>onRebind(Intent intent) {<br/>        <em class="kt">// A client is binding to the service with bindService(),<br/>        // after onUnbind() has already been called<br/>    </em>}<br/>    @Override<br/>    <strong class="ml io">public void </strong>onDestroy() {<br/>        <em class="kt">// The service is no longer used and is being destroyed<br/>    </em>}<br/>}</span></pre><p id="2fec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Daur Hidup <em class="kt"> Started Service </em> dan <em class="kt"> Bound Service </em> </strong></p><p id="577b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> Bound Service </em> hanya tersedia untuk menyajikan komponen aplikasi yang terikat padanya, sehingga bila tidak ada lagi komponen yang diikat ke <em class="kt"> service </em> tersebut, sistem akan memusnahkannya. <em class="kt"> Bound Service </em> tidak perlu dihentikan secara eksplisit seperti halnya <em class="kt"> Started Service </em> (menggunakan <em class="kt"> stopService() </em> atau <em class="kt"> stopSelf() </em> ).</p><p id="3bdd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Gambar dibawah ini adalah menampilkan perbedaan daur hidup dari keduanya :</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/98004f694f13f0bd7f25964ee2c1bd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*XwnMB2vyqV4k1H9Kj1HGpA.jpeg"/></div></div></figure><p id="5dd2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Foreground Service </strong></p><p id="036d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Walaupun sebagian besar layanan berjalan di latar belakang, sebagian lagi ada yang berjalan di latar depan ( <em class="kt"> Foreground </em> ). <em class="kt"> Foreground Service </em> adalah <em class="kt"> service </em> yang diketahui pengguna, jadi ini bukan layanan yang bakal dimatikan sistem bila memori tinggal sedikit.</p><p id="e8b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Misalnya, pemutar musik yang memutar musik dari <em class="kt"> service </em> harus disetel untuk berjalan di latar depan, karena pengguna mengetahui operasinya. Notifikasi di bilah status dapat menunjukkan lagu saat ini dan memungkinkan pengguna meluncurkan aktivitas untuk berinteraksi dengan pemutar musik.</p><p id="7970" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Untuk meminta agar layanan berjalan di latar depan, panggil <em class="kt"> startForeground() </em> sebagai ganti <em class="kt"> startService() </em> . Metode ini menggunakan dua parameter: integer yang secara unik mengidentifikasi notifikasi dan Notification untuk bilah status. Notifikasi ini sedang berlangsung, artinya tidak bisa ditutup. Notifikasi tetap berada di bilah status hingga <em class="kt"> service </em> dihentikan atau dibuang dari latar depan. Misalnya :</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="d5af" class="mp kv in ml b gy mq mr l ms mt">NotificationCompat.Builder <strong class="ml io">mBuilder </strong>=<br/>        <strong class="ml io">new </strong>NotificationCompat.Builder(<strong class="ml io">this</strong>)<br/>                .setSmallIcon(R.drawable.notification_icon)<br/>                .setContentTitle(<strong class="ml io">"My notification"</strong>)<br/>                .setContentText(<strong class="ml io">"Hello World!"</strong>);<br/>startForeground(ONGOING_NOTIFICATION_ID, <strong class="ml io">mBuilder</strong>.build());</span></pre><p id="ad7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Catatan: ID integer yang Anda berikan ke <em class="kt"> startForeground() </em> tidak boleh 0.</p><p id="0cce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Untuk membuang layanan dari latar depan, panggil <em class="kt"> stopForeground() </em> . Metode ini memerlukan <em class="kt"> boolean </em> , yang menunjukkan apakah akan membuang notifikasi bilah status atau tidak. Metode ini tidak menghentikan <em class="kt"> service </em> . Akan tetapi, jika Anda menghentikan <em class="kt"> service </em> sewaktu masih berjalan di latar depan, maka notifikasi juga akan dibuang.</p><h1 id="d11a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Scheduled services</h1><p id="3a03" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Untuk <em class="kt"> API </em> level 21 dan yang lebih tinggi, Anda bisa meluncurkan service menggunakan <em class="kt"> JobScheduler API </em> . Untuk menggunakan <em class="kt"> JobScheduler </em> , Anda perlu mendaftarkan tugas dan menetapkan persyaratannya untuk jaringan dan pengaturan waktu. Sistem menjadwalkan tugas untuk dieksekusi di waktu yang tepat.</p><p id="f541" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Antarmuka <em class="kt"> JobScheduler </em> menyediakan banyak metode untuk mendefinisikan ketentuan eksekusi layanan. Untuk detailnya, lihat <a class="ae nd" href="https://developer.android.com/reference/android/app/job/JobScheduler.html" rel="noopener ugc nofollow" target="_blank"> <em class="kt"> JobScheduler reference </em> </a> .</p><p id="1cfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Nah seperti itu konsep dari <em class="kt"> Service </em> pada Android :D Jangan menyerah untuk terus belajar ya :) Saya sendiri awalnya pusing mengerti konsep yang sebenarnya lebih banyak dari ini :D Mudah-mudahan dengan postingan kali ini yang sedikit ringkas ini bisa membuat anda mengerti tentang <em class="kt"> Service </em> . Sekian dari saya, apabila terdapat kesalahan dalam penulisan, mohon dimaafkan :D</p><p id="ef7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> Salam Coders! </em></p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><p id="35e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> Artikel ini di tulis oleh </em> <a class="nm nn ep" href="https://medium.com/u/423a2702de9a?source=post_page-----4b37b2402a9e--------------------------------" rel="noopener" target="_blank"> <em class="kt"> Mahesa Iqbal Ridwansyah </em> </a> <em class="kt"> beliau sering menulis artikel mengenai Software Engineering dan Programming. Follow profilnya untuk mendapatkan update-an terbaru artikel-artikel beliau. </em></p><p id="6fd9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> Jika anda merasa artikel ini menarik dan bermanfaat, bagikan ke lingkaran pertemanan anda, agar mereka dapat membaca artikel ini. </em></p></div></div>    
</body>
</html>