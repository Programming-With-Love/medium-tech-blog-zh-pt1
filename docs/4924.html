<html>
<head>
<title>Why Kotlin has Mutable Collections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么科特林有可变集合</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/why-kotlin-has-mutable-collections-3937a515f913?source=collection_archive---------2-----------------------#2020-10-01">https://blog.kotlin-academy.com/why-kotlin-has-mutable-collections-3937a515f913?source=collection_archive---------2-----------------------#2020-10-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="127d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">原因比你想象的要深。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b3fb8d48f7b3e631fbb0ae5ae14beca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ksilW_7FpsB_yg8E7vYxpQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image taken from: <a class="ae ks" href="https://www.runtastic.com/blog/en/kotlin-collections-inside-part-1/" rel="noopener ugc nofollow" target="_blank">https://www.runtastic.com/blog/en/kotlin-collections-inside-part-1/</a></figcaption></figure><p id="d230" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Kotlin中的一切都是巧妙而优雅的——你永远不必编写不必要的代码，原始语言结构<em class="lp">就可以工作</em>。但是<a class="ae ks" href="https://kotlinlang.org/docs/reference/collections-overview.html#collection-types" rel="noopener ugc nofollow" target="_blank">可变集合</a>和不可变集合之间的二分法似乎是可以避免的。它是语言中不可或缺的一部分，这一事实一定指向了更深层的东西。</p><p id="5217" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">简单的一行解释是这样的:</p><blockquote class="lq"><p id="a9a6" class="lr ls in bd lt lu lv lw lx ly lz lo dk translated">可变和不可变集合分别公开了不能共存于单个接口中的有用特性。可变集合是可变的，而不可变集合是协变的。</p></blockquote><p id="a64d" class="pw-post-body-paragraph kt ku in kv b kw ma jo ky kz mb jr lb lc mc le lf lg md li lj lk me lm ln lo ig bi translated">如果这对你没有意义，不要担心。这篇文章的其余部分是写给你解释的！</p><h1 id="3a8e" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">类型层次结构</h1><p id="fa8b" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">在继续之前，我们需要建立一些关于等级类型的重要东西。</p><h2 id="5ecc" class="nc mg in bd mh nd ne dn ml nf ng dp mp lc nh ni mr lg nj nk mt lk nl nm mv nn bi translated">分配能力</h2><p id="4da4" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">考虑以下变量:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/0c6be1b1ae5f4b4f81e7a7f8142aa007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTO6YkTVZC7dy_T-7fRLSg.png"/></div></div></figure><p id="8731" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然变量是用类型<code class="fe np nq nr ns b">Shape</code>声明的，但是实际上可以在其中存储类型<code class="fe np nq nr ns b">Rectangle</code>的对象。这是因为<code class="fe np nq nr ns b">Rectangle</code>是<code class="fe np nq nr ns b">Shape</code>的一个子类型，所以它至少实现了<code class="fe np nq nr ns b">Shape</code>的所有属性/字段/方法。</p><p id="e296" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，这是有效的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/f38b7824b9218091acb3c317fe00aba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qdSJ2I2nt7aI4KvyS1QcJg.png"/></div></div></figure><p id="c853" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就引出了你需要记住的第一个要点:</p><blockquote class="lq"><p id="9927" class="lr ls in bd lt lu lv lw lx ly lz lo dk translated">当将一个对象赋给一个变量时，<strong class="ak">变量</strong>的类型必须是的<strong class="ak">超类型(或者与<strong class="ak">传入对象</strong>的类型相同)。</strong></p></blockquote><p id="1e2a" class="pw-post-body-paragraph kt ku in kv b kw ma jo ky kz mb jr lb lc mc le lf lg md li lj lk me lm ln lo ig bi translated">强调变量类型和对象类型之间的区别是很重要的。变量<code class="fe np nq nr ns b">myShape</code>看起来像一个<code class="fe np nq nr ns b">Shape</code>，但实际上包含一个<code class="fe np nq nr ns b">Rectangle</code>。</p><p id="1406" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从这个意义上说，变量的类型定义了一个接口。当你与<code class="fe np nq nr ns b">myShape</code>互动时，你与<code class="fe np nq nr ns b">Rectangle</code>互动，但你只以<code class="fe np nq nr ns b">Shape</code>特定的方式这样做。</p><h2 id="92fa" class="nc mg in bd mh nd ne dn ml nf ng dp mp lc nh ni mr lg nj nk mt lk nl nm mv nn bi translated">对象的类型</h2><p id="153a" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">为了显示<code class="fe np nq nr ns b">myShape</code>实际上包含一个<code class="fe np nq nr ns b">Rectangle</code>，考虑<code class="fe np nq nr ns b">Shape</code>的实现:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/bac46301ba6abfcbffc1d2654317d9bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRDTuxgTwNzcY7vJk7cfmg.png"/></div></div></figure><p id="f0db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">而这个<code class="fe np nq nr ns b">Rectangle</code>的实现:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/27172d324f332e78d6c566cffa7588aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CY0V-ttbCCWvz5P2yg6gyw.png"/></div></div></figure><p id="bdbc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你运行<code class="fe np nq nr ns b">myShape.description()</code>，你会得到如下结果:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/342c5a126de2d9b90d50ddb67bf85f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgoOoWX3coMa8JbpvbX3JA.png"/></div></div></figure><p id="698a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为底层对象的类型是<code class="fe np nq nr ns b">Rectangle</code>。<code class="fe np nq nr ns b">shape</code>中的引用是对<code class="fe np nq nr ns b">Rectangle</code>方法的引用。</p><h2 id="ec12" class="nc mg in bd mh nd ne dn ml nf ng dp mp lc nh ni mr lg nj nk mt lk nl nm mv nn bi translated">变量的类型</h2><p id="d874" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">为了说明您只能以<code class="fe np nq nr ns b">Shape</code>特有的方式与<code class="fe np nq nr ns b">myShape</code>交互，假设<code class="fe np nq nr ns b">Rectangle</code>还定义了以下函数:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/1b91f8bcbabbd884238340ae64a3503a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2CTf4wLNZzBQ3QhOKshLA.png"/></div></div></figure><p id="4abd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您运行<code class="fe np nq nr ns b">myShape.describeRectangularProperties()</code>，您将得到以下编译时错误:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/a475db3856ea810c08f55f784f63e404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XWWCDZQZaqHXDczhCNnIAg.png"/></div></div></figure><p id="4031" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为变量<code class="fe np nq nr ns b">myShape</code>属于<code class="fe np nq nr ns b">Shape</code>类型，因此不能公开<code class="fe np nq nr ns b">Rectangle</code>特定的方法<code class="fe np nq nr ns b">describeRectangularProperties()</code>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/f4d3b77c29932261dfba2ed5119f3048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*SCCfRIMGWPPELiAe9BmU-w.png"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/9040086270a48f34718d96f7a4a89974.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*CIdaRaFJwQd51TPobENVcA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">A Rectangle object in a Shape variable</figcaption></figure><h1 id="8d0d" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">类型参数</h1><p id="eb91" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">当谈到集合时，<code class="fe np nq nr ns b">Shape</code>和<code class="fe np nq nr ns b">Rectangle</code>会显示为类型参数(如<code class="fe np nq nr ns b">List&lt;Shape&gt;</code>和<code class="fe np nq nr ns b">List&lt;Rectangle&gt;</code>)。像这样依赖于类型参数的类被称为<a class="ae ks" href="https://kotlinlang.org/docs/reference/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>。</p><p id="847c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">作为类型参数的<code class="fe np nq nr ns b">Shape</code>和<code class="fe np nq nr ns b">Rectangle</code>的作用有点复杂。在深入研究集合之前，让我们考虑一个更一般的问题:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/18557425171c9f0302ecd54adf1e7607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLG8PzuxJr9G15sxsaAdfg.png"/></div></div></figure><p id="db67" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然这看起来很自然，但你不能将一个<code class="fe np nq nr ns b">Generic&lt;Rectangle&gt;</code>对象赋给一个<code class="fe np nq nr ns b">Generic&lt;Shape&gt;</code>变量。换句话说，这可能是无效的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/792f8d6b10231159030721df3e5f0df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Q5Ij0J94ItakAUJBXfWVw.png"/></div></div></figure><p id="0dde" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是因为类型<code class="fe np nq nr ns b">Generic&lt;Shape&gt;</code> / <code class="fe np nq nr ns b">Generic&lt;Rectangle&gt;</code>的对象不仅仅封装了<code class="fe np nq nr ns b">Shape</code> / <code class="fe np nq nr ns b">Rectangle</code>对象。它们还封装了一些方法，这些方法的行为取决于所提供的类型参数(<code class="fe np nq nr ns b">Shape</code>或<code class="fe np nq nr ns b">Rectangle</code>)。这让事情变得复杂了。</p><p id="668f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，让我们来分析一下。在方法中，类型参数只能出现在两个地方:</p><h2 id="7e82" class="nc mg in bd mh nd ne dn ml nf ng dp mp lc nh ni mr lg nj nk mt lk nl nm mv nn bi translated">返回类型</h2><p id="a500" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">在此<code class="fe np nq nr ns b">Drawable</code>界面中:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/0b6a0a4f96366990a5053fed87e32026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNS2vW8tMFLzNk_PpP8pLw.png"/></div></div></figure><p id="aaf8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">…类型参数<code class="fe np nq nr ns b">T</code>只出现在封装的抽象方法的返回类型中。</p><p id="f7f7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在Kotlin中，这种类型参数是通过在泛型定义中的类型参数前放置<code class="fe np nq nr ns b">out</code>关键字来标记的。</p><h2 id="a930" class="nc mg in bd mh nd ne dn ml nf ng dp mp lc nh ni mr lg nj nk mt lk nl nm mv nn bi translated">参数类型</h2><p id="a1c9" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">在这个<code class="fe np nq nr ns b">Stackable</code>界面中:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/6db9b8537cb62e1eee234d32f0122db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmanpfyWV3nvLpvKikIcJw.png"/></div></div></figure><p id="6756" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">…类型参数<code class="fe np nq nr ns b">T</code>只显示为封装的抽象方法的参数类型。</p><p id="559d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在Kotlin中，这种类型参数是通过在泛型定义中的类型参数前放置<code class="fe np nq nr ns b">in</code>关键字来标记的。</p><h1 id="20a2" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">协方差</h1><p id="dd9b" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">考虑像<code class="fe np nq nr ns b">List&lt;Shape&gt;</code>这样的不可变集合。一旦它被构造，你唯一能做的就是读取它——因此，它的内部方法只会返回<code class="fe np nq nr ns b">Shape</code> s，而不会接收它们。这类似于上面的<code class="fe np nq nr ns b">Drawable</code>界面。</p><p id="5d62" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这种泛型有一个非常特殊的属性——它们遵循与它们的类型参数相同的继承关系:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/d70f9f76f796d6a8637802a43e37ba80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKI1s40fpqZj4vDJbbeuew.png"/></div></div></figure><p id="233d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你仔细想想，这是有意义的——只要我们需要返回<code class="fe np nq nr ns b">Shape</code>的对象，我们就可以发送一个返回<code class="fe np nq nr ns b">Rectangles</code>的对象。这里最重要的词是“回报”。</p><p id="dd68" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个属性被称为"<strong class="kv io">协方差"</strong>，因为泛型的类型层次<em class="lp">随类型参数的层次</em>一起变化。</p><h1 id="f44e" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">对不可变集合的需求</h1><p id="a20e" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">协方差对于集合来说是一个非常有用的属性:它感觉起来很自然，并且使代码更加直观。但是只有不可变集合才有可能。</p><p id="4b5a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你看，可变集合需要公开添加和移除元素的方法；这些方法必须接受类型参数作为参数。如上所述，这意味着可变集合不能协变。</p><p id="1327" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了让这最后一段更清楚，我们来看一个例子。如果我们允许可变集合是协变的，下面的代码将是有效的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/b846d8fe1d3f0439883ebe7094ba5e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ta7rOFB3SrARVj9QYjS-1g.png"/></div></div></figure><p id="0408" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是让我们看看如果我们允许它，会出什么问题:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi no"><img src="../Images/306d6a66528f06c6ac30a738bec765fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zLdY8j5mg_lDWKczljevIw.png"/></div></div></figure><p id="eade" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后一行会抛出运行时错误！这是因为最后一行试图将一个<code class="fe np nq nr ns b">Circle</code>添加到一个<code class="fe np nq nr ns b">MutableList&lt;Rectangle&gt;</code>中。</p><p id="a657" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有两种方法可以避免上述错误:</p><ol class=""><li id="dadd" class="nv nw in kv b kw kx kz la lc nx lg ny lk nz lo oa ob oc od bi translated">如果<code class="fe np nq nr ns b">rectanglesList</code>不能放入类型为<code class="fe np nq nr ns b">MutableList&lt;Shape&gt;</code>的变量中(即没有协方差)</li><li id="8f50" class="nv nw in kv b kw oe kz of lc og lg oh lk oi lo oa ob oc od bi translated">如果<code class="fe np nq nr ns b">shapesList</code>和<code class="fe np nq nr ns b">rectanglesList</code>没有类似<code class="fe np nq nr ns b">add()</code>的方法(即没有可变性)</li></ol><p id="93aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">即使将类型检查添加到可变集合中的所有写方法，这些类型检查也会产生它们自己的运行时错误/异常……这违背了Kotlin尽可能具有编译时类型安全性的哲学。</p><p id="6aa6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里要传达的信息是:</p><blockquote class="oj ok ol"><p id="4bd8" class="kt ku lp kv b kw kx jo ky kz la jr lb om ld le lf on lh li lj oo ll lm ln lo ig bi translated">可变性和协变性不能在同一个集合接口中实现。</p></blockquote><h1 id="d999" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">结论</h1><ol class=""><li id="ff13" class="nv nw in kv b kw mx kz my lc op lg oq lk or lo oa ob oc od bi translated">可变集合可以从写入的<em class="lp">和</em>中读取。但是Kotlin努力避免所有运行时故障，因此，这些可变集合是不变的。</li><li id="1f58" class="nv nw in kv b kw oe kz of lc og lg oh lk oi lo oa ob oc od bi translated">不可变集合是协变的，但是它们是…嗯…不可变的。尽管如此，Kotlin确实提供了用这些不可变集合做有用事情的机制(比如过滤值或从现有的不可变集合创建新的不可变集合)。这篇文章给出了一个很好的例子列表:</li></ol><div class="os ot gp gr ou ov"><a href="https://medium.com/mobile-app-development-publication/read-only-collection-in-kotlin-leads-to-better-coding-40cdfa4c6359" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd io gy z fp pa fr fs pb fu fw im bi translated">Kotlin中的只读集合导致更好的编码。</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">在Kotlin中，如果创建一个列表或映射，它就是只读的(类似于不可变的，但略有不同)。这意味着什么…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">medium.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj km ov"/></div></div></a></div><p id="0a76" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从元素构建集合时使用可变集合。</p><p id="b7ef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不过，最终要将它们转移到不可变集合中，这将在需要时为您带来协变赋值的额外好处。</p></div><div class="ab cl pk pl hr pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="ig ih ii ij ik"><h1 id="abbb" class="mf mg in bd mh mi pr mk ml mm ps mo mp jt pt ju mr jw pu jx mt jz pv ka mv mw bi translated">点击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="7048" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">了解卡帕头最新的重大新闻。学院、<a class="ae ks" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>、<a class="ae ks" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在Medium上关注我们。</p><p id="f846" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您需要Kotlin工作室，请查看我们如何帮助您:<a class="ae ks" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi pw"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>