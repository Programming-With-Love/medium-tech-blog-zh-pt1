<html>
<head>
<title>Getting started with C++ and Android Native Activities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++和Android原生活动入门</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/getting-started-with-c-and-android-native-activities-2213b402ffff?source=collection_archive---------0-----------------------#2019-02-25">https://medium.com/androiddevelopers/getting-started-with-c-and-android-native-activities-2213b402ffff?source=collection_archive---------0-----------------------#2019-02-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="de38" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="a1cd" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我将带您了解如何设置一个简单的Android原生活动。我将介绍基本的设置，并尝试为您提供前进所需的工具。</p><p id="ad3d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">虽然我的重点是游戏，但我不会告诉你如何编写OpenGL应用程序或如何设计你自己的游戏引擎。这是一个几乎可以填满书籍的讨论。</p><h1 id="f9c7" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">为什么选择C++</h1><p id="3b3d" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在Android上，操作系统及其支持基础设施被设计成支持用Java或Kotlin编程语言编写的应用程序。用这些语言编写的应用程序受益于嵌入到系统底层架构中的工具。许多核心的Android系统特性，比如Android UI和意图处理，只通过Java接口公开。</p><p id="4147" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">选择使用C++，并不比使用诸如Kotlin或Java之类的托管语言更“原生”于Android。与直觉相反，在某种程度上，你正在编写一个只有部分Android功能可用的外国应用程序。对于大多数应用程序来说，使用像Kotlin这样的语言会更好。</p><p id="0356" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这条规则有几个例外。游戏开发是我最关心的事情。由于游戏通常使用定制的渲染逻辑，通常用OpenGL或Vulkan编写，所以预计游戏看起来与标准的Android应用程序不同。当你也考虑到C和C++对于每一个计算平台几乎都是通用的，以及相对丰富的C库来支持游戏开发时，走上原生开发的道路就变得合理了。</p><p id="1dcd" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">如果你想从头开始做一个游戏，或者移植现有的游戏，Android的原生开发工具包(或NDK)及其支持工具已经准备好了。事实上，我将向您展示的本机活动提供了一个简单的一站式商店，您可以在其中设置OpenGL画布并开始收集用户输入。你可能会发现，尽管C的认知开销，一些常见的代码挑战，如从游戏数据构建顶点属性数组，在C++中变得比高级语言更容易。</p><h1 id="89be" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">我不会报道的</h1><p id="80ec" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我不会向你展示如何初始化一个<a class="ae kf" href="https://www.khronos.org/vulkan/" rel="noopener ugc nofollow" target="_blank"> Vulkan </a>或<a class="ae kf" href="https://www.khronos.org/opengles/" rel="noopener ugc nofollow" target="_blank"> OpenGL </a>上下文。我推荐通读谷歌提供的<a class="ae kf" href="https://github.com/googlesamples/android-ndk/" rel="noopener ugc nofollow" target="_blank">样本</a>，尽管我会提供一些提示让你的生活更轻松。你可以选择使用像SDL这样的库，甚至谷歌的库。</p><h1 id="9ceb" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">设置您的IDE</h1><p id="64a3" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">首先，我们需要确保您已经为本地开发安装了所有东西。为此，我们需要安卓NDK。启动Android Studio:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/e1b2a1cec35e62d45f3a0e1eb634e884.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/0*PA-Xq6EqB-lE3jrt"/></div></figure><p id="85d3" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">并在“配置”下选择“SDK管理器”:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ko"><img src="../Images/06edbd2f3e457046cbb245855aef43f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/0*XkTYhsrl0frw9d1A"/></div></figure><p id="659f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">从这里安装LLDB(本机调试器)、CMake(我们将使用的构建系统)和NDK本身:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kp"><img src="../Images/f2c3668aba2f683c5254c48325cbd7d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uy97JiOnnh2aar8b"/></div></div></figure><h1 id="8e25" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">创建您的项目</h1><p id="e3e0" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">现在您已经设置好了一切，我们将创建一个项目。我们想要创建一个没有活动的空项目:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ku"><img src="../Images/8f71e7636459f69c759087cc3ce9ec8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5gtGSseWGEljglcK"/></div></div></figure><p id="4137" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">自Gingerbread以来，NativeActivity就已经出现在Android中，但如果你刚刚开始学习，我建议你选择当时可用的最高目标。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ku"><img src="../Images/f5cfc5da5e539e80274eee8b21347c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EHxm6XZy9PFoX1BJ"/></div></div></figure><p id="db48" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">现在我们需要制作一个CMakeLists.txt来告诉Android如何构建我们的C++项目。在项目视图中右键单击您的应用程序，并创建一个新文件:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kv"><img src="../Images/6cfb558a519082b31e01b178d2505bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/0*3174Sy0lsdV_izN8"/></div></figure><p id="c157" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">已命名CMakeLists.txt:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kw"><img src="../Images/7a0d028fbf542e1ba0c6439c31035d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/0*UjYrafAf-GIjfcp1"/></div></figure><p id="998d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">并创建一个简单的CMake文件:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="6d8d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们声明我们正在Android Studio (3.6.0)中使用最新的CMake，并且我们正在构建一个名为helloworld-c的共享库。我还添加了一个我们必须创建的源文件。</p><p id="8e27" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">为什么是共享库而不是可执行文件？Android使用一个称为Zygote的进程来加速在Android运行时内启动应用程序或服务的过程。这适用于Android中每个面向用户的进程，所以你的应用程序运行代码的第一个机会实际上是在一个托管的虚拟机中。然后，托管代码必须加载一个包含您的逻辑的共享库文件，如果您使用本机活动，这将为您处理。相反，当构建一个可执行文件时，期望操作系统会直接加载你的程序并执行一个叫做“main”的C函数这是Android中的<em class="kz">可能</em>，但我还没有发现它的任何实际用途。</p><p id="c8a9" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">现在创建C++文件:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es la"><img src="../Images/5411dd8f23ecb3d89907d1d0ef8e5b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*3bEdMVWFetPHaLh8"/></div></figure><p id="d688" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">并将它重新定位到我们在make文件中指定的目录:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lb"><img src="../Images/e2ff3ff2abd5a8af8868a9fd75c0fe67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0RgvGlIX1A5qXOO-W5K0Zw.png"/></div></div></figure><p id="ec1f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">让我们放入一些小东西，它会告诉我们它是否正在正确构建:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="1cac" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">最后，让我们将C++项目链接到我们的应用程序中:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lc"><img src="../Images/0953ea33486be867c968059d486b164d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*peP9yeLNekk5o0Yg"/></div></div></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es ld"><img src="../Images/67bde279c109478afa7b495a598a4f85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rkx1eC_6gH0nZ1N5"/></div></div></figure><p id="1228" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">如果一切顺利，项目将成功更新:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es le"><img src="../Images/e8c4aef7598b909f3a80e4c5b9880ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gbNXngCYA7e990Vn"/></div></div></figure><p id="7302" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">您可以毫无问题地运行构建:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lf"><img src="../Images/a0ab7f7a6d4551cbe628bebe20737ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/0*SpKDW8ZXatIV2ioE"/></div></figure><p id="b719" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">至于你的构建脚本有什么变化。如果你打开你的应用的build.gradle，你应该会看到这个<code class="du lg lh li lj b">externalNativeBuild</code>条目:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><h1 id="18f3" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">创建本地活动</h1><p id="e82c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">活动基本上是Android用来显示应用程序界面的窗口。通常你会用Java或Kotlin编写一个扩展Activity的类，但是Google创建了一个特殊的C等价类，叫做native activity。</p><h1 id="3953" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">设置您的构建文件</h1><p id="33ee" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">创建本地活动的最佳方式是包含<code class="du lg lh li lj b">native_app_glue</code>。许多示例将其从SDK复制到他们的项目中。这并没有错，但是我个人的偏好是把它留在原地，让这个成为我的游戏所依赖的库。我将使它成为一个静态库，这样我就不用支付动态库调用的额外成本:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="4c4c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这里有很多东西需要分解，所以我们开始吧。首先我<code class="du lg lh li lj b">add_library</code>创建一个名为<code class="du lg lh li lj b">native_app_glue</code>的库，并将其命名为<code class="du lg lh li lj b">STATIC</code>库。然后我寻找自动生成的环境变量<code class="du lg lh li lj b">${ANDROID_NDK}</code>来寻找NDK安装中的一些文件。使用这个，我取出了native_app_glue的实现:<code class="du lg lh li lj b">android_native_app_glue.c</code>。</p><p id="a85e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在我将代码与目标关联之后，我想说目标在哪里找到它的头文件。我使用<code class="du lg lh li lj b">target_include_directories</code>将文件夹和它所有的标题放在一起，并将它们标为<code class="du lg lh li lj b">PUBLIC</code>标题。其他选项是<code class="du lg lh li lj b">INTERNAL</code>或<code class="du lg lh li lj b">PRIVATE</code>这些范围现在无关紧要。一些教程可能会使用<code class="du lg lh li lj b">include_directories</code>而不是<code class="du lg lh li lj b">target_include_directories</code>。这是一种更古老的做法。最近的<code class="du lg lh li lj b">target_include_directories</code>允许您将目录与目标相关联，这有助于降低大型项目的复杂性。</p><p id="757b" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">现在，我希望能够将东西记录到Android的LogCat中。仅仅写入标准输出(例如:<code class="du lg lh li lj b">std::cout</code>或<code class="du lg lh li lj b">printf</code>)并不像在普通的C和C++应用程序中那样有效。使用<code class="du lg lh li lj b">find_library</code>定位<code class="du lg lh li lj b">log</code>，我们缓存Android的日志库，以备后用。</p><p id="3ee1" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">最后，我们告诉CMake让<code class="du lg lh li lj b">helloworld-c</code>依赖于<code class="du lg lh li lj b">native_app_glue</code>、<code class="du lg lh li lj b">android</code>，以及我们使用<code class="du lg lh li lj b">target_link_libraries</code>调用的库<code class="du lg lh li lj b">log-lib</code>。这将让我们在C++项目中引用本机应用程序逻辑。在<code class="du lg lh li lj b">add_library</code>之前的<code class="du lg lh li lj b">set</code>调用也确保了helloworld-c没有实现由<code class="du lg lh li lj b">android_native_app_glue</code>提供的一个名为<code class="du lg lh li lj b">ANativeActivity_onCreate,</code>的函数。</p><h1 id="272a" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">编写一个简单的本地活动</h1><p id="cdf7" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">现在我们准备好了，让我们建立我们的应用程序！</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="29b6" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这里发生了什么事？</p><p id="826e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">首先，用<code class="du lg lh li lj b">extern "C"{}</code>，我们只是告诉链接器我们需要把那些花括号之间的所有东西都当作C。你仍然可以在里面写C++代码，但是对于我们程序的其余部分来说，这些函数看起来像C函数。</p><p id="9210" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我正在创建一个小占位符函数<code class="du lg lh li lj b">handle_cmd</code>。这将作为我们未来的信息循环。任何触摸事件、窗口事件、&amp; c都会通过这里。</p><p id="4fe6" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">节目的核心是<code class="du lg lh li lj b">android_main</code>。当应用程序启动时，这个函数由<code class="du lg lh li lj b">android_native_app_glue</code>调用。我们首先将<code class="du lg lh li lj b">pApp-&gt;onAppCmd</code>指向我们的消息循环，这样系统消息就有了去处。</p><p id="07d7" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">接下来我们使用<code class="du lg lh li lj b">ALooper_pollAll</code>来处理所有排队的系统事件，第一个参数是超时。如果我们得到一个大于或等于0的值，我们需要帮助<code class="du lg lh li lj b">pSource</code>处理事件。否则，我们继续，直到应用程序关闭。</p><p id="bda2" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们仍然不能运行这个活动，但是可以自由构建以确保一切正常。</p><h1 id="9fc9" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">将所需信息添加到ApplicationManifest中</h1><p id="3c07" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">现在我们需要填写您的AndroidManifest.xml来告诉您的系统如何运行您的应用程序。您可以在应用程序&gt;清单&gt; AndroidManfiest.xml下找到它:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lk"><img src="../Images/4695b99870ddca486debb5656e58c163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1A_awLp5-K82UG_z"/></div></div></figure><p id="19a1" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">首先，我们将告诉Android android关于本机活动(称为“android.app.NativeActivity”)的信息，并告诉它不要因为方向变化或键盘状态变化而破坏活动:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="7cea" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">然后我们告诉本机活动在哪里可以找到我们想要运行的代码。如果您忘记了名称，请查看您的CMakeLists.txt！</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="61fd" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们告诉Android操作系统这是一个启动器活动，也是主要活动:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="fce3" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">如果一切顺利，您可以点击debug并看到一个空白窗口！</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lc"><img src="../Images/012f61c7c586caf1e36a2e431ea19d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uxFZ9rm7AA3nokHt"/></div></div></figure><h1 id="c496" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">为OpenGL做好准备</h1><p id="740f" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">google样本库中已经有优秀的OpenGL样本:</p><div class="ll lm ez fb ln lo"><a href="https://github.com/googlesamples/android-ndk/tree/master/native-activity" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab dw"><div class="lq ab lr cl cj ls"><h2 class="bd hi fi z dy lt ea eb lu ed ef hg bi translated">googlesamples/android-ndk</h2><div class="lv l"><h3 class="bd b fi z dy lt ea eb lu ed ef dx translated">Android工作室的Android NDK示例。通过在…上创建帐户，为googlesamples/android-ndk开发做出贡献</h3></div><div class="lw l"><p class="bd b fp z dy lt ea eb lu ed ef dx translated">github.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc km lo"/></div></div></a></div><p id="3f77" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我会给你一些有用的提示让你开始。首先，要使用OpenGL，在CMakeLists.txt中添加以下几行:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es md"><img src="../Images/108993d5116e9f94c6f7ec4cd4c585f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*3yD719x_3mGZ4qAy"/></div></div></figure><p id="9586" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在这里，你可以为各种Android平台做更多的智能工作，但是将EGL和GLESv3添加到你的目标中对于最新版本的Android来说是没问题的。</p><p id="0c26" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">接下来，我想创建一个名为<code class="du lg lh li lj b">Renderer</code>的类来处理我的渲染。如果你用一个构造函数来初始化你的渲染器，用析构函数来销毁它，用一个<code class="du lg lh li lj b">render()</code>函数来渲染，我建议你的程序看起来像这样:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="kx ky l"/></div></figure><p id="d4b6" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">所以，我做的第一件事就是开始使用<code class="du lg lh li lj b">android_app</code>中这个叫做<code class="du lg lh li lj b">userData</code>的小字段。你可以在这里存储任何你想要的东西，这个<code class="du lg lh li lj b">android_app</code>的每个实例都会得到它。我选择添加我的渲染器。</p><p id="acc1" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">接下来，我只能在窗口初始化后拥有一个渲染器，并且在它被破坏时必须将其删除。我使用我之前告诉过你的那个<code class="du lg lh li lj b">handle_cmd</code>函数来做这件事。</p><p id="0605" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">最后，如果有渲染器(即:窗口已创建)，我从<code class="du lg lh li lj b">android_app</code>检索它，并要求它渲染。否则我就继续处理这个循环。</p><h1 id="c1e2" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论</h1><p id="dd1c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">此时，您已经准备好使用OpenGL ES 3，就像您在任何其他平台上一样！如果您需要更多资源或教程，以下是一些有用的链接:</p><ul class=""><li id="ebba" class="me mf hh je b jf ka jj kb jn mg jr mh jv mi jz mj mk ml mm bi translated">谷歌的安卓NDK样本对我拼凑这个教程是非常宝贵的:【https://github.com/googlesamples/android-ndk/ T4】</li><li id="c63b" class="me mf hh je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm bi translated">对于原生活动:<a class="ae kf" href="https://github.com/googlesamples/android-ndk/tree/master/native-activity" rel="noopener ugc nofollow" target="_blank">https://github . com/Google samples/Android-ndk/tree/master/native-activity</a></li><li id="45be" class="me mf hh je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm bi translated">CMake是我在Android for C++上的首选构建系统，你可以在这里找到参考页面:<a class="ae kf" href="https://cmake.org/" rel="noopener ugc nofollow" target="_blank">https://cmake.org/</a></li><li id="1830" class="me mf hh je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm bi translated">如果你是第一次接触CMake，或者如果你对<code class="du lg lh li lj b">target_include_directories</code>而不是<code class="du lg lh li lj b">include_directories</code>不熟悉，我推荐你阅读“现代”CMake:<a class="ae kf" href="https://cliutils.gitlab.io/modern-cmake/" rel="noopener ugc nofollow" target="_blank">https://cliutils.gitlab.io/modern-cmake/</a></li><li id="c20b" class="me mf hh je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm bi translated">OpenGL ES 3参考页面:<a class="ae kf" href="https://www.khronos.org/registry/OpenGL-Refpages/es3.0/" rel="noopener ugc nofollow" target="_blank">https://www.khronos.org/registry/OpenGL-Refpages/es3.0/</a></li><li id="2000" class="me mf hh je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm bi translated">安卓的Java OpenGL教程。它以Java为中心，但是讨论了许多Android特有的问题:<a class="ae kf" href="https://developer.android.com/training/graphics/opengl/" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/training/graphics/opengl/</a></li><li id="dfae" class="me mf hh je b jf mn jj mo jn mp jr mq jv mr jz mj mk ml mm bi translated">NeHe的OpenGL教程有点过时了，主要集中在旧的OpenGL桌面版本上。我还没有找到更好的OpenGL入门教程:<a class="ae kf" href="http://nehe.gamedev.net/" rel="noopener ugc nofollow" target="_blank">http://nehe.gamedev.net/</a></li></ul></div></div>    
</body>
</html>