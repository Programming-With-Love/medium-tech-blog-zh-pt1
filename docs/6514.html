<html>
<head>
<title>Advanced Python made easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级Python变得简单</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/advanced-python-made-easy-eece317334fa?source=collection_archive---------0-----------------------#2018-09-06">https://medium.com/quick-code/advanced-python-made-easy-eece317334fa?source=collection_archive---------0-----------------------#2018-09-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/9bc4e41a67b4f08b22a02756dbf5384b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SgDJheMsi779kthQFZtYBg.jpeg"/></div></div></figure><p id="5e87" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Python是一种面向对象的语言，非常类似于英语，这使它成为初学者学习的好语言。它的高级特性和支持的库包甚至使得困难的任务可以写成一堆代码行。在本文中，我们将介绍python的一些高级特性。</p><h2 id="5c68" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated"><strong class="ak">列表理解</strong></h2><p id="777d" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">列表理解为无处不在的循环提供了一个更短更好的替代<em class="kn">。它用在迭代的环境中，我们需要对列表中的每个元素执行操作。</em></p><p id="6260" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">语法:- </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="a006" class="jn jo hh kt b fi kx ky l kz la">          <strong class="kt hi">[some_operation(element) for element in sequence]<br/>                                - returns list of elements.</strong></span></pre><p id="97de" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">示例:- </strong></p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div><figcaption class="ld le et er es lf lg bd b be z dx">List comprehension example</figcaption></figure><p id="8c93" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们连接了从两个列表理解返回的列表。第一个是在列表的每个元素上应用<em class="kn">偶数校验</em>，而第二个执行<em class="kn">奇数校验</em>。</p><h2 id="426b" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated"><strong class="ak">切片</strong></h2><p id="e1b7" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">切片用于从给定序列中提取元素的连续序列/子序列。默认情况下<em class="kn">步长</em>为1，因此生成连续序列。然而，我们可以为<em class="kn"> step_size </em>提供任何值来获得非连续的元素序列。</p><p id="a956" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">语法:- </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="dad9" class="jn jo hh kt b fi kx ky l kz la">                <strong class="kt hi">list[start_index : end_index : step_size]</strong>     <br/>                           <strong class="kt hi">- returns list of elements.<br/>                           - default start_index is 0.<br/>                           - default end_index is -1.<br/>                           - default step_size is 1.</strong></span></pre><p id="7f8e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">例子:- </strong></p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div><figcaption class="ld le et er es lf lg bd b be z dx">List slicing example with step size as 1</figcaption></figure><p id="b397" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，我们再次连接两个切片操作的结果。首先，我们从索引' d '到结尾对列表进行切片，然后从开始到索引' d'。</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="161e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">展示step_size用例的另一个例子。步长为-1意味着切片将从结束到开始。</p><h2 id="ea21" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated"><strong class="ak">λ</strong></h2><p id="80ea" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">Lambda是一个匿名函数，只能保存一个表达式。它基本上是函数的简写，可以用在任何需要表达式的地方。</p><p id="92e7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">语法:- </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="308d" class="jn jo hh kt b fi kx ky l kz la">                  <strong class="kt hi">lambda arguments : expression</strong></span></pre><p id="9a03" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">举例:- </strong></p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div><figcaption class="ld le et er es lf lg bd b be z dx">Lambda expression for square root.</figcaption></figure><h2 id="b1ea" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">地图</h2><p id="413b" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">Map用于我们需要对一系列元素应用函数/lambda的场景。尽管您几乎总是可以用列表理解来代替使用映射的需要。</p><p id="b560" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">语法:- </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="68fe" class="jn jo hh kt b fi kx ky l kz la">                      <strong class="kt hi">map(function , sequence)<br/>                                           - returns an iterable.</strong></span></pre><p id="a639" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">示例:- </strong></p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="e515" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kn">映射</em>用于对序列的每个元素求平方。由于<em class="kn">映射</em>返回一个iterable，我们需要用期望的类型包装结果(上例中的<em class="kn">列表</em>)。</p><h2 id="5c9c" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">过滤器</h2><p id="da8d" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">另一方面，Filter对元素序列应用函数/lambda，并返回函数/lambda为其返回<em class="kn"> True </em>的元素序列。</p><p id="c702" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">语法:- </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f8d4" class="jn jo hh kt b fi kx ky l kz la">                     <strong class="kt hi">filter(function, sequence)<br/>                                    - returns an iterable.</strong></span></pre><p id="e40b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">例子:- </strong></p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="3222" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，我们应用filter只返回序列中的偶数。强烈推荐2021年<a class="ae lh" href="https://blog.coursesity.com/learning-plan-learn-coding-in-python-like-a-tiger/" rel="noopener ugc nofollow" target="_blank">学Python </a>编程。</p><h2 id="8980" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">迭代协议</h2><p id="748f" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">贯穿python编程语言的一个重要概念是迭代协议和可迭代对象。用最简单的术语来说，iterable是可以使用迭代协议进行迭代的东西。理解迭代协议的一个最简单的方法是看它如何与内置类型一起工作。让我们以文件为例。我们要用的样本文件是<em class="kn"> script.py </em>，内容如下<em class="kn"> :- </em></p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="df62" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在python中，我们有很多种读取文件的方法，有些方法比其他方法更有效。不属于后一类的一种方法是使用<em class="kn">读取线</em>。</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="c4a8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一种更好也更有效的方法是使用for循环:-</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="0d6a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这只是读取整个文件的一行代码。但是它是如何工作的呢？到底for循环是如何知道逐行读取文件的？</p><p id="3052" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好了，迭代协议来了。总结如下</p><blockquote class="li lj lk"><p id="3dfc" class="ip iq kn ir b is it iu iv iw ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl jm ha bi translated">任何使用__next__方法前进到下一个结果并在一系列结果结束时引发StopIteration异常的对象，在python中都被认为是迭代器。任何这样的对象也可以用for循环或其他迭代工具来单步执行。</p></blockquote><p id="aba1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的例子中，文件对象本身是一个迭代器(因为它实现了所需的接口)，而for循环是一个迭代工具。下面是python中我们称之为迭代协议的most接口(<em class="kn"> most在这里确实有意义，如下文</em>所述)。</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="f0ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是for循环内部或一般任何迭代工具将做的事情，即调用<em class="kn"> __next__ </em>方法，直到到达结尾。除了for循环，python中还有其他迭代工具，如<em class="kn"> list comprehension、map、zip </em>等。</p><p id="6f4a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到目前为止一切顺利，然而迭代协议还有一步，那就是获取底层对象的迭代器。<em class="kn">文件对象不需要这一步，因为它有自己的迭代器</em>。但是对于像list这样的其他对象，我们需要通过这个额外的步骤来获取迭代器。</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure><h2 id="5a0b" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated"><strong class="ak">发电机</strong></h2><p id="2cbb" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">生成器是创建迭代器的一种简单方式。更正式地说，生成器是返回一个对象(迭代器)的函数，我们可以迭代这个对象(一次迭代一个值)。如果我们用python从头开始编写同样的功能，它会是这样的</p><p id="8285" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">示例:- </strong></p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="aff9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，python让我们变得很容易。下面是一些类似的使用发电机。可以看到，上面提到的所有开销(<em class="kn">调用__iter__()和__next__() </em>)都是由生成器自动处理的。</p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure><blockquote class="li lj lk"><p id="83fa" class="ip iq kn ir b is it iu iv iw ix iy iz ll jb jc jd lm jf jg jh ln jj jk jl jm ha bi translated"><em class="hh">生成器是通过用yield语句而不是return语句</em>定义一个普通函数来创建的，即如果该函数包含至少一个yield语句，它就成为一个生成器函数。yield和return都将从函数中返回一些值。尽管函数在执行return时终止，但yield语句会暂停函数，保存它的所有状态，然后在后续调用中继续执行。</p></blockquote><p id="aab0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本质上是发电机，</p><ul class=""><li id="0ea6" class="lo lp hh ir b is it iw ix ja lq je lr ji ls jm lt lu lv lw bi translated">至少有一条yield语句。</li><li id="c38f" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">返回一个对象(迭代器)，但不立即开始执行。</li><li id="ffb6" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">记住局部变量及其在连续调用之间的状态。</li><li id="e9ae" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">实现迭代协议。</li></ul><h2 id="4c56" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated"><strong class="ak">发电机表情</strong></h2><p id="f31c" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">正如lambda是函数，生成器表达式是python中的生成器，即生成器表达式创建一个匿名的生成器函数。它的语法非常类似于列表理解。</p><p id="9f38" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">举例:- </strong></p><figure class="ko kp kq kr fd ii"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="dbbb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">列表理解和生成器之间的主要区别在于，列表理解生成整个列表，而生成器表达式一次生成一个项目。从本质上说，它们是列表理解的一个懒惰的对抗部分。</p><p id="28a9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">为什么用python写生成器？</strong></p><ul class=""><li id="3afe" class="lo lp hh ir b is it iw ix ja lq je lr ji ls jm lt lu lv lw bi translated">它们很容易实现。正如你所看到的，在生成器的帮助下，我们能够将几十行代码转换成3行代码</li><li id="aa50" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">它们的内存效率极高。返回2的下一次幂的普通函数会在内存中创建一个完整的序列。在数十亿个数字的情况下，成本将是巨大的。生成器可以以更友好的方式实现它们，因为它们一次生成一个元素，而不是整个序列</li><li id="25da" class="lo lp hh ir b is lx iw ly ja lz je ma ji mb jm lt lu lv lw bi translated">生成器也可以用来表示无限的数据流。因为无限流不能存储在内存中，所以生成器在这种情况下也很有用。</li></ul><p id="1f60" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请通过您的评论让我知道文章中需要的任何修改/改进。</p></div></div>    
</body>
</html>