<html>
<head>
<title>Reference and Value Types in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的参考和值类型</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/reference-and-value-types-in-swift-de792db330b2?source=collection_archive---------0-----------------------#2016-07-14">https://medium.com/capital-one-tech/reference-and-value-types-in-swift-de792db330b2?source=collection_archive---------0-----------------------#2016-07-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/991fd3241f6996175ecfcb90c92aed0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ksALvTyQZhX7LgKlc0lqVA.jpeg"/></div></div></figure><div class=""/><p id="670e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我们将探讨引用类型和值类型之间的区别。我们将介绍这两个概念，看看它们的优缺点，并研究如何在Swift中利用它们。</p><h1 id="7518" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><em class="kl">参考类型</em></h1><blockquote class="km kn ko"><p id="b5a7" class="ip iq kp ir b is it iu iv iw ix iy iz kq jb jc jd kr jf jg jh ks jj jk jl jm ha bi translated"><strong class="ir ht">引用类型</strong>:一种类型，一旦被初始化，当被赋给一个变量或常量时，或者当被传递给一个函数时，返回对同一个现有实例的引用。</p></blockquote><p id="eb6e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">引用类型的一个典型例子是对象。一旦实例化，当我们将它赋值或作为值传递时，我们实际上是在将引用赋值或传递给原始实例(即它在内存中的位置)。引用类型赋值据说具有浅层复制语义。</p><p id="3da7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Swift中，使用<strong class="ir ht">类</strong>关键字定义对象:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="4732" class="lc jo hs ky b fi ld le l lf lg">class PersonClass {<br/>    var name: String</span><span id="b655" class="lc jo hs ky b fi lh le l lf lg">    init(name: String) {<br/>        self.name = name<br/>    }<br/>}</span><span id="6b0a" class="lc jo hs ky b fi lh le l lf lg">var person = PersonClass(name: "John Doe")</span></pre><h1 id="6a5c" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><em class="kl">值类型</em></h1><blockquote class="km kn ko"><p id="375a" class="ip iq kp ir b is it iu iv iw ix iy iz kq jb jc jd kr jf jg jh ks jj jk jl jm ha bi translated"><strong class="ir ht">值类型</strong>:当赋值给变量或常量，或者传递给函数时，创建新实例(副本)的类型。</p></blockquote><p id="9ffc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">值类型的一个典型例子是基元类型。常见的原语类型，也是值类型，有:<strong class="ir ht"> Int </strong>，<strong class="ir ht"> Double </strong>，<strong class="ir ht"> String </strong>，<strong class="ir ht"> Array </strong>，<strong class="ir ht"> Dictionary </strong>，<strong class="ir ht"> Set </strong>。一旦实例化，当我们分配它或者把它作为一个值传递时，我们实际上得到的是原始实例的一个副本。</p><p id="381e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Swift中最常见的值类型是<strong class="ir ht">struct</strong>，<strong class="ir ht">enum</strong>和<strong class="ir ht">tuple</strong>可以是值类型。值类型赋值据说具有深度复制语义。</p><h1 id="959a" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><em class="kl">复制语义</em></h1><p id="f4d0" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">我将通过一个实例来说明复制语义之间的区别。假设我们正在使用一个通用的树形数据结构:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="09d9" class="lc jo hs ky b fi ld le l lf lg">class Node&lt;T: Comparable&gt; {<br/>    let value: T<br/>    var left: Node?<br/>    var right: Node?</span><span id="8549" class="lc jo hs ky b fi lh le l lf lg">    convenience init(value: T) { […] }</span><span id="30c3" class="lc jo hs ky b fi lh le l lf lg">    init(value: T, left: Node?, right: Node?){ […] }<br/><br/>    func add(value: T) { […] }<br/>}</span></pre><p id="6c0f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以轻松地创建一个二叉树的实例，如下所示:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="1eb8" class="lc jo hs ky b fi ld le l lf lg">let binaryTree = Node(value: 8)<br/>tree.add(2)<br/>tree.add(13)</span></pre><figure class="kt ku kv kw fd hj er es paragraph-image"><div class="er es ln"><img src="../Images/d96149e621a6595b8ae533f9aed5e089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*OiqXI5hUfolWUoJ8Ex_yFg.jpeg"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">A binary tree instance</figcaption></figure><p id="f13e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，让我们来看看复制语义的不同行为。</p><h2 id="0ce5" class="lc jo hs bd jp ls lt lu jt lv lw lx jx ja ly lz kb je ma mb kf ji mc md kj me bi translated"><strong class="ak">浅层复制(引用类型)</strong></h2><p id="262b" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">复制引用类型时，Swift编译器会复制实例的引用。但不是它的属性。因此，当创建引用类型对象的多个副本时，每个副本将共享由实例属性表示的相同数据。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div class="er es mf"><img src="../Images/cee569d20c6ce773b45757efe3ddab6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*LahWkFaO1hrby1MewTnCZA.jpeg"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Binary tree shallow copy</figcaption></figure><h2 id="8635" class="lc jo hs bd jp ls lt lu jt lv lw lx jx ja ly lz kb je ma mb kf ji mc md kj me bi translated"><strong class="ak">深度复制(值类型)</strong></h2><p id="e5e8" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">复制值类型时，Swift编译器会制作原始实例的全新副本。这意味着所有原始实例属性都被复制到新的实例属性中。这个过程对每个本身是值类型的属性重复进行。因此，当创建值类型对象的多个副本时，每个副本将是一个没有共享数据的新的单独实例。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div class="er es mg"><img src="../Images/34ecae89d3afb74c235ef490298546a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*LKTg6ViVjnGYStPcNyxjfA.jpeg"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Binary tree deep copy</figcaption></figure><h1 id="7c41" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">引用类型实例的问题:隐式数据共享</strong></h1><p id="3a46" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">为了展示引用类型的典型问题，让我们定义一个<strong class="ir ht">类</strong>来表示2D空间中的一个点。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="72c4" class="lc jo hs ky b fi ld le l lf lg">class PointClass {<br/>    var x: Int = 0<br/>    var y: Int = 0</span><span id="5880" class="lc jo hs ky b fi lh le l lf lg">    init(x: Int, y: Int) {<br/>        self.x = x<br/>        self.y = y<br/>    }<br/>}</span></pre><p id="90fa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，如果我们实例化一个<strong class="ir ht"> PointClass </strong>对象并将其分配给另一个对象，会发生什么呢？</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="d77a" class="lc jo hs ky b fi ld le l lf lg">var pointA = PointClass(x: 1, y: 3)<br/>var pointB = pointA</span></pre><p id="f2c1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为<strong class="ir ht"> PointClass </strong>是一个引用类型，所以最后一条语句实际上是将对<em class="kp"> pointA </em>的引用赋值给<em class="kp"> pointB </em>。我们可以用图形表示上述场景如下:</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div class="er es mh"><img src="../Images/3b955042e55422f4b7c9d9ff4e6e50ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*N6PpaM5C6vRKO4wkNdZ3zg.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Reference type instances</figcaption></figure><p id="2cec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种情况下，<em class="kp"> pointB </em>和<em class="kp"> pointA </em>和<strong class="ir ht">共享</strong>同一个实例。因此，<em class="kp">点A </em>的任何变化都会反映在<em class="kp">点B </em>上，反之亦然。这在许多情况下可能没问题，但也是细微错误的常见来源。</p><p id="d75d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们来看看一种非常简单的方法来解决隐式共享数据问题。假设我们实例化了一个视图控制器，并给它分配了一个对一个<strong class="ir ht">人</strong>对象(我们的<em class="kp">对象模型</em>)实例的引用。然后，作为对用户交互的响应，我们推送另一个视图控制器(在第一个视图控制器之上)，并为它分配相同的引用实例。我们可以将这一特定场景想象如下:</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div class="er es mi"><img src="../Images/322dffb766102da0f3a46250364173b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*jpPRvUoNin9IFO6r5CBkYg.jpeg"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Assigning a reference type to more than one view controller</figcaption></figure><p id="9b5a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于两个视图控制器被分配了相同的引用实例，如果我们在<em class="kp"> SecondViewController </em>中修改它的任何属性，我们最终会修改最初分配给<em class="kp"> FirstViewController </em>的原始(共享)<strong class="ir ht"> Person </strong>实例。因此，在<em class="kp"> SecondViewController </em>内部对<em class="kp">对象模型</em>的任何修改都将传播到<em class="kp"> FirstViewController </em>。</p><p id="f444" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">回到我们最初的例子，避免隐式数据共享问题的一种方法是显式创建实例的副本。我们可以手动创建一个副本并分配它，而不仅仅是分配<em class="kp">点A </em>:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="9471" class="lc jo hs ky b fi ld le l lf lg">var pointB = pointA.copy()</span></pre><p id="4c01" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，<em class="kp">点B </em>将有自己单独的引用，并且在<em class="kp">点A </em>和<em class="kp">点B </em>之间不再有共享数据。这种技术工作良好，但是有一些缺点:</p><ul class=""><li id="7280" class="mj mk hs ir b is it iw ix ja ml je mm ji mn jm mo mp mq mr bi translated">不得不:</li><li id="8fa5" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">—从NSObject继承并实现NSCopying</li><li id="ffcd" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">—实施新的<em class="kp">可复制</em>协议，用于在Swift中复制对象</li><li id="4d82" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">为每个赋值显式调用<em class="kp"> copy() </em>会引入一些开销</li><li id="9240" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">很容易忘记为每个赋值调用<em class="kp"> copy() </em></li></ul><h1 id="9141" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">值类型实例:没有隐式共享</strong></h1><p id="74ed" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">当分配值类型时，编译器将自动创建(并返回)实例的副本。让我们看看，如果不将我们的2D点定义为一个<strong class="ir ht">类</strong>(引用类型)，而是将其定义为一个<strong class="ir ht">结构</strong>(值类型)，会发生什么。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="97e6" class="lc jo hs ky b fi ld le l lf lg">struct PointStruct {<br/>    var x: Int = 0<br/>    var y: Int = 0</span><span id="c9d6" class="lc jo hs ky b fi lh le l lf lg">    init(x: Int, y: Int) {<br/>        self.x = x<br/>        self.y = y<br/>    }<br/>}</span></pre><p id="c8c2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们可以创建一个<strong class="ir ht"> PointStruct </strong>的实例，并将其分配给另一个实例。</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="3f0e" class="lc jo hs ky b fi ld le l lf lg">var pointA = PointStruct(x: 1, y: 3)<br/>var pointB = pointA</span></pre><p id="d29a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为<strong class="ir ht"> PointStruct </strong>是一个值类型，所以最后一条语句创建了一个<em class="kp"> pointA </em>的副本，并将其分配给<em class="kp"> pointB </em>。这使得赋值是安全的，因为两个实例是不同的。我们可以用图形表示这种情况如下:</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div class="er es mh"><img src="../Images/2baad419521912e4ecac436168f44fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*fy15016EX_uhEkpMgiMX2Q.png"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Values type instances</figcaption></figure><p id="a658" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以看到<em class="kp"> pointB </em>有自己单独的引用，在<em class="kp"> pointA </em>和<em class="kp"> pointB </em>之间不会有共享数据。这表明，通过使用值类型，我们可以很容易地确保我们的所有实例都是不同的，并且不共享任何数据。</p><p id="1fe4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从性能的角度来看，使用值类型不会增加很大的开销:</p><blockquote class="km kn ko"><p id="00c0" class="ip iq kp ir b is it iu iv iw ix iy iz kq jb jc jd kr jf jg jh ks jj jk jl jm ha bi translated"><strong class="ir ht">副本很便宜</strong> <br/>复制一个基本类型(<strong class="ir ht"> Int </strong>，<strong class="ir ht"> Double </strong>，…)需要恒定的时间<br/>复制一个<strong class="ir ht">结构</strong>，<strong class="ir ht">枚举</strong>或<strong class="ir ht">元组</strong>值类型需要恒定的时间</p><p id="a21a" class="ip iq kp ir b is it iu iv iw ix iy iz kq jb jc jd kr jf jg jh ks jj jk jl jm ha bi translated"><strong class="ir ht">可扩展数据结构使用写时复制</strong> <br/>复制涉及固定数量的引用计数操作<br/>这种技术被许多标准库类型使用:<strong class="ir ht">字符串</strong>、<strong class="ir ht">数组</strong>、<strong class="ir ht">集合</strong>、<strong class="ir ht">字典</strong>、…</p></blockquote><p id="6365" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除上述之外，值类型的另一个性能优势是它们是堆栈分配的，这比堆分配(用于引用类型)更有效。这使得访问速度更快，但缺点是必须放弃对继承的支持。</p><p id="5d47" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">需要指出的是，只有当<strong class="ir ht">结构</strong>、<strong class="ir ht">枚举</strong>和<strong class="ir ht">元组</strong>的所有属性都是值类型时，它们才是<em class="kp">真值类型</em>。如果它们的任何属性是引用类型，我们仍然会遇到上一段中描述的隐式数据共享问题。</p><p id="471b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们来看看下面的<strong class="ir ht">结构</strong>:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="5c13" class="lc jo hs ky b fi ld le l lf lg">struct PersonView {<br/>    let person: PersonStruct<br/>    let view: UIView<br/>}</span></pre><p id="e917" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的预期目标是创建一个容器来跟踪一个人，并处理一个显示所有相关信息的视图。我们可能会自信地认为上面的代码是合理的；毕竟我们用<strong class="ir ht">让</strong>声明了所有属性，对吗？不幸的是，事实并非如此。因为<em class="kp">视图</em>属性是一个引用，因为<strong class="ir ht"> UIView </strong>是一个引用类型，我们仍然能够改变它的属性！但是还有一个更微妙的漏洞来源。为了说明这一点，让我们创建一个<strong class="ir ht">人员视图</strong>的实例，并制作一个副本:</p><pre class="kt ku kv kw fd kx ky kz la aw lb bi"><span id="55cc" class="lc jo hs ky b fi ld le l lf lg">let personViewA =<br/>    PersonView(person: PersonStruct(name: "John Doe"), <br/>               view: UIView())</span><span id="7a4b" class="lc jo hs ky b fi lh le l lf lg">let personViewB = personViewA</span></pre><p id="b694" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，因为<em class="kp">视图</em>是一个引用类型，所以<strong class="ir ht">人员视图</strong>的两个实例共享同一个属性！这意味着，如果我们修改任何实例的<em class="kp">视图</em>属性，我们最终实际上修改了<strong class="ir ht">共享</strong>视图。下图应该更容易看出这一点，并帮助我们认识到，我们再次遇到了我们前面讨论过的隐式数据共享问题:</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div class="er es mx"><img src="../Images/19966eafa8482e88ab145ee0726c8166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*X8K5iFiszLE-tOfeNONcWQ.jpeg"/></div><figcaption class="lo lp et er es lq lr bd b be z dx">Value type containing a reference type</figcaption></figure><h1 id="3944" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">引用类型、值类型和不变性</strong></h1><blockquote class="km kn ko"><p id="79c0" class="ip iq kp ir b is it iu iv iw ix iy iz kq jb jc jd kr jf jg jh ks jj jk jl jm ha bi translated"><strong class="ir ht">不变性</strong>:实例创建后状态不可修改的属性。</p></blockquote><p id="13af" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不变性是一个非常重要的属性，它与<a class="ae my" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>范例密切相关。我们看到，通过使用值类型，我们能够创建无限期保留其状态的实例，根据定义，它们是不可变的。不可变对象有一些有趣的优点和缺点。</p><h2 id="dc3d" class="lc jo hs bd jp ls lt lu jt lv lw lx jx ja ly lz kb je ma mb kf ji mc md kj me bi translated">优点:</h2><ul class=""><li id="aae7" class="mj mk hs ir b is li iw lj ja mz je na ji nb jm mo mp mq mr bi translated">不可变对象不共享数据，因此在实例之间没有共享状态。这避免了由<a class="ae my" href="https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29" rel="noopener ugc nofollow" target="_blank">副作用</a>引起的意外变化的问题</li><li id="618d" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">前一点的直接结果是不可变对象本质上是线程安全的。这意味着我们不需要担心竞争条件和<a class="ae my" href="https://en.wikipedia.org/wiki/Synchronization_%28computer_science%29" rel="noopener ugc nofollow" target="_blank">线程同步</a></li><li id="f75d" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">因为不可变对象保留了它们的状态，所以更容易对代码进行推理</li></ul><h2 id="9a20" class="lc jo hs bd jp ls lt lu jt lv lw lx jx ja ly lz kb je ma mb kf ji mc md kj me bi translated">缺点:</h2><ul class=""><li id="1d35" class="mj mk hs ir b is li iw lj ja mz je na ji nb jm mo mp mq mr bi translated">不变性并不总是有效地映射到机器模型。一个典型的例子是执行就地修改的算法(像<a class="ae my" href="https://www.objc.io/blog/2014/10/20/functional-snippet-3-functional-quicksort/" rel="noopener ugc nofollow" target="_blank">快速排序</a>)。在保持原有性能的同时，使用值类型实现这些功能并不容易。</li></ul><p id="95b5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Swift中，我们可以使用两个不同的关键字来定义变量:</p><ul class=""><li id="5d25" class="mj mk hs ir b is it iw ix ja ml je mm ji mn jm mo mp mq mr bi translated"><strong class="ir ht"> <em class="kp"> var </em> </strong>:定义可变实例</li><li id="5f61" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated"><strong class="ir ht"> <em class="kp">让</em> </strong>:定义不可变的实例</li></ul><p id="b50b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上述关键字有不同的行为，这取决于它们是用于引用还是值类型。</p><h1 id="7151" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">可变实例:变量</strong></h1><h2 id="d4ef" class="lc jo hs bd jp ls lt lu jt lv lw lx jx ja ly lz kb je ma mb kf ji mc md kj me bi translated">参考类型</h2><p id="d756" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">可以改变<strong class="ir ht">引用</strong>(<em class="kp">可变</em>):可以改变实例本身，也可以改变实例引用。</p><h2 id="f264" class="lc jo hs bd jp ls lt lu jt lv lw lx jx ja ly lz kb je ma mb kf ji mc md kj me bi translated">值类型</h2><p id="de29" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">可以更改<strong class="ir ht">实例</strong>(<em class="kp">可变</em>):您可以更改实例的属性。</p><h1 id="3d25" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">不可变实例:让</strong></h1><h2 id="b9d7" class="lc jo hs bd jp ls lt lu jt lv lw lx jx ja ly lz kb je ma mb kf ji mc md kj me bi translated">参考类型</h2><p id="1c22" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated"><strong class="ir ht">引用</strong>保持不变(<em class="kp">不可变</em>):您不能改变实例引用，但是您可以改变实例本身。</p><h2 id="4fca" class="lc jo hs bd jp ls lt lu jt lv lw lx jx ja ly lz kb je ma mb kf ji mc md kj me bi translated">值类型</h2><p id="b8e0" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated"><strong class="ir ht">实例</strong>保持不变(<em class="kp">不可变</em>):你不能改变实例的属性，不管属性是用<em class="kp"> let </em>还是<em class="kp"> var声明的。</em></p><h1 id="2222" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">应该选择哪种类型？</strong></h1><p id="2f9e" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">一个很常见的问题是:<em class="kp">“我如何决定什么时候使用引用类型，什么时候使用值类型？”你可以在网上找到很多关于那件事的讨论。我最喜欢的一些例子是:</em></p><ul class=""><li id="1d34" class="mj mk hs ir b is it iw ix ja ml je mm ji mn jm mo mp mq mr bi translated">我应该使用Swift结构还是类？</li><li id="a0bd" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">周五Q&amp;A 2015–07–17:何时使用Swift结构和类</li><li id="61c4" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated"><a class="ae my" href="https://www.objc.io/issues/16-swift/swift-classes-vs-structs/" rel="noopener ugc nofollow" target="_blank">热烈欢迎结构和值类型</a></li><li id="104f" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">回复:我应该使用Swift结构还是类？</li><li id="6052" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated"><a class="ae my" href="http://troz.net/2016/03/structs-vs-classes/" rel="noopener ugc nofollow" target="_blank">结构vs类</a></li><li id="75e4" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated"><a class="ae my" href="https://www.mikeash.com/pyblog/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes.html" rel="noopener ugc nofollow" target="_blank">Swift中的引用与值类型:第1/2部分</a></li></ul><p id="a359" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为一个基本规则，每次我们从<strong class="ir ht">n object</strong>子类化时，我们都被迫创建引用类型。这是与Cocoa SDK交互时的常见场景。Apple 提供了一些使用引用类型和值类型的通用规则。下面我总结了一下。</p><h2 id="4b9d" class="lc jo hs bd jp ls lt lu jt lv lw lx jx ja ly lz kb je ma mb kf ji mc md kj me bi translated">参考类型，当:</h2><ul class=""><li id="74a3" class="mj mk hs ir b is li iw lj ja mz je na ji nb jm mo mp mq mr bi translated">对象的子类必须是类类型</li><li id="6a39" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">将<em class="kp">实例标识</em>与<strong class="ir ht"> === </strong>进行比较是有意义的</li><li id="6e29" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">你想要创建<em class="kp">共享的、可变的状态</em></li></ul><h2 id="d6a5" class="lc jo hs bd jp ls lt lu jt lv lw lx jx ja ly lz kb je ma mb kf ji mc md kj me bi translated">值类型，当:</h2><ul class=""><li id="a46c" class="mj mk hs ir b is li iw lj ja mz je na ji nb jm mo mp mq mr bi translated">将<em class="kp">实例数据</em>与<strong class="ir ht"> == </strong>进行比较是有意义的(<strong class="ir ht">等同于</strong>协议)</li><li id="9860" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">您希望副本具有<em class="kp">独立状态</em></li><li id="0048" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">数据将在跨多个线程的代码中使用(避免显式同步)</li></ul><p id="8386" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有趣的是，Swift标准库非常青睐值类型:</p><ul class=""><li id="c45a" class="mj mk hs ir b is it iw ix ja ml je mm ji mn jm mo mp mq mr bi translated">原始类型(<strong class="ir ht"> Int </strong>、<strong class="ir ht"> Double </strong>、<strong class="ir ht"> String </strong>、…)是值类型</li><li id="70dc" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">标准集合(<strong class="ir ht">数组</strong>、<strong class="ir ht">字典</strong>、<strong class="ir ht">集合</strong>、…)是值类型</li></ul><p id="c367" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过查看<a class="ae my" href="https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/" rel="noopener ugc nofollow" target="_blank"> Swift标准库参考文献</a>，有可能收集到确切的数字来证实上述陈述。以下是类型的划分:</p><ul class=""><li id="02db" class="mj mk hs ir b is it iw ix ja ml je mm ji mn jm mo mp mq mr bi translated">类别= 4</li><li id="9807" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">结构= 103</li><li id="2403" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated">枚举= 9</li></ul><p id="e28d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除了上面举例说明的以外，选择实际上取决于您试图实现什么。根据经验，如果没有特定的约束迫使您选择引用类型，或者您不确定哪个选项最适合您的特定用例，您可以从使用值类型实现数据结构开始。如果需要的话，您应该能够在稍后用相对较少的努力将其转换为引用类型。</p><h1 id="b621" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">结论</strong></h1><p id="6ae5" class="pw-post-body-paragraph ip iq hs ir b is li iu iv iw lj iy iz ja lk jc jd je ll jg jh ji lm jk jl jm ha bi translated">你可以在这里下载这篇文章<a class="ae my" href="https://github.com/andrea-prearo/SwiftPlaygrounds/tree/master/ReferenceAndValueTypes" rel="noopener ugc nofollow" target="_blank">中的代码。</a></p><p id="65bc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我们研究了引用类型和值类型之间的区别。在研究了隐式数据共享的一个常见问题之后，我们看到了如何通过使用值类型而不是引用类型来避免这个问题。</p><p id="dca3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还介绍了不变性的概念，并了解了它如何应用于Swift中的引用类型和值类型。最后，我们回顾了一些用例，在这些用例中，引用类型和值类型之间的选择非常简单。对于所有其他情况，实验是找出最佳选择的最佳方式。</p><h2 id="abaf" class="lc jo hs bd jp ls lt lu jt lv lw lx jx ja ly lz kb je ma mb kf ji mc md kj me bi translated">有关系的</h2><ul class=""><li id="99cc" class="mj mk hs ir b is li iw lj ja mz je na ji nb jm mo mp mq mr bi translated"><a class="ae my" rel="noopener" href="/capital-one-developers/smooth-scrolling-in-uitableview-and-uicollectionview-a012045d77f">在UITableView和UICollectionView中平滑滚动</a></li><li id="773c" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated"><a class="ae my" rel="noopener" href="/capital-one-developers/boost-smooth-scrolling-with-ios-10-pre-fetching-api-818c25cd9c5d">用iOS 10预取API提升平滑滚动</a></li><li id="fce7" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated"><a class="ae my" rel="noopener" href="/capital-one-developers/generic-data-sources-in-swift-c6fbb531520e">Swift中的通用数据源</a></li><li id="a3c5" class="mj mk hs ir b is ms iw mt ja mu je mv ji mw jm mo mp mq mr bi translated"><a class="ae my" rel="noopener" href="/capital-one-developers/an-alternative-to-type-erasure-for-generic-protocols-a9a48e96618a">通用协议类型擦除的替代方案</a></li></ul></div><div class="ab cl nc nd go ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ha hb hc hd he"><p id="2363" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如需了解更多关于Capital One的API、开源、社区活动和开发人员文化的信息，请访问我们的一站式开发人员门户网站DevExchange。<a class="ae my" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><em class="kp">https://developer.capitalone.com/</em></a></p></div></div>    
</body>
</html>