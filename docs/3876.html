<html>
<head>
<title>Docker, the developer’s friend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker，开发者的朋友</h1>
<blockquote>原文：<a href="https://medium.com/globant/docker-the-developers-friend-3464e5e7f43d?source=collection_archive---------0-----------------------#2022-05-11">https://medium.com/globant/docker-the-developers-friend-3464e5e7f43d?source=collection_archive---------0-----------------------#2022-05-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/07848f7fb750f3aec68701b5aaafb4ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9oCF3DhVpvWy6njI"/></div></div></figure><div class=""/><div class=""><h2 id="c9c6" class="pw-subtitle-paragraph ip hr hs bd b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg dx translated"><strong class="ak">用Docker开发</strong></h2></div><p id="df81" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在本文的第一部分(你可以在这里查看<a class="ae kd" rel="noopener" href="/globant/docker-the-developers-friend-dd01399de87d"/>，我们讲述了Docker的主要概念。这是我们要和docker玩一会儿的第二部分。</p><p id="cfc2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">是时候看看前面的概念是如何一起构建一个小演示并更好地理解了！！</p><p id="ebad" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">假设我们将开发一个项目(本文的简单项目),这个项目包含一个管理图书馆图书系统的web应用程序。应用程序使用数据库来保存数据，该应用程序的简单架构图如下:</p><figure class="kf kg kh ki fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ke"><img src="../Images/5ecf1ffd55e1b0fbd77c141fa9e40ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EBl-hdWNQ6sRumZo"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx"><strong class="bd kn">Book System high-level architecture diagram</strong></figcaption></figure><p id="f087" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">对于这个系统，使用容器的想法可能是:</p><figure class="kf kg kh ki fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ko"><img src="../Images/d72f21971de9c118d6cf62563d5de46c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*96jbNWZIuu0p_RgZ"/></div></div></figure><p id="2056" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们将有两个主要容器，一个用于图书应用程序，另一个用于数据库，另外一个(可选)容器可以使用<strong class="jj ht"> <em class="kp"> pgAdmin </em> </strong>来管理数据库。所以，我们来玩docker吧。</p><p id="a096" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">步骤1: </strong>从Docker hub下载<strong class="jj ht"> PostgreSQL </strong>和<strong class="jj ht"> pgAdmin </strong>镜像:</p><p id="7d87" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为此，我们需要运行以下命令:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="7762" class="kv kw hs kr b fi kx ky l kz la"><strong class="kr ht"><em class="kp">docker pull postgres</em></strong></span></pre><p id="e284" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">然后:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="b856" class="kv kw hs kr b fi kx ky l kz la"><strong class="kr ht"><em class="kp">docker pull dpage/pgadmin4</em></strong></span></pre><p id="2a7f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这些命令之后，我们将执行命令<strong class="jj ht"> <em class="kp"> docker images </em> </strong>来查看我们主机中的新图像:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="c9b2" class="kv kw hs kr b fi kx ky l kz la">docker images</span></pre><figure class="kf kg kh ki fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lb"><img src="../Images/2a0d0814142ec3dbff56d457ff414cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ay9bOCVfPa_6BH-L"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx"><strong class="bd kn">The result from docker images command</strong></figcaption></figure><p id="a660" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因此，在前面的图像中，我们可以看到docker图像PostgreSQL和pgadmin。</p><p id="38fb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">步骤2: </strong>运行PostgreSQL和pgadmin容器</p><p id="0acb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了运行Postgres容器，我们需要执行以下命令:</p><figure class="kf kg kh ki fd hj"><div class="bz dy l di"><div class="lc ld l"/></div></figure><blockquote class="le lf lg"><p id="02ec" class="jh ji kp jj b jk jl it jm jn jo iw jp lh jr js jt li jv jw jx lj jz ka kb kc ha bi translated"><strong class="jj ht">注意</strong>:正如我们看到的，这个命令有一个<strong class="jj ht">网络</strong>指令，它允许我们在同一个docker运行时在两个容器之间进行通信，这在这里是必要的，但是稍后我们会看到其他选项。</p></blockquote><p id="2104" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们可以使用命令<strong class="jj ht"> <em class="kp"> docker ps </em> </strong>来验证Postgres容器是否正在运行</p><figure class="kf kg kh ki fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ke"><img src="../Images/ccf09118ff6ba1e5f8de2dd6ca1b4580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5hW7ADmI_3tAhEa0"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx"><strong class="bd kn">The result from docker ps command</strong></figcaption></figure><p id="6cb2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因此，让我们运行pgadmin容器，我们可以使用以下命令:</p><figure class="kf kg kh ki fd hj"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="c382" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">我们可以使用命令<strong class="jj ht"> <em class="kp">验证pgadmin容器是否正在运行</em></strong></p><figure class="kf kg kh ki fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ke"><img src="../Images/b845321c1d103c5d8e905ae21685f566.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RcXOi9hDmR4PaRwQ"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx"><strong class="bd kn">The result from docker ps command</strong></figcaption></figure><p id="e2a5" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">另一种确认pgadmin容器正在运行的方法是通过pgadmin web访问<a class="ae kd" href="http://localhost:9292" rel="noopener ugc nofollow" target="_blank"> http://localhost:9292 </a>，让使用它来管理我们的数据库。</p><figure class="kf kg kh ki fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ke"><img src="../Images/3f8b821cb5d6bc5578d892f858849956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W3X1EpDSkMwcNIug"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">pgadmin login page</figcaption></figure><p id="a360" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">为了登录到<strong class="jj ht"> <em class="kp"> pgadmin </em> </strong>，记住docker运行命令中使用的用户名和密码(PGADMIN_DEFAULT_EMAIL和PGADMIN_DEFAULT_PASSWORD)。现在，我们可以创建我们的数据库模式，也可以创建我们的表来保存我们的数据，对于这个小项目，我们将拥有表<strong class="jj ht"> book </strong>，以便通过API启用CRUD功能。</p><p id="4c00" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">步骤3: </strong>将图书应用程序部署到一个容器中</p><p id="59a0" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">下一步是将应用程序部署到容器中，我们可以使用下面的docker命令来启动容器。</p><figure class="kf kg kh ki fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lk"><img src="../Images/9c0b87620028a1ba81e12d4b550313e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tz2C55KQ7usgTs1B"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Books API</figcaption></figure><blockquote class="le lf lg"><p id="2f64" class="jh ji kp jj b jk jl it jm jn jo iw jp lh jr js jt li jv jw jx lj jz ka kb kc ha bi translated"><strong class="jj ht">注意</strong>:这个演示应用程序的Git库是<a class="ae kd" href="https://github.com/jparanda/book-app" rel="noopener ugc nofollow" target="_blank">这里是</a>，请随意使用它。</p></blockquote><p id="42f8" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">因此，为了将应用程序作为容器运行，我们需要创建它应该运行的环境，为此，我们需要创建一个Dockerfile(<strong class="jj ht">I ' l</strong>l<strong class="jj ht">T7】在下一节 </strong>中解释docker file)。因此<strong class="jj ht"> <em class="kp"> DockerFile </em> </strong>基本上是一个文件文本，它允许我们指定为Book应用程序创建图像的指令，Docker将使用这些指令将图像运行到容器中。因此，让我们为我们的<strong class="jj ht"> <em class="kp">图书应用程序</em> </strong>构建一个Dockerfile</p><figure class="kf kg kh ki fd hj"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="9238" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">一旦我们有了docker文件，我们需要构建它，让我们使用下面的命令:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="a7ee" class="kv kw hs kr b fi kx ky l kz la"><strong class="kr ht"><em class="kp">docker build --no-cache -t book-app .</em></strong></span></pre><p id="2768" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，如果我们执行命令<strong class="jj ht"> <em class="kp"> docker images </em> </strong>，我们将看到两个新图像，一个是名为<strong class="jj ht"> <em class="kp"> book-app </em> </strong>的图书应用程序，另一个是基本图像<strong class="jj ht"> <em class="kp"> OpenJDK </em> </strong></p><figure class="kf kg kh ki fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ll"><img src="../Images/dd3a7b6bce471254c6832bc2d7add13a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*17VRNoHzRjJdCLTo"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx"><strong class="bd kn">The result from docker images command</strong></figcaption></figure><p id="3570" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">现在，我们可以运行book-app容器，使用其他容器Postgres和pgadmin，我们的book系统已经准备好接收请求，因此为了做到这一点，使用以下命令:</p><figure class="kf kg kh ki fd hj"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="788f" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果我们看到上面的命令，我们正在使用同一个网络，<strong class="jj ht"><em class="kp">【pg network】，</em> </strong>以便允许与postgres进行网络通信。现在，我们可以执行docker ps命令来验证所有容器都在运行:</p><figure class="kf kg kh ki fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ke"><img src="../Images/133dce3e1be97e5eecf7cc10b1cf80cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8dpxBcA0KhrfyBeo"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Result from docker ps command</figcaption></figure><p id="a625" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">在这一点上，我们已经看到了让我们的系统在其所有组件中完全停靠的方法，包括应用程序、数据库以及数据库管理应用程序。</p><p id="3ee9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">让我们详细了解一下什么是docker文件。</p><h2 id="2d7d" class="kv kw hs bd kn lm ln lo lp lq lr ls lt jq lu lv lw ju lx ly lz jy ma mb mc md bi translated">Docker文件</h2><p id="dc87" class="pw-post-body-paragraph jh ji hs jj b jk me it jm jn mf iw jp jq mg js jt ju mh jw jx jy mi ka kb kc ha bi translated">它是一个文本文档，我们可以在其中指定用户可以在命令行上调用或使用的所有命令来组合一个图像。Dockerfile文件有以下说明:</p><p id="7a16" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">从</strong> - &gt;定义了图像库。每个Dockerfile都必须以FROM指令开始，简单来说，就是起点。</p><p id="d3f9" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">运行</strong> - &gt;允许我们在构建时将指令运行到容器中。</p><p id="6e01" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht"> ADD </strong>和<strong class="jj ht"> COPY </strong> - &gt;都是用来把主机上的文件放到Docker镜像中的，但是ADD有更多的功能，比如从web上复制URL资源，还可以从源直接提取tar到目的地。更多详情请点击链接<a class="ae kd" href="https://docs.docker.com/engine/reference/builder/#add" rel="noopener ugc nofollow" target="_blank">添加命令</a> <a class="ae kd" href="https://docs.docker.com/engine/reference/builder/#copy" rel="noopener ugc nofollow" target="_blank">复制命令</a>。</p><p id="a6d2" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">入口点</strong> - &gt;允许我们将容器运行配置为可执行文件。它是我们告诉Docker如何运行应用程序的地方。</p><p id="3adb" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">让我们看一个例子:</p><figure class="kf kg kh ki fd hj"><div class="bz dy l di"><div class="lc ld l"/></div></figure><h2 id="daa2" class="kv kw hs bd kn lm ln lo lp lq lr ls lt jq lu lv lw ju lx ly lz jy ma mb mc md bi translated">Docker撰写</h2><p id="261a" class="pw-post-body-paragraph jh ji hs jj b jk me it jm jn mf iw jp jq mg js jt ju mh jw jx jy mi ka kb kc ha bi translated">它是一个工具，允许我们使用YML文件运行多容器docker应用程序来配置我们的服务。使用docker compose的最大优点是我们可以在一个文件中定义所有的应用程序堆栈，然后用一个简单的命令运行它。</p><p id="499a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">请记住，在这一点上，我们知道运行容器的唯一方法，例如，PostgreSQL数据库使用docker run命令，但是，这是一个很大的命令，对吗？对于所有可能的选择，我们必须使用它。让我们看看如何定义docker-compose文件并配置上面的各个命令:</p><figure class="kf kg kh ki fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ke"><img src="../Images/1d753d3cf1c597a39ac7814f9fbb738b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CImE9JIOmwZbCkGh"/></div></div></figure><p id="1dbf" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">正如我们所见，定义一个docker-compose文件很容易，记住在这个文件中我们可以定义所有的应用程序堆栈，让我们开始吧！！：</p><figure class="kf kg kh ki fd hj"><div class="bz dy l di"><div class="lc ld l"/></div></figure><p id="1165" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">厉害！！我们所有的片段都在同一个docker-compose文件中，我们可以在我的例子中指定一个文件名<strong class="jj ht"><em class="kp">book-app-stack . yml</em></strong>或者直接将其命名为<strong class="jj ht"><em class="kp">docker-compose . yml</em></strong>。因此，为了运行我们的book系统容器，我们需要使用以下命令:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="0a74" class="kv kw hs kr b fi kx ky l kz la"><strong class="kr ht"><em class="kp">docker-compose up</em></strong></span></pre><p id="6632" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">如果docker compose名称是docker-compose.yml，请使用前面的命令，否则我们需要使用以下命令:</p><pre class="kf kg kh ki fd kq kr ks kt aw ku bi"><span id="e288" class="kv kw hs kr b fi kx ky l kz la"><strong class="kr ht"><em class="kp">docker-compose -f {name_compose_file} up</em></strong></span></pre><p id="85be" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">无论是哪种情况，我们都会看到所有的容器都在我们的主机中运行:</p><figure class="kf kg kh ki fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ke"><img src="../Images/ceac529ba5b3e266dd32cd423487301d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rG_Dw3dO0IYqPPtx"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx">Result docker ps command</figcaption></figure><p id="2352" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">让我们看看可以与前面的命令一起使用的命令选项:</p><p id="abca" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">-f，指定一个替代合成文件(默认值:docker-compose.yml)</p><p id="b423" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">-p，指定备用项目名(默认:目录名)</p><p id="151a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">-d，以分离模式运行容器。</p><p id="b8a4" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">结论</strong></p><p id="ca40" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated">作为开发人员，我们需要搜索所有能够让我们在工作中更有效率的资源，在这种情况下，Docker是一个有用的工具，可以避免在我们的开发环境中花费时间进行不必要的配置和安装。Docker还允许我们快速部署和共享我们的应用程序，并以更好的方式与所有团队以及所有环境(如开发、QA、试运行、生产等)共享一个公共环境。所以，让我们开始了解Docker，并开始在我们的项目中使用它。</p><p id="c61d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><strong class="jj ht">参考文献</strong></p><p id="0a45" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><a class="ae kd" href="https://www.baeldung.com/spring-boot-postgresql-docker" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/spring-boot-postgresql-docker </a></p><p id="b895" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><a class="ae kd" href="https://www.docker.com/why-docker" rel="noopener ugc nofollow" target="_blank">https://www.docker.com/why-docker </a></p><p id="475a" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><a class="ae kd" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/</a></p><p id="c56d" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><a class="ae kd" href="https://cloudacademy.com/blog/docker-vs-virtual-machines-differences-you-should-know/" rel="noopener ugc nofollow" target="_blank">https://cloudacademy.com/blog/docker-vs-virtual-machines-differences-you-should-know/</a></p><p id="76b3" class="pw-post-body-paragraph jh ji hs jj b jk jl it jm jn jo iw jp jq jr js jt ju jv jw jx jy jz ka kb kc ha bi translated"><a class="ae kd" href="https://phoenixnap.com/kb/docker-image-vs-container" rel="noopener ugc nofollow" target="_blank">https://phoenixnap.com/kb/docker-image-vs-container </a></p></div></div>    
</body>
</html>