<html>
<head>
<title>May the power of Coroutine be with you…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">愿协程的力量与你同在…</h1>
<blockquote>原文：<a href="https://medium.com/globant/may-the-power-of-coroutine-be-with-you-e345cb5f82e1?source=collection_archive---------4-----------------------#2020-04-13">https://medium.com/globant/may-the-power-of-coroutine-be-with-you-e345cb5f82e1?source=collection_archive---------4-----------------------#2020-04-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="ec59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用协程轻松摆脱回调和异步编程。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/6b214589b2f1761969246da226d14075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zxx4iQAG4HilOIQqDKpxJw.jpeg"/></div></div></figure></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="045d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">科特林的<a class="ae jv" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">协同程序</a>引入了一种新的并发方式，可以在Android上使用来简化异步代码。它是在kot Lin 1.3中引入的，从那以后我就广泛地使用它来进行异步编程。一路走来，我学到了一些用例，在某种程度上让我很惊讶。了解协程的基本知识是理解以下概念的先决条件。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><h1 id="685d" class="jw jx hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">将回调转换为挂起的函数</h1><p id="76aa" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">Kotlin提供了漂亮流畅的API来将回调转换为挂起的函数。Kotlin提供了一个构建器<a class="ae jv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendecancelablecoroutine</a>，它将充当协程世界和基于回调的世界之间的适配器。</p><p id="a663" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它需要一个lambda作为输入，它将被执行并立即挂起。将提供cancellableContinuation，使用它我们可以在稍后的时间点恢复执行。</p><ul class=""><li id="7355" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated">如果收到成功的回调，您必须调用<a class="ae jv" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/resume.html" rel="noopener ugc nofollow" target="_blank"> resume(value: T) </a></li></ul><blockquote class="li lj lk"><p id="034d" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">继续执行相应的协程，将[value]作为最后一个暂停点的返回值。</p></blockquote><ul class=""><li id="01e8" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated">如果出现错误，您需要调用<a class="ae jv" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/resume-with-exception.html" rel="noopener ugc nofollow" target="_blank"> resumeWithException(异常:Throwable) </a></li></ul><blockquote class="li lj lk"><p id="0854" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">恢复相应协程的执行，以便在最后一个暂停点之后立即重新抛出[异常]。</p></blockquote><ul class=""><li id="9591" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated">我们可以通过调用<a class="ae jv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellable-continuation/cancel.html" rel="noopener ugc nofollow" target="_blank">cancelablecontinuation . cancel</a><strong class="ig hi">()</strong>来取消协程的执行</li></ul><blockquote class="li lj lk"><p id="f8be" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">通过可选取消<code class="du lp lq lr ls b"><em class="hh">cause</em></code>取消该延续。如果这个调用导致这个延续被取消，那么结果是<code class="du lp lq lr ls b"><em class="hh">true</em></code>，否则是<code class="du lp lq lr ls b"><em class="hh">false</em></code>。</p></blockquote></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="1df5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我正在使用MVVM架构，并决定存储库将只具有暂停的功能。这可以从viewModelScope中的ViewModel中进一步调用。它对房间数据库和改造库非常有用，因为它们支持开箱即用的协程。</p><p id="8c5d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我遇到了一个需要位置更新的场景。我决定把它写在存储库中，因为它只是移动设备中另一个传感器的输入。按照标准惯例，我使用<a class="ae jv" href="https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient" rel="noopener ugc nofollow" target="_blank"> FusedLocationAPI </a>来获取所需的位置细节。</p><p id="2efd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">按照我的规则，存储库将只有暂停的功能。这种约束迫使我去寻找其他的选择，于是我遇到了这个生成器。</p><h1 id="873a" class="jw jx hh bd jy jz lt kb kc kd lu kf kg kh lv kj kk kl lw kn ko kp lx kr ks kt bi translated">获取最后已知位置</h1><p id="9b65" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">第一个目标是创建一个suspend函数，它可以返回设备的最后一个已知位置(如果它可用的话),或者抛出适当的错误。<a class="ae jv" href="https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient" rel="noopener ugc nofollow" target="_blank"> FusedLocationAPI </a>提供了一个方法<a class="ae jv" href="https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient#public-tasklocation-getlastlocation-" rel="noopener ugc nofollow" target="_blank"> getLastLocation() </a>，该方法将返回包含位置或异常的任务。我们可以在这个任务中添加一个完整的监听器来观察结果。</p><p id="431f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了将这个基于回调的函数转换成挂起的函数，我使用了如下所示的<a class="ae jv" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendecancellablecoroutine</a>。</p><pre class="jd je jf jg fd ly ls lz ma aw mb bi"><span id="3bee" class="mc jx hh ls b fi md me l mf mg"><strong class="ls hi">suspend fun </strong>getLastKnownLocation(): Location? {<br/>    <strong class="ls hi">return </strong><em class="ll">suspendCancellableCoroutine </em><strong class="ls hi">{ </strong>continuation <strong class="ls hi">-&gt;<br/>        val </strong>flp = LocationServices.getFusedLocationProviderClient(<strong class="ls hi">context</strong>)<br/>        <strong class="ls hi">val </strong>task = flp.<em class="ll">lastLocation<br/>        </em>task.addOnCompleteListener <strong class="ls hi">{<br/>            if </strong>(<strong class="ls hi">it</strong>.<em class="ll">isSuccessful</em>)<br/>                continuation.<em class="ll">resume</em>(task.<em class="ll">result</em>)<br/>            <strong class="ls hi">else<br/>                </strong>continuation.<em class="ll">resumeWithException</em>(<strong class="ls hi">it</strong>.<em class="ll">exception </em>?: NullPointerException())<br/>        <strong class="ls hi">}<br/>    }<br/></strong>}</span></pre><h1 id="7579" class="jw jx hh bd jy jz lt kb kc kd lu kf kg kh lv kj kk kl lw kn ko kp lx kr ks kt bi translated">检查设备的GPS设置</h1><p id="8087" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated"><a class="ae jv" href="https://developers.google.com/android/reference/com/google/android/gms/location/SettingsClient" rel="noopener ugc nofollow" target="_blank">需要访问SettingAPI </a>，以确保设备的系统设置正确配置，满足应用程序的定位需求。请求定位服务时，设备的系统设置可能处于阻止应用程序获取所需位置数据的状态。例如，GPS或Wi-Fi扫描可能会关闭。这一意图使得以下操作变得容易:</p><ul class=""><li id="e375" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated">确定设备上的相关系统设置是否已启用，以执行所需的位置请求。</li><li id="466c" class="kz la hh ig b ih mh il mi ip mj it mk ix ml jb le lf lg lh bi translated">可选地，调用一个对话框，该对话框允许用户通过单击来启用必要的位置设置。</li></ul><p id="43b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了将它转换成挂起的函数，我使用了下面的代码</p><pre class="jd je jf jg fd ly ls lz ma aw mb bi"><span id="b523" class="mc jx hh ls b fi md me l mf mg"><strong class="ls hi">suspend fun </strong>checkLocationSettings(locationRequest: LocationRequest): Unit {<br/>    <strong class="ls hi">return </strong><em class="ll">suspendCancellableCoroutine </em><strong class="ls hi">{ </strong>continuation <strong class="ls hi">-&gt;<br/>        val </strong>builder = LocationSettingsRequest.Builder()<br/>            .addLocationRequest(locationRequest)</span><span id="c136" class="mc jx hh ls b fi mm me l mf mg">        <strong class="ls hi">val </strong>client: SettingsClient = LocationServices.getSettingsClient(<strong class="ls hi">context</strong>)<br/>        <strong class="ls hi">val </strong>task: Task&lt;LocationSettingsResponse&gt; = client.checkLocationSettings(builder.build())</span><span id="dbd3" class="mc jx hh ls b fi mm me l mf mg">        task.addOnSuccessListener <strong class="ls hi">{<br/>            </strong>continuation.<em class="ll">resume</em>(LocationSettingResult(true))<br/>        <strong class="ls hi">}</strong></span><span id="7831" class="mc jx hh ls b fi mm me l mf mg"><strong class="ls hi">        </strong>task.addOnFailureListener <strong class="ls hi">{<br/>            </strong>continuation.<em class="ll">resume</em>(LocationSettingResult(false, <strong class="ls hi">it</strong>))<br/>        <strong class="ls hi">}<br/>    }<br/></strong>}</span><span id="4db2" class="mc jx hh ls b fi mm me l mf mg"><strong class="ls hi">data class </strong>LocationSettingResult(<strong class="ls hi">val success</strong>: Boolean, <strong class="ls hi">val error</strong>: Exception? = <strong class="ls hi">null</strong>)</span></pre><p id="934e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，我故意不在失败回调中调用resumeWithException()方法，因为我不想突然取消执行，而是想显示一个位置设置弹出窗口。</p><h1 id="46f9" class="jw jx hh bd jy jz lt kb kc kd lu kf kg kh lv kj kk kl lw kn ko kp lx kr ks kt bi translated">获取连续的位置更新</h1><p id="8f70" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">作为用例的最后一部分，我想从<a class="ae jv" href="https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient" rel="noopener ugc nofollow" target="_blank"> FusedLocationAPI </a>获得连续的位置更新。在获取位置更新之前，我会检查位置设置，如果一切顺利，我会开始更新。</p><pre class="jd je jf jg fd ly ls lz ma aw mb bi"><span id="3048" class="mc jx hh ls b fi md me l mf mg"><strong class="ls hi">suspend fun </strong>getLocationUpdates(<br/>    onLocationUpdated: (Pair&lt;Double, Double&gt;?, error: Exception?) -&gt; Unit) {<br/>    <strong class="ls hi">return </strong><em class="ll">coroutineScope </em><strong class="ls hi">{<br/>        val </strong>request = LocationRequest.create().<em class="ll">apply </em><strong class="ls hi">{<br/>            </strong><em class="ll">interval </em>= 10000<br/>            <em class="ll">fastestInterval </em>= 2000<br/>            <em class="ll">priority </em>= LocationRequest.<em class="ll">PRIORITY_HIGH_ACCURACY<br/>        </em><strong class="ls hi">}</strong></span><span id="f310" class="mc jx hh ls b fi mm me l mf mg"><strong class="ls hi">        val </strong>locationSettingsResult = checkLocationSettings(request)</span><span id="847a" class="mc jx hh ls b fi mm me l mf mg">        <strong class="ls hi">if </strong>(locationSettingsResult.<strong class="ls hi">success</strong>) {<br/>            <strong class="ls hi">val </strong>done = <em class="ll">CompletableDeferred</em>&lt;Unit&gt;()<br/>            <strong class="ls hi">val </strong>flp = LocationServices.getFusedLocationProviderClient(<strong class="ls hi">context</strong>)</span><span id="2b43" class="mc jx hh ls b fi mm me l mf mg">            <strong class="ls hi">val </strong>callback = <strong class="ls hi">object </strong>: LocationCallback() {<br/>                <strong class="ls hi">val mutex </strong>= <em class="ll">Mutex</em>()<br/>                <strong class="ls hi">var job</strong>: Job? = <strong class="ls hi">null<br/>                override fun </strong>onLocationResult(locationRestult: LocationResult?) {<br/>                    locationRestult?.<em class="ll">lastLocation</em>?.<em class="ll">let </em><strong class="ls hi">{<br/>                        job</strong>?.cancel()<br/>                        <strong class="ls hi">job </strong>= <em class="ll">launch </em><strong class="ls hi">{<br/>                            mutex</strong>.<em class="ll">withLock </em><strong class="ls hi">{<br/>                                </strong>onLocationUpdated(Pair(<strong class="ls hi">it</strong>.<em class="ll">latitude</em>, <strong class="ls hi">it</strong>.<em class="ll">longitude</em>), <strong class="ls hi">null</strong>)<br/>                            <strong class="ls hi">}<br/>                        }<br/>                    }<br/>                </strong>}<br/>            }</span><span id="81fe" class="mc jx hh ls b fi mm me l mf mg">            <strong class="ls hi">try </strong>{<br/>                flp.requestLocationUpdates(request, callback, Looper.getMainLooper())<br/>                done.await()<br/>            } <strong class="ls hi">finally </strong>{<br/>                flp.removeLocationUpdates(callback)<br/>            }<br/>        } <strong class="ls hi">else </strong>{<br/>            onLocationUpdated(<strong class="ls hi">null</strong>, locationSettingsResult.<strong class="ls hi">error</strong>)<br/>        }<br/>    <strong class="ls hi">}</strong></span></pre><p id="6b0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">getLocationUpdates()函数将输入作为lambda，当接收到位置或错误时将调用该函数。让我们考虑一个场景，其中GPS设置不合适，需要打开它，然后getLocationUpdates()将被调用，并出现异常。通过调用<a class="ae jv" href="https://developers.google.com/android/reference/com/google/android/gms/location/SettingsClient" rel="noopener ugc nofollow" target="_blank">设置API </a>中提到的方法，可以显示位置启用弹出窗口。</p><p id="11fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一方面，如果GPS设置是适当的，那么getLocationUpdates()将被包含纬度和经度的对<double double="">调用。</double></p><p id="f1f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">getLocationUpdates()函数将从viewModelScope调用，因此直到ViewModel在内存中，位置更新才会被传递。协程支持结构化并发，因此如果viewModelScope过期，它将抛出异常，该异常将被finally block捕获，更新将被停止。这样，我们可以保证在执行过程中不会发生内存泄漏。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="6745" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用这个构建函数，我们可以很容易地在基于回调和基于协程的世界之间架起一座桥梁。这也适用于任何未来、任务、单身、也许等等。对象，因为它们在内部使用回调。</p></div></div>    
</body>
</html>