<html>
<head>
<title>Advanced Python made easy — 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级Python变得简单— 2</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/advanced-python-made-easy-2-d5a7ffb4e658?source=collection_archive---------3-----------------------#2018-10-30">https://medium.com/quick-code/advanced-python-made-easy-2-d5a7ffb4e658?source=collection_archive---------3-----------------------#2018-10-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1a1dcf88917090079b1d4c9aad6dd2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_4lxTLROUCIxpP3lftY95A.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.google.com/url?sa=i&amp;source=images&amp;cd=&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjdpuO72K3eAhUPTY8KHaPSDlMQjB16BAgBEAQ&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DnYDKH9fvlBY&amp;psig=AOvVaw15dGMwvmWMVNU4HgKcVb_m&amp;ust=1540972559079869" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="965d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<a class="ae it" rel="noopener" href="/quick-code/advanced-python-made-easy-eece317334fa">上一篇文章</a>中，我们已经大致了解了python编程语言的几个有用特性。所以，把这看作是前一篇文章的延续，我们会用一些额外的概念来扩展它，很明显是使用了装饰符，也就是说，不会扰乱前一篇文章的实际内容。</p><h2 id="956f" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">装修工</h2><p id="f1bb" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">装饰器的概念不仅在python领域，而且在整个软件设计领域，呈现了最美丽和最强大的设计可能性之一。装饰者本质上只是包装者，主要通过扩展功能来修改代码的行为，而不需要改变它所包装的内容。为了让概念变得清晰，让我们从建立基础开始。</p><p id="e981" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">函数又名第一类对象</strong></p><p id="4fc3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">函数只是根据给定的参数返回一个值。在python中，这些函数被赋予了额外的荣誉<strong class="iw hi">一级对象</strong>。考虑到函数可以像普通对象一样传递和用作参数，这一荣誉被恰当地授予了函数。例如，它们可以作为参数传递给其他函数，也可以用作函数的返回值。</p><p id="7088" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">充当自变量</strong></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2421" class="js jt hh kx b fi lb lc l ld le">def greet(name):<br/>    print ('Hello ' + name)</span><span id="0236" class="js jt hh kx b fi lf lc l ld le">def send_greetings(fun, name):<br/>    fun(name)</span><span id="cca6" class="js jt hh kx b fi lf lc l ld le">send_greetings(greet, 'John')</span></pre><p id="5e2e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">内部函数</strong></p><p id="a7c8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">内部函数是在其他函数内部定义的。因此，在调用父函数之前，内部函数不会被定义，或者它们的局部范围是父函数，或者它们只作为局部变量存在于父函数中。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="0194" class="js jt hh kx b fi lb lc l ld le">def send_greetings(name):<br/>    def greet_message():<br/>        return ‘Hello ‘<br/>    result = greet_message() + name<br/>    print (result)<br/> <br/>send_greetings(‘John’)</span></pre><p id="8332" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">从函数中返回函数</strong></p><p id="0f7e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Python也允许使用function作为其他函数的返回值。本质上，我们只是返回对内部函数的引用，我们稍后可以调用它。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b991" class="js jt hh kx b fi lb lc l ld le">def classify(element):<br/>    def even_number():<br/>        print ('Element is even.')<br/>    def odd_number():<br/>        print ('Element is odd.')<br/>    if element%2 == 0:<br/>        return even_number<br/>    else:<br/>        return odd_number</span><span id="7914" class="js jt hh kx b fi lf lc l ld le">classify(2)()</span></pre><p id="79c3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">装修工</strong></p><p id="9c37" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，有了所有这些基本概念，让我们把这些部分组合起来，形成一个完整的画面。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f090" class="js jt hh kx b fi lb lc l ld le">def my_decorator(fun):<br/>    def wrapper():<br/>        print (‘Before calling the function…’)<br/>        fun()<br/>        print (‘After calling the function…’)<br/>    return wrapper</span><span id="4709" class="js jt hh kx b fi lf lc l ld le">def say_hello():<br/>    print (‘Hello!’)</span><span id="0409" class="js jt hh kx b fi lf lc l ld le">say_hello = my_decorator(say_hello)</span></pre><p id="06e6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就是这样！！！。这是我们能找到的最简单的室内设计师。我们实际上只是应用了目前为止所学的知识。所以装潢师是</p><blockquote class="lg lh li"><p id="1ee6" class="iu iv lj iw b ix iy iz ja jb jc jd je lk jg jh ji ll jk jl jm lm jo jp jq jr ha bi translated">一个函数将另一个函数作为参数，生成一个新函数，增加原始函数的功能，最后返回生成的函数，这样我们就可以在任何地方使用它。</p></blockquote><p id="88cd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，python使得程序员创建和使用decorators变得更加干净和友好。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="712d" class="js jt hh kx b fi lb lc l ld le">def my_decorator(fun):<br/>    def wrapper():<br/>        print (‘Before calling the function…’)<br/>        fun()<br/>        print (‘After calling the function…’)<br/>    return wrapper</span><span id="0fc2" class="js jt hh kx b fi lf lc l ld le">@my_decorator<br/>def say_hello():<br/>    print (‘Hello!’)</span></pre><h2 id="e61e" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">上下文管理器</h2><p id="ecab" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">简而言之，上下文管理器是一种资源获取和释放机制，它可以防止资源泄漏，并确保即使在面临致命异常时也能进行适当的清理。例如，确保文件打开后关闭，获取后释放锁。这个概念在许多其他编程语言中被清楚地表达和恰当地使用，比如C++中的<a class="ae it" href="https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii" rel="noopener ugc nofollow" target="_blank">RAII</a>。</p><p id="7ade" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从技术上讲，这是一个对象需要遵循的简单协议。此协议要求对象作为上下文管理器，实现__enter__和__exit__方法。</p><blockquote class="lg lh li"><p id="2a1b" class="iu iv lj iw b ix iy iz ja jb jc jd je lk jg jh ji ll jk jl jm lm jo jp jq jr ha bi translated">__enter__返回要管理的资源，而__exit__执行任何清理工作，不返回任何内容。</p></blockquote><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d3a5" class="js jt hh kx b fi lb lc l ld le">class File:<br/>    def __init__(self, name):<br/>        self.name = name<br/>    <br/>    def __enter__(self):<br/>        self.file = open(self.name, 'w')<br/>        return self.file</span><span id="a943" class="js jt hh kx b fi lf lc l ld le">    def __exit__(self, type, value, trace_back):<br/>        if self.file:<br/>            self.close()</span></pre><p id="31c2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在上面的类可以在带块的<strong class="iw hi">内安全使用。更一般地，使用<strong class="iw hi">和</strong>，我们可以调用任何返回上下文管理器的东西。</strong></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="00de" class="js jt hh kx b fi lb lc l ld le">with File('example.txt') as f:<br/>    f.write('Hey hello')<br/>    f.write('See you later. Bye!!!')</span></pre><p id="ee2d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">__enter__在执行用语句进入<strong class="iw hi">的上下文时调用。当执行用</strong>块离开<strong class="iw hi">时，调用__exit__。</strong></p><p id="bb35" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上下文管理器也可以用于更复杂的问题。让我们看另一个例子，对上下文管理器的需求几乎是不可避免的。正在讨论的资源是<em class="lj">锁</em>，我们可以避免的问题是巨大的<em class="lj">死锁</em>。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="9d60" class="js jt hh kx b fi lb lc l ld le">from threading import Lock<br/>lock = Lock()</span><span id="bee9" class="js jt hh kx b fi lf lc l ld le">def do_something():<br/>    lock.acquire()<br/>    raise Exception('Oops I am sorry. I have to raise it!')<br/>    lock.release()</span><span id="3830" class="js jt hh kx b fi lf lc l ld le">try:<br/>    do_something()<br/>except:<br/>    print ('Got an exception.')</span></pre><p id="cbdf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意，这个异常是在释放锁之前引发的。这样做的明显后果是，所有其他调用<em class="lj"> do_something </em>的线程将永远被阻塞，导致系统死锁。使用上下文管理器，我们可以摆脱这种糟糕的情况。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b3d7" class="js jt hh kx b fi lb lc l ld le">from threading import Lock<br/>lock = Lock()</span><span id="f905" class="js jt hh kx b fi lf lc l ld le">def do_something():<br/>    with lock:<br/>        raise Exception('Oops I am sorry. I have to raise it!')</span><span id="95bf" class="js jt hh kx b fi lf lc l ld le">try:<br/>    do_something()<br/>except:<br/>    print ('Got an exception.')</span></pre><p id="11d4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">哇哦。即使面对某些异常，清理也会正常进行。显然，没有合理的方法可以使用上下文管理器获得锁，而最终不释放它。就应该是这样。</p><h2 id="d94d" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">链式异常</h2><p id="a71e" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">考虑这样一种情况，由于试图将一个数除以零，一个方法抛出了<code class="du ln lo lp kx b">ZeroDivisionError</code>。显然，我们有一套很好的工具来处理python中的异常。然而，如果这个异常的原因是这个函数调用的其他函数中的<code class="du ln lo lp kx b">TypeError </code>呢？在这种情况下，仅仅报告顶级异常是不够的，因为我们将失去异常链的起源和主要原因。为了证明这个概念，让我们举一个简单的例子。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2ac1" class="js jt hh kx b fi lb lc l ld le">def chained_exceptions():<br/>    try:<br/>        raise ValueError(17)<br/>    except Exception as ex:<br/>        raise ValueError(23) from ex<br/><br/>if __name__ == "__main__":<br/>    chained_exceptions()</span></pre><p id="d6df" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在python 2.0中，类似上面的情况会导致后一个异常被报告，而前一个异常丢失，如下图所示。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b095" class="js jt hh kx b fi lb lc l ld le">Traceback (most recent call last):<br/>File “test.py”, line 3, in chained_exceptions<br/>    raise ValueError(23)<br/>ValueError: 23</span></pre><p id="d867" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">显然，我们已经失去了一条有价值的信息，因为我们失去了异常的实际原因，即它的起源。然而，用python 3.0运行相同的脚本，我们会得到完整的异常堆栈跟踪。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4f86" class="js jt hh kx b fi lb lc l ld le">Traceback (most recent call last):<br/>File “test.py”, line 3, in chained_exceptions<br/>    raise ValueError(17)<br/>ValueError: 17</span><span id="60f0" class="js jt hh kx b fi lf lc l ld le">The above exception was the direct cause of the following exception:</span><span id="4f0d" class="js jt hh kx b fi lf lc l ld le">Traceback (most recent call last):<br/>File “test.py”, line 8, in &lt;module&gt; chained_exceptions()<br/>File “test.py”, line 5, in chained_exceptions<br/>    raise ValueError(23) from ex<br/>ValueError: 23</span></pre><p id="f0b5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请通过您的评论让我知道文章中需要的任何修改/改进。</p></div></div>    
</body>
</html>