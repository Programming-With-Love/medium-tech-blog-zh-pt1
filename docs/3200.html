<html>
<head>
<title>All you Need to Know About Solid Principles in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你所需要知道的关于Java的坚实原理</h1>
<blockquote>原文：<a href="https://medium.com/edureka/solid-principles-in-java-b4b029776231?source=collection_archive---------0-----------------------#2019-09-13">https://medium.com/edureka/solid-principles-in-java-b4b029776231?source=collection_archive---------0-----------------------#2019-09-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/44b1cc01f544ee31fabecc07f1b61448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*T0B3kJSZSutrSzdx.jpg"/></div></figure><p id="55f0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在面向对象编程(OOP)的世界中，有许多设计指南、模式或原则。这些原则中的五个通常被组合在一起，并被缩写为SOLID。虽然这五个原则中的每一个都描述了一些特定的东西，但是它们也有重叠，因此采用其中的一个意味着或导致采用另一个。在本文中，我们将了解Java中的坚实原理。</p><ul class=""><li id="297a" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">Java坚实原则的历史</li><li id="4067" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">神盾局是什么意思？</li></ul><h1 id="b000" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Java坚实原则的历史</h1><p id="921e" class="pw-post-body-paragraph il im hh in b io kv iq ir is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">罗伯特·马丁(Robert C. Martin)给出了五个面向对象的设计原则，首字母缩写“S.O.L.I.D”用于表示它。当你结合使用S.O.L.I.D的所有原则时，开发易于管理的软件就变得更容易了。使用S.O.L.I.D .的其他功能有:</p><ul class=""><li id="7df3" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">它避免了代码气味。</li><li id="7632" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">快速折射代码。</li><li id="72cd" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">可以进行适应性或敏捷的软件开发。</li></ul><p id="433f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当你在编码中使用S.O.L.I.D原则时，你就开始编写既高效又有效的代码。</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es la"><img src="../Images/091b703b87b654945f67ee3cb4d01fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*cZvxgEyC4LDuTN6d.png"/></div></figure><h1 id="d636" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">神盾局是什么意思？</h1><p id="001a" class="pw-post-body-paragraph il im hh in b io kv iq ir is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">Solid代表了java的五个原则，它们是:</p><ul class=""><li id="4f44" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">单一责任原则</li><li id="6571" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><strong class="in hi"> O </strong>:开闭原理</li><li id="3f0b" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><strong class="in hi"> L </strong>:利斯科夫替代原理</li><li id="a6fa" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><strong class="in hi"> I </strong>:界面分离原理</li><li id="da52" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><strong class="in hi"> D </strong>:依存倒置原则</li></ul><p id="a1c3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这个博客中，我们将详细讨论Java的所有五个坚实的原则。</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es la"><img src="../Images/a24fb26fefb89c0f3b4734649bff3a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*URUyOyqwOVGup9ZG.png"/></div></figure><h1 id="85d1" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Java中的单一责任原则</h1><p id="8910" class="pw-post-body-paragraph il im hh in b io kv iq ir is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">它说什么？</p><p id="b115" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Robert C. Martin将其描述为一个类应该有且只有一个责任。</p><p id="d17b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">根据单一责任原则，应该只有一个原因导致一个类被改变。这意味着一个类应该有一个任务要做。这一原则通常被称为主观的。</p><p id="b389" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">用一个例子就能很好地理解原理。假设有一个执行以下操作的类。</p><ul class=""><li id="3c59" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">连接到数据库</li><li id="63ca" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">从数据库表中读取一些数据</li><li id="d21d" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">最后，将其写入文件。</li></ul><p id="648f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你想象过这个场景吗？在这里，类有多种改变的原因，其中一些是文件输出的修改、新数据库的采用。当我们谈论单一原则责任时，我们会说，有太多的理由让这个阶级改变；因此，它不适合单一责任原则。</p><p id="d9ad" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，汽车类可以自己启动或停止，但清洗它的任务属于CarWash类。在另一个例子中，一个Book类有存储它自己的名字和文本的属性。但是打印书的任务必须属于书打印机类。Book Printer类可能会打印到控制台或另一个介质，但这种依赖关系已从Book类中删除</p><h1 id="2434" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">为什么需要这个原则？</h1><p id="db87" class="pw-post-body-paragraph il im hh in b io kv iq ir is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">当遵循单一责任原则时，测试更容易。有了单一的责任，这个类将会有更少的测试用例。更少的功能也意味着对其他类的依赖性更少。这导致了更好的代码组织，因为更小和更好的类更容易搜索。</p><p id="88d8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一个阐明这一原则的例子:</p><p id="1ff2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">假设您被要求实现一个用户设置服务，其中用户可以更改设置，但在此之前，用户必须经过身份验证。实现这一点的一种方法是:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="987e" class="lk jy hh lg b fi ll lm l ln lo">public class UserSettingService<br/>{<br/>public void changeEmail(User user)<br/>{<br/>if(checkAccess(user))<br/>{<br/>//Grant option to change<br/>}<br/>}<br/>public boolean checkAccess(User user)<br/>{<br/>//Verify if the user is valid.<br/>}<br/>}</span></pre><p id="28ed" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一切看起来都很好，除非您想在其他地方重用检查访问代码，或者您想对检查访问的方式进行更改。在这两种情况下，您最终都要更改同一个类，在第一种情况下，您还必须使用UserSettingService来检查访问。<br/>纠正这种情况的一种方法是将用户设置服务分解为用户设置服务和安全服务。并将检查访问代码移动到SecurityService中。</p><p id="75de" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一切看起来都很好，除非您想在其他地方重用checkAccess代码，或者您想对checkAccess的执行方式进行更改。在这两种情况下，您最终都要更改同一个类，在第一种情况下，您还必须使用UserSettingService来检查访问。<br/>纠正这种情况的一种方法是将UserSettingService分解为UserSettingService和SecurityService。并将checkAccess代码移到SecurityService中。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="aee5" class="lk jy hh lg b fi ll lm l ln lo">public class UserSettingService<br/>{<br/>   public void changeEmail(User user)<br/>  {<br/>    if(SecurityService.checkAccess(user))<br/>   {<br/>//Grant option to change<br/>   }<br/> }<br/> <br/>}<br/> <br/>public class SecurityService<br/>{<br/>public static boolean checkAccess(User user)<br/>{<br/>//check the access.<br/>}<br/>}</span></pre><h1 id="9a0b" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Java中的开闭原则</h1><p id="aa34" class="pw-post-body-paragraph il im hh in b io kv iq ir is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">Robert C. Martin将其描述为软件组件应该对扩展开放，但对修改关闭。</p><p id="b97c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">准确地说，根据这个原则，一个类应该以这样一种方式编写，它可以完美地执行它的工作，而不需要假设未来的人会简单地来改变它。因此，该类应该保持关闭以便修改，但是它应该有扩展的选项。扩展该类的方法包括:</p><ul class=""><li id="1641" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">从类继承</li><li id="134e" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">从类中重写所需的行为</li><li id="3a7e" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">扩展类的某些行为</li></ul><p id="0788" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">开闭原理的一个很好的例子，可以借助浏览器来理解。你还记得在你的chrome浏览器中安装扩展吗？</p><p id="9ac9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">chrome浏览器的基本功能是浏览不同的网站。当你使用chrome浏览器写邮件时，你想检查语法吗？如果是的话，你可以简单地使用语法扩展，它提供你对内容的语法检查。</p><p id="9b24" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这种增加浏览器功能的机制是一种扩展。因此，浏览器是一个很好的功能性的例子，它对扩展是开放的，但对修改是关闭的。简单来说，你可以通过在浏览器上添加/安装插件来增强功能，但不能构建任何新的东西。</p><h1 id="4e8b" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">为什么需要这个原则？</h1><p id="65b5" class="pw-post-body-paragraph il im hh in b io kv iq ir is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">OCP很重要，因为课程可能是通过第三方图书馆提供给我们的。我们应该能够扩展那些类，而不用担心那些基类是否支持我们的扩展。但是继承可能导致依赖基类实现的子类。为了避免这种情况，建议使用接口。这种额外的抽象导致了松散耦合。</p><p id="85ba" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">假设我们需要计算各种形状的面积。我们首先为第一个矩形创建一个类，它有两个属性:长度和宽度。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="e98d" class="lk jy hh lg b fi ll lm l ln lo"><strong class="lg hi">public</strong> <strong class="lg hi">class</strong> <!-- -->Rectangle</span><span id="8a67" class="lk jy hh lg b fi lp lm l ln lo">{</span><span id="e9d0" class="lk jy hh lg b fi lp lm l ln lo"><strong class="lg hi">public</strong> <strong class="lg hi">double</strong> <!-- -->length;</span><span id="bd20" class="lk jy hh lg b fi lp lm l ln lo"><strong class="lg hi">public</strong> <strong class="lg hi">double</strong> <!-- -->width;</span><span id="e7cd" class="lk jy hh lg b fi lp lm l ln lo">}</span></pre><p id="0073" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">接下来，我们创建一个类来计算这个矩形的面积，该类有一个calculateRectangleArea方法，该方法将矩形作为输入参数并计算其面积。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="a166" class="lk jy hh lg b fi ll lm l ln lo">public class AreaCalculator<br/>{<br/>  public double calculateRectangleArea(Rectangle rectangle)<br/> {<br/>  return rectangle.length *rectangle.width;<br/> }<br/>}</span></pre><p id="2a4c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">到目前为止一切顺利。现在假设我们得到了第二个形状圆。因此，我们立即创建了一个新的具有单一属性半径的类圆。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="af79" class="lk jy hh lg b fi ll lm l ln lo">public class Circle<br/>{<br/>public double radius;<br/>}</span></pre><p id="0df5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后我们修改Areacalculator类，通过一个新方法calculateCircleaArea()添加圆计算</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="85d0" class="lk jy hh lg b fi ll lm l ln lo">public class AreaCalculator<br/> <br/>{<br/>   public double calculateRectangleArea(Rectangle rectangle)<br/>  {<br/>     return rectangle.length *rectangle.width;<br/>     }<br/>public double calculateCircleArea(Circle circle)<br/> <br/>    {<br/>return (22/7)*circle.radius*circle.radius;<br/>  }<br/>}</span></pre><p id="7848" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">但是，请注意，我们在上面设计解决方案的方式中存在缺陷。</p><p id="3a26" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">假设我们有一个新的五边形。在这种情况下，我们将再次修改AreaCalculator类。随着形状类型的增加，这变得更加混乱，因为AreaCalculator一直在变化，这个类的任何用户都必须不断更新包含AreaCalculator的库。因此，AreaCalculator类不会被基线化(最终化),因为每次一个新的形状出现，它都会被修改。所以，这个设计是不能修改的。</p><p id="9c77" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">AreaCalculator将需要继续在更新的方法中添加计算逻辑。我们并没有真正扩大形状的范围；相反，我们只是为每一个添加的形状做一点一点的解决方案。</p><p id="228d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">修改上述设计，以符合开启/关闭原则:</p><p id="f2a2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在让我们来看一个更优雅的设计，它通过坚持打开/关闭原则解决了上述设计中的缺陷。首先，我们将使设计具有可扩展性。为此，我们需要首先定义一个基本类型的形状，并让圆形和矩形实现形状接口。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="19be" class="lk jy hh lg b fi ll lm l ln lo">public interface Shape<br/>{<br/>public double calculateArea();<br/>}<br/> <br/>public class Rectangle implements Shape<br/>{<br/>double length;<br/>double width;<br/>public double calculateArea()<br/>{<br/>return length * width;<br/>}<br/>}<br/> <br/>public class Circle implements Shape<br/>{<br/>public double radius;<br/>public double calculateArea()<br/>{<br/>return (22/7)*radius*radius;<br/>}<br/>}</span></pre><p id="191e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">有一个基本接口形状。所有形状现在都实现了基本接口形状。shape接口有一个抽象方法calculateArea()。circle和rectangle都使用自己的属性提供了自己的calculateArea()方法的重写实现。我们引入了一定程度的可扩展性，因为形状现在是形状接口的一个实例。这允许我们使用形状而不是单独的类<br/>上面最后一点提到了这些形状的消费者。在我们的例子中，消费者将是AreaCalculator类，现在看起来像这样。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="4ca0" class="lk jy hh lg b fi ll lm l ln lo">public class AreaCalculator<br/>{<br/>public double calculateShapeArea(Shape shape)<br/>{<br/>return shape.calculateArea();<br/>}<br/>}</span></pre><p id="fcaf" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这个AreaCalculator类现在完全消除了我们上面提到的设计缺陷，并且给出了一个遵循开闭原则的简洁的解决方案。让我们继续学习Java中的其他坚实的原理</p><h1 id="719e" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">Java中的Liskov替换原理</h1><p id="837f" class="pw-post-body-paragraph il im hh in b io kv iq ir is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">Robert C. Martin将其描述为派生类型必须完全可以替换其基本类型。</p><p id="0d36" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">利斯科夫替换原则假设q(x)是一个属性，关于属于类型t的x的实体是可证明的。现在，根据这个原则，对于属于类型S的对象y，q (y)现在应该是可证明的，并且S实际上是t的子类型。你现在困惑了，不知道利斯科夫替换原则实际上是什么意思吗？它的定义可能有点复杂，但事实上，它很简单。唯一的事情是，每个子类或派生类应该可以替换它们的父类或基类。</p><p id="e5b6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你可以说它是一个独特的面向对象原则。该原理可以进一步简化为:一个特定父类型的子类型，在不制造任何复杂情况或搞砸事情的情况下，应该有能力代替那个父类型。这个原理与利斯科夫替代原理密切相关。</p><h1 id="7345" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">为什么需要这个原则？</h1><p id="f7d1" class="pw-post-body-paragraph il im hh in b io kv iq ir is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">这避免了误用继承。它帮助我们符合“是-是”的关系。我们也可以说子类必须履行基类定义的契约。从这个意义上说，它与由Bertrand Meyer首先描述的契约设计有关。例如，很容易说圆是一种椭圆，但圆没有两个焦点或长/短轴。</p><p id="358e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">LSP通常用正方形和长方形的例子来解释。如果我们假设正方形和长方形之间有ISA关系。因此，我们称“正方形是长方形”下面的代码代表了这种关系。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="3c99" class="lk jy hh lg b fi ll lm l ln lo">public class Rectangle<br/>{<br/>private int length;<br/>private int breadth;<br/>public int getLength()<br/>{<br/>return length;<br/>}<br/>public void setLength(int length)<br/>{<br/>this.length = length;<br/>}<br/>public int getBreadth()<br/>{<br/>return breadth;<br/>}<br/>public void setBreadth(int breadth)<br/>{<br/>this.breadth = breadth;<br/>}<br/>public int getArea()<br/>{<br/>return this.length * this.breadth;<br/>}<br/>}</span></pre><p id="f0fa" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下面是Square的代码。请注意，正方形扩展了矩形。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="5247" class="lk jy hh lg b fi ll lm l ln lo">public class Square extends Rectangle<br/>{<br/> <br/>public void setBreadth(int breadth)<br/>{<br/>super.setBreadth(breadth);<br/>super.setLength(breadth);<br/>}<br/> <br/>public void setLength(int length)<br/>{<br/>super.setLength(length);<br/>super.setBreadth(length);<br/>}<br/>}</span></pre><p id="239c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这种情况下，我们尝试在Square和Rectangle之间建立一个ISA关系，这样，如果传递了Square的一个实例，那么在下面的代码中调用“Square is a Rectangle”将会出现意外行为。在检查“面积”和检查“宽度”的情况下，将会抛出断言错误，尽管程序会由于面积检查失败而抛出断言错误而终止。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="ce66" class="lk jy hh lg b fi ll lm l ln lo">public class LSPDemo<br/>{<br/>public void calculateArea(Rectangle r)<br/>{<br/>r.setBreadth(2);<br/>r.setLength(3);<br/>assert r.getArea() == 6 : printError("area", r);<br/>assert r.getLength() == 3 : printError("length", r);<br/>assert r.getBreadth() == 2 : printError("breadth", r);<br/>}<br/>private String printError(String errorIdentifer, Rectangle r)<br/>{<br/>return "Unexpected value of " + errorIdentifer + " for instance of " + r.getClass().getName();<br/>}<br/>public static void main(String[] args)<br/>{<br/>LSPDemo lsp = new LSPDemo();<br/>// An instance of Rectangle is passed<br/>lsp.calculateArea(new Rectangle());<br/>// An instance of Square is passed<br/>lsp.calculateArea(new Square());<br/>}<br/>}</span></pre><p id="4be8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">该类演示了Liskov替换原则(LSP)。根据该原则，使用基类引用的函数必须能够在不知道的情况下使用派生类的对象。</p><p id="5c30" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因此，在下面的示例中，使用“Rectangle”引用的函数calculateArea应该能够使用Square等派生类的对象，并满足矩形定义提出的要求。应该注意，根据矩形的定义，在给定以下数据的情况下，以下必须始终成立:</p><ol class=""><li id="181b" class="jj jk hh in b io ip is it iw jl ja jm je jn ji lq jp jq jr bi translated">长度必须始终等于作为方法setLength的输入传递的长度</li><li id="3f4c" class="jj jk hh in b io js is jt iw ju ja jv je jw ji lq jp jq jr bi translated">宽度必须始终等于作为输入传递给方法setBreadth的宽度</li><li id="4163" class="jj jk hh in b io js is jt iw ju ja jv je jw ji lq jp jq jr bi translated">面积必须始终等于长度和宽度的乘积</li></ol><p id="3516" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果我们试图在正方形和矩形之间建立ISA关系，我们称之为“正方形是一个矩形”，上面的代码将开始意外地运行，如果正方形的一个实例被传递，在检查面积和检查宽度的情况下将抛出断言错误，尽管程序将终止，因为断言错误是由于面积检查失败而抛出的。</p><p id="953d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Square类不需要像set width或setLength这样的方法。LSPDemo类需要知道Rectangle(如Square)的派生类的详细信息，以适当地编码，避免抛出错误。现有代码的改变首先打破了开闭原则。</p><h1 id="3241" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">界面分离原理</h1><p id="7f50" class="pw-post-body-paragraph il im hh in b io kv iq ir is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">Robert C. Martin将其描述为客户不应该被迫实现他们不会使用的不必要的方法。</p><p id="76a6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">根据接口分离原则，无论如何都不应该强迫客户实现它不使用的接口，或者不应该强迫客户依赖他们不使用的任何方法。因此，基本上，接口分离原则，因为你喜欢的接口，这是小的，但客户特定的，而不是单片和更大的接口。简而言之，强迫客户依赖他们不需要的某样东西对你来说是不好的。</p><p id="8e69" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，用于写入和读取日志的单个日志记录接口对于数据库很有用，但对于控制台就不一样了。对于控制台日志记录器来说，读取日志毫无意义。继续这篇坚实的Java原理文章。</p><h1 id="f6be" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">为什么需要这个原则？</h1><p id="b035" class="pw-post-body-paragraph il im hh in b io kv iq ir is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">假设有一个餐馆接口，其中包含接受来自在线客户、拨入或电话客户以及上门客户的订单的方法。它还包含处理在线支付(针对在线客户)和当面支付(针对上门客户以及电话客户，当他们的订单送货上门时)的方法。</p><p id="b5fe" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在让我们为餐馆创建一个Java接口，并将其命名为RestaurantInterface.java。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="2f4e" class="lk jy hh lg b fi ll lm l ln lo">public interface RestaurantInterface<br/>{<br/>  public void acceptOnlineOrder();<br/>  public void takeTelephoneOrder();<br/>  public void payOnline();<br/>  public void walkInCustomerOrder();<br/>  public void payInPerson();<br/>}</span></pre><p id="ec6d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">RestaurantInterface中定义了5种方法，分别用于接受在线订单、接受电话订单、接受无预约顾客的订单、接受在线支付和亲自接受支付。</p><p id="10df" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们从为在线客户实现餐馆界面开始，就像OnlineClientImpl.java一样</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="eb52" class="lk jy hh lg b fi ll lm l ln lo">public class OnlineClientImpl implements RestaurantInterface<br/>{<br/>public void acceptOnlineOrder()<br/>{<br/>//logic for placing online order<br/>}<br/>public void takeTelephoneOrder()<br/>{<br/>//Not Applicable for Online Order<br/>throw new UnsupportedOperationException();<br/>}<br/>public void payOnline()<br/>{<br/>//logic for paying online<br/>}<br/>public void walkInCustomerOrder()<br/>{<br/>//Not Applicable for Online Order<br/>throw new UnsupportedOperationException();<br/>}<br/>public void payInPerson() {<br/>//Not Applicable for Online Order<br/>throw new UnsupportedOperationException();<br/>}<br/>}</span></pre><ul class=""><li id="af7f" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">由于上面的代码(OnlineClientImpl.java)是针对在线订单的，所以抛出UnsupportedOperationException。</li><li id="7c4c" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">在线、电话和无预约客户使用特定于他们的RestaurantInterface实现。</li><li id="30c2" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">电话客户和无预约客户的实现类将有不支持的方法。</li><li id="1a00" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">因为这5个方法是RestaurantInterface的一部分，所以实现类必须实现所有这5个方法。</li><li id="3331" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">每个实现类抛出UnsupportedOperationException的方法。正如你可以清楚地看到的——实现所有的方法是低效的。</li><li id="395c" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">RestaurantInterface的任何方法中的任何更改都将传播到所有实现类。然后代码的维护开始变得非常麻烦，变更的回归效应会不断增加。</li><li id="5282" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">RestaurantInterface.java打破了单一责任原则，因为付款逻辑和订单逻辑都集中在一个界面中。</li></ul><p id="045a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了克服上述问题，我们应用接口分离原理来重构上述设计。</p><ol class=""><li id="7400" class="jj jk hh in b io ip is it iw jl ja jm je jn ji lq jp jq jr bi translated">将支付和订单功能分离到两个独立的精益接口中，PaymentInterface.java和PaymentInterface.java。</li><li id="3710" class="jj jk hh in b io js is jt iw ju ja jv je jw ji lq jp jq jr bi translated">每个客户端都使用PaymentInterface和OrderInterface的一个实现。例如—OnlineClient.java使用OnlinePaymentImpl和OnlineOrderImpl等等。</li><li id="bc15" class="jj jk hh in b io js is jt iw ju ja jv je jw ji lq jp jq jr bi translated">单一责任原则现在附加为支付接口(PaymentInterface.java)和订购接口(OrderInterface)。</li><li id="5f1a" class="jj jk hh in b io js is jt iw ju ja jv je jw ji lq jp jq jr bi translated">订单或支付界面中任何一个的变化都不会影响另一个。他们现在独立了。不需要做任何虚拟实现或者抛出一个UnsupportedOperationException，因为每个接口只有它将一直使用的方法。</li></ol><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es lr"><img src="../Images/0f135966ae84dbd96c501fffb9284c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/0*MVa83Ar6saej-4q2.png"/></div></figure><p id="6206" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">申请ISP后</strong></p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es ls"><img src="../Images/01b9867976623958889ab6f1dcd1cb91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YHEDQkxseA291Hso.png"/></div></figure><h1 id="0057" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">从属倒置原则</h1><p id="7881" class="pw-post-body-paragraph il im hh in b io kv iq ir is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">罗伯特·c·马丁认为它依赖于抽象，而不是具体。根据它，高级模块决不能依赖于任何低级模块。例如</p><p id="1f9a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你去当地的商店买东西，你决定用你的借记卡支付。所以，当你把你的卡交给店员付款时，店员根本不会检查你给的是哪种卡。</p><p id="ab9f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">就算你给了Visa卡，他也不会拿出Visa机给你刷卡。你用哪种类型的信用卡或借记卡付款并不重要；他们会简单地刷一下。所以，在这个例子中，你可以看到你和店员都依赖于信用卡的抽象，你不担心卡的细节。这就是依赖性反转原则。</p><h1 id="ec23" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">为什么需要这个原则？</h1><p id="b2c8" class="pw-post-body-paragraph il im hh in b io kv iq ir is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">它允许程序员去除硬编码的依赖性，从而使应用程序变得松散耦合和可扩展。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="6664" class="lk jy hh lg b fi ll lm l ln lo">public class Student<br/>{<br/>   private Address address;<br/>   public Student()<br/>  {<br/>    address = new Address();<br/>   }<br/>}</span></pre><p id="2dce" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在上面的例子中，Student类需要一个地址对象，它负责初始化和使用地址对象。如果将来改变了地址类，那么我们也必须改变学生类。这使得学生和地址对象之间紧密耦合。我们可以使用依赖倒置设计模式来解决这个问题。即，地址对象将被独立实现，并且将在通过使用基于构造函数或基于设置器的依赖性反转来实例化学生时被提供给学生。</p><p id="e2e0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">至此，我们结束了Java中的这个坚实的原则。如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，你可以参考Edureka的官方网站。</p><p id="ba96" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">请留意本系列中解释Java其他各方面的其他文章。</p><blockquote class="lu lv lw"><p id="5d92" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 1。</em> <a class="ae lt" rel="noopener" href="/edureka/object-oriented-programming-b29cfd50eca0"> <em class="hh">面向对象编程</em> </a></p><p id="10af" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 2。</em><a class="ae lt" rel="noopener" href="/edureka/inheritance-in-java-f638d3ed559e"><em class="hh">Java中的继承</em> </a></p><p id="003b" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 3。</em><a class="ae lt" rel="noopener" href="/edureka/polymorphism-in-java-9559e3641b9b"><em class="hh">Java中的多态性</em> </a></p><p id="7762" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 4。</em><a class="ae lt" rel="noopener" href="/edureka/java-abstraction-d2d790c09037"><em class="hh">Java中的抽象</em> </a></p><p id="5392" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 5。</em> <a class="ae lt" rel="noopener" href="/edureka/java-string-68e5d0ca331f"> <em class="hh"> Java字符串</em> </a></p><p id="3ff2" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 6。</em> <a class="ae lt" rel="noopener" href="/edureka/java-array-tutorial-50299ef85e5"> <em class="hh"> Java数组</em> </a></p><p id="8f28" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 7。</em> <a class="ae lt" rel="noopener" href="/edureka/java-collections-6d50b013aef8"> <em class="hh"> Java收藏</em> </a></p><p id="c747" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 8。</em> <a class="ae lt" rel="noopener" href="/edureka/java-thread-bfb08e4eb691"> <em class="hh"> Java线程</em> </a></p><p id="e3c8" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 9。</em><a class="ae lt" rel="noopener" href="/edureka/java-servlets-62f583d69c7e"><em class="hh">Java servlet简介</em> </a></p><p id="f982" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 10。</em> <a class="ae lt" rel="noopener" href="/edureka/servlet-and-jsp-tutorial-ef2e2ab9ee2a"> <em class="hh"> Servlet和JSP教程</em> </a></p><p id="7861" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 11。</em><a class="ae lt" rel="noopener" href="/edureka/java-exception-handling-7bd07435508c"><em class="hh">Java中的异常处理</em> </a></p><p id="8476" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 12。</em> <a class="ae lt" rel="noopener" href="/edureka/java-tutorial-bbdd28a2acd7"> <em class="hh"> Java教程</em> </a></p><p id="a55f" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 13。</em> <a class="ae lt" rel="noopener" href="/edureka/java-interview-questions-1d59b9c53973"> <em class="hh"> Java面试题</em> </a></p><p id="ed2f" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 14。</em> <a class="ae lt" rel="noopener" href="/edureka/java-programs-1e3220df2e76"> <em class="hh"> Java程序</em> </a></p><p id="9714" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 15。</em><a class="ae lt" rel="noopener" href="/edureka/kotlin-vs-java-4f8653f38c04"><em class="hh">kot Lin vs Java</em></a></p><p id="ce8a" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 16。</em> <a class="ae lt" rel="noopener" href="/edureka/what-is-dependency-injection-5006b53af782"> <em class="hh">依赖注入使用Spring Boot </em> </a></p><p id="a3b8" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 17。</em> <a class="ae lt" rel="noopener" href="/edureka/comparable-in-java-e9cfa7be7ff7"> <em class="hh">堪比爪哇的</em> </a></p><p id="4c98" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated">18。 <a class="ae lt" rel="noopener" href="/edureka/java-frameworks-5d52f3211f39"> <em class="hh">十大Java框架</em> </a></p><p id="39f7" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 19。</em> <a class="ae lt" rel="noopener" href="/edureka/java-reflection-api-d38f3f5513fc"> <em class="hh"> Java反射API </em> </a></p><p id="bcd3" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated">20。<a class="ae lt" rel="noopener" href="/edureka/pattern-programs-in-java-f33186c711c8"><em class="hh">Java中的30大模式</em> </a></p><p id="6f1e" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated">21。 <a class="ae lt" rel="noopener" href="/edureka/java-cheat-sheet-3ad4d174012c"> <em class="hh">核心Java备忘单</em> </a></p><p id="8716" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 22。</em><a class="ae lt" rel="noopener" href="/edureka/socket-programming-in-java-f09b82facd0"><em class="hh">Java中的套接字编程</em> </a></p><p id="b6dc" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 23。</em> <a class="ae lt" rel="noopener" href="/edureka/java-oop-cheat-sheet-9c6ebb5e1175"> <em class="hh"> Java OOP备忘单</em> </a></p><p id="50c1" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 24。</em><a class="ae lt" rel="noopener" href="/edureka/annotations-in-java-9847d531d2bb"><em class="hh">Java中的注释</em> </a></p><p id="6f53" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 25。</em><a class="ae lt" rel="noopener" href="/edureka/library-management-system-project-in-java-b003acba7f17"><em class="hh">Java中的库管理系统项目</em> </a></p><p id="5859" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 26。</em><a class="ae lt" rel="noopener" href="/edureka/java-binary-tree-caede8dfada5"><em class="hh">Java中的树</em> </a></p><p id="d0b7" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 27。</em><a class="ae lt" rel="noopener" href="/edureka/machine-learning-in-java-db872998f368"><em class="hh">Java中的机器学习</em> </a></p><p id="bed4" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 28。</em> <a class="ae lt" rel="noopener" href="/edureka/data-structures-algorithms-in-java-d27e915db1c5"> <em class="hh">顶级数据结构&amp;Java中的算法</em> </a></p><p id="27f2" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 29。</em> <a class="ae lt" rel="noopener" href="/edureka/java-developer-skills-83983e3d3b92"> <em class="hh"> Java开发者技能</em> </a></p><p id="00ce" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 30。</em> <a class="ae lt" rel="noopener" href="/edureka/servlet-interview-questions-266b8fbb4b2d"> <em class="hh">前55名Servlet面试问题</em> </a></p><p id="53c8" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 31。</em><a class="ae lt" rel="noopener" href="/edureka/java-exception-handling-7bd07435508c"><em class="hh"/></a><a class="ae lt" rel="noopener" href="/edureka/java-projects-db51097281e3"><em class="hh">顶级Java项目</em> </a></p><p id="3d88" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 32。</em> <a class="ae lt" rel="noopener" href="/edureka/java-string-cheat-sheet-9a91a6b46540"> <em class="hh"> Java字符串备忘单</em> </a></p><p id="20b8" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 33。</em><a class="ae lt" rel="noopener" href="/edureka/nested-classes-java-f1987805e7e3"><em class="hh">Java中的嵌套类</em> </a></p><p id="44b1" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 34。</em> <a class="ae lt" rel="noopener" href="/edureka/java-collections-interview-questions-162c5d7ef078"> <em class="hh"> Java集合面试问答</em> </a></p><p id="fe0e" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated">35。<a class="ae lt" rel="noopener" href="/edureka/deadlock-in-java-5d1e4f0338d5"><em class="hh">Java中如何处理死锁？</em> </a></p><p id="64fe" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated">36。 <a class="ae lt" rel="noopener" href="/edureka/java-collections-interview-questions-6d20f552773e"> <em class="hh">你需要知道的50个Java合集面试问题</em> </a></p><p id="d97f" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 37。</em><a class="ae lt" rel="noopener" href="/edureka/java-string-pool-5b5b3b327bdf"><em class="hh">Java中的字符串池是什么概念？</em> </a></p><p id="e9f6" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 38。</em><a class="ae lt" rel="noopener" href="/edureka/difference-between-c-cpp-and-java-625c4e91fb95"><em class="hh">C、C++和Java有什么区别？</em> </a></p><p id="3035" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated">39。<a class="ae lt" rel="noopener" href="/edureka/palindrome-in-java-5d116eb8755a"><em class="hh">Java中的回文——如何检查一个数字或字符串？</em>T29】</a></p><p id="6106" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated">40。 <a class="ae lt" rel="noopener" href="/edureka/mvc-interview-questions-cd568f6d7c2e"> <em class="hh">你需要知道的顶级MVC面试问答</em> </a></p><p id="0306" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated">41。<a class="ae lt" rel="noopener" href="/edureka/applications-of-java-11e64f9588b0"><em class="hh">Java编程语言十大应用</em> </a></p><p id="6b7e" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 42。</em><a class="ae lt" rel="noopener" href="/edureka/deadlock-in-java-5d1e4f0338d5"><em class="hh">Java中的死锁</em> </a></p><p id="7323" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 43。</em><a class="ae lt" rel="noopener" href="/edureka/java-sqrt-method-59354a700571"><em class="hh">Java中的平方和平方根</em> </a></p><p id="89fd" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 44。</em><a class="ae lt" rel="noopener" href="/edureka/type-casting-in-java-ac4cd7e0bbe1"><em class="hh">Java中的类型转换</em> </a></p><p id="d224" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 45。</em><a class="ae lt" rel="noopener" href="/edureka/operators-in-java-fd05a7445c0a"><em class="hh">Java中的运算符及其类型</em> </a></p><p id="e302" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 46。</em><a class="ae lt" rel="noopener" href="/edureka/destructor-in-java-21cc46ed48fc"><em class="hh">Java中的析构函数</em> </a></p><p id="bfef" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 47。</em><a class="ae lt" rel="noopener" href="/edureka/binary-search-in-java-cf40e927a8d3"><em class="hh">Java中的二分搜索法</em> </a></p><p id="ff60" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 48。</em><a class="ae lt" rel="noopener" href="/edureka/mvc-architecture-in-java-a85952ae2684"><em class="hh">Java中的MVC架构</em> </a></p><p id="2bd2" class="il im lx in b io ip iq ir is it iu iv ly ix iy iz lz jb jc jd ma jf jg jh ji ha bi translated"><em class="hh"> 49。</em> <a class="ae lt" rel="noopener" href="/edureka/hibernate-interview-questions-78b45ec5cce8"> <em class="hh">冬眠面试问答</em> </a></p></blockquote></div><div class="ab cl mb mc go md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ha hb hc hd he"><p id="f0b9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="lx">原载于2019年9月13日</em><a class="ae lt" href="https://www.edureka.co/blog/solid-principles-in-java/" rel="noopener ugc nofollow" target="_blank"><em class="lx">https://www.edureka.co</em></a><em class="lx">。</em></p></div></div>    
</body>
</html>