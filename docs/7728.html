<html>
<head>
<title>UPDATE: This story is from 2018. Much has probably changed since then and IntersectionObserver is for the most part not the recommended method of lazy loading images.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更新:这个故事是2018年的。从那以后可能发生了很大的变化，IntersectionObserver在很大程度上不是延迟加载图像的推荐方法。</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/lazy-loading-images-intersectionobserver-8c5bff730920?source=collection_archive---------0-----------------------#2018-09-10">https://medium.com/walmartglobaltech/lazy-loading-images-intersectionobserver-8c5bff730920?source=collection_archive---------0-----------------------#2018-09-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/d9b1f5ad15acb4cd85216e8929e4d96b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZQ4RzptJR8LXaIlYa9K2iw.jpeg"/></div></div></figure><div class=""/><h1 id="8c74" class="iq ir hs bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">使用IntersectionObserver延迟加载图像</h1><p id="668f" class="pw-post-body-paragraph jo jp hs jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">对于现在的大多数网站来说，图片是网站性能的主要瓶颈。</p><p id="799d" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">尤其是对于电子商务网站，<strong class="jq ht">图像构成了页面内容的大部分，并且往往尺寸很大</strong>，通常每页在网络上总计达数兆字节的图像数据。</p><p id="be65" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">以<a class="ks kt ge" href="https://medium.com/u/c884135151a4?source=post_page-----8c5bff730920--------------------------------" rel="noopener" target="_blank">沃尔玛实验室</a>的<a class="ae kr" href="https://www.walmart.com/cp/home/4044" rel="noopener ugc nofollow" target="_blank">首页</a>为例:</p><figure class="kv kw kx ky fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ku"><img src="../Images/9b661314921a5234e89889ccbd82b307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9mEvgfEQjmrGIHJrCXx_gg.gif"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx"><a class="ae kr" href="https://www.walmart.com/cp/home/4044" rel="noopener ugc nofollow" target="_blank">https://www.walmart.com/cp/home/4044</a></figcaption></figure><p id="dceb" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">这是正在加载的图像数量的汇总:</p><figure class="kv kw kx ky fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ld"><img src="../Images/4b18f3c343615d6101054e0e3a94b948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnlDF8HN4uM1c-SK1QVcfA.png"/></div></div></figure><p id="a467" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">137张图片！网络上80%以上的数据是图像。😬</p><p id="879a" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">现在看一下网络请求瀑布的片段:</p><figure class="kv kw kx ky fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es le"><img src="../Images/7bd4f0710211c0a72356022136eab2ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVFCcnYL6j6M9kC1ZjV5nQ.png"/></div></div></figure><p id="9460" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">在我们的具体例子中，代码分割模块代码的加载要晚得多，因为它首先需要主包<code class="du lf lg lh li b">cp_ny.bundle</code>。然而，如果没有18个图像争夺带宽，主包可能会更快到达。</p><figure class="kv kw kx ky fd hj er es paragraph-image"><div class="er es lj"><img src="../Images/8bb1589d0595b2fed04d16d06c5542ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/1*e0QzMH82qIqBJ5NnigYPvg.gif"/></div><figcaption class="kz la et er es lb lc bd b be z dx">😵 <a class="ae kr" href="https://tenor.com/view/bruh-faint-gif-9862849" rel="noopener ugc nofollow" target="_blank">tenor.com</a> 😵</figcaption></figure><p id="3ff6" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">好吧好吧好吧。<strong class="jq ht">那么我们该如何解决这个问题呢？你不能真的“修复”它，但是你可以做很多事情来优化图片在你的网站上的加载方式。在许多不同类型的优化中，例如不同的格式、压缩、模糊动画、CDNs等。，我将介绍<strong class="jq ht">“惰性加载”</strong>。我将介绍如何使用React实现延迟加载的图像，但是只要您使用JavaScript，实现(本质上)是相同的。</strong></p><p id="dfca" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">以这个<em class="lk">超</em>简单反应<code class="du lf lg lh li b">Image</code>组件为例:</p><pre class="kv kw kx ky fd ll li lm ln aw lo bi"><span id="2b46" class="lp ir hs li b fi lq lr l ls lt">class Image extends PureComponent {<br/>  render() {<br/>    const { src } = this.props;<br/>    return &lt;img src={src} /&gt;;<br/>  }<br/>}</span></pre><p id="abeb" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">它所做的只是接受一个<code class="du lf lg lh li b">src</code> URL作为道具，并使用它来呈现一个HTML <code class="du lf lg lh li b">img</code>元素。<br/> <a class="ae kr" href="https://jsfiddle.net/parkjoon/Lvhq8fap/" rel="noopener ugc nofollow" target="_blank"> JSFiddle </a></p><figure class="kv kw kx ky fd hj er es paragraph-image"><div class="er es lu"><img src="../Images/0c922b7f5c17ea067f57e0900221caab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/1*ZNtMrN_pLCI37wYq41mQ8w.gif"/></div></figure><p id="b54a" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">下面是使这个图像组件延迟加载的基本步骤:<br/> <strong class="jq ht"> 1) </strong>最初不渲染图像源。<br/> <strong class="jq ht"> 2) </strong>设置图像与视口相交时的检测。<br/> <strong class="jq ht"> 3) </strong>当我们检测到图像将在视图中时渲染图像源。</p><figure class="kv kw kx ky fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lv"><img src="../Images/4a38522bbfdeaeecf7cf077897fa25b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2onutxDK9k2Hj4RIIKl1Lg.jpeg"/></div></div></figure><h2 id="4f88" class="lp ir hs bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">步骤1-最初不渲染任何图像</h2><pre class="kv kw kx ky fd ll li lm ln aw lo bi"><span id="c945" class="lp ir hs li b fi lq lr l ls lt">render() {<br/>  return &lt;img /&gt;;<br/>}</span></pre><h2 id="1780" class="lp ir hs bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">步骤2 —设置检测</h2><pre class="kv kw kx ky fd ll li lm ln aw lo bi"><span id="a54b" class="lp ir hs li b fi lq lr l ls lt">componentDidMount() {<br/>  this.observer = new IntersectionObserver(() =&gt; {<br/>    // Step 3<br/>  },<br/>  {<br/>    root: document.querySelector(".container")<br/>  });</span><span id="cda4" class="lp ir hs li b fi mj lr l ls lt">  this.observer.observe(this.element);<br/>}</span><span id="aa36" class="lp ir hs li b fi mj lr l ls lt">....</span><span id="7405" class="lp ir hs li b fi mj lr l ls lt">render() {<br/>  return &lt;img ref={el =&gt; this.element = el} /&gt;;<br/>}</span></pre><p id="0b3e" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated"><strong class="jq ht">我在这里做了什么？</strong> <br/> <strong class="jq ht"> 1) </strong>我给<code class="du lf lg lh li b">img</code>元素添加了一个<a class="ae kr" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank"> ref </a>，这样我们就可以稍后更新<code class="du lf lg lh li b">src</code> URL，而不会导致重新呈现。<br/> <strong class="jq ht"> 2) </strong>我创建了一个<code class="du lf lg lh li b">IntersectionObserver</code>的新实例(稍后解释)。<br/> <strong class="jq ht"> 3) </strong>我告诉观察者使用<code class="du lf lg lh li b">observe(this.element)</code>来“观察”我的图像元素。</p><p id="c811" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">什么是<code class="du lf lg lh li b">IntersectionObserver</code>？听起来确实如此。这里是MDN 的一个<a class="ae kr" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">快速总结:</a></p><blockquote class="mk ml mm"><p id="c6b4" class="jo jp lk jq b jr km jt ju jv kn jx jy mn ko kb kc mo kp kf kg mp kq kj kk kl ha bi translated">交叉点观察器API提供了一种异步观察目标元素与祖先元素或顶级文档的视口的交叉点变化的方法。</p></blockquote><p id="d517" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">乍一看，这似乎令人望而生畏，但他们实际上已经使API变得非常直观。在几个选项中传递了一个<code class="du lf lg lh li b">IntersectionObserver</code>的实例。我们用的是<code class="du lf lg lh li b">root</code>；这只是定义了我们将考虑的边界容器的DOM元素:我们想要检查我们的图像是否有交叉路径的容器。它默认为visible viewport，但是我在JSFiddle iframe中将它显式地设置为一个容器，因为有一个我稍后将解释的特性不是为在iframe中使用而设计的。</p><p id="99d2" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated"><code class="du lf lg lh li b">IntersectionObserver</code>是比<code class="du lf lg lh li b">onScroll</code> + <code class="du lf lg lh li b">getBoundingClientRect()</code>等传统方法更受欢迎的可见性检测方法，这是因为<strong class="jq ht">实际的检测实现并不在主线程上运行。</strong>然而，当一个交集被触发时，回调确实在主线程上运行，所以保持它的轻量级！</p><h2 id="b573" class="lp ir hs bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">步骤3-渲染图像！</h2><p id="b63e" class="pw-post-body-paragraph jo jp hs jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">现在我们需要为<code class="du lf lg lh li b">root</code>和<code class="du lf lg lh li b">target</code>元素之间的交集被触发时设置回调。在我们的例子中，它们分别是<code class="du lf lg lh li b">.container</code> div和<code class="du lf lg lh li b">this.element</code> ref。</p><pre class="kv kw kx ky fd ll li lm ln aw lo bi"><span id="e43b" class="lp ir hs li b fi lq lr l ls lt">....</span><span id="eac2" class="lp ir hs li b fi mj lr l ls lt">this.observer = new IntersectionObserver(<br/>  entries =&gt; {<br/>    entries.forEach(entry =&gt; {<br/>      const { isIntersecting } = entry;</span><span id="fc20" class="lp ir hs li b fi mj lr l ls lt">      if (isIntersecting) {<br/>        this.element.src = this.props.src;<br/>        this.observer = this.observer.disconnect();<br/>      }<br/>    });<br/>  },<br/>  {<br/>    root: document.querySelector(".container")<br/>  }<br/>);</span><span id="391d" class="lp ir hs li b fi mj lr l ls lt">....</span></pre><p id="95b5" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">当发生交集时，回调会返回一个<code class="du lf lg lh li b">entries</code>数组，这有点像触发交集的所有目标元素的快照。<code class="du lf lg lh li b">isIntersecting</code>表示交叉口的方向。如果目标正在向根元素移动，那就是<code class="du lf lg lh li b">true</code>。如果目标正在移出根元素，则为<code class="du lf lg lh li b">false</code>。</p><p id="c44b" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">因此，当我检测到图像元素与容器的底部边缘相交时，我手动设置图像<code class="du lf lg lh li b">src</code>并清理不再需要的观察者。</p><h2 id="084b" class="lp ir hs bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">(秘密)第4步——看结果，跳一支快乐的舞</h2><figure class="kv kw kx ky fd hj er es paragraph-image"><div class="er es lu"><img src="../Images/585d70eac680ea662982750b8950e5e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/1*p7zHF4T-im7-vE7IKCi6Hw.gif"/></div><figcaption class="kz la et er es lb lc bd b be z dx"><a class="ae kr" href="https://jsfiddle.net/parkjoon/sgz9rbnf/" rel="noopener ugc nofollow" target="_blank">JSFiddle</a></figcaption></figure><figure class="kv kw kx ky fd hj er es paragraph-image"><div class="er es mq"><img src="../Images/fc2797e6da82dadc0a8c7ed0ec6bfc90.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/1*zJUvG1ZAXQFTLHY96vM--Q.gif"/></div><figcaption class="kz la et er es lb lc bd b be z dx"><a class="ae kr" href="https://tenor.com/view/dancing-dance-dancing-baby-baby-toddler-gif-5478110" rel="noopener ugc nofollow" target="_blank">tenor.com</a></figcaption></figure><p id="8f6f" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated"><strong class="jq ht">等一下……</strong>你在结果中注意到什么了吗？<br/>让我为您加速滚动，节流网速:</p><figure class="kv kw kx ky fd hj er es paragraph-image"><div class="er es mr"><img src="../Images/233e05aecbf5d4627f361aa13d7f9ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/1*aDIQv84H82YKVT8PKi3YVw.gif"/></div><figcaption class="kz la et er es lb lc bd b be z dx">Throttled Network Speed</figcaption></figure><p id="c3ad" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">由于我们只在用户已经到达应该看到图像的位置时才加载图像，因此<strong class="jq ht">用户在下载</strong>之前不能向下滚动并看到图像。通常，这对于拥有快速互联网的台式电脑来说不是问题，但是现在很多消费者都在手机上冲浪，有时，他们会被3G或者更糟的东西卡住……EDGE。😱</p><p id="154d" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">谢天谢地，<code class="du lf lg lh li b">IntersectionObserver</code> API提供了增加或缩小根元素(我们的<code class="du lf lg lh li b">.container</code>元素)检测边界的能力。<br/>我们需要做的就是在我们放置选项的地方添加一行代码来指定一个根容器:</p><pre class="kv kw kx ky fd ll li lm ln aw lo bi"><span id="acd2" class="lp ir hs li b fi lq lr l ls lt">rootMargin: "0px 0px 200px 0px"</span></pre><p id="3972" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated"><code class="du lf lg lh li b">rootMargin</code>选项接受符合常规CSS边距规则的字符串。在我们的例子中，我们告诉它增加底部检测边界<code class="du lf lg lh li b">200px</code>。这意味着当根元素<em class="lk">加上</em> <code class="du lf lg lh li b">200px</code>的底部出现时(默认边距为<code class="du lf lg lh li b">0</code>)将触发交集回调。</p><figure class="kv kw kx ky fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ms"><img src="../Images/d7f0fbed5dbbfdc18d39c5727df91ad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0TpznTm4PPrD0kp5CQBsZA.gif"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx"><a class="ae kr" href="https://jsfiddle.net/parkjoon/ytfc7vh5/" rel="noopener ugc nofollow" target="_blank">JSFiddle</a></figcaption></figure><p id="2458" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">不错。因此，即使我们只滚动到第四个最后一行内容，图像也已经加载到了屏幕下方的<code class="du lf lg lh li b">200px</code>。</p><h2 id="5099" class="lp ir hs bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">等等。</h2><figure class="kv kw kx ky fd hj er es paragraph-image"><div class="er es mt"><img src="../Images/c760a7aa57522642836cf5b22712594b.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*VWU9wPYYoW-9Hc5l9-3DGQ.gif"/></div><figcaption class="kz la et er es lb lc bd b be z dx"><a class="ae kr" href="https://tenor.com/view/woah-whoa-wait-hold-on-hold-up-gif-9844131" rel="noopener ugc nofollow" target="_blank">tenor.com</a></figcaption></figure><p id="6b90" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">对于那些仔细检查gif的人来说，你会注意到当图像被加载时滚动条会跳跃。幸运的是，这很容易修复。问题是最初<code class="du lf lg lh li b">0</code>高度的图像元素现在跳到了<code class="du lf lg lh li b">300px</code>。您所需要做的就是通过给图像添加<code class="du lf lg lh li b">height={300}</code>属性来设置一个固定的高度。</p><p id="141a" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">那么，我们在家庭部登录页面<a class="ks kt ge" href="https://medium.com/u/c884135151a4?source=post_page-----8c5bff730920--------------------------------" rel="noopener" target="_blank">沃尔玛实验室</a>上看到了什么样的性能优势呢？根据网络速度、CDN可用性、页面上的图像数量、它们的相交规则等，性能优势<strong class="jq ht">变化很大</strong>。换句话说，你最好自己在应用程序中实现这一点，并找出实际的好处。</p><p id="6d8b" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">如果你仍然对我们在<a class="ks kt ge" href="https://medium.com/u/c884135151a4?source=post_page-----8c5bff730920--------------------------------" rel="noopener" target="_blank">沃尔玛实验室</a>看到的好处感到好奇，我们在预生产环境中进行的内部合成慢速3G测试显示，加载时间减少了<strong class="jq ht"> 32%，速度指数<strong class="jq ht">减少了</strong>22%，折叠次数</strong>减少了<strong class="jq ht"> 17%。</strong></p><p id="5b80" class="pw-post-body-paragraph jo jp hs jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl ha bi translated">感谢阅读！😊</p></div></div>    
</body>
</html>