<html>
<head>
<title>Master the JavaScript Interview: What is a Promise?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript面试:什么是承诺？</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261?source=collection_archive---------1-----------------------#2017-01-23">https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261?source=collection_archive---------1-----------------------#2017-01-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4a7314a030890840b15da647518a1f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*agGENodMcD6hhwIFdqGwrw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by Kabun (CC BY NC SA 2.0)</figcaption></figure><blockquote class="it iu iv"><p id="d1d4" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“掌握JavaScript面试”是一系列的帖子，旨在帮助候选人准备在申请中高级JavaScript职位时可能遇到的常见问题。这些是我在真实面试中经常用到的问题。</p></blockquote><h1 id="74e1" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">什么是承诺？</h1><p id="6299" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">承诺是一个可能在未来某个时间产生单个值的对象:一个已解决的值，或者一个未解决的原因(例如，发生了网络错误)。承诺可能处于三种状态之一:已履行、已拒绝或待定。Promise用户可以附加回调来处理实现的值或拒绝的原因。</p><p id="b000" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">承诺是急切的，这意味着一旦调用了承诺构造函数，承诺就会开始执行您交给它的任何任务。如果你需要偷懒，看看<a class="ae lb" href="https://github.com/Reactive-Extensions/RxJS" rel="noopener ugc nofollow" target="_blank">可观察的事物</a>或<a class="ae lb" href="https://github.com/rpominov/fun-task" rel="noopener ugc nofollow" target="_blank">任务</a>。</p><h1 id="b1f7" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">承诺的不完整历史</h1><p id="e56e" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">早在20世纪80年代，promises和futures(一种类似/相关的思想)的早期实现就开始出现在MultiLisp和Concurrent Prolog等语言中。单词“promise”的使用是由Barbara Liskov和Liuba Shrira在1988年创造的[1]。</p><p id="1ca9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">我第一次听说JavaScript中的承诺时，Node是全新的，社区正在讨论处理异步行为的最佳方式。社区试验了一段时间的承诺，但最终确定了节点标准错误优先回调。</p><p id="6f2b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">大约在同一时间，Dojo通过Deferred API添加了承诺。不断增长的兴趣和活动最终导致了新形成的Promises/一个旨在使各种承诺更具互操作性的规范。</p><p id="3243" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">jQuery的异步行为围绕承诺进行了重构。jQuery的promise支持与Dojo的Deferred有显著的相似之处，并且由于jQuery的广泛流行，它很快成为JavaScript中最常用的promise实现——有一段时间。然而，<a class="ae lb" href="https://blog.domenic.me/youre-missing-the-point-of-promises/" rel="noopener ugc nofollow" target="_blank">它不支持双通道(履行/拒绝)链接行为&amp;异常管理</a>，人们指望它在承诺之上构建工具。</p><p id="feae" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">尽管存在这些弱点，jQuery还是正式让JavaScript promises成为主流，更好的独立promise库如Q、When和Bluebird变得非常流行。jQuery实现的不兼容性激发了promise规范中一些重要的澄清，该规范被重写并更名为<a class="ae lb" href="https://promisesaplus.com/" rel="noopener ugc nofollow" target="_blank"> Promises/A+规范</a>。</p><p id="8ba3" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">ES6带来了一个符合Promises/A+的<code class="du lc ld le lf b">Promise</code> global，一些非常重要的API建立在新标准Promise支持之上:特别是<a class="ae lb" href="https://fetch.spec.whatwg.org/" rel="noopener ugc nofollow" target="_blank"> WHATWG Fetch </a>规范和<a class="ae lb" href="https://tc39.github.io/ecmascript-asyncawait/" rel="noopener ugc nofollow" target="_blank"> Async Functions </a>标准(在撰写本文时是第3阶段草案)。</p><p id="3cd0" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">这里描述的承诺是那些与承诺/A+规范兼容的承诺，重点是ECMAScript标准<code class="du lc ld le lf b">Promise</code>的实现。</p><h1 id="443c" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">承诺是如何运作的</h1><p id="5060" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">承诺是可以从异步函数同步返回的对象。它将处于三种可能状态之一:</p><ul class=""><li id="a7d1" class="lg lh hh iz b ja jb je jf kv li kx lj kz lk ju ll lm ln lo bi translated"><strong class="iz hi">应验了:</strong> <code class="du lc ld le lf b">onFulfilled()</code>会被召唤(如<code class="du lc ld le lf b">resolve()</code>会被召唤)</li><li id="aa52" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><strong class="iz hi">被拒绝:</strong> <code class="du lc ld le lf b">onRejected()</code>将被调用(如<code class="du lc ld le lf b">reject()</code>被调用)</li><li id="ebc1" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><strong class="iz hi">待定:</strong>尚未履行或拒绝</li></ul><p id="9508" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">如果一个承诺不是悬而未决的(它已经被解决或拒绝),它就是<strong class="iz hi">解决的</strong>。有时人们用<em class="iy">已解决</em>和<em class="iy">已解决</em>来表示同一个意思:<em class="iy">未决</em>。</p><p id="d743" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">承诺一旦达成，就不能再兑现。再次调用<code class="du lc ld le lf b">resolve()</code>或<code class="du lc ld le lf b">reject()</code>不会有任何效果。约定承诺的不变性是一个重要特征。</p><p id="1dfd" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">原生JavaScript承诺不公开承诺状态。相反，你应该把承诺当成一个黑盒。只有负责创建承诺的功能才知道承诺状态，或者有权解决或拒绝。</p><p id="5250" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">下面是一个返回承诺的函数，该承诺将在指定的时间延迟后解决:</p><figure class="lu lv lw lx fd ii"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae lb" href="http://codepen.io/ericelliott/pen/EZWyaY?editors=0012" rel="noopener ugc nofollow" target="_blank">wait — promise example on CodePen</a></figcaption></figure><p id="9525" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">我们的<code class="du lc ld le lf b">wait(3000)</code>调用会等待3000ms (3秒)，然后登录<code class="du lc ld le lf b">'Hello!'</code>。所有规范兼容的承诺都定义了一个<code class="du lc ld le lf b">.then()</code>方法，您可以用它来传递处理程序，这些处理程序可以接受解析或拒绝的值。</p><p id="1e73" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">ES6 promise构造函数接受一个函数。该函数有两个参数，<code class="du lc ld le lf b">resolve()</code>和<code class="du lc ld le lf b">reject()</code>。在上面的例子中，我们只使用了<code class="du lc ld le lf b">resolve()</code>，所以我把<code class="du lc ld le lf b">reject()</code>从参数列表中去掉了。然后我们调用<code class="du lc ld le lf b">setTimeout()</code>来创建延迟，并在完成时调用<code class="du lc ld le lf b">resolve()</code>。</p><p id="2ffa" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">你可以选择带值的<code class="du lc ld le lf b">resolve()</code>或<code class="du lc ld le lf b">reject()</code>，这些值将被传递给带有<code class="du lc ld le lf b">.then()</code>的回调函数。</p><p id="9b20" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">当我用一个值<code class="du lc ld le lf b">reject()</code>时，我总是传递一个<code class="du lc ld le lf b">Error</code>对象。一般来说，我希望有两种可能的解决状态:正常的快乐路径，或者例外——任何阻止正常快乐路径发生的事情。传递一个<code class="du lc ld le lf b">Error</code>对象可以使这一点显式化。</p><h1 id="16e4" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">重要的承诺规则</h1><p id="e57a" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">承诺的标准是由<a class="ae lb" href="https://promisesaplus.com/implementations" rel="noopener ugc nofollow" target="_blank">承诺/A+规范</a>社区定义的。有许多实现符合该标准，包括JavaScript标准ECMAScript promises。</p><p id="7caa" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">遵循规范的承诺必须遵循一套特定的规则:</p><ul class=""><li id="5658" class="lg lh hh iz b ja jb je jf kv li kx lj kz lk ju ll lm ln lo bi translated">承诺或“thenable”是一个提供符合标准的<code class="du lc ld le lf b">.then()</code>方法的对象。</li><li id="06e7" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated">待定承诺可能会转变为已履行或已拒绝状态。</li><li id="1e2d" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated">一个被实现或拒绝的承诺是确定的，不能转换到任何其他状态。</li><li id="8551" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated">承诺一旦谈妥，就必须有一个值(可能是<code class="du lc ld le lf b">undefined</code>)。这一价值不能改变。</li></ul><p id="e5c5" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">这个语境中的变化指的是同一性(<code class="du lc ld le lf b">===</code>)比较。一个对象可能被用作实现的值，并且对象属性可能发生变化。</p><p id="d186" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">每个承诺必须提供一个带有以下签名的<code class="du lc ld le lf b">.then()</code>方法:</p><pre class="lu lv lw lx fd ma lf mb mc aw md bi"><span id="794a" class="me jw hh lf b fi mf mg l mh mi">promise.then(<br/>  onFulfilled?: Function,<br/>  onRejected?: Function<br/>) =&gt; Promise</span></pre><p id="7bee" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated"><code class="du lc ld le lf b">.then()</code>方法必须符合以下规则:</p><ul class=""><li id="63f6" class="lg lh hh iz b ja jb je jf kv li kx lj kz lk ju ll lm ln lo bi translated"><code class="du lc ld le lf b">onFulfilled()</code>和<code class="du lc ld le lf b">onRejected()</code>都是可选的。</li><li id="f19b" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated">如果提供的参数不是函数，则必须忽略它们。</li><li id="77b5" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><code class="du lc ld le lf b">onFulfilled()</code>将在承诺兑现后调用，以承诺的值作为第一个参数。</li><li id="6965" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><code class="du lc ld le lf b">onRejected()</code>承诺被拒绝后会被调用，拒绝原因作为第一个参数。原因可能是任何有效的JavaScript值，但是因为拒绝本质上等同于异常，所以我建议使用错误对象。</li><li id="44c7" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><code class="du lc ld le lf b">onFulfilled()</code>和<code class="du lc ld le lf b">onRejected()</code>都不能被调用一次以上。</li><li id="65aa" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><code class="du lc ld le lf b">.then()</code>同一承诺可能被多次叫停。换句话说，承诺可以用来聚集回调。</li><li id="3a78" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><code class="du lc ld le lf b">.then()</code>必须返回新的承诺，<code class="du lc ld le lf b">promise2</code>。</li><li id="b394" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated">如果<code class="du lc ld le lf b">onFulfilled()</code>或<code class="du lc ld le lf b">onRejected()</code>返回值<code class="du lc ld le lf b">x</code>，且<code class="du lc ld le lf b">x</code>为承诺，<code class="du lc ld le lf b">promise2</code>将锁定<code class="du lc ld le lf b">x</code>(假设状态和值相同)。否则，<code class="du lc ld le lf b">promise2</code>将用<code class="du lc ld le lf b">x</code>的值来完成。</li><li id="e407" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated">如果<code class="du lc ld le lf b">onFulfilled</code>或<code class="du lc ld le lf b">onRejected</code>中有一个抛出异常<code class="du lc ld le lf b">e</code>，则<code class="du lc ld le lf b">promise2</code>必须被拒绝，原因是<code class="du lc ld le lf b">e</code>。</li><li id="b15e" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated">如果<code class="du lc ld le lf b">onFulfilled</code>不是一个函数并且<code class="du lc ld le lf b">promise1</code>被满足，<code class="du lc ld le lf b">promise2</code>必须用与<code class="du lc ld le lf b">promise1</code>相同的值来满足。</li><li id="008d" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated">如果<code class="du lc ld le lf b">onRejected</code>不是功能，且<code class="du lc ld le lf b">promise1</code>被拒绝，则<code class="du lc ld le lf b">promise2</code>必须被拒绝，原因与<code class="du lc ld le lf b">promise1</code>相同。</li></ul><h1 id="a7ba" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">承诺链</h1><p id="92eb" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">因为<code class="du lc ld le lf b">.then()</code>总是返回一个新的承诺，所以可以通过精确控制错误处理的方式和位置来连锁承诺。承诺允许你模仿普通同步代码的<code class="du lc ld le lf b">try</code> / <code class="du lc ld le lf b">catch</code>行为。</p><p id="df0b" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">像同步代码一样，链接将产生一个串行运行的序列。换句话说，您可以:</p><pre class="lu lv lw lx fd ma lf mb mc aw md bi"><span id="cb11" class="me jw hh lf b fi mf mg l mh mi">fetch(url)<br/>  .then(process)<br/>  .then(save)<br/>  .catch(handleErrors)<br/>;</span></pre><p id="f5dd" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">假设<code class="du lc ld le lf b">fetch()</code>、<code class="du lc ld le lf b">process()</code>、<code class="du lc ld le lf b">save()</code>各函数返回承诺，<code class="du lc ld le lf b">process()</code>将等待<code class="du lc ld le lf b">fetch()</code>完成后再启动，<code class="du lc ld le lf b">save()</code>将等待<code class="du lc ld le lf b">process()</code>完成后再启动。<code class="du lc ld le lf b">handleErrors()</code>只有在先前的承诺被拒绝时才会运行。</p><p id="939a" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">这是一个复杂的承诺链的例子，有多次拒绝:</p><figure class="lu lv lw lx fd ii"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae lb" href="http://codepen.io/ericelliott/pen/MJmqgN?editors=0012" rel="noopener ugc nofollow" target="_blank">Promise chaining behavior example on CodePen</a></figcaption></figure><h1 id="fb52" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">错误处理</h1><p id="3dcb" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">请注意，承诺既有成功处理程序，也有错误处理程序，这样做的代码非常常见:</p><pre class="lu lv lw lx fd ma lf mb mc aw md bi"><span id="cb20" class="me jw hh lf b fi mf mg l mh mi">save().then(<br/>  handleSuccess,<br/>  handleError<br/>);</span></pre><p id="9fe1" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">但是如果<code class="du lc ld le lf b">handleSuccess()</code>抛出一个错误会怎么样呢？从<code class="du lc ld le lf b">.then()</code>返回的承诺将被拒绝，但是没有任何东西可以捕捉到拒绝——这意味着你的应用程序中的一个错误被忽略了。哎呀！</p><p id="5449" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">出于这个原因，有些人认为上面的代码是反模式的，并建议使用下面的代码:</p><pre class="lu lv lw lx fd ma lf mb mc aw md bi"><span id="a7db" class="me jw hh lf b fi mf mg l mh mi">save()<br/>  .then(handleSuccess)<br/>  .catch(handleError)<br/>;</span></pre><p id="b098" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">差别很微妙，但很重要。在第一个例子中，源于<code class="du lc ld le lf b">save()</code>操作的错误将被捕获，但源于<code class="du lc ld le lf b">handleSuccess()</code>函数的错误将被接受。</p><figure class="lu lv lw lx fd ii er es paragraph-image"><div class="er es mj"><img src="../Images/935df4823dd555b5efd97dfad161f2e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*5Z_vNz6xHn9mjTgvrqa2Aw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Without .catch(), an error in the success handler is uncaught.</figcaption></figure><p id="a207" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">在第二个例子中，<code class="du lc ld le lf b">.catch()</code>将处理来自<code class="du lc ld le lf b">save()</code>或<code class="du lc ld le lf b">handleSuccess()</code>的拒绝。</p><figure class="lu lv lw lx fd ii er es paragraph-image"><div class="er es mj"><img src="../Images/f95317f7d54229a49fa11c68ebec1f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*vRaV9sYpYKdxBj3Ld7KM1Q.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">With .catch(), both error sources are handled. (<a class="ae lb" href="http://stackoverflow.com/questions/24662289/when-is-thensuccess-fail-considered-an-antipattern-for-promises" rel="noopener ugc nofollow" target="_blank">diagram source</a>)</figcaption></figure><p id="1ca8" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">当然，<code class="du lc ld le lf b">save()</code>错误可能是网络错误，而<code class="du lc ld le lf b">handleSuccess()</code>错误可能是因为开发人员忘记处理特定的状态代码。如果你想用不同的方式处理它们呢？您可以选择同时处理这两种情况:</p><pre class="lu lv lw lx fd ma lf mb mc aw md bi"><span id="0da5" class="me jw hh lf b fi mf mg l mh mi">save()<br/>  .then(<br/>    handleSuccess,<br/>    handleNetworkError<br/>  )<br/>  .catch(handleProgrammerError)<br/>;</span></pre><p id="12e5" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">无论你喜欢什么，我建议用一个<code class="du lc ld le lf b">.catch()</code>结束所有的承诺链。值得重复的是:</p><blockquote class="mk"><p id="a0d6" class="ml mm hh bd mn mo mp mq mr ms mt ju dx translated">我建议用一个<code class="du lc ld le lf b">.catch()</code>结束所有的承诺链。</p></blockquote><h1 id="b713" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg mu ki kj kk mv km kn ko mw kq kr ks bi translated">如何取消承诺？</h1><p id="04bf" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">new promise用户经常想知道的第一件事是如何取消一个承诺。这里有个想法:以“取消”为理由拒绝承诺就好。如果您需要以不同于“正常”错误的方式处理它，请在错误处理程序中进行分支。</p><p id="e9eb" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">以下是人们在取消承诺时会犯的一些常见错误:</p><h2 id="9fe2" class="me jw hh bd jx mx my mz kb na nb nc kf kv nd ne kj kx nf ng kn kz nh ni kr nj bi translated">添加中。取消承诺</h2><p id="f2fd" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">添加<code class="du lc ld le lf b">.cancel()</code>使承诺变得不标准，但也违反了承诺的另一条规则:只有创建承诺的函数才应该能够解决、拒绝或取消承诺。公开它打破了这种封装，并鼓励人们编写代码，在不应该知道它的地方操纵承诺。避免意大利面和失信。</p><h2 id="0a7a" class="me jw hh bd jx mx my mz kb na nb nc kf kv nd ne kj kx nf ng kn kz nh ni kr nj bi translated">忘记打扫卫生</h2><p id="a995" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">一些聪明人已经发现有一种方法可以使用<code class="du lc ld le lf b">Promise.race()</code>作为取消机制。这样做的问题是取消控制来自创建承诺的函数，这是您可以进行适当清理活动的唯一地方，例如清除超时或通过清除对数据的引用来释放内存，等等...</p><h2 id="b6ea" class="me jw hh bd jx mx my mz kb na nb nc kf kv nd ne kj kx nf ng kn kz nh ni kr nj bi translated">忘记处理被拒绝的取消承诺</h2><p id="435d" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">你知道吗，当你忘记处理拒绝承诺时，Chrome会在整个控制台上抛出警告信息。哎呀！</p><h2 id="13ab" class="me jw hh bd jx mx my mz kb na nb nc kf kv nd ne kj kx nf ng kn kz nh ni kr nj bi translated">过于复杂</h2><p id="89c6" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated"><a class="ae lb" href="https://github.com/tc39/proposal-cancelable-promises" rel="noopener ugc nofollow" target="_blank">撤回的TC39取消提案</a>提出了单独的取消消息传递渠道。它还使用了一个叫做注销令牌的新概念。在我看来，这个解决方案会大大扩充promise规范，并且它提供的唯一不直接支持推测的特性是拒绝和取消的分离，在我看来，这并不是一开始就必须的。</p><p id="129c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">您是否希望根据是否有例外或取消来进行切换？是的，绝对的。那是诺言的工作吗？在我看来，不，不是。</p><h2 id="eb26" class="me jw hh bd jx mx my mz kb na nb nc kf kv nd ne kj kx nf ng kn kz nh ni kr nj bi translated">重新思考承诺取消</h2><p id="3058" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">一般来说，我会传递承诺创建时确定如何解决/拒绝/取消所需的所有信息。那样的话，承诺就不需要<code class="du lc ld le lf b">.cancel()</code>方法了。你可能想知道你怎么可能知道你是否会在承诺创建时取消。</p><blockquote class="it iu iv"><p id="cf26" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">“如果我还不知道是否要取消，当我创建承诺时，我怎么知道要传递什么？”</p></blockquote><p id="1481" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">要是有某种物体能代表未来的潜在价值就好了……<em class="iy">哦，等等。</em></p><p id="bba6" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">我们传入的表示是否取消的值本身就是一个承诺。这看起来可能是这样的:</p><figure class="lu lv lw lx fd ii"><div class="bz dy l di"><div class="ly lz l"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae lb" href="http://codepen.io/ericelliott/pen/MJpewL?editors=0012" rel="noopener ugc nofollow" target="_blank">Cancellable wait — try it on CodePen</a></figcaption></figure><p id="1669" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">我们使用默认参数赋值来告诉它默认情况下不要取消。这使得<code class="du lc ld le lf b">cancel</code>参数可以方便地选择。然后，我们像以前一样设置超时，但这次我们捕获超时的id，以便我们可以在以后清除它。</p><p id="e48f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">我们使用<code class="du lc ld le lf b">cancel.then()</code>方法来处理取消和资源清理。只有在承诺有机会解决之前被取消，才会运行。如果你取消得太晚，你已经错过了机会。那列火车已经离开车站。</p><blockquote class="it iu iv"><p id="073d" class="iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">注意:你可能想知道<code class="du lc ld le lf b">noop()</code>函数是干什么用的。noop这个词代表no-op，意思是一个什么也不做的函数。没有它，V8会抛出警告:<code class="du lc ld le lf b">UnhandledPromiseRejectionWarning: Unhandled promise rejection</code>。这是一个好主意，<strong class="iz hi">总是处理承诺拒绝，</strong>即使你的处理者是一个<code class="du lc ld le lf b">noop()</code>。</p></blockquote><h2 id="5f35" class="me jw hh bd jx mx my mz kb na nb nc kf kv nd ne kj kx nf ng kn kz nh ni kr nj bi translated">抽象承诺取消</h2><p id="5a2a" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">这对于一个<code class="du lc ld le lf b">wait()</code>定时器来说很好，但是我们可以进一步抽象这个想法来封装你必须记住的一切:</p><ol class=""><li id="d203" class="lg lh hh iz b ja jb je jf kv li kx lj kz lk ju nk lm ln lo bi translated">默认情况下拒绝取消承诺——如果没有传递取消承诺，我们不想取消或抛出错误。</li><li id="190a" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju nk lm ln lo bi translated">当您拒绝取消时，请记住执行清理。</li><li id="b151" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju nk lm ln lo bi translated">记住<code class="du lc ld le lf b">onCancel</code>清理本身可能会抛出一个错误，这个错误也需要处理。(注意，在上面的等待示例中省略了错误处理—这很容易忘记！)</li></ol><p id="3244" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">让我们创建一个可取消的承诺实用程序，您可以用它来包装任何承诺。例如，为了处理网络请求等，签名将如下所示:</p><pre class="lu lv lw lx fd ma lf mb mc aw md bi"><span id="ecec" class="me jw hh lf b fi mf mg l mh mi">speculation(fn: SpecFunction, shouldCancel: Promise) =&gt; Promise</span></pre><p id="e984" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">SpecFunction就像您将传递到<code class="du lc ld le lf b">Promise</code>构造函数中的函数，只有一个例外——它需要一个<code class="du lc ld le lf b">onCancel()</code>处理程序:</p><pre class="lu lv lw lx fd ma lf mb mc aw md bi"><span id="055b" class="me jw hh lf b fi mf mg l mh mi">SpecFunction(resolve: Function, reject: Function, onCancel: Function) =&gt; Void</span></pre><figure class="lu lv lw lx fd ii"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="9736" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">注意，这个例子只是一个说明，给你它是如何工作的要点。还有一些你需要考虑的边缘情况。例如，在这个版本中，如果您取消已经结算的承诺，将会调用<code class="du lc ld le lf b">handleCancel</code>。</p><p id="0528" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">我已经实现了一个维护的产品版本，边缘案例作为开源库，<a class="ae lb" href="https://github.com/ericelliott/speculation" rel="noopener ugc nofollow" target="_blank">推测</a>。</p><p id="9e6d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">让我们使用改进的库抽象来重写以前的可取消的<code class="du lc ld le lf b">wait()</code>实用程序。首次安装推测:</p><pre class="lu lv lw lx fd ma lf mb mc aw md bi"><span id="edb1" class="me jw hh lf b fi mf mg l mh mi">npm install --save speculation</span></pre><p id="3892" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">现在您可以导入并使用它:</p><figure class="lu lv lw lx fd ii"><div class="bz dy l di"><div class="ly lz l"/></div></figure><p id="f07d" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">这稍微简化了一些事情，因为你不必担心<code class="du lc ld le lf b">noop()</code>，在你的<code class="du lc ld le lf b">onCancel()</code>，函数或者其他边缘情况下捕捉错误。那些细节已经被<code class="du lc ld le lf b">speculation()</code>抽象掉了。检查一下，并在实际项目中随意使用。</p><h1 id="3d93" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">原生JS承诺的额外内容</h1><p id="a0cd" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">原生<code class="du lc ld le lf b">Promise</code>对象有一些您可能感兴趣的额外内容:</p><ul class=""><li id="809f" class="lg lh hh iz b ja jb je jf kv li kx lj kz lk ju ll lm ln lo bi translated">返回被拒绝的承诺。</li><li id="3b71" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><code class="du lc ld le lf b">Promise.resolve()</code>返回已解决的承诺。</li><li id="aba9" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><code class="du lc ld le lf b">Promise.race()</code>接受一个数组(或任何iterable)并返回一个承诺，该承诺以iterable中第一个解析的承诺的值进行解析，或者以第一个拒绝的承诺的原因进行拒绝。</li><li id="449c" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><code class="du lc ld le lf b">Promise.all()</code>接受一个数组(或任何可迭代的)并返回一个承诺，当<em class="iy">可迭代的参数中的所有承诺</em>都已解决时，该承诺将解决，或以第一个传递的承诺拒绝的原因拒绝。</li></ul><h1 id="4082" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论</h1><p id="a978" class="pw-post-body-paragraph iw ix hh iz b ja kt jc jd je ku jg jh kv kw jk jl kx ky jo jp kz la js jt ju ha bi translated">承诺已经成为JavaScript中几个习惯用法不可或缺的一部分，包括用于大多数现代ajax请求的WHATWG Fetch标准和用于使异步代码看起来同步的Async Functions标准。</p><p id="d6cf" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">在撰写本文时，异步函数还处于第三阶段，但是我预测它们将很快成为JavaScript中非常流行、非常常用的异步编程解决方案——这意味着在不久的将来，学会珍惜承诺对JavaScript开发人员来说将变得更加重要。</p><p id="158c" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">例如，如果您使用redux，我建议您查看一下<a class="ae lb" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>:一个用于管理Redux副作用的库，它依赖于整个文档中的异步函数。</p><p id="351f" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">我希望即使是有经验的promise用户，在看完这篇文章后，也能更好地理解什么是承诺以及它们是如何工作的，以及如何更好地使用它们。</p><h2 id="16b9" class="me jw hh bd jx mx my mz kb na nb nc kf kv nd ne kj kx nf ng kn kz nh ni kr nj bi translated">探索该系列</h2><ul class=""><li id="b3c2" class="lg lh hh iz b ja kt je ku kv nl kx nm kz nn ju ll lm ln lo bi translated"><a class="ae lb" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36#.ecfskj935">什么是闭包？</a></li><li id="a716" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><a class="ae lb" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9#.h96dymht1">类和原型继承有什么区别？</a></li><li id="5846" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><a class="ae lb" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976#.4256pjcfq">什么是纯函数？</a></li><li id="9469" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><a class="ae lb" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0#.i84zm53fb">什么是函数构成？</a></li><li id="e45a" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><a class="ae lb" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0#.jddz30xy3">什么是函数式编程？</a></li><li id="415f" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><a class="ae lb" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261#.aa7ubggsy">什么是承诺？</a></li><li id="1323" class="lg lh hh iz b ja lp je lq kv lr kx ls kz lt ju ll lm ln lo bi translated"><a class="ae lb" rel="noopener" href="/javascript-scene/master-the-javascript-interview-soft-skills-a8a5fb02c466">软技能</a></li></ul></div><div class="ab cl no np go nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ha hb hc hd he"><ol class=""><li id="6ad4" class="lg lh hh iz b ja jb je jf kv li kx lj kz lk ju nk lm ln lo bi translated"><em class="iy">芭芭拉·利斯科夫；柳巴·施里拉(1988年)。“Promises:分布式系统中高效异步过程调用的语言支持”。SIGPLAN '88程序设计语言设计和实现会议录:美国乔治亚州亚特兰大，第260-267页。ISBN 0–89791–269–1，由ACM出版。也发表在ACM SIGPLAN Notices，第23卷，第7期，1988年7月。</em></li></ol></div><div class="ab cl no np go nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ha hb hc hd he"><figure class="lu lv lw lx fd ii er es paragraph-image"><a href="https://ericelliottjs.com/premium-content/lesson-pure-functions"><div class="er es nv"><img src="../Images/649c1c875d8140aa42e9e3d9ffedf8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgRYDo68_u8KgIhnlZffcg.png"/></div></a><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae lb" href="https://ericelliottjs.com/premium-content/lesson-pure-functions" rel="noopener ugc nofollow" target="_blank">Start your free lesson on EricElliottJS.com</a></figcaption></figure><p id="d435" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated"><strong class="iz hi"> <em class="iy">埃里克·艾略特</em> </strong> <em class="iy">是一位科技产品和平台顾问，《T5】 <a class="ae lb" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="iy">【作曲软件】</em></a><em class="iy"/><a class="ae lb" href="https://ericelliottjs.com" rel="noopener ugc nofollow" target="_blank"><em class="iy">【EricElliottJS.com】</em></a><em class="iy"/><a class="ae lb" href="https://devanywhere.io" rel="noopener ugc nofollow" target="_blank"><em class="iy">devanywhere . io</em></a><em class="iy">的联合创始人，以及dev团队导师。他曾为Adobe Systems、</em> <strong class="iz hi"> <em class="iy">、Zumba Fitness、</em> </strong> <em class="iy"> </em> <strong class="iz hi"> <em class="iy">【华尔街日报、</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【ESPN、</em></strong><em class="iy"/><strong class="iz hi"><em class="iy">【BBC】</em></strong><em class="iy">等顶级录音艺人和包括</em> <strong class="iz hi"> <em class="iy"> Usher、【Metallica】</em></strong></em></p><p id="16e9" class="pw-post-body-paragraph iw ix hh iz b ja jb jc jd je jf jg jh kv jj jk jl kx jn jo jp kz jr js jt ju ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>