<html>
<head>
<title>The Evolution of Electrode Archetype</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">电极原型的演变</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/the-evolution-of-electrode-archetype-d61a5dcc90c9?source=collection_archive---------3-----------------------#2017-09-13">https://medium.com/walmartglobaltech/the-evolution-of-electrode-archetype-d61a5dcc90c9?source=collection_archive---------3-----------------------#2017-09-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="6e75" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="6d04" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi ka translated">使用来自<a class="kk kl ge" href="https://medium.com/u/c884135151a4?source=post_page-----d61a5dcc90c9--------------------------------" rel="noopener" target="_blank"> @WalmartLabs </a>的<a class="ae kj" href="http://www.electrode.io/" rel="noopener ugc nofollow" target="_blank">电极平台</a>，我们引入了一个名为<a class="ae kj" href="https://github.com/electrode-io/electrode/blob/cd8e1fb94eac2fbc080bdc31d0fba73e90aa34b2/docs/overview/what-are-archetypes.md" rel="noopener ugc nofollow" target="_blank">原型</a>的新概念，它在平台中发挥着重要作用。对于尝试过电极的人来说，你可能对原型很熟悉。原型是在拥有数百名开发人员的组织中提高开发人员生产率的需求的结果。在这篇文章中，我将讨论它们从开始，概念验证，过去的迭代，到当前版本，以及未来的发展。</p></div><div class="ab cl km kn go ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ha hb hc hd he"><h1 id="bd74" class="ie if hh bd ig ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb bi translated">初始和概念验证</h1><p id="d90f" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">什么是电极原型？它是一对npm模块，包含典型的标准内容，如配置、依赖关系以及用于开发应用程序或模块的工具和脚本。应用程序将原型作为依赖项来使用。详情请见我们的文档<a class="ae kj" href="https://github.com/electrode-io/electrode/blob/0d7942ac91798cc7b48563e6c5cb67757c294bbc/docs/chapter1/intermediate/app-archetype/what-are-archetypes.md" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="b0a9" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">我们想要解决的最初问题是快速地让团队加入并支持我们的平台。通常情况下，生成器会创建一个具有标准设置的基本应用程序，但是我们如何将更新和修复传播到已建立的应用程序呢？</p><p id="c126" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">我们通过创建一个名为bolt的工具开始了一项实验，该工具包含一组针对<code class="du ld le lf lg b">linting</code>、<code class="du ld le lf lg b">transpiling</code>、<code class="du ld le lf lg b">bundling</code>和<code class="du ld le lf lg b">testing</code>的常见任务。回购现在已被弃用，但在这里仍然可用<a class="ae kj" href="https://github.com/walmartlabs/bolt" rel="noopener ugc nofollow" target="_blank"/>。结果是令人鼓舞的，并有助于基于原型<code class="du ld le lf lg b">npm scripts</code>的开始。</p></div><div class="ab cl km kn go ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ha hb hc hd he"><h1 id="356f" class="ie if hh bd ig ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb bi translated">构建器迭代</h1><p id="52de" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们喜欢使用<code class="du ld le lf lg b">npm scripts</code>来构建。它们简单且容易获得。我们希望在我们的构建中利用它们，所以我们将它们作为我们最初原型的基础。</p><p id="1213" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">强大的为我们创造了一个名为<a class="ae kj" href="https://github.com/FormidableLabs/builder" rel="noopener ugc nofollow" target="_blank"> builder </a>的工具。它从原型和应用程序加载<code class="du ld le lf lg b">npm scripts</code>，并允许您用<code class="du ld le lf lg b"><em class="lh">builder run</em></code>调用它们。</p><p id="9985" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">我们带着建造者的原型踏上了土地。当我们解决遇到的问题时，这个工具随着原型概念一起改进和成熟。有许多小事情，但最大的问题与<code class="du ld le lf lg b">node_modules</code>的依赖有关。</p><h2 id="34c4" class="li if hh bd ig lj lk ll ik lm ln lo io jn lp lq is jr lr ls iw jv lt lu ja lv bi translated">依赖关系与开发依赖关系</h2><p id="f1e4" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们希望像<code class="du ld le lf lg b">babel</code>、<code class="du ld le lf lg b">webpack</code>、<code class="du ld le lf lg b">karma</code>等依赖项成为应用程序的<code class="du ld le lf lg b">devDependencies</code>，因此它应该消费我们的原型。</p><p id="63ff" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">好吧，与此同时，有些东西我们想在生产中提供给应用程序，所以我们也需要原型在应用程序的<code class="du ld le lf lg b">dependencies</code>中。</p><p id="ca07" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">所以我们把原型分成两个模块。一个主文件和另一个带有<code class="du ld le lf lg b">-dev</code>后缀的文件，这两个文件只用于引入依赖关系，所以它主要只包含一个<code class="du ld le lf lg b">package.json</code>文件。双模块的消耗如下:</p><figure class="lx ly lz ma fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es lw"><img src="../Images/1fecef406ccf3414b7fa6ac68a588af3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k1md2YlTS4qHzIHpIG4_-A.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Loading the dual archetypes in our getting-started sample app.</figcaption></figure><h2 id="8cf8" class="li if hh bd ig lj lk ll ik lm ln lo io jn lp lq is jr lr ls iw jv lt lu ja lv bi translated">node_modules依赖树</h2><p id="53de" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们遇到的最大问题大多与<code class="du ld le lf lg b"><em class="lh">npm</em></code>安装的模块的不确定嵌套有关。我们无法让它与<code class="du ld le lf lg b">npm@2</code>一起工作。幸运的是，带有模块扁平化的<code class="du ld le lf lg b">npm@3</code>已经可用，我们改用它。</p><p id="bc8e" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated"><code class="du ld le lf lg b">npm@3</code>的扁平化将模块提升到依赖关系树中尽可能高的位置，但是如果另一个模块依赖于同一事物的不同版本，我们的原型的依赖关系可能不会得到提升。</p><p id="62d3" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">举个例子，如果我们的原型需要<code class="du ld le lf lg b">foo@6</code>，但是应用程序需要<code class="du ld le lf lg b">bar</code>来引入<code class="du ld le lf lg b">foo@5</code>，那么我们可能会在<code class="du ld le lf lg b">node_modules</code>的顶层得到<code class="du ld le lf lg b">foo@5</code>，而<code class="du ld le lf lg b">foo@6</code>嵌套在dev原型中。如果我们从主原型中<code class="du ld le lf lg b">require</code> <code class="du ld le lf lg b">foo</code>，那么它就会得到<code class="du ld le lf lg b">foo@5</code>——不完全是我们想要的。</p><figure class="lx ly lz ma fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mm"><img src="../Images/1f2791ac76d8383eb576948fba9e9f90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kS5zD9tQTV0oVAPIYBDT_g.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">The package.json of a test-app that pulls in bar which pulls in foo@5 to the top level.</figcaption></figure><figure class="lx ly lz ma fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mn"><img src="../Images/dbe9ad3b4bbfcad5e8e4babc2d39c35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lyb6ms-NNtwKmzLrzpAP0w.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">And foo@5 being promoted to the top level, while foo@6 got nested inside the <code class="du ld le lf lg b">dev</code> archetype.</figcaption></figure><p id="b501" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">解决办法很简单。因为NodeJS为每个模块创建了一个<code class="du ld le lf lg b">require</code>的实例，我们可以传递它，它总是需要来自原始模块的位置。</p><p id="b3a3" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">所以我们在dev原型中创建了一个简单的文件，它简单地导出了它的<code class="du ld le lf lg b">require</code>。在主原型中，我们在任何需要的时候都使用它，而且效果很好。</p><pre class="lx ly lz ma fd mo lg mp mq aw mr bi"><span id="1501" class="li if hh lg b fi ms mt l mu mv">module.exports = require;</span></pre><p id="429d" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">它仍然没有完全解决问题，因为一些工具从它自己的上下文内部<code class="du ld le lf lg b">require</code>模块。幸运的是，这种情况很少见，到目前为止都很容易解决。</p><p id="95e2" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated"><em class="lh">顺便说一下，基于这个解决方案，我创建了一个</em> <a class="ae kj" href="https://github.com/jchip/require-at" rel="noopener ugc nofollow" target="_blank"> <em class="lh">小模块require-at </em> </a> <em class="lh">让你调用</em> <code class="du ld le lf lg b"><em class="lh">require</em></code> <em class="lh">假装你在任何你想去的目录。</em></p><h2 id="d672" class="li if hh bd ig lj lk ll ik lm ln lo io jn lp lq is jr lr ls iw jv lt lu ja lv bi translated">推广开发原型</h2><p id="71b8" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">最终我们意识到，我们原型中的大多数东西只是与开发相关的任务，它们真的应该在开发原型中。因此，我们将所有的配置设置和脚本从主原型移到了开发原型，这从一个只有<code class="du ld le lf lg b">package.json</code>文件的空模块得到了很好的提升。</p></div><div class="ab cl km kn go ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ha hb hc hd he"><h1 id="5685" class="ie if hh bd ig ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb bi translated">吞咽迭代</h1><p id="ce09" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">随着时间的推移，我们原型中的<code class="du ld le lf lg b">npm scripts</code>变得非常大，很难维护。我们在一个<code class="du ld le lf lg b">JSON</code>字符串中有超过50个shell脚本。另一个问题是他们中的许多人可能会打破窗户。</p><p id="82eb" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">虽然我们用JavaScript实现了更复杂的东西，并从shell脚本中调用它们，但仍然很难维护。在这一点上，<code class="du ld le lf lg b">npm scripts</code>不再那么吸引人了。</p><figure class="lx ly lz ma fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mw"><img src="../Images/ef346aa558271212e94c531ec042358b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kdNbJBZQKBX5nlDgmLF6jQ.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">A peek of how it’s like with all shell scripts inside package.json (wordwrap set at column 200)</figcaption></figure><p id="b299" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">我想找到一种方法来摆脱在<code class="du ld le lf lg b">JSON</code>字符串中维护这些shell脚本。显而易见的答案是JavaScript。</p><p id="d002" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">我发现<code class="du ld le lf lg b">gulp</code>可以执行JavaScript中的任务，但只能并发执行。幸运的是，有一个插件<a class="ae kj" href="https://www.npmjs.com/package/run-sequence" rel="noopener ugc nofollow" target="_blank">可以串行执行任务。</a></p><p id="4cb3" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">接下来，我需要一种简单的方法将shell脚本转换成JavaScript。所以我写了一个<a class="ae kj" href="https://github.com/electrode-io/electrode-gulp-helper" rel="noopener ugc nofollow" target="_blank">简单的加载器</a>把它们放到<code class="du ld le lf lg b">gulp</code>里，用<code class="du ld le lf lg b"><a class="ae kj" href="http://documentup.com/shelljs/shelljs" rel="noopener ugc nofollow" target="_blank">shelljs</a></code>执行。结果出乎意料地简单却有效，我们切换到基于<code class="du ld le lf lg b">gulp</code>的原型。</p></div><div class="ab cl km kn go ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ha hb hc hd he"><h1 id="7861" class="ie if hh bd ig ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb bi translated">xclap迭代</h1><p id="f26f" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">有时候，一些用户希望在调用原型任务之前注入他们自己的代码来完成设置或其他工作。但是，如果他们将一个同名的任务添加到gulp中，那么原型的任务就会丢失。为此，类似任务名称空间的东西会很有用。</p><p id="0ba5" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">为gulp实现任务命名空间并不简单，而且gulp中的任何改变都是不可能的。所以我创建了一个具有更多特性的替代任务执行器<code class="du ld le lf lg b"><a class="ae kj" href="https://www.npmjs.com/package/xclap" rel="noopener ugc nofollow" target="_blank">xclap</a></code>,其中之一显然是任务的名称空间。</p><p id="a91f" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">在来自<code class="du ld le lf lg b">xclap</code>的名称空间的支持下，用户可以从原型中定义具有相同名称的任务，但仍然可以调用原始任务。</p><p id="d7f0" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">另外，<code class="du ld le lf lg b">xclap</code>可以串行或并发地加载和执行<code class="du ld le lf lg b">npm scripts</code>，并适当地嵌套执行层次。它有一个事件驱动的执行生命周期，因此可以开发不同的可视化进度报告。它还为任务提供了更好的集成，让它们更灵活地影响其他任务的执行。</p><figure class="lx ly lz ma fd mb er es paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="er es mx"><img src="../Images/3f34593908856594ec65a24f3e27aaea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LiARkO2aWh-LKhAoxxA53A.png"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">xclap showing tasks from package.json and our archetype electrode-archetype-njs-module-dev.</figcaption></figure><h1 id="1720" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">未来</h1><p id="cf6c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">偶尔，我们仍然会遇到模块依赖混淆的问题，应用程序必须明确依赖某些模块才能在顶层安装它们。目前真的没有简单的方法来解决这个问题，我们将继续寻找更好的解决方案。</p><p id="0de6" class="pw-post-body-paragraph jc jd hh je b jf ky jh ji jj kz jl jm jn la jp jq jr lb jt ju jv lc jx jy jz ha bi translated">此外，我们正在不断改进和更新我们现有的原型，以提高开发人员的生产力，如果我们确定了一个新的项目类别，那么我们可以开发新的原型，使他们的开发更简单。</p><h1 id="a174" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论</h1><p id="3c5a" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">电极原型是需要提高开发人员生产力的结果。在它们的开发过程中，我们解决了与节点模块和实现任务的不同方法相关的问题，并开发了不同的工具来满足这些需求。我们一直在寻找更好的工具和方法，让我们的开发人员摆脱重复性的工作，让他们更快更容易地开发他们的应用程序。</p><h2 id="28ab" class="li if hh bd ig lj lk ll ik lm ln lo io jn lp lq is jr lr ls iw jv lt lu ja lv bi translated">承认</h2><p id="8690" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><a class="kk kl ge" href="https://medium.com/u/900ee8ad3db9?source=post_page-----d61a5dcc90c9--------------------------------" rel="noopener" target="_blank">令人生畏的</a>在原型的发展和演变中起了重要作用。为<a class="kk kl ge" href="https://medium.com/u/c884135151a4?source=post_page-----d61a5dcc90c9--------------------------------" rel="noopener" target="_blank"> @WalmartLabs </a>工作的开发人员为帮助将电极和原型带到今天的位置做出了很多贡献。</p></div></div>    
</body>
</html>