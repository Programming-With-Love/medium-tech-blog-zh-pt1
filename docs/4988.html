<html>
<head>
<title>Getting Started With CameraX in building Camera Apps on Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开始使用CameraX在Android上构建相机应用程序</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/getting-started-with-camerax-in-building-camera-apps-on-android-ec5416a66c9?source=collection_archive---------0-----------------------#2022-07-20">https://blog.kotlin-academy.com/getting-started-with-camerax-in-building-camera-apps-on-android-ec5416a66c9?source=collection_archive---------0-----------------------#2022-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0c39192ef6e0fc8486c5d056aadbc190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zCKFF9FMp6US7EzA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@juliusdrost?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Julius Drost</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d616" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于Android开发人员来说，在Android上开发一个使用Instagram或Snapchat等相机功能的应用程序一直是一个麻烦，部分原因是设备制造商众多，设备制造商范围广泛。</p><p id="889c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你的兴趣不是控制相机，你只是需要拍照，最简单的做法是启动相机意图拍照。尽管如此，如果你需要完全控制相机，那么CameraX是你Android开发的首选库。CameraX让你免去了为众多Android设备的相机与不同制造商打交道的烦恼，并专注于开发相机应用程序。</p><h2 id="61ea" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">早期剧透警报</h2><p id="f22e" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在我们进一步讨论之前，我想提醒您注意，CameraX的大部分开发都是围绕构建器模式进行的。光是这种理解就能帮你想出很多东西。使用<strong class="kf ir"> <em class="lz">构建器模式</em> </strong>，复杂对象将其创建委托给特定的<strong class="kf ir">构建器类</strong>而不是其自身。一旦创建(或构建)了对象，就不能对其进行更改。因此，大多数时候，您会看到类似下面这样的语句。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Builder pattern calls</figcaption></figure><p id="202e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像<a class="ae kc" href="https://square.github.io/retrofit/" rel="noopener ugc nofollow" target="_blank">改型</a>这样的库使用这种模式。</p><h2 id="5fb4" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">返回CameraX步骤</h2><p id="da6f" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">当你想使用相机时，需要的步骤是启动相机应用程序(可能首先授予相机权限)，预览图像帧，然后拍摄照片或录制视频。我将向您解释这些相同的步骤，但首先，您必须在Android Studio中创建一个<strong class="kf ir">空活动</strong>项目，并在app-level <strong class="kf ir"> build.gradle </strong>文件的dependencies块中添加必要的CameraX依赖项。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">CameraX dependencies</figcaption></figure><p id="fda6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整个相机-*是为了相机功能和未来需要我们使用协程<a class="ae kc" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-guava/kotlinx.coroutines.guava/await.html" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">wait</strong></a>on<a class="ae kc" href="https://developer.android.com/guide/background/listenablefuture#kts" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">ListenableFuture</strong></a><strong class="kf ir">。</strong></p><h2 id="781f" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">将预览视图添加到MainActivity</h2><p id="e51a" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">为了让我们预览图像帧，我们需要在<strong class="kf ir"> activity_main.xml </strong>中的PreviewView视图，并在<strong class="kf ir"> MainActivity.kt </strong>中引用它。我们还将添加一个拍照按钮。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">PreviewView in activity_main.xml</figcaption></figure><h2 id="b7e8" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">声明用例并初始化预览视图</h2><p id="c203" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在<strong class="kf ir"> MainActivity.kt </strong>中，我们的兴趣是预览图像帧，并拍照，因此我们需要两个用例，</p><p id="f083" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">预览</strong>用例以及<strong class="kf ir">图像捕捉</strong>用例。我们也将在这里引用来自<strong class="kf ir">activity _ main . XML</strong>的预览视图。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="76a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要做的下一件事是创建预览用例，并将PreviewView绑定到<strong class="kf ir"> Preview </strong>用例。本质上，一个<strong class="kf ir">预览</strong>需要一个表面，在这个表面上预览将被渲染，因此我们将预览视图的表面设置为这个表面。为此，让我们创建一个名为i <strong class="kf ir"> nitPreview() </strong>的简单方法来做到这一点。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="1de4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，正如我前面解释的，在创建预览时使用了构建器模式。这将是一个相同的模式。在这一点上，你期望如果你在<strong class="kf ir"> onCreate </strong>方法中调用<strong class="kf ir"> initPreview </strong>，当你指向一个相机时，你应该看到图像帧，但是不要太快，我们必须请求相机许可才能看到预览。为此，我们将首先在<strong class="kf ir"> MainActivity.kt </strong>中创建另一个名为<strong class="kf ir">requestCameraPermission()</strong>的方法。在onCreate中，我们会在启动相机之前请求许可。这样，我们将需要另一个叫做<strong class="kf ir"> startCamera() </strong>的方法。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="663e" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">选择要使用的摄像机</h2><p id="a880" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">在我们的<strong class="kf ir"> startCamera() </strong>方法中，我们必须像上面在<strong class="kf ir"> initPreview() </strong>方法中一样初始化预览用例，然后选择一个要使用的相机(创建CameraSelector用例)，然后通过调用<em class="lz">processcameraprovider . getinstance(this @ main activity)创建一个相机提供者。await() </em>并最终将相机提供者绑定到一个<strong class="kf ir">生命周期所有者</strong>。相机状态为打开、启动或关闭，用例仅在相机启动时接收相机数据。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="8f7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里你需要再次注意的是<strong class="kf ir"> CameraSelector </strong>仍然是按照构建器模式构建的，并且<strong class="kf ir"> cameraProvider </strong>的创建发生在<strong class="kf ir"> lifecycleScope.launch </strong>中，因为<strong class="kf ir">等待</strong>是一个挂起函数。我们只是决定使用CameraSelector的Builder<strong class="kf ir">requireLensFacing()</strong>方法默认使用后置摄像头。然后我们继续解除所有用例的绑定，如果有绑定的话，然后调用方法<strong class="kf ir">camera provider . bindtolifecycle()</strong>。<strong class="kf ir"> bindToLifeCycle </strong>方法返回一个<strong class="kf ir"> Camera </strong>对象，并接受一个生命周期所有者、CameraSelector和最后一个参数作为各种用例，对于当前用例，我们将只传递预览用例。有了所有这些设置，开始检查我们是否有相机许可，我们启动相机，如果我们没有，我们请求它。我们也不会忘记在MainActivity中覆盖<strong class="kf ir">onRequestPermissionResult</strong>方法，以便在授权结果不为空并且权限被授予的情况下启动摄像机。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">onRequestPermissionResult.</figcaption></figure><p id="1adc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成所有这些设置后，调用<strong class="kf ir"> onCreate </strong>()中的<strong class="kf ir">requestCameraPermission</strong>方法，在你的设备或模拟器上运行该应用程序后，当你接受相机权限时，你应该会看到一个预览。不过，我更希望你使用真正的设备。</p><h2 id="abc4" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">捕获图像并在ImageView中显示</h2><p id="3d9d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">你已经能够看到图像的框架，但我们更感兴趣的是用相机来拍照。我们通过构造一个<strong class="kf ir"> ImageCapture </strong>用例并调用它的<strong class="kf ir"> takePicture() </strong>方法来实现这一点。为此，我们将创建一个方法<strong class="kf ir"> initImageCapture </strong>，我们将在startCamera方法的<strong class="kf ir"> initPreview </strong>中的行之后调用这个方法。对于我们的例子，takePicture方法有两个参数，即一个执行器和一个<strong class="kf ir"> ImageCapture。OnImageCapturedCallback </strong>。回调有两个方法，分别是<strong class="kf ir"> onCaptureSuccess </strong>和<strong class="kf ir"> onError </strong>。当拍照成功时调用<strong class="kf ir"> onCaptureSuccess </strong>方法，否则调用onError。在我们做任何事情之前，我们将首先向XML布局文件添加一个ImageView。当捕获成功时，我们将显示它(使它可见)。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">ImageView in activity_main.xml</figcaption></figure><p id="1002" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图像捕获的拍照实现和生命周期绑定如下所示。</p><p id="64da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在initImageCapture中，我们构建了ImageCapture用例，并将图片质量设置为100%。接下来我们要担心的是扩展函数convertImageProxyToBitmap(这里我就不解释了)</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="74bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所看到的，startCamera方法没有太多变化，但值得注意的是ImageCapture的初始化和对bindLifecycleOwner的调用有一个额外的<strong class="kf ir"> imageCapture </strong>用例。如前所述，我们可以传递可变数量的用例。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">convert image proxy to bitmap</figcaption></figure><p id="0660" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们在<strong class="kf ir"> onCaptureSuccess </strong>中将图像代理转换为位图时，我们将位图设置为imageView。请注意，有一个不同版本的<strong class="kf ir">拍照</strong>可以拍摄图像。FileOutputOptions、Executor和一个an <strong class="kf ir"> OnImageSavedCallback </strong>。您可能有兴趣将拍摄的照片保存到您的磁盘上，因此您可能需要添加存储权限以在磁盘上创建图像文件(我将让您研究这一点)。</p><p id="0c34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们感兴趣的下一个用例是<strong class="kf ir">图像分析</strong>和<strong class="kf ir">视频捕捉</strong>。使用ImageAnalysis，您可能希望检测预览中所有面部的微笑，并检测面部何时哭泣或其他面部表情。这当然需要某种机器学习或人工智能。我们不会处理这两个用例，但我们宁愿使用CameraX扩展。</p><h2 id="36c5" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">主要通话</h2><p id="d38b" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">因此，为了总结使用CameraX捕获图像所需的主要调用，主要调用如下所示；</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">CameraX main calls</figcaption></figure><h2 id="6a18" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">用肖像、夜间模式和HDR扩展CameraX。</h2><p id="88e8" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">有些手机支持人像模式、夜间模式和HDR等效果。在肖像模式下，要拍摄的主要对象具有焦点，而背景中的其他对象则模糊不清。夜间模式使照片在低光照强度下更清晰，而HDR代表高清晰度分辨率。当然，我们可以通过cameraX使用一个<strong class="kf ir">扩展管理器</strong>和我们创建的摄像机选择器和摄像机提供器来访问它。我们将调用<strong class="kf ir">extensions manager . getinstance async(this @ main activity，cameraProvider)。await() </strong>恰好也是一个挂起函数，因为<strong class="kf ir">extensions manager . getinstance async(this @ main activity，cameraProvider) </strong>返回一个ListenableFuture，就像<strong class="kf ir">processcameraprovider . getinstance(this @ main activity)</strong>一样。</p><p id="80df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将检查特定的摄像机是否支持我们希望使用的效果，如果支持，我们将创建该效果的cameraSelector并使用它来代替我们传统的CameraSelector。因此，我们使用肖像模式或散景效果的方法如下。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="5a1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对<strong class="kf ir">extension manager . isextensionavailable</strong>的调用使用我们之前创建的基本摄像机选择器，我们将效果指定为第二个参数。如果该扩展在该设备上受支持，我们使用<strong class="kf ir">extensions manager . getextensionenabledcameraselector</strong>创建一个散景相机选择器，将基本相机选择器和模式作为第二个参数传递。我们将使用bokehCameraSelector，而不是使用基本相机选择器。设置完整源代码后，设置<strong class="kf ir">浮动操作按钮</strong>调用MainActivity中的拍照。完整的源代码可以在 这里找到<a class="ae kc" href="https://github.com/ngengesenior/MyCameraApp" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">。</strong></a></p><p id="1d4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了这个基本功能，你就可以扩展你的cameraX应用程序，让它做的不仅仅是拍照。你可能想跳到<a class="ae kc" href="https://developer.android.com/training/camerax" rel="noopener ugc nofollow" target="_blank"> CameraX文档</a>去了解更多。</p><h2 id="0907" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">谢谢你</h2><p id="889a" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">如果你读到这里，谢谢你，不要忘记分享，你可以订阅我的简讯，也许你会想点击关注按钮，给我一些大拇指。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi mg"><img src="../Images/68557afd7e8ae2a75dec26b78d8ec016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxZ6inD12UP7rnbt-2PJZw.png"/></div></a></figure></div></div>    
</body>
</html>