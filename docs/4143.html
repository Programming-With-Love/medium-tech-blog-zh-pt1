<html>
<head>
<title>Screen capture in Google Chrome</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌浏览器中的屏幕截图</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/screen-capture-in-google-chrome-8fd99ace5fd3?source=collection_archive---------2-----------------------#2017-10-13">https://medium.com/google-developer-experts/screen-capture-in-google-chrome-8fd99ace5fd3?source=collection_archive---------2-----------------------#2017-10-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d22e6aac7f6367830634c57837478230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*86PNSBAQnoht-I1LrgJYYw.png"/></div></div></figure><p id="dc20" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要在WebRTC视频聊天应用程序中构建屏幕共享功能，您必须首先能够捕捉屏幕上的内容。在这篇文章中，我们将看到如何在一个网络应用程序中使用谷歌浏览器的截屏功能。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es jn"><img src="../Images/3d111c061a60945821f22f77aaec9b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/1*7CJkKrSQ0pux13Ru55vm8Q.gif"/></div></figure><h1 id="0d66" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">你需要什么</h1><p id="edcc" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">为了构建这个项目，您需要:</p><ul class=""><li id="f319" class="kv kw hh ir b is it iw ix ja kx je ky ji kz jm la lb lc ld bi translated"><a class="ae le" href="https://www.google.com/chrome/index.html" rel="noopener ugc nofollow" target="_blank">谷歌浏览器</a></li><li id="d65f" class="kv kw hh ir b is lf iw lg ja lh je li ji lj jm la lb lc ld bi translated">文本编辑器</li><li id="31e7" class="kv kw hh ir b is lf iw lg ja lh je li ji lj jm la lb lc ld bi translated">本地web服务器——我喜欢用<a class="ae le" href="https://www.npmjs.com/package/servedir" rel="noopener ugc nofollow" target="_blank"> servedir </a>来做这样的事情</li></ul><h1 id="7e63" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">屏幕共享</h1><p id="6d2c" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">目前，Chrome不允许你通过“媒体设备”API访问屏幕内容。有一个“getDisplayMedia”方法的<a class="ae le" href="https://w3c.github.io/mediacapture-screen-share/" rel="noopener ugc nofollow" target="_blank">草案规范</a>，但是还没有浏览器实现它。对于最终用户来说，网络上的屏幕共享有很多安全问题，所以浏览器在处理这一功能时会有所顾虑。</p><p id="3ef3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那我们现在能做什么？</p><p id="f7b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗯，在Chrome中，我们可以编写一个扩展，让我们能够访问屏幕、应用程序窗口和浏览器标签。Chrome扩展具有扩展的权限和API，允许访问页面上常规JavaScript不能访问的资源。</p><p id="f03d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们编写一个扩展来访问屏幕截图，然后在页面上显示结果。</p><h1 id="d356" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">构建Chrome扩展</h1><p id="d778" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们将要构建的扩展非常简单。它由两部分组成:一个描述扩展的“manifest.json”文件和我们想要运行的脚本，我们称之为“extension.js”。</p><h2 id="84ae" class="lk jt hh bd ju ll lm ln jy lo lp lq kc ja lr ls kg je lt lu kk ji lv lw ko lx bi translated">扩展清单</h2><p id="10bd" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">创建一个新目录来构建我们的应用程序，一个用于扩展本身的目录，以及文件“manifest.json”和“extension.js”。</p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="5a57" class="lk jt hh lz b fi md me l mf mg">mkdir screen-capture<br/>cd screen-capture<br/>mkdir extension<br/>touch extension/manifest.json extension/extension.js</span></pre><p id="6149" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在您最喜欢的文本编辑器中打开“manifest.json”。我们需要向清单添加一些基本的细节:名称、描述、我们的扩展版本以及我们需要的清单文件格式的版本，在本例中是2。</p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="c172" class="lk jt hh lz b fi md me l mf mg">{<br/>  "name": "Desktop Capture",<br/>  "description":<br/>  "Allows you to capture your desktop for use in video applications",<br/>  "version": "0.1.0",<br/>  "manifest_version": 2<br/>}</span></pre><p id="18cc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们需要描述扩展是如何工作的。将以下内容添加到清单中:</p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="eaf1" class="lk jt hh lz b fi md me l mf mg">  "manifest_version": 2,<br/>  "background": {<br/>    "scripts": ["extension.js"],<br/>    "persistent": false<br/>  },<br/>  "externally_connectable": {<br/>    "matches": ["*://localhost/*"]<br/>  },<br/>  "permissions": ["desktopCapture"]<br/>}</span></pre><p id="7b46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这告诉Chrome这个扩展实际上做了什么。</p><p id="aad8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，它在后台运行文件“extension.js”。“persistant”:false”选项表示我们正在构建一个<a class="ae le" href="https://developer.chrome.com/extensions/event_pages" rel="noopener ugc nofollow" target="_blank">事件页面</a>。这意味着当不需要扩展时，它会被卸载，不会占用系统资源。</p><p id="40c9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">成为<a class="ae le" href="https://developer.chrome.com/extensions/manifest/externally_connectable" rel="noopener ugc nofollow" target="_blank"> `externally_connectable` </a>意味着该扩展可以接收来自匹配URL上的网页的消息。在这种情况下，这是一个开发扩展，将只适用于“本地主机”。如果您想将它构建为您站点的扩展，您需要在这里添加您自己的域匹配代码。</p><p id="2baa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，权限部分意味着我们想要访问Chrome扩展的<a class="ae le" href="https://developer.chrome.com/extensions/desktopCapture" rel="noopener ugc nofollow" target="_blank">桌面捕获API </a>。当我们为扩展本身编写代码时，我们将看到它是如何工作的。</p><h2 id="c285" class="lk jt hh bd ju ll lm ln jy lo lp lq kc ja lr ls kg je lt lu kk ji lv lw ko lx bi translated">扩展代码</h2><p id="8b89" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">要构建事件页面，我们需要创建一个事件监听器。我们将等待来自网页的<a class="ae le" href="https://developer.chrome.com/apps/messaging#external-webpage" rel="noopener ugc nofollow" target="_blank">消息，因此打开“extension.js”并开始输入:</a></p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="3a30" class="lk jt hh lz b fi md me l mf mg">chrome.runtime.onMessageExternal.addListener((message, sender, sendResponse) =&gt; {</span><span id="da1f" class="lk jt hh lz b fi mh me l mf mg">});</span></pre><p id="479c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae le" href="https://developer.chrome.com/apps/runtime" rel="noopener ugc nofollow" target="_blank"> `chrome.runtime` </a>是我们用来响应扩展外部事件以及返回关于扩展本身的其他细节的API。“onMessageExternal”在收到来自扩展外部的消息时触发，因此我们需要侦听它。当我们的侦听器被调用时，它接收三个参数，我们从页面发送的消息，一个<a class="ae le" href="https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/MessageSender" rel="noopener ugc nofollow" target="_blank"> `runtime.MessageSender` </a>对象和一个我们最多可以使用一次将消息发送回页面的函数。</p><p id="d1b8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦这个事件触发，我们就需要使用<a class="ae le" href="https://developer.chrome.com/extensions/desktopCapture#method-chooseDesktopMedia" rel="noopener ugc nofollow" target="_blank">` chrome . desktop capture . choose desktop media `</a>来弹出屏幕共享选项。我们需要传递一组源来捕获。<a class="ae le" href="https://developer.chrome.com/extensions/desktopCapture#type-DesktopCaptureSourceType" rel="noopener ugc nofollow" target="_blank">这些可以是“屏幕”、“窗口”、“标签”或“音频”</a>我们将在发送的消息中从网页传递它们。我们还将发送消息的选项卡传递给扩展。最后，我们需要传递一个回调函数，一旦函数为我们请求访问的流返回一个“streamId ”,就会调用这个回调函数。为了让我们异步使用“sendResponse”函数，我们还需要在侦听器函数的末尾“返回true”。</p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="b460" class="lk jt hh lz b fi md me l mf mg">chrome.runtime.onMessageExternal.addListener((message, sender, sendResponse) =&gt; {<br/>  const sources = message.sources;<br/>  const tab = sender.tab;<br/>  chrome.desktopCapture.chooseDesktopMedia(sources, tab, (streamId) =&gt; {</span><span id="09dc" class="lk jt hh lz b fi mh me l mf mg">  });<br/>  return true;<br/>});</span></pre><p id="718f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦我们得到了对回调的响应，我们就差不多完成了扩展。我们需要做的只是检查用户是否授权访问屏幕，并使用“sendResponse”将不成功的响应或流的ID发送回网页。</p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="d361" class="lk jt hh lz b fi md me l mf mg">chrome.runtime.onMessageExternal.addListener((message, sender, sendResponse) =&gt;; {<br/>  const sources = message.sources;<br/>  const tab = sender.tab;<br/>  chrome.desktopCapture.chooseDesktopMedia(sources, tab, (streamId) =&gt; {<br/>    if (!streamId) {<br/>      sendResponse({<br/>        type: 'error',<br/>        message: 'Failed to get stream ID'<br/>      });<br/>    } else {<br/>      sendResponse({<br/>        type: 'success',<br/>        streamId: streamId<br/>      });<br/>    }<br/>  });<br/>  return true;<br/>});</span></pre><p id="5962" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是我们需要为这个版本的扩展编写的全部内容。现在我们需要在使用它之前安装它。</p><h2 id="e43f" class="lk jt hh bd ju ll lm ln jy lo lp lq kc ja lr ls kg je lt lu kk ji lv lw ko lx bi translated">安装延伸部分</h2><p id="9c9d" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">在Chrome中安装一个你正在开发的扩展来进行测试是非常简单的。只要在浏览器的地址栏输入chrome://extensions就可以打开扩展设置页面。</p><p id="086a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，要安装扩展，你需要选中“开发者模式”框，然后选择“加载未打包的扩展…”。从对话框中，导航到保存扩展的目录，并选择整个目录。</p><p id="b25b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上传后，您需要记下您的分机ID。我们将在下一部分用到它。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/600c56daad8ae5682234b5cf84f91e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lpq1sAfOBGFxtMMGwqrc1w.png"/></div></div></figure><h1 id="1dca" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">构建屏幕截图</h1><p id="0fa8" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">在这篇文章的剩余部分，我们将会看到如何使用我们的新扩展来获取屏幕截图。现在，我们将在网页上的“T3”视频&gt;元素中展示这一点。在另一篇文章中，我们将研究在视频聊天中使用流，这样我们就可以远程共享我们的屏幕。</p><p id="0b10" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先在项目目录中创建名为“chrome”的目录，并在其中创建一个名为“index.html”的新HTML页面。</p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="121e" class="lk jt hh lz b fi md me l mf mg">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;</span><span id="e300" class="lk jt hh lz b fi mh me l mf mg">&lt;head&gt;<br/>  &lt;meta charset="UTF-8"&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br/>  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;<br/>  &lt;title&gt;Screen&lt;/title&gt;<br/>&lt;/head&gt;</span><span id="26e6" class="lk jt hh lz b fi mh me l mf mg">&lt;body&gt;<br/>  &lt;h1&gt;Show my screen&lt;/h1&gt;</span><span id="384a" class="lk jt hh lz b fi mh me l mf mg">  &lt;video autoplay id="screen-view" width="50%"&gt;&lt;/video&gt;<br/>  &lt;button id="get-screen"&gt;Get the screen&lt;/button&gt;<br/>  &lt;button id="stop-screen" style="display:none"&gt;Stop the screen&lt;/button&gt;</span><span id="35e0" class="lk jt hh lz b fi mh me l mf mg">  &lt;script&gt;<br/>  &lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="7736" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个基本的HTML页面，里面有一个`<video>'元素来显示我们的结果，两个按钮来启动和停止屏幕截图，还有一个`<script>'块，我们将在这里编写其余的代码。&lt;/root&gt;</script></video></p><p id="99c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将从收集将要使用的DOM元素开始编写代码。我们还为稍后将向扩展发出的请求设置了一个对象。请记住，我们可以提供我们想要选择的来源。在这个应用程序中，我们将能够从整个屏幕、应用程序的窗口或Chrome的标签中进行选择。您还需要之前将扩展加载到Chrome时的扩展ID。将此内容添加到您的`&lt;脚本&gt;块中:</p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="67be" class="lk jt hh lz b fi md me l mf mg">(() =&gt; {<br/> const EXTENSION_ID = 'YOUR_EXTENSION_ID';</span><span id="9ae6" class="lk jt hh lz b fi mh me l mf mg">const video = document.getElementById('screen-view’);<br/> const getScreen = document.getElementById('get-screen');<br/> const stopScreen = document.getElementById('stop-screen');<br/> const request = { sources: ['window', 'screen', 'tab'] };<br/> let stream;</span><span id="22df" class="lk jt hh lz b fi mh me l mf mg">})();</span></pre><p id="0862" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，开始捕捉桌面。当我们点击按钮进入屏幕时，我们向扩展发出请求，并在回调中得到响应。</p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="5b92" class="lk jt hh lz b fi md me l mf mg">  let stream;<br/>  getScreen.addEventListener('click', event =&gt; {<br/>    chrome.runtime.sendMessage(EXTENSION_ID, request, response =&gt; {</span><span id="0514" class="lk jt hh lz b fi mh me l mf mg">    });<br/>  });<br/>})();</span></pre><p id="989b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦我们得到响应，我们就检查它是否成功。如果是这样，我们可以获取扩展返回给我们的流ID，并将其传递给“media devices”API。如果没有，那么我们记录访问被拒绝。</p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="8508" class="lk jt hh lz b fi md me l mf mg">  chrome.runtime.sendMessage(EXTENSION_ID, request, response =&gt; {<br/>    if (response &amp;&amp; response.type === 'success') {<br/>      navigator.mediaDevices.getUserMedia({<br/>        video: {<br/>          mandatory: {<br/>            chromeMediaSource: 'desktop',<br/>            chromeMediaSourceId: response.streamId,<br/>          }<br/>        }<br/>      });<br/>    } else {<br/>      console.error('Could not get stream');<br/>    }<br/>  });</span></pre><p id="7832" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这段代码中，我们将选项传递给“mediaDevices.getUserMedia”的视频选项。“chromeMediaSource”应设置为“desktop”,“chrome media source Id”是我们从扩展中获得的流ID。</p><p id="818c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们需要编写的其余代码与常规的“getUserMedia”代码完全相同。该函数返回一个用流解析的承诺，因此我们需要将流设置为页面的`&lt; video &gt;'元素的源。我们还将隐藏get screen按钮，显示stop screen按钮，并捕捉任何可能发生的错误。</p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="ad04" class="lk jt hh lz b fi md me l mf mg">  navigator.mediaDevices.getUserMedia({<br/>    video: {<br/>      mandatory: {<br/>        chromeMediaSource: 'desktop',<br/>        chromeMediaSourceId: response.streamId,<br/>      }<br/>    }<br/>  }).then(returnedStream =&gt; {<br/>    stream = returnedStream;<br/>    video.src = URL.createObjectURL(stream);<br/>    getScreen.style.display = "none";<br/>    stopScreen.style.display = "inline";<br/>  }).catch(err =&gt; {<br/>    console.error('Could not get stream: ', err);<br/>  });</span></pre><p id="072d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，我们可以编写代码来处理停止屏幕捕获。这将监听按钮上的点击，获取流的曲目并停止它们。它还从“<video>”中删除了“src ”,并反转了可见按钮。</video></p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="62da" class="lk jt hh lz b fi md me l mf mg">      } else {<br/>        console.error('Could not get stream');<br/>      }<br/>    });<br/>  });</span><span id="d211" class="lk jt hh lz b fi mh me l mf mg">  stopScreen.addEventListener('click', event =&gt; {<br/>    stream.getTracks().forEach(track =&gt; track.stop());<br/>    video.src = '';<br/>    stopScreen.style.display = 'none';<br/>    getScreen.style.display = 'inline';<br/>  });<br/>})();</span></pre><p id="da0e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是所有的代码。让我们运行这个。</p><h1 id="2735" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">捕捉屏幕</h1><p id="7d09" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们需要做的最后一件事是在本地主机上提供这个HTML文件。我通常使用一个名为<a class="ae le" href="https://www.npmjs.com/package/servedir" rel="noopener ugc nofollow" target="_blank"> servedir </a>的npm模块。如果您已经安装了Node.js和npm，那么您可以使用</p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="bde1" class="lk jt hh lz b fi md me l mf mg">npm install servedir -g</span></pre><p id="fae1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，您可以使用命令行导航到保存文件的目录，并通过输入以下命令在localhost:8000上提供该文件:</p><pre class="jo jp jq jr fd ly lz ma mb aw mc bi"><span id="e113" class="lk jt hh lz b fi md me l mf mg">serve .</span></pre><p id="3d69" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您有另一种方法用于在本地主机上提供静态文件，您也可以使用这种方法。</p><p id="0e92" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">打开页面，点击“获取屏幕”按钮，选择您想要共享的屏幕、窗口或选项卡。您已经捕获了您的屏幕！</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es jn"><img src="../Images/3d111c061a60945821f22f77aaec9b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/1*7CJkKrSQ0pux13Ru55vm8Q.gif"/></div></figure><h1 id="8538" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">后续步骤</h1><p id="80c2" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">如果你没有写下所有的代码，你也可以在<a class="ae le" href="https://github.com/philnash/screen-capture" rel="noopener ugc nofollow" target="_blank">的GitHub repo </a>中查看结果。</p><p id="0064" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们在这里所做的一切都是针对Chrome浏览器的，但事实证明你也可以在Firefox中访问屏幕截图。理想情况下，我们可以将它封装在一个能在两种浏览器上无缝运行的函数中。请留意关于如何达到这一阶段的更多博客文章。</p><p id="0014" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们已经实现了所需扩展的一个非常小的版本来访问屏幕截图。对于更强大的版本，查看Twilio文档中的屏幕截图指南<a class="ae le" href="https://www.twilio.com/docs/api/video/screen-capture-chrome?code-sample=code-onmessageexternal-event-listener&amp;code-language=js&amp;code-sdk-version=default" rel="noopener ugc nofollow" target="_blank">。您还可以在那里找到更多关于如何在视频通话中使用Twilio Video的这一新功能进行屏幕共享的信息。</a></p><p id="3516" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你有一个有趣的浏览器截屏用例吗？请在下面的评论中告诉我你的想法或任何问题。或者，你也可以在推特上通过@菲尔纳什联系我们，或者通过电子邮件联系philnash@twilio.com。</p></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><p id="0738" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae le" href="https://www.twilio.com/blog/2017/10/screen-capture-in-google-chrome.html" rel="noopener ugc nofollow" target="_blank"> <em class="mq">谷歌Chrome中的截屏</em> </a> <em class="mq">原载于2017年10月12日</em> <a class="ae le" href="https://www.twilio.com/blog" rel="noopener ugc nofollow" target="_blank"> <em class="mq"> Twilio博客</em> </a> <em class="mq">。</em></p></div></div>    
</body>
</html>