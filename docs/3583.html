<html>
<head>
<title>PEG away at evaluating expressions in JavaScript — Enhancements and Fixes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">专注于评估JavaScript中的表达式——增强和修复</h1>
<blockquote>原文：<a href="https://medium.com/globant/peg-away-at-evaluating-expressions-in-javascript-enhancements-and-fixes-ecbb81f5bda?source=collection_archive---------0-----------------------#2020-12-22">https://medium.com/globant/peg-away-at-evaluating-expressions-in-javascript-enhancements-and-fixes-ecbb81f5bda?source=collection_archive---------0-----------------------#2020-12-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="f61c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于使用解析表达式语法评估JavaScript中表达式的进一步思考和经验</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/d2e47ec7dd9bcfeaee11e4178086a633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GM08N5Nd2DC5rwPZ"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@sortino?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Sortino</a> on <a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3f6e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不久前，正如我在JavaScript  中的文章<a class="ae js" rel="noopener" href="/globant/peg-away-at-evaluating-expressions-in-javascript-15159511fa97"> <em class="jt"> PEG away中所描述的，我们使用解析表达式语法(PEG)来验证和评估涉及数字、变量和函数的数学公式。</em></a></p><div class="ju jv ez fb jw jx"><a rel="noopener follow" target="_blank" href="/globant/peg-away-at-evaluating-expressions-in-javascript-15159511fa97"><div class="jy ab dw"><div class="jz ab ka cl cj kb"><h2 class="bd hi fi z dy kc ea eb kd ed ef hg bi translated">专注于计算JavaScript中的表达式</h2><div class="ke l"><h3 class="bd b fi z dy kc ea eb kd ed ef dx translated">通过使用解析表达式语法，以简单而强大的方式安全地评估JavaScript中的表达式</h3></div><div class="kf l"><p class="bd b fp z dy kc ea eb kd ed ef dx translated">medium.com</p></div></div><div class="kg l"><div class="kh l ki kj kk kg kl jm jx"/></div></div></a></div><p id="ffc1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在将代码付诸实践后，一些增强的想法出现了，并且(喘息！)几个bug！我们甚至发现，Excel的规则有时与正常的算术规则不同，因此我们必须添加一些更改，以获得错误的(但在Excel的“眼中”是正确的)结果。</p><p id="268c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们将看到我们如何进一步修改我们的PEG，以包括简化和修正，并展示我们增强的公式评估代码；我们开始吧！</p><h1 id="cb56" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">修复:变量名</h1><p id="02db" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated">我们添加的第一个补丁很简单。我们最初对变量名的定义(见下文)实际上允许像<code class="du lp lq lr ls b">220960</code>这样的名字——这在大多数(all？)语言。此外，大写字符没有包含在定义中，所以像<code class="du lp lq lr ls b">returnOnInvestment</code>这样的变量不会被识别。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="95a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">修复很简单:我们定义第一个字符(<code class="du lp lq lr ls b">char1</code>，如下)必须是一个下划线或字母(小写或大写),其后可以是更多的下划线、字母或数字。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="2ce3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种改变既简单又快速，添加更多允许的字符将是微不足道的。让我们继续，以避免一些不必要的转换，我们已经包括在几个地方。</p><h1 id="1ff3" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">简化:数字处理</h1><p id="ac70" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated">我们做的下一个改变与数字处理有关。在我们的第一个版本中，我们在很多地方加入了<code class="du lp lq lr ls b">Number()</code>转换，来处理字符串到数字的转换。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="1df5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在与用户讨论这个问题后，他们同意不应该对字符串进行数学运算，也不需要，如果需要的话，那么应该实现Excel的<a class="ae js" href="https://support.microsoft.com/en-us/office/value-function-257d0108-07dc-437d-ae1c-bc2d3953d8c2" rel="noopener ugc nofollow" target="_blank"> VALUE()函数</a>。变化本身就是简单。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="2f77" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">坦白说:在检查<code class="du lp lq lr ls b">Number()</code>的用法时，我们发现它的用法并不一致，有些地方我们漏掉了……<em class="jt">现在</em>没事了！</p><p id="fffb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我们决定尝试获得更清晰的语法。</p><h1 id="6c86" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">增强:使用令牌名称</h1><p id="f8a4" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated">我们做的下一个改变是一个简单的重构:我们没有在所有的语法规则中混合标记和字符串，而是决定在任何地方都使用标记。第一步是为单个字符(如<code class="du lp lq lr ls b">CARET</code>和<code class="du lp lq lr ls b">COMMA</code>)、集合(如<code class="du lp lq lr ls b">DIGIT</code>和<code class="du lp lq lr ls b">LETTER</code>)以及特定字符串(如<code class="du lp lq lr ls b">LOG10</code>和<code class="du lp lq lr ls b">TRUE</code>)定义令牌。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="7931" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一步很简单；我们只是修改了所有现有的规则来使用这些令牌。例如，我们从</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="a739" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">到下面的代码；变化基本上是微不足道的，只是一个“查找和替换”的问题。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="b5e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这本身并没有给语言或函数的计算带来任何变化，但是让代码变得更加清晰。然而，仍然有一些我们不喜欢的东西…那些到处显示空白的下划线使得规则有点太长，所以我们决定继续努力。</p><h1 id="210d" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">简化:空白空间处理</h1><p id="6d88" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated">至于空位，我们的规则很简单；基本上大多数标记的前面或后面都可以有空格。我们没有添加这么多作品，而是决定每个标记或符号将“吞噬”它后面的任何空白空间。当然，有些符号(比如数字中的句号)不允许有空格；我们考虑到了这一点。我们通过在名称中添加下划线来重命名允许空格的标记。让我们看看这里的一些变化。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="4909" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更新后的规则(如上所示)如下所示。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="ac7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不错！规则变得更短更清晰，所以我们认为这是一个胜利。然而，就在这个时候，一件不太好的事情突然出现了；一些公式产生了错误的结果！</p><h1 id="3958" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">修正:数学左联想</h1><p id="c0ec" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated">让我们看看社交网络中经常出现的一个谜题:24/4/2是什么？做24/4=6，再做6/2=3，就找到了正确答案；另一种说法是除法运算符是<em class="jt">左关联</em>。(乘法运算符也是左关联的，但是如果将24乘以4乘以2计算为(24乘以4)乘以2，或者计算为24乘以(4乘以2)，结果是相同的。)然而，我们的联系汇率有一个问题；我们来复习一下。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="917d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">中间的规则是24/4/2应该被解释为24除以另一个表达式(4/2 ),所以我们得到的不是3而是12。我不想输入太多的细节，但是使用<a class="ae js" href="https://en.wikipedia.org/wiki/Context-free_grammar" rel="noopener ugc nofollow" target="_blank">上下文无关语法</a>我们可以通过左递归定义来解决这个问题，或者通过应用<a class="ae js" href="https://en.wikipedia.org/wiki/Left_recursion" rel="noopener ugc nofollow" target="_blank">左递归去除算法</a>来使语法变得更复杂。然而，PEG提供了一种更简单的方法，如下所示。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="be60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个语法规则说一个<code class="du lp lq lr ls b">EXP_PD</code>以一个<code class="du lp lq lr ls b">EXP_X</code>开始，后面是零对或多对乘法或除法记号和另一个<code class="du lp lq lr ls b">EXP_X</code>。使用JavaScript的<code class="du lp lq lr ls b">.reduce()</code>方法让我们从左到右计算表达式，正如所料。</p><p id="2f8e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对了，我们还用同样的方法固定了减法:6–3–2应该解释为(6减3)减2，而不是6减(3减2)。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="0a04" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这两个错误只是在特定的测试之后才浮出水面。幸运的是，用户没有编写过有这些问题的公式，所以我们躲过了一劫——但是修复后的代码肯定消除了bug，并且展示了其他强大的PEG特性。</p><h1 id="4026" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">增强:逻辑常数</h1><p id="6429" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated">下一次增强是因为用户对Excel的熟悉；他说你不必写<code class="du lp lq lr ls b">TRUE()</code>,因为括号是可选的；<code class="du lp lq lr ls b">TRUE</code>也是一样。在检查了文档之后，我们知道我们必须修复它，但幸运的是这很容易。我们只需重写之前的<code class="du lp lq lr ls b">TRUE()</code>和<code class="du lp lq lr ls b">FALSE()</code>规则，如下所示:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="6391" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在新规则中，我们做了一个小小的语法改变，使括号成为可选的。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="b496" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，括号对是可选的；他们可能都在场，也可能都不在场。我们以为我们已经对公式有了一个很好的最终定位，但是一个新的问题出现了:Excel不能像预期的那样进行数学运算！</p><h1 id="833a" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">修复:Excel/算术差异</h1><p id="6bb8" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated">用我们的评估器和Excel做实验显示了一些问题。第一，<a class="ae js" href="https://en.wikipedia.org/wiki/Order_of_operations#Serial_exponentiation" rel="noopener ugc nofollow" target="_blank">根据数学规则</a>，2^3^2应该被评价为2^(3^2)，或者2⁹，所以512。但是，Excel是从左到右计算的，所以结果应该是(2^3)^2，或64。这个问题的解决方案类似于我们对除法和减法所做的。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="4eef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们最初的定义是右结合的；通过使用与前面相同的风格，我们从左到右做幂运算。有了这个<code class="du lp lq lr ls b">EXP_X</code>的替代定义，现在结果与Excel的一致。但是我们发现了另一个不同点！</p><p id="c19c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">-2^2是什么？这按照通常的规则应该理解为-4 <a class="ae js" href="https://en.wikipedia.org/wiki/Order_of_operations#Unary_minus_sign" rel="noopener ugc nofollow" target="_blank">，但是Excel评估如果是(-2)^2，所以结果是4。在这种情况下，我们的公式评估员给出了正确的(Excel)结果，但在我们看来是错误的！如果我们修复它(如下所示),结果将与Excel的不匹配，但我们也希望有一个完全符合算术规则的评估器；一个语法可以表现为两种不同的方式。</a></p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="b0f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用的<a class="ae js" href="https://pegjs.org/" rel="noopener ugc nofollow" target="_blank"> peg.js库</a>允许我们拥有它，通过使用<a class="ae js" href="https://pegjs.org/documentation#grammar-syntax-and-semantics" rel="noopener ugc nofollow" target="_blank">一种特殊的检查</a>。首先，我们在文件的顶部添加了一个常量。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="64ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果<code class="du lp lq lr ls b">EXCEL_STYLE</code>为真，我们的评估者将以Excel的方式行事；如果我们将其设置为false，它将遵循正常的算术规则。然后我们重写了<code class="du lp lq lr ls b">VALUE</code>和<code class="du lp lq lr ls b">EXP_X</code>规则以依赖<code class="du lp lq lr ls b">EXCEL_STYLE</code>。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="e043" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">只有当<code class="du lp lq lr ls b">EXCEL_STYLE</code>为真时，才会考虑以<code class="du lp lq lr ls b">&amp; { return EXCEL_STYLE; }</code>开头的行；相反，只有当<code class="du lp lq lr ls b">EXCEL_STYLE</code>为假时，才会考虑以<code class="du lp lq lr ls b">! { return EXCEL_STYLE; }</code>开头的行。你也可以用另一种方式重写规则。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="d476" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了这最后的改变，我们有了一个可以双向工作的公式计算器:根据Excel的规则，或者根据标准的算术规则。我们发现，如果需要进行标准评估，我们已经有了所需的解决方案，实现起来并不难。</p><h1 id="0b6f" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">代码的最终版本</h1><p id="8122" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated">经过这么多的修改，代码长度是以前的两倍(149行而不是77行),但是我们认为它更清晰了(希望如此！！)无bug。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="a461" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还开发了许多单元测试(这里没有显示),以便验证我们的更改没有破坏任何东西，现在我们对最终结果有了更多的信心——但是如果您发现任何问题，请让我们知道；记住，测试只能证明你是错的，永远不能证明你是对的！</p><h1 id="904e" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">摘要</h1><p id="96c0" class="pw-post-body-paragraph ie if hh ig b ih lk ij ik il ll in io ip lm ir is it ln iv iw ix lo iz ja jb ha bi translated">在“完成”我们的算术表达式求值器之后，我们提出了一些改进，也提出了一些对特定问题的修复。我们的最终结果越来越清晰(或者说我们是这样认为的！)和灵活性(允许我们容易地表示公式求值的两种可选方式)。我们应用了PEG库的新特性，我们觉得这些变化并不难实现或理解。现在我们只需要等待用户的意见和新的要求！</p></div></div>    
</body>
</html>