<html>
<head>
<title>What are micro tasks and macro tasks in the event loop?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">事件循环中的微观任务和宏观任务是什么？</h1>
<blockquote>原文：<a href="https://medium.com/globant/what-are-micro-tasks-and-macro-tasks-in-the-event-loop-29bc0abdd445?source=collection_archive---------0-----------------------#2022-08-24">https://medium.com/globant/what-are-micro-tasks-and-macro-tasks-in-the-event-loop-29bc0abdd445?source=collection_archive---------0-----------------------#2022-08-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/05cdbb46e72107e9afcb88eece52e7c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hzTrWmMbU2J_Jg2o"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@flub?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Maxime Lebrun</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="02a9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi js translated">既然你来到了这个页面，我假设你是一个JavaScript开发者，并且想知道更多关于事件循环是如何工作的。</p><blockquote class="kb kc kd"><p id="cc39" class="iu iv ke iw b ix iy iz ja jb jc jd je kf jg jh ji kg jk jl jm kh jo jp jq jr ha bi translated">我不打算讨论事件循环的阶段。我将向您简要介绍所有的异步函数，任何JavaScript开发人员，无论是前端开发人员(React.js)还是后端开发人员(Node.js)，在他们的一生中都必须至少使用过一次。</p></blockquote><p id="2552" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">读完这篇博客后，你将能够回答这些问题:-</p><ol class=""><li id="164a" class="ki kj hh iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">JavaScript如何一次处理多件事？</li><li id="4597" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">事件循环如何区分下一个要执行的任务的优先级？</li><li id="234a" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">这一过程涉及哪些组件？</li><li id="3afb" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">最后，何时使用什么？</li></ol><p id="ceea" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们开始吧…</p></div><div class="ab cl kw kx go ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ha hb hc hd he"><h1 id="e87c" class="ld le hh bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">事件循环</h1><p id="bebb" class="pw-post-body-paragraph iu iv hh iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr ha bi translated">事件循环就是一个无限循环。JavaScript并不是第一个使用事件循环概念的地方。<a class="ae it" href="https://docs.python.org/3/library/asyncio-eventloop.html#event-loop" rel="noopener ugc nofollow" target="_blank"> Python </a>、<a class="ae it" href="https://livebook.manning.com/book/netty-in-action/chapter-7/" rel="noopener ugc nofollow" target="_blank"> Netty </a>和<a class="ae it" href="http://www.tcl.tk/about/netserver.html" rel="noopener ugc nofollow" target="_blank"> TCL </a>是另外几个使用它的地方。现在我将坚持使用JavaScript事件循环。无论您在浏览器还是Node.js上运行JavaScript代码，都会有一个事件循环负责处理异步任务。</p><p id="66fa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我将在这篇博客中频繁使用异步这个词。我所说的异步是指您希望在以后某个时间点执行的代码的某个部分。异步函数的一些例子有setTimeout、回调、承诺、处理事件、网络请求等。JavaScript使用事件循环，通过单线程处理所有这些类型的异步任务。</p><p id="a987" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">事件循环涉及<strong class="iw hi">调用栈、宏任务和微任务。</strong></p><figure class="mh mi mj mk fd ii er es paragraph-image"><div class="er es mg"><img src="../Images/99826d6fb5d1f1ae9a561c49945d7892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*NKmNMqD9spvlNLJgHfDIfw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Macro and micro task queue in event loop</figcaption></figure><h1 id="5020" class="ld le hh bd lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw mp ly lz ma bi translated"><strong class="ak">调用堆栈</strong></h1><p id="53a7" class="pw-post-body-paragraph iu iv hh iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr ha bi translated">调用栈是后进先出栈。这是从宏任务队列或微任务队列添加任务的地方。您将在以下段落中找到关于微任务和宏任务的详细信息。</p><blockquote class="kb kc kd"><p id="be91" class="iu iv ke iw b ix iy iz ja jb jc jd je kf jg jh ji kg jk jl jm kh jo jp jq jr ha bi translated">JavaScript引擎从调用堆栈中选择要执行的任务。事件循环不断检查调用堆栈中需要运行的任何函数。</p></blockquote><h1 id="f536" class="ld le hh bd lf lg ml li lj lk mm lm ln lo mn lq lr ls mo lu lv lw mp ly lz ma bi translated">宏任务</h1><p id="93a4" class="pw-post-body-paragraph iu iv hh iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr ha bi translated">你会发现宏任务队列在互联网上的一些资源中被称为任务队列。任务队列和宏任务队列是同一个概念。</p><blockquote class="kb kc kd"><p id="37fb" class="iu iv ke iw b ix iy iz ja jb jc jd je kf jg jh ji kg jk jl jm kh jo jp jq jr ha bi translated">宏任务是由标准机制(如事件回调、间隔或超时)安排运行的任何JavaScript代码。</p></blockquote><p id="63d4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所有这些都被安排在宏任务队列中。宏任务的一些示例如下:</p><ol class=""><li id="b615" class="ki kj hh iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated"><em class="ke"> setTimeout() </em></li><li id="aca7" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated"><em class="ke"> setImmediate() </em></li><li id="f389" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated"><em class="ke"> setInterval() </em></li><li id="9fee" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated"><em class="ke">requestAnimationFrame()</em></li><li id="4a7c" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">输入－输出</li><li id="589a" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated">用户界面渲染</li></ol><h2 id="3789" class="mq le hh bd lf mr ms mt lj mu mv mw ln jf mx my lr jj mz na lv jn nb nc lz nd bi translated"><a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout" rel="noopener ugc nofollow" target="_blank"><em class="ne"/></a></h2><p id="c6a3" class="pw-post-body-paragraph iu iv hh iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr ha bi translated">每个JavaScript开发人员一生中肯定至少使用过一次<em class="ke"> setTimeout() </em>。它只是一个实用函数，接受第一个参数作为函数回调，第二个参数作为以毫秒为单位的时间。一旦定时器到期，它就执行函数回调。</p><p id="bd18" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="ke"> setTimeout() </em>返回Timeout对象，该对象可用于引用所设置的超时。这个超时对象也可以用来取消超时。虽然<em class="ke"> setTimeout() </em>是一个异步函数，但是您不能使用它来暂停其他函数的执行。</p><figure class="mh mi mj mk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nf"><img src="../Images/4decc2f99ec093114b4e221345aa6bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8tZ_FvW3127t7iBSCx17UA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Example of <strong class="bd lf">setTimeout()</strong></figcaption></figure><div class="ng nh ez fb ni nj"><a href="https://www.mycompiler.io/view/Ay5qramNAIo" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">setTimeout()示例</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">单击此处运行setTimeout()示例</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">www.mycompiler.io</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx in nj"/></div></div></a></div><p id="d5db" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由<em class="ke"> setTimeout() </em>执行的代码从与调用<em class="ke"> setTimeout() </em>的函数不同的执行上下文中调用。如果你没有在调用中或者用apply或bind函数为这个设置一个值，它将默认为全局对象。</p><p id="e2d5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在代码片段中，我有一个名为<em class="ke"> demoTimeout() </em>的函数。我只是在那个函数中打印“Hello world”。我将<em class="ke"> demoTimeout() </em>作为第一个参数传递，这不过是对<em class="ke"> setTimeout() </em>的回调。该函数的第二个参数是毫秒数，在我们的例子中是1000毫秒。根据setTimeout()的概念，<em class="ke"> demoTimeout() </em>理想情况下将在1000毫秒后被调用。</p><h2 id="fe55" class="mq le hh bd lf mr ms mt lj mu mv mw ln jf mx my lr jj mz na lv jn nb nc lz nd bi translated"><a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate" rel="noopener ugc nofollow" target="_blank"> setImmediate() </a></h2><p id="8bbb" class="pw-post-body-paragraph iu iv hh iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr ha bi translated">setImmediate() 是Node.js提供的另一个实用函数，当您希望尽可能快地异步执行某段代码时，它可以是选项之一。</p><p id="93e0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="ke"> setTimeout() </em>和<em class="ke"> setImmediate() </em>类似，但是根据调用的时间不同，行为方式也不同。<em class="ke"> setImmediate() </em>用于在事件循环的轮询阶段完成后执行脚本。<em class="ke"> setTimeout() </em>调度在经过最小阈值(毫秒)后运行的脚本。</p><p id="899e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">计时器的执行顺序将根据调用它们的上下文而变化。如果两者都是从主模块中调用的，那么时间将受到进程性能的限制。</p><p id="bc05" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="ke"> setImmediate() </em>返回即时对象，可用于取消预定的即时。</p><figure class="mh mi mj mk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ny"><img src="../Images/26814ff8c3fcb4efec0bbbcda6d807fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Ae1TCcs-3x5L79jCy5ReQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Example of <strong class="bd lf">setImmediate()</strong></figcaption></figure><div class="ng nh ez fb ni nj"><a href="https://www.mycompiler.io/view/8RSgZN5NvZH" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">setImmediate示例</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">单击此处运行setImmediate()示例</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">www.mycompiler.io</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx in nj"/></div></div></a></div><p id="5231" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码片段中，我在主模块中编写了<em class="ke"> setTimeout() </em>和<em class="ke"> setImmediate() </em>。两个定时器的执行顺序取决于进程的性能。但是，如果在一个I/O周期内移动这两个调用，<em class="ke"> setImmediate() </em> callback将总是首先执行。下面，我在I/O循环中添加了<em class="ke"> setTimeout() </em>和<em class="ke"> setImmediate() </em>。</p><figure class="mh mi mj mk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ny"><img src="../Images/f05bdd2a2c6858dfa7cd67e8477a48a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9d5gp5umepPD4Ocx28yDIQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">setTimeout() and setImmediate() in I/O cycle</figcaption></figure><div class="ng nh ez fb ni nj"><a href="https://www.mycompiler.io/view/HOvxIRrhRJx" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">I/O周期中的setImmediate()</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">单击此处以在I/O周期中运行setImmediate()</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">www.mycompiler.io</p></div></div><div class="ns l"><div class="oa l nu nv nw ns nx in nj"/></div></div></a></div><h2 id="818d" class="mq le hh bd lf mr ms mt lj mu mv mw ln jf mx my lr jj mz na lv jn nb nc lz nd bi translated"><a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/API/setInterval" rel="noopener ugc nofollow" target="_blank"> setInterval() </a></h2><p id="960e" class="pw-post-body-paragraph iu iv hh iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr ha bi translated">如果一段代码需要重复执行，那么<em class="ke"> setInterval() </em>可以用来调度这段代码的重复执行。类似于<em class="ke"> setTimeout() </em>，以回调函数为第一参数，以毫秒数为第二参数。</p><p id="e2f2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="ke"> setTimeout() </em>和<em class="ke"> setInterval() </em>的区别在于，<em class="ke"> setTimeout() </em>只会执行一次给定的回调函数，<em class="ke"> setInterval() </em>会无限次执行回调函数。</p><p id="6dcb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">和<em class="ke"> setTimeout() </em>一样，<em class="ke"> setInterval() </em>也返回Timeout对象，这个对象可以用来引用和修改已经设置好的时间间隔。</p><figure class="mh mi mj mk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ny"><img src="../Images/e22ce6eead1a5ab20673ef05365a9d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwuDj8EP3z_NQJ62rzWG3A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Example of <strong class="bd lf">setInterval()</strong></figcaption></figure><div class="ng nh ez fb ni nj"><a href="https://www.mycompiler.io/view/Dtyb8uJwD47" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">setInterval()示例</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">单击此处运行setInterval()示例</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">www.mycompiler.io</p></div></div><div class="ns l"><div class="ob l nu nv nw ns nx in nj"/></div></div></a></div><p id="77e0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码片段中，我有一个每隔1000毫秒执行一次的函数回调。我正在增加<em class="ke">计数</em>直到5，然后清除间隔。这将停止回调函数的重复执行。</p><p id="e46a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我觉得这三个例子足够理解宏观任务了。<em class="ke">requestAnimationFrame()</em>、I/O、UI渲染是宏任务的几个其他例子。</p></div><div class="ab cl kw kx go ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ha hb hc hd he"><h1 id="de30" class="ld le hh bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">微任务</h1><p id="b7cb" class="pw-post-body-paragraph iu iv hh iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr ha bi translated">宏观和微观任务之间的区别似乎很小。它们都被放在调用堆栈中，并在适当的时间运行。事件循环从调用堆栈中一个接一个地拾取任务。它以不同的方式对待微观任务。</p><blockquote class="kb kc kd"><p id="40f2" class="iu iv ke iw b ix iy iz ja jb jc jd je kf jg jh ji kg jk jl jm kh jo jp jq jr ha bi translated">所有的微任务都将在事件循环的一次循环中执行。一个微任务可以调度另一个微任务。</p></blockquote><p id="9b92" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">事件循环连续运行所有的微任务。您需要谨慎对待递归添加微任务的方式。一些微任务的例子是:</p><ol class=""><li id="5edb" class="ki kj hh iw b ix iy jb jc jf kk jj kl jn km jr kn ko kp kq bi translated">承诺</li><li id="262e" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated"><em class="ke"> process.nextTick() </em></li><li id="3138" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr kn ko kp kq bi translated"><em class="ke"> queueMicrotask() </em></li></ol><h2 id="487a" class="mq le hh bd lf mr ms mt lj mu mv mw ln jf mx my lr jj mz na lv jn nb nc lz nd bi translated"><a class="ae it" href="https://www.w3.org/2001/tag/doc/promises-guide" rel="noopener ugc nofollow" target="_blank">承诺</a></h2><p id="1dc7" class="pw-post-body-paragraph iu iv hh iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr ha bi translated">承诺表示异步操作的最终结果。承诺是处理异步代码的一种方式。异步函数在幕后使用承诺。</p><p id="d7c7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">与promise交互的主要方式是通过它的<em class="ke"> then </em>函数，该函数注册一个回调来接收promise的最终值或Promise无法实现的原因。一旦承诺被调用，它将开始处于待定状态。这意味着调用函数将继续执行，直到承诺得到解决。所创造的承诺最终会以一种解决的状态或拒绝的状态结束。</p><figure class="mh mi mj mk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ny"><img src="../Images/02020d566ac0d2ab8f98f0b7c2f0acaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K686vdeTKsHPa9KLHunu6g.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Example of <strong class="bd lf">Promise</strong></figcaption></figure><div class="ng nh ez fb ni nj"><a href="https://www.mycompiler.io/view/KDel5GQLDDd" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">承诺范例</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">单击此处运行承诺示例</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">www.mycompiler.io</p></div></div><div class="ns l"><div class="oc l nu nv nw ns nx in nj"/></div></div></a></div><p id="664d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码片段中，我在I/O模块中有<em class="ke"> setImmediate() </em>，setTimeout()和main模块中的两个承诺。承诺回调被添加到承诺队列。承诺队列将在同一个迭代中执行。但是，宏任务会在事件循环的下一次迭代中执行。在我们的例子中，承诺将首先被执行，因为承诺是微任务的一部分，并且比宏任务的<em class="ke"> setTimeout() </em>和<em class="ke"> setImmediate() </em>具有更高的优先级。</p><h2 id="dacb" class="mq le hh bd lf mr ms mt lj mu mv mw ln jf mx my lr jj mz na lv jn nb nc lz nd bi translated"><a class="ae it" href="https://nodejs.dev/learn/understanding-process-nexttick" rel="noopener ugc nofollow" target="_blank"> process.nextTick() </a></h2><p id="8af2" class="pw-post-body-paragraph iu iv hh iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr ha bi translated">在Node.js中，事件循环的每次迭代称为一个tick。传递给<em class="ke"> process.nextTick() </em>的回调将在事件循环的当前阶段执行。<em class="ke"> process.nextTick() </em>虽然是异步API的一部分，但不是事件循环的一部分。</p><p id="e5c8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="ke"> process.nextTick() </em>将在设置的任何即时变量以及任何计划的I/O之前运行。<em class="ke"> process.nextTick() </em>不可清除。一旦代码被<em class="ke"> process.nextTick() </em>调度执行，就不能停止执行。</p><p id="86a7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">任何时候，在给定的阶段调用<em class="ke"> process.nextTick() </em>，传递给它的所有回调都将在事件循环继续之前得到解决。这可能会造成一些不好的情况，因为它允许您通过进行递归的<em class="ke"> process.nextTick() </em>调用来耗尽I/O。</p><figure class="mh mi mj mk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ny"><img src="../Images/34211f34b1e9719d0e5a91278399cc8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSgHFV8UfyrTQwb5uP2V5Q.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Example of <strong class="bd lf">process.nextTick()</strong></figcaption></figure><div class="ng nh ez fb ni nj"><a href="https://www.mycompiler.io/view/7XydtfydMgr" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">process.nextTick()示例</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">单击此处运行process.nextTick()示例</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">www.mycompiler.io</p></div></div><div class="ns l"><div class="od l nu nv nw ns nx in nj"/></div></div></a></div><p id="1948" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码片段中，我们有两个回调函数，一个用于<em class="ke"> process.nextTick() </em>，另一个用于promise。正如我上面已经提到的，<em class="ke"> process.nextTick() </em>将在任何immediates之前执行。首先执行传递给<em class="ke"> process.nextTick() </em>的回调，然后执行传递给promise的回调。</p><h2 id="0b62" class="mq le hh bd lf mr ms mt lj mu mv mw ln jf mx my lr jj mz na lv jn nb nc lz nd bi translated"><a class="ae it" href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide" rel="noopener ugc nofollow" target="_blank"> queueMicrotask() </a></h2><p id="62be" class="pw-post-body-paragraph iu iv hh iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr ha bi translated"><em class="ke"> queueMicrotask() </em>会显式地把一个任务放到微任务队列中。这就是承诺兑现时的情况。回调函数在微任务中排队。如果链接多个then语句，它们的所有回调都将被添加到微任务队列中，并保证在将控制权交还给事件循环之前得到执行。如果您一直将任务排队到微任务队列中，您的浏览器/服务器将变得没有响应。</p><p id="b86c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="ke"> queueMicrotask() </em>在浏览器平台上可用。在版本11之前，它在Node.js上不可用，但现在我们也可以在Node.js上使用它。</p><figure class="mh mi mj mk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ny"><img src="../Images/be3ac6764477344cfbd05b4672e88f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wdHoFnnIAAZGlu-mMUJvQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Example of <strong class="bd lf">queueMicrotask()</strong></figcaption></figure><div class="ng nh ez fb ni nj"><a href="https://www.mycompiler.io/view/1rVQmlfAAl1" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">queueMicrotask()示例</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">单击此处运行queueMicrotask()示例</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">www.mycompiler.io</p></div></div><div class="ns l"><div class="oe l nu nv nw ns nx in nj"/></div></div></a></div><p id="c0df" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的代码片段中，我们调用了<em class="ke"> queueMicrotask() </em>，它再次调用<em class="ke"> queueMicrotask() </em>并将回调添加到微任务队列中。它们在序列中被调用。</p></div><div class="ab cl kw kx go ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ha hb hc hd he"><h1 id="454e" class="ld le hh bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">什么时候用什么</h1><p id="40af" class="pw-post-body-paragraph iu iv hh iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr ha bi translated">每当你想推迟某段代码的执行时，你应该执行一个宏任务。但是，如果你想让JavaScript同步运行，那就去做微任务吧。不建议在代码中过度使用微任务。它将阻塞事件循环的执行，对于应用程序的用户来说，这将是一个非常糟糕的体验。</p><h2 id="6523" class="mq le hh bd lf mr ms mt lj mu mv mw ln jf mx my lr jj mz na lv jn nb nc lz nd bi translated"><strong class="ak">资源</strong></h2><div class="ng nh ez fb ni nj"><a href="https://www.jsv9000.app/?code=c2V0VGltZW91dChmdW5jdGlvbiBhKCkgewogIGNvbnNvbGUubG9nKCJmaXJzdCBtYWNyb3Rhc2siKTsKfSwgMCk7CgpQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uIGIoKSB7CiAgY29uc29sZS5sb2coImZpcnN0IG1pY3JvdGFzayIpOwp9KTsKCnNldFRpbWVvdXQoZnVuY3Rpb24gYygpIHsKICBjb25zb2xlLmxvZygic2Vjb25kIG1hY3JvdGFzayIpOwp9LCAwKTsKClByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gZCgpIHsKICBjb25zb2xlLmxvZygic2Vjb25kIG1pY3JvdGFzayIpOwp9KTs%3D" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">JS可视化工具9000</h2><div class="nq l"><h3 class="bd b fi z dy no ea eb np ed ef dx translated">JavaScript可视化工具</h3></div><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">www.jsv9000.app</p></div></div></div></a></div><p id="3556" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">JavaScript visualizer是一个在线工具，用于可视化事件循环中一些宏和微任务的执行。我建议逐步了解所有任务的执行顺序。</p><p id="8ef8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">灵感来自以下链接</p><ul class=""><li id="456e" class="ki kj hh iw b ix iy jb jc jf kk jj kl jn km jr of ko kp kq bi translated"><a class="ae it" href="https://youtu.be/8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">究竟什么是事件循环？菲利普·罗伯特</a> s</li><li id="45d3" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr of ko kp kq bi translated"><a class="ae it" href="https://javascript.info/event-loop" rel="noopener ugc nofollow" target="_blank">https://javascript.info/event-loop</a></li><li id="facd" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr of ko kp kq bi translated"><a class="ae it" href="https://nodejs.dev/learn/the-nodejs-event-loop" rel="noopener ugc nofollow" target="_blank">https://nodejs.dev/learn/the-nodejs-event-loop</a></li><li id="1d1b" class="ki kj hh iw b ix kr jb ks jf kt jj ku jn kv jr of ko kp kq bi translated"><a class="ae it" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">https://nodejs . org/en/docs/guides/event-loop-timers-and-next tick/</a></li></ul><p id="0d3a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我已经将上述所有示例添加到一个git存储库下。下面给出了链接:</p><div class="ng nh ez fb ni nj"><a href="https://github.com/ajitfawade/macrotasks-microtasks" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab dw"><div class="nl ab nm cl cj nn"><h2 class="bd hi fi z dy no ea eb np ed ef hg bi translated">GitHub-ajitfawade/macro tasks-micro tasks:事件中宏任务和微任务的例子…</h2><div class="nr l"><p class="bd b fp z dy no ea eb np ed ef dx translated">github.com</p></div></div><div class="ns l"><div class="og l nu nv nw ns nx in nj"/></div></div></a></div><p id="139e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">暂时就这样了。</p></div></div>    
</body>
</html>