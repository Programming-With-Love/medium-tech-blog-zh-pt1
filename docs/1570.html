<html>
<head>
<title>Lightweight, Cloud-Native Messaging with NATS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过NATS实现轻量级云原生消息传递</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/lightweight-cloud-native-messaging-with-nats-ad730ca2becf?source=collection_archive---------1-----------------------#2018-06-11">https://medium.com/capital-one-tech/lightweight-cloud-native-messaging-with-nats-ad730ca2becf?source=collection_archive---------1-----------------------#2018-06-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/80f2f6ea8992cbe77c89873ff587a76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uu-NTSDZrR19C-OdGwy-OQ.jpeg"/></div></div></figure><p id="caf6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在为云构建应用时，我们通常会投入大量精力来打破我们的铁板一块，将应用构建为小型、容器化的工作负载，这些工作负载遵循云原生应用的<a class="ae jn" href="https://www.oreilly.com/webops-perf/free/beyond-the-twelve-factor-app.csp" rel="noopener ugc nofollow" target="_blank"> 12(或15)个因素</a>。随着我们的关注点缩小到代码库的内部，我们经常将关于<em class="jo">消息传递</em>的讨论和设计留在待办事项中。</p><p id="87a6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">消息传递是任何大规模分布式系统的<em class="jo">中枢神经系统</em>。无论我们是在做事件外包还是更简单的工作分派模型，消息传递都是让一切工作顺利进行的粘合剂。没有它，我们美妙的分布式系统就会陷入停顿。</p><p id="23e6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么，我们如何为我们的应用程序选择消息代理或消息传递架构呢？这可能会让人感到不知所措，因为大量的选项已经存在，而且每天都有新的选项出现。</p><p id="f5f6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在复杂性和规模方面，我们有<a class="ae jn" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">卡夫卡</em> </a>。Kafka通常被称为分布式日志存储。假设在Kafka中发布到主题的消息将持续一段时间，并且<a class="ae jn" href="https://kafka.apache.org/documentation/#theconsumer" rel="noopener ugc nofollow" target="_blank"> <em class="jo">消费者群体</em> </a>的概念允许消息在同一服务的多个实例中平均分布。它非常强大，但伴随着这种力量而来的是巨大的责任。Kafka很难维护，对于任何希望提高技术的团队来说，学习曲线都很陡。</p><p id="c171" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一个相当常见的选择是<a class="ae jn" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> <em class="jo"> RabbitMQ </em> </a>(或者任何<a class="ae jn" href="https://www.amqp.org/" rel="noopener ugc nofollow" target="_blank"><em class="jo">AMQP</em></a>——顺从的经纪人，真的)。Rabbit的重量要轻得多，但是Rabbit没有使用独特的<em class="jo">消费者群体</em>的概念，而是采用了让客户消费队列的更简单的方法。如果一个客户端没有确认消息，它将回到队列中由另一个客户端处理。这种架构的微妙之处在于，允许两个工人接收相同的调度的小时间窗口，等等。</p><p id="170f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">甚至像Redis这样不把自己标榜为消息代理的应用程序也支持发布/订阅消息。正如您所看到的，围绕消息代理的产品和服务的列表非常庞大。</p><p id="1d4e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每一种产品都有它们的亮点，它们闪耀的地方。Kafka在使用持久消息日志的大规模消息流和聚合场景中展示了自己的实力。Rabbit在需要更简单的发布/订阅功能和消息代理范围之外的工作的强制幂等性的环境中茁壮成长。如果您的所有消息客户端都与Redis进行缓存，并且您不需要持久化消息，Redis甚至可能是一个很好的选择。</p><p id="2f94" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我真的想拥抱“中枢神经系统”的想法，但我不想所有的其他解决方案的开销呢？如果我想既能进行传统的发布/订阅，又能请求/回复，甚至分散-收集，同时又保持事物的敏捷和轻便，该怎么办？这就是NATS 可能更适合的地方。</p><p id="94d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">NATS是一个令人难以置信的快速，开放源码的消息传递系统，建立在一个简单，但功能强大，核心。该服务器使用基于文本的协议，因此虽然有许多特定语言的客户端库，但您可以真正地进入NATS服务器并发送和接收消息。NATS被设计成永远在线、连接并随时接受命令。如果你的年龄足够大，知道什么是“<em class="jo">拨号音</em>”，那么值得一提的是，NATS的文档喜欢用这个比喻来描述这个设计。</p><p id="2051" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了感受在NATS上构建应用程序的感觉，让我们来看几个常见的用例。</p><h1 id="f847" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">发布和订阅</h1><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kr"><img src="../Images/37f928b5ba16dc23f8760f049f184590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-EM19k7-NwFAGdHwt1hzMw.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Publish/Subscribe Pattern</figcaption></figure><p id="186a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在最简单的发布/订阅模型中，我们有一个发布者向主题为<em class="jo">的</em>发布消息(尽管您可能更熟悉术语<em class="jo">主题</em>)。任何对该主题的消息感兴趣的人都可以订阅它。NATS将保证<em class="jo">最多一次</em>交货。这意味着从单个发布者发送的消息保证按顺序到达，但是在多个发布者之间不保持顺序。我将把“全球信息排序”的兔子洞讨论留到以后的博客文章中，因为这场辩论可能会持续几天。</p><p id="98e7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设我们正在构建一个进行面部识别的视频分析系统。当分析器在一大块媒体上取得进展时，我们希望将进展发布给任何可能感兴趣的人。</p><p id="815d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为NATS是一种文本协议，所以您可以发出类似如下的命令:</p><pre class="ks kt ku kv fd la js lb lc aw ld bi"><span id="0c9c" class="le ju hh js b fi lf lg l lh li">PUB analysis.progress 55<br/>{"hash": "abc56fghe", id: 12, progress: 32, faces: 78}<br/><strong class="js hi">+OK</strong></span></pre><p id="326b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们告诉NATS主题(<code class="du jp jq jr js b">analysis.progress</code>)和内容长度(55字节)。然后，在实际数据之前和之后有一个换行符。如果一切顺利，NATS给了我们一个<code class="du jp jq jr js b">+OK</code>的回应。这与一些消息代理使用的复杂甚至专有的二进制协议形成了鲜明的对比。当我们可以用POSTman插件轻松调试RESTful服务时，我们的感觉类似于我可以远程登录到我的NATS服务器时的感觉。</p><p id="1a17" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要订阅，我们创建一个具有唯一主题标识符的订阅(主题ID是我的连接的私有ID):</p><pre class="ks kt ku kv fd la js lb lc aw ld bi"><span id="0e86" class="le ju hh js b fi lf lg l lh li">SUB analysis.progress 50</span></pre><p id="b591" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这意味着主题ID 50代表对<code class="du jp jq jr js b">analysis.progress</code>的订阅。每个订户都会收到一条类似这样的消息:</p><pre class="ks kt ku kv fd la js lb lc aw ld bi"><span id="c5b1" class="le ju hh js b fi lf lg l lh li">MSG analysis.progress 50 55<br/>{"hash": "abc56fghe", id: 12, progress: 32, faces: 78}</span></pre><p id="0206" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与发布一样，仅用一个简单的换行符/回车符组合就将有效负载与元数据分开了。每个<code class="du jp jq jr js b">MSG</code>协议消息包含主题ID和原始消息的内容长度。</p><p id="6c8a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与其他一些代理相比，在某些情况下，我们必须在服务开始之前编写管理脚本来提前创建主题。卡夫卡要求显式创建主题，兔子也是如此，而雷迪斯和NATS让你在飞行中创建频道和主题(它们各自的术语)。</p><p id="3c2d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种按需创建主题的能力是启用请求-应答语义的关键。</p><h1 id="f50c" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">请求-回复</h1><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/e723183c0a89bb6a2dade5464f712886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*exiAGO87XqIdpQ2TkOJ9FA.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Request — Reply Pattern</figcaption></figure><p id="ef6f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们进行RESTful服务调用时，我们向服务发出HTTP请求，然后得到回复，我们使用的是传统的同步请求-响应模式。</p><p id="f84e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于许多消息传递系统，请求-应答模式通常很困难，或者需要一些非常笨拙且负担沉重的妥协。使用NATS，请求-回复是一个相当简单的操作，包括在发布消息时提供一个“回复”主题。</p><p id="7c64" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是在基于NATS的请求-回复场景中发生的事情的分解，在该场景中，我们想要请求出现特定人物的视频列表。这里要记住的一件重要的事情是，我们不知道我们要求的信息是谁的。我们所做的只是发布我们对答案的渴望，而系统会满足我们的要求。这种松散耦合令人难以置信地增强了我们的能力，给了我们极大的灵活性来升级和增强系统，而不需要发布“停止世界”的版本。</p><ol class=""><li id="3be0" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated">发布者订阅一个主题，例如<code class="du jp jq jr js b">vididentify.reply</code></li><li id="7300" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">然后，发布者发送一条主题为<code class="du jp jq jr js b">vididentify.inquiry</code>的消息，并包含“回复”主题的名称:<code class="du jp jq jr js b">vididentify.reply</code></li><li id="25ca" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">然后，Publisher会等待一段时间来接收单个响应</li><li id="0c23" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">出版商取消了对<code class="du jp jq jr js b">vididentify.reply</code>主题的兴趣</li><li id="f6f6" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">发布者相应地处理响应</li></ol><p id="39ac" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了防止相同类型的多个并发请求相互干扰，并确保处理请求的任何代码只回复给负责该消息的单个请求发布者，每个请求的“回复”主题是唯一的，通常带有GUID后缀。例如，我们可以发布如下视频识别查询请求:</p><pre class="ks kt ku kv fd la js lb lc aw ld bi"><span id="9af1" class="le ju hh js b fi lf lg l lh li">PUB vididentify.inquiry vididentify.reply.1b807ae3-bc12-42ab-b667-ccbd6c677745 25<br/>{ "person_id": 4237249 }<br/><strong class="js hi">+OK</strong></span></pre><p id="7b97" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种复杂性几乎总是由特定于语言的客户端来处理。例如，<strong class="ir hi"> Go </strong>客户端完全隐藏了回复主题的创建:</p><pre class="ks kt ku kv fd la js lb lc aw ld bi"><span id="c4b0" class="le ju hh js b fi lf lg l lh li">nc, err := nats.Connect(*urls) <br/>if err != nil { <br/> log.Fatalf("Can't connect: %v\n", err) <br/>}</span><span id="706e" class="le ju hh js b fi ly lg l lh li">defer nc.Close()<br/>// get payload...</span><span id="3212" class="le ju hh js b fi ly lg l lh li"><strong class="js hi">msg, err := nc.Request("vididentify.inquiry",<br/>                       []byte(payload), 100*time.Millisecond)</strong></span></pre><p id="be70" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将发布一个请求，并等待100毫秒的答复。Go库对开发人员隐藏了回复主题的详细信息。它还隐藏了对回复主题的订阅和取消订阅。如果您正在使用的库没有为您实现这一点，那么创建一个实现这一点的包装器是相当容易的。</p><h1 id="d2b6" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">分散-聚集</h1><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/0479101f0fd920566e671e397bf570d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_o4YVxCTmTdnPyuV7g7QRA.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx">Scatter — Gather Pattern</figcaption></figure><p id="c4b9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在分散-聚集模式中，单个发布者同时向未知数量的订阅者发布关于某个主题的消息。假设所有的监听器都将开始工作。然后，发布者等待部分或全部订阅者的回复，然后以某种方式汇总结果。</p><p id="cd41" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设我有几千架无人机组成了我的包裹递送设备舰队。有一个递送包裹的请求，我想选择我要使用的无人机。“用老方法”做事，我可以迭代所有无人机的已知列表，通过缓慢且潜在不可靠的网络单独询问每一个无人机，然后当我完成这个循环时，我可以最终根据剩余电池、重量容量和当前位置做出决定。这很慢，容易出错，而且效率非常低。</p><p id="d6cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了解决这个问题，我们可以使用<a class="ae jn" href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/BroadcastAggregate.html" rel="noopener ugc nofollow" target="_blank"> <em class="jo">来代替</em> </a>。我就<code class="du jp jq jr js b">package.auction</code>话题发布一条消息如下:</p><pre class="ks kt ku kv fd la js lb lc aw ld bi"><span id="d41d" class="le ju hh js b fi lf lg l lh li">PUB package.auction auction.d5e979a1-bf54-4baf-abdc-c91d451898c5.replies (content-length)<br/>{ "pkg_weight": 12.5, "dest_address": {...}, "priority": "A"}<br/><strong class="js hi">+OK</strong></span></pre><p id="8b72" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，我们仍然使用一个独特的回复主题。这允许舰队中的所有监听无人机回复这个特定的拍卖请求，并且不干扰同时处理的任何其他拍卖请求。</p><p id="49db" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那些没有收到消息的人显然不是好的选择，那些没有在我们预期的超时时间内回复的人也不是。消息可能会像这样返回:</p><pre class="ks kt ku kv fd la js lb lc aw ld bi"><span id="f749" class="le ju hh js b fi lf lg l lh li">MSG auction.d5e979a1-bf54-4baf-abdc-c91d451898c5.replies 50 (content-length)<br/>{"drone_id":12345,"est_batt_remaining":12.34,"capacity":30, ...}</span></pre><p id="df22" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我们可以收集在超时期限内收到的所有结果，并根据无人机电池寿命、位置、容量以及在投放结束时它可能剩余的电池量，从回复中做出决定。</p><h1 id="df75" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">摘要</h1><p id="5472" class="pw-post-body-paragraph ip iq hh ir b is ma iu iv iw mb iy iz ja mc jc jd je md jg jh ji me jk jl jm ha bi translated">让NATS如此强大的不是它的复杂性，而是它的简单性。我对简约的优雅情有独钟(日本人对此有个词，<a class="ae jn" href="http://www.romajidesu.com/dictionary/meaning-of-%E6%9E%AF%E6%B7%A1.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi"> <em class="jo">【古田】</em> </strong> </a>)，而NATS很好地体现了这一点。通过保持底层协议的简单性，通过关注性能和云原生可靠性，我们可以构建各种真正强大的消息传递模式，而不必硬塞笨拙的功能或在更大的产品中承载大量未使用的功能。</p><p id="4add" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">希望这篇文章已经启发了你，不仅要看看NATS，还要用批判的眼光评估你的消息代理需要的复杂程度。如果你想尝试NATS，你可以去拿起<a class="ae jn" href="https://nats.io/documentation/tutorials/gnatsd-docker/" rel="noopener ugc nofollow" target="_blank"> gnatsd docker图片</a>开始摆弄它。</p></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><p id="83a9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jo">声明:以上观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为Capital One 2018。</em></p></div></div>    
</body>
</html>