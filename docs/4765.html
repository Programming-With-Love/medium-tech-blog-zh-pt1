<html>
<head>
<title>Testing Software: What is TDD?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试软件:什么是TDD？</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/testing-software-what-is-tdd-459b2145405c?source=collection_archive---------2-----------------------#2020-01-13">https://medium.com/javascript-scene/testing-software-what-is-tdd-459b2145405c?source=collection_archive---------2-----------------------#2020-01-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="cfb0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">问答式实用介绍</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/e4ab0c7c55491b091fc77f76dbeced25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FIJ5iySPhnCgvsz5NqLzA.png"/></div></div></figure><p id="e2f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">测试驱动开发</strong>是一个软件开发过程，遵循以下步骤:</p><ol class=""><li id="45f9" class="jo jp hh ig b ih ii il im ip jq it jr ix js jb jt ju jv jw bi translated">为一个需求写一个失败的测试。</li><li id="1bd9" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">实现足够的代码来通过测试。</li><li id="20fa" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">自信地重构(如果需要的话)。</li></ol><h1 id="5689" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">TDD &amp;科学方法</h1><p id="6c38" class="pw-post-body-paragraph ie if hh ig b ih la ij ik il lb in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">TDD就像是科学方法，但是对于软件来说。科学方法是我们了解世界的方式。它是这样工作的:</p><ol class=""><li id="b3f6" class="jo jp hh ig b ih ii il im ip jq it jr ix js jb jt ju jv jw bi translated">做个观察。</li><li id="d576" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">问一个关于观察的问题。</li><li id="323b" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">对观察结果形成一个假设或可检验的解释。</li><li id="696d" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">根据假设做一个<strong class="ig hi">预测</strong>。</li><li id="14a4" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">测试预测。</li><li id="8262" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">迭代:使用结果做出新的假设或预测。</li></ol><p id="55cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们将其分解为更简单的元素:</p><ol class=""><li id="67c2" class="jo jp hh ig b ih ii il im ip jq it jr ix js jb jt ju jv jw bi translated">问题</li><li id="8218" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated"><strong class="ig hi">预测</strong></li><li id="3e2a" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">实验</li><li id="9425" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">科目</li></ol><p id="2e17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了TDD，我们不是在学习关于世界的东西，而是在创造一个符合我们规范的新世界。我们不是从对现实世界的观察开始，而是从一个需求开始。TDD颠倒了这个过程。我们没有了解真实世界，而是调整科学方法来创造一个新的世界。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="8401" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">科学方法和TDD的关键因素是<strong class="ig hi">预测</strong>。通过预测，我们消除了事后诸葛亮的可能性。在结果已经知道之后，人们经常相信他们可以预测到结果:他们一直都知道。在代码中，后见之明偏差可能会产生更为隐蔽的影响:您的代码可能会产生错误的输出，但您可能会认为它是正确的输出。</p><p id="0bfd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">后见之明偏差是快照测试的常见现象，快照测试是一种在事情发生变化时提醒您的测试形式，而不是在事情出错时提醒您。如果您刚刚对代码进行了更改，并且快照测试提醒您有更改，那么您已经预料到了该警告，并且您偏向于相信结果是正确的，这使您容易接受不正确的结果。</p><p id="4198" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是效果并不局限于快照测试。通常，在实现完成后添加测试时，开发人员倾向于接受程序生成的输出，而不仔细检查手动计算的结果。</p><p id="44cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">TDD迫使我们对预期的输出进行预测性的计算，因为产生实际输出的代码还不存在。马后炮偏见没有机会影响我们的判断。</p><p id="ddc7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">记住这一点，我们可以增强我们的TDD过程:</p><ol class=""><li id="d4d5" class="jo jp hh ig b ih ii il im ip jq it jr ix js jb jt ju jv jw bi translated">将需求转化为可证伪的测试。</li><li id="2333" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated"><strong class="ig hi">根据需求预测</strong>预期产量。</li><li id="87a6" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">运行测试以获得实际输出。第一次应该<em class="lh">失败</em>。如果通过，请转到步骤1。</li><li id="1047" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">编写实现。这次测试应该<em class="lh">通过</em>。如果失败，重复此步骤。</li><li id="cc33" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb jt ju jv jw bi translated">继续下一个需求，从第1步开始重复。</li></ol><h1 id="b7d2" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">TDD优势</h1><ul class=""><li id="5d52" class="jo jp hh ig b ih la il lb ip li it lj ix lk jb ll ju jv jw bi translated">消除对变化的恐惧。如果代码变更引入了一个bug，开发人员会很快得到警告，TDD的紧密反馈环会在它被修复时很快通知他们。</li><li id="7921" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb ll ju jv jw bi translated"><strong class="ig hi">安全网</strong>让持续部署更加安全。测试失败会暂停部署过程，让您可以在客户有机会看到错误之前修复它们。</li><li id="af88" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb ll ju jv jw bi translated"><a class="ae lm" href="https://www.researchgate.net/publication/3249271_Guest_Editors'_Introduction_TDD--The_Art_of_Fearless_Programming" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">减少40% — 80%的bug</strong></a><strong class="ig hi">。</strong></li><li id="ed66" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb ll ju jv jw bi translated"><a class="ae lm" href="https://ieeexplore.ieee.org/abstract/document/4343755" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">比事后编写测试更好的代码覆盖率</strong> </a>。因为我们创建代码来进行特定的测试，所以代码覆盖率将接近100%。</li><li id="c219" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb ll ju jv jw bi translated"><strong class="ig hi">更快的开发者反馈循环。</strong>没有TDD，开发人员必须手工测试每一个变更，以确保它能够工作。使用TDD，单元测试可以根据变化自动运行，在开发和调试阶段提供更快的反馈。</li><li id="a6d6" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb ll ju jv jw bi translated"><strong class="ig hi">界面设计辅助:</strong>开发者在考虑使用软件组件的开发者体验之前，往往会先考虑软件的实现。TDD扭转了这一局面，迫使开发人员在实现之前设计API。</li><li id="4d7c" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb ll ju jv jw bi translated">吻和YAGNI是两个重叠的软件设计原则——“保持简单，笨蛋”和“你不会需要它”。接吻的意思就像它听起来的意思一样。保持事情简单。YAGNI的意思是不要构建特性和抽象，除非那些特性服务于特定的<em class="lh">现有需求</em>(不是未来需求)。TDD通过迫使你在小的迭代中工作，在需要的基础上一次处理一个需求，来帮助这个过程。</li></ul><h1 id="d1dd" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">TDD成本</h1><p id="eefd" class="pw-post-body-paragraph ie if hh ig b ih la ij ik il lb in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated">没有TDD经验的用户可能会发现他们的速度慢了15%-30%，但是经过1-2年的实践，TDD的实时反馈过程可以提高生产率。</p><h1 id="e69b" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">技巧</h1><ul class=""><li id="9586" class="jo jp hh ig b ih la il lb ip li it lj ix lk jb ll ju jv jw bi translated"><strong class="ig hi">预测先于实现。</strong>(快照和测试后不符合TDD的条件)。</li><li id="4779" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb ll ju jv jw bi translated"><strong class="ig hi">使用小迭代。一次测试并构建一个需求。</strong></li><li id="5e12" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb ll ju jv jw bi translated">自信地重构，但只在需要的时候。</li><li id="b459" class="jo jp hh ig b ih jx il jy ip jz it ka ix kb jb ll ju jv jw bi translated"><strong class="ig hi">学习TDD就是学习模块化app架构的过程。通常需要1-2年的练习才能熟练掌握。耐心点。关于模块化应用程序架构，TDD教会了我大部分知识。</strong></li></ul><h1 id="4760" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">问题和答案</h1><blockquote class="ln lo lp"><p id="4fc9" class="ie if lh ig b ih ii ij ik il im in io lq iq ir is lr iu iv iw ls iy iz ja jb ha bi translated">100%的代码覆盖率合理吗？</p></blockquote><p id="d12a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">仅仅使用单元测试来达到100%的代码覆盖率是不合理的，因为大量代码的存在是为了将你的应用与其他服务相集成，比如网络、磁盘、用户显示器等等。单元测试最适合确定性的纯函数:给定相同的输入，函数总是返回相同的输出，没有任何外部可见状态的变化。</p><p id="6a8e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这使得你的一部分代码没有被单元测试覆盖。这就是功能测试和其他类型的集成测试出现的地方。功能和集成测试确保您的代码单元相互集成。</p><p id="ce09" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">单元测试的覆盖率越接近100%，就越难提高单元测试的覆盖率。在某种程度上，你会发现自己越来越困难，这使得你的代码更容易出错，更难维护。</p><p id="ace9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为手头的工作选择正确的测试类型可以帮助你避免编写不必要模拟的诱惑。它还可以帮助您避免不必要的依赖注入，从而使您的代码保持简单。你不应该为了单元测试而使你的代码复杂化。</p><p id="812e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">经验法则: TDD应该让你的代码更简单，而不是更复杂。</p><p id="b6e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总之:100%的覆盖率是好的，但是你应该通过单元、集成和功能测试的组合来实现。为手头的工作使用正确的测试。</p><blockquote class="ln lo lp"><p id="ce58" class="ie if lh ig b ih ii ij ik il im in io lq iq ir is lr iu iv iw ls iy iz ja jb ha bi translated">应该使用TDD进行视觉造型吗？</p></blockquote><p id="7ad8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不。相反，视觉回归和快照工具可以帮助您测试视觉样式。视觉设计往往变化频繁，而且往往主观多于客观。对某样东西应该是什么样子以及如何通过标记和样式来实现这种样子做出科学的预测是很有挑战性的。如果用户界面改变了，视觉回归工具可以提醒你，但是设计者应该批准或拒绝改变，而不是计算机。请记住，快照式回归测试并不<em class="lh">也不</em>符合TDD的标准。视觉快照可以增强您的过程，但不能取代TDD。</p><blockquote class="ln lo lp"><p id="d651" class="ie if lh ig b ih ii ij ik il im in io lq iq ir is lr iu iv iw ls iy iz ja jb ha bi translated">出于可访问性的考虑，应该使用TDD吗？</p></blockquote><p id="94b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">是啊！诸如<em class="lh">“我们使用了正确的语义标记吗？”</em>和<em class="lh">“组件是否有正确的</em> <a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA" rel="noopener ugc nofollow" target="_blank"> <em class="lh">咏叹调</em> </a> <em class="lh">提示？”</em>可轻松进行单元测试。</p><blockquote class="ln lo lp"><p id="9c6d" class="ie if lh ig b ih ii ij ik il im in io lq iq ir is lr iu iv iw ls iy iz ja jb ha bi translated">有时，新的需求与已经通过测试的现有需求重叠。我该如何处理？</p></blockquote><p id="bba7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">无论现有的代码是否已经覆盖了一个测试用例，您仍然希望显式地添加新的测试用例，因为测试有助于记录API的需求。当这种情况发生时，您可以注释掉使测试通过的代码，编写新的测试，观察它失败，并取消注释代码以观察测试再次通过。看到每一个测试失败是很重要的，因为如果你从来没有看到一个测试失败，你就不知道这个测试是否有效。</p><blockquote class="ln lo lp"><p id="5376" class="ie if lh ig b ih ii ij ik il im in io lq iq ir is lr iu iv iw ls iy iz ja jb ha bi translated">有时，函数输出很难或不可能预测。使用TDD过程，我如何知道如何预测期望值？</p></blockquote><p id="7d8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">遇到真的无法预测函数调用结果的情况应该不多见。</p><p id="dc9e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">这通常是一种代码味道，表明函数是不确定的。</strong>例如，该函数使用当前系统时间或生成一个随机数。</p><p id="081f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为函数生成的数据创建可选的参数覆盖，如日期或随机数。</p><pre class="jd je jf jg fd lt lu lv lw aw lx bi"><span id="0d81" class="ly kd hh lu b fi lz ma l mb mc">import cuid from 'cuid';</span><span id="3f10" class="ly kd hh lu b fi md ma l mb mc">const createTodo = ({ description, date = Date.now(), id = cuid() }) =&gt; ({<br/>  type: 'createTodo',<br/>  payload: { description, date }<br/>});</span></pre><p id="c591" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您没有传入<code class="du me mf mg lu b">date</code>或<code class="du me mf mg lu b">id</code>，它将在调用时生成它们。在您的单元测试中，您可以传递它们以获得确定性的输出。</p><p id="b56e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">有时候，你只是不熟悉API的行为方式。</strong>可能没有很好的文档记录，或者可能需要很长时间才能找到文档。在这些情况下，我通常会从一个故意错误的期望开始，查看实际的输出，然后将输出复制并粘贴到测试的期望中。</p><p id="1937" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了测试这个测试，我将注释掉实现代码并确保没有它测试会失败，然后恢复注释并再次观察测试是否通过。请记住，这种类型的测试比预测驱动的测试更弱，因为你跳过了科学过程中的关键预测步骤，并引入了后见之明偏差的可能性。</p><blockquote class="ln lo lp"><p id="cce3" class="ie if lh ig b ih ii ij ik il im in io lq iq ir is lr iu iv iw ls iy iz ja jb ha bi translated">我应该在我的git历史中捕获TDD过程吗？</p></blockquote><p id="59b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不。良好的测试覆盖率足以保证TDD过程是有效的。像“特性x的单元测试”这样的提交只会弄乱你的git历史，并使你脱离你在代码中所做的工作流程。</p><p id="06c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当你在构建特性时，你的思想应该在你写的代码上，而不是为了过程而过程。就像你应该保持你的代码简单一样，你也应该保持你的过程简单。</p><p id="1a13" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，您可以使用一个监视脚本，在每次保存文件时自动运行您的测试。您不必执行任何额外的步骤来查看您的代码是否有效。在开发控制台中编写实现代码并检查测试输出，整个过程都处于构建代码的流程中。您不需要停止编写代码，手动运行测试，然后任务切换回编写代码。不要让自己从真正的工作中分心。</p><blockquote class="ln lo lp"><p id="8de2" class="ie if lh ig b ih ii ij ik il im in io lq iq ir is lr iu iv iw ls iy iz ja jb ha bi translated">当我们重构代码时，很多测试会开始失败。我们应该重构测试，还是编写新的？</p></blockquote><p id="a6f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个问题暴露了“重构”这个词的一个常见误用重构并不意味着“任何代码改变”相反，“重构”意味着我们正在改变被测单元的内部结构，而不改变它的外部行为。使用黑盒测试，这意味着对于每个代码单元(不考虑粒度)，您只测试该单元的API的表面区域。</p><p id="cf6d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不要编写知道内部实现细节的测试。例如，如果您正在为一个新的数据结构测试一个map方法，不要检查数据结构本身，因为如果您这样做了，并且您后来更改了数据结构，那么您的测试将会失败，即使外部行为没有改变。</p><p id="2b72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当你重构被测单元时，测试不应该中断。只有当单元的行为需求改变时，单元测试才应该中断。例如，您开始返回一个数组，后来发现您需要返回一个键控对象。在那个阶段，你需要做出选择。重构现有的测试或者重写它们会需要更多的工作吗？</p><p id="09e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有时需求变化如此之大，以至于现有的测试代码不是很有用。在这些情况下，您仍然应该仔细检查需求，并决定哪些适用于新的行为，哪些不适用。记下你需要测试的所有适用需求，然后废弃你不需要的测试。</p><h1 id="1d56" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">后续步骤</h1><p id="6991" class="pw-post-body-paragraph ie if hh ig b ih la ij ik il lb in io ip lc ir is it ld iv iw ix le iz ja jb ha bi translated"><strong class="ig hi"> TDD Day </strong>是一个全天(5小时)的团队入职网络广播录制，将向您的团队传授TDD基本知识，并提供大量由Q &amp; A驱动的实用建议，这些建议来自像您这样的团队——与迪士尼互动、Spotify、网飞、PayPal和亚马逊等团队使用的优质培训相同。</p><p id="9463" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">EricElliottJS.com的<a class="ae lm" href="https://ericelliottjs.com" rel="noopener ugc nofollow" target="_blank">成员可以观看TDD日视频，还有大量关于函数式编程、React、Redux等主题的内容。Shotgun系列让您观看我构建真正的生产应用程序，因此您可以看到TDD过程的运行。</a></p><p id="cb03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae lm" href="https://ericelliottjs.com/purchase/register" rel="noopener ugc nofollow" target="_blank">今天报名</a>。</p></div><div class="ab cl mh mi go mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ha hb hc hd he"><p id="efaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="lh">艾里克·艾略特</em> </strong> <em class="lh">著有《书籍》、</em> <a class="ae lm" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="lh">【排版软件】</em></a><em class="lh"/><a class="ae lm" href="https://pjabook.com/" rel="noopener ugc nofollow" target="_blank"><em class="lh">【编程JavaScript应用】</em> </a> <em class="lh">。作为</em><a class="ae lm" href="https://ericelliottjs.com/" rel="noopener ugc nofollow" target="_blank"><em class="lh">【EricElliottJS.com】</em></a><em class="lh">和</em><a class="ae lm" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank"><em class="lh">devanywhere . io</em></a><em class="lh">的联合创始人，他教授开发者必备的软件开发技能。他为加密项目组建开发团队并提供建议，为Adobe Systems、</em> <strong class="ig hi"> <em class="lh">、Zumba Fitness、</em> </strong> <em class="lh"> </em> <strong class="ig hi"> <em class="lh">【华尔街日报、</em></strong><em class="lh"/><strong class="ig hi"><em class="lh">【ESPN、</em></strong><em class="lh"/><strong class="ig hi"><em class="lh">BBC、</em> </strong> <em class="lh">以及包括</em> <strong class="ig hi"> <em class="lh"> Usher、弗兰克·奥申、金属乐队在内的顶级录音</em></strong></p><p id="5f19" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>