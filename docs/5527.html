<html>
<head>
<title>From locally running Node application to Cloud based Kubernetes Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从本地运行的节点应用程序到基于云的Kubernetes部署</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/from-locally-running-node-application-to-cloud-based-kubernetes-deployment-1fed34280952?source=collection_archive---------0-----------------------#2018-11-16">https://medium.com/oracledevs/from-locally-running-node-application-to-cloud-based-kubernetes-deployment-1fed34280952?source=collection_archive---------0-----------------------#2018-11-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="aa13" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我将讨论我必须经历的步骤，以便获得我的本地运行的节点应用程序——具有各种硬编码，有时是秘密值——并将其部署在基于云的Kubernetes集群上。我将讨论应用程序的容器化、用对环境变量的引用替换硬编码值、Docker容器图像操作、创建用于创建Kubernetes资源的Kubernetes yaml文件，以及应用程序的实际执行。</p><h1 id="df13" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">背景</h1><p id="d2eb" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">几天前，在东京，我出席了当地的J-JUG活动，这是甲骨文亚太区开拓之旅的一部分。我准备了一个非常好的演示:一个基于云的Oracle数据库的更新被复制到另一个基于云的数据库——MongoDB数据库。在这个演示中，我首先使用Twitter作为交换更新事件的媒介，然后使用Oracle Event Hub(托管Apache Kafka)云服务。</p><p id="0577" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这张照片形象化了我想做的事情:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/1c5c5dc65268df6637a1b11020a98ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/0*8tG8zrIz8PMw_mE_.png"/></div></figure><p id="690a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，我的演示失败了。我运行了一个本地节点(JS)应用程序，该应用程序将通过HTTP从Oracle数据库中调用，并发布到Twitter和Kafka。当我在酒店房间里做演示的时候，一切都很好。我使用ngrok在公共互联网上公开我的本地运行的应用程序——这是在跨云演示中轻松集成本地服务的一个好方法。结果是，我做演讲的甲骨文日本办公室的网络配置不允许使用ngrok。我无法让我的笔记本电脑创建到ngrok服务的隧道，以允许它传递来自Oracle数据库的HTTP请求。</p><p id="e06a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这给了我一个教训。不管在本地运行有多方便，我真的应该能够让这个演示的所有组件都在云中运行。除了使用无服务器功能之外，最明显的方法是将该应用程序部署在Kubernetes集群上。尽管我知道如何到达那里——我意识到这些步骤并没有像应该的那样在我的头脑和手指中根深蒂固——特别是为了在不到30分钟的时间里让我的演示恢复往日的辉煌。</p><h1 id="4d89" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">行动计划</h1><p id="0b3d" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我的演示应用程序——有些快速地组合在一起——包含相当多的硬编码值，包括机密设置，如Kafka服务器IP地址和主题名称，以及Twitter应用程序凭证。我需要采取的第一步是从应用程序代码中删除所有这些硬编码的值，并用对环境变量的引用来替换它们。</p><p id="0735" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个重要步骤是为我的应用程序构建一个容器。这个容器需要提供节点运行时，拥有应用程序使用的所有npm模块，并包含应用程序代码本身。容器应该自动启动应用程序，并公开正确的端口。在这一步结束时，我应该能够在Docker容器中本地运行我的应用程序——用Docker run命令注入环境变量的值。</p><p id="8cb5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第三步是从容器创建一个容器映像——并将该映像(在有意义的标记之后)推送到容器注册中心。</p><p id="5f43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来是Kubernetes资源的准备。我的应用程序由一个Pod和一个服务(用Kubernetes的术语来说)组成，它们组合在一个部署中，位于自己的名称空间中。部署使用了两个秘密——一个包含Kafka服务器的机密值(IP地址和主题名),另一个包含Twitter客户端应用程序凭证。这些秘密的值用于设置一些环境变量。其他值在部署定义中是硬编码的。</p><p id="7d34" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在安排了对Kubernetes集群实例(运行在Oracle云基础设施中，通过Oracle Kubernetes引擎(OKE)服务提供)的访问之后，我可以部署K8S资源并使应用程序运行。现在，我终于可以将Oracle数据库触发器指向云中Kubernetes上的服务端点，并开始发布所有相关数据库更新的tweets。</p><p id="7018" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一点上，我应该——在阅读完本文的其余部分后，您也应该——对如何使节点应用程序Kubernetalize有一个很好的理解，这样我就不会在演示中被愚蠢的网络问题所困扰。我想毫不犹豫地将我的本地应用程序转换成运行在Kubernetes上的容器化应用程序。</p><p id="321b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注:本文讨论的来源可以在GitHub上找到:<a class="ae kn" href="https://github.com/lucasjellema/groundbreaker-japac-tour-cqrs-via-twitter-and-event-hub/tree/master/db-synch-orcl-2-mongodb-over-twitter-or-kafka" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/lucasjellema/ground breaker-japac-tour-cqrs-via-Twitter-and-event-hub/tree/master/d b-synch-orcl-2-MongoDB-over-Twitter-or-Kafka</a>。</p><h1 id="409c" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">1.用环境变量引用替换硬编码值</h1><p id="a7bd" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我的应用程序包含Kafka Broker端点的硬编码值和我的Twitter应用程序凭据秘密。对于在本地运行的应用程序来说，这几乎是不可接受的。对于部署在云环境中的应用程序(其源代码发布在GitHub上)，这显然不是一个好主意。</p><p id="4c1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">任何硬编码的值都将从代码中删除，替换为对环境变量的引用，使用节点表达式:</p><p id="a8a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">变量的名称</p><p id="8b25" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">或者</p><p id="a748" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">process.env['变量名称']</p><p id="abc3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们不要担心这些值是如何设置并提供给节点应用程序的。</p><p id="ede8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我已经创建了一个通用代码片段，它将在启动应用程序时检查是否已经定义了所有预期的环境变量，如果没有，则在输出中写入一个警告:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="7cba" class="kt jd hh kp b fi ku kv l kw kx">const REQUIRED_ENVIRONMENT_SETTINGS = [</span><span id="abd9" class="kt jd hh kp b fi ky kv l kw kx">{name:"PUBLISH_TO_KAFKA_YN" , message:"with either Y (publish event to Kafka) or N (publish to Twitter instead)"},</span><span id="3b73" class="kt jd hh kp b fi ky kv l kw kx">{name:"KAFKA_SERVER" , message:"with the IP address of the Kafka Server to which the application should publish"},</span><span id="36d1" class="kt jd hh kp b fi ky kv l kw kx">{name:"KAFKA_TOPIC" , message:"with the name of the Kafka Topic to which the application should publish"},</span><span id="ae32" class="kt jd hh kp b fi ky kv l kw kx">{name:"TWITTER_CONSUMER_KEY" , message:"with the consumer key for a set of Twitter client credentials"},</span><span id="2f9c" class="kt jd hh kp b fi ky kv l kw kx">{name:"TWITTER_CONSUMER_SECRET" , message:"with the consumer secret for a set of Twitter client credentials"},</span><span id="1483" class="kt jd hh kp b fi ky kv l kw kx">{name:"TWITTER_ACCESS_TOKEN_KEY" , message:"with the access token key for a set of Twitter client credentials"},</span><span id="2ef2" class="kt jd hh kp b fi ky kv l kw kx">{name:"TWITTER_ACCESS_TOKEN_SECRET" , message:"with the access token secret for a set of Twitter client credentials"},</span><span id="f8d8" class="kt jd hh kp b fi ky kv l kw kx">{name:"TWITTER_HASHTAG" , message:"with the value for the twitter hashtag to use when publishing tweets"},</span><span id="47ce" class="kt jd hh kp b fi ky kv l kw kx">]</span><span id="c2ea" class="kt jd hh kp b fi ky kv l kw kx">for(var env of REQUIRED_ENVIRONMENT_SETTINGS) {</span><span id="d2d3" class="kt jd hh kp b fi ky kv l kw kx">if (!process.env[env.name]) {</span><span id="4824" class="kt jd hh kp b fi ky kv l kw kx">console.error(`Environment variable ${env.name} should be set: ${env.message}`);</span><span id="525b" class="kt jd hh kp b fi ky kv l kw kx">} else {</span><span id="c296" class="kt jd hh kp b fi ky kv l kw kx">// convenient for debug; however: this line exposes all environment variable values - including any secret values they may contain</span><span id="ba12" class="kt jd hh kp b fi ky kv l kw kx">// console.log(`Environment variable ${env.name} is set to : ${process.env[env.name]}`);</span><span id="9e91" class="kt jd hh kp b fi ky kv l kw kx">}</span><span id="929e" class="kt jd hh kp b fi ky kv l kw kx">}</span></pre><p id="c2a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个片段用于我的节点应用程序中的<a class="ae kn" href="https://github.com/lucasjellema/groundbreaker-japac-tour-cqrs-via-twitter-and-event-hub/blob/master/db-synch-orcl-2-mongodb-over-twitter-or-kafka/index.js" rel="noopener ugc nofollow" target="_blank"> index.js </a>文件。该文件还包含对process.env的几个引用，这些引用曾经是硬编码的值。</p><p id="d2fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用<em class="kz"> npm start </em>来运行应用程序似乎很方便——例如，因为它允许我们将环境变量定义为应用程序启动的一部分。当您执行<em class="kz"> npm start </em>时，npm将检查package.json文件中是否有带“start”键的脚本。该脚本通常包含类似“node index”或“node index.js”的内容。您可以在运行节点应用程序之前，使用要应用的环境变量的定义来扩展该脚本，如下所示(取自package.json):</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="acb5" class="kt jd hh kp b fi ku kv l kw kx">"scripts": { "start": "(export KAFKA_SERVER=myserver.cloud.com &amp;&amp; export KAFKA_TOPIC=cool-topic ) || (set KAFKA_SERVER=myserver.cloud.com &amp;&amp; set KAFKA_TOPIC=cool-topic &amp;&amp; set TWITTER_CONSUMER_KEY=very-secret )&amp;&amp; node index", … },</span></pre><p id="aaee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:我们可能需要适应Linux和Windows环境，它们对环境变量的处理是不同的。</p><h1 id="77e5" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">2.容器化节点应用程序</h1><p id="473c" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在我的例子中，我在我的Windows笔记本电脑上工作，从Windows命令行开发和测试节点应用程序。显然，这不是构建和运行Docker容器的理想环境。我所做的是使用流浪者运行一个虚拟机，里面有Docker引擎。所有Docker容器操作都可以在这个虚拟机中轻松完成。</p><p id="782d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">查看指导vagger利用VirtualBox创建和运行所需虚拟机的vagger文件。请注意，本地目录包含了travel file，并且从该目录执行了<em class="kz">travel up</em>命令，该目录被自动共享到VM中，挂载为/travel。</p><p id="fbbb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:我用这篇文章作为我文章的这一部分的灵感:<a class="ae kn" href="https://nodejs.org/en/docs/guides/nodejs-docker-webapp/" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/en/docs/guides/nodejs-docker-webapp/</a>。</p><p id="b58c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意2:我使用dockerignore文件来排除包含Dockerfile的根文件夹中的文件和目录。dockerignore中列出的任何内容都不会添加到构建上下文中，也不会出现在容器中。</p><p id="fa0e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Docker容器映像是使用Docker构建文件构建的。Docker的起点是随后扩展的基础映像。在这种情况下，基本映像是node:10.13.0-alpine，这是一个小型的最新节点运行时环境。我创建了一个目录/usr/src/app，并让Docker将这个目录设置为所有后续操作的焦点。</p><p id="6257" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Docker容器图像是分层创建的。docker文件中的每个构建步骤都会添加一个层。如果重新运行构建，则仅重新运行docker文件中已更改的步骤的层，并且在推送映像时仅实际上载已更改的层。因此，将变化最大的步骤放在Dockerfile文件的末尾是明智的。在我的例子中，这意味着应用程序源代码应该在构建过程的后期复制到容器映像中。</p><p id="3bc6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我只复制package.json文件——假设这个文件不会经常改变。在复制package.json之后，立即使用<em class="kz"> npm install </em>将所有节点模块安装到容器映像中。</p><p id="db31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">只有这样，应用程序源才会被复制。我选择从容器中公开端口8080——这是一个非常武断的决定。然而，环境变量PORT——其值是使用process.env.PORT在index.js中读取的——需要与我公开的任何端口完全对应。</p><p id="669f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，容器运行时运行节点应用程序的指令:<em class="kz"> npm start </em>传递给CMD指令。</p><p id="93e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下是完整的Dockerfile文件:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="ded9" class="kt jd hh kp b fi ku kv l kw kx"># note: run docker build in a directory that contains this Docker build file, the package.json file and all your application sources and static files <br/># this directory should NOT contain the node-modules or any other resources that should not go into the Docker container - unless these are explicitly excluded in a .Dockerignore file! </span><span id="4ae5" class="kt jd hh kp b fi ky kv l kw kx">FROM node:10.13.0-alpine</span><span id="c54b" class="kt jd hh kp b fi ky kv l kw kx"># Create app directory</span><span id="d8f2" class="kt jd hh kp b fi ky kv l kw kx">WORKDIR /usr/src/app</span><span id="5733" class="kt jd hh kp b fi ky kv l kw kx"># Install app dependencies</span><span id="a098" class="kt jd hh kp b fi ky kv l kw kx"># A wildcard is used to ensure both package.json AND package-lock.json are copied</span><span id="14d0" class="kt jd hh kp b fi ky kv l kw kx"># where available (npm@5+)</span><span id="f9ef" class="kt jd hh kp b fi ky kv l kw kx">COPY package*.json ./</span><span id="7275" class="kt jd hh kp b fi ky kv l kw kx">RUN npm install</span><span id="0503" class="kt jd hh kp b fi ky kv l kw kx"># Bundle app source - copy Node application from the current directory</span><span id="6877" class="kt jd hh kp b fi ky kv l kw kx">COPY . .</span><span id="0fb2" class="kt jd hh kp b fi ky kv l kw kx"># the application will be exposed at port 8080</span><span id="bb60" class="kt jd hh kp b fi ky kv l kw kx">ENV PORT=8080</span><span id="15ad" class="kt jd hh kp b fi ky kv l kw kx">#so we should expose that port</span><span id="00f5" class="kt jd hh kp b fi ky kv l kw kx">EXPOSE 8080</span><span id="3efd" class="kt jd hh kp b fi ky kv l kw kx"># run the application, using npm start (which runs the start script in package.json)</span><span id="38ad" class="kt jd hh kp b fi ky kv l kw kx">CMD [ "npm", "start" ]</span></pre><p id="9800" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行docker build —确切地说，我运行:docker build-t lucasjellema/http-to-Twitter-app。—给出以下输出:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es la"><img src="../Images/937b9262b49c9d08cdd3fbe85c04bb0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/0*7ELQUUVC1a1FTN0s.png"/></div></figure><p id="81e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">容器图像被创建。</p><p id="ba47" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我现在可以运行容器本身，例如:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="8e8e" class="kt jd hh kp b fi ku kv l kw kx">docker run -p 8090:8080 -e KAFKA_SERVER=127.1.1.1 -e KAFKA_TOPIC=topic -e TWITTER_CONSUMER_KEY=818 -e TWITTER_CONSUMER_SECRET=secret -e TWITTER_ACCESS_TOKEN_KEY=tokenkey -e TWITTER_ACCESS_TOKEN_SECRET=secret lucasjellema/http-to-twitter-app</span></pre><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lb"><img src="../Images/e097d37d17aeadaf6704db29a933491d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9iZAaISngGiE17y8.png"/></div></div></figure><p id="2c53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">容器正在运行，应用程序正在运行，并且在Docker主机上的端口8090，我应该能够访问应用程序:<a class="ae kn" href="http://192.168.188.120:8090/about" rel="noopener ugc nofollow" target="_blank">http://192.168.188.120:8090/about</a>(而不是:192 . 168 . 188 . 120是由vagger管理的虚拟机暴露的IP地址)</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lb"><img src="../Images/d187efe511faaf366c3d87ba0be8b447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PZhD7aDp0eh0YeYp.png"/></div></div></figure><h1 id="a39c" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">3.构建、标记和推送容器映像</h1><p id="3212" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">为了在Kubernetes集群上运行一个容器——或者实际上是在构建它的机器上运行——这个容器必须被共享或发布。最简单的方法是使用容器(映像)注册中心，比如Docker Hub。在这种情况下，我只是用当前适用的标签lucasjellema/http-to-Twitter-app:0.9:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="cd10" class="kt jd hh kp b fi ku kv l kw kx">docker tag lucasjellema/http-to-twitter-app:latest lucasjellema/http-to-twitter-app:0.9</span></pre><p id="ede1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我将标记的图像推送到Docker Hub注册表:(注意:在执行该语句之前，我已经使用docker login将我的会话连接到Docker Hub):</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="b319" class="kt jd hh kp b fi ku kv l kw kx">docker push lucasjellema/http-to-twitter-app:0.9</span></pre><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lb"><img src="../Images/2834919c213925bfd0bb704d8ac7b782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S5l9YyAMx2DpLo2l.png"/></div></div></figure><p id="02bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一点上，节点应用程序是公开可用的——并且可以在任何Docker兼容的容器引擎上运行。它不包含任何秘密——所有依赖项(比如Twitter凭证和Kafka配置)都需要通过环境变量设置来注入。</p><h1 id="cbc8" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">4.准备Kubernetes资源(Pod、服务、机密、名称空间、部署)</h1><p id="a390" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">当节点应用程序在Kubernetes上运行时，它应该有许多组成部分:</p><ul class=""><li id="06d5" class="lg lh hh ig b ih ii il im ip li it lj ix lk jb ll lm ln lo bi translated">一个名称空间<em class="kz"> cqrs-demo </em>将其他工件隔离在它们自己的区间中</li><li id="0d32" class="lg lh hh ig b ih lp il lq ip lr it ls ix lt jb ll lm ln lo bi translated">两个秘密提供了关于Kafka和关于Twitter客户端凭证的敏感的、动态的、特定于部署的细节</li><li id="aa8d" class="lg lh hh ig b ih lp il lq ip lr it ls ix lt jb ll lm ln lo bi translated">单个容器的Pod带有节点应用程序</li><li id="1bcb" class="lg lh hh ig b ih lp il lq ip lr it ls ix lt jb ll lm ln lo bi translated">服务—在(外部)可访问的端点上公开Pod，并将请求导向Pod公开的端口</li><li id="375e" class="lg lh hh ig b ih lp il lq ip lr it ls ix lt jb ll lm ln lo bi translated">部署<em class="kz">http-to-Twitter-app</em>——通过用于扩展和重新部署的模板来配置Pod</li></ul><p id="c8c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">单独的名称空间cqrs-demo是用一个简单的kubectl命令创建的:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="f949" class="kt jd hh kp b fi ku kv l kw kx">kubectl create namespace cqrs-demo</span></pre><p id="a595" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这两个秘密是两组敏感数据条目。每个条目都有一个键和一个值，当然这个值是敏感的。对于本文中的应用程序，我已经确保只有秘密对象包含敏感信息。任何其他工件中都没有密码、端点和凭证。所以我可以自由地分享其他文件——甚至在GitHub上。但不是秘密文件。它们包含有价值的货物。</p><p id="c633" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:即使这些秘密看起来是加密的——在这种情况下，它们不是。它们只包含实际值的base64表示。这些base64b值可以在Linux命令行上使用以下命令轻松检索:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="f185" class="kt jd hh kp b fi ku kv l kw kx">echo -n '&lt;value&gt;' | base64</span></pre><p id="57e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些秘密是从这些yaml文件中创建的:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="88a5" class="kt jd hh kp b fi ku kv l kw kx">apiVersion: v1</span><span id="744b" class="kt jd hh kp b fi ky kv l kw kx">kind: Secret</span><span id="025e" class="kt jd hh kp b fi ky kv l kw kx">metadata:</span><span id="070e" class="kt jd hh kp b fi ky kv l kw kx">name: twitter-app-credentials-secret</span><span id="fb35" class="kt jd hh kp b fi ky kv l kw kx">namespace: cqrs-demo</span><span id="9f32" class="kt jd hh kp b fi ky kv l kw kx">type: Opaque</span><span id="9514" class="kt jd hh kp b fi ky kv l kw kx">data:</span><span id="46f0" class="kt jd hh kp b fi ky kv l kw kx">CONSUMER_KEY: U0hh</span><span id="2968" class="kt jd hh kp b fi ky kv l kw kx">CONSUMER_SECRET: dT=</span><span id="cbed" class="kt jd hh kp b fi ky kv l kw kx">ACCESS_TOKEN_KEY: ODk=</span><span id="66bf" class="kt jd hh kp b fi ky kv l kw kx">ACCESS_TOKEN_SECRET: aUZv</span></pre><p id="a879" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">和</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="8d3c" class="kt jd hh kp b fi ku kv l kw kx">apiVersion: v1</span><span id="1ce0" class="kt jd hh kp b fi ky kv l kw kx">kind: Secret</span><span id="e7d6" class="kt jd hh kp b fi ky kv l kw kx">metadata:</span><span id="4455" class="kt jd hh kp b fi ky kv l kw kx">name: kafka-server-secret</span><span id="ebac" class="kt jd hh kp b fi ky kv l kw kx">namespace: cqrs-demo</span><span id="6f98" class="kt jd hh kp b fi ky kv l kw kx">type: Opaque</span><span id="8ae0" class="kt jd hh kp b fi ky kv l kw kx">data:</span><span id="6f1a" class="kt jd hh kp b fi ky kv l kw kx">kafka-server-endpoint: MTI5</span><span id="9997" class="kt jd hh kp b fi ky kv l kw kx">kafka-topic: aWRj</span></pre><p id="c32b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用这些kubectl语句:</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="dd9f" class="kt jd hh kp b fi ku kv l kw kx">kubectl create -f ./kafka-secret.yaml kubectl create -f ./twitter-app-credentials-secret.yaml</span></pre><p id="ba9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Kubernetes仪表盘显示了两个秘密:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lb"><img src="../Images/00d97d18ffa2de013e5fe111439ed108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V3Y7QUmAahUqTvD1.png"/></div></div></figure><p id="2593" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">和一些细节(但不是敏感值):</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lu"><img src="../Images/3e5d9930ae7e614dc17ced5ed94c6175.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/0*Gxw_F9YLpZ3Yot6u.png"/></div></figure><p id="5022" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">文件k8s-deployment.yml包含服务和部署的定义，并通过部署间接包含pod。</p><p id="defb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该服务被定义为LoadBalancer类型。这导致Oracle Kubernetes引擎在一个特殊的外部IP地址上分配给这个服务。这可能被认为有些浪费。更好的方法是使用Ingres controller——它允许我们在外部IP地址上处理多个服务。对于当前示例，LoadBalancer就可以了。注意:当您在不支持LoadBalancer的环境(如minikube)中运行Kubernetes工件时，您可以将LoadBalancer类型更改为NodePort类型。然后，将随机端口分配给该服务，该服务将在K8S集群的IP地址上的该端口上可用。</p><p id="c389" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该服务在端口80对外公开——尽管其他端口也很好。该服务在<em class="kz"> cqrs-demo </em>名称空间中使用逻辑名<em class="kz"> app-api-port </em>连接到容器端口。这个端口是为<em class="kz"> http-to-twitter-app </em>部署中的<em class="kz"> http-to-twitter-app </em>容器定义而定义的。注意:对于此单个容器定义，可以启动多个容器，具体取决于部署中指定的副本数量，例如取决于正在进行的(重新)部署问题。服务机制确保流量在公开app-api-port的所有容器实例之间实现负载平衡。</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="d526" class="kt jd hh kp b fi ku kv l kw kx">kind: Service</span><span id="0028" class="kt jd hh kp b fi ky kv l kw kx">apiVersion: v1</span><span id="df35" class="kt jd hh kp b fi ky kv l kw kx">metadata:</span><span id="28e0" class="kt jd hh kp b fi ky kv l kw kx">name: http-to-twitter-app</span><span id="5554" class="kt jd hh kp b fi ky kv l kw kx">namespace: cqrs-demo</span><span id="7ef3" class="kt jd hh kp b fi ky kv l kw kx">labels:</span><span id="3ccb" class="kt jd hh kp b fi ky kv l kw kx">k8s-app: http-to-twitter-app</span><span id="7f80" class="kt jd hh kp b fi ky kv l kw kx">kubernetes.io/name: http-to-twitter-app</span><span id="b39a" class="kt jd hh kp b fi ky kv l kw kx">spec:</span><span id="5fff" class="kt jd hh kp b fi ky kv l kw kx">selector:</span><span id="c3cb" class="kt jd hh kp b fi ky kv l kw kx">k8s-app: http-to-twitter-app</span><span id="2bf7" class="kt jd hh kp b fi ky kv l kw kx">ports:</span><span id="3f9e" class="kt jd hh kp b fi ky kv l kw kx">- protocol: TCP</span><span id="9486" class="kt jd hh kp b fi ky kv l kw kx">port: 80</span><span id="77fc" class="kt jd hh kp b fi ky kv l kw kx">targetPort: app-api-port</span><span id="5874" class="kt jd hh kp b fi ky kv l kw kx">type: LoadBalancer</span><span id="6ba9" class="kt jd hh kp b fi ky kv l kw kx"># with type LoadBalancer, an external IP will be assigned - if the K8S provider supports that capability, such as OKE</span><span id="b82b" class="kt jd hh kp b fi ky kv l kw kx"># with type NodePort, a port is exposed on the cluster; whether that can be accessed or not depends on the cluster configuration; on Minikube it can be, in many other cases an IngressController may have to be configured</span></pre><p id="d962" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建服务后，需要一些时间(最多几分钟)才能将外部IP地址与服务(的负载平衡器)相关联。外部ip将显示为<em class="kz">待定</em>。下面是分配了外部IP地址时仪表盘中的样子，尽管我模糊了大部分实际IP地址)</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lv"><img src="../Images/dd662a121acf21352dbcabd1630ce7f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/0*rdaHBPMl85bAuBzh.png"/></div></div></figure><p id="2d60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在的部署只指定了一个副本。它指定了这个部署中的容器(实例)所基于的容器映像:lucasjellema/http-to-Twitter-app:0.9。这当然是我在上一节中推送的容器映像。容器公开了端口8080(容器端口)，这个端口被赋予了逻辑名<em class="kz"> app-api-port </em>，我们之前已经看到过。</p><p id="a8d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我使用的K8S集群实例有一个从域名到IP地址的DNS转换问题。最初，我的应用程序不能工作，因为URL api.twitter.com不能被转换成IP地址。我没有试图修复这个DNS问题，而是利用了Kubernetes中一个名为hostAliases的内置特性。这个特性允许我们指定在运行时添加到容器中的hosts文件的DNS条目。在本例中，我指示Kubernetes将api.twitter.com及其IP地址之间的映射注入到容器的hosts文件中。</p><p id="b2cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，容器模板指定了一系列环境变量值。这些在启动时被注入到容器中。te环境变量的一些值是在部署定义中逐字定义的。其他包含对secrets中条目的引用，例如TWITTER_CONSUMER_KEY的值是使用CONSUMER_KEY密钥从twitter-app-credentials-secret派生的。</p><pre class="kg kh ki kj fd ko kp kq kr aw ks bi"><span id="1c5e" class="kt jd hh kp b fi ku kv l kw kx">apiVersion: extensions/v1beta1</span><span id="1a49" class="kt jd hh kp b fi ky kv l kw kx">kind: Deployment</span><span id="d563" class="kt jd hh kp b fi ky kv l kw kx">metadata:</span><span id="769c" class="kt jd hh kp b fi ky kv l kw kx">labels:</span><span id="4d52" class="kt jd hh kp b fi ky kv l kw kx">k8s-app: http-to-twitter-app</span><span id="3561" class="kt jd hh kp b fi ky kv l kw kx">name: http-to-twitter-app</span><span id="454e" class="kt jd hh kp b fi ky kv l kw kx">namespace: cqrs-demo</span><span id="0069" class="kt jd hh kp b fi ky kv l kw kx">spec:</span><span id="f9d0" class="kt jd hh kp b fi ky kv l kw kx">replicas: 1</span><span id="8551" class="kt jd hh kp b fi ky kv l kw kx">strategy:</span><span id="5f54" class="kt jd hh kp b fi ky kv l kw kx">rollingUpdate:</span><span id="9922" class="kt jd hh kp b fi ky kv l kw kx">maxSurge: 1</span><span id="8636" class="kt jd hh kp b fi ky kv l kw kx">maxUnavailable: 1</span><span id="6c25" class="kt jd hh kp b fi ky kv l kw kx">type: RollingUpdate</span><span id="3180" class="kt jd hh kp b fi ky kv l kw kx">template:</span><span id="bac8" class="kt jd hh kp b fi ky kv l kw kx">metadata:</span><span id="bc60" class="kt jd hh kp b fi ky kv l kw kx">labels:</span><span id="daa7" class="kt jd hh kp b fi ky kv l kw kx">k8s-app: http-to-twitter-app</span><span id="3691" class="kt jd hh kp b fi ky kv l kw kx">spec:</span><span id="bdca" class="kt jd hh kp b fi ky kv l kw kx">hostAliases:</span><span id="117d" class="kt jd hh kp b fi ky kv l kw kx">- ip: "104.244.42.66"</span><span id="c508" class="kt jd hh kp b fi ky kv l kw kx">hostnames:</span><span id="ffbb" class="kt jd hh kp b fi ky kv l kw kx">- "api.twitter.com"</span><span id="9ee2" class="kt jd hh kp b fi ky kv l kw kx">containers:</span><span id="ef1e" class="kt jd hh kp b fi ky kv l kw kx">-</span><span id="d2bd" class="kt jd hh kp b fi ky kv l kw kx">image: "lucasjellema/http-to-twitter-app:0.9"</span><span id="3e52" class="kt jd hh kp b fi ky kv l kw kx">imagePullPolicy: Always</span><span id="e262" class="kt jd hh kp b fi ky kv l kw kx">name: http-to-twitter-app</span><span id="8839" class="kt jd hh kp b fi ky kv l kw kx">ports:</span><span id="d266" class="kt jd hh kp b fi ky kv l kw kx">-</span><span id="abb4" class="kt jd hh kp b fi ky kv l kw kx">containerPort: 8080</span><span id="5dff" class="kt jd hh kp b fi ky kv l kw kx">name: app-api-port</span><span id="dc5c" class="kt jd hh kp b fi ky kv l kw kx">protocol: TCP</span><span id="d912" class="kt jd hh kp b fi ky kv l kw kx">env:</span><span id="0df1" class="kt jd hh kp b fi ky kv l kw kx">-</span><span id="46a1" class="kt jd hh kp b fi ky kv l kw kx">name: PUBLISH_TO_KAFKA_YN</span><span id="d7f0" class="kt jd hh kp b fi ky kv l kw kx">value: "N"</span><span id="484c" class="kt jd hh kp b fi ky kv l kw kx">-</span><span id="ce09" class="kt jd hh kp b fi ky kv l kw kx">name: TWITTER_HASHTAG</span><span id="590a" class="kt jd hh kp b fi ky kv l kw kx">value: "#GroundbreakersTourOrderEvent"</span><span id="3110" class="kt jd hh kp b fi ky kv l kw kx">-</span><span id="7e87" class="kt jd hh kp b fi ky kv l kw kx">name: TWITTER_CONSUMER_KEY</span><span id="209f" class="kt jd hh kp b fi ky kv l kw kx">valueFrom:</span><span id="2283" class="kt jd hh kp b fi ky kv l kw kx">secretKeyRef:</span><span id="fcbd" class="kt jd hh kp b fi ky kv l kw kx">name: twitter-app-credentials-secret</span><span id="aa6f" class="kt jd hh kp b fi ky kv l kw kx">key: CONSUMER_KEY</span><span id="babe" class="kt jd hh kp b fi ky kv l kw kx">-</span><span id="70ed" class="kt jd hh kp b fi ky kv l kw kx">name: TWITTER_CONSUMER_SECRET</span><span id="e9f2" class="kt jd hh kp b fi ky kv l kw kx">valueFrom:</span><span id="1d8b" class="kt jd hh kp b fi ky kv l kw kx">secretKeyRef:</span><span id="1bdd" class="kt jd hh kp b fi ky kv l kw kx">name: twitter-app-credentials-secret</span><span id="a9b6" class="kt jd hh kp b fi ky kv l kw kx">key: CONSUMER_SECRET</span><span id="af09" class="kt jd hh kp b fi ky kv l kw kx">-</span><span id="9f34" class="kt jd hh kp b fi ky kv l kw kx">name: TWITTER_ACCESS_TOKEN_KEY</span><span id="a6ee" class="kt jd hh kp b fi ky kv l kw kx">valueFrom:</span><span id="9196" class="kt jd hh kp b fi ky kv l kw kx">secretKeyRef:</span><span id="54f4" class="kt jd hh kp b fi ky kv l kw kx">name: twitter-app-credentials-secret</span><span id="63b4" class="kt jd hh kp b fi ky kv l kw kx">key: ACCESS_TOKEN_KEY</span><span id="d104" class="kt jd hh kp b fi ky kv l kw kx">-</span><span id="cf84" class="kt jd hh kp b fi ky kv l kw kx">name: TWITTER_ACCESS_TOKEN_SECRET</span><span id="201e" class="kt jd hh kp b fi ky kv l kw kx">valueFrom:</span><span id="4620" class="kt jd hh kp b fi ky kv l kw kx">secretKeyRef:</span><span id="43ef" class="kt jd hh kp b fi ky kv l kw kx">name: twitter-app-credentials-secret</span><span id="46bb" class="kt jd hh kp b fi ky kv l kw kx">key: ACCESS_TOKEN_SECRET</span><span id="8563" class="kt jd hh kp b fi ky kv l kw kx">-</span><span id="06c1" class="kt jd hh kp b fi ky kv l kw kx">name: KAFKA_SERVER</span><span id="5028" class="kt jd hh kp b fi ky kv l kw kx">valueFrom:</span><span id="1d33" class="kt jd hh kp b fi ky kv l kw kx">secretKeyRef:</span><span id="ff92" class="kt jd hh kp b fi ky kv l kw kx">name: kafka-server-secret</span><span id="5178" class="kt jd hh kp b fi ky kv l kw kx">key: kafka-server-endpoint</span><span id="d002" class="kt jd hh kp b fi ky kv l kw kx">-</span><span id="c614" class="kt jd hh kp b fi ky kv l kw kx">name: KAFKA_TOPIC</span><span id="a1a3" class="kt jd hh kp b fi ky kv l kw kx">valueFrom:</span><span id="632c" class="kt jd hh kp b fi ky kv l kw kx">secretKeyRef:</span><span id="7e64" class="kt jd hh kp b fi ky kv l kw kx">name: kafka-server-secret</span><span id="e024" class="kt jd hh kp b fi ky kv l kw kx">key: kafka-topic</span></pre><p id="651a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">仪表板中的部署:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lw"><img src="../Images/ae9502c9ab5bc42bb745f9be30d0a605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oa7zQXDc5PlE9Og3.png"/></div></div></figure><p id="a1d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pod的详细信息:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lx"><img src="../Images/08c192ced9cd3e3d025fee1d596db993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/0*El4in_qsYd7aFHCp.png"/></div></figure><p id="d36e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">给定管理员权限，我可以检查从secrets派生的环境变量的真实值。</p><p id="e10d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pod日志记录也很容易访问:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lb"><img src="../Images/b13dfb2d8e1d5dd1bbaefe8f76ae7841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gsfKRZNLhbuRpkGv.png"/></div></div></figure><h1 id="ef3b" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">5.运行并试用该应用程序</h1><p id="33b6" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">当外部IP已经分配给服务并且Pod成功运行时，可以访问应用程序。从Oracle数据库，也可以从任何浏览器:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lb"><img src="../Images/8e717df84fbf8d9ee6ba9d105cab40f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3EoGuGXjbdqW-BKn.png"/></div></div></figure><p id="e779" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">地址栏中的公共IP地址模糊不清。请注意，在URL中没有指定端口——因为端口将默认为yo 80，而这恰好是服务中定义的端口，作为映射到容器的公开端口(8080)的端口。</p><p id="0be4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当数据库发出HTTP请求时，我们可以在Pod日志中看到请求已被处理:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ly"><img src="../Images/1430ca0273f4bfce32d353eb809c2484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/0*tpo0HP5XUmP3q1F1.png"/></div></figure><p id="60e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我甚至可以验证它已经完成了应用程序在日志中声明的工作:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lz"><img src="../Images/3da9c72d3f6fc4f774757f1b75816347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6dPOgaMEIbviu066.png"/></div></div></figure><h1 id="fb15" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">资源</h1><p id="cf51" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">GitHub来源:<a class="ae kn" href="https://github.com/lucasjellema/groundbreaker-japac-tour-cqrs-via-twitter-and-event-hub" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/lucasjellema/ground breaker-japac-tour-cqrs-via-Twitter-and-event-hub</a></p><p id="b746" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">面向Docker开发者的kubernetes cheat sheet:<a class="ae kn" href="https://technology.amis.nl/2018/09/26/from-docker-run-to-kubectl-apply-quick-kubernetes-cheat-sheet-for-docker-users/" rel="noopener ugc nofollow" target="_blank">https://technology . amis . nl/2018/09/26/from-Docker-run-to-kubectl-apply-quick-kubernetes-cheat-sheet-for-Docker-users/</a></p><p id="ceaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">库伯内特关于秘密的文件:【https://kubernetes.io/docs/concepts/configuration/secret/ T2】</p><p id="f0b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Kubernetes关于主机别名的文档:<a class="ae kn" href="https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/Docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-Host-Aliases/</a></p><p id="fd66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">dockerrignore上的docker docs<a class="ae kn" href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/engine/reference/builder/# dockerrignore-file</a></p><p id="b716" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Kubernetes关于部署的文档:<a class="ae kn" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/Docs/concepts/workloads/controllers/Deployment/</a></p></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="926f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kz">原载于2018年11月16日</em><a class="ae kn" href="https://technology.amis.nl/2018/11/16/from-locally-running-node-application-to-cloud-based-kubernetes-deployment/" rel="noopener ugc nofollow" target="_blank"><em class="kz">technology . amis . nl</em></a><em class="kz">。</em></p></div></div>    
</body>
</html>