<html>
<head>
<title>DIY Google Cloud Storage replication using Cloud Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用云功能DIY Google云存储复制</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/diy-google-cloud-storage-replication-using-cloud-functions-51ae3a7124a7?source=collection_archive---------1-----------------------#2021-11-25">https://medium.com/google-developer-experts/diy-google-cloud-storage-replication-using-cloud-functions-51ae3a7124a7?source=collection_archive---------1-----------------------#2021-11-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/6b14515c405ed44f761eca67885172ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEnvnXJWVR8LAG0I01-VlQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Image from Google</figcaption></figure><p id="565f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">9月14日，谷歌云开放了多伦多地区，作为一名多伦多人，我欣喜若狂——期待已久的第二个加拿大地区终于到来了！但是，虽然这提供了更多的解决方案，但其中一些解决方案需要更多的创造力和对构成谷歌云平台(GCP)的基本构件的理解。</p><h1 id="c23d" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">介绍</h1><p id="971a" class="pw-post-body-paragraph it iu hh iv b iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ku jo jp jq ha bi translated">我是一名云顾问，我们的客户主要是受监管的行业，如银行、卫生或政府。大多数都有必须遵守的法规遵从性，最常见的是数据必须保留在加拿大境内，因为通常涉及个人身份信息(PII)和/或个人健康信息(PHI)的处理。拥有第二个区域意味着备份和灾难恢复(DR)有了一条可行的前进道路。然而，在谷歌云存储(GCS)的情况下，加拿大地区桶还没有双区域或多区域复制选项(从我与一些谷歌员工的交谈中，这似乎没有出现在他们的路线图上)。正如你可能从我的文章标题中猜到的那样，我将展示一个解决方案，通过使用<a class="ae jr" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank">云功能</a>来完成你自己的复制。</p><h1 id="0061" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">先决条件</h1><p id="ed23" class="pw-post-body-paragraph it iu hh iv b iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ku jo jp jq ha bi translated">在GCP端，您需要启用API:</p><ul class=""><li id="4a72" class="kv kw hh iv b iw ix ja jb je kx ji ky jm kz jq la lb lc ld bi translated"><strong class="iv hi">云函数API </strong></li><li id="0771" class="kv kw hh iv b iw le ja lf je lg ji lh jm li jq la lb lc ld bi translated"><strong class="iv hi">云构建API </strong></li></ul><p id="f3e0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我还设置了两个区域GCS存储桶——蒙特利尔的源存储桶和多伦多的复制存储桶。我构建GCS buckets的方式是在相同的名称上添加一个位置后缀(即<em class="lj"> my-bucket-mtl </em>和<em class="lj"> my-bucket-tor </em>)。云函数将从源存储桶中去除源位置，并附加复制的存储桶位置。这绝不是一个硬性要求，但是您应该以某种方式组织您的存储桶的命名，以允许云函数很容易地重用，几乎不需要修改。</p><p id="1944" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">云存储事件只会在同一个项目中触发云函数，所以要确保你的源GCS bucket和云函数在同一个项目中。对于这个例子，复制的GCS bucket也将在同一个项目中。</p><p id="3242" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您的云功能使用的服务帐户(默认:<em class="lj">PROJECT _ ID</em>@ appspot . gserviceaccount . com)将需要<strong class="iv hi">roles/storage . object admin</strong>权限，因为它将在复制的GCS存储桶中创建/删除对象。</p><h1 id="63fb" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">代码</h1><p id="dcf0" class="pw-post-body-paragraph it iu hh iv b iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ku jo jp jq ha bi translated">为这两个云函数分别创建一个文件夹。它们都应该包含一个<code class="du lk ll lm ln b">requirements.txt</code>和<code class="du lk ll lm ln b">main.py</code>(我使用的是Python运行时):</p><ul class=""><li id="edac" class="kv kw hh iv b iw ix ja jb je kx ji ky jm kz jq la lb lc ld bi translated"><code class="du lk ll lm ln b">requirements.txt</code>(两种功能通用)</li></ul><pre class="lo lp lq lr fd ls ln lt lu aw lv bi"><span id="b3ee" class="lw jt hh ln b fi lx ly l lz ma">google-cloud-storage==1.42.3</span></pre><ul class=""><li id="9de8" class="kv kw hh iv b iw ix ja jb je kx ji ky jm kz jq la lb lc ld bi translated"><code class="du lk ll lm ln b">main.py</code> ( <em class="lj"> copy_to_tor_gcs </em>函数)</li></ul><figure class="lo lp lq lr fd ii"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="562f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">用<code class="du lk ll lm ln b">gcloud</code>部署函数，指定源桶为触发资源，触发事件为<code class="du lk ll lm ln b">google.storage.object.finalize</code>，一旦创建(或覆盖)对象就会触发:</p><pre class="lo lp lq lr fd ls ln lt lu aw lv bi"><span id="56c1" class="lw jt hh ln b fi lx ly l lz ma">gcloud functions deploy copy_to_tor_gcs \<br/>  --runtime python39 \<br/>  --entry-point copy_to_gcs \<br/>  --trigger-resource my-bucket-mtl \<br/>  --trigger-event google.storage.object.finalize \<br/>  --region northamerica-northeast1 \<br/>  --memory 128MB</span></pre><ul class=""><li id="fc4d" class="kv kw hh iv b iw ix ja jb je kx ji ky jm kz jq la lb lc ld bi translated"><code class="du lk ll lm ln b">main.py</code>(<em class="lj">delete _ from _ tor _ GCS</em>函数)</li></ul><figure class="lo lp lq lr fd ii"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="5bfb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">对于<em class="lj"> delete_from_tor_gcs </em>函数，触发事件将改为<code class="du lk ll lm ln b">google.storage.object.delete</code>。如果您想了解更多可用的其他类型的触发器，请参见<a class="ae jr" href="https://cloud.google.com/functions/docs/calling/storage" rel="noopener ugc nofollow" target="_blank"> GCS触发器</a>文档页面。</p><h1 id="ab26" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">为什么此解决方案是合规的</h1><p id="19bb" class="pw-post-body-paragraph it iu hh iv b iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ku jo jp jq ha bi translated">云功能是一种区域性资源，但是利用HTTP触发器的可能不是，因为数据/有效负载将通过谷歌前端(GFE)传递，这可能在您的地区或国家之外。在我们的例子中，我们使用的是通过<a class="ae jr" href="https://cloud.google.com/storage/docs/pubsub-notifications" rel="noopener ugc nofollow" target="_blank">发布/订阅通知</a>发送的GCS事件触发器。Pub/Sub可能是一项全球服务，但它会选择最近的允许区域，并且随着您的GCS存储桶和云功能本地化到加拿大区域，Pub/Sub也应该使用这些区域之一。</p><h1 id="cc46" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">局限性/陷阱</h1><ol class=""><li id="576e" class="kv kw hh iv b iw kq ja kr je md ji me jm mf jq mg lb lc ld bi translated">本文给出的解决方案假设源和复制的bucket都属于同一个项目，但是从技术上来说，复制到不同项目中的GCS bucket也是可能的，但是这需要更多的技巧，我不会在本文中讨论。也许是未来文章的主题。</li><li id="bf77" class="kv kw hh iv b iw le ja lf je lg ji lh jm li jq mg lb lc ld bi translated">只有在部署云功能后添加或删除的对象才会发生复制(和删除)。如果您正在将此应用于预先存在的GCS铲斗，请确保首先运行<code class="du lk ll lm ln b">gsutil rsync</code>。</li><li id="d7bb" class="kv kw hh iv b iw le ja lf je lg ji lh jm li jq mg lb lc ld bi translated">如果源(蒙特利尔)GCS存储桶被删除，它将首先删除其内容，这将触发复制(多伦多)GCS存储桶中每个相应对象的删除。如果您有一个双区域或多区域存储桶，那么存储桶删除会让您得到相同的结果，但是在您决定删除源存储桶并希望复制的存储桶及其所有内容保持不变的情况下，注意这种行为是很重要的。</li></ol><h1 id="ff02" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">放弃</h1><p id="58c8" class="pw-post-body-paragraph it iu hh iv b iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ku jo jp jq ha bi translated">虽然我在这里描述了一种使用云功能复制GCS存储桶的方法，并提供了关于事件和数据如何传输的见解，但我自己没有经历过任何云存储区域故障，因此我不知道它是否会触发删除事件——常识表明，区域范围的网络丢失(例如)不应在受影响的区域中注册为对象删除，但我也不知道我不知道什么。</p></div><div class="ab cl mh mi go mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ha hb hc hd he"><h1 id="f8ff" class="js jt hh bd ju jv mo jx jy jz mp kb kc kd mq kf kg kh mr kj kk kl ms kn ko kp bi translated">奖金！</h1><p id="61ab" class="pw-post-body-paragraph it iu hh iv b iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ku jo jp jq ha bi translated">我创建了一个<a class="ae jr" href="https://github.com/Neutrollized/pulumi-diy-gcs-replication" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>，它使用<a class="ae jr" href="https://www.pulumi.com/" rel="noopener ugc nofollow" target="_blank"> Pulumi </a>(另一个类似于Terraform的基础设施代码工具)部署我上面描述的设置。</p></div></div>    
</body>
</html>