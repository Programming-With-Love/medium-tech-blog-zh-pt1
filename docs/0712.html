<html>
<head>
<title>Migrating Architecture Blueprints to Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将架构蓝图迁移到Jetpack Compose</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/migrating-architecture-blueprints-to-jetpack-compose-8ffa6615ede3?source=collection_archive---------1-----------------------#2022-04-11">https://medium.com/androiddevelopers/migrating-architecture-blueprints-to-jetpack-compose-8ffa6615ede3?source=collection_archive---------1-----------------------#2022-04-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/0e9f044cded94e01b63d470e888b4c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J2NKRQ4qedvMVWoxL_4ZLA.jpeg"/></div></div></figure><div class=""/><p id="df46" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为我们更新<a class="ae jn" href="http://goo.gle/mad-architecture-guide" rel="noopener ugc nofollow" target="_blank">应用架构指南</a>工作的一部分，我们希望尝试不同的用户界面模式，看看什么最有效，找出备选方案之间的相似性和差异，并最终将这些经验作为最佳实践。</p><p id="60ec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了使我们的发现尽可能容易理解，我们需要一个有熟悉的商业案例并且不太复杂的样本。还有…谁不知道<em class="jo"> TODO </em>应用？我们选择了<a class="ae jn" href="https://github.com/android/architecture-samples" rel="noopener ugc nofollow" target="_blank">建筑蓝图</a>！历史上，蓝图是建筑选择的实验场。这也非常适合！</p><figure class="jq jr js jt fd hj er es paragraph-image"><div class="er es jp"><img src="../Images/1e25812d692fd9e26907d9389fe640d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/1*YAdLGd6Gdq0PGeZLYDH7vA.gif"/></div><figcaption class="ju jv et er es jw jx bd b be z dx"><em class="jy">Architecture Blueprints app in action</em></figcaption></figure><p id="3504" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们想要试验的模式显然受到当今可用的不同API的影响。镇上的新成员是Jetpack Compose的State API！由于Compose可以无缝地与任何<a class="ae jn" href="https://developer.android.com/jetpack/guide/ui-layer#udf" rel="noopener ugc nofollow" target="_blank"> <em class="jo">单向数据流</em>模式</a>一起工作，我们将使用Compose来呈现UI以进行公平的比较。</p><p id="1ee9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">这篇博文讲述了团队如何将架构蓝图移植到Jetpack Compose </strong>的故事。由于在我们的实验中,<a class="ae jn" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank"> LiveData </a>也被认为是一种替代方案，我们保留了迁移时的样本。<strong class="ir ht">在这次重构中，视图模型类和数据层保持不变。</strong></p><p id="90d6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">⚠️:这个基于LiveData的代码库中使用的架构没有完全遵循<a class="ae jn" href="http://goo.gle/mad-architecture-guide" rel="noopener ugc nofollow" target="_blank">最新架构最佳实践</a>。特别是，LiveData <strong class="ir ht">不应该在<a class="ae jn" href="https://developer.android.com/jetpack/guide/data-layer" rel="noopener ugc nofollow" target="_blank">数据</a>或<a class="ae jn" href="https://developer.android.com/jetpack/guide/domain-layer" rel="noopener ugc nofollow" target="_blank">域</a>层中使用</strong>，而应该使用流和协程。</p><p id="0825" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在上下文已经清楚了，让我们深入了解一下我们是如何处理Jetpack Compose的重构蓝图的。你可以在<a class="ae jn" href="https://github.com/android/architecture-samples/tree/dev-compose" rel="noopener ugc nofollow" target="_blank"> dev-compose分支</a>上查看完整的代码。</p><h1 id="de74" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">✍️计划逐步迁移</h1><p id="13e7" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">在进行任何<em class="jo">实际的</em>编码工作之前，团队创建了一个迁移计划，以确保每个人都同意所提议的变更。最终目标是将Blueprints作为单活动应用程序，将屏幕作为可组合功能，并使用推荐的<a class="ae jn" href="https://developer.android.com/jetpack/compose/navigation" rel="noopener ugc nofollow" target="_blank">组合导航</a>库在屏幕之间移动。</p><p id="36c2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">幸运的是，Blueprints已经是一个单活动应用程序，它使用<a class="ae jn" href="https://developer.android.com/guide/navigation" rel="noopener ugc nofollow" target="_blank"> Jetpack导航</a>在用片段实现的不同屏幕之间移动。为了迁移到组合，我们遵循导航<a class="ae jn" href="https://developer.android.com/jetpack/compose/navigation#interoperability" rel="noopener ugc nofollow" target="_blank">互操作性指南</a>，该指南建议混合应用程序使用基于片段的导航组件，并使用片段来保存基于视图的屏幕、组合屏幕以及同时使用视图和组合的屏幕。不幸的是，不可能在同一个导航图中混合片段和组合目的地。</p><p id="5905" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">渐进迁移的目标是简化代码审查，并在整个迁移过程中维护一个可发布的产品。迁移计划包括三个步骤:</p><ol class=""><li id="df3a" class="lc ld hs ir b is it iw ix ja le je lf ji lg jm lh li lj lk bi translated">迁移每个屏幕的<em class="jo">内容</em>进行合成。每个屏幕都可以单独迁移到Compose，包括它们的UI测试。然后片段成为每个迁移屏幕的容器/主机。</li><li id="d813" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">将应用程序迁移到Navigation Compose——从项目中移除所有片段——并将活动UI逻辑迁移到根组件。端到端测试也在此时被迁移。</li><li id="a1bc" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm lh li lj lk bi translated">移除视图系统依赖项。</li></ol><p id="2b82" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是我们所做的！🧑‍💻快进⏩两周时间，我们迁移了<em class="jo">统计</em>屏幕(<a class="ae jn" href="https://github.com/android/architecture-samples/pull/821" rel="noopener ugc nofollow" target="_blank"> PR </a>)、<em class="jo">添加/编辑任务</em>屏幕(<a class="ae jn" href="https://github.com/android/architecture-samples/pull/823" rel="noopener ugc nofollow" target="_blank"> PR </a>)、<em class="jo">任务明细</em>屏幕(<a class="ae jn" href="https://github.com/android/architecture-samples/pull/822" rel="noopener ugc nofollow" target="_blank"> PR </a>)，以及<em class="jo">任务</em>屏幕(<a class="ae jn" href="https://github.com/android/architecture-samples/pull/826" rel="noopener ugc nofollow" target="_blank">PR</a>)；并且我们合并了<a class="ae jn" href="https://github.com/android/architecture-samples/pull/827" rel="noopener ugc nofollow" target="_blank">最终的PR </a>，它迁移了导航和活动逻辑来组合，包括<a class="ae jn" href="https://github.com/android/architecture-samples/pull/827/commits/2810a37c479ef4b23b4cabf095c55df7b342235e" rel="noopener ugc nofollow" target="_blank">移除未使用的视图系统依赖</a>。</p><figure class="jq jr js jt fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/627eb06764101cda8666c493caf4def5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c5F40DoLeO3lrwKp"/></div></div><figcaption class="ju jv et er es jw jx bd b be z dx">How we gradually migrated Blueprints to Compose</figcaption></figure><h1 id="914f" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">💡迁移亮点</h1><p id="a150" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">在迁移过程中，我们遇到了一些值得强调的特定于Compose的问题:</p><h2 id="e8d8" class="lr ka hs bd kb ls lt lu kf lv lw lx kj ja ly lz kn je ma mb kr ji mc md kv me bi translated">🧪 UI测试</h2><p id="42a3" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">一旦你开始向你的应用添加Compose，断言Compose UI的测试需要使用<a class="ae jn" href="https://developer.android.com/jetpack/compose/testing" rel="noopener ugc nofollow" target="_blank"> Compose测试API</a>。</p><p id="3fc9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">对于屏幕级UI测试</strong>，我们没有使用<code class="du mf mg mh mi b"><a class="ae jn" href="https://developer.android.com/guide/fragments/test#create" rel="noopener ugc nofollow" target="_blank">launchFragmentInContainer&lt;FragmentType&gt;</a></code> API，而是使用了<code class="du mf mg mh mi b"><a class="ae jn" href="http://createandroidcomposerule" rel="noopener ugc nofollow" target="_blank">createAndroidComposeRule&lt;ComponentActivity&gt;</a></code> API，它允许我们在测试中获取字符串资源。<strong class="ir ht">这些测试在Espresso和Robolectric </strong>中运行。因为Compose已经支持所有这些，所以不需要额外的修改。例如，您可以比较迁移到<code class="du mf mg mh mi b"><a class="ae jn" href="https://github.com/manuelvicnt/architecture-samples/blob/8a203594541b25e5eec2daac63415c05884242ad/app/src/sharedTest/java/com/example/android/architecture/blueprints/todoapp/addedittask/AddEditTaskScreenTest.kt" rel="noopener ugc nofollow" target="_blank">AddEditTaskScreenTest</a></code>的<code class="du mf mg mh mi b"><a class="ae jn" href="https://github.com/android/architecture-samples/blob/653a563e9fe0874b4ae3fba539ce4b6518a2f796/app/src/sharedTest/java/com/example/android/architecture/blueprints/todoapp/addedittask/AddEditTaskFragmentTest.kt" rel="noopener ugc nofollow" target="_blank">AddEditTaskFragmentTest</a></code>中的代码。注意，如果使用<code class="du mf mg mh mi b">ComponentActivity</code>，需要依赖<code class="du mf mg mh mi b"><a class="ae jn" href="https://developer.android.com/jetpack/compose/testing#setup" rel="noopener ugc nofollow" target="_blank">androidx.compose.ui:ui-test-manifest</a></code>神器。</p><p id="d6e8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">对于端到端或者集成测试</strong>，我们也没有发现任何问题！感谢<strong class="ir ht"> Espresso和Compose互操作性</strong>，我们使用Espresso断言来检查视图，使用Compose APIs来检查Compose UI。下面是<code class="du mf mg mh mi b"><a class="ae jn" href="https://github.com/manuelvicnt/architecture-samples/blob/249a636ea9a3f16aab5c284e3245069ef56a557f/app/src/androidTestMock/java/com/example/android/architecture/blueprints/todoapp/tasks/AppNavigationTest.kt" rel="noopener ugc nofollow" target="_blank">AppNavigationTest</a></code>在迁移过程中如何看待一个点来进行编写。</p><h2 id="8bec" class="lr ka hs bd kb ls lt lu kf lv lw lx kj ja ly lz kn je ma mb kr ji mc md kv me bi translated">🤙视图模型事件</h2><p id="9e8c" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">蓝图中处理<a class="ae jn" href="https://developer.android.com/jetpack/guide/ui-layer/events#handle-viewmodel-events" rel="noopener ugc nofollow" target="_blank">视图模型事件</a>的方式确实有问题。Blueprints实现了一个<a class="ae jn" href="https://github.com/android/architecture-samples/blob/8e1e0527a0d043b41da58925a39fb8e03d62829a/app/src/main/java/com/example/android/architecture/blueprints/todoapp/Event.kt" rel="noopener ugc nofollow" target="_blank">事件包装器</a>解决方案，将<em class="jo">命令</em>从ViewModel发送到UI。然而，这在Compose中并不适用。我们最近的指南<a class="ae jn" href="https://developer.android.com/jetpack/guide/ui-layer/events#handle-viewmodel-events" rel="noopener ugc nofollow" target="_blank">建议</a>将那些“事件”建模为状态，这就是我们在迁移期间所做的。</p><p id="5f7c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">查看<em class="jo">在屏幕上显示消息</em>事件用例，我们将LiveData的<code class="du mf mg mh mi b">Event&lt;Int&gt;</code>类型替换为<code class="du mf mg mh mi b">Int?</code>。这也模拟了没有消息显示给用户的场景。在这个特定的用例中，每当显示消息时，ViewModel还需要来自UI的确认。在下面的代码中可以看到这两种实现之间的区别:</p><figure class="jq jr js jt fd hj"><div class="bz dy l di"><div class="mj mk l"/></div></figure><p id="8a47" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管乍一看这似乎需要更多的工作，但是<strong class="ir ht">保证了</strong>消息显示在屏幕上！</p><p id="3668" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在UI代码中，确保事件只被处理一次的方法是调用<code class="du mf mg mh mi b">event.getContentIfNotHandled()</code>。这种方法在片段中工作<em class="jo">还好</em>但是在编写自然组合代码的时候<strong class="ir ht">它完全中断了组合</strong>！因为在撰写过程中随时都可能发生重新撰写，所以事件包装不是有效的解决方案。如果事件被处理并且函数被重组(在测试这种方法时经常发生)，那么snackbar将被取消，用户可能会错过消息。这是一个不可接受的UX问题！<strong class="ir ht">事件包装解决方案不应用于撰写应用程序。</strong></p><p id="e2c5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，您可以编写代码来避免在某些情况下重新编写部分函数，但是，事件包装解决方案限制了在这种情况下必须如何实现UI。<strong class="ir ht">不鼓励在Compose中使用事件包装解决方案</strong>。</p><p id="b76d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">参见下面的代码片段，在(事件包装器)之前是<em class="jo">，在</em>(作为状态的事件)之后是<em class="jo">。因为在屏幕上显示消息是<a class="ae jn" href="https://developer.android.com/jetpack/guide/ui-layer#logic-types" rel="noopener ugc nofollow" target="_blank"> UI逻辑</a>并且我们的屏幕组件变得越来越复杂，我们使用了<a class="ae jn" href="https://developer.android.com/jetpack/compose/state#types-of-state-and-logic" rel="noopener ugc nofollow" target="_blank">普通状态容器类</a>来管理这种复杂性(例如参见<code class="du mf mg mh mi b"><a class="ae jn" href="https://github.com/manuelvicnt/architecture-samples/blob/88cf650fd1759486cce198878b5cf08e823012dc/app/src/main/java/com/example/android/architecture/blueprints/todoapp/addedittask/AddEditTaskState.kt" rel="noopener ugc nofollow" target="_blank">AddEditTaskState</a></code>)。</em></p><figure class="jq jr js jt fd hj"><div class="bz dy l di"><div class="mj mk l"/></div></figure><h2 id="eeb3" class="lr ka hs bd kb ls lt lu kf lv lw lx kj ja ly lz kn je ma mb kr ji mc md kv me bi translated">👌如有疑问，请选择应用程序正确性</h2><p id="bf95" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">在重构时，迁移手头的所有东西来进行组合可能很有诱惑力。虽然这完全没问题，但你不应该牺牲应用程序的用户体验或正确性。进行渐进式迁移的全部意义在于，应用程序始终处于可交付状态。</p><p id="68de" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们在迁移一些屏幕进行合成时就遇到了这种情况。我们不想同时进行太多的迁移，在从事件包装器迁移之前，我们迁移了一些屏幕来组合<em class="jo">。我们没有在Compose中处理事件包装器并提供次优体验，而是在片段中处理这些消息，而屏幕的其余代码在Compose中处理。例如，参见迁移期间<code class="du mf mg mh mi b"><a class="ae jn" href="https://github.com/manuelvicnt/architecture-samples/blob/249a636ea9a3f16aab5c284e3245069ef56a557f/app/src/main/java/com/example/android/architecture/blueprints/todoapp/tasks/TasksFragment.kt" rel="noopener ugc nofollow" target="_blank">TasksFragment</a></code> <a class="ae jn" href="https://github.com/manuelvicnt/architecture-samples/blob/249a636ea9a3f16aab5c284e3245069ef56a557f/app/src/main/java/com/example/android/architecture/blueprints/todoapp/tasks/TasksFragment.kt" rel="noopener ugc nofollow" target="_blank">的状态。</a></em></p><h1 id="7463" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">🧐挑战</h1><p id="d5fb" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">并非一切都像看上去的那样顺利。🫤尽管将片段内容转换成组合很简单，但是从导航片段迁移到导航组合需要更多的时间和考虑。</p><p id="4adb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有必要扩展和改进不同方面的指南，以便将来更容易迁移到Compose。这项工作引发了对话，我们希望很快有新的指导！🎊</p><p id="1cbf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为导航初学者✋和处理导航合成迁移的人，我面临以下挑战:</p><ul class=""><li id="2991" class="lc ld hs ir b is it iw ix ja le je lf ji lg jm ml li lj lk bi translated">文档中没有代码显示如何用可选参数导航<strong class="ir ht">！感谢<a class="ae jn" href="https://github.com/chrisbanes/tivi/blob/main/app/src/main/java/app/tivi/AppNavigation.kt" rel="noopener ugc nofollow" target="_blank"> Tivi的导航图</a>，我找到了我的方法并解决了问题(在此跟随问题改进文档<a class="ae jn" href="https://issuetracker.google.com/226103829" rel="noopener ugc nofollow" target="_blank">)。</a></strong></li><li id="dbbe" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm ml li lj lk bi translated"><strong class="ir ht">从基于XML的导航图和SafeArgs迁移到Kotlin DSL </strong>应该是一项简单、机械的任务。然而，考虑到我没有参与最初的实现，对我来说<em class="jo">并不那么容易。一些关于如何正确做这件事的指导会对我有所帮助(关注这个问题以改进文档<a class="ae jn" href="https://issuetracker.google.com/226315955" rel="noopener ugc nofollow" target="_blank">这里</a>)。</em></li><li id="5bca" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm ml li lj lk bi translated">这不仅是一个挑战，这一点是一个陷阱！<a class="ae jn" href="https://developer.android.com/guide/navigation/navigation-ui" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">导航UI </strong> </a> <strong class="ir ht">在导航方面已经为你做了一些工作</strong>。因为这在Compose中不可用，所以您需要密切关注并手动完成。例如，当在抽屉的屏幕之间导航时，保持背面清洁需要特殊的<code class="du mf mg mh mi b">NavigationOptions</code>(参见此处的示例<a class="ae jn" href="https://github.com/android/architecture-samples/blob/dev-compose/app/src/main/java/com/example/android/architecture/blueprints/todoapp/TodoNavigation.kt#L79" rel="noopener ugc nofollow" target="_blank"/>)。这是<a class="ae jn" href="https://developer.android.com/jetpack/compose/navigation#bottom-nav" rel="noopener ugc nofollow" target="_blank">已经包含在文档</a>中，但是你需要意识到你需要它！</li></ul><h1 id="15c1" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">🧑‍🏫结论</h1><p id="267e" class="pw-post-body-paragraph ip iq hs ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">总的来说，从导航片段迁移到导航组合是一项有趣的任务！有趣的是，我们花了更多的时间等待同行评审，而不是迁移项目本身！创建迁移计划并让每个人都在同一页面上肯定有助于尽早设定期望，并提醒同行注意冗长的即将到来的评审。</p><p id="debe" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们希望您喜欢阅读我们迁移到Compose的方法，我们期待着分享更多关于我们将在架构蓝图中进行的实验和改进。</p><p id="a244" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您有兴趣查看包含合成代码的蓝图，可以看看<a class="ae jn" href="https://github.com/android/architecture-samples/tree/dev-compose" rel="noopener ugc nofollow" target="_blank">开发-合成分支</a>。如果您想了解逐步迁移的PRs，以下是列表:</p><ul class=""><li id="2fba" class="lc ld hs ir b is it iw ix ja le je lf ji lg jm ml li lj lk bi translated"><em class="jo">统计</em>画面(<a class="ae jn" href="https://github.com/android/architecture-samples/pull/821" rel="noopener ugc nofollow" target="_blank">公关</a>)、</li><li id="abae" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm ml li lj lk bi translated"><em class="jo">添加/编辑任务</em>屏幕(<a class="ae jn" href="https://github.com/android/architecture-samples/pull/823" rel="noopener ugc nofollow" target="_blank"> PR </a>)，</li><li id="2184" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm ml li lj lk bi translated"><em class="jo">任务详情</em>屏幕(<a class="ae jn" href="https://github.com/android/architecture-samples/pull/822" rel="noopener ugc nofollow" target="_blank"> PR </a>)，</li><li id="77c9" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm ml li lj lk bi translated"><em class="jo">任务</em>屏幕(<a class="ae jn" href="https://github.com/android/architecture-samples/pull/826" rel="noopener ugc nofollow" target="_blank"> PR </a>)，以及</li><li id="6ae9" class="lc ld hs ir b is ll iw lm ja ln je lo ji lp jm ml li lj lk bi translated"><a class="ae jn" href="https://github.com/android/architecture-samples/pull/827" rel="noopener ugc nofollow" target="_blank">最终PR </a>迁移导航和活动逻辑进行组合，包括<a class="ae jn" href="https://github.com/android/architecture-samples/pull/827/commits/2810a37c479ef4b23b4cabf095c55df7b342235e" rel="noopener ugc nofollow" target="_blank">移除未使用的视图系统依赖</a>。</li></ul><h1 id="114c" class="jz ka hs bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi">👋</h1></div></div>    
</body>
</html>