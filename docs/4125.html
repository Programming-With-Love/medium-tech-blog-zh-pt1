<html>
<head>
<title>Reactive Programming para Desenvolvedores Android — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适用于 Android 开发人员的 Reactive Programming — Part I</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/reactive-programming-para-desenvolvedores-android-part-i-53788a4fbc9f?source=collection_archive---------0-----------------------#2017-03-01">https://medium.com/google-developer-experts/reactive-programming-para-desenvolvedores-android-part-i-53788a4fbc9f?source=collection_archive---------0-----------------------#2017-03-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="21c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我如此喜欢软件开发领域的一件事,特别是在谈论Android应用程序开发时,是事物变化的速度带来了新的有趣的工具和技术。</p><p id="acd4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">近年来,函数式响应式编程(特别是适用于 Java 和 Android 的 RX Java 库)一直是 Android 开发社区中讨论最多的话题之一。<br/>在过去的一年中,我有机会深入了解和实施,我想在一系列帖子中分享,首先谈谈这个主题的动机和基本解释。</p><h1 id="af36" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">什么是Functional Reactive Programming?</h1><p id="84c5" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">这是一个非常热门的话题,但许多人发现很难理解的原因之一是,在将这些概念转化为代码之前,命名法产生了很多混乱,因为名称的“功能”部分将我们引导到另一个更古老的概念,与我将在本系列文章中讨论的内容无关。</p><h2 id="9519" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">函数式编程 — 真正的意义(最古老的)</h2><p id="fe75" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">函数式编程本质上是一个范式,它假定函数(或方法)应该被编写为执行特定的函数而没有副作用(纯函数)。<br/>这意味着一个函数不依赖于或操纵超出其作用域的变量。(因为函数式编程是一个有趣的主题,而且本身就很长,所以如果你有兴趣阅读更多关于这个主题的内容,我建议你阅读更详细的帖子<a class="ae kt" href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming" rel="noopener ugc nofollow" target="_blank"> 这里</a> )</p><p id="bea9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">考虑到<em class="ku">functional programming的原始定义,让我们来看看<em class="ku">functional reactive programming</em>的定义,以便我们能够理解这两个名称之间的<em class="ku">functional</em>部分的差异。</em></p><blockquote class="kv kw kx"><p id="b839" class="ie if ku ig b ih ii ij ik il im in io ky iq ir is kz iu iv iw la iy iz ja jb ha bi translated">功能反应式编程是使用异步数据流进行编程,可以使用一组函数将其转换为新数据流。T10 此数据流由一个元素发出,并且在接收数据流时可能存在或可能不存在另一个元素。</p></blockquote><p id="4e55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">查看上面的定义,而较旧的术语指的是纯函数的创建,较新的术语指的是函数部分,它是一组允许修改数据流的函数,我们将在下面看到。</p><p id="d1df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此,我相信从现在开始,我们可以同意,当我们想谈论<em class="ku">功能性反应性编程</em>时,我将使用术语<em class="ku">反应性编程</em>,以避免疑问和混淆。</p><h2 id="b05c" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated">观察者模式 The Observer Pattern</h2><p id="4860" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">响应式编程(T1)基于<em class="ku">观察者模式(T3),它假定存在两个组件,其中第一个组件被命名为<strong class="ig hi">观察者(T5),负责发送数据流,第二个组件被命名为<strong class="ig hi">观察者(T7),负责监听和接收数据流,如下图所示:</strong></strong></em></p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lb"><img src="../Images/a167a58cd17c45153a4f30cc42614850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAqxHN3Fm-KrN-gyYeoqAQ.png"/></div></div></figure><h2 id="f91f" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated"><strong class="ak"> Reactive Programming [The Observer Pattern++]</strong></h2><p id="7608" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">反过来,响应式编程可以被认为是对<em class="ku">观察者模式</em>的升级,其中我们继续有两个元素,其中一个发出数据流,另一个接收并响应该数据流,并添加一个强大的中间组件,由不同的函数组成,允许操作数据或流作为一个整体,如下图所示。</p><figure class="lc ld le lf fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ln"><img src="../Images/18d6f85055266a4938b56925a7847a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AGVbTMXl1iLUhD28D4ztsA.png"/></div></div></figure><h2 id="0b89" class="kf jd hh bd je kg kh ki ji kj kk kl jm ip km kn jq it ko kp ju ix kq kr jy ks bi translated"><strong class="ak">为什么要以反应式的方式思考?(T13 )</strong></h2><p id="9bcf" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">反应性思维的想法源于当我们以相反的反应性思维(<strong class="ig hi">而不是<em class="ku">反应性思维)时,我们必须做的问题和工作。(T17) (T17)</em></strong></p><p id="4948" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">思维方式<strong class="ig hi">非反应式</strong>是思维方式<strong class="ig hi">命令式,</strong>和思维方式<strong class="ig hi">命令式</strong>通常是从我们开始学习编程时开始的,我们在单线程中查看要执行的代码,并使用回调逻辑,我们希望它在原始线程上执行,一旦另一个线程完成了某些工作。</p><p id="fb23" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以连接到API以读取数据的基本(Web,Android)应用程序为例,在实现中,必须有一个组件负责启动API调用并定义一个回调方法,该方法将在API发送响应时立即被调用。</p><p id="2913" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在此之前,这种解决方案一直是最好的,因此许多系统都是以这种方式开发的。然而,问题是,随着系统的增长,在处理多个线程时使用回调方法管理这些接口变得非常昂贵,并使代码变得非常难以维护。</p><p id="248b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了进一步强调前面的例子中专门为Android实现的强制性思维的限制,这意味着API调用将用于在片段或活动中呈现信息,因为我们不知道这项工作何时会结束,并且调用的方式不知道启动它的组件, 如果用户退出应用程序,我们可能会遇到严重的问题,因为任务继续运行,并且在 Activity 或 Fragment 中对字段进行 <em class="ku"> set </em> 时,这些组件将不再存在。</p><p id="f011" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">具体来说,对于Android,整个系统可以被认为是异步的,因为在上面的例子中,诸如读取内部数据库,用户通过点击事件发送的输入等操作是异步的,并且必须思考,尽管它工作总是会随着应用程序的增长而增加更多的工作。</p><p id="0738" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">鉴于上述情况,现在最大的疑问应该是如何被动地思考。</p><p id="aa57" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">反应性思维很简单(<strong class="ig hi">一个谎言,让你读到下一个帖子,这在</strong>系列结束时成为现实),我们应该简单地看看正在开发的系统,就其中的数据流而言,也就是说,思考一个给定的组件将如何自动响应系统中另一个组件的变化,该组件准备听取其更改。</p><p id="c145" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如,如果在命令形式中存在一个变量<strong class="ig hi">a</strong>,并且该变量被定义为变量<strong class="ig hi">b + c</strong>的总和,除非我们再次将<strong class="ig hi">a</strong>的定义操作作为<strong class="ig hi">b+c</strong>的总和,否则{T10} a的值将永远不会改变。</p><p id="1717" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在反应性形式中,<strong class="ig hi"> a </strong> <em class="ku"> 将被订阅(</em> 我将在整个 <em class="ku"> 系列中经常使用的术语) </em> a <strong class="ig hi"> b </strong> 和 <strong class="ig hi"> c 【T25] 并且在 <strong class="ig hi"> b </strong> 和 <strong class="ig hi"> c </strong> 改变时,其值将被更新,而无需执行两个变量的求和赋值操作。</strong></p><p id="2122" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在理论上理解这一切一开始是非常复杂的,但我可以向你保证,在下一篇文章中,我将详细介绍如何使用适用于Java和Android的RX Java库将这种思维方式转化为代码。</p><p id="46d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你喜欢这篇文章的内容,请点击下面的心脏留下一个喜欢,并与你认为你也想了解更多关于这个主题的朋友分享。</p><p id="90f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">吃下一篇文章,</p><p id="53ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">dm=)</p></div></div>    
</body>
</html>