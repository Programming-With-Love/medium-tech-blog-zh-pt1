<html>
<head>
<title>Animating on a Schedule</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按计划制作动画</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/animating-on-a-schedule-8a90d812ae4?source=collection_archive---------2-----------------------#2018-08-22">https://medium.com/androiddevelopers/animating-on-a-schedule-8a90d812ae4?source=collection_archive---------2-----------------------#2018-08-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/3208e020bba3fc5ce01c6bdc2e429b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ULjCNQdC2RYZNjBddSKnA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="4410" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">Google I/O应用程序中的动画</h2></div><p id="3682" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我最近是一个伟大团队的成员，该团队致力于开发谷歌I/O 2018 Android应用程序。这是一个会议伴侣应用程序，允许与会者和远程人员找到会议，制定个性化的时间表，并在会场预订座位(如果你足够幸运的话！).我们在应用程序中构建了许多有趣的动画功能，我相信这些功能极大地增强了体验。这个应用的代码刚刚被<a class="ae hu" href="https://github.com/google/iosched" rel="noopener ugc nofollow" target="_blank">开源</a>，我想强调其中的几个实例和一些有趣的实现细节。</p><figure class="kj kk kl km fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ki"><img src="../Images/196ba79ba6fbb837c18e940dc23bcf4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qwdwefn9aFPNyDai"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kn">Some animated elements in the I/O app</em></figcaption></figure><p id="20f6" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">通常，我们在应用程序中使用3种类型的动画:</p><ol class=""><li id="55b0" class="ko kp hx jo b jp jq js jt jv kq jz kr kd ks kh kt ku kv kw bi translated">英雄动画——用于强化品牌效应，带来愉悦时刻</li><li id="178e" class="ko kp hx jo b jp kx js ky jv kz jz la kd lb kh kt ku kv kw bi translated">屏幕过渡</li><li id="544b" class="ko kp hx jo b jp kx js ky jv kz jz la kd lb kh kt ku kv kw bi translated">状态变化</li></ol><p id="8fdf" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我想详细介绍其中一些。</p><h1 id="01fb" class="lc ld hx bd le lf lg lh li lj lk ll lm jd ln je lo jg lp jh lq jj lr jk ls lt bi translated">倒数计秒</h1><p id="da83" class="pw-post-body-paragraph jm jn hx jo b jp lu iy jr js lv jb ju jv lw jx jy jz lx kb kc kd ly kf kg kh ha bi translated">该应用的部分作用是为会议营造兴奋感和期待感。因此，今年我们在登机屏幕和信息部分都加入了一个大型的会议开始倒计时动画。这也是将活动品牌嵌入应用程序的绝佳机会，带来了许多特色。</p><figure class="kj kk kl km fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lz"><img src="../Images/38669acc39fb268a5549515233d2a2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8wmefPd7bAyozKg0kVMADg.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kn">The countdown to the conference start</em></figcaption></figure><p id="789c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这个动画是由一个动作设计师设计的，以一系列<a class="ae hu" href="http://airbnb.io/lottie/" rel="noopener ugc nofollow" target="_blank"> Lottie </a> json文件的形式发布:每一个1秒长的文件显示一个数字动画“进”然后“出”。Lottie格式使得将文件放入<code class="du ma mb mc md b">assets</code>变得很容易，甚至提供了像<a class="ae hu" href="http://airbnb.io/lottie/android/android.html#play-animation-segments" rel="noopener ugc nofollow" target="_blank"> setMinAndMaxProgress </a>这样的便利方法，允许我们只播放一个动画的前半部分或后半部分(显示一个数字的动画进或出)。</p><p id="c850" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">有趣的部分实际上是将这些多个动画编排成整体倒计时。为了做到这一点，我们创建了一个定制的<code class="du ma mb mc md b"><a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/widget/CountdownView.kt" rel="noopener ugc nofollow" target="_blank">CountdownView</a></code>，它是一个相当复杂的<a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/res/layout/countdown.xml" rel="noopener ugc nofollow" target="_blank"/><code class="du ma mb mc md b"><a class="ae hu" href="https://developer.android.com/reference/android/support/constraint/ConstraintLayout.html" rel="noopener ugc nofollow" target="_blank">ConstraintLayout</a></code>包含许多<code class="du ma mb mc md b">LottieAnimationViews</code>。在这里，我们<a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/widget/CountdownView.kt#L103" rel="noopener ugc nofollow" target="_blank">创建了</a>一个Kotlin <a class="ae hu" href="https://kotlinlang.org/docs/reference/delegated-properties.html" rel="noopener ugc nofollow" target="_blank">委托</a>来封装启动适当的动画。这允许我们简单地为每个代表分配一个应该显示的数字的<code class="du ma mb mc md b">Int</code>，代表将设置并开始动画。我们扩展了<code class="du ma mb mc md b"><a class="ae hu" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-observable-property/index.html" rel="noopener ugc nofollow" target="_blank">ObservableProperty</a></code>委托，确保我们只在数字变化时运行动画。然后，我们的动画循环只是每秒发布一个runnable(当附加视图时),它计算每个视图应该显示哪个数字并更新代理。</p><h1 id="6163" class="lc ld hx bd le lf lg lh li lj lk ll lm jd ln je lo jg lp jh lq jj lr jk ls lt bi translated">保留</h1><p id="c1f3" class="pw-post-body-paragraph jm jn hx jo b jp lu iy jr js lv jb ju jv lw jx jy jz lx kb kc kd ly kf kg kh ha bi translated">该应用程序的一个关键动作是让与会者预订座位。因此，我们在会话详细信息屏幕上的<a class="ae hu" href="https://material.io/develop/android/components/floating-action-button/" rel="noopener ugc nofollow" target="_blank"> FAB </a>中突出显示了该操作。我们认为，重要的是，一旦会话在后端成功完成，就只报告会话已被保留(不像启动会话这样不太重要的操作，我们乐观地立即更新UI)。这可能需要一点时间来等待来自后端的响应，因此为了使这更具响应性，我们使用了动画图标来提供我们正在处理的反馈，并平稳地过渡到新状态。</p><figure class="kj kk kl km fd hj er es paragraph-image"><div class="er es me"><img src="../Images/c6df58100170d80834efb6b66d467bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/0*72rpT-rsncLpM4dQ"/></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kn">Feedback whilst reserving a seat at a session</em></figcaption></figure><p id="6dbc" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这是复杂的，因为该图标需要反映许多状态:会话可能是可预订的，他们可能已经预订了座位，如果会话已满，则可能有等待列表，或者他们可能在等待列表上，或者接近会话开始，预订被禁用。这导致了不同状态的许多排列来在它们之间产生动画效果。为了简化这些转换，我们决定总是经历一个“工作”状态；上面的动画沙漏。因此，每个转换实际上是一对:状态1 →工作&amp;工作→状态2。这大大简化了事情。我们用<a class="ae hu" href="http://shapeshifter.design/" rel="noopener ugc nofollow" target="_blank">变形人</a>制作了每一个动画；参见<code class="du ma mb mc md b">avd_state_to_state</code>文件<a class="ae hu" href="https://github.com/google/iosched/tree/master/mobile/src/main/res/drawable" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="c152" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了显示这一点，我们使用了一个自定义视图和一个<code class="du ma mb mc md b"><a class="ae hu" href="https://developer.android.com/reference/android/graphics/drawable/AnimatedStateListDrawable" rel="noopener ugc nofollow" target="_blank">AnimatedStateListDrawable</a></code> ( <code class="du ma mb mc md b">ASLD</code>)。如果你以前没有使用过<code class="du ma mb mc md b">ASLD</code>，它(顾名思义)是你可能<em class="mf">遇到过</em>的<code class="du ma mb mc md b"><a class="ae hu" href="https://developer.android.com/reference/android/graphics/drawable/StateListDrawable" rel="noopener ugc nofollow" target="_blank">StateListDrawable</a></code>的动画版本——允许你不仅为每个状态提供不同的drawables，还可以在状态之间提供<em class="mf">转换</em>(以<code class="du ma mb mc md b"><a class="ae hu" href="https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable.html" rel="noopener ugc nofollow" target="_blank">AnimatedVectorDrawable</a></code>或<code class="du ma mb mc md b"><a class="ae hu" href="https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html" rel="noopener ugc nofollow" target="_blank">AnimationDrawable</a></code>的形式)。<a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/res/drawable/asld_reservation.xml" rel="noopener ugc nofollow" target="_blank">这里是定义静态图像的drawable </a>以及进入和退出预约图标工作状态的转换。</p><p id="ae68" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们创建了一个<a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/ui/reservation/StarReserveFab.kt" rel="noopener ugc nofollow" target="_blank">定制视图</a>来支持我们自己的定制状态。视图提供了一些标准状态，如按下或选中。类似地，您可以<a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/res/values/attrs.xml#L19-L31" rel="noopener ugc nofollow" target="_blank">定义自己的</a>并让视图<a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/ui/reservation/StarReserveFab.kt#L82-L98" rel="noopener ugc nofollow" target="_blank">将</a>路由到它正在显示的任何<code class="du ma mb mc md b">Drawable</code>。我们定义了自己的<code class="du ma mb mc md b">state_reservable</code>、<code class="du ma mb mc md b">state_reserved</code>等。然后我们创建了这些不同状态的enum<a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/ui/reservation/ReservationViewState.kt" rel="noopener ugc nofollow" target="_blank">,封装了视图状态和任何相关的属性，比如相关的内容描述。然后，我们的业务逻辑可以简单地在视图上设置这个枚举的适当值(通过数据绑定)，这将更新drawable的状态，通过<code class="du ma mb mc md b">ASLD</code>开始动画。自定义状态和<code class="du ma mb mc md b">AnimatedStateListDrawable</code>的结合是实现这一点的好方法，在声明层保留了大量的状态，产生了最少的视图代码。</a></p><h1 id="46d8" class="lc ld hx bd le lf lg lh li lj lk ll lm jd ln je lo jg lp jh lq jj lr jk ls lt bi translated">扬声器转换</h1><p id="d2f1" class="pw-post-body-paragraph jm jn hx jo b jp lu iy jr js lv jb ju jv lw jx jy jz lx kb kc kd ly kf kg kh ha bi translated">许多屏幕过渡与标准窗口动画配合得很好。我们偏离这一点的一个地方是<a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/res/transition/speaker_shared_enter.xml" rel="noopener ugc nofollow" target="_blank">转换</a>到扬声器细节屏幕。这在过渡的任何一侧显示扬声器图像，并且是共享元素过渡的完美候选。这有助于减轻屏幕之间的上下文变化。</p><figure class="kj kk kl km fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lz"><img src="../Images/fa517c94f3b951513ebdb8b1705da729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*95rpN018ohiAapW6ARxuGg.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kn">A shared element transition</em></figcaption></figure><p id="4c6f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这是一个非常标准的共享元素转换，在一个<code class="du ma mb mc md b">ImageView</code>上使用平台<code class="du ma mb mc md b"><a class="ae hu" href="https://developer.android.com/reference/android/transition/ChangeBounds.html" rel="noopener ugc nofollow" target="_blank">ChangeBounds</a></code>和<code class="du ma mb mc md b"><a class="ae hu" href="https://developer.android.com/reference/android/transition/ArcMotion.html" rel="noopener ugc nofollow" target="_blank">ArcMotion</a></code>类。</p><p id="3977" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">更有趣的是启动这个转换是如何适应我们用于导航的<a class="ae hu" rel="noopener" href="/google-developers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150">事件模式</a>的。本质上，这种模式将输入事件(比如在扬声器上录音)从导航事件中分离出来，让<code class="du ma mb mc md b">ViewModel</code>负责如何响应输入。在这种情况下，这种解耦意味着<code class="du ma mb mc md b">ViewModel</code> <a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/ui/sessiondetail/SessionDetailViewModel.kt#L147" rel="noopener ugc nofollow" target="_blank">暴露了<code class="du ma mb mc md b">Event</code> s的</a> a <code class="du ma mb mc md b">LiveData</code>，它只知道要导航到的说话者的ID。启动一个共享元素转换需要共享的<code class="du ma mb mc md b">View</code>，在这一点上我们没有。我们通过<a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/ui/sessiondetail/SessionDetailAdapter.kt#L103" rel="noopener ugc nofollow" target="_blank">在视图绑定时将演讲者的ID作为标签存储</a>来解决这个问题，这样当我们需要导航到一个特定的演讲者详细信息屏幕时，视图就可以被<a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/ui/sessiondetail/SessionDetailFragment.kt#L195" rel="noopener ugc nofollow" target="_blank">检索到</a>。</p><h1 id="fcec" class="lc ld hx bd le lf lg lh li lj lk ll lm jd ln je lo jg lp jh lq jj lr jk ls lt bi translated">过滤</h1><p id="6558" class="pw-post-body-paragraph jm jn hx jo b jp lu iy jr js lv jb ju jv lw jx jy jz lx kb kc kd ly kf kg kh ha bi translated">会议应用的一个核心部分是将众多事件筛选出你感兴趣的事件。为了便于识别，每个主题都有一种相关的颜色，我们收到了一个很棒的定制“芯片”设计，可以在选择过滤器时使用:</p><figure class="kj kk kl km fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lz"><img src="../Images/cb7650f0be154f0a22cc1919a7036e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hQIbFDgFL9MyKIZOphsPhg.gif"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="kn">Animated filter chips</em></figcaption></figure><p id="024e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们从材料组件中查看了<code class="du ma mb mc md b"><a class="ae hu" href="https://material.io/develop/android/components/chip/" rel="noopener ugc nofollow" target="_blank">Chip</a></code>,但是选择实现我们自己的<a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/ui/schedule/filters/EventFilterView.kt" rel="noopener ugc nofollow" target="_blank">自定义视图</a>,以便更好地控制“选中”状态之间的显示和动画。这是使用画布绘图和用于显示文本的<code class="du ma mb mc md b"><a class="ae hu" href="https://developer.android.com/reference/android/text/StaticLayout.html" rel="noopener ugc nofollow" target="_blank">StaticLayout</a></code>实现的。该视图有一个单独的<code class="du ma mb mc md b">progress</code>属性[0–1]建模未选中–选中。为了切换状态，我们简单地激活这个值并使视图无效，渲染代码<a class="ae hu" href="https://github.com/google/iosched/blob/master/mobile/src/main/java/com/google/samples/apps/iosched/util/Extensions.kt#L65" rel="noopener ugc nofollow" target="_blank">基于此线性地插入</a>元素的位置和大小。</p><p id="f483" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">最初实现这个的时候，我让视图实现了<code class="du ma mb mc md b"><a class="ae hu" href="https://developer.android.com/reference/android/widget/Checkable.html" rel="noopener ugc nofollow" target="_blank">Checkable</a></code>接口，并在<code class="du ma mb mc md b">setChecked</code>方法设置了一个新状态时开始动画。当我们在一个<code class="du ma mb mc md b">RecyclerView</code>中显示多个过滤器时，如果一个被选择的过滤器滚出来，视图被反弹到一个未被选择的过滤器滚进来，这会对动画的运行产生不利的影响。哎呦。因此，我们添加了一个单独的方法来启动动画，使我们能够区分它是通过单击切换还是在将新数据绑定到视图时立即更新。</p><p id="e159" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">此外，当我们引入这个切换动画时，我们发现它是janking，即丢帧。是我的动画代码有问题吗？这些过滤器显示在主会议日程屏幕前的<code class="du ma mb mc md b">BottomSheet</code>中。当切换过滤器时，我们启动应用于时间表的过滤逻辑(并更新过滤器表标题中匹配事件的数量)。一些<a class="ae hu" href="https://developer.android.com/studio/command-line/systrace" rel="noopener ugc nofollow" target="_blank">系统</a>的探索之后，我们确定问题在于当过滤器被应用时，<code class="du ma mb mc md b">RecyclerViews</code>显示时间表的<code class="du ma mb mc md b">ViewPager</code>忠实地关闭并更新到新交付的数据。这导致许多观点被夸大和束缚。所有这些工作都超出了我们的框架预算…但是更新时间表不可见，因为它在过滤表后面。我们决定延迟执行实际的过滤，直到动画运行，为了更流畅的用户体验，我们牺牲了更多的实现复杂性。最初我使用<code class="du ma mb mc md b">postDelayed</code>实现了这个，但是这导致了UI测试的问题。相反，我们切换了启动动画的方法，以接受lambda在结束时运行。这允许我们更好地尊重用户的动画设置，并正确地测试执行。</p><h1 id="649e" class="lc ld hx bd le lf lg lh li lj lk ll lm jd ln je lo jg lp jh lq jj lr jk ls lt bi translated">变得生动</h1><p id="44e7" class="pw-post-body-paragraph jm jn hx jo b jp lu iy jr js lv jb ju jv lw jx jy jz lx kb kc kd ly kf kg kh ha bi translated">总的来说，我觉得动画确实对应用的体验、个性、品牌和响应做出了贡献。希望这篇文章有助于解释为什么以及如何使用它们，并为您提供了它们的实现方法。</p><figure class="kj kk kl km fd hj er es paragraph-image"><div class="er es mg"><img src="../Images/85e260253bd6545f5b64d84a62930f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/1*G-o08BnqDQiUUBpYYB2QJg.gif"/></div></figure></div></div>    
</body>
</html>