<html>
<head>
<title>Coroutines On Android (part III): real work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上的协同程序(第三部分):实际工作</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/coroutines-on-android-part-iii-real-work-2ba8a2ec2f45?source=collection_archive---------1-----------------------#2019-05-21">https://medium.com/androiddevelopers/coroutines-on-android-part-iii-real-work-2ba8a2ec2f45?source=collection_archive---------1-----------------------#2019-05-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/a0be03964836145a1dc72cbfd017a28d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K__YGB4eb12WKTRwpvAuhg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><p id="70c9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是关于在Android上使用协程的系列文章的一部分。这篇文章主要通过实现一次请求来解决使用协程的实际问题。</p><h2 id="1f64" class="js jt hx bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">本系列的其他文章:</h2><div class="hg hh ez fb hi kn"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hy fi z dy ks ea eb kt ed ef hw bi translated">Android上的协同程序(第一部分):了解背景</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">协程解决什么问题？</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">medium.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb ho kn"/></div></div></a></div><div class="hg hh ez fb hi kn"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-on-android-part-ii-getting-started-3bff117176dd"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hy fi z dy ks ea eb kt ed ef hw bi translated">Android上的协同程序(第二部分):入门</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">了解CoroutineScope以及它如何帮助您避免在Android上泄露工作。</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">medium.com</p></div></div><div class="kw l"><div class="kx l ky kz la kw lb ho kn"/></div></div></a></div><h1 id="a39c" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">用协程解决现实世界的问题</h1><p id="bbc3" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">本系列的第一部分和第二部分主要关注如何使用协程来简化代码，在Android上提供主安全，并避免泄漏工作。在这种背景下，它们看起来像是后台处理的一个很好的解决方案，也是简化Android上基于回调的代码的一种方式。</p><p id="1189" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">到目前为止，我们已经关注了什么是协程以及如何管理它们。在这篇文章中，我们将看看如何使用它们来完成一些真正的任务。协程是一种通用编程语言特性，与函数处于同一层次——所以您可以用它们来实现任何您可以用函数和对象实现的东西。然而，有两种类型的任务在实际代码中经常出现，协程是解决这两种任务的好方法:</p><ol class=""><li id="f625" class="ly lz hx iw b ix iy jb jc jf ma jj mb jn mc jr md me mf mg bi translated"><strong class="iw hy"> One shot </strong> <strong class="iw hy">请求</strong>是每次被调用时运行的请求——它们总是在结果准备好之后完成。</li><li id="7830" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated"><strong class="iw hy">流</strong> <strong class="iw hy">请求</strong>是持续观察变化并将其报告给调用者的请求——它们不会在第一个结果准备好时完成。</li></ol><p id="2cf1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">协程是这两项任务的绝佳解决方案。在本帖中，我们将深入探讨一次性请求，并探索如何在Android上使用协程来实现它们。</p><h1 id="5332" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">一次性请求</h1><p id="9609" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">单次请求在每次调用时执行一次，并在结果准备就绪后立即完成。这种模式与常规的函数调用相同——它被调用，做一些工作，然后返回。由于与函数调用的相似性，它们比流请求更容易理解。</p><blockquote class="mm"><p id="fccb" class="mn mo hx bd mp mq mr ms mt mu mv jr dx translated">每次调用时都会执行一次单次请求。一旦结果准备好，它就停止执行。</p></blockquote><p id="4fa1" class="pw-post-body-paragraph iu iv hx iw b ix mw iz ja jb mx jd je jf my jh ji jj mz jl jm jn na jp jq jr ha bi translated">对于一个一次性请求的例子，考虑你的浏览器是如何加载这个页面的。当你点击这篇文章的链接时，你的浏览器向服务器发送了一个网络请求来加载这个页面。一旦页面被传输到你的浏览器，它就停止与后端对话——它有所有它需要的数据。如果服务器修改了帖子，新的更改将不会显示在您的浏览器中，您必须刷新页面。</p><p id="173f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，虽然它们缺乏流请求的实时推送，但一次性请求非常强大。在Android应用程序中，你可以做很多事情，这些事情可以通过一次性请求来解决，比如获取、存储或更新数据。对于排序列表之类的事情，这也是一个很好的模式。</p><h1 id="a27b" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">问题:显示排序列表</h1><p id="ddc9" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">让我们通过查看如何显示一个排序列表来研究一次性请求。为了具体说明这个例子，让我们构建一个库存应用程序，供商店的员工使用。它将被用来查找产品的基础上，当他们最后一次库存-他们将希望能够排序列表升序和降序。它有如此多的产品，以至于对其进行排序可能需要一秒钟——所以我们将使用协程来避免阻塞主线程！</p><p id="2715" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个应用程序中，所有产品都存储在一个房间数据库中。这是一个很好的探索用例，因为它不需要涉及网络请求，所以我们可以专注于模式。尽管这个例子因为不使用网络而更简单，但它公开了实现一次性请求所需的模式。</p><p id="997e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了使用协程实现这个请求，您将向<code class="du nb nc nd ne b">ViewModel</code>、<code class="du nb nc nd ne b">Repository</code>和<code class="du nb nc nd ne b">Dao</code>引入协程。让我们一次浏览一遍，看看如何将它们与协程集成。</p><figure class="nf ng nh ni fd hj"><div class="bz dy l di"><div class="nj nk l"/></div></figure><p id="d05d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du nb nc nd ne b">ProductsViewModel</code>负责从UI层接收事件，然后向存储库请求更新的数据。它使用<code class="du nb nc nd ne b"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>来保存当前排序的列表，以供UI显示。当新事件到来时，<code class="du nb nc nd ne b">sortProductsBy</code>启动一个新的协程来对列表进行排序，并在结果就绪时更新<code class="du nb nc nd ne b">LiveData</code>。在这个架构中，<code class="du nb nc nd ne b"><a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank">ViewModel</a></code>通常是启动大多数协程的正确位置，因为它可以取消<code class="du nb nc nd ne b">onCleared</code>中的协程。如果用户离开屏幕，他们通常对杰出的工作没有用处。</p><p id="412f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="nl">如果你没怎么用过LiveData，看看这篇由</em><a class="ae hu" href="https://twitter.com/CeruleanOtter" rel="noopener ugc nofollow" target="_blank"><em class="nl">@ CeruleanOtter</em></a><em class="nl">撰写的伟大文章，介绍他们如何为ui存储数据。</em></p><div class="hg hh ez fb hi kn"><a rel="noopener follow" target="_blank" href="/androiddevelopers/viewmodels-a-simple-example-ed5ac416317e"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hy fi z dy ks ea eb kt ed ef hw bi translated">视图模型:简单的例子</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">介绍</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">medium.com</p></div></div><div class="kw l"><div class="nm l ky kz la kw lb ho kn"/></div></div></a></div><p id="5d46" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是Android上协程的一般模式。由于Android框架不调用挂起函数，您需要与协程协调来响应UI事件。最简单的方法是在事件到来时启动一个新的协程——这样做的自然位置是在<code class="du nb nc nd ne b">ViewModel</code>中。</p><blockquote class="mm"><p id="50b7" class="mn mo hx bd mp mq mr ms mt mu mv jr dx translated">作为一般模式，在ViewModel中启动协程。</p></blockquote><p id="6f9f" class="pw-post-body-paragraph iu iv hx iw b ix mw iz ja jb mx jd je jf my jh ji jj mz jl jm jn na jp jq jr ha bi translated"><code class="du nb nc nd ne b">ViewModel</code>使用一个<code class="du nb nc nd ne b">ProductsRepository</code>来实际获取数据。看起来是这样的:</p><figure class="nf ng nh ni fd hj"><div class="bz dy l di"><div class="nj nk l"/></div></figure><p id="6433" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du nb nc nd ne b">ProductsRepository</code>提供了与产品交互的合理界面。在这个应用程序中，由于所有东西都在本地房间数据库中，它只是为<code class="du nb nc nd ne b">@Dao</code>提供了一个很好的接口，该接口针对不同的排序顺序提供了两种不同的功能。</p><p id="b300" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">存储库是Android Architecture Components架构的可选部分——但如果你的应用程序中有它或类似的层，它应该更喜欢公开常规的挂起功能。由于存储库没有自然的生命周期——它只是一个对象——它没有办法清理工作。因此，默认情况下，在存储库中启动的任何协程都会泄漏。</p><p id="9fe9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">除了避免泄漏之外，通过公开常规的挂起函数，很容易在不同的上下文中重用存储库。任何知道如何做协程的人都可以叫<code class="du nb nc nd ne b">loadSortedProducts</code>。例如，由WorkManager库调度的后台作业可以直接调用它。</p><blockquote class="mm"><p id="a61f" class="mn mo hx bd mp mq mr ms mt mu mv jr dx translated">存储库应该更喜欢公开主安全的常规挂起函数。</p></blockquote><blockquote class="nn no np"><p id="cf45" class="iu iv nl iw b ix mw iz ja jb mx jd je nq my jh ji nr mz jl jm ns na jp jq jr ha bi translated">注意:<em class="hx">一些后台保存操作可能希望在用户离开屏幕后继续，并且让这些保存没有生命周期地运行是有意义的。在大多数其他情况下，</em> <code class="du nb nc nd ne b"><em class="hx">viewModelScope</em></code> <em class="hx">是合理的选择。</em></p></blockquote><p id="cf7d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">继续看<code class="du nb nc nd ne b">ProductsDao</code>，看起来是这样的:</p><figure class="nf ng nh ni fd hj"><div class="bz dy l di"><div class="nj nk l"/></div></figure><p id="a41b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du nb nc nd ne b">ProductsDao</code>是一个暴露两个挂起函数的房间<code class="du nb nc nd ne b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/Dao" rel="noopener ugc nofollow" target="_blank">@Dao</a></code>。因为这些函数被标记为suspend，所以Room确保它们是主安全的。这意味着您可以从<code class="du nb nc nd ne b">Dispatchers.Main</code>直接调用它们。</p><p id="53f1" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="nl">如果你还没有在房间里看到coroutines，看看这个由</em><a class="ae hu" href="https://twitter.com/FMuntenescu" rel="noopener ugc nofollow" target="_blank"><em class="nl">@</em>FMuntenescu</a>发布的伟大帖子</p><div class="hg hh ez fb hi kn"><a rel="noopener follow" target="_blank" href="/androiddevelopers/room-coroutines-422b786dc4c5"><div class="ko ab dw"><div class="kp ab kq cl cj kr"><h2 class="bd hy fi z dy ks ea eb kt ed ef hw bi translated">房间🔗协同程序</h2><div class="ku l"><h3 class="bd b fi z dy ks ea eb kt ed ef dx translated">给你的数据库增加一些悬念</h3></div><div class="kv l"><p class="bd b fp z dy ks ea eb kt ed ef dx translated">medium.com</p></div></div><div class="kw l"><div class="nt l ky kz la kw lb ho kn"/></div></div></a></div><p id="ed5b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不过需要提醒的是，调用这个函数的协程将在主线程上。因此，如果您对结果做了一些开销很大的事情——比如将它们转换成一个新的列表——您应该确保没有阻塞主线程。</p><blockquote class="nn no np"><p id="7bc8" class="iu iv nl iw b ix iy iz ja jb jc jd je nq jg jh ji nr jk jl jm ns jo jp jq jr ha bi translated"><em class="hx">注意:</em> <em class="hx"> Room使用自己的dispatcher在后台线程上运行查询。您的代码</em>不应该<em class="hx">使用</em> <code class="du nb nc nd ne b"><em class="hx">withContext(Dispatchers.IO)</em></code> <em class="hx">来调用暂停房间查询。这将使代码变得复杂，并使您的查询运行得更慢。</em></p></blockquote><blockquote class="mm"><p id="4d2d" class="mn mo hx bd mp mq nu nv nw nx ny jr dx translated">Room中的挂起功能是主安全的，并在自定义调度程序上运行。</p></blockquote><h1 id="61f8" class="lc jt hx bd ju ld le lf jy lg lh li kc lj nz ll kf lm oa lo ki lp ob lr kl ls bi translated">一次性请求模式</h1><p id="7fdb" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">这是在Android架构组件中使用协程进行一次性请求的完整模式。我们向<code class="du nb nc nd ne b">ViewModel</code>、<code class="du nb nc nd ne b">Repository</code>和<code class="du nb nc nd ne b">Room</code>添加了协程，每一层都有不同的职责。</p><ol class=""><li id="648e" class="ly lz hx iw b ix iy jb jc jf ma jj mb jn mc jr md me mf mg bi translated">ViewModel在主线程上启动一个协程——它在有结果时完成。</li><li id="87dc" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated">Repository公开了常规的挂起函数，并确保它们是主安全的。</li><li id="d041" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated">数据库和网络公开常规挂起函数，并确保它们是主安全的。</li></ol><p id="1ea7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"/><code class="du nb nc nd ne b"><strong class="iw hy">ViewModel</strong></code>负责启动协程，并确保当用户离开屏幕时它们被取消。它不做昂贵的事情，而是依靠其他层来做繁重的工作。一旦有了结果，它就使用<code class="du nb nc nd ne b">LiveData</code>将结果发送到UI。</p><p id="9a4c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于<code class="du nb nc nd ne b">ViewModel</code>不做繁重的工作，它在主线程上启动协程。通过在main上启动，如果结果立即可用(例如，从内存缓存中)，它可以更快地响应用户事件。</p><p id="a18d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy"/><code class="du nb nc nd ne b"><strong class="iw hy">Repository</strong></code>公开常规的挂起函数来访问数据。它通常不会启动自己的长期协程，因为它没有办法取消它们。每当<code class="du nb nc nd ne b">Repository</code>必须做一些昂贵的事情，比如转换一个列表，它应该使用<code class="du nb nc nd ne b">withContext</code>来公开一个主安全接口。</p><p id="24d0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">数据层</strong>(网络或数据库)总是暴露常规的挂起功能。使用Kotlin协程时，这些挂起函数是主安全的，这一点很重要，房间和翻新都遵循这一模式。</p><p id="761b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在单次请求中，数据层<em class="nl">仅</em>暴露挂起功能。如果调用者想要一个新的值，他们必须再次调用。这就像网页浏览器上的刷新按钮。</p><p id="fbc7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">值得花点时间来确保您理解这些一次性请求的模式。这是Android上协程的正常模式，您会一直使用它。</p><h1 id="75e5" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">我们的第一份错误报告！</h1><p id="6ac4" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">测试该解决方案后，您将其投入生产，几周以来一切都很顺利，直到您收到一个非常奇怪的错误报告:</p><blockquote class="nn no np"><p id="272c" class="iu iv nl iw b ix iy iz ja jb jc jd je nq jg jh ji nr jk jl jm ns jo jp jq jr ha bi translated"><strong class="iw hy">主题:</strong>🐞—错误的排序顺序！</p><p id="0396" class="iu iv nl iw b ix iy iz ja jb jc jd je nq jg jh ji nr jk jl jm ns jo jp jq jr ha bi translated"><strong class="iw hy">报告:</strong>当我非常非常快速地点击排序按钮时，有时排序是错误的。这种情况并不经常发生🙃。</p></blockquote><p id="acdb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你看一看，挠一挠头。会出什么问题呢？算法似乎相当简单:</p><ol class=""><li id="902a" class="ly lz hx iw b ix iy jb jc jf ma jj mb jn mc jr md me mf mg bi translated">开始用户请求的排序。</li><li id="f6d0" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated">在房间调度程序中运行排序。</li><li id="dcf0" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated">显示排序的结果。</li></ol><p id="c35c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你很想关闭bug<strong class="iw hy">“wont fix——不要这么快按下按钮”</strong>但是你担心可能有什么东西坏了。在添加了日志记录语句并编写了一个测试来一次调用大量排序之后——您终于弄明白了！</p><p id="2bba" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">原来显示的结果实际上并不是“第<em class="nl">次排序的结果”，而是“第<em class="nl">次排序的结果”当用户按下按钮时——他们同时开始多个排序，并且可以按任何顺序完成！</em></em></p><blockquote class="mm"><p id="e590" class="mn mo hx bd mp mq mr ms mt mu mv jr dx translated">当启动一个新的协同例程来响应一个UI事件时，考虑一下如果用户在这个完成之前启动另一个会发生什么。</p></blockquote><p id="2c79" class="pw-post-body-paragraph iu iv hx iw b ix mw iz ja jb mx jd je jf my jh ji jj mz jl jm jn na jp jq jr ha bi translated">这是一个<em class="nl">并发错误</em>，它与协程没有任何关系。如果我们以同样的方式使用回调、Rx，甚至是<code class="du nb nc nd ne b">ExecutorService</code>,我们也会有同样的错误。</p><p id="befb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<code class="du nb nc nd ne b">ViewModel</code>和<code class="du nb nc nd ne b">Repository</code>中有很多方法可以解决这个问题。让我们探索一些模式来确保单次请求按照用户期望的顺序完成。</p><h1 id="5071" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">最佳解决方案:禁用按钮</h1><p id="3f17" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">最根本的问题是我们在做两种分类。我们可以通过让它只做一种来解决这个问题！最简单的方法是禁用排序按钮来停止新事件。</p><p id="2aaf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这似乎是一个简单的解决方案，但它确实是一个好主意。实现这一点的代码很简单，易于测试，只要它在UI中有意义，就可以完全解决问题！</p><p id="c3d8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要禁用按钮，告诉UI在<code class="du nb nc nd ne b">sortPricesBy</code>中发生了一个排序请求，如下所示:</p><figure class="nf ng nh ni fd hj"><div class="bz dy l di"><div class="nj nk l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Disabling the buttons while a sort runs using _sortButtonsEnabled in sortPricesBy.</figcaption></figure><p id="d3ec" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好的，那个不算太坏。只需禁用调用存储库周围的<code class="du nb nc nd ne b">sortPricesBy </code>中的按钮。</p><p id="33f3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在大多数情况下，这是解决这个问题的正确方法。但是，如果我们想让按钮保持启用状态并修复错误呢？这有点难，我们将在这篇文章的剩余部分探索一些不同的选择。</p><blockquote class="nn no np"><p id="e522" class="iu iv nl iw b ix iy iz ja jb jc jd je nq jg jh ji nr jk jl jm ns jo jp jq jr ha bi translated">重要提示:<em class="hx">这段代码展示了在main上启动的一个主要优点——按钮在响应点击时会立即失效。如果你换了调度程序，一个在慢速手机上快速操作的用户可以发送不止一次点击！</em></p></blockquote><h1 id="eeaa" class="lc jt hx bd ju ld le lf jy lg lh li kc lj lk ll kf lm ln lo ki lp lq lr kl ls bi translated">并发模式</h1><p id="52bf" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">接下来的几节将探讨高级主题——如果您刚刚开始使用协程，您不需要马上理解它们。简单地禁用按钮是解决您遇到的大多数问题的最佳方案。</p><p id="5255" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文的其余部分，我们将探索使用协程来保持按钮启用的方法，但要确保一次性请求的执行顺序不会让用户感到意外。我们可以通过控制协程何时运行(或不运行)来避免意外并发。</p><p id="be74" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有三种基本模式可用于一次性请求，以确保一次只运行一个请求。</p><ol class=""><li id="d20a" class="ly lz hx iw b ix iy jb jc jf ma jj mb jn mc jr md me mf mg bi translated"><strong class="iw hy">开始更多工作前，取消之前的工作</strong>。</li><li id="4efb" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated"><strong class="iw hy">将下一个工作</strong>排入队列，等待前面的请求完成后再开始下一个。</li><li id="41a1" class="ly lz hx iw b ix mh jb mi jf mj jj mk jn ml jr md me mf mg bi translated"><strong class="iw hy">加入之前的工作</strong>如果已经有一个请求在运行，只需返回那个请求，而不是启动另一个请求。</li></ol><p id="4ce9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您浏览这些解决方案时，您会注意到它们的实现有些复杂。为了专注于如何使用这些模式而不是实现细节，我<a class="ae hu" href="https://gist.github.com/objcode/7ab4e7b1df8acd88696cb0ccecad16f7#file-concurrencyhelpers-kt-L19" rel="noopener ugc nofollow" target="_blank">创建了一个要点，将所有三个模式的实现</a>作为可重用的抽象。</p><h2 id="edb1" class="js jt hx bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">解决方案1:取消之前的工作</h2><p id="e026" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在排序的情况下，从用户那里获得一个新事件通常意味着您可以取消上一次排序。毕竟，如果用户已经告诉你他们不想要这个结果，那么继续下去还有什么意义呢？</p><p id="e806" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要取消之前的请求，我们需要以某种方式跟踪它。要点中的函数<code class="du nb nc nd ne b">cancelPreviousThenRun</code> <a class="ae hu" href="https://gist.github.com/objcode/7ab4e7b1df8acd88696cb0ccecad16f7#file-concurrencyhelpers-kt-L91" rel="noopener ugc nofollow" target="_blank">正是这么做的。</a></p><p id="d660" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们来看看如何用它来修复这个错误:</p><figure class="nf ng nh ni fd hj"><div class="bz dy l di"><div class="nj nk l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Using cancelPreviousThenRun to ensure that only one sort runs at a time.</figcaption></figure><p id="aa0f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">查看gist中<code class="du nb nc nd ne b">cancelPreviousThenRun</code>的<a class="ae hu" href="https://gist.github.com/objcode/7ab4e7b1df8acd88696cb0ccecad16f7#file-concurrencyhelpers-kt-L91" rel="noopener ugc nofollow" target="_blank">示例实现</a>是了解如何跟踪正在进行的工作的好方法。</p><figure class="nf ng nh ni fd hj"><div class="bz dy l di"><div class="nj nk l"/></div></figure><p id="c967" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简而言之，它总是跟踪成员变量<code class="du nb nc nd ne b">activeTask</code>中当前活动的排序。每当排序开始时，它会立即<code class="du nb nc nd ne b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel-and-join.html" rel="noopener ugc nofollow" target="_blank">cancelAndJoin</a></code>处理当前在<code class="du nb nc nd ne b">activeTask</code>中的任何东西。这具有在开始新的排序之前取消任何正在进行的排序的效果。</p><p id="6bf0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用类似于<code class="du nb nc nd ne b">ControlledRunner&lt;T&gt;</code>的抽象来封装这样的逻辑是一个好主意，而不是将临时并发与应用程序逻辑混合。</p><blockquote class="mm"><p id="dfae" class="mn mo hx bd mp mq mr ms mt mu mv jr dx translated">考虑构建抽象，以避免将临时并发模式与应用程序代码混合在一起。</p></blockquote><blockquote class="nn no np"><p id="cfd5" class="iu iv nl iw b ix mw iz ja jb mx jd je nq my jh ji nr mz jl jm ns na jp jq jr ha bi translated">重要提示:<em class="hx">这种模式不太适合在全局单例中使用，因为不相关的调用者不应该互相取消。</em></p></blockquote><h2 id="da03" class="js jt hx bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">解决方案2:将下一个工作排队</h2><p id="5ced" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">有一种解决并发错误的方法<em class="nl">总是有效。</em></p><p id="ac8c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">将请求排队，这样一次只能发生一件事！就像商店里的队列或队伍一样，请求将按照开始的顺序一次执行一个。</p><p id="df03" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于这个特殊的排序问题，取消可能比排队更好，但是值得讨论一下，因为它总是有效的。</p><figure class="nf ng nh ni fd hj"><div class="bz dy l di"><div class="nj nk l"/></div></figure><p id="c649" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每当一个新的排序进来时，它使用一个<code class="du nb nc nd ne b">SingleRunner</code>实例来确保一次只有一个排序在运行。</p><p id="4648" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它<a class="ae hu" href="https://gist.github.com/objcode/7ab4e7b1df8acd88696cb0ccecad16f7#file-concurrencyhelpers-kt-L49" rel="noopener ugc nofollow" target="_blank">使用一个</a> <code class="du nb nc nd ne b"><a class="ae hu" href="https://gist.github.com/objcode/7ab4e7b1df8acd88696cb0ccecad16f7#file-concurrencyhelpers-kt-L49" rel="noopener ugc nofollow" target="_blank">Mutex</a></code>，这是一个单一的票(或锁)，协程必须得到它才能进入该块。如果另一个协程在一个正在运行时尝试，它会挂起自己，直到所有未决的协程都使用<code class="du nb nc nd ne b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.sync/-mutex/" rel="noopener ugc nofollow" target="_blank">Mutex</a></code>完成。</p><blockquote class="mm"><p id="f617" class="mn mo hx bd mp mq mr ms mt mu mv jr dx translated">互斥体让你确保一次只有一个协程运行——并且它们将按照开始的顺序完成。</p></blockquote><h2 id="bd26" class="js jt hx bd ju jv oc jx jy jz od kb kc jf oe ke kf jj of kh ki jn og kk kl km bi translated">解决方案3:加入以前的工作</h2><p id="bce9" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">第三个要考虑的方案是加入之前的工作。如果新的请求将重新开始已经完成一半的完全相同的工作，这是一个好主意。</p><p id="fe81" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种模式对于sort函数没有太大意义，但是对于加载数据的网络获取来说，这是一种自然的选择。</p><p id="e370" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于我们的产品库存应用程序，用户需要一种从服务器获取新产品库存的方法。作为一个简单的UI，我们将为他们提供一个刷新按钮，他们可以按下这个按钮来启动一个新的网络请求。</p><p id="6e3b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就像排序按钮一样，在请求运行时简单地禁用按钮是这个问题的完整解决方案。但是，如果我们没有——或者不能——这样做，我们可以加入现有的请求。</p><p id="29bd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们来看看使用gist中的<a class="ae hu" href="https://gist.github.com/objcode/7ab4e7b1df8acd88696cb0ccecad16f7#file-concurrencyhelpers-kt-L124" rel="noopener ugc nofollow" target="_blank"> joinPreviousOrRun </a>的一些代码，看看它是如何工作的:</p><figure class="nf ng nh ni fd hj"><div class="bz dy l di"><div class="nj nk l"/></div></figure><p id="9a37" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这颠倒了<code class="du nb nc nd ne b">cancelPreviousAndRun</code>的行为。它不是通过取消请求来丢弃以前的请求，而是丢弃新的请求并避免运行它。如果已经有一个请求在运行，它会等待当前“运行中”请求的结果并返回，而不是运行一个新的请求。只有在没有请求运行的情况下，才会执行该块。</p><p id="aa02" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以在<code class="du nb nc nd ne b">joinPreviousOrRun</code>开始时看到它是如何工作的——如果<code class="du nb nc nd ne b">activeTask</code>中有任何东西，它就返回先前的结果:</p><figure class="nf ng nh ni fd hj"><div class="bz dy l di"><div class="nj nk l"/></div></figure><p id="c817" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种模式很适合于像通过<code class="du nb nc nd ne b">id</code>获取产品这样的请求。您可以添加一个从<code class="du nb nc nd ne b">id</code>到<code class="du nb nc nd ne b">Deferred</code>的映射，然后使用相同的连接逻辑来跟踪相同产品的先前请求。</p><blockquote class="mm"><p id="12b3" class="mn mo hx bd mp mq mr ms mt mu mv jr dx translated">加入以前的工作是避免重复网络请求的一个很好的解决方案。</p></blockquote><h1 id="613c" class="lc jt hx bd ju ld le lf jy lg lh li kc lj nz ll kf lm oa lo ki lp ob lr kl ls bi translated">下一步是什么？</h1><p id="03d8" class="pw-post-body-paragraph iu iv hx iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在这篇文章中，我们探讨了如何使用Kotlin协程实现一次请求。首先，我们实现了一个完整的模式，展示了如何在<code class="du nb nc nd ne b">ViewModel</code>中启动一个协程，然后从<code class="du nb nc nd ne b">Repository</code>和<code class="du nb nc nd ne b">Dao</code>空间中公开常规的挂起函数。</p><p id="a423" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于大多数任务来说，为了在Android上使用Kotlin协程，这是您需要做的全部工作。这种模式可以应用于许多常见的任务，比如像我们在这里展示的那样对列表进行排序。您还可以使用它来获取、保存或更新网络上的数据</p><p id="64eb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，我们看了一个可能出现的细微错误和可能的解决方案。解决这个问题最简单(通常也是最好)的方法是在UI中——在排序过程中禁用排序按钮。</p><p id="7c52" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，我们看了一些高级并发模式以及如何在Kotlin协程中实现它们。这个的<a class="ae hu" href="https://gist.github.com/objcode/7ab4e7b1df8acd88696cb0ccecad16f7#file-concurrencyhelpers-kt-L158" rel="noopener ugc nofollow" target="_blank">代码有点复杂，但是它为一些高级协程主题提供了很好的介绍。</a></p><p id="d101" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在下一篇文章中，我们将看看流请求，并探索如何使用<code class="du nb nc nd ne b">liveData</code> builder！</p></div></div>    
</body>
</html>