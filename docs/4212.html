<html>
<head>
<title>Background Fetch API: Get Ready To Use It!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">后台取API:准备使用！</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/background-fetch-api-get-ready-to-use-it-69cca522cd8f?source=collection_archive---------1-----------------------#2018-11-30">https://medium.com/google-developer-experts/background-fetch-api-get-ready-to-use-it-69cca522cd8f?source=collection_archive---------1-----------------------#2018-11-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="b072" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在过去的12个月里，在我的PWA幻灯片中，有一部分是关于后台获取API的解释。它在我的“高级服务人员”会议的“即将推出的功能”一章中，我只介绍了基本概念，幻灯片上有一些代码。我在HolyJS会议上演讲的前一天晚上，我决定在ChromeStatus.com T2和Chrome Canary查看这个有前途的API的状态(我喜欢在我的会议期间报告所有最新的状态),并且……那天晚上我睡得不多——我发现T4最新的API规范几乎处于工作状态，并花了几个小时进行实验。这篇文章是关于服务人员后台获取的想法，以及如何开始使用它。</p><blockquote class="jd je jf"><p id="0109" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">声明:后台取API还是很实验的。它只有粗略的规范建议和Chrome Canary (M72)中的部分工作实现，并启用了<!-- -->实验性Web平台特性<!-- -->标志。所有的概念/接口/方法/事件在未来都可能改变。</p></blockquote><h1 id="9791" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是后台获取？</h1><p id="fc38" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">如果我们从“填补web和本地应用程序功能之间的差距”的角度来看待渐进式Web应用程序的概念，这个API带来了可管理和可预测的大型资产(确切地说是资产集)的下载和上传:文件、资源，应有尽有。大到足以开始担心可能的网络中断和/或脚本超时。例如，在本地存储音乐流媒体服务的MP3文件，或播客剧集，甚至可能是一些视频，或大型PDF文件。</p><ul class=""><li id="2dbd" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">你可能会说，我们在没有任何服务人员的情况下做了很多年——只需点击文件的链接，浏览器就会完成剩下的工作:可以暂停、取消和恢复下载。你是对的，但是你把这个资源下载到了<em class="jg">操作系统的</em>上下文(文件系统)，而不是你的web应用程序。我们使用后台获取API从网络上获得的一切都可以存储在相应应用程序的上下文中，供以后使用，没有任何额外的麻烦。</li><li id="bee8" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">现在你说我们只要使用服务工作者的<em class="jg"> fetch </em>事件就可以达到同样的效果。是的，我们可以下载一些文件，并将其放入app origin的缓存存储中(这是我们通常为app shell架构和运行时API端点缓存所做的)。这里的区别还是在于该资源的大小——在下载过程中，浏览器是否有可能因为超时而杀死服务人员。此外，从UX的角度来看，通知用户下载的事实和进度是有意义的。</li></ul><p id="3d3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">后台获取是为了以对开发者和用户友好的方式解决大型资产下载/上传问题。让我们看看WICG(网络孵化器社区团体)<a class="ae jc" href="https://github.com/WICG/background-fetch" rel="noopener ugc nofollow" target="_blank"> repo </a>上列出的这个API的特性，扮演规范提案的角色:</p><blockquote class="jd je jf"><p id="53f1" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">-允许获取(请求和响应)继续，即使用户关闭了到源的所有窗口和工作线程。</p><p id="409c" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">-根据应用程序的定义，允许单个作业涉及多个请求。</p><p id="0b60" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">-允许浏览器/操作系统显示用户界面以指示该作业的进度，并允许用户暂停/中止。</p><p id="6438" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">-允许浏览器/操作系统通过暂停/恢复下载来处理不良连接。</p><p id="e1ef" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">-允许应用程序对作业的成功/失败做出反应，也许是通过缓存结果。</p><p id="778a" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">-允许在后台获取资源时访问它们。</p></blockquote><p id="22e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简而言之:在我们注册了一个后台获取并通过这个事实启动了传输之后(这可以在我们的主线程和服务工作者中完成)，我们完全被浏览器(或平台)的可能性所覆盖。在传输过程中，我们可以使用应用程序关闭选项卡—传输不会停止。我们可以关闭浏览器，浏览器重启后传输将继续。网络可能会中断，浏览器在恢复后会自动继续传输。操作的结果将被发送给服务人员(因为应用程序选项卡可能会在那时关闭)。尽管这个API的名字，它不是100%的“后台”操作，因为它让用户清楚地了解正在发生的事情。</p><p id="9610" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个特性集看起来真的很有趣，让我们开始编码，看看它是如何工作的，看起来怎么样！</p><h1 id="0d78" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">后台获取MVP</h1><p id="ff7d" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">我们从非常小的解开始，只是为了检查它是否可行。计划如下:</p><ul class=""><li id="c152" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">我们注册了一名服务人员</li><li id="ca94" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">我们通过点击按钮在我们的主应用程序中注册一个后台获取</li><li id="cf80" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">我们在服务工作器中监听后台获取事件。成功时—我们将资产放入缓存存储。失败时—我们仍会尝试将所有可能获得的数据存储到存储中</li></ul><blockquote class="jd je jf"><p id="2475" class="ie if jg ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">声明:为了专注于我们今天的主题，我们不会创建完整意义上的PWA(既不会有app shell也不会有web app manifest)，所以我们可以正式地将我们的项目称为“服务工作者驱动的网站/webapp”。</p></blockquote><h2 id="43c3" class="lb jl hh bd jm lc ld le jq lf lg lh ju ip li lj jy it lk ll kc ix lm ln kg lo bi translated">看到下载开始的最少代码</h2><p id="b477" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">步骤1的代码如下:</p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="1f83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在app start上，我们注册了一个服务人员文件<code class="du lw lx ly lz b">service-worker.js</code>。请注意，即使在这个演示中，我也使用注册的最佳实践来强调以下几点的重要性:</p><ul class=""><li id="9f21" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">功能检测——不破坏旧浏览器中的应用程序。大多数PWA功能的良好方式。</li><li id="8083" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">注册推迟到<code class="du lw lx ly lz b">window.onload</code>。嗯，在我们的例子中，除了<code class="du lw lx ly lz b">index.html</code>本身，我们没有任何其他资源可以加载，但是让这个适当的注册片段提醒我们这样一个事实:服务人员<strong class="ig hi">不能</strong>改善<em class="jg">首次加载体验</em>，但是它很容易使情况变得更糟。</li></ul><p id="87cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在“本地存储资产”(“<em class="jg">下载</em>”术语不能100%正确地反映我们执行的操作)按钮上单击我们调用的<code class="du lw lx ly lz b">backgroundFetch.fetch()</code>活动服务工作者注册。它会注册一个后台获取，并立即启动传输。</p><p id="b856" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的服务工作者中，除了实用程序<code class="du lw lx ly lz b">install</code>和<code class="du lw lx ly lz b">activate</code>事件(为了更简单地跟踪生命周期阶段)，我们目前只有一个有用的事件处理程序:<code class="du lw lx ly lz b">backgroundfetchsuccess</code>，在这里我们输出事件的<code class="du lw lx ly lz b">registration</code>对象。让我们看看它的实际效果吧！对于我们的例子，我使用Mac OS上的<code class="du lw lx ly lz b">http-server</code>静态web服务器从相同的源下载了1，39 GB的电影文件(以便有几秒钟的时间观看电影流)。<em class="jg">(提醒:我们必须使用Chrome Canary M72来测试后台获取API) </em></p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="lu lv l"/></div><figcaption class="ma mb et er es mc md bd b be z dx">The command and output we have in Terminal</figcaption></figure><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es me"><img src="../Images/610fa534196dad904a7774e5b50e2e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bqi7gem3j5e5OlfMtht0PQ.gif"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">We download the file using Background Fetch API</figcaption></figure><p id="2455" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">是啊！有用！我们在浏览器的底部栏看到我们的文件下载(我们通常在那里看到常规下载)。那么，如果:</p><ul class=""><li id="975f" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated"><em class="jg">你用app </em>关闭标签:下载会继续，你会在底部栏看到。</li><li id="b563" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated"><em class="jg">你关闭浏览器</em>(点击<code class="du lw lx ly lz b">x</code>按钮):关闭确认出现。如果我们确认—下载仍将继续，现在状态显示在浏览器图标上:</li></ul><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es ml"><img src="../Images/4744fa2b5588b3cd0d7c2fdba04e12b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*E8YUcIMi4aQ6MM3ZR7P4dw.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx">Chrome is downloading the asset without the window open</figcaption></figure><ul class=""><li id="bda7" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated"><em class="jg">您从内存中卸载浏览器</em>(通过从右键菜单中选择<code class="du lw lx ly lz b">Quit</code>):下载将停止，但会在您再次启动浏览器后继续。</li></ul><p id="daa4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">厉害！我们有一个下载机制，它在应用程序状态和浏览器重启时都是持久的。我们甚至可以暂停/取消传输:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es mm"><img src="../Images/08cb73282223902255c0d1ad72e457a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*fvIWzpTlayP1vcp-zS64Qg.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx">Using standard browser download UI to manage background fetches</figcaption></figure><p id="0dbc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">只有一个问题:我们将此资产下载到…任何地方！因为这取决于我们——我们希望如何处理收到的这些字节。是时候实施了！</p><h2 id="2804" class="lb jl hh bd jm lc ld le jq lf lg lh ju ip li lj jy it lk ll kc ix lm ln kg lo bi translated">将接收的数据存储在高速缓冲存储器中的代码</h2><p id="8c15" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">我们现在以简化的形式从<a class="ae jc" href="https://github.com/WICG/background-fetch" rel="noopener ugc nofollow" target="_blank">后台获取API提议报告</a>中获取样本代码。同时，在我们的主应用程序中，让我们将第二个要下载的资产添加到后台获取的相同注册中——根据规范，这是可能的。</p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="585e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们把它分成几个步骤:</p><ul class=""><li id="1b37" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated"><em class="jg">index.html</em>中的按钮点击:我们注册了一个ID为<code class="du lw lx ly lz b">my-fetch</code>的后台获取和一个包含两个文件的数组作为目标。我们可以在那里传递URL数组(这就是我们所做的)或<code class="du lw lx ly lz b">Request</code>(对<em class="jg">上传</em>用例有用)。就在浏览器开始执行这个请求之后(<em class="jg">下载</em>)。</li><li id="1552" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated"><em class="jg">在service-worker.js中下载就绪</em>:服务人员获得<code class="du lw lx ly lz b">backgroundfetchsuccess</code>事件，其中我们:</li></ul><ol class=""><li id="3a06" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb mn kt ku kv bi translated">打开(或创建)名为equals background fetch <code class="du lw lx ly lz b">registration.id</code>的缓存。缓存名称实际上可以是任何字符串。</li><li id="c950" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb mn kt ku kv bi translated">使用<code class="du lw lx ly lz b">registration.matchAll()</code>获取后台获取的所有记录。我们在后台获取注册期间列出的每个记录= URL/请求。</li><li id="6ee5" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb mn kt ku kv bi translated">通过遍历记录来构建承诺数组，等待记录的<code class="du lw lx ly lz b">responseReady</code>被解析，并尝试将该记录的响应放入缓存中。</li><li id="37e7" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb mn kt ku kv bi translated">履行承诺</li></ol><p id="9256" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结果是:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es mo"><img src="../Images/e1f95d9efdf6f07fb4c54d37df3e6eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lz4s8_nwI1wjeaihfrMvZg.gif"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">Downloading two large files</figcaption></figure><p id="62be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看到下载是如何开始的,“使用”图表是如何更新的。在下载期间，我们将数据放在“其他”类别中，然后(在<code class="du lw lx ly lz b">cache.put()</code>)将数据移动到缓存中。如果我们打开“缓存存储”部分，我们会在那里找到这两个大文件(1，39 GB和140 MB)—现在我们可以拦截对它们的请求，并从缓存中为它们提供服务！</p><p id="a805" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还有一件事。根据规范，浏览器应该显示“下载多个文件”确认对话框，如下所示:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div class="er es mm"><img src="../Images/228915fa98384462ff82a9b846277b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*ygTj-yRzpOuqzjX5V75Fgg.png"/></div><figcaption class="ma mb et er es mc md bd b be z dx">Native confirmation dialogue</figcaption></figure><p id="45f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有时它会出现，但大多数时候它并不存在。我试图改变来源，重置缓存，在后台使用不同的资产获取注册，但仍然无法重现这个窗口的持续弹出。很可能是当前Chrome金丝雀版本的错误。无论如何，我可以解释它是如何工作的:如果你点击“阻止”,你改变这个原点的“自动下载”设置，你会在地址栏看到相应的图标:</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es mp"><img src="../Images/c66746c6ebd233d175f5440fac785c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsdEZ2glcpn53pk2jgAuWA.png"/></div></div></figure><p id="e279" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是为什么我们在后台获取注册的<code class="du lw lx ly lz b">catch</code>块中使用了<code class="du lw lx ly lz b">alert()</code>来解释如何解决这个问题。最有可能的错误原因正是这个设置。</p><p id="8cf0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后一个与代码相关的注释。如果后台获取注册成功，我们为什么要禁用“在本地存储资产”按钮？为了避免另一个可能的错误:用同一个id重复注册。如果第一个注册是活动的(执行网络传输)，则具有相同ID <em class="jg">的第二个注册将被拒绝</em>。传输完成后，相应的后台获取注册将被删除，如果我们希望执行与刚刚完成的操作完全相同的操作，我们可以启用按钮(此时未实现)。</p><p id="e031" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一些观察结果:</p><ul class=""><li id="d4e0" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">这个转移既不出现在<em class="jg"> DevTools - &gt;网络</em>标签中，也不出现在Chrome金丝雀的<em class="jg">下载</em>部分。从这个意义上说，这是100%真实的后台获取。</li><li id="505d" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">在<em class="jg"> DevTools - &gt; Network </em>选项卡中打开“离线”复选框不会影响传输。</li><li id="2df4" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">从内存中卸载浏览器后继续下载会很奇怪。传输再次开始，但每次状态改变后流程停止:下载第一个文件后，您必须重启浏览器开始下载第二个文件。下载完第二个文件后，你必须重启浏览器来调用<code class="du lw lx ly lz b">backgroundfetchsuccess</code>事件。我希望这将在发布版本中得到解决。</li></ul><p id="4e85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以<em class="jg">几乎</em>一切都很好，但看起来不是很用户友好:准确地说，不是很有信息量。让我们利用这种可能性来提供一些关于资产的元信息，并跟踪进度。</p><h2 id="361c" class="lb jl hh bd jm lc ld le jq lf lg lh ju ip li lj jy it lk ll kc ix lm ln kg lo bi translated">组织一个更好的UX</h2><p id="7996" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">让我们用关于我们想要注册的资产集的元信息将JSON具体化，并为我们的主应用程序和服务人员添加一些额外的特性:</p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="23b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">新增内容:</p><ul class=""><li id="bfce" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">带有一些设置的JSON文件(关于这个资产集的元信息)。我们<code class="du lw lx ly lz b">fetch</code>在主应用程序和服务人员中都有这些数据。在现实生活中，这可能是对您的后端API的调用——根据其ID(在我们的代码中硬编码为<code class="du lw lx ly lz b">'series’</code>)获取这个特定资产集的设置。</li><li id="97af" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated"><em class="jg">index.html</em>:我们现在将可选参数<code class="du lw lx ly lz b">options</code>传递给包含<code class="du lw lx ly lz b">title</code>、<code class="du lw lx ly lz b">icons</code>、<code class="du lw lx ly lz b">downloadTotal</code>的后台获取注册，这些属性几乎不言自明。此外，我们将<code class="du lw lx ly lz b">progress</code>事件监听器附加到后台获取注册，在那里我们可以访问<code class="du lw lx ly lz b">downloaded</code>属性，该属性以一定的周期变化。</li><li id="a67e" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated"><em class="jg"> service-worker.js </em>:无论主操作成功还是失败，我们都用当前状态和我们在JSON设置文件中指定的后台获取的<em class="jg">标题</em>来更新下载指示器。当然，代替这个可选的title属性，我们可以为主应用程序和服务工作者消息使用后台获取注册ID，但是这个ID不是用于UI的(例如，它可以是一个长的自动生成的唯一散列字符串)，所以提供人类友好的标题是一个非常好的主意。</li></ul><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es mq"><img src="../Images/6b4962299d65464ce1b15b38f7f15193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QiiKy6y6RBYeO4X9YXkztQ.gif"/></div></div></figure><p id="d1a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们完全控制了文本和用户通知。一些注意事项:</p><ul class=""><li id="b713" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">我无法显示自定义图标。也许这个特性还没有实现，或者我使用了错误的对象格式。</li><li id="5438" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">我们在后台获取注册时传递的<code class="du lw lx ly lz b">downloadTotal</code>属性是整个集合的总字节数。也是可选的。如果通过，它就像一个守卫——如果资源的总大小更大，我们将在服务工作器中得到<code class="du lw lx ly lz b">backgroundfetcherror</code>事件。此外，如果需要，它也是我们UI显示正确下载百分比的好帮手。不幸的是，还有另一个错误:至少在Mac OS上，这个数字不能大于2147483647 (2 GB)，这是文件系统中一个文件的最大大小，但它应该是整个<em class="jg">集</em>的最大总大小。关于这一点，我将向Chromium bug Tracker<a class="ae jc" href="https://bugs.chromium.org/p/chromium/issues/list?q=component:Blink%3EBackgroundFetch" rel="noopener ugc nofollow" target="_blank">提交一个Bug。同时，如果总的集合大小没有超过2GB(就像我们的例子)，我们的计算是正确的。</a></li></ul><p id="b733" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们为服务人员添加一些更有用的处理程序，并尝试一些非标准情况来调用一些错误。</p><h2 id="b15e" class="lb jl hh bd jm lc ld le jq lf lg lh ju ip li lj jy it lk ll kc ix lm ln kg lo bi translated">处理错误</h2><p id="ae59" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">到目前为止，我们只看到了最好的情况，即一切都按计划进行，但在处理网络连接时，情况并非总是如此。让我们为服务人员添加更多的处理程序，为各种可能的错误做好准备。同样，我们将使用来自<a class="ae jc" href="https://github.com/WICG/background-fetch" rel="noopener ugc nofollow" target="_blank">后台获取API提议报告</a>的代码作为基础。</p><figure class="lp lq lr ls fd lt"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="c287" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们期望什么:</p><ul class=""><li id="2fce" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated"><em class="jg">任何类型的失败</em> —让我们尝试至少将我们已经下载的内容保存到缓存中(并让我们继续处理下一个资产，如果有的话)</li><li id="a507" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated"><em class="jg">如果用户中止传输</em> —我们不会存储可能下载的内容</li><li id="9123" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated"><em class="jg">与错误无关bu有用的处理程序</em> —如果用户点击此传输信息栏，我们只需打开新选项卡，其中包含我们在JSON文件中指定的URL和资产设置</li></ul><p id="5e52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">演示时间！让我们为集合中的一个资产指定错误的URL:<code class="du lw lx ly lz b">assets/s01e01.avi</code>(不是。mpg):</p><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es mr"><img src="../Images/da604e44b7a408f91518d95638a16a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VE-o1EzCCB5xp2iqvh6RBg.gif"/></div></div></figure><p id="48cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">后台获取以<code class="du lw lx ly lz b">backgroundfetchfail</code>事件结束，其中<code class="du lw lx ly lz b">registration.failureReason</code>等于“<em class="jg">不良状态</em>”。重要的是，尽管某个特定资产出现错误，我们仍可以继续处理下一个资产，并且可以缓存我们之前所有的成功响应。</p><p id="524d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我的另一个尝试调用不同类型的错误:</p><ul class=""><li id="4172" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">从其他来源下载资产。如果CORS设置好了，它就能正常工作。如果没有—我们以“<em class="jg">获取错误</em>”作为<code class="du lw lx ly lz b">registration.failureReason</code>的<code class="du lw lx ly lz b">backgroundfetchfail</code>事件结束。您只能指定HTTPS驱动的源(或本地主机)。</li><li id="01e5" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">关闭服务器，等待网络超时—“<em class="jg">不良状态</em></li><li id="607c" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">关闭服务器并再次启动(模拟暂时停止服务)—效果不佳。它在服务器上线后恢复传输，但很快向<code class="du lw lx ly lz b">backgroundfetchfail</code>发送“<em class="jg">错误状态</em>”。此外，我们有不一致的配额使用数量:</li></ul><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es ms"><img src="../Images/10f3a388bbb37054ecfa759cab85a524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EYoDOamIjretIZ_SVylAZA.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">Three different values for what has been downloaded</figcaption></figure><ul class=""><li id="5da5" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">这种情况下还有两个问题。首先，第二个文件的下载甚至没有开始(尽管服务器是活动的)。第二，缓存浏览器中显示的“<em class="jg"> Content-Length </em>”令人困惑地等于完整的文件大小，尽管我们只能下载该资产的一部分:</li></ul><figure class="lp lq lr ls fd lt er es paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="er es mt"><img src="../Images/a589f9d3f41f09f1002edd85b9830011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7xnX7TfQ95z11FHpwB51g.png"/></div></div><figcaption class="ma mb et er es mc md bd b be z dx">And value number four…</figcaption></figure><p id="841c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上述错误给了我们一个机会来缓存可以成功下载的内容。根据<a class="ae jc" href="https://github.com/WICG/background-fetch" rel="noopener ugc nofollow" target="_blank">规范提案</a>，与<code class="du lw lx ly lz b">downloadTotal</code>属性相关的错误的行为是不同的。让我们将它设置为等于<em class="jg">140015339</em>——我们的“小”资产(<em class="jg"> s01e02.mpg </em>)的精确字节大小。传输开始后，我们收到带有“<em class="jg">总下载量超过</em>”的<code class="du lw lx ly lz b">backgroundfetchfail</code>。这是意料之中的事——<em class="jg">s01e 01 . mpg</em>大于此限制。我们没有预料到的是(但根据规范这是正确的)——在这种情况下，即使是<em class="jg"> s01e02.mpg </em>也不会被缓存——传输操作在出现“<em class="jg">total-download-exceed</em>”错误时立即中止。我们甚至不能将适当大小的资产放入缓存。因此，如果我们从要获取的URL数组中删除这个“大小不正确”的文件，<em class="jg"> s01e02.mpg </em>将位于缓存中。</p><p id="84e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们服务工作器中的最后一个处理程序——<code class="du lw lx ly lz b">backgroundfetchclick</code>——与错误处理无关。这就是当用户点击这个下载信息栏时发生的情况。在我们的例子中，我们用配置中提供的URL打开一个新的选项卡。</p><p id="bab1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">演示的完整代码(下载图像而不是大型电影文件)可从以下网址获得:</p><ul class=""><li id="0397" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">在<a class="ae jc" href="https://github.com/webmaxru/background-fetch" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上</li><li id="9697" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">关于<a class="ae jc" href="https://background-fetch.glitch.me/" rel="noopener ugc nofollow" target="_blank">故障</a></li></ul><h1 id="3fca" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="78a4" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">在我看来，后台获取API可能是PWA概念的“下一件大事”。在大型应用程序资产网络操作方面，有许多有趣的用例使web应用程序与本地应用程序一样强大。但是也有一些风险:</p><ul class=""><li id="ebcc" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated"><em class="jg">浏览器厂商采用</em>。是的，我们都知道PWA中的一切都基于"<em class="jg">渐进增强</em>"的理念，我们必须以这种方式设计我们的应用，并使用特征检测积极构建我们的应用。但是我真的不想有一些特定于这个或那个供应商的API。</li><li id="a370" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated"><em class="jg">用户保护。</em>浪费网络流量消耗，废弃资源乱放存储，暴露下载网址列表破坏隐私是我主要关注的问题。规范作者和开发人员都应该非常认真地对待下载和存储大型资源的问题。</li></ul><p id="40a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我不想以“风险”的陈述来结束这篇文章，所以让我给你一个后台获取流程自动化的模块/库/包的概念。让我们假设我们想给我们的用户在本地存储一些静态文件(MP3？)在我们的服务器上。</p><ul class=""><li id="b070" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">使用某种构建助手，我们生成后台获取清单(看起来像我们在演示中使用的JSON设置文件)。它可能是遍历文件夹的脚本。</li><li id="1fac" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">在我们的应用程序UI中，我们现在可以生成资产列表。比如文件名+“本地存储”按钮。</li><li id="082e" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">我们在某种API上达成了一致——比如“单击<em class="jg">本地存储</em>按钮，我们将文件名发送到<em class="jg">/存储管理器</em>端点”。另一个要删除的端点。</li><li id="7d1c" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">此外，在该列表生成期间，检查缓存存储中该资产的状态是有意义的。如果它在那里，我们有“从设备中删除”按钮，而不是“存储”。</li><li id="c3e5" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">在我们的服务工作者中，基于我们刚刚在上面构建的后台获取清单和API，我们为“获取”事件生成路由。现在，我们可以在应用程序发出请求后，在我们的服务人员中注册后台获取。</li></ul><p id="4a67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你想把它实现为一个独立的助手或者一个工具箱的插件，我会给你更多的细节。</p><p id="3fea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们从后台获取API开始我们的实验吧！</p><h1 id="61c2" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">关于我</h1><p id="ad5e" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">我对PWA话题很感兴趣。并且一天比一天深入:)我称自己为PWAdvocate，因为我通过提供这个主题的最新更新，通过介绍和分享开发人员友好和用户友好的方法来构建应用程序，通过回答问题来支持开发人员(作为一名开发人员)。你可以在很多会议上看到我的演讲和培训(我每年有100+次飞行)——欢迎来和我聊聊PWA，Web平台，开发者社区！</p><p id="7077" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，我欢迎2019年在您的会议或私人企业会议/训练营/hackaton上发言/培训的邀请——只需在<a class="ae jc" href="https://twitter.com/webmaxru" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上给我发消息。</p></div></div>    
</body>
</html>