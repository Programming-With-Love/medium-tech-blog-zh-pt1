<html>
<head>
<title>Mouse Control for Shooting Game using OpenCV and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用OpenCV和Python实现射击游戏的鼠标控制</h1>
<blockquote>原文：<a href="https://medium.easyread.co/mouse-control-for-shooting-game-using-opencv-and-python-452c3446d1a3?source=collection_archive---------0-----------------------#2020-07-06">https://medium.easyread.co/mouse-control-for-shooting-game-using-opencv-and-python-452c3446d1a3?source=collection_archive---------0-----------------------#2020-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9923" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何在不触摸鼠标的情况下控制鼠标的基本概念/想法。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/28bd015154177a24e1f0873c8b279a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DTv5Y15asoQWmeKh9LwJyg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://pixabay.com/photos/children-win-success-video-game-593313/" rel="noopener ugc nofollow" target="_blank">pixabay.com</a></figcaption></figure><p id="bf95" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">大家好！在差不多两个星期没有发布新的故事之后，我终于回来了！！我仍然想分享一些与软件工程领域技术相关的经验、想法或观点！！最近，我了解了人工智能，尤其是在计算机视觉领域。当我们谈论计算机视觉时，也许OpenCV会首先出现在我们的脑海中。是的，因为OpenCV是一个非常受欢迎的计算机视觉库，并且是BSD许可下的开源库！请访问官方网站<a class="ae ks" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank">https://opencv.org/</a>了解更多信息！</p><p id="be34" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">OpenCV的应用领域非常广泛，例如面部识别系统、手势识别、运动跟踪等。然而，在本主题中，我们将只尝试图像处理区域来检测对象的颜色。正如这个故事的标题，我们将尝试玩一个简单的射击游戏，它只需要一个动作和鼠标左键点击，但我们将使用OpenCV识别的对象颜色来控制它！！对于编程语言，我们将使用Python，因为它在人工智能、物联网等领域非常流行。</p><p id="7812" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我将总结一下这个实验我们需要什么。</p><ul class=""><li id="981c" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">简单的射击游戏</li><li id="7356" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">2个对象</li><li id="e8ad" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">计算机编程语言</li><li id="112d" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">OpenCV</li></ul><h1 id="45bd" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">射击游戏</h1><p id="9035" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">我们将玩什么游戏？它叫做地铁警察。经典世嘉街机游戏Virtua Cop的Demake，如果你玩过的话。游戏可以在这个链接【https://helpcomputer.itch.io/metro-cop<a class="ae ks" href="https://helpcomputer.itch.io/metro-cop" rel="noopener ugc nofollow" target="_blank">的</a>中在线获得。我们可以用浏览器轻松播放。就像我说的，这个游戏只需要移动和点击鼠标。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/04d5d0e2fe219212fdada228c126273e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/1*LpGbP6AQRpU36UOhkZWKqw.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture Metro Cop Game by indieretronews.com</figcaption></figure><h1 id="f618" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">目标</h1><p id="1ee9" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">在这个例子中，我使用了两个物体，橙色的用于移动，绿色的用于点击。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nb"><img src="../Images/64f9e81e93c5cf0dd560634676b05bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7MBS1SLcYnbS3T_3NP0iWQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture 1 My Objects</figcaption></figure><h1 id="bbc0" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">计算机编程语言</h1><p id="53dc" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">运行这个实验的时候我的Python版本是3.7.7。访问位于https://www.python.org/<a class="ae ks" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank">的Python官方网站</a>，了解更多关于如何在您的环境中安装的信息。因为我假设您的机器上已经安装了Python。</p><h1 id="77be" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">OpenCV</h1><p id="4b96" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">而我写这个故事的时候OpenCV版本是4.2.0。我还假设您已经安装了OpenCV。访问我之前提到的官方链接，了解更多关于如何安装OpenCV的信息。</p><h1 id="4675" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">构建基本应用程序</h1><p id="3c69" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">确保您的系统上安装了pip。Pip是Python的一个包安装程序。通常，当我们使用从<a class="ae ks" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank">python.org</a>下载的Python 2 &gt;=2.7.9或Python 3 &gt;=3.4时，pip就已经安装好了。这次我的pip版本是20.0.2。</p><p id="4aa6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们需要为Python安装OpenCV包。请点击此链接<a class="ae ks" href="https://pypi.org/project/opencv-python/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/opencv-python/</a>获取指导。</p><p id="b11f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了验证我们的环境是否已经准备好，编写一个简单的应用程序来读取我们的网络摄像头，并在一个窗口中输出视频。将文件保存为<code class="fe nc nd ne nf b"><strong class="kv io">main.py</strong></code>。使用命令<code class="fe nc nd ne nf b"><strong class="kv io">python3 main.py</strong></code>运行应用程序</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ni"><img src="../Images/aee009af9b0ef5f46d48ba87f5c92e42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5Mrwz0_zLtDdHyFX5S-YA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture 2 Basic OpenCV App</figcaption></figure><p id="5ad9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你得到了如上图的结果，是的，这意味着我们准备好进入下一步了！我将快速解释一下代码。</p><p id="118a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们需要使用<code class="fe nc nd ne nf b"><strong class="kv io">import cv2</strong></code>导入开放的cv库。然后使用此代码<code class="fe nc nd ne nf b"><strong class="kv io">cap = cv2.VideoCapture(0)</strong></code> <strong class="kv io"> 0 </strong>访问我们的摄像头以捕捉视频，0 表示我们的PC/笔记本电脑的默认摄像头，如果我们有几个摄像头，则该数字是指USB端口号。</p><p id="d2bb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们需要使用<code class="fe nc nd ne nf b"><strong class="kv io">while True</strong></code>将捕获的图像作为视频输出进行循环。之后要用<code class="fe nc nd ne nf b"><strong class="kv io">cap.read()</strong></code>功能逐帧捕捉。默认情况下，相框不像我们在镜子里看到的自己。我个人比较喜欢翻翻。我们需要<code class="fe nc nd ne nf b"><strong class="kv io">frame = cv2.flip(frame, 1)</strong></code>来制作这个。<br/> <code class="fe nc nd ne nf b"><strong class="kv io">1(&gt;0)</strong></code> <strong class="kv io"> </strong>为横向，<code class="fe nc nd ne nf b"><strong class="kv io">0</strong></code>为纵向，<code class="fe nc nd ne nf b"><strong class="kv io">&lt;1</strong></code>为纵向和横向。</p><p id="05d9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nc nd ne nf b"><strong class="kv io">cv2.waitKey(1)</strong></code>将显示一帧1 ms，之后显示屏将自动关闭。<code class="fe nc nd ne nf b"><strong class="kv io">if key == 27</strong></code>表示<code class="fe nc nd ne nf b"><strong class="kv io">ESC</strong></code>键码，当我们按下时，窗口将关闭。</p><p id="e4c9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，使用<code class="fe nc nd ne nf b"><strong class="kv io">cv2.imshow("frame", frame)</strong></code>显示结果帧。“框架”字符串将成为窗口的标题。一切完成后，使用<code class="fe nc nd ne nf b"><strong class="kv io">cap.release()</strong></code>和<code class="fe nc nd ne nf b"><strong class="kv io">cv2.destroyAllWindows()</strong></code>释放捕捉</p></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><h1 id="c218" class="md me in bd mf mg nq mi mj mk nr mm mn jt ns ju mp jw nt jx mr jz nu ka mt mu bi translated">寻找物体的颜色</h1><p id="96f0" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">也许我们对颜色名称有相同的理解。比方说，在这个实验中，我提到了橙色和绿色。但是在你这边，对我来说可能是另一种橙绿色。解决方案是我们将使用OpenCV跟踪颜色，为我们的“橙色”或“绿色”找到最佳范围。我们将转换为HSV(色调、饱和度、值)，而不是使用RGB(红、绿、蓝)颜色模型值。让我们构建这个简单的轨迹颜色应用程序。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7989" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">保存文件，假设为<code class="fe nc nd ne nf b"><strong class="kv io">main.py</strong></code>并使用<code class="fe nc nd ne nf b"><strong class="kv io">python3 main.py</strong></code>命令运行。我们将得到3个帧:命名为<strong class="kv io"> <em class="nv">帧</em> </strong>、<strong class="kv io"> <em class="nv">蒙版、</em> </strong>和<strong class="kv io"> <em class="nv">结果</em> </strong>和一个跟踪条的小窗口。要查找对象的颜色，请将对象放在框架内，并在跟踪条中调整“下”(左高、L-S、左低)和“上”( U-高、U-S、U-V)的值。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/65b1fd9d5f35c228fdca4a774fd45b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22BMF3-tN2lThhuPS6j1dA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture 3 Tracking Object Color</figcaption></figure><p id="66c2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">是的，我们得到了橙色范围！正如你所看到的，遮罩和结果框将只显示橙色！还是，迷茫？让我解释一下，也是为了代码。</p><p id="bf0c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们通过添加以下代码来创建跟踪条。</p><pre class="kd ke kf kg gt nx nf ny nz aw oa bi"><span id="90ab" class="ob me in nf b gy oc od l oe of">def nothing(x):<br/>    pass</span><span id="f180" class="ob me in nf b gy og od l oe of">cap = cv2.VideoCapture(0)</span><span id="b95c" class="ob me in nf b gy og od l oe of">cv2.namedWindow('Trackbars')<br/>cv2.createTrackbar('L - H', 'Trackbars', 0, 179, nothing)<br/>cv2.createTrackbar('L - S', 'Trackbars', 0, 255, nothing)<br/>cv2.createTrackbar('L - V', 'Trackbars', 0, 255, nothing)<br/>cv2.createTrackbar('U - H', 'Trackbars', 179, 179, nothing)<br/>cv2.createTrackbar('U - S', 'Trackbars', 255, 255, nothing)<br/>cv2.createTrackbar('U - V', 'Trackbars', 255, 255, nothing)</span></pre><p id="440f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">开始时，<code class="fe nc nd ne nf b"><strong class="kv io">cv2.nameWindows('windowName')</strong></code>会根据输入值创建一个新的命名窗口。<br/>接下来，<code class="fe nc nd ne nf b"><strong class="kv io">cv2.createTrackbar('trackbarName', ‘windowName’, minValue, maxValue, callBackOnChange)</strong></code>将根据配置创建跟踪条:跟踪条名称、引用窗口名称、最小值、最大值，以及调用更改。因为色相最大值是179，我们只为h .设置，其余为255。因为我们不想做任何事情，所以我们创建了一个函数，对回调做任何事情。</p><p id="ed2a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们将使用这个代码<code class="fe nc nd ne nf b"><strong class="kv io">hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</strong></code>把颜色转换成HSV。HSV框架看起来怎么样？你可以看到下面的图片，似乎令人毛骨悚然:)</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/428db8dc615fa785acb684138e302cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sGY8kJUvi1CsnwZ-rQBojQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture 4 HSV Look Like</figcaption></figure><p id="f9e3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，我们将根据跟踪条和窗口名称从跟踪条中获取值。</p><pre class="kd ke kf kg gt nx nf ny nz aw oa bi"><span id="a739" class="ob me in nf b gy oc od l oe of">l_h = cv2.getTrackbarPos('L - H', 'Trackbars')<br/>l_s = cv2.getTrackbarPos('L - S', 'Trackbars')<br/>l_v = cv2.getTrackbarPos('L - V', 'Trackbars')<br/>u_h = cv2.getTrackbarPos('U - H', 'Trackbars')<br/>u_s = cv2.getTrackbarPos('U - S', 'Trackbars')<br/>u_v = cv2.getTrackbarPos('U - V', 'Trackbars')</span></pre><p id="2bf2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们将从HSV帧中找出我们已经调整过的从下到上的对象颜色。这一帧的输出，正如你在<strong class="kv io"> <em class="nv">图3 </em> </strong>上看到的，是第二帧。我们将得到白色的物体颜色，黑色的背景。为了方便使用数组，我们使用了<code class="fe nc nd ne nf b"><strong class="kv io">numpy</strong></code>。并且<code class="fe nc nd ne nf b">inRange</code>代码将在较低和较高HSV值之间查看对象。</p><pre class="kd ke kf kg gt nx nf ny nz aw oa bi"><span id="13c0" class="ob me in nf b gy oc od l oe of">import numpy as np</span><span id="61e4" class="ob me in nf b gy og od l oe of">...</span><span id="66c0" class="ob me in nf b gy og od l oe of">lower = np.array([l_h, l_s, l_v])<br/>upper = np.array([u_h, u_s, u_v])<br/>mask = cv2.inRange(hsv, lower, upper)</span></pre><p id="7f5e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，<code class="fe nc nd ne nf b"><strong class="kv io">bitwise_and</strong></code>代码将在<strong class="kv io">画面3 </strong>上创建第三帧输出。基于遮罩框架，我们将获得相同的对象，但具有原始颜色。</p><pre class="kd ke kf kg gt nx nf ny nz aw oa bi"><span id="1047" class="ob me in nf b gy oc od l oe of"><strong class="nf io">result = cv2.bitwise_and(frame, frame, mask=mask)</strong></span></pre><p id="5c15" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，用这段代码显示所有的帧。</p><pre class="kd ke kf kg gt nx nf ny nz aw oa bi"><span id="71e5" class="ob me in nf b gy oc od l oe of">cv2.imshow('frame', frame)<br/>cv2.imshow('mask', mask)<br/>cv2.imshow('result', result)</span></pre><p id="aac6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">按照上面的步骤找出绿色。最后，这是我的颜色范围:</p><pre class="kd ke kf kg gt nx nf ny nz aw oa bi"><span id="7ed7" class="ob me in nf b gy oc od l oe of">lower_orange = np.array([0, 109, 195])<br/>upper_orange = np.array([17, 255, 255])</span><span id="9697" class="ob me in nf b gy og od l oe of">lower_green = np.array([37, 130, 95])<br/>upper_green = np.array([48, 190, 173])</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oi"><img src="../Images/f1293045cb0e5ae541bc370bded00cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1E0LatArOAAYn0aMa3Mijg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture 5 Tracking Another Object Color</figcaption></figure></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><h1 id="4ec1" class="md me in bd mf mg nq mi mj mk nr mm mn jt ns ju mp jw nt jx mr jz nu ka mt mu bi translated">构建应用程序</h1><p id="8eaf" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">好了，我们已经得到了物体的颜色范围，是时候构建应用程序了！</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="dabb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一开始，有一个调整窗口大小的函数(<code class="fe nc nd ne nf b"><strong class="kv io">image_resize</strong></code>)。我用这个是因为我想保留两个游戏，我们的框架可以一起放在屏幕上。调整窗口大小但仍然保持纵横比的参考来自这里:<a class="ae ks" href="https://stackoverflow.com/questions/44650888/resize-an-image-without-distortion-opencv" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/44650888/resize-an-image-without-distortion-opencv</a></p><p id="b162" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，也许我们会跳入<code class="fe nc nd ne nf b"><strong class="kv io">cv2.findCountours</strong></code>代码。像<code class="fe nc nd ne nf b">cv2.itwise_and</code>一样，我们将基于遮罩框创建轮廓。轮廓可以简单地解释为连接所有连续点(沿边界)的曲线，具有相同的颜色或强度。<strong class="kv io">RETR _外部</strong>表示仅检索最外轮廓。并且<strong class="kv io"> CHAIN_APPROX_SIMPLE </strong>将压缩水平、垂直和对角线段，只留下它们的端点。</p><p id="65c5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">轮廓包含多个坐标，这就是为什么我们需要使用<code class="fe nc nd ne nf b"><strong class="kv io">for c in contours</strong></code>代码循环轮廓。我们还需要检查轮廓大小区域，确保使用<code class="fe nc nd ne nf b"><strong class="kv io">cv2.contourArea(contour)</strong></code>检测到的区域大小合理。为了绘制轮廓，我们使用了<code class="fe nc nd ne nf b"><strong class="kv io">cv2.drawContours(img, contours, countourIdx, color, thickness)</strong></code>功能。绘制轮廓的结果会像下图一样。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/3b5696891964d98fefdfd18aabf21d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qJMYLZ6T4k-x3MnICCPHA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture 6 Draw Countour Based on Mask Color</figcaption></figure><p id="aee3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">很好，现在，我们将整合轮廓和鼠标控制功能。经过研究，我发现了几个控制鼠标的模块。首先，PyAutoGUI(<a class="ae ks" href="https://pypi.org/project/PyAutoGUI/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/PyAutoGUI/</a>)。但是，在我看来，很慢。跟不上我们的手势。然后，我寻找另一种解决方案，找到了py mouse(<a class="ae ks" href="https://pypi.org/project/PyMouse/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/PyMouse/</a>)。这样更好！我想我对目前的状况没有意见。</p><p id="d646" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么，我们如何移动和点击鼠标呢？PyMouse已经有这个功能了。我们需要使用<code class="fe nc nd ne nf b"><strong class="kv io">from pymouse import PyMouse</strong></code>导入模块，并像这样初始化变量<code class="fe nc nd ne nf b"><strong class="kv io">m = PyMouse()</strong></code></p><p id="967f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，我们可以使用<code class="fe nc nd ne nf b"><strong class="kv io">m.move(x, y)</strong></code>和<code class="fe nc nd ne nf b"><strong class="kv io">m.click(x, y, 1)</strong></code>来控制鼠标。<code class="fe nc nd ne nf b"><strong class="kv io">(x, y)</strong></code>表示指针的坐标。我们在哪里可以得到坐标？实际上是轮廓。如果我们看橙色轮廓，我们会看到<code class="fe nc nd ne nf b"><strong class="kv io">x, y, _, _ = cv2.boundingRect(c)</strong></code>，它将从我们的轮廓返回位置。而且PyMouse还有一个返回当前位置的函数，所以如果我们要点击什么东西，就需要坐标，对吧？然后，我们应该得到当前位置，以避免在使用<code class="fe nc nd ne nf b"><strong class="kv io">x, y = m.position()</strong></code>进行点击时错过位置。</p><p id="a7ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nv">耶</em>，我想这就是对这个简单实验的解释了。<em class="nv">哦对了，</em>我正在添加一个规则，用于延迟点击。因为根据我的经验，如果我们在检测到绿色时没有实现这一点，它会在点击功能上快速循环，我们的手势无法处理这一速度。这就是为什么我要设置一些规则来检查最后一次点击，以避免多次点击。</p><p id="c974" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好吧，玩这个怎么样？下面这张图你可以跟着我的手。当我们想开枪的时候，我们会张开大拇指。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ok"><img src="../Images/3744786aeecbf699de18af97233e05d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3OiqYD7dRAVVqrMHEdOQ-g.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture 7 Object Position</figcaption></figure></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><h1 id="e425" class="md me in bd mf mg nq mi mj mk nr mm mn jt ns ju mp jw nt jx mr jz nu ka mt mu bi translated">测试</h1><p id="9afc" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">酷，我们已经建立了应用程序。是时候做测试了！我们需要使用<code class="fe nc nd ne nf b">python3 main.py</code>运行应用程序，并使用浏览器打开游戏的URL。确保浏览器选项卡处于活动模式。试着移动橙色的东西作为我们的指针。很好，是工作！接下来，试着打开我们的拇指检测绿色作为点击功能。耶！点击了！现在我们可以不用触摸鼠标/触摸板就可以玩游戏了！！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/d7844e162613e9ce650aa3c7ab8346ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*3duiUJnmy6bwI0D25H-J1g.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture 8 Testing the App</figcaption></figure></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><h1 id="1aa0" class="md me in bd mf mg nq mi mj mk nr mm mn jt ns ju mp jw nt jx mr jz nu ka mt mu bi translated">改进</h1><p id="cb7d" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">我知道这是一个基本的应用程序，或者只是一个不用直接触摸就能控制鼠标的想法。也许有很多功能不能正常工作。我找到的例子是:</p><ul class=""><li id="2c4b" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">指针无法到达屏幕底部。当你这边的游戏屏幕变大时，这将成为一个问题。</li><li id="7bab" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">当我们周围的背景颜色相同时，颜色可能会发生冲突。也许我们可以添加额外的规则，比如形状+颜色，而不是只使用颜色。</li></ul><p id="4414" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是为什么如果你对此有一些改进的想法或建议，可以直接做个PR！谢谢大家！这里是这个实验的GitHub库。</p><div class="om on gp gr oo op"><a href="https://github.com/moemoe89/py-opencv-kumis" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd io gy z fp ou fr fs ov fu fw im bi translated">moemoe89/py-opencv-kumis</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">在GitHub上创建一个帐户，为moemoe89/py-opencv-kumis开发做贡献。</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">github.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd km op"/></div></div></a></div><h1 id="6a06" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">参考</h1><ul class=""><li id="a88b" class="lp lq in kv b kw mv kz mw lc pe lg pf lk pg lo lu lv lw lx bi translated"><a class="ae ks" href="https://pysource.com/" rel="noopener ugc nofollow" target="_blank">https://pysource.com/</a></li><li id="cbf2" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">https://www.pyimagesearch.com/<a class="ae ks" href="https://www.pyimagesearch.com/" rel="noopener ugc nofollow" target="_blank"/></li></ul></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ph nh l"/></div></figure></div></div>    
</body>
</html>