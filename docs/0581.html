<html>
<head>
<title>Built-in Delegates</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内置委托</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/built-in-delegates-4811947e781f?source=collection_archive---------4-----------------------#2020-11-09">https://medium.com/androiddevelopers/built-in-delegates-4811947e781f?source=collection_archive---------4-----------------------#2020-11-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/fc82c9fa6e27477c74910d831194b1ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9peGthDF8Psx-2nO"/></div></div></figure><div class=""/><p id="a9fe" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">代表第二部分</p><p id="de2a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">委托帮助你将任务委托给其他对象，并提供更好的代码重用，你可以在<a class="ae jn" rel="noopener" href="/androiddevelopers/delegating-delegates-to-kotlin-ee0a0b21c52b">这篇文章</a>中了解更多。Kotlin不仅支持用关键字<code class="du jo jp jq jr b">by</code>实现委托的简单方法，还在Kotlin标准库中提供了内置的委托，如<code class="du jo jp jq jr b">lazy()</code>、<code class="du jo jp jq jr b">observable()</code>、<code class="du jo jp jq jr b">vetoable()</code>和<code class="du jo jp jq jr b">notNull()</code>。让我们看看这些内置的委托以及它们是如何工作的。</p><h1 id="db9e" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">懒惰()</h1><p id="b90f" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html#kotlin$lazy(kotlin.Function0((kotlin.lazy.T)))" rel="noopener ugc nofollow" target="_blank">lazy()</a></code>函数是一个属性委托，它帮助你延迟初始化属性，也就是在第一次访问它们的时候。<code class="du jo jp jq jr b">lazy()</code>对于制作昂贵的物品非常有用。</p><p id="d44d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">lazy()</code>接受两个参数，一个<code class="du jo jp jq jr b">LazyThreadSafetyMode</code>枚举值和一个lambda。</p><p id="2342" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">LazyThreadSafetyMode</code>参数指定了初始化如何在不同线程之间同步，而<code class="du jo jp jq jr b">lazy()</code>使用默认值<code class="du jo jp jq jr b">LazyThreadSafetyMode.SYNCHRONIZED</code>，这意味着初始化是线程安全的，代价是显式同步会对性能产生轻微影响。</p><p id="c568" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">lambda在第一次访问属性时执行，然后存储其值以供将来访问。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="6d18" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在后台</h1><p id="fe70" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">当检查反编译的Java代码时，我们看到Kotlin编译器为惰性委托创建了一个类型为<code class="du jo jp jq jr b">Lazy</code>的引用。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="dcfc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个委托由<code class="du jo jp jq jr b">LazyKt.lazy()</code>函数用您指定的lambda和线程安全模式参数初始化。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="f15e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们来看看<code class="du jo jp jq jr b"><a class="ae jn" href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/util/Lazy.kt" rel="noopener ugc nofollow" target="_blank">lazy()</a></code>的源代码。由于<code class="du jo jp jq jr b">lazy()</code>函数默认使用<code class="du jo jp jq jr b">LazyThreadSafetyMode.SYNCHRONIZED</code>，它返回一个<code class="du jo jp jq jr b">SynchronizedLazyImpl</code>类类型的<code class="du jo jp jq jr b">Lazy</code>对象。</p><pre class="kv kw kx ky fd lb jr lc ld aw le bi"><span id="4452" class="lf jt hs jr b fi lg lh l li lj">public actual fun &lt;T&gt; lazy(initializer: () -&gt; T): Lazy&lt;T&gt; =<br/>   SynchronizedLazyImpl(initializer)</span></pre><p id="7aab" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当第一次访问委托属性时，调用<code class="du jo jp jq jr b">SynchronizedLazyImpl</code>的<code class="du jo jp jq jr b">getValue()</code>函数，该函数在<code class="du jo jp jq jr b">synchronized</code>块中初始化属性。</p><pre class="kv kw kx ky fd lb jr lc ld aw le bi"><span id="e333" class="lf jt hs jr b fi lg lh l li lj">override val value: T<br/>   get() {<br/>       val _v1 = _value<br/>       if (_v1 !== UNINITIALIZED_VALUE) {<br/>           @Suppress("UNCHECKED_CAST")<br/>           return _v1 as T<br/>       }<br/><br/>       return synchronized(lock) {<br/>           val _v2 = _value<br/>           if (_v2 !== UNINITIALIZED_VALUE) {<br/>               @Suppress("UNCHECKED_CAST") (_v2 as T)<br/>           } else {<br/>               val typedValue = initializer!!()<br/>               _value = typedValue<br/>               initializer = null<br/>               typedValue<br/>           }<br/>       }<br/>   }</span></pre><p id="316b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这保证了惰性对象以线程安全的方式初始化，但是增加了<code class="du jo jp jq jr b">synchronized</code>块的性能成本。</p><blockquote class="lk ll lm"><p id="d764" class="ip iq ln ir b is it iu iv iw ix iy iz lo jb jc jd lp jf jg jh lq jj jk jl jm ha bi translated">注意:如果你确定这个资源会被单线程初始化，可以将<code class="du jo jp jq jr b"> LazyThreadSafetyMode.NONE</code>传递给<code class="du jo jp jq jr b">lazy()</code>，函数在惰性初始化时不会使用<code class="du jo jp jq jr b">synchronized</code>块。然而，请记住<code class="du jo jp jq jr b">LazyThreadSafetyMode.NONE</code>不会改变惰性初始化的同步特性。由于惰性初始化是同步的，所以它仍然需要与第一次访问时对象的非惰性初始化相同的时间。这意味着，如果从UI线程访问对象，需要很长时间初始化的对象仍然会阻塞UI线程。</p><p id="02bd" class="ip iq ln ir b is it iu iv iw ix iy iz lo jb jc jd lp jf jg jh lq jj jk jl jm ha bi translated"><code class="du jo jp jq jr b"><strong class="ir ht">val lazyValue</strong>: String <strong class="ir ht">by </strong><em class="hs">lazy</em>(LazyThreadSafetyMode.<em class="hs">NONE</em>) <strong class="ir ht">{“lazy”}</strong></code></p></blockquote><p id="af15" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">惰性初始化有助于初始化昂贵的资源。但是，对于简单的对象，比如字符串，<code class="du jo jp jq jr b">lazy()</code>通过生成其他对象，比如<code class="du jo jp jq jr b">Lazy</code>和<code class="du jo jp jq jr b">KProperty</code>，增加了开销。</p><h1 id="4ad8" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">可观察量</h1><p id="ffd9" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html" rel="noopener ugc nofollow" target="_blank">Delegates.observable()</a></code>是Kotlin标准库的另一个内置代表。Observer是一种设计模式，在这种模式中，一个对象维护其依赖者的列表，称为<em class="ln">观察者</em>，当其状态改变时会自动通知它们。当一个值发生变化时，需要通知多个对象，而不是让每个依赖对象定期调用并检查资源是否更新，这种模式非常有用。</p><p id="f051" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">observable()</code>有两个参数:初始值和一个侦听器处理程序，当值被修改时，将调用这个处理程序。<code class="du jo jp jq jr b">observable()</code>创建一个<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-observable-property/" rel="noopener ugc nofollow" target="_blank">ObservableProperty</a></code>对象，该对象在每次调用setter时执行您传递给委托的lambda。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="fd7b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">查看反编译的<code class="du jo jp jq jr b">Person</code>类，我们看到Kotlin编译器生成了一个扩展了<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-observable-property/" rel="noopener ugc nofollow" target="_blank">ObservableProperty</a></code>的类。这个类还实现了一个名为<code class="du jo jp jq jr b">afterChange()</code>的函数，它具有传递给可观察委托的lambda函数。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="b42f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">父类<code class="du jo jp jq jr b">ObservableProperty</code>的设置器调用<code class="du jo jp jq jr b">afterChange()</code>函数。这意味着每次调用者为<code class="du jo jp jq jr b">address</code>设置一个新值时，设置者将自动调用<code class="du jo jp jq jr b">afterChange()</code>函数，导致所有的监听器被通知这个变化。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="c0ea" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您还可以在反编译的代码中看到对<code class="du jo jp jq jr b">beforeChange()</code>的调用。<code class="du jo jp jq jr b">beforeChange()</code>不是由可观察委托使用的，而是下一个委托<code class="du jo jp jq jr b">vetoable()</code>的基础。</p><h1 id="be18" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">可否决</h1><p id="c131" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html" rel="noopener ugc nofollow" target="_blank">vetoable()</a></code>是另一个内置委托，其中属性委托对其值的否决权。类似于<code class="du jo jp jq jr b">observable()</code>委托，<code class="du jo jp jq jr b">vetoable()</code>接受两个参数:初始值和一个监听器处理程序，当任何调用者想要修改属性值时，将调用这个处理程序。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="30af" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果lambda条件返回<code class="du jo jp jq jr b">true</code>，属性值将被修改，否则值将保持不变。在这种情况下，如果调用者试图用小于15个字符的内容更新地址，则当前值将被保留。</p><p id="4d77" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">查看反编译的<code class="du jo jp jq jr b">Person</code>类，Kotlin生成了一个扩展了<code class="du jo jp jq jr b">ObservableProperty</code>的新类。生成的类包含了我们在<code class="du jo jp jq jr b">beforeChange()</code>函数中传递的lambda，在设置值之前，setter会调用它。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><h1 id="7a60" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">notNull</h1><p id="d2fe" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">Kotlin标准库提供的最后一个内置委托是<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/not-null.html" rel="noopener ugc nofollow" target="_blank">Delegates.notNull()</a></code>。<code class="du jo jp jq jr b">notNull()</code>只是允许在以后初始化一个属性。<code class="du jo jp jq jr b">notNull()</code>类似于<code class="du jo jp jq jr b"><a class="ae jn" href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables" rel="noopener ugc nofollow" target="_blank">lateinit</a></code>。在大多数情况下，<code class="du jo jp jq jr b">lateinit</code>是首选，因为<code class="du jo jp jq jr b">notNull()</code>为每个属性创建了一个额外的对象。但是，您可以将<code class="du jo jp jq jr b">notNull()</code>用于基本类型，而<code class="du jo jp jq jr b">lateinit</code>不支持这种类型。</p><pre class="kv kw kx ky fd lb jr lc ld aw le bi"><span id="4f30" class="lf jt hs jr b fi lg lh l li lj"><strong class="jr ht">val fullname</strong>: String <strong class="jr ht">by </strong>Delegates.notNull&lt;String&gt;()</span></pre><p id="9760" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">notNull()</code>使用一种特殊类型的<code class="du jo jp jq jr b">ReadWriteProperty</code>命名为<code class="du jo jp jq jr b">NotNullVar</code>。</p><p id="8952" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">查看反编译的代码，<code class="du jo jp jq jr b">fullname</code>属性是用<code class="du jo jp jq jr b">notNull()</code>函数初始化的。</p><pre class="kv kw kx ky fd lb jr lc ld aw le bi"><span id="dfcd" class="lf jt hs jr b fi lg lh l li lj"><strong class="jr ht">this</strong>.<strong class="jr ht">fullname$delegate </strong>= Delegates.<strong class="jr ht"><em class="ln">INSTANCE</em></strong>.notNull();</span></pre><p id="fd28" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该函数返回一个<code class="du jo jp jq jr b">NotNullVar</code>对象。</p><pre class="kv kw kx ky fd lb jr lc ld aw le bi"><span id="fd74" class="lf jt hs jr b fi lg lh l li lj"><strong class="jr ht">public fun </strong>&lt;T : Any&gt; notNull(): ReadWriteProperty&lt;Any?, T&gt; = NotNullVar()</span></pre><p id="1d5b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">NotNullVar</code>类只是保存一个通用的可空内部引用，如果有代码在值初始化之前调用getter，就会抛出<code class="du jo jp jq jr b">IllegalStateException() </code>。</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div></figure><p id="fbee" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Kotlin标准库提供了一组内置的委托，因此您不需要编写、维护和重新发明它们。内置委托延迟初始化字段，允许稍后初始化基元类型，观察并在值更改时得到通知，甚至否决这些更改。</p></div></div>    
</body>
</html>