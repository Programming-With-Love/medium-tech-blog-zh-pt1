<html>
<head>
<title>Best practises for KubernetesPodOperator in Cloud Composer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Cloud Composer中KubernetesPodOperator的最佳实践</h1>
<blockquote>原文：<a href="https://medium.com/compendium/best-practises-for-kubernetespodoperator-in-cloud-composer-91760f848a39?source=collection_archive---------0-----------------------#2020-10-16">https://medium.com/compendium/best-practises-for-kubernetespodoperator-in-cloud-composer-91760f848a39?source=collection_archive---------0-----------------------#2020-10-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="cc93" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我将通过例子介绍使用KubernetesPodOperator的最佳实践。我将分享Dag和terraform脚本，所以你应该很容易测试出来。</p><p id="70cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在谈论Cloud Composer时，我得到的相当多的问题是如何使用它来自动扩展作业操作。根据cloud composer为您提供的(当前)开箱即用设置，您可以实现的可扩展性非常有限。</p><p id="f9de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，cloud composer无法根据工作需求进行水平扩展，因此通常的做法是拥有足够的集群规模和配置来处理任何工作负载。当你想超越最初的设定时，挑战就出现了。假设您突然有了一个需要10Gi内存的作业，但是您的工作节点只有n1台机器？那么，你会以一种成本有效的方式做什么呢？</p><p id="f783" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">python库和依赖性问题呢？如果在没有虚拟环境的情况下使用python操作符，很快就会变得混乱。</p><p id="bc78" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">KubernetesPodOperator是一个出色的操作者，它利用原生的kubernetes功能来执行工作，处理水平缩放和烘焙docker映像中的所有依赖项。你甚至不必使用python——因为它都是集装箱化的！</p><p id="8f9e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我简化了下图中的架构:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/4c6f158ba531180dad9075faf351562c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTt4MN3yeeHTZhxIQKaS7Q.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Simplified illustration of composer internals</figcaption></figure><p id="8954" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，通常您在composer中运行的任务是在绿点内运行的。一个绿点从任务队列中并行选取x个任务，因此如果您正在运行一个cpu繁重的工作负载，它可能也会影响composer中运行的其他作业。如果您正在运行一个内存特别大的任务，整个工作舱可能会被杀死，导致它正在处理的所有任务失败！</p><p id="81ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">KubernetesPodOperator允许我们在一个单独的节点池(机器)中以蓝点的形式产生进程，并为它们分配资源，这样它们就不会从“正常”的作业中获取资源。横向扩展是现成的，因为我们告诉kubernets要使用多少cpu和内存——如果kubernets没有足够的内存来放置蓝点，它将在节点池大小允许的情况下启动一个新的虚拟机，或者优雅地等待资源变得可用。</p><p id="a5ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">KubernetesPodOperator最近越来越受关注，我想分享一些来之不易的经验——如果你愿意，可以说是最佳实践。</p><h1 id="f209" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在Composer中运行窗格</h1><p id="4c7f" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">至少有两个有效的运算符可以做到这一点:</p><h2 id="1810" class="kv jt hh bd ju kw kx ky jy kz la lb kc ip lc ld kg it le lf kk ix lg lh ko li bi translated">1.KubernetesPodOperator</h2><p id="1ad5" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">在当前composer群集中运行pod</p><h2 id="0c44" class="kv jt hh bd ju kw kx ky jy kz la lb kc ip lc ld kg it le lf kk ix lg lh ko li bi translated">2.gkepodooperator</h2><p id="2f9b" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">在任何GKE群集中运行一个pod。请注意，这个操作符有一个关于xcom的已知错误，因此将它与xcom一起使用将不起作用。(<a class="ae lj" href="https://stackoverflow.com/questions/58349627/airflow-gkepodoperator-xcom-push-returns-none/59285712#59285712" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/58349627/air flow-gkepodoperator-xcom-push-returns-none/59285712 # 59285712</a>)</p><blockquote class="lk ll lm"><p id="dbd8" class="ie if ln ig b ih ii ij ik il im in io lo iq ir is lp iu iv iw lq iy iz ja jb ha bi translated">我建议使用KubernetesPodOperator，主要是因为xcom的bug，google对修复这个bug没什么兴趣。</p></blockquote><h1 id="707b" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建单独的节点池来运行您的任务</h1><p id="a9cc" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">创建单独的<em class="ln">自动扩展的</em>节点池来运行您的工作负载。如果你不这样做，你的pod会在composer k8s集群中运行，它们会争夺资源。因为airflow-worker的默认配置是请求0字节的内存(！idspnonenote)。)，气流-如果资源短缺，工人是第一个被驱逐的！</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lr"><img src="../Images/3e536a88e2f2e65578cc5604a48ebcd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rsZ7gA6h_qx6J4DiT4OLw.png"/></div></div></figure><p id="5c7d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您还需要创建规则，防止kubernetes通过使用污点和容忍将composer核心服务迁移到您的新节点池。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ls"><img src="../Images/418f923fd690d059b194929faec8f7a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*ik81vgXnwea7QtShAIcOvQ.png"/></div></figure><p id="14ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">原因很简单:工作负载会崩溃，如果在您有一个昂贵的节点池启动并运行时，意外地(<a class="ae lj" rel="noopener" href="/@ael_78866/troubleshooting-cloud-composer-a2c074c69dcc">这种情况发生在我身上</a>)气流服务崩溃，那么kubernetes很有可能会将气流服务放在该节点上。这将阻止它的规模缩小，因为kubernetes不会自己关闭服务，把它放在别的地方！</p><h1 id="dac6" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">指示作曲者将您的任务放在哪里</h1><p id="8b3d" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">您需要明确地告诉composer您希望它在哪个节点池上运行，并放置正确的容差。如果不这样做，它将在默认节点池中运行，而airflow本身也在默认节点池中运行—这不是一个好主意！</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="61a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于这种配置可能很抽象，所以通常会在dags文件夹中创建一个包，并在其中添加引导代码，从而减少工作中的视觉干扰。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="07b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ln">上图:将语言代码移入包装以减少视觉噪音的示例</em></p><h1 id="43d9" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">始终指定资源请求！</h1><p id="999a" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">这可能是要做的最重要的事情之一。如果在utils函数中包装pod创建，则可以基于资源请求动态选择节点池。(超过5Gi的内存分配给内存较大的节点池，而不到5Gi的内存分配给较便宜的节点池)</p><p id="36c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你不这样做，你会遇到自动伸缩的问题(kubernetes会认为你的作业需要0个资源，并试图把所有的作业放在同一个节点上)和驱逐单元的问题(一旦你用完了资源)。</p><h1 id="6d43" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">指定足够的启动时间</h1><p id="527f" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">pod的默认启动时间是120秒。如果作业的启动时间超过此时间，它将仅在composer中失败。kubernetes调度程序仍然将pod放在它的池中，并且仍然会尝试启动它(并且可能会成功！)给你一些很难调试的案例。</p><p id="9194" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将举例说明:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lv"><img src="../Images/5c1581a77ab6c395de99ca4f5f30ff01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*e-UScLZL0DVnVqzsDJwT0Q.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Job illustration</figcaption></figure><p id="44d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们有一个只有1个节点(n1-highmem-2)的节点池，有2个CPU和13Gi。3Gi任务每个都需要120秒才能完成</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="75b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实际工作的结果</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lw"><img src="../Images/2d4c9f257f7352e6ec04be0e5d59fd09.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*8tsVIMR18TJdBG2EKaWDmQ.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Result in composer</figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lx"><img src="../Images/bc4ac970550517759164fb955a5081d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YjickcmpwgLx14wctH2R-w.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">how it looks in GKE</figcaption></figure><p id="38ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们现在看库伯内特斯，它看起来像这样。红色和绿色似乎有点同步…但是，kubernetes调度程序还没有放弃！</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ly"><img src="../Images/e00e67b1d633e9a4e0090ceb3feb0303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*chL4QbZcZObA570wGGegNQ.png"/></div></figure><p id="b98e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么发生了什么？</p><p id="ba12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3Gi任务每个都需要3Gi内存，需要2分钟才能完成。本例的启动时间设置为60秒。并发设置为10，因此composer将尝试同时启动所有10个。Composer能够启动3个作业，然后它必须等待…其余的作业在composer中失败。但是由于kubernetes调度程序的超时超过了120秒(实际上，kubernetes调度程序并不关心经过了多少时间，它会在放弃之前尝试特定的次数。)—你可以看到这样的错误。相应地设置并发和启动时间(至少600秒)!</p><p id="125b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你在这个<a class="ae lj" href="https://github.com/ael-computas/gcp-cloud-composer-pod-operator" rel="noopener ugc nofollow" target="_blank"> repo </a>里找，你可以找到这个帖子里用到的所有资料来源。通常我在与客户的研讨会上主持这个，所以它可能包含一些我没有详细介绍的额外内容。</p></div></div>    
</body>
</html>