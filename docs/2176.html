<html>
<head>
<title>Developing Backend for Targeted Push Notification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为目标推送通知开发后端</h1>
<blockquote>原文：<a href="https://medium.easyread.co/developing-backend-for-targeted-push-notification-6b605c522c29?source=collection_archive---------1-----------------------#2017-10-07">https://medium.easyread.co/developing-backend-for-targeted-push-notification-6b605c522c29?source=collection_archive---------1-----------------------#2017-10-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9771" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一个我们如何在Kurio从后端开发目标推送通知服务的故事。</h2></div><p id="1b69" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">几周前，我们在<a class="ae ky" href="https://kurio.co.id/" rel="noopener ugc nofollow" target="_blank"> Kurio </a>，正在开发一个新功能。是推荐/定向推送通知。这与我们当前的推送通知系统不同，在当前的推送通知系统中，推送通知是基于我们所拥有的数据发送给所有用户的。通过此功能，每个用户都可以获得不同的推送通知。</p><h2 id="01e9" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">我们的工具</h2><ul class=""><li id="b45b" class="ls lt in ke b kf lu ki lv kl lw kp lx kt ly kx lz ma mb mc bi translated">Go (1.8)</li><li id="8276" class="ls lt in ke b kf md ki me kl mf kp mg kt mh kx lz ma mb mc bi translated">关系型数据库</li><li id="552d" class="ls lt in ke b kf md ki me kl mf kp mg kt mh kx lz ma mb mc bi translated">Google Coud发布订阅</li><li id="4d2b" class="ls lt in ke b kf md ki me kl mf kp mg kt mh kx lz ma mb mc bi translated">云消息传递(GCM，APNS)</li></ul><h1 id="fa78" class="mi la in bd lb mj mk ml le mm mn mo lh jt mp ju lk jw mq jx ln jz mr ka lq ms bi translated">它是如何工作的</h1><p id="bc36" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">我们的旧系统如果画成图可能是这样的:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi mw"><img src="../Images/4e0009fdbaa2feff8d8b17e6bd85ae24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbPVn785jmyo5DMx08BSDA.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Kurio Normal Push</figcaption></figure><p id="3903" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是普通推送通知的工作方式。我们根据关于文章的数据选择一篇文章进行推送，然后从仪表板启动推送通知，这将触发“推送管理”服务。基于推送，每个用户将获得相同的推送通知。</p><p id="27df" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们决定通过发送有针对性的推送来改进它，这样每个用户都可以根据他们之前阅读的内容获得不同的推送通知。</p><p id="5837" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个过程看起来像这样:</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nm"><img src="../Images/e95cf3becf5cf7bdf05a0f495aa77b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R26ciH_w0QfCTVimXTJPLQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Kurio Targeted Push Notification</figcaption></figure><p id="0395" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个新系统看起来更复杂，因为它使用一个外部服务来根据用户的读数提供<code class="fe nn no np nq b">user_id</code>和<code class="fe nn no np nq b">article_id</code>。<br/>由于处理所有用户以获得有针对性的推送通知需要一些时间，并且数据会非常大，所以我们决定使用Google Cloud PubSub。通过使用PubSub，我们可以在处理完每个用户后立即开始发送通知。</p><h1 id="7df4" class="mi la in bd lb mj mk ml le mm mn mo lh jt mp ju lk jw mq jx ln jz mr ka lq ms bi translated">挑战</h1><p id="1c86" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">当我们决定定向推送通知时，我们面临的挑战是与外部定向系统集成。外部目标系统可以按需生成<code class="fe nn no np nq b">user_id</code>和<code class="fe nn no np nq b">article_id</code>的元组。并且该目标系统可能需要一些时间来进行一些处理。然后，我们需要定义我们希望如何使用这些数据，因为这些数据可能很大。</p><h1 id="1243" class="mi la in bd lb mj mk ml le mm mn mo lh jt mp ju lk jw mq jx ln jz mr ka lq ms bi translated">从Pubsub计算机监听</h1><p id="27dc" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">考虑到这些挑战，我们决定使用Google Cloud PubSub。<br/>以便外部目标系统可以从容不迫，只要准备好就发布<code class="fe nn no np nq b">user_id</code>和<code class="fe nn no np nq b">article_id</code>的元组。那么我们只需要一个订阅者来听这个话题。</p><p id="835b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们的工作人员获得必要的数据来构建通知。在这种情况下，我们需要的数据是文章的细节(标题、缩略图等。)和用户的设备信息(推送令牌)。</p><p id="0e8e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我们的微服务架构，我们可以从管理这些数据的服务中获得文章的细节。对于用户的设备信息，我们已经有了自己的数据库。</p><h2 id="0263" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">首次尝试</h2><p id="4313" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">所以在我们完成代码之后，我们在生产环境中测试这个系统。对于几百个用户来说，系统仍然运行良好。扩大用户数量后，灾难就发生了。</p><p id="6cb5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们得到了<code class="fe nn no np nq b">Too Many Connection</code>错误。当我们为每条消息生成一个goroutine时，就会发生这种情况。随着goroutine数量的增加，Mysql的连接数也在增加，最终达到了极限。</p><h1 id="b2b4" class="mi la in bd lb mj mk ml le mm mn mo lh jt mp ju lk jw mq jx ln jz mr ka lq ms bi translated">创建连接池</h1><p id="f8b9" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在意识到这个错误之后，我们从golang自身设置了一个数据库的最大连接池。我们设置最大开放连接和最大空闲连接。看这里:<a class="ae ky" href="http://go-database-sql.org/connection-pool.html" rel="noopener ugc nofollow" target="_blank">http://go-database-sql.org/connection-pool.html</a></p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nr"><img src="../Images/d70ba5b8f8d0d9c07ab2634e1bcd62dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJvlASdSizeVsv3C-N0_Kw.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Kurio Connection Pooling</figcaption></figure><pre class="mx my mz na gt ns nq nt nu aw nv bi"><span id="ff53" class="kz la in nq b gy nw nx l ny nz">dbConn.SetConnMaxLifetime(1 * time.Minute)<br/>dbConn.SetMaxIdleConns(10)<br/>dbConn.SetMaxOpenConns(250)</span></pre><p id="0591" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当设置这个的时候，我们必须知道的是不要设置超过Mysql处理能力的最大开放连接数。在我们的实例中，我们的数据库可以处理多达300个连接。</p><h2 id="a4d8" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">第二次尝试</h2><p id="b3a9" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">设置连接池之后，现在我们处理<code class="fe nn no np nq b">Too Many Connections</code>的错误。但是我们意识到奇怪事情发生了。我们的消息队列已经在pubsub机器中清空，但是我们的worker仍然在运行处理数据。这需要一个漫长的过程。找到原因后，我们知道我们在golang中使用的库有默认的<code class="fe nn no np nq b">Maximum Outstanding Message : 1000</code></p><p id="bfef" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个突出的消息意味着，我们的项目接受多达1000条消息。这解释了为什么订阅已经清空了，但是我们的worker仍然运行了很长时间。</p><h1 id="3dc2" class="mi la in bd lb mj mk ml le mm mn mo lh jt mp ju lk jw mq jx ln jz mr ka lq ms bi translated">设置MaxOutstandingMessage</h1><p id="2707" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">为了减少worker中的队列，我们发现未处理的消息比数据库的连接要大。这使得我们的围棋套路越来越大。因为我们只使用大约60K的消息进行测试，所以goroutine可能仍然能够处理，因为goroutine很小，而且在资源上很便宜。但是，如果我们显著增加用户数量，接下来会发生什么呢？</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oa"><img src="../Images/5b7324803ba0e8c0e57ea4207e4d9181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATk4sCS1EGu4550-sy-SmQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Before enhanced Max Outstanding Message in Pubsub Client</figcaption></figure><p id="12aa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了处理这个问题，我们设置了推送工作器可以处理的最大未完成消息。通过这样做，我们的队列不会变得太大，因为内存占用也会增加。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oa"><img src="../Images/3e21cbb85bd1f401a44dc7478650108f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AbOto4iRICod7-LqN1e8vQ.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Reduce the Max Outstanding Message</figcaption></figure><p id="2346" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为消息传入的速度比查询DB以获取基于每个用户的活动设备的速度快，所以我们将最大未处理消息减少到100，比默认值低10%。</p><p id="65fa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这有助于我们减少工作线程中运行的线程数量。</p><h2 id="657e" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">第三次尝试</h2><p id="f58b" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">做了这些改进后，我们再次尝试。我们优化了东西，现在运行得很好。但是还有其他问题，一个新的意想不到的问题。</p><p id="11a4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在运行改进后，我们发现了另一个问题。我们的系统是推送管理服务，因此，除了向GCM/APNS发送推送通知之外，我们还有一个API，在API端提供过去通知的列表。</p><p id="0300" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的仪表盘和移动应用程序都在使用这项服务。问题是，当我们的工作人员发送目标推送时，我们无法访问该API。它会一直等待，直到最后超时。</p><p id="cd3a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们开始对它的成因感到困惑。经过一些调查，我们终于意识到，只有当工作人员正在发送有针对性的推送通知时，才会发生这种情况。结果是工作人员已经用完了所有的Mysql连接池，并让API等待连接池的连接。</p><h1 id="1fc1" class="mi la in bd lb mj mk ml le mm mn mo lh jt mp ju lk jw mq jx ln jz mr ka lq ms bi translated">独立的Mysql客户端</h1><p id="59b4" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">为了解决这个问题，考虑到交付目标(也就是最后期限)，我们决定将API和worker的Mysql客户端分开，这样它们都可以独立地获得各自的连接池。</p><p id="7662" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以现在我们在一个项目中有2个Mysql客户端</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi nr"><img src="../Images/0e0144379bcd87ef08c348e9fa15a095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QahjJ7hoxeZY42qS3b3ZQg.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Create 2 Mysql Client Connection</figcaption></figure><p id="aa99" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，我们使用单个客户端供整个系统使用，我们将数据库分成2个客户端。</p><p id="5184" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">客户端1将由API系统用于提供仪表板和移动应用。客户端2将由推送工作器使用。</p><p id="9d7f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们将API端的最大连接数设置为低于worker端。由于工人端需要每个用户一个连接，我们需要快速发送，它将需要池中更多的连接。</p><p id="13d2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过这种设置，即使我们正在发送有针对性的推送通知，仪表板和移动应用程序也可以访问API。</p><h2 id="b3c4" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">第四次尝试</h2><p id="bcd9" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">然后第四次，我们再试一次。运行目标推送通知。</p><p id="f621" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以调用API推送管理，仪表盘运行良好，即使我们正在进行有针对性的推送通知。</p><p id="52eb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是…</p><p id="c034" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们发现有些奇怪的行为。这与逻辑无关。现在一切都运行良好。但是对于单个通知，将消息发送到云消息可能需要长达3个小时。真的真的好长。查看日志后，我们可以看到获取每个用户的设备信息的查询花费了很长时间。</p><p id="4b32" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">WTF！！！！</p><h1 id="3c9b" class="mi la in bd lb mj mk ml le mm mn mo lh jt mp ju lk jw mq jx ln jz mr ka lq ms bi translated">改进查询:使用索引</h1><p id="25aa" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">然后我们开始调查这个查询。事实证明，一个查询至少需要30秒。真的吗？</p><p id="5bc6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">问题不是因为我们没有索引。我们的表中已经有了一个索引。但这就像Mysql没有使用正确的索引，也是因为我们的查询速度慢。</p><pre class="mx my mz na gt ns nq nt nu aw nv bi"><span id="4b1b" class="kz la in nq b gy nw nx l ny nz">SELECT `token` FROM device  WHERE `id` IN ( SELECT max(`id`) as `id` FROM device WHERE `deleted_at` IS NULL AND `user_id` IN ("<strong class="nq io"><em class="ob">userIDs</em></strong> ")  GROUP BY uuid )</span></pre><p id="7f59" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了改进查询，我们编写了一个新的查询。因为我们只需要一台最新设备，所以我们将其更改为:</p><pre class="mx my mz na gt ns nq nt nu aw nv bi"><span id="cf51" class="kz la in nq b gy nw nx l ny nz">SELECT `token`<br/> FROM device <strong class="nq io">USE INDEX</strong> (user_id)<br/> WHERE `user_id` = ?<br/>  AND `deleted_at` IS NULL<br/> ORDER BY id DESC<br/> LIMIT 1</span></pre><p id="4333" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过这个查询，我们迫使Mysql使用正确的索引。这为我们节省了大量的查询时间。使用新的查询，现在只需要大约30毫秒</p><p id="9acc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">万岁！！！！</p><h2 id="4407" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">速度更快，做准备语句</h2><p id="a33a" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">甚至在获得我们想要的查询速度之后，我们还做了一些额外的改进。</p><figure class="mx my mz na gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi oc"><img src="../Images/e078c5b964302e31f26154b4776f7627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EBuXVrSyIbEhbCOxk-V81A.png"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Kurio Prepared Statement Querying</figcaption></figure><p id="fa48" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每次查询时(打开连接、创建查询、执行查询)，我们不需要重做一堆过程，而是通过使用准备好的语句来简化它。我们准备了关于申请开始的声明。然后将该语句注入到将由推送工作器调用的函数中。</p><p id="c547" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在main函数中，我们打开连接并准备语句</p><pre class="mx my mz na gt ns nq nt nu aw nv bi"><span id="460b" class="kz la in nq b gy nw nx l ny nz">dsn := "kurio:someofpassword@tcp(127.0.0.1:3306)/push_notification?parseTime=1&amp;loc=Asia%2FJakarta"</span><span id="216a" class="kz la in nq b gy od nx l ny nz">dbConn, _ := sql.Open(`mysql`, dsn)</span><span id="437a" class="kz la in nq b gy od nx l ny nz"><strong class="nq io">StmtGetDevicesByUserID</strong>, err:= dbConn.<strong class="nq io">Prepare</strong>(queryGetDeviceByUserID)</span><span id="0872" class="kz la in nq b gy od nx l ny nz"><em class="ob">// stmtGetDevicesByUserID : will injected to function GetDeviceByUserID</em></span></pre><p id="fb38" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">准备好后，语句<code class="fe nn no np nq b">StmtGetDevicesByUserID</code>将被注入到检索设备的函数中。然后在这个函数中，我们只执行准备好的语句。</p><pre class="mx my mz na gt ns nq nt nu aw nv bi"><span id="841e" class="kz la in nq b gy nw nx l ny nz">func (repo *Repository)GetDeviceByUserID(userID int64) *Device{</span><span id="c094" class="kz la in nq b gy od nx l ny nz">row:= repo.<strong class="nq io">StmtGetDevicesByUserID</strong>.QueryRow(userID)</span><span id="54f5" class="kz la in nq b gy od nx l ny nz">device:= &amp;Device{}<br/>err:= row.Scan(<br/>  &amp;device.Token)<br/>return device<br/>}</span></pre><p id="4533" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，当每个工人从Google Pubsub获得新消息时，它现在只传递用户ID。因为查询和样板文件已经准备好了。</p><h2 id="ed19" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">缓存和HTTP配置</h2><p id="9240" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">对于文章服务的HTTP调用，我们使用一些缓存机制，因为可能会有一些用户获得相同的文章。因此，为了减少对我们的文章服务的HTTP调用，我们添加了内存缓存，它将在特定时间内过期(例如10分钟)。</p><p id="5258" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在这里使用了开源的内存golang缓存<a class="ae ky" href="https://github.com/patrickmn/go-cache" rel="noopener ugc nofollow" target="_blank">https://github.com/patrickmn/go-cache</a></p><p id="4a29" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并在HTTP默认传输中进行一些配置</p><pre class="mx my mz na gt ns nq nt nu aw nv bi"><span id="6ceb" class="kz la in nq b gy nw nx l ny nz">timeout := 2 * time.Second<br/>keepAliveTimeout := 100 * time.Second <br/>defaultTransport := &amp;http.Transport{<br/>  Dial: (&amp;net.Dialer{<br/>   KeepAlive: keepAliveTimeout,<br/>  }).Dial,<br/>  MaxIdleConns:100,<br/>  MaxIdleConnsPerHost:600,<br/> }</span><span id="0ae7" class="kz la in nq b gy od nx l ny nz">client:= &amp;http.Client{<br/>   Transport: defaultTransport,<br/>   Timeout:   timeout,<br/>  }</span></pre><p id="cdf7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这用于优雅地处理HTTP调用和超时。<br/>关于这一点的更多解释，你可以在cloudfare的这篇博文中读到:<a class="ae ky" href="https://blog.cloudflare.com/the-complete-guide-to-golang-net-http-timeouts/" rel="noopener ugc nofollow" target="_blank">https://blog . cloud flare . com/The-complete-guide-to-golang-net-http-time outs/</a></p><h1 id="6e58" class="mi la in bd lb mj mk ml le mm mn mo lh jt mp ju lk jw mq jx ln jz mr ka lq ms bi translated">结论</h1><p id="bbdc" class="pw-post-body-paragraph kc kd in ke b kf lu jo kh ki lv jr kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">在开发这个特性的几个星期后，我学到了很多东西，也学到了很多可以帮助我改进代码的东西</p><ul class=""><li id="3981" class="ls lt in ke b kf kg ki kj kl oe kp of kt og kx lz ma mb mc bi translated">围棋套路小而便宜，但正因为它们的便宜，我们必须小心翼翼地去照顾它们，尤其是在处理人脉等的时候。</li><li id="cb0f" class="ls lt in ke b kf md ki me kl mf kp mg kt mh kx lz ma mb mc bi translated">目前，由于截止日期，我们分开了两个客户，因为我们公司想做一些关于定位系统的初步测试。目前，我们对此没有任何问题。如果这发生了一些意想不到的事情，我们将稍后进行更改，并在此更新。</li><li id="6fda" class="ls lt in ke b kf md ki me kl mf kp mg kt mh kx lz ma mb mc bi translated">如果你认为你可以改善这一点，以获得更好的优化，只需向join@kurio.co.id问好😄</li></ul><p id="d4ca" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢<a class="oh oi ep" href="https://medium.com/u/c4a88043f0b0?source=post_page-----6b605c522c29--------------------------------" rel="noopener" target="_blank"> Andrew Ongko </a>、<a class="oh oi ep" href="https://medium.com/u/c244e0555136?source=post_page-----6b605c522c29--------------------------------" rel="noopener" target="_blank"> Rifad Ainun Nazieb </a>、<a class="oh oi ep" href="https://medium.com/u/3c688feb6ac4?source=post_page-----6b605c522c29--------------------------------" rel="noopener" target="_blank"> Arie Ardaya Lizuardi </a>以及所有参与<a class="ae ky" href="https://kurio.co.id/" rel="noopener ugc nofollow" target="_blank"> Kurio </a>的团队。</p><p id="6441" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你认为这值得一读，就在你的twitter、facebook等上分享，这样其他人也可以阅读。如果你有任何问题，你可以在下面回复或者发邮件给我<a class="ae ky" href="mailto:iman.tumorang@gmail.com" rel="noopener ugc nofollow" target="_blank"><em class="ob"/></a><em class="ob"/></p><div class="oj ok gp gr ol om"><a href="https://toolbox.kurio.co.id" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd io gy z fp or fr fs os fu fw im bi translated">Kurio工具箱</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">来自你友好的邻居Kurio的工程相关的笔记</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">toolbox.kurio.co.id</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ng om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://toolbox.kurio.co.id/implementing-grpc-service-in-golang-afb9e05c0064" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd io gy z fp or fr fs os fu fw im bi translated">在戈兰实施gRPC服务</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">指南，使gRPC服务使用清洁的建筑在果兰。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">toolbox.kurio.co.id</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa ng om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://hackernoon.com/golang-clean-archithecture-efd6d7c43047" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd io gy z fp or fr fs os fu fw im bi translated">在Golang尝试干净的建筑</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">独立的、可测试的和干净的</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">hackernoon.com</p></div></div><div class="ov l"><div class="pc l ox oy oz ov pa ng om"/></div></div></a></div></div></div>    
</body>
</html>