<html>
<head>
<title>Programmer dictionary: Implicit receiver vs explicit receiver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">程序员词典:隐式接收者与显式接收者</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c?source=collection_archive---------3-----------------------#2017-11-30">https://blog.kotlin-academy.com/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c?source=collection_archive---------3-----------------------#2017-11-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="57fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之前已经解释过<a class="ae ki" href="https://medium.com/p/b085b1620890" rel="noopener">接收器的概念</a>，所以在进一步阅读之前，确保你知道什么是接收器。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/7f80e740cf35649b41781eb7ddc10003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1QcX65-iUGtBWy2yw302g.jpeg"/></div></div></figure><p id="a587" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这两个术语可能看起来有点陌生，但是您可能已经多次使用过接收器了。许多开发人员可能不知道实际名称，但他们肯定熟悉这些概念。让我们直接看一个例子。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="74be" class="la lb in kw b gy lc ld l le lf">val guitar = Guitar()<br/>guitar.playTone()</span></pre><p id="c52f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中<em class="lg">吉他</em>是<strong class="jm io">显式接收器</strong>。但是，有些情况下，我们可以在不指定接收者的情况下访问成员:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="9d2c" class="la lb in kw b gy lc ld l le lf">class Guitar {<br/>  fun playTone() { }</span><span id="f2b2" class="la lb in kw b gy lh ld l le lf">  fun playSong() {<br/>     playTone()<br/>  }<br/>}</span></pre><p id="9600" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从类内部，我们可以简单地通过使用成员名(<em class="lg"> playTone </em>方法)来访问这个类中定义的成员。在幕后，receiver对象(类的实例)存储对这些成员的引用。在上面的例子中，我们正在使用一个<strong class="jm io">隐式接收器</strong>调用<em class="lg"> playTone </em>方法(我们正在隐式访问接收器，而没有指定接收器名称)。我们也可以显式地引用类内部的接收者，我们将在下面的例子中通过使用<em class="lg"> this </em>关键字来这样做:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="5272" class="la lb in kw b gy lc ld l le lf">class Guitar {<br/>   fun playTone() { }</span><span id="7270" class="la lb in kw b gy lh ld l le lf">   fun playSong() {<br/>      this.playTone() // explicit receiver<br/>      playTone() // implicit receiver<br/>   }<br/>}</span></pre><p id="02f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的示例中，receiver是<em class="lg"> Guitar </em>类的实例，在该类中声明了方法。在这种情况下，两个调用是等效的，但是我们使用了一个显式的接收者，而不是隐式的。</p><blockquote class="li lj lk"><p id="482c" class="jk jl lg jm b jn jo jp jq jr js jt ju ll jw jx jy lm ka kb kc ln ke kf kg kh ig bi translated">如果我们在访问一个对象的成员时显式地引用它，我们说<strong class="jm io">接收者是显式的</strong>。如果我们在访问对象的成员时不显式地引用对象，我们说<strong class="jm io">接收者是隐式的</strong>。</p></blockquote><p id="08e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常我们不使用<code class="fe lo lp lq kw b">this</code>作为显式的接收者，因为我们不想产生额外的样板文件。然而，很少有显式接收器很方便的情况。最简单的例子是访问与方法参数同名的字段:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="62d2" class="la lb in kw b gy lc ld l le lf">class Person() {<br/>   private var age: Int = 18</span><span id="10ed" class="la lb in kw b gy lh ld l le lf">   fun setName(age: Int) {<br/>      this.age = age<br/>   }<br/>}</span></pre><p id="15c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们有两个同名的变量(类中声明的<em class="lg">年龄</em>字段和方法头中定义的<em class="lg">年龄</em>参数)。没有接收方的变量总是引用最内部的封闭范围(在这种情况下是方法体)。方法参数声明隐藏了字段声明。如果不使用显式接收器(<em class="lg"> this </em>)，我们将无法访问<em class="lg"> age </em>字段，因为在此范围内存在另一个同名的变量声明(方法参数变量隐藏了一个字段)。</p><p id="5d88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们想要访问在父类中实现的方法而不是在子类中覆盖的方法时，我们也使用显式的接收器(<em class="lg"> super </em>关键字)。让我们考虑这个例子，其中两个接口用相同的名称和默认实现定义成员:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="b953" class="la lb in kw b gy lc ld l le lf">interface A {<br/>   fun doSomething() {<br/>      println("A is doing something")<br/>   }<br/>}</span><span id="9e80" class="la lb in kw b gy lh ld l le lf">interface B {<br/>   fun doSomething() {<br/>      println("B is doing something")<br/>   }<br/>}</span><span id="3794" class="la lb in kw b gy lh ld l le lf">class Test : A, B {<br/>   override fun doSomething() {<br/>      doSomething() // infinitely recursive call<br/>   }<br/>}</span></pre><p id="d8c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，默认情况下，<em class="lg">测试</em>类中定义的<em class="lg"> doSomething </em>方法将被调用，导致无限递归调用。为了解决这个问题，我们需要使用显式接收器(<em class="lg"> super </em>)来告诉Kotlin编译器我们想要调用的方法。两个接口都默认实现了<em class="lg"> doSomething </em>方法，所以我们还需要用接口名来限定显式接收者:</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="ba4f" class="la lb in kw b gy lc ld l le lf">class Test : A, B {<br/>   override fun doSomething() {<br/>      super&lt;A&gt;.doSomething() // explicit receiver<br/>      super&lt;B&gt;.doSomething() // explicit receiver<br/>   }<br/>}</span></pre><p id="b5ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总结一下。如果调用一个方法而没有显式地命名一个接收者对象，我们说接收者是隐式的，否则我们说接收者是显式的。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="4b4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我要感谢<a class="ae ki" href="https://twitter.com/intelliyole" rel="noopener ugc nofollow" target="_blank">德米特里·杰梅罗夫</a>的校对。这篇帖子是<a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-2cb67fff1fe2" rel="noopener">科特林程序员词典</a>的第八部分。要保持最新的新零件，只需遵循此介质。为了与我的文章保持联系，<a class="ae ki" href="https://twitter.com/igorwojda" rel="noopener ugc nofollow" target="_blank">在Twitter上观察我</a>。这里提到我的关键是<a class="ae ki" href="https://twitter.com/igorwojda" rel="noopener ugc nofollow" target="_blank"> @IgorWojda </a>。</p><p id="43b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">喜欢的话记得<strong class="jm io">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi ly"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="8d02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是《科特林程序员词典》的其他部分:</p><ul class=""><li id="f8a1" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">形参vs实参，类型形参vs类型实参</a></li><li id="1953" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0" rel="noopener">语句vs表达式</a></li><li id="2a4f" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">功能vs方法vs程序</a></li><li id="d41a" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">属性对字段</a></li><li id="84df" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类对类型对对象</a></li><li id="795a" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b">对象表达式vs对象声明</a></li><li id="8499" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-b085b1620890">接收器</a></li><li id="6b7e" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277">分机接收机vs调度接收机</a></li><li id="6016" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-type-vs-receiver-object-575d2705ddd9">接收者类型与接收者对象</a></li><li id="f460" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">函数类型vs函数文字vs Lambda表达式vs匿名函数</a></li><li id="f8fd" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-higher-order-function-9cadb07df94e">高阶函数</a></li><li id="e380" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-function-literal-with-receiver-vs-function-type-with-receiver-cc21dba0f4ff">带接收方的函数文字与带接收方的函数类型</a></li><li id="2d84" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-generics-variance-modifiers-36b82c7caa39">不变性vs协方差vs逆变</a></li><li id="7dfe" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-event-listener-vs-event-handler-305c667d0e3c">事件监听器vs事件处理器</a></li><li id="3dd4" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-delegation-vs-composition-3025d9e8ae3d">代表团vs组成</a></li></ul></div></div>    
</body>
</html>