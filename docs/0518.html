<html>
<head>
<title>Improving app startup with I/O prefetching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过I/O预取改善应用启动</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/improving-app-startup-with-i-o-prefetching-62fbdb9c9020?source=collection_archive---------0-----------------------#2020-07-15">https://medium.com/androiddevelopers/improving-app-startup-with-i-o-prefetching-62fbdb9c9020?source=collection_archive---------0-----------------------#2020-07-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/3f5fb79602d33328a9c7dc2c92216234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QV-cLPJKHxuIP5FEiRMwng.png"/></div></div></figure><div class=""/><p id="76bd" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在Android 11中，我们引入了IORap，这是一个新功能，可以大大缩短应用程序的启动时间。我们观察到，在各种设备上，应用程序的启动速度平均快5%以上(冷启动)。一些英雄案例显示<strong class="is ht"> 20%+ </strong>更快的启动时间。用户无需更改任何开发人员应用程序即可获得额外的性能！</p><figure class="jp jq jr js fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jo"><img src="../Images/4e065c4d5cd80a008ba43163963c3c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r1O-VkAXbGor-DxrEIhI_w.png"/></div></div></figure><p id="4811" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is ht">Android应用的IORap预取</strong></p><p id="3c43" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">IORap通过预测需要哪些I/O并提前完成来减少应用程序的启动时间。由于I/O阻塞，许多应用程序初创公司有很多时间IO请求队列没有饱和。因此，我们没有最大限度地提高IO延迟。预取数据并压缩I/O后，应用程序可以从<code class="du jt ju jv jw b">pagecache</code>开始几乎立即访问这些数据，从而显著减少应用程序启动延迟。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jx"><img src="../Images/dd28e29d0a84368c03b2ff03b71e0290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4G9nvxMdB7SUAaB1VVTjQ.png"/></div></div></figure><p id="fa0f" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当我们评估来自Play Store的一些热门应用时，80%以上的应用在发布期间花费了10%以上的时间来阻止I/O。而大约50%的应用程序甚至花费了20%以上的时间。我们看到的大多数应用都可以从IORap中受益。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jo"><img src="../Images/5f43d676c46d1c898dffcf433a130bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5UEDw2IMRBjIumL5XMeIg.png"/></div></div></figure><figure class="jp jq jr js fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jo"><img src="../Images/23572adc0eba627785568b036cdd5878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LxI-PYUOVbKJDmD5F5JUg.png"/></div></div></figure><p id="39ab" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">IORap作为设备上的独立服务运行。它通过IPC与包管理器、活动管理器、<code class="du jt ju jv jw b">perfetto</code>服务等交互。IORap的整体架构如下图所示:</p><figure class="jp jq jr js fd hj er es paragraph-image"><div class="er es jy"><img src="../Images/9af32fee3646841de5bf82ed499a788c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*pUQGmt5N2wMkuxv4UIBvJw.png"/></div></figure><p id="97ce" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is ht">第一步:收集性能痕迹</strong></p><p id="c585" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">IORap使用基于分析的策略来确定要预取的I/O。这些知识来自<code class="du jt ju jv jw b">perfetto</code> trace，它记录了内核<code class="du jt ju jv jw b">pagecache</code>的页面移除/添加(来自<em class="jz"> ftrace </em>)。在应用程序的前几次冷运行中，会启动<code class="du jt ju jv jw b">perfetto</code>跟踪来获取<code class="du jt ju jv jw b">pagecache</code>丢失的事件。我们的研究表明<code class="du jt ju jv jw b">perfetto</code>跟踪在启动时的开销是可以忽略的。</p><p id="0137" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is ht">步骤2:生成预取列表</strong></p><p id="9452" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">基于上一步获得的<code class="du jt ju jv jw b">perfetto</code>轨迹，IORap在设备空闲期间生成一个预取列表。基本上，预取列表包含应用程序启动时访问的文件信息(名称、偏移量、长度)。IORap分析来自<code class="du jt ju jv jw b">perfetto</code>跟踪的<code class="du jt ju jv jw b">mm_pagemap</code>事件，并通过将<code class="du jt ju jv jw b">inode</code>反转为文件名将其结果(<code class="du jt ju jv jw b">inode</code>，偏移量，长度)转换为(名称，偏移量，长度)。然后，数据存储在预取列表中，该列表是一个<code class="du jt ju jv jw b">protobuf</code>文件。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ka"><img src="../Images/5c15673c2182a789748549bdfee136c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*grYGPiKhLsgHA-BVyKk6Lw.png"/></div></div></figure><p id="2dcd" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is ht">第三步:I/O预取</strong></p><p id="6396" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">预取列表生成后，IORap可以为应用程序的后续运行预取相应的数据。不再需要<code class="du jt ju jv jw b">perfetto</code>追踪。用户和开发人员不需要做任何事情。当用户点击图标或通过另一个应用程序间接请求时，就会执行预取。享受加速！</p><p id="e6ab" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is ht">步骤4:废弃预取列表</strong></p><p id="3dd6" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">预取列表不会永远存在。一些事件可能会导致预回迁列表过时。更新应用程序时，预取列表会被弃用，因为应用程序可能会更改，以前的数据可能不准确。还有，<code class="du jt ju jv jw b">dexopt</code>服务可以在安装后优化app。应用程序优化后，布局可能会有所不同，使预取列表过时。过时的预取列表将被删除，新一轮将从<code class="du jt ju jv jw b">perfetto</code>踪迹收集开始。</p><p id="76c4" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is ht">改进&amp;观察</strong></p><p id="4d1e" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">对比我们实验室的几个实验结果，我们确定IORap的优势涵盖了从低端到高端设备的范围。平均来说，IORap可以提供高达<strong class="is ht"> ~26% </strong>的加速。这对于启动时有大量I/O的应用程序非常有帮助。例如，Spotify显示低端设备(Go和Pixel 3A)和高端设备(Pixel 3或4)都有两位数的改善。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kb"><img src="../Images/d66e81b8ecebdc07666b6b8e5745d5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edzlh-vUSGbwu45sqZLHfA.png"/></div></div></figure><p id="5cfc" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">实验中一个有趣的发现是，IORap的性能很大程度上受预取数据量的影响。准确的跟踪持续时间对于IORap来说非常重要。跟踪持续时间越短，预取的数据就越少，性能提升也越小。另一方面，较长的预取时间会导致预取过多的数据，在最坏的情况下，这可能会导致启动速度变慢。IORap使用应用程序报告<code class="du jt ju jv jw b">ReportFullyDrawn</code>事件的时间戳来估计跟踪持续时间。对于未报告此事件的应用程序，将使用显示时间。所以在适当的时候调用<code class="du jt ju jv jw b">reportFullyDrawn</code>回调可以提高IORap的性能。</p><p id="6a90" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is ht">未来发展</strong></p><p id="3e7a" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我们对IORap展示的改进感到兴奋，我们计划在未来从以下两个方向进一步探索这一概念。首先，更频繁地预取。如果可以在分析期间进行预取，那就太好了。然后，我们可以通过提供预构建的预取列表，在生成预取列表之前消除一些性能差距。其次，IORap可以预测应用程序将会更早启动并开始预取，从而进一步加快启动时间。</p><p id="0f6b" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is ht">结论</strong></p><p id="42eb" class="pw-post-body-paragraph iq ir hs is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当你的应用程序完成启动时，你可以通过调用<code class="du jt ju jv jw b">ReportFullyDrawn</code>回调来帮助IORap。IORap主要有助于减少I/O阻塞时间，因此考虑分析您的应用程序启动是否存在其他可能的性能问题。</p></div></div>    
</body>
</html>