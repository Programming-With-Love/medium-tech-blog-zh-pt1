<html>
<head>
<title>KAFKA Automation using KARATE</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用空手道的卡夫卡自动化</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/kafka-automation-using-karate-6a129cfdc210?source=collection_archive---------0-----------------------#2021-04-15">https://medium.com/walmartglobaltech/kafka-automation-using-karate-6a129cfdc210?source=collection_archive---------0-----------------------#2021-04-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5e2c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">自动化需求:</strong></p><p id="fe8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在持续集成(CI)中，开发团队实现小的更改，并频繁地将代码签入版本控制存储库。连续交付(CD)自动部署到选定的基础架构环境中。大多数开发人员在多个部署环境中工作，比如生产、开发和测试。这些服务器上的任何延迟或错误都会影响所有的开发部署。</p><p id="30a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">自动化减少了在CI和CD的许多重复步骤中可能发生的错误数量。</p><p id="cab3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个额外的好处是，它节省了开发人员在产品开发上花费的时间，同时也降低了将错误代码交付到产品中的风险。</p><p id="7e0f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">空手道:</strong></p><p id="b344" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">空手道是Intuit开发的一个强大的自动化工具，它基于Cucumber推广的BDD语法，因此它是语言中立的，对于非程序员来说也很容易。测试执行和报告生成感觉就像任何标准的Java项目。你不需要编译代码。只需用简单易读的语法编写测试。</p><p id="b537" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">用例:</strong></p><p id="f4d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们托管在Azure private PaaS上的服务使用Cucumber framework对我们的REST APIs进行端到端的功能测试。由于我们已经习惯了Cucumber并编写了测试，我们计划探索使用空手道来处理我们新引入的Kafka组件的自动化的可能性。幸运的是，这个决定被证明是正确的。:D</p><p id="d6b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在运行现有Auto时面临的主要问题是，我们必须使用JPA维护一个单独的验证服务，以连接到我们的数据库并执行操作。由于大多数团队远程工作，建立了不必要数量的数据库连接，从而阻碍了开发人员，妨碍了他们的工作效率。甚至资源优化也没有到位，因为即使在没有运行的情况下也使用了大量资源。</p><p id="b50d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，由于空手道提供了开箱即用的支持，通过特性文件连接到各种数据库/Azure Resources/Kafka (SQL、blob、cosmos等),以在特性文件中运行Java类，并提供严格的方法来执行验证，我们可以取消验证服务，将所有代码转移到空手道。</p><p id="31ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">探索每一步的各种优势，让我们看看我们是如何使用空手道实现Kafka自动化的。</p><p id="8781" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">设置:</strong></p><p id="e84a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该场景主要由两个使用Kafka相互交互的服务(服务A和服务B)组成。</p><p id="ca02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">流程如下:</p><ul class=""><li id="5e4f" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">服务A产生消息。</li><li id="b076" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">服务B使用这些消息，并根据消息的使用情况生成一个确认数据包。</li><li id="9d6e" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">成功消费后，服务B也会生成一个业务包。</li></ul><p id="84fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将使用空手道进行模拟和自动化的流程:</p><ul class=""><li id="e35e" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">从服务A到服务b的消息生产</li><li id="62f6" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">从服务B到服务a的确认包验证</li></ul><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es jq"><img src="../Images/dba896bdcf8ad24c4b3140cf2afc1945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_pB7ynyZJ_SHgmFI.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx">Flow Simulated for our use case</figcaption></figure><p id="8c4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">涵盖的场景</strong></p><p id="327b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下表中，生产者生产的每个数据包都可以使用ID字段进行唯一标识。</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es kg"><img src="../Images/19fb3d563f1f59a4b78e771d786b4a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVVThLcFok0MOYSDQH3PkA.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx">Scenario Covered</figcaption></figure><p id="786d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个生产者，用于为各种场景(成功的和错误的数据包)向主题填充消息</p><ul class=""><li id="7c66" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">创建一个singleton类来更新HashMap，它将包含形式为&lt; KEY , TEST-CASE &gt;的条目。每当生产者发布新消息时，就会调用这个函数。<br/> KEY →字段，通过它我们可以唯一地标识生产者-消费者对(在我们的例子中是ID)。<br/>值→应该为特定场景执行的特征文件的名称。</li><li id="3971" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">使用唯一的组id创建另一个汽车消费者，并收听传出的话题。</li><li id="5269" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">遍历消费者选择的所有消息，并根据ID，读取HashMap来确定要执行的测试用例(特性文件)。</li></ul><p id="af6a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上表中定义的场景将通过此方法以下列方式处理:</p><p id="457e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ID1 -&gt;由自动生成器生成→条目会出现在HashMap → <br/> &lt; ID1，feature file 1 . feature&gt;<br/>ID2-&gt;由自动生成器生成→条目会出现在HashMap → <br/> &lt; ID2，feature file 2 . feature&gt;<br/>ID3-&gt;由自动生成器生成→条目会出现在HashMap → <br/> &lt; ID3，FeatureFile3.feature &gt;</p><p id="0eb2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦所有的信息都被公布，我们的汽车消费者将会参与进来。</p><p id="69fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ID1 →基于ID1从HashMap中读取→确定该案例的特征文件(FeatureFile1.feature)并执行验证集。<br/> ID2 →基于ID2从HashMap中读取→确定该案例的特征文件(FeatureFile2.feature)并执行验证集。<br/> ID3 →基于ID3从HashMap中读取→确定该案例的特征文件(FeatureFile3.feature)并执行验证集。</p><p id="5ee3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">使用的Maven依赖关系:</strong></p><p id="27f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">空手道依赖</p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="2129" class="km kn hh ki b fi ko kp l kq kr">&lt;dependency&gt;<br/>   &lt;groupId&gt;com.intuit.karate&lt;/groupId&gt;<br/>   &lt;artifactId&gt;karate-apache&lt;/artifactId&gt;<br/>   &lt;version&gt; 0.9.5&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="84d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Kafka客户端依赖性:</p><pre class="jr js jt ju fd kh ki kj kk aw kl bi"><span id="6383" class="km kn hh ki b fi ko kp l kq kr">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;<br/>    &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;<br/>    &lt;version&gt;2.5.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="8146" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">使用的方法:</strong></p><p id="a4ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是我们空手道特征文件的样子。</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es jq"><img src="../Images/796e53a5fd85b78d1036dc24a4d13c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oo0qJVAd-TZTKBqP.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx">Karate feature file used</figcaption></figure><p id="31db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第一步:</strong></p><p id="3eee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将自动化场景中使用的使用者组的偏移量重置为最新值，以便选择为自动化场景发布的消息，而不是其他消息，从而确保顺利运行。</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es jq"><img src="../Images/ac37f30becb12ccb76f4778787200f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FzA28M6a_nz4TsPM.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx">Reset offset to latest</figcaption></figure><p id="e4d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的特性文件中，我们将调用JAVA代码在其他步骤开始执行之前将偏移量重置为latest。</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es ks"><img src="../Images/0308ac29e38d537b66ad77b26cbc1648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DyzNz-ISpZDwt6kl.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx">Java code used for resetting the offset</figcaption></figure><p id="08a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第二步:</strong></p><p id="942e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">产生从服务A到服务b的消息。</p><p id="6843" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一步中，我们将根据需要读取JSON或XML或任何其他格式，并将其发布到服务B的传入主题。Producer是用JAVA编写的，是一个Kafka客户端，将记录发布到Kafka集群。</p><p id="1dc5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">发布消息的空手道特征文件:</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es jq"><img src="../Images/2d5dcb359078e9f74fa59e98cce4365f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oTPs9BfQkXqgWi4F.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx">Feature file to publish messages</figcaption></figure><p id="350a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用于将数据发送到订阅主题的Java代码。</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es ks"><img src="../Images/7897e56e59e4b794e33716aef5808fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mnXMEl3Jxl-OwLy9.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx">Java code for producing messages</figcaption></figure><p id="54de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第三步:</p><p id="134b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">验证从服务B到服务A的确认数据包</p><p id="a160" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种情况下的主要步骤是:</p><ul class=""><li id="5cff" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">从服务B向服务a获取确认包。在调用poll()之前，消费者只是在空转。只有在调用poll()之后，它才会启动到集群的连接，获得分配的分区并尝试获取消息。所以我们将调用poll()，然后等待一段时间，直到分区被分配。然后发出一个信号(倒计时锁存)，让构造函数可以返回。</li></ul><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es jq"><img src="../Images/768f69df120bde8a0b62be7d083cef02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mX2h4-XGJCSf3i88.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx">Fetch acknowledgement based on ID</figcaption></figure><p id="8c9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据我们在步骤2中发布消息时使用的ID，确定要执行的测试用例。</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es jq"><img src="../Images/26e5f24cd85b7b864ee4703ad3afa9c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KBPgfAHcJtwzlO3x.png"/></div></div><figcaption class="kc kd et er es ke kf bd b be z dx">Determine test case to be executed</figcaption></figure><p id="21a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">执行一组验证。</p><p id="efce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论:</strong></p><p id="014d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在对Cucumber上运行的现有测试集进行分析并将其转移到空手道上之后，我们确实看到了测试运行所用时间的改进，因为空手道提供了并行运行，并增加了以下优势:</p><ul class=""><li id="81c1" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">数据驱动的测试甚至可以使用JSON或CSV源代码</li><li id="c611" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">跨测试轻松重用JSON或JS / Java逻辑</li><li id="f59c" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">强大而灵活的有效负载断言</li><li id="7c9f" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">聚合报告的并行执行</li><li id="f013" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">通过跨平台可执行文件/ CLI轻松集成CI</li></ul><p id="6c94" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">鸣谢:</strong></p><p id="844b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感谢<a class="kt ku ge" href="https://medium.com/u/e8ad3283f426?source=post_page-----6a129cfdc210--------------------------------" rel="noopener" target="_blank"> Mayur Patki </a>帮助完成方法和设计。</p></div></div>    
</body>
</html>