<html>
<head>
<title>Azure Cosmos DB : Change Feed processor for Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure Cosmos DB:更改Java的提要处理器</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/azure-cosmos-change-feed-processor-for-java-3e784ac6ef07?source=collection_archive---------0-----------------------#2020-12-14">https://medium.com/walmartglobaltech/azure-cosmos-change-feed-processor-for-java-3e784ac6ef07?source=collection_archive---------0-----------------------#2020-12-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/be6ae6def86c5848b54d65aa5550b567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0eRODV2VsqV_vW0a4vIgPw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo Credit: <a class="ae it" href="https://pixabay.com/photos/combine-harvester-agriculture-5401538/" rel="noopener ugc nofollow" target="_blank">Anrita</a></figcaption></figure><p id="dd75" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我最近开始从事一个项目，该项目涉及几个不同系统的集成，一些是遗留系统，一些是新系统。在找出整个解决方案的管道和各种细节的过程中，Azure Cosmos DB被选为其中一个中间层的中间存储。在这篇文章中，我将具体讨论我们的团队如何使用Azure Change Feed处理器来处理从Azure Cosmos到数据接收器的数百万个事件。</p><h1 id="f1cf" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">眼前的问题</h1><p id="2f16" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们有一个大约数千用户的生产者基础，每天为我们的Cosmos DB生成<strong class="iw hi">百万个事件</strong>。事件生产者分布在不同的地理位置。这些事件来自商店设备触发的API事件，来自多个系统的Kafka事件。除此之外，我们还有多个相关的服务集成，这些集成要求数据以经过处理的格式接近实时。我们需要验证数据、处理数据并将其重新保存到数据库中，以及将其推送到相关的系统中。我们还需要提供API来提供关于已处理信息的信息。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es kv"><img src="../Images/d1bbe4044629b3d88ceaf1344d4e950c.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*yMxHuKLdph8CLXTvLHgdUA.jpeg"/></div></figure><h1 id="093b" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">这项研究</h1><p id="a628" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我遇到了<strong class="iw hi"> Azure的</strong> <a class="ae it" href="https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed-processor" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi"> Change feed处理器模式</strong> </a> <strong class="iw hi"> </strong>，它已经被用于跨多个平台读取feed，处理和重复大规模数据。但想了解它是如何以不同于现有系统的方式工作的。</p><p id="d67e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以使用<strong class="iw hi">推模型</strong>或<strong class="iw hi">拉模型</strong>来处理Azure Cosmos DB变更提要。在推模型中，服务器(变更提要)将工作推给客户机，客户机具有处理这项工作的业务逻辑。然而，检查工作和存储最后处理的工作的状态的复杂性是在服务器上处理的。</p><blockquote class="la lb lc"><p id="f3f1" class="iu iv ld iw b ix iy iz ja jb jc jd je le jg jh ji lf jk jl jm lg jo jp jq jr ha bi translated">拉模型的延续令牌和变更提要处理器的租约容器都是变更提要中最后处理的项目(或项目批次)的“书签”。</p></blockquote><p id="01ed" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用CFP库或Azure函数，你会得到一个推送模型，在这个模型中，你的代码会等待Azure Cosmos DB实时推送过来的修改。在拉动模式下，你可以控制消费的速度。类似于(不推荐的)直接方法，您的代码查询变更提要以从中“拉”出变更，而不是等待变更被推送。</p><p id="296e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然推模型通常提供了一种更好的方法，但在某些情况下，拉模型可能更容易使用。首先，它具有通过分区键查询更改的独特能力。此外，通过控制变更馈送消耗，对于那些一次性的数据迁移场景来说也更容易。</p><p id="bc8e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用变更馈送处理器[默认实现]优于拉模型有许多优点，如下所示:</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lh"><img src="../Images/b7f010eaa933b73f46eb1f81cd6cf454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yx7t8tmBbtMJtllrQnyYFw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo credit : <a class="ae it" href="https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed-pull-model" rel="noopener ugc nofollow" target="_blank">Official Website</a></figcaption></figure><blockquote class="la lb lc"><p id="8ab4" class="iu iv ld iw b ix iy iz ja jb jc jd je le jg jh ji lf jk jl jm lg jo jp jq jr ha bi translated">Change Feed处理器库提供“至少一次”保证，确保您不会错过处理任何事件。</p></blockquote><p id="56f7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">更换进料处理器的一些缺点如下:</p><ul class=""><li id="154f" class="li lj hh iw b ix iy jb jc jf lk jj ll jn lm jr ln lo lp lq bi translated">至少一次保证也带来了潜在的问题，即相同的消息被处理多次。我们已经看到，在系统故障、分区上的租约切换或某些应用程序故障的情况下，会收到副本。</li><li id="c92f" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">批处理号是一个很难设置的数字，因为值太高会导致失败时大量重复处理，值太低会导致处理时间延迟，因为存在feed轮询延迟。</li></ul><p id="1b1f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们继续使用change feed处理器的推送模式有多种原因:</p><ul class=""><li id="7311" class="li lj hh iw b ix iy jb jc jf lk jj ll jn lm jr ln lo lp lq bi translated">我们有多个逻辑分区，数据大小最终也会导致多个物理分区，因此CFP推模型保持了分区管理的整洁。</li><li id="30c0" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">为了避免繁琐的租约(光标)管理</li><li id="6100" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">为了避免手动维护所有的文档确认</li><li id="3427" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">CFP的检查点管理确保了在异常情况下零数据故障。</li></ul><h1 id="9cf3" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">天蓝色宇宙变化饲料处理器</strong></h1><p id="feaa" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">微软官网提到的文章可以总结如下。</p><blockquote class="la lb lc"><p id="8086" class="iu iv ld iw b ix iy iz ja jb jc jd je le jg jh ji lf jk jl jm lg jo jp jq jr ha bi translated">Azure Cosmos DB Change Feed向Cosmos DB外部公开数据库日志。当数据库中有任何变化时，它会立即通知用户。它支持所有的插入和更新。Azure Cosmos DB change feed支持高效处理大量写入的大型数据集。Change feed processor还提供了一种替代方法，可以查询整个数据集来确定发生了什么变化。</p></blockquote><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lw"><img src="../Images/5af7ab2d67470802aee39f5ab0c8fbfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*83pzsx9eJDsOmJ3PtHqzpg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo credit: <a class="ae it" href="https://docs.microsoft.com/en-us/azure/cosmos-db/media/change-feed/changefeedoverview.png" rel="noopener ugc nofollow" target="_blank">Official Page</a></figcaption></figure><p id="a073" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">找零进料处理器的组件</p><ul class=""><li id="6671" class="li lj hh iw b ix iy jb jc jf lk jj ll jn lm jr ln lo lp lq bi translated"><strong class="iw hi">被监控的容器</strong>:所有的插入和更新都是对这个容器进行的。变更提要就是从这个容器中生成的。</li><li id="b6d1" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated"><strong class="iw hi">租约容器</strong>:它充当状态存储，并协调多个工作者之间的变更处理。</li><li id="e51e" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">主机:它是一个应用程序，监听变更提要中的变更。具有相同租用配置的多个主机实例可以并行运行，但是每个实例应该有不同的主机名。</li><li id="6571" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated"><strong class="iw hi">Delegate</strong>:Delegate是定义您，开发人员，想要对变更提要处理器读取的每一批变更做什么的代码。</li></ul><h1 id="e51a" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">履行</h1><p id="0be0" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">对于这个博客，我们将使用4.8.0版本的Azure sdk for java。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="955d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们需要Azure Cosmos DB中的以下基本参数集:</p><ul class=""><li id="fbfc" class="li lj hh iw b ix iy jb jc jf lk jj ll jn lm jr ln lo lp lq bi translated"><strong class="iw hi">主机名</strong>:我们可以使用一个简单的名称作为‘host-1’</li><li id="64b8" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated"><strong class="iw hi"> feedContainer </strong>:我们可以在我们的Cosmos DB实例中设置这个容器，记下分区键。</li><li id="0979" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated"><strong class="iw hi">租赁集装箱</strong>:同上。</li><li id="d9da" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated"><strong class="iw hi">委托:</strong>委托是您定义的函数，用于处理变更输入处理器输入的每一批变更。</li></ul><p id="77c6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们需要一个客户端连接到Cosmos DB的变化饲料处理器。提供了多个选项，请参见示例代码:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="3744" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一致性级别——代表Azure Cosmos DB服务中Azure Cosmos DB客户端操作支持的一致性级别。</p><blockquote class="la lb lc"><p id="f7d3" class="iu iv ld iw b ix iy iz ja jb jc jd je le jg jh ji lf jk jl jm lg jo jp jq jr ha bi translated">注意:<em class="hh">请求的一致性级别必须匹配或弱于为数据库帐户提供的一致性级别。<br/>按照强度顺序排列的一致性级别为强、有限过时、会话和最终。</em></p></blockquote><p id="4f24" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">创建简单变更馈送处理器的示例代码:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="7f23" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">将变更馈送处理添加到您的模块是一个很好的方法，我们可以使用以下设置让变更馈送与Azure Cosmos DB容器进行交互:</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="lx ly l"/></div></figure><blockquote class="la lb lc"><p id="b400" class="iu iv ld iw b ix iy iz ja jb jc jd je le jg jh ji lf jk jl jm lg jo jp jq jr ha bi translated">注意:当<br/> <em class="hh">未初始化租赁项目时，可使用该选项，但要小心将处理重新设置为从头开始。如果租赁项目存在并且具有有效的延续令牌，将忽略此设置。<br/> -未指定开始延续标记选项。<br/> -未指定开始时间选项。</em></p></blockquote><h1 id="c443" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">性能试验</h1><p id="d47d" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在高峰时，我们的解决方案需要并行处理大量的读写操作。作为我们性能测试策略的一部分，我们也想检查这种行为。</p><p id="8b86" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">注意相同的RU消耗。 </strong></p><p id="69ff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> Cosmos DB配置:<br/> </strong> <em class="ld">多区域部署与<br/> </em>一致性:强<br/> <em class="ld">最大规模计数:无限制<br/>Cosmos DB容器最大RU:4000</em></p><p id="3b88" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">更改送纸器配置</strong> : <br/> <em class="ld">每页最大项数或送纸响应:</em><strong class="iw hi"><em class="ld">100</em></strong><em class="ld"><br/>租用更新间隔:17秒<br/>租用获取间隔:13秒<br/>租用到期间隔:60秒<br/>送纸轮询延迟:</em><strong class="iw hi"><em class="ld">5</em><em class="ld">秒</em></strong></p><p id="695b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">源容器</strong> —用于写入测试数据的容器，以便在变更馈送处理器中进行后续读取。<br/> <strong class="iw hi">成功容器</strong> —用于存储在更改进给处理器处理方法中进行后处理的数据的容器。</p><p id="eb04" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">步骤</strong></p><p id="1cfa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">测试总结和发现</strong> <br/> -在23分钟内将56000条记录/行插入源容器<br/> -在23分钟内完成32000条记录的插入(并行读写)后，在change feed处理器中进行成功的后处理并存储到成功容器中。<br/>-23分钟32360个请求—在同一容器上并行写入时，每秒处理23.44个请求。<br/> - RU消耗在最大分配RU的50%以内。有效的RU使用。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/5b494ec3d3539ba319d6c7641329909d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcK9T08-cJghVnC0kK2zYw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">RU usage for Source container</figcaption></figure><h1 id="9b33" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">值得注意的发现</strong></h1><ul class=""><li id="e57b" class="li lj hh iw b ix kq jb kr jf ma jj mb jn mc jr ln lo lp lq bi translated"><strong class="iw hi">每页最大项目数</strong>定义您从变更进料处理器获取多少批次进行处理，这形成了一个瓶颈，因为变更进料处理器会等待您将该批次标记为已处理，然后再进入下一批次进料。<br/>将该值设置得很高会导致故障场景的复杂情况。假设我们将这个值设置为200而不是100。假设在后处理期间，第109个节点失败，那么如果节点处理失败，则整个批次失败。我们需要一种方法来处理失败，并在每页计数的大项目上重试。</li><li id="fc73" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated"><strong class="iw hi"> Lease fetch Delay : </strong>我们看到，一旦最后一批页面完成，获取下一批页面大约需要2到3秒的时间。默认的轮询延迟值是5秒，因此设置任何低于3秒的值都是多余的，因为下一批将需要大约3秒来获得分区离开。还要记住处理每批文档所需的时间。</li></ul><h1 id="1496" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">值得关注的事情</h1><h2 id="cc66" class="md jt hh bd ju me mf mg jy mh mi mj kc jf mk ml kg jj mm mn kk jn mo mp ko mq bi translated">并行处理</h2><ul class=""><li id="5a70" class="li lj hh iw b ix kq jb kr jf ma jj mb jn mc jr ln lo lp lq bi translated">多个变更提要处理器可以通过使用租用机制来平均分配工作</li><li id="3bf7" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">如果变更馈送处理器实例的数量少于可用的物理分区，则每个变更馈送处理器实例将拥有多个分区的唯一所有权。</li><li id="17c9" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">如果变更馈送处理器实例的数量超过了可用的物理分区，那么其他实例将处于空闲状态</li><li id="af38" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">如果多个变更馈送处理器想要处理相同的事件，则使用<strong class="iw hi">租用前缀</strong>的概念。每个订阅者将使用不同的租用前缀来处理相同的事件。</li></ul><h2 id="2303" class="md jt hh bd ju me mf mg jy mh mi mj kc jf mk ml kg jj mm mn kk jn mo mp ko mq bi translated">可量测性</h2><p id="10a4" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">变更馈送处理器实例的数量可以增加和减少，并且变更馈送处理器将通过相应地重新分配来动态地调整负载。</p><ul class=""><li id="58e0" class="li lj hh iw b ix iy jb jc jf lk jj ll jn lm jr ln lo lp lq bi translated">如果一个处理器崩溃、挂起或失去网络连接，它的租约将到期，并在其他可用的变更馈送处理器实例之间分配。</li><li id="e962" class="li lj hh iw b ix lr jb ls jf lt jj lu jn lv jr ln lo lp lq bi translated">如果一个处理器拥有所有租约，而另一个租约出现了，后一个将开始从前者窃取租约，这样租约最终将在运行的主机之间平均分配。</li></ul><h2 id="0eb2" class="md jt hh bd ju me mf mg jy mh mi mj kc jf mk ml kg jj mm mn kk jn mo mp ko mq bi translated">跳回</h2><p id="5686" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">如果您的委托实现有未处理的异常，处理该特定批更改的线程将被停止，并将创建一个新线程。新线程将检查租约存储对于该范围的分区键值的最新时间点，并从那里重新开始，有效地将同一批更改发送给委托。这种行为将一直持续，直到您的委托正确地处理变更，这也是变更馈送处理器至少有一次 保证的原因，因为如果委托代码抛出异常，它将重试该批次。</p><blockquote class="la lb lc"><p id="8036" class="iu iv ld iw b ix iy iz ja jb jc jd je le jg jh ji lf jk jl jm lg jo jp jq jr ha bi translated">为了防止更改提要处理器进入连续的重试循环，我们可以在接收端编写更好的委托函数。我们已经为系统做了一个基于resilience4j的二级弹性，以进一步加强我们的系统。我将很快就此写另一篇博客。</p></blockquote><h2 id="53b0" class="md jt hh bd ju me mf mg jy mh mi mj kc jf mk ml kg jj mm mn kk jn mo mp ko mq bi translated">费用</h2><p id="5ee8" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">除了系统行为，我们还在测试过程中监控成本使用情况。我们使用了11K的RUs来测试不同的场景，每月花费我们大约500美元。然后，我们将RU消耗调整回4K，从那时起，我们的系统始终保持在2K RUs以内。负载增加会导致成本增加。建议持续监控。</p><h1 id="8f5f" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">接下来呢？</h1><p id="58da" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们已经看到了Azure change feed processor的优势，以及在代码中部署和使用它。在这篇文章中，你看到了通过手动添加Azure Cosmos sdk和添加Cosmos change feed processor的实现是多么容易。添加一个示例代码库供您参考(【https://github.com/Inbaraj-S/ChangeFeedProcessor_Demo】T4)。它也可以通过带有Cosmos DB触发器的Azure函数来完成，这本身就是另一个博客的主题。Azure change feed processor对Java开发者的在线支持很少。所以如果你尝试了一些东西，一定要和社区分享。快乐编码:)</p></div></div>    
</body>
</html>