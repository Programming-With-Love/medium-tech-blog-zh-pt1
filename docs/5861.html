<html>
<head>
<title>Analyze Bank Transaction Data using Graph (Part 2/3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用图表分析银行交易数据(第2/3部分)</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/analyze-bank-transaction-data-using-graph-part-2-3-155516bb6349?source=collection_archive---------0-----------------------#2022-01-06">https://medium.com/oracledevs/analyze-bank-transaction-data-using-graph-part-2-3-155516bb6349?source=collection_archive---------0-----------------------#2022-01-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a92bcb3a1a7447bcbc5d10fa28b0a6ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0v2sau_D3wE-R9TBfGSYHQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@eduschadesoares?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Eduardo Soares</a> on <a class="ae it" href="https://unsplash.com/s/photos/atm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a> (edited)</figcaption></figure><p id="3ae3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<a class="ae it" rel="noopener" href="/oracledevs/analyze-bank-transaction-data-using-graph-part-1-3-2088c6024f81">第1部分</a>中，我展示了如何使用图形数据库API (PGQL作为SQL的替代)将银行交易数据表示为图形，以及如何添加节点和边，并使用模式匹配对它们进行搜索。我们现在来看一种不同的方法:在现有的数据库表上创建一个图表作为视图。我们还将执行一些搜索并可视化结果。</p><p id="cc6a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">我们应该像图表一样管理数据吗？</strong></p><p id="f87a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们已经看到模式匹配语法可以简化查询，但是您可能还没有看到将数据作为节点和边添加到数据库中的好处。原因之一是，在这个用例中，节点和边的类型从一开始就是隐式确定的。我们不需要添加任何类型的节点和边的灵活性。</p><p id="8783" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们讨论图数据库的应用时，这是一个常见的情况。有逻辑层的原因认为固定的数据库模式对于应用程序开发是可取的，也有物理层的原因认为表索引和扫描在聚合中更有效。</p><p id="10b2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">创建一个图形作为视图(PG视图)</strong></p><p id="083d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，利用图(主要用于搜索和分析)的最佳方式是将表和图一起使用，实际上，到目前为止，图数据库一直与RDBMS一起使用。因此，Oracle Graph使用<a class="ae it" href="https://pgql-lang.org/spec/1.4/#creating-a-property-graph" rel="noopener ugc nofollow" target="_blank"> CREATE PROPERTY GRAPH </a>语句提供了从表到图的声明性映射，并且能够在表数据的基础上创建视图。有了这个想法，我们可以避免额外的ETL处理和数据复制。</p><p id="43aa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以我们来试试吧。首先，我们将创建标准表。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="4a15" class="kb kc hh jx b be kd ke l kf kg">DROP TABLE bank_account;<br/>DROP TABLE bank_customer;<br/>DROP TABLE bank_transaction;<br/><br/>CREATE TABLE bank_account (<br/>  acc_id NUMBER NOT NULL<br/>, cst_id NUMBER NOT NULL<br/>, CONSTRAINT account_pk PRIMARY KEY (acc_id)<br/>);<br/><br/>CREATE TABLE bank_customer (<br/>  cst_id NUMBER NOT NULL<br/>, first_name VARCHAR2(255)<br/>, last_name VARCHAR2(255)<br/>, CONSTRAINT customer_pk PRIMARY KEY (cst_id)<br/>);<br/><br/>CREATE TABLE bank_transaction (<br/>  acc_id_src NUMBER<br/>, acc_id_dst NUMBER<br/>, txn_id NUMBER<br/>, datetime TIMESTAMP<br/>, amount NUMBER<br/>, CONSTRAINT transaction_pk PRIMARY KEY (txn_id)<br/>);</span></pre><p id="9764" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用INSERT语句保存数据文件，<a class="ae it" href="https://raw.githubusercontent.com/ryotayamanaka/oracle-graph/main/bank-transaction/data/scale-100/bank_account.sql" rel="noopener ugc nofollow" target="_blank"> bank_account.sql </a>，<a class="ae it" href="https://raw.githubusercontent.com/ryotayamanaka/oracle-graph/main/bank-transaction/data/scale-100/bank_customer.sql" rel="noopener ugc nofollow" target="_blank"> bank_customer.sql </a>，<a class="ae it" href="https://raw.githubusercontent.com/ryotayamanaka/oracle-graph/main/bank-transaction/data/scale-100/bank_transaction.sql" rel="noopener ugc nofollow" target="_blank"> bank_transaction.sql </a>(右键单击并选择将链接另存为..)并将它们加载到数据库中。如果您希望加载CSV数据，请使用<a class="ae it" href="https://raw.githubusercontent.com/ryotayamanaka/oracle-graph/main/bank-transaction/data/scale-100/bank_account.csv" rel="noopener ugc nofollow" target="_blank"> bank_account.csv </a>、<a class="ae it" href="https://raw.githubusercontent.com/ryotayamanaka/oracle-graph/main/bank-transaction/data/scale-100/bank_customer.csv" rel="noopener ugc nofollow" target="_blank"> bank_customer.csv </a>、<a class="ae it" href="https://raw.githubusercontent.com/ryotayamanaka/oracle-graph/main/bank-transaction/data/scale-100/bank_transaction.csv" rel="noopener ugc nofollow" target="_blank"> bank_transaction.csv </a>。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="651a" class="kb kc hh jx b be kd ke l kh kg">SQL&gt; @bank_account.sql<br/>SQL&gt; @bank_customer.sql<br/>SQL&gt; @bank_transaction.sql</span></pre><p id="23c0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">用SQL登录数据库，切换到PGQL模式。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="2631" class="kb kc hh jx b be kd ke l kh kg">SQL&gt; PGQL AUTO ON</span></pre><p id="f5f1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在是本文中最重要的一点:如何编写从表到图的映射。对于图，我们需要从表中识别和提取关于顶点、边和标签的信息。下面关于<code class="du ki kj kk jx b">VERTEX TABLES</code>和<code class="du ki kj kk jx b">EDGE TABLES</code>的段落分别指定哪些表格作为顶点和边的信息源，以及它们在新创建的图形中的标签。</p><p id="c9fd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里，顶点描述很简单，因为它只是从客户表创建“客户”顶点，从帐户表创建“帐户”顶点。对于边，我们将事务表中保存的关系标记为“transferred _ to”。从account表中，我们提取并标记哪个客户“拥有”该帐户的关系。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="f989" class="kb kc hh jx b be kd ke l kf kg">CREATE PROPERTY GRAPH graph2<br/>  VERTEX TABLES (<br/>    bank_customer<br/>      KEY (cst_id)<br/>      LABEL customer<br/>      PROPERTIES (cst_id, first_name, last_name)<br/>  , bank_account<br/>      KEY (acc_id)<br/>      LABEL account<br/>      PROPERTIES (acc_id)<br/>  )<br/>  EDGE TABLES (<br/>    bank_transaction<br/>      KEY (txn_id)<br/>      SOURCE KEY(acc_id_src) REFERENCES bank_account<br/>      DESTINATION KEY(acc_id_dst) REFERENCES bank_account<br/>      LABEL transferred_to<br/>      PROPERTIES (txn_id, datetime, amount)<br/>  , bank_account<br/>      KEY (acc_id)<br/>      SOURCE KEY(cst_id) REFERENCES bank_customer<br/>      DESTINATION KEY(acc_id) REFERENCES bank_account<br/>      LABEL owns<br/>  )<br/>  OPTIONS (PG_VIEW)<br/>;</span></pre><p id="fda5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，通过在末尾添加<code class="du ki kj kk jx b">OPTIONS (PG_VIEW)</code>,我们可以创建这个图作为视图。如果没有这个选项，将在一组表中创建一个新的图形，作为一个无模式的图形(在我们称为PG模式的结构中)，就像第1部分中创建的图形一样。但是，我建议使用视图，除非您需要以无模式的方式处理图表，因为它允许您在不复制数据的情况下维护图表。</p><p id="4e77" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们检查一下图形可视化工具是否可以访问这个图形。由于此视图对象存储在数据库中，因此从高级选项中选择数据库作为连接目的地。</p><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/086d102cad9734e1b3b6ecf4ea0a724c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCwkHTZSQ3kMyVkW1kZBOg.png"/></div></div></figure><p id="bd6f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们通过选择GRAPH2作为要查询的图来尝试一个PGQL查询。</p><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/5a4e1fb5c76e03329f7c3542d6f9c109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HhE0ukLBSmeDdwAQ0eDxtw.png"/></div></div></figure><p id="3d0e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">保存<a class="ae it" href="https://raw.githubusercontent.com/ryotayamanaka/oracle-graph/main/bank-transaction/settings.json" rel="noopener ugc nofollow" target="_blank"> settings.json </a>(右键选择链接另存为..)并从“加载设置”按钮上传，因此您可以按如下方式更改图标。</p><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/c6bbe64c8d629fbdfe1e2aa1e340c232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JD8SXQpyYhXB0QvfS2qCoA.png"/></div></div></figure><p id="0312" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">使用PGQL进行搜索和可视化</strong></p><p id="46ff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们尝试一些PGQL查询来搜索和可视化结果。请注意，我们可以在使用图形可视化工具的查询中跳过<code class="du ki kj kk jx b">ON graph2</code>,因为已经指定了目标图形。</p><p id="204a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们将检查cst_id = 10的客户持有的账户。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="efaf" class="kb kc hh jx b be kd ke l kf kg">SELECT *<br/>FROM MATCH (c:customer)-[e:owns]-&gt;(a:account) ON graph2<br/>WHERE c.cst_id = 10</span></pre><p id="a1cd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以看到，这位客户的名字是劳拉，她拥有两个帐户。</p><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/49e1de3789744d5c5e47c9a1e91be218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFJgWebumI90Kl7Ce3zo5g.png"/></div></div></figure><p id="55e2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，让我们展示Laura的所有转账。我们将在匹配模式中再增加一跳。由于模式中有两个账户，我们为它们分配不同的变量，比如<code class="du ki kj kk jx b">a</code>和<code class="du ki kj kk jx b">a1</code>。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="b58f" class="kb kc hh jx b be kd ke l kf kg">SELECT *<br/>FROM MATCH (c:customer)-[e:owns]-&gt;(a:account)-[t:transferred_to]-&gt;(a1:account) ON graph2<br/>WHERE c.cst_id = 10</span></pre><p id="e9e2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以看到Laura使用这两个帐户向一些帐户转账。</p><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/4be16c6c83b31418e99702b6bacb6aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*stvHXGAz4Siz61ehh4FMIA.png"/></div></div></figure><p id="7e70" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，只关注帐户之间的转帐，让我们寻找一种模式，从acc_id = 10的帐户开始，经过3次跳跃返回到同一个帐户。再者，我们可以加一个条件，这些转账在时间上是按这个顺序发生的，而且转账的金额必须始终在500以上。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="7a7f" class="kb kc hh jx b be kd ke l kf kg">SELECT *<br/>FROM MATCH (<br/>       (a1)-[t1:transferred_to]-&gt;(a2)-[t2:transferred_to]-&gt;(a3)<br/>     , (a3)-[t3:transferred_to]-&gt;(a1)<br/>     ) ON graph2<br/>WHERE a1.acc_id = 10<br/>  AND t1.amount &gt; 500 AND t2.amount &gt; 500 AND t3.amount &gt; 500<br/>  AND t1.datetime &lt; t2.datetime AND t2.datetime &lt; t3.datetime</span></pre><p id="1b1c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在整个图形中，仅在包含acc_id = 10、75和77的帐户的路径中检测到这种模式。</p><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/4fdb21fe0b8aeea61a13275123969a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJX5QKPyIkCVIMl3rX-7Hw.png"/></div></div></figure><p id="78e0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样，我们将尝试4跳。查询变得越来越长，但是它仍然比SQL中的要紧凑得多。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="b114" class="kb kc hh jx b be kd ke l kf kg">SELECT *<br/>FROM MATCH (<br/>       (a1)-[t1:transferred_to]-&gt;(a2)-[t2:transferred_to]-&gt;(a3)<br/>     , (a3)-[t3:transferred_to]-&gt;(a4)-[t4:transferred_to]-&gt;(a1)<br/>     ) ON graph2<br/>WHERE a1.acc_id = 10 AND ALL_DIFFERENT(a1, a2, a3, a4)<br/>  AND t1.amount &gt; 500 AND t2.amount &gt; 500<br/>  AND t3.amount &gt; 500 AND t4.amount &gt; 500<br/>  AND t1.datetime &lt; t2.datetime AND t2.datetime &lt; t3.datetime<br/>  AND t3.datetime &lt; t4.datetime</span></pre><p id="e5a1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样，在4跳的情况下，仅在一个组合中检测到该模式。</p><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/1d98aad906942480ffaeac53e0f46bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_rD1rHXP79dV-j27ESdrQ.png"/></div></div></figure><p id="724c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">也可以使用GROUP BY进行聚合。例如，让我们寻找在10月1日到12月1日期间收到大量小额汇款(少于500)的账户。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="d57a" class="kb kc hh jx b be kd ke l kf kg">SELECT a2.acc_id AS acc_id, COUNT(a2) AS num_of_txn<br/>FROM MATCH (a1)-[t:transferred_to]-&gt;(a2) ON graph2<br/>WHERE t.datetime &gt;= TIMESTAMP '2020-10-01 00:00:00'<br/>  AND t.datetime &lt; TIMESTAMP '2020-12-01 00:00:00'<br/>  AND t.amount &lt; 500.00<br/>GROUP BY a2 ORDER BY num_of_txn DESC LIMIT 10</span></pre><p id="6bef" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是，聚合结果不能用图形表示，所以您必须在表格中显示它们。</p><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/e336128f98a2e6f5d514844117d075a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_iQn6ypl28fZevIJUetviQ.png"/></div></div></figure><p id="15e3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">acc_id = 23的账号收到了29笔转账，我们来展示一下。</p><pre class="js jt ju jv fd jw jx jy bn jz ka bi"><span id="39d3" class="kb kc hh jx b be kd ke l kf kg">SELECT *<br/>FROM MATCH (a1)-[t:transferred_to]-&gt;(a2)&lt;-[o:owns]-(c) ON graph2<br/>WHERE t.datetime &gt;= TIMESTAMP '2020-10-01 00:00:00'<br/>  AND t.datetime &lt; TIMESTAMP '2020-12-01 00:00:00'<br/>  AND t.amount &lt; 500.00<br/>  AND a2.acc_id = 23</span></pre><p id="80d5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以确认转账。</p><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/7be504e863f0b6a67266eb057eb5c1cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9wV8V5k0LXrLOnBfD9ZzmQ.png"/></div></div></figure><p id="d246" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你怎么想呢?您可以看到，通过使用<code class="du ki kj kk jx b">CREATE PROPERTY GRAPH</code>语句创建一个视图，存储在表中的交易数据(如银行转帐)可以作为一个图形进行管理。使用这种方法，图定义使得表连接更加受限，因此我们可以保持PGQL查询的直观性和紧凑性。</p><p id="9237" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一方面，在PG view机制中，PGQL被转换为SQL并被执行，因此我们不能期望使用PGQL会提高查询性能。在这种机制上运行图算法也是没有效率的。在<a class="ae it" href="https://ryotayamanaka.medium.com/analyze-bank-transaction-data-using-graph-part-3-3-ab8ae1f68bd2" rel="noopener">第3部分</a>中，我们将引入一个3层架构选项来克服这些挑战。</p></div><div class="ab cl km kn go ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ha hb hc hd he"><p id="2e13" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请从以下网址了解有关<strong class="iw hi">甲骨文图</strong>的更多信息:</p><ul class=""><li id="c6ce" class="kt ku hh iw b ix iy jb jc jf kv jj kw jn kx jr ky kz la lb bi translated"><a class="ae it" rel="noopener" href="/tag/oracle-graph">中</a> (=所有带甲骨文图形标签的文章)</li><li id="1b94" class="kt ku hh iw b ix lc jb ld jf le jj lf jn lg jr ky kz la lb bi translated"><a class="ae it" href="https://stackoverflow.com/questions/tagged/oracle-graph" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a> (=带有oracle-graph标记的问题)</li><li id="8237" class="kt ku hh iw b ix lc jb ld jf le jj lf jn lg jr ky kz la lb bi translated"><a class="ae it" href="https://join.slack.com/t/andouc/shared_invite/zt-1a2hmiz6f-vLlblcQyv0t9FMraMMP5uQ" rel="noopener ugc nofollow" target="_blank"> Slack AnDOUC </a> (=邀请链接，请访问#graph)</li><li id="bfff" class="kt ku hh iw b ix lc jb ld jf le jj lf jn lg jr ky kz la lb bi translated"><a class="ae it" href="https://join.slack.com/t/oracledevrel/shared_invite/zt-uffjmwh3-ksmv2ii9YxSkc6IpbokL1g" rel="noopener ugc nofollow" target="_blank"> Slack OracleDevRel </a> (=邀请链接，请访问#oracle-db-graph)</li></ul></div></div>    
</body>
</html>