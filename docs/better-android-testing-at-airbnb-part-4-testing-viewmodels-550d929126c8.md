# Airbnb 更好的 Android 测试——第 4 部分:测试视图模型

> 原文：<https://medium.com/airbnb-engineering/better-android-testing-at-airbnb-part-4-testing-viewmodels-550d929126c8?source=collection_archive---------2----------------------->

在我们 Airbnb Android 测试系列的第四部分中，我们来看看 ViewModels 中单元测试逻辑的框架。

![](img/f37aff38ac07d1a2fe508c81b73f3ab7.png)

[在本系列的第三部分](/airbnb-engineering/better-android-testing-at-airbnb-1d1e91e489b4)中，我们看到了自动化交互测试如何通过记录状态变化来覆盖视图模型中的一些代码路径。然而，这不能测试我们逻辑的所有边缘情况。ViewModel 逻辑对于每个屏幕的正确行为至关重要，因此值得更深入地测试。

# 单元测试视图模型

视图模型是我们支持手动编写测试的一个例子，但是像往常一样，我们通过为我们的开发人员提供一个单元测试框架来最小化手动测试的开销。这包括一个简化测试语句的 DSL，与我们的网络堆栈集成以对执行的请求进行断言，以及与我们的状态模拟系统结合以轻松设置测试的 ViewModel 状态。

我们基于几个核心原则开发了单元测试框架:

*   视图模型函数应该是独立可测试的。视图模型的设计不应该依赖于多个函数调用之间的交互。
*   函数调用的行为应该完全由调用函数时 ViewModel 的状态以及传递给它的参数来定义。
*   该函数的输出应该是 ViewModel 上设置的新状态，或者是对依赖项的调用。

鉴于这些原则，我们的框架采用了以下方法:

*   每个单元测试调用一个视图模型函数
*   测试的输入是 ViewModel 的初始状态，加上传递给函数的参数
*   测试的输出是关于状态中发生了什么变化的断言，和/或对依赖项的预期调用的验证(通过 Mockito)。

# 一个基本例子

让我们看一个存储可更新字符串的基本视图模型。

测试 ***setText*** 函数的代码如下所示:

这指定了对我们正在测试的函数的引用、调用该函数的参数以及我们预期的结果是什么状态变化。这里我们测试调用***setText(" hello ")***导致文本状态被更新为" hello "。

***expectState*** 函数将初始状态作为接收方，返回期望的输出状态。这个返回的状态必须与输出完全匹配，否则测试会失败，框架会打印出哪些属性不相等。实际上， ***expectState*** 定义了哪些属性需要更改以及新的值应该是什么。这可以防止副作用被遗漏。

# 测试设置

测试框架负责初始化视图模型、收集测试语句和检查断言。

测试使用普通的 JUnit 和 Robolectric 设置运行，每个测试类对应一个视图模型。该类实现了一个接口，测试框架使用该接口为每个测试初始化一个新的 ViewModel。

例如，上述 ViewModel 的完整测试类如下所示:

测试框架使用 ***buildViewModel()*** 函数为每个测试创建一个新的 ViewModel。

视图模型的初始状态可以是从屏幕的现有模拟中重用的模拟状态。这允许屏幕截图测试、交互测试和 ViewModel 单元测试共享相同的底层模拟实例。这极大地减少了设置测试所涉及的工作，并且如果状态数据结构发生变化，只需要在一个地方更新 mock。

# 修改状态

如果测试需要使用默认状态的修改版本，它可以利用我们之前提到的数据类 DSL 来轻松地对嵌套状态进行更改。

为了演示，让我们把例子扩展得更复杂一点。现在它有了一些额外的状态，允许我们跟踪文本是否加粗。

我们检查 ***setBold*** 函数的测试语法如下:

这将执行以下操作:

1.  将嵌套的 ***bold*** 布尔属性初始化为 false
2.  用参数值 ***真*** 调用 ***setBold***
3.  验证 ViewModel 的最终状态是否将 ***粗体*** 属性设置为 true

# 展开性

DSL 使用可插拔系统，以便第三方扩展功能可以添加自定义语句和断言。我们自己用它来检查对我们的网络堆栈的预期调用。

在我们的示例 ViewModel 中，让我们添加一个从网络请求中加载文本的函数。

测试它的函数如下所示:

这项测试:

1.  调用 id 参数为“1”的 ***loadText*** 函数
2.  断言我们期望 ViewModel 使用 id 作为查询参数对给定的 API 路径执行网络 GET 请求
3.  指定模拟响应值“服务器结果”
4.  断言文本的最终状态值匹配我们模拟的响应值“服务器结果”

这允许我们用网络层测试我们的视图模型的边界，容易地检查期望的请求是否被发出并模拟返回值。

***expect requests***函数是单元测试框架的扩展函数。这允许我们开源核心库，但仍然在 Airbnb 测试我们的内部库。

同样值得注意的是，在单元测试和集成测试中，我们从不在 JSON 层模拟网络请求。我们发现维护 JSON 文件模拟很困难，也没有必要。相反，我们采用 GraphQL 来保证每个请求模式的编译时间。这意味着我们只需要断言进行了正确的查询，并且我们可以相信响应将是有效的、预期的格式。

这简化了我们的测试范围，提高了可维护性，并且仍然为我们的网络层功能提供了保证。

# 高级用法

单元测试框架提供了其他一些测试通用 ViewModel 模式的实用工具。

## 自动验证

一个常见的例子是 ViewModel 函数，它更新状态的单个属性，比如我们上面的例子切换“bold”布尔值。该框架为这种情况提供了特殊的处理，使它只需几行代码就可以测试。

使用此语法，测试:

1.  表示正在测试 ***setBold*** 功能
2.  指定对将因此而更改的嵌套状态属性的引用
3.  检测 ***setBold*** 函数的参数类型(本例中为布尔值)
4.  基于参数类型生成测试输入。对于布尔值，这将是真和假。如果它是可空的，它还将测试一个" ***null*** "输入。
5.  使用生成的输入值调用 ***setBold*** 函数，并在每次调用后检查状态中的“Bold”属性是否已更新为相同的值。

这适用于任何具有单一原始类型的函数——类型通过反射检测，函数通过各种测试值调用。然后检查状态的属性值，以确保它等于预期的测试值。

在更一般的情况下，我们也支持多参数函数以及状态属性类型不同于函数参数类型的情况。

例如，下面测试一个函数，该函数对输入进行平方，并设置状态的“result”属性值。

这使得列出输入到输出的映射变得容易；它自动调用每个输入的函数，并检查状态的相应输出。

## 测试初始化

ViewModel 在初始化期间执行网络请求或其他任务也很常见；也就是说，当实例化一个新实例并调用构造函数时。

例如，假设我们上面的 TextViewModel 被修改为在创建时从网络请求中加载文本。我们可以用这个语法测试这个行为。

这断言当 ViewModel 被实例化时，它:

1.  向预期的 API 路径发出网络 GET 请求
2.  将文本属性设置为“正在加载”状态

与正常的函数测试语法相比，这种语法是必需的，因为它必须包装视图模型的实例化并隔离那里的行为。另一方面，当测试函数时，我们排除了实例化过程中的行为，以免将它们合并。

## 生成测试脚手架

最后，在一个多模块的世界里，为每一个新创建的模块建立一个单元测试环境可能是乏味的(我们有数百个模块！).对于每个模块，我们需要:

*   一个机器人测试跑步者
*   测试类要扩展的基本测试，以便应用 runner
*   支持匕首测试覆盖的支架(一个新的匕首模块加上一个测试应用程序来设置匕首模块的注射)。
*   一个支持模拟最终类和函数的 mockito 插件(用于 Kotlin 用法)

我们已经创建了自动为模块生成所有这些测试框架的工具，因此开发人员可以立即开始编写单元测试，而无需处理任何繁琐的配置。

此外，我们还创建了一个 Intellij IDEA 插件，可以为我们生成新的 MvRx ViewModels。这允许我们为我们添加的每个新视图模型自动创建一个测试文件。

# 下一步:我们的自动化基础设施

总的来说，我们这个单元测试框架的目标是:

1.  消除测试视图模型逻辑的摩擦，同时；
2.  提供了一个简单而灵活的 API，可以覆盖 ViewModel 的所有用例。

此外，我们将该库设计为可扩展的，这样我们就可以对其进行开源，允许团队轻松地将他们自己的断言添加到 DSL 中。

虽然这对我们来说很棒，而且是全面测试业务逻辑所必需的，但是最好的测试是我们可以自动生成的！接下来，在系列文章的[第 5 部分，我们将重新审视我们的自动化集成测试框架，看看它如何为我们的交互和屏幕截图测试提供动力。](/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b)

## 系列索引

这是关于 Airbnb 测试的七篇系列文章。

第一部分-[测试哲学和模拟系统](/airbnb-engineering/better-android-testing-at-airbnb-3f5b90b9c40a)

第 2 部分-[MvRx 和 Happo 截图测试](/airbnb-engineering/better-android-testing-at-airbnb-a77ac9531cab)

第 3 部分-[自动化交互测试](/airbnb-engineering/better-android-testing-at-airbnb-1d1e91e489b4)

**第 4 部分(本文)** — [单元测试视图模型框架](/airbnb-engineering/better-android-testing-at-airbnb-part-4-testing-viewmodels-550d929126c8)

第 5 部分— [我们的自动化测试框架的体系结构](/airbnb-engineering/better-android-testing-at-airbnb-661a554a8c8b)

第 6 部分— [持续嘲讽的障碍](/airbnb-engineering/better-android-testing-at-airbnb-a11f6832773f)

第 7 部分— [测试生成和 CI 配置](/airbnb-engineering/better-android-testing-at-airbnb-eacec3a8a72f)

## 我们在招人！

想和我们一起在这些和其他大规模的 Android 项目上合作吗？Airbnb 正在全公司招聘几个 Android 工程师职位！当前空缺见 https://careers.airbnb.com。