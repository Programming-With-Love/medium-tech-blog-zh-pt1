<html>
<head>
<title>Method references and lambdas in lazy properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">惰性属性中的方法引用和lambdas</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/method-references-and-lambdas-in-lazy-properties-371dbbea857b?source=collection_archive---------3-----------------------#2020-08-10">https://blog.kotlin-academy.com/method-references-and-lambdas-in-lazy-properties-371dbbea857b?source=collection_archive---------3-----------------------#2020-08-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/68a0d61855e7f102c17efccfcec1a126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yDTXgA8nWKZQrN_KYqbftg.jpeg"/></div></div></figure><div class=""/><p id="988a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">这都是关于字节码的</strong></p><p id="8df2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> TLDR </strong></p><p id="3f07" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Kotlin中使用方法引用和lambdas时要小心，尤其是与Android框架创建的惰性属性和类(活动、片段、服务等)结合使用时。方法引用和lambdas被翻译成不同的java字节码，如果处理不当，这会带来麻烦。</p><p id="d7c1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">问题</strong></p><p id="d705" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我的项目突然在一个屏幕上出现奇怪的<code class="fe kt ku kv kw b">NullPointerException</code> (NPE)时，我遇到了这个问题。似乎在使用辅助注入从意图中获取信息时，意图是空的(剧透:它与懒惰的表示器初始化和方法引用有关)。</p><p id="c48a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">我们开始吧</strong></p><p id="bc0a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有的代码都可以在我的<a class="ae kx" href="https://github.com/SpKiwi/lambdas" rel="noopener ugc nofollow" target="_blank">库</a>中找到。</p><p id="362a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了说明这个问题，让我们创建一个简单的应用程序。它由两个屏幕组成。第一个屏幕是SeekBars可以用来根据年龄过滤人们的地方。当用户完成滑动时，他们可以打开第二个屏幕，显示基于这些标准的人(过滤器本身被传递到意图内部)。然后，如果用户点击任何一个人的名字，他们会得到一个祝酒词来问候这个特定的人。</p><p id="ad6f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用以下逻辑来创建屏幕:</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="9eaf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建这些活动的代码是相同的，除了用户正在启动的特定活动。活动也是一样的，除了一个小细节。其中一个活动将一个引用方法传递给用户适配器。另一个活动使用lambda。</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="faf5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您所看到的，presenter是延迟创建的，因为它需要访问在intent内部传递的信息(在框架完成所有与活动相关的初始化逻辑后，这些信息就可用了)。这就是辅助注入，因为参数是在运行时解析的，并且是从意图中提取的。让我们试试这两个例子。使用lambdas的例子工作得非常好。然而，当我们尝试使用方法引用(更简洁和更常用)时，事情就变得有趣了。</p><p id="d9d4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"><em class="le">Java . lang . nullpointerexception:试图对空对象引用调用虚拟方法“Java . io . serializable Android . content . intent . getserializableextra(Java . lang . string)”</em></strong></p><p id="685f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">UserPresenter</code>是延迟创建的，因此它应该在活动的<code class="fe kt ku kv kw b">onCreate</code>方法之后创建，并且到那时intent不应该为null。然而，在方法引用的情况下，<code class="fe kt ku kv kw b">UserPresenter</code>是在此之前创建的。它实际上是在创建适配器时初始化的。这怎么可能呢？让我们深入到反编译的java代码中，并尝试找出答案。</p><p id="7de3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们看看使用lambdas的代码。</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="3d2e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很简单。创建了一个<code class="fe kt ku kv kw b">Function1</code>类的匿名实例。而<code class="fe kt ku kv kw b">invoke</code>方法是当用户点击项目时将被调用的方法。但是在方法引用的情况下就有点棘手了:</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="0c84" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">匿名<code class="fe kt ku kv kw b">Function1</code>也被创建。但是这里的presenter是作为参数传递给构造函数的。即使它很懒，这也会立即初始化它，使它尝试访问意图，结果产生NPE。</p><p id="ad15" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">惰性初始化</strong></p><p id="935e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这也可能在其他情况下造成麻烦。初始化类有时会非常昂贵，甚至永远不会发生，这就是懒惰初始化的全部哲学。</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="289b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是由于所描述的问题，属性<code class="fe kt ku kv kw b">b</code>将被立即创建，尽管这不是预期的行为。</p><p id="0910" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">结论</strong></p><p id="0415" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总而言之，要小心，避免将方法引用与惰性属性结合使用。它将防止您的应用程序进行昂贵的初始化，并使您免于与框架初始化的类(如android活动、片段、服务等)相关的崩溃。</p></div><div class="ab cl lf lg hr lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ig ih ii ij ik"><h1 id="aeed" class="lm ln iy bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="475a" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kx" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kx" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在媒体上关注我们。</p><p id="51b2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您需要Kotlin工作室，请查看我们如何帮助您:<a class="ae kx" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi mp"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>