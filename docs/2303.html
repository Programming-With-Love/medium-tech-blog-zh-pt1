<html>
<head>
<title>Trying Clean Architecture on Golang — 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang-2上尝试清洁建筑</h1>
<blockquote>原文：<a href="https://medium.easyread.co/trying-clean-architecture-on-golang-2-44d615bf8fdf?source=collection_archive---------1-----------------------#2018-04-30">https://medium.easyread.co/trying-clean-architecture-on-golang-2-44d615bf8fdf?source=collection_archive---------1-----------------------#2018-04-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8360" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">独立的、可测试的和干净的</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/5475163d65eed85c2e4f66369e3ec7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P4_MZRp-WdZ-WAUbvkAbQw.png"/></div></div></figure><p id="50a3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">写完我的经历:“在Golang上尝试清洁建筑”这里:<a class="ae lk" href="https://hackernoon.com/golang-clean-archithecture-efd6d7c43047" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/Golang-Clean-Architecture-EFD 6d 7 c 43047</a></p><p id="6a28" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我从那里的人们和其他地鼠那里学到了很多东西。在我的项目中，我收到了许多电子邮件、评论甚至github问题，这一切都让我更加明白我错过了什么和犯了什么错误。</p><h2 id="d77e" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">循环导入</h2><p id="6d2c" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">我以前的项目和故事是:“在Golang 上尝试干净的建筑”，我可以说，这个项目和结构对Golang来说是有限的。我面临的最大问题之一是当模型中有多个依赖项时。这就是驱动循环导入，这里所说的<a class="ae lk" href="https://github.com/danf0rth" rel="noopener ugc nofollow" target="_blank">daf 0 rth</a>:<a class="ae lk" href="https://github.com/bxcodec/go-clean-arch/issues/7" rel="noopener ugc nofollow" target="_blank">https://github.com/bxcodec/go-clean-arch/issues/7</a>。</p><h2 id="73e6" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">包装系统</h2><p id="3df9" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">另一件事是，Golang不同于其他编程语言。它使用包系统。换句话说，最好将所有项目的<code class="fe mj mk ml mm b">struct</code>或<code class="fe mj mk ml mm b">function</code>存储在一个包中，这样会更安全。我可以在许多golang项目的库中或github的开源中看到这一点。我们以<a class="ae lk" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> logrus </a>为例。所有的<code class="fe mj mk ml mm b">struct</code>和<code class="fe mj mk ml mm b">function</code>都存储在一个包中，它位于项目包本身的根目录下。因此，我们可以很容易地将<code class="fe mj mk ml mm b">logrus</code>作为一个包导入到我们的任何整个项目中。</p><h1 id="896d" class="mn lm in bd ln mo mp mq lq mr ms mt lt jt mu ju lw jw mv jx lz jz mw ka mc mx bi translated">求解？</h1><p id="c671" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">因此，在意识到这一点后，我尝试了许多方法，但没有错过“干净架构”的概念，即独立、可测试、可维护和干净，也没有失去Golang身份。最后，我对我的旧项目进行了更新，例如:<a class="ae lk" href="https://github.com/bxcodec/go-clean-arch" rel="noopener ugc nofollow" target="_blank">https://github.com/bxcodec/go-clean-arch</a></p><h2 id="182d" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">—避免循环导入</h2><p id="8f84" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">为了避免循环导入，我将模型分离到一个包中。因此，如果我们有模型之间的关系，我们可以解决它，因为它们已经存储在一个包中。</p><h2 id="0f6f" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">—使用包装系统恢复Golang身份</h2><p id="4239" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">在不失去Golang身份的情况下，作为一种包编程语言，我将接口(用例和存储库层)移动到他们的根域包。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi my"><img src="../Images/5feb4640c6a5c1fcb421b5db1b0e6302.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*1L20aohBH1Bu7O68sHuqdA.png"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk">domain package golang clean architecture</figcaption></figure><pre class="kd ke kf kg gt nd mm ne nf aw ng bi"><span id="1c6f" class="ll lm in mm b gy nh ni l nj nk">article<br/>├── delivery<br/>│   └── http<br/>│       ├── article_handler.go<br/>│       └── article_test.go<br/>├── mocks<br/>│   ├── ArticleRepository.go<br/>│   └── ArticleUsecase.go<br/>├── repository //<strong class="mm io">Encapsulated Implementation of Repository Interface</strong><br/>│   ├── mysql_article.go<br/>│   └── mysqlarticle_test.go<br/>├── repository.go // <strong class="mm io">Repository Interface</strong><br/>├── usecase //<strong class="mm io">Encapsulated Implementation of Usecase Interface</strong><br/>│   ├── articleucase_test.go<br/>│   └── artilce_ucase.go<br/>└── usecase.go // <strong class="mm io">Usecase Interface.</strong></span></pre><p id="2f3c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，从这个结构项目中，其他领域，如<code class="fe mj mk ml mm b">Author</code>的领域，只知道接口和功能，而不知道实现。</p><p id="7b2d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">嗯，实际上，我只是把接口<code class="fe mj mk ml mm b">repository</code>和<code class="fe mj mk ml mm b">usecase</code>移到它们的域根。</p><pre class="kd ke kf kg gt nd mm ne nf aw ng bi"><span id="ed55" class="ll lm in mm b gy nh ni l nj nk">article/usecase/usecase.go <strong class="mm io">&gt;&gt;&gt;&gt;</strong> article/usecase.go<br/>article/repository/repository.go <strong class="mm io">&gt;&gt;&gt;&gt;</strong> article/repository.go</span></pre><p id="9418" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">并将它们实现留在它们的旧文件夹中。通过这些设计，我仍然可以在不更改合同的情况下更改它们的实现。我仍然可以将存储库实现从MySQL更改为MongoDB，或者我仍然可以更改用例逻辑，而不更改函数的输出和输入。</p><h2 id="c663" class="ll lm in bd ln lo lp dn lq lr ls dp lt kx lu lv lw lb lx ly lz lf ma mb mc md bi translated">测试？</h2><p id="959f" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">观念依然没有改变。还有测试。还是老样子。这个改变仅仅是为了避免循环导入，也是为了恢复golang作为一个包编程的身份。</p><h1 id="0aa2" class="mn lm in bd ln mo mp mq lq mr ms mt lt jt mu ju lw jw mv jx lz jz mw ka mc mx bi translated">最后但并不是最不重要的</h1><p id="2271" class="pw-post-body-paragraph ko kp in kq b kr me jo kt ku mf jr kw kx mg kz la lb mh ld le lf mi lh li lj ig bi translated">所有这些设计都是基于我自己的经验和对他人的学习。一些特性可能是我从其他源代码中获取，其中一些我做了一些改进。如果我在文章中犯了什么错误或遗漏了什么，我将非常感谢任何问题、评论或修改。</p><p id="00c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在戈朗的生活中，没有标准的建筑，我们可以自由地尝试许多方法，因为我们可以做和学习。对一些人来说，我提出的架构是有帮助的，但对另一些人来说，它真的不适合，也没有解决真正的问题。但是，我想说的是，Golang是免费的，从来没有标准，您可以开发自己的标准，或者您可以尝试其他人在那里做的事情，有这么多其他人提出的干净的架构，这可能会对您有更多的帮助。</p><p id="fb49" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nl">但是，如果你发现这很好，并且适合你的问题，请分享并鼓掌帮助其他人解决这个问题。</em></p></div></div>    
</body>
</html>