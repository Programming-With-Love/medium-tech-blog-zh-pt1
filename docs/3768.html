<html>
<head>
<title>Design Patterns in JavaScript: Behavioral</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的设计模式:行为</h1>
<blockquote>原文：<a href="https://medium.com/globant/design-patterns-in-javascript-behavioral-3c8f53aaa7c0?source=collection_archive---------0-----------------------#2021-10-17">https://medium.com/globant/design-patterns-in-javascript-behavioral-3c8f53aaa7c0?source=collection_archive---------0-----------------------#2021-10-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/773e15823238b16384b423e44a5b6433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9EMwqRi8RuIn68LBbc_9A.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@gpthree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">George Pagan III</a> on <a class="ae it" href="https://unsplash.com/s/photos/patterns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a>.</figcaption></figure><p id="413c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">设计模式是将众所周知且经过测试的解决方案应用于软件开发中常见问题的好方法。<em class="js">行为</em>模式是一个设计模式类别，被授予与<em class="js">沟通和对象之间的分配</em>情况相关的常见问题。我写这篇文章的目的是为开发者提供一个简单易用的快速参考指南。</p><h1 id="342d" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">责任链。</h1><p id="9427" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">责任链模式允许沿着有机会处理请求的对象链传递请求。收到请求后，每个处理程序决定是处理请求还是将请求传递给链中的下一个处理程序。</p><p id="b5a6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，我们链接了折扣类来处理购物车中的折扣是多少的请求。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">chain of responsability</figcaption></figure><p id="9eb8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当不止一个对象可以处理一个请求，并且该信息在运行时已知时，使用这种模式。</p><h1 id="07a2" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">命令。</h1><p id="eb6c" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">命令模式允许将请求封装为对象。这种转换允许您将请求作为方法参数传递，延迟或排队请求的执行，并支持可撤销的操作。</p><p id="8de6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，我们将on/off的指令封装为对象，并在Car构造函数中将它们作为参数传递。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">command</figcaption></figure><p id="960c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您有一个请求队列需要处理或者您想要一个<em class="js">撤销</em>动作时，使用这个模式。</p><h1 id="ee6e" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">翻译。</h1><p id="2567" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">解释器模式允许在问题经常出现时为简单语言创建语法；可以考虑用简单的语言将其表示为一个句子，以便解释者可以通过解释该句子来解决问题。</p><p id="a3a9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，我们创建了一个简单的数来乘以几个数的幂。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">interpreter</figcaption></figure><p id="19f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您想要解释给定的语言，并且可以将语句表示为抽象语法树时，请使用这种模式。</p><h1 id="fdd4" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">迭代器。</h1><p id="7d89" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">迭代器模式允许访问集合中的元素，而不暴露其底层表示。</p><p id="26dc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，我们创建了一个简单的迭代器，它有一个包含元素的数组，使用方法next()和hasNext()我们可以遍历所有的元素。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">iterator</figcaption></figure><p id="7265" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您想要访问一个对象的内容集合而不知道它在内部是如何表示的时候，可以使用这种模式。</p><h1 id="51c3" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">调解员。</h1><p id="571e" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">中介模式通过定义一个封装了一组对象如何交互的对象，减少了对象之间混乱的依赖关系。</p><p id="c8e7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，我们创建了一个类mediator TrafficTower，它现在允许我们从飞机实例中获取所有位置。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">mediator</figcaption></figure><p id="7bbb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当一组对象以复杂的方式相互通信时，使用这种模式。</p><h1 id="e83c" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">纪念品。</h1><p id="f7a8" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">memento模式允许捕获和具体化一个对象的内部状态，以便该对象可以在以后恢复到这个状态。</p><p id="ff2d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本例中，我们创建了一种简单的方法来存储值并在需要时恢复快照。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">memento</figcaption></figure><p id="313d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您希望生成对象状态的快照以便能够还原对象以前的状态时，请使用此模式。</p><h1 id="52f9" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">观察者。</h1><p id="32e0" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">观察者模式允许在对象之间定义一对多的依赖关系，这样当一个对象改变状态时，它的所有依赖对象都会得到通知并自动更新。</p><p id="8e1b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本例中，我们创建了一个简单的类产品，其他类可以观察register()方法中的注册更改，当有更新时，notifyAll()方法将与所有观察器就这些更改进行通信。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">observer</figcaption></figure><p id="7015" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当更改一个对象的状态可能需要更改其他对象，并且实际的对象集事先未知或动态变化时，请使用此模式。</p><h1 id="4ac9" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">状态。</h1><p id="ea28" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">状态模式允许对象在其内部状态改变时改变其行为。</p><p id="687f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本例中，我们创建了一个简单的状态模式，其中的Order类将使用next()方法更新状态。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">state</figcaption></figure><p id="fcad" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当对象的行为依赖于它的状态，并且它在运行时的行为变化依赖于它的状态时，使用这种模式。</p><h1 id="82f5" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">策略。</h1><p id="0649" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">策略模式允许定义一系列算法，封装每一个算法，并使它们可以互换。</p><p id="47be" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个例子中，我们有一组可以在购物车中应用的折扣。这里的技巧是，我们可以将要应用的函数传递给构造函数，并以这种方式更改折扣金额。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">strategy</figcaption></figure><p id="babc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当你有许多相似的类，只是它们执行某些行为的方式不同时，使用这种模式。</p><h1 id="089b" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">模板法。</h1><p id="9dbb" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">模板模式允许在超类中定义算法的框架，但允许子类在不改变其结构的情况下覆盖算法的特定步骤。</p><p id="d9a4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本例中，我们将创建一个简单的模板方法来计算税款，并在增值税和商品及服务税(税种)中扩展该模板，这样我们就可以在多个税种中重用相同的结构。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">template</figcaption></figure><p id="60d3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您希望让客户端只扩展算法的特定步骤，而不是整个算法或其结构时，请使用此模式。</p><h1 id="00ad" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">访客。</h1><p id="9289" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">访问者模式允许将算法与它们所操作的对象分开。</p><p id="68c7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本例中，我们创建了一个结构来计算两种类型员工的奖金，通过这种方式，我们可以将奖金方法扩展到越来越多类型的员工，如CEO奖金、VP奖金等。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">visitor</figcaption></figure><p id="651c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当一个对象结构包含许多类，并且您想要对依赖于它们的类的结构元素执行操作时，请使用这种模式。</p><h1 id="a48e" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">在系列中。</h1><p id="3558" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated"><a class="ae it" rel="noopener" href="/globant/design-patterns-in-javascript-creational-2a02726e4e71">创作</a></p><p id="65c5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" href="https://blog.carlosrojas.dev/design-patterns-in-javascript-structural-106bc31953c9" rel="noopener ugc nofollow" target="_blank">结构性</a></p><p id="d22f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" href="https://blog.carlosrojas.dev/design-patterns-in-javascript-behavioral-3c8f53aaa7c0" rel="noopener ugc nofollow" target="_blank">行为</a></p><h1 id="36b6" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">参考文献。</h1><p id="0bca" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated"><em class="js">设计模式——JavaScript</em>。(2019).设计模式— JavaScript。https://designpatternsgame.com/patterns<a class="ae it" href="https://designpatternsgame.com/patterns" rel="noopener ugc nofollow" target="_blank"/></p><p id="bf06" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Refactoring.Guru. (2014)。<em class="js">设计图案</em>。<a class="ae it" href="https://refactoring.guru/design-patterns" rel="noopener ugc nofollow" target="_blank">https://refactoring.guru/design-patterns</a></p><p id="dff0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">蒂姆斯，S. (2016年)。<em class="js">掌握JavaScript设计模式—第二版</em>(第二修订版)。包装出版公司。</p><p id="a5c6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我希望这篇文章能派上用场，如果你有问题，不要忘记发表评论，或者通过<a class="ae it" href="https://mobile.twitter.com/carlosrojas_o" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我。再见:)</p></div></div>    
</body>
</html>