<html>
<head>
<title>Hilt Extensions in the MAD Skills series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">疯狂技能系列中的手柄扩展</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/hilt-extensions-in-the-mad-skills-series-f2ed6fcba5fe?source=collection_archive---------4-----------------------#2021-09-13">https://medium.com/androiddevelopers/hilt-extensions-in-the-mad-skills-series-f2ed6fcba5fe?source=collection_archive---------4-----------------------#2021-09-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/ec3aed893acac649e393e9ce71ba397f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a_ZJwMHs17SmEFr3uEbxDg.png"/></div></div></figure><div class=""/><p id="f048" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是剑柄上疯狂技能系列的第四集！请务必查看<a class="ae jn" rel="noopener" href="/androiddevelopers/introduction-to-hilt-in-the-mad-skills-series-40f0908f2fc0">第1集</a>—DI和刀柄介绍、<a class="ae jn" rel="noopener" href="/androiddevelopers/hilt-testing-best-practices-in-the-mad-skills-series-8186a57eee2c">第2集</a> —测试最佳实践，以及<a class="ae jn" rel="noopener" href="/androiddevelopers/mad-skills-series-hilt-under-the-hood-9d89ee227059">第3集</a> —引擎盖下的刀柄。在这一集，我们将看看如何编写自己的刀柄扩展。</p><p id="beec" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您喜欢以视频格式观看这些内容，请点击此处查看:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="js jt l"/></div></figure><h1 id="02c8" class="ju jv hs bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">示例:工作管理器扩展</h1><p id="7b8e" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">刀柄扩展是生成代码的库，通常通过注释处理器。生成的代码是模块或入口点，它们构成了Hilt的依赖注入图。</p><p id="6258" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">扩展的一个例子是用于<a class="ae jn" href="https://developer.android.com/training/dependency-injection/hilt-jetpack#workmanager" rel="noopener ugc nofollow" target="_blank"> Jetpack的工作管理器</a>的集成库。WorkManager扩展有助于减少为工作人员提供依赖关系所需的样板文件和设置。这个库由两个工件组成，<em class="kx"> androidx.hilt:hilt-work </em>和<em class="kx">Android x . hilt:hilt-compiler</em>。第一个工件包含HiltWorker注释以及一些运行时助手类，而第二个工件是一个注释处理器，它使用第一个工件的注释提供的信息生成模块。</p><p id="a3e9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用扩展非常简单，只需用@HiltWorker注释您的工人:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="ky jt l"/></div></figure><p id="f6d5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么扩展编译器将生成一个@Module注释类:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="ky jt l"/></div></figure><p id="0f0f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该模块为工作线程定义了一个可由HiltWorkerFactory访问的绑定。然后，WorkManager被配置为使用工厂，支持工人的依赖注入。</p><h1 id="b94a" class="ju jv hs bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">刀柄聚合</h1><p id="ccb9" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">支持扩展的一个关键机制是，Hilt能够发现类路径中的模块和入口点。这被称为聚合，因为模块和入口点被聚合到用@HiltAndroidApp注释的应用程序中。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kz"><img src="../Images/bfab4e81d4cdf8ee8e6a1c18196f546a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q4G6jyCZ0ivpesIG"/></div></div></figure><p id="5564" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">得益于Hilt的聚合，任何用@InstallIn生成@Module或@EntryPoint注释类的工具都会被Hilt发现，并在编译时成为Hilt DI图的一部分。这使得用户无需任何额外的工作就可以轻松地将扩展插件插入到刀柄中。</p><h1 id="9b48" class="ju jv hs bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">注释处理器</h1><p id="0dcb" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">生成代码的一种常见方式是通过注释处理器。在将源代码转换成类文件之前，注释处理器在编译器中运行。当找到一个带有处理器声明的受支持注释之一的源时，处理器将运行。处理器可以生成可以进一步处理的代码，因此编译器会循环运行注释处理器，直到不再生成新的源代码。一旦所有回合结束，编译器就将源代码转换成类文件。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es la"><img src="../Images/602de3c2fbd567a3f549b16ad599fb39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KnUDr6eT568J0juP"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx">Annotation Processing Diagram</figcaption></figure><p id="5d8e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于多轮机制，处理器可以相互作用。这很重要，因为这允许Hilt的注释处理器处理其他处理器生成的@Module或@EntryPoint类。这也意味着你的扩展可以建立在别人编写的扩展之上！</p><p id="4a39" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:hilt/hilt-compiler/src/main/kotlin/androidx/hilt/work/" rel="noopener ugc nofollow" target="_blank"> WorkManager扩展处理器</a>基于用@HiltWorker注释的类生成代码，验证注释用法，并使用<a class="ae jn" href="https://github.com/square/javapoet" rel="noopener ugc nofollow" target="_blank"> JavaPoet </a>等库生成代码。</p><h1 id="7eab" class="ju jv hs bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">刀柄延伸部分注释</h1><p id="a811" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">在Hilt的API中有两个重要的注释，扩展应该使用它们来正确地与Hilt集成。它们是@GeneratesRootInput和@OriginatingElement。</p><p id="5a44" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由扩展触发代码生成的注释应该用@GeneratesRootInput进行注释。这让Hilt的注释处理器知道它应该在生成组件之前等待扩展注释处理器完成。例如，@HiltWorker注释本身是用@GeneratesRootInput注释的:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="ky jt l"/></div></figure><p id="5b1c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用@Module或@EntryPoint以及@InstallIn注释的生成类也应该用@OriginatingElement注释，它的值是导致生成模块或入口点的顶级类。这是为了让Hilt能够识别生成的模块或入口点是否是本地测试。例如，如果一个内部类@HiltWorker是在一个Hilt测试中定义的，那么这个模块的原始元素就是这个测试。</p><p id="6efa" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于以下测试:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="ky jt l"/></div></figure><p id="e7b1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">生成的模块将包含以下@OriginatingElement:</p><figure class="jo jp jq jr fd hj"><div class="bz dy l di"><div class="ky jt l"/></div></figure><h1 id="0956" class="ju jv hs bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">主意</h1><p id="a77c" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">刀柄扩展有多种可能性，下面是一些创建扩展的想法:</p><p id="d2f8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">项目中常用的模式。</strong></p><p id="2f01" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您的项目中有一个创建模块或入口点的通用模式，那么它们很可能可以通过一个柄扩展来自动化。例如，如果对于每个实现特定接口的类，必须创建一个具有多绑定绑定的模块，那么就可以创建一个扩展，只需对实现类进行注释，就可以生成多绑定模块。</p><p id="c4f2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">支持非标准成员注入。</strong></p><p id="4899" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于拥有实例化的其他框架的成员注入类型，则需要创建一个@EntryPoint。如果有多种类型需要成员注入，那么自动创建入口点的扩展会很有用。例如，通过<a class="ae jn" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html" rel="noopener ugc nofollow" target="_blank"> ServiceLoader </a>发现服务实现的库负责实例化发现的服务。为了将依赖项注入到服务实现中，必须创建一个@EntryPoint。有了Hilt扩展，就有可能注释实现类，从而自动生成一个入口点。扩展可以进一步生成代码来使用入口点，比如一个基类，然后由服务实现扩展。这类似于@ AndroidEntryPoint为活动创建@EntryPoint，并创建一个基类，该基类使用生成的入口点在活动中执行成员注入。</p><p id="6172" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">镜像绑定</strong></p><p id="8d9e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有时，绑定需要用不同的限定符进行镜像或重新声明。当存在自定义组件时，这可能更常见。为了避免错过重新声明，可以创建一个句柄扩展来自动生成镜像其他绑定的模块。例如，考虑包含不同依赖实现的应用程序的“付费”和“免费”订阅的情况。然后，每一层都有两个不同的定制组件，这样就可以确定依赖关系的范围。当添加一个公共的非作用域绑定时，定义绑定的模块可以在它的“@InstallIn”中包含两个组件，或者可以安装在父组件中，通常是单例组件。但是当绑定被限定范围时，模块必须被复制，因为需要不同的限定符。一个扩展可以生成两个模块，避免样板代码并确保公共绑定不会丢失。</p><h1 id="0da2" class="ju jv hs bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">摘要</h1><p id="fcc0" class="pw-post-body-paragraph ip iq hs ir b is ks iu iv iw kt iy iz ja ku jc jd je kv jg jh ji kw jk jl jm ha bi translated">对Hilt的扩展可以进一步增强代码库中的依赖注入，因为它们可以被创作来与其他还不被Hilt支持的库集成。总而言之，一个扩展通常由两部分组成。一个包含扩展注释的运行时工件，以及一个代码生成器，通常是一个注释处理器，它生成@Module或@EntryPoint。扩展的运行时方面可能有额外的助手类，它们使用在生成的模块或入口点中声明的绑定。代码生成器也可能生成与扩展相关的附加代码，也就是说，它们不需要专门生成模块和入口点。</p><p id="ff8b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">扩展必须使用两个注释才能正确地与Hilt交互:</p><ul class=""><li id="d2a8" class="lf lg hs ir b is it iw ix ja lh je li ji lj jm lk ll lm ln bi translated">@GeneratesRootInput放在扩展注释中。</li><li id="9fff" class="lf lg hs ir b is lo iw lp ja lq je lr ji ls jm lk ll lm ln bi translated">@OriginatingElement通过扩展放在生成的模块或入口点中。</li></ul></div><div class="ab cl lt lu go lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ha hb hc hd he"><p id="84a7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，对于一个简单扩展的示例项目，它展示了本文中提到的概念，您可以查看一下<a class="ae jn" href="https://www.github.com/danysantiago/hilt-install-binding" rel="noopener ugc nofollow" target="_blank"> hilt-install-binding </a>项目:</p><div class="hg hh ez fb hi ma"><a href="https://www.github.com/danysantiago/hilt-install-binding" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab dw"><div class="mc ab md cl cj me"><h2 class="bd ht fi z dy mf ea eb mg ed ef hr bi translated">GitHub-dany Santiago/hilt-安装-绑定</h2><div class="mh l"><h3 class="bd b fi z dy mf ea eb mg ed ef dx translated">在GitHub上创建一个帐户，为dany Santiago/hilt-install-binding开发做贡献。</h3></div><div class="mi l"><p class="bd b fp z dy mf ea eb mg ed ef dx translated">www.github.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo ho ma"/></div></div></a></div><p id="8e82" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">剑柄狂技能系列到此为止！你可以观看这个<a class="ae jn" href="https://goo.gle/hilt-mad" rel="noopener ugc nofollow" target="_blank"> Youtube播放列表</a>中的所有剧集。谢谢大家！</p></div></div>    
</body>
</html>