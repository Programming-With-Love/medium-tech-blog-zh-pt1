<html>
<head>
<title>Docker host and bridged networking. Running library/httpd on different ports</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker主机和桥接网络。在不同的端口上运行库/httpd</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/docker-host-and-bridged-networking-running-library-httpd-on-different-ports-1de81af1ae4b?source=collection_archive---------0-----------------------#2018-08-18">https://medium.com/oracledevs/docker-host-and-bridged-networking-running-library-httpd-on-different-ports-1de81af1ae4b?source=collection_archive---------0-----------------------#2018-08-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="e354" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Docker提供了不同的网络选项。使用Docker主机网络时，您没有创建端口映射的选项。当使用像library/httpd:2.4这样的映像时，您没有更新它运行的端口的选项；默认情况下，它运行在端口80上。假设您想要使用主机联网特性，并且想要在不同的端口上运行library/httpd:2.4，您会如何做呢？</p><p id="826f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇博客中，我将解释两种机制，通过这两种机制，您可以使用主机网络在不同的端口上公开library/httpd，以及如何使用桥接网络来做同样的事情。我将描述不同解决方案的几个特征以及连接/主机查找选项的结果。在这篇文章的最后，我会给出一些关于如何测试容器间连通性的提示。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/fa8ef7b7206c3fbc31a6d3d7cf7d3647.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*FfG-0Dw8lcQa8b_l.png"/></div></figure></div><div class="ab cl jk jl go jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ha hb hc hd he"><h1 id="7e00" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">使用Docker主机网络</h1><h2 id="49e7" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">每个端口的图像</h2><p id="4672" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">您可以创建自己的docker文件并使用ARG(参数),如下所示:</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="222d" class="kp js hh lj b fi ln lo l lp lq">FROM httpd:2.4<br/>MAINTAINER Maarten Smeets &lt;maarten.smeets@amis.nl&gt;</span><span id="9a58" class="kp js hh lj b fi lr lo l lp lq">LABEL nl.amis.smeetsm.httpd.name=”Apache Httpd” nl.amis.smeetsm.httpd.version=”2.4"<br/> <br/>#COPY ./www/ /usr/local/apache2/htdocs/<br/>ARG PORT<br/>RUN sed -ri “s/^Listen 80/Listen $PORT/g” /usr/local/apache2/conf/httpd.conf<br/>ENTRYPOINT [“httpd-foreground”] </span></pre><p id="2702" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以这样构建:</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="0d69" class="kp js hh lj b fi ln lo l lp lq">docker build — build-arg PORT=84 -t smeetsm/httpd:2.4 .</span></pre><p id="86fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">像这样运行:</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="bf8f" class="kp js hh lj b fi ln lo l lp lq">docker run -dit — network host — name my-running-app-01 smeetsm/httpd:2.4</span></pre><p id="8bd8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这允许您构建一个在特定端口上运行的容器。这样做的缺点是，您构建的映像专门用于在单个端口上运行。如果希望容器在多个端口上运行，就需要多个映像。</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="328b" class="kp js hh lj b fi ln lo l lp lq">docker build — build-arg PORT=84 -t smeetsm/httpdport84:2.4 .</span><span id="d608" class="kp js hh lj b fi lr lo l lp lq">docker build — build-arg PORT=85 -t smeetsm/httpdport85:2.4 .</span><span id="5c57" class="kp js hh lj b fi lr lo l lp lq">docker build — build-arg PORT=86 -t smeetsm/httpdport86:2.4 .</span></pre><p id="2cd5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">像这样运行它们</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="ea9e" class="kp js hh lj b fi ln lo l lp lq">docker run -dit — network host — name my-running-app-01 smeetsm/httpdport84:2.4</span><span id="7971" class="kp js hh lj b fi lr lo l lp lq">docker run -dit — network host — name my-running-app-02 smeetsm/httpdport85:2.4</span><span id="1677" class="kp js hh lj b fi lr lo l lp lq">docker run -dit — network host — name my-running-app-03 smeetsm/httpdport86:2.4 </span></pre><p id="5699" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您不能在多个端口上运行同一个映像。因此，您必须为每个端口创建一个映像，这可能不是您想要的。此外，用这种方式创建的容器不容易扩展。</p><h2 id="4c69" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">在不同端口上运行的单个映像</h2><p id="1136" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">更干净的解决方案是使用Apache提供的相同基础映像，并向端口提供run命令。您可以这样做:</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="914f" class="kp js hh lj b fi ln lo l lp lq">docker run -dit — network host — name my-running-app-01 library/httpd:2.4 /bin/bash -c “sed -ri ‘s/^Listen 80/Listen 84/g’ /usr/local/apache2/conf/httpd.conf &amp;&amp; httpd-foreground”</span><span id="627d" class="kp js hh lj b fi lr lo l lp lq">docker run -dit — network host — name my-running-app-01 library/httpd:2.4 /bin/bash -c “sed -ri ‘s/^Listen 80/Listen 85/g’ /usr/local/apache2/conf/httpd.conf &amp;&amp; httpd-foreground”</span><span id="b1d2" class="kp js hh lj b fi lr lo l lp lq">docker run -dit — network host — name my-running-app-01 library/httpd:2.4 /bin/bash -c “sed -ri ‘s/^Listen 80/Listen 86/g’ /usr/local/apache2/conf/httpd.conf &amp;&amp; httpd-foreground”</span></pre><p id="84d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Docker run允许您指定要运行的单个命令，并且您可以为此命令提供参数。如果希望依次运行多个命令，可以使用bash的-c参数。</p><p id="e8e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以上命令使用主机网络驱动程序启动指定端口(84、85、86)上的3个容器。这确实有局限性，如果不通过主机接口，容器就不能相互通信。它们都共享Docker主机主机名，因为它们直接使用Docker主机网络接口。有趣的是，他们可以使用自己的主机名直接访问主机上的不同端口。</p><p id="69de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，如果我使用主机名ubuntu-vm在端口84上运行my-running-app-01，并且使用相同的主机名(因为使用了相同的网络接口)在端口85上运行my-running-app-02，那么我可以通过访问ubuntu-vm或localhost(！)端口85。my-running-app-01不知道my-running-app-02是在Docker容器内部运行还是直接托管在Docker主机上。</p><h1 id="cbaf" class="jr js hh bd jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko bi translated">Docker桥接网络</h1><p id="0f17" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">使用桥接网络，这通常是使用Docker时的默认设置，您可以创建命名的桥接网络。这些命名桥接网络上的主机可以通过它们的容器名(自动DNS)找到彼此。</p><p id="2bc9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">桥接网络还在主机网络和容器网络之间提供了一个层。容器可以通过NAT接口访问其他网络资源。如果您想从主机或外部世界访问端口，您必须显式映射端口。使用桥接网络，容器内的软件可以在同一端口上运行，只有外部端口可以不同。因此，当您想要在不同的端口上运行时，不需要更新配置文件。在这种情况下，您使用相同的图像来创建不同的容器。以下示例使用默认桥接网络。容器可以通过IP互相访问</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="1df9" class="kp js hh lj b fi ln lo l lp lq">docker run -dit — name my-running-app-01 -p 84:80 library/httpd:2.4</span><span id="2fbe" class="kp js hh lj b fi lr lo l lp lq">docker run -dit — name my-running-app-02 -p 85:80 library/httpd:2.4</span><span id="4ea4" class="kp js hh lj b fi lr lo l lp lq">docker run -dit — name my-running-app-03 -p 86:80 library/httpd:2.4 </span></pre><p id="a4e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的例子使用了一个命名的桥接网络。容器可以通过名称相互访问。</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="4d02" class="kp js hh lj b fi ln lo l lp lq">docker network create — driver bridge my-net</span><span id="4411" class="kp js hh lj b fi lr lo l lp lq">docker run -dit — name my-running-app-01 -p 84:80 — network my-net library/httpd:2.4</span><span id="f0fc" class="kp js hh lj b fi lr lo l lp lq">docker run -dit — name my-running-app-02 -p 85:80 — network my-net library/httpd:2.4</span><span id="e25d" class="kp js hh lj b fi lr lo l lp lq">docker run -dit — name my-running-app-03 -p 86:80 — network my-net library/httpd:2.4</span></pre><h1 id="0970" class="jr js hh bd jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko bi translated">笔记</h1><p id="830a" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">为了测试网络连接，我使用了以下工具:</p><h2 id="183f" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">网络和容器</h2><p id="3bc0" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">为了找出使用了哪些网络:</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="ad5f" class="kp js hh lj b fi ln lo l lp lq">docker network ls</span><span id="0629" class="kp js hh lj b fi lr lo l lp lq">NETWORK ID NAME DRIVER SCOPE<br/>3457e6f0a394 bridge bridge local<br/>43e8356475ab host host local<br/>bffb13042787 my-net bridge local<br/>fc4390096330 none null local</span></pre><p id="cf95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了找出哪个容器连接到哪个网络以及它使用哪个IP，我做了:</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="2d81" class="kp js hh lj b fi ln lo l lp lq">docker network inspect my-net</span><span id="15ae" class="kp js hh lj b fi lr lo l lp lq">"Containers": {<br/>            "3398bb1f84504d1d5cb85a107420059dce3b617a91aef6663f526e0f7cd610b0": {<br/>                "Name": "my-running-app-02",<br/>                "EndpointID": "7f8191b81db6718b6f4c8091344e35a1b9641bb591025a6d5aa12699b631fbaf",<br/>                "MacAddress": "02:42:ac:12:00:03",<br/>                "IPv4Address": "172.18.0.3/16",<br/>                "IPv6Address": ""<br/>            },<br/>            "810f87402961d79538238d07a9fb70774621b5f6363878d83884fafc89e382ed": {<br/>                "Name": "my-running-app-01",<br/>                "EndpointID": "5a6c99d83d4d43fec8cb7b6812f1628620f39dd13abf4caa4e5bacbf36f2707a",<br/>                "MacAddress": "02:42:ac:12:00:02",<br/>                "IPv4Address": "172.18.0.2/16",<br/>                "IPv6Address": ""<br/>            }<br/>        }</span></pre><p id="8233" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以上只是输出的一部分，但确实指出了容器和IP</p><h2 id="ccda" class="kp js hh bd jt kq kr ks jx kt ku kv kb ip kw kx kf it ky kz kj ix la lb kn lc bi translated">从容器内部检查连通性</h2><p id="9294" class="pw-post-body-paragraph ie if hh ig b ih ld ij ik il le in io ip lf ir is it lg iv iw ix lh iz ja jb ha bi translated">输入容器:</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="3d60" class="kp js hh lj b fi ln lo l lp lq">docker exec -it my-running-app-01 /bin/bash </span></pre><p id="4132" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为容器是基于Debian的，所以我可以使用Apt来安装包。</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="f3b0" class="kp js hh lj b fi ln lo l lp lq">apt-get update &amp;&amp; apt-get install -y telnet</span></pre><p id="22ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尝试从特定容器内连接到特定容器</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="eaad" class="kp js hh lj b fi ln lo l lp lq">telnet my-running-app-02 80</span></pre><p id="537d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我得到这样的回应:</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="029b" class="kp js hh lj b fi ln lo l lp lq">telnet my-running-app-02 80</span><span id="1eef" class="kp js hh lj b fi lr lo l lp lq">Trying 172.18.0.3…<br/>Connected to my-running-app-02.<br/>Escape character is ‘^]’.<br/>^C</span></pre><p id="76b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以建立连接。</p><p id="92c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我得到这样的回应</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="f811" class="kp js hh lj b fi ln lo l lp lq">telnet my-running-app-02 81<br/>Trying 172.18.0.3…<br/>telnet: Unable to connect to remote host: Connection refused</span></pre><p id="e4af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我无法建立联系。上述内容表明将my-running-app-02解析为一个有效的IP。</p><p id="a3cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果主机也无法解析，则异常如下:</p><pre class="jd je jf jg fd li lj lk ll aw lm bi"><span id="da02" class="kp js hh lj b fi ln lo l lp lq">telnet whatever 80<br/>telnet: could not resolve whatever/80: Name or service not known</span></pre></div><div class="ab cl jk jl go jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ha hb hc hd he"><p id="5615" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lx">原载于2018年8月18日</em><a class="ae ly" href="https://javaoraclesoa.blogspot.com/2018/08/docker-host-and-bridged-networking.html" rel="noopener ugc nofollow" target="_blank"><em class="lx">【javaoraclesoa.blogspot.com】</em></a><em class="lx">。</em></p></div></div>    
</body>
</html>