# 为什么我们需要 WebAssembly

> 原文：<https://medium.com/javascript-scene/why-we-need-webassembly-an-interview-with-brendan-eich-7fb2a60b0723?source=collection_archive---------1----------------------->

# 布伦丹·艾希访谈

## Brendan Eich 和 Eric Elliott 讨论 WebAssembly 细节和误解

上周(2015 年 6 月 17 日)， [Brendan Eich 宣布了一个新项目](https://brendaneich.com/2015/06/from-asm-js-to-webassembly/),为 web 带来新的底层原语——这一举措将使用 C & C++等语言编写的项目更容易编译，以便在浏览器和其他 JavaScript 环境中运行。如果这是你第一次听说它，请阅读[“什么是 web assembly”](/javascript-scene/what-is-webassembly-the-dawn-of-a-new-era-61256ec5a8f6)以获得基本概述。

WebAssembly 团队包括来自**谷歌、微软、Mozilla、** **苹果**以及其他打着 [**W3C WebAssembly 社区组**](https://www.w3.org/community/webassembly/) 旗号的人。

这个声明让 web 开发社区开始猜测 WebAssembly 会如何影响 JavaScript 的未来。**布伦丹·艾希在接受埃里克·埃利奥特采访时填补了空白**。

**TL；博士:没有小鸡，天没有塌下来。**

所有的重点都加了。

> **EE:** 最近，你在博客上宣布，我们将推出一款名为 WebAssembly 的产品。基本上是一种用于 web 的汇编语言，一种低级编译目标。你能告诉我们这是关于什么的吗？是什么激励你去做这件事的？

**是:**确定。从某些方面来说，这只是一个延续的过程，始于 **ASM.js** 。ASM.js 是 JavaScript 的一个子集，它没有对象，没有垃圾收集，或者只是在编译器暂停时。它是 C/C++的目标 JavaScript 的静态类型子集。这一点在 Mozilla 与大型游戏公司的合作中得到了展示，如使用虚幻引擎的 **Epic Games** 和使用 Unity 引擎和 IDE 的 **Unity** 。

因此，这使得许多用这些引擎发布的游戏——市场上有虚幻引擎 3 和虚幻引擎 4 的游戏，基于 Unity 5 的游戏只使用另一种指令集来针对 JavaScript。

这些游戏可能会瞄准 **PS4** 、 **XBox** 和 **PC。**现在**他们也可以针对网络**用 [**WebGL**](https://en.wikipedia.org/wiki/WebGL) 和 [**ASM.js**](http://asmjs.org/) ，网络音频和其他 API 很重要，游戏手柄 API，全屏 API 都很重要。

我在 Mozilla 时，这是一个巨大的成功，他们实际上已经转向了微软。我记得几年前和安德斯·海尔斯伯格、T21 和史蒂夫·卢科交谈过。**安德斯**当然是谁做了 **C#** 和**。领导**脉轮**团队的网**和**史蒂夫**——我认为仍然如此。他们对此非常热情，因此 **Edge 支持 ASM.js** 作为在线优化的整体模块优化，就像 Mozilla 一样，性能良好。

不客气地说，我认为这是**本机客户端**的最后一根稻草，或真正可移植的本机客户端(PNaCl ),这是**谷歌**在浏览器中为 C & C++安全编译他们的版本的唯一方式，这甚至从未在 **Chrome 中完全启用。它被列入了某些谷歌资产的白名单。我想 Google+有一个图像编辑器。**

随着时间的推移，完全原生的客户端不会跨越到其他浏览器。要做他们想做的每一件事，还有很长的路要走。他们雄心勃勃。而 ASM.js 一开始看起来就像，哦，它没有线程，没有锁，没有本机代码中需要的很多东西，它没有 **SIMD** (单指令，多数据)，我们现代 CPU 中内置的向量单元的短向量内部函数。

毫无疑问，JavaScript 没有这些东西，但现在它有了。 **SIMD** 在**火狐**每晚，它的**来到 V8** ，英特尔已经在他们版本的 V8、**人行横道**、**微软宣布 SIMD 支持**来到**查克拉**。

**假设网络停滞不前——这不是一个好的假设**，我认为这也是很久以前发生在便携原生客户端和 **Dart** 等项目上的错误。他们认为 JavaScript 是无能的，它不可能变得更好，因此他们必须做一些事情，相当于将整个第二系统或第三系统添加到浏览器中，但他们无法将其完全融入 Chrome。

我没有幸灾乐祸。现实主义需要渐进主义。所有的浏览器都必须以更小的步伐前进。这真的是火狐和 Chrome 恢复浏览器竞争的地方——火狐优先。当然，也有不同的世界，我们在 21 世纪初看到一个，IE 达到 95%的市场份额，微软不投资网络，而是投资**。NET** 和**Windows Presentation Foundation**，所有那些东西。

无论如何不要继续谈论历史，**ASM . js 的继续发展是 wasm** 。它之所以重要，是因为一旦 **ASM.js 跨越**进入其他浏览器，很明显它将跨越**进入所有浏览器**。

然而，JavaScript 甚至是 JavaScript 的子集 ASM.js 都缺少 SIMD、线程、共享内存和其他原语。即使使用 ASM.js，您仍然要解析 JavaScript。这是一个子集。您可以为该子集运行专用的解析器，这是另一项维护工作，因为现在您有了两个解析器，一个用于完整的 JavaScript 语言，另一个用于子集。

你仍然面临着**一个昂贵的解析问题**，相比之下，用一个更有效的、压缩的**抽象语法树(AST)** 就可以解决这个问题，而这正是 WebAssembly 的目标。

人们一直在网上寻求字节码，以为他们想要 Java 字节码。我认为 MSR 和其他地方的研究人员已经表明，他们不想那样——那在几个方面都有所阻碍。AST 编码要好得多。

起初， **WebAssembly 就像 ASM.js** 一样开始，但是使用了压缩的语法，那是一个**二进制语法**。但是一旦所有的浏览器都支持 wasm 和 ASM.js，并且经过一段时间的浏览器更新，那么 **wasm 可以开始增加额外的语义，而不需要放入 JavaScript** 。

事实上，它们可能会被放入 JavaScript 和 wasm 中，因为它们是同一个引擎(1vm)，但有些东西我们可能不想放入 JavaScript，因为为了 C++或 Haskell 等其他语言的利益，它们可能会被放入 wasm 中。有很多语言可以编译成 wasm。

> 你能给我们举些例子吗？

**BE:** 当然，这些都是[写在 GitHub](https://github.com/WebAssembly/design#webassembly-community-group-design) 中的，但是仅仅争论**共享内存数组缓冲区**来获得**多线程游戏**交叉编译是对 JavaScript 的一种压力，因为在很长一段时间里，我们不希望 JavaScript 中有竞争条件——这总是一个有错误危险的脆弱过程。这是一个例子，如果我们可以选择的话，我们可能会把它保存在 WebAssembly 中。

接下来还有类似的事情，比如**零成本异常**在 JavaScript 中可能没有意义。它们需要一些编译器和运行时技巧，但对 C++和 Swift 来说确实有意义。

再比如 **call/cc** (带电流延续的呼叫 **)** 。Call/cc 这个工具太强大了。它对 JavaScript 引擎有**实现上的挑战**和**安全隐患**。

你有这些非本地函数 gotos。您可以调用 continuation 并在不同的堆栈中关闭。所以它不像 ES6 中的生成器那样是局部的、有限的延续。是更深层次的延续。所以 **call/cc 可以放入 wasm** 中，放入引擎中处理 wasm 和 JavaScript。可想而知。它不会转向 JavaScript 语言，而是转向 WebAssembly 语法，不会影响遗留的 JavaScript 世界。

> **EE:** 说到这里，wasm 有没有我们需要仔细考虑的安全隐患？

**BE:** 因为它一开始是与 ASM.js 共同表达的，所以**一开始并没有增加任何新的安全问题**，但是随着一两年后它开始出现分歧，那么**是的，我们需要看看所有这些扩展的安全属性**。这是一个额外的挑战。这是谷歌本地客户一直在思考的问题。他们正在提供帮助，他们在这方面的知识很有帮助。

我们试图从 C++和[**【PNaCl】**](https://developer.chrome.com/native-client/overview)使用的 [**LLVM**](http://llvm.org/) 编译器以及[**emscriten**](https://github.com/kripken/emscripten)也使用的编译器中驱逐未定义的行为。从硬件到 C++的规范，有许多未定义的行为，这对安全性不利。

JavaScript 的规范性更强，并试图比许多其他语言更安全。对于 WebAssembly，我们需要更多地使用 JavaScript。

> 登记簿上有一个有趣的标题。你是想扼杀 JavaScript 吗？这就是全部的原因吗？

**贝:**(笑)不，我是个实用主义者。我是一个老 C/C++黑客。这是一个进化的大系统。人类在尝试，但也面临着网络上真正的兼容性限制。

你不破坏网络，你就没有机会重新开始。任何尝试的人都会失败。即使你看到移动设备上的原生应用，那里有相当成熟的用户界面和图形的原生语言和工具包，但仍然有很多网络。有很多混合应用。

**脸书**仍然使用网络浏览。所有的大应用——亚马逊、 **Pinterest、**等等都使用网络视图。用原生表示层代替 HTML 来重新发明很多 web 资产是完全疯狂的。所以网络仍然非常重要。这也是最高的货币化平台。

智能手机有着难以置信的渗透率。几年内，这个星球上几乎每个成年人都会有一部智能手机，这对许多事情来说都是巨大的，但这并不意味着智能手机就是一台电脑。它更像是一个消费设备。这不像你坐着打字，深入研究和购物。

因此，与其杀死 JavaScript，这是不可行的，我想做的是回应我们在 ASM.js 中遇到的实际工程问题。从 Epic 或 Unity 加载一个大型游戏可能需要 20 - 30 秒。那太长了。压缩的抽象语法树编码速度快 20 倍，只需几秒钟，这就是你想要的。所以**wasm**有一个真正的原因，而且是一个有效的原因。

> [阅读 [Unity 博客文章](http://blogs.unity3d.com/2015/06/18/webgl-webassembly-and-feature-roadmap/)了解 WebAssembly 如何显著改善游戏体验。]

Wasm **帮助** JS 获胜，这不仅是本机代码编译的胜利。最终，所有的浏览器和网络视图都将支持 wasm 语法来服务于编译目标主机，并释放 JavaScript，以便它可以服务于 JavaScript 主机。

JavaScript 一直处于分裂阶段，从长远来看，它永远不会成功。就像我说的，即使是共享数组缓冲区扩展，对 JavaScript 来说也有点困难，并且有能力让 wasm 做 C++想要的奇特的事情，而不需要想办法把那些不太安全的设施放到 JavaScript 中，这是一个很大的解脱。

因此，解析性能，而不是服务于两个主服务器，这些都是使用 wasm 的好理由。我们没有扼杀 JavaScript。我觉得连 JavaScript 都杀不死。

> “天没有塌下来。”

> **EE:** 对于很多一直有点担心的人来说，这是个好消息。事实上，我认为这是我在互联网上看到的对 wasm 公告最常见的反应。人们害怕天要塌下来。**我认为我们可以有把握地说，天不会塌下来，JavaScript 将会存在一段时间。**

**BE:** 我认为考虑到 JavaScript 的特权地位，以及 **wasm 是如何真正成为 C++** 等静态语言的目标的，我们还需要一段时间才能获得 wasm 的其他未来扩展，如垃圾收集和 wasm 的即时编译，这些是动态语言良好运行所需的功能，这也需要一段时间。

与此同时，在谷歌做 Dart 编译器的人将继续使用 JavaScript，因为当你不在检查模式下编译时，Dart 代码实际上是动态代码——它需要 JavaScript 的 JIT(即时编译)。它需要多态内联缓存和其他优化。

理想情况下，我们将在 JavaScript 中获得 Dart 拥有但 JavaScript 还没有的大整数/big num，这是未来 ECMAScript 的议程。我认为 JavaScript 会一直存在下去。很难说我们能在任何时候摆脱作为浏览器内置和唯一内置高级语言的 **JavaScript。**

> 回到 90 年代，我曾经自己写了很多 C/C++。我在民主的环境中长大。我不知道你是否熟悉，但我们基本上构建了艺术应用程序，就像一部运行实时代码而不是预先录制的视频的电影。那时候，我们总是使用汇编语言来做视频处理或音频处理，或者需要大量数据处理的效果。你认为 wasm 是构建这类应用的有用工具吗？

我愿意。我应该提到，我们有 SIMD 来 JavaScript。我们已经将 WebGL 追溯到了近 10 年前。Mozilla 的 Vladimir vuki EVI 在年开始这样做，后来加入了 Khronos Group ，WebGL 成为支持 Epic、Unity 和其他大型游戏的基础的一部分是一件好事。

然而这仅仅是基于 **OpenGL ES** ，OpenGLT5[的移动配置文件。在 WebGL 2 中，它只是刚刚从 OpenGL ES2 提升到 3 点。所以当你看到桌面 GPU 时，它们可以做得更多。Wasm 可以拥有 OpenGL 4，这是最新最棒的桌面，拥有所有花哨的额外着色器，并针对所有疯狂的 Nvidia GPUs。](https://en.wikipedia.org/wiki/OpenGL)

也许这些图形处理器会渗透到移动设备中，但这需要一段时间。无论 WebGL 发生什么，有了 wasm，我们可以在未来几年进行更多的硬件编程，包括那些先进的 GPU。

> 谁参与了这件事？我知道你在博客中提到了微软和谷歌的人，他们都参与其中，我们将从哪里得到支持？

BE:**BE:**因为我是一个局外人，所以很难为其他公司发布公告，你可能已经注意到了，一家公司的名字不太可能被借用，但这只是一个常见的协议延迟问题。那里没有困难，负责 [WebKit](https://www.webkit.org/) 和 [JavaScriptCore](https://trac.webkit.org/wiki/JavaScriptCore) 、 [Filip Pizlo](http://www.filpizlo.com/) 的负责人的名字在 [GitHub 库](https://github.com/WebAssembly)(web assembly GitHub 帐户)中很活跃。

菲利普为苹果公司工作。其他命名的公司有**微软、Mozilla、**和**谷歌**。

Mozilla 确实是 ASM.js 的先驱，但 PNaCl 上的 Google 人员也一直在解决许多相同的问题，并解决未定义的行为，在我们开始做共享数组缓冲区之前，考虑 ASM.js 目前不支持的更高级的功能，如动态链接和线程。

我认为在某种程度上是时候弥合裂痕了。我认为在[黑客新闻](https://news.ycombinator.com/)上，很多人认为我是一个大混蛋，因为不知何故，从我在 Mozilla 的头骨王座上，我设法在精神上控制了行业中的每个人，以阻止 PNaCl 进入其他浏览器，或者如果我只是把它放入 Mozilla(以巨大的代价),那么其他人就会排队**,因为如果 Mozilla 和 Google 做什么，其他人必须做。**并非如此，参见 WebM。

![](img/830427e95110c3c5891bbd728e75b157.png)

Mozilla office photo by [@mart3ll](https://twitter.com/mart3ll) — [Eye-witness testimony](https://news.ycombinator.com/item?id=9555028)

所以，我认为有很多不面对现实的人会有不好的感受。事实是 PNaCl 不会跨浏览器，但是很多工作都是基于 LLVM 的。它超越了我们对 ASM.js 所做的一切，所以这是一次完美的联姻。它最初被认为是不吉利的，但事实证明，让曾经从事 ASM.js 和 PNaCl 工作的人从事 WebAssembly 工作非常棒。

> 考虑到它背后的所有支持，我们什么时候能看到 wasm 的内置浏览器支持？

**BE:** 我不知道，他们仍然必须建立一个原型或一些可以发展的东西，因为我们从 JavaScript 和 HTML 中学到的一件事是，你不能做很多硬版本。您最终会浮动一些具有对象检测或特性检测，或者一些 autoconf 测试工具的东西，以便您可以编写防御性代码来优雅地降级。

因此，如果几年后 wasm 2018 中有 call/cc，也许其他一些语言只是运气不好，但如果它也有一些高级功能，如零成本异常，那么你想在没有零成本异常的 wasm 2017 浏览器上运行，也许你会因异常调用而受到更大的打击。也许没关系。

JavaScript 编程中有一些非常重要的东西，我们称之为 **1JS** ，这是大约 8 年前我们在 ES4 中使用的 mimetype 版本。在 Bjoern Hoehrmann 的关于 JavaScript 的*`<script type = " application/ecmascript ">`*的文章中对其进行了整理。他说有一个版本参数。它没有说版本的值是什么，(但你不能忽略它)，但人们总是会得到错误的版本，错误的 mimetype 或编写没有任何 mime type 的脚本标签。

版本锁定的整个想法失败了，这是理所当然的，我认为这是其他尝试它的运行时系统普遍存在的问题。我预计在接下来的几个月里，他们会对抽象语法树编码性能感到满意，在编码效率和解码效率之间进行权衡，解码是最重要的。他们会很清楚如何扩展语法。

然后他们可以开始在夜间运输。我希望有一天——我想是明年——但这完全是猜测，对，我没有水晶球。但是我们将开始看到至少夜间浏览器已经支持 wasm，甚至可能更快，可能是今年秋天。

> “我会考虑明年—
> 但这完全是猜测。”

很快，社区小组将开始考虑语法的标准化。让这个问题变得不那么紧迫的一件事是，已经有了他们所谓的 poly fill——它实际上只是一个库——一个 JavaScript 版本的解码器，用于从二进制代码返回 ASM.js 的原型抽象语法树。

即使是现在，JavaScript 也在某种程度上软启动了 wasm，而无需遵循确切的语法。与现代 HTML5 时代一样，web 标准的关键是迭代，而不是试图做一些巨大的 10 年规格并立即获得所有权利，任何时候都像 ES4(这是一个大的重构)或 ES6(这是一个大的重构)一样，唯一能挽救它的是真实引擎中正在进行的增量原型。

HTML5 是一个大型的多年版本，以一个巨大的版本 stamp 5 结束，但事实上，在任何人说它已经完成之前，它已经推出了部分。

> 你提到了一个原型，是不是人们现在就可以下载、玩、看的东西？

**BE:** 是的，我想是的，如果你去 GitHub 账户，WebAssembly，然后你在 [polyfill-prototype-1](https://github.com/WebAssembly/polyfill-prototype-1) 下找，你会看到一个解码器。我没有时间，但是如果你看一下[Emscripten](https://github.com/kripken/emscripten)——Emscripten 将使用 polyfill(库 JavaScript 解码器)以可选模式支持这一点，我想这已经在实验中了。

> **EE:** 随着所有这些东西进入 wasm，JavaScript 还会看到你在演讲“走大路和小路”中提到的一些底层特性吗？

**BE:** 是的，就像我说的，当 wasm 受到支持并且不需要 polyfill 时，它可以比 ASM.js 更有表现力。它可以有更大的语义，但是，这需要一段时间。

与此同时，无论如何，大量的东西必须进入 JavaScript，因为人们需要它，即使他们没有编译。他们想用它来手工编码。这是 SIMD 的真实情况，这是我们一直在提升的许多东西的真实情况 *`Math`* 对象，内在的，你可能在 [**libm**](https://en.wikipedia.org/wiki/C_mathematical_functions) 中得到的东西，如果你是 C 代码或 C++代码，有一些东西是 ES6 添加的，还有一些东西在我们的议程上。

我认为我们仍然会走捷径，但我认为在大约 5 年的时间框架内，我们不必如此担心，如果有一些捷径只适用于编译器，并且我们非常确定 JavaScript 手工编码者不需要，那么我们可以将它从 JavaScript 中删除，这是不服务于两个主的一部分。

> 你认为这会导致大量的语言碎片化吗，或者是多样性，有什么不同吗？这是好事还是坏事？很多人似乎对此感到困惑。

**BE:** 我认为 **JavaScript 在浏览器状态中内置了独特的动态语言**，但是 wasm 可以支持许多编译语言，当然现在是静态语言——尤其是那些使用 LLVM 的语言。微软有他们自己的编译器，所以他们将从不同的编译器框架来做 wasm，但这很好。越多越好

当然 [GCC](https://gcc.gnu.org/) 或类似的可以生成 wasm，但是我认为要使用动态语言，比如我提到的 **Dart、**或 **Ruby、**或 **Python，甚至 JavaScript——这需要一些我之前提到的扩展**,比如:垃圾收集挂钩、JIT 支持等等。否则他们就没有竞争力。

有很好的先例。JVM 发展了很多年，这要归功于约翰·罗斯(John Rose)开发出了像 *`invokedynamic`* 这样的东西，以及像多态内联缓存这样的实时编译优化挂钩，所以 JVM 实际上是一个可信的动态语言平台。

所有这些运行时都变成了多语言虚拟机——JavaScript 虚拟机。Java 并没有因为 JVM 现在支持 Clojure、Scala 和其他语言而消亡。我们几乎处于编程语言的第二个黄金时代，你知道，以 Rust、Haskell、Idris 和其他语言为例。

我说，人越多越好。它不会成为巴别塔，因为我认为 JavaScript 将成为浏览器的通用语言，无论是现在还是将来。如果你写的是前端代码，或者实际上是任何在你分析时不在关键路径上的东西。

> “我说，人越多越好。”

但如果你真的想绘制那些激烈的 3d 游戏，或者一些非常复杂的计算机视觉内核算法，那么你可能会使用 C++或编译成 wasm 的东西，在五年内，如果人们对编译成 wasm 的新语言充满热情，那么这种语言应该会兴起，我不认为这是一个问题，我认为这只是大城市生活的一部分。

> 所以，如果有更好的东西出现，你真的希望看到 JavaScript 最终被淘汰吗？

**BE:** 再说一次，我不认为它会被扼杀，因为网络上的所有内容都必须在浏览器中运行，而在 wasm 中实现 JavaScript 运行时对工程师来说是一个真正的挑战，要想和 V8 一样快。但是很多年后，如果有人这样做了，那么你就可以让 JavaScript 成为 T4 实现的语言之一。

> “嘿，这不是我记得的 JavaScript
> ——这相当不错！”

但是仍然是这种语言在网络上有如此大的立足点。它也在发展，因为我们仍在努力使 JavaScript 成为更好的手工编码语言，所以它不是静止不动的。ES6 让人们说，“嘿，这不是我记得的 JavaScript——这很好！”

再说一次，我没有水晶球，我只是认为杀死 JavaScript 是非常困难的。我不是*想*干掉 JavaScript。我并不特别需要看到 JavaScript 活得比它需要的时间更长，如果人们从长远来看发现其他语言更好，如果在这条路上，我们经历了如此多的迭代，以至于内置在浏览器中的 JavaScript 并不重要，那么我说，**“que sera sera。”**

我真的认为那些因为某种原因敌视 JavaScript 而希望它失败的人会失望的。它不会消失的。

这实际上对 JavaScript 和其他语言都有好处。不要假设停滞状态。我认为 wasm 将会为包括 JavaScript 在内的很多很多语言增加很多很多的表现力。

这是每个人都能赢的例子之一。这确实符合每个人对网络的愿望，无论是苹果、谷歌、微软还是 Mozilla。

现在要做的事情是专注于渐进的改进，而不是试图走在现实的前面太远。像 ES4、PNaCl、Dart 或 XHTML 之类的东西。所有这些试图按照自己的宏伟计划重塑网络的大爆炸都不起作用。

所以现在我们有所有这些人在这些小刘海上合作，我们应该会看到一系列具有巨大累积效应的小刘海。

*/be*

> [跟随 Eric Elliott](https://ericelliottjs.com) 学习 JavaScript

***埃里克·艾略特*** *著有* [*【编程 JavaScript 应用】*](http://pjabook.com) *(奥赖利)，以及* [*【学习 JavaScript 通用 App 开发用节点，ES6，&【React】*](https://leanpub.com/learn-javascript-react-nodejs-es6/)*。他为 Adobe Systems******尊巴健身*******华尔街日报*******【ESPN*******BBC****等顶级录音师贡献了软件经验******

**他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。**