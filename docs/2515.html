<html>
<head>
<title>Integration Test (Database) in Golang using Dockertest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dockertest在Golang中进行集成测试(数据库)</h1>
<blockquote>原文：<a href="https://medium.easyread.co/integration-test-database-in-golang-using-dockertest-59ed3b35240e?source=collection_archive---------0-----------------------#2020-06-14">https://medium.easyread.co/integration-test-database-in-golang-using-dockertest-59ed3b35240e?source=collection_archive---------0-----------------------#2020-06-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="813d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我们如何使用Dockertest在Golang中进行集成测试</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/261212c0d9e57fcf0505df69370d33c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxgPxyq5IBxQhxsiGTDskw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://pixabay.com/illustrations/feedback-satisfaction-employee-3240007/" rel="noopener ugc nofollow" target="_blank">pixabay.com</a></figcaption></figure><p id="6692" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">大家好！又是我，还是想分享一些关于软件工程领域技术相关的经验、思考或者看法。今天，我要和你分享的话题是关于我在Golang中使用Dockertest进行集成测试的经历。这个集成测试将集中在使用数据库的代码上。</p><p id="9345" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在继续之前，集成测试的定义是什么？在我看来，根据我的经验，如果单元测试将在模拟数据上测试我们的代码库，那么集成测试将集中在使用真实数据上。事实上，真正的数据不仅仅是关于数据库，有时我们可以为我们的应用程序提供外部服务。但是，我们的应用程序通常会有一个数据库，那么在本文中，我们将重点关注与数据库的集成测试。</p><p id="6610" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">工程师通常是如何解决这种集成测试的？根据我的经验，通常，他们会这样做:</p><ul class=""><li id="ee11" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">在虚拟机或服务器上设置真实数据库测试</li><li id="68a0" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">使用Docker这样的容器设置数据库测试</li></ul><p id="c69e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我认为第2点对于现在来说已经足够简单了，但是我意识到我们可以在Go中使用Dockertest使它更简单。</p><h2 id="48dc" class="md me in bd mf mg mh dn mi mj mk dp ml lc mm mn mo lg mp mq mr lk ms mt mu mv bi translated">什么是Dockertest？为什么呢？</h2><p id="b1f5" class="pw-post-body-paragraph kt ku in kv b kw mw jo ky kz mx jr lb lc my le lf lg mz li lj lk na lm ln lo ig bi translated">基于他们在<a class="ae ks" href="https://github.com/ory/dockertest" rel="noopener ugc nofollow" target="_blank">https://github.com/ory/dockertest</a>的项目，实际上Dockertest将拥有与第2点相同的机制。但是Dockertest库提供了易于使用的命令来旋转Docker容器并在测试中使用它们，正如他们所说的。然后，我们不需要通过Dockerfile或docker-compose手动设置docker。</p><p id="4f16" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还是不知道吗？让我们试着写测试！</p><p id="b57f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Dockertest支持多种数据库，如MySQL、PostgreSQL、MongoDB、Redis、Cassandra等。但是，在本文中，我们将尝试使用PostgreSQL。首先，像这样创建项目结构:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="8509" class="md me in nc b gy ng nh l ni nj"><em class="nk">+ your_gopath/<br/>|<br/>+--+ src/github.com/moemoe89<br/>|  |<br/>|  +--+ integration-test-golang/<br/>|     |<br/>|     +--+ main.go<br/>|        + repository/<br/>|        |<br/>|        +--+ repository.go<br/>|        |<br/>|        +--+ mysql<br/>|        |  |<br/>|        |  +--+ mysql.go<br/>|        |     + mysql_test.go<br/>|        |<br/>|        +--+ postgres<br/>|           |<br/>|           +--+ postgres.go<br/>|              + postgres_test.go<br/>|<br/>+--+ bin/<br/>|  |<br/>|  +-- ... executable file<br/>|<br/>+--+ pkg/<br/>   |<br/>   +-- ... all dependency_library required</em></span></pre><p id="dbbe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们需要制作3个文件:<code class="fe nl nm nn nc b"><strong class="kv io">repository</strong></code>目录下的<code class="fe nl nm nn nc b"><strong class="kv io">repository.go</strong></code>和<code class="fe nl nm nn nc b"><strong class="kv io">repository/postgres</strong></code>目录下的<code class="fe nl nm nn nc b"><strong class="kv io">postgres.go</strong></code>和<code class="fe nl nm nn nc b"><strong class="kv io">postgres_test.go</strong></code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="aa35" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe nl nm nn nc b"><strong class="kv io">repository.go</strong></code>只包含数据模型的实现和结构的接口。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9b6f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，<code class="fe nl nm nn nc b"><strong class="kv io">postgres.go</strong></code>会有<code class="fe nl nm nn nc b"><strong class="kv io">repository</strong></code>接口的实现，包括迁移和CRUD功能。如果您已经熟悉了干净架构的概念和依赖注入，那么代码对您来说就很容易了。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5c2f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，测试文件<code class="fe nl nm nn nc b"><strong class="kv io">postgres_test.go</strong></code>将使用Dockertest测试存储库代码。我将对这一部分进行更多的解释，因为我们将在这个实现中使用Dockertest代码。</p><p id="6878" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，我们需要创建一个池。如果要使用默认值，请将string参数留空。</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="2270" class="md me in nc b gy ng nh l ni nj">pool, err := dockertest.NewPool(<strong class="nc io">""</strong>)<br/><strong class="nc io">if </strong>err != nil {<br/>   log.Fatalf(<strong class="nc io">"Could not connect to docker: %s"</strong>, err)<br/>}</span></pre><p id="e6c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其次，我们将在这里开始运行容器。这就是为什么我们应该定义像图像库、标签、环境变量以及暴露端口这样的选项。</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="dcf2" class="md me in nc b gy ng nh l ni nj">opts := dockertest.RunOptions{<br/>   Repository: <strong class="nc io">"postgres"</strong>,<br/>   Tag:        <strong class="nc io">"12.3"</strong>,<br/>   Env: []string{<br/>      <strong class="nc io">"POSTGRES_USER=" </strong>+ user,<br/>      <strong class="nc io">"POSTGRES_PASSWORD=" </strong>+ password,<br/>      <strong class="nc io">"POSTGRES_DB=" </strong>+ db,<br/>   },<br/>   ExposedPorts: []string{<strong class="nc io">"5432"</strong>},<br/>   PortBindings: <strong class="nc io">map</strong>[docker.Port][]docker.PortBinding{<br/>      <strong class="nc io">"5432"</strong>: {<br/>         {HostIP: <strong class="nc io">"0.0.0.0"</strong>, HostPort: port},<br/>      },<br/>   },<br/>}</span><span id="1e4d" class="md me in nc b gy nq nh l ni nj">resource, err := pool.RunWithOptions(&amp;opts)<br/><strong class="nc io">if </strong>err != nil {<br/>   log.Fatalf(<strong class="nc io">"Could not start resource: %s"</strong>, err.Error())<br/>}</span></pre><p id="8995" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们需要为包装在池重试中的Postgres db模型创建一个存储库接口的表示。为什么我们需要这个机制？因为有时候我们需要等待Docker准备好服务db连接。</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="db4e" class="md me in nc b gy ng nh l ni nj"><strong class="nc io">if </strong>err = pool.Retry(<strong class="nc io">func</strong>() error {<br/>   repo, err = postgres.NewRepository(dialect, dsn, idleConn, maxConn)<br/>   <strong class="nc io">return </strong>err<br/>}); err != nil {<br/>   log.Fatalf(<strong class="nc io">"Could not connect to docker: %s"</strong>, err.Error())<br/>}</span></pre><p id="985f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后一步是净化。清除将从docker中删除docker容器和链接的卷。</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="94e9" class="md me in nc b gy ng nh l ni nj"><strong class="nc io">if </strong>err := pool.Purge(resource); err != nil {<br/>   log.Fatalf(<strong class="nc io">"Could not purge resource: %s"</strong>, err)<br/>}</span></pre><p id="c163" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好吧！是时候进行测试了。使用<code class="fe nl nm nn nc b"><strong class="kv io">go test ./...</strong></code>执行测试用例。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/87e9be78d3b51303b7a1d0662baddb65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whbCf6HYZBTwHL76gMTpGw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture 1 Integration Test Result</figcaption></figure><p id="08d3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">很好，我们通过了测试！！在上面的图1中，我也写了MySQL测试。因此，当我们检查docker图像时，会显示MySQL和Postgres图像，如下图2所示。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/1e67cadcbdb6034e94a825c9635aa0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m3tkTLW8-05omUF_YxRxfw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture 2 Docker Images</figcaption></figure><p id="27fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有趣的是，我们可以在像Travis CI这样的CI服务上做到这一点。在我的存储库中，您可以看到我正在使用Travis CI来执行测试！</p><p id="a378" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是<code class="fe nl nm nn nc b"><strong class="kv io">.travis.yml</strong></code>文件的例子。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ea73" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您想查看这个测试的完整示例项目，您可以访问我在GitHub上的这个项目的资源库。也许我会添加另一个数据库，如果我有时间！</p><div class="nt nu gp gr nv nw"><a href="https://github.com/moemoe89/integration-test-golang" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">moe moe 89/集成测试-golang</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">通过在GitHub上创建帐户，为moe moe 89/integration-test-golang开发做出贡献。</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">github.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok km nw"/></div></div></a></div><p id="6c9c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">希望你喜欢它，我很高兴如果这篇文章对你有用！测试愉快！</p><p id="ac01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">谢谢大家！</p></div><div class="ab cl ol om hr on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="os np l"/></div></figure></div></div>    
</body>
</html>