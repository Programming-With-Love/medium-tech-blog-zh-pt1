<html>
<head>
<title>Bridging the Network Divide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弥合网络鸿沟</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/bridging-the-network-divide-80e2355051dc?source=collection_archive---------1-----------------------#2017-01-17">https://medium.com/walmartglobaltech/bridging-the-network-divide-80e2355051dc?source=collection_archive---------1-----------------------#2017-01-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8bd71b2391403d9e7a2407bf016eb1f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6tnfPiokTzSuP-1XlNKCg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Illustration by Dustan Kasten. Icons from Gravit.io</figcaption></figure><p id="2097" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您是否曾经想过，为什么我们在API和数据库层构建并支持丰富的类型和模型信息，而在跨越HTTP界限进入web和本地客户端时却将这些都抛弃了？我们在<a class="ae jr" href="http://www.walmartlabs.com/" rel="noopener ugc nofollow" target="_blank">沃尔玛实验室</a>的杂货团队对<a class="ae jr" href="http://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a> <a class="ae jr" href="https://netflix.github.io/falcor/" rel="noopener ugc nofollow" target="_blank">、Falcor </a>和类似工具带来的许多想法感兴趣。存在于客户机和服务器上的GraphQL类型系统和通过网络的Falcor透明模型访问都使得构建和维护产品的方法变得非常强大和容易。</p><p id="fe16" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">像大多数团队一样，除了减缓或阻止采用这些特定工具的其他约束之外，我们已经在生产中有过多的服务。尽管有了我们手中的工具，我们还是可以达到和实现这些其他抽象所提供的一些承诺。</p><p id="31cc" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="js">当我要写下我们的具体实现时，我希望你明白的是，你不应该利用你当前的环境或技术来阻止你今天做得更好。可能有一些方法可以创建更具表现力的抽象或工具，让您更安全、更稳定地放心开发和部署。</em></p><p id="06b5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">具体来说，我的团队有从API实现本身生成的文档。我们可以消费这些信息，并将其输入JavaScript代码生成工具，如<a class="ae jr" href="http://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>和<a class="ae jr" href="https://github.com/facebook/jscodeshift" rel="noopener ugc nofollow" target="_blank"> jscodeshift </a>来生成我们的客户端代码。有了用<a class="ae jr" href="http://flowtype.org/" rel="noopener ugc nofollow" target="_blank">流</a>类型注释的生成代码，我们很快就在UI和服务器模型之间建立了一座坚实的桥梁。</p><p id="70cb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">使用代码生成模型这样做的一个关键好处是，我们可以按需生成<code class="du jt ju jv jw b">git diff</code>来查看所有的API契约变更。流的静态分析可以随后引导我们通过任何突破性的变化。这让我们确信，我们的客户端代码以安全和正确的方式与API交互，并且在使用与API交互的方法时，为编辑器自动完成提供了方便的开发人员工具。</p><figure class="jy jz ka kb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jx"><img src="../Images/38aa892b8b5fbaafb29fde5e1f7b363d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLfVSsWsrdnjwhUCBKm5fw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Flow so smart</figcaption></figure><p id="da3a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">大多数现代服务器框架都有工具来丰富地描述、验证和共享领域模型。这通常以一种<a class="ae jr" href="https://en.wikipedia.org/wiki/Object-relational_mapping" rel="noopener ugc nofollow" target="_blank"> ORM </a>的形式出现，它从应用程序操作中抽象出数据库操作，同时提供丰富的API来与这些对象进行交互。</p><p id="bad2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Rails有ActiveRecord。<br/>哈比神有Joi验证。<br/> GraphQL有它的类型系统。</p><p id="3480" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这些抽象使得服务器工程师生成文档并将其公开给消费者(比如UI工程师！).</p><p id="96c0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">但是为什么就此止步呢？</strong>为什么为了网络部门的一些微薄的文档而放弃API <strong class="iv hi">合同</strong>的工具集成和安全性？</p><p id="d16a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">对于本文的其余部分，我想概述我们当前的解决方案，并以一些问题和后续步骤结束。我们的方法优先解决以下两个问题:</p><ul class=""><li id="6f60" class="kc kd hh iv b iw ix ja jb je ke ji kf jm kg jq kh ki kj kk bi translated">我们如何让API交互变得可预测和自动化？</li><li id="33ed" class="kc kd hh iv b iw kl ja km je kn ji ko jm kp jq kh ki kj kk bi translated">我们如何对API请求和响应契约启用UI代码的静态分析？</li></ul><p id="fa76" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们并不认为我们的解决方案是新颖的。解决类似问题的现有技术是:</p><ul class=""><li id="0ffa" class="kc kd hh iv b iw ix ja jb je ke ji kf jm kg jq kh ki kj kk bi translated">脸书<a class="ae jr" href="http://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a> / <a class="ae jr" href="https://facebook.github.io/relay/" rel="noopener ugc nofollow" target="_blank">继电器</a></li><li id="5094" class="kc kd hh iv b iw kl ja km je kn ji ko jm kp jq kh ki kj kk bi translated">谷歌的<a class="ae jr" href="https://developers.google.com/protocol-buffers/" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a></li><li id="c209" class="kc kd hh iv b iw kl ja km je kn ji ko jm kp jq kh ki kj kk bi translated">网飞的<a class="ae jr" href="https://netflix.github.io/falcor/" rel="noopener ugc nofollow" target="_blank">法鲁克</a></li></ul><p id="bf00" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">考虑到折衷，我们的解决方案介于自组织网络呼叫和上述解决方案之间。这些解决方案要求系统上的客户机和服务器之间有一个超越HTTP的协议。我们的解决方案允许我们利用现有的工具和基础设施，同时采用一种渐进的方式来实现更有见解和更强大的抽象。</p></div><div class="ab cl kq kr go ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ha hb hc hd he"><h1 id="4f54" class="kx ky hh bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">工具</h1><ul class=""><li id="7ffd" class="kc kd hh iv b iw lv ja lw je lx ji ly jm lz jq kh ki kj kk bi translated"><a class="ae jr" href="http://swagger.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="iv hi"> Swagger </strong> </a>从实现中生成丰富的文档。</li><li id="54fb" class="kc kd hh iv b iw kl ja km je kn ji ko jm kp jq kh ki kj kk bi translated"><a class="ae jr" href="https://github.com/facebook/jscodeshift" rel="noopener ugc nofollow" target="_blank"> <strong class="iv hi"> jscodeshift </strong> </a>将Swagger表示转换成JavaScript抽象语法树(AST)和源文件。</li></ul><p id="eae2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们将使用IBM沃森公开的狂妄定义。你可以在https://Watson-API-explorer . mybluemix . net/APIs/text-to-speech-v1看到它的HTML视图</p><p id="2585" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">秘密在于Swagger也生成了一个JSON视图。<a class="ae jr" href="https://watson-api-explorer.mybluemix.net/listings/text-to-speech-v1.json" rel="noopener ugc nofollow" target="_blank">https://Watson-API-explorer . mybluemix . net/listings/text-to-speech-v1 . JSON</a></p><p id="8f0c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">作为程序员，我们习惯于处理像对象和数组这样的数据结构，并转换它们。</p><p id="d406" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="js">…要是我们能把Swagger的JSON格式转换成JavaScript文件就好了… </em></p><p id="b3e8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我来给大家介绍一下JavaScript抽象语法树！唉，不要害怕。树木制造我们呼吸的氧气！</p></div><div class="ab cl kq kr go ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ha hb hc hd he"><h1 id="94e9" class="kx ky hh bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">对ASTs过于简单的介绍</h1><p id="2e6f" class="pw-post-body-paragraph it iu hh iv b iw lv iy iz ja lw jc jd je ma jg jh ji mb jk jl jm mc jo jp jq ha bi translated">一个典型的程序被编写并存储在一个称为字符串的数据结构中。字符串不是一种非常丰富的数据结构，所以大多数工具将字符串转换成一个丰富的层，称为抽象语法树AST。</p><p id="bf46" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">一个<a class="ae jr" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">树结构</a>只是节点的集合。在JavaScript中有一些节点，比如标识符、变量声明、函数表达式、every语句和语言的其他结构。作为一个简短的例子，你可以看看下面的hello world函数及其AST表示。</p><div class="md me ez fb mf mg"><a href="http://astexplorer.net/#/13NIfAERo1" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab dw"><div class="mi ab mj cl cj mk"><h2 class="bd hi fi z dy ml ea eb mm ed ef hg bi translated">AST浏览器</h2><div class="mn l"><h3 class="bd b fi z dy ml ea eb mm ed ef dx translated">在线AST浏览器。</h3></div><div class="mo l"><p class="bd b fp z dy ml ea eb mm ed ef dx translated">astexplorer.net</p></div></div></div></a></div><pre class="jy jz ka kb fd mp jw mq mr aw ms bi"><span id="a898" class="mt ky hh jw b fi mu mv l mw mx">function hello () {<br/> return “world!”;<br/>}</span></pre><p id="a5c3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">上述函数可以表示为以下AST结构:</p><pre class="jy jz ka kb fd mp jw mq mr aw ms bi"><span id="098d" class="mt ky hh jw b fi mu mv l mw mx">{<br/>  "type": "FunctionDeclaration",<br/>  "id": {<br/>    "type": "Identifier",<br/>    "name": "hello"<br/>  },<br/>  "params”: [],<br/>  "body": {<br/>    "type": "BlockStatement",<br/>    "body": [<br/>      {<br/>        "type": "ReturnStatement",<br/>        "argument": {<br/>          "type": "Literal",<br/>          "value": "world!",<br/>          "raw": "\"world!\""<br/>        }<br/>      }<br/>    ]<br/>  }<br/>}</span></pre></div><div class="ab cl kq kr go ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ha hb hc hd he"><h1 id="f0fd" class="kx ky hh bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">将碎片拼在一起</h1><p id="0f89" class="pw-post-body-paragraph it iu hh iv b iw lv iy iz ja lw jc jd je ma jg jh ji mb jk jl jm mc jo jp jq ha bi translated">我们已经看了一下Swagger JSON模型以及JS程序的源代码。现在编写一个程序，将Swagger模型转换为我们的JavaScript AST，并将其打印到一个文件中。</p><p id="689c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们从简单地生成文件的导出函数和签名开始。对于每个Swagger端点，我们希望生成一个类似如下的代码块:</p><pre class="jy jz ka kb fd mp jw mq mr aw ms bi"><span id="0cd6" class="mt ky hh jw b fi mu mv l mw mx">type CustomType = any;<br/>export function getV1Resource(<br/>  arg1 : string,<br/>  arg2 : string,<br/>  arg3 : CustomType<br/>) {}</span></pre><p id="7db0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">只需大约130行代码就可以生成完整的Swagger定义。这是130行注释代码，包括请求和解析JSON本身。</p><p id="8d01" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><a class="ae jr" href="https://gist.github.com/iamdustan/2e36a440b5702e14376bfba56d303427" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/iamdustan/2e 36 a 440 b 5702 e 14376 bfba 56d 303427</a></p><p id="8b4c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">通读一遍。一开始可能感觉有点陌生，但是很容易。保证！</p><p id="599c" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">它的核心就是这么小:</p><pre class="jy jz ka kb fd mp jw mq mr aw ms bi"><span id="cdde" class="mt ky hh jw b fi mu mv l mw mx">/**<br/> * Generate a JS AST from a Swagger entry.<br/> */<br/>const toFn = (path, method, obj) =&gt; Object.assign(<br/>  j.exportDeclaration(false, j.functionDeclaration(<br/>    j.identifier(genFnName(method, path)),<br/>    genArgs(obj.parameters),<br/>    j.blockStatement([])<br/> )),<br/> {comments: [j.commentBlock(formatDescription(obj.description))]}<br/>);</span></pre><p id="6146" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们是沃尔玛实验室<a class="ae jr" href="http://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的狂热用户，所以接下来我们将使导出函数声明的返回值成为一个简单的对象定义。</p><p id="23b5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们通过编写生成以下函数体的代码来结束本教程:</p><pre class="jy jz ka kb fd mp jw mq mr aw ms bi"><span id="2646" class="mt ky hh jw b fi mu mv l mw mx">return {<br/>  type: 'FETCH',<br/>  payload: {}<br/>};</span></pre><p id="d10a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是一个<code class="du jt ju jv jw b">ReturnStatement</code>，它的值是一个有两个键的<code class="du jt ju jv jw b">ObjectExpression</code>。</p><pre class="jy jz ka kb fd mp jw mq mr aw ms bi"><span id="843b" class="mt ky hh jw b fi mu mv l mw mx">const genBody = (path, method, obj) =&gt;<br/>  j.blockStatement([j.returnStatement(<br/>    j.objectExpression([<br/>      j.property(‘init’, j.identifier(‘type’), j.literal(‘FETCH’)),<br/>      j.property(‘init’, j.identifier(‘payload’), j.objectExpression([]))<br/>   ])<br/> )]);</span></pre></div><div class="ab cl kq kr go ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ha hb hc hd he"><h1 id="1f0e" class="kx ky hh bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">未来的挑战</strong></h1><p id="f1bf" class="pw-post-body-paragraph it iu hh iv b iw lv iy iz ja lw jc jd je ma jg jh ji mb jk jl jm mc jo jp jq ha bi translated">在这一点上，我们取得了一些重大胜利。对于API可能返回的每个模型，我们都有丰富的类型定义。我们可以在整个代码库中使用它们，每当它们改变时，Flow将告诉我们UI的哪些部分正在执行无效的属性查找，或者缺少API所需的输入参数。</p><p id="abef" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当我们想要与API交互时，我们不再需要离开我们的编辑器来查看API契约，而是可以直接从Flow中获取信息。</p><p id="f1f8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">唉，我们对返回值的类型定义有很大的损失。例如，如果可接受的输入是<code class="du jt ju jv jw b">{a: string} | {b: SomeEnum}</code>，那么当前生成的是完全不同的<code class="du jt ju jv jw b">{a: string, b: SomeEnum}</code>。我们目前正在手动修补这些案例。既然我们的API已经稳定下来，我们已经考虑放弃自动生成的类型，转而使用手动维护的定义。</p><p id="ee71" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">最后，我们正在考虑探索fetch中间件的参数化类型定义，目标是帮助Flow理解Redux reducers需要考虑的精确形状。</p><p id="0832" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在，如果我能找到一种方法，在JavaScript中实现Rust的详尽模式匹配<br/></p></div><div class="ab cl kq kr go ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ha hb hc hd he"><p id="0093" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="js">感谢</em> <a class="ae jr" href="https://twitter.com/fkling42" rel="noopener ugc nofollow" target="_blank"> <em class="js">菲利克斯克林</em> </a> <em class="js">和乔哈德森对本文的审阅和反馈。</em></p></div></div>    
</body>
</html>