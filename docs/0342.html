<html>
<head>
<title>#31DaysOfKotlin — Week 2 Recap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated"># 31日sOfKotlin —第2周回顾</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/31daysofkotlin-week-2-recap-9eedcd18ef8?source=collection_archive---------4-----------------------#2018-04-12">https://medium.com/androiddevelopers/31daysofkotlin-week-2-recap-9eedcd18ef8?source=collection_archive---------4-----------------------#2018-04-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/cacbece860b904efd2bbad58bc8e6fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wkSlarhHvNPOIVE7BIPfbg.png"/></div></div></figure><div class=""/><p id="97a5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们写的Kotlin代码越多，我们就越喜欢它！Kotlin的现代语言功能与<a class="ae jn" href="https://github.com/android/android-ktx" rel="noopener ugc nofollow" target="_blank"> Android KTX </a>一起，让我们的Android代码更加简洁、清晰和令人愉快。我们(<a class="ae jn" href="https://twitter.com/objcode" rel="noopener ugc nofollow" target="_blank"> @objcode </a>和<a class="ae jn" href="https://twitter.com/FMuntenescu" rel="noopener ugc nofollow" target="_blank"> @FMuntenescu </a>)开始了<a class="ae jn" href="https://twitter.com/search?q=%2331DaysOfKotlin" rel="noopener ugc nofollow" target="_blank"> #31DaysOfKotlin </a>系列，作为分享我们最喜欢的Kotlin和Android KTX功能的一种方式，并希望让更多的人像我们一样喜欢它。</p><p id="45b3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在第二篇文章中，我们继续探索kot Lin——更深入地探讨密封类和内联等主题。</p><p id="278a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">查看其他摘要:</p><div class="hg hh ez fb hi jo"><a rel="noopener follow" target="_blank" href="/google-developers/31daysofkotlin-week-1-recap-fbd5a622ef86"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd ht fi z dy jt ea eb ju ed ef hr bi translated"># 31日sOfKotlin —第1周回顾</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">我们写的Kotlin代码越多，我们就越喜欢它！Kotlin的现代语言功能与Android KTX一起使…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">medium.com</p></div></div><div class="jx l"><div class="jy l jz ka kb jx kc ho jo"/></div></div></a></div><div class="hg hh ez fb hi jo"><a rel="noopener follow" target="_blank" href="/google-developers/31daysofkotlin-week-3-recap-20b20ca9e205"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd ht fi z dy jt ea eb ju ed ef hr bi translated"># 31日sOfKotlin —第3周回顾</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">我们写的Kotlin代码越多，我们就越喜欢它！Kotlin的现代语言功能与Android KTX一起使…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">medium.com</p></div></div><div class="jx l"><div class="kd l jz ka kb jx kc ho jo"/></div></div></a></div><div class="hg hh ez fb hi jo"><a rel="noopener follow" target="_blank" href="/google-developers/31daysofkotlin-week-4-recap-d820089f8090"><div class="jp ab dw"><div class="jq ab jr cl cj js"><h2 class="bd ht fi z dy jt ea eb ju ed ef hr bi translated"># 31日sOfKotlin —第4周回顾</h2><div class="jv l"><h3 class="bd b fi z dy jt ea eb ju ed ef dx translated">我们写的Kotlin代码越多，我们就越喜欢它！Kotlin的现代语言功能与Android KTX一起使…</h3></div><div class="jw l"><p class="bd b fp z dy jt ea eb ju ed ef dx translated">medium.com</p></div></div><div class="jx l"><div class="ke l jz ka kb jx kc ho jo"/></div></div></a></div><h1 id="94ce" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第八天:能见度</h1><p id="4d80" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">在Kotlin中，默认情况下一切都是公开的！嗯，差不多了。Kotlin有一组丰富的可见性修饰符可供您使用:<code class="du li lj lk ll b">private</code>、<code class="du li lj lk ll b">protected</code>、<code class="du li lj lk ll b">internal</code>。它们中的每一种都以不同的方式降低了可见度。文档:<a class="ae jn" href="https://kotlinlang.org/docs/reference/visibility-modifiers.html" rel="noopener ugc nofollow" target="_blank">可见性修饰符</a></p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="688a" class="lu kg hs ll b fi lv lw l lx ly">// public by default<br/>val <em class="lz">isVisible </em>= true</span><span id="d7dd" class="lu kg hs ll b fi ma lw l lx ly">// only in the same file<br/>private val <em class="lz">isHidden </em>= true</span><span id="2621" class="lu kg hs ll b fi ma lw l lx ly">// internal to compilation ‘module’<br/>internal val <em class="lz">almostVisible </em>= true</span><span id="ba8c" class="lu kg hs ll b fi ma lw l lx ly">class Foo {<br/>  // public by default<br/>  val isVisible = true</span><span id="6730" class="lu kg hs ll b fi ma lw l lx ly">  // visible to my subclasses<br/>  protected val isInheritable = true</span><span id="af4b" class="lu kg hs ll b fi ma lw l lx ly">  // only in the same class<br/>  private val isHidden = true<br/>}</span></pre><h1 id="04bc" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第九天:默认参数</h1><p id="8e97" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">方法重载的数量是否失控？指定函数中的默认参数值。使用命名参数使代码更具可读性。文档:<a class="ae jn" href="https://kotlinlang.org/docs/reference/functions.html#default-arguments" rel="noopener ugc nofollow" target="_blank">默认参数</a></p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="b29d" class="lu kg hs ll b fi lv lw l lx ly">// parameters with default values<br/>class BulletPointSpan(<br/>  private val bulletRadius: Float = DEFAULT_BULLET_RADIUS,<br/>  private val gapWidth: Int = DEFAULT_GAP_WIDTH,<br/>  private val color: Int = Color.BLACK<br/>) {…}</span><span id="ec1e" class="lu kg hs ll b fi ma lw l lx ly">// using only default values<br/>val bulletPointSpan = BulletPointSpan()</span><span id="ef90" class="lu kg hs ll b fi ma lw l lx ly">// passing a value for the first argument, others default<br/>val bulletPointSpan2 = BulletPointSpan(<br/>    resources.getDimension(R.dimen.radius))</span><span id="f140" class="lu kg hs ll b fi ma lw l lx ly">// using a named parameter for the last argument, others default<br/>val bulletPointSpan3 = BulletPointSpan(color = Color.RED)</span></pre><h1 id="6480" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第10天:密封课程</h1><p id="14a9" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">Kotlin <code class="du li lj lk ll b">sealed</code>类让您轻松处理错误数据。当与<code class="du li lj lk ll b">LiveData</code>结合使用时，你可以用一个<code class="du li lj lk ll b">LiveData</code>来表示成功路径和错误路径。比使用两个变量要好得多。单据:<a class="ae jn" href="https://kotlinlang.org/docs/reference/sealed-classes.html" rel="noopener ugc nofollow" target="_blank">密封类</a></p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="c673" class="lu kg hs ll b fi lv lw l lx ly">sealed class NetworkResult<br/>data class Success(val result: String): NetworkResult()<br/>data class Failure(val error: Error): NetworkResult()</span><span id="8453" class="lu kg hs ll b fi ma lw l lx ly">// one observer for success and failure<br/>viewModel.data.observe(this, Observer&lt;NetworkResult&gt; { data -&gt;<br/>  data ?: return@Observer // skip nulls<br/>  when(data) {<br/>    is Success -&gt; showResult(data.result) // smart cast to Success<br/>    is Failure -&gt; showError(data.error) // smart cast to Failure<br/>  }<br/>})</span></pre><p id="b4c5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您也可以在<code class="du li lj lk ll b">RecyclerView</code>适配器中使用密封类。它们非常适合<code class="du li lj lk ll b">ViewHolders</code>——有一组干净的类型可以显式地分派给每个持有者。用作表达式时，如果所有类型都不匹配，编译器将出错。</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="25f8" class="lu kg hs ll b fi lv lw l lx ly">// use Sealed classes as ViewHolders in a RecyclerViewAdapter<br/>override fun onBindViewHolder(<br/>  holder: SealedAdapterViewHolder?, position: Int) {<br/>  when (holder) { // compiler enforces handling all types<br/>    is HeaderHolder -&gt; {<br/>      holder.displayHeader(items[position]) // smart cast here<br/>    }<br/>    is DetailsHolder -&gt; {<br/>      holder.displayDetails(items[position]) // smart cast here<br/>    }<br/>  }<br/>}</span></pre><p id="4961" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于<code class="du li lj lk ll b">RecyclerViews</code>更进一步，如果我们有很多来自<code class="du li lj lk ll b">RecyclerView</code>项目的回调，比如这个详细的点击、分享和删除动作，我们可以使用密封类。一个回调带一个密封类就可以处理所有的事情！</p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="cf24" class="lu kg hs ll b fi lv lw l lx ly">sealed class DetailItemClickEvent<br/>data class DetailBodyClick(val section: Int): DetailItemClickEvent()<br/>data class ShareClick(val platform: String): DetailItemClickEvent()<br/>data class DeleteClick(val confirmed: Boolean):<br/>     DetailItemClickEvent()</span><span id="a285" class="lu kg hs ll b fi ma lw l lx ly">class MyHandler : DetailItemClickInterface {<br/>  override fun onDetailClicked(item: DetailItemClickEvent) {<br/>    when (item) { // compiler enforces handling all types<br/>      is DetailBodyClick -&gt; expandBody(item.section)<br/>      is ShareClick -&gt; shareOn(item.platform)<br/>      is DeleteClick -&gt; {<br/>        if (item.confirmed) doDelete() else confirmDetele()<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h1 id="9e3a" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第11天:懒惰</h1><p id="525e" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">偷懒就好！通过使用<code class="du li lj lk ll b">lazy</code>，将昂贵的属性初始化成本推迟到真正需要的时候。计算出的值随后被保存并用于任何将来的调用。Docs: <a class="ae jn" href="https://kotlinlang.org/docs/reference/delegated-properties.html#lazy" rel="noopener ugc nofollow" target="_blank">懒</a></p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="13c5" class="lu kg hs ll b fi lv lw l lx ly">val preference: String by lazy {<br/>  sharedPreferences.getString(PREFERENCE_KEY) <br/>}</span></pre><h1 id="fa6e" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第12天:迟到</h1><p id="b67c" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">在Android中，<code class="du li lj lk ll b">onCreate</code>或者其他回调初始化对象。在Kotlin中，非空val必须初始化。怎么办？输入<code class="du li lj lk ll b">lateinit</code>。一言为定:以后初始化我！用它发誓它最终会是零安全的。文档:<a class="ae jn" href="https://kotlinlang.org/docs/reference/properties.html#late-initialized-properties-and-variables" rel="noopener ugc nofollow" target="_blank"> lateinit </a></p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="9eb0" class="lu kg hs ll b fi lv lw l lx ly">class MyActivity : AppCompatActivity() {<br/>  // non-null, but not initalized<br/>  lateinit var recyclerView: RecyclerView<br/><br/>  override fun onCreate(savedInstanceState: Bundle?) {<br/>    // …</span><span id="1b04" class="lu kg hs ll b fi ma lw l lx ly">    // initialized here<br/>    recyclerView = findViewById(R.id.recycler_view)<br/>  }<br/>}</span></pre><h1 id="16c8" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第13天:要求和检查</h1><p id="2dd0" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">你的函数参数有效吗？使用前检查，用<code class="du li lj lk ll b">require</code>。如果它们无效，就会抛出一个<code class="du li lj lk ll b">IllegalArgumentException</code>。单据:<a class="ae jn" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html" rel="noopener ugc nofollow" target="_blank">需要</a></p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="b136" class="lu kg hs ll b fi lv lw l lx ly">fun setName(name: String) {<br/>  // calling setName(“”) throws IllegalArgumentException<br/>  require(name.isNotEmpty()) { “Invalid name” }<br/>  <br/>  // …<br/>}</span></pre><p id="b7a4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你的封闭类的状态正确吗？使用<code class="du li lj lk ll b">check</code>进行验证。如果检查的值是<code class="du li lj lk ll b">false</code>，它将抛出一个<code class="du li lj lk ll b">IllegalStateException</code>。文件:<a class="ae jn" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check.html" rel="noopener ugc nofollow" target="_blank">检查</a></p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="c3bd" class="lu kg hs ll b fi lv lw l lx ly">fun User.logOut(){<br/>  // When not authenticated, throws IllegalStateException<br/>  check(isAuthenticated()) { “User $email is not authenticated” }<br/>  isAuthenticated = false<br/>}</span></pre><h1 id="fc73" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">第14天:内嵌</h1><p id="39d7" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">迫不及待想用lambdas做新的API？排队吧。Kotlin允许您将函数指定为<code class="du li lj lk ll b">inline</code>——这意味着调用将被函数体所取代。呼吸，零开销地制作基于lambda的API。文档:<a class="ae jn" href="https://kotlinlang.org/docs/reference/inline-functions.html" rel="noopener ugc nofollow" target="_blank">内嵌函数</a></p><pre class="lm ln lo lp fd lq ll lr ls aw lt bi"><span id="8375" class="lu kg hs ll b fi lv lw l lx ly">// define an inline function that takes a function argument</span><span id="f009" class="lu kg hs ll b fi ma lw l lx ly">inline fun onlyIf(check: Boolean, operation: () -&gt; Unit) {<br/>  if (check) {<br/>    operation()<br/>  }<br/>}</span><span id="55b6" class="lu kg hs ll b fi ma lw l lx ly">// call it like this<br/>onlyIf(shouldPrint) { // call: pass operation as a lambda<br/>  println(“Hello, Kotlin”)<br/>}</span><span id="f577" class="lu kg hs ll b fi ma lw l lx ly">// which will be inlined to this<br/>if (shouldPrint) { // execution: no need to create lambda<br/>  println(“Hello, Kotlin”)<br/>}</span></pre><p id="b263" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本周深入探讨了Kotlin的特性:可见性、默认参数、密封类、lazy、lateinit、require和check，以及真正强大的内联。下周我们将深入更多的Kotlin特性，并开始探索Android KTX。</p><p id="bad0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你已经开始使用科特林了吗？我们很想知道你还喜欢哪些功能，以及你是如何在你的Android应用中使用这些功能的。</p></div></div>    
</body>
</html>