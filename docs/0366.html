<html>
<head>
<title>Kotlin Demystified: The power of `when`</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林揭秘:“何时”的力量</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/kotlin-demystified-the-power-of-when-f0ac616ddd1a?source=collection_archive---------1-----------------------#2018-09-26">https://medium.com/androiddevelopers/kotlin-demystified-the-power-of-when-f0ac616ddd1a?source=collection_archive---------1-----------------------#2018-09-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b104253ca3c590a016acc6d999573585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i01n_giwRQlYqRwu_Pyxaw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">NES image by <a class="ae it" href="http://www.visionriders.com/" rel="noopener ugc nofollow" target="_blank">Dale M.A. Johnson</a></figcaption></figure><p id="3d32" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我要坦白一件事。我有点像游戏玩家。塞尔达传说游戏是特别受欢迎的。想象一下当我得知有“随机程序”时我的兴奋，这些程序会在游戏中打乱物品、地牢入口、地图布局和角色统计，这样即使是有经验的玩家也会有新鲜的体验。一些我绝对喜欢的游戏的随机化器，包括最初的<a class="ae it" href="https://github.com/tetraly/zelda-randomizer" rel="noopener ugc nofollow" target="_blank"> <em class="js">塞尔达传说</em> </a> <em class="js"> </em>和<em class="js">林克的冒险</em>。由于我们中的许多人不再有原来的硬件，我们转向模拟器。</p><p id="e49f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通常，模拟器实现起来会非常复杂。但事实证明，在任何现代计算机上模拟像NES这样的系统并不特别具有挑战性。从本质上来说，NES仿真器是一个非常简单的循环，它寻找下一条指令并执行它。</p><h1 id="18f9" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">基础</h1><p id="ccdb" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">我们可以写一个包含所有指令的巨大的if-else-if列表，但是这很难维护。相反，我们用<code class="du kw kx ky kz b"><a class="ae it" href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression" rel="noopener ugc nofollow" target="_blank">when</a></code>。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="bdec" class="li ju hh kz b fi lj lk l ll lm">val instruction = fetchNextInstruction()<br/>when (instruction) {<br/>    0x0 -&gt; handleBreak()<br/>    0x8 -&gt; handlePushProcessorStatus()<br/>    0x10 -&gt; handleBranchOnPlus()<br/>    // Many other instructions...<br/>    else -&gt; throw IllegalStateException("Unknown instruction: ${instruction.toHex()}")<br/>}<br/>inline fun Int.toHex() = this.toString(16)</span></pre><p id="daaf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这个实现中，<code class="du kw kx ky kz b">when</code>与C++或Java中的<code class="du kw kx ky kz b">switch</code>语句几乎相同。</p><p id="8e22" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">只有<em class="js">与</em>几乎相同的原因是，正如来自C++或Java的人会注意到的，没有任何<code class="du kw kx ky kz b">break</code>语句。属于<code class="du kw kx ky kz b">when</code> <em class="js">的语句不会失败。</em></p><p id="49cc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这仅仅是触及表面。</p><h1 id="c911" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">作为一种表达</h1><p id="6a88" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">NES的游戏卡带有许多不同的种类，尽管它们大多使用相同的连接器。他们有不同类型和数量的ROM和RAM，包括有电池的RAM来保存游戏。一些盒式磁带甚至在盒式磁带本身上包括额外的硬件。处理这种情况的墨盒上的电路被称为“<a class="ae it" href="https://wiki.nesdev.com/w/index.php/Mapper" rel="noopener ugc nofollow" target="_blank">映射器</a>”。</p><p id="fd88" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">基于在Kotlin中<code class="du kw kx ky kz b">when</code>像<code class="du kw kx ky kz b">switch</code>一样被使用的认识，像这样的代码是决定哪个映射器用于特定游戏的一种方式:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="7fff" class="li ju hh kz b fi lj lk l ll lm">fun getCartridgeMapper(rom: Cartridge): Mapper {<br/>    var mapper: Mapper? = null<br/>    when (rom.mapperId) {<br/>        1 -&gt; mapper = MMC1(rom)<br/>        3 -&gt; mapper = CNROM(rom)<br/>        4 -&gt; mapper = MMC3(rom)<br/>        // Etc…<br/>    }<br/>    return mapper ?: throw NotImplementedError("Mapper for ${rom.mapperId} not yet implemented")<br/>}</span></pre><p id="f2b4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个还可以，但是不理想。<a class="ae it" href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression" rel="noopener ugc nofollow" target="_blank">引用文档</a>将<code class="du kw kx ky kz b">when</code>描述为一个表达式，意思是它可以有一个值(就像Kotlin中的<code class="du kw kx ky kz b">if</code>)。考虑到这一点，上面的函数可以简化:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="9ef8" class="li ju hh kz b fi lj lk l ll lm">fun getCartridgeMapper(rom: Cartridge): Mapper = when (rom.mapperId) {<br/>    1 -&gt; MMC1(rom)<br/>    3 -&gt; CNROM(rom)<br/>    4 -&gt; MMC3(rom)<br/>    // Etc...<br/>    else -&gt; throw NotImplementedError("Mapper for ${rom.mapperId} not yet implemented")<br/>}</span></pre><p id="278b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就去掉了临时变量，并将该函数的块体转换为表达式体，从而将焦点保持在代码的重要部分。</p><h1 id="a5a3" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">超越简单的<code class="du kw kx ky kz b">case</code>语句</h1><p id="f8e4" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated"><code class="du kw kx ky kz b">switch</code>的另一个限制是值仅限于常量表达式。相反，<code class="du kw kx ky kz b">when</code>允许使用各种各样的表达式，比如范围检查。例如，仿真器需要根据仿真硬件的哪一位保存数据来区别对待要读取的内存地址。完成这项工作的代码存在于我们的映射器中。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="e23c" class="li ju hh kz b fi lj lk l ll lm">val data = when (addressToRead) {<br/>    in 0..0x1fff -&gt; {<br/>        // With this mapper, the graphics for the game can be in one of two locations.<br/>        // We can figure out which one to look in based on the memory address.<br/>        val bank = addressToRead / 0x1000<br/>        val bankAddress = addressToRead % 0x1000<br/>        readBank(bank, bankAddress)<br/>    }<br/>    in 0x6000..0x7fff -&gt; {<br/>        // There's 8k of program (PRG) RAM in the cartridge mapped here.<br/>        readPrgRam(addressToRead - 0x6000)<br/>    }<br/>    // etc...<br/>}</span></pre><p id="14ba" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您也可以使用<code class="du kw kx ky kz b">is</code>操作符来检查<code class="du kw kx ky kz b">when</code>的参数类型。这在使用密封类时尤其有用:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="a1ca" class="li ju hh kz b fi lj lk l ll lm">sealed class Interrupt<br/>class NonMaskableInterrupt : Interrupt()<br/>class ResetInterrupt : Interrupt()<br/>class BreakInterrupt : Interrupt()<br/>class InterruptRequestInterrupt(val number: Int) : Interrupt()</span></pre><p id="0c07" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后…</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="ac4e" class="li ju hh kz b fi lj lk l ll lm">interrupt?.let {<br/>    val handled = when (interrupt) {<br/>        is NonMaskableInterrupt -&gt; handleNMI()<br/>        is ResetInterrupt -&gt; handleReset()<br/>        is BreakInterrupt -&gt; handleBreak()<br/>        is InterruptRequestInterrupt -&gt; handleIRQ(interrupt.number)<br/>    }<br/>}</span></pre><p id="237d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意，这里不需要<code class="du kw kx ky kz b">else</code>。这是因为<code class="du kw kx ky kz b">Interrupt</code>是一个密封类，编译器知道<code class="du kw kx ky kz b">interrupt</code>所有可能的类型。如果我们错过了一个类型，或者后来添加了一个新的中断类型，编译器将失败，并显示一个错误，指示<code class="du kw kx ky kz b">when</code>必须是穷举的，或者必须添加一个<code class="du kw kx ky kz b">else</code>分支。</p><p id="e58d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du kw kx ky kz b">when</code>也可以不带参数使用。在这种情况下，它就像一个if-then-else表达式，其中每种情况都作为一个布尔表达式进行计算。从上到下读取，执行评估为<code class="du kw kx ky kz b">true</code>的第一个案例。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="07d5" class="li ju hh kz b fi lj lk l ll lm">when {<br/>    address &lt; 0x2000 -&gt; writeBank(address, value)<br/>    address &gt;= 0x6000 &amp;&amp; address &lt; 0x8000 -&gt; writeSRam(address, value)<br/>    address &gt;= 0x8000 -&gt; writeRegister(address, value)<br/>    else -&gt; throw RuntimeException("Unhandled write to address ${address.toHex()}")<br/>}</span></pre><h1 id="d1c1" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">还有一点</h1><p id="0389" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">以前，为了在<code class="du kw kx ky kz b">when</code>表达式中使用函数的返回，唯一的方法是这样的:</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="9615" class="li ju hh kz b fi lj lk l ll lm">getMapper().let { mapper -&gt;<br/>    when (mapper) {<br/>        is MMC5 -&gt; mapper.audioTick()<br/>        is Mapper49 -&gt; mapper.processQuirks()<br/>        // Etc... <br/>    }<br/>}</span></pre><p id="99b8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从<a class="ae it" href="https://blog.jetbrains.com/kotlin/2018/07/see-whats-coming-in-kotlin-1-3-m1/" rel="noopener ugc nofollow" target="_blank"> Kotlin 1.3M1 </a>开始，可以通过在<code class="du kw kx ky kz b">when</code>表达式的参数中创建一个变量来优化这段代码。</p><pre class="la lb lc ld fd le kz lf lg aw lh bi"><span id="bacf" class="li ju hh kz b fi lj lk l ll lm">when (val mapper = getMapper()) {<br/>    is MMC5 -&gt; mapper.audioTick()<br/>    is Mapper49 -&gt; mapper.processQuirks()<br/>    // Etc... <br/>}</span></pre><p id="d9ca" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">类似于使用<code class="du kw kx ky kz b">let</code>的例子，<code class="du kw kx ky kz b">mapper</code>的作用域是<code class="du kw kx ky kz b">when</code>表达式本身。</p><h1 id="37d1" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="e2da" class="pw-post-body-paragraph iu iv hh iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr ha bi translated">我们已经看到<code class="du kw kx ky kz b">when</code>的工作方式类似于C++和Java中的<code class="du kw kx ky kz b">switch</code>,并且它可以以许多强大的方式使用，例如充当表达式，包括<code class="du kw kx ky kz b">Comparable</code>类型的范围，以及简化长的if-then-else块。</p><p id="acd4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你有兴趣了解更多关于NES仿真(和Kotlin)的信息，请查看Felipe Lima在GitHub 上的<a class="ae it" href="https://github.com/felipecsl/ktnes" rel="noopener ugc nofollow" target="_blank"> KTNES项目。</a></p><p id="2b74" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请务必关注<a class="ae it" href="https://medium.com/androiddevelopers" rel="noopener"> Android Developers </a>出版物，了解更多精彩内容，并关注更多关于Kotlin的文章！</p></div></div>    
</body>
</html>