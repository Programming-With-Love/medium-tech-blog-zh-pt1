<html>
<head>
<title>Multiple Entities in a Single NgRx 8 State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单个NgRx 8状态中的多个实体</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/multiple-entities-in-a-single-ngrx-8-state-ed5fd082c3f0?source=collection_archive---------2-----------------------#2019-10-09">https://medium.com/capital-one-tech/multiple-entities-in-a-single-ngrx-8-state-ed5fd082c3f0?source=collection_archive---------2-----------------------#2019-10-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="c7c3" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">如何管理具有复杂数据的复杂状态</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/df4b77da3719d1322330ea72fbd9cd5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgVdcnPKmCgjnQWWbsoo5Q.png"/></div></div></figure><p id="83e5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae ke" href="https://ngrx.io/guide/entity" rel="noopener ugc nofollow" target="_blank">实体</a>是<a class="ae ke" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a>的一个有用的附加组件。它们通过以规范化状态存储数据来帮助管理大量数据，并提供添加、更新和删除数据对象的有用功能。</p><p id="bfb3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">随着应用程序变得越来越复杂，您可能会意识到需要将多个实体对象存储在一个状态中。在最近的一个项目中，我发现自己正处于这样的情况:我正在构建一个加载了图表和其他数据可视化元素的web应用程序。这些元素是相关的，但不是简单的一对一或一对多的关系。我发现对数据使用单一的EntityAdapter会导致复杂和过度工程化的action reducers。</p><p id="a92b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我对这个混乱的reducer的解决方案是将实体对象分解成多个实体。然而，我想保留我创建的状态，迫使我在一个状态中容纳两个<a class="ae ke" href="https://ngrx.io/guide/entity/adapter" rel="noopener ugc nofollow" target="_blank"> EntityAdapters </a>。</p><p id="d22d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我将通过一个使用两个对象的简化示例向您展示我是如何做到这一点的:书籍和作者。让我们从定义我们的实体开始:<code class="du kf kg kh ki b">book.entity.ts</code>和<code class="du kf kg kh ki b">author.entity.ts</code>。</p><p id="de4e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> book.entity.ts </strong></p><pre class="ix iy iz ja fd kj ki kk kl aw km bi"><span id="4399" class="kn ko hh ki b fi kp kq l kr ks">export <strong class="ki hi">function</strong> selectBookId(b: Book): number {<br/>  return b.id;<br/>}</span><span id="8c1b" class="kn ko hh ki b fi kt kq l kr ks">export <strong class="ki hi">function</strong> sortByBookTitle(a: Book, b: Book): number {<br/>  return a.title.localeCompare(b.title);<br/>}</span><span id="41d5" class="kn ko hh ki b fi kt kq l kr ks">export <strong class="ki hi">const</strong> bookAdapter: EntityAdapter&lt;Book&gt; = createEntityAdapter&lt;Book&gt;({<br/>  selectId: selectBookId,<br/>  sortComparer: sortByBookTitle<br/>});</span><span id="e867" class="kn ko hh ki b fi kt kq l kr ks">export <strong class="ki hi">interface</strong> BookState <strong class="ki hi">extends</strong> EntityState&lt;App&gt; {}</span></pre><p id="3113" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> author.entity.ts </strong></p><pre class="ix iy iz ja fd kj ki kk kl aw km bi"><span id="f4e7" class="kn ko hh ki b fi kp kq l kr ks">export <strong class="ki hi">function</strong> selectAuthorId(a: Author): number {<br/>  return a.id;<br/>}</span><span id="26fc" class="kn ko hh ki b fi kt kq l kr ks">export <strong class="ki hi">function</strong> sortByAuthorLastName(a: Author, b: Author): number {<br/>  return a.lastName.localeCompare(b.lastName);<br/>}</span><span id="dc93" class="kn ko hh ki b fi kt kq l kr ks">export <strong class="ki hi">const</strong> authorAdapter: EntityAdapter&lt;Author&gt; =   createEntityAdapter&lt;Author&gt;({<br/>  selectId: selectAuthorId,<br/>  sortComparer: sortByAuthorLastName<br/>});</span><span id="5786" class="kn ko hh ki b fi kt kq l kr ks">export <strong class="ki hi">interface</strong> AuthorState <strong class="ki hi">extends</strong> EntityState&lt;Author&gt; {}</span></pre><p id="5475" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">正如您在上面看到的，我有两个相关的实体，但不能存储在单个数据对象中，主要是因为书籍和作者之间的多对多关系，书籍可以由多个作者编写，每个作者可以写多本书。</p><p id="64cd" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">通常，我们会将函数和EntityAdapter合并到reducer文件中。然而，由于有多个适配器，我认为最好将它们分离到各自的文件中，这样reducer文件就不会变得过于混乱。</p><p id="5227" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">既然我们已经定义了实体，我们应该看看我们的状态:</p><p id="bc0f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> library.reducer.ts </strong></p><pre class="ix iy iz ja fd kj ki kk kl aw km bi"><span id="439a" class="kn ko hh ki b fi kp kq l kr ks">export <strong class="ki hi">interface</strong> LibraryState {<br/>  books: BookState;<br/>  authors: AuthorState;<br/>  selectedCategory: string;<br/>}</span><span id="a41c" class="kn ko hh ki b fi kt kq l kr ks">export <strong class="ki hi">const</strong> initialState: LibraryState = {<br/>  books: bookAdapter.getInitialState(),<br/>  authors: authorAdapter.getInitialState(),<br/>  selectedCategory: ‘NON-FICTION’,<br/>};</span></pre><p id="dd70" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">状态很简单。它包含图书实体、作者实体和一个选定类别的字段。神奇的事情发生在状态初始化中；我们从两个<code class="du kf kg kh ki b">*.entity.ts</code>文件中导入适配器，这样当状态被初始化时，两个实体都用它创建。</p><p id="4812" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">最后要记住的是，<a class="ae ke" href="https://ngrx.io/guide/entity/adapter#adapter-collection-methods" rel="noopener ugc nofollow" target="_blank">实体助手函数</a> (addMany()、update()、upsert()等。)中的<a class="ae ke" href="https://ngrx.io/guide/store/reducers" rel="noopener ugc nofollow" target="_blank">减速器</a>也需要修改。下面是一个StoreAuthors操作的示例，它将Authors的有效负载添加到状态中。</p><p id="4885" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> library.reducer.ts </strong></p><pre class="ix iy iz ja fd kj ki kk kl aw km bi"><span id="4a0f" class="kn ko hh ki b fi kp kq l kr ks">…<br/>on(LibraryActions.storeAuthors, (state, { authors }) <strong class="ki hi">=&gt;</strong> (<br/>  {<br/>    …state,<br/>    authors: authorAdapter.addMany(authors, state.authors)<br/>  }<br/>)),<br/>…</span></pre><p id="9285" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">reducer将LibraryState从Author实体中分离出来，这就是为什么我们使用<a class="ae ke" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> spread操作符</a>来存储状态，并独立修改<code class="du kf kg kh ki b">authors </code>。此外，所有适配器的第二个函数参数是状态。这里我们不传入LibraryState对象；相反，我们传递的是独占作者实体的状态片段。</p><p id="5c81" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">通过将实体分开，我们完成了几件事情。首先，我们将一个潜在的复杂实体分解成两个相关但独立的实体。其次，我们通过解开实体来简化父状态。最后，我们简化了reducer函数，减少了不必要的状态更新。</p><p id="6e6c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这就是将多个NgRx实体合并到一个州的全部内容！希望这篇教程对你的工作有所帮助！</p></div><div class="ab cl ku kv go kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ha hb hc hd he"><p id="c4d6" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lb">披露声明:2019资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>