<html>
<head>
<title>Robot Pattern Testing for XCUITest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">XCUITest的机器人模式测试</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/robot-pattern-testing-for-xcuitest-4c2f0c40b4ad?source=collection_archive---------0-----------------------#2018-11-08">https://medium.com/capital-one-tech/robot-pattern-testing-for-xcuitest-4c2f0c40b4ad?source=collection_archive---------0-----------------------#2018-11-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="6ef0" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">在iOS上使用机器人模式</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/d272fc241179bf19914383fced0fbcbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42lJDUOtj1tShWIMqw2VrQ.jpeg"/></div></div></figure><p id="b278" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我最近在<a class="ae ke" href="https://www.iosdevuk.com/" rel="noopener ugc nofollow" target="_blank"> iOSDevUK </a>上做了<a class="ae ke" href="https://rwapp.co.uk/2018/09/08/iOSDevUK-18/" rel="noopener ugc nofollow" target="_blank">发言，概述了我们如何在Capital One测试我们的旗舰iOS应用。我被问到的最常见的后续问题是关于使用<strong class="jk hi">机器人图案</strong>。<em class="kf"> </em>我在</a><a class="ae ke" href="https://rwapp.co.uk/A-Swift-Testing-Journey.IOSDevUK.September2018.pdf" rel="noopener ugc nofollow" target="_blank">幻灯片中简单地提到了机器人模式</a>，但显然这是其他人有兴趣了解更多的东西</p><p id="a39e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae ke" href="https://jakewharton.com/testing-robots/" rel="noopener ugc nofollow" target="_blank">机器人模型</a>由<a class="ae ke" href="https://twitter.com/JakeWharton" rel="noopener ugc nofollow" target="_blank">杰克·沃顿</a>在广场设计，用于在科特林测试。因此，许多可用的信息都集中在科特林和浓缩咖啡测试上。在iOS online上使用机器人模式的相对较少。然而，Capital One英国移动团队决定使用机器人模式，因为这意味着我们的Android和iOS测试方法一致。下面是它在iOS应用程序中的工作原理。</p><h2 id="a128" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated"><strong class="ak">为什么使用机器人模式</strong></h2><p id="dce2" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">在编写XCUI测试时使用Robot模式有三大原因。</p><ol class=""><li id="b939" class="lg lh hh jk b jl jm jo jp jr li jv lj jz lk kd ll lm ln lo bi translated"><strong class="jk hi">易于理解</strong> <br/>我们从葫芦来到XCUITests，在那里我们的测试用<a class="ae ke" href="https://docs.cucumber.io/" rel="noopener ugc nofollow" target="_blank">黄瓜</a>编写。黄瓜接近自然语言。这意味着我们可以快速轻松地阅读和理解正在测试的内容，而不需要知道测试是如何进行的。用本地代码编写测试，并且已经有了一个学习曲线来知道什么正在被测试，什么没有被测试。</li><li id="51c6" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt kd ll lm ln lo bi translated">通过将我们的测试分解成步骤，每个实现步骤都可以根据需要重复使用。如果你的应用程序在执行任何操作之前有一个登录界面，那么每次测试都需要大量的设置。相反，您可以每次只调用login()，然后转移到您的测试的更具体的区域。如果您确实需要做一些稍微不同的事情，您可以将参数传递到函数中。</li><li id="9d4d" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt kd ll lm ln lo bi translated"><strong class="jk hi">隔离实现细节</strong> <br/>无论你的应用使用什么架构，你的目标都是单一责任原则。坚持这一点允许您用新的实现将一个对象换成一个新的对象，同时仍然保持对象的核心功能。这使得代码更容易维护、测试和改进。那么为什么你的测试应该是不同的呢？杰克·沃顿将此描述为将“什么”与“如何”分开。你的测试应该只关注“什么”,也就是说，如果你的观点改变了屏幕上事情出现或发生的方式，你不需要改变你的整个测试套件。</li></ol><h2 id="4e1c" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated"><strong class="ak">编写一个XCUITest </strong></h2><p id="6e84" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">假设我们正在为苹果内置的Messages应用程序编写UI测试。如果你从暂停状态加载应用程序，你会在屏幕顶部看到一个大标题“消息”和一个创建新消息的按钮。让我们假设我们正在测试点击这个按钮，并用iMessage向用户发送一条新消息。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lu"><img src="../Images/8296f9bd01f25915439fdecda6948366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTwdmoThFlFMf73dG48wzQ.png"/></div></div></figure><p id="3a9a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们的XCUITest可能如下所示:</p><pre class="ix iy iz ja fd lv lw lx ly aw lz bi"><span id="737b" class="kg kh hh lw b fi ma mb l mc md">func test_sendNewiMessage() {<br/>   let app = XCUIApplication()<br/>   app.launch()<br/> <br/>   app.buttons[“new_message”].tap()<br/> <br/>   let newMessage = app.staticTexts[“New Message”]<br/>   let predicate = NSPredicate(format: “exists == true”)<br/>   let expectation = XCTNSPredicateExpectation(predicate: predicate, object: newMessage)<br/>   let result = XCTWaiter.wait(for: [expectation], timeout: 5)<br/>   XCTAssertEqual(result, .completed)<br/> <br/>   app.typeText(“iMessage Contact”)<br/> <br/>   let newimessage = app.staticTexts[“New iMessage”]<br/>   let newimessagePredicate = NSPredicate(format: “exists == true”)<br/>   let newiMessageExpectation = XCTNSPredicateExpectation(predicate: newimessagePredicate, object: newimessage)<br/>   let newiMessageResult = XCTWaiter.wait(for:   [newiMessageExpectation], timeout: 5)<br/>   XCTAssertEqual(newiMessageResult, .completed)<br/> <br/>   let firstField = app.textFields[“messageField”]<br/> <br/>   firstField.typeText(“test iMessage”)<br/>   app.buttons[“send”].tap()<br/> <br/>   let message = app.staticTexts[“test iMessage”]<br/>   let messagePredicate = NSPredicate(format: “exists == true”)<br/>   let messageExpectation = XCTNSPredicateExpectation(predicate: messagePredicate, object: message)<br/>   let messageResult = XCTWaiter.wait(for: [messageExpectation], timeout: 5)<br/>   XCTAssertEqual(messageResult, .completed)<br/>}</span></pre><p id="66a5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">很明显，这个测试有几个问题——有很多重复的代码，很难跟踪正在测试的内容。但是，如果我们还想测试向SMS联系人发送新消息，该怎么办呢？我们必须重复整个测试。然后，如果我们对UI进行真正的更改，我们必须更改两个测试。</p><h2 id="a338" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated"><strong class="ak">创造机器人</strong></h2><p id="8952" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">在测试过程中，我们将访问两个屏幕。</p><ul class=""><li id="32f4" class="lg lh hh jk b jl jm jo jp jr li jv lj jz lk kd me lm ln lo bi translated">最初的对话列表，有一个大标题“消息”。</li><li id="b405" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt kd me lm ln lo bi translated">点击新消息按钮后出现的对话详细信息屏幕。</li></ul><p id="4315" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们将创建一个基本的机器人类，包含一些常见的功能，如断言元素存在和在屏幕上点击。每个屏幕都有自己的机器人类来扩展机器人。这些特定于屏幕的机器人包含特定于该屏幕的动作，因此我们的对话列表将包含一个创建新消息的高级功能。我们的对话细节有更多关于这个测试的内容，因为这是我们要花大部分时间的地方。</p><pre class="ix iy iz ja fd lv lw lx ly aw lz bi"><span id="3f98" class="kg kh hh lw b fi ma mb l mc md">import XCTest</span><span id="3dbb" class="kg kh hh lw b fi mf mb l mc md">class Robot {<br/>         var app = XCUIApplication()<br/> <br/>         func tap(_ element: XCUIElement, timeout: TimeInterval = 5) {<br/>                  let expectation = XCTNSPredicateExpectation(predicate: NSPredicate(format: “isHittable == true”), object: element)<br/>                  guard XCTWaiter.wait(for: [expectation], timeout: timeout) == .completed else {<br/>                          XCTAssert(false, “Element \(element.label) not hittable”)<br/>                  }<br/>         }<br/> <br/>         func assertExists(_ elements: XCUIElement…, timeout: TimeInterval = 5) {<br/>                  let expectation = XCTNSPredicateExpectation(predicate: NSPredicate(format: “exists == true”), object: elements)<br/>                  guard XCTWaiter.wait(for: [expectation], timeout: timeout) == .completed else {<br/>                           XCTAssert(false, “Element does not exist”)<br/>                   }<br/>         }<br/>}</span><span id="bd0e" class="kg kh hh lw b fi mf mb l mc md">class ConversationListRobot: Robot {<br/> <br/>         lazy private var newConversationButton = app.buttons[“new_message”]<br/> <br/>         func newConversation() -&gt; ConversationDetailRobot {<br/>         tap(newConversationButton)<br/>         }<br/>}</span><span id="7b63" class="kg kh hh lw b fi mf mb l mc md">class ConversationDetailRobot: Robot {<br/> <br/>         private var messageType = “Message”<br/>         lazy private var screenTitle = app.staticTexts[“New \(messageType)”]<br/>        lazy private var contactField = app.textFields[“contact”]<br/>        lazy private var cancel = app.buttons[“Cancel”]<br/>        lazy private var messageField =     app.textFields[“messageField”]<br/>        lazy private var sendButton = app.buttons[“send”]<br/> <br/>        func checkScreen(messageType: String) -&gt; Self {<br/>                 self.messageType = messageType<br/>                 assertExists(screenTitle, contactField, cancel, message   Field, sendButton)<br/>                 return self<br/>        }<br/> <br/>        func enterContact(contact: String) -&gt; Self {<br/>                 tap(contactField)<br/>                 contactField.typeText(contact)<br/>                 return self<br/>        }<br/> <br/>        func enterMessage(message: String) -&gt; Self {<br/>                 tap(messageField)<br/>                 messageField.typeText(message)<br/>                 return self<br/>        }<br/> <br/>        func sendMessage() -&gt; Self {<br/>                 tap(sendButton)<br/>                 return self<br/>        }<br/> <br/>        @discardableResult<br/>        func checkConversationContains(message: String) -&gt; Self {<br/>                 let messageBubble = app.staticTexts[message]<br/>                 assertExists(messageBubble)<br/>                 return self<br/>        }<br/>}</span></pre><p id="ca5a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这样，我们就可以将这些函数链接起来创建测试，所以上面的例子变成了:</p><pre class="ix iy iz ja fd lv lw lx ly aw lz bi"><span id="5ea8" class="kg kh hh lw b fi ma mb l mc md">func test_sendNewiMessage() {<br/> <br/>  let message = “test message”<br/> <br/>   XCUIApplication().launch()<br/> <br/>   ConversationListRobot()<br/>   .newConversation()<br/>   .checkConversationContains(message: “Message”)<br/>   .enterContact(contact: “iMessage Contact”)<br/>   .checkScreen(messageType: “iMessage”)<br/>   .enterMessage(message: message)<br/>   .sendMessage()<br/>   .checkConversationContains(message: message)<br/>}</span></pre><p id="970b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">立即，这是更容易阅读和理解一目了然，而不必知道应用程序如何工作或如何编写Swift。</p><h2 id="14b3" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated"><strong class="ak">积木</strong></h2><p id="ca7b" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">根据我们想要测试的内容，这些高级功能可以在不同的配置中链接在一起。假设我们想尝试同样的方式，但使用短信联系。我们做了一个新的测试，将我们的联系人改为“SMS联系人”，在我们的第二个checkScreen()上，我们的消息类型将是“消息”。</p><p id="b3b8" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">使用这种技术，我们可以很容易地从我们创建的构件中构建几个测试:</p><ul class=""><li id="6384" class="lg lh hh jk b jl jm jo jp jr li jv lj jz lk kd me lm ln lo bi translated">无效的联系人。</li><li id="5335" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt kd me lm ln lo bi translated">返回消息列表。</li><li id="88da" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt kd me lm ln lo bi translated">试图发送空白邮件。</li><li id="dba5" class="lg lh hh jk b jl lp jo lq jr lr jv ls jz lt kd me lm ln lo bi translated">发送媒体</li></ul><p id="8f69" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">都使用这些基本函数，传递不同的值，或者以不同的顺序传递值，或者在需要的地方添加新的值。如果用来发送消息的按钮改变了，我们只需要在sendMessage()的实现中改变它，而不是在每个测试中。</p><h2 id="0169" class="kg kh hh bd ki kj kk kl km kn ko kp kq jr kr ks kt jv ku kv kw jz kx ky kz la bi translated">结论</h2><p id="fbbc" class="pw-post-body-paragraph ji jj hh jk b jl lb ii jn jo lc il jq jr ld jt ju jv le jx jy jz lf kb kc kd ha bi translated">我强烈推荐您熟悉XCUITesting，这是一种非常简单的方法来测试您的应用程序呈现给用户的内容是否是您所期望的。据我所知，它没有被充分利用。机器人模式被证明是一种干净、简单的技术，为我们的团队解决了许多问题。这真的值得考虑它是否会为你做同样的事情。</p><p id="21ac" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">虽然很少有关于在Swift和iOS上使用机器人模式的文档，<a class="ae ke" href="https://twitter.com/faruktoptas" rel="noopener ugc nofollow" target="_blank">Faruk topta</a>在<a class="ae ke" rel="noopener" href="/android-bits/espresso-robot-pattern-in-kotlin-fc820ce250f7">的文章</a>中提供了一些示例Android Kotlin代码，机器人模式的设计师Jake Wharton就其设计背后的决策进行了精彩的<a class="ae ke" href="https://academy.realm.io/posts/kau-jake-wharton-testing-robots/" rel="noopener ugc nofollow" target="_blank">介绍性发言</a>。</p></div><div class="ab cl mg mh go mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ha hb hc hd he"><p id="4447" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="kf">声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2018首都一。</em></p></div></div>    
</body>
</html>