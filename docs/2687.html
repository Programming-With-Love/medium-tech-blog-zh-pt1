<html>
<head>
<title>Selenium WebDriver — TestNG and For Test Case Management And Report Generation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">selenium web driver——TestNG，用于测试用例管理和报告生成</h1>
<blockquote>原文：<a href="https://medium.com/edureka/selenium-webdriver-tutorial-e3e6219f21ad?source=collection_archive---------2-----------------------#2017-05-05">https://medium.com/edureka/selenium-webdriver-tutorial-e3e6219f21ad?source=collection_archive---------2-----------------------#2017-05-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/1461b49eabbb8070813a90802412b8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*extLPc_wrtp8jE6vtLs9aw.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">Selenium WebDriver — Edureka</figcaption></figure><p id="e9eb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我将介绍高级Selenium WebDriver概念。我已经多次提到Selenium WebDriver在测试用例管理和测试报告生成方面有局限性。那么，还有什么选择呢？像Selenium这样受欢迎的工具肯定有变通方法，对吗？当然有！我们可以使用Selenium和TestNG的组合来克服这个限制，这将是本文讨论的主题。</p><p id="db53" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">来自世界各地的软件开发人员会一致同意，在测试用例中编写代码节省了他们调试时间的很大一部分。为什么？这是因为测试用例有助于创建健壮且无错误的代码。它是怎么做到的？通过将整个代码分成更小的测试用例，然后评估每个测试用例的通过/失败条件，我们可以创建无错误的代码。因为Selenium不支持在测试用例中执行代码，所以我们必须使用TestNG来实现同样的功能。这就是TestNG适合Selenium框架的地方。</p><p id="5e15" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> TestNG </strong>代表<em class="jn">测试下一代</em>，它是一个开源的测试自动化框架，灵感来自JUnit和NUnit。不仅仅是灵感，而是对这两个框架的升级。所以你可能会问这里的升级是什么？TestNG的升级在于，它在代码中提供了额外的功能，如测试注释、分组、优先级、参数化和排序技术，这在早期是不可能的。</p><p id="d2d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">除了管理测试用例，通过使用TestNG甚至可以获得测试的详细报告。将会有一个概要，显示失败的测试用例，以及它所属的组和类。当bug可以像这样被准确定位时，它们可以被立即修复，让开发人员松了一口气。下图描述了TestNG的工作方式。</p><figure class="jp jq jr js fd ii er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es jo"><img src="../Images/1875fd10360998849701734f9a87ad4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e0tdPQBapeXEm-cJT50NZg.png"/></div></div></figure><p id="7644" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么，TestNG是如何完成工作的呢？这个问题将在这篇Selenium WebDriver教程文章的下一节中回答，在那里我将讨论如何使用TestNG管理各种测试用例。</p><h1 id="7e49" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">带TestNG的Selenium WebDriver</h1><p id="b5de" class="pw-post-body-paragraph ip iq hh ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">测试用例可以通过以下方式之一来定义和管理:</p><ol class=""><li id="8dab" class="la lb hh ir b is it iw ix ja lc je ld ji le jm lf lg lh li bi translated">测试注释</li><li id="08de" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">优化</li><li id="189b" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">禁用测试用例</li><li id="f385" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">方法依赖性</li><li id="8819" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">分组</li><li id="e198" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">断言</li><li id="2e23" class="la lb hh ir b is lj iw lk ja ll je lm ji ln jm lf lg lh li bi translated">报表生成</li></ol><p id="858a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我开始解释这些功能。</p><h2 id="9676" class="lo jy hh bd jz lp lq lr kd ls lt lu kh ja lv lw kl je lx ly kp ji lz ma kt mb bi translated">测试注释</h2><p id="3f7e" class="pw-post-body-paragraph ip iq hh ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">首先，让我们问自己这个问题:为什么我们需要使用注释？我们什么时候可以使用它们？Selenium中的注释用于控制下一个要执行的方法。测试注释是在测试代码中的每个方法之前定义的。如果任何方法没有以注释为前缀，那么该方法将被忽略，并且不会作为测试代码的一部分执行。为了定义它们，方法需要简单地用“<strong class="ir hi"> @Test </strong>”进行注释。例如，请看下面的代码片段。</p><pre class="jp jq jr js fd mc md me mf aw mg bi"><span id="2592" class="lo jy hh md b fi mh mi l mj mk">package testng;<br/> <br/>import org.openqa.selenium.WebDriver;<br/>import org.openqa.selenium.firefox.FirefoxDriver;<br/>import org.testng.annotations.AfterClass;<br/>import org.testng.annotations.AfterMethod;<br/>import org.testng.annotations.BeforeClass;<br/>import org.testng.annotations.BeforeMethod;<br/>import org.testng.annotations.Test;<br/> <br/>public class TestAnnotations {<br/> <a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/> public void myTestMethod() {<br/> System.out.println("Inside method:- myTestMethod");<br/> WebDriver driver = new FirefoxDriver();<br/> driver.get("<a class="ae ml" href="http://www.seleniumframework.com/Practiceform/" rel="noopener ugc nofollow" target="_blank">http://www.seleniumframework.com/Practiceform/</a>");<br/> String title = driver.getTitle();<br/> System.out.println(title);<br/> driver.quit();<br/> }<br/>  <br/> <a class="ae ml" href="http://twitter.com/BeforeMethod" rel="noopener ugc nofollow" target="_blank">@BeforeMethod</a><br/> public void beforeMethod() {<br/> System.out.println("This piece of code is executed before method:- myTestMethod");<br/> System.setProperty("webdriver.gecko.driver", "C:\\Users\\Vardhan\\workspace\\SeleniumProject\\files\\geckodriver.exe");<br/> }<br/> <br/> <a class="ae ml" href="http://twitter.com/AfterMethod" rel="noopener ugc nofollow" target="_blank">@AfterMethod</a><br/> public void afterMethod() {<br/> System.out.println("This piece of code is executed after method:- myTestMethod");<br/> }<br/> <br/> <a class="ae ml" href="http://twitter.com/BeforeClass" rel="noopener ugc nofollow" target="_blank">@BeforeClass</a><br/> public void beforeClass() {<br/> System.out.println("This piece of code is executed before the class is executed");<br/> }<br/> <br/> <a class="ae ml" href="http://twitter.com/AfterClass" rel="noopener ugc nofollow" target="_blank">@AfterClass</a><br/> public void afterClass() {<br/> System.out.println("This piece of code is executed after the class is executed");<br/> }<br/>}</span></pre><p id="fde3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的代码中，你会注意到我没有定义一个“main”方法。然而，我定义了5个其他方法。它们是“myTestMethod”、“beforeMethod”、“afterMethod”、“beforeClass”和“afterClass”。此外，请注意代码中方法定义的顺序，因为它们不会以相同的顺序执行。</p><p id="d2ec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">方法“myTestMethod”用<strong class="ir hi"> @Test </strong>注释，它是必须执行的主要方法或代码段。其他带注释的方法将在该方法执行前后执行。由于' beforeMethod '是用<strong class="ir hi"> @BeforeMethod </strong>注释的，所以会在' myTestMethod '执行之前执行。同样，“afterMethod”用<strong class="ir hi"> @AfterMethod </strong>注释，因此它将在“myTestMethod”之后执行。</p><p id="3610" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是，“beforeClass”被注释为<strong class="ir hi"> @BeforeClass </strong>，这意味着它甚至会在类本身被执行之前被执行。我们这里的类名是<strong class="ir hi"> TestAnnotations </strong>，因此在类开始执行之前，将执行“beforeClass”中的代码段。类似地，“afterClass”用<strong class="ir hi"> @AfterMethod </strong>注释，因此将在类<strong class="ir hi"> TestAnnotations </strong>执行后执行。</p><p id="d7e2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您仍然对执行的顺序感到困惑，那么下面的代码片段一定会帮助您。</p><pre class="jp jq jr js fd mc md me mf aw mg bi"><span id="264a" class="lo jy hh md b fi mh mi l mj mk">1. BeforeSuite<br/>2. BeforeTest<br/>3. BeforeClass<br/>4. BeforeMethod<br/>5. Test<br/>6. AfterMethod<br/>7. AfterClass<br/>8. AfterTest<br/>9. AfterSuite</span></pre><p id="89f9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上述代码的输出将是:</p><pre class="jp jq jr js fd mc md me mf aw mg bi"><span id="2e29" class="lo jy hh md b fi mh mi l mj mk">This piece of code is executed before the class is executed<br/>This piece of code is executed before method:- myTestMethod<br/>Inside method:- myTestMethod<br/>1493192682118 geckodriver INFO Listening on 127.0.0.1:13676<br/>1493192682713 mozprofile::profile INFO Using profile path C:\Users\Vardhan\AppData\Local\Temp\rust_mozprofile.wGkcwvwXkl2y<br/>1493192682729 geckodriver::marionette INFO Starting browser C:\Program Files (x86)\Mozilla Firefox\firefox.exe<br/>1493192682729 geckodriver::marionette INFO Connecting to Marionette on localhost:59792<br/>[GPU 6152] WARNING: pipe error: 109: file c:/builds/moz2_slave/m-rel-w32-00000000000000000000/build/src/ipc/chromium/src/chrome/common/ipc_channel_win.cc, line 346<br/>1493192688316 Marionette INFO Listening on port 59792<br/>Apr 26, 2017 1:14:49 PM org.openqa.selenium.remote.ProtocolHandshake createSession<br/>INFO: Detected dialect: W3C<br/>JavaScript error: <a class="ae ml" href="http://t.dtscout.com/i/?l=http%3A%2F%2Fwww.seleniumframework.com%2FPracticeform%2F&amp;j=" rel="noopener ugc nofollow" target="_blank">http://t.dtscout.com/i/?l=http%3A%2F%2Fwww.seleniumframework.com%2FPracticeform%2F&amp;j=</a>, line 1: TypeError: document.getElementsByTagName(...)[0] is undefined<br/>Selenium Framework | Practiceform<br/>1493192695134 Marionette INFO New connections will no longer be accepted<br/>Apr 26, 2017 1:14:57 PM org.openqa.selenium.os.UnixProcess destroy<br/>SEVERE: Unable to kill process with PID 6724<br/>This piece of code is executed after method:- myTestMethod<br/>This piece of code is executed after the class is executed<br/>PASSED: myTestMethod</span><span id="4097" class="lo jy hh md b fi mm mi l mj mk">===============================================<br/> Default test<br/> Tests run: 1, Failures: 0, Skips: 0<br/>===============================================</span><span id="7d3d" class="lo jy hh md b fi mm mi l mj mk">===============================================<br/>Default suite<br/>Total tests run: 1, Failures: 0, Skips: 0<br/>===============================================</span></pre><p id="f490" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从上面的输出可以看出，测试运行的次数是1，失败的次数是0。这意味着代码是成功的。甚至方法的执行顺序也会按照我前面提到的顺序。</p><p id="925b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您在机器上执行这段代码时，Selenium WebDriver将实例化您的Firefox浏览器，导航到Selenium Framework的练习表单，关闭浏览器实例，并在您的Eclipse IDE中显示与上面所示相同的输出。</p><p id="e423" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在代码中只使用了5种不同的注释。但是还有更多的注释可以用来控制下一个要执行的方法。下表解释了注释的完整列表:</p><blockquote class="mn mo mp"><p id="ccdf" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated"><strong class="ir hi"> @BeforeSuite </strong> —用<em class="hh"> @BeforeSuite </em>标注的方法将在套件中的所有测试运行之前运行。</p><p id="0c11" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated"><strong class="ir hi"> @AfterSuite </strong> —用<em class="hh"> @AfterSuite </em>标注的方法将在套件中的所有测试运行完毕后运行。</p><p id="ac68" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated"><strong class="ir hi"> @BeforeTest </strong> —用<em class="hh"> @BeforeTest </em>标注的方法将在属于某个类的任何测试方法运行之前运行。</p><p id="6a43" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated"><strong class="ir hi"> @AfterTest </strong> —注释有<em class="hh"> @AfterTest </em>的方法将在属于一个类的所有测试方法都运行后运行。</p><p id="5c2e" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated"><strong class="ir hi"> @BeforeGroup </strong> —注释有<em class="hh"> @BeforeGroup </em>的方法将在每个组运行之前运行。</p><p id="8db7" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated"><strong class="ir hi"> @AfterGroup </strong> —注释有<em class="hh"> @AfterGroup </em>的方法将在每组运行后运行。</p><p id="1bb4" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated"><strong class="ir hi"> @BeforeClass </strong> —用<em class="hh"> @BeforeClass </em>标注的方法将在调用当前类中的第一个测试方法之前运行一次。</p><p id="a08e" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated"><strong class="ir hi"> @AfterClass </strong> —用<em class="hh"> @AfterClass </em>标注的方法将在当前类中的所有测试方法运行后运行一次。</p><p id="0d53" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated"><strong class="ir hi"> @BeforeMethod </strong> —用<em class="hh"> @BeforeMethod </em>标注的方法将在类内的任何测试方法运行之前运行。</p><p id="46f7" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated"><strong class="ir hi"> @AfterMethod </strong> —用<em class="hh"> @AfterMethod </em>标注的方法将在类内的每个测试方法运行后运行。</p><p id="4069" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated"><strong class="ir hi"> @Test </strong> —注有<em class="hh"> @Test </em>的方法是整个程序中的主要测试方法。其他带注释的方法将围绕这个方法执行。</p></blockquote><p id="b980" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">TestNG报告的屏幕截图如下所示</p><figure class="jp jq jr js fd ii er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es mt"><img src="../Images/e445a5e4683553a95da70de26c87d542.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4SPrMjtvajVg7ldOLv7JQ.png"/></div></div></figure><h2 id="6a20" class="lo jy hh bd jz lp lq lr kd ls lt lu kh ja lv lw kl je lx ly kp ji lz ma kt mb bi translated">优化</h2><p id="a8b1" class="pw-post-body-paragraph ip iq hh ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">我们谈到了如何定义不同的方法，以便围绕<em class="jn"> @Test </em>方法执行这些方法。但是，如果您有不止一个<strong class="ir hi"> @Test </strong>方法，并且想要定义它们之间的执行顺序，该怎么办呢？</p><p id="823f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种情况下，我们可以通过给带注释的测试用例分配一个数字来区分它们的优先级。数字越小，优先级越高。在定义测试用例时，优先级可以被指定为参数。但是，如果没有指定优先级，那么带注释的测试方法将按照测试的字母顺序执行。看看下面这段代码中测试注释的参数。</p><pre class="jp jq jr js fd mc md me mf aw mg bi"><span id="2f5b" class="lo jy hh md b fi mh mi l mj mk"><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a>(Priority=2)<br/>public static void FirstTest()<br/>{<br/>system.out.println("This is the Test Case number Two because of Priority #2");<br/>}<br/> <br/><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a>(Priority=1)<br/>public static void SecondTest()<br/>{<br/>system.out.println("This is the Test Case number One because of Priority #1");<br/>}<br/> <br/><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/>public static void FinalTest()<br/>{<br/>system.out.println("This is the Final Test Case because there is no Priority");<br/>}</span></pre><h2 id="01ec" class="lo jy hh bd jz lp lq lr kd ls lt lu kh ja lv lw kl je lx ly kp ji lz ma kt mb bi translated">禁用测试用例</h2><p id="4bb5" class="pw-post-body-paragraph ip iq hh ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">让我给你看一些更有趣的东西。如果您有一个跨越百万行的代码，由数百个测试用例组成，而您只想禁用一个测试方法，该怎么办？您不需要删除代码的任何部分，相反，我们可以简单地禁用该测试方法。</p><p id="9d59" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">禁用测试用例的行为也是通过参数来完成的。我们可以将<em class="jn"> enabled </em>属性设置为‘false’。默认情况下，所有的测试用例都将被启用，因此我们不需要在每次编写测试时都定义它们。看看下面这段代码中第三和第四个方法的参数。</p><pre class="jp jq jr js fd mc md me mf aw mg bi"><span id="1fa3" class="lo jy hh md b fi mh mi l mj mk"><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a>(Priority=2, enabled = True)<br/>public static void FirstTest()<br/>{<br/>system.out.println("This is the Test Case number Two because of Priority #2");<br/>}<br/> <br/><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a>(Priority=1, enabled = True)<br/>public static void SecondTest()<br/>{<br/>system.out.println("This is the Test Case number One because of Priority #1");<br/>}<br/> <br/><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a>(enabled = false)<br/>public static void SkippedTest()<br/>{<br/>system.out.println("This is the Skipped Test Case because this has been disabled");<br/>}<br/> <br/><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a>(enabled = True)<br/>public static void FinalTest()<br/>{<br/>system.out.println("This is the Final Test Case, which is enabled and has no Priority");<br/>}</span></pre><h2 id="e6b5" class="lo jy hh bd jz lp lq lr kd ls lt lu kh ja lv lw kl je lx ly kp ji lz ma kt mb bi translated">方法依赖性</h2><p id="ca8f" class="pw-post-body-paragraph ip iq hh ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">现在，如果您有这样一种情况，您希望一段代码仅在满足某个条件或某个特定方法成功执行时才执行，那么我们可以通过使用<em class="jn"> dependsOnMethod()来实现这一点。</em>这基本上是一个方法依赖的条件，其中一个方法将依赖于另一个方法来执行。如果我们另外将<em class="jn"> alwaysRun </em>属性设置为true，那么无论依赖方法的失败/通过条件如何，该方法都将被执行。查看下面代码片段中的代码。</p><pre class="jp jq jr js fd mc md me mf aw mg bi"><span id="434d" class="lo jy hh md b fi mh mi l mj mk"><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/>public static void FirstTest()<br/>{<br/>system.out.println("This is the first Test Case to be executed");<br/>}<br/> <br/><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a>(dependsOnMethods = { "FirstTest" })<br/>public static void SecondTest()<br/>{<br/>system.out.println("This is the second Test Case to be executed; This is a Dependent method");<br/>}<br/> <br/><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a>(dependsOnMethods = { "SecondTest" })<br/>public static void FinalTest()<br/>{<br/>system.out.println("This is the Final Test Case; It will be executed anyway.");<br/>}</span></pre><p id="498c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，这将我们带到测试注释的另一个重要方面，那就是<em class="jn">分组</em>。</p><h2 id="5e81" class="lo jy hh bd jz lp lq lr kd ls lt lu kh ja lv lw kl je lx ly kp ji lz ma kt mb bi translated">分组</h2><p id="1159" class="pw-post-body-paragraph ip iq hh ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">到现在为止，您一定知道在代码中将有许多方法作为我们测试用例的一部分。假设有100个测试用例，但是我们希望在下一个测试中只执行20个测试用例。你认为我们能做到吗？我们当然可以。</p><p id="b621" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为此，我们可以使用<em class="jn">组</em>属性。我们可以为一些测试用例分配一个组名，然后选择执行这个组，而不是整个代码。查看下面的代码片段，了解如何创建组。</p><pre class="jp jq jr js fd mc md me mf aw mg bi"><span id="b91b" class="lo jy hh md b fi mh mi l mj mk"><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a>(groups = { "MyGroup" })<br/>public static void FirstTest()<br/>{<br/>system.out.println("This is a part of the Group: MyGroup");<br/>}<br/> <br/><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a>(groups = { "MyGroup" })<br/>public static void SecondTest()<br/>{<br/>system.out.println("This is also a part of the Group: MyGroup");<br/>}<br/> <br/><a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/>public static void ThirdTest()<br/>{<br/>system.out.println("But, this is not a part of the Group: MyGroup");<br/>}</span></pre><h2 id="bba4" class="lo jy hh bd jz lp lq lr kd ls lt lu kh ja lv lw kl je lx ly kp ji lz ma kt mb bi translated">测试断言</h2><p id="3df7" class="pw-post-body-paragraph ip iq hh ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">这就把我们带到了TestNG的下一个主题，即断言。顾名思义，断言可以在测试方法中用来确定测试的通过/失败条件。基于陈述的真/假条件，测试将通过/失败。</p><p id="0a8d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下面的代码中，我包含了3个测试方法，其中第一个和第三个方法有一个通过条件，第二个方法有一个失败条件。自己看代码。</p><pre class="jp jq jr js fd mc md me mf aw mg bi"><span id="5e26" class="lo jy hh md b fi mh mi l mj mk">package testng;<br/> <br/>import org.testng.annotations.Test;<br/>import org.testng.annotations.BeforeMethod;<br/>import org.openqa.selenium.WebDriver;<br/>import org.openqa.selenium.firefox.FirefoxDriver;<br/>import org.testng.Assert;<br/>import org.testng.annotations.AfterMethod;<br/> <br/>public class Assertions {<br/> <a class="ae ml" href="http://twitter.com/BeforeMethod" rel="noopener ugc nofollow" target="_blank">@BeforeMethod</a><br/> public void beforeMethod() {<br/> System.setProperty("webdriver.gecko.driver",<br/> "C:\\Users\\Vardhan\\workspace\\SeleniumProject\\files\\geckodriver.exe");<br/> }<br/>  <br/> public boolean isEqual(int a, int b) {<br/> if (a == b) {<br/> return true;<br/> } else {<br/> return false;<br/> }<br/> }<br/>  <br/> <a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/> public void testEquality1() {<br/> Assert.assertEquals(true, isEqual(10, 10));<br/> System.out.println("This is a pass condition");<br/> }<br/> <br/> <a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/> public void testEquality2() {<br/> Assert.assertEquals(true, isEqual(10, 11));<br/> System.out.println("This is a fail condition");<br/> }<br/> <br/> <a class="ae ml" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/> public void getTitle() {<br/> WebDriver driver = new FirefoxDriver();<br/> driver.get("<a class="ae ml" href="https://www.gmail.com" rel="noopener ugc nofollow" target="_blank">https://www.gmail.com</a>");<br/> String title = driver.getTitle();<br/> Assert.assertEquals(title, "Gmail");<br/> System.out.println("This is again a pass condition");<br/> }<br/>}</span></pre><p id="31b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您查看执行后生成的报告时，您会注意到在三个测试中，一个失败，两个通过。另一个需要注意的要点是，当断言失败时，该测试中的其他命令/代码行将被跳过。只有当断言成功时，才会在该测试中执行下一行代码。查看下面的输出，其中<em class="jn"> system.out.println </em>只执行了第一个和第三个方法。</p><pre class="jp jq jr js fd mc md me mf aw mg bi"><span id="957d" class="lo jy hh md b fi mh mi l mj mk">1493277977348 geckodriver INFO Listening on 127.0.0.1:47035<br/>1493277977993 mozprofile::profile INFO Using profile path C:\Users\Vardhan\AppData\Local\Temp\rust_mozprofile.Z7X9uFdKODvi<br/>1493277977994 geckodriver::marionette INFO Starting browser C:\Program Files (x86)\Mozilla Firefox\firefox.exe<br/>1493277977998 geckodriver::marionette INFO Connecting to Marionette on localhost:50758<br/>[GPU 6920] WARNING: pipe error: 109: file c:/builds/moz2_slave/m-rel-w32-00000000000000000000/build/src/ipc/chromium/src/chrome/common/ipc_channel_win.cc, line 346<br/>1493277981742 Marionette INFO Listening on port 50758<br/>Apr 27, 2017 12:56:22 PM org.openqa.selenium.remote.ProtocolHandshake createSession<br/>INFO: Detected dialect: W3C<br/>This is again a pass condition<br/>This is a pass condition<br/>PASSED: getTitle<br/>PASSED: testEquality1<br/>FAILED: testEquality2<br/>java.lang.AssertionError: expected [false] but found [true]<br/> at org.testng.Assert.fail(Assert.java:93)<br/> at org.testng.Assert.failNotEquals(Assert.java:512)<br/> at org.testng.Assert.assertEqualsImpl(Assert.java:134)<br/> at org.testng.Assert.assertEquals(Assert.java:115)<br/> at org.testng.Assert.assertEquals(Assert.java:304)<br/> at org.testng.Assert.assertEquals(Assert.java:314)<br/> at testng.Assertions.testEquality2(Assertions.java:38)<br/> at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br/> at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)<br/> at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)<br/> at java.lang.reflect.Method.invoke(Unknown Source)<br/> at org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:108)<br/> at org.testng.internal.Invoker.invokeMethod(Invoker.java:661)<br/> at org.testng.internal.Invoker.invokeTestMethod(Invoker.java:869)<br/> at org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1193)<br/> at org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:126)<br/> at org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:109)<br/> at org.testng.TestRunner.privateRun(TestRunner.java:744)<br/> at org.testng.TestRunner.run(TestRunner.java:602)<br/> at org.testng.SuiteRunner.runTest(SuiteRunner.java:380)<br/> at org.testng.SuiteRunner.runSequentially(SuiteRunner.java:375)<br/> at org.testng.SuiteRunner.privateRun(SuiteRunner.java:340)<br/> at org.testng.SuiteRunner.run(SuiteRunner.java:289)<br/> at org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:52)<br/> at org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:86)<br/> at org.testng.TestNG.runSuitesSequentially(TestNG.java:1301)<br/> at org.testng.TestNG.runSuitesLocally(TestNG.java:1226)<br/> at org.testng.TestNG.runSuites(TestNG.java:1144)<br/> at org.testng.TestNG.run(TestNG.java:1115)<br/> at org.testng.remote.AbstractRemoteTestNG.run(AbstractRemoteTestNG.java:132)<br/> at org.testng.remote.RemoteTestNG.initAndRun(RemoteTestNG.java:230)<br/> at org.testng.remote.RemoteTestNG.main(RemoteTestNG.java:76)</span><span id="fdd7" class="lo jy hh md b fi mm mi l mj mk">===============================================<br/> Default test<br/> Tests run: 3, Failures: 1, Skips: 0<br/>===============================================</span><span id="6f45" class="lo jy hh md b fi mm mi l mj mk">===============================================<br/>Default suite<br/>Total tests run: 3, Failures: 1, Skips: 0<br/>===============================================</span></pre><p id="4184" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以，这就是与测试用例管理相关的概念的结尾。我们还有一个话题，那就是报告生成。报告生成是本Selenium WebDriver教程的最后一个主题，因为只有在执行了所有测试之后才能生成报告。</p><h2 id="3b83" class="lo jy hh bd jz lp lq lr kd ls lt lu kh ja lv lw kl je lx ly kp ji lz ma kt mb bi translated">报表生成</h2><p id="237d" class="pw-post-body-paragraph ip iq hh ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">您需要注意的最重要的一点是，报告只能通过. xml文件生成。这意味着，无论是一个方法，还是一个类，或者是一个组，都必须在。xml文件。</p><p id="0340" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，您可以在项目下创建一个新文件夹，并在该文件夹中创建一个新文件，为该文件命名，然后用。xml扩展。您可以通过右键单击package explorer来创建新的文件夹和文件。创建文件后，转到窗口底部的source选项卡，输入下面代码片段中指定的配置。</p><pre class="jp jq jr js fd mc md me mf aw mg bi"><span id="4e65" class="lo jy hh md b fi mh mi l mj mk">&lt;!DOCTYPE suite SYSTEM "<a class="ae ml" href="http://testng.org/testng-1.0.dtd" rel="noopener ugc nofollow" target="_blank">http://testng.org/testng-1.0.dtd</a>" &gt;<br/>&lt;suite name="TestNGs"&gt;<br/> &lt;test name="Test Annotations"&gt;<br/>  &lt;classes&gt;<br/>   &lt;class name="testng.TestAnnotations"&gt;<br/>   &lt;/class&gt;<br/>  &lt;/classes&gt;<br/> &lt;/test&gt;<br/>&lt;/suite&gt;</span></pre><p id="e916" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一行是XML文档类型定义。这是所有测试报告的标准和强制性要求。但是，其他行非常简单明了。我已经为suite、test、classes和class使用了open标记。Classes标记中可以有一个或多个类。因此，如果我们想要生成一个测试多个类的报告，就可以使用它。这对想要测试一段长代码的开发人员来说尤其方便。</p><p id="ac73" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">无论如何，回到我们的报告，你可以在打开这些标签后命名每个套件或测试或类，并记住关闭你打开的每个标签。我将我的套件名命名为<em class="jn"> TestNGs </em>，测试名命名为<em class="jn"> Test </em> <em class="jn"> Annotations </em>，类名命名为<em class="jn">TestNG . Test Annotations</em>注意类名的格式是<strong class="ir hi">'<em class="jn">package name . class name '</em></strong>。</p><p id="8b94" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您将这个文件作为TestNG suite运行时，将开始执行，您将获得详细的测试报告。您将在控制台选项卡中获得测试输出，在下一个选项卡中获得测试套件的结果。我为执行我的代码生成的报告在下面的屏幕截图中。您会注意到，这一次，有一个套件名、测试名、类名以及执行它们所花费的时间。</p><figure class="jp jq jr js fd ii er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es mu"><img src="../Images/c5841a0c15d4c35771689012dda09f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_b_J-nLk9gnaQBPGLBxtaQ.png"/></div></div></figure><p id="1e50" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您想要查看HTML报告(索引报告或电子邮件报告)，您可以转到工作区中项目目录内的<em class="jn">测试输出</em>文件夹。通过点击它们，您甚至可以在以后的某个时间点查看报告。下面是他们的截图。</p><p id="8bb1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">指标报告</strong> :-</p><figure class="jp jq jr js fd ii er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es mv"><img src="../Images/4e52f132ebc8e241ce6cd2c52e52285c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-3SADjnmXvg4lL9HhbRog.png"/></div></div></figure><p id="c82c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">电子邮件报告</strong> :-</p><figure class="jp jq jr js fd ii er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es mw"><img src="../Images/1d72833d8c670f02ce966e5d9fffc76d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fO4IL-6Qv9h6jScQbj7jVQ.png"/></div></div></figure><p id="6282" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就把我们带到了这篇Selenium WebDriver教程文章的结尾。现在是时候在您的终端安装eclipse、安装各种Selenium包、安装TestNG并开始编写测试用例了。</p><p id="a84d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想查看更多关于人工智能、DevOps、道德黑客等市场最热门技术的文章，那么你可以参考<a class="ae ml" href="https://www.edureka.co/blog/?utm_source=medium&amp;utm_medium=content-link&amp;utm_campaign=selenium-webdriver-tutorial" rel="noopener ugc nofollow" target="_blank"> Edureka的官方网站。</a></p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释硒的各个方面。</p><blockquote class="mn mo mp"><p id="0461" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">1.<a class="ae ml" rel="noopener" href="/edureka/selenium-tutorial-77879a1d9af1">硒教程</a></p><p id="b3c0" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">2.<a class="ae ml" rel="noopener" href="/edureka/selenium-framework-data-keyword-hybrid-frameworks-ea8d4f4ce99f">构建数据驱动、关键字驱动的&amp;混合Selenium框架</a></p><p id="5a10" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">3.<a class="ae ml" rel="noopener" href="/edureka/locators-in-selenium-f6e6b282aed8">硒中的定位器</a></p><p id="e36e" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">4.<a class="ae ml" rel="noopener" href="/edureka/xpath-in-selenium-cd659373e01a"> XPath教程</a></p><p id="07c4" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">5.<a class="ae ml" rel="noopener" href="/edureka/waits-in-selenium-5b57b56f5e5a">等待硒</a></p><p id="c455" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">6.<a class="ae ml" rel="noopener" href="/edureka/selenium-grid-tutorial-ef342799c484">为分布式硒测试设置硒网格</a></p><p id="5dbd" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">7.<a class="ae ml" rel="noopener" href="/edureka/selenium-using-python-edc22a44f819">硒使用Python </a></p><p id="3c91" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">8.<a class="ae ml" rel="noopener" href="/edureka/cross-browser-testing-9299b04ce277">使用LambdaTest进行跨浏览器测试</a></p><p id="81e4" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">9.<a class="ae ml" rel="noopener" href="/edureka/cross-browser-testing-using-selenium-90b1911c6d60">使用Selenium进行跨浏览器测试</a></p><p id="587a" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">10.<a class="ae ml" rel="noopener" href="/edureka/handle-multiple-windows-in-selenium-727ba5f8f6a7">在Selenium中处理多个窗口</a></p><p id="d832" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">11.<a class="ae ml" rel="noopener" href="/edureka/page-object-model-in-selenium-bc4d7c8c4203">硒中页面对象模型</a></p><p id="4dfd" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">12.<a class="ae ml" rel="noopener" href="/edureka/selenium-projects-b2df15d35fe2">硒项目</a></p><p id="d88a" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">13.<a class="ae ml" rel="noopener" href="/edureka/qtp-vs-selenium-338f3d3bbfa7"> QTP vs硒</a></p><p id="7324" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">14.<a class="ae ml" rel="noopener" href="/edureka/selenium-vs-rpa-84159dbcd0f2">硒vs RPA </a></p><p id="300a" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">15.<a class="ae ml" rel="noopener" href="/edureka/selenium-webdriver-architecture-565e2db26dd5"> Selenium WebDriver架构</a></p><p id="ce70" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">16.<a class="ae ml" rel="noopener" href="/edureka/exceptions-in-selenium-369c38155e7d">在Selenium中处理异常</a></p><p id="88d8" class="ip iq jn ir b is it iu iv iw ix iy iz mq jb jc jd mr jf jg jh ms jj jk jl jm ha bi translated">17.<a class="ae ml" rel="noopener" href="/edureka/cucumber-selenium-tutorial-aefec05f4733">使用黄瓜&amp;硒</a>进行网站测试</p></blockquote></div><div class="ab cl mx my go mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ha hb hc hd he"><p id="472d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">原载于2017年5月5日www.edureka.co</em><em class="jn">的</em> <a class="ae ml" href="https://www.edureka.co/blog/selenium-webdriver-tutorial" rel="noopener ugc nofollow" target="_blank"> <em class="jn">。</em></a></p></div></div>    
</body>
</html>