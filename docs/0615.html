<html>
<head>
<title>A UX journey of Compose Preview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作曲预告UX之旅</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/a-ux-journey-of-compose-preview-3c95e1f0a8bf?source=collection_archive---------4-----------------------#2021-03-09">https://medium.com/androiddevelopers/a-ux-journey-of-compose-preview-3c95e1f0a8bf?source=collection_archive---------4-----------------------#2021-03-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/6ad4d52000474e2edf6cc4580c98102e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ujTM2iZjQLcGCTL261Q69g.png"/></div></div></figure><div class=""/><p id="f0cb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">以下帖子由Android开发者UX团队的</em><a class="ae jo" href="https://twitter.com/p3srini?lang=en" rel="noopener ugc nofollow" target="_blank"><em class="jn">Preethi Sri nivas</em></a><em class="jn">(UX研究员)和</em><a class="ae jo" href="https://twitter.com/parishsuhsu?lang=en" rel="noopener ugc nofollow" target="_blank"><em class="jn">Paris Hsu</em></a><em class="jn">(交互设计师)撰写。</em></p><p id="a978" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Jetpack Compose刚刚打了<a class="ae jo" href="https://android-developers.googleblog.com/2021/02/announcing-jetpack-compose-beta.html" rel="noopener ugc nofollow" target="_blank"> Beta </a>！🎉在这个激动人心的时刻，Android开发者UX团队想邀请您进入我们的世界，带您了解我们迄今为止是如何设计Compose预览版的。这从理解挑战和形成方向开始，继续到原型和评估。</p><h1 id="a772" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">背景:理解挑战</h1><p id="02ad" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">Jetpack Compose是用于Android开发的下一代现代UI工具包，旨在使制作漂亮、高性能的Android应用程序更加简单快捷。它利用了直观的Kotlin APIs，因此当应用程序状态改变时，您的UI会自动更新。当我们的团队第一次听说这个项目时，我们对Compose的可能性感到非常兴奋，这是一种混合逻辑和将数据绑定到UI的潜力，可以为开发人员打开新的用例。然而，这种构建UI的新方式带来了新的设计挑战。</p><p id="b61c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于经典的Android视图，UI是静态的，主要是用XML创建的。这意味着我们几乎可以立即反映变化，并创建体验，如<a class="ae jo" href="https://developer.android.com/studio/write/layout-editor" rel="noopener ugc nofollow" target="_blank">布局编辑器</a>，开发人员可以通过可视化拖放编辑他们的应用布局，并查看自动生成的XML代码中反映的相应编辑。然而，使用Compose，每次进行修改时，我们都必须编译Kotlin代码以反映更改，这需要时间，这会减慢迭代和创建过程。</p><h1 id="98b7" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">构思:向设计方案冲刺</h1><p id="a12b" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">为了发现在Compose中支持这种开发UI代码的新模式的方法，我们的团队与我们的软件工程、开发人员关系工程和产品管理合作伙伴举办了一个研讨会，以解决一个设计挑战:<strong class="ir ht">我们如何通过利用开发人员对当前工具的现有经验来帮助他们创建和操作Compose UI？</strong></p><p id="8cd3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<a class="ae jo" href="https://en.wikipedia.org/wiki/Design_thinking" rel="noopener ugc nofollow" target="_blank">设计思维方法</a>，我们从理解和整理问题空间开始。这一过程要求团队在<a class="ae jo" href="https://www.designkit.org/methods/3" rel="noopener ugc nofollow" target="_blank">“我们如何……”框架</a>中写下想法，这些想法后来被<a class="ae jo" href="https://ux-everything.com/affinity-diagram/" rel="noopener ugc nofollow" target="_blank">具体化</a>以帮助识别和细化手头的设计问题。我们使用先前的研究作为跳板，在开发人员旅程的不同点上指导团队思考和工具解决方案的草图。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/fadd44ec06825ad050a2c425334cc94b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lj5qRKwx8aw379H9"/></div></div></figure><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/bf8d6302ac8c4c61ff4354d8ecc6bbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t8-HVvyq4XV8gkYg"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Compose Design Workshop</figcaption></figure><p id="6cd6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">设计研讨会帮助综合了为2020年及以后的组合工具路线图奠定基础的核心原则:</p><ul class=""><li id="52ea" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated">建立在以前构建XML工具的经验基础上</li><li id="81e6" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">像画布一样拥抱代码</li><li id="b641" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">针对迭代和实验进行优化</li></ul><p id="bb1b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些原则构成了我们设计理念向前发展的基础。例如，Compose Preview建立在一种在<em class="jn">外观和感觉</em>中熟悉的体验上，但是补充了Compose通过小的、可重用的组件构建布局的范例。设计研讨会还鼓励我们更倾向于以代码为中心的<a class="ae jo" href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" rel="noopener ugc nofollow" target="_blank"> REPL </a>体验，允许开发人员在预览代码时有更多的控制和灵活性——本质上提供了一个支持迭代、实验和学习的交互式编程环境。我们还构思了XML世界以外的新体验，例如交互式预览，用于支持ide内沙盒环境中隔离的实时交互；部署预览，用于部署可组合到仿真器或物理设备的预览，而无需运行整个应用程序。</p><h1 id="017f" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">原型:早期脉搏检查</h1><p id="7d76" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">为了验证我们的假设和设计方法，我们从设计研讨会开始原型化我们的想法，并在用户研究中测试它们。我们开展研究，以便验证当前的方向，并获得对未来想法或投资的反馈。我们选择了一种迭代的方法来获取反馈，因此在解决其他与作曲相关的主题的多项研究中，机会主义地纳入了与预览相关的主题。</p><p id="203c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">举例来说，为了理解预览体验，我们从询问开发人员会问的问题开始:</p><ul class=""><li id="3cb9" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated">如何使用撰写预览？</li><li id="0042" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">在什么样的背景下，人们想要预览一个动态的交互？</li><li id="c7b6" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">在物理设备或仿真器上部署一个独立的可组合组件并与之交互有多大用处？</li></ul><p id="0447" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们邀请开发人员参加<em class="jn">编码会议</em>，在一个为研究目的而创建的Compose项目中完成简单的编程练习。这种方法节省了设置开发环境的时间和精力，特别是当Compose处于预开发人员预览阶段时，并帮助我们关注开发人员在使用预览和其他Compose APIs时的体验。早期的研究确实需要围绕产品稳定性问题开展工作，预览版并不总是像预期的那样工作。研究计划预测了这些不可避免的问题，同时仍然能够获得非常早期的见解。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/8ab64c42f564f6898eef39dae5308a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MiEhqPOTFnGGFNRb"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Usability research via coding sessions</figcaption></figure><p id="aebc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这些会议中，一些开发人员在区分预览工具栏上的“<em class="jn">刷新”</em>图标和横幅中的“<em class="jn">刷新&amp;构建”</em>图标时表示困惑。大多数人没有意识到“刷新”图标只会更新不需要完整构建的代码变更，而横幅则会更新构建过程中的所有变更。</p><blockquote class="lp lq lr"><p id="e97a" class="ip iq jn ir b is it iu iv iw ix iy iz ls jb jc jd lt jf jg jh lu jj jk jl jm ha bi translated">“如果<strong class="ir ht"> Refresh </strong>和<strong class="ir ht"> Build和Refresh </strong>打算相同，如果它们在一起就好了——我最初认为刷新按钮只会刷新UI，不会构建项目。”</p></blockquote><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/a56def7dec2cba67df13e435842260ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-8GGppqoGETUFziJ"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Preview Refresh &amp; Build (before &amp; after)</figcaption></figure><p id="41bd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这一反馈使我们调整了二者并改善了体验，以便当用户单击图标或横幅时，预览会查看更改，以确定是否需要刷新或重建来反映更改。</p><p id="0716" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">几轮早期研究中关于Compose Preview的一个关键见解包括，开发人员在Compose中制作UI原型时，将提高的生产率与<em class="jn">处于控制中的感觉</em>联系起来。</p><blockquote class="lp lq lr"><p id="1b40" class="ip iq jn ir b is it iu iv iw ix iy iz ls jb jc jd lt jf jg jh lu jj jk jl jm ha bi translated">“<strong class="ir ht">刷新</strong>模式让我可以快速原型化用户界面。让Kotlin的全部功能可用于创建UI以及@Preview函数的示例数据，这比旧的XML方式中的XML名称空间帮助器要好得多。”</p></blockquote><p id="5d8c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们也听到开发人员在与预览版中的组件交互时，对能够导航到代码中的特定点感到惊讶和高兴。</p><blockquote class="lp lq lr"><p id="195f" class="ip iq jn ir b is it iu iv iw ix iy iz ls jb jc jd lt jf jg jh lu jj jk jl jm ha bi translated">“我刚刚发现了这一点，我很高兴，我可以在预览中点击不同的视图，并直接跳转到负责绘制它的代码。我很乐意看到更多这样的想法应用到Jetpack Compose中”</p></blockquote><p id="c7e4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在可用性研究中，我们观察到开发人员通过在预览中点击不同的UI元素，在代码编辑器中导航到他们项目的不同部分——这需要对UI层次有更深的理解。一些开发人员发现，当撰写预览和代码导航中的交互不一致时，体验会有问题。例如，在列中可组合文本的目标区域之外单击，可以导航到代码编辑器中定义该列的行。这让我们通过在布局中包含可组合的轮廓来提供可组合的视觉启示，从而增强预览体验。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lv"><img src="../Images/3b9bc742fe87fc0a50feeaacf9e0ab26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CFyAB9qMQoZJVyJ6"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Preview code navigation</figcaption></figure><h1 id="0ae4" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">沉浸:写日记</h1><p id="5cf4" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">现场的、面对面的可用性研究相对来说是轻量级的，有价值的，并且能激发新的想法。然而，由于时间限制，很难深入挖掘主题。因此，我们转向我们的研究方法，并开始更倾向于一种远程技术，这种技术允许开发人员在他们自己的时间内进行几周的Compose项目。在此期间，开发人员写日记，包括一系列问题，以记录他们在指定项目或自己项目中的工作流程。为了更好地理解开发人员日记中的特定条目，我们通常会在几周的探索之后，将这与采访对话结合起来。经过几天的探索，我们还邀请了一些开发人员参加Google Meet上的编码会议，以观察和确定事情进展顺利的时刻以及可以改进的体验。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div class="er es lw"><img src="../Images/9e4a6443fc60856120f2759dc96cd1ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/0*j3lI-rLxRW29uAzU"/></div><figcaption class="kx ky et er es kz la bd b be z dx">Developer diary with questions to help guide feedback capture</figcaption></figure><p id="e886" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些研究中出现了一个一致的主题——开发人员使用预览来支持创建和故障排除/验证工作流。例如，在创建UI时，开发人员更多地依赖于<em class="jn">刷新</em>模式，而在处理手势/交互时，他们切换到使用<em class="jn">交互</em>模式，而<em class="jn">部署</em>模式最常用于故障排除或验证检查。</p><blockquote class="lp lq lr"><p id="7c1b" class="ip iq jn ir b is it iu iv iw ix iy iz ls jb jc jd lt jf jg jh lu jj jk jl jm ha bi translated">“当我发现互动模式可以在长按上显示明星的动画时，我非常高兴。但是，在随后的长按中，交互模式不起作用——动画不再显示。通过在模拟器上部署预览模式，我看到动画确实工作了。如果交互模式变得更加稳定，它将是我测试交互内容+动画的首选模式。有趣的是，在创建新的用户界面和查看它们是如何呈现的时候，我大部分时间都不需要使用它。”</p></blockquote><p id="4962" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，我们从一些开发人员那里了解到，在考虑整个布局之前，能够提取并集中实现单个可组合组件的重要性。</p><blockquote class="lp lq lr"><p id="c401" class="ip iq jn ir b is it iu iv iw ix iy iz ls jb jc jd lt jf jg jh lu jj jk jl jm ha bi translated">“只部署预览版意味着我不需要仅仅为了测试一个新的组件而将UI与实际的流程(有多个屏幕和用户输入)挂钩。这使得调试+更改复杂的ui变得容易得多。”</p></blockquote><h1 id="0a16" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">将洞察力转化为行动</h1><p id="2cb0" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">我们将我们的方向建立在研究的基础上，这有助于我们将开发人员的见解和问题反馈到我们的工具迭代中——同时确保我们还捕捉到新出现的主题来塑造我们的设计理念。以下是几个例子:</p><h1 id="e5c6" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">新人预览</h1><p id="855c" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">我们观察到开发人员在发现创建预览的入口点时遇到困难——许多人在示例项目中注意到了预览，但是无法在他们自己的项目中复制类似的体验。在创建预览可组合时，不直观的设计通常会导致对组合编译器支持和不支持的误解。例如，我们观察到一些开发人员试图预览接受参数的可组合组件Compose不支持这种功能。在这种情况下，编译器提供的错误消息经常被遗漏或忽略。</p><blockquote class="lp lq lr"><p id="319e" class="ip iq jn ir b is it iu iv iw ix iy iz ls jb jc jd lt jf jg jh lu jj jk jl jm ha bi translated">“我不知道如何用预览显示拆分视图，即使我从示例项目中复制代码，我也无法使用预览注释。”</p></blockquote><p id="5abf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个重要的发现让我们引入了一个<em class="jn">默认</em>状态，其中，如果一个Kotlin文件还没有定义预览组合，那么一个拆分编辑器(从View/XML world中的预览借用)总是以一个空状态可见。我们相信这种解决方案不仅能提高预览的意识和可发现性，还能提供与创建和操作预览相关的学习体验。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/df093475e09209e9322d5f024c3155bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LLEWJRy5ih0MeC9a"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Preview default state</figcaption></figure><h1 id="265d" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">加速编码体验</h1><p id="73b5" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">在调查研究中，开发者问我们:</p><ul class=""><li id="b93d" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated">如何预览明暗主题的布局？</li><li id="83bd" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">如何预览包含样本数据的布局？</li><li id="66a1" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">我如何利用Preview来识别我在代码中的什么地方定义了一个特定的UI元素？</li><li id="61f9" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">有没有一种方法可以让Compose模仿View/XML世界中的预览体验，特别是能够在代码更改时快速看到预览中的视觉变化？</li></ul><p id="721f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些问题说明了一个重要的主题——开发人员正在寻找一种快速简单的机制来操作预览，并期望更快的迭代。</p><p id="59c7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将继续原型化和测试从开发人员反馈中出现的新功能，例如，预览配置选择器将允许开发人员可视化地配置他们的布局(例如，在不同的主题、设备、语言等中)。)，以增加@Preview API的可发现性和易学性。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lv"><img src="../Images/151a456d07704d5f14da5689fdc1ebb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HbzKQS7wqQtfGpDF"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Preview Configuration Picker</figcaption></figure><p id="eafc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一个例子是<a class="ae jo" href="https://developer.android.com/jetpack/compose/tooling#live-literals" rel="noopener ugc nofollow" target="_blank">Live literals</a>——我们的工程团队的解决方案，通过引入对一些可组合值(例如，Boolean、Char、String、Color等)的实时更新来优化迭代开发的速度。)在预览面板中。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lv"><img src="../Images/ee2e42be1bf6929e0089ccb9a9650999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xiK1rO2IUtqzVmIv"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Live Literals in action</figcaption></figure><p id="d993" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jo" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/tooling/preview/PreviewParameterProvider" rel="noopener ugc nofollow" target="_blank"> PreviewParameterProvider </a>是我们将样本数据合并到预览中的又一个例子，以允许真实环境测试。</p><figure class="kt ku kv kw fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ks"><img src="../Images/fd9d8b77dcfb689b0d9aa5fdb6843391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZEdFPpt0trV11Q-R"/></div></div><figcaption class="kx ky et er es kz la bd b be z dx">Using the PreviewParameterProvider</figcaption></figure><h1 id="6be8" class="jp jq hs bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">旅程还在继续…</h1><p id="da45" class="pw-post-body-paragraph ip iq hs ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">我们希望这篇文章揭示了您的反馈如何影响Compose Preview改进的幕后真相。当然，旅程并没有到此结束！总的来说，我们有许多计划来继续支持和改进Compose预览和工具的体验。例如，将<a class="ae jo" href="https://developer.android.com/jetpack/compose/tooling#live-literals" rel="noopener ugc nofollow" target="_blank">活文字</a>扩展为超越文字类型，以获得更快的速度和更快的迭代反馈循环。</p><p id="5d8e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">和往常一样，如果你在使用撰写工具时遇到任何问题，或者对可以改善你的体验的新功能有什么想法，请在这里提交一个bug <a class="ae jo" href="https://issuetracker.google.com/issues/new?component=823947" rel="noopener ugc nofollow" target="_blank">。我们也在寻找参与用户研究会议的开发人员——在此</a>注册<a class="ae jo" href="https://g.co/userresearch/androiddev21" rel="noopener ugc nofollow" target="_blank">参与研究。</a></p></div></div>    
</body>
</html>