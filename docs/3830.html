<html>
<head>
<title>DynamoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DynamoDB</h1>
<blockquote>原文：<a href="https://medium.com/globant/dynamodb-daaeeb4c0a76?source=collection_archive---------6-----------------------#2022-02-22">https://medium.com/globant/dynamodb-daaeeb4c0a76?source=collection_archive---------6-----------------------#2022-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="d923" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><strong class="ak">第一眼</strong></h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/b8ca9c94440285aa3f98a29d5a00d71c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IV2gsLTEoWPw5Hoh"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Photo by <a class="ae jm" href="https://unsplash.com/@tofi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tobias Fischer</a> on <a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f4c0" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">NoSQL数据引擎DynamoDB</h1><p id="d704" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">AWS将DynamoDB定义为一个完全托管的NoSQL数据库服务，具有出色的性能和可伸缩性。听起来很酷，但是对于一个第一次面对使用NoSQL引擎的开发团队来说，这一切到底意味着什么呢？在这篇文章中，我想向您解释它的含义，以及您应该记住什么来以一种好的方式接近DynamoDB，正确地使用它并利用它。为此，我们将重点了解DynamoDB的优势，以及为什么为了利用DynamoDB服务而进行适当的设计是重要的。</p><p id="9838" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated"><strong class="kh hi"> <em class="lg">免责声明:</em> </strong>这是一篇短文，除了概述在DynamoDB中进行设计的最重要的方面以及如何深入研究之外，并不打算做更多的工作。请不要认为阅读10分钟的文章就足以成为DynamoDB专家！</p><h1 id="a854" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">让我们从头开始</h1><p id="dff8" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">首先要理解的是，在一般的NoSQL世界中(尤其是在DynamoDB中), SQL不被用作查询语言(我们可能会从名字中怀疑这一点，对吗？)，数据也不会像在关系引擎中那样保存。在NoSQL发动机中，DynamoDB被归类为混合<em class="lg">键值/宽列</em>。简化很多，这意味着你可以把DynamoDB想象成一个大的哈希表，只有表中的每一个条目，如果需要的话，都有一个B树，所以你可以非常快速的查找“相似”的记录(我们后面会看到这是什么意思)。</p><p id="c0f9" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">但是如果关系引擎已经为我们服务了50多年，我们为什么还要费心学习一个新的范例呢？有几个优点(也有几个问题)，但是如果我必须只用一个词的话，那就是<strong class="kh hi">可扩展性</strong>。</p></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><p id="b4c4" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">[1]:更确切的说是从1970年开始！可以在这里阅读一些历史:<a class="ae jm" href="https://twobithistory.org/2017/12/29/codd-relational-model.html" rel="noopener ugc nofollow" target="_blank">https://twobithistory . org/2017/12/29/codd-relational-model . html</a></p></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><p id="06f1" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">在NoSQL(和DynamoDB！)您的设计目标是尽可能快速有效地执行最常见的查询。如果您做得好，基础设施将保持一致的性能，响应时间不到10毫秒，不管您的数据库中有多少数据！</p><p id="1c78" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">为什么我要说设计？你一定听说过NoSQL是无月经的，对吗？因此你可以把你能想到的任何东西放在每条记录里，对吗？那是一个小(也有点脏)秘密；尽管实际上没有针对每个表的模式，但现实是您确实需要仔细考虑和设计。</p><p id="0452" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">最后，“完全托管服务”是什么意思？这意味着，一旦你设计了你的表，并做了一些初步的定义，基本上你就不需要执行管理任务:你不需要照顾服务器，根据需求扩展(或缩减)你的基础设施，担心磁盘被填满，完成备份，应用更新，以及许多平凡但必要的管理任务。所有这些都是服务的一部分，因此您可以致力于为您的客户创造真正的价值。</p><h1 id="99fe" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">基本概念</h1><p id="3351" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">在考虑DynamoDB数据库的设计时，有两个基本概念应该始终牢记在心:</p><ol class=""><li id="1d52" class="lo lp hh kh b ki lb kl lc ko lq ks lr kw ls la lt lu lv lw bi translated">理解数据将如何被查询是必不可少的(例如，获取数据访问模式)。因此，第一步是理解我们的引擎将要解决的业务问题和用例。</li><li id="c343" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la lt lu lv lw bi translated">应该维护尽可能少的表(事实上，一些顶尖的DynamoDB专家提倡单表设计，即所有数据都驻留在同一个表中！).这与数据库建模时的一个基本原则有很大关系，那就是保持相关数据“紧密结合”[2]。</li></ol></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><p id="88d2" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">[2]:正如我们在DynamoDB中大多数时候会看到的“紧靠在一起”是指在同一个表中！</p></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><p id="ee69" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">为了理解如何将这些概念付诸实践，我们需要回顾一下DynamoDB中的数据组织方式:</p><ul class=""><li id="7d14" class="lo lp hh kh b ki lb kl lc ko lq ks lr kw ls la mc lu lv lw bi translated"><strong class="kh hi">表:</strong>只是一组在概念上放在一起的记录，对我们领域的一个或多个实体进行<strong class="kh hi">建模。与我们在关系引擎中所习惯的相反，不同的实体可以在同一个表中，如果这样做对加速公共搜索有意义的话。</strong></li><li id="7ff0" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated"><strong class="kh hi">项:</strong>是表格中的单个记录。</li><li id="88e3" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated"><strong class="kh hi">属性:</strong>是一个项目中的个别特征。例如，在用户表中，属性可以是他们的用户名、电子邮件等。有标量属性(<em class="lg">字符串</em>，数字，二进制，<em class="lg">布尔</em>，和<em class="lg">空</em>)，复杂属性(列表和映射)，以及<em class="lg">集合</em> ( <em class="lg">字符串集合</em>，<em class="lg">数字集合</em>和<em class="lg">二进制集合</em>)。</li><li id="fa69" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated"><strong class="kh hi">主键:</strong>DynamoDB虽然是无模式的，但是有结构。每个表都必须声明它的主键，这是DynamoDB中最重要的设计决策。</li><li id="2e70" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated"><strong class="kh hi">二级索引:</strong>如果存在主键不能单独满足的访问模式，一个表可以有二级索引。至少在大多数情况下，二级索引是原始表的副本(部分或全部),其中二级索引成为该副本的主键。</li></ul><p id="8c8c" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">一个非常简单的表格如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es md"><img src="../Images/0d933cd38e7e3c6af4492cae8394ab65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/0*nnX3IrI9i-A_XXWU"/></div></figure><p id="fe65" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">有几点需要注意:</p><ul class=""><li id="8c16" class="lo lp hh kh b ki lb kl lc ko lq ks lr kw ls la mc lu lv lw bi translated">正如我前面提到的，大多数情况下，二级索引是原始表的副本。一个常见的观察是，在云中，存储是廉价的，而计算是昂贵的，因此存储冗余信息比每次都计算它更有利可图。</li><li id="75e7" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated">这也允许我们提出<em class="lg">加入</em>的问题:在DynamoDB中没有<em class="lg">加入</em>！[3].根据引擎设计者的说法，<em class="lg">加入</em>是关系型引擎无法同时拥有规模和性能的主要原因之一，这也是它们不存在于DynamoDB中的原因。那又怎样？既然存储便宜，为什么不保存预先加入的数据？但是数据规范化呢？嗯，DynamoDB让我们忘记了神圣范式(有一些例外)。</li></ul></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><p id="6cda" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">[3]:至少从服务的角度来看，你总是可以在客户端级别模拟一个join，但这绝对不是你可以要求DynamoDB去做的操作。</p></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><h1 id="abcf" class="jn jo hh bd jp jq me js jt ju mf jw jx in mg io jz iq mh ir kb it mi iu kd ke bi translated">主键</h1><p id="b681" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">DynamoDB中有两种类型的主键:</p><ul class=""><li id="dbed" class="lo lp hh kh b ki lb kl lc ko lq ks lr kw ls la mc lu lv lw bi translated"><strong class="kh hi">简单主键:</strong>由称为<em class="lg">分区键</em>(以前称为哈希键)的单个元素组成。上面显示的users表有一个简单的主键，对应于用户名。</li><li id="f2a2" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated"><strong class="kh hi">复合主键:</strong>由两个元素组成，称为分区键和排序键(以前称为范围键)。</li></ul><p id="dfcf" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">通过选择一个分区键，我们将表中的所有项划分成组，这一思想是DynamoDB可伸缩性的核心。这里再次值得将DynamoDB看作一个大哈希表，我们的分区键作为DynamoDB使用的哈希函数的输入。</p><p id="5dee" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">同样，复合主键(即分区键<strong class="kh hi">和排序键</strong>的组合)允许我们在单个数据库查询中满足“获得许多相关记录”的访问模式。使用分区键，我们可以得到一个具有相同值的项目集合，使用排序键上的条件，我们可以指定整个集合中需要的特定项目的范围。顺便提一下，在DynamoDB中，分区键中具有相同值的所有项目的集合称为项目集合。</p><p id="d0ee" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">我们来看一个具体的例子。为此，我们将进行一些迭代设计:在第一次迭代中，我们将使用一个更简单的设计，稍后我们将扩展它，因为我们将改变我们想要回答的查询的类型。</p><p id="038d" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">为此，假设我们正在开发一个SaaS应用程序；这项服务的客户是组织，每个组织都有注册用户。假设我们想要查询属于某个组织的用户，为此我们可以有一个如下所示的表:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mj"><img src="../Images/c7172102386f01757d463cbdcded4fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/0*ZmXMMfGINaSZ2Rv1"/></div></figure><p id="de0c" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">在这种情况下，要获取属于某个组织的所有用户，我们只需获取与该特定组织相关联的项目集合。例如，如果我们使用DynamoDB API <em class="lg">查询</em>，表明分区键是<em class="lg"> "MolinosSanAlfonso" </em>，这个调用返回所有相应的项(在本例中，我们的用户是Fabiola Salazar和Pedro Salas)。</p><p id="ea9f" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated"><strong class="kh hi">注意:</strong>我们还没有提到的一件事是，在实践中，所有能够过滤和搜索的条件都必须包含在主键或二级索引上。虽然我们可以通过普通属性进行过滤，但是这些过滤器在信息从存储器中提取出来之后，在发送到客户端之前，作用于服务端<strong class="kh hi">，所以它们不是我们真正想要使用的机制(如果我们想要至少在时间和金钱上高效的话！).因此，所有与高效搜索相关的工作都是在主键和二级索引级别完成的。</strong></p><p id="c715" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">这是我们的第一个设计，但是，让我们扩展一下这个例子(并相应地改变设计)，看看我们如何在没有连接的情况下工作。</p><p id="a186" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">因此，让我们假设我们现在知道我们的应用程序最频繁的查询是关于组织信息，它必须包括所有用户的列表。一种方法是将组织表添加到我们已经为用户准备的表中。但是，记住我们没有joins <em class="lg"> </em>，这需要我们分别获取组织及其用户的信息，也就是在我们的应用程序中通过逻辑链接的两个独立的搜索。为了改善这一点，我们可以引入另一种策略，在DynamoDB中很常见，称为键和索引重载。如果我们将几个不同的实体放在同一个表中(并因此对库进行单个查询)，这意味着公共属性(即那些构成我们的键和索引的属性)将有不同的含义，这取决于实体(这就是为什么我们谈论重载)。</p><p id="fb8c" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">让我们看看这在实践中意味着什么，为此我们将使用以下设计(其中PK和SK是主键和排序键的通用名称，顺便说一下，这是一个常用的约定):</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mk"><img src="../Images/4ac53827c56a92ad5ff71dc2f225c22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/0*feuAvUxWI-a2jRmQ"/></div></figure><p id="ef94" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">哇！我们有一些变化，让我们更详细地回顾一下:</p><ul class=""><li id="900c" class="lo lp hh kh b ki lb kl lc ko lq ks lr kw ls la mc lu lv lw bi translated">首先，我们看到该表有几个实体，因为它不仅包含用户，还存储了关于组织本身的信息。每种类型的实体都有自己的属性，公共属性(<em class="lg"> PK </em>和<em class="lg"> SK </em>在我们的例子中)对每种类型的实体有不同的含义。</li><li id="29e3" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated">蓝色标记的是对应于值<em class="lg">“ORG # MOLINOSSANALFONSO”</em>的<em class="lg">项集合</em>，或者换句话说，分区键具有相同值的所有项。然而，在这种情况下，我们看到，我们现在已经成功地关联了不同的实体:一方面，我们拥有组织自己的信息(它被称为什么，它已经签订了什么计划)，另一方面，我们拥有属于该组织的所有用户。</li></ul><p id="39f4" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">这样，当我们谈论“预先绑定”相关的值时，我们终于可以明白我们的意思了。在关系引擎中，这将被建模为两个单独的表，一个SQL查询使用一个连接操作根据公共属性(在本例中是组织名称或标识符)合并这两个表。</p><p id="4c46" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">有理由问，利润是什么？我们不得不重新设计这个表，最终我们得到了一个看起来很“奇怪”的表，让一个关系引擎来处理所有事情不是更容易吗？嗯，一如既往，这完全取决于我们在寻找什么。通过这样做，我们获得的是可伸缩性和持续的良好性能，而不管我们的基数有多大。此外，我向你保证，当你做出更多类似的设计时，这些桌子就不会显得“怪异”了。</p><p id="32eb" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">这种设计允许我们解决几个问题，例如:</p><ul class=""><li id="99be" class="lo lp hh kh b ki lb kl lc ko lq ks lr kw ls la mc lu lv lw bi translated">如果我们想要获取一个特定的组织，通过它的完整主键(例如，<em class="lg">PK</em>=<em class="lg">SK</em>=<em class="lg">" ORG # MOLINOSSANALFONSO "</em>)获取一个物品就足够了。为此，我们使用名为<em class="lg"> GetItem </em>的DynamoDB API和适当的参数(当我们需要一个特定的项目时，我们使用<em class="lg"> GetItem </em>，当我们需要一组相关项目的分区键时，我们使用<em class="lg"> Query </em>)。</li><li id="9894" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated">对于我们说的使用最多的查询(即组织的完整信息，包括其所有用户)，使用带有<em class="lg">PK = " ORG # MOLINOSSANALFONSO "</em>条件的<em class="lg">查询</em> DynamoDB API就足够了。</li><li id="e87c" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated">如果我们想要一个特定的用户，例如来自<em class="lg"> "Molinos San Alfonso" </em>的<em class="lg"> "Pedro Salas" </em>，我们应该使用带有条件<em class="lg">PK</em><em class="lg">=</em><em class="lg">" ORG # MOLINOSSANALFONSO "和SK = "USER#PEDRO_SALAS" </em>的<em class="lg"> GetItem </em>。</li></ul><h1 id="b8a0" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">次要索引</h1><p id="69ae" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">如果我们还记得的话，我们使用二级索引来访问那些仅仅通过主键无法满足的模式；实际上，根据索引的类型，二级索引是原始表的副本，只包含所需的数据。进行查询。</p><p id="deab" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">DynamoDB中有两种类型的二级索引:</p><ul class=""><li id="2559" class="lo lp hh kh b ki lb kl lc ko lq ks lr kw ls la mc lu lv lw bi translated"><strong class="kh hi">本地二级索引:</strong>相同的<em class="lg">分区键</em>，但不同的<em class="lg">排序键</em>。在这种情况下，没有表的副本，但是需要注意某些DynamoDB限制(这里没有更多细节，因为我们还没有看到一些具体的DynamoDB实现概念，这些概念对于解释为什么存在这些限制是必要的)。</li><li id="9ff4" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated"><strong class="kh hi">全局二级索引:</strong>完全不同的属性被用于<em class="lg">分区键</em>和<em class="lg">排序键</em>，导致表的副本(部分或全部)。这是潜在的“存储是廉价的”哲学的另一个例子，由于增加了灵活性，它们比本地索引使用得更多。</li></ul><p id="5f87" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">为二级索引提出的想法和策略与我们为主键建模时的想法相同，但是我们需要一个新的构造来解析额外的访问模式(在那些通过使用主键解析的模式之上)。</p><p id="0e65" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">一种重复出现的策略是使用二级索引来模拟N-N关系，将N-N关系视为两个1-N关系，其中我们使用一个1-N关系的主键，并使用一个全局二级索引来模拟另一个1-N关系。</p><p id="702f" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">这种N-N关系的一个例子是电影和演员之间的存在，其中一个演员可以出现在许多电影中，一部电影可以出现在许多演员中。例如，如果我们必须回答的查询是“给我所有参与电影的演员”和“给我一个演员参与的所有电影”，那么我们可以有一个由“<id_pelicula> + &lt; id_actor&gt;”(返回所有参与电影的演员)组成的主键，并有一个全局辅助索引“<id_actor> + <id_pelicula>”(返回演员参与的所有电影)。</id_pelicula></id_actor></id_pelicula></p><h1 id="d0c9" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">DynamoDB API</h1><p id="6c3e" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">我们已经看到了一些可以用来访问DynamoDB数据库的API示例，现在我们将列出所有可用的操作:</p><ul class=""><li id="d3bd" class="lo lp hh kh b ki lb kl lc ko lq ks lr kw ls la mc lu lv lw bi translated"><strong class="kh hi">与特定项相关的动作:</strong> DynamoDB是作为键值数据存储而诞生的，这可以在API中看到。所有这些动作都在单个项目上配置典型的CRUD动作，并且需要完整的主键作为参数:<br/> - <strong class="kh hi"> GetItem: </strong>获取一个特定的项目。<br/> - <strong class="kh hi"> PutItem: </strong>创建或覆盖一个特定的项目。<br/> - <strong class="kh hi"> UpdateItem: </strong>创建或更新一个特定的项目。<br/> - <strong class="kh hi">删除项目:</strong>删除一个特定的项目。</li><li id="81ec" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated"><strong class="kh hi">对多个项目的操作:<br/> -查询:</strong>获取一个项目集合，即一组具有相同分区键值的项目(可选择通过使用排序键上的条件进行过滤)。<br/>-<strong class="kh hi">:Scan:</strong>这个动作基本上遍历整个表，将满足某个表达式的所有条目都带出来，这个表达式涉及到不包含在键或索引中的属性。它应该只作为最后的手段或者在某些特殊的情况下使用(例如，在为非常不频繁的查询创建特殊索引没有意义的小表上)。</li></ul><p id="c67c" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">像所有AWS APIs一样，HTTPS被用作传输协议，这是与具有专用通信协议的关系引擎的另一个区别。当然，最常见的语言都有自己的库，所以没有必要直接使用API，根据语言的不同，会提供不同的构造和抽象来方便开发人员的工作。</p><h1 id="106e" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">平台</h1><p id="0557" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">到目前为止，我们还没有谈到服务的技术方面，以及这种实现如何提供可伸缩性和性能。</p><p id="b52d" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">正如其他NoSQL引擎(甚至像Apache Kafka这样的服务，它们不是数据引擎，但它们提供了一个持久层)，神奇的词是横向扩展。水平增长与分区的概念相关联，我们认为分区是DynamoDB的核心。几乎所有操作都必须选择和使用分区键，这使得DynamoDB能够为不同的数据子集分配专用的基础设施(不仅仅是存储，还有计算和通信)。</p><p id="9723" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">同样，将DynamoDB表想象成一个大哈希表也很有帮助。有了分区键，我们可以立即找到相应的物品所在的位置，而不管底座有多大。</p><p id="6a5f" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">因此，我们终于知道在DynamoDB背后有服务器集群，每个服务器都有计算、存储和通信资源，专用于服务我们数据的特定分区。如果数据增长，DynamoDB会向集群添加更多的节点，允许线性扩展(请记住，由于使用了我们的分区键，访问特定分区的操作不依赖于数据库的大小)。</p><p id="f58a" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">DynamoDB的最后一个优点是，所有这些对用户都是透明的，一切都由服务来处理。</p><h1 id="84b2" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">何时使用DynamoDB</h1><p id="57ca" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">一个很重要的问题是什么时候使用DynamoDB。我并不是说DynamoDB对每个问题都是一个好的选择，尽管经过精心设计，它可以用于大多数问题。相反，我将尝试提供一些标准，让我们能够决定它是否是符合我们需求的好的<em class="lg">匹配</em>:</p><ol class=""><li id="da52" class="lo lp hh kh b ki lb kl lc ko lq ks lr kw ls la lt lu lv lw bi translated">这是一个事务性应用程序。DynamoDB不太适合分析项目。</li><li id="747e" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la lt lu lv lw bi translated">所有数据访问模式都可以从一开始就确定。如果我们如何查询数据存在很多不确定性，那么这可能不是DynamoDB的一个好用例。</li><li id="0d75" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la lt lu lv lw bi translated">人们倾向于使用无服务器服务，或者至少这是一个可以接受的选择。</li><li id="d137" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la lt lu lv lw bi translated">对于使用DynamoDB的第一个项目来说，需要支持强劲增长、保持一致的响应时间并具有简单数据访问模式的应用程序是理想的应用程序。当然，随着经验的增加，几乎任何问题都可以用DynamoDB解决。</li></ol><h1 id="9edb" class="jn jo hh bd jp jq jr js jt ju jv jw jx in jy io jz iq ka ir kb it kc iu kd ke bi translated">完成</h1><p id="87d5" class="pw-post-body-paragraph kf kg hh kh b ki kj ii kk kl km il kn ko kp kq kr ks kt ku kv kw kx ky kz la ha bi translated">哇，我们到达终点了！虽然我们仅仅触及了DynamoDB的皮毛，但我希望我已经实现了我的初衷，并与您分享了成功理解和使用DynamoDB所必需的基础知识。</p><p id="6d67" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">作为总结，我将把我想传达给你们的最重要的想法留下来:</p><ul class=""><li id="728c" class="lo lp hh kh b ki lb kl lc ko lq ks lr kw ls la mc lu lv lw bi translated">DynamoDB是一个非关系数据库服务，如果我们的设计尊重某些规则，它可以很好地扩展并呈现一致的性能。</li><li id="b11f" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated">要在DynamoDB中实现正确的设计，你必须做的是:<br/> a .理解<strong class="kh hi">所有</strong>我们的应用程序需要的数据访问模式。<br/> b .决定我们将使用哪些表，以及允许我们回答我们提出的访问模式的主键(和辅助索引，如果必要的话)。</li><li id="335d" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated"><strong class="kh hi">推论:</strong>不要期望如果你在设计时考虑了关系引擎，你会得到在DynamoDB中运行良好的东西！</li></ul><p id="9dd5" class="pw-post-body-paragraph kf kg hh kh b ki lb ii kk kl lc il kn ko ld kq kr ks le ku kv kw lf ky kz la ha bi translated">我们还没有回顾很多主题:数据一致性、备份、监控、优化、<em class="lg">流</em>、迁移、更高级的设计模式等等。然而，我希望我已经告诉了你足够的信息来激起你的好奇心，并想继续调查。为此，我推荐以下资源:</p><ul class=""><li id="8a0f" class="lo lp hh kh b ki lb kl lc ko lq ks lr kw ls la mc lu lv lw bi translated">Alex DeBrie是DynamoDB的大师之一，他有几个很棒的资源:<br/> -一个致力于不同DynamoDB主题的网站:<a class="ae jm" href="https://www.dynamodbguide.com/" rel="noopener ugc nofollow" target="_blank">https://www.dynamodbguide.com/</a><br/>-一本致力于DynamoDB的完整书籍，非常强调设计:<a class="ae jm" href="https://www.dynamodbook.com/" rel="noopener ugc nofollow" target="_blank">https://www.dynamodbook.com/</a>。我在本文中展示的例子是受这本书的启发。</li><li id="c7e4" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated">YouTube上有几个关于DynamoDB的教程和潜水课，我将放几个我觉得特别好的:<br/>——Alex DeBrie在reInvent 2019的DynamoDB建模课上:<a class="ae jm" href="https://www.youtube.com/watch?v=yvBR71D0nAQ&amp;t=295s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v= yvbr 71 d0 naq&amp;t = 295s</a>。<br/> -另一个高级设计环节:【https://www.youtube.com/watch?v=HaEPXoXVf2k T4】。这个环节真的会让你大吃一惊(字面意思！).<br/> -更技术性的会议，DynamoDB开发团队的一名成员解释了其内部工作的各个方面:<a class="ae jm" href="https://www.youtube.com/watch?v=yvBR71D0nAQ&amp;t=295s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=yvBR71D0nAQ&amp;t = 295s</a>。</li><li id="24f0" class="lo lp hh kh b ki lx kl ly ko lz ks ma kw mb la mc lu lv lw bi translated">显然我得把DynamoDB的AWS官方指南包括进来:<a class="ae jm" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/Amazon DynamoDB/latest/developer guide/introduction . html</a>。</li></ul></div></div>    
</body>
</html>