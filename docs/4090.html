<html>
<head>
<title>Angular — Unit Testing recipes (v2+)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度—单元测试配方(v2+)</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/angular-2-unit-testing-with-jasmine-defe20421584?source=collection_archive---------0-----------------------#2016-02-19">https://medium.com/google-developer-experts/angular-2-unit-testing-with-jasmine-defe20421584?source=collection_archive---------0-----------------------#2016-02-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4612" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用Jasmine进行角度单元测试的方法</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/77d4249983223a7df017b3d79f820f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKFxOIfp4twTb0vLTm-eWQ.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Reza Ali (colorised)</figcaption></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="30e5" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">角度—测试指南(v4+)</h1><p id="cdf0" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">最新版本的<strong class="ig hi">角度单元测试配方</strong>。阅读它以了解最新的<strong class="ig hi">Angular</strong>API。</p><div class="lc ld ez fb le lf"><a rel="noopener follow" target="_blank" href="/google-developer-experts/angular-2-testing-guide-a485b6cb1ef0"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="bd hi fi z dy lk ea eb ll ed ef hg bi translated">角度测试指南</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">使用TestBed、fixtures、async和fakeAsync/tick的九个易于理解的示例。</h3></div><div class="ln l"><p class="bd b fp z dy lk ea eb ll ed ef dx translated">medium.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt jm lf"/></div></div></a></div><p id="a528" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请继续阅读，查看测试API的旧版本。Jasmine部分和自定义匹配器仍然有效。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="6788" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Angular的前身设计时就考虑到了<strong class="ig hi">的可测试性</strong>，它提供了多种选项来支持<strong class="ig hi">单元测试</strong>。在本文中，我们将向您展示如何设置Jasmine并为您的角度应用编写一些常见的单元测试。我们将涵盖:</p><ul class=""><li id="dc44" class="lv lw hh ig b ih ii il im ip lx it ly ix lz jb ma mb mc md bi translated">Jasmine简介:<a class="ae lu" href="#e924" rel="noopener ugc nofollow">主要概念</a>，<a class="ae lu" href="#4250" rel="noopener ugc nofollow">特点</a>，<a class="ae lu" href="#4880" rel="noopener ugc nofollow">设置和拆卸</a>，<a class="ae lu" href="#14c4" rel="noopener ugc nofollow">默认匹配器</a>和<a class="ae lu" href="#b334" rel="noopener ugc nofollow">自定义匹配器</a>。</li><li id="1452" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">角度测试:<a class="ae lu" href="#479b" rel="noopener ugc nofollow">设置</a>和<a class="ae lu" href="#05b4" rel="noopener ugc nofollow">依赖注入</a>。</li><li id="8ce2" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">Angular的单元测试配方:<a class="ae lu" href="#8d61" rel="noopener ugc nofollow">组件</a>，<a class="ae lu" href="#58b7" rel="noopener ugc nofollow">服务</a>，<a class="ae lu" href="#45ef" rel="noopener ugc nofollow"> Http </a>和<a class="ae lu" href="#5ac2" rel="noopener ugc nofollow"> MockBackend </a>，<a class="ae lu" href="#2e84" rel="noopener ugc nofollow">指令</a>，<a class="ae lu" href="#a937" rel="noopener ugc nofollow">管道</a>，<a class="ae lu" href="#0bc9" rel="noopener ugc nofollow">路由</a>，<a class="ae lu" href="#59a4" rel="noopener ugc nofollow">可观察对象</a>和<a class="ae lu" href="#3882" rel="noopener ugc nofollow">事件发射器</a>。</li></ul><p id="38c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以使用上面的链接导航到每个食谱，或者如果你已经熟悉Jasmine，跳到<a class="ae lu" href="#e264" rel="noopener ugc nofollow">第二部分</a>。</p><p id="436a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">包含所有规格的完整工作示例可以在<a class="ae lu" href="http://plnkr.co/edit/N3Acjuk7g9sPs35Rchjg?p=preview" rel="noopener ugc nofollow" target="_blank">这里</a>找到。在<a class="ae lu" href="https://twitter.com/intent/user?screen_name=gerardsans" rel="noopener ugc nofollow" target="_blank"> @gerardsans </a>找到我的最新观点。</p><h1 id="bb2c" class="jz ka hh bd kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw bi translated">茉莉简介</h1><p id="bc8d" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">Jasmine是来自<a class="ae lu" href="http://pivotal.io/labs" rel="noopener ugc nofollow" target="_blank"> Pivotal Labs </a>的开源测试框架，它使用行为驱动的符号，从而带来流畅和改进的测试体验。</p><h2 id="e924" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">主要概念</h2><ul class=""><li id="dba7" class="lv lw hh ig b ih kx il ky ip nc it nd ix ne jb ma mb mc md bi translated">Suites — <strong class="ig hi"> <em class="nf"> describe(字符串，函数)</em> </strong> <em class="nf"> </em> functions，取一个标题和一个包含一个或多个规格的函数。</li><li id="5187" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">Specs — <strong class="ig hi"> <em class="nf"> it(string，function) </em> </strong> functions，取一个标题和一个包含一个或多个期望的函数。</li><li id="d5f0" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">期望—是评估为<em class="nf">真</em>或<em class="nf">假</em>的断言。基本语法为<strong class="ig hi"> <em class="nf"> expect(实际)。</em> </strong></li><li id="6b0c" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">匹配器—是通用断言的预定义助手。例如:<strong class="ig hi"> <em class="nf"> toBe(预期)</em></strong><strong class="ig hi"><em class="nf">to equal(预期)</em> </strong>。点击查看完整列表<a class="ae lu" href="https://github.com/JamieMason/Jasmine-Matchers" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><blockquote class="ng nh ni"><p id="a274" class="ie if nf ig b ih ii ij ik il im in io nj iq ir is nk iu iv iw nl iy iz ja jb ha bi translated">注意<strong class="ig hi">。toEqual() </strong>做深度比较而<strong class="ig hi">。toBe() </strong>只是一个引用等式。</p></blockquote><h2 id="4250" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">茉莉花特征</h2><p id="43ff" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">自2.0版本重大升级(2013年12月)以来，几乎没有发布。Jasmine 2.4.1于去年12月发布。请参阅以下自2.0以来的主要新增内容:</p><ul class=""><li id="942b" class="lv lw hh ig b ih ii il im ip lx it ly ix lz jb ma mb mc md bi translated"><strong class="ig hi"><em class="nf">jasmine . string matching(string | regExp)</em></strong>matcher—字符串的部分匹配。它也接受正则表达式作为参数。</li><li id="1dc4" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated"><strong class="ig hi"><em class="nf">jasmine . array containing(array)</em></strong>matcher—当期望值只要求数组中的某些值存在时的部分匹配</li><li id="60f1" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated"><strong class="ig hi"><em class="nf">jasmine . any()</em></strong>matcher—匹配任何非空或未定义的值。</li><li id="1be5" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated"><strong class="ig hi"><em class="nf">【pending(string)</em></strong>函数—我们现在可以传入一个原因，作为报告者要显示的文本。</li><li id="fba9" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated"><strong class="ig hi"><em class="nf">fail(string | Error)</em></strong>function—<em class="nf">fail</em>function会导致spec失败，以消息或错误对象作为参数。</li><li id="712a" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated"><strong class="ig hi">聚焦规格/套件</strong> —通过使用<em class="nf"> fit </em>和<em class="nf">fdescripe</em>您可以决定运行哪些规格或套件。</li><li id="8a01" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated"><strong class="ig hi">一次性安装和拆卸</strong>——这可以通过调用<em class="nf">之前的</em>和<em class="nf">之后的<em class="nf">来使用。</em></em></li><li id="af06" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated"><strong class="ig hi"> <em class="nf">禁用的规格/套件</em> </strong> <em class="nf"> —您可以使用xit和xdescript</em><em class="nf">有选择地禁用规格或套件(显示为待定)。</em></li></ul><p id="2e29" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">点击查看所有发布详情<a class="ae lu" href="https://github.com/jasmine/jasmine/releases" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="4880" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">安装和拆卸</h2><p id="7ca2" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">在我们的规范中避免代码重复的一个好方法是包含设置代码。</p><blockquote class="nm"><p id="8f73" class="nn no hh bd np nq nr ns nt nu nv jb dx translated">使用beforeEach和afterEach在每个规范之前和之后进行更改</p></blockquote><p id="b4f0" class="pw-post-body-paragraph ie if hh ig b ih nw ij ik il nx in io ip ny ir is it nz iv iw ix oa iz ja jb ha bi translated">Jasmine提供了四个处理程序来添加我们的设置和拆卸代码:每个 之前的<strong class="ig hi">，<strong class="ig hi"> <em class="nf">之后的每个</em> </strong>以及每个套件执行一次的<strong class="ig hi"> <em class="nf">之前的所有</em> </strong>，<strong class="ig hi"> <em class="nf">之后的所有</em> </strong>。</strong></p><h2 id="bc64" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">默认匹配器</h2><p id="bb58" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">这些是Jasmine的默认匹配器。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><blockquote class="ng nh ni"><p id="25ea" class="ie if nf ig b ih ii ij ik il im in io nj iq ir is nk iu iv iw nl iy iz ja jb ha bi translated">查看<a class="ae lu" href="https://github.com/JamieMason/Jasmine-Matchers" rel="noopener ugc nofollow" target="_blank"> Jasmine-Matchers </a>获得数组、布尔值、浏览器、数字、异常、字符串、对象和日期的其他匹配器。</p></blockquote><h2 id="b334" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">自定义匹配器</h2><p id="c2a2" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">有时你可以使用定制的匹配器库来改进你的规格或者错误信息。如果你觉得你在测试中做了很多样板文件，这可能会对你有所帮助。</p><p id="96e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看如何创建一个<em class="nf"> myCustomMatchers </em>库，其中只包含一个简化的匹配器:<strong class="ig hi"><em class="nf">toBeAllowedToDrive</em></strong>。匹配器必须在包含<em class="nf">比较</em>函数的工厂对象中。它的签名是<em class="nf"> compare(actual，expected) </em>返回一个类似<em class="nf"> { pass: boolean，message: string }的对象。</em>这个实现对<em class="nf"> expect(age)都有效。toBeAllowedToDrive() </em>和<em class="nf">(年龄). not.toBeAllowedToDrive()。</em></p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="4204" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以在下面的代码中看到我们是如何提高规范可读性的。消息还将改善未来的维护和调试体验。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><h1 id="e264" class="jz ka hh bd kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw bi translated">角度测试</h1><h2 id="479b" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">设置</h2><p id="f231" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated"><a class="ae lu" href="https://angular.io/docs/ts/latest/testing/first-app-tests.html" rel="noopener ugc nofollow" target="_blank">设置您的环境</a>有几个选项。你可以使用Jasmine的<em class="nf">SpecRunner.html</em>从<a class="ae lu" href="https://github.com/pivotal/jasmine/releases" rel="noopener ugc nofollow" target="_blank">独立发行版</a>开始或者创建你自己的。你也可以把它和类似<a class="ae lu" href="https://karma-runner.github.io" rel="noopener ugc nofollow" target="_blank"> Karma </a>的测试跑步者整合在一起。我们不会涵盖所有的组合，因为我们对实际测试更感兴趣。</p><blockquote class="ng nh ni"><p id="d14e" class="ie if nf ig b ih ii ij ik il im in io nj iq ir is nk iu iv iw nl iy iz ja jb ha bi translated">此设置仅供参考，仅适用于Plunker。</p></blockquote><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="fd2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们加载Jasmine依赖项，后面是Angular依赖项。我们正在使用一个<strong class="ig hi"> System.js </strong>和<strong class="ig hi"> TypeScript </strong>设置。我们使用<em class="nf"> Promise.all() </em>一次性加载我们的规范，一旦所有规范都可用，就触发Jasmine测试程序。别忘了包括<em class="nf"> testing.dev.js </em>。</p><blockquote class="ng nh ni"><p id="7d37" class="ie if nf ig b ih ii ij ik il im in io nj iq ir is nk iu iv iw nl iy iz ja jb ha bi translated">检查这个<a class="ae lu" href="https://github.com/angular/angular/blob/d116861c8e884d911f15b8caabeefc6f049c775d/modules/angular2/docs/bundles/overview.md#es5-and-ngupgrade-users" rel="noopener ugc nofollow" target="_blank"> url </a>以找出您的设置需要哪些模块、桶和包。</p></blockquote><h2 id="05b4" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">依赖注入</h2><p id="ad5d" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">为了在测试中使用角度组件，我们需要像在应用程序中使用bootstrap一样包含我们的依赖关系。然后，依赖注入引擎将使用该信息来解析所有引用。为此我们将使用:<a class="ae lu" href="https://angular.io/docs/ts/latest/api/testing/beforeEachProviders-function.html" rel="noopener ugc nofollow" target="_blank"><em class="nf">before each providers</em></a><em class="nf"/><a class="ae lu" href="https://angular.io/docs/ts/latest/api/testing/inject-function.html" rel="noopener ugc nofollow" target="_blank"><em class="nf">inject</em></a><em class="nf"/>和<em class="nf"/><a class="ae lu" href="https://angular.io/docs/ts/latest/api/testing/injectAsync-function.html" rel="noopener ugc nofollow" target="_blank"><em class="nf">inject async</em></a><em class="nf">。</em>全部从<em class="nf">进口【角度2/测试】。</em></p><p id="bd95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看如何在<em class="nf">languageservice</em>组件中使用它们:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="134b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，在每个提供者 之前，我们用<a class="ae lu" href="https://angular.io/docs/ts/latest/api/testing/beforeEachProviders-function.html" rel="noopener ugc nofollow" target="_blank"> <em class="nf">加载测试所需的依赖关系。这将在每次测试之前设置一个全新的<a class="ae lu" href="https://angular.io/docs/ts/latest/api/core/Injector-class.html" rel="noopener ugc nofollow" target="_blank"> <em class="nf">注入器</em> </a>实例，使用数组<em class="nf">所需的依赖项。然后根据我们的规范，我们使用<a class="ae lu" href="https://angular.io/docs/ts/latest/api/testing/inject-function.html" rel="noopener ugc nofollow" target="_blank"> <em class="nf">注入</em> </a>来自动实例化每个依赖项。对于简单的测试，我们也可以使用下面的替代方法，但是一般来说，使用<a class="ae lu" href="https://angular.io/docs/ts/latest/api/testing/inject-function.html" rel="noopener ugc nofollow" target="_blank"> <em class="nf">注入</em> </a> <em class="nf"> </em>来充分发挥DI的潜力。</em></em></a></p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="224a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae lu" href="https://angular.io/docs/ts/latest/api/testing/inject-function.html" rel="noopener ugc nofollow" target="_blank"> <em class="nf">注射</em> </a>的两种常见用法是:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx">Different notations for inject.</figcaption></figure><p id="b440" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，当依赖关系涉及异步处理时，我们可以使用<a class="ae lu" href="https://angular.io/docs/ts/latest/api/testing/async-function.html" rel="noopener ugc nofollow" target="_blank"> <em class="nf">异步</em> </a> <em class="nf"> </em>。这将在内部创建一个区域，并处理任何异步处理。</p><p id="7cee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看如何测试应用程序的不同构件。为了简洁起见，我们将跳过本帖中所有必需的<strong class="ig hi"> <em class="nf">导入</em> </strong>。我们在必要时添加了注释。他们可以在这里找到<a class="ae lu" href="http://plnkr.co/edit/N3Acjuk7g9sPs35Rchjg?p=preview" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="5aa7" class="jz ka hh bd kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw bi translated">角度(v2+)的单元测试方法</h1><h2 id="8d61" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">测试组件</h2><p id="8e15" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">让我们看一个简单的组件，它使用一个<a class="ae lu" href="https://angular.io/docs/ts/latest/api/core/Input-var.html" rel="noopener ugc nofollow" target="_blank"> @ <em class="nf"> Input() </em> </a>属性呈现一个<em class="nf">问候</em>消息。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="7d31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了帮助测试这个组件，我们将使用一个通用的设置，使用<em class="nf">beforeachproviders</em>。</p><blockquote class="nm"><p id="f04e" class="nn no hh bd np nq nr ns nt nu nv jb dx translated">使用beforeEachProviders()加载相应的依赖项，以便它们在测试期间可用</p></blockquote><p id="6e08" class="pw-post-body-paragraph ie if hh ig b ih nw ij ik il nx in io ip ny ir is it nz iv iw ix oa iz ja jb ha bi translated">通常的做法是在每个之前使用<em class="nf">来重构我们的测试。通过这样做，我们避免了为每个测试<em class="nf">重复一些代码，如<em class="nf">注入</em>。这也将简化我们的规格。</em></em></p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="50d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用来自<a class="ae lu" href="https://github.com/angular/angular/blob/a7e9bc97f6a19a2b47b962bd021cb91346a44baa/modules/angular2/src/testing/test_component_builder.ts#L95" rel="noopener ugc nofollow" target="_blank"><em class="nf">TestComponentBuilder</em></a>的<em class="nf"> createAsync() </em>来创建我们的<em class="nf"> Greeter </em>组件的一个实例，返回一个<em class="nf"> Promise </em>。然后组件将在测试<a class="ae lu" href="https://github.com/angular/angular/blob/a7e9bc97f6a19a2b47b962bd021cb91346a44baa/modules/angular2/src/testing/test_component_builder.ts#L31" rel="noopener ugc nofollow" target="_blank">夹具</a>中创建。这是它的主要API:</p><pre class="jd je jf jg fd od oe of og aw oh bi"><span id="9ecc" class="mo ka hh oe b fi oi oj l ok ol">abstract class <a class="ae lu" href="https://github.com/angular/angular/blob/a7e9bc97f6a19a2b47b962bd021cb91346a44baa/modules/angular2/src/testing/test_component_builder.ts#L31" rel="noopener ugc nofollow" target="_blank">ComponentFixture</a> {<br/>  debugElement;       // test helper <br/>  componentInstance;  // access properties and methods<br/>  nativeElement;      // access DOM<br/>  detectChanges();    // trigger component change detection<br/>}</span></pre><p id="3698" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用<em class="nf"> name </em>属性来设置一个值，触发变更检测并检查预期的结果。</p><blockquote class="ng nh ni"><p id="fd90" class="ie if nf ig b ih ii ij ik il im in io nj iq ir is nk iu iv iw nl iy iz ja jb ha bi translated">我们使用Jasmine的异步测试支持，使用Jasmine 2中引入的<em class="hh"> done </em>。如果你不熟悉它，请阅读<a class="ae lu" href="http://jasmine.github.io/2.4/introduction.html#section-Asynchronous_Support" rel="noopener ugc nofollow" target="_blank">这个</a>。我们要用几次。</p></blockquote><h2 id="58b7" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">测试服务</h2><p id="6a90" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated"><em class="nf"> LanguagesService，</em>只有一个方法返回应用程序可用语言的数组。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="1258" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">类似于我们之前的例子，我们使用<em class="nf"> beforeEach实例化服务。</em>正如我们所说，这是<em class="nf"> </em>一个好的实践，即使我们只有一个规范。在这种情况下，我们正在检查每种语言和总计数。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><h2 id="45ef" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">使用Http进行测试</h2><p id="3e34" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">我们通常不希望在测试期间进行http调用，但是我们将展示它以供参考。我们已经将最初的服务<em class="nf"> LanguageService </em>替换为<em class="nf"> LanguageServiceHttp。</em></p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="c552" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，它使用<em class="nf"> http.get() </em>来读取一个json文件。然后我们使用<a class="ae lu" href="https://github.com/ReactiveX/RxJS/blob/master/src/operator/map.ts" rel="noopener ugc nofollow" target="_blank"><em class="nf">observable . map()</em></a><em class="nf"/>使用<em class="nf"> json()将响应转换成最终结果。</em></p><p id="a62c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的测试看起来与前一个非常相似。主要的区别是由于订阅，我们使用了异步测试，就像我们对组件所做的那样。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="eed3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="nf"> http.get() </em>返回我们可以订阅的可观察值。我们将在后面更详细地讨论可观察到的现象。</p><h2 id="5ac2" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">使用模拟后端进行测试</h2><p id="e2f3" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">一个更真实的用例是用一个<em class="nf"> MockBackend </em>代替http调用。为了做到这一点，我们可以使用<em class="nf"> provide </em>来创建一个新的实例，每次我们使用<em class="nf"> useFactory </em>实例化<em class="nf"> Http </em>并提供必要的管道(第9–11行)<em class="nf">。</em>这个<em class="nf"> </em>将允许我们模拟我们的响应，避免触及真正的后端来推进我们的测试。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="b5ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的测试中，我们构建了模拟响应(第22–24行),因此当我们最终调用我们的服务时，它会得到预期的结果。</p><h2 id="2e84" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">测试指令</h2><p id="e733" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">Angular中的指令是一种特殊类型的组件，通常没有附带视图。我们将使用一个<a class="ae lu" href="https://angular.io/docs/ts/latest/guide/attribute-directives.html" rel="noopener ugc nofollow" target="_blank">属性指令</a>、<em class="nf"> logClicks、</em>来记录我们在<strong class="ig hi">、<em class="nf">主机元素</em>、</strong>上点击了多少次，这样您就可以理解了。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="8f5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了测试这个指令，我们决定创建一个<em class="nf">容器</em>组件。我们将对它进行设置，使它充当我们的主机，再现由我们的指令发出的事件。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="df52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在每个之前使用<em class="nf">来将创建组件的逻辑从测试中分离出来。该器件现在可用于所有规格。</em></p><p id="c344" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用<strong class="ig hi"><em class="nf">inject async</em></strong><em class="nf"/>作为异步创建的夹具。<em class="nf"> injectAsync </em>要求我们返回一个<em class="nf">承诺</em>。在这个实例中，我们正在返回由<em class="nf"> createAsync </em>返回的<em class="nf">承诺</em>。只有在它被解决后，它才会开始运行规范。</p><blockquote class="nm"><p id="d373" class="nn no hh bd np nq nr ns nt nu nv jb dx translated">我们也可以使用injectAsync返回一个承诺来处理异步测试</p></blockquote><h2 id="a937" class="mo ka hh bd kb mp om mr kf ms on mu kj ip oo mw kn it op my kr ix oq na kv nb bi translated">测试管道</h2><p id="44ac" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">管道是将输入数据转换成用户可读格式的函数。我们将使用标准的<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase" rel="noopener ugc nofollow" target="_blank"><em class="nf">string . toupper case</em></a><em class="nf">()</em>编写一个自定义的大写管道，<em class="nf">大写，</em>。这只是为了简单起见，因为angular有自己的<a class="ae lu" href="https://angular.io/docs/ts/latest/api/common/UpperCasePipe-class.html" rel="noopener ugc nofollow" target="_blank"><em class="nf">upper case pice</em></a><em class="nf"/>实现。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="dc58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">管道只是可以注入的普通类，所以我们可以使用<em class="nf">注入</em>非常容易地设置我们的规范。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="1a9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了测试我们的管道，我们检查了常见的情况:不使用字符串时抛出，应该使用空字符串，最后应该大写。请注意，我们必须使用箭头函数来捕获<em class="nf"> expect </em>中的异常。</p><h2 id="0bc9" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">测试路线</h2><p id="ff80" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">路线有时会被遗漏，但这通常被视为复式簿记的良好做法。在我们的例子中，我们将使用一个简单的路由配置，只有几个路由和一个指向home的默认路由。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="5467" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的测试将使用上面的这些路线来检验我们的期望。最后一个捕获所有剩余的路由，并将它们重定向到home。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="9999" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了测试路由，我们需要包含一些内部依赖项(第6–9行)。注意我们是如何定义根组件的(第9行)。这些可能很快会被重构，但是你现在可以使用它们。在每个之前，我们在<em class="nf">内实例化了<em class="nf">路由器</em>和<em class="nf">位置</em>，使我们的测试更具可读性。</em></p><p id="2fd8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们用<strong class="ig hi"><em class="nf">navigate(params)</em></strong><em class="nf"/>和<em class="nf"/><strong class="ig hi"><em class="nf">navigateByUrl(URL)</em></strong><em class="nf"/>都返回一个<em class="nf">的承诺</em>。我们检查当我们导航到'<em class="nf"> /home' </em>时，我们的位置会相应地改变。最后，我们检查是否有任何其他路线将您引回家。我们像以前一样使用Jasmine的异步测试。</p><h2 id="59a4" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">测试可观测量</h2><p id="d28a" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">Angular中使用可观测量来处理异步任务。它们可以在一些地方看到，比如<em class="nf"> Http </em>，表单控件，验证或者在<em class="nf"> EventEmitter </em>后面。我们将使用下面的<em class="nf">可观察的</em>来展示我们如何测试它们的行为。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="cdc7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们创建了一个<em class="nf">可观察的</em>，它发出1，2，3并完成。为了测试它，我们设置了next，error并在subscribe上完成回调。由于下一次回调将被调用几次，我们必须动态地设置我们的期望。请注意我们如何在<em class="nf">完成</em>的情况下再次使用Jasmines异步测试。</p><h2 id="3882" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">测试事件发射器</h2><p id="b827" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">EventEmitters在Angular中用于在组件之间传递事件。我们创建了一个计数器组件，<em class="nf"> Counter </em>，<em class="nf"> </em>，它允许我们递增或递减初始值0。每次我们这样做的时候，新的值将会被使用一个<em class="nf">事件发射器</em>推送，当<em class="nf">改变</em>时被暴露。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="f8c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">设置将非常类似于Observables。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="4fe2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，我们检查是否可以在<em class="nf"> EventEmitter </em>上使用subscribe来递增或递减，因为它公开了一个<em class="nf">可观察对象</em>。我们通过调用change方法触发不同的值，并在下一次回调中检查我们的期望。</p><p id="7ebc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是我现在所知道的！感谢阅读！有什么问题吗？在<a class="ae lu" href="https://twitter.com/intent/user?screen_name=gerardsans" rel="noopener ugc nofollow" target="_blank"> @gerardsans </a>给我发短信</p><h2 id="0782" class="mo ka hh bd kb mp mq mr kf ms mt mu kj ip mv mw kn it mx my kr ix mz na kv nb bi translated">想要更多吗？</h2><p id="e872" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">如果您需要更多示例，请随时通过<em class="nf">Gerard _ dot _ sans _ at _ Gmail _ dot _ com</em>联系我，或者前往GitHub中的<a class="ae lu" href="https://github.com/angular/angular/tree/e748adda2e7a1f6e302628d0d76b5c3d1e3fc196/modules/angular2/test" rel="noopener ugc nofollow" target="_blank">角度单元测试</a>！</p><div class="lc ld ez fb le lf"><a href="http://www.meetup.com/AngularZone/" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="bd hi fi z dy lk ea eb ll ed ef hg bi translated">安古拉宗社区</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">欢迎来到我们的社区。我们的激情是有棱角的。加入我们吧！🚀</h3></div></div><div class="lo l"><div class="or l lq lr ls lo lt jm lf"/></div></div></a></div><h1 id="fa76" class="jz ka hh bd kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw bi translated">进一步阅读</h1><ul class=""><li id="c518" class="lv lw hh ig b ih kx il ky ip nc it nd ix ne jb ma mb mc md bi translated">幻灯片:<a class="ae lu" href="https://docs.google.com/presentation/d/1UkuJgBaOAjDMYiMBLT38LEWMzh6sW_iliTPF1PHnmzY" rel="noopener ugc nofollow" target="_blank">带角度的测试策略</a>或<a class="ae lu" href="https://www.youtube.com/watch?v=C0F2E-PRm44" rel="noopener ugc nofollow" target="_blank">视频</a>朱莉·拉夫，<a class="ae lu" href="https://twitter.com/SomeJulie" rel="noopener ugc nofollow" target="_blank"> @SomeJulie </a></li><li id="de67" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated"><a class="ae lu" href="http://angularconnect.com/sessions" rel="noopener ugc nofollow" target="_blank"> Angular Connect Media </a>所有会议的幻灯片和视频</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><a href="https://twitter.com/intent/user?screen_name=gerardsans"><div class="er es os"><img src="../Images/abefda0aa7864742686ec7f7fdffe2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K1tQhWBuVOdzR7OAGvyd8Q.png"/></div></a></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ot"><img src="../Images/f77e66796b94b3e2ad0405bc2ffe730a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_QiTtWCVSuc8TSjsYGuHg.png"/></div></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ou"><img src="../Images/67b37e5d672384f0953563450fca0029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uNeEFxYiwJq8RfiDCsI-Xg.gif"/></div></div></figure></div></div>    
</body>
</html>