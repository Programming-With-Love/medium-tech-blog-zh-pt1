<html>
<head>
<title>Focus in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack撰写中的焦点</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/focus-in-jetpack-compose-6584252257fe?source=collection_archive---------1-----------------------#2021-06-16">https://medium.com/google-developer-experts/focus-in-jetpack-compose-6584252257fe?source=collection_archive---------1-----------------------#2021-06-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="b6d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">真正开始写作需要心态的转变。当你开始以正确的方式思考时，使用声明式用户界面会非常快，而且很有收获。训练自己摆脱旧习惯需要时间，重新学习如何做事。Compose中的焦点管理与我们在普通的旧Android中所习惯的略有不同，所以让我们来看看！</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/06b4af7404e9b697a9d7bd16f2a236d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e7wMpsqnOkqHGS1iDsfd3g.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx">Photo by <a class="ae js" href="https://unsplash.com/@stefanbc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Stefan Cosma</a> on <a class="ae js" href="https://unsplash.com/s/photos/focus?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a478" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">设置场景</h1><p id="ec18" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">有一段时间，我一直在做一个<a class="ae js" href="https://github.com/jamiesanson/tick" rel="noopener ugc nofollow" target="_blank">待办事项应用</a>作为兼职项目。这个应用程序可以做很多有趣的事情，它的UI完全是在Compose中构建的。暂且抛开所有花里胡哨的东西，让我们<em class="kw">聚焦</em>使用这款app的核心体验。下面是描述基本待办事项列表的一段代码。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="fe34" class="lc ju hh ky b fi ld le l lf lg">LazyColumn {<br/>    items(todos) { todo -&gt; <br/>        TodoRow(<br/>            text = todo.text,<br/>            isDone = todo.isDone, <br/>	    callbacks = TodoCallbacks(/* For things a row can do */)<br/>        )<br/>    } <br/>}</span></pre><p id="9708" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我今天早上开始改善这个列表的导航性。除了键盘之外，添加和删除待办事项应该是快速而简单的。这张gif展示了我所追求的行为类型，来自Google Keep。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="ab fe cl lh"><img src="../Images/ce33513e57e1bf0db2c9ec4739f16a7d.png" data-original-src="https://miro.medium.com/v2/1*YPLa0Pi0ojMJieGNlCIqBQ.gif"/></div></figure><p id="4547" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简而言之，如果我正在输入一件需要做的事情，然后按enter键，我希望我的光标移动到一个新的行，有一个新的todo项。如果我完全退格退出一个项目，我希望这个项目被删除，我的光标移动到上面的行。很明显，我们需要管理焦点，所以让我们看看我们的选择。</p><h1 id="abf6" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">焦点管理器</h1><p id="bd03" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">Compose UI包含一个<code class="du li lj lk ky b">FocusManager</code>类型，允许您在一次调用中推动焦点，非常适合简单的内容遍历。</p><p id="cdf3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，您可能在一个表单中有一个简单的<code class="du li lj lk ky b">TextField</code>列，当用户按下键盘上的“next”按钮时，您希望在其中导航。<code class="du li lj lk ky b">FocusManager</code>将为你遍历你的关注层次，并在你要求的方向上找到下一件要关注的事情。下面是一些代码，用<code class="du li lj lk ky b">FocusDirection.Down</code>将焦点移到列表中的下一个字段。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="fdec" class="lc ju hh ky b fi ld le l lf lg">Column {<br/>    val focusManager = LocalFocusManager.current<br/><br/>    for (i in 1..4) {<br/>        TextField(<br/>            // ...<br/>            keyboardActions = KeyboardActions(<br/>                onNext = {<br/>                     focusManager.moveFocus(FocusDirection.Down)<br/>                }    <br/>            )<br/>        )<br/>    }	<br/>}</span></pre><p id="af6a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你想让<code class="du li lj lk ky b">Down</code>表示列表中下一个元素以外的东西呢？或者您希望您的自定义可组合组件是可聚焦的？好吧，你很幸运，因为焦点修改器是<code class="du li lj lk ky b">FocusManager</code>的基础，可以用于任何事情。</p><h1 id="356e" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">焦点修改器</h1><p id="005b" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">您可以通过几个不同的修改器与Compose中的焦点机制进行交互</p><ul class=""><li id="8f88" class="ll lm hh ig b ih ii il im ip ln it lo ix lp jb lq lr ls lt bi translated"><code class="du li lj lk ky b">Modifier.focusTarget()</code> —这允许你使组件可聚焦</li><li id="dd50" class="ll lm hh ig b ih lu il lv ip lw it lx ix ly jb lq lr ls lt bi translated"><code class="du li lj lk ky b">Modifier.focusOrder()</code> —与<code class="du li lj lk ky b">FocusRequester</code> s结合使用，您可以改变对焦顺序</li><li id="7864" class="ll lm hh ig b ih lu il lv ip lw it lx ix ly jb lq lr ls lt bi translated"><code class="du li lj lk ky b">Modifier.focusRequester()</code> —添加一个自定义<code class="du li lj lk ky b">FocusRequester</code>，允许您观察焦点状态，并为单个组件请求焦点</li><li id="6bcd" class="ll lm hh ig b ih lu il lv ip lw it lx ix ly jb lq lr ls lt bi translated"><code class="du li lj lk ky b">Modifier.onFocusEvent()</code>、<code class="du li lj lk ky b">Modifier.onFocusChanged()</code> —观察聚焦状态内部或实际变化的更简单方法</li></ul><p id="4918" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了理解这些是如何工作的，让我们看一些例子。</p><h2 id="6ca7" class="lc ju hh bd jv lz ma mb jz mc md me kd ip mf mg kh it mh mi kl ix mj mk kp ml bi translated">用<code class="du li lj lk ky b">onFocusChanged</code>观察聚焦状态</h2><p id="873b" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated"><code class="du li lj lk ky b">onFocusChanged</code>允许您对影响您的组件或其子组件的焦点变化做出反应:</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="2544" class="lc ju hh ky b fi ld le l lf lg">TextField(<br/>    value = "My text field",<br/>	onValueChange = { },<br/>	modifier = Modifier.onFocusChanged { focusState -&gt; <br/>        when {<br/>            focusState.isFocused -&gt; <br/>                println("I'm focused!")<br/>            focusState.hasFocus -&gt; <br/>                println("A child of mine has focus!")<br/>        }<br/>    }<br/>)</span></pre><p id="ff30" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以通过<code class="du li lj lk ky b">onFocusEvent</code>修改器获得更细粒度的更改，每当内部焦点状态被写入时，该修改器将发出一个新的<code class="du li lj lk ky b">FocusState</code>。</p><h2 id="0a42" class="lc ju hh bd jv lz ma mb jz mc md me kd ip mf mg kh it mh mi kl ix mj mk kp ml bi translated">为自定义布局实现聚焦</h2><p id="3688" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">当实现一个定制的可组合组件时，你可以使它具有可聚焦的交互性。既然这样，<code class="du li lj lk ky b">focusTarget()</code>就是你的朋友！</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="7a84" class="lc ju hh ky b fi ld le l lf lg">@Composable<br/>fun CoolFocusableGraph(modifier: Modifier = Modifier) {<br/>    // Make ensure our laid out component is focusable, and <br/>    // observe focus events to make it interactive<br/>    val customComponentModifier = modifier<br/>        .focusTarget() // Now focusable!<br/>        .onFocusEvent { TODO("React to events") }<br/>        .drawBehind { TODO("Draw something cool") }<br/> <br/>    Layout(<br/>        content = {},<br/>        modifier = customComponentModifier,<br/>        measurePolicy = TODO()<br/>    )<br/>}</span></pre><h2 id="133f" class="lc ju hh bd jv lz ma mb jz mc md me kd ip mf mg kh it mh mi kl ix mj mk kp ml bi translated">更改焦点顺序</h2><p id="b5d1" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">有些情况下，您可能希望焦点顺序不同于默认顺序。在大多数情况下，这是不可取的，但如果你需要它，这里是如何做到这一点。一个不好的例子可能是当字段填充了有效数据时跳过它们。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="0afb" class="lc ju hh ky b fi ld le l lf lg">// First, get a reference to two focus requesters<br/>val (first, second) = FocusRequester.createRefs()<br/><br/>Column {<br/>    // Down should take us to the third component<br/>    TextField(<br/>        ...<br/>        modifier = Modifier.focusOrder(first) { down = second }<br/>    )<br/><br/>    // Skip this one when moving in the "down" direction<br/>    TextField(...)<br/><br/>    // Set the requester to tie them together<br/>    TextField(<br/>        ...<br/>        modifier = Modifier.focusOrder(second)<br/>    )<br/>}</span></pre><h2 id="73f7" class="lc ju hh bd jv lz ma mb jz mc md me kd ip mf mg kh it mh mi kl ix mj mk kp ml bi translated">以编程方式请求特定组件的焦点</h2><p id="5d7a" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">更不明智的是，你可以选择自己管理焦点！如果您不够小心，这可能是一个坏主意，因为很容易错过焦点遍历应该如何工作的微妙之处。如果您足够小心，您最终会在不使用焦点内部机制的情况下重新实现焦点遍历逻辑——这并不有趣。总的来说，尽可能多的尝试一下<code class="du li lj lk ky b">FocusManager</code>是值得的。</p><p id="a5a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果这绝对是您需要做的事情，那么您可以使用带有<code class="du li lj lk ky b">focusRequester()</code>修饰符的<code class="du li lj lk ky b">FocusRequester</code>以编程方式请求特定组件的焦点。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="5711" class="lc ju hh ky b fi ld le l lf lg">// Focus could be part of your state<br/>data class InputField(val text: String, val isFocused: Boolean)<br/><br/>@Composable <br/>fun InputRow(item: InputField) {<br/>    val requester = FocusRequester()<br/><br/>    TextField(<br/>        ...<br/>        modifier = Modifier.focusRequester(requester)<br/>    )<br/><br/>    // Request focus as a SideEffect (after the composition)<br/>    SideEffect {<br/>        if (item.isFocused) {<br/>            requester.requestFocus()<br/>        }<br/>    }<br/>}</span></pre><h1 id="be45" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">遍历待办事项列表</h1><p id="c756" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">现在，我们已经看到了focus的所有内容，让我们尝试将它应用到我们的todo list问题中。</p><p id="a3b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我想要的解决方案是<code class="du li lj lk ky b">FocusManager</code>，当添加或删除项目时，我试图向上或向下移动焦点。这对于删除项目非常有效，因为下一个焦点目标已经存在。当把焦点转移到新添加的项目上时，事情开始变得有点复杂。我试图将焦点转移到一个目前并不存在的组件上，让我停留在原来的位置上。</p><p id="4a75" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我首先想到的解决办法是尝试在<code class="du li lj lk ky b">SideEffect</code>中运行<code class="du li lj lk ky b">focusManager.moveFocus</code>调用，这是一段在每次合成后运行的代码。这是有意义的，因为我有效地向外部发布了状态，但这使得事情变得更加棘手，因为我只想对添加到列表中的每个项目调用一次。实际上，我想要的是在一幅成功的作品中，项目列表发生变化后转移焦点。最终，我选择了<code class="du li lj lk ky b">LaunchedEffect</code>和<code class="du li lj lk ky b">focusManager.moveFocus</code>调用的组合，只在项目列表改变时才移动焦点。完整的代码可以在下面看到。</p><pre class="jd je jf jg fd kx ky kz la aw lb bi"><span id="a48c" class="lc ju hh ky b fi ld le l lf lg">@Composable<br/>fun ListScreen(lists: List&lt;TodoList&gt;) {<br/>    // Get a reference to the current FocusManager<br/>    val focusManager = LocalFocusManager.current<br/>    var focusDirectionToMove by remember { mutableStateOf&lt;FocusDirection?&gt;(null) }<br/>    <br/>    // Redux dispatch - stay tuned for a blog about this<br/>    val dispatch = LocalDispatch.current<br/><br/>    // When add or remove events are dispatched, move the focus<br/>    val wrappedDispatch: (Any) -&gt; Any = { action -&gt;<br/>        when (action) {<br/>            is Action.AddTodo, <br/>            is Action.AddTodoAsSibling -&gt; <br/>                focusDirectionToMove = FocusDirection.Down<br/>            is Action.DeleteTodo -&gt; <br/>                focusDirectionToMove = FocusDirection.Up<br/>        }<br/><br/>        dispatch(action)<br/>    }<br/><br/>    // My list of items<br/>    TodoListColumn(lists, wrappedDispatch)<br/><br/>    // If we've previously asked to move the focus, do it when<br/>    // the lists parameter changes<br/>    LaunchedEffect(lists) {<br/>        focusDirectionToMove?.let(focusManager::moveFocus)<br/>        focusDirectionToMove = null<br/>    }<br/>}</span></pre></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><p id="abd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">聚焦是一个棘手的问题，如果处理不当，可能会对用户产生负面影响。Compose中的focus APIs允许您配置任意多或任意少的焦点——希望这能让您了解什么是可能的！</p><p id="2222" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你想看更多，请关注我的<a class="ae js" rel="noopener" href="/@jamiesanson">媒体</a>。或者，我会交叉发布到我自己的个人博客上，我偶尔会发微博。</p></div></div>    
</body>
</html>