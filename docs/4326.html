<html>
<head>
<title>Advanced FP for the Enterprise Bee: Traverse</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向企业Bee的高级FP:Traverse</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-traverse-b5e4e8b7b8e4?source=collection_archive---------2-----------------------#2021-01-08">https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-traverse-b5e4e8b7b8e4?source=collection_archive---------2-----------------------#2021-01-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8f1878e1727e20bfb57c44ec61c4c972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GAhKVPMXbQExcEhYho3XzQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Honey Bees in Hive</figcaption></figure><h1 id="8ee7" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">介绍</h1><p id="6e21" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">本文是我们通过Kotlin介绍高级FP概念的系列文章的第一篇。目标受众是像我这样的企业开发人员，我们行业的工蜂。</p><p id="d62e" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">我打算把重点放在实际应用上(不管它们有多简陋)，把理论推迟到必要的时候。后期评价毕竟很FP…</p><p id="97dc" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">在这篇文章中，我想为这个系列做个铺垫，然后从介绍<em class="ku">遍历</em>开始。所有显示的代码都可以通过这个公共库在<a class="ae kv" href="https://bitbucket.org/instilco/advanced-fp-gde/src/master/" rel="noopener ugc nofollow" target="_blank">获得。</a></p><h1 id="d1f4" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">搭建舞台</h1><p id="0862" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">马拉松跑步、音乐、武术和编程有什么共同点？它们都有大量参与者退出的“退出点”。典型的退出点出现在一个有意义的目标已经达到，但是到下一个目标的距离令人生畏的时候。</p><p id="7a6a" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">例如，许多人开始跑步健身，但一旦达到特定水平就放弃了。我相信你知道有人跑完一场马拉松后就把运动鞋挂了起来。</p><p id="6bd8" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">在编码中，退出点存在于个别语言中，比如<a class="ae kv" href="http://blog.fogus.me/2011/09/02/scala-is-for-drivers/" rel="noopener ugc nofollow" target="_blank"> Scala的《疯狂的悬崖》</a>。但是它们也适用于一般的编程风格。Lambda Conf发布了一个函数式编程的<a class="ae kv" href="https://pbs.twimg.com/media/CydL5EYUsAAI-61.jpg:large" rel="noopener ugc nofollow" target="_blank">阶梯</a>来记录FP的实现水平。这既吓人又能增长见识，所以我建议多加几个梯级，让攀登不那么令人担忧。</p><p id="a8a0" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">就我个人而言，我将FP中的学习水平分类如下:</p><ol class=""><li id="36e9" class="kw kx hh jt b ju kp jy kq kc ky kg kz kk la ko lb lc ld le bi translated">Lambdas和核心运算符(<em class="ku">过滤器</em>、<em class="ku">映射</em>和<em class="ku"> forEach </em>)</li><li id="dcad" class="kw kx hh jt b ju lf jy lg kc lh kg li kk lj ko lb lc ld le bi translated">标准FP工具包(<em class="ku"> flatMap </em>、<em class="ku"> reduce </em>、<em class="ku"> partition </em>等)</li><li id="dd25" class="kw kx hh jt b ju lf jy lg kc lh kg li kk lj ko lb lc ld le bi translated">自定义高阶函数、currying和部分调用</li><li id="bb3f" class="kw kx hh jt b ju lf jy lg kc lh kg li kk lj ko lb lc ld le bi translated">功能类型和组成(<em class="ku">选项</em>、<em class="ku">任一</em>、<em class="ku">验证</em>等)</li><li id="f426" class="kw kx hh jt b ju lf jy lg kc lh kg li kk lj ko lb lc ld le bi translated">这里有龙…</li></ol><p id="175a" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">许多人(相当正确地)在了解了当前项目所需的一切后就停止了。我将假设你在3级或4级左右，并且有兴趣学习更多。但是你是一个实用的程序员，不愿意容忍理论的海啸。所以我们从一个你可能没听说过的非常有用的操作符开始。</p><h1 id="189a" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">引入导线</h1><p id="b3d4" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">假设你有一个同事，他最近参加了一个Kotlin课程，导师[咳咳]技术高超且友好。作为其中的一部分，他们接触到了箭头框架及其功能数据类型。有一天你在代码库中发现了这个:</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="960c" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">显然，你的同事为了提供帮助，已经包装了<em class="ku"> getProperty </em>方法，以便它返回一个<em class="ku">或者</em>。如果属性存在，我们得到一个包含结果的右的<em class="ku">，否则是一个包含错误消息的左<em class="ku">。</em></em></p><p id="fe42" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">今天的工作要求您获取三个属性的值，因此您编写了一个Spike来进行测试:</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="8df9" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">以下是您得到的结果:</p><pre class="lk ll lm ln fd lq lr ls lt aw lu bi"><span id="e78c" class="lv iu hh lr b fi lw lx l ly lz">[Right(test1.txt), Right(test2.txt), Right(test3.txt)]<br/>[Right(test1.txt), Left(No JVM property: false), Right(test3.txt)]</span></pre><p id="d5da" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">很明显<em class="ku">列表</em>或者<em class="ku">列表</em>都是一件烦人的事情。有一些操作符，如<em class="ku">所有</em>、<em class="ku">任何</em>、<em class="ku">过滤器</em>和<em class="ku">分区</em>，可以用来处理<em class="ku">左</em>和<em class="ku">右</em>值。但它仍然是粗糙的代码。</p><p id="1485" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">你会想到这与你所需要的正好相反。理想情况下，您会希望有一个函数能为您提供以下功能之一:</p><ul class=""><li id="e798" class="kw kx hh jt b ju kp jy kq kc ky kg kz kk la ko ma lc ld le bi translated">一个<em class="ku">右侧</em>包含一个结果列表</li><li id="7bb6" class="kw kx hh jt b ju lf jy lg kc lh kg li kk lj ko ma lc ld le bi translated">包含错误信息的<em class="ku">左侧</em></li></ul><p id="408c" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">这是<em class="ku">遍历</em>提供的服务。</p><h1 id="8ff0" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">运行中的遍历</h1><p id="5043" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">这是一个我们想要的实现:</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="af90" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">我们获取一个属性名列表，然后<em class="ku">遍历</em>，而不是<em class="ku">映射</em>。这具有转换类型的效果。<strong class="jt hi">如果一切正常，返回的将是一个<em class="ku">右&lt;列表&gt; </em>而不是一个<em class="ku">列表&lt;右&gt; </em>。</strong></p><p id="2c9f" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">因为调用的结果现在是一个<em class="ku">或者</em>我们可以<em class="ku">折叠</em>在它上面。我们传入两个lambdas或函数，第一个在失败时被调用，第二个在成功时被调用。记住这一点的简单方法是<strong class="jt hi">右</strong>输入处理<strong class="jt hi">右</strong>结果。</p><p id="e5ce" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">让我们尝试一下，以确保:</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="6a09" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">这是结果输出。如您所见，这正是我们所需要的:</p><pre class="lk ll lm ln fd lq lr ls lt aw lu bi"><span id="9383" class="lv iu hh lr b fi lw lx l ly lz">Results are:<br/> test1.txt<br/> test2.txt<br/> test3.txt<br/>No JVM property: false<br/>No JVM property: false<br/>No JVM property: false</span></pre><h1 id="cb85" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">调查我们的成功</h1><p id="b5a5" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">万岁。所以<em class="ku">遍历</em>的目的是反转我们正在处理的类型。</p><p id="0644" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">我们在以下情况下使用导线:</p><ul class=""><li id="e74d" class="kw kx hh jt b ju kp jy kq kc ky kg kz kk la ko ma lc ld le bi translated">我们正在迭代一个值列表</li><li id="5166" class="kw kx hh jt b ju lf jy lg kc lh kg li kk lj ko ma lc ld le bi translated">我们需要对每个值应用一个动作</li><li id="fba3" class="kw kx hh jt b ju lf jy lg kc lh kg li kk lj ko ma lc ld le bi translated">该动作返回一个<em class="ku"> Foo </em>容器</li><li id="b121" class="kw kx hh jt b ju lf jy lg kc lh kg li kk lj ko ma lc ld le bi translated">我们想要一个<em class="ku">Foo&lt;List&gt;T55】，而不是一个<em class="ku">List&lt;Foo&gt;T57】</em></em></li></ul><p id="974d" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">在这种情况下，动作是<em class="ku"> propertyViaJVM </em>，容器是<em class="ku">或者</em>。调用<em class="ku">映射</em>会给我们一个<em class="ku">列表&lt;或者&gt; </em>，而调用<em class="ku">遍历</em>会给我们<em class="ku">的(更有用的)反转&lt;列表&gt; </em>。</p><p id="21dc" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">如果你更仔细地看代码，你会发现有两个神奇的方面。正如所承诺的，我们关注的是应用而不是理论，所以现在我们只能说:</p><ul class=""><li id="d207" class="kw kx hh jt b ju kp jy kq kc ky kg kz kk la ko ma lc ld le bi translated">作为第一个参数传递给<em class="ku">遍历</em>的<em class="ku">应用</em>使其能够反转类型。每种类型都需要有特定的<em class="ku">适用</em>。</li><li id="874f" class="kw kx hh jt b ju lf jy lg kc lh kg li kk lj ko ma lc ld le bi translated">对<em class="ku"> fix </em>的调用是执行类型转换所必需的。在幕后，Arrow正在模仿一种叫做<em class="ku">的更高级的种类</em>。</li></ul><p id="be67" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">本系列的下两篇文章将详细讨论这些主题。但是我们已经知道的足够多了，可以继续看更复杂的例子。</p><h1 id="fe68" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">遍历和文件</h1><p id="d325" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">假设我们的函数朋友也负责从属性文件中检索值的代码:</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="6065" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">这里我们使用Java Streams API从给定的文件中读取适当的值。这又是一个被返回的<em class="ku">或</em>。如果一切顺利的话，这将是持有房产价值的权利。如果文件不能被读取，或者属性不存在，它将是一个包含错误信息的<em class="ku">左</em>。</p><p id="1072" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">我们再次需要读取三个属性的值。现在我们知道了秘密，我们可以直接跳到<em class="ku">遍历</em>。</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="b0cd" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">注意，代码几乎和以前一样。我们只需要管理一个文件名。让我们检查它的工作情况:</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="6bf0" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">以下是输出结果:</p><pre class="lk ll lm ln fd lq lr ls lt aw lu bi"><span id="fc03" class="lv iu hh lr b fi lw lx l ly lz">Results are:<br/> test1.txt<br/> test2.txt<br/> test3.txt<br/>No property called false<br/>No property called false<br/>No property called false<br/>No file called false.properties</span></pre><p id="46d4" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">遍历又一次让我们的生活变得更简单，让我们能够优雅地处理错误。</p><h1 id="f32a" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">进入单子</h1><p id="d464" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">因为<em class="ku">或者</em>是一个<em class="ku">单子</em>，我们可以以一种非常简洁的方式将调用组合在一起。</p><p id="bf6c" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">假设我们的任务有四个相互依赖的步骤，如下所示:</p><ol class=""><li id="8ab8" class="kw kx hh jt b ju kp jy kq kc ky kg kz kk la ko lb lc ld le bi translated">我们需要访问三个JVM属性的值</li><li id="a053" class="kw kx hh jt b ju lf jy lg kc lh kg li kk lj ko lb lc ld le bi translated">这些属性的值本身就是属性文件中使用的一个键</li><li id="d257" class="kw kx hh jt b ju lf jy lg kc lh kg li kk lj ko lb lc ld le bi translated">属性文件中保存的值是包含数据的文本文件的名称</li><li id="dba1" class="kw kx hh jt b ju lf jy lg kc lh kg li kk lj ko lb lc ld le bi translated">我们想读取并输出所有的数据</li></ol><p id="8cbd" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">这听起来工作量很大。但是根据我们目前所做的，这并不太难。首先，我们需要一个函数来尝试读取文件中的所有行:</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="f9c6" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">然后，我们可以将迄今为止所做的一切整合在一起:</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="00e2" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">这次我们使用<em class="ku">或者</em>函数将<em class="ku"> findViaJVM </em>、<em class="ku"> findViaFile </em>和<em class="ku"> readEverything </em>连接在一起。在底层，挂起函数被用来实现一元合成，但那是另一篇文章的主题。就目前而言，它能起作用就足够了。</p><p id="2e0e" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">为了证明这一点，这里有一个示例<em class="ku"> main </em>方法。请注意，因为<em class="ku">或者</em>正在挂起<em class="ku">去代理</em>和<em class="ku">主</em>也需要被挂起。</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="bd23" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">这些名字是对1970年警匪片的致敬。下面是属性文件的内容:</p><pre class="lk ll lm ln fd lq lr ls lt aw lu bi"><span id="b857" class="lv iu hh lr b fi lw lx l ly lz">cagney.lacy=test1.txt<br/>starsky.hutch=test2.txt<br/>hart.hart=test3.txt</span></pre><p id="a55f" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">当我们运行<em class="ku"> main </em>时，它成功地找到了正在打印出来的文件内容。</p><p id="ae7f" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">我们已经走了相当长的一段距离了！值得花点时间喝一杯含咖啡因的饮料，庆祝我们的了不起…</p><h1 id="ff97" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">切换到已验证</h1><p id="2532" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">到目前为止，在我们所有的代码中，我们一直使用<em class="ku">或者</em>类型来表示结果或者错误消息。这是完全合理的，但是<em class="ku">验证的</em>类型正是为了这个目的。所以我们可以重写现有的代码来使用它。</p><p id="b432" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">例如，下面是我们重构的<em class="ku"> propertyViaJVM </em>方法:</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="bf60" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated"><em class="ku"> demoTraverse </em>方法几乎没有变化。但是请注意，当我们创建<em class="ku">应用</em>时，我们还必须为字符串传递一个<em class="ku">半群</em>。这是因为<em class="ku">验证的</em>类型将提供额外的服务，将我们遇到的所有错误消息连接起来。</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="bf25" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">更广泛的一点是，我们可以使用任何一元类型的<em class="ku">遍历</em>。另一个很好的例子是执行几个网络操作，并获得一个<em class="ku">未来&lt;列表&gt; </em>而不是一个<em class="ku">列表&lt;未来&gt; </em>。由于目前似乎没有人同意HTTP客户端，我把它作为读者的可怕练习…</p><h1 id="cc91" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">结论</h1><p id="a790" class="pw-post-body-paragraph jr js hh jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ha bi translated">希望这篇文章已经将<em class="ku">遍历</em>添加到你的FP武库中，并且满足你的胃口，让你知道FP还能如何简化你的代码。这就是我打算涵盖的内容。但在此之前，我们需要巩固迄今取得的成就。</p><p id="50d5" class="pw-post-body-paragraph jr js hh jt b ju kp jw jx jy kq ka kb kc kr ke kf kg ks ki kj kk kt km kn ko ha bi translated">在本文中，我们使用了<em class="ku">应用</em>、<em class="ku">半群</em>和<em class="ku">更高级的类型、</em>，但没有正确定义它们是什么。本系列接下来的几篇文章将分别讨论这些问题。但是如果你想继续阅读<a class="ae kv" href="https://arrow-kt.io/docs/patterns/glossary/" rel="noopener ugc nofollow" target="_blank">，箭头注释</a>是一个很好的起点。下次见…</p></div></div>    
</body>
</html>