<html>
<head>
<title>Migrating the Google I/O app to Hilt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Google I/O应用程序移植到Hilt</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/migrating-the-google-i-o-app-to-hilt-f3edf03affe5?source=collection_archive---------0-----------------------#2020-07-20">https://medium.com/androiddevelopers/migrating-the-google-i-o-app-to-hilt-f3edf03affe5?source=collection_archive---------0-----------------------#2020-07-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f91553a6295ce307f0a2ece8aff97b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xs3Sms79TkxhV7WgvIWcag.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by Claudia Sanchez</figcaption></figure><div class=""/><p id="6d31" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">Hilt是建立在Dagger之上的新库，它简化了Android应用程序中的依赖注入(DI)。但是，<em class="jr">它简化了多少</em>？我们迁移了Google I/O app ( <a class="ae js" href="https://github.com/google/iosched/commit/9c20fdd52d446e5fdb03369e50fb196c31ae16e3" rel="noopener ugc nofollow" target="_blank"> iosched </a>)一探究竟，它已经用Dagger搭配<a class="ae js" href="https://dagger.dev/api/latest/dagger/android/package-summary.html" rel="noopener ugc nofollow" target="_blank"> dagger.android </a>。</p><p id="6330" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在本文中，我将介绍我们迁移这个特定应用程序的经验。有关正确和全面的说明，请查看<a class="ae js" href="https://dagger.dev/hilt/migration-guide" rel="noopener ugc nofollow" target="_blank">刀柄迁移指南</a>。</p><h1 id="24fd" class="jt ju hw bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi">-2000, +500</h1><p id="642a" class="pw-post-body-paragraph it iu hw iv b iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm kv jo jp jq ha bi translated">我们用500行代码代替了2000行DI代码。这不是唯一的成功标准，但是很有希望！</p><p id="f586" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这种减少怎么可能呢？我们使用dagger.android，它也承诺在android中减少一些样板文件。<strong class="iv hx">不同的是，希尔特要固执得多</strong>。它已经实现了一些适用于Android应用的概念。</p><p id="e381" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">例如，您不需要定义AppComponent。刀柄自带一堆<a class="ae js" href="https://dagger.dev/api/latest/dagger/hilt/android/components/package-summary.html" rel="noopener ugc nofollow" target="_blank">预定义组件</a>，包括<code class="du kw kx ky kz b">ApplicationComponent</code>、<code class="du kw kx ky kz b">ActivityComponent</code>或<code class="du kw kx ky kz b">FragmentComponent</code>。你仍然可以<a class="ae js" href="https://dagger.dev/hilt/custom-components" rel="noopener ugc nofollow" target="_blank">创造你自己的</a>当然，剑柄只是匕首上面的一个包装。</p><p id="1add" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们深入了解细节:</p><h1 id="dbee" class="jt ju hw bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Android组件和范围</h1><p id="4684" class="pw-post-body-paragraph it iu hw iv b iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm kv jo jp jq ha bi translated">Android中依赖注入的一个问题(实际上，一个普遍的烦恼)是组件，像活动一样，是由框架创建的。所以，为了注入依赖，你必须在创建之后以某种方式注入。通过让你调用<code class="du kw kx ky kz b">AndroidInjection.inject</code> (this)来简化这个过程，我们通过扩展<code class="du kw kx ky kz b">DaggerAppCompatActivity</code>或<code class="du kw kx ky kz b">DaggerFragment</code>来做到这一点。除此之外，我们有一个模块(<code class="du kw kx ky kz b"><a class="ae js" href="https://github.com/google/iosched/blob/d5b168fc724b53bbe602cf92978274d07f37ba3b/mobile/src/main/java/com/google/samples/apps/iosched/di/ActivityBindingModule.kt" rel="noopener ugc nofollow" target="_blank">ActivityBindingModule</a></code>)将定义dagger.android应该创建哪些子组件，它们的范围和所有包含在其中的模块，使用<code class="du kw kx ky kz b">@ContributesAndroidInjector</code>用于活动和片段:</p><p id="c0c9" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du kw kx ky kz b"><a class="ae js" href="https://github.com/google/iosched/blob/d5b168fc724b53bbe602cf92978274d07f37ba3b/mobile/src/main/java/com/google/samples/apps/iosched/di/ActivityBindingModule.kt" rel="noopener ugc nofollow" target="_blank">ActivityBindingModule.kt</a></code>:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="4370" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">此外，每个片段都有自己的子组件，也是用<code class="du kw kx ky kz b">@ContributesAndroidInjector</code>在它们自己的模块中生成的:</p><p id="924e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du kw kx ky kz b"><a class="ae js" href="https://github.com/google/iosched/blob/d5b168fc724b53bbe602cf92978274d07f37ba3b/mobile/src/main/java/com/google/samples/apps/iosched/ui/onboarding/OnboardingModule.kt" rel="noopener ugc nofollow" target="_blank">OnboardingModule.kt</a></code></p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="94db" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果你看看不同的dagger.android项目，它们都有相似的样板文件。</p><p id="c9da" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">使用Hilt，您只需移除<code class="du kw kx ky kz b">@ContributesAndroidInjector</code>绑定，并为所有需要注入依赖关系的Android组件(活动、片段、视图、服务和广播接收器)添加<code class="du kw kx ky kz b">@AndroidEntryPoint</code>注释。</p><p id="d3d1" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们拥有的大部分模块，超过20个，都可以被删除，因为它们只包含<code class="du kw kx ky kz b">@ContributesAndroidInjector</code>(像<a class="ae js" href="https://github.com/google/iosched/blob/d5b168fc724b53bbe602cf92978274d07f37ba3b/mobile/src/main/java/com/google/samples/apps/iosched/ui/signin/SignInDialogModule.kt" rel="noopener ugc nofollow" target="_blank"> OnboardingModule </a>)和ViewModel绑定(稍后会详细介绍)。现在您只需要将片段注释为入口点:</p><p id="f1b5" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du kw kx ky kz b"><a class="ae js" href="https://github.com/google/iosched/blob/9c20fdd52d446e5fdb03369e50fb196c31ae16e3/mobile/src/main/java/com/google/samples/apps/iosched/ui/onboarding/OnboardingFragment.kt" rel="noopener ugc nofollow" target="_blank">OnboardingFragment.kt</a></code>:</p><pre class="la lb lc ld fd lg kz lh li aw lj bi"><span id="e28e" class="lk ju hw kz b fi ll lm l ln lo"><strong class="kz hx">@AndroidEntryPoint</strong><br/>class OnboardingFragment : Fragment() {...</span></pre><p id="3a1b" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">对于其他类型的绑定，我们仍然使用模块来定义它们，它们需要用<code class="du kw kx ky kz b">@InstallIn</code>来注释。</p><p id="9523" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du kw kx ky kz b"><a class="ae js" href="https://github.com/google/iosched/blob/9c20fdd52d446e5fdb03369e50fb196c31ae16e3/mobile/src/main/java/com/google/samples/apps/iosched/ui/sessioncommon/SessionViewPoolModule.kt" rel="noopener ugc nofollow" target="_blank">SessionViewPoolModule.kt</a></code>:</p><pre class="la lb lc ld fd lg kz lh li aw lj bi"><span id="b86e" class="lk ju hw kz b fi ll lm l ln lo"><strong class="kz hx">@InstallIn(FragmentComponent::class)</strong><br/>@Module<br/>internal class SessionViewPoolModule {</span></pre><p id="d878" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">作用域的工作就像你所期望的那样，使用熟悉的预定义的<a class="ae js" href="https://dagger.dev/api/latest/dagger/hilt/android/scopes/package-summary.html" rel="noopener ugc nofollow" target="_blank">作用域</a>，比如<code class="du kw kx ky kz b">ActivityScoped</code>、<code class="du kw kx ky kz b">FragmentScoped</code>、<code class="du kw kx ky kz b">ServiceScoped</code>等。</p><p id="bbd8" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du kw kx ky kz b"><a class="ae js" href="https://github.com/google/iosched/blob/9c20fdd52d446e5fdb03369e50fb196c31ae16e3/mobile/src/main/java/com/google/samples/apps/iosched/ui/sessioncommon/SessionViewPoolModule.kt" rel="noopener ugc nofollow" target="_blank">SessionViewPoolModule.kt</a></code>:</p><pre class="la lb lc ld fd lg kz lh li aw lj bi"><span id="b4cb" class="lk ju hw kz b fi ll lm l ln lo"><strong class="kz hx">    @FragmentScoped</strong><br/>    @Provides<br/>    @Named("sessionViewPool")<br/>    fun providesSessionViewPool(): RecyclerView.RecycledViewPool = RecyclerView.RecycledViewPool()</span></pre><p id="9198" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">另一个去除样板文件的工具是预定义的限定符，比如<code class="du kw kx ky kz b">@ApplicationContext</code>或<code class="du kw kx ky kz b">@ActivityContext</code>，这样你就不必在所有应用程序中创建相同的绑定。</p><pre class="la lb lc ld fd lg kz lh li aw lj bi"><span id="abb5" class="lk ju hw kz b fi ll lm l ln lo">    @Singleton<br/>    @Provides<br/>    fun providePreferenceStorage(<br/>        <strong class="kz hx">@ApplicationContext</strong> context: Context<br/>): PreferenceStorage = SharedPreferenceStorage(context)</span></pre><h1 id="b90f" class="jt ju hw bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Android架构组件</h1><p id="d53e" class="pw-post-body-paragraph it iu hw iv b iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm kv jo jp jq ha bi translated">Hilt真正闪光的地方是它与架构组件的集成。支持<a class="ae js" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank">视图模型</a>和工作管理器<a class="ae js" href="https://developer.android.com/reference/kotlin/androidx/work/Worker" rel="noopener ugc nofollow" target="_blank">工作器</a>的注入。</p><p id="d3c2" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在使用Hilt之前，这样做需要对Dagger有深刻的理解(或者良好的复制粘贴技能，因为大多数项目都有相同的设置)。</p><p id="4efa" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">首先，我们为片段和活动提供了一个视图模型工厂，以通过视图模型提供者获得视图模型:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="df9b" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">使用Hilt，我们可以用一行代码获得视图模型的片断:</p><pre class="la lb lc ld fd lg kz lh li aw lj bi"><span id="4c80" class="lk ju hw kz b fi ll lm l ln lo">private val viewModel: AgendaViewModel by viewModels()</span></pre><p id="a73e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">或者，如果您想将范围扩大到父活动:</p><pre class="la lb lc ld fd lg kz lh li aw lj bi"><span id="e921" class="lk ju hw kz b fi ll lm l ln lo">private val mainActivityViewModel: MainActivityViewModel by activityViewModels()</span></pre><p id="538d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">其次，在使用Hilt之前，在视图模型中使用注入的依赖项需要使用一个复杂的多绑定设置<code class="du kw kx ky kz b">ViewModelKey</code>:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="d43b" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在每个模块中，您应该这样提供:</p><p id="ebc7" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><code class="du kw kx ky kz b"><a class="ae js" href="https://github.com/google/iosched/blob/d5b168fc724b53bbe602cf92978274d07f37ba3b/mobile/src/main/java/com/google/samples/apps/iosched/ui/sessiondetail/SessionDetailModule.kt" rel="noopener ugc nofollow" target="_blank">SessionDetailModule.kt</a></code>:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="bf9d" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">使用Hilt，我们将<code class="du kw kx ky kz b">@ViewModelInject</code>注释添加到ViewModel的构造函数中。就是这样。无需在模块中定义它们，也无需将它们添加到魔法地图中。</p><pre class="la lb lc ld fd lg kz lh li aw lj bi"><span id="4b16" class="lk ju hw kz b fi ll lm l ln lo">class SessionDetailViewModel <strong class="kz hx">@ViewModelInject</strong> constructor(...) { … }</span></pre><p id="c625" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注意，这是<a class="ae js" href="https://developer.android.com/training/dependency-injection/hilt-jetpack" rel="noopener ugc nofollow" target="_blank"> Hilt和Jetpack集成</a>的一部分，你需要定义额外的依赖来使用它们。</p><h1 id="e15a" class="jt ju hw bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">测试</h1><h2 id="0942" class="lk ju hw bd jv lp lq lr jz ls lt lu kd je lv lw kh ji lx ly kl jm lz ma kp mb bi translated">单元测试</h2><p id="f814" class="pw-post-body-paragraph it iu hw iv b iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm kv jo jp jq ha bi translated">单元测试不会改变。您的架构应该允许独立于您如何创建对象图来测试您的类。</p><h2 id="bbfe" class="lk ju hw bd jv lp lq lr jz ls lt lu kd je lv lw kh ji lx ly kl jm lz ma kp mb bi translated">仪表测试—测试运行器设置</h2><p id="954c" class="pw-post-body-paragraph it iu hw iv b iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm kv jo jp jq ha bi translated">相对于Dagger来说，使用带柄的仪器化测试有所改变。这一切都从一个定制的测试运行程序开始，它允许您定义一个不同的测试应用程序:</p><p id="bcc5" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">之前:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="be1b" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">后的<a class="ae js" href="https://github.com/google/iosched/blob/9c20fdd52d446e5fdb03369e50fb196c31ae16e3/mobile/src/androidTest/java/com/google/samples/apps/iosched/tests/CustomTestRunner.kt" rel="noopener ugc nofollow" target="_blank">:</a></p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="3c30" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在<code class="du kw kx ky kz b">newApplication</code>方法中，我们需要返回<code class="du kw kx ky kz b">CustomTestRunner_Application</code>，而不是返回一个带有不同匕首图的测试应用程序。实际的测试应用程序在<code class="du kw kx ky kz b">@CustomTestApplication</code>注释中定义。只有当有一些重要的初始化工作要做时，才需要这个类。在我们的例子中，它是AndroidThreeTen，我们还添加了木材。</p><p id="b1d0" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">之前，我们必须告诉Dagger使用哪个<code class="du kw kx ky kz b">AndroidInjector</code>，并且我们可以扩展主应用程序:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="441e" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">有了Hilt，<code class="du kw kx ky kz b">MainTestApplication</code>不能扩展你现有的应用程序，因为它已经用<code class="du kw kx ky kz b">@HiltAndroidApp</code>注释过了。我们需要创建一个新的<code class="du kw kx ky kz b">Application</code>，并在这里定义重要的初始化步骤:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="830b" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">测试到此为止。运行仪器测试时，该应用程序将取代<code class="du kw kx ky kz b">MainApplication</code>。</p><h1 id="1a41" class="jt ju hw bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">仪表测试—测试类别</h1><p id="2c5b" class="pw-post-body-paragraph it iu hw iv b iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm kv jo jp jq ha bi translated">实际的测试类也各不相同。由于我们不再有<code class="du kw kx ky kz b">AppComponent</code>(或<code class="du kw kx ky kz b">TestAppComponent</code>)，所有安装在预定义的<code class="du kw kx ky kz b">ApplicationComponent</code>中的模块和依赖项在测试时都是可用的。然而，您经常想要替换其中的一些模块。</p><p id="6ca9" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">例如，在iosched中，我们将<code class="du kw kx ky kz b">CoroutinesModule</code>替换为<code class="du kw kx ky kz b">TestCoroutinesModule</code>,使执行变平，因此它是同步的、可重复的和一致的。这个<code class="du kw kx ky kz b">TestCoroutinesModule</code>只是简单地添加到<code class="du kw kx ky kz b">androidTest</code>目录中，通常安装在<code class="du kw kx ky kz b">ApplicationComponent</code>中:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="d9b6" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">然而，此时我们会有“重复绑定”的错误，因为两个模块(<code class="du kw kx ky kz b">CoroutinesModule</code>和<code class="du kw kx ky kz b">TestCoroutinesModule</code>)可以提供相同的依赖关系。为了解决这个问题，我们只需使用<code class="du kw kx ky kz b">@UninstallModules</code>注释卸载测试类中的生产模块。</p><pre class="la lb lc ld fd lg kz lh li aw lj bi"><span id="a0c5" class="lk ju hw kz b fi ll lm l ln lo">@HiltAndroidTest<br/><strong class="kz hx">@UninstallModules(CoroutinesModule::class)<br/></strong>@RunWith(AndroidJUnit4::class)<br/>class AgendaTest {...</span></pre><p id="2df5" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">此外，我们需要向测试类添加<code class="du kw kx ky kz b">@HiltAndroidTest</code>注释和<code class="du kw kx ky kz b">@HiltAndroidRule</code> JUnit规则。但是有一件事你必须考虑到:</p><h1 id="ecc9" class="jt ju hw bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">HiltAndroidRule顺序</h1><p id="439c" class="pw-post-body-paragraph it iu hw iv b iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm kv jo jp jq ha bi translated">需要注意的一点是，必须在活动启动之前处理<code class="du kw kx ky kz b">HiltAndroidRule</code>。在任何其他规则之前运行它可能是一个好主意。</p><p id="5f26" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在JUnit 4.13之前，你可以使用<code class="du kw kx ky kz b">RuleChain</code>来定义顺序，但是我个人不喜欢外部/内部规则的概念。在4.13中，一个简单的<code class="du kw kx ky kz b">order</code>参数被添加到<code class="du kw kx ky kz b">@Rule</code>注释中，使得它们更具可读性:</p><figure class="la lb lc ld fd hj"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="fc49" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">请记住，如果您不定义顺序，您将引入一个竞争条件和一个微妙的错误，它可能会在最糟糕的时候出现。</p></div><div class="ab cl mc md go me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ha hb hc hd he"><h1 id="a700" class="jt ju hw bd jv jw mj jy jz ka mk kc kd ke ml kg kh ki mm kk kl km mn ko kp kq bi translated">应该用刀柄吗？</h1><p id="34da" class="pw-post-body-paragraph it iu hw iv b iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm kv jo jp jq ha bi translated">像Jetpack中发布的所有东西一样，Hilt是一种让你更快编写Android应用程序的方法，但它仍然是可选的。如果你对你的匕首技能有信心，你可能没有理由迁移。然而，如果你在一个多样化的团队中工作，不是每个人都吃多绑定的早餐，你应该考虑使用Hilt来简化你的代码库。构建时间相似，dex方法计数与dagger.android相似。</p><p id="691a" class="pw-post-body-paragraph it iu hw iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">同样，如果你不使用阿迪框架，现在正是时候。我推荐从<a class="ae js" href="https://codelabs.developers.google.com/codelabs/android-hilt" rel="noopener ugc nofollow" target="_blank"> codelab </a>开始，它没有假设任何匕首知识！</p></div></div>    
</body>
</html>