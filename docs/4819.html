<html>
<head>
<title>Programmer Dictionary: Delegation vs Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">程序员词典:委托vs组合</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/programmer-dictionary-delegation-vs-composition-3025d9e8ae3d?source=collection_archive---------2-----------------------#2018-02-08">https://blog.kotlin-academy.com/programmer-dictionary-delegation-vs-composition-3025d9e8ae3d?source=collection_archive---------2-----------------------#2018-02-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5169" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我在Kotlin 的<a class="ae ki" href="https://www.packtpub.com/application-development/android-development-kotlin" rel="noopener ugc nofollow" target="_blank"> Android开发中描述</a><a class="ae ki" href="https://kotlinlang.org/docs/reference/delegation.html#class-delegation" rel="noopener ugc nofollow" target="_blank"> <em class="kj">类委托</em> </a>时，我参考了像《有效的Java》这样的好书，这些书展示了这种解决方案相对于继承的优势。尽管“有效的Java”读者可能会感到困惑，因为这本书根本没有使用“委托”这个词。它在描述“作文”的优点。那么它的参数如何引用<em class="kj">类委托</em>特性呢？</p><p id="7004" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">答案是:完全正确。所有给出的例子都同时显示了委托和组合。实际上，<em class="kj">委托模式</em>需要构图！我们可以说<em class="kj">委托模式</em>是我们使用组合的一种方式。这些术语来自不同的概念，我们应该从这些概念出发来理解它。</p><p id="c54d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">组合术语用于对象建模。它表示对象之间的“有-有”关系。它通常与继承和聚合相对。当<code class="fe kk kl km kn b">Car</code>是一个对象时，我们说它组成了<code class="fe kk kl km kn b">Engine</code>。从实用的角度来看，我们可以说类中的每一个只读属性都是一个复合的例子。(读写属性很可能是聚合的一个例子。)</p><p id="c9a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">授权用于职责方面。当我们需要做某件事的时候，我们可以把这个责任委托给另一个对象。它通常与分派或转发相对。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/f8d3ee6fdbf6515ede5b8dc662102c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mcEhmX4vpTStQ2ny.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Image from <a class="ae ki" href="http://www.diplomacy.edu/" rel="noopener ugc nofollow" target="_blank">Diplo</a></figcaption></figure><p id="70d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基于委托思想，<em class="kj">委托模式</em>诞生了。在<em class="kj">委托模式</em>中，类将delegate作为只读属性，并将一些方法的调用传递给它。这里有一个例子:</p><pre class="kp kq kr ks gt le kn lf lg aw lh bi"><span id="fa94" class="li lj in kn b gy lk ll l lm ln"><strong class="kn io">class</strong> <strong class="kn io">Rectangle</strong>(<strong class="kn io">val</strong> height: Double, <strong class="kn io">val</strong> width: Double) {<br/>    <strong class="kn io">fun</strong> area() = height * width<br/>}<br/><br/><strong class="kn io">class</strong> <strong class="kn io">Square(val </strong>a: Double<strong class="kn io">)</strong> {<br/>    val rectangle = Rectangle(a, a)<br/>    <strong class="kn io">fun</strong> area() = rectangle.area()<br/>}</span></pre><p id="a55d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是<em class="kj">授权模式</em>的一个例子。让我们看看如何使用继承来代替:</p><pre class="kp kq kr ks gt le kn lf lg aw lh bi"><span id="e1ca" class="li lj in kn b gy lk ll l lm ln"><strong class="kn io">open class</strong> <strong class="kn io">Rectangle</strong>(<strong class="kn io">val</strong> height: Double, <strong class="kn io">val</strong> width: Double) {<br/>    <strong class="kn io">fun</strong> area() = height * width<br/>}</span><span id="466c" class="li lj in kn b gy lo ll l lm ln"><strong class="kn io">class</strong> <strong class="kn io">Square(val </strong>a: Double<strong class="kn io">): </strong>Rectangle(a, a)</span></pre><p id="e8cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们看继承用法时，它可能看起来像更好的实现。首先，它更短更简单。其次，我们有多态行为，允许我们接受<code class="fe kk kl km kn b">Square</code>和<code class="fe kk kl km kn b">Rectangle</code>:</p><pre class="kp kq kr ks gt le kn lf lg aw lh bi"><span id="daa5" class="li lj in kn b gy lk ll l lm ln"><strong class="kn io">fun </strong>printSize(shape: Rectangle) {<br/>    <em class="kj">println</em>(<strong class="kn io">"Size is ${</strong>shape.area()<strong class="kn io">}"</strong>)<br/>}<br/><br/>// Usage<br/><em class="kj">printSize</em>(Rectangle(10.0, 20.0)) // Size is 200.0<br/><em class="kj">printSize</em>(Square(10.0)) // Size is 100.0</span></pre><p id="ecc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了在<em class="kj">委托模式</em>中有类似的行为，我们需要引入一些对委托和委托的类通用的接口:</p><pre class="kp kq kr ks gt le kn lf lg aw lh bi"><span id="3937" class="li lj in kn b gy lk ll l lm ln"><strong class="kn io">interface Shape</strong>() {<br/>    <strong class="kn io">fun</strong> area(): Double<br/>}</span><span id="abab" class="li lj in kn b gy lo ll l lm ln"><strong class="kn io">class</strong> <strong class="kn io">Rectangle</strong>(<strong class="kn io">val</strong> height: Double, <strong class="kn io">val</strong> width: Double): Shape {<br/>    <strong class="kn io">override fun</strong> area() = height * width<br/>}<br/><br/><strong class="kn io">class</strong> <strong class="kn io">Square(val </strong>a: Double<strong class="kn io">)</strong>: Shape {<br/>    val rectangle = Rectangle(a, a)<br/>    <strong class="kn io">override fun</strong> area() = rectangle.area()<br/>}</span><span id="8020" class="li lj in kn b gy lo ll l lm ln"><strong class="kn io">fun </strong>printSize(shape: Shape) {<br/>    <em class="kj">println</em>(<strong class="kn io">"Size is ${</strong>shape.area()<strong class="kn io">}"</strong>)<br/>}<br/><br/>// Usage<br/><em class="kj">printSize</em>(Rectangle(10.0, 20.0)) // Size is 200.0<br/><em class="kj">printSize</em>(Square(10.0)) // Size is 100.0</span></pre><p id="e6de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是<em class="kj">委托模式</em>最常见的实现方式。请注意，在这里，而且在大多数情况下，object将某个接口中指定的方法委托给一个委托。这就是为什么接口可以用来指定我们想要委托的方法。这就是<em class="kj">类委托</em>背后的思想，它需要一个接口来指定哪些方法应该被委托:</p><pre class="kp kq kr ks gt le kn lf lg aw lh bi"><span id="e959" class="li lj in kn b gy lk ll l lm ln"><strong class="kn io">interface Shape</strong>() {<br/>    <strong class="kn io">fun</strong> area(): Double<br/>}</span><span id="52f2" class="li lj in kn b gy lo ll l lm ln"><strong class="kn io">class</strong> <strong class="kn io">Rectangle</strong>(<strong class="kn io">val</strong> height: Double, <strong class="kn io">val</strong> width: Double): Shape {<br/>    <strong class="kn io">override fun</strong> area() = height * width<br/>}<br/><br/><strong class="kn io">class</strong> <strong class="kn io">Square(val </strong>a: Double<strong class="kn io">)</strong>: Shape by Rectangle(a, a)</span></pre><p id="92ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了简短的语法和多态的行为。但是为什么我们应该选择这种实现而不是使用继承的实现呢？我在本讲座开始的<a class="ae ki" href="https://www.youtube.com/watch?v=8QgWSIaa_QU" rel="noopener ugc nofollow" target="_blank"/>和Kotlin书中的<a class="ae ki" href="https://www.packtpub.com/application-development/android-development-kotlin" rel="noopener ugc nofollow" target="_blank"> Android Development中给出了很长的答案。一个简短的回答是:因为从面向对象设计的角度来看，<code class="fe kk kl km kn b">Square</code>并不是真正的<code class="fe kk kl km kn b">Rectangle</code>。如果我们为<code class="fe kk kl km kn b">Rectangle</code>写测试，他们不会通过<code class="fe kk kl km kn b">Square</code>！<code class="fe kk kl km kn b">Square</code>未延长<code class="fe kk kl km kn b">Rectangle</code>。这是它的特例。继承的使用打破了面向对象设计的原则。特别是</a><a class="ae ki" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noopener ugc nofollow" target="_blank">利斯科夫替代原理</a>。在<code class="fe kk kl km kn b">Square</code>中我们还是可以用<code class="fe kk kl km kn b">Rectangle</code>，但是要用复合而不是继承。在这种情况下，<em class="kj">委托模式</em>，组合的具体实现，完美地匹配了我们的需求。</p><p id="2a38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是<em class="kj">类委托</em>背后的其他论点和理由:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lp lq l"/></div></figure></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><p id="10e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个帖子是<a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-2cb67fff1fe2" rel="noopener">科特林程序员词典</a>的第十六部分。要了解最新的新部件，只需关注这个媒体或在推特上观察我。如果你需要帮助，记住我随时准备接受咨询。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><a href="https://www.kt.academy/#workshops-offer"><div class="gh gi ly"><img src="../Images/018370a2476e1ce49e6d3299428b4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-f1laplrjQQAMlYKfLgHw.png"/></div></a></figure><h2 id="1e50" class="li lj in bd lz ma mb dn mc md me dp mf jv mg mh mi jz mj mk ml kd mm mn mo mp bi translated">学到了什么？单击👏说“谢谢！”并帮助他人找到这篇文章。</h2><p id="1239" class="pw-post-body-paragraph jk jl in jm b jn mq jp jq jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated">你需要Kotlin工作室吗？请访问我们的网站，看看我们能为您做些什么。</p><p id="effd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae ki" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae ki" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>在medium上关注我们。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi mv"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="9723" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是《科特林程序员词典》的其他部分:</p><ul class=""><li id="f8a1" class="mw mx in jm b jn jo jr js jv my jz mz kd na kh nb nc nd ne bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">实参对形参，类型实参对类型形参</a></li><li id="5a40" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0" rel="noopener">语句vs表情</a></li><li id="13fb" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">功能vs方法vs程序</a></li><li id="7623" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">字段对属性</a></li><li id="15f8" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类vs类型vs对象</a></li><li id="4d02" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b">对象表达式vs对象声明</a></li><li id="fb03" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-b085b1620890">接收器</a></li><li id="4dc6" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c">隐式接收者vs显式接收者</a></li><li id="515c" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277">分机接收机vs调度接收机</a></li><li id="21ae" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-type-vs-receiver-object-575d2705ddd9">接收方类型与接收方对象</a></li><li id="f3f7" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">函数类型vs函数字面vs Lambda表达式vs匿名函数</a></li><li id="0ad6" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-higher-order-function-9cadb07df94e">高阶函数</a></li><li id="304d" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-function-literal-with-receiver-vs-function-type-with-receiver-cc21dba0f4ff">带接收方的函数文字与带接收方的函数类型</a></li><li id="ae5e" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/kotlin-generics-variance-modifiers-36b82c7caa39">不变性vs协方差vs逆变</a></li><li id="01c9" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-event-listener-vs-event-handler-305c667d0e3c">事件监听器vs事件处理器</a></li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>