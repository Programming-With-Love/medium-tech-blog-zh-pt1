<html>
<head>
<title>LiveData with Coroutines and Flow — Part II: Launching coroutines with Architecture Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有协同程序和流程的LiveData第二部分:使用架构组件启动协同程序</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/livedata-with-coroutines-and-flow-part-ii-launching-coroutines-with-architecture-components-337909f37ae7?source=collection_archive---------1-----------------------#2020-07-13">https://medium.com/androiddevelopers/livedata-with-coroutines-and-flow-part-ii-launching-coroutines-with-architecture-components-337909f37ae7?source=collection_archive---------1-----------------------#2020-07-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/948170b74bfd574483cc861a75a26f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhMDChty1gzkEUQxhc4hWw.jpeg"/></div></div></figure><div class=""/><p id="a80c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文是我在2019年Android Dev峰会上与Yigit Boyar的谈话摘要的第二部分。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="jr js l"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">LiveData with Coroutines and Flow (ADS 2019)</figcaption></figure><p id="d560" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jx" rel="noopener" href="/p/b20f676d25d7">第一部分:反应式用户界面</a></p><p id="3132" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第二部分:用架构组件启动协程(这篇文章)</p><p id="05cc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jx" rel="noopener" href="/p/592485a4a85a">第三部分:LiveData和协程模式</a></p></div><div class="ab cl jy jz go ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ha hb hc hd he"><p id="430f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"> Jetpack的架构组件提供了一堆快捷方式</strong>所以你不用担心作业和取消。您只需选择您的运营范围:</p><h1 id="8f34" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">视图模型范围</h1><p id="3358" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">这是启动协程最常见的方式之一，因为大多数数据操作都是从视图模型开始的。使用<a class="ae jx" href="https://developer.android.com/topic/libraries/architecture/coroutines#viewmodelscope" rel="noopener ugc nofollow" target="_blank"> viewModelScope </a>扩展，当ViewModel被清除时，作业被自动取消。使用<code class="du li lj lk ll b">viewModelScope.launch</code>启动协程。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lm js l"/></div></figure><h1 id="6bee" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">活动和片段范围</h1><p id="67a9" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">类似地，如果您使用<code class="du li lj lk ll b"><a class="ae jx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope" rel="noopener ugc nofollow" target="_blank">lifecycleScope</a>.launch</code>，您可以将操作的范围限定到一个视图的特定实例。</p><p id="9b80" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您使用<code class="du li lj lk ll b"><a class="ae jx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope" rel="noopener ugc nofollow" target="_blank">launchWhenResumed</a></code>、<code class="du li lj lk ll b"><a class="ae jx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope" rel="noopener ugc nofollow" target="_blank">launchWhenStarted</a></code>或<code class="du li lj lk ll b"><a class="ae jx" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleCoroutineScope" rel="noopener ugc nofollow" target="_blank">launchWhenCreated</a></code>将操作限制在某个生命周期状态，您甚至可以缩小范围。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lm js l"/></div></figure><h1 id="9195" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">适用范围</h1><p id="ade9" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">对于应用程序范围来说，有一些很好的用例(在这里阅读全部内容<a class="ae jx" rel="noopener" href="/androiddevelopers/coroutines-patterns-for-work-that-shouldnt-be-cancelled-e26c40f142ad"/>)但是，首先，如果您的作业最终必须执行，您应该考虑使用<a class="ae jx" href="https://developer.android.com/topic/libraries/architecture/workmanager" rel="noopener ugc nofollow" target="_blank">工作管理器</a>。</p><h1 id="f99c" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">ViewModel + LiveData</h1><p id="bbee" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">到目前为止，我们已经看到了如何启动一个协程，但是还没有看到如何从中获得结果。您可以像这样使用<code class="du li lj lk ll b">MutableLiveData</code>:</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lm js l"/></div></figure><p id="0c39" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是，因为您将向视图公开这个结果，所以您可以通过使用<code class="du li lj lk ll b"><a class="ae jx" href="https://developer.android.com/topic/libraries/architecture/coroutines#livedata" rel="noopener ugc nofollow" target="_blank">liveData</a></code> <a class="ae jx" href="https://developer.android.com/topic/libraries/architecture/coroutines#livedata" rel="noopener ugc nofollow" target="_blank">协程生成器</a>来节省一些输入，协程生成器会启动一个协程并允许您通过不可变的LiveData公开结果。您使用<code class="du li lj lk ll b">emit()</code>向它发送更新。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lm js l"/></div></figure><h1 id="c990" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">带有开关映射的LiveData协同程序构建器</h1><p id="6c76" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">在某些情况下，每当LiveData的值发生变化时，您都希望启动一个协程。例如，在开始数据加载操作之前，您需要一个ID。使用<a class="ae jx" href="https://developer.android.com/reference/android/arch/lifecycle/Transformations#switchMap(android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20android.arch.lifecycle.LiveData%3CY%3E%3E)" rel="noopener ugc nofollow" target="_blank">转换有一个方便的模式。</a></p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lm js l"/></div></figure><p id="6384" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du li lj lk ll b">result</code>是一个不可变的LiveData，每当<code class="du li lj lk ll b">itemId</code>有一个新值时，它就会用调用<code class="du li lj lk ll b">fetchItem</code> suspend函数的结果来更新。</p><h1 id="cad7" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">从另一个LiveData发出所有项目</h1><p id="7d5a" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">这个特性不太常见，但是也可以保存一些样板文件:您可以使用<code class="du li lj lk ll b">emitSource</code>传递一个LiveData源。当您想先发出一个初始值，然后再发出一系列值时，这很有用。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lm js l"/></div></figure></div><div class="ab cl jy jz go ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ha hb hc hd he"><h1 id="353f" class="kf kg hs bd kh ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc bi translated">取消协程</h1><p id="cd60" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">如果您使用上述<strong class="ir ht">中的任何模式，您不必明确取消作业</strong>。然而，有一件重要的事情需要记住:<em class="ls">协程取消是协同的</em>。</p><p id="68a4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这意味着如果调用的协程被取消，您必须帮助Kotlin停止一个作业。假设你有一个挂起函数，它启动了一个无限循环。Kotlin没有办法为您停止这个循环，所以您需要<em class="ls">配合</em>，定期检查作业是否处于活动状态。您可以通过检查<code class="du li lj lk ll b">isActive</code>属性来做到这一点。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lm js l"/></div></figure><p id="5126" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">顺便说一下，如果你使用<code class="du li lj lk ll b">kotlinx.coroutines</code>中的任何功能(像<code class="du li lj lk ll b">delay</code>，你应该知道它们都是<em class="ls">可取消的</em>，这意味着它们会为你做检查。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lm js l"/></div></figure><p id="5bd4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管如此，我还是建议您添加检查，因为将来可能会有人删除延迟调用，从而在您的代码中引入一个微妙的bug。</p></div><div class="ab cl jy jz go ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ha hb hc hd he"><h1 id="4dc9" class="kf kg hs bd kh ki ln kk kl km lo ko kp kq lp ks kt ku lq kw kx ky lr la lb lc bi translated">单次值与多次值</h1><p id="06f3" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">为了理解协程(以及反应式ui ),我们需要对以下两者进行重要的区分:</p><ul class=""><li id="e341" class="lt lu hs ir b is it iw ix ja lv je lw ji lx jm ly lz ma mb bi translated">一次性操作:它们运行一次，可以返回一个结果</li><li id="a3b6" class="lt lu hs ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated">返回多个值的操作:对可以随时间发出多个值的数据源的订阅。</li></ul><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mh"><img src="../Images/d953dbbd1f75069b4d163ff8fa90f0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jf23LueFWJGtLfGc"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Twitter app showing parts of the UI requiring different types of operations. Retweets and likes update over time.</figcaption></figure><h1 id="ace7" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">使用协程的单次操作</h1><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/4260444aceb70e27d6b5cd10901103ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n_5XcPDQJtM6oPiz"/></div></div></figure><p id="846d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用挂起函数并用<code class="du li lj lk ll b">viewModelScope</code>或<code class="du li lj lk ll b">liveData{}</code>调用它们是运行非阻塞操作的一种非常方便的方式。</p><figure class="jn jo jp jq fd hj"><div class="bz dy l di"><div class="lm js l"/></div></figure><p id="8290" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，当我们听到变化时，事情变得有点复杂。</p><h1 id="b667" class="kf kg hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">使用LiveData接收多个值</h1><p id="4e93" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">我在<a class="ae jx" rel="noopener" href="/androiddevelopers/livedata-beyond-the-viewmodel-reactive-patterns-using-transformations-and-mediatorlivedata-fda520ba00b7">LiveData beyond the ViewModel</a>(2018)中谈到了这个主题，在那里我谈到了可以用来解决LiveData从未被设计为全功能流构建器这一事实的模式。</p><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/167d6ab9195b4d2586f03ae1f297295a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gfBln17pezL65DHI"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">An app’s presentation layer (green) and data layer (blue) using LiveData for communication</figcaption></figure><p id="62f6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如今，更好的方法是使用科特林的<a class="ae jx" href="https://kotlinlang.org/docs/reference/coroutines/flow.html" rel="noopener ugc nofollow" target="_blank">流</a>(警告:一些部分仍在实验中)。流类似于RxJava中的反应流特性。</p><p id="4ff2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，虽然协程使得非阻塞的一次性操作更加容易，但是对于流来说情况就不一样了。溪流还是很难把握。尽管如此，如果你想创建快速和可靠的反应式用户界面，我会说这是值得的时间投资。由于它是语言的一部分和一个小的依赖，许多库开始添加流支持(<a class="ae jx" rel="noopener" href="/androiddevelopers/room-flow-273acffe5b57">比如Room </a>)。</p><p id="872f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，我们可以公开来自数据源和存储库的流，而不是LiveData，但是ViewModel仍然公开LiveData，因为它是生命周期感知的。</p><figure class="jn jo jp jq fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mi"><img src="../Images/0864daacb9a958a761ef342de76e551a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*am4BDbdNxKQSqWp7"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Using Flow for communication instead of LiveData in the data layer</figcaption></figure></div><div class="ab cl jy jz go ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="ha hb hc hd he"><p id="1781" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">继续阅读<a class="ae jx" rel="noopener" href="/p/592485a4a85a">第三部分:LiveData和协程模式</a></p></div></div>    
</body>
</html>