<html>
<head>
<title>Apache Beam Dataflow GCP Pipeline Setup Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Beam数据流GCP管道设置框架</h1>
<blockquote>原文：<a href="https://medium.com/globant/apache-beam-dataflow-gcp-pipeline-setup-framework-447835fd67cb?source=collection_archive---------2-----------------------#2022-11-21">https://medium.com/globant/apache-beam-dataflow-gcp-pipeline-setup-framework-447835fd67cb?source=collection_archive---------2-----------------------#2022-11-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a8a02dc43a83e638489b78d6c97dc2be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPGQae_PI5c4bAzyUl34mQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><strong class="bd it">Apache Beam Dataflow Pipeline</strong></figcaption></figure><p id="422e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文的目的是提供使用<a class="ae js" href="https://beam.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Beam </a>在<a class="ae js" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> GCP </a>(谷歌云平台)建立管道时所需的样板代码，这样开发者就不需要在多个项目中重复编写类似的代码。这有助于开发人员将数据流选项和编码传递给框架，框架负责设置它们。它为<code class="du jt ju jv jw b">PubsubMessage</code>设置自定义和默认的编码器，并返回一个在数据流中使用的<code class="du jt ju jv jw b">Pipeline </code>实例。</p><figure class="jy jz ka kb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jx"><img src="../Images/7e1e68ea1fcea622ba55c5ebd2781f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2RVj3HMsk7knLOAiNye1-Q.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><strong class="bd it">Schematic of GCP Pipeline</strong></figcaption></figure><p id="ab30" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文的读者应该对Apache Beam管道和管道术语有所了解。这个故事对在<a class="ae js" href="https://en.wikipedia.org/wiki/Data_science" rel="noopener ugc nofollow" target="_blank">数据科学</a>和<a class="ae js" href="https://en.wikipedia.org/wiki/Big_data" rel="noopener ugc nofollow" target="_blank">大数据</a>处理领域工作的读者很有帮助。</p><h1 id="38fd" class="kc kd hh bd it ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">支持数据的批处理和流式传输</strong></h1><p id="9f38" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">大数据正在三个方面扩展:数据量、数据速度和数据多样性。它支持通过批处理和流处理数据。Apache Beam是一个开源的高级统一编程模型，适用于批处理(有限)和流(连续)用例。使用Apache Beam，可以使用SDK(<a class="ae js" href="https://www.java.com/" rel="noopener ugc nofollow" target="_blank">Java</a>、<a class="ae js" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>、<a class="ae js" href="https://go.dev/" rel="noopener ugc nofollow" target="_blank"> Go </a>和<a class="ae js" href="https://www.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> Scala </a>)创建BigData处理管道。</p><p id="7389" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Apache Beam流水线可以在最流行的数据处理系统中执行，如<a class="ae js" href="https://cloud.google.com/dataflow" rel="noopener ugc nofollow" target="_blank"> GCP数据流</a>、<a class="ae js" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"> Spark </a>、<a class="ae js" href="https://flink.apache.org/" rel="noopener ugc nofollow" target="_blank"> Flink </a>、<a class="ae js" href="https://en.wikipedia.org/wiki/MapReduce" rel="noopener ugc nofollow" target="_blank"> Hadoop Map Reduce </a>等。，并提出了类似于<a class="ae js" href="https://en.wikipedia.org/wiki/Extract,_transform,_load" rel="noopener ugc nofollow" target="_blank"> ETL </a>(提取、转换和加载)<a class="ae js" href="https://en.wikipedia.org/wiki/Analytics" rel="noopener ugc nofollow" target="_blank">分析</a>和<a class="ae js" href="https://hazelcast.com/glossary/stream-processing/" rel="noopener ugc nofollow" target="_blank">流处理</a>的解决方案。管道是消息在云系统中流动的主要媒介。</p><h1 id="cf42" class="kc kd hh bd it ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">使用阿帕奇光束的原因</strong></h1><p id="1fba" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">我们将看到下面的用例以及有资格使用Apache Beam的情况。</p><ul class=""><li id="edec" class="le lf hh iw b ix iy jb jc jf lg jj lh jn li jr lj lk ll lm bi translated"><strong class="iw hi">消息驱动系统</strong>:在不同消息类型的消息驱动系统中，我们可以创建不同的管道，将消息从一种形式转换为另一种形式，并发布到<a class="ae js" href="https://cloud.google.com/pubsub/docs/overview" rel="noopener ugc nofollow" target="_blank">GCP</a>的相关主题中。</li><li id="9d00" class="le lf hh iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><strong class="iw hi">用于处理消息的双工和多路复用管道</strong>:管道可以是双工或多路复用的，通过它它们可以监听来自前端和后端的消息并独立地处理它们。</li><li id="d846" class="le lf hh iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><strong class="iw hi">异步消息处理:</strong>以消息的形式异步处理大数据。</li><li id="d249" class="le lf hh iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><strong class="iw hi">关注业务逻辑需求:</strong>开发人员可以关注核心业务逻辑，而不用担心消息是如何在系统中处理和流动的。</li><li id="be77" class="le lf hh iw b ix ln jb lo jf lp jj lq jn lr jr lj lk ll lm bi translated"><strong class="iw hi">系统性能问题:</strong>一旦消息处理被委托给GCP Apache Beam管道开发人员，就不必担心系统在负载下的性能，因为这一切都由GCP管理。</li></ul><h1 id="0554" class="kc kd hh bd it ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">框架的积木</strong></h1><p id="42fe" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">以下部分显示了管道和编码器的类别。</p><h2 id="2ff8" class="ls kd hh bd it lt lu lv kh lw lx ly kl jf lz ma kp jj mb mc kt jn md me kx mf bi translated">管道类别</h2><p id="d118" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated"><code class="du jt ju jv jw b">AcmePipeline</code>类提供了一组变量、构造函数、管道设置方法和管道编码程序。</p><pre class="jy jz ka kb fd mg jw mh bn mi mj bi"><span id="973c" class="mk kd hh jw b be ml mm l mn mo">class AcmePipeline {<br/>  Pipeline pipeline;<br/>  DataflowPipelineOptions options;<br/>  PipelineOptionsFactory.Builder pipelineBuilder;<br/>  AcmePipeline(PipelineOptionsFactory.Builder pipelineBuilder)<br/>  AcmePipeline(String[] args, Class &lt; ?<br/>    extends DataflowPipelineOptions &gt; clazz, List &lt; AcmeCoder &gt;<br/>    coders)<br/>  AcmePipeline(String[] args, Class &lt; ?<br/>    extends DataflowPipelineOptions &gt; clazz, List &lt; AcmeCoder &gt;<br/>    coders, boolean streaming)<br/>  AcmePipeline(String[] args, Class &lt; ?<br/>    extends DataflowPipelineOptions &gt; clazz)<br/><br/>  createPipeline(DataflowPipelineOptions options)<br/>  createPipeline(DataflowPipelineOptions options, booleam streaming)<br/>  createPipeline(DataflowPipelineOptions options, List &lt; AcmeCoder &gt;<br/>    coders)<br/>  createPipeline(DataflowPipelineOptions options, List &lt; AcmeCoder &gt;<br/>    coders, booleam streaming)<br/><br/>  registerCoders(Pipeline pipeline, List &lt; AcmeCoder &gt; coders)<br/>  void setOptions(DataflowPipelineOptions options)<br/>  DataflowPipelineOptions getOptions()<br/>  Pipeline getPipeline()<br/>}</span></pre><h2 id="4ca5" class="ls kd hh bd it lt lu lv kh lw lx ly kl jf lz ma kp jj mb mc kt jn md me kx mf bi translated">编码器类别</h2><p id="d403" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated"><code class="du jt ju jv jw b">AcmeCoder</code>类提供了一组注册定制编码者和注册默认编码者的方法。</p><pre class="jy jz ka kb fd mg jw mh bn mi mj bi"><span id="c5ab" class="mk kd hh jw b be ml mm l mn mo">class AcmeCoder {<br/>  Class &lt; ? &gt; clazz;<br/>  Coder &lt; ? &gt; coder;<br/>  void registerCoders(CodeRegistry codeRegistry, List &lt; AcmeCoder &gt; coders)<br/>  void registerDefaultCoders(CodeRegistry codeRegistry)<br/>}</span></pre><p id="d697" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们已经创建了类<code class="du jt ju jv jw b">AcmePipeline</code>和<code class="du jt ju jv jw b">AcmeCoder</code>来设置管道中的编码员。默认的编码器是<code class="du jt ju jv jw b"><strong class="iw hi">PubsubMessage.class</strong></code>的<code class="du jt ju jv jw b"><strong class="iw hi">PubsubMessageWithAttributesCoder</strong></code>及其属性。</p><h2 id="a112" class="ls kd hh bd it lt lu lv kh lw lx ly kl jf lz ma kp jj mb mc kt jn md me kx mf bi translated">设置管道</h2><p id="7f33" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">管道可以按如下方式设置:</p><pre class="jy jz ka kb fd mg jw mh bn mi mj bi"><span id="bdb3" class="mk kd hh jw b be ml mm l mn mo">public AcmePipeline(String[] args, Class &lt; ?<br/>  extends DataflowPipelineOptions &gt; clazz, List &lt; AcmeCoder &gt; coders<br/>  ) {<br/>  PipelineOptionsFactory.register(clazz);<br/>  this.options = (DataflowPipelineOptions) PipelineOptionsFactory<br/>    .fromArgs(args).withValidation().as(clazz);<br/>  this.options.setStreaming(true);<br/>  this.pipeline = Pipeline.create(this.options);<br/>  log.info("Register coders called");<br/>  this.registerCoders(this.pipeline, coders);<br/>  this.setOptions(this.options);<br/>}</span></pre><p id="1c3c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的例子中，<code class="du jt ju jv jw b">AcmePipeline()</code>构造函数接受提到的具有数据流选项的命令行参数、<code class="du jt ju jv jw b">DataflowPipelineOption</code>的相应的<code class="du jt ju jv jw b">Pipeline </code>特定实现，以及<code class="du jt ju jv jw b">List&lt;AcmeCoder&gt;</code>管道用于消息转换的编码器。管道的默认操作模式是流真，因为管道将处理流数据。</p><h2 id="b041" class="ls kd hh bd it lt lu lv kh lw lx ly kl jf lz ma kp jj mb mc kt jn md me kx mf bi translated">登记编码员</h2><p id="bd70" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">编码器的设置如下:</p><p id="9ea4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du jt ju jv jw b">registerCoder()</code>调用从管道中获取<code class="du jt ju jv jw b">CoderRegistry</code>，并调用各自<code class="du jt ju jv jw b">AcmeCoder</code>上的registerCoders在管道中注册自己。结束时的调用<code class="du jt ju jv jw b">registerDefaultCoders()</code>如下。</p><pre class="jy jz ka kb fd mg jw mh bn mi mj bi"><span id="f5bf" class="mk kd hh jw b be ml mm l mn mo">public static void registerDefaultCoders(<br/>CoderRegistry coderRegistry) {<br/>  coderRegistry.registerCoderForClass(PubsubMessage.class,<br/>    PubsubMessageWithAttributesCoder.of());<br/>}</span></pre><p id="f380" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">数据流适配器可以使用<code class="du jt ju jv jw b">initDataflowPipeline()</code>初始化数据流管道来设置管道。</p><p id="f6aa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du jt ju jv jw b"><strong class="iw hi">PubsubMessageWithAttributesCoder</strong></code> <strong class="iw hi"> </strong>是序列化和反序列化<code class="du jt ju jv jw b">PubsubMessage</code>所需的编码器。<code class="du jt ju jv jw b">PubsubMessage</code>是GCP预定义的报文格式。我们可以把这个编码器当作我们需要的缺省编码器，由Apache Beam库提供。</p><pre class="jy jz ka kb fd mg jw mh bn mi mj bi"><span id="de22" class="mk kd hh jw b be ml mm l mn mo">public void initDataflowPipeline(String[] args) {<br/>  if (null != args &amp;&amp; 0 &lt; args.length) {<br/>    AcmePipeline acmePipeline = new AcmePipeline(args,<br/>      AcmeDataflowOptions.class, getCoders());<br/>    AcmeDataflowOptions options = (AcmeDataflowOptions) acmePipeline<br/>      .getOptions();<br/>    executePipeline(options, acmePipeline.getPipeline());<br/>  }<br/>}</span></pre><p id="eae7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">编码者列表如下:</p><pre class="jy jz ka kb fd mg jw mh bn mi mj bi"><span id="f7cc" class="mk kd hh jw b be ml mm l mn mo">private List &lt; AcmeCoder &gt; getCoders() {<br/>  List &lt; AcmeCoder &gt; coders = new ArrayList &lt; &gt; ();<br/>  coders.add(new AcmeCoder(HBMessage.class, new HBMessageCoder()));<br/>  coders.add(new AcmeCoder(HBData.class, new HBDataCoder()));<br/>  coders.add(new AcmeCoder(DeviceShutdownMessage.class,<br/>    new DeviceShutdownMessageCoder()));<br/>  return coders;<br/>}</span></pre><p id="13bd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每个编码器类从<code class="du jt ju jv jw b">org.apache.beam.sdk.coders.CustomCoder</code>扩展并实现<code class="du jt ju jv jw b">encode()</code>和<code class="du jt ju jv jw b">decode()</code>。这是在转换过程中<strong class="iw hi">序列化</strong>和<strong class="iw hi">反序列化</strong>消息所必需的；<code class="du jt ju jv jw b">encode()</code>用于序列化，<code class="du jt ju jv jw b">decode()</code>用于反序列化。</p><h2 id="e385" class="ls kd hh bd it lt lu lv kh lw lx ly kl jf lz ma kp jj mb mc kt jn md me kx mf bi translated">创建管道</h2><p id="0746" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">可以按如下方式创建管道:</p><pre class="jy jz ka kb fd mg jw mh bn mi mj bi"><span id="e9fe" class="mk kd hh jw b be ml mm l mn mo">public AcmePipeline(String[] args, Class &lt; ?<br/>  extends DataflowPipelineOptions &gt; clazz, List &lt; AcmeCoder &gt; coders<br/>  ) {<br/>  PipelineOptionsFactory.register(clazz);<br/>  options = PipelineOptionsFactory.fromArgs(args).withValidation()<br/>    .as(clazz);<br/>  options.setStreaming(true);<br/>  pipeline = Pipeline.create(options);<br/>  registerCoders(pipeline, coders);<br/>  setOptions(options);<br/>}<br/><br/>public void createPipeline(DataflowPipelineOptions options,<br/>  boolean streaming) {<br/>  options.setStreaming(streaming);<br/>  pipeline = Pipeline.create(options);<br/>}</span></pre><h1 id="d517" class="kc kd hh bd it ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="4161" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">我希望通过这篇文章，您可以了解如何开发一个框架，以便在GCP无缝地建立beam管道。为了更好地理解Apache Beam基础知识，请阅读下面的故事:</p><div class="mp mq ez fb mr ms"><a rel="noopener follow" target="_blank" href="/globant/apache-beam-with-gcp-dataflow-and-pubsub-c10235a7b598"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hi fi z dy mx ea eb my ed ef hg bi translated">具有GCP数据流和公共订阅的Apache Beam</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">介绍</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">medium.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng in ms"/></div></div></a></div><p id="7c36" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>