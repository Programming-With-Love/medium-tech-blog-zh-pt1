<html>
<head>
<title>Do React Hooks Replace Higher Order Components (HOCs)?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React挂钩会取代高阶组件(hoc)吗？</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/do-react-hooks-replace-higher-order-components-hocs-7ae4a08b7b58?source=collection_archive---------1-----------------------#2019-07-31">https://medium.com/javascript-scene/do-react-hooks-replace-higher-order-components-hocs-7ae4a08b7b58?source=collection_archive---------1-----------------------#2019-07-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/830a23d13cf90c974aedfaf4128cd16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJ2obPBc-qMV1tU9wIEEvA.jpeg"/></div></div></figure><p id="f255" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">自从引入React hooks API以来，出现了许多关于React hooks是否会取代React+Redux生态系统中其他常见库和模式的问题。</p><p id="4cb4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">钩子被设计用来代替<code class="du jn jo jp jq b">class</code>，并提供了另一个将行为组合到组件中的很好的选择。高阶组件对于合成行为也很有用。有一些明显的重叠，那么React钩子会取代高阶组件吗？很明显，它们可以替代一些hoc。但是你应该把你所有的hoc都换成React钩子吗？</p><p id="37a5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了弄清楚这一点，我们首先应该很好地理解什么是高阶元件，它们是如何使用的，以及使用它们时应该注意的一些注意事项。</p><h1 id="334f" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">什么是高阶元件？</h1><p id="5bf9" class="pw-post-body-paragraph ip iq hh ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">高阶组件(HOC)是接受一个组件并返回一个组件的组件。hoc可以使用无指针、声明性的函数组合来组合。这里有一个将每个页面视图记录到一个<code class="du jn jo jp jq b">/logger</code> API的例子:</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="974e" class="lc js hh jq b fi ld le l lf lg">import React, { useEffect } from 'react';</span><span id="b423" class="lc js hh jq b fi lh le l lf lg">const withLogging = Component =&gt; props =&gt; {<br/>  useEffect(() =&gt; {<br/>    fetch(`/logger?location=${ window.location}`);<br/>  }, []);</span><span id="0905" class="lc js hh jq b fi lh le l lf lg">  return &lt;Component {...props } /&gt;;<br/>};</span><span id="c44b" class="lc js hh jq b fi lh le l lf lg">export default withLogging;</span></pre><p id="7c17" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要使用它，您可以将它混合到一个HOC中，以便环绕每个页面:</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="2228" class="lc js hh jq b fi ld le l lf lg">import compose from 'ramda';</span><span id="5182" class="lc js hh jq b fi lh le l lf lg">import withRedux from './with-redux.js';<br/>import withAuth from './with-auth.js';<br/>import withLogging from './with-logging.js';<br/>import withLayout from './with-layout.js';</span><span id="ee83" class="lc js hh jq b fi lh le l lf lg">const page = compose(<br/>  withRedux,<br/>  withAuth,<br/>  withLogging,<br/>  withLayout('default'),<br/>);</span><span id="378c" class="lc js hh jq b fi lh le l lf lg">export default page;</span></pre><p id="4d49" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将创建一个组件层次结构，您可以这样想:</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="4c06" class="lc js hh jq b fi ld le l lf lg">&lt;withRedux&gt;<br/>  &lt;withAuth&gt;<br/>    &lt;withLogging&gt;<br/>      &lt;withLayout&gt;<br/>        &lt;MyPageComponent /&gt;<br/>      &lt;/withLayout&gt;<br/>    &lt;/withLogging&gt;<br/>  &lt;/withAuth&gt;<br/>&lt;/withRedux&gt;</span></pre><p id="4268" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要将此用于页面:</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="43ea" class="lc js hh jq b fi ld le l lf lg">import page from '../hocs/page.js';<br/>import MyPageComponent from './my-page-component.js';</span><span id="30f5" class="lc js hh jq b fi lh le l lf lg">export default page(MyPageComponent);</span></pre><p id="ad68" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个很好的模式，如果:</p><ul class=""><li id="bd5d" class="li lj hh ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated"><strong class="ir hi">特设不需要创建多个属性</strong>来传递给子组件。如果他们根本不创造任何道具就更好了。</li><li id="6fd4" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">HOC不会创建其他HOC或组件依赖的隐式依赖关系</strong>。</li><li id="da8f" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">你的应用程序中的所有或许多组件都需要共享该行为。</strong></li></ul><blockquote class="lw lx ly"><p id="588e" class="ip iq lz ir b is it iu iv iw ix iy iz ma jb jc jd mb jf jg jh mc jj jk jl jm ha bi translated">注意:这些并不是绝对的规则，你永远都不应该偏离。相反，它们是通常对你有用的经验法则。我经常为提供Redux提供程序的HOC的“无隐式依赖”规则做一个小小的例外。我称之为<code class="du jn jo jp jq b">withRedux</code>。一旦Redux连接上，其他hoc就可以访问状态来授权用户等等。</p></blockquote><p id="fc9a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为所有页面共享的功能组合hoc的模式仍然是我所知道的最好的方法，用于许多横切关注点，例如共享布局、日志、认证/授权，以及任何其他共享的东西，但是<em class="lz">不需要任何特定于组件的逻辑。</em></p><h1 id="03b0" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">为什么使用HOCs？</h1><p id="be89" class="pw-post-body-paragraph ip iq hh ir b is kp iu iv iw kq iy iz ja kr jc jd je ks jg jh ji kt jk jl jm ha bi translated">hoc的主要好处不是它们支持什么(还有其他方法)，而是它们如何在页面根级别组合在一起。与钩子不同，hoc可以使用标准的函数组合来声明性地组合，例如:</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="40bb" class="lc js hh jq b fi ld le l lf lg">const page = compose(<br/>  withRedux,<br/>  withAuth,<br/>  withLogging,<br/>  withLayout('default'),<br/>);</span></pre><p id="8123" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您完全消除hoc，其他选项(例如，挂钩和渲染道具)需要特别的组合，这需要大量的代码复制和相同逻辑的大量一次性实现，这些实现遍布您的应用程序并添加到不应与它们相关的组件中，违反了一些基本的软件设计原则，包括:</p><ul class=""><li id="57cb" class="li lj hh ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated"><a class="ae md" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">不重复自己(干)</strong> </a></li><li id="1fcc" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><a class="ae md" href="https://en.wikipedia.org/wiki/Unix_philosophy" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">【DOT】</strong></a><strong class="ir hi"/>(源自Unix哲学)</li><li id="187d" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><a class="ae md" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">分离关注点</strong> </a></li><li id="8cec" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><a class="ae md" href="https://en.wikipedia.org/wiki/Law_of_Demeter" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">最少知识原理(德米特定律)</strong> </a></li></ul><p id="d852" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用hoc时请记住以下几点，因为如果使用不当，hoc可能会产生问题:</p><ul class=""><li id="d321" class="li lj hh ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated"><strong class="ir hi">左右移动hoc的顺序可以打碎东西。</strong></li><li id="c0db" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">传递过来的道具都是隐性依赖。理解道具的来源和直接在使用它的组件中导入你所依赖的行为可能会令人困惑。</strong></li><li id="cbe0" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">使用大量的hoc和大量的道具会导致道具冲突</strong>——多个hoc竞相为你的组件提供相同的道具名称。</li></ul><blockquote class="lw lx ly"><p id="0015" class="ip iq lz ir b is it iu iv iw ix iy iz ma jb jc jd mb jf jg jh mc jj jk jl jm ha bi translated">注意:hoc是可组合的功能组件，它可以将任何东西混合到传递给包装组件的道具中，当它们混合在道具中时，使它们成为<a class="ae md" rel="noopener" href="/javascript-scene/functional-mixins-composing-software-ffb66d5e731c">功能混合</a>的一种形式。所有适用于混合功能的警告同样适用于混合道具的hoc。</p></blockquote><p id="1785" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">钩子将这些隐式的依赖关系移动到每个单独的组件中，所以你可以在组件中看到它们，并且知道你所有的依赖关系来自哪里。属性冲突是可以避免的，因为您可以将钩子返回值赋给任何您想要的变量，并显式地将它们作为属性传递给子依赖项，根据需要手动处理名称冲突。</p><p id="d692" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是一个使用钩子的真实组件的例子:</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="3d8a" class="lc js hh jq b fi ld le l lf lg">import React, { useState } from 'react';<br/>import t from 'prop-types';<br/>import TextField, { Input } from '<a class="ae md" href="http://twitter.com/material/react-text-field?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">@material/react-text-field</a>';</span><span id="8d7d" class="lc js hh jq b fi lh le l lf lg">const noop = () =&gt; {};</span><span id="3122" class="lc js hh jq b fi lh le l lf lg">const Holder = ({<br/>  itemPrice = 175,<br/>  name = '',<br/>  email = '',<br/>  id = '',<br/>  removeHolder = noop,<br/>  showRemoveButton = false,<br/>}) =&gt; {<br/>  const [nameInput, setName] = useState(name);<br/>  const [emailInput, setEmail] = useState(email);</span><span id="2026" class="lc js hh jq b fi lh le l lf lg">  const setter = set =&gt; e =&gt; {<br/>    const { target } = e;<br/>    const { value } = target;<br/>    set(value);<br/>  };</span><span id="3556" class="lc js hh jq b fi lh le l lf lg">  return (<br/>    &lt;div className="row"&gt;<br/>      &lt;div className="holder"&gt;<br/>        &lt;div className="holder-name"&gt;<br/>          &lt;TextField label="Name"&gt;<br/>            &lt;Input value={nameInput} onChange={setter(setName)} required /&gt;<br/>          &lt;/TextField&gt;<br/>        &lt;/div&gt;<br/>        &lt;div className="holder-email"&gt;<br/>          &lt;TextField label="Email"&gt;<br/>            &lt;Input<br/>              value={emailInput}<br/>              onChange={setter(setEmail)}<br/>              type="email"<br/>              required<br/>            /&gt;<br/>          &lt;/TextField&gt;<br/>        &lt;/div&gt;<br/>        {showRemoveButton &amp;&amp; (<br/>          &lt;button<br/>            className="remove-holder"<br/>            aria-label="Remove membership"<br/>            onClick={e =&gt; {<br/>              e.preventDefault();<br/>              removeHolder(id);<br/>            }}<br/>          &gt;<br/>            &amp;times;<br/>          &lt;/button&gt;<br/>        )}<br/>      &lt;/div&gt;<br/>      &lt;div className="line-item-price"&gt;${itemPrice}&lt;/div&gt;<br/>      &lt;style jsx&gt;{cssHere}&lt;/style&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/>Holder.propTypes = {<br/>  name: t.string,<br/>  email: t.string,<br/>  itemPrice: t.number,<br/>  id: t.string,<br/>  removeHolder: t.func,<br/>  showRemoveButton: t.bool,<br/>};</span><span id="89a6" class="lc js hh jq b fi lh le l lf lg">export default Holder;</span></pre><p id="c8e4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这段代码使用<code class="du jn jo jp jq b">useState</code>来跟踪姓名和电子邮件的短暂表单输入状态:</p><pre class="ku kv kw kx fd ky jq kz la aw lb bi"><span id="51e5" class="lc js hh jq b fi ld le l lf lg">const [nameInput, setName] = useState(name);<br/>const [emailInput, setEmail] = useState(email);</span></pre><p id="b9a0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个状态只用于这个组件，所以钩子非常适合这个用例。</p><p id="002f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">钩子的缺点是，如果你不正确地使用它们，你可能会在应用程序的所有组件中传播一个地方的逻辑，这为忘记事情或者将重复的错误传播到应用程序的一千个地方而不是一个地方提供了很多机会。</p><p id="6cec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不要禁止所有的hoc，你应该意识到哪些问题是hoc的好用例，哪些不是。</p><p id="02e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">在下列情况下，hoc的用例可能很差:</strong></p><ul class=""><li id="a0b5" class="li lj hh ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated">这个行为需要<strong class="ir hi">给一个组件添加一堆道具。</strong></li><li id="2e1f" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">该行为只在一个组件中使用。</strong></li><li id="cb79" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">行为必须为使用它的每个组件定制。</strong></li></ul><p id="efd2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">在以下情况下，您可能有一个很好的hoc用例:</strong></p><ul class=""><li id="0b99" class="li lj hh ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated">行为<strong class="ir hi">不是特定于任何单个组件，</strong>而是<strong class="ir hi">应用于应用程序中的许多或所有组件，</strong>和</li><li id="1230" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">行为不需要给使用它的组件提供一堆道具</strong>。</li><li id="31e9" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">组件可以独立使用</strong>,没有来自特设的行为。</li><li id="7ce1" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">无需向由特设</strong>包装的组件添加定制逻辑。</li></ul><p id="d54d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于广泛使用的横切关注点，使用HOCs将为您提供一个非常简单的、声明性的、单点实现，而使用hooks将为您提供许多特别的命令式实现，这些实现可能会在您的应用程序的UI代码中增加大量代码和复杂性。</p><figure class="ku kv kw kx fd ii er es paragraph-image"><a href="https://ericelliottjs.com/premium-content/lesson-pure-functions"><div class="er es me"><img src="../Images/7b6fec98432d14424a91ed1be7e13d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2HPemdrJr767xue2.png"/></div></a><figcaption class="mf mg et er es mh mi bd b be z dx"><a class="ae md" href="https://ericelliottjs.com/premium-content/lesson-pure-functions" rel="noopener ugc nofollow" target="_blank">Start your free lesson on EricElliottJS.com</a></figcaption></figure></div><div class="ab cl mj mk go ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ha hb hc hd he"><p id="aed4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lz">艾里克·艾略特</em> </strong> <em class="lz">著有《书籍》、</em> <a class="ae md" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="lz">【排版软件】</em></a><em class="lz"/><a class="ae md" href="https://www.amazon.com/Programming-JavaScript-Applications-Architecture-Libraries-dp-1491950293/dp/1491950293/ref=as_li_ss_tl?_encoding=UTF8&amp;language=en_US&amp;linkCode=ll1&amp;linkId=06971c7a0f2b13309e5af242b2483609&amp;me=&amp;qid=&amp;tag=eejs-20" rel="noopener ugc nofollow" target="_blank"><em class="lz">【编程JavaScript应用】</em> </a> <em class="lz">。作为</em><a class="ae md" href="https://ericelliottjs.com/" rel="noopener ugc nofollow" target="_blank"><em class="lz">【EricElliottJS.com】</em></a><em class="lz">和</em><a class="ae md" href="https://devanywhere.io/" rel="noopener ugc nofollow" target="_blank"><em class="lz">devanywhere . io</em></a><em class="lz">的联合创始人，他教授开发者必备的软件开发技能。他为加密项目组建开发团队并提供建议，为Adobe Systems、</em> <strong class="ir hi"> <em class="lz">、Zumba Fitness、</em> </strong> <em class="lz"> </em> <strong class="ir hi"> <em class="lz">【华尔街日报、</em></strong><em class="lz"/><strong class="ir hi"><em class="lz">【ESPN、</em></strong><em class="lz"/><strong class="ir hi"><em class="lz">BBC、</em> </strong> <em class="lz">以及包括</em> <strong class="ir hi"> <em class="lz"> Usher、弗兰克·奥申、金属乐队在内的顶级录音</em></strong></p><p id="5dc3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>