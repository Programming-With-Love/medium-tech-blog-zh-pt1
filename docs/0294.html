<html>
<head>
<title>Understanding migrations with Room</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解迁移与空间</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/understanding-migrations-with-room-f01e04b07929?source=collection_archive---------0-----------------------#2017-07-18">https://medium.com/androiddevelopers/understanding-migrations-with-room-f01e04b07929?source=collection_archive---------0-----------------------#2017-07-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f235272d6d97d2ed5437e42ae37934a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6oobbwzRm7OFhv2UVlu4Q.png"/></div></div></figure><figure class="hq hr hs ht fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/f235272d6d97d2ed5437e42ae37934a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6oobbwzRm7OFhv2UVlu4Q.png"/></div></div><figcaption class="hu hv et er es hw hx bd b be z dx">Flip the switch and migrate (<a class="ae hy" href="https://unsplash.com/photos/qAShc5SV83M" rel="noopener ugc nofollow" target="_blank">Source</a>)</figcaption></figure><div class=""/><p id="59cd" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">用SQLite API执行数据库迁移总是让我觉得我在拆除一个炸弹——好像我差一步就让应用程序在我的用户手中爆炸了。如果您正在使用<a class="ae hy" href="https://developer.android.com/topic/libraries/architecture/room.html" rel="noopener ugc nofollow" target="_blank">房间</a>来处理您的数据库操作，迁移就像扳动开关一样简单。</p><p id="c046" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">有了Room，如果你更改了数据库模式但没有升级版本，你的应用就会崩溃。如果您升级版本但不提供任何迁移，您的应用程序将会崩溃，或者数据库表被丢弃，您的用户将会丢失数据。不要拿你(应用程序)的生命冒险去猜测w̶h̶i̶c̶h̶̶s̶w̶i̶t̶c̶h̶̶t̶o̶̶f̶l̶i̶p̶如何实现迁移。相反，要理解Room的内部工作方式，以便放心地迁移您的数据库。</p><h1 id="97ce" class="jw jx ib bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">幕后数据库迁移</h1><h2 id="f55e" class="ku jx ib bd jy kv kw kx kc ky kz la kg jj lb lc kk jn ld le ko jr lf lg ks lh bi translated">SQLite API做什么</h2><p id="a069" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ha bi translated">SQLite数据库在数据库版本控制的帮助下处理模式变化。更准确地说，每次通过添加、删除或修改表来改变模式时，都必须增加数据库版本号并更新<code class="du ln lo lp lq b">SQLiteOpenHelper.onUpgrade</code>方法的实现。这就是你如何告诉SQLite从旧版本到新版本需要做什么。</p><p id="bf10" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">这也是当您的应用程序开始使用数据库时触发的第一个调用。SQLite将首先尝试处理版本升级，然后才打开数据库。</p><h2 id="ce5c" class="ku jx ib bd jy kv kw kx kc ky kz la kg jj lb lc kk jn ld le ko jr lf lg ks lh bi translated">哪个房间有</h2><p id="65e7" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ha bi translated">Room以<code class="du ln lo lp lq b"><a class="ae hy" href="https://developer.android.com/reference/android/arch/persistence/room/migration/Migration.html" rel="noopener ugc nofollow" target="_blank">Migration</a></code>类的形式提供了一个抽象层来简化SQLite迁移。一个<code class="du ln lo lp lq b">Migration</code>类定义了从一个特定版本迁移到另一个版本时应该执行的动作。Room使用自己的<code class="du ln lo lp lq b">SQLiteOpenHelper</code>实现，并且在<code class="du ln lo lp lq b">onUpgrade</code>方法中，将触发您定义的迁移。</p><p id="9ff4" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">以下是您第一次访问数据库时发生的情况:</p><ol class=""><li id="1940" class="lr ls ib ja b jb jc jf jg jj lt jn lu jr lv jv lw lx ly lz bi translated">建立房间数据库</li><li id="c986" class="lr ls ib ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated"><code class="du ln lo lp lq b">SQLiteOpenHelper.onUpgrade</code>方法被调用，房间触发迁移</li><li id="9ab6" class="lr ls ib ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated">数据库被打开</li></ol><p id="8a99" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">如果您不提供迁移，但增加了数据库版本，您的应用程序可能会崩溃，或者您的数据可能会丢失，这取决于我们将在下面考虑的一些情况。</p><p id="d7dd" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">迁移内部的一个重要部分是由一个<code class="du ln lo lp lq b">identity hash String</code>扮演的，它被Room用来唯一地标识每个数据库版本。当前版本的身份哈希保存在数据库中由Room管理的配置表中。因此，如果您看到数据库中的<code class="du ln lo lp lq b">room_master_table</code>表，不要感到惊讶。</p></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><p id="0a36" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">让我们举一个简单的例子，我们有一个<code class="du ln lo lp lq b">users</code>表，有两列:</p><ul class=""><li id="b923" class="lr ls ib ja b jb jc jf jg jj lt jn lu jr lv jv mm lx ly lz bi translated">一个ID，<code class="du ln lo lp lq b">int</code>，也是主键</li><li id="cb29" class="lr ls ib ja b jb ma jf mb jj mc jn md jr me jv mm lx ly lz bi translated">一个用户名，<code class="du ln lo lp lq b">String</code></li></ul><p id="26b3" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><code class="du ln lo lp lq b">users</code>表是版本为1的数据库的一部分，使用<code class="du ln lo lp lq b">SQLiteDatabase</code> API实现。</p><p id="5c46" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">让我们假设您的用户已经在使用这个版本，并且您想开始使用Room。让我们看看Room如何处理一些场景。</p><h1 id="6865" class="jw jx ib bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">将SQLite API代码迁移到房间</h1><p id="ebc9" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ha bi translated">在<a class="ae hy" rel="noopener" href="/google-developers/7-steps-to-room-27a5fe5f99b2">另一篇文章</a>中，我们讨论了如何将您的应用迁移到房间，让我们在此基础上更深入地了解数据迁移的细节。让我们假设<code class="du ln lo lp lq b">User</code> <a class="ae hy" href="https://developer.android.com/topic/libraries/architecture/room.html#entities" rel="noopener ugc nofollow" target="_blank">实体类</a>和<code class="du ln lo lp lq b">UserDao</code><a class="ae hy" href="https://developer.android.com/topic/libraries/architecture/room.html#daos" rel="noopener ugc nofollow" target="_blank">数据访问对象类</a>被创建，并且只关注扩展<code class="du ln lo lp lq b"><a class="ae hy" href="https://developer.android.com/reference/android/arch/persistence/room/RoomDatabase.html" rel="noopener ugc nofollow" target="_blank">RoomDatabase</a></code>的<code class="du ln lo lp lq b">UsersDatabase</code>类。</p><pre class="hq hr hs ht fd mn lq mo mp aw mq bi"><span id="fb48" class="ku jx ib lq b fi mr ms l mt mu">@Database(entities = {User.class}, version = 1)<br/>public abstract class UsersDatabase extends RoomDatabase</span></pre></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><h2 id="a553" class="ku jx ib bd jy kv kw kx kc ky kz la kg jj lb lc kk jn ld le ko jr lf lg ks lh bi translated">场景1:保持数据库版本不变——应用崩溃</h2><p id="28aa" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ha bi translated">如果我们保持数据库版本不变并运行我们的应用程序，这就是Room在幕后做的事情。</p><p id="a1e5" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">步骤1:尝试打开数据库</p><ul class=""><li id="66e1" class="lr ls ib ja b jb jc jf jg jj lt jn lu jr lv jv mm lx ly lz bi translated">通过将当前版本的标识哈希与保存在room_master_table中的标识哈希进行比较，检查数据库的标识。但是，由于没有保存身份哈希，<strong class="ja ic">应用程序会因<code class="du ln lo lp lq b">IllegalStateException</code> ❌而导致</strong>崩溃</li></ul><pre class="hq hr hs ht fd mn lq mo mp aw mq bi"><span id="e68c" class="ku jx ib lq b fi mr ms l mt mu">java.lang.IllegalStateException: Room cannot verify the data integrity. Looks like you’ve changed schema but forgot to update the version number. You can simply fix this by increasing the version number.</span></pre><blockquote class="mv mw mx"><p id="da8a" class="iy iz my ja b jb jc jd je jf jg jh ji mz jk jl jm na jo jp jq nb js jt ju jv ha bi translated">如果您修改了数据库模式但没有更新版本号，Room将总是抛出<code class="du ln lo lp lq b"><strong class="ja ic"><em class="ib">IllegalStateException</em></strong></code>。</p></blockquote><p id="268c" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">让我们听一听错误并增加数据库版本。</p><pre class="hq hr hs ht fd mn lq mo mp aw mq bi"><span id="aaf3" class="ku jx ib lq b fi mr ms l mt mu">@Database(entities = {User.class}, <strong class="lq ic">version = 2</strong>)<br/>public abstract class UsersDatabase extends RoomDatabase</span></pre></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><h2 id="fc54" class="ku jx ib bd jy kv kw kx kc ky kz la kg jj lb lc kk jn ld le ko jr lf lg ks lh bi translated">场景2:版本增加，但不提供迁移—应用崩溃</h2><p id="f81a" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ha bi translated">现在，当再次运行应用程序时，Room正在做以下事情:</p><p id="4eff" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">步骤1:尝试从版本1(安装在设备上)升级到版本2</p><ul class=""><li id="a634" class="lr ls ib ja b jb jc jf jg jj lt jn lu jr lv jv mm lx ly lz bi translated">由于没有迁移，应用程序因<code class="du ln lo lp lq b">IllegalStateException</code>而崩溃。❌</li></ul><pre class="hq hr hs ht fd mn lq mo mp aw mq bi"><span id="760f" class="ku jx ib lq b fi mr ms l mt mu">java.lang.IllegalStateException: A migration from 1 to 2 is necessary. Please provide a Migration in the builder or call fallbackToDestructiveMigration in the builder in which case Room will re-create all of the tables.</span></pre><blockquote class="mv mw mx"><p id="c555" class="iy iz my ja b jb jc jd je jf jg jh ji mz jk jl jm na jo jp jq nb js jt ju jv ha bi translated">如果不提供迁移，Room将抛出一个<code class="du ln lo lp lq b"><em class="ib">IllegalStateException</em></code>。</p></blockquote></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><h2 id="c071" class="ku jx ib bd jy kv kw kx kc ky kz la kg jj lb lc kk jn ld le ko jr lf lg ks lh bi translated">场景3:版本增加，支持回退到破坏性迁移—数据库被清除</h2><p id="5e62" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ha bi translated">如果您不想提供迁移，并且您明确地<strong class="ja ic">希望在升级版本时</strong>清除您的数据库，请在数据库构建器中调用<code class="du ln lo lp lq b">fallbackToDestructiveMigration</code>:</p><pre class="hq hr hs ht fd mn lq mo mp aw mq bi"><span id="a678" class="ku jx ib lq b fi mr ms l mt mu"><em class="my">database </em>= Room.<em class="my">databaseBuilder</em>(context.getApplicationContext(),<br/>                        UsersDatabase.class, "Sample.db")<br/>                .<strong class="lq ic">fallbackToDestructiveMigration()</strong><br/>                .build();</span></pre><p id="ef1f" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">现在，当再次运行应用程序时，Room正在做以下事情:</p><p id="87f9" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">步骤1:尝试从版本1(安装在设备上)升级到版本2</p><ul class=""><li id="0d5f" class="lr ls ib ja b jb jc jf jg jj lt jn lu jr lv jv mm lx ly lz bi translated">因为没有迁移，我们退回到破坏性迁移，所以<strong class="ja ic">表被删除</strong>并且<code class="du ln lo lp lq b">identity_hash</code>被插入。🤷</li></ul><p id="f9ec" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">步骤2:尝试打开数据库</p><ul class=""><li id="5c5f" class="lr ls ib ja b jb jc jf jg jj lt jn lu jr lv jv mm lx ly lz bi translated">当前版本的身份哈希与保存在<code class="du ln lo lp lq b">room_master_table</code>中的身份哈希相同。✅</li></ul><p id="68e9" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">所以现在，我们的应用程序不会崩溃，但我们会丢失所有数据。因此，请确保这是您特别希望处理迁移的方式。</p></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><h2 id="a5c0" class="ku jx ib bd jy kv kw kx kc ky kz la kg jj lb lc kk jn ld le ko jr lf lg ks lh bi translated">场景4:版本增加，提供迁移—保留数据</h2><p id="fb92" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ha bi translated">为了保留用户的数据，我们需要实现迁移。由于模式没有改变，我们只需要提供一个<strong class="ja ic">空迁移实现</strong>并告诉Room使用它。</p><pre class="hq hr hs ht fd mn lq mo mp aw mq bi"><span id="27a3" class="ku jx ib lq b fi mr ms l mt mu">@Database(entities = {User.class},<strong class="lq ic"> </strong>version = 2)<br/>public abstract class UsersDatabase extends RoomDatabase {</span><span id="2319" class="ku jx ib lq b fi nc ms l mt mu">…</span><span id="d891" class="ku jx ib lq b fi nc ms l mt mu">static final Migration <em class="my">MIGRATION_1_2 </em>= new Migration(1, 2) {<br/>    @Override<br/>    public void migrate(SupportSQLiteDatabase database) {<br/>        // Since we didn't alter the table, there's nothing else to do here.<br/>    }<br/>};</span><span id="1f95" class="ku jx ib lq b fi nc ms l mt mu">…</span><span id="d719" class="ku jx ib lq b fi nc ms l mt mu">database =  Room.<em class="my">databaseBuilder</em>(context.getApplicationContext(),<br/>        UsersDatabase.class, "Sample.db")<br/>        <strong class="lq ic">.addMigrations(<em class="my">MIGRATION_1_2</em>)</strong><br/>        .build();</span></pre><p id="a886" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">运行应用程序时，Room会执行以下操作:</p><p id="9c6d" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">步骤1:尝试从版本1(安装在设备上)升级到版本2</p><ul class=""><li id="a35c" class="lr ls ib ja b jb jc jf jg jj lt jn lu jr lv jv mm lx ly lz bi translated">触发了✅的空迁移</li><li id="9c6c" class="lr ls ib ja b jb ma jf mb jj mc jn md jr me jv mm lx ly lz bi translated">在<code class="du ln lo lp lq b">room_master_table</code> ✅中更新身份哈希</li></ul><p id="5adb" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">步骤2:尝试打开数据库</p><ul class=""><li id="b094" class="lr ls ib ja b jb jc jf jg jj lt jn lu jr lv jv mm lx ly lz bi translated">当前版本的身份哈希与保存在<code class="du ln lo lp lq b">room_master_table</code>中的身份哈希相同。✅</li></ul><p id="7cab" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">所以现在，我们的应用程序打开，用户的数据被迁移！🎉</p><h1 id="6964" class="jw jx ib bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">通过简单的模式更改进行迁移</h1><p id="9a90" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ha bi translated">让我们通过修改<code class="du ln lo lp lq b">User</code>类，将另一列<code class="du ln lo lp lq b">last_update</code>添加到我们的<code class="du ln lo lp lq b">users</code>表中。在<code class="du ln lo lp lq b">UsersDatabase</code>类中我们需要做如下的修改:</p><p id="9415" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">1.将版本增加到3</p><pre class="hq hr hs ht fd mn lq mo mp aw mq bi"><span id="c925" class="ku jx ib lq b fi mr ms l mt mu">@Database(entities = {User.class}, <strong class="lq ic">version = 3</strong>)<br/>public abstract class UsersDatabase extends RoomDatabase</span></pre><p id="1c05" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">2.添加从版本2到版本3的迁移</p><pre class="hq hr hs ht fd mn lq mo mp aw mq bi"><span id="9658" class="ku jx ib lq b fi mr ms l mt mu">static final Migration <em class="my">MIGRATION_2_3 </em>= new Migration(2, 3) {<br/>    @Override<br/>    public void migrate(SupportSQLiteDatabase database) {<br/>        database.execSQL("ALTER TABLE users "<br/>                + " ADD COLUMN last_update INTEGER");<br/>    }<br/>};</span></pre><p id="9c64" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">3.将迁移添加到房间数据库生成器:</p><pre class="hq hr hs ht fd mn lq mo mp aw mq bi"><span id="d0d2" class="ku jx ib lq b fi mr ms l mt mu">database = Room.<em class="my">databaseBuilder</em>(context.getApplicationContext(),<br/>        UsersDatabase.class, "Sample.db")<br/><strong class="lq ic">        .addMigrations(<em class="my">MIGRATION_1_2</em>, <em class="my">MIGRATION_2_3</em>)<br/></strong>        .build();</span></pre><p id="d853" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">运行应用程序时，需要完成以下步骤:</p><p id="b1cb" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">步骤1:尝试从版本2(安装在设备上)升级到版本3</p><ul class=""><li id="0e5d" class="lr ls ib ja b jb jc jf jg jj lt jn lu jr lv jv mm lx ly lz bi translated">触发迁移并更改表，保持用户数据✅</li><li id="152c" class="lr ls ib ja b jb ma jf mb jj mc jn md jr me jv mm lx ly lz bi translated">更新<code class="du ln lo lp lq b">room_master_table</code> ✅中的身份哈希</li></ul><p id="8cbb" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">步骤2:尝试打开数据库</p><ul class=""><li id="837b" class="lr ls ib ja b jb jc jf jg jj lt jn lu jr lv jv mm lx ly lz bi translated">当前版本的身份哈希与保存在<code class="du ln lo lp lq b">room_master_table</code>中的身份哈希相同。✅</li></ul><h1 id="cf47" class="jw jx ib bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">具有复杂模式更改的迁移</h1><p id="dd4f" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ha bi translated">SQLite的<code class="du ln lo lp lq b">ALTER TABLE…</code>命令<a class="ae hy" href="https://sqlite.org/lang_altertable.html" rel="noopener ugc nofollow" target="_blank">相当有限</a>。例如，将用户的id从<code class="du ln lo lp lq b">int</code>更改为<code class="du ln lo lp lq b">String</code>需要几个步骤:</p><ul class=""><li id="1b07" class="lr ls ib ja b jb jc jf jg jj lt jn lu jr lv jv mm lx ly lz bi translated">用新模式创建一个新的临时表，</li><li id="d25f" class="lr ls ib ja b jb ma jf mb jj mc jn md jr me jv mm lx ly lz bi translated">将数据从<code class="du ln lo lp lq b">users</code>表复制到临时表，</li><li id="2867" class="lr ls ib ja b jb ma jf mb jj mc jn md jr me jv mm lx ly lz bi translated">放下<code class="du ln lo lp lq b">users</code>桌子</li><li id="4c3c" class="lr ls ib ja b jb ma jf mb jj mc jn md jr me jv mm lx ly lz bi translated">将临时表重命名为<code class="du ln lo lp lq b">users</code></li></ul><p id="b6af" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">使用Room，迁移实现如下所示:</p><pre class="hq hr hs ht fd mn lq mo mp aw mq bi"><span id="1d35" class="ku jx ib lq b fi mr ms l mt mu">static final Migration <em class="my">MIGRATION_3_4 </em>= new Migration(3, 4) {<br/>    @Override<br/>    public void migrate(SupportSQLiteDatabase database) {<br/>        // Create the new table<br/>        database.execSQL(<br/>                "CREATE TABLE users_new (userid TEXT, username TEXT, last_update INTEGER, PRIMARY KEY(userid))");</span><span id="5b7f" class="ku jx ib lq b fi nc ms l mt mu">// Copy the data<br/>        database.execSQL(<br/>                "INSERT INTO users_new (userid, username, last_update) SELECT userid, username, last_update FROM users");</span><span id="ff51" class="ku jx ib lq b fi nc ms l mt mu">// Remove the old table<br/>        database.execSQL("DROP TABLE users");</span><span id="93c2" class="ku jx ib lq b fi nc ms l mt mu">// Change the table name to the correct one<br/>        database.execSQL("ALTER TABLE users_new RENAME TO users");<br/>    }<br/>};</span></pre><h1 id="1863" class="jw jx ib bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">多个数据库版本增量</h1><p id="e565" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ha bi translated">如果您的用户有一个旧版本的应用程序，运行数据库版本1，并希望升级到版本4，该怎么办？到目前为止，我们已经定义了以下迁移:版本1到2、版本2到3、版本3到4，所以Room将一个接一个地触发所有迁移。</p><p id="de71" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">Room可以处理不止一个版本增量:我们可以定义一个从版本1到版本4的单步迁移，使得迁移过程更快。</p><pre class="hq hr hs ht fd mn lq mo mp aw mq bi"><span id="3bc3" class="ku jx ib lq b fi mr ms l mt mu">static final Migration <em class="my">MIGRATION_1_4 </em>= new Migration(1, 4) {<br/>    @Override<br/>    public void migrate(SupportSQLiteDatabase database) {<br/>        // Create the new table<br/>        database.execSQL(<br/>                "CREATE TABLE users_new (userid TEXT, username TEXT, last_update INTEGER, PRIMARY KEY(userid))");<br/>        <br/>        // Copy the data<br/>        database.execSQL(<br/>                "INSERT INTO users_new (userid, username, last_update) SELECT userid, username, last_update FROM users");</span><span id="7eed" class="ku jx ib lq b fi nc ms l mt mu">// Remove the old table<br/>        database.execSQL("DROP TABLE users");</span><span id="e301" class="ku jx ib lq b fi nc ms l mt mu">// Change the table name to the correct one<br/>        database.execSQL("ALTER TABLE users_new RENAME TO users");<br/>    }<br/>};</span></pre><p id="9947" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">接下来，我们将它添加到迁移列表中:</p><pre class="hq hr hs ht fd mn lq mo mp aw mq bi"><span id="a34a" class="ku jx ib lq b fi mr ms l mt mu">database = Room.<em class="my">databaseBuilder</em>(context.getApplicationContext(),<br/>        UsersDatabase.class, "Sample.db")<br/>        .<strong class="lq ic">addMigrations</strong>(<em class="my">MIGRATION_1_2</em>, <em class="my">MIGRATION_2_3</em>, <em class="my">MIGRATION_3_4</em>, <strong class="lq ic"><em class="my">MIGRATION_1_4</em></strong>)<br/>        .build();</span></pre><blockquote class="mv mw mx"><p id="18bc" class="iy iz my ja b jb jc jd je jf jg jh ji mz jk jl jm na jo jp jq nb js jt ju jv ha bi translated">注意，您在<code class="du ln lo lp lq b"><em class="ib">Migration.migrate</em></code>实现中编写的查询在运行时不会被编译，这与您的Dao中的查询不同。确保您正在<a class="ae hy" rel="noopener" href="/google-developers/testing-room-migrations-be93cdb0d975">为您的迁移</a>实现测试。</p></blockquote><h1 id="14ed" class="jw jx ib bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">给我看看代码</h1><p id="0255" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ha bi translated">您可以在这个示例应用程序中查看<a class="ae hy" href="https://github.com/googlesamples/android-architecture-components" rel="noopener ugc nofollow" target="_blank">的实现。为了便于比较，每个数据库版本都以自己的方式实现:</a></p><ol class=""><li id="59ee" class="lr ls ib ja b jb jc jf jg jj lt jn lu jr lv jv lw lx ly lz bi translated"><a class="ae hy" href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample/app/src/sqlite/java/com/example/android/persistence/migrations" rel="noopener ugc nofollow" target="_blank"> <strong class="ja ic"> sqlite </strong> </a> —使用sqliteOpenHelper和传统的SQLite接口。</li><li id="6ad9" class="lr ls ib ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated"><a class="ae hy" href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample/app/src/room/java/com/example/android/persistence/migrations" rel="noopener ugc nofollow" target="_blank"> <strong class="ja ic">房间</strong> </a> —用房间替换实现，并提供到版本2的迁移</li><li id="5eaf" class="lr ls ib ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated"><a class="ae hy" href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample/app/src/room2/java/com/example/android/persistence/migrations" rel="noopener ugc nofollow" target="_blank"> <strong class="ja ic"> room2 </strong> </a> —将数据库更新到新的模式，版本3</li><li id="40e2" class="lr ls ib ja b jb ma jf mb jj mc jn md jr me jv lw lx ly lz bi translated"><a class="ae hy" href="https://github.com/googlesamples/android-architecture-components/tree/master/PersistenceMigrationsSample/app/src/room3/java/com/example/android/persistence/migrations" rel="noopener ugc nofollow" target="_blank"> <strong class="ja ic"> room3 </strong> </a> —将DB更新到新的版本4。提供从版本2到版本3、版本3到版本4以及版本1到版本4的迁移路径。</li></ol><h1 id="fa86" class="jw jx ib bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">结论</h1><p id="2be4" class="pw-post-body-paragraph iy iz ib ja b jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr lm jt ju jv ha bi translated">你的模式改变了吗？只需增加数据库版本并编写新的<code class="du ln lo lp lq b"><a class="ae hy" href="https://developer.android.com/reference/android/arch/persistence/room/migration/Migration.html" rel="noopener ugc nofollow" target="_blank">Migration</a></code>实现。你将确保你的应用不会崩溃，你的用户数据不会丢失。就像扳动开关一样简单！</p><p id="60b1" class="pw-post-body-paragraph iy iz ib ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">但是，你怎么知道你是否按对了开关呢？您如何测试您是否正确地从您的<code class="du ln lo lp lq b">SQLiteDatabase</code>实现迁移到了Room，您是否在不同的数据库版本之间实现了正确的迁移，或者您的数据库是否确实在特定版本中正常启动？我们详细讨论了<a class="ae hy" href="https://developer.android.com/topic/libraries/architecture/room.html#db-migration-testing" rel="noopener ugc nofollow" target="_blank">测试迁移</a>，这里涵盖了几种不同的场景:</p><div class="hg hh ez fb hi nd"><a rel="noopener follow" target="_blank" href="/google-developers/testing-room-migrations-be93cdb0d975"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd ic fi z dy ni ea eb nj ed ef ia bi translated">测试室迁移</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">在之前的一篇文章中，我解释了带房间的数据库迁移是如何工作的。我们看到一个不正确的…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">medium.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ho nd"/></div></div></a></div></div></div>    
</body>
</html>