<html>
<head>
<title>A Modern Dilemma: When to Use Rules vs. Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代困境:何时使用规则与机器学习</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/a-modern-dilemma-when-to-use-rules-vs-machine-learning-61cc908769b0?source=collection_archive---------1-----------------------#2020-08-17">https://medium.com/capital-one-tech/a-modern-dilemma-when-to-use-rules-vs-machine-learning-61cc908769b0?source=collection_archive---------1-----------------------#2020-08-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="52b9" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">如何识别用例的正确解决方案</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/100d3476b33917d0bd4215bd788d235f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBFpiMGtIBHRhmojwPP-Jg.png"/></div></div></figure><p id="346b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">机器学习正在席卷全球，许多使用规则引擎进行商业决策的公司开始利用它。然而，这两种技术面向不同的问题。规则引擎用于执行需要100%精确的离散逻辑。另一方面，机器学习专注于获取大量输入并试图预测结果。了解这两种技术的优势非常重要，这样您就可以针对问题找到正确的解决方案。在某些情况下，这不是一个或另一个，而是你如何一起使用两者来获得最大价值。</p><h1 id="0fae" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">业务逻辑、计算和工作流</h1><p id="3fd9" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">我们先从理解业务逻辑开始。这些年来，我在系统中与各种类型的逻辑打交道，理解上下文很重要。</p><p id="a3eb" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">什么是商业逻辑？最简单的形式，它的逻辑包含管理业务流程的决策。这些决策是商业决策。这种逻辑往往会随着市场的变化而变化，并且可能会根据特定行业的驱动因素而经常变化。逻辑关注于<em class="lb">为什么和什么时候</em>。最终，在采取行动之前，条件必须为真。</p><p id="1f42" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">业务逻辑通常利用业务计算。与业务逻辑不同，业务计算往往保持不变。他们关注<em class="lb">什么和如何</em>。将这两者从部署方面分离很重要，因为它们以不同的速度变化。一般来说，任何可重用的逻辑都应该是可独立部署的。如果可重用逻辑与应用程序部署相关联，那么它就不能单独重用，而是与其他组件相关联。理想情况下，我们希望将应用程序的可重用部分分解成微服务，以便它们可以独立地重用和部署。例如，参见马丁·福勒在“图1:单片和微服务”下的<a class="ae lc" href="https://martinfowler.com/articles/microservices.html#CharacteristicsOfAMicroserviceArchitecture" rel="noopener ugc nofollow" target="_blank">插图</a>。</p><p id="aca9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们如何将业务逻辑的不同步骤连接在一起？<strong class="jk hi"> <em class="lb">工作流程</em> </strong>。</p><p id="f828" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">它们是业务流程中工作任务的结构化流程或序列。工作流可以是基于人的、基于系统的(例如编排)，也可以是两者的混合。在之前的<a class="ae lc" rel="noopener" href="/capital-one-tech/microservices-when-to-react-vs-orchestrate-c6b18308a14c">博客</a>中，我讨论了什么时候反应，什么时候配合。</p><h1 id="b310" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">实现业务逻辑的方法</h1><p id="1b24" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">现在我们已经了解了这些部分是如何组合在一起的，让我们讨论一些构建业务逻辑的方法。一般来说，实现业务逻辑有三种不同的方法:<em class="lb">应用程序代码、决策表和规则引擎</em>。在我的经验中，我已经使用了这三种方法中的每一种，确定决定哪一种最适合的标准很重要。</p><h2 id="5264" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated">应用代码</h2><p id="44a9" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">当逻辑变化不大并且相当简单时，应用程序是一个很好的选择。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lr"><img src="../Images/0d4a96ce3592ad6f3e211e229874ea23.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*Uw72vyzr024db7T1jceGXA.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx">example code</figcaption></figure><h2 id="2c8c" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated">决策表</h2><p id="d9a6" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">决策表非常适合经常变化的逻辑，并且有大量的条件，这些条件在表中比在代码中更容易管理</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lw"><img src="../Images/d2f25cfad74d604047b5f32d9649a0b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*jOyPh_ydRzFAZWxFYKUM_Q.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx">example decision tree</figcaption></figure><h2 id="ffa9" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated">规则引擎</h2><p id="3153" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">规则引擎非常适合经常变化且高度复杂的逻辑，涉及许多逻辑层次。规则引擎通常是业务规则管理系统(BRMS)的一部分，它提供了管理复杂性的广泛功能。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lx"><img src="../Images/63b97c1d05c507a9d8fa2d50bd206433.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*e2Ri86goiYpgfEYYR8Zn4g.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx">example rules engine flow</figcaption></figure><p id="068c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果我们将此指导放入象限，它看起来会像下面这样:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ly"><img src="../Images/fd8710ff4ded6828ebcd652b71def7c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_hyOl6DoGBR4qc0Mdd_dA.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">business logic usage graph</figcaption></figure><p id="2493" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">随着复杂性和变化率的增加，应用程序代码不再适合业务逻辑。随着变化率的增加，决策表提供了一些缓解，但最终BRMS提供了最适合高变化率和高复杂性的方法。</p><h1 id="e3ce" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated"><strong class="ak">业务规则管理系统(BRMS) </strong></h1><p id="0e3a" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">让我们通过查看下面的功能参考视图来更深入地了解BRMS的功能。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lz"><img src="../Images/9f7f08298f762b2182c89ce395eeef21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEkqjk5Zo9sADnmV_AT5Tw.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">BRMS capability reference view</figcaption></figure><p id="45b7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们接触一下这个参考视图中的几个关键功能，并强调一些与机器学习功能重叠的功能。</p><h2 id="3600" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated"><strong class="ak">规则创作</strong></h2><ul class=""><li id="d1f3" class="ma mb hh jk b jl kw jo kx jr mc jv md jz me kd mf mg mh mi bi translated">技术规则或指导性规则提供了两种不同的方式来创作适合不同最终用户的规则。技术规则更适合您的开发人员，而指导性规则由点击式方法组成，可能更适合技术水平较低的用户。</li><li id="e2f4" class="ma mb hh jk b jl mj jo mk jr ml jv mm jz mn kd mf mg mh mi bi translated">领域特定语言(DSL)是另一种能力，它可以使非技术用户用更容易使用的语言编写规则。</li><li id="5b99" class="ma mb hh jk b jl mj jo mk jr ml jv mm jz mn kd mf mg mh mi bi translated">神经网络是机器学习中使用的一种算法形式，有趣的是看到一些BRMS与此相结合。</li></ul><h2 id="be81" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated"><strong class="ak">规则管理</strong></h2><p id="00ff" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">规则库是BRMS最强大的功能之一。它是一种机制，开发人员可以在其中发现已经构建了什么，以及他们可能能够重用什么。规则元数据存储在这里，这对于理解底层意图至关重要。</p><h2 id="5b42" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated"><strong class="ak">部署</strong></h2><p id="8f0c" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">通常，可以通过两种方式部署规则——作为通过REST API调用调用的独立服务的一部分，或者作为应用程序的一部分嵌入(进程内)。在本文稍后，我们将看到机器学习平台共享类似的模型。</p><h2 id="84d8" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated"><strong class="ak">规则执行&amp;部署</strong></h2><p id="1563" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated"><a class="ae lc" href="https://en.wikipedia.org/wiki/Predictive_Model_Markup_Language" rel="noopener ugc nofollow" target="_blank">预测模型标记语言(PMML) </a>或<a class="ae lc" href="https://en.wikipedia.org/wiki/Portable_Format_for_Analytics" rel="noopener ugc nofollow" target="_blank">可移植分析格式(PFA) </a>，都是使模型可互换的行业标准格式。它们使您能够用一种语言或平台构建模型，并将其移植到另一种支持PMML或PFA的语言或平台中。</p></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><p id="e0d7" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">BRMS的一个例子是<a class="ae lc" href="https://www.drools.org/" rel="noopener ugc nofollow" target="_blank">流口水</a>。Drools是一个开源的Apache许可的、基于Java的规则引擎。它支持利用PHREAK算法的正向和反向链接推理引擎。如果您希望规则引擎决定规则的顺序，这个推理引擎就派上了用场。Drools提供了指导性规则、技术规则DRL语法和对领域特定语言(DSL)的支持。Drools还支持进程内和独立部署模型。一个名为<a class="ae lc" href="https://kogito.kie.org/" rel="noopener ugc nofollow" target="_blank"> Kogito </a>的新社区项目构建在Drools 7之上，为您创建rest可部署Drools服务。我经常发现自己在Java微服务中部署drools规则，然后将它们作为restful APIs公开。科吉托为你做这个。</p><h1 id="332f" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">机器学习平台</h1><p id="94d8" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">现在我们对规则引擎有了很好的了解，让我们将它们与机器学习平台进行比较。在<a class="ae lc" rel="noopener" href="/capital-one-tech/using-machine-learning-and-open-source-bpm-in-a-reactive-microservices-architecture-96bb8dc9e962">之前的一篇文章</a>中，我概述了什么是机器学习，以及如何在<a class="ae lc" rel="noopener" href="/capital-one-tech/comparing-and-contrasting-open-source-bpm-projects-196833f23391">开源BPM </a>中使用它。在一篇类似的帖子中，我解释了如何通过<a class="ae lc" rel="noopener" href="/capital-one-tech/leveraging-akka-and-machine-learning-in-a-reactive-microservices-architecture-57b2da0c949e"> Akka </a>使用机器学习。现在让我们来看看机器学习平台的能力参考视图。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mv"><img src="../Images/d96f9253fddb32490f8b65096083ab6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dRFp178uNKOVePRc_6VtMw.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">Machine Learning Platform Capability Reference View</figcaption></figure><p id="3954" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们触及一些关键功能，并再次联系到与BRMS视图的类似重叠。</p><h2 id="f804" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated"><strong class="ak">数据摄取</strong></h2><p id="1a93" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">数据是机器学习中最重要的东西。你的模型和你的数据一样好。您需要尽可能多的数据，这可能包括批处理和实时数据源。</p><h2 id="a390" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated"><strong class="ak">特征工程</strong></h2><p id="061b" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">特征是模型的输入，一些ML平台提供了创建这些特征的能力。其他软件提供了自动生成特性的功能。</p><h2 id="da68" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated"><strong class="ak">建模范例</strong></h2><p id="c700" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">这些是可以在机器学习模型中使用的不同算法。这里需要注意的重要一点是，它们并不局限于<a class="ae lc" href="https://en.wikipedia.org/wiki/Supervised_learning#:~:text=Supervised%20learning%20is%20the%20machine,a%20set%20of%20training%20examples." rel="noopener ugc nofollow" target="_blank">有监督的</a>、<a class="ae lc" href="https://en.wikipedia.org/wiki/Unsupervised_learning" rel="noopener ugc nofollow" target="_blank">无监督的</a>或<a class="ae lc" href="https://en.wikipedia.org/wiki/Reinforcement_learning#:~:text=Reinforcement%20learning%20(RL)%20is%20an,supervised%20learning%20and%20unsupervised%20learning." rel="noopener ugc nofollow" target="_blank">强化学习</a>类别，而是可以在所有三个类别中使用。</p><h2 id="d133" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated"><strong class="ak">部署&amp;执行</strong></h2><p id="a32e" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">您会注意到这方面与BRMS功能的一些相似之处，特别是进程内和独立的REST API部署以及对PMML的支持。</p><h2 id="530c" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated"><strong class="ak">管理</strong></h2><p id="8e0a" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">管理机器学习模型的一个最重要的方面是监控它的准确性。机器学习的一个常见谬误是，ML模型永远不需要重新训练，因为它可以自我学习。事实并非如此，因为机器学习模型必须经常重新训练，因为它们训练的数据开始偏离它们在生产中执行的数据。</p></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><p id="b155" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><a class="ae lc" href="https://www.h2o.ai/" rel="noopener ugc nofollow" target="_blank"> H2O </a>就是这样一个开源内存机器学习平台的例子。它提供了多种算法(例如<a class="ae lc" href="https://en.wikipedia.org/wiki/Generalized_linear_model" rel="noopener ugc nofollow" target="_blank">广义线性模型</a>、<a class="ae lc" href="https://en.wikipedia.org/wiki/Random_forest" rel="noopener ugc nofollow" target="_blank">随机森林</a>、<a class="ae lc" href="https://en.wikipedia.org/wiki/Gradient_boosting" rel="noopener ugc nofollow" target="_blank">梯度推进机</a>、<a class="ae lc" href="https://en.wikipedia.org/wiki/Principal_component_analysis" rel="noopener ugc nofollow" target="_blank">主成分分析</a>等)。)用于训练机器学习模型以及生成显示所生成模型的准确性和性能的度量。H2O还将生成一个可部署的工件，您可以将它包含在您的项目中，比如POJO (Plain Old Java Object)或者MOJO ( Model ObJect，Optimized)工件。当POJO达到大小限制或需要更高的性能时，通常会使用MOJO。</p></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><p id="17be" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">通过比较机器学习平台和规则引擎的能力，我们现在可以看到在能力水平上的相似性和差异。鉴于这些领域的产品越来越接近，在这两者之间做出选择是很困难的，这是可以理解的。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mw"><img src="../Images/a7a0460be7233063aeaf872370dc7eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RxE4vQVI5NtknD0nIy6kyw.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">Comparison between rules engines and machine learning platforms</figcaption></figure><h1 id="c05e" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">指导何时使用规则引擎与机器学习</h1><p id="1393" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">那么，我们如何决定何时使用规则引擎或机器学习呢？要回答这个，我们先从<em class="lb">逻辑、逻辑类型、什么创建了逻辑、数据</em>这些维度来回答这个问题。规则非常适合以下情况:</p><ul class=""><li id="efda" class="ma mb hh jk b jl jm jo jp jr mx jv my jz mz kd mf mg mh mi bi translated"><strong class="jk hi">逻辑:</strong>确切的逻辑是已知的。有了规则，你就能提前知道你想要执行的逻辑。</li><li id="ef87" class="ma mb hh jk b jl mj jo mk jr ml jv mm jz mn kd mf mg mh mi bi translated"><strong class="jk hi">逻辑类型:</strong>精密基础。如果商业逻辑是精确的，并且不涉及任何预测。它基于对事实的评估产生布尔型结果。</li><li id="f442" class="ma mb hh jk b jl mj jo mk jr ml jv mm jz mn kd mf mg mh mi bi translated"><strong class="jk hi">逻辑创建:</strong>由人工完成。软件工程师或业务用户创建表示业务逻辑的规则。</li><li id="1345" class="ma mb hh jk b jl mj jo mk jr ml jv mm jz mn kd mf mg mh mi bi translated"><strong class="jk hi">数据:</strong>不需要从数据中自动推导出逻辑。分析通常在数据上预先发生，以确定确切的逻辑应该是什么。</li></ul><p id="0ba5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在，让我们用同样的维度来看机器学习:</p><ul class=""><li id="8b2f" class="ma mb hh jk b jl jm jo jp jr mx jv my jz mz kd mf mg mh mi bi translated"><strong class="jk hi">逻辑:</strong>确切的逻辑不得而知。相反，在创建预测中有意义的输入/特征可能是已知的。</li><li id="0871" class="ma mb hh jk b jl mj jo mk jr ml jv mm jz mn kd mf mg mh mi bi translated"><strong class="jk hi">逻辑类型:</strong>基于使用算法的预测。</li><li id="85c1" class="ma mb hh jk b jl mj jo mk jr ml jv mm jz mn kd mf mg mh mi bi translated"><strong class="jk hi">逻辑创建:</strong>由通过训练运行算法的机器学习软件创建。</li><li id="4b08" class="ma mb hh jk b jl mj jo mk jr ml jv mm jz mn kd mf mg mh mi bi translated"><strong class="jk hi">数据:</strong>用于最终生成模型逻辑。是机器学习中最重要的。你希望使用尽可能多的数据，并确保数据是公正的。如果数据有偏差，那么模型也会变得有偏差。</li></ul><p id="b8ad" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">总的来说，当你需要精确并且知道逻辑的时候，利用规则。当你想预测某事但不知道具体如何预测时，利用机器学习。</p><p id="3071" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">但是它总是那样清晰吗？如果你想同时利用两者的力量呢？答案是可以。有许多混合模式，您可以结合使用机器学习和规则来确定结果。让我们看一个示例用例。</p><h1 id="5f00" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">一起使用机器学习和规则引擎的模式</h1><p id="fb5a" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">想象一下这样一个用例，你是一名房地产经纪人，想要为你的客户提供最佳的购房指导。也许有几个他们感兴趣，但不确定他们应该多快行动。让我们通过三种不同的模式来实现机器学习和规则的结合。</p><h2 id="a2f7" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated"><strong class="ak"> <em class="na">模式1:利用机器学习输出作为规则的输入</em> </strong></h2><p id="b47b" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">在这种模式中，执行两种不同的机器学习模型。一个确定10天内房子卖出的概率。另一个因素决定了卖家降低要价的概率。这两种预测都是对规则的输入。然后，规则评估模型的输出，并最终向房地产经纪人提供建议。具体来说，如果房子在10天内卖出的概率大于50%，而卖家降价的概率小于50%，那么这个模式会为房地产经纪人做出具体的推荐。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nb"><img src="../Images/7e4f5b68b405e5285d9a71d8727ecc2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*kMdNfKNK2LeGQU0cA5bGxg.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx">Pattern 1: leverage machine learning output as an input into rules</figcaption></figure><h2 id="2ece" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated"><strong class="ak"> <em class="na">模式2:利用规则输出作为机器学习模型的特征输入</em> </strong></h2><p id="ed79" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">在这种模式中，我们从作为机器学习模型输入的规则开始。规则执行业务逻辑来确定基于布尔值。这房子需要修理吗？是卖盘淡季吗？卖家现在想脱手卖掉房子吗？然后，这些规则的输出成为机器学习模型的特征。然后，机器学习模型向房地产经纪人提供10天内房屋出售的概率，以及卖家降价的概率。请注意，在这种模式中，没有给房地产经纪人的建议，而是提供了可能性，最后的建议留给房地产经纪人。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nc"><img src="../Images/b6316ad7231058f2ad07b17b0b67f05a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*oXty3-d_PXLiAPGQiYm0nw.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx">Pattern 2: Leverage rule outputs as a feature input into machine learning models</figcaption></figure><h2 id="b77c" class="ld kf hh bd kg le lf lg kk lh li lj ko jr lk ll kq jv lm ln ks jz lo lp ku lq bi translated"><strong class="ak"> <em class="na">模式3:利用规则和机器学习输出作为输入</em> </strong></h2><p id="2acb" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">在这种模式中，它混合了前两种模式。规则和机器学习输出都是机器学习模型的输入。在这种情况下，卖家降价的概率是10天内房子出售概率的输入。这种模式也把最终的建议留给了房地产经纪人。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nd"><img src="../Images/ab06e8e04b5ae67627d4c451c3ae72a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*-i1rY3xjpj43xFOolba2GA.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx">Pattern 3: Leverage both rule and machine learning outputs as inputs</figcaption></figure><h1 id="8caa" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated">一个示例实现</h1><p id="f246" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">现在让我们将这些模式应用到一个实际的概念证明中。我将基于我在之前的<a class="ae lc" rel="noopener" href="/capital-one-tech/leveraging-akka-and-machine-learning-in-a-reactive-microservices-architecture-57b2da0c949e">帖子</a>中构建的之前的反应式微服务机器学习概念验证。我们将对其进行增强，使其包含一个规则服务，机器学习模型将该服务作为输入。它将使用上面的模式1，利用机器学习输出作为规则的输入。</p><p id="8108" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们从我们在概念证明中改变什么来支持规则与机器学习的集成开始。下图说明了该架构:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ne"><img src="../Images/726179c35d81115518f8e7785539c660.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*eck1EVsVpecFfB25wH9WIQ.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx">Architecture for example proof of concept</figcaption></figure><p id="ac4b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">之前的<a class="ae lc" rel="noopener" href="/capital-one-tech/leveraging-akka-and-machine-learning-in-a-reactive-microservices-architecture-57b2da0c949e">概念验证</a>的所有组成部分都是正确的，(详情请见之前的博客，我在此不再赘述)。我们引入的一个新东西是基于Java的Rules MS。这是一个Rules微服务，将评估机器学习模型概率的输出。H20输出置信度值作为其预测的一部分。对于机器学习模型确定为OK/非欺诈的交易，规则服务将检查该置信度值。如果置信度值小于50%，那么它将评估一些额外的欺诈检查的输出，在这种情况下是姓名和地址。如果其中任何一个失败，规则将建议该交易是欺诈性的。</p><p id="7845" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">下面是一个循序渐进的流程图:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nf"><img src="../Images/e50ef26f4b2c88e0a83300d57a10b414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eHUyalXpTtdmcsymiHv23w.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx">overall flow for proof of concept</figcaption></figure><p id="ec6c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在让我们看一下Java Rules MS代码，看看drools规则是如何运行的。</p><pre class="ix iy iz ja fd ng nh ni nj aw nk bi"><span id="084f" class="ld kf hh nh b fi nl nm l nn no">rule “Trans OK and Prob &lt; 0.50 and name check fail”<br/>   when<br/>      m : RulesData( modelProb &lt;= 0.50, mymodelProb : modelProb)<br/>      RulesData( status == “Transaction OK” )<br/>      RulesData( nameCheck &lt;= 0 )<br/>   then<br/>      m.setStatus(“Fraudulent Transaction from Rules, name check    <br/>      failed”);<br/>end</span><span id="2dde" class="ld kf hh nh b fi np nm l nn no">rule “Trans OK and Prob &lt; 0.50 and address check fail”<br/>   when<br/>      m : RulesData( modelProb &lt;= 0.50, mymodelProb : modelProb)<br/>      RulesData( status == “Transaction OK” )<br/>      RulesData( addressCheck &lt;= 0 )<br/>   then<br/>      m.setStatus(“Fraudulent Transaction from Rules, address check <br/>      failed”);<br/>end</span></pre><p id="4437" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以看到这是使用Drools drl语法，这是一种编写技术规则的方法。有两个规则都检查交易是否OK，以及机器学习输出是否小于50%。第一个规则还检查名称检查是否失败，第二个规则检查地址检查是否失败。您会注意到Drools中没有任何else子句。这是由设计和规则根据您指定的条件触发的。在每个规则中，您会注意到一个RulesData函数正在检查几个变量的状态。为了根据数据评估Drools规则，您必须创建一个表示数据模型的POJO。这将包括getters和setters。请参见下面的示例:</p><pre class="ix iy iz ja fd ng nh ni nj aw nk bi"><span id="2fb1" class="ld kf hh nh b fi nl nm l nn no">public static class RulesData {<br/>   private int nameCheck=0, addressCheck=0;<br/>   private String status=null;<br/>   private double modelProb=0;</span><span id="953c" class="ld kf hh nh b fi np nm l nn no">   public String getStatus() {<br/>      return this.status;<br/>   }</span><span id="ae14" class="ld kf hh nh b fi np nm l nn no">   public int getNameCheck() {<br/>      return this.nameCheck;<br/>   }</span><span id="4fbf" class="ld kf hh nh b fi np nm l nn no">   public int getAddressCheck() {<br/>      return this.addressCheck;<br/>   }</span><span id="3d20" class="ld kf hh nh b fi np nm l nn no">   public double getModelProb() {<br/>      return this.modelProb;<br/>   }</span><span id="1931" class="ld kf hh nh b fi np nm l nn no">   public void setNameCheck(int nameCheck) {<br/>      this.nameCheck = nameCheck;<br/>   }</span><span id="6e0d" class="ld kf hh nh b fi np nm l nn no">   public void setAddressCheck(int addressCheck) {<br/>      this.addressCheck = addressCheck;<br/>   }</span><span id="16ce" class="ld kf hh nh b fi np nm l nn no">   public void setModelProb(double modelProb) {<br/>      this.modelProb = modelProb;<br/>   }</span><span id="7832" class="ld kf hh nh b fi np nm l nn no">   public void setStatus(String status) {<br/>      this.status = status;<br/>   }<br/>}</span></pre><p id="afd9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们来看一段调用Drools规则的Java代码，如下所示:</p><pre class="ix iy iz ja fd ng nh ni nj aw nk bi"><span id="ebe5" class="ld kf hh nh b fi nl nm l nn no">//run drools rules<br/>KieServices ks = KieServices.Factory.get();<br/>KieContainer kContainer = ks.getKieClasspathContainer();<br/>KieSession kSession = kContainer.newKieSession("ksession-rules");</span><span id="8a03" class="ld kf hh nh b fi np nm l nn no">// go !<br/>kSession.insert(applicant);<br/>kSession.fireAllRules();<br/>kSession.destroy();</span></pre><p id="1012" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">这段代码创建了一个KieSession，然后将我们希望规则执行的数据插入到KieSession中。FireAllRules()告诉Drools这样做，触发所有规则。然后使用Destroy()进行清理。基于Java的规则MS获取drools规则的输出，并最终将其写入Kafka，在那里可以使用它。</p><h1 id="191b" class="ke kf hh bd kg kh ki kj kk kl km kn ko in kp io kq iq kr ir ks it kt iu ku kv bi translated"><strong class="ak">总结</strong></h1><p id="4bc5" class="pw-post-body-paragraph ji jj hh jk b jl kw ii jn jo kx il jq jr ky jt ju jv kz jx jy jz la kb kc kd ha bi translated">规则和机器学习各有所长，结合使用更是如虎添翼。使用正确的解决方案是关键。当你需要精确并知道逻辑时，利用规则；当你想预测某事但不知道具体如何预测时，利用机器学习。两者都可以在反应式微服务架构风格中使用，这种架构风格提供了更易维护、更易扩展且交付速度更快的架构。</p><p id="d4e0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我希望你觉得这个博客很有价值，感谢你的时间！</p></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><p id="d55a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="lb">披露声明:2020首创一号。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p></div></div>    
</body>
</html>