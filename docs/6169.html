<html>
<head>
<title>How we built rearranging Pins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">How we built rearranging Pins</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/how-we-built-rearranging-pins-b11052e95c8b?source=collection_archive---------1-----------------------#2018-02-14">https://medium.com/pinterest-engineering/how-we-built-rearranging-pins-b11052e95c8b?source=collection_archive---------1-----------------------#2018-02-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3f51" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Samuel Hsiung &amp; Alice Chang | Pinterest engineers, Emerging products</p><p id="665c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Listening to user feedback is essential to building a product Pinners love and use to discover and save ideas every day. Often, their feature requests present interesting technical challenges for our engineers. For example, today we launched the ability to <a class="ae jc" href="https://pin.it/62qiveja7ssx6k" rel="noopener ugc nofollow" target="_blank">reorder Pins on boards</a>, one of the most frequently asked for features. As we set out to build its backend service, we tackled new database scaling problems we’ll cover in this post.</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/f50819bc1aa84e4e3ba078b910c48b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5E-sp9zw-ABkjiCu2KT52w.gif"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Rearranging Pins on iOS</figcaption></figure><h2 id="472c" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated"><strong class="ak">Requirements</strong></h2><p id="2750" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">During the planning phase, we set the following requirements for the reordering backend service:</p><ul class=""><li id="443e" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">Pins can be dragged between two other Pins on the same board</li><li id="5840" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">Pin reordering can happen in the same board repeatedly within a span of seconds</li><li id="4112" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">The solution should scale across boards with many Pins</li></ul><p id="0477" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">To fulfill the first requirement, we built the following interface for the reordering API:</p><pre class="je jf jg jh fd lh li lj lk aw ll bi"><span id="4033" class="jt ju hh li b fi lm ln l lo lp">reorder_board_pin(board_id, pin_id, before_pin_id, after_pin_id)</span></pre><p id="09c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du lq lr ls li b">pin_id</code> corresponds to the Pin being dragged, and <code class="du lq lr ls li b">before_pin_id</code> and <code class="du lq lr ls li b">after_pin_id</code> correspond to the neighbors of its dropped position.</p><h2 id="a652" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated"><strong class="ak">Data storage</strong></h2><p id="8534" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">The relationship between boards and their child Pins is stored in a sharded MySQL table. Before Pin reordering was implemented, Pins were arranged by recency via a descending sort on the <code class="du lq lr ls li b">sequence</code> column of the table.</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lt"><img src="../Images/f97f805bb000d5cf639513c415f6dd9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jT-Hw4Gia590xOnA8yHYMA.png"/></div></div></figure><p id="23f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Each Pin’s sequence is initialized to the epoch timestamp in seconds corresponding to the moment of creation.</p><h2 id="1f21" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated"><strong class="ak">Explorations</strong></h2><p id="dd36" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">One naive approach to reordering we briefly considered was adjusting the sequence values of each consecutive Pin between the reordered Pin’s initial and final position. The diagram below outlines the steps for this approach, where each circle represents a Pin and the number represents its sequence.</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/bef764fe0968a74b4e8546525ad5f14f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uBQ3ChcrNUxYEMQtH3jNng.png"/></div></div></figure><p id="7cfc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">This solution requires a few SQL queries which look like this:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="285d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">One drawback of this approach is that some Pinners have boards with as many as tens of millions of Pins. This could result in many row updates for a single Pin reorder if the drag distance is far away (such is the case if the reorder API is called manually), thereby putting a heavy writeload on the database.</p><h2 id="ca36" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated"><strong class="ak">Gap bisection</strong></h2><p id="aadd" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">To reduce the number of writes, we considered bisecting gaps between the neighboring sequences of the dropped Pin. In the figure below, the reordered Pin takes on the midpoint value 9 of its neighbors 8 and 10:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/3205715bc7ab724283009ec317b2ebc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TRVmbXCxBBfaTKVt7befsg.png"/></div></div></figure><p id="2689" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">With gap bisection, we only need to update one row in the table after each reorder:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="d1e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">However, as you may have quickly noticed, the sequences will collide after enough reorders, because the integer-based sequence won’t have enough resolution to capture the gaps. Take the following example where the Pin with sequence 7 collides with the sequence of its right neighbor 9 after the midpoint is rounded down to the nearest integer:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ly"><img src="../Images/b1bf5da3e7e842cc38b798501df6b7d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2MiSlYWQCfB0k5jzv6CIzA.png"/></div></div></figure><p id="a6e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">In our case, the sequence column type is INT(11), meaning sequences are represented as ten digit 4-byte integers.This means that Pins saved eight seconds apart could only support <em class="lz">log(8) = 3*</em> bisections before a collision.</p><h2 id="0ebe" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated"><strong class="ak">Improvements</strong></h2><p id="ccff" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">To address this, we increased the resolution of the timestamps used for initializing sequence values from seconds to milliseconds. We also increased the digits of the sequence column from ten to 38 (the max allowed by our Hive backup tables).</p><p id="18a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">To fully utilize the column size, we padded the 13 digit timestamp given by Java’s epoch timestamp generator <em class="lz">System.currentTimeMillis()</em> with twenty-five trailing zeros. Here’s an example of a sequence before and after the conversion:</p><p id="2aaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Before:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ma"><img src="../Images/ddea58e1e33b8a7277047c3752aed620.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*uFK1z8BSkt5y0ui8vJFb8Q.png"/></div></figure><p id="2757" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">After:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/8dffb12733153c0e0b416513710f4e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1i3XBNRhaM2gu4S1hXM9A.png"/></div></div></figure><p id="67fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">With the new type, we can now support up to <em class="lz">log(10²⁵) ≈ 84* </em>bisections before two sequences collide, assuming a worst case scenario where Pins are saved one millisecond apart.</p><h2 id="9027" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated"><strong class="ak">Tying up loose ends</strong></h2><p id="c263" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">While increasing the sequence resolution allows us to support most reordering use cases by making sequence collisions unlikely, it doesn’t guarantee they won’t happen. To ensure sequence gaps always have space available to them, we created an offline job that’s enqueued when the sequence gap between any two neighboring Pins ever dips below a chosen threshold following a reorder. The job re-spaces the sequences of the neighboring Pins until each gap is guaranteed to support at least a configured number of bisections.</p><p id="61ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lz">Acknowledgements: Pin reordering was built in collaboration with Brian Donohue, Eric Sung, Ernie Souhrada, Kapil Bajaj, Kelei Xu, Purajit Malalur and Steven Ramkumar.</em></p><p id="d3df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">*logarithms are base 2</p></div></div>    
</body>
</html>