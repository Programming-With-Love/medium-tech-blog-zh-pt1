<html>
<head>
<title>Docker Tutorial — Complete Beginner’s guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker教程—完整的初学者指南</h1>
<blockquote>原文：<a href="https://medium.easyread.co/docker-tutorial-complete-beginners-guide-8b7dd2362c35?source=collection_archive---------0-----------------------#2021-06-20">https://medium.easyread.co/docker-tutorial-complete-beginners-guide-8b7dd2362c35?source=collection_archive---------0-----------------------#2021-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="5fab" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">序幕</h1><p id="9dd0" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这篇文章将给出一个如何使用Docker的基本教程。将要解释的主题是:</p><ul class=""><li id="f14b" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated"><strong class="kk io">什么是Docker </strong></li><li id="3af8" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><strong class="kk io">码头建筑</strong></li><li id="6d85" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><strong class="kk io">开始使用Docker(基本命令使用指南)</strong></li><li id="0e9e" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><strong class="kk io">使用Dockerfile </strong>创建图像</li><li id="8b0d" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><strong class="kk io">使用环境变量</strong>处理图像</li><li id="7db6" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><strong class="kk io">整合集装箱网络</strong></li><li id="bd12" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><strong class="kk io">管理Docker中的数据</strong></li><li id="678d" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><strong class="kk io"> Docker撰写</strong></li><li id="d638" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><strong class="kk io">对接工具</strong></li><li id="50eb" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><strong class="kk io"> Docker备忘单</strong></li></ul><p id="9f0d" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">这篇文章会很长，我希望你会喜欢，并随时给我反馈来帮助我改进这篇教程。</p><p id="04aa" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">谢谢，好好享受吧！</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h1 id="c52e" class="jk jl in bd jm jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh bi translated">Docker是什么？</h1><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/85657ce3b3112154730ff85061675e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IIpt0_gNmTjSNFgo"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Photo by <a class="ae nb" href="https://unsplash.com/@carrier_lost?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ian Taylor</a> on <a class="ae nb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e67a" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated"><a class="ae nb" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk io"> Docker </strong> </a>是一个配置管理工具，用于在轻量级容器中自动部署软件。这些容器帮助应用程序在不同的环境中高效地工作。通过使用Docker，开发人员可以快速构建、打包、运输和运行应用程序，作为轻量级、可移植、自给自足的容器，几乎可以在任何地方运行。容器允许开发人员将应用程序及其依赖项打包，并作为一个单元进行部署。通过提供预构建和自我维持的应用程序容器，开发人员可以专注于应用程序代码并使用它，而无需担心底层操作系统或部署系统。</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h1 id="7be3" class="jk jl in bd jm jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh bi translated">码头建筑</h1><p id="389f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Docker的核心概念是图像和容器。Docker映像包含运行软件所需的一切:代码、运行时(例如，Java虚拟机(JVM))、驱动程序、工具、脚本、库、部署等等。<br/>Docker容器是Docker映像的运行实例。然而，与使用类型1或类型2虚拟机管理程序的传统虚拟化不同，Docker容器运行在主机操作系统的内核上。在Docker映像中，没有单独的操作系统，如下图所示。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/1c0898d3e46ab9c322655ec10cf61586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pqIVWn0AomBJGm8k.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Docker Architecture</figcaption></figure><p id="8b24" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">每个Docker容器都有自己的文件系统、网络堆栈(因此也有自己的IP地址)、进程空间以及为CPU和内存定义的资源限制。因为Docker容器不需要引导操作系统，所以它会立即启动。Docker是关于隔离的，即分离主机操作系统的资源，与虚拟化相反，即在主机操作系统之上提供客户操作系统。</p><h2 id="b30d" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">图像</h2><p id="ccf5" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Image是一个只读文件，带有一堆指令。当执行这些指令时，它会创建一个Docker容器。我们可以说，图像是创建容器的模板。</p><h2 id="08b8" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">容器</h2><p id="7981" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">容器是一个软件包，具有运行应用程序所需的所有依赖关系。当运行容器时，它使用隔离的文件系统。</p><h2 id="8f43" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">集装箱登记处</h2><p id="31b7" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Docker容器注册表是我们在将Docker映像部署到服务器之前远程放置它的地方。换句话说，这是存储和分发Docker图像的标准方式。它还有助于提高存储在其存储库中的docker图像的访问控制和安全性。在管理图像分发的同时，它还可以与应用程序开发工作流集成。开发人员可以建立自己的容器注册中心，因为它是在Apache许可下的基于开源的存储库。也可以使用托管容器服务，比如Docker Hub或者Azure Container Registry等。</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h1 id="2a83" class="jk jl in bd jm jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh bi translated">安装码头工人</h1><p id="5888" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我不会介绍如何安装Docker。有很多关于如何将Docker安装到你的机器上的教程。对我来说，我更喜欢使用官方文件。你可以在这里看到指令<a class="ae nb" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h1 id="97b5" class="jk jl in bd jm jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh bi translated">开始使用Docker</h1><p id="0fe3" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">安装Docker后，让我们开始吧！</p><h2 id="3f5e" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">从注册表中提取图像</h2><p id="6b22" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io">查看我们本地的图像</strong></p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="4c63" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker images</strong></span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ny"><img src="../Images/592d2719ba693ca6c3241a2e881d393a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/0*elSkYT8BS92X6Hma.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Image list</figcaption></figure><p id="6ebe" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">如果你新安装了Docker，你不会在列表中看到任何东西。您将只看到标题结果、<code class="fe nz oa ob nq b"><strong class="kk io">REPOSITORY</strong></code>、<code class="fe nz oa ob nq b"><strong class="kk io">TAG</strong></code>、<code class="fe nz oa ob nq b"><strong class="kk io">IMAGE ID</strong></code>、<code class="fe nz oa ob nq b"><strong class="kk io">CREATED</strong></code>、<code class="fe nz oa ob nq b"><strong class="kk io">SIZE</strong>.</code></p><p id="e09a" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated"><strong class="kk io">拉图像</strong></p><p id="ff32" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">要提取图像，您可以使用以下命令:</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="752a" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker pull &lt;image-name&gt;</strong></span></pre><p id="7efd" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">或者对于特定的图像版本</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="5150" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker pull &lt;image-name&gt;:&lt;tag-name&gt;</strong></span></pre><p id="e0ec" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">对于这个例子，我们将使用MongoDB图像。你可以在这里 查看<a class="ae nb" href="https://hub.docker.com/_/mongo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk io">。如果你打开链接，你可以看到在右边，有一个命令告诉你如何拉图片。</strong></a></p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b7d2e08a48a55d9f8e34aa31a4ec55ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/0*Tq5pMziTsl69dtba.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Docker hub</figcaption></figure><p id="0147" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在<code class="fe nz oa ob nq b"><strong class="kk io">Tags</strong></code>菜单上，您可以看到图像的可用版本</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi od"><img src="../Images/7fef8c0cf2405a659fe0021858a0087a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/0*AfpvC76lztfvh-rp.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Docker hub tags menu</figcaption></figure><p id="6008" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">复制image pull命令，并在终端上运行它。您将会看到图像正被从注册表中提取到我们的本地机器上。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oe"><img src="../Images/f1f822e3531f1ee2e970c953b088bb4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qw-kwpRtACBryYU3.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Pulling image</figcaption></figure><p id="6658" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">如果我们不指定标签名称，它将自动拉最新的图像在注册表中。在图像提取完成后，我们可以重新检查图像列表，你会在列表中看到mongo</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi of"><img src="../Images/9add68537c8fc236e1ec0ac7514ed0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bpfrqX2aQAIfW8sI.png"/></div></div></figure><h2 id="7536" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">创建容器</h2><p id="98f9" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io">检查运行中的容器。</strong></p><p id="bd8a" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">要检查正在运行的容器，您可以使用</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="2292" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container ls</strong></span></pre><p id="65eb" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">它将只显示正在运行的<strong class="kk io"> </strong>容器，但是如果你有一些停止的容器，它不会显示在列表中。要查看我们所有的容器，我们可以使用</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="07b3" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container ls --all</strong></span></pre><p id="9a74" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">您可以使用<code class="fe nz oa ob nq b"><strong class="kk io">--all</strong></code>或<code class="fe nz oa ob nq b"><strong class="kk io">-a</strong>.</code>来显示您本地机器上的所有容器。您可以在图像上看到，有些容器正在运行，有些容器停止了。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/e84a2ca93b6f479576097059add83ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*46ZkpSAWa6BK1k1P.png"/></div></div></figure><p id="c0db" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">您可以在图像上看到，有些容器正在运行，有些容器停止了。</p><p id="0524" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated"><strong class="kk io">创建容器</strong></p><p id="3e62" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">创建容器有很多种方法。这些命令是:</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="61e1" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container create &lt;image-name&gt;</strong></span></pre><p id="206b" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">创建带有特定图像标签的容器</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="e2fa" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container create &lt;image-name&gt;:&lt;tag&gt;</strong></span></pre><p id="b126" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">要创建一个具有预定义名称的容器，我们可以在命令中使用<code class="fe nz oa ob nq b"><strong class="kk io">--name</strong></code>参数</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="5e65" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container create --name &lt;some-container-name&gt; &lt;image-name&gt;:&lt;tag&gt;</strong></span></pre><p id="575a" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">例如，让我们为提取的MongoDB图像创建一个容器，</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="72d4" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container create --name test-mongo mongo</strong></span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi og"><img src="../Images/d46f6b648f742e67c649d4df26342c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/0*hdgh4ZekLun_yoBl.png"/></div></figure><p id="382d" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">让我们用我们的容器检查一下，</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/89eb2493ff6ee8594a210e72b06f805e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VdoLOTlsac_EpZIA.png"/></div></div></figure><p id="9196" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">您可以看到没有test-mongo容器。发生这种情况是因为使用container create命令只是创建容器，而不是启动它。你可以尝试使用<code class="fe nz oa ob nq b">docker contaner ls -a</code>命令来查看容器。</p><p id="b371" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">您也可以用一个条件从同一图像创建多个容器；容器名称必须不同，因为容器名称是唯一的。如果创建容器时没有指定名称，Docker会为容器生成一个随机名称。</p><h2 id="0c64" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">开始容器</h2><p id="65ee" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">创建容器后，我们可以使用命令运行它</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="7183" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container start &lt;container-name&gt;</strong></span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/795691f5e9b0a85349875ed327a01c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/0*RTq3BB53jVI1EVER.png"/></div></figure><p id="3cb6" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">运行命令后，让我们检查容器列表，</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/a025a250942573de14183c73f9697446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hjPRmsOYTMCz4gA0.png"/></div></div></figure><p id="4108" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">如你所见，我们的<code class="fe nz oa ob nq b"><strong class="kk io">test-mongo</strong></code>已经开始运行了。在我们的例子中，你可以看到。在我们的例子中，您可以看到<code class="fe nz oa ob nq b"><strong class="kk io">test-mongo</strong></code>容器的<code class="fe nz oa ob nq b"><strong class="kk io">PORTS</strong></code>部分，我们可以通过使用端口<code class="fe nz oa ob nq b"><strong class="kk io">27017</strong></code>访问该容器。</p><p id="bcbd" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">让我们尝试连接到MongoDB。您可以使用支持MongoDB连接的DB客户端，如<a class="ae nb" href="https://robomongo.org/" rel="noopener ugc nofollow" target="_blank"> Robo3T </a>，但我使用的是Datagrip。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/df9ef28cdb8a91a4f7feae7510ba18c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/0*6Em6KVshs4zZg5e1.png"/></div></figure><p id="efcd" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">所以，我们无法连接到我们的MongoDB。为什么会这样？嗯，这是因为<code class="fe nz oa ob nq b"><strong class="kk io">PORTS</strong></code>我们之前看到的信息是容器上的端口。容器的行为是，它将创建一个隔离系统，这意味着我们不能在不暴露端口的情况下访问系统，因此它不能访问容器的外部。</p><h2 id="c146" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">港口</h2><p id="86bc" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">那么，我们如何公开容器的端口呢？为了实现这一点，我们应该考虑在创建容器时传递一个参数<code class="fe nz oa ob nq b"><strong class="kk io">-p</strong></code>或<code class="fe nz oa ob nq b"><strong class="kk io">--port</strong></code>，这样命令看起来就像这样</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="52e3" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container create --name &lt;container-name&gt; -p &lt;external-port&gt;:&lt;container-port&gt; &lt;image-name&gt;:&lt;tag&gt;</strong></span></pre><p id="4017" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">让我们尝试创建一个新的容器</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/0684d69af2965679bbf1e1084f3429eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*F_tfZuZmNnKMU1Lr.png"/></div></figure><p id="29e9" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">我会解释这个命令。</p><p id="ec27" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">container-port</strong></code> i是构建映像时已经分配的预定义端口。如果我们使用从docker注册中心获得的图像，我们可以看到图像的文档以获取端口信息。在本例中，MongoDB使用端口<code class="fe nz oa ob nq b"><strong class="kk io">27017</strong></code>。</p><p id="b83b" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在<code class="fe nz oa ob nq b"><strong class="kk io">external-port</strong></code>中，我使用端口<code class="fe nz oa ob nq b"><strong class="kk io">8011</strong></code>。这意味着，当我在容器外(或者在我的本地机器上)使用端口<code class="fe nz oa ob nq b">8011 </code>时，通过端口<code class="fe nz oa ob nq b"><strong class="kk io">8011</strong></code>传来的每个请求都将被转发到容器内的端口<code class="fe nz oa ob nq b"><strong class="kk io">27017</strong></code>。</p><p id="2c63" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">尝试启动新容器，有了这个，我们就可以访问MongoDB了。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ok"><img src="../Images/74f60bf8d644a0b8474c3b20f4be5f29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xQUf5T8AP2wrO2tB.png"/></div></div></figure><h2 id="bb22" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">移除容器</h2><p id="7832" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">要删除容器，我们使用命令</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="3a92" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container rm &lt;container-name&gt;</strong></span></pre><p id="7b72" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">让我们试着删除<code class="fe nz oa ob nq b"><strong class="kk io">test-mongo</strong></code>容器</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/993891b0d5acc2c412d1483dc98e1717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rH76H7to-K5UzxJc.png"/></div></div></figure><p id="28de" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">将会出现错误。发生这种情况是因为Docker希望我们在移除容器之前停止它。有两种方法可以解决这个问题，</p><ul class=""><li id="02eb" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">使用停止容器</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="7298" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container stop &lt;image-name&gt;</strong></span></pre><p id="14c4" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">然后再次运行容器删除命令</p><ul class=""><li id="f9e2" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">使用参数<code class="fe nz oa ob nq b"><strong class="kk io">--force</strong></code>强制删除容器</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="257e" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container rm &lt;image-name&gt; --force</strong></span></pre><p id="86ef" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">使用此命令时，请确保您知道自己在做什么。</p><p id="22ea" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">对于这个例子，我将使用选项2，</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/cba94722e0ca7009f00e45fa29c3c991.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*4ox5O8cSfzQR2vxc.png"/></div></figure><p id="8adc" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">您可以尝试重新检查容器列表，以确保该容器已经被删除。</p><h2 id="c0a1" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">移除图像</h2><p id="61c9" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">与移除容器一样，我们不能在移除所有使用图像的容器之前移除该图像。要删除图像，可以使用命令</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="9af6" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker image remove &lt;imange-name&gt;:&lt;tag&gt;</strong></span></pre><p id="7c91" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">让我们停下来移除容器，然后移除<code class="fe nz oa ob nq b">mongo</code>图像。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/593b6071d6337e5a4cea3540f754f12d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zHNwgYc6uWtU9yNy.png"/></div></div></figure><h2 id="0358" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">码头日志</h2><p id="c24b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们可以看到docker日志来帮助我们调试容器内部的应用程序。为此，我们可以使用命令</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="eceb" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker logs &lt;container-name&gt;</strong></span></pre><p id="1c3a" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">您可以尝试创建一些容器，并检查容器的日志。这是我的Postgres容器的一个例子。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi om"><img src="../Images/0336212992ed1bccf05f96fd8cda3634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*deyg0yHFLgnCXVZ6.png"/></div></div></figure><h2 id="c480" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">进入集装箱内部</h2><p id="5b3f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">尽管容器与容器的外部是隔离的，但是Docker有一些命令，我们可以使用它们在容器内部传递命令。我们可以使用命令</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="f732" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker exec &lt;option&gt; &lt;container-name&gt; &lt;command&gt;</strong></span></pre><p id="d853" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">你可以在这里看到更多关于docker exec <a class="ae nb" href="https://docs.docker.com/engine/reference/commandline/exec/" rel="noopener ugc nofollow" target="_blank">的信息</a></p><p id="15bb" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">我将演示如何使用我的名为<code class="fe nz oa ob nq b">dev-postgres</code>的<code class="fe nz oa ob nq b">postgre</code>进入容器内部的Postgres客户端。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/5190d3357a1e81e7845cd7cf64bd64b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IpkehVoU2Ai9TUHA.png"/></div></div></figure><p id="900e" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">你可以看到我正在运行一个命令来显示容器内的数据库列表<code class="fe nz oa ob nq b"><strong class="kk io">-it</strong></code>表示<code class="fe nz oa ob nq b"><strong class="kk io">interactive</strong></code>(保持STDIN打开)和tty(分配一个伪TTY)。</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h1 id="5180" class="jk jl in bd jm jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh bi translated">用Dockerfile创建图像</h1><p id="0df2" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们已经使用Docker处理来自容器注册中心的图像，但是如果我们想创建一个图像呢？档案来了。Dockerfile是一个简单的文本文件，由构建Docker映像的指令组成。Dockerfile由指导您如何构建特定Docker映像的命令组成。</p><p id="32b0" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">例如，我们需要准备一些应用程序代码来演示如何构建应用程序映像。我们将创建两个文件，应用程序代码和docker文件。对于应用程序代码，我将使用Go制作一个简单的HTTP app。你不需要在你的电脑上安装Go runtime，因为我们会把我们的应用程序放在容器里，然后在里面安装Go runtime。</p><h2 id="bee5" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">准备应用程序</h2><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="5e0a" class="nd jl in nq b gy nu nv l nw nx">package main</span><span id="1627" class="nd jl in nq b gy on nv l nw nx">import (<br/>	"fmt"<br/>	"net/http"<br/>)</span><span id="8642" class="nd jl in nq b gy on nv l nw nx">func main() {<br/></span><span id="ed8d" class="nd jl in nq b gy on nv l nw nx">	// * Handle Route "/"<br/>	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {<br/>		fmt.Fprintf(w, "&lt;h1&gt;Hello Docker!&lt;/h1&gt;")<br/>	})<br/></span><span id="067f" class="nd jl in nq b gy on nv l nw nx">    http.ListenAndServe(":8000", nil)<br/>}</span></pre><h2 id="6588" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">创建Dockerfile文件</h2><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="3819" class="nd jl in nq b gy nu nv l nw nx"># BUILD IMAGE FROM EXISTING IMAGE<br/># Line with '#' will not executed</span><span id="7204" class="nd jl in nq b gy on nv l nw nx"># 1. Call the image<br/># FROM &lt;image name&gt;:&lt;tag&gt;<br/># for the base we will use golang image version 1.15</span><span id="5ab3" class="nd jl in nq b gy on nv l nw nx">FROM golang:1.15</span><span id="68c4" class="nd jl in nq b gy on nv l nw nx"># 2. Copy file that needed in this image<br/># COPY &lt;source&gt; &lt;destination&gt;<br/># we will put file main.go in /app/main.go inside the container</span><span id="c99b" class="nd jl in nq b gy on nv l nw nx">COPY main.go /app/main.go</span><span id="8c1b" class="nd jl in nq b gy on nv l nw nx"># 3. Telling the image how to run the app<br/># CMD [&lt;add command using array&gt;]</span><span id="0b62" class="nd jl in nq b gy on nv l nw nx">CMD ["go", "run", "/app/main.go"] # same with "go run /app/main.go"</span></pre><h1 id="a960" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">构建图像</h1><p id="a7ac" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们可以用三种方法来建立一个图像:</p><ul class=""><li id="1c93" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">简单方法</li></ul><p id="0255" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">docker build &lt;path-to-dockerfile&gt;</strong></code></p><ul class=""><li id="7672" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">在我们的图像中添加一个名称</li></ul><p id="5f66" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">docker build --tag &lt;app name&gt; &lt;path-to-dockerfile&gt;</strong></code></p><ul class=""><li id="cd8c" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">添加名称和版本号</li></ul><p id="d412" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">docker build --tag &lt;app name&gt;:&lt;version number&gt; &lt;path-to-dockerfile&gt;</strong></code></p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="a4da" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker build --tag app-golang:1.0 .</strong></span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/45be6024542aa5b45e5b05c4dae3e301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Xsbj-WN6tLB0RvGs.png"/></div></div></figure><p id="0b73" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">使用Dockerfile构建映像的方式多种多样，具体取决于您的需求，在创建映像时经常会用到许多Dockerfile语法，例如:</p><ul class=""><li id="8898" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">入口点</li><li id="e4d6" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated">奔跑</li><li id="4875" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated">工作方向</li><li id="cd62" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated">包封/包围（动词envelop的简写）</li></ul><p id="3bc9" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">阅读这个docker <a class="ae nb" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk io">文档</strong> </a>，了解所有的语法，并查看使用它的最佳实践。</p><h2 id="79e6" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">创建我们的应用容器</h2><p id="7fe6" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们试着为我们的应用程序创建一个容器并运行它。然后，我们可以使用浏览器查看我们的应用程序。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oo"><img src="../Images/949ff0b8b83ec494a0202d53b956894b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/0*TALOE2p29CL0ZU3e.png"/></div></div></figure><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a17d7bc02731ff811904a4aade2f41c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/0*uiuLKVyh3ZF4qcIE.png"/></div></figure><h2 id="fc77" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">将图像上传到注册表</h2><p id="91d0" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io">准备</strong></p><ul class=""><li id="0a96" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">在<a class="ae nb" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/</a>登录您的账户</li></ul><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/efd29214f76ccd0b48bd94168c0d5efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YVcQbEVAaIkveydH.png"/></div></div></figure><ul class=""><li id="863a" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">为图像创建新的存储库</li></ul><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/db24ece3241cddd0f0122d2dcddb5d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UYcbh-y-KYzLUM2m.png"/></div></div></figure><p id="dc7b" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated"><strong class="kk io">推送图像</strong></p><p id="8b9d" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">我们将使用docker命令来推送图像，<code class="fe nz oa ob nq b"><strong class="kk io">docker push &lt;repository name&gt;:&lt;tag&gt;</strong></code></p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/3152974d6d3a658ed0d089722a138869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XEDdiw_VxWbqOBtJ.png"/></div></div></figure><p id="66f8" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">如果我们尝试插入这个命令，我们会得到一个错误:<code class="fe nz oa ob nq b">An image does not <strong class="kk io">exist locally ...</strong></code></p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/a7b8f355e353586e413b89df12d8f436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sD0pns7IMlt3Ctnw.png"/></div></div></figure><p id="1c03" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">这是因为我们创建了一个名称不同于我们的存储库名称的映像。让我们在本地检查图像，使用:</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="2bec" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker images</strong></span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oq"><img src="../Images/88216e407f96407559c55574ebb3a152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*36_F7TZYePUs609A.png"/></div></div></figure><p id="7e65" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">我们的本地映像被命名为<strong class="kk io"> app-golang </strong>，但是docker registry想要<strong class="kk io"> repoerna/example-go-app </strong>。</p><p id="0519" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">为了解决这个问题，我们需要使用</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="86d1" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker tag &lt;local-image&gt;:&lt;tagname&gt; &lt;reponame&gt;:&lt;tagname&gt;</strong></span></pre><p id="9983" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在我们的本地检查docker图像，我们将看到新的图像被创建，</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/0c37cb926b7da99e795d9d83e3e403b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dTRJ9_THERRPwG3G.png"/></div></div></figure><p id="7c60" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">之后，我们可以通过使用之前使用的相同命令来推送至存储库</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi or"><img src="../Images/1fe2191b9d7484e8f53ec6baa0f09d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/0*LD-ZZ5te6hVGme7c.png"/></div></figure><p id="a7c6" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">哎呀！我们仍然得到一个错误，我们的推送请求被拒绝。这是因为，我们当地的码头工人不知道，在哪里推动形象。</p><p id="27bb" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">我们需要登录，通过使用</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="2dde" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker login</strong></span></pre><p id="1e30" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">输入您的docker hub帐户凭据</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/7d0c70af02352efeca8fa3b4fc7d0e94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A06ZHuZ6ldMe9mIf.png"/></div></div></figure><p id="cf1b" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">登录后，让我们再次尝试推送</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/e38d6f5f96948e3147a253928d7086a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UYXhXhPU0azIETzO.png"/></div></div></figure><p id="da87" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">好吧！我们成功地将本地映像推送到远程存储库，让我们在docker hub中进行检查</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/341a5cc27b30d3527c9a62ab8e3f5f87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ehaxrc9aZ3cOekpX.png"/></div></div></figure><p id="864f" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">关于docker库的详细信息，可以阅读<a class="ae nb" href="https://docs.docker.com/docker-hub/repos/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk io">文档</strong> </a></p><h1 id="2222" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">用环境变量处理图像</h1><blockquote class="os ot ou"><p id="b4d3" class="ki kj ov kk b kl li kn ko kp lj kr ks ow lw kv kw ox lx kz la oy ly ld le lf ig bi translated"><em class="in">一个</em> <strong class="kk io"> <em class="in">环境变量</em> </strong> <em class="in">是一个动态命名的值，它可以影响正在运行的进程在计算机上的行为方式。它们是流程运行环境的一部分。</em> <strong class="kk io"> <em class="in"> —维基百科</em> </strong></p></blockquote><p id="4a93" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">很少直接使用环境变量。它通常被程序用来配置自己。在软件开发中，程序/应用程序的一些配置是通过使用环境变量来设置的。如果我们希望我们的程序改变一些配置，我们可以通过改变环境变量而不改变代码来实现。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oz"><img src="../Images/4704cb9fb128a32392af7d464f1cb60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pZDz76DYxmD5gBHN.png"/></div></div></figure><p id="3145" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在Linux或macOS中，您可以使用命令查看您的OS环境变量</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="1e26" class="nd jl in nq b gy nu nv l nw nx">$ printenv</span></pre><p id="3003" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">如果您使用Windows，您可以通过打开<strong class="kk io">控制面板&gt;高级系统设置&gt;环境变量</strong>来访问该环境变量。您将看到环境变量窗口。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pa"><img src="../Images/67902db25813caf69885613babbd84b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/0*PAYkgBZPXOpWkh93.png"/></div></div></figure><p id="a9ff" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">如果我们想对需要环境变量的程序进行dockerize，我们应该在运行容器之前添加一些命令。给你一个例子，让我们更新我们的程序来处理一些环境变量。我们将添加一个新的路由来管理环境变量。</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="cdf6" class="nd jl in nq b gy nu nv l nw nx">package main<br/><br/>import (<br/>	"fmt"<br/>	"net/http"<br/>	"os"<br/>)<br/><br/>func main() {<br/>package main<br/><br/>import (<br/>	"fmt"<br/>	"net/http"<br/>	"os"<br/>)<br/><br/>func main() {<br/>	// * this will set env variable MYNAME<br/>	// os.Setenv("MYNAME", "REPOERNA")<br/><br/>	// * get env variable MYNAME<br/>	appPort := os.Getenv("APP_PORT")<br/>	port := fmt.Sprintf(":%s", appPort)<br/><br/>	myName := os.Getenv("MYNAME")<br/>	txt := fmt.Sprintf("&lt;h1&gt;Hello, %s&lt;/h1&gt;", myName) // &lt;-- env var MYNAME will be used in this line<br/><br/>	// * Handle Route "/"<br/>	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {<br/>		fmt.Fprintf(w, "&lt;h1&gt;Hello Docker!&lt;/h1&gt;")<br/>	})<br/><br/>	// * Handle route "/myname"<br/>	http.HandleFunc("/myname", func(w http.ResponseWriter, r *http.Request) {<br/>		fmt.Fprintf(w, txt)<br/>	})<br/><br/>	http.ListenAndServe(port, nil) // &lt;-- env var APP_PORT will be used in this line<br/>}</span></pre><p id="eb8d" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">记住，在我们的程序中，我们需要两个环境变量，APP_PORT和MYNAME。更新我们的程序后，在不改变docker文件的情况下重新构建它。</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="db1a" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker build --tag app-golang:1.0 .</strong></span></pre><p id="8ecd" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">然后使用图像创建一个容器，并添加<code class="fe nz oa ob nq b">-e</code>来添加一个环境变量</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="a604" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container create --name golang-test-env -p 8080:8080 -e APP_PORT=8080 -e MYNAME=REPOERNA app-golang:1.0</strong></span></pre><p id="150b" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">创建容器后，让我们使用命令检查其中的环境变量</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="f5ca" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container inspect golang-test-env</strong></span></pre><p id="0c68" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在列表中，你会看到在带有<code class="fe nz oa ob nq b">APP_PORT</code>和<code class="fe nz oa ob nq b">MYNAME.</code>的<code class="fe nz oa ob nq b">Env</code>中，值与我们之前输入的命令相同。对于<code class="fe nz oa ob nq b">PATH</code>，<code class="fe nz oa ob nq b">GOLANG_VERSION</code>，<code class="fe nz oa ob nq b">GOPATH</code>是自动添加的，因为我们在docker文件中使用了golang。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/6d09df042802ed8c7c1d70d0dd852a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wmEqsXjz1kqcUuwO.png"/></div></div></figure><p id="2c69" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">因此，让我们运行容器，检查我们的程序正在工作</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="79ea" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container start golang-test-env</strong></span></pre><p id="94c7" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">如果没有出现错误，在浏览器<em class="ov">中打开localhost:8080/myname </em>，会显示<code class="fe nz oa ob nq b">MYNAME</code>环境变量值。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/df422b52e948e34fa75d29c75fab71c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/0*XsPvOsnitBnMACBo.png"/></div></figure><ul class=""><li id="ab39" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">注意:使用docker文件创建图像时，可以在docker文件中指定环境变量。请参阅关于如何实现的官方文档。</li></ul><h1 id="5109" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">集成集装箱网络</h1><p id="d94a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在本节中，我们将讨论如何将容器连接到另一个容器。假设我们有一个web服务器，它需要与Postgres通信以获取数据库，与Redis通信以获取缓存或会话存储。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/1b3930d5135bacf7b4080c9cdf1b1ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/0*2-1_thdvJ4ZlfwJQ.png"/></div></figure><p id="9187" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">因此，我们将准备3个容器，一个用于app，一个用于Postgres，一个用于Redis。在此之前，我们先准备好我们的app。我们将使用我们以前的应用程序，并添加一些代码来连接Postgres和Redis。</p><h2 id="3806" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">更新我们的应用</h2><p id="e952" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io"> main.go </strong></p><p id="d1e6" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">我们将添加一些数据库连接到我们的应用程序。</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="ca5d" class="nd jl in nq b gy nu nv l nw nx">Package main</span><span id="74b3" class="nd jl in nq b gy on nv l nw nx">import (<br/>	"database/sql"<br/>	"fmt"<br/>	"net/http"<br/>	"os"</span><span id="a7c9" class="nd jl in nq b gy on nv l nw nx">	"github.com/go-redis/redis"<br/>	_ "github.com/lib/pq"<br/>)</span><span id="a889" class="nd jl in nq b gy on nv l nw nx">func main() {</span><span id="9057" class="nd jl in nq b gy on nv l nw nx">	dbHost := os.Getenv("DB_HOST")<br/>	dbPort := 5432<br/>	dbUser := "postgres"<br/>	dbPass := "Secure123"<br/>	dbName := "docker-demo"<br/>	redisHost := os.Getenv("REDIS_HOST")<br/>	redisAddr := fmt.Sprintf("%s:6379", redisHost)<br/>	redisPass := "" //no password set<br/>	redisDB := 0    //default db</span><span id="01f1" class="nd jl in nq b gy on nv l nw nx">	// * setup postgre connection<br/>	dsn := fmt.Sprintf("host=%s port=%d user=%s "+<br/>		"password=%s dbname=%s sslmode=disable",<br/>		dbHost, dbPort, dbUser, dbPass, dbName)<br/>	db, err := sql.Open(<br/>		"postgres",<br/>		dsn,<br/>	)<br/>	if err != nil {<br/>		fmt.Println(err)<br/>	}</span><span id="4f1d" class="nd jl in nq b gy on nv l nw nx">	// * Ping for test the connection<br/>	if err = db.Ping(); err != nil {<br/>		fmt.Println(err)<br/>	} else {<br/>		fmt.Println("DB Postgres Connected !")<br/>	}</span><span id="d408" class="nd jl in nq b gy on nv l nw nx">	// * setup redis connection<br/>	rdb := redis.NewClient(&amp;redis.Options{<br/>		Addr:     redisAddr,<br/>		Password: redisPass,<br/>		DB:       redisDB,<br/>	})</span><span id="5361" class="nd jl in nq b gy on nv l nw nx">	// * Ping for test the connection<br/>	pong, err := rdb.Ping().Result()<br/>	if err != nil {<br/>		fmt.Println(err)<br/>	} else {<br/>		fmt.Println(pong)<br/>		fmt.Println("Redis Connected !")<br/>	}</span><span id="685e" class="nd jl in nq b gy on nv l nw nx">	// * get env variable MYshNAME<br/>	appPort := os.Getenv("APP_PORT")<br/>	// handle for default port<br/>	if appPort == "" {<br/>		appPort = "8080"<br/>	}<br/>	port := fmt.Sprintf(":%s", appPort)</span><span id="4e91" class="nd jl in nq b gy on nv l nw nx">	// myName := os.Getenv("MYNAME")<br/>	// txt := fmt.Sprintf("&lt;h1&gt;Hello, %s&lt;/h1&gt;", myName)</span><span id="1b61" class="nd jl in nq b gy on nv l nw nx">	// * Handle Route "/"<br/>	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {<br/>		fmt.Fprintf(w, "&lt;h1&gt;Hello Docker!&lt;/h1&gt;")<br/>	})</span><span id="6c5d" class="nd jl in nq b gy on nv l nw nx">	// * Handle route "/myname"<br/>	// http.HandleFunc("/myname", func(w http.ResponseWriter, r *http.Request) {<br/>	// 	fmt.Fprintf(w, txt)<br/>	// })</span><span id="d54d" class="nd jl in nq b gy on nv l nw nx">	http.ListenAndServe(port, nil)<br/>}</span></pre><p id="4fd9" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">对于Postgres和Redis hostname，我们将使用一个环境变量，因为我们正在使用Redis，所以我们需要在我们的go应用程序中使用模块。因此，我们需要更新docker文件来处理go模块。</p><p id="3011" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated"><strong class="kk io"> Dockerfile </strong></p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="aefa" class="nd jl in nq b gy nu nv l nw nx">FROM golang:1.15<br/><br/>ENV GO111MODULE=on<br/><br/>WORKDIR /app<br/><br/><br/>RUN go mod init<br/><br/>COPY . .<br/><br/>RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build<br/><br/>EXPOSE 8080<br/>CMD ["go", "run", "/app/main.go"]</span></pre><p id="b89e" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在应用程序准备好之后，我们将继续准备容器，不要忘记清理之前的容器</p><h2 id="d786" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">创建容器</h2><ul class=""><li id="0ea8" class="lg lh in kk b kl km kp kq kt pd kx pe lb pf lf ln lo lp lq bi translated">重建我们的golang应用形象</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="1d6f" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker build — tag app-golang:1.0 .</strong></span></pre><ul class=""><li id="957b" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">创建golang应用程序容器</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="a223" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container create — name golang-docker -e REDIS_HOST=localhost -e DB_HOST=localhost -p 8080:8080 app-golang:1.0</strong></span></pre><ul class=""><li id="0d52" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">创建Postgres容器</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="531e" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container create --name postgres-docker -p 5432:5432 -e POSTGRES_DB=docker-demo -e POSTGRES_PASSWORD=mysecretpassword postgres</strong></span></pre><ul class=""><li id="645b" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">创建Redis容器</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="5144" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container create --name redis-docker -p 6379:6379 redis</strong></span></pre><p id="89c9" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">让我们看看我们创建的容器</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/d25e5d9ee45a20072215f908b3eb95bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HFDJGoXnk83igAEb.png"/></div></div></figure><h2 id="68a3" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">启动容器</h2><p id="adc6" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">启动所有3个容器</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="1dac" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container start redis-docker postgres-docker golang-docker</strong></span></pre><p id="eb9a" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">查看我们的应用容器</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="f3c0" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container logs golang-docker</strong></span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pg"><img src="../Images/965534b793958cc6980e2471ce01a481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1AmAwa9G-j29H7Py.png"/></div></div></figure><p id="37d3" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">正如我所料，将会发生错误，因为我们试图连接到本地主机。我们无法连接到本地主机，因为Redis和Postgres在不同的容器中。我们需要使用容器名作为主机名。所以，让我们删除<code class="fe nz oa ob nq b">golang-docker</code>容器并重新创建它。</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="c4bb" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container create --name golang-docker -e REDIS_HOST=redis-docker -e DB_HOST=postgres-docker -p 8080:8080 app-golang:1.0</strong></span></pre><p id="8af3" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">启动容器，并再次检查日志。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pg"><img src="../Images/821b1e0129609dace2bd44b03aff2573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YQppcLN1MBVvqgQU.png"/></div></div></figure><p id="1211" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">我们仍然无法连接到Redis和Postgres。这里发生了什么？如你所见，我们的应用程序出现了一个错误。这是因为我们的程序仍然找不到Redis和Postgres。在使用<em class="ov"> localhost </em>或<em class="ov"> 127.0.0.1 </em>作为主机之前，localhost指的是当前计算机或系统中的主机名。</p><p id="894a" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">如你所知，<strong class="kk io">当创建一个容器时，里面的系统将与另一个容器</strong>隔离。即使我们希望容器连接到我们的笔记本电脑或计算机，我们也需要公开容器端口并将其映射到我们的计算机端口。但是，在我们将主机名更改为容器名之后，仍然会出现错误。那么<strong class="kk io">如何让容器互相沟通呢？</strong></p><h2 id="dd57" class="nd jl in bd jm ne nf dn jq ng nh dp ju kt ni nj jy kx nk nl kc lb nm nn kg no bi translated">设置容器网络</h2><p id="e7ed" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">为了实现这一点，我们需要使用<strong class="kk io"> docker网络</strong>，它将帮助我们连接容器</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="1afa" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker network --help</strong></span></pre><ul class=""><li id="3bbd" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">创建docker网络</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="8e00" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker network create example-network</strong></span></pre><p id="6f35" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">我们可以使用以下命令来检查我们创建的网络</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="6602" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker network ls</strong></span></pre><ul class=""><li id="8516" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">设置容器网络</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="7414" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker network connect example-network golang-docker<br/>$ docker network connect example-network redis-docker<br/>$ docker network connect example-network postgres-docker</strong></span></pre><p id="ae29" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在我们将容器连接到网络之后，让我们检查我们的容器</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="c8ac" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container inspect golang-docker</strong></span></pre><p id="ab63" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">您可以在“网络”中看到我们之前创建的<strong class="kk io">示例-网络</strong>。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/943abc593e58709a0f85d801a8415024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qyl1tawEZVOEhH9K.png"/></div></div></figure><p id="57ba" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">让我们重新启动golang-app容器，并检查日志</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="c31f" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container restart golang-docker</strong></span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ph"><img src="../Images/08967439b78c68b6268c2db6c6aa375c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pvbPQxD-9he_2nkr.png"/></div></div></figure><p id="0357" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">终于接通了！恭喜我们！</p><h1 id="ca2b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">管理Docker中的数据</h1><p id="5d30" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">创建应用程序时，最好使其无状态。这意味着没有数据保存或数据存储在其他地方。然而，有些应用程序需要有状态，例如数据库。我们如何运行有状态的应用程序？我们如何保存数据，以便当我们删除一个容器时，数据仍然会保留？</p><p id="8886" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">实际上，你可以在这里阅读关于那个<a class="ae nb" href="https://docs.docker.com/storage/" rel="noopener ugc nofollow" target="_blank">的文档</a></p><p id="4557" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">Docker中管理数据的方法有很多。通常，我会使用绑定挂载，但这次我们将尝试使用卷。</p><p id="4117" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在这个例子中，我们将尝试创建一个MongoDB容器。要管理数据，首先，我们必须知道应用程序将数据保存在哪里。如果您使用docker hub 中的<a class="ae nb" href="https://hub.docker.com/_/mongo" rel="noopener ugc nofollow" target="_blank"> mongo映像，我们可以在副标题的描述中看到存储数据的位置，从那里我们可以看到mongo数据驻留在哪里，它在/data/db中。</a></p><p id="98a4" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">那么，让我们开始…</p><ul class=""><li id="a923" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">拉图像</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="21b9" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker pull mongo</strong></span></pre><ul class=""><li id="4fa9" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">创建新卷</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="0593" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker create volume mongo-test</strong></span></pre><p id="dac5" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">该卷将在我们的容器中使用。这是保存数据的地方。您可以使用以下命令检查卷在计算机中的存储位置:</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="0c9f" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker volume inspect &lt;volume-name&gt;</strong></span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="ab gu cl pi"><img src="../Images/91e178d4b05f3ba2120b6d0986ef0c3e.png" data-original-src="https://miro.medium.com/v2/format:webp/0*ArHQfIx1102s6WvA.png"/></div></figure><ul class=""><li id="6fef" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">创建容器</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="0852" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container create --name mongo-docker -v mongo-test:/data/db -p 27017:27017</strong></span></pre><p id="a75c" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在这个命令中，我们使用<code class="fe nz oa ob nq b"><strong class="kk io">-v &lt;docker_volume&gt;:&lt;data location in application&gt;</strong></code>在docker和我们的计算机之间创建卷绑定。</p><ul class=""><li id="2071" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">启动容器</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="9a35" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container start mongo-docker</strong></span></pre><ul class=""><li id="1c58" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">使用mongo客户端打开mongo DB，这里我用的是<a class="ae nb" href="https://studio3t.com/" rel="noopener ugc nofollow" target="_blank"> Studio 3T </a></li></ul><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/ca8d75261aaa7610d414297c710e7acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/0*MzLuE7ZhxAtTI8ey.png"/></div></figure><p id="9bcd" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">默认情况下，新创建的MongoDB中有3个类似上面的DB。让我们创建一个新的数据库，并在其中添加新数据</p><ul class=""><li id="ea15" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">创建一个新的数据库并插入一些数据</li></ul><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pk"><img src="../Images/bb753d586bdfc0e8fc0ba48c49f8381e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jAivSg-jczuDUmV3.png"/></div></div></figure><p id="b0e0" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在这里，我已经创建了名为test_db新的<code class="fe nz oa ob nq b"><strong class="kk io">DB</strong></code>，一个名为<code class="fe nz oa ob nq b"><strong class="kk io">test_collection</strong></code>的集合，在该集合中有1个文档</p><ul class=""><li id="d390" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">停止并删除容器</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="5840" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container stop mongo-docker</strong></span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/243485a54c89c3c0a740ed791118d595.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/0*5WcNdaNN0VG2-DFp.png"/></div></figure><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="9148" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker container rm mongo-docker</strong></span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/5bba4abdf4453ca26735c75b418a531c.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/0*Op7jY9h7LGA1-9Wv.png"/></div></figure><ul class=""><li id="3f9d" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">使用步骤3和4中的相同命令再次创建并启动容器</li><li id="4068" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated">使用Mongo客户端再次检查数据库</li></ul><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi pk"><img src="../Images/f5966aeaf1b427fdeb47a522b232ff80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q3ve1yinBt2eNpP2.png"/></div></div></figure><p id="dca6" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">你会看到，你的数据还在那里。恭喜你！</p><p id="e629" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">这是如何在docker中管理数据的一种方法，在docker中管理数据还有很多方法。请务必阅读<a class="ae nb" href="https://docs.docker.com/storage/" rel="noopener ugc nofollow" target="_blank">文档</a>。在那里你将知道使用什么方法以及如何根据你的需要使用它。</p><h1 id="da60" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Docker撰写</h1><p id="c4a2" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们已经学会了整合我们的容器。在前面的例子中，我们使用了3个容器，但是如果我们的应用程序或系统需要更多呢？每一步手动做都会有问题吧？因此，Docker Compose将帮助我们自动化这个过程。</p><p id="4899" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">基本上，使用Docker Compose有3个步骤，这些步骤是:</p><ol class=""><li id="6b14" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf pn lo lp lq bi translated">用一个<code class="fe nz oa ob nq b"><strong class="kk io">Dockerfile</strong></code>来定义你的应用环境，这样它可以在任何地方被复制。</li><li id="4389" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf pn lo lp lq bi translated">在<code class="fe nz oa ob nq b"><strong class="kk io">docker-compose.yml</strong></code>中定义组成您的应用程序的服务，以便在一个隔离的环境中一起运行。</li><li id="2589" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf pn lo lp lq bi translated">运行<code class="fe nz oa ob nq b"><strong class="kk io">docker-compose up</strong></code>，Compose会启动并运行你的整个应用程序。</li></ol><p id="6fec" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在步骤1中，我们已经学习了如何创建<code class="fe nz oa ob nq b"><strong class="kk io">Dockerfile</strong></code>，所以我们将关注步骤2，如何创建<code class="fe nz oa ob nq b"><strong class="kk io">docker-compose.yml</strong></code>文件，以及步骤3，如何运行它。</p><p id="f829" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">让我们创造我们的<code class="fe nz oa ob nq b"><strong class="kk io">docker-compose.yml</strong></code>，</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="ff99" class="nd jl in nq b gy nu nv l nw nx">version: "3.9" # optional since v1.27.0</span><span id="1246" class="nd jl in nq b gy on nv l nw nx">services:<br/>  db:<br/>    container_name: postgres-comose<br/>    image: postgres<br/>    ports:<br/>      - 5432:5432<br/>    networks:<br/>      - compose-network<br/>    environment:<br/>      - POSTGRES_DB=docker-demo<br/>      - POSTGRES_PASSWORD=mysecretpassword<br/>  cache:<br/>    container_name: redis-compose<br/>    image: redis<br/>    ports:<br/>      - 6379:6379<br/>    networks:<br/>      - compose-network<br/>  app:<br/>    container_name: golang-compose<br/>    # image: app-golang:1.0<br/>    build:<br/>      context: .<br/>      dockerfile: Dockerfile<br/>    ports:<br/>      - 8080:8080<br/>    restart: unless-stopped<br/>    networks:<br/>      - compose-network<br/>    depends_on:<br/>      - db<br/>      - cache<br/>    environment:<br/>      - REDIS_HOST=redis-compose<br/>      - DB_HOST=postgres-compose<br/>      - MYNAME=REPOERNA</span><span id="f6be" class="nd jl in nq b gy on nv l nw nx">networks:<br/>  compose-network:<br/>    name: new-example-network</span></pre><p id="eada" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated"><strong class="kk io">*注:在app服务环境中，我们使用REDIS_HOST和DB_HOST使用REDIS和Postgres容器名</strong></p><p id="cef0" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">好吧，我会解释我们写的东西。在文件的根目录下，我们有:</p><ul class=""><li id="10e6" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">version</strong></code>定义撰写发布。每个版本都有我们可以使用的不同特性和参数。你可以在这里 阅读各个版本<a class="ae nb" href="https://docs.docker.com/compose/compose-file/compose-versioning/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk io">的兼容矩阵。如果通过</strong>缺省省略<code class="fe nz oa ob nq b"><strong class="kk io">version</strong></code> <strong class="kk io">，它将使用版本1。</strong></a></li><li id="da85" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">services</strong></code>定义了我们系统中的所有服务。在我们的例子中，在我们使用Postgres、Redis和golang app之前，这3个服务将在这里定义。</li><li id="282a" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">network</strong></code>定义网络将被使用，如果你还没有创建网络，它将被自动创建，并且你可以在这里创建多个网络。</li></ul><p id="140a" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在服务内部，有服务名；我们有数据库、缓存和应用程序。对于每个服务，我们将定义一个将在每个服务上使用的参数。这些参数是:</p><ul class=""><li id="5b9d" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">container_name</strong></code>定义名称服务容器。</li><li id="7c9e" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">image</strong></code>定义将用于创建容器的图像。</li><li id="c413" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">port</strong></code>定义端口绑定，将容器内部的端口暴露给外部环境。</li><li id="aa6f" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">networks</strong></code>定义服务将使用的网络。</li><li id="a4e2" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">depends_on</strong></code>定义app services需要的其他服务。</li><li id="38ae" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf ln lo lp lq bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">environment</strong></code>定义容器内部的环境变量。</li></ul><p id="4183" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">在<code class="fe nz oa ob nq b"><strong class="kk io">app</strong></code>服务中，我们将使用<code class="fe nz oa ob nq b">build</code>来构建图像，而不是使用图像，在<code class="fe nz oa ob nq b"><strong class="kk io">build</strong></code>下面有<code class="fe nz oa ob nq b"><strong class="kk io">context</strong></code>来定义将用于构建图像的Dockerfile的位置，还有<code class="fe nz oa ob nq b"><strong class="kk io">dockerfile</strong></code>来定义docker file文件名。</p><p id="98ce" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">要运行Docker Compose，我们需要使用一些命令，您可以使用</p><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="2b0e" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker-compose</strong></span></pre><p id="dd60" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">它将向您显示命令列表及其功能的简短描述。你需要知道如何正确使用它。我经常使用的命令有:</p><ul class=""><li id="7fc8" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">docker-compose build</strong></code></li></ul><p id="ed7c" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">如果您使用的是<code class="fe nz oa ob nq b"><strong class="kk io">build</strong></code>而不是<code class="fe nz oa ob nq b"><strong class="kk io">docker-compose.yml</strong></code>中的<code class="fe nz oa ob nq b"><strong class="kk io">image</strong></code>，它将重建映像，如果您的服务使用现有映像，将会出现错误。</p><ul class=""><li id="41b0" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">docker-compose up -d</strong></code></li></ul><p id="76b9" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">它将创建并启动容器，最好使用<code class="fe nz oa ob nq b">-d</code>或守护模式，在后台运行进程。</p><ul class=""><li id="d60a" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated"><code class="fe nz oa ob nq b"><strong class="kk io">docker-compose down</strong></code></li></ul><p id="88e9" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">它将停止并删除容器、网络、图像和卷。请注意，如果您在服务中使用数据库，当您使用此命令时，数据也将被删除。</p><p id="91c8" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">那么，让我们运行Docker Compose</p><ul class=""><li id="87ad" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">重建形象</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="195f" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker-compose build</strong></span></pre><p id="8268" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">该过程与<code class="fe nz oa ob nq b"><strong class="kk io">docker build</strong></code>相同</p><ul class=""><li id="21aa" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">启动服务</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="7633" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker-compose up -d</strong></span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi po"><img src="../Images/f89d3df5a302d91c14e0f35d42e072e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/0*c_rG9VRdyk36akpP.png"/></div></div></figure><ul class=""><li id="0fe7" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">查看我们的申请</li></ul><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/73d5234c210f0bfc6febae630a6e4f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hm94NkBt7nxwmiyQ.png"/></div></div></figure><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/f47e6a42d4c15d4326625bd2f73da6b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/0*U8x1gAWZa6OuW-K7.png"/></div></figure><p id="65b9" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">我们的服务开始了！没有发生错误。</p><ul class=""><li id="bc81" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf ln lo lp lq bi translated">打扫</li></ul><pre class="mm mn mo mp gt np nq nr ns aw nt bi"><span id="bb5f" class="nd jl in nq b gy nu nv l nw nx"><strong class="nq io">$ docker-compose down</strong></span></pre><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/6cc46e233139b19981895bfa6e1dbd34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/0*ABuD6vGLfoclaqvH.png"/></div></figure><h1 id="8ced" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Docker工具— Kitematic</h1><p id="004d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Docker工具是一个软件，你可以用它来帮助你使用GUI管理Docker。Docker有自己的工具，叫做Docker Desktop，但是只针对Windows和macOS。对于Linux，我更喜欢使用Kitematic，因为它也可以在Windows，macOS上运行。它也比Docker桌面拥有更多的功能。</p><p id="3352" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">其特点是:</p><ol class=""><li id="554f" class="lg lh in kk b kl li kp lj kt lk kx ll lb lm lf pn lo lp lq bi translated">创建、删除、启动和停止容器</li><li id="6b45" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf pn lo lp lq bi translated">查看容器日志</li><li id="8531" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf pn lo lp lq bi translated">管理卷</li><li id="8f30" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf pn lo lp lq bi translated">添加环境变量</li><li id="be8c" class="lg lh in kk b kl lr kp ls kt lt kx lu lb lv lf pn lo lp lq bi translated">命令行访问</li></ol><p id="3d73" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">您可以在上查看详细信息</p><p id="d19c" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">你可以在Kitematic网站或<a class="ae nb" href="https://docs.docker.com/kitematic/userguide/" rel="noopener ugc nofollow" target="_blank"> docker文档</a>上查看详情。</p><h1 id="d756" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><a class="ae nb" href="https://www.docker.com/sites/default/files/d8/2019-09/docker-cheat-sheet.pdf" rel="noopener ugc nofollow" target="_blank"> Docker备忘单</a></h1></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h1 id="778a" class="jk jl in bd jm jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh bi translated">参考文献</h1><p id="f354" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">[1] <a class="ae nb" href="https://www.simplilearn.com/tutorials/docker-tutorial/what-is-dockerfile" rel="noopener ugc nofollow" target="_blank">什么是Dockerfile:你需要知道的一切</a></p><p id="ed56" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">[2] <a class="ae nb" href="https://www.oracle.com/cloud-native/container-registry/what-is-docker/" rel="noopener ugc nofollow" target="_blank"> Docker容器和容器云服务</a></p><p id="c97c" class="pw-post-body-paragraph ki kj in kk b kl li kn ko kp lj kr ks kt lw kv kw kx lx kz la lb ly ld le lf ig bi translated">【3】<a class="ae nb" href="http://oracle-help.com/oracle-cloud/basic-docker-oracle/" rel="noopener ugc nofollow" target="_blank">Oracle中关于Docker的基本</a></p></div></div>    
</body>
</html>