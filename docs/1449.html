<html>
<head>
<title>A Look Inside JavaScript by a Java Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java开发人员对JavaScript的深入了解</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/look-inside-javascript-by-java-developer-f3a20998e47b?source=collection_archive---------2-----------------------#2017-06-15">https://medium.com/capital-one-tech/look-inside-javascript-by-java-developer-f3a20998e47b?source=collection_archive---------2-----------------------#2017-06-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="d923" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">我已经做了九个月的网页开发员了！T3】</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/ccf62c3119e1e8f47d0530f7821c78c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ylTSVVfX5-mTwOZCmREFUg.jpeg"/></div></div></figure><p id="7689" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在此之前，我做了五年的Android/iOS开发人员，开发过Java和Swift这两种基于编译器的语言。但是在过去的九个月里，我一直在用基于运行时语言的JavaScript编写代码。</p><p id="0523" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">这些语言有一些特征差异。下面是我转行到web开发时发现的最有趣的一个小列表。</p><h1 id="0f49" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak"> 1。静态打字与动态打字</strong></h1><p id="6ea5" class="pw-post-body-paragraph jj jk hh jl b jm kx ii jo jp ky il jr js kz ju jv jw la jy jz ka lb kc kd ke ha bi translated">Java是一种静态类型语言，它将代码编译成JVM字节码，然后解释成机器语言。相反，JavaScript是一种动态类型语言，它在运行时解释代码。这在实践中意味着什么？</p><p id="3a13" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">用两种语言思考这个例子:</p><h2 id="57e7" class="lc kg hh bd kh ld le lf kl lg lh li kp js lj lk kr jw ll lm kt ka ln lo kv lp bi translated"><strong class="ak"> Java </strong></h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="ce2f" class="lc kg hh lr b fi lv lw l lx ly">public float getShipping(String state) {<br/>    return ON_CAMPAIGN ? 0.f : SHIPPING.get(state);<br/>}</span><span id="a27f" class="lc kg hh lr b fi lz lw l lx ly">public float getTotalPrice(String price, String state) {<br/>    float withShipping = price + getShipping(state); // Compiler error<br/>     ...<br/>}</span></pre><h2 id="bc16" class="lc kg hh bd kh ld le lf kl lg lh li kp js lj lk kr jw ll lm kt ka ln lo kv lp bi translated">java描述语言</h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="8fe1" class="lc kg hh lr b fi lv lw l lx ly">function shipping(state) {<br/>    return onCampaign ? 0 : shipping[state];<br/>}</span><span id="13cf" class="lc kg hh lr b fi lz lw l lx ly">function totalPrice(price, state) {<br/>    ...<br/>    const withShipping = price + shipping(state);      <br/>    console.log(withShipping);              // this prints ???<br/>}</span></pre><p id="040f" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">由于类型不匹配，上面的Java代码无法编译。Java告诉你，你正在做的事情是错误的，以防止在你运行代码之前出现小错误。</p><p id="ed11" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">上面的JavaScript代码不会让您知道可能有问题。虽然乍一看可能没什么问题，但是让我们想想这段代码打印出了什么。</p><p id="fdd2" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">当<strong class="jl hi"> <em class="ma">价格</em> </strong>为10.0且<strong class="jl hi"> <em class="ma">发货【状态】</em> </strong>返回2.0，则console.log输出12.0。如果<strong class="jl hi"> <em class="ma">发货【状态】</em> </strong>返回“2.0”怎么办？现在<strong class="jl hi"> <em class="ma"> console.log </em> </strong>打印出“102.0”。在运行之前，我们无法保证这段代码会产生什么结果。</p><p id="73a7" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">使用基于编译器的语言，如Java，您需要预先付出努力来修复可能的错误，并减少运行时出错的机会。这样，通过编译器就像一种单元测试，你需要通过它来验证你的逻辑。而对于基于运行时的语言，比如JavaScript，直到运行时你才会意识到错误。为了防止它们，你需要写更多的测试来确保你将得到更少的运行时错误。</p><h1 id="41ff" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak"> 2。猴子补丁vs无猴子补丁</strong></h1><p id="9d85" class="pw-post-body-paragraph jj jk hh jl b jm kx ii jo jp ky il jr js kz ju jv jw la jy jz ka lb kc kd ke ha bi translated">JavaScript的一个特性是你可以动态地修改函数的行为；这种技术被称为猴子补丁。也就是说，<em class="ma">不用对应用程序代码做任何修改，就可以交换一个依赖的实现。</em></p><p id="a0c9" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在Java中，由于代码必须被编译，所以在运行代码之前，每个类和函数的定义都必须被定义(不可变)。依赖注入必须到位，以便能够在运行代码之前交换行为。</p><p id="878e" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们看一个例子。假设我有一个名为order.js的类，我使用Jest测试了order.js中的一个函数。</p><h2 id="eed9" class="lc kg hh bd kh ld le lf kl lg lh li kp js lj lk kr jw ll lm kt ka ln lo kv lp bi translated"><strong class="ak"> order.js </strong></h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="438a" class="lc kg hh lr b fi lv lw l lx ly">const shipping = require('./shipping');<br/>const tax = require('./tax');</span><span id="91de" class="lc kg hh lr b fi lz lw l lx ly">module.exports = {<br/>    totalPrice: function totalPrice (price, state) {<br/>        const shippingFee = shipping.fee(state);<br/>        const tax = tax.get(price, state);<br/>    <br/>        return price + shippingFee + tax;<br/>    }<br/>}</span></pre><p id="9e49" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">您可以看到<strong class="jl hi"> <em class="ma"> shipping </em> </strong>和<strong class="jl hi"> <em class="ma"> tax </em> </strong>是本地依赖项，在该文件中需要使用。这是测试。</p><h2 id="a0c6" class="lc kg hh bd kh ld le lf kl lg lh li kp js lj lk kr jw ll lm kt ka ln lo kv lp bi translated"><strong class="ak"> order-test.js </strong></h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="8897" class="lc kg hh lr b fi lv lw l lx ly">jest.mock('./tax');<br/>jest.mock('./order');</span><span id="d5a5" class="lc kg hh lr b fi lz lw l lx ly">const shipping = require('./shipping');<br/>const tax = require('./tax');<br/>const order = require('./order');</span><span id="a251" class="lc kg hh lr b fi lz lw l lx ly">it('should return total price with shipping and tax', function () {<br/>    shipping.fee = jest.fn();<br/>    tax.get = jest.fn();<br/>      <br/>    shipping.fee.mockReturnValue(6.0);<br/>    tax.get.mockReturnValue(7.5);</span><span id="9021" class="lc kg hh lr b fi lz lw l lx ly">    expect(order.totalPrice(100.0, 'CA')).toEqual(113.5);<br/>});</span></pre><p id="60b7" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在这个测试文件中，我用Jest函数重写了<strong class="jl hi"> <em class="ma"> shipping.fee </em> </strong>和<strong class="jl hi"> <em class="ma"> tax.get </em> </strong>的实现，而order.js中没有任何特殊代码。当<strong class="jl hi"><em class="ma">order . total price</em></strong>在那一行之后运行时，<strong class="jl hi"> <em class="ma"> shipping.fee </em> </strong>和<strong class="jl hi"> <em class="ma"> tax.get </em> </strong>不是order.js相反，它成为Jest的实现。这部分归功于Jest框架；然而底线是JavaScript可以动态地覆盖函数的行为。</p><p id="5960" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在Java中，同样的测试不像在JavaScript中那么瘦。Java是一种基于编译器的语言，所以所有的功能都与我定义的内容绑定在一起，并且在运行时不可互换。因此，如果我为一个具有本地依赖的类编写测试，我必须要么通过公共函数让这个类接受依赖，要么使用依赖注入框架来处理依赖。</p><p id="5685" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">为了演示这一点，我将使用名为<a class="ae mb" href="https://google.github.io/dagger/" rel="noopener ugc nofollow" target="_blank"> Dagger </a>的Java依赖注入框架重写上面的JavaScript测试示例。</p><p id="cea5" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我将使用<a class="ae mb" href="http://junit.org/junit4/" rel="noopener ugc nofollow" target="_blank"> JUnit </a>进行Java测试。测试场景与上面的JavaScript示例相同。我有一个叫Order.java的类，我在Order.java测试一个函数。</p><p id="581f" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">首先，Order类需要以依赖注入的方式编写。</p><h2 id="7662" class="lc kg hh bd kh ld le lf kl lg lh li kp js lj lk kr jw ll lm kt ka ln lo kv lp bi translated"><strong class="ak">Order.java</strong></h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="82c1" class="lc kg hh lr b fi lv lw l lx ly">public class Order {<br/> <br/>    @Inject<br/>    Shipping shipping;<br/> <br/>    @Inject<br/>    Tax tax;<br/> <br/>    public Order() {<br/>        DaggerOrderComponent.<em class="ma">builder</em>()<br/>            .orderModule(new OrderModule())<br/>            .build()<br/>            .inject(this);<br/>    }<br/> <br/>    public float getTotalPrice(float price, String state) {<br/>        float shippingFee = shipping.fee(state);<br/>        float taxValue = tax.get(price, state);<br/> <br/>        return price + shippingFee + taxValue;<br/>    }<br/>}</span></pre><p id="4212" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">@Inject是Dagger注释，使一个字段可以从这个类和<strong class="jl hi"><em class="ma">daggerordercomponent . builder()外部注入。orderModule(新的OrderModule())。构建()。注射(这个)；</em> </strong>将注入所有@Inject注释字段(依赖)。</p><p id="a4e5" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">其次，我需要准备一个类来注入生产代码依赖，另一个类来注入测试代码依赖(即被模仿的对象)到订单类。</p><h2 id="4c2e" class="lc kg hh bd kh ld le lf kl lg lh li kp js lj lk kr jw ll lm kt ka ln lo kv lp bi translated"><strong class="ak">OrderModule.java(用于生产代码相关性)</strong></h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="27c7" class="lc kg hh lr b fi lv lw l lx ly">@Module<br/>public class OrderModule {<br/> <br/>    @Provides<br/>    @Singleton<br/>    public Shipping provideShipping() {<br/>        return new Shipping();<br/>    }<br/> <br/>    @Provides<br/>    @Singleton<br/>    public Tax provideTax() {<br/>        return new Tax();<br/>    }<br/>}</span></pre><p id="d415" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">@Module类包含一组函数，这些函数提供了要注入的依赖项。这些函数被注释为@Provides，它返回一个类，该类将被注入到另一个类的@Inject注释字段中。为了测试，我不想使用实际的<strong class="jl hi"><em class="ma"/></strong>和<strong class="jl hi"> <em class="ma">税</em> </strong>类。相反，我想用这些的模拟类。因此，我为测试编写了@Module类，如下所示:</p><p id="58e9" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">我将使用<a class="ae mb" href="http://site.mockito.org/" rel="noopener ugc nofollow" target="_blank"> Mockito </a>来生成模拟类。</p><h2 id="8680" class="lc kg hh bd kh ld le lf kl lg lh li kp js lj lk kr jw ll lm kt ka ln lo kv lp bi translated"><strong class="ak">TestOrderModule.java(用于测试代码依赖)</strong></h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="3bf9" class="lc kg hh lr b fi lv lw l lx ly">@Module<br/>public class OrderTestModule {<br/> <br/>    @Mock<br/>    Shipping shipping;<br/> <br/>    @Mock<br/>    Tax tax;<br/> <br/>    public OrderTestModule() {<br/>        MockitoAnnotations.initMocks(this);<br/>    }<br/> <br/>    @Provides<br/>    @Singleton<br/>    public Shipping provideShipping() {<br/>        return shipping;<br/>    }<br/> <br/>    @Provides<br/>    @Singleton<br/>    public Tax provideTax() {<br/>        return tax;<br/>    }<br/>}</span></pre><p id="627c" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">现在，我可以将这个测试模块注入到Order类中，这样我就可以通过使用模拟的类来测试Order类。</p><h2 id="f46a" class="lc kg hh bd kh ld le lf kl lg lh li kp js lj lk kr jw ll lm kt ka ln lo kv lp bi translated"><strong class="ak">OrderTest.java</strong></h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="5259" class="lc kg hh lr b fi lv lw l lx ly">@Test<br/>public void testGetTotalPrice() {<br/>    OrderTestModule module = new OrderTestModule();<br/>    Order order = new Order();</span><span id="57a3" class="lc kg hh lr b fi lz lw l lx ly">    // Inject mocked classes in Order class        <br/>    DaggerOrderTestComponent<br/>        .<em class="ma">builder</em>()<br/>        .orderTestModule(module)<br/>        .build()<br/>        .inject(order);<br/> <br/>    <em class="ma">when</em>(module.shipping.fee("")).thenReturn(6.f);<br/>    <em class="ma">when</em>(module.tax.get(0.f, "")).thenReturn(7.5f);</span><span id="e4a8" class="lc kg hh lr b fi lz lw l lx ly">    float result = order.getTotalPrice(100.f, "CA");<br/> <br/>    <em class="ma">assertEquals</em>(result, 113.5f);<br/>}</span></pre><p id="97a6" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">正如您所注意到的，与JavaScript相比，具有本地依赖性的Java需要更多的代码来使类可测试。基于编译器的语言，如Java，由于其语言模型，不能动态地修改函数的实现，而JavaScript可以动态地改变函数的行为。</p><h1 id="fc10" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">3.面向对象编程与函数式编程</h1><p id="fed6" class="pw-post-body-paragraph jj jk hh jl b jm kx ii jo jp ky il jr js kz ju jv jw la jy jz ka lb kc kd ke ha bi translated">包括Java在内的面向对象编程(OOP)有一个对象的概念，其中一个类定义对象的属性(字段)并控制这些属性(方法)。类别会维护物件的状态。</p><p id="4346" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">包括JavaScript在内的函数式编程是通过计算数据来定义的，不需要保持状态，也不需要用函数来改变状态。这种范式中的函数只依赖于它的输入，而输出是由只基于输入的计算产生的。</p><p id="8da0" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">让我们看一个真实的例子。假设我下面有一个cart.js文件。这个函数不包含任何状态，每个函数只依赖于它的输入。</p><h2 id="5266" class="lc kg hh bd kh ld le lf kl lg lh li kp js lj lk kr jw ll lm kt ka ln lo kv lp bi translated"><strong class="ak"> cart.js </strong></h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="84ca" class="lc kg hh lr b fi lv lw l lx ly">module.exports = {</span><span id="5ec5" class="lc kg hh lr b fi lz lw l lx ly">  addItem: function (cart, newItem, qty) {<br/>    const itemsInCart = cart.items.filter(function (item, index) {<br/>      return item.id === newItem.id;<br/>    });</span><span id="456b" class="lc kg hh lr b fi lz lw l lx ly">    // closeDeep from lodash<br/>    const updatedCart = cloneDeep(cart);<br/>    if (itemsInCart.length === 0) {<br/>      updatedCart.items.push({<br/>        item: newItem,<br/>        qty<br/>      });<br/>    }</span><span id="dd81" class="lc kg hh lr b fi lz lw l lx ly">    // Get total price of cart contents.<br/>    // (omit implementation of totalPrice)<br/>    updatedCart.totalPrice = totalPrice(updatedCart.items);</span><span id="6bbd" class="lc kg hh lr b fi lz lw l lx ly">    return updatedCart;<br/>  },</span><span id="52d9" class="lc kg hh lr b fi lz lw l lx ly">  updateQty: function (cart, itemId, newQty) {<br/>    const updatedItems = cart.items.map(function (item) {<br/>      if (item.id === itemId) {<br/>        item.qty = newQty;<br/>      }<br/>      return item;<br/>    });<br/>    <br/>    const updatedCart = cloneDeep(cart);<br/>    updatedCart.items = updatedItems;<br/>    // (omit implementation of totalPrice)<br/>    updatedCart.totalPrice = totalPrice(updatedItems);</span><span id="dff8" class="lc kg hh lr b fi lz lw l lx ly">    return updatedCart;<br/>  }<br/>}</span></pre><p id="f1ef" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">由于函数式编程不保留任何状态，所以“cart”需要总是被传递。</p><p id="5c53" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">如果我利用OOP的一个原则——<em class="ma">封装</em>——用OOP范式把它翻译成Java，我可以写如下。</p><h2 id="1f5b" class="lc kg hh bd kh ld le lf kl lg lh li kp js lj lk kr jw ll lm kt ka ln lo kv lp bi translated"><strong class="ak">Cart.java</strong></h2><pre class="iy iz ja jb fd lq lr ls lt aw lu bi"><span id="4b7c" class="lc kg hh lr b fi lv lw l lx ly">public class Cart {<br/>    <br/>    private ProductDao productDao;<br/>     <br/>    private float totalPrice = 0.f;<br/>    private List&lt;Product&gt; items = new ArrayList&lt;&gt;();</span><span id="162a" class="lc kg hh lr b fi lz lw l lx ly">    public Cart() {<br/>        productDao = new ProductDao();<br/>    }</span><span id="a468" class="lc kg hh lr b fi lz lw l lx ly">    public void addItem(String productId, String qty) {<br/>        if (indexOfItem(productId) == -1) {<br/>            tems.add(productDao.get(productId));<br/>        }<br/>        // (Omit the implementation)<br/>        updateTotalPrice();<br/>    }<br/>  <br/>    public void updateQty(String productId, int qty) {<br/>        Product product = productDao.get(productId);<br/>        product.setQty(qty);<br/>        items.set(indexOfItem(productId), product);<br/>        // (Omit the implementation)<br/>        updateTotalPrice();<br/>    }</span><span id="79dc" class="lc kg hh lr b fi lz lw l lx ly">    public float getTotalPrice() {<br/>        return totalPrice;<br/>    }<br/> <br/>    public List&lt;Product&gt; getItems() {<br/>        return items;<br/>    }<br/>  <br/>    private int indexOfItem(String productId) {<br/>        for (int i = 0; i &lt; items.size(); i++) {<br/>            if (items.get(i).getProductId().equals(productId)) {<br/>                return i;<br/>            }<br/>        }<br/>         <br/>        return -1;<br/>    }<br/>}</span></pre><p id="df8e" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">这个Cart类跟踪属性<strong class="jl hi"> <em class="ma">总价</em> </strong>和<strong class="jl hi"> <em class="ma">项目</em> </strong>。因此，类的使用者只传递最少的信息来执行操作。然而，在JavaScript示例中，传递给该函数的<strong class="jl hi"> <em class="ma"> cart </em> </strong>可能不会在每次调用该函数时都具有相同的结构。在Java示例中，用户只能执行某些操作，不能直接接触属性。</p><p id="5cec" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">函数式编程要求所有函数都是纯函数。因此，它易于测试、易于调试，并且是线程安全的(完全没有状态！).然而，由于所有函数都依赖于输入，因此消费者有责任跟踪从函数返回并作为输入传递给其他函数的数据。</p><p id="cd2c" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">面向对象编程保留了状态，并封装了对状态的控制，减少了一些重复代码，增加了代码的可重用性。一般来说，消费者应该能够在不知道函数实现的情况下使用函数，因为复杂的逻辑/状态管理隐藏在包含函数的对象内部。</p><h1 id="d0cc" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated"><strong class="ak">结论</strong></h1><p id="1bdd" class="pw-post-body-paragraph jj jk hh jl b jm kx ii jo jp ky il jr js kz ju jv jw la jy jz ka lb kc kd ke ha bi translated">从移动开发过渡到web开发是一个有趣的旅程！JavaScript和Java是两种截然不同的语言，直到我做出改变，我才意识到这一点。我已经列出了一些我觉得有趣的主要区别，但是你还可以列出更多。</p><p id="c5b5" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">两者都有特定的优势，了解各自的特点将有助于您确定哪种语言最适合哪种情况。当然，这不仅仅适用于JavaScript和Java。您可以将此应用于任何静态类型或动态类型语言，以确定哪种语言适合您的项目。这同样适用于面向对象编程或函数式编程语言。关键的一点是，无论你选择哪一种，都要了解它的特点，并确保利用它的特长！</p></div><div class="ab cl mc md go me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ha hb hc hd he"><p id="2a5d" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><em class="ma">声明:这些观点仅代表作者个人观点。除非本帖中另有说明，否则Capital One不属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权都是其各自所有者的所有权。本文为2017首都一。</em></p><p id="0172" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated"><em class="ma">欲了解更多关于Capital One的API、开源、社区活动和开发者文化，请访问我们的一站式开发者门户DevExchange。</em><a class="ae mb" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank"><em class="ma">https://developer.capitalone.com/</em></a></p></div></div>    
</body>
</html>