<html>
<head>
<title>My Twelve Favorite ES6/ES2015 Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我最喜欢的12项ES6/ES2015功能</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/my-12-favorite-es6-es2015-features-76e70397fee0?source=collection_archive---------0-----------------------#2016-04-19">https://medium.com/capital-one-tech/my-12-favorite-es6-es2015-features-76e70397fee0?source=collection_archive---------0-----------------------#2016-04-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex ie if ig ih er es paragraph-image"><div class="ab fe cl ii"><img src="../Images/94c827b571141bc797cf917dad815adf.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ntc_sKT1wTsib-iq-I0tWQ.jpeg"/></div></figure><p id="9cd5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你知道ES6是什么吗？这是一个新的JavaScript标准！如果你是一名尚未使用ES6(官方名称为ES2015或ECMAScript 2015)的企业JavaScript开发人员，那么请继续升级你的技能，这是该语言自2009年以来的第一次重大更新。这篇文章将向您快速介绍ES6的12个特性，这个标准正在改变世界上最流行的编程语言——JavaScript。</p><p id="8277" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">排名不分先后，这里列出了我最喜欢的12个ES6特性，每个企业开发人员都应该知道:</p><ol class=""><li id="3675" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">默认参数</li><li id="db8f" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">静止和伸展参数</li><li id="c247" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">模板文字</li><li id="00e6" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">多行字符串</li><li id="2dfe" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">解构分配</li><li id="230e" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">增强的对象文字</li><li id="7819" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">箭头功能</li><li id="50ea" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">承诺</li><li id="2c9a" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">块范围的构造:Let和Const</li><li id="5ee5" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">班级</li><li id="1dcc" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">模块</li><li id="2209" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">为了理解</li></ol><p id="2a48" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">过去，许多企业开发人员怀疑JavaScript是否可以作为一种可行的编程语言；而是偏爱Java、Python或C++等语言。公平地说，早期的JavaScript有它的<a class="ae jx" href="http://archive.oreilly.com/pub/a/javascript/excerpts/javascript-good-parts/bad-parts.html" rel="noopener ugc nofollow" target="_blank">怪癖</a>，但是ES6代表了JavaScript的重大进步。</p><p id="b3ca" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们看看语言的历史——那些不知道历史的人不能创造它。简短的JavaScript时间表:</p><p id="0188" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi"> 1995年:</strong> JavaScript在网景公司诞生为LiveScript</p><p id="2329" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi"> 1997年:</strong> ECMAScript标准由欧洲计算机制造商协会制定</p><p id="8cf6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">1999年: ES3问世，IE5风靡一时</p><p id="fb14" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">2000年至2005年:XMLHttpRequest(又名AJAX)在Outlook Web Access (2000年)和Oddpost (2002年)、Gmail (2004年)和Google Maps (2005年)等应用程序中广受欢迎</p><p id="6b29" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi"> 2009: </strong> ES5出来了(这是我们大多数人现在用的)带有<em class="jy"> forEach，Object.keys，Object.create </em>(专门为<a class="ae jx" href="http://www.crockford.com/" rel="noopener ugc nofollow" target="_blank">道格拉斯·克洛克福特</a>)和标准JSON</p><p id="0088" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">2015:</strong>ES6/ecmascript 2015出来修复了ES5很多有问题的部分</p><p id="59d5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">2016年: ES7即将面世</p><p id="ce18" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">JavaScript历史课已经讲得够多了，让我们进入编码的正题，更深入地了解这次ES6更新和我最喜欢的12个JavaScript新特性。</p></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><h2 id="e23a" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">1.ES6中的默认参数</h2><p id="4982" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">当我们编写模块时，我们需要考虑参数被省略的情况。换句话说，好的模块必须足够智能，能够拥有参数的默认值。在ES5中，您可以编写类似下面的代码，它使用逻辑OR (||):</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="2a28" class="kg kh hh ll b fi lp lq l lr ls">var getAccounts = function(limit) {<br/>  var limit = limit || 10<br/>  ...<br/>}<br/><br/>var link = function (height, color, url) {<br/>    var height = height || 50<br/>    var color = color || 'red'<br/>    var url = url || 'http://capitalone.io'<br/>    ...<br/>}</span></pre><p id="d703" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">除了边缘情况之外，这些语句工作得很好。例如，如果值为0 —因为在JavaScript中0是falsy条件默认为硬编码的值，而不是成为值本身，这在某些情况下可能是您所希望的。当然，谁需要0作为值(#sarcasmfont)，所以我们只是忽略了这个缺陷，使用逻辑OR反正…</p><p id="cf82" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">或者可能事件一个if/else条件来检查未定义的值:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="b206" class="kg kh hh ll b fi lp lq l lr ls">var getAccounts = function(limit) {<br/>  if (typeof limit == 'undefined')  limit = 10<br/>  ...<br/>}</span></pre><p id="b021" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">不再有了！在ES6中，我们可以将默认值放在函数的签名中，如下所示:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="f22e" class="kg kh hh ll b fi lp lq l lr ls">var getAccounts = function(limit = 10) {<br/>  ...<br/>}<br/>var link = function(height = 50, color = 'red', url = 'http://capitalone.io') {<br/>  ...<br/>}</span></pre><p id="e04a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这不仅使用了更少的代码行，而且增加了可读性。顺便说一句，这个语法类似于Ruby和Python！</p><h2 id="8ef5" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">2.ES6中的静止和伸展参数</h2><p id="d73b" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">如果你曾经使用或编写过一个带有变量甚至无限数量参数的JavaScript函数，你就会知道<em class="jy">参数</em>对象。该对象包含传递给函数的所有参数。问题是这个<em class="jy">自变量</em>对象不是一个真正的数组。如果你想显式地使用像<em class="jy">排序</em>或<em class="jy">映射</em>这样的函数，你必须把它转换成一个数组。例如，这个请求函数使用<em class="jy"> call() </em>转换<em class="jy">参数</em>:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="f1c6" class="kg kh hh ll b fi lp lq l lr ls">function request(url, options, callback){<br/>  var args = Array.prototype.slice.call(arguments, f.length);<br/>  var url = args[0]<br/>  var callback = args[2]<br/>  // …<br/>}</span></pre><p id="871c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">那么在ES6中有没有更好的方法来访问数组形式的无限数量的参数呢？是啊！这是rest参数语法，用省略号定义。例如，这是带有rest参数<em class="jy">回调</em>的ES6函数签名，回调成为带有其余参数的数组:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5946" class="kg kh hh ll b fi lp lq l lr ls">function(url, options, ...callbacks) {<br/>  var callback1 = callbacks[0]<br/>    var callback2 = callbacks[2]<br/>  // ...<br/>}</span></pre><p id="ed48" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">注意:在rest数组中，第一个参数是没有名字的，例如，回调是在索引0处，而不是像ES5的<em class="jy">参数</em>中那样在索引2处。此外，在rest参数后放置其他命名参数将导致一个<strong class="in hi">语法错误</strong>。rest参数是对JavaScript的一个很好的修饰，因为它取代了不是真正数组的<em class="jy"> arguments </em>对象。</p><p id="3251" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在ES5中，如果你想使用一个数组作为函数的参数，你必须使用<em class="jy"> apply() </em>函数:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="b6fd" class="kg kh hh ll b fi lp lq l lr ls">function request(url, options, callback) { <br/>  // ...<br/>}<br/>var requestArgs = ['http://capitalone.io', {...}, function(){...}]<br/>request.apply(null, requestArgs)</span></pre><p id="6b99" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，在ES6中，我们可以使用spread参数，这些参数在语法上与rest参数相似，因为它们使用省略号:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6d5d" class="kg kh hh ll b fi lp lq l lr ls">function request(url, options, callback) { <br/>  // ...<br/>}<br/>var requestArgs = ['http://capitalone.io', {...}, function(){...}]<br/>request(...requestArgs)</span></pre><p id="86b0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">ES6开发人员可以在以下情况下使用spread运算符:</p><ul class=""><li id="9c6b" class="jj jk hh in b io ip is it iw jl ja jm je jn ji lt jp jq jr bi translated">函数调用如上所示</li><li id="111c" class="jj jk hh in b io js is jt iw ju ja jv je jw ji lt jp jq jr bi translated">数组文字，例如<em class="jy"> array2 = […array1，x，y，z] </em></li><li id="7d1f" class="jj jk hh in b io js is jt iw ju ja jv je jw ji lt jp jq jr bi translated">解构(本文的第五部分)</li><li id="36e1" class="jj jk hh in b io js is jt iw ju ja jv je jw ji lt jp jq jr bi translated"><em class="jy"> new </em>函数调用(构造函数)，例如<em class="jy"> var d = new Date(…dates) </em></li><li id="f377" class="jj jk hh in b io js is jt iw ju ja jv je jw ji lt jp jq jr bi translated"><em class="jy"> push() </em>调用，例如<em class="jy"> arr1.push(…arr2) </em></li></ul><p id="161d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">spread运算符的语法与rest参数类似，但rest用于函数定义/声明，spread用于调用和文字。它们让开发人员不必输入额外的命令性代码，因此了解和使用它们是一项很好的技能。</p><h2 id="56a4" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">3.ES6中的模板文字</h2><p id="e6bb" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">模板文字(或者在其他语言中称为插值)是一种在混合了一些文本的字符串中输出变量的方式，通常在用户界面中。在ES5中，我们必须像这样断弦。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5d28" class="kg kh hh ll b fi lp lq l lr ls">var name = 'Your name is ' + first + ' ' + last + '.'<br/>var url = 'http://localhost:3000/api/messages/' + id</span></pre><p id="9a74" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">幸运的是，在ES6中，我们可以在反勾字符串中使用新的语法<em class="jy"> ${NAME} </em>:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="e48a" class="kg kh hh ll b fi lp lq l lr ls">var name = `Your name is ${first} ${last}.`<br/>var url = `http://localhost:3000/api/messages/${id}`</span></pre><p id="1eef" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这很简洁，让开发人员一眼就能看到字符串的最终结果，而不是试图评估连接表达式。</p><p id="5c51" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">ES6字符串模板很好，但是如果您使用字符串模板和内联代码标记，语法将在Markdown文档中引起冲突，(因为在Markdown中，内联代码也由反勾号标记)。顺便说一下，CoffeeScript有一个我认为更好的解决方案，当它插入双终止字符串时(类似于Ruby):</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="87fe" class="kg kh hh ll b fi lp lq l lr ls">var name = "Your name is #{first} #{last}."<br/>var url = "http://localhost:3000/api/messages/#{id}"</span></pre><p id="37cd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">插值很好，但是如何在JavaScript中处理多行文本呢？</p><h2 id="d213" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">4.ES6中的多行字符串</h2><p id="e822" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">另一个有趣的语法糖衣是多行字符串。在ES5中，我们不得不使用这些方法中的一种，而且很难看。带串联:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9f56" class="kg kh hh ll b fi lp lq l lr ls">var roadPoem = 'Then took the other, as just as fair,\n\t'<br/>    + 'And having perhaps the better claim\n\t'<br/>    + 'Because it was grassy and wanted wear,\n\t'<br/>    + 'Though as for that the passing there\n\t'<br/>    + 'Had worn them really about the same,\n\t'</span></pre><p id="ab44" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">或者用转义斜杠:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="b663" class="kg kh hh ll b fi lp lq l lr ls">var fourAgreements = 'You have the right to be you.\n\<br/>    You can only be you when you do your best.'</span></pre><p id="1582" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在ES6中，只需按如下方式使用反斜线:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="1bc9" class="kg kh hh ll b fi lp lq l lr ls">var roadPoem = `Then took the other, as just as fair,<br/>    And having perhaps the better claim<br/>    Because it was grassy and wanted wear,<br/>    Though as for that the passing there<br/>    Had worn them really about the same,`<br/><br/>var fourAgreements = `You have the right to be you.<br/>    You can only be you when you do your best.`</span></pre><p id="b47e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您必须在JavaScript代码中使用大量文本，多行字符串是一个有用的补充。</p><h2 id="abbe" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">5.ES6中的析构赋值</h2><p id="9907" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">与多行字符串相比，析构可能是一个更难理解的概念，因为在幕后有一些魔法在起作用……假设你有简单的赋值，其中键<em class="jy"> userId </em>和<em class="jy"> accountNumber </em>是变量<em class="jy"> userId </em>和<em class="jy"> accountNumber </em>:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="eb31" class="kg kh hh ll b fi lp lq l lr ls">var data = $('body').data(), // data has properties <br/>userId and accountNumber   userId = data.userId,   accountNumber = data.accountNumber</span></pre><p id="5b85" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">变量名和对象属性名相同的其他赋值示例:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="e775" class="kg kh hh ll b fi lp lq l lr ls">var json = require('body-parser').json<br/><br/>var body = req.body, // body has username and password<br/>  username = body.username,<br/>  password = body.password</span></pre><p id="2672" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在ES6中，我们可以用这些语句替换上面的ES5代码:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="5c8e" class="kg kh hh ll b fi lp lq l lr ls">var { userId, accountNumber} = $('body').data() <br/><br/>var {json} = require('body-parser')<br/><br/>var {username, password} = req.body</span></pre><p id="4243" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这也适用于数组。疯了！</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="2a9d" class="kg kh hh ll b fi lp lq l lr ls">var [col1, col2]  = $('.column'),<br/>  [line1, line2, line3, , line5] = file.split('\n')</span></pre><p id="06c0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">适应<a class="ae jx" href="http://www.2ality.com/2015/01/es6-destructuring.html" rel="noopener ugc nofollow" target="_blank">析构赋值语法</a>可能需要一些时间，但这仍然是一个甜蜜的糖衣。</p><h2 id="d15b" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">6.ES6中增强的对象文字</h2><p id="ac59" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">在ES6中，你可以用对象文字做的事情是惊人的！我们从ES5中JSON的美化版本发展到了ES6中类似类的东西。</p><p id="ad1b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在企业开发中，代码模块化很重要，因为项目更大，有更多的活动部分。使用增强的对象文字，您可以创建加载了功能的真正强大的对象。</p><p id="053f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下面是一个典型的ES5对象文字，带有一些方法和属性:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ec4b" class="kg kh hh ll b fi lp lq l lr ls">var serviceBase = {port: 3000, url: 'azat.co'},<br/>    getAccounts = function(){return [1,2,3]}<br/><br/>var accountServiceES5 = {<br/>  port: serviceBase.port,<br/>  url: serviceBase.url,<br/>  getAccounts: getAccounts,<br/>  toString: function() {<br/>    return JSON.stringify(this.valueOf())<br/>  },<br/>  getUrl: function() {return "http://" + this.url + ':' + this.port},<br/>  valueOf_1_2_3: getAccounts()<br/>}</span></pre><p id="e88d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果我们想更花哨，我们可以通过使用<em class="jy">对象使其成为原型来继承<em class="jy">service base</em>。create</em>方法:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="e5ae" class="kg kh hh ll b fi lp lq l lr ls">var accountServiceES5ObjectCreate = Object.create(serviceBase)<br/>var accountServiceES5ObjectCreate = {<br/>  getAccounts: getAccounts,<br/>  toString: function() {<br/>    return JSON.stringify(this.valueOf())<br/>  },<br/>  getUrl: function() {return "http://" + this.url + ':' + this.port},<br/>  valueOf_1_2_3: getAccounts()<br/>}</span></pre><p id="479e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我知道，<em class="jy">accountservices 5 object create</em>和<em class="jy">accountservices 5</em>并不完全相同，因为一个对象(<em class="jy">accountservices 5</em>)将具有<em class="jy"> __proto__ </em>对象中的属性，如下图所示:</p><figure class="lg lh li lj fd ih er es paragraph-image"><div class="ab fe cl ii"><img src="../Images/4ccb95b21d17ea694f6ca3bf3c27aefe.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9BBUGJ1qHvuNnQzxpPLukg.png"/></div></figure><p id="f97a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">但是为了这个例子，让我们认为它们是相似的。在ES6对象文字中，我们可以使用简写来赋值。例如，<em class="jy">getAccounts:</em><em class="jy">getAccounts</em>，就变成了<em class="jy"> getAccounts </em>。</p><p id="79d7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们还可以在<em class="jy"> __proto__ </em>属性中设置原型(但不是'<em class="jy"> __proto__ 【T9 ')。例如，<em class="jy"> serviceBase </em>就是一个原型:</em></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="094e" class="kg kh hh ll b fi lp lq l lr ls">var serviceBase = {port: 3000, url: 'azat.co'},<br/>    getAccounts = function(){return [1,2,3]}<br/>var accountService = {<br/>    __proto__: serviceBase,<br/>    getAccounts,</span></pre><p id="edac" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">此外，我们可以调用super并拥有动态键。例如，<em class="jy"> toString() </em>方法通过调用<em class="jy"> super.valueOf() </em>返回一个JSON对象作为字符串，而<em class="jy"> valueOf_1_2_3 </em>是一个动态属性名:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6f12" class="kg kh hh ll b fi lp lq l lr ls">toString() {<br/>     return JSON.stringify((super.valueOf()))<br/>    },<br/>    getUrl() {return "http://" + this.url + ':' + this.port},<br/>    [ 'valueOf_' + getAccounts().join('_') ]: getAccounts()<br/>};<br/>console.log(accountService)</span></pre><figure class="lg lh li lj fd ih er es paragraph-image"><div class="ab fe cl ii"><img src="../Images/cb9086424a1c974cfe3acb3a15da7586.png" data-original-src="https://miro.medium.com/v2/format:webp/1*57Uchqw9FAcZYfhxvRF0yw.png"/></div></figure><p id="bbde" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这是对传统对象文字的一个很好的增强，因为开发人员可以打包更多的逻辑，比ES5对象做更多的事情！</p><h2 id="14f1" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">7.ES6中的箭头功能</h2><p id="6543" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">这可能是我等待最多的功能。我喜欢CoffeeScript 的<a class="ae jx" href="http://webapplog.com/understanding-fat-arrows-in-coffeescript" rel="noopener ugc nofollow" target="_blank">胖箭头</a>。现在我们在ES6中有它们。</p><p id="1da3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">粗箭头令人惊奇，因为它们会使您的<em class="jy"> this </em>行为正常，即<em class="jy"> this </em>将具有与函数上下文中相同的值——它不会像每次创建闭包时通常发生的那样发生变化。这种行为是JavaScript最糟糕的部分之一，经常会给初学这门语言的开发人员带来很多困惑。在ES6中使用箭头功能可以让我们停止使用那个<em class="jy"> =这个</em>或者<em class="jy"> self =这个</em>或者<em class="jy">_这个=这个或者。【绑定(本)】T31。</em></p><p id="3699" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，ES5中的这段代码很难看，因为您可能会忘记用<em class="jy"> _this </em>将上下文转移到闭包:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d600" class="kg kh hh ll b fi lp lq l lr ls">var _this = this<br/>$('.btn').click(function(event){<br/>  _this.sendData()<br/>})</span></pre><p id="9365" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">由于冗长，<em class="jy"> bind() </em>或<em class="jy"> call() </em>方法也好不到哪里去。但是看看这个漂亮的ES6代码:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="403e" class="kg kh hh ll b fi lp lq l lr ls">$('.btn').click((event) =&gt;{<br/>  this.sendData()<br/>})</span></pre><p id="e5a6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">可悲的是，ES6委员会认为借用CoffeeScript的细箭头太过了，并留给我们一个冗长的旧<em class="jy">函数</em>代替。(<a class="ae jx" href="https://www.udemy.com/coffeescript/?couponCode=a" rel="noopener ugc nofollow" target="_blank">coffee script中的瘦箭头</a>的工作方式类似于ES5和ES6中的常规<em class="jy">函数</em>)。</p><p id="7eec" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下面是另一个例子，我们使用<em class="jy">调用</em>将上下文传递给ES5中的<em class="jy"> logUpperCase() </em>函数:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9924" class="kg kh hh ll b fi lp lq l lr ls">var logUpperCase = function() {<br/>  var _this = this<br/><br/>  this.string = this.string.toUpperCase()<br/>  return function () {<br/>    return console.log(_this.string)<br/>  }<br/>}<br/><br/>logUpperCase.call({ string: 'es6 rocks' })()</span></pre><p id="c04b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">而在ES6中，我们不需要跟<em class="jy"> _this </em>:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="92fc" class="kg kh hh ll b fi lp lq l lr ls">var logUpperCase = function() {<br/>  this.string = this.string.toUpperCase()<br/>  return () =&gt; console.log(this.string)<br/>}<br/><br/>logUpperCase.call({ string: 'es6 rocks' })()</span></pre><p id="b44b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">请注意，您可以在ES6中将旧的<em class="jy">功能</em>与<em class="jy"> = &gt; </em>混合搭配。当一个箭头函数和一行语句一起使用时，它就变成了一个表达式；即。它将隐式地<em class="jy">返回</em>那条语句的结果。如果你有不止一行，那么你需要显式地使用return。</p><p id="c224" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这个ES5代码从<em class="jy">消息</em>数组中创建一个数组:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="7d70" class="kg kh hh ll b fi lp lq l lr ls">var ids = ['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9']<br/>var messages = ids.map(function (value) {<br/>  return "ID is " + value // explicit return<br/>});</span></pre><p id="3f73" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在ES6中将变成这样:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="fe33" class="kg kh hh ll b fi lp lq l lr ls">var ids = ['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9']<br/>var messages = ids.map(value =&gt; `ID is ${value}`) // implicit return</span></pre><p id="dafe" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">注意，我使用了字符串模板。CoffeeScript的另一个特色…我喜欢它们！</p><p id="ba66" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">括号<em class="jy"> () </em>对于箭头函数签名中的单个参数是可选的。然而，当使用多个参数时，您将需要它们。在ES5中，代码有带显式返回的<em class="jy">函数</em>:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="3118" class="kg kh hh ll b fi lp lq l lr ls">var ids = ['5632953c4e345e145fdf2df8', '563295464e345e145fdf2df9'];<br/>var messages = ids.map(function (value, index, list) {<br/>  return 'ID of ' + index + ' element is ' + value + ' ' // explicit return<br/>});</span></pre><p id="2d36" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，这里是ES6中的代码的一个更有说服力的版本，参数周围有括号和隐式返回:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="64fe" class="kg kh hh ll b fi lp lq l lr ls">var ids = ['5632953c4e345e145fdf2df8','563295464e345e145fdf2df9']<br/>var messages = ids.map((value, index, list) =&gt; `ID of ${index} element is ${value} `) // implicit return</span></pre><p id="c53a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">胖箭不是很棒吗？使用它们。</p><h2 id="be4e" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">8.ES6中的承诺</h2><p id="a25e" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">承诺一直是一个有争议的发展话题，尤其是在较大的组织中，很难就共同的方法达成一致。其中一个原因是promise实现使用了稍微不同的语法——Q、bluebird、deferred.js、vow、avow和jquery deferred等等。另一个原因是，一些软件工程师说，“我们不需要承诺，可以使用异步、生成器、回调等。”</p><p id="5aa7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">幸运的是，随着ES6增加了标准的<em class="jy">承诺</em>实现，争论有可能会平息下来！</p><p id="aab2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们考虑一个相当简单的延迟异步执行的例子，使用<em class="jy"> setTimeout() </em>:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d037" class="kg kh hh ll b fi lp lq l lr ls">setTimeout(function(){   console.log('Yay!') }, 1000)</span></pre><p id="9692" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们可以在ES6中重写这段代码，并承诺:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="4ecb" class="kg kh hh ll b fi lp lq l lr ls">var wait1000 =  new Promise(function(resolve, reject) {<br/>  setTimeout(resolve, 1000)<br/>}).then(function() {<br/>  console.log('Yay!')<br/>})</span></pre><p id="ec12" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">或使用ES6箭头功能:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="3c11" class="kg kh hh ll b fi lp lq l lr ls">var wait1000 =  new Promise((resolve, reject)=&gt; {<br/>  setTimeout(resolve, 1000)<br/>}).then(()=&gt; {<br/>  console.log('Yay!')<br/>})</span></pre><p id="29b1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">到目前为止，我们已经将代码行数从3行增加到5行，但没有任何明显的好处。没错，确实看起来违反直觉。如果我们在<em class="jy"> setTimeout() </em>回调中有更多的嵌套逻辑，好处就来了。例如，这个ES5代码有两个嵌套的回调:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="8dfd" class="kg kh hh ll b fi lp lq l lr ls">setTimeout(function(){<br/>  console.log('Yay!')<br/>  setTimeout(function(){<br/>    console.log('Wheeyee!')<br/>  }, 1000)<br/>}, 1000)</span></pre><p id="a03c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">它可以重写为ES6承诺，如下所示:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="3129" class="kg kh hh ll b fi lp lq l lr ls">var wait1000 =  ()=&gt; <br/>  new Promise((resolve, reject)=&gt; {<br/>    setTimeout(resolve, 1000)<br/>  })<br/><br/>wait1000()<br/>    .then(function() {<br/>        console.log('Yay!')<br/>        return wait1000()<br/>    })<br/>    .then(function() {<br/>        console.log('Wheeyee!')<br/>    });</span></pre><p id="93b8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">正如您所观察到的，当我们重构回调时，代码组织发生了变化——仅将代码重构为带有承诺的代码。</p><p id="dc23" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这篇文章没有提到的另一个好处是——承诺也有一个失败一网打尽的回调，这是一个很好的特性。看看这个帖子，了解更多关于承诺的信息:<a class="ae jx" href="http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell" rel="noopener ugc nofollow" target="_blank"><em class="jy">ES6承诺介绍</em> </a>。</p><h2 id="4098" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">9.块范围的构造:Let和Const</h2><p id="b31b" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">你可能已经看到了ES6代码中奇怪的发音<em class="jy"> let </em>。这不仅仅是一个糖衣功能。它更加复杂，并且为变量声明增加了更多的逻辑。</p><p id="c794" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jy"> let </em>是一个新的<em class="jy">变量</em>，它允许开发者将变量的范围扩大到块。我们用花括号来定义块。在ES5中，块没有对变量做任何事情，如下所示:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="da0a" class="kg kh hh ll b fi lp lq l lr ls">function calculateTotalAmount (vip) {<br/>  var amount = 0<br/>  if (vip) {<br/>    var amount = 1<br/>  }<br/>  { // more crazy blocks!<br/>    var amount = 100<br/>    {<br/>      var amount = 1000<br/>      }<br/>  }  <br/>  return amount<br/>}<br/><br/>console.log(calculateTotalAmount(true))</span></pre><p id="0b71" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在上面的代码中，结果将是1000。哇！那是一个非常糟糕的错误。在ES6中，我们使用<em class="jy"> let </em>将范围限制到块。然后变量的作用域是函数。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="faac" class="kg kh hh ll b fi lp lq l lr ls">function calculateTotalAmount (vip) {<br/>  var amount = 0 // probably should also be let, but you can mix var and let<br/>  if (vip) {<br/>    let amount = 1 // first amount is still 0<br/>  } <br/>  { // more crazy blocks!<br/>    let amount = 100 // first amount is still 0<br/>    {<br/>      let amount = 1000 // first amount is still 0<br/>      }<br/>  }  <br/>  return amount<br/>}<br/><br/>console.log(calculateTotalAmount(true))</span></pre><p id="ae10" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这段代码中，值为0，因为<em class="jy"> if </em>块也有<em class="jy"> let </em>声明。如果它什么都没有(<em class="jy"> amount=1 </em>)，那么表达式应该是1。</p><p id="acb9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">到了<em class="jy"> const </em>，事情就好办了；它只是防止重新赋值，而且它也是块范围的，就像<em class="jy"> let </em>一样。为了演示，这里有多个常量，代码运行良好，因为<em class="jy"> const </em>语句属于不同的块:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6e49" class="kg kh hh ll b fi lp lq l lr ls">function calculateTotalAmount (vip) {<br/>  const amount = 0  <br/>  if (vip) {<br/>    const amount = 1 <br/>  } <br/>  { // more crazy blocks!<br/>    const amount = 100 <br/>    {<br/>      const amount = 1000<br/>      }<br/>  }  <br/>  return amount<br/>}<br/><br/>console.log(calculateTotalAmount(true))</span></pre><p id="01d1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">依我拙见，<em class="jy">让</em>和<em class="jy"> const </em>把语言复杂化了。没有它们，我们只有一种行为，现在有多种情况需要考虑。；-(对于来自Java等语言的JavaScript新手来说，<em class="jy"> const </em>和<em class="jy"> let </em>提供了一个新的内置防护层来防止一些不可预测的行为。</p><h2 id="dc26" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">10.ES6中的类别</h2><p id="2847" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">如果你喜欢面向对象编程(OOP)，那么你会喜欢这个特性。这使得在ES6中编写类，并从它们继承，就像喜欢评论脸书一样简单。</p><p id="db2a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在ES5中，至少可以说类的创建和使用是困难的。没有关键字<em class="jy">类</em>(被保留，但什么也没做)。除此之外，许多继承模式，如<a class="ae jx" href="http://javascript.info/tutorial/pseudo-classical-pattern" rel="noopener ugc nofollow" target="_blank">伪经典</a>、<a class="ae jx" href="http://www.crockford.com/javascript/inheritance.html" rel="noopener ugc nofollow" target="_blank">经典</a>、<a class="ae jx" href="http://javascript.info/tutorial/factory-constructor-pattern" rel="noopener ugc nofollow" target="_blank">功能性</a>都增加了混乱，给JavaScript开发者之间激烈的分歧火上浇油。</p><p id="c8f8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我不会给你演示如何用ES5写一个类，因为有很多模式。让我们马上来看看ES6的例子。我可以告诉你，ES6类将使用原型，而不是函数工厂方法。我们有一个<em class="jy"> classbaseModel </em>，在其中我们可以定义一个构造函数和一个<em class="jy"> getName() </em>方法:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="3858" class="kg kh hh ll b fi lp lq l lr ls">class baseModel {<br/>  constructor(options = {}, data = []) { // class constructor<br/>        this.name = 'Base'<br/>    this.url = 'http://azat.co/api'<br/>        this.data = data<br/>    this.options = options<br/>    }<br/><br/>    getName() { // class method<br/>        console.log(`Class name: ${this.name}`)<br/>    }<br/>}</span></pre><p id="acdd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">注意，我对选项和数据使用了默认的参数值。此外，方法名不再需要有单词<em class="jy"> function </em>或冒号(:)。另一个大的区别是你不能分配属性<em class="jy">这个。以与方法相同的方式命名</em>，也就是说，你不能在与方法相同的缩进层次上说<em class="jy">名</em>。要设置属性的值，只需在构造函数中赋值。</p><p id="2a5d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jy"> AccountModel </em>将用<em class="jy">类名继承<em class="jy"> baseModel </em>扩展PARENT_NAME </em>:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d00a" class="kg kh hh ll b fi lp lq l lr ls">class AccountModel extends baseModel {<br/>    constructor(options, data) {</span></pre><p id="92cb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要调用父构造函数，可以毫不费力地调用带有参数的<em class="jy"> super() </em>:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="e66f" class="kg kh hh ll b fi lp lq l lr ls">super({private: true}, ['32113123123', '524214691']) // Call the parent method with super<br/>      this.name = 'Account Model'<br/>      this.url +='/accounts/'<br/>    }</span></pre><p id="4e24" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您想变得更有趣，您还可以设置一个这样的getter，将<em class="jy"> accountsData </em>作为属性:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="15ba" class="kg kh hh ll b fi lp lq l lr ls">get accountsData() { // Calculated attribute getter<br/>      // ... make XHR<br/>     return this.data<br/>    }<br/>}</span></pre><p id="1ae2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">那么在<em class="jy">所有这些工作</em>之后，你实际上如何使用这个类abracadabra呢？这就像骗一个三岁的孩子相信圣诞老人一样容易。使用<em class="jy">新的</em>操作数:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="f052" class="kg kh hh ll b fi lp lq l lr ls">let accounts = new AccountModel(5)<br/>accounts.getName()<br/>console.log('Data is %s', accounts.accountsData)</span></pre><p id="d42e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您想知道，输出是:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9c26" class="kg kh hh ll b fi lp lq l lr ls">Class name: Account Model<br/>Data is %s 32113123123,524214691</span></pre><p id="65d6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当然，<a class="ae jx" href="http://webapplog.com/coffeescript-fundamentals-the-better-javascript/" rel="noopener ugc nofollow" target="_blank">类存在于CoffeeScript </a>和更老的JavaScript标准中，所以它们不是全新的。然而，在ES6中，使用类变得更加容易，这对于企业开发人员来说尤其重要，因为他们通常在跨多个团队的大型项目中工作(因此代码需要模块化)。</p><h2 id="1483" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">11.ES6中的模块</h2><p id="cd37" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">您可能知道，在ES6之前的JavaScript中没有本地模块支持。人们想出了AMD、RequireJS、CommonJS和其他变通办法，但它们仅仅是变通办法和黑客。对于ES6，现在有内置模块，带有<em class="jy">输入</em>和<em class="jy">输出</em>操作数。</p><p id="cb55" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在ES5中，你可以使用life的<em class="jy"> &lt; script &gt; </em>标签，或者AMD这样的库，而在ES6中，你可以使用<em class="jy"> export </em>来公开你的类。因为我是Node.js的人，所以我将使用CommonJS来解决这个问题，common js也是Node.js语法。通过<a class="ae jx" href="http://browserify.org/" rel="noopener ugc nofollow" target="_blank">浏览器绑定器</a>在浏览器上使用CommonJS非常简单。假设我们在ES5 <em class="jy"> module.js </em>中有<em class="jy"> port </em>变量和<em class="jy"> getAccounts </em>方法:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6fc2" class="kg kh hh ll b fi lp lq l lr ls">module.exports = {<br/>  port: 3000,<br/>  getAccounts: function() {<br/>    ...<br/>  }<br/>}</span></pre><p id="2e16" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在ES5 <em class="jy"> main.js </em>中，我们会要求(<em class="jy">‘模块’</em>)依赖关系:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="676e" class="kg kh hh ll b fi lp lq l lr ls">var service = require('module.js')<br/>console.log(service.port) // 3000</span></pre><p id="0730" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在ES6中，我们将使用<em class="jy">导出</em>和<em class="jy">导入</em>。例如，这是我们在ES6 <em class="jy"> module.js文件</em>中的库:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="8644" class="kg kh hh ll b fi lp lq l lr ls">export var port = 3000<br/>export function getAccounts(url) {<br/>  ...<br/>}</span></pre><p id="11da" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在导入器ES6文件<em class="jy"> main.js </em>中，我们使用<em class="jy">import { name } from‘my-module’</em>语法。例如，我们可以从名为module的模块中导入对象/方法<em class="jy"> port </em>和<em class="jy"> getAccounts </em>:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="e2a0" class="kg kh hh ll b fi lp lq l lr ls">import {port, getAccounts} from 'module'<br/>console.log(port) // 3000</span></pre><p id="1f38" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">或者我们可以在<em class="jy"> main.js </em>中将所有东西作为变量<em class="jy"> service </em>导入:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="866d" class="kg kh hh ll b fi lp lq l lr ls">import * as service from 'module'<br/>console.log(service.port) // 3000</span></pre><p id="8893" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">注意，浏览器对ES6模块的本地支持不会很快到来(至少在撰写本文时是这样)，所以你需要像<a class="ae jx" href="http://jspm.io/" rel="noopener ugc nofollow" target="_blank"> jspm </a>这样的东西来利用ES6模块。</p><p id="7ce8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">有关ES6模块的更多信息和示例，请看一下<a class="ae jx" href="http://exploringjs.com/es6/ch_modules.html" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。记住，无论如何，要写模块化的JavaScript！</p><h2 id="e4d5" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">12.ES6中对…的理解</h2><p id="400e" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">这里有一个关于ES5的问题:当我们想要使用它的键来迭代对象时，我们需要首先用<em class="jy"> Object.keys() </em>提取那些键。例如:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="17c8" class="kg kh hh ll b fi lp lq l lr ls">var books = ['Pro Express.js', 'React Quickly', 'Full Stack JavaScript'] <br/>books.author = 'Azat'<br/>Object.keys(books).forEach(function (element, index) {<br/>    console.log(books[element], element); // prints 'Pro Express.js', 'React Quickly', 'Full Stack JavaScript', 'Azat' <br/>    console.log(books[index], index);   // prints 'Pro Express.js', 'React Quickly', 'Full Stack JavaScript', undefined<br/>});</span></pre><p id="5c96" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jy"> forEach </em>的另一个问题是你需要编写word <em class="jy">函数</em>。但是ES6里有更好的说法！语句的<em class="jy">for……代替了</em>的标准<em class="jy">和<em class="jy"> forEach </em>，除了</em>中的<em class="jy">for……和</em> over values中的<em class="jy">for……外，与</em>中的<em class="jy">for……类似。</em></p><p id="2c91" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用前面代码片段的数据<em class="jy"> (books) </em>，我们可以使用中的<em class="jy">for…和键或者使用</em>中的<em class="jy">for…进行迭代:</em></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="4285" class="kg kh hh ll b fi lp lq l lr ls">for (let key in books){<br/>  console.log(books[key])<br/>}</span></pre><p id="f5f4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">输出密钥:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="088c" class="kg kh hh ll b fi lp lq l lr ls">Pro Express.js<br/>React Quickly<br/>Full Stack JavaScript<br/>Azat</span></pre><p id="19de" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">而的<em class="jy">将与以下值一起工作:</em></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ba6d" class="kg kh hh ll b fi lp lq l lr ls">for (let book of books){<br/>  console.log(book)<br/>}</span></pre><p id="1a87" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">的…的<em class="jy">输出:</em></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0f41" class="kg kh hh ll b fi lp lq l lr ls">Pro Express.js<br/>React Quickly<br/>Full Stack JavaScript</span></pre><p id="bfe9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">请注意，的……的<em class="jy">输出会忽略key <em class="jy"> author </em>的值，就像数组上的<em class="jy"> forEach </em>一样:</em></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9829" class="kg kh hh ll b fi lp lq l lr ls">books.forEach(function (element, index) {<br/>    console.log(element); // Pro Express.js, React Quickly, Full Stack JavaScript<br/>    console.log(index);   // 0, 1, 2<br/>});</span></pre><p id="3653" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我个人使用理解的经验是它们增加了代码的可读性。这对于企业应用程序中的代码维护至关重要。</p></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><h2 id="23c9" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">今天如何使用ES6(巴别塔)</h2><p id="1190" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">ES6已经完成，但并非所有浏览器都完全支持(例如<a class="ae jx" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla" rel="noopener ugc nofollow" target="_blank"> ES6 Firefox支持</a>)。今天要用ES6，就去弄个<a class="ae jx" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>这样的编译器。您可以将它作为独立工具运行，也可以将其与您的构建系统一起使用。有Babel <a class="ae jx" href="http://babeljs.io/docs/setup" rel="noopener ugc nofollow" target="_blank">插件</a>用于Grunt、Gulp和Webpack。</p><figure class="lg lh li lj fd ih er es paragraph-image"><div class="ab fe cl ii"><img src="../Images/bbcc78ad0413f9b03ec978afd3a36075.png" data-original-src="https://miro.medium.com/v2/format:webp/1*pfrFp1K2kikRQipdA_-27w.png"/></div></figure><p id="89a7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这里有一个吞咽的例子。安装插件:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="f70a" class="kg kh hh ll b fi lp lq l lr ls">$ npm install --save-dev gulp-babel</span></pre><p id="dd2f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在<em class="jy"> gulpfile.js </em>中，定义一个任务构建，该任务构建采用<em class="jy"> src/app.js </em>并将其编译到<em class="jy"> build </em>文件夹中:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="7fd9" class="kg kh hh ll b fi lp lq l lr ls">var gulp = require('gulp'),<br/>  babel = require('gulp-babel')<br/><br/>gulp.task('build', function () {<br/>  return gulp.src('src/app.js')<br/>    .pipe(babel())<br/>    .pipe(gulp.dest('build'))<br/>})</span></pre><h2 id="8dee" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">Node.js和ES6</h2><p id="aa4e" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">对于Node.js，可以用构建工具编译Node.js文件，或者使用独立的Babel模块<em class="jy"> babel-core </em>。要安装它，创建一个全新的文件夹，并在其中创建一个<em class="jy"> package.json </em>文件:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="7df6" class="kg kh hh ll b fi lp lq l lr ls">$ mkdir babel-test<br/>$ cd babel-test<br/>$ npm init</span></pre><p id="803a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后使用npm v3.x安装Babel v6.6.5 CLI工具和<a class="ae jx" href="https://babeljs.io/docs/plugins/preset-es2015" rel="noopener ugc nofollow" target="_blank">es 2015插件</a>:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="9b5d" class="kg kh hh ll b fi lp lq l lr ls">$ npm install --save-dev babel-cli@6.6.5<br/>$ npm install --save-dev babel-preset-es2015@6.6.0</span></pre><p id="10af" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">创建一个配置文件<em class="jy">。带有ES2015预设的babelrc </em>(这与v6.x中的tos v5.x不同):</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="cc7c" class="kg kh hh ll b fi lp lq l lr ls">$ echo '{ "presets": ["es2015"] }' &gt; .babelrc</span></pre><p id="cb3f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在你可以通过运行本地巴别塔模块来编译<em class="jy"> src </em>文件夹中的文件。输出将在<em class="jy"> lib </em>文件夹中:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6b13" class="kg kh hh ll b fi lp lq l lr ls">$ ./node_modules/.bin/babel src -d lib</span></pre><h2 id="af40" class="kg kh hh bd ki kj kk kl km kn ko kp kq iw kr ks kt ja ku kv kw je kx ky kz la bi translated">其他ES6功能和资源</h2><p id="119e" class="pw-post-body-paragraph il im hh in b io lb iq ir is lc iu iv iw ld iy iz ja le jc jd je lf jg jh ji ha bi translated">还有许多其他值得注意的ES6特性，您可能会使用，也可能不会使用(至少不会马上使用)，排名不分先后:</p><ol class=""><li id="7e14" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated">新的数学、数字、字符串、数组和对象方法</li><li id="9f86" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">二进制和八进制数字类型</li><li id="77bb" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">标志</li><li id="9101" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">尾部呼叫</li><li id="fc0e" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">发电机</li><li id="097c" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated">像Map和Set这样的新数据结构</li></ol><p id="8cbe" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于那些无法停止学习ES6的高材生来说——就像有些人在第一个薯片之后就停不下来一样(就再来一个！)—以下是进一步阅读的清单:</p><ol class=""><li id="9beb" class="jj jk hh in b io ip is it iw jl ja jm je jn ji jo jp jq jr bi translated"><a class="ae jx" href="https://github.com/azat-co/cheatsheets/tree/master/es6" rel="noopener ugc nofollow" target="_blank"> ES6/ES2015备忘单</a></li><li id="704c" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><a class="ae jx" href="https://leanpub.com/understandinges6" rel="noopener ugc nofollow" target="_blank"> <em class="jy">理解ECMAScript 6 </em>尼古拉斯·扎卡斯著</a></li><li id="f333" class="jj jk hh in b io js is jt iw ju ja jv je jw ji jo jp jq jr bi translated"><a class="ae jx" href="https://leanpub.com/exploring-es6" rel="noopener ugc nofollow" target="_blank"> <em class="jy">探索ES6 </em>阿克塞尔·劳施迈尔博士</a></li></ol></div><div class="ab cl jz ka go kb" role="separator"><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke kf"/><span class="kc bw bk kd ke"/></div><div class="ha hb hc hd he"><p id="cbdd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jy">欲了解更多关于Capital One的API、开源、社区活动和开发人员文化的信息，请访问我们的一站式开发人员门户网站DevExchange。</em><a class="ae jx" href="https://developer.capitalone.com/" rel="noopener ugc nofollow" target="_blank">【https://developer.capitalone.com/】T21</a></p></div></div>    
</body>
</html>