<html>
<head>
<title>Developers are users too — part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发者也是用户——第1部分</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/developers-are-users-too-part-1-c753483a50dc?source=collection_archive---------2-----------------------#2017-11-21">https://medium.com/androiddevelopers/developers-are-users-too-part-1-c753483a50dc?source=collection_archive---------2-----------------------#2017-11-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/5e876904ce495091bd10f5cf3f84fc1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUzDeiHZ1Dfe2grlecdC1g.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Images: <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virgina Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="7ae9" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">提高UI和API可用性的5条准则</h2></div><p id="29d9" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在上一篇文章中，我们看到了UI和API可用性的重要性，并且UI可用性指南也可以应用于API。看看这里。</p><div class="hg hh ez fb hi ki"><a rel="noopener follow" target="_blank" href="/google-developers/developers-are-users-too-introduction-fefdb42f05a"><div class="kj ab dw"><div class="kk ab kl cl cj km"><h2 class="bd hy fi z dy kn ea eb ko ed ef hw bi translated">开发者也是用户—简介</h2><div class="kp l"><h3 class="bd b fi z dy kn ea eb ko ed ef dx translated">可用性——从UI中学习，在API中应用</h3></div><div class="kq l"><p class="bd b fp z dy kn ea eb ko ed ef dx translated">medium.com</p></div></div><div class="kr l"><div class="ks l kt ku kv kr kw ho ki"/></div></div></a></div><p id="d96e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在本文中，我们将讨论前5条可用性指南:</p><ol class=""><li id="c6c5" class="kx ky hx jo b jp jq js jt jv kz jz la kd lb kh lc ld le lf bi translated"><a class="ae hu" href="#a062" rel="noopener ugc nofollow">系统状态的可见性</a></li><li id="0af2" class="kx ky hx jo b jp lg js lh jv li jz lj kd lk kh lc ld le lf bi translated"><a class="ae hu" href="#fd9a" rel="noopener ugc nofollow">系统与现实世界的匹配</a></li><li id="6925" class="kx ky hx jo b jp lg js lh jv li jz lj kd lk kh lc ld le lf bi translated"><a class="ae hu" href="#52bc" rel="noopener ugc nofollow">用户控制和自由</a></li><li id="8039" class="kx ky hx jo b jp lg js lh jv li jz lj kd lk kh lc ld le lf bi translated"><a class="ae hu" href="#7d0b" rel="noopener ugc nofollow">一致性和标准</a></li><li id="0bf5" class="kx ky hx jo b jp lg js lh jv li jz lj kd lk kh lc ld le lf bi translated"><a class="ae hu" href="#6f9b" rel="noopener ugc nofollow">错误预防</a></li></ol><h1 id="a062" class="ll lm hx bd ln lo lp lq lr ls lt lu lv jd lw je lx jg ly jh lz jj ma jk mb mc bi translated">1.系统状态的可见性</h1><blockquote class="md me mf"><p id="a753" class="jm jn mg jo b jp jq iy jr js jt jb ju mh jw jx jy mi ka kb kc mj ke kf kg kh ha bi translated">系统应该通过适当的反馈，在合理的时间内让用户了解正在发生的事情。</p></blockquote><p id="aebc" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> UI: </strong>当用户发起一个需要较长时间的动作时，通知他们进度。如果可能的话，更喜欢一个进度条而不是一个正在加载的图像，一个带有百分比的上传或下载通知。用户应该知道他们在等待什么，以及需要多长时间。</p><figure class="ml mm mn mo fd hj er es paragraph-image"><div class="er es mk"><img src="../Images/9a2ecaac25d8933dd3569d1e0707532a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*uyWN73Fvr91jvuw9AfrUTQ.gif"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Keep the user informed of progress. <a class="ae hu" href="https://material.io/guidelines/components/progress-activity.html#progress-activity-types-of-indicators" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="7355" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy">API:</strong>API应该提供查询当前状态的方法。例如，<code class="du mp mq mr ms b"><a class="ae hu" href="https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable.html" rel="noopener ugc nofollow" target="_blank">AnimatedVectorDrawable</a></code>类提供了一种检查动画是否正在运行的方法:</p><pre class="ml mm mn mo fd mt ms mu mv aw mw bi"><span id="3f73" class="mx lm hx ms b fi my mz l na nb">boolean isAnimationRunning = avd.isRunning();</span></pre><p id="1b63" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">API可以以回调机制的形式给出反馈，允许API用户知道对象何时改变状态——就像动画何时开始和结束的通知。<code class="du mp mq mr ms b"><a class="ae hu" href="https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable.html" rel="noopener ugc nofollow" target="_blank">AnimatedVectorDrawable</a></code>对象允许<a class="ae hu" href="https://developer.android.com/reference/android/graphics/drawable/AnimatedVectorDrawable.html#registerAnimationCallback(android.graphics.drawable.Animatable2.AnimationCallback)" rel="noopener ugc nofollow" target="_blank">为此注册</a>一个<code class="du mp mq mr ms b"><a class="ae hu" href="https://developer.android.com/reference/android/graphics/drawable/Animatable2.html#registerAnimationCallback(android.graphics.drawable.Animatable2.AnimationCallback)" rel="noopener ugc nofollow" target="_blank">AnimationCallback</a></code>。</p><h1 id="fd9a" class="ll lm hx bd ln lo lp lq lr ls lt lu lv jd lw je lx jg ly jh lz jj ma jk mb mc bi translated">2.系统与现实世界的匹配</h1><blockquote class="md me mf"><p id="0d8e" class="jm jn mg jo b jp jq iy jr js jt jb ju mh jw jx jy mi ka kb kc mj ke kf kg kh ha bi translated">应用程序应该说用户的语言，使用用户熟悉的短语和概念，而不是面向系统的术语。</p></blockquote><figure class="ml mm mn mo fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nc"><img src="../Images/ebb7b9fd23248a9def4989bebdcfd0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wSpL4tOdQ80XTC-B."/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Use concepts familiar to the user. <a class="ae hu" href="https://material.io/guidelines/style/writing.html#writing-language" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><h2 id="3174" class="mx lm hx bd ln nd ne nf lr ng nh ni lv jv nj nk lx jz nl nm lz kd nn no mb np bi translated">类和方法的命名应该符合用户的期望</h2><p id="758d" class="pw-post-body-paragraph jm jn hx jo b jp nq iy jr js nr jb ju jv ns jx jy jz nt kb kc kd nu kf kg kh ha bi translated"><strong class="jo hy"> API: </strong>当在一个新的API中搜索一个类时，用户没有一个明确的起点，而是依赖于以前使用类似API的经验，或者依赖于与API领域相关的一般概念。例如，当使用Glide或Picasso下载和显示图像时，用户可能会寻找一种称为“加载”或“下载”的方法。</p><h1 id="52bc" class="ll lm hx bd ln lo lp lq lr ls lt lu lv jd lw je lx jg ly jh lz jj ma jk mb mc bi translated">3.用户控制和自由</h1><blockquote class="md me mf"><p id="fd03" class="jm jn mg jo b jp jq iy jr js jt jb ju mh jw jx jy mi ka kb kc mj ke kf kg kh ha bi translated">为用户提供恢复其操作的可能性。</p></blockquote><p id="b363" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> UI: </strong>对于用户发起的可能不确定发生了什么事情的操作，如删除或存档电子邮件，显示一条确认消息并允许用户撤销该操作。</p><figure class="ml mm mn mo fd hj er es paragraph-image"><div class="er es nv"><img src="../Images/f537965aff4f041667a0fb87aa00948c.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*6ZgbBYTkeyh-LrA96T8Nuw.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Allow the user to undo certain actions. <a class="ae hu" href="http://Elements like “Help” and “Send feedback” are usually placed at the bottom of the navigation drawer." rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><h2 id="a856" class="mx lm hx bd ln nd ne nf lr ng nh ni lv jv nj nk lx jz nl nm lz kd nn no mb np bi translated">API应该允许中止或重置操作，并且很容易将API恢复到正常状态</h2><p id="cf1b" class="pw-post-body-paragraph jm jn hx jo b jp nq iy jr js nr jb ju jv ns jx jy jz nt kb kc kd nu kf kg kh ha bi translated"><strong class="jo hy"> API: </strong>例如，retrieval公开了一个<a class="ae hu" href="https://square.github.io/retrofit/2.x/retrofit/retrofit2/Call.html#cancel--" rel="noopener ugc nofollow" target="_blank"> Call#cancel </a>方法，该方法试图取消正在进行的网络调用，或者，如果调用尚未执行，则确保它永远不会执行。如果你使用NotificationManager API，你会发现你既可以创建也可以<a class="ae hu" href="https://developer.android.com/reference/android/app/NotificationManager.html#cancel(int)" rel="noopener ugc nofollow" target="_blank">取消</a>通知。</p><h1 id="7d0b" class="ll lm hx bd ln lo lp lq lr ls lt lu lv jd lw je lx jg ly jh lz jj ma jk mb mc bi translated">4.一致性和标准</h1><blockquote class="md me mf"><p id="4485" class="jm jn mg jo b jp jq iy jr js jt jb ju mh jw jx jy mi ka kb kc mj ke kf kg kh ha bi translated">你的应用程序的用户不应该怀疑不同的词语、情况或动作是否意味着相同的事情。</p></blockquote><p id="e6ed" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> UI: </strong>与您的应用程序交互的用户已经通过与其他应用程序的交互得到了培训，他们希望常见的交互元素以某种方式呈现和表现。背离这些约定会导致容易出错的情况。</p><p id="3c02" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">与平台保持一致，使用用户熟知的UI控件，这样他们就能很快识别并操作它们。此外，在整个应用程序中保持一致。在应用程序的多个屏幕上使用相同的文字和图标来表示相同的事物。例如，当用户可以编辑应用程序中的多个元素时，请始终使用相同的编辑图标。</p><figure class="ml mm mn mo fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es nw"><img src="../Images/392090f52ed52dc48772a7470bb8c3f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ioWpCsAMsI7gRHxo."/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Dialogs should be consistent with the platform. <a class="ae hu" href="https://material.io/guidelines/usability/accessibility.html#accessibility-implementation" rel="noopener ugc nofollow" target="_blank">Source</a></figcaption></figure><p id="d49c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy">API:</strong>API设计的所有部分都应该一致</p><h2 id="3d19" class="mx lm hx bd ln nd ne nf lr ng nh ni lv jv nj nk lx jz nl nm lz kd nn no mb np bi translated">跨方法使用一致的命名</h2><p id="01a5" class="pw-post-body-paragraph jm jn hx jo b jp nq iy jr js nr jb ju jv ns jx jy jz nt kb kc kd nu kf kg kh ha bi translated">考虑以下示例，其中我们有一个接口，该接口公开了设置两种不同类型的观察器的两种方式:</p><pre class="ml mm mn mo fd mt ms mu mv aw mw bi"><span id="48c3" class="mx lm hx ms b fi my mz l na nb">public interface MyInterface {<br/>    <br/>    void registerContentObserver(ContentObserver observer);</span><span id="2ee2" class="mx lm hx ms b fi nx mz l na nb">    void addDataSetObserver(DataSetObserver observer);<br/>}</span></pre><p id="a2aa" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这个界面的用户会问自己<code class="du mp mq mr ms b">register…Observer</code>和<code class="du mp mq mr ms b">add…Observer</code>有什么区别。一种方法一次只允许一个观察者，而另一种方法允许多个观察者吗？开发人员要么需要仔细阅读文档，要么寻找接口的实现，以查看两种方法的行为方式是否相同。</p><pre class="ml mm mn mo fd mt ms mu mv aw mw bi"><span id="64cb" class="mx lm hx ms b fi my mz l na nb">private List&lt;ContentObserver&gt; contentObservers;<br/>private List&lt;DataSetObserver&gt; dataSetObservers;</span><span id="ad81" class="mx lm hx ms b fi nx mz l na nb">public void registerContentObserver(ContentObserver observer) {<br/>    contentObservers.add(observer);<br/>}</span><span id="cbf5" class="mx lm hx ms b fi nx mz l na nb">public void addDataSetObserver(DataSetObserver observer){<br/>    dataSetObservers.add(observer);<br/>}</span></pre><p id="12f6" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">对做同样事情的方法使用<strong class="jo hy">相同的名字</strong>。</p><p id="dc0e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">考虑使用成对的<strong class="jo hy">反义词</strong> : get — set，add — remove，subscribe — unsubscribe，show—dissolve。</p><h2 id="a222" class="mx lm hx bd ln nd ne nf lr ng nh ni lv jv nj nk lx jz nl nm lz kd nn no mb np bi translated">跨方法使用一致的参数排序</h2><p id="1a03" class="pw-post-body-paragraph jm jn hx jo b jp nq iy jr js nr jb ju jv ns jx jy jz nt kb kc kd nu kf kg kh ha bi translated">重载方法时，确保所有方法中出现的参数保持相同的顺序。否则，您的API用户将花费更多的时间来理解重载方法之间的差异。</p><pre class="ml mm mn mo fd mt ms mu mv aw mw bi"><span id="8f6f" class="mx lm hx ms b fi my mz l na nb">void setNotificationUri( <strong class="ms hy">ContentResolver cr,<br/>                         Uri notifyUri</strong>);</span><span id="72c1" class="mx lm hx ms b fi nx mz l na nb">void setNotificationUri( <strong class="ms hy">Uri notifyUri,<br/>                         ContentResolver cr</strong>,<br/>                         int userHandle);</span></pre><h2 id="ecf6" class="mx lm hx bd ln nd ne nf lr ng nh ni lv jv nj nk lx jz nl nm lz kd nn no mb np bi translated">避免函数具有多个相同类型的连续参数</h2><p id="6ce6" class="pw-post-body-paragraph jm jn hx jo b jp nq iy jr js nr jb ju jv ns jx jy jz nt kb kc kd nu kf kg kh ha bi translated">尽管Android Studio使得使用具有多个连续的同类型参数的方法变得更加容易，但是排序错误很容易出现，也很难被发现。参数顺序应该尽可能与参数的逻辑顺序相匹配。</p><figure class="ml mm mn mo fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ny"><img src="../Images/9c7309750475ebc84df01c1c066295a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2oT4UN19rU1q_aJI."/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">It’s easy to make mistakes when parameters have the same type. Here county and country are interchanged.</figcaption></figure><p id="0b39" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">作为这个问题的解决方案，您可以使用构建器模式，或者对于科特林的<a class="ae hu" href="https://kotlinlang.org/docs/reference/functions.html" rel="noopener ugc nofollow" target="_blank">命名参数</a>。</p><h2 id="7fba" class="mx lm hx bd ln nd ne nf lr ng nh ni lv jv nj nk lx jz nl nm lz kd nn no mb np bi translated">方法应该最多有4个参数</h2><p id="40f4" class="pw-post-body-paragraph jm jn hx jo b jp nq iy jr js nr jb ju jv ns jx jy jz nt kb kc kd nu kf kg kh ha bi translated">参数越多，方法越复杂。对于每个参数，用户需要理解方法的含义以及与其他参数的关系。这意味着每一个额外的参数都会导致复杂性的指数增长。当一个方法有4个以上的参数时，考虑将其中一些封装在其他类中或者使用构建器。</p><h2 id="2c44" class="mx lm hx bd ln nd ne nf lr ng nh ni lv jv nj nk lx jz nl nm lz kd nn no mb np bi translated">返回值会影响方法的复杂性</h2><p id="5ded" class="pw-post-body-paragraph jm jn hx jo b jp nq iy jr js nr jb ju jv ns jx jy jz nt kb kc kd nu kf kg kh ha bi translated">当一个方法返回一个值时，开发人员需要知道这个值代表什么，如何存储，等等。当不使用返回值时，它对方法的复杂性没有影响。</p><p id="fb6a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">例如，当在数据库中插入一个对象时，Room可以同时返回一个<code class="du mp mq mr ms b">Long</code>或<code class="du mp mq mr ms b">void</code>。当API用户想要使用返回值时，首先需要理解它的含义，然后才是在哪里存储它。当不需要该值时，可以使用void方法。</p><pre class="ml mm mn mo fd mt ms mu mv aw mw bi"><span id="4747" class="mx lm hx ms b fi my mz l na nb">@Insert<br/><strong class="ms hy">Long</strong> insertData(Data data);</span><span id="99b3" class="mx lm hx ms b fi nx mz l na nb">@Insert<br/><strong class="ms hy">void</strong> insertData(Data data);</span></pre><p id="47d2" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因此，您应该更喜欢返回值，让API用户决定他们在哪里需要它。如果您正在创建基于代码生成的库，请允许返回这两个选项的方法。</p><h1 id="6f9b" class="ll lm hx bd ln lo lp lq lr ls lt lu lv jd lw je lx jg ly jh lz jj ma jk mb mc bi translated">5.错误预防</h1><blockquote class="md me mf"><p id="d6c8" class="jm jn mg jo b jp jq iy jr js jt jb ju mh jw jx jy mi ka kb kc mj ke kf kg kh ha bi translated">创造一个从一开始就防止问题发生的设计。</p></blockquote><p id="00b7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">通常，用户会从手头的任务中分心，所以你应该通过引导用户来防止无意识的错误，这样他们就能保持在正确的道路上，减少失误的机会。例如，你可以要求他们在采取破坏性行动之前进行确认，或者建议好的默认设置。</p><p id="f703" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">例如，Google相册通过添加确认对话框来确保你不会误删除相册。收件箱允许你暂停一封邮件，并提供一键默认设置。</p><figure class="ml mm mn mo fd hj er es paragraph-image"><div class="er es nz"><img src="../Images/b3442d5b10a1e08e5f9bc2e30306a66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*qLkM_Zm1bR15IgbFZiKMRQ.png"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">Google Photo uses confirmation before destructive actions. Inbox provides one-click defaults when snoozing an email</figcaption></figure><h2 id="24cf" class="mx lm hx bd ln nd ne nf lr ng nh ni lv jv nj nk lx jz nl nm lz kd nn no mb np bi translated">API应该引导用户正确使用API。尽可能使用默认值。</h2><p id="3f88" class="pw-post-body-paragraph jm jn hx jo b jp nq iy jr js nr jb ju jv ns jx jy jz nt kb kc kd nu kf kg kh ha bi translated">API应该易于使用，难以误用。通过提供默认值来帮助您的用户。例如，在创建房间数据库时，其中一个默认值确保即使在增加数据库版本时也能保留数据库中的数据。这为合并了空间的应用程序的用户带来了更好的可用性，因为他们的数据被保留并且数据库版本是透明的。</p><p id="f0a7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Room还提供了一个可以改变这种行为的方法:<code class="du mp mq mr ms b"><a class="ae hu" href="https://developer.android.com/reference/android/arch/persistence/room/RoomDatabase.Builder.html#fallbackToDestructiveMigration()" rel="noopener ugc nofollow" target="_blank">fallbackToDestructiveMigration</a></code>如果没有提供迁移，当版本改变时，它会销毁然后重新创建数据库。</p></div><div class="ab cl oa ob go oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ha hb hc hd he"><p id="b5ff" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们还有5条指导方针需要深入研究:</p><ul class=""><li id="81b3" class="kx ky hx jo b jp jq js jt jv kz jz la kd lb kh oh ld le lf bi translated"><a class="ae hu" rel="noopener" href="/google-developers/developers-are-users-too-part-2-96e03fe17535#b705">承认而不是回忆</a></li><li id="d589" class="kx ky hx jo b jp lg js lh jv li jz lj kd lk kh oh ld le lf bi translated"><a class="ae hu" rel="noopener" href="/google-developers/developers-are-users-too-part-2-96e03fe17535#0709">使用的灵活性和效率</a></li><li id="240f" class="kx ky hx jo b jp lg js lh jv li jz lj kd lk kh oh ld le lf bi translated"><a class="ae hu" rel="noopener" href="/google-developers/developers-are-users-too-part-2-96e03fe17535#3033">唯美极简设计</a></li><li id="541d" class="kx ky hx jo b jp lg js lh jv li jz lj kd lk kh oh ld le lf bi translated"><a class="ae hu" rel="noopener" href="/google-developers/developers-are-users-too-part-2-96e03fe17535#d40e">帮助用户识别、诊断错误并从中恢复</a></li><li id="fe1d" class="kx ky hx jo b jp lg js lh jv li jz lj kd lk kh oh ld le lf bi translated"><a class="ae hu" rel="noopener" href="/google-developers/developers-are-users-too-part-2-96e03fe17535#e86b">帮助和文档</a></li></ul></div></div>    
</body>
</html>