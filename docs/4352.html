<html>
<head>
<title>From Java to Kotlin and back (II): Calling Kotlin from Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Java到Kotlin并返回(II):从Java调用Kotlin</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/from-java-to-kotlin-and-back-ii-calling-kotlin-from-java-3bdf72da6e52?source=collection_archive---------6-----------------------#2021-03-07">https://medium.com/google-developer-experts/from-java-to-kotlin-and-back-ii-calling-kotlin-from-java-3bdf72da6e52?source=collection_archive---------6-----------------------#2021-03-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/56a3906ec245aecc70a64cc313c09c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4E0BvbPibFWgKGs1iPi-9w.jpeg"/></div></div></figure><div class=""/><p id="4e00" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本文是系列文章的一部分。您可以在这里找到本系列的其余文章:</p><p id="4438" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" rel="noopener" href="/google-developer-experts/from-java-to-kotlin-and-back-ii-calling-kotlin-from-java-3bdf72da6e52">从Java到Kotlin并返回(II):从Java调用kot Lin</a></p><p id="90bf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://enriquelopezmanas.medium.com/from-java-to-kotlin-and-back-iii-calling-java-from-kotlin-f33f5c246d69" rel="noopener">从Java到Kotlin并返回(III):从Kotlin调用Java</a></p><p id="eabb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上一篇文章中，我们探讨了Java和Kotlin如何相互交互，以及这方面的一些注意事项。在第二版中，我们将继续思考Java调用Kotlin时需要考虑的一些相关方面。</p><h1 id="616c" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">类别中的属性</h1><p id="e306" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">当我们听到语言和数据类时，第一个突出的Kotlin特性可能是。数据类主要用来保存数据，并允许一些额外的功能，因此被称为数据类。我们喜欢它们是因为它们会自动生成一些函数(getters、setters、<code class="du kr ks kt ku b">toString()</code>、<code class="du kr ks kt ku b">copy()</code>、<code class="du kr ks kt ku b">equals()</code>和<code class="du kr ks kt ku b">hashCode()</code>，否则我们需要手动创建这些函数。例如，一个只包含<code class="du kr ks kt ku b">var name : String</code>的数据类将在Java中编译成如下代码:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx">Data class compiled in Java</figcaption></figure><p id="4fb6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果变量的名称以is开头，那么得到的getter将以前缀is开头。比如说。如果我们有<code class="du kr ks kt ku b">var isYoung: Boolean</code>，那么产生的setter将是:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx">Resulting setter of an “is” attribute</figcaption></figure><p id="01b2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请记住，这不仅适用于布尔类型，也适用于任何类型。</p><h1 id="d452" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">用JvmName命名</h1><p id="d0bb" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们在上一篇文章中探讨了<code class="du kr ks kt ku b">@JvmName</code>的一些用法，我想提供一些更多的想法。</p><p id="4910" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，尽管Kotlin支持可选值，但在Java中我们并不这样命名。因此，如果我们正在设计可能被Java调用的扩展函数，我们可能希望为它们提供一个不同的名称，以便它们对我们的Java代码来说足够地道。让我们检查以下代码:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx">Kotlin class with idiomatic naming</figcaption></figure><p id="4ba2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">很可能会让我们的Java同行感到困惑，他们在寻找的是一个变量是否可能为空。因此，我们指定<code class="du kr ks kt ku b">@JvmName(“ofNullable”)</code>，来改变产生的JVM名称。这将在Java中被调用如下:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx">Java calling JvmName function</figcaption></figure><p id="bacd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">还要注意，Java可以访问不同类型的密封类。</p><h1 id="6240" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Java接口中的默认方法</h1><p id="c85e" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">从Java 1.8开始，Java接口可以包含默认方法。无需太多细节，它们使您能够向现有接口添加新功能，确保与为上述接口的旧版本编写的代码兼容。下面的<a class="ae jn" href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" rel="noopener ugc nofollow" target="_blank">链接</a>详细解释了它们的工作原理。</p><p id="5b16" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们想让Kotlin接口的所有非抽象成员成为实现它们的任何Java类的默认成员，我们需要用以下选项编译代码:</p><p id="8d12" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b">-Xjvm-default=all</code></p><p id="b03c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们在实践中看到这一点。考虑下面这个带有默认方法的接口，我们正在用<code class="du kr ks kt ku b">-Xjvm-default=all</code>进行编译:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx">Default interface Kotlin</figcaption></figure><p id="fadf" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这将在Java类中实现，如下所示:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx">Java class implementing default interface</figcaption></figure><p id="f3b3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当然，Java将能够调用接口的所有功能:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx">Java class calling default methods</figcaption></figure><p id="bd63" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个有趣的调整是，当然，Java也可以覆盖所有的默认函数。因此，如果在我们的例子中，<code class="du kr ks kt ku b">functionA()</code>需要在实现它的类中有一个自定义实现，我们可以安全地覆盖它。</p><h1 id="e688" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">Getter和Setter重命名</h1><p id="9c4d" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">偶尔我们可能想要重命名我们的getters和setters。一个典型的例子是，当返回一个属性时，可以通过对一些其他属性的操作来组合(例如，返回一个带有<code class="du kr ks kt ku b">getName()</code>的名称，它添加了某种前缀或评估来确定返回的完整字符串)。我们可以很容易地用注释<code class="du kr ks kt ku b">@get:JvmName</code>和<code class="du kr ks kt ku b">@set:JvmName</code>来做，如下所示:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx">Changing getters and setters</figcaption></figure><h1 id="375f" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">零安全</h1><p id="6d79" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">Kotlin是空安全的，Java不是空安全的。当我们从Java调用Kotlin函数时，我们总是可以传递一个<code class="du kr ks kt ku b">null</code>作为非空参数。Kotlin为所有需要非空值的公共函数生成运行时检查。这立即在Java代码中引发了一个<code class="du kr ks kt ku b">NullPointerException</code>。在函数中定义可空参数和不可空参数时要小心，因为在Kotlin中令人愉快的体验可能会变成Java代码中的运行时异常。</p><h1 id="f72b" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">在Java中使用Nothing类型</h1><p id="d743" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">或者从技术上来说，不使用它，因为在Java世界中没有自然的对等物。其实很有意思，因为java Void接受null，但没有什么不接受的。事实上，这是计算机科学中的一个复杂问题，我们可以从哲学上用另一种方法来解决，因为我们试图用一些东西来表示任何东西，而我们是处理我们世界中物品的物理表现的生物。抛开虚无不谈，在Java中，虚无类型用原始类型表示，所以在处理虚无时要记住这一点:</p><figure class="kv kw kx ky fd hj"><div class="bz dy l di"><div class="kz la l"/></div><figcaption class="lb lc et er es ld le bd b be z dx">Nothing in Java</figcaption></figure><h1 id="30d9" class="jo jp hs bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">摘要</h1><p id="41b8" class="pw-post-body-paragraph ip iq hs ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">本文探讨了更多从Java调用Kotlin代码的技巧。本系列的下一篇文章将探索河流的反面，我们将了解Kotlin如何使用遗留Java代码进行编码，以及我们需要记住哪些注意事项。</p><p id="860f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在我的推特账户上写下我对软件工程和生活的想法。如果你喜欢这篇文章或者它对你有帮助，请随意分享，👏和/或发表评论。这是给业余作家加油的货币。</p></div></div>    
</body>
</html>