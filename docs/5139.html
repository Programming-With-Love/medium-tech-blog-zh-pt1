<html>
<head>
<title>Mitigating The Risk Of Long-Running Processes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">降低长时间运行流程的风险</h1>
<blockquote>原文：<a href="https://medium.com/mendix/mitigating-the-risk-of-long-running-processes-9fcdf1cd04d6?source=collection_archive---------3-----------------------#2021-08-27">https://medium.com/mendix/mitigating-the-risk-of-long-running-processes-9fcdf1cd04d6?source=collection_archive---------3-----------------------#2021-08-27</a></blockquote><div><div class="ef hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fm fo hv hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff hs"><img src="../Images/b70d07c8ab63e5a61377e6bfb3fbcfe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmtC5fCi3Z99XL6EvmHXFw.png"/></div></div></figure><div class=""/><h1 id="d86c" class="jc jd if bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz dt translated">我们都经历过。无论你多么小心谨慎，还是会有一些脏东西渗入到你的数据中，需要清理。或者您可能有一个长时间运行的流程，例如复杂的价格上涨或计算。然而，一个处理不当的小错误可能会导致整个流程回滚(并且会花费大量的处理时间！)</h1><p id="4822" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">虽然在Mendix中有多种方法可以解决这个问题，但是降低整个长时间运行的流程失败风险的一种方法是以基于行(或基于对象)的调度方法运行流程。这可以通过为您的处理器创建一个单独的模块或将其构建到受影响的模块中来实现。如果您正在处理多个项目，这些项目都可以从中受益，那么推荐使用单独的模块方法，因为它有助于确保该功能可以在不同的项目和项目中的模块之间持续重用。本文将使用分离模块方法作为例子。</p><p id="e3bb" class="pw-post-body-paragraph ka kb if bd b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">注意，本文假设您以前使用过MxModelReflection和CommunityCommons模块。因此，需要这些模块的一些功能可能不会深入讨论。这两个模块都可以在Mendix市场上免费获得。</p><h2 id="891e" class="lc jd if bd je ld le lf ji lg lh li jm kk lj lk jq ko ll lm ju ks ln lo jy lp dt translated">为什么要使用预定流程方法？</h2><p id="4dd7" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">当少数数据点可能导致错误时，计划流程方法是有益的——无论错误是否是预期的。“捕捉”这些错误可以帮助识别边缘情况数据点，并改进您的处理流程。</p><p id="2e82" class="pw-post-body-paragraph ka kb if bd b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这种方法的一些好处包括:</p><ul class=""><li id="7d81" class="lq lr if bd b kc kx kg ky kk ls ko lt ks lu kw lv lw lx ly dt translated"><em class="lz">它减少了事务时间(不一定是总的事务时间，而是单个事务的时间，从而减少了可以回滚的项目)</em></li><li id="2974" class="lq lr if bd b kc ma kg mb kk mc ko md ks me kw lv lw lx ly dt translated"><em class="lz">它可以捕捉错误(取决于你的设置)并以一种有意义的方式显示它们，而无需回滚你之前完成的所有更改</em></li><li id="3c06" class="lq lr if bd b kc ma kg mb kk mc ko md ks me kw lv lw lx ly dt translated"><em class="lz">如果需要，可以暂停加工</em></li><li id="f434" class="lq lr if bd b kc ma kg mb kk mc ko md ks me kw lv lw lx ly dt translated"><em class="lz">可以创建其他功能，如报告工具</em></li></ul><p id="9b26" class="pw-post-body-paragraph ka kb if bd b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">这种方法的一些缺点包括:</p><ul class=""><li id="6b48" class="lq lr if bd b kc kx kg ky kk ls ko lt ks lu kw lv lw lx ly dt translated"><em class="lz">总处理时间增加</em></li><li id="794a" class="lq lr if bd b kc ma kg mb kk mc ko md ks me kw lv lw lx ly dt translated"><em class="lz">读/写IOPS的增加</em></li></ul><figure class="mg mh mi mj fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mf"><img src="../Images/68b5c5e685331c4387281d4ceba59e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ulMuMZZp9PZ-3o7aqghgnw.png"/></div></div><figcaption class="mk ml fg fe ff mm mn bd b be z ek"><a class="ae mo" href="https://www.mendix.com/pricing/#pricingTable" rel="noopener ugc nofollow" target="_blank">https://www.mendix.com/pricing</a></figcaption></figure><h2 id="20aa" class="lc jd if bd je ld le lf ji lg lh li jm kk lj lk jq ko ll lm ju ks ln lo jy lp dt translated"><strong class="ak">它是如何工作的？</strong></h2><p id="8606" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">本节高度概括了如何实现计划流程。</p><p id="d2f9" class="pw-post-body-paragraph ka kb if bd b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">使用下面的图片作为参考，<strong class="bd mp">YourProcessModule</strong>——包含处理功能的模块——其核心由两个主要实体组成:<strong class="bd mp">装载器</strong>和<strong class="bd mp">对象助手</strong>。LoadHolder将包含执行处理所需的相关信息，如用户和微流，以及附加信息，如与之相关的行数。<strong class="bd mp"> ObjectHelper </strong>将被用作一个<strong class="bd mp">泛化</strong>实体，该实体将充当需要处理的实体和LoadHolder之间的链接，并将包含诸如对象是否已经被处理之类的信息。</p><figure class="mg mh mi mj fq hw fe ff paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="fe ff mq"><img src="../Images/09189d301ef32cf823767b8257d4a8aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*moOvDg9DnKZ-6dTXulBxTg.png"/></div></div></figure><p id="e26a" class="pw-post-body-paragraph ka kb if bd b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><strong class="bd mp"> ImplementedModule </strong>将包含要进行处理的实体。在这个场景中，它是<strong class="bd mp"> EntityA </strong>。在ImplementModule中创建了一个新实体，<strong class="bd mp">entityprocesshelper</strong>，它是<strong class="bd mp"> YourProcessModule的<strong class="bd mp">专门化</strong>。对象助手</strong>。EntityAProcessHelper将链接到EntityA，从而完成您要处理的实体和装载固定器之间的引用。</p><p id="9c2e" class="pw-post-body-paragraph ka kb if bd b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">处理器的流程可以总结如下:</p><ol class=""><li id="459b" class="lq lr if bd b kc kx kg ky kk ls ko lt ks lu kw mr lw lx ly dt translated">按钮或预定事件创建LoadHolder和EntityAProcessHelpers</li><li id="e046" class="lq lr if bd b kc ma kg mb kk mc ko md ks me kw mr lw lx ly dt translated">您的ProcessModule中的计划事件检查是否有任何具有未处理的ObjectHelpers的LoadHolders。如果有，它开始使用与LoadHolder相关联的微流和用户来处理它。</li><li id="e2e7" class="lq lr if bd b kc ma kg mb kk mc ko md ks me kw mr lw lx ly dt translated">然后批量处理与装入容器相关联的ObjectHelpers</li><li id="3217" class="lq lr if bd b kc ma kg mb kk mc ko md ks me kw mr lw lx ly dt translated">所有的处理都是通过使用与LoadHolder相关联的微流和一个Java动作来完成的，比如在Mendix的CommunityCommons模块中提供的executeenverifiedmicrosflowauser动作。</li><li id="1e83" class="lq lr if bd b kc ma kg mb kk mc ko md ks me kw mr lw lx ly dt translated">如果ObjectHelper处理成功，它将被标记为已处理。否则，ObjectHelper被标记为已处理但有错误。注意，对象助手的这种标记需要发生在处理微流中。</li></ol><h2 id="a5c9" class="lc jd if bd je ld le lf ji lg lh li jm kk lj lk jq ko ll lm ju ks ln lo jy lp dt translated"><strong class="ak">一些需要考虑的事情</strong></h2><p id="57c5" class="pw-post-body-paragraph ka kb if bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hn dt translated">如前所述，这种方法只是减轻长时间运行的流程和数据修复风险的一种方式，实施这种方法可能会带来一些操作上的好处。然而，正如本叔叔所说，“权力越大，责任越大”。我们遇到的一些问题如下:</p><ul class=""><li id="f97f" class="lq lr if bd b kc kx kg ky kk ls ko lt ks lu kw lv lw lx ly dt translated">如果您想要添加暂停处理的功能，请确保在您想要运行流程时没有暂停它！如果你忘记了你的暂停处理，你可能会得到一个很长的提示。</li><li id="4ecf" class="lq lr if bd b kc ma kg mb kk mc ko md ks me kw lv lw lx ly dt translated">使用日志来帮助跟踪您的进程的进展(它也有助于识别无限循环…哎呀…)</li><li id="cadb" class="lq lr if bd b kc ma kg mb kk mc ko md ks me kw lv lw lx ly dt translated">对于连续的过程(如周期性的、复杂的增加)，使用一种标记，如布尔值，以确保特定的实体不会被选择两次进行处理。您可以在处理中使用验证，但是，使用标记有助于减少不必要的处理</li><li id="54a3" class="lq lr if bd b kc ma kg mb kk mc ko md ks me kw lv lw lx ly dt translated">将您的处理批次保持在合理的规模。批量太小会导致不必要的开销。批量太大，会降低您的环境。我们发现一个最佳点是大约500-1000行。</li></ul><h2 id="4b49" class="lc jd if bd je ld le lf ji lg lh li jm kk lj lk jq ko ll lm ju ks ln lo jy lp dt translated">阅读更多</h2><div class="ht hu fm fo hv ms"><a href="https://docs.mendix.com/appstore/modules/model-reflection" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd ig fv z el mx eo ep my er et ie dt translated">Mx模型反映-市场指南| Mendix文档</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">Mx模型反射模块允许您从应用程序中访问有关应用程序的域模型的信息。对于…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">docs.mendix.com</p></div></div></div></a></div><div class="ht hu fm fo hv ms"><a href="https://docs.mendix.com/appstore/modules/community-commons-function-library" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd ig fv z el mx eo ep my er et ie dt translated">社区公共函数库-市场指南| Mendix文档</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">Community Commons函数库模块向您的应用程序添加了许多可重用的Java方法，这些方法可以被称为…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">docs.mendix.com</p></div></div></div></a></div><div class="ht hu fm fo hv ms"><a href="https://docs.mendix.com/refguide/scheduled-events" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd ig fv z el mx eo ep my er et ie dt translated">预定事件- Studio Pro 9指南| Mendix文档</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">通过调度事件，您可以让运行时在特定时刻执行微流。该事件也可以是…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">docs.mendix.com</p></div></div></div></a></div><div class="ht hu fm fo hv ms"><a href="https://www.mendix.com/blog/limits-and-offsets/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab ej"><div class="mu ab mv cl cj mw"><h2 class="bd ig fv z el mx eo ep my er et ie dt translated">极限和偏移| Mendix</h2><div class="mz l"><h3 class="bd b fv z el mx eo ep my er et ek translated">最近，我遇到了一个问题，我导入到我的应用程序中的数据没有得到更新，尽管我…</h3></div><div class="na l"><p class="bd b gc z el mx eo ep my er et ek translated">www.mendix.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng ib ms"/></div></div></a></div></div><div class="ab cl nh ni hb nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="hn ho hp hq hr"><p id="e9c5" class="pw-post-body-paragraph ka kb if bd b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><em class="lz">来自发布者- </em></p><p id="0a29" class="pw-post-body-paragraph ka kb if bd b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><em class="lz">如果你喜欢这篇文章，你可以在我们的</em> <a class="ae mo" href="https://medium.com/mendix" rel="noopener"> <em class="lz">媒体页面</em> </a> <em class="lz">或我们自己的</em> <a class="ae mo" href="https://developers.mendix.com/community-blog/" rel="noopener ugc nofollow" target="_blank"> <em class="lz">社区博客网站</em> </a> <em class="lz">找到更多类似的文章。</em></p><p id="01f5" class="pw-post-body-paragraph ka kb if bd b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated"><em class="lz">希望入门的创客，可以注册一个</em> <a class="ae mo" href="https://signup.mendix.com/link/signup/?source=direct" rel="noopener ugc nofollow" target="_blank"> <em class="lz">免费账号</em> </a> <em class="lz">，通过我们的</em> <a class="ae mo" href="https://academy.mendix.com/link/home" rel="noopener ugc nofollow" target="_blank"> <em class="lz">学苑</em> </a> <em class="lz">即时获取学习。</em></p><p id="5371" class="pw-post-body-paragraph ka kb if bd b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hn dt translated">有兴趣更多地参与我们的社区吗？你可以加入我们的 <a class="ae mo" href="https://join.slack.com/t/mendixcommunity/shared_invite/zt-hwhwkcxu-~59ywyjqHlUHXmrw5heqpQ" rel="noopener ugc nofollow" target="_blank"> <em class="lz"> Slack社区频道</em> </a> <em class="lz">或者想更多参与的人，看看加入我们的</em> <a class="ae mo" href="https://developers.mendix.com/meetups/#meetupsNearYou" rel="noopener ugc nofollow" target="_blank"> <em class="lz">遇见ups </em> </a> <em class="lz">。</em></p></div></div>    
</body>
</html>