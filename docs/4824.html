<html>
<head>
<title>Dependency Injection: the pattern without the framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入:没有框架的模式</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/dependency-injection-the-pattern-without-the-framework-33cfa9d5f312?source=collection_archive---------0-----------------------#2018-02-26">https://blog.kotlin-academy.com/dependency-injection-the-pattern-without-the-framework-33cfa9d5f312?source=collection_archive---------0-----------------------#2018-02-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d3f6" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">其实挺好的！</h2></div><blockquote class="kc kd ke"><p id="7a5f" class="kf kg kh ki b kj kk jo kl km kn jr ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">依赖注入是一种模式，而不是任何特定的框架。你甚至可以手动实现它，但是那太麻烦了。</p><p id="20c2" class="kf kg kh ki b kj kk jo kl km kn jr ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated"><strong class="ki io">等等..为什么？我们怎么知道的？</strong></p></blockquote><p id="edca" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><em class="kh">更新:增加了一段关于依赖注入(一个我一直使用的术语)和服务定位器(我通常更喜欢的替代模式)之间的区别。</em></p><p id="dd83" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">依赖注入是Android世界的一个大话题。忽略它，你很快就会感受到痛苦的体验，你所有的代码都与android框架紧密相连，你不能真正以一种有意义和实际有用的方式测试你的应用。</p><p id="501f" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">Dagger 是一个依赖注入框架，最初来自Square，后来被Google重新混合，是android世界的大框架(尽管不限于它)。本文假设读者熟悉dagger。</p><p id="b927" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">关于这个主题的好资源包括杰克·沃顿的一个演讲，一个片段播客，还有一个缺失的指南:如何使用匕首。我将借用后一篇文章中的例子，因为我发现它很实用而且切中要害。</p><p id="11ab" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">关于这个话题的讨论通常的共同点是，他们坚持依赖注入是一种通用的编程模式，而不是任何特定的框架。你可以自己做DI……嗯，除了你不做，因为那根本不实际。</p><p id="4c7f" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我想知道:真的是这样吗？我想我会试一试，好奇看看在哪个点上我会碰壁。</p><p id="2e6d" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">那没有发生。</p><p id="b68d" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">想看看如何用几个约定、一些技巧和普通的语言结构进行依赖注入吗？</p><p id="21e3" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">让我们开始吧。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/427bd818250978921337ce4e7f2bc8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmvLcyhGLS3eeV9Ecm0bFw.png"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">Business Logic / Component / Configuration modules</figcaption></figure><p id="ab56" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我们将保留dagger的基本架构，如上面的模式所述。</p><p id="5607" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">因为我们有相似的架构，我们将通过展示如何从dagger迁移来开始探索。</p><p id="e051" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">假设我们已经正确设置了dagger配置模块。Dagger可以为我们提供AppComponent的实现，这是我们目前所关心的。这允许我们直接处理业务逻辑。但是首先，我们将重构组件。</p><p id="0562" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><strong class="ki io">注意</strong> : <em class="kh">如果您想尝试上面的代码片段，而不必为此配置完整的android项目，请使用下面定义了所需类型的代码片段</em><a class="ae lf" href="https://gist.github.com/jmfayard/5313e2fa8afdbba84bb94ea5a0a52792" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/jmfayard/5313 e 2 fa 8 AFD BBA 84 bb 94 ea 5a 0a 52792</a></p><h1 id="4649" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">出发点</h1><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lf" href="https://gist.github.com/jmfayard/9378a7ed21f61c40424442aa98732905" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/9378a7ed21f61c40424442aa98732905</a></figcaption></figure><p id="9cdb" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我们从一个标准的dagger项目开始，除了我通过一个顶级函数使组件易于访问。稍后将解释这个惯例，现在请耐心听我说。</p><p id="b849" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated"><code class="fe mq mr ms mt b">fun app(): AppComponent = ...</code></p><h1 id="634f" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">构造函数注入，而不是字段注入</h1><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lf" href="https://gist.github.com/jmfayard/1ff428054248d3c2777f78f07da4dec3" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/1ff428054248d3c2777f78f07da4dec3</a></figcaption></figure><p id="bf69" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">在这一点上，你可以做两种类型的DI。我坚定地站在偏爱构造函数注入的一边。我心目中的Fields injection 与Israel Ferrer Camacho所说的“<strong class="ki io">墨西哥卷饼设计模式</strong>”玩得太好了，在那里你在属于框架的上帝对象中放了太多东西。<strong class="ki io">构造函数注入</strong>干净简单。</p><h1 id="fbcb" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">属性的组成部分</h1><p id="93b5" class="pw-post-body-paragraph kf kg in ki b kj mu jo kl km mv jr ko lc mw kr ks ld mx kv kw le my kz la lb ig bi translated">在我们继续讨论业务逻辑之前，我们将应用一个重要的技巧:<strong class="ki io">在组件接口</strong>中使用getter方法内部的属性！</p><p id="9fd2" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">IntelliJ/Android Studio正好有合适的重构工具:<code class="fe mq mr ms mt b">convert function to property</code>让我们把它应用到每一个getter方法上。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lf" href="https://gist.github.com/jmfayard/e609e0c8c329b1ee19fab261de708c78" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/e609e0c8c329b1ee19fab261de708c78</a></figcaption></figure><p id="12cc" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这里发生了什么？对我们来说，它会很重要，但从匕首的角度来看<em class="kh"> : </em> <em class="kh">几乎没什么</em>。它将您的<strong class="ki io"> val </strong> <strong class="ki io">属性</strong>视为有效的getter方法。再次编译该项目，它将继续像魔法一样工作。</p><h1 id="b5a5" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">业务逻辑:构造函数注入+默认值</h1><p id="f8f2" class="pw-post-body-paragraph kf kg in ki b kj mu jo kl km mv jr ko lc mw kr ks ld mx kv kw le my kz la lb ig bi translated">所以我们有一个可以注入的属性列表。下面是我们通常如何在代码生成的dagger方法中使用它们:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lf" href="https://gist.github.com/jmfayard/f1384464039b35e714fea72d750fb1d1" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/f1384464039b35e714fea72d750fb1d1</a></figcaption></figure><p id="df09" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">所以我们在构造函数中传递属性，用<code class="fe mq mr ms mt b">inject</code>注释标记它，在组件中添加一个新的getter方法(或者实际上，一个属性)。为了获得CatController，我们要求组件提供它。</p><p id="d9cd" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">不依靠匕首能达到同样的效果吗？</p><p id="9e77" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">是的，我们可以用一个简单的模式:我们像以前一样在构造函数中声明所需的属性，然后我们声明一个来自组件的相同属性的默认值。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lf" href="https://gist.github.com/jmfayard/184f7389ec851d6b448789ca9fd91fdb" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/184f7389ec851d6b448789ca9fd91fdb</a></figcaption></figure><p id="f7f9" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">几个月来，我一直在使用这种方法，并与dagger一起构建AppComponent本身，它有许多我喜欢的地方:</p><ul class=""><li id="9b30" class="mz na in ki b kj kk km kn lc nb ld nc le nd lb ne nf ng nh bi translated">用法方面非常简单。这只是对构造函数的一个标准调用，按照惯例，不要为可选参数传递任何值。</li><li id="1218" class="mz na in ki b kj ni km nj lc nk ld nl le nm lb ne nf ng nh bi translated">您不必向组件添加新属性</li><li id="ee68" class="mz na in ki b kj ni km nj lc nk ld nl le nm lb ne nf ng nh bi translated">您有两种可能性来启用测试:或者您通过创建一个实现AppComponent的<code class="fe mq mr ms mt b">TestComponent</code>来全局地改变依赖图</li><li id="8c38" class="mz na in ki b kj ni km nj lc nk ld nl le nm lb ne nf ng nh bi translated">…或者你直接在构造函数中通过任何你需要的测试。</li><li id="fb2b" class="mz na in ki b kj ni km nj lc nk ld nl le nm lb ne nf ng nh bi translated">注意你如何混合自由注入的字段(<code class="fe mq mr ms mt b">catService</code>)和普通的构造函数参数(<code class="fe mq mr ms mt b">catId</code>)</li><li id="dd62" class="mz na in ki b kj ni km nj lc nk ld nl le nm lb ne nf ng nh bi translated">注入两种不同类型的属性是很容易的事(<code class="fe mq mr ms mt b">mainThread </code>对<code class="fe mq mr ms mt b">backgroundThread</code>)。不需要使用类似<code class="fe mq mr ms mt b">Named</code>的附加注释</li><li id="468d" class="mz na in ki b kj ni km nj lc nk ld nl le nm lb ne nf ng nh bi translated">因为我们使用的是简单的语言结构，而不是一些额外的语言注释处理魔术，你的IDE(a)可以用它通常帮助你的所有方式来帮助你:自动完成，跳转到<code class="fe mq mr ms mt b">app()</code>的定义，查看一个属性的每个实现，…</li></ul><p id="90fb" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">另一方面，你将不得不输入比我们所依赖的<code class="fe mq mr ms mt b">Inject</code>更多的字符。我很喜欢这种样板文件，它可以使事情变得清晰，并且可以很好地自动完成，所以对我来说这是一个有效的权衡。</p><p id="3770" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这个模式我用了几个月，不会回头。</p><h1 id="fb92" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">概述</h1><p id="4500" class="pw-post-body-paragraph kf kg in ki b kj mu jo kl km mv jr ko lc mw kr ks ld mx kv kw le my kz la lb ig bi translated">下面是我们的依赖注入的三个部分与dagger的比较</p><ul class=""><li id="4520" class="mz na in ki b kj kk km kn lc nb ld nc le nd lb ne nf ng nh bi translated">我们保留了dagger的<code class="fe mq mr ms mt b">Component</code>抽象，做了一些小而重要的调整:我们使用构造函数注入、kotlin属性和一个顶级函数来轻松访问它。</li><li id="5c54" class="mz na in ki b kj ni km nj lc nk ld nl le nm lb ne nf ng nh bi translated">在业务逻辑中，我们为构造函数注入部分制定了自己的约定</li><li id="b297" class="mz na in ki b kj ni km nj lc nk ld nl le nm lb ne nf ng nh bi translated">我们有dagger实现了<code class="fe mq mr ms mt b">Component</code>接口。</li></ul><p id="b063" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">此时，dagger只是一个实现细节。它实现了组件接口，并且做得很好。但是我们也可以直接实现组件接口。</p><p id="7db3" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">当我们开始一个新项目时，有很强的理由这样做。</p><h1 id="496b" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">从零到一</h1><p id="7873" class="pw-post-body-paragraph kf kg in ki b kj mu jo kl km mv jr ko lc mw kr ks ld mx kv kw le my kz la lb ig bi translated">如果我不是从一个已经使用dagger的项目开始，而是从一个全新的项目开始，会怎么样？</p><p id="5d6d" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我曾经有过这样的经历:写了一个应用程序，然后发现已经太晚了，以至于不能用一种有意义的方式来测试它。再也不会了！我想从第一天开始就进行依赖注入。另一方面，dagger最初的设置很痛苦。如果我们可以稍后设置dagger，但仍然使用依赖注入，会怎么样？</p><p id="7b8b" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">假设我们正在构建网络部分。最自然的开始方式就是这样</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lf" href="https://gist.github.com/jmfayard/40b44ba26850d03986e5b56efe31c98f" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/40b44ba26850d03986e5b56efe31c98f</a></figcaption></figure><p id="7e9b" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">接下来我们只需要让我们的接口<code class="fe mq mr ms mt b">ApiComponent</code>有用。让我们使用重构工具<code class="fe mq mr ms mt b">Pull Members Up</code>。<br/>此外，像以前一样，我们通过顶级函数使组件可访问。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lf" href="https://gist.github.com/jmfayard/b65b999a7729664365a11858e603c7eb" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/b65b999a7729664365a11858e603c7eb</a></figcaption></figure><p id="2fc7" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">IDE完成了这里几乎所有的工作！懒惰，这是我非常喜欢的事情。我们已经准备好编写可测试的产品代码。</p><h1 id="5e81" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">科特林地产</h1><p id="c0c5" class="pw-post-body-paragraph kf kg in ki b kj mu jo kl km mv jr ko lc mw kr ks ld mx kv kw le my kz la lb ig bi translated">第一次成功之后，让我们深入探讨一下。用纯kotlin语言复制dagger的代码生成所做的聪明工作有多难？答案是科特林的属性非常强大</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/6ce517806f6231159535b9b1332f8e0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*LabV5fYOODlfivPQ9DR9wA.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">Singleton Provides fun retrofit(okHttpClient: OkHttpClient, moshi: Moshi)</figcaption></figure><p id="8ad5" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这就是我们在ApiModule示例中提供翻新的方式。这里实际上发生了很多事情。用dagger的话来说，我们的ApiModule是一个<em class="kh"> ObjectGraph </em>，它是<em class="kh">基于其他提供<code class="fe mq mr ms mt b">Moshi</code>和<code class="fe mq mr ms mt b">OkHttpClient</code>的方法为</em>提供类型改进。编译器和IDE努力确保我们没有空指针异常，并且不会打乱我们初始化属性的顺序。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi no"><img src="../Images/75e1d38ea209373cd3c3de9747fca2e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*zkz1oYqj643_z3_pZ0QYxA.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">the compiler working hard for us</figcaption></figure><p id="34da" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">有了kotlin属性，正如Perl的一句格言所说，<em class="kh">简单的事情很容易，复杂的事情也有可能。</em></p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b4fc" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">在这一点上，我们陷入了第一世界的问题:我们应该使用dagger来实现组件还是自己实现它？</p><p id="9c59" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">对于这个问题，我的答案是明确的:是的</p><p id="59c2" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">两种方法都有效。根据上下文，我们可以选择不同的权衡。如果团队很了解dagger，dagger没问题。如果团队很了解科特林，直接的方法是没问题的。而且，这是一次很好的学习经历。</p><p id="92a0" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我愉快地使用dagger几个月了。最近我转而直接实现它。转行不难。相同的概念，相同的有向无环依赖图，只是语法不同。</p><p id="0c5f" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">对我来说，转折点是我将我的应用程序模块化，并且能够将除dagger之外的所有代码生成工具归入更小的模块。从主模块中移除<code class="fe mq mr ms mt b">kapt</code>是一个巨大的胜利，因为它拥有可靠快速的增量构建、构建缓存、网络缓存……以及卓越的IDE集成。</p><h1 id="0c13" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">额外收获:java呢？</h1><p id="31ad" class="pw-post-body-paragraph kf kg in ki b kj mu jo kl km mv jr ko lc mw kr ks ld mx kv kw le my kz la lb ig bi translated">有一个不是100%科特林的项目？没问题，依赖默认参数的方法也可以。只需声明两个构造函数，一个包含所有依赖项，另一个传递组件。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lf" href="https://gist.github.com/jmfayard/8b79752a3b93a1e164ee3a98a88035d3" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/8b79752a3b93a1e164ee3a98a88035d3</a></figcaption></figure><h1 id="1d6e" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">额外收获:走向多模块</h1><p id="f90e" class="pw-post-body-paragraph kf kg in ki b kj mu jo kl km mv jr ko lc mw kr ks ld mx kv kw le my kz la lb ig bi translated">正如我所说的，我正在把我的应用程序分成多个更小的模块。事实证明，使用这种模式非常简单。</p><p id="479e" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">函数<code class="fe mq mr ms mt b">fun app(): AppComponent</code>之所以这么叫是因为它提供了<code class="fe mq mr ms mt b">:app</code> gradle模块需要注入的属性。</p><p id="1180" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">如果我们有多个像<code class="fe mq mr ms mt b">:app, :common</code>这样的模块，我们只需要重复这个模式:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lf" href="https://gist.github.com/jmfayard/e982331d4a8dbb8d122f424260c5e601" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/e982331d4a8dbb8d122f424260c5e601</a></figcaption></figure><h1 id="8a55" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">奖励:注入活动/片段</h1><p id="4f1d" class="pw-post-body-paragraph kf kg in ki b kj mu jo kl km mv jr ko lc mw kr ks ld mx kv kw le my kz la lb ig bi translated">到目前为止，我一直假设我处理的是普通的类，其中可以使用构造函数注入。但是属于框架的活动和片段呢？我们通常至少有(通常应该最多有)0个片段和1个活动。</p><p id="1945" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">实际上有很多不同的方法来模拟磁场注入，您可能会发现这些方法很有用</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lf" href="https://gist.github.com/jmfayard/eaf1c45b6b048b9eb51ece527192d7d1" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/eaf1c45b6b048b9eb51ece527192d7d1</a></figcaption></figure><h1 id="cbe4" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">结论</h1><p id="39da" class="pw-post-body-paragraph kf kg in ki b kj mu jo kl km mv jr ko lc mw kr ks ld mx kv kw le my kz la lb ig bi translated">如果没有别的，尝试手工依赖注入将会是一次很好的学习经历。我第一次将dagger集成到我的应用程序中时，感觉势不可挡。同时掌握概念和语法是很难的。我发现深入研究核心依赖注入模式非常有帮助，尽管它非常有用，但实际上很简单。一旦你得到了模式并写下了依赖关系图，设置dagger只是一个语法问题。</p><p id="4c04" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">在玩了几个月的手动DI之后，我可以自信地说，在许多情况下，它实际上是一个很好的选择。</p><p id="a1ef" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">当你开始一个新项目并希望尽快拥有DI时，这是一种优越的体验。一旦你习惯了，事情就简单了。编写体验是优越的，因为您习惯的所有IDE集成在这里也能工作，您不需要依赖语言范围之外的特性。它与构建缓存配合得很好。这对我的构建时间来说是一件好事，因为代码生成现在被限制在更小的模块中。</p><p id="cc75" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">同样，最后，我们使用的概念实际上是有意地与dagger的概念相差不远。如果在项目生命的某个时刻，使用高效成熟的dagger框架更有意义，那么切换并不难。只是语法不同。</p><h1 id="64f1" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">更新(27.02):依赖注入与服务定位器</h1><p id="9bac" class="pw-post-body-paragraph kf kg in ki b kj mu jo kl km mv jr ko lc mw kr ks ld mx kv kw le my kz la lb ig bi translated">在本文中，我一直不严格地使用依赖注入这个术语。</p><p id="565a" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">敏锐的读者指出，我所描述的正确术语是<strong class="ki io">服务定位器</strong>。这是因为我的类像<em class="kh"> CatController </em>是<em class="kh">从外部</em>(在我的例子中是通过默认参数)找到它们的依赖关系。</p><p id="e675" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">为了实现依赖注入，我必须做的最少的改变就是下面的这个改变，在这个改变中，对定位器本身的依赖被移除了。从这个人为的例子中，人们可以开始看到权衡。CatController现在对外界一无所知。另一方面，组件变得更大。它有一个递归的方面。仅仅*使用*一个注入属性的一切可能都应该由组件(DI框架)产生，并以一种巧妙的方式确定范围(我们的“范围”仅限于:交付一个单例或新实例)</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk"><a class="ae lf" href="https://gist.github.com/jmfayard/bfba725b36d99599ceeb0a9ee315114d" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jmfayard/bfba725b36d99599ceeb0a9ee315114d</a></figcaption></figure><p id="5c45" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我以前听说过这种区别，但不太明白为什么它很重要，或者我是否应该在乎。</p><p id="e892" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">在与敏锐的读者讨论之前，我有一个不清楚的前概念，即服务定位器模式比依赖注入模式差一些。事实上它很相似，只是有不同的穿线。Martin Fowler自己对此的看法是<em class="kh">依赖注入和服务定位器之间的选择没有配置和使用分离的原则重要。</em></p><blockquote class="kc kd ke"><p id="06a7" class="kf kg kh ki b kj kk jo kl km kn jr ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">基本的选择是在服务定位器和依赖注入之间。第一点是，这两种实现都提供了简单示例中所缺少的基本解耦——在这两种情况下，应用程序代码都独立于服务接口的具体实现。这两种模式的重要区别在于如何将实现提供给应用程序类。使用服务定位器，应用程序类通过给定位器发送消息来明确地请求它。对于注入，没有明确的请求，服务出现在应用程序类中——因此出现了控制反转。</p><p id="4234" class="kf kg kh ki b kj kk jo kl km kn jr ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">控制反转是框架的一个常见特征，但这是有代价的。当你试着调试时，它往往很难理解并导致问题。所以总的来说，除非我需要，否则我宁愿避免它。这并不是说这是一件坏事，只是我认为它需要证明自己比更直接的选择。</p><p id="443c" class="kf kg kh ki b kj kk jo kl km kn jr ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">关键区别在于，使用服务定位器，服务的每个用户都依赖于定位器。定位器可以隐藏对其他实现的依赖，但是您确实需要看到定位器。所以定位器和注入器之间的决定取决于这种依赖是否是一个问题(…)</p><p id="e1f3" class="kf kg kh ki b kj kk jo kl km kn jr ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated"><strong class="ki io">控制容器的倒置和依赖注入模式</strong></p><p id="6b7c" class="kf kg kh ki b kj kk jo kl km kn jr ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">https://martinfowler.com/articles/injection.html<a class="ae lf" href="https://martinfowler.com/articles/injection.html" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><p id="bf6e" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">退一步说，我在寻找什么？我想把我的应用的核心从它的边界(网络、共享偏好、数据库、android框架调用等等)中分离出来。我想通过用假的服务实现替换真实的服务实现来支持测试。我想用一种类型安全的方式来做这件事。</p><p id="1216" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">正确实现的服务定位器模式正好提供了这一点。它更简单，因为它仍然感觉像普通代码。另一方面，DI模式提供了比我真正需要的更多的东西。我能感受到它的美丽，以及它在某些情况下的强大，但这是有代价的。所以我最终意识到，我通常更喜欢简单的服务定位器。</p><h1 id="33f2" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">链接</h1><div class="np nq gp gr nr ns"><a href="https://medium.com/@Zhuinden/that-missing-guide-how-to-use-dagger2-ef116fbea97" rel="noopener follow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">缺失的指南:如何使用Dagger2</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">Dagger是一个依赖注入框架，它使得管理我们的类之间的依赖关系变得更加容易。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og lq ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://kotlinlang.org/docs/reference/properties.html" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">属性和字段:Getters、Setters、const、lateinit - Kotlin编程语言</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">最常见的属性是简单地从后台字段中读取(或者写入)。另一方面，随着…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">kotlinlang.org</p></div></div><div class="ob l"><div class="oh l od oe of ob og lq ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://kotlinlang.org/docs/reference/delegated-properties.html" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">委托属性- Kotlin编程语言</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">一个常见的用例是在地图中存储属性值。这在解析JSON等应用程序中经常出现…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">kotlinlang.org</p></div></div><div class="ob l"><div class="oi l od oe of ob og lq ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a rel="noopener  ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">科特林程序员词典:字段与属性</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">这是一个Java字段的示例:</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="ob l"><div class="oj l od oe of ob og lq ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://martinfowler.com/articles/injection.html" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">控制容器的倒置和依赖注入模式</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">在Java社区中，出现了大量的轻量级容器，它们有助于从不同的…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">martinfowler.com</p></div></div><div class="ob l"><div class="ok l od oe of ob og lq ns"/></div></div></a></div></div><div class="ab cl ol om hr on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ig ih ii ij ik"><p id="e5e8" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">喜欢的话记得<strong class="ki io">拍</strong>。注意，如果你按住鼓掌按钮，你可以留下更多的掌声！</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><a href="https://kt.academy/workshop"><div class="gh gi os"><img src="../Images/3a56ace9079f060f9ee79ad3ed6b6756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HxsEmnZGeKgLuGPFgNaLzA.png"/></div></a></figure><p id="2ae5" class="pw-post-body-paragraph kf kg in ki b kj kk jo kl km kn jr ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">了解卡帕头最新的重大新闻。学院、<a class="ae lf" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>、<a class="ae lf" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi ot"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure></div></div>    
</body>
</html>