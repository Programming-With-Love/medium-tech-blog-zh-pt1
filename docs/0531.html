<html>
<head>
<title>Configuration caching deep dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">配置缓存深入探究</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/configuration-caching-deep-dive-bcb304698070?source=collection_archive---------1-----------------------#2020-07-29">https://medium.com/androiddevelopers/configuration-caching-deep-dive-bcb304698070?source=collection_archive---------1-----------------------#2020-07-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/b2a82fcac9ad9811b5af31876f27824e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E0g4dU6DuLRp5wzblvr5yg.png"/></div></div></figure><div class=""/><h1 id="8fa8" class="iq ir hs bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么是配置缓存？</h1><p id="2761" class="pw-post-body-paragraph jo jp hs jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">无论是从IDE还是从命令行，配置缓存都是加快构建速度的基本构造块。Gradle <code class="du kn ko kp kq b">6.6</code>中的是一个高度实验性的<a class="ae km" href="https://docs.gradle.org/current/userguide/configuration_cache.html" rel="noopener ugc nofollow" target="_blank">特性，它允许构建系统记录一次关于任务图的信息，并在后续的构建中重用它，从而避免了重新配置整个构建的需要。这也是配置阶段改进的延续，其中</a><a class="ae km" href="https://docs.gradle.org/current/userguide/lazy_configuration.html" rel="noopener ugc nofollow" target="_blank">惰性配置</a>被引入以避免在构建的这个阶段不必要的工作。不用说，这对于快速迭代开发尤其重要，这是Android Studio团队一直关注的用例。</p><h1 id="1872" class="iq ir hs bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">性能改进</h1><p id="a582" class="pw-post-body-paragraph jo jp hs jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">这项工作的主要目标是提高构建速度。在与<a class="ae km" href="https://github.com/gradle/santa-tracker-performance" rel="noopener ugc nofollow" target="_blank"> Santa Tracker </a> Android项目的基准测试中，我们测量了Android Studio中启用配置缓存的构建的总构建时间减少了35%(从688毫秒减少到443毫秒)(在采用英特尔(R)至强(R) Gold 6154 CPU @ 3.00GHz的Linux上测量)。这是一个图表，显示了在有和没有配置缓存的情况下，100次构建的平均总构建时间(以毫秒为单位)。</p><figure class="ks kt ku kv fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kr"><img src="../Images/7299c13b23ec6d70bac90c3fbeb9c5c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jr6lRBgUY3oJODK-"/></div></div></figure><p id="aafc" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">对于某些项目，配置阶段可能需要几十秒钟，因此节省的时间可能会更多。无论您运行的是全新构建、增量构建还是最新构建，这种开销都是一样的。要测量构建的配置阶段需要多长时间，在模拟运行模式下运行任务就足够了，例如<code class="du kn ko kp kq b">/gradlew :app:assembleDebug --dry-run</code>。</p><p id="9db7" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">除了避免运行配置阶段，配置缓存还允许来自同一个项目的任务并行运行。以前，只有利用<a class="ae km" href="https://guides.gradle.org/using-the-worker-api/" rel="noopener ugc nofollow" target="_blank"> Worker API </a>的任务可以并发运行，但是因为配置缓存确保任务是隔离的，并且不能访问共享的全局状态(例如<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" rel="noopener ugc nofollow" target="_blank">Project</a></code>实例)，所以这种行为可以默认启用。此外，依赖项解析结果现在在运行之间被缓存，这有助于总体构建时间的改进。</p><h1 id="553b" class="iq ir hs bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">怎么试出来？</h1><p id="f168" class="pw-post-body-paragraph jo jp hs jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">配置缓存目前处于试验状态，我们希望您能试用并向我们提供反馈。为了在您的构建中使用它，所有项目中所有应用的插件都应该兼容。为了安全地序列化(反序列化)任务图，这是必要的。你可能需要更新一些Gradle插件，所以请参见<a class="ae km" href="https://github.com/gradle/gradle/issues/13490" rel="noopener ugc nofollow" target="_blank">本期</a>获得支持的插件的完整列表。如果您正在使用的插件不在列表中，请在他们的问题跟踪器上提交一个问题，并从Gradle <a class="ae km" href="https://github.com/gradle/gradle/issues/13490" rel="noopener ugc nofollow" target="_blank"> issue </a>链接到它。</p><p id="a11d" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">Android Gradle插件的最新<code class="du kn ko kp kq b">4.1</code>版本(目前为<code class="du kn ko kp kq b">4.1.0-beta05</code>)是兼容的，但如果你想获得所有的错误修复，请尝试最新的<code class="du kn ko kp kq b">4.2</code>版本(目前为<code class="du kn ko kp kq b">4.2.0-alpha06</code>)。Gradle版本应该是6.6，如果你正在使用Kotlin，请将Kotlin Gradle插件更新到最新的1.4版本(相关<a class="ae km" href="https://youtrack.jetbrains.com/issue/KT-33908" rel="noopener ugc nofollow" target="_blank"> Kotlin问题</a>)。最后，用以下内容更新gradle.properties</p><pre class="ks kt ku kv fd lb kq lc ld aw le bi"><span id="7a29" class="lf ir hs kq b fi lg lh l li lj">org.gradle.unsafe.configuration-cache=true<br/># Use this flag sparingly, in case some of the plugins are not fully compatible<br/>org.gradle.unsafe.configuration-cache-problems=warn</span></pre><p id="d98e" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">要验证配置缓存是否启用，您应该在Android Studio的构建输出窗口中或者在第一次运行时的命令行中看到<code class="du kn ko kp kq b">“Calculating task graph as no configuration cache is available for tasks…”</code>。第二次运行应该重用配置缓存，并且它应该在输出中包含<code class="du kn ko kp kq b">“Reusing configuration cache.”</code>。</p><p id="4b41" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">请在Android Studio <a class="ae km" href="https://developer.android.com/studio/report-bugs" rel="noopener ugc nofollow" target="_blank">问题跟踪器</a>或Gradle <a class="ae km" href="https://github.com/gradle/gradle/issues" rel="noopener ugc nofollow" target="_blank">问题跟踪器</a>上报告任何问题。</p><h1 id="2c99" class="iq ir hs bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">它是如何工作的？</h1><p id="e691" class="pw-post-body-paragraph jo jp hs jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">为了深入配置缓存的细节，我们需要从构建的配置阶段开始。即使启用了配置缓存，第一次构建也会经历这个阶段。在构建的这一部分，所有已经包含的项目(在评估<code class="du kn ko kp kq b">settings.gradle</code>时)都是通过评估它们的构建文件来配置的。通常，所有插件将首先被应用，DSL对象将被实例化。接下来，构建文件评估将继续，DSL对象将被赋予您指定的值。一旦构建文件评估完成，Android Gradle插件(和许多遵循相同模式的其他插件)将调用它们的<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#afterEvaluate-org.gradle.api.Action-" rel="noopener ugc nofollow" target="_blank">Project.afterEvaluate</a></code>回调。在这个回调过程中，大部分工作由Android Gradle插件完成，包括创建变体和注册任务。</p><p id="9e86" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">在DSL评估和任务注册之后，下一阶段构建任务图。您请求执行的任务将被完全配置，并且它们依赖的所有任务也将被配置。这一直持续到到达没有依赖性的叶任务。这个配置阶段的输出是一个任务图，Gradle中的调度机制将使用它来运行构建操作。一旦任务图完成，配置缓存将把它存储在磁盘上(对于格雷德<code class="du kn ko kp kq b">6.6 </code>来说，这是在根项目<code class="du kn ko kp kq b">.gradle/configuration-cache directory</code>下)。能够序列化所有分级管理的类型(如<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/file/FileCollection.html" rel="noopener ugc nofollow" target="_blank">FileCollection</a></code>、<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Property.html" rel="noopener ugc nofollow" target="_blank">Property</a></code>、<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Provider.html" rel="noopener ugc nofollow" target="_blank">Provider</a></code>)和所有用户自定义的可序列化类型。在这个阶段结束时，每个任务的状态都将被完整地记录和持久化。</p><p id="a359" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">在第二次构建期间，假设Gradle能够重用已记录的缓存，则所请求任务的任务图将被加载，跳过DSL评估、任务配置等。这意味着所有任务都将被实例化，它们的属性将从缓存中加载。从这一点开始，构建几乎与非缓存的构建一样，默认情况下并行运行任务，并重用缓存中的依赖关系解析结果。</p><p id="db69" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">为了保证正确性，Gradle跟踪影响缓存任务图的所有输入，包括构建文件、请求的任务以及在配置期间访问的Gradle和系统属性。请求运行一组不同的任务会导致不同的任务图，因此创建一个新的缓存条目是必要的。需要使状态无效的一个例子是，如果您更改构建文件或<code class="du kn ko kp kq b">buildSrc</code>，为环境变量或系统属性传递一个不同的值。为了检测这样的变化，构建系统创建了当任务图被缓存时使用的构建文件的快照。此外，它还检测在<code class="du kn ko kp kq b">buildSrc</code>中是否有任何任务不是最新的。最后，任何影响配置阶段的值都应该包装在Gradle管理的类型中。这允许构建系统跟踪在配置阶段使用了哪个值的变量。</p><h1 id="22ab" class="iq ir hs bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">使用兼容的Gradle API</h1><p id="db58" class="pw-post-body-paragraph jo jp hs jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">构建中应用的所有Gradle插件都需要与配置缓存兼容。因此，引入了一组新的API。在这里，我们研究一些由配置缓存和API强加的约束。</p><h2 id="cd33" class="lf ir hs bd is lk ll lm iw ln lo lp ja jz lq lr je kd ls lt ji kh lu lv jm lw bi translated">在任务中使用项目实例</h2><p id="9c75" class="pw-post-body-paragraph jo jp hs jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">Gradle插件中最常见的不兼容性是在任务动作中使用<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/Task.html#getProject--" rel="noopener ugc nofollow" target="_blank">Task.getProject()</a></code>。使用配置缓存，任务将停止访问这种共享状态，以便使它们完全隔离。这是必要的，因为对于<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" rel="noopener ugc nofollow" target="_blank">Project</a> </code>实例，可以访问<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#getTasks--" rel="noopener ugc nofollow" target="_blank">TaskContainer</a></code>、<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html#getConfigurations--" rel="noopener ugc nofollow" target="_blank">ConfigurationContainer</a></code>和其他不会在缓存运行中填充的对象，从而反映无效状态。引入了许多替代API，专注于惰性对象创建，如<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/model/ObjectFactory.html" rel="noopener ugc nofollow" target="_blank">ObjectFactory</a></code>，这些API可用于获取项目文件系统布局信息，如<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/file/ProjectLayout.html" rel="noopener ugc nofollow" target="_blank">ProjectLayout</a></code>和<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/process/ExecOperations.html" rel="noopener ugc nofollow" target="_blank">ExecOperations</a></code>，以防您需要在构建中启动进程。在这里，您可以找到要迁移到的API的全面列表。</p><h2 id="28de" class="lf ir hs bd is lk ll lm iw ln lo lp ja jz lq lr je kd ls lt ji kh lu lv jm lw bi translated">访问梯度/系统属性或环境变量</h2><p id="ae04" class="pw-post-body-paragraph jo jp hs jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">如果您想使用系统属性、梯度属性、环境变量或附加文件来指定构建逻辑输入，会发生什么情况？构建系统已经跟踪了对构建文件的更改，但是任何影响任务图的附加值都应该通过使用<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/ProviderFactory.html" rel="noopener ugc nofollow" target="_blank">ProviderFactory</a></code> API来获得。下面的例子显示了如何获取影响配置的<code class="du kn ko kp kq b">enableTask </code>系统属性值，以及如何获取仅仅是任务输入的<code class="du kn ko kp kq b">anotherFlag</code>系统属性。如果前一个的值发生变化，缓存将失效，如果后一个发生变化，缓存将被重用，任务将不是最新的。</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="ed70" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">在幕后，Gradle跟踪在配置阶段解决的值提供者，其中的每一个都被认为是构建逻辑输入。此外，除非调用<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/Provider.html#forUseAtConfigurationTime--" rel="noopener ugc nofollow" target="_blank">Provider.forUseAtConfigurationTime()</a></code>，否则不可能解析提供者，从而很难引入意外的配置阶段输入。正如已经提到的，如果任何构建文件改变，Gradle将使配置缓存无效，所以这与<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/provider/ProviderFactory.html" rel="noopener ugc nofollow" target="_blank">ProviderFactory</a> </code> API一起确保捕获影响任务图的一切。</p><h2 id="93b6" class="lf ir hs bd is lk ll lm iw ln lo lp ja jz lq lr je kd ls lt ji kh lu lv jm lw bi translated">任务间共享工作</h2><p id="d91d" class="pw-post-body-paragraph jo jp hs jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">如果你想在任务之间共享一些工作，比如避免多次连接到一个web服务器或者避免多次解析一些信息，<a class="ae km" href="https://docs.gradle.org/current/userguide/build_services.html" rel="noopener ugc nofollow" target="_blank">共享构建服务</a>是一种配置缓存兼容的实现方式。与任务类似，构建服务也有输入，这些输入将在第一次运行时被序列化。缓存运行将简单地反序列化参数并实例化任务所需的构建服务。构建服务的额外好处是它们非常适合构建生命周期。如果构建完成后您想释放一些资源，那么在您的构建服务中实现<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html?is-external=true" rel="noopener ugc nofollow" target="_blank">AutoCloseable</a></code>就足够了。添加生成侦听器与配置缓存不兼容，因为那些侦听器无法安全地序列化到磁盘。</p><h1 id="9637" class="iq ir hs bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Android Gradle插件迁移的教训</h1><p id="b560" class="pw-post-body-paragraph jo jp hs jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated">在努力使Android Gradle插件与配置缓存兼容的过程中，我们学到了一些插件和构建脚本作者可能会觉得有用的东西。</p><p id="0b52" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">首先，如果在启用配置缓存后，您在构建输出中看到类似这样的内容，请不要气馁，因为许多问题都是重复的，可以不费吹灰之力就得到解决:</p><pre class="ks kt ku kv fd lb kq lc ld aw le bi"><span id="e7d1" class="lf ir hs kq b fi lg lh l li lj">428 problems were found reusing the configuration cache, 4 of which seem unique.</span></pre><p id="47f3" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">我们遇到了许多问题，通过迁移到新的API，我们很容易解决了这些问题。例如:</p><p id="30b2" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated"><em class="lz">旧代码</em></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="6f6d" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated"><em class="lz">迁移代码</em></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="024d" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">如果您仍然在任务中使用项目实例，请检查是否有替代API。对于它们中的大多数，应该有一个兼容的API，并且移植应该是简单的。</p><p id="1025" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">另一个要点是避免一创建任务就创建不可序列化或昂贵的对象；相反，只有在任务操作需要时才创建它们。例如，在下面的示例中，我们不必强制处理程序类型可序列化，因为我们只在需要时才创建它:</p><p id="afec" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated"><em class="lz">旧代码</em></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="f52f" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated"><em class="lz">迁移代码</em></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="5990" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">创作任务时，确保任务输入正确反映了任务在执行过程中需要的一切。避免访问环境对象或从<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" rel="noopener ugc nofollow" target="_blank">Project</a></code>实例可以到达的任何东西。例如，如果你的插件创建了一个配置，把它作为<code class="du kn ko kp kq b"><a class="ae km" href="https://docs.gradle.org/current/javadoc/org/gradle/api/file/FileCollection.html" rel="noopener ugc nofollow" target="_blank">FileCollection</a></code>传递给任务。如果需要构建目录位置，请将其记录在任务属性中:</p><p id="9ef5" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated"><em class="lz">旧代码</em></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="6f53" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated"><em class="lz">迁移代码</em></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="809a" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">Android Gradle插件曾经依赖的一个常见模式是在第一次使用时初始化某个对象，将其存储在一个静态字段中，并在构建完成后使用构建侦听器来清理状态。如前所述，<a class="ae km" href="https://docs.gradle.org/current/userguide/build_services.html" rel="noopener ugc nofollow" target="_blank">共享构建服务</a>应该用于这个用例。关于如何使用它，请参见下面的示例:</p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="6722" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">最后一条建议是，在实现定制的可序列化类型时，要小心序列化什么。确保不要序列化派生的属性，并使这些属性成为瞬态属性或使用函数。这是必要的，否则在缓存的运行中，你会得到一个<code class="du kn ko kp kq b">allLines</code>属性的旧值。</p><p id="8fb0" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated"><em class="lz">旧代码</em></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="f2d8" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated"><em class="lz">迁移代码</em></p><figure class="ks kt ku kv fd hj"><div class="bz dy l di"><div class="lx ly l"/></div></figure></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="f8a6" class="pw-post-body-paragraph jo jp hs jq b jr kw jt ju jv kx jx jy jz ky kb kc kd kz kf kg kh la kj kk kl ha bi translated">配置缓存目前还处于试验阶段，我们希望您能尝试一下并给我们提供反馈。请在Android Studio <a class="ae km" href="https://developer.android.com/studio/report-bugs" rel="noopener ugc nofollow" target="_blank">问题跟踪器</a>或Gradle <a class="ae km" href="https://github.com/gradle/gradle/issues" rel="noopener ugc nofollow" target="_blank">问题跟踪器</a>上报告任何问题。编码快乐！</p></div></div>    
</body>
</html>