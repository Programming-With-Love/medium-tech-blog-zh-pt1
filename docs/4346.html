<html>
<head>
<title>Advanced FP for the Enterprise Bee: Shiny Things</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向企业蜜蜂的高级FP:闪亮的东西</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-shiny-things-770ae9c27472?source=collection_archive---------2-----------------------#2021-02-26">https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-shiny-things-770ae9c27472?source=collection_archive---------2-----------------------#2021-02-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/ee5f77ff9beb92f20abc197e633c0056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/0*2D7qyemVVsa0Aldp.jpg"/></div><figcaption class="il im et er es in io bd b be z dx">Vendor at a Honey Festival in France</figcaption></figure><h1 id="a278" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="5ed9" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这是我们八部分系列的最后一篇文章。我们已经为好奇而又注重实践的Kotlin开发人员探索了高级函数式编程。我希望你觉得这是值得的。</p><p id="bf7c" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">以下是迄今为止所有内容的回顾:</p><ul class=""><li id="2efb" class="kq kr hh jp b jq kl ju km jy ks kc kt kg ku kk kv kw kx ky bi translated"><a class="ae kz" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-traverse-b5e4e8b7b8e4">第一部分</a>:横移作业</li><li id="2850" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated"><a class="ae kz" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-applicatives-be76e4b6803c">第二部分</a>:使用应用程序</li><li id="0ee3" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated"><a class="ae kz" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-higher-kinded-types-c6742e24527">第3部分</a>:更高级的种类</li><li id="67d9" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated"><a class="ae kz" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-kleisli-1d0de0fa82d9">第4部分</a>:克莱斯利型</li><li id="844e" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated"><a class="ae kz" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-typeclasses-2addc232ae23">第5部分</a>:使用类型类</li><li id="08f0" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated"><a class="ae kz" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-optics-2ccc444d409b">第6部分</a>:使用光学器件</li><li id="18f6" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated"><a class="ae kz" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-state-4f8fd2d8098b">第7部分</a>:状态类型</li></ul><p id="2a22" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在这最后一篇文章中，我想:</p><ol class=""><li id="8b48" class="kq kr hh jp b jq kl ju km jy ks kc kt kg ku kk lf kw kx ky bi translated">向你展示一些额外的FP操作</li><li id="f1d4" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk lf kw kx ky bi translated">对箭头1中的新特性提供一些见解</li><li id="6f7f" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk lf kw kx ky bi translated">提供一些我认为有用的资源的链接</li></ol><h1 id="428b" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">第1部分:来自Arrow的附加操作</h1><p id="052d" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们已经看到Arrow可以大大简化您的日常编码工作。但是我们的调查远非全面。以下是我发现在日常开发中有用的一些附加操作。</p><h2 id="d569" class="lg iq hh bd ir lh li lj iv lk ll lm iz jy ln lo jd kc lp lq jh kg lr ls jl lt bi translated">开始吧</h2><p id="e08c" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们的大多数例子都是从类似下面的代码开始的。我们迭代1到6之间的整数范围，并将它们映射到右<em class="lu">或左<em class="lu">的</em></em></p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><pre class="lv lw lx ly fd mb mc md me aw mf bi"><span id="240b" class="lg iq hh mc b fi mg mh l mi mj">[Left(1), Right(2), Left(3), Right(4), Left(5), Right(6)]</span></pre><h2 id="875a" class="lg iq hh bd ir lh li lj iv lk ll lm iz jy ln lo jd kc lp lq jh kg lr ls jl lt bi translated">从地图到Bimap</h2><p id="2600" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们已经看到<em class="lu">地图</em>与<em class="lu">或者</em>都是右倾的。左侧的<em class="lu">内的值被忽略。但是如果你想对左</em>和右都应用变换，那么你可以使用<code class="du mk ml mm mc b">bimap</code>。</p><p id="e9ac" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在下面的例子中，我们将奇数(包含在左<em class="lu">和右</em>中)乘以10，将偶数(包含在右<em class="lu">和100:</em></p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><pre class="lv lw lx ly fd mb mc md me aw mf bi"><span id="4d76" class="lg iq hh mc b fi mg mh l mi mj">[Left(10), Right(200), Left(30), Right(400), Left(50), Right(600)]</span></pre><h2 id="43ed" class="lg iq hh bd ir lh li lj iv lk ll lm iz jy ln lo jd kc lp lq jh kg lr ls jl lt bi translated">折叠再探</h2><p id="be6a" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在以前的文章中，我们使用<code class="du mk ml mm mc b">fold</code>作为终端操作。我们提供了两个副作用函数，以便处理<em class="lu">左</em>和<em class="lu">右</em>结果。这可能像<code class="du mk ml mm mc b">result.fold(::println, ::println)</code>一样简单</p><p id="863f" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">然而，这并不是<em class="lu">折叠</em>的唯一可能用途。与<code class="du mk ml mm mc b">bimap</code>不同的是，<em class="lu"> fold </em>操作返回一个值而不是一个容器。因此，将<code class="du mk ml mm mc b">bimap</code>应用于<em class="lu">或者</em>会产生另一个<em class="lu">或者</em>，而应用<code class="du mk ml mm mc b">fold</code>会产生一个值。</p><p id="b19f" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">下面是同样的例子，改写成使用<code class="du mk ml mm mc b">fold</code>。如您所见，输出是一个数字列表，而不是一个<em class="lu">列表</em></p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><pre class="lv lw lx ly fd mb mc md me aw mf bi"><span id="b195" class="lg iq hh mc b fi mg mh l mi mj">[10, 200, 30, 400, 50, 600]</span></pre><p id="0152" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">Fold有许多有趣的变化。例如<code class="du mk ml mm mc b">bifoldLeft</code>允许我们在函数中注入一个附加值。</p><p id="69d0" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">让我们用十作为我们的附加值。我们将这个值加到奇数上，同时乘以偶数:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><pre class="lv lw lx ly fd mb mc md me aw mf bi"><span id="c211" class="lg iq hh mc b fi mg mh l mi mj">[11, 20, 13, 40, 15, 60]</span></pre><h2 id="6846" class="lg iq hh bd ir lh li lj iv lk ll lm iz jy ln lo jd kc lp lq jh kg lr ls jl lt bi translated">交换价值</h2><p id="09f9" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在有两个结果的容器中，可以通过<code class="du mk ml mm mc b">swap</code>操作在选项之间进行切换。在这种情况下，所有的<em class="lu">右</em>项都变成了<em class="lu">左、</em>项，反之亦然:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><pre class="lv lw lx ly fd mb mc md me aw mf bi"><span id="df52" class="lg iq hh mc b fi mg mh l mi mj">[Left(1), Right(2), Left(3), Right(4), Left(5), Right(6)]<br/>[Right(1), Left(2), Right(3), Left(4), Right(5), Left(6)]</span></pre><h2 id="ea62" class="lg iq hh bd ir lh li lj iv lk ll lm iz jy ln lo jd kc lp lq jh kg lr ls jl lt bi translated">重温半群</h2><p id="5734" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在以前的文章中，我们看到一个<em class="lu">半群</em>是一个具有<code class="du mk ml mm mc b">combine</code>方法的容器。大多数函数类型是<em class="lu">半群</em>，包括<em class="lu">或者</em>。</p><p id="b05a" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><code class="du mk ml mm mc b">maybeCombine</code>方法组合两个<em class="lu">或者</em>实例，假设它们都是<em class="lu">左</em>或者<em class="lu">右</em>。这里我们将向列表中的每个<em class="lu">右</em>实例添加100，但是<em class="lu">左</em>实例将不受影响:</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><pre class="lv lw lx ly fd mb mc md me aw mf bi"><span id="783f" class="lg iq hh mc b fi mg mh l mi mj">[Left(1), Right(102), Left(3), Right(104), Left(5), Right(106)]</span></pre><h2 id="7129" class="lg iq hh bd ir lh li lj iv lk ll lm iz jy ln lo jd kc lp lq jh kg lr ls jl lt bi translated">重温应用程序</h2><p id="a786" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们系列中的<a class="ae kz" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-applicatives-be76e4b6803c">第二篇文章详细研究了<em class="lu">应用程序</em>。列表算作<em class="lu">应用程序</em>，因此提供一个<code class="du mk ml mm mc b">ap</code>操作。</a></p><p id="5445" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">如果您提供一个包含单个函数的列表，那么该函数将应用于原始列表中的每一项，如下面的<em class="lu"> result1 </em>所示。如果您提供多个函数，那么每个函数都与每个项目相关联，如<em class="lu"> result2: </em>所示</p><figure class="lv lw lx ly fd ii"><div class="bz dy l di"><div class="lz ma l"/></div></figure><pre class="lv lw lx ly fd mb mc md me aw mf bi"><span id="5486" class="lg iq hh mc b fi mg mh l mi mj">[10, 20, 30, 40]<br/>[100, 1000, 200, 2000, 300, 3000, 400, 4000]</span></pre><h1 id="c0f8" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">第2部分:箭头1中的新特性</h1><p id="1a5e" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">当Arrow第一次被创建时，它是一个非常志愿者驱动的努力，看看一个类似于<a class="ae kz" href="https://typelevel.org/cats/" rel="noopener ugc nofollow" target="_blank">猫</a>或Haskell base库的库是否可以在Kotlin中工作。令人高兴的是，答案是肯定的！但是必须做一些调整，因为更高级的类型和类型类不是Kotlin固有的。详见本系列<a class="ae kz" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-higher-kinded-types-c6742e24527">第三篇</a>和<a class="ae kz" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-typeclasses-2addc232ae23">第五篇</a>。</p><p id="52f4" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">随着Arrow接近重要的1.0版本，焦点已经转移到最大化它的可用性和充分利用Kotlin独有的语言特性。这导致了一些重大变化。最重要的是，在可预见的未来，更高级的类型将被放弃，直到Kotlin IDEA插件意识到社区Kotlin编译器插件。</p><p id="57db" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">正如我们已经看到的，HKT要求呼唤<code class="du mk ml mm mc b">fix</code>，这是学习的一个障碍。避免这些调用的唯一方法是通过编译器插件和适当的IDEA支持。这可以在需要的地方插入下导管，而不需要任何人工干预。不幸的是，虽然Kotlin 1.4为所有编译器提供了一个通用的后端，但是编译器插件的标准API还没有出现。</p><p id="4d3c" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">好消息是已经有了更好的选择。当你用<code class="du mk ml mm mc b">suspend</code>声明一个函数时，编译器实现一个基于延续的状态机来处理函数的暂停和恢复。我的同事Eamonn和我去年写了一篇关于这个的文章。</p><p id="cebc" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这种机制不仅可用于协同例程的并发。研究表明，悬浮函数可以用来实现我们在本系列中讨论的所有类型的计算模块。所以<em class="lu">或者</em>，<em class="lu">有效</em>，<em class="lu">状态</em>等等，相关的效果操作符可以实现为挂起函数，不需要HKT或者类型类。</p><p id="004f" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这次重新设计的重点是悬浮，不仅适用于Arrow Core，还适用于Optics和Fx，它们现在提供了与悬浮一起使用的最流行的FP操作符的内嵌版本。随着这一变化，<em class="lu"> IO </em>类型将被弃用，因为暂停功能涵盖了<em class="lu"> IO </em>的所有用例，而没有分配和ADT成本。</p><p id="7a25" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">你可以在箭头网站上深入了解这一重新设计。由于减少了分配与Typeclasses、ADT和滥用堆相关的实例的需要，使这些模式成为堆栈安全的，所以它提供了性能上的实质性改进。核心类型也将变得更容易使用——例如，当调用<code class="du mk ml mm mc b">traverse</code>时，你将不再需要传入相关的<em class="lu">可应用的</em>实例。</p><p id="eeaf" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">所有这些新功能将在两个即将发布的版本中实现。箭头0.12(已经在预览版中可用)将反对HKT的和类型类，而箭头0.13将完全删除它们。它们将在未来几周内同时问世。</p><p id="0b66" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">不使用kinds或者不介意中断更改的用户可以直接使用0.13。这一版本将构成Arrow 1.0的基础，预计将于今年夏天发布。它将得到长期支持，并更容易被业界采用。</p><h1 id="46db" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">第3部分:附加资源</h1><p id="aa4a" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这里有一些我特别推荐的书籍、论文和讲座。我根据作者对FP知识的掌握程度，按升序列出了它们:</p><ul class=""><li id="2248" class="kq kr hh jp b jq kl ju km jy ks kc kt kg ku kk kv kw kx ky bi translated">弗里斯比教授的函数式编程指南已经足够了。一本优秀的FP入门书，免费提供JavaScript示例。</li><li id="a610" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated">Kevlin Henney的精彩演讲，讲述了Lambdas和物体是如何相互对立的。事实上，它们是重叠和可替代的。</li><li id="be71" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated">罗纳·比雅纳松(<a class="ae kz" href="https://www.amazon.co.uk/Functional-Programming-Scala-Paul-Chiusano/dp/1617290653" rel="noopener ugc nofollow" target="_blank">‘红色Scala book’</a>的作者)关于纯函数式编码如何实现大型系统组合的<a class="ae kz" href="https://skillsmatter.com/skillscasts/10746-keynote-composing-programs" rel="noopener ugc nofollow" target="_blank">主题演讲。</a></li><li id="1e2c" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated">即将推出的<a class="ae kz" href="http://Functional Programming in Kotlin" rel="noopener ugc nofollow" target="_blank"> Kotlin / Arrow版</a>上面提到的那本书。</li><li id="c89e" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated">Eric Torreborre关于Haskell的特性是如何逐渐被主流语言采用的演讲。</li><li id="1578" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated">Scott Wlaschin讲述了如何使用<a class="ae kz" href="https://www.youtube.com/watch?v=srQt1NAHYC0" rel="noopener ugc nofollow" target="_blank">功能模式来促进面向铁路的编程</a>。</li><li id="a7f2" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated">劳尔·拉贾·马丁内斯在科特林孔夫对《箭头》的介绍。</li><li id="808c" class="kq kr hh jp b jq la ju lb jy lc kc ld kg le kk kv kw kx ky bi translated"><a class="ae kz" href="https://www.youtube.com/watch?v=V10hzjgoklA" rel="noopener ugc nofollow" target="_blank">菲利普·瓦德勒介绍范畴理论</a>，以及与之相关的情况。</li></ul><h1 id="bbe9" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论</h1><p id="d596" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">就是这样，伙计们！我真的希望这个系列对你有用，并且帮助你增强了对FP概念的了解。反馈总是受欢迎的——无论是在这里，<a class="ae kz" href="https://twitter.com/GarthGilmour" rel="noopener ugc nofollow" target="_blank">在Twitter上</a>和<a class="ae kz" href="https://instil.co/enquiries/" rel="noopener ugc nofollow" target="_blank">在工作中</a>。编码快乐！</p><h1 id="e683" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">谢谢</h1><p id="a5a2" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">感谢<a class="ae kz" href="https://twitter.com/rickityg" rel="noopener ugc nofollow" target="_blank"> Richard Gibson </a>和<a class="ae kz" href="https://instil.co/training/team/" rel="noopener ugc nofollow" target="_blank"> Instil培训团队</a>对这一系列文章的评论、评论和鼓励。在此，我要特别感谢来自47度的Raul Raja，他和我以及Richard一起讨论了他们对Arrow 1的看法。所有的错误当然是我自己的。</p></div></div>    
</body>
</html>