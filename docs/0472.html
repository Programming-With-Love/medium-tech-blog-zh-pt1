<html>
<head>
<title>Exceptions in coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协程中的异常</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c?source=collection_archive---------1-----------------------#2020-03-11">https://medium.com/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c?source=collection_archive---------1-----------------------#2020-03-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/4d08893442e6d6cbd909ec38bf974783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YcXLfA7ah4xelW1O"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="89da" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">协程中的取消和异常(第3部分)——必须全部捕获！</h2></div><p id="0ee2" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们这些开发者，通常会花很多时间打磨我们app的快乐路径。然而，同样重要的是，当事情不尽如人意时，提供适当的用户体验。一方面，看到应用程序崩溃对用户来说是糟糕的体验；另一方面，当一个动作没有成功时，向用户显示正确的信息是必不可少的。</p><p id="113b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">正确处理异常对用户如何看待您的应用程序有着巨大的影响。在本文中，我们将解释异常是如何在协程中传播的，以及如何始终处于控制之中，包括处理它们的不同方式。</p><p id="7f6f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你喜欢视频，可以看看我和弗洛里纳·芒特内斯库在2019年科特林康夫的演讲:</p><figure class="kk kl km kn fd hj"><div class="bz dy l di"><div class="ko kp l"/></div></figure><blockquote class="kq kr ks"><p id="9480" class="jm jn kt jo b jp jq iy jr js jt jb ju ku jw jx jy kv ka kb kc kw ke kf kg kh ha bi translated">⚠️为了毫无问题地理解文章的其余部分，需要阅读和理解系列文章的第1部分。</p></blockquote><div class="hg hh ez fb hi kx"><a rel="noopener follow" target="_blank" href="/androiddevelopers/coroutines-first-things-first-e6187bf3bb21"><div class="ky ab dw"><div class="kz ab la cl cj lb"><h2 class="bd hy fi z dy lc ea eb ld ed ef hw bi translated">协程:先做最重要的事情</h2><div class="le l"><h3 class="bd b fi z dy lc ea eb ld ed ef dx translated">协同程序中的取消和异常(第一部分)</h3></div><div class="lf l"><p class="bd b fp z dy lc ea eb ld ed ef dx translated">medium.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll ho kx"/></div></div></a></div><h1 id="3a0b" class="lm ln hx bd lo lp lq lr ls lt lu lv lw jd lx je ly jg lz jh ma jj mb jk mc md bi translated">一个协程突然失效！现在怎么办？😱</h1><p id="1c89" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">当一个协程因异常而失败时，它会将所述异常向上传播到它的父进程！然后，父节点将1)取消其余的子节点，2)取消自身，3)将异常向上传播到其父节点。</p><p id="249b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">异常将到达层级的根，并且所有由<code class="du mj mk ml mm b">CoroutineScope</code>启动的协程也将被取消。</p><figure class="kk kl km kn fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mn"><img src="../Images/b7f51912e581df41e585cf0a71fcedbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UcEpsF2X-ihztU2Z"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mo">An exception in a coroutine will be propagated throughout the coroutines hierarchy</em></figcaption></figure><p id="e050" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">虽然在某些情况下传播异常是有意义的，但在其他情况下这是不可取的。想象一个处理用户交互的UI相关的<code class="du mj mk ml mm b">CoroutineScope</code>。如果子协程抛出异常，UI范围将被取消，整个UI组件将变得无响应，因为被取消的范围不能启动更多的协程。</p><p id="edd4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你不想要那种行为呢？或者，您可以在创建这些协程的<code class="du mj mk ml mm b">CoroutineScope</code>的<code class="du mj mk ml mm b">CoroutineContext</code>中使用<code class="du mj mk ml mm b">Job</code>的不同实现，即<code class="du mj mk ml mm b">SupervisorJob</code>。</p><h2 id="54fc" class="mp ln hx bd lo mq mr ms ls mt mu mv lw jv mw mx ly jz my mz ma kd na nb mc nc bi translated">拯救者的监督工作</h2><p id="50ba" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">有了<code class="du mj mk ml mm b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-supervisor-job.html" rel="noopener ugc nofollow" target="_blank"><strong class="jo hy">SupervisorJob</strong></a></code>，一个孩子的失败不影响其他孩子。一个<code class="du mj mk ml mm b">SupervisorJob</code>不会取消自己或者它的其余子节点。而且，<code class="du mj mk ml mm b">SupervisorJob</code>也不会传播异常，会让子协程来处理。</p><p id="11ae" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">您可以创建一个类似于<code class="du mj mk ml mm b">val uiScope = CoroutineScope(SupervisorJob())</code>的<code class="du mj mk ml mm b">CoroutineScope</code>,以便在协程失败时不传播取消，如下图所示:</p><figure class="kk kl km kn fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/1196279729e79205b6aba8e5da6697e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mrf17HLbWQPfTt1I"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mo">A SupervisorJob won’t cancel itself or the rest of its children</em></figcaption></figure><p id="0593" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果异常没有被处理并且<code class="du mj mk ml mm b">CoroutineContext</code>没有<code class="du mj mk ml mm b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html" rel="noopener ugc nofollow" target="_blank">CoroutineExceptionHandler</a></code>(我们将在后面看到)，它将到达默认线程的<code class="du mj mk ml mm b">ExceptionHandler</code>。在JVM中，异常将被记录到控制台；在安卓系统中，不管发生在哪个调度程序上，它都会让你的应用崩溃。</p><blockquote class="nd"><p id="221e" class="ne nf hx bd ng nh ni nj nk nl nm kh dx translated">💥不管使用哪种作业，总是会抛出未捕获的异常</p></blockquote><p id="5b3d" class="pw-post-body-paragraph jm jn hx jo b jp nn iy jr js no jb ju jv np jx jy jz nq kb kc kd nr kf kg kh ha bi translated">同样的行为也适用于范围构建器<code class="du mj mk ml mm b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html" rel="noopener ugc nofollow" target="_blank"><strong class="jo hy">coroutineScope</strong></a></code>和<code class="du mj mk ml mm b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html" rel="noopener ugc nofollow" target="_blank"><strong class="jo hy">supervisorScope</strong></a></code>。这将创建一个子作用域(相应地以一个<code class="du mj mk ml mm b">Job</code>或一个<code class="du mj mk ml mm b">SupervisorJob</code>作为父作用域),您可以用它对协程进行逻辑分组(例如，如果您想进行并行计算，或者您想让它们相互影响或不相互影响)。</p><p id="5e58" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy"> <em class="kt">警告</em> </strong>:一个<code class="du mj mk ml mm b">SupervisorJob</code> <strong class="jo hy">只有</strong>作为作用域的一部分时才起作用:使用<code class="du mj mk ml mm b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html" rel="noopener ugc nofollow" target="_blank">supervisorScope</a></code>或<code class="du mj mk ml mm b">CoroutineScope(SupervisorJob())</code>创建。</p><h2 id="e51b" class="mp ln hx bd lo mq mr ms ls mt mu mv lw jv mw mx ly jz my mz ma kd na nb mc nc bi translated">工作还是主管工作？🤔</h2><p id="8758" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">什么时候应该使用<code class="du mj mk ml mm b">Job</code>或<code class="du mj mk ml mm b">SupervisorJob</code>？当您不想取消父级和同级时，使用<code class="du mj mk ml mm b">SupervisorJob</code>或<code class="du mj mk ml mm b">supervisorScope</code>。</p><p id="efa1" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">一些例子:</p><pre class="kk kl km kn fd ns mm nt nu aw nv bi"><span id="9287" class="mp ln hx mm b fi nw nx l ny nz">// Scope handling coroutines for a particular layer of my app<br/>val scope = CoroutineScope(<strong class="mm hy">SupervisorJob()</strong>)</span><span id="d5f0" class="mp ln hx mm b fi oa nx l ny nz">scope.launch {<br/>    // Child 1<br/>}</span><span id="f510" class="mp ln hx mm b fi oa nx l ny nz">scope.launch {<br/>    // Child 2<br/>}</span></pre><p id="4384" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这种情况下，如果<code class="du mj mk ml mm b">child#1</code>失败，<em class="kt"/>范围和<code class="du mj mk ml mm b">child#2</code>都不会被取消。</p><p id="f058" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">另一个例子:</p><pre class="kk kl km kn fd ns mm nt nu aw nv bi"><span id="32bf" class="mp ln hx mm b fi nw nx l ny nz">// Scope handling coroutines for a particular layer of my app<br/>val scope = CoroutineScope(<strong class="mm hy">Job()</strong>)</span><span id="bd16" class="mp ln hx mm b fi oa nx l ny nz">scope.launch {<br/>    <strong class="mm hy">supervisorScope</strong> {<br/>        launch {<br/>            // Child 1<br/>        }<br/>        launch {<br/>            // Child 2<br/>        }<br/>    }<br/>}</span></pre><p id="69bd" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这种情况下，由于<code class="du mj mk ml mm b">supervisorScope</code>创建了一个带有<code class="du mj mk ml mm b">SupervisorJob</code>的子作用域，如果<code class="du mj mk ml mm b">child#1</code>失败，<code class="du mj mk ml mm b">child#2</code>将被取消<em class="kt">而不是</em>。相反，如果在实现中使用了<code class="du mj mk ml mm b">coroutineScope</code>，失败将会传播开来，最终也会取消作用域。</p><h2 id="ebff" class="mp ln hx bd lo mq mr ms ls mt mu mv lw jv mw mx ly jz my mz ma kd na nb mc nc bi translated">小心测验！谁是我的父母？🎯</h2><p id="ece5" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">给出下面的代码片段，你能识别出<code class="du mj mk ml mm b">Job</code> <code class="du mj mk ml mm b">child#1</code>是哪种类型的父节点吗？</p><pre class="kk kl km kn fd ns mm nt nu aw nv bi"><span id="b264" class="mp ln hx mm b fi nw nx l ny nz">val scope = CoroutineScope(<strong class="mm hy">Job()</strong>)</span><span id="636d" class="mp ln hx mm b fi oa nx l ny nz">scope.launch(<strong class="mm hy">SupervisorJob()</strong>) {<br/>    // new coroutine -&gt; can suspend<br/>   launch {<br/>        // Child 1<br/>    }<br/>    launch {<br/>        // Child 2<br/>    }<br/>}</span></pre><p id="32c9" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><code class="du mj mk ml mm b">child#1</code>的父作业类型为<code class="du mj mk ml mm b">Job</code>！希望你没弄错！即使在第一印象中，您可能认为它可以是一个<code class="du mj mk ml mm b">SupervisorJob</code>，但这并不是因为一个新的协程总是被赋予一个新的<code class="du mj mk ml mm b">Job()</code>，在这种情况下它会覆盖<code class="du mj mk ml mm b">SupervisorJob</code>。<code class="du mj mk ml mm b">SupervisorJob</code>是用<code class="du mj mk ml mm b">scope.launch</code>创建的协程的父级；所以从字面上看，<code class="du mj mk ml mm b">SupervisorJob</code>在这段代码中什么也不做！</p><figure class="kk kl km kn fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/10aaa0c60b22af09b4394ee20f005b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CB9c0_BAhlSJpC7w"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx"><em class="mo">The parent of child#1 and child#2 is of type Job, not SupervisorJob</em></figcaption></figure><p id="43bf" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因此，如果<code class="du mj mk ml mm b">child#1</code>或<code class="du mj mk ml mm b">child#2</code>失败，该失败将达到范围，该范围开始的所有工作将被取消。</p><p id="0968" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">请记住，当<code class="du mj mk ml mm b">SupervisorJob</code> <strong class="jo hy">是作用域的一部分时，只有</strong>才能像描述的那样工作:要么使用<code class="du mj mk ml mm b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html" rel="noopener ugc nofollow" target="_blank">supervisorScope</a></code>创建，要么使用<code class="du mj mk ml mm b">CoroutineScope(SupervisorJob())</code>创建。将一个<code class="du mj mk ml mm b">SupervisorJob</code>作为协程构建器的参数传递将不会达到您想要的取消效果。</p><p id="d2b4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">关于异常，如果任何孩子抛出异常，那么<code class="du mj mk ml mm b">SupervisorJob</code>不会在层次结构中向上传播异常，而是让它的协程处理它。</p><h2 id="96e3" class="mp ln hx bd lo mq mr ms ls mt mu mv lw jv mw mx ly jz my mz ma kd na nb mc nc bi translated">在后台</h2><p id="afc2" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">如果你想知道<code class="du mj mk ml mm b">Job</code>是如何工作的，看看<code class="du mj mk ml mm b">JobSupport.kt</code>文件中函数<code class="du mj mk ml mm b"><a class="ae hu" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/JobSupport.kt#L645" rel="noopener ugc nofollow" target="_blank">childCancelled</a></code>和<a class="ae hu" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/JobSupport.kt#L326" rel="noopener ugc nofollow" target="_blank">notif</a><code class="du mj mk ml mm b"><a class="ae hu" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/JobSupport.kt#L326" rel="noopener ugc nofollow" target="_blank">y</a></code><a class="ae hu" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/JobSupport.kt#L326" rel="noopener ugc nofollow" target="_blank">canceling</a>的实现。</p><p id="94fc" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在<code class="du mj mk ml mm b">SupervisorJob</code>实现中，<code class="du mj mk ml mm b"><a class="ae hu" href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/kotlinx-coroutines-core/common/src/Supervisor.kt#L64" rel="noopener ugc nofollow" target="_blank">childCancelled</a></code>方法只返回<code class="du mj mk ml mm b">false</code>，这意味着它不传播取消，但也不处理异常。</p><h1 id="a962" class="lm ln hx bd lo lp lq lr ls lt lu lv lw jd lx je ly jg lz jh ma jj mb jk mc md bi translated">处理异常👩‍🚒</h1><p id="2821" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">协程使用常规的Kotlin语法来处理异常:<code class="du mj mk ml mm b">try/catch</code>或内置的助手函数，如<code class="du mj mk ml mm b"><a class="ae hu" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run-catching.html" rel="noopener ugc nofollow" target="_blank">runCatching</a></code>(在内部使用<code class="du mj mk ml mm b">try/catch</code>)。</p><p id="a5df" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们之前说过<strong class="jo hy">未被捕获的异常总是会被抛出</strong>。然而，不同的协程构建器以不同的方式处理异常。</p><h2 id="59db" class="mp ln hx bd lo mq mr ms ls mt mu mv lw jv mw mx ly jz my mz ma kd na nb mc nc bi translated">发动</h2><p id="d8a3" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">有了launch，<strong class="jo hy">异常一发生就会被抛出</strong>。因此，您可以将能够抛出异常的代码包装在一个<code class="du mj mk ml mm b">try/catch</code>中，如下例所示:</p><pre class="kk kl km kn fd ns mm nt nu aw nv bi"><span id="1ee7" class="mp ln hx mm b fi nw nx l ny nz">scope.<strong class="mm hy">launch</strong> {<br/>    try {<br/>        codeThatCanThrowExceptions()<br/>    } catch(e: Exception) {<br/>        // Handle exception<br/>    }<br/>}</span></pre><blockquote class="nd"><p id="260f" class="ne nf hx bd ng nh ob oc od oe of kh dx translated">有了launch，异常一发生就会被抛出</p></blockquote><h2 id="bdc3" class="mp ln hx bd lo mq og ms ls mt oh mv lw jv oi mx ly jz oj mz ma kd ok nb mc nc bi translated">异步ˌ非同步(asynchronous)</h2><p id="e288" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated">当<code class="du mj mk ml mm b">async</code>被用作根协程(作为<code class="du mj mk ml mm b">CoroutineScope</code>实例或<code class="du mj mk ml mm b">supervisorScope</code>的直接子代的协程)时，<strong class="jo hy">异常不会自动抛出，而是在调用</strong> <code class="du mj mk ml mm b"><strong class="jo hy">.await()</strong></code>时抛出。</p><p id="3e35" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了在<code class="du mj mk ml mm b">async</code>是根协程时处理抛出的异常，可以将<code class="du mj mk ml mm b">.await()</code>调用包装在<code class="du mj mk ml mm b">try/catch</code>中:</p><pre class="kk kl km kn fd ns mm nt nu aw nv bi"><span id="d2e8" class="mp ln hx mm b fi nw nx l ny nz"><strong class="mm hy">supervisorScope</strong> {<br/>    val deferred = <strong class="mm hy">async</strong> {<br/>        codeThatCanThrowExceptions()<br/>    }</span><span id="f1ac" class="mp ln hx mm b fi oa nx l ny nz">    <strong class="mm hy">try</strong> {<br/>        deferred.await()<br/>    } <strong class="mm hy">catch</strong>(e: Exception) {<br/>        // Handle exception thrown in async<br/>    }<br/>}</span></pre><p id="d040" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这种情况下，注意调用<code class="du mj mk ml mm b">async</code>将<em class="kt">永远不会</em>抛出异常，这就是为什么没有必要包装它。<code class="du mj mk ml mm b">await</code>将抛出发生在<code class="du mj mk ml mm b">async</code>协程内部的异常。</p><blockquote class="nd"><p id="5958" class="ne nf hx bd ng nh ni nj nk nl nm kh dx translated">当<code class="du mj mk ml mm b">async</code>被用作根协程时，当你调用时会抛出异常。等待</p></blockquote><p id="e127" class="pw-post-body-paragraph jm jn hx jo b jp nn iy jr js no jb ju jv np jx jy jz nq kb kc kd nr kf kg kh ha bi translated">另外，请注意，我们使用了一个<code class="du mj mk ml mm b">supervisorScope</code>来调用<code class="du mj mk ml mm b">async</code>和<code class="du mj mk ml mm b">await</code>。正如我们之前所说，a <code class="du mj mk ml mm b">SupervisorJob</code>让协程处理异常；与<code class="du mj mk ml mm b">Job</code>相反，它会自动在层次结构中向上传播，因此不会调用<code class="du mj mk ml mm b">catch</code>块:</p><pre class="kk kl km kn fd ns mm nt nu aw nv bi"><span id="89bb" class="mp ln hx mm b fi nw nx l ny nz"><strong class="mm hy">coroutineScope</strong> {<br/>    try {<br/>        val deferred = <strong class="mm hy">async</strong> {<br/>            codeThatCanThrowExceptions()<br/>        }<br/>        deferred.await()<br/>    } catch(e: Exception) {<br/>        // <strong class="mm hy">Exception thrown in async WILL NOT be caught here <br/>        </strong>//<strong class="mm hy"> but propagated up to the scope<br/>    </strong>}<br/>}</span></pre><p id="6fdc" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">此外，不管协程生成器如何，由其他协程创建的协程中发生的异常将总是被传播。例如:</p><pre class="kk kl km kn fd ns mm nt nu aw nv bi"><span id="2f70" class="mp ln hx mm b fi nw nx l ny nz">val scope = CoroutineScope(Job())</span><span id="1ea8" class="mp ln hx mm b fi oa nx l ny nz">scope.<strong class="mm hy">launch</strong> {<br/>    <strong class="mm hy">async</strong> {<br/>        // If async throws, launch throws without calling .await()<br/>    }<br/>}</span></pre><p id="d131" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这种情况下，如果<code class="du mj mk ml mm b">async</code>抛出一个异常，它会在发生时立即抛出，因为作为该作用域的直接子代的协程是<code class="du mj mk ml mm b">launch</code>。原因是<code class="du mj mk ml mm b">async</code>(在其<code class="du mj mk ml mm b">CoroutineContext</code>中有一个<code class="du mj mk ml mm b">Job</code>)会自动将异常向上传播到其父级(<code class="du mj mk ml mm b">launch</code>)，父级将抛出异常。</p><blockquote class="nd"><p id="1cfc" class="ne nf hx bd ng nh ni nj nk nl nm kh dx translated">在协同作用域构建器或其他协同程序创建的协同程序中抛出的⚠️异常不会在try/catch中被捕获！</p></blockquote><p id="4c78" class="pw-post-body-paragraph jm jn hx jo b jp nn iy jr js no jb ju jv np jx jy jz nq kb kc kd nr kf kg kh ha bi translated">在<code class="du mj mk ml mm b">SupervisorJob</code>部分，我们提到了<code class="du mj mk ml mm b">CoroutineExceptionHandler</code>的存在。让我们开始吧！</p><h2 id="5788" class="mp ln hx bd lo mq mr ms ls mt mu mv lw jv mw mx ly jz my mz ma kd na nb mc nc bi translated">CoroutineExceptionHandler</h2><p id="92ea" class="pw-post-body-paragraph jm jn hx jo b jp me iy jr js mf jb ju jv mg jx jy jz mh kb kc kd mi kf kg kh ha bi translated"><code class="du mj mk ml mm b">CoroutineExceptionHandler</code>是<code class="du mj mk ml mm b">CoroutineContext</code>的可选元素，允许你<strong class="jo hy">处理未捕获的异常</strong>。</p><p id="9a81" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">下面是如何定义一个<code class="du mj mk ml mm b">CoroutineExceptionHandler</code>，无论何时捕获到一个异常，您都有关于发生异常的<code class="du mj mk ml mm b">CoroutineContext</code>和异常本身的信息:</p><pre class="kk kl km kn fd ns mm nt nu aw nv bi"><span id="ac8b" class="mp ln hx mm b fi nw nx l ny nz">val <strong class="mm hy">handler</strong> = CoroutineExceptionHandler {<br/>    context, exception -&gt; println("Caught $exception")<br/>}</span></pre><p id="1fbe" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果满足以下要求，将会捕获异常:</p><ul class=""><li id="7b3b" class="ol om hx jo b jp jq js jt jv on jz oo kd op kh oq or os ot bi translated"><strong class="jo hy">当</strong>⏰:异常由一个协程抛出，该协程使<em class="kt">自动抛出异常</em>(适用于<code class="du mj mk ml mm b">launch</code>，不适用于<code class="du mj mk ml mm b">async</code>)。</li><li id="6496" class="ol om hx jo b jp ou js ov jv ow jz ox kd oy kh oq or os ot bi translated"><strong class="jo hy">哪里</strong>🌍:如果它在<code class="du mj mk ml mm b">CoroutineScope</code>或根协程的<code class="du mj mk ml mm b">CoroutineContext</code>(<code class="du mj mk ml mm b">CoroutineScope</code>或<code class="du mj mk ml mm b">supervisorScope</code>的直接子进程)中。</li></ul><p id="b675" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">让我们看一些使用上面定义的<code class="du mj mk ml mm b">CoroutineExceptionHandler</code>的例子。在下面的例子中，异常<em class="kt">将被处理程序</em>捕获:</p><pre class="kk kl km kn fd ns mm nt nu aw nv bi"><span id="736f" class="mp ln hx mm b fi nw nx l ny nz">val scope = CoroutineScope(Job())<br/>scope.launch(<strong class="mm hy">handler</strong>) {<br/>    launch {<br/>        throw Exception("Failed coroutine")<br/>    }<br/>}</span></pre><p id="ebbf" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在另一种情况下，处理程序安装在内部协程中，它<em class="kt">不会被</em>捕获:</p><pre class="kk kl km kn fd ns mm nt nu aw nv bi"><span id="5ea1" class="mp ln hx mm b fi nw nx l ny nz">val scope = CoroutineScope(Job())<br/>scope.launch {<br/>    launch(<strong class="mm hy">handler</strong>) {<br/>        throw Exception("Failed coroutine")<br/>    }<br/>}</span></pre><p id="f220" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">该异常没有被捕获，因为处理程序没有安装在正确的<code class="du mj mk ml mm b">CoroutineContext</code>中。一旦发生异常，内部启动会将异常向上传播到父进程，因为父进程不知道任何关于处理程序的信息，异常将被抛出。</p></div><div class="ab cl oz pa go pb" role="separator"><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe pf"/><span class="pc bw bk pd pe"/></div><div class="ha hb hc hd he"><p id="301b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在应用程序中优雅地处理异常对于获得良好的用户体验非常重要，即使事情并不像预期的那样发展。</p><p id="6890" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">当您希望避免在异常发生时传播取消时，请记住使用<code class="du mj mk ml mm b">SupervisorJob</code>，否则请使用<code class="du mj mk ml mm b">Job</code>。</p><p id="0df4" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">未捕获的异常将被传播，捕获它们以提供一个伟大的UX！</p></div></div>    
</body>
</html>