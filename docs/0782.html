<html>
<head>
<title>Pew pew! Making a Game with Compose Canvas on Wear OS 👾</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">皮尤皮尤！在Wear OS上用Compose Canvas制作游戏👾</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/pew-pew-making-a-game-with-compose-canvas-on-wear-os-9a37fa498d3?source=collection_archive---------5-----------------------#2022-12-14">https://medium.com/androiddevelopers/pew-pew-making-a-game-with-compose-canvas-on-wear-os-9a37fa498d3?source=collection_archive---------5-----------------------#2022-12-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/3fa7517a9e56bae2e2d889a21a684ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09t9AFD2cRCsI10Oyxk1wA.png"/></div></div></figure><div class=""/><p id="8f8e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">几周前，<a class="ae jn" href="https://www.linkedin.com/in/sara-hamilton-552026a5/" rel="noopener ugc nofollow" target="_blank"> Sara Hamilton </a>和我通过使用<a class="ae jn" href="https://developer.android.com/training/wearables/compose" rel="noopener ugc nofollow" target="_blank"> Compose for Wear OS </a>制作了一个Wear OS游戏，稍微偏离了我们通常感兴趣的领域。</p><p id="2626" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的目标包括:</p><ul class=""><li id="0e1a" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">使用我们现有的Jetpack Compose(在移动设备上)和Compose for Wear OS的知识</li><li id="6266" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">尝试佩戴操作系统设备特有的输入(如<a class="ae jn" href="https://www.youtube.com/watch?v=2CzWz5Ad4iM" rel="noopener ugc nofollow" target="_blank">旋转输入</a>通过旋转挡板和侧按钮)</li><li id="14a5" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">了解在Wear操作系统上玩游戏还需要考虑哪些因素</li></ul><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kc"><img src="../Images/9a6ff6303e4e5a5d9db48f9a6370a1d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6CV4vwXsacBFq6REBlmnhw.png"/></div></div></figure><p id="0bc0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们首先制作了一个克隆的Chrome Dino游戏，在这个游戏中，一只霸王龙跳过了仙人掌(除了我们的是一只跳过甜点的鸭子——这同样有意义，伙计们！)，并以一个激光发射宇宙飞船的演示结束，这样我们就有更多的空间去探索。</p><h1 id="d62b" class="kh ki hs bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">创建游戏循环</h1><p id="712f" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">这个游戏的基础是由一个无限循环驱动的，这个无限循环间歇地调用一个函数来处理游戏状态并产生UI状态。由于<code class="du lk ll lm ln b">GameEngineViewModel</code>是屏幕级别的状态持有者，这就是游戏循环(业务逻辑)将存在的地方。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lq"><img src="../Images/de780e6e10f4024ecb73e74200c5161b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDV2MQwELztGfv13S6pPHw.png"/></div></div></figure><p id="a8b3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lk ll lm ln b">update()</code>是ViewModel中的一个私有函数，在这里我们可以处理对<code class="du lk ll lm ln b">GameState</code>的更改，并使用它生成一个新的<code class="du lk ll lm ln b">UiState</code>。</p><p id="40e9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的可组合函数<code class="du lk ll lm ln b">SpaceCanvas</code>会在发出新消息时呈现<code class="du lk ll lm ln b">UiState</code>，并通知ViewModel用户输入事件。</p><h1 id="5821" class="kh ki hs bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">用合成画布呈现用户界面</h1><p id="4102" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">用Compose Canvas渲染我们的游戏世界是理想的，因为它有一个简单的坐标系，并包括用于绘图的API，这些API也可以在Wear OS上工作。</p><p id="bf59" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Canvas composable的<code class="du lk ll lm ln b"><a class="ae jn" href="https://developer.android.com/jetpack/compose/graphics/draw/overview#drawscope" rel="noopener ugc nofollow" target="_blank">onDraw</a></code> <a class="ae jn" href="https://developer.android.com/jetpack/compose/graphics/draw/overview#drawscope" rel="noopener ugc nofollow" target="_blank">参数</a>提供了对<code class="du lk ll lm ln b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope" rel="noopener ugc nofollow" target="_blank">DrawScope</a></code>的访问，允许我们单独绘制每个元素，使用扩展函数来保持我们的<code class="du lk ll lm ln b">SpaceCanvas</code> composable简短且易于管理。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="a2b4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每当<code class="du lk ll lm ln b">SpaceCanvas</code>的参数改变时，它会重新组合并绘制一个新帧。激光是用<code class="du lk ll lm ln b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope#drawCircle(androidx.compose.ui.graphics.Brush,kotlin.Float,androidx.compose.ui.geometry.Offset,kotlin.Float,androidx.compose.ui.graphics.drawscope.DrawStyle,androidx.compose.ui.graphics.ColorFilter,androidx.compose.ui.graphics.BlendMode)" rel="noopener ugc nofollow" target="_blank">drawCircle()</a></code>绘制的:</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="6bb3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">而飞船本身就画有<code class="du lk ll lm ln b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope#drawPath(androidx.compose.ui.graphics.Path,androidx.compose.ui.graphics.Color,kotlin.Float,androidx.compose.ui.graphics.drawscope.DrawStyle,androidx.compose.ui.graphics.ColorFilter,androidx.compose.ui.graphics.BlendMode)" rel="noopener ugc nofollow" target="_blank">drawPath()</a></code>。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="9185" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<code class="du lk ll lm ln b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/package-summary#(androidx.compose.ui.graphics.drawscope.DrawScope).rotate(kotlin.Float,androidx.compose.ui.geometry.Offset,kotlin.Function1)" rel="noopener ugc nofollow" target="_blank">rotate()</a></code>转换让我们不用处理大量的数学运算就能确定船的方向。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><h1 id="2907" class="kh ki hs bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">避免不必要的工作</h1><p id="3aa5" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">我们每次绘制时都在创建飞船路径，因为它当前依赖于飞船的位置和大小。</p><p id="f5ae" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于在游戏的生命周期中，尺寸只改变一次(当“SpaceCanvas”尺寸改变时),我们可以通过记住路径，并使用<code class="du lk ll lm ln b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/package-summary#(androidx.compose.ui.graphics.drawscope.DrawScope).translate(kotlin.Float,kotlin.Float,kotlin.Function1)" rel="noopener ugc nofollow" target="_blank">translate()</a></code>变换来正确定位它，从而避免每帧昂贵的初始化。</p><p id="40fc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们写一个函数在位置(0，0)创建飞船路径。这就消除了对飞船位置的依赖性，因为飞船位置经常更新:</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="fb57" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后我们可以在<code class="du lk ll lm ln b">SpaceCanvas</code>组合中使用它:</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="151b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lk ll lm ln b">remember(spaceship.width, spaceship.length)</code>意味着<code class="du lk ll lm ln b">spaceshipPath</code>只会在飞船的宽度或长度发生变化时更新，而不是每一帧都更新。</p><h1 id="52cd" class="kh ki hs bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">检测转动的旋转输入</h1><p id="334a" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">作为用户，我们需要执行三个动作:转身、推进和开火。旋转输入似乎非常适合第一个用例:旋转。</p><p id="1464" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">佩戴操作系统设备，如Pixel Watch，可以配备物理旋转侧按钮或表盘周围的旋转表圈。边框可以是物理硬件的一部分，也可以只是软件的一部分，就像三星Galaxy Watch5一样。旋转侧边按钮和挡板将输入事件的相关信息发送到焦点视图。</p><p id="85d5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以在画布上获得焦点，以便将这些旋转滚动事件发送到那里。<a class="ae jn" href="https://developer.android.com/jetpack/compose/modifiers#order-modifier-matters" rel="noopener ugc nofollow" target="_blank">修改器的顺序很重要</a>:<code class="du lk ll lm ln b">focusRequester</code>和<code class="du lk ll lm ln b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/rotary/package-summary#(androidx.compose.ui.Modifier).onRotaryScrollEvent(kotlin.Function1)" rel="noopener ugc nofollow" target="_blank">onRotaryScrollEvent</a></code>都需要应用在可聚焦的东西上。这意味着它们应该出现在<code class="du lk ll lm ln b">focusable()</code>修饰符之前，或者在同一个修饰符链中(如本例)，或者在一个父组件中:</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="cb3b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们可以在视图模型中修改船的状态:</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="3a6e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当下一次调用<code class="du lk ll lm ln b">update()</code>生成新的<code class="du lk ll lm ln b">UiState</code>时，画布将使用<code class="du lk ll lm ln b">rotationDegrees</code>来转换飞船的路径。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div class="er es lr"><img src="../Images/ceacaaefa4a56e30636fd1d6c61fa7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*BSfXnvb2wUTfNvPxSNQ5Mw.gif"/></div></figure><h1 id="204d" class="kh ki hs bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">检测用于按压的触摸输入</h1><p id="8067" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">我们可以认为抽插是一种布尔状态；当飞船的推进器工作时，我们想施加一个向前的力，当它们脱离时，我们想施加“摩擦力”使飞船减速。为此，我们使用带有 <code class="du lk ll lm ln b"><a class="ae jn" href="https://developer.android.com/jetpack/compose/gestures#tapping" rel="noopener ugc nofollow" target="_blank">detectTapGestures</a></code> <a class="ae jn" href="https://developer.android.com/jetpack/compose/gestures#tapping" rel="noopener ugc nofollow" target="_blank">功能</a>的<a class="ae jn" href="https://developer.android.com/jetpack/compose/gestures#tapping" rel="noopener ugc nofollow" target="_blank"/><code class="du lk ll lm ln b"><a class="ae jn" href="https://developer.android.com/jetpack/compose/gestures#tapping" rel="noopener ugc nofollow" target="_blank">pointerInput</a></code><a class="ae jn" href="https://developer.android.com/jetpack/compose/gestures#tapping" rel="noopener ugc nofollow" target="_blank">修改器检测屏幕上的按压:</a></p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><p id="8646" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在前面的代码片段中，<code class="du lk ll lm ln b">onPress</code>不是一个简单的回调函数——它是一个带有<code class="du lk ll lm ln b">PressGestureScope</code>接收器的挂起函数。这里，我们可以用<code class="du lk ll lm ln b">tryAwaitRelease()</code>来区分down和up事件。</p><p id="9d6c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当用户按下屏幕(<code class="du lk ll lm ln b">thrusting == true</code>)时，ViewModel将施加向前的力，这将导致船只加速或减速，这取决于船只的方位和动量。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div class="er es lr"><img src="../Images/e3aeeb4d8e705b666c23a0bb88de660c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*AeSPiELUE6Ssj2-0YU4Taw.gif"/></div></figure><p id="0b31" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lk ll lm ln b">detectTapGestures</code>接收另一个有用的参数，即<code class="du lk ll lm ln b">onDoubleTap</code> lambda，我们可以用它来检测用户何时双击使船只发射激光，如下所示。</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><figure class="kd ke kf kg fd hj er es paragraph-image"><div class="er es lr"><img src="../Images/6f494f3a7cdd19d408fbe262309eab33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*meBQgUZRnitRrMrdq_UaOQ.gif"/></div></figure><h1 id="3fbc" class="kh ki hs bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">处理不同的设备形状</h1><p id="9a29" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">游戏的一个机制包括“传送”宇宙飞船，这样当它飞出视口时，它会重新出现在另一边。</p><p id="d5cd" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在矩形设备上，当飞船的x坐标小于0或大于视口宽度时，我们将其设置为相反的值(y坐标和视口高度的逻辑类似)，例如从A到B。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/5e1b7f65b5b68a3b4ca9ba6fcfb46137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-HW7R_GcRTXigNKhDwLIhw.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx">“A” indicates the current position of the spaceship as it flies off towards the right edge of the screen, and “B” indicates its next position</figcaption></figure><p id="f868" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这在圆形设备上不起作用，原因有二:</p><ul class=""><li id="78c0" class="jo jp hs ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">画布的角被设备框架夹住，因此它们对用户来说是不可见的，但实际上仍然存在。这意味着如果宇宙飞船飞向角落，它会消失，但需要更长的时间才能在另一边重新出现，因为它仍然在穿越“看不见的”空间</li><li id="a537" class="jo jp hs ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">圆的“相对”面在概念上是不同的</li></ul><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ls"><img src="../Images/be1c0b07d47ffa3dc21f109054c921e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*juQKyRaVO-zhTU5SQJ0JoQ.png"/></div></div><figcaption class="lt lu et er es lv lw bd b be z dx">Left: shows the same behavior with a circle canvas where the Y-coordinate does not change, Right: shows the desired behavior with a circle canvas, where “B” is on the opposite side of the circle to “A”.</figcaption></figure><p id="e6b5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了解决这个问题，我们根据屏幕类型应用不同的传送逻辑，我们可以通过一个可组合的函数来检查:</p><figure class="kd ke kf kg fd hj"><div class="bz dy l di"><div class="lo lp l"/></div></figure><figure class="kd ke kf kg fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lx"><img src="../Images/d23a4a9c57d4c48cfc14192443d7356b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElTEFw5XjbApehBzCGDXeQ.png"/></div></div></figure><p id="e1e9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们知道“a”和“b ”,因为这是宇宙飞船的位置和圆心之间的绝对差值。利用毕达哥拉斯定理，我们可以计算出“c”。</p><p id="61df" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果“c”大于圆的半径，它就在圆的外面，我们需要把飞船传送到对面，使用“a”和“b”来计算新的位置。</p><figure class="kd ke kf kg fd hj er es paragraph-image"><div class="er es lr"><img src="../Images/db4f7b2210ade9de6a9cbe2ab8ffb824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*eD6g7X3-E-rvzfeizpeRzg.gif"/></div></figure><h1 id="935b" class="kh ki hs bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">下一步是什么？</h1><p id="c264" class="pw-post-body-paragraph ip iq hs ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">在Wear OS上使用Canvas和在mobile上使用Canvas没什么区别。这很有意义，因为它来自于<code class="du lk ll lm ln b">compose-foundation</code>工件，该工件在Wear OS 、mobile和其他支持Jetpack Compose的表面上<a class="ae jn" href="https://developer.android.com/training/wearables/compose#compose-compiler" rel="noopener ugc nofollow" target="_blank">工作。</a></p><p id="bd2b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们为自定义组件添加了旋转输入支持，并通过一次布尔检查将设备形状考虑在内！我们可以使用相同的技术在Wear OS上构建应用程序，而不仅仅是游戏，那么我们还需要考虑什么？</p><p id="1f5a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">保护电池是可穿戴设备的重中之重。使用深色或柔和的颜色(正如我们所做的)可以帮助显示器使用更少的能源。如果你正在制作一个需要互联网接入的应用程序，请考虑网络使用情况，并且更喜欢在设备连接到WiFi和充电器时进行同步。</p><p id="4799" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您使用旋转输入等设备功能时，请确保它们是支持它们的设备的增强功能，而不是不支持它们的设备所必需的。在我们的情况下，我们应该增加另一种方式让飞船旋转，例如，<code class="du lk ll lm ln b">onPressDownEvent()</code>可以改变飞船的方位以及控制推力。</p><p id="6f4a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">你有Wear OS应用、游戏或演示的想法吗？给我们展示一下</strong><a class="ae jn" href="https://kotlinlang.slack.com/archives/C02GBABJUAF" rel="noopener ugc nofollow" target="_blank"><strong class="ir ht">#穿缀</strong> </a> <strong class="ir ht">松弛通道，上</strong> <a class="ae jn" href="https://androiddev.social/@ataulm" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">乳齿象</strong> </a> <strong class="ir ht">，</strong> <a class="ae jn" href="https://twitter.com/ataulm" rel="noopener ugc nofollow" target="_blank"> <strong class="ir ht">碎碎念</strong> </a> <strong class="ir ht">或以下！</strong></p><p id="315a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本演示中显示的代码是<a class="ae jn" href="https://gist.github.com/ataulm/7a6b4b63ed45a5cfda013427c2212536" rel="noopener ugc nofollow" target="_blank">，可在此处</a>获得。</p></div></div>    
</body>
</html>