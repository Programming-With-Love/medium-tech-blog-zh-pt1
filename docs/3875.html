<html>
<head>
<title>Docker, the developer’s friend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker，开发者的朋友</h1>
<blockquote>原文：<a href="https://medium.com/globant/docker-the-developers-friend-dd01399de87d?source=collection_archive---------3-----------------------#2022-05-04">https://medium.com/globant/docker-the-developers-friend-dd01399de87d?source=collection_archive---------3-----------------------#2022-05-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/0f758567c7c3245f2ad3cbbe9602f2a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CmXaeyNZMiE18iZO"/></div></div></figure><div class=""/><h1 id="50dc" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">摘要</h1><p id="1f66" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">如今，软件开发需要的不仅仅是编写代码和测试代码。我们有多种语言、工具、框架、操作系统、架构、集成等等，造成了巨大的复杂性。Docker简化并加速了您的工作流程，同时让开发人员可以自由地为每个项目选择工具、应用程序堆栈和部署环境。在这个docker概述中，您将了解docker的主要特性，从而获得允许您在我们的项目中开始使用该技术的知识。</p><p id="cad0" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这篇文章由两部分组成，第一部分(你在这里)将从一些重要的概念和定义开始，第二部分(<a class="ae kq" rel="noopener" href="/globant/docker-the-developers-friend-3464e5e7f43d">这里</a>)将在一个简单的实践中把所有的理论付诸行动。</p><p id="035a" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">让我们看看容器之前和之后的软件开发过程。</p><h2 id="96dc" class="kr iq hs bd ir ks kt ku iv kv kw kx iz jy ky kz jd kc la lb jh kg lc ld jl le bi translated"><strong class="ak">应用开发</strong></h2><h2 id="ab65" class="kr iq hs bd ir ks kt ku iv kv kw kx iz jy ky kz jd kc la lb jh kg lc ld jl le bi translated"><strong class="ak">集装箱前</strong></h2><ul class=""><li id="94ef" class="lf lg hs jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">我们必须在您的本地主机或开发人员的机器上安装大部分技术，例如，PostgreSQL、Redis、Apache Tomcat、RabbitMQ等，显然，每个开发人员的主机操作系统可能不同，安装过程也不同。</li><li id="7c5b" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">安装技术堆栈的步骤很多，可能会有几个步骤使其变得复杂。</li></ul><h2 id="c853" class="kr iq hs bd ir ks kt ku iv kv kw kx iz jy ky kz jd kc la lb jh kg lc ld jl le bi translated"><strong class="ak">后容器</strong></h2><ul class=""><li id="df4b" class="lf lg hs jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">有了容器，我们不必直接在本地主机上安装任何技术堆栈，因为容器是打包您的堆栈的隔离环境，例如对于PostgreSQL，我们将在一个单元中有一个包含所有特定版本、配置和脚本的容器。</li><li id="c148" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">开发人员只需要去容器库，下载并在他们的本地机器上运行特定的容器，而不依赖于开发人员的主机操作系统。</li><li id="5b23" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">我们可以拥有不同版本的开发人员堆栈，例如，我们可以让Redis 6.0.12和6.2.1同时在您的本地主机上运行，而不会出现任何问题或冲突。</li></ul><h2 id="40a9" class="kr iq hs bd ir ks kt ku iv kv kw kx iz jy ky kz jd kc la lb jh kg lc ld jl le bi translated"><strong class="ak">应用部署</strong></h2><h2 id="cafb" class="kr iq hs bd ir ks kt ku iv kv kw kx iz jy ky kz jd kc la lb jh kg lc ld jl le bi translated"><strong class="ak">在容器之前</strong></h2><ul class=""><li id="1819" class="lf lg hs jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">第一步，<strong class="jp ht"> <em class="lt">开发团队</em> </strong>生产工件，例如jar、ear、war以及关于如何在服务器上配置和设置它的指令。此外，我们可以对其他工件或数据库、在服务器上运行的脚本、指令等进行同样的处理。</li><li id="41ce" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">第二步，前面的指令将提供给<strong class="jp ht"> <em class="lt">运营团队</em> </strong>，该团队将遵循这些指令并尝试配置和设置目标环境，这种方法可能会出现以下问题:</li><li id="2cd5" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">在目标服务器上安装和配置一切。</li><li id="7cd8" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">如果多台服务器在同一台主机上运行，依赖关系版本会发生冲突。</li><li id="1bbb" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">开发团队和运营团队之间的误解，因为说明是文本指南，导致错误的解释，或者开发团队可能忘记包括某些内容。</li></ul><h2 id="1649" class="kr iq hs bd ir ks kt ku iv kv kw kx iz jy ky kz jd kc la lb jh kg lc ld jl le bi translated"><strong class="ak">集装箱后</strong></h2><ul class=""><li id="bf4f" class="lf lg hs jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">开发团队和运营团队一起将应用程序打包到一个容器中。</li><li id="0ead" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">除了Docker运行时，服务器上不需要任何环境配置。</li><li id="8f15" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">它意味着一次性的努力。</li></ul><h1 id="914f" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">什么是容器？</h1><p id="4151" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">docker的主要概念是<strong class="jp ht"> <em class="lt">容器</em> </strong>(打包代码及其依赖项的软件单元)<strong class="jp ht"> <em class="lt">。</em></strong>Docker容器是一个可执行的软件包，包括运行应用程序、代码、运行时、系统工具、系统库和设置所需的一切。</p><h1 id="9d18" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">docker是什么？</h1><p id="a253" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Docker是一个用于开发应用程序的开源平台，独立于基础设施，这是一个将应用程序与基础设施分离的好工具，它还意味着，例如，开发团队可以拥有一个公共的开发环境，其中包含一段代码成功工作所需的所有依赖项，从而允许非常快速的软件交付。</p><h1 id="852c" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">什么是图像？</h1><p id="8ef6" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">Images是一个文件(只读),它包含运行特定应用程序容器的所有指令，并且可以在Docker容器平台上运行。例如，假设我们想要创建一个在线购物商店，那么对于这个项目，我们需要操作系统、应用程序本身、数据库(PostgreSQL)、用于处理缓存的Redis等等，所以在docker映像文件中，我们将定义创建容器的指令，例如:</p><ul class=""><li id="ff37" class="lf lg hs jp b jq kl ju km jy lu kc lv kg lw kk lk ll lm ln bi translated">安装操作系统、安装数据库以及安装和运行应用程序的指令。</li></ul><blockquote class="lx ly lz"><p id="d4e6" class="jn jo lt jp b jq kl js jt ju km jw jx ma kn ka kb mb ko ke kf mc kp ki kj kk ha bi translated"><strong class="jp ht"> <em class="hs"> Docker图片也是任何第一次使用Docker的人的起点。</em>T13】</strong></p></blockquote><h1 id="5a85" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">虚拟机vs Docker</h1><p id="8bd1" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">清楚docker和VM之间的区别很重要，让我们来分析一下。</p><h2 id="c2e2" class="kr iq hs bd ir ks kt ku iv kv kw kx iz jy ky kz jd kc la lb jh kg lc ld jl le bi translated">虚拟计算机</h2><figure class="me mf mg mh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es md"><img src="../Images/fd07789431bdf5dbf7c11078e94af636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Cvrgyg_8HSqfE4Wo"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Virtual Machine architecture</figcaption></figure><p id="842f" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">我们可以说虚拟机(VM)是物理硬件的抽象，它将一台服务器变成多台服务器。<strong class="jp ht">虚拟机管理程序</strong>允许我们在一台机器上运行多个虚拟机。每个虚拟机都包括一个完整的操作系统副本(<strong class="jp ht"> <em class="lt">客户操作系统层</em> </strong>)、应用程序以及必要的二进制文件和库，这可能会占用数十GB的空间，显然，虚拟机的启动速度也会很慢。</p><h2 id="8829" class="kr iq hs bd ir ks kt ku iv kv kw kx iz jy ky kz jd kc la lb jh kg lc ld jl le bi translated">码头集装箱</h2><p id="3cab" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">容器是包括应用程序(代码)和它们打包在一起的依赖关系的抽象。许多容器可以在同一台机器上运行，并与其他容器共享操作系统内核，这里重要的是每个容器作为一个独立的进程运行。容器的大小是几十兆字节，显然，容器也可以比虚拟机更快。</p><figure class="me mf mg mh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es md"><img src="../Images/a2b76b71952ad42b415580a904b3bea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QeOWpIPWsEdgi9Ug"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Docker Architecture</figcaption></figure><p id="015c" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">让我们回顾一下上面的图像。首先，docker拥有与虚拟机相同的<strong class="jp ht"> <em class="lt">基础架构</em> </strong>层，在此之上我们拥有主机操作系统，它可以是能够运行docker的任何操作系统(Linux、Windows、Mac OS)，请查看操作系统主机要求(对于<a class="ae kq" href="https://docs.docker.com/docker-for-windows/install/#system-requirements" rel="noopener ugc nofollow" target="_blank"> windows </a>和<a class="ae kq" href="https://docs.docker.com/docker-for-mac/install/#system-requirements" rel="noopener ugc nofollow" target="_blank"> Mac OS </a>)。记住Docker是在Linux操作系统上本地运行的。第三层是docker架构中最有趣的一层，即<strong class="jp ht"> <em class="lt"> docker </em> </strong>守护进程，它取代了虚拟机上的虚拟机管理程序，是一种在后台运行的服务，允许运行docker容器。最后一层是应用程序，其中有代码、依赖项和配置文件，因此，应用程序需要正确运行的所有必要内容。如果我们在Docker容器架构中看到，客户操作系统层被取消，我们节省了它所占用的资源数量。</p><h1 id="1cc0" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">码头设备</h1><p id="2984" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">要在Windows操作系统、Mac操作系统和Linux操作系统上安装docker，我们可以遵循官方说明:</p><ul class=""><li id="3795" class="lf lg hs jp b jq kl ju km jy lu kc lv kg lw kk lk ll lm ln bi translated"><a class="ae kq" href="https://docs.docker.com/docker-for-windows/install/" rel="noopener ugc nofollow" target="_blank">在Windows操作系统上安装docker</a></li><li id="4c96" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><a class="ae kq" href="https://docs.docker.com/docker-for-mac/install/" rel="noopener ugc nofollow" target="_blank">在Mac OS上安装docker</a></li><li id="80f4" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><a class="ae kq" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank">在Linux操作系统上安装docker</a></li></ul><h1 id="8f46" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">码头枢纽</h1><p id="cf0b" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这是一个公共存储库，我们可以在其中找到关于我们项目的任何组件的一些图像，例如，MySQL、PostgreSQL、Redis、Cassandra、Ubuntu OS、Alpine、JVM、JBoss、Apache等的图像。要使用docker hub，请转到页面<a class="ae kq" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>我们将看到以下页面，这对于创建免费帐户非常有用。</p><figure class="me mf mg mh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mm"><img src="../Images/c4d09bc6112c0dc6624bac5e6058886d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RXNENHCCnmpe_w9T"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Docker hub</figcaption></figure><p id="0039" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在那里，我们可以搜索任何docker图像，例如，让我们搜索PostgreSQL图像，我们将看到以下结果。</p><figure class="me mf mg mh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mm"><img src="../Images/136d98e4c930952355c41555ed65f67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FX37OPLL4CW6o0AA"/></div></div><figcaption class="mi mj et er es mk ml bd b be z dx">Docker hub search result</figcaption></figure><p id="f225" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这是PostgreSQL团队的官方docker图片，但是我们可以使用其他作者的图片。</p><p id="e7e1" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">从docker hub下载图像</p><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="33b3" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker pull</em></strong><em class="lt"> </em><strong class="mo ht"><em class="lt">image_name</em></strong></span></pre><p id="9e85" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">显示所有下载的图像</p><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="e6f2" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker images</em></strong></span></pre><p id="33d8" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">显示所有正在运行的容器</p><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="d6f7" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker ps</em></strong></span></pre><p id="9d36" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">显示停止和运行的容器</p><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="c4ba" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker ps -a</em></strong></span></pre><p id="56fc" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">使用定义的名称启动创建的容器。</p><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="1609" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker start container_name</em></strong></span></pre><p id="0387" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">拦住集装箱</p><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="f7c2" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker stop container_name</em></strong></span></pre><p id="49e6" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">从映像运行容器</p><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="3d81" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker run container_name</em></strong><em class="lt"> </em><strong class="mo ht"><em class="lt">image</em></strong></span></pre><p id="a6d3" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在容器中运行shell命令。</p><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="8e44" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker exec -ti container_name “cmd”</em></strong></span></pre><p id="4994" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">显示/跟踪容器的日志输出。</p><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="b8eb" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker logs -ft container_name</em></strong></span></pre><p id="6b9c" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">杀死所有运行的码头集装箱。</p><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="022a" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker kill $(docker ps -q)</em></strong></span></pre><p id="1119" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">删除悬挂的Docker图像。</p><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="759a" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker rmi $(docker images -q -f dangling=true)</em></strong></span></pre><p id="7779" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">移除所有停止的容器。</p><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="de1f" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker rm $(docker ps -a -q)</em></strong></span></pre><h1 id="1857" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">运行第一个容器</h1><p id="bca1" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">所以让我们用一个小图像例如Ubuntu OS，让我们开始。</p><ul class=""><li id="2fca" class="lf lg hs jp b jq kl ju km jy lu kc lv kg lw kk lk ll lm ln bi translated"><strong class="jp ht">步骤1 </strong>:从docker hub下载镜像，对其执行命令:</li></ul><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="071b" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker pull ubuntu</em></strong></span></pre><ul class=""><li id="a2b9" class="lf lg hs jp b jq kl ju km jy lu kc lv kg lw kk lk ll lm ln bi translated"><strong class="jp ht">步骤2 </strong>:一旦前面的命令完成，使用下面的命令检查图像，你应该在那里看到ubuntu图像:</li></ul><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="3021" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker images</em></strong></span></pre><figure class="me mf mg mh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mw"><img src="../Images/8036093476f3b12fd535b972b9f11a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1XWyGaBvt0igfRZ5"/></div></div></figure><ul class=""><li id="b76a" class="lf lg hs jp b jq kl ju km jy lu kc lv kg lw kk lk ll lm ln bi translated"><strong class="jp ht">第三步</strong>:有了主机中的ubuntu镜像，我们可以为ubuntu创建一个容器。让我们开始吧。</li></ul><pre class="me mf mg mh fd mn mo mp mq aw mr bi"><span id="edae" class="kr iq hs mo b fi ms mt l mu mv"><strong class="mo ht"><em class="lt">docker run -ti — name local_ubuntu ubuntu:latest</em></strong></span></pre><figure class="me mf mg mh fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mm"><img src="../Images/7c42dd854cc39474860818a9e1bd8ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hZVfcu9hL1MOLnJL"/></div></div></figure><p id="a325" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">我们对Ubuntu docker容器很感兴趣，所以它已经可以用在我们的项目中了。也许我们可以安装一个Apache Tomcat并在那里部署应用程序，很简单，对吗？。</p><h1 id="b830" class="ip iq hs bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">卷</h1><p id="a24b" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">基本上，卷是一种保存容器生成和使用的数据的机制。创建卷时，它存储在Docker主机上的一个目录中。体积有几个优点，我们来看看:</p><ul class=""><li id="4972" class="lf lg hs jp b jq kl ju km jy lu kc lv kg lw kk lk ll lm ln bi translated">卷更容易备份或迁移。</li><li id="098d" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">您可以使用Docker CLI命令或Docker API来管理卷。</li><li id="7f6c" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">卷在Linux和Windows容器上都可以工作。</li><li id="51d0" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">可以在多个容器之间更安全地共享卷。</li><li id="038a" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">新卷的内容可以由容器预先填充。</li><li id="fc63" class="lf lg hs jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">卷不会增加使用它的容器的大小，并且卷的内容存在于给定容器的生命周期之外。</li></ul><p id="7a67" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">让我们用一个形象来看这个概念，我觉得比较好理解:</p><figure class="me mf mg mh fd hj er es paragraph-image"><div class="er es mx"><img src="../Images/1dec2556d3e0271c9f52925be7ee8689.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/0*eeNdPamf7xBB3YS4"/></div><figcaption class="mi mj et er es mk ml bd b be z dx">docker volumes</figcaption></figure><p id="433d" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">主机上的物理文件夹被挂载到Docker的虚拟文件系统中。</p><p id="e7d5" class="pw-post-body-paragraph jn jo hs jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">到目前为止，我们已经回顾了关于docker的主要概念，如何从docker hub获取图像，如何开始在我们的个人计算机上安装图像，以及如何创建简单的容器。在本文的第二部分，我们将看到一个小例子来更好地理解我们所学的内容。</p><h2 id="87ad" class="kr iq hs bd ir ks kt ku iv kv kw kx iz jy ky kz jd kc la lb jh kg lc ld jl le bi translated">参考</h2><p id="168f" class="pw-post-body-paragraph jn jo hs jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">【https://docs.docker.com/get-started/overview/ T4】</p></div></div>    
</body>
</html>