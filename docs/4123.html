<html>
<head>
<title>Send messages when you’re back online with Service Workers and Background Sync</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当您与服务人员和后台同步恢复在线时发送信息</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/send-messages-when-youre-back-online-with-service-workers-and-background-sync-be6fc7de36c9?source=collection_archive---------1-----------------------#2017-02-17">https://medium.com/google-developer-experts/send-messages-when-youre-back-online-with-service-workers-and-background-sync-be6fc7de36c9?source=collection_archive---------1-----------------------#2017-02-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/8374af858a5194bd029ab0c3e688974b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*VkE1y7pIQ1xaY9YrQto0AQ.gif"/></div></figure><p id="b77a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当你发送短信，但你的手机没有很好的信号，它会继续尝试在后台发送消息，即使你关闭应用程序。很有用吧？</p><p id="e291" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这篇文章中，我们将看到如何使用来自<a class="ae jj" href="https://developers.google.com/web/fundamentals/getting-started/primers/service-workers" rel="noopener ugc nofollow" target="_blank">服务工作者</a>的<a class="ae jj" href="https://developers.google.com/web/updates/2015/12/background-sync" rel="noopener ugc nofollow" target="_blank">后台同步API </a>在web应用程序中复制这种行为。</p><h1 id="22b6" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">我们需要什么</h1><p id="002a" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">为了演示后台同步API，让我们在现有的应用程序中构建一个功能，一个基于web的Twilio号码SMS收件箱。当我们为收到的文本消息实现<a class="ae jj" href="https://www.twilio.com/blog/2016/02/web-powered-sms-inbox-with-service-worker-push-notifications.html" rel="noopener ugc nofollow" target="_blank">网络推送通知</a>时，你可能已经见过这个应用程序了。</p><p id="2e2a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要运行该应用程序，您需要:</p><p id="0f56" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一旦你对这些比特进行了排序，你就可以从GitHub 下载应用程序或者使用git克隆它。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="f7eb" class="kw jl hh ks b fi kx ky l kz la">$ git clone https://github.com/philnash/sms-messages-app.git</span></pre><p id="8483" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">转到目录并安装依赖项:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="c3bb" class="kw jl hh ks b fi kx ky l kz la">$ cd sms-messages-app<br/>$ npm install</span></pre><p id="4174" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">将<code class="du lb lc ld ks b">.env.example</code>文件复制到一个名为<code class="du lb lc ld ks b">.env</code>的文件中，并在其中填入您的Twilio帐户SID、身份验证令牌和您的Twilio电话号码。</p><p id="1b3b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，您应该能够启动应用程序并对其进行测试。使用以下命令启动它:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="faa8" class="kw jl hh ks b fi kx ky l kz la">$ node index.js</span></pre><p id="623a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在<a class="ae jj" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>的浏览器中打开应用程序。您可以使用<a class="ae jj" href="http://localhost:3000/messages/new" rel="noopener ugc nofollow" target="_blank">新消息表单</a>给自己发送短信。</p><figure class="kn ko kp kq fd ii er es paragraph-image"><div class="er es le"><img src="../Images/6502adc10d1da5cf30798454973ee7cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/0*Y9uuY77QhA6eZt71.gif"/></div></figure><p id="c03a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果你试图在没有网络连接的情况下用这个应用程序发送消息，你会得到不一样的体验。</p><figure class="kn ko kp kq fd ii er es paragraph-image"><div class="er es le"><img src="../Images/379b856b4d27b662ccfe4e863bc1c9b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/0*0OGHLeVoIV2A7KPl.gif"/></div></figure><p id="6ecf" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">事实上，这种体验很糟糕，但后台同步API可以解决这一问题。如果我们有一个服务人员，并注册了一个同步事件，那么浏览器将只在它认为有一个良好的网络连接时触发该事件。这允许我们在离线时存储我们想要发送的消息，并且只在浏览器再次连接时发送它们。</p><h1 id="d8c3" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">我们要做什么</h1><p id="e12f" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">要完成这项任务，我们还有几个步骤，所以让我们把它们分解一下。在页面上，我们需要:</p><ol class=""><li id="879e" class="lf lg hh in b io ip is it iw lh ja li je lj ji lk ll lm ln bi translated">注册服务人员</li><li id="376e" class="lf lg hh in b io lo is lp iw lq ja lr je ls ji lk ll lm ln bi translated">拦截消息表单的“提交”事件</li><li id="4bbe" class="lf lg hh in b io lo is lp iw lq ja lr je ls ji lk ll lm ln bi translated">将消息详情放入浏览器数据库中的<a class="ae jj" href="https://developer.mozilla.org/en/docs/Web/API/IndexedDB_API" rel="noopener ugc nofollow" target="_blank"> IndexedDB </a>。</li><li id="ee7e" class="lf lg hh in b io lo is lp iw lq ja lr je ls ji lk ll lm ln bi translated">注册服务人员以接收“同步”事件</li></ol><p id="7b75" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后，在服务人员中，我们需要:</p><ol class=""><li id="a172" class="lf lg hh in b io ip is it iw lh ja li je lj ji lk ll lm ln bi translated">监听同步事件</li><li id="acbe" class="lf lg hh in b io lo is lp iw lq ja lr je ls ji lk ll lm ln bi translated">当接收到同步事件时，从IndexedDB中检索消息</li><li id="5178" class="lf lg hh in b io lo is lp iw lq ja lr je ls ji lk ll lm ln bi translated">对于每封邮件，向我们的服务器发送一个发送邮件的请求</li><li id="b134" class="lf lg hh in b io lo is lp iw lq ja lr je ls ji lk ll lm ln bi translated">如果消息发送成功，则从IndexedDB中删除该消息</li></ol><p id="c55c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">仅此而已。我们将从服务人员注册开始。</p><h1 id="9a82" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">注册服务人员</h1><p id="644d" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">在<code class="du lb lc ld ks b">public/js</code>目录下创建一个名为<code class="du lb lc ld ks b">app.js</code>的新文件。通过将以下内容添加到<code class="du lb lc ld ks b">views/layout.hbs</code>的底部，将其包含在页面中:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="5505" class="kw jl hh ks b fi kx ky l kz la">    &lt;script type=”text/javascript” src=”https://www.twilio.com/blog/js/material.min.js"&gt;&lt;/script&gt;<br/>    &lt;script type=”text/javascript” src=”https://www.twilio.com/blog/js/app.js"&gt;&lt;/script&gt; <br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="8f90" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">打开<code class="du lb lc ld ks b">public/js/app.js</code>并从以下内容开始:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="e7c0" class="kw jl hh ks b fi kx ky l kz la">document.addEventListener('DOMContentLoaded', function(event) {<br/>  if ('serviceWorker' in navigator) {<br/>    navigator.serviceWorker.register('/sw.js').then(function(reg) {<br/>      if ('sync' in reg) {<br/>        // do stuff here<br/>      }<br/>    }).catch(function(err) { <br/>      console.error(err); // the Service Worker didn't install correctly<br/>    });<br/>  }<br/>});</span></pre><p id="90c2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一旦DOM的内容被完全加载，这段代码将检查浏览器是否支持服务人员，如果不支持，那么继续下去就没有意义了。然后它在文件<code class="du lb lc ld ks b">sw.js</code>中注册将要居住的服务工作者。当承诺完成并且服务人员成功注册后，我们将检查是否也支持同步。然后我们就可以真正开始工作了。</p><h1 id="ec78" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">拦截表单提交事件</h1><p id="5dcc" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">我们需要获取对表单和字段的引用，稍后我们将从中读取值。然后我们监听表单上的<code class="du lb lc ld ks b">submit</code>事件，这样当它触发时，我们可以阻止它实际提交。相反，我们将创建一个包含电话号码和消息正文的<code class="du lb lc ld ks b">message</code>对象，并将其保存到IndexedDB中。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="e5f8" class="kw jl hh ks b fi kx ky l kz la">if ('sync' in reg) {<br/>  var form = document.querySelector('.js-background-sync');<br/>  var phoneNumberField = form.querySelector('#phoneNumber');<br/>  var bodyField = form.querySelector('#body');</span><span id="2f03" class="kw jl hh ks b fi lt ky l kz la">  form.addEventListener('submit', function(event) {<br/>    event.preventDefault();<br/>    var message = {<br/>      phoneNumber: phoneNumberField.value,<br/>      body: bodyField.value<br/>    };</span><span id="e9a5" class="kw jl hh ks b fi lt ky l kz la">    // do more stuff here<br/>  });<br/>}</span></pre><h1 id="a3cf" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">将邮件保存到IndexedDB</h1><p id="683c" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">现在我们已经将消息作为一个对象，我们需要将它保存到<a class="ae jj" href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" rel="noopener ugc nofollow" target="_blank"> IndexedDB </a>中，以便服务人员以后可以再次获取它。我们使用IndexedDB来做这件事，因为<a class="ae jj" href="https://developer.mozilla.org/en/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank"> localStorage </a> API虽然更简单，但不能在服务工作者中工作。</p><p id="7cfe" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了使使用IndexedDB更容易一些，我将包含Jake Archibald的idb库，它用承诺代替了回调系统。这有两个好处，使用数据库的代码稍微简单一点，服务人员希望工作时有承诺，所以这为我们以后更容易的工作做好了准备。如果你不熟悉承诺，看看张秀坤的承诺指南。</p><p id="fe65" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我已经在项目中包含了这个库，所以只需在<code class="du lb lc ld ks b">app.js</code>之前将下面的脚本标签添加到布局中。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="e7bf" class="kw jl hh ks b fi kx ky l kz la">  &lt;script type="text/javascript" src="<a class="ae jj" href="https://www.twilio.com/blog/js/material.min.js" rel="noopener ugc nofollow" target="_blank">https://www.twilio.com/blog/js/material.min.js</a>"&gt;&lt;/script&gt;<br/>  &lt;script type="text/javascript" src="<a class="ae jj" href="https://www.twilio.com/blog/js/idb.js" rel="noopener ugc nofollow" target="_blank">https://www.twilio.com/blog/js/idb.js</a>"&gt;&lt;/script&gt;<br/>  &lt;script type="text/javascript" src="<a class="ae jj" href="https://www.twilio.com/blog/js/app.js" rel="noopener ugc nofollow" target="_blank">https://www.twilio.com/blog/js/app.js</a>"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="0993" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">接下来，我们打开一个数据库，我们称之为“消息”，在回调中，我们创建一个名为“发件箱”的对象存储，并告诉它使用一个自动递增键，我们称之为<code class="du lb lc ld ks b">id</code>。当这个承诺兑现后，我们就可以访问我们的数据库了。然后，我们可以使用它在我们的对象存储中启动一个事务，并将<code class="du lb lc ld ks b">put</code>消息对象放入存储中。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="0759" class="kw jl hh ks b fi kx ky l kz la">    var message = {<br/>      phoneNumber: phoneNumberField.value,<br/>      body: bodyField.value<br/>    };</span><span id="19a9" class="kw jl hh ks b fi lt ky l kz la">    idb.open('messages', 1, function(upgradeDb) {<br/>      upgradeDb.createObjectStore('outbox', { autoIncrement : true, keyPath: 'id' });<br/>    })<br/>    .then(function(db) {<br/>      var transaction = db.transaction('outbox', 'readwrite');<br/>      return transaction.objectStore('outbox').put(message);<br/>    })<br/>    .then(function() {<br/>      // register for sync and clean up the form<br/>    });<br/>  });<br/>}</span></pre><p id="9467" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一旦数据库事务成功完成，我们需要做的就是注册同步事件，我们希望服务人员接收并整理我们的表单。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="7d4a" class="kw jl hh ks b fi kx ky l kz la">      return transaction.objectStore('outbox').put(message);<br/>    }).then(function() {<br/>      bodyField.value = '';<br/>      if (phoneNumberField.getAttribute('type') !== 'hidden') {<br/>        phoneNumberField.value = '';<br/>      }<br/>      return reg.sync.register('outbox');<br/>    }).catch(function(err) {<br/>      // something went wrong with the database or the sync registration, log and submit the form<br/>      console.error(err); <br/>      form.submit();<br/>    });<br/>  });<br/>}</span></pre><p id="cb9b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在我们测试第一部分之前，我们需要为服务人员创建一个文件，否则我们的初始安装会失败，我们的代码都不会运行。只需在<code class="du lb lc ld ks b">public</code>目录下创建一个名为<code class="du lb lc ld ks b">sw.js</code>的空白文件。现在，打开消息表单，填写消息和您的电话号码，然后单击发送。表单将被清除，但不会发送任何消息。如果您打开开发工具并从应用程序选项卡中检查IndexedDB，您会发现消息安全地存储在那里。</p><figure class="kn ko kp kq fd ii er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/e105a5c7350bc7862e2b69ea909276de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oFKkRs1TjTIUwWqw.png"/></div></div></figure><p id="4488" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了使服务人员的开发对我们来说更容易，选择dev tools的Application标签下的Update on reload复选框。这将使我们在开发过程中不必处理服务工作者的生命周期。</p><figure class="kn ko kp kq fd ii er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/467029b826bb1a87c6087d2d5232b423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ei0Q22C-pM5uR8fe.png"/></div></div></figure><p id="c818" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们需要在服务工作者中实现实际的同步事件。</p><h1 id="6294" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">实现同步事件</h1><p id="5f57" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">打开<code class="du lb lc ld ks b">public/sw.js</code>，从<a class="ae jj" href="https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/importScripts" rel="noopener ugc nofollow" target="_blank">导入</a>IDB库开始，监听同步事件。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="6629" class="kw jl hh ks b fi kx ky l kz la">importScripts('/js/idb.js');</span><span id="fef4" class="kw jl hh ks b fi lt ky l kz la">self.addEventListener('sync', function(event) {</span><span id="9c1d" class="kw jl hh ks b fi lt ky l kz la">});</span></pre><p id="e4df" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在事件侦听器中，我们需要告诉浏览器等待服务工作者完成连接到IndexedDB、检索任何需要发送的消息并发送它们的异步任务。</p><p id="0921" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为此，我们使用事件的<code class="du lb lc ld ks b"><a class="ae jj" href="https://developer.mozilla.org/en-US/docs/Web/API/ExtendableEvent/waitUntil" rel="noopener ugc nofollow" target="_blank">waitUntil</a></code>方法，该方法将一个承诺作为参数，只有在承诺得到解决时才完成。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="ad4c" class="kw jl hh ks b fi kx ky l kz la">importScripts('/js/idb.js');</span><span id="ea99" class="kw jl hh ks b fi lt ky l kz la">self.addEventListener('sync', function(event) {<br/>  event.waitUntil(<br/>    // do asynchronous tasks here<br/>  );<br/>});</span></pre><h2 id="92e8" class="kw jl hh bd jm lz ma mb jq mc md me ju iw mf mg jy ja mh mi kc je mj mk kg ml bi translated">是时候进行重构了</h2><p id="b9f9" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">我们需要连接到我们的IndexedDB数据库，但是我们已经在我们的<code class="du lb lc ld ks b">app.js</code>文件中编写了这样做的代码。这个连接代码可以在服务人员和页面之间重构和共享。</p><p id="4bf8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在<code class="du lb lc ld ks b">public/js</code>目录中创建一个名为<code class="du lb lc ld ks b">store.js</code>的文件，并输入以下内容:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="03cb" class="kw jl hh ks b fi kx ky l kz la">var store = {<br/>  db: null,</span><span id="e66e" class="kw jl hh ks b fi lt ky l kz la">  init: function() {<br/>    if (store.db) { return Promise.resolve(store.db); }<br/>    return idb.open('messages', 1, function(upgradeDb) {<br/>      upgradeDb.createObjectStore('outbox', { autoIncrement : true, keyPath: 'id' });<br/>    })<br/>    .then(function(db) {<br/>      return store.db = db;<br/>    });<br/>  },</span><span id="d30a" class="kw jl hh ks b fi lt ky l kz la">  outbox: function(mode) {<br/>    return store.init().then(function(db) {<br/>      return db.transaction('outbox', mode).objectStore('outbox');<br/>    })<br/>  }<br/>}</span></pre><p id="4745" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果需要的话,<code class="du lb lc ld ks b">init</code>函数会打开并升级数据库，并返回一个用数据库对象本身解决的承诺。<code class="du lb lc ld ks b">outbox</code>函数返回一个承诺，该承诺在一个事务中以所选择的模式(“readonly”或“readwrite”)通过对发件箱的对象存储的引用来解析。</p><p id="e076" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">将这个脚本添加到<code class="du lb lc ld ks b">views/layouts.hbs</code>中。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="93c4" class="kw jl hh ks b fi kx ky l kz la">  &lt;script type="text/javascript" src="<a class="ae jj" href="https://www.twilio.com/blog/js/material.min.js" rel="noopener ugc nofollow" target="_blank">https://www.twilio.com/blog/js/material.min.js</a>"&gt;&lt;/script&gt;<br/>  &lt;script type="text/javascript" src="<a class="ae jj" href="https://www.twilio.com/blog/js/idb.js" rel="noopener ugc nofollow" target="_blank">https://www.twilio.com/blog/js/idb.js</a>"&gt;&lt;/script&gt;<br/>  &lt;script type="text/javascript" src="<a class="ae jj" href="https://www.twilio.com/blog/js/store.js" rel="noopener ugc nofollow" target="_blank">https://www.twilio.com/blog/js/store.js</a>"&gt;&lt;/script&gt;<br/>  &lt;script type="text/javascript" src="<a class="ae jj" href="https://www.twilio.com/blog/js/app.js" rel="noopener ugc nofollow" target="_blank">https://www.twilio.com/blog/js/app.js</a>"&gt;&lt;/script&gt;<br/>&lt;/body&gt;</span></pre><p id="7293" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">用我们的新店取代<code class="du lb lc ld ks b">app.js</code>中idb的使用。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="a888" class="kw jl hh ks b fi kx ky l kz la">var message = {<br/>                phoneNumber: phoneNumberField.value,<br/>                body: bodyField.value<br/>              };<br/>-           idb.open('messages', 1, function(upgradeDb) {<br/>-             upgradeDb.createObjectStore('outbox', { autoIncrement : true, keyPath: 'id' });<br/>-           }).then(function(db) {<br/>-             var transaction = db.transaction('outbox', 'readwrite');<br/>-             return transaction.objectStore('outbox').put(message);<br/>+           store.outbox('readwrite').then(function(outbox) {<br/>+             return outbox.put(message);<br/>            }).then(function() {</span></pre><p id="3043" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">将我们的商店导入到服务人员文件中。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="324a" class="kw jl hh ks b fi kx ky l kz la">importScripts('/js/idb.js');<br/>importScripts('/js/store.js');</span><span id="941e" class="kw jl hh ks b fi lt ky l kz la">self.addEventListener('sync', function(event) {<br/>  event.waitUntil(<br/>    // do asynchronous tasks here<br/>  );<br/>});</span></pre><p id="b34a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，我们可以使用我们的存储来获取所有消息，而无需重复自己。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="18fb" class="kw jl hh ks b fi kx ky l kz la">self.addEventListener('sync', function(event) {<br/>  event.waitUntil(<br/>    store.outbox('readonly').then(function(outbox) {<br/>      return outbox.getAll();<br/>    })<br/>    .then(function(messages) {<br/>      // send the messages<br/>    })<br/>    .catch(function(err) { console.error(err); });<br/>  );<br/>});</span></pre><p id="c813" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们有一系列信息要发送。对于每条消息，我们需要向原始路径“/messages”发出一个POST请求，请求中包含消息的详细信息。然后我们将读取响应，如果成功，我们将从数据库中删除该消息。</p><p id="fa4c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">由于所有这些动作都是异步的，我们需要使用<code class="du lb lc ld ks b">Promise.all</code>来等待它们全部成功完成。在sw.js中应该是这样的:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="9425" class="kw jl hh ks b fi kx ky l kz la">    store.outbox('readonly').then(function(outbox) {<br/>      return outbox.getAll();<br/>    })<br/>    .then(function(messages) {<br/>      return Promise.all(messages.map(function(message) {<br/>        return fetch('/messages', {<br/>          method: 'POST',<br/>          body: JSON.stringify(message),<br/>          headers: {<br/>            'Accept': 'application/json',<br/>            'X-Requested-With': 'XMLHttpRequest',<br/>            'Content-Type': 'application/json'<br/>          }<br/>        })<br/>        .then(function(response) {  <br/>          return response.json();<br/>        })<br/>        .then(function(data) {<br/>          if (data.result === 'success') {<br/>            return store.outbox('readwrite').then(function(outbox) {<br/>              return outbox.delete(message.id);<br/>            });<br/>          }<br/>        })<br/>    })<br/>    .catch(function(err) { console.error(err); });</span></pre><p id="9123" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一切就绪后，我们就可以开始测试了。重新加载页面并发送消息。你应该马上收到它。您还应该收到您尝试发送的第一条消息，因为它也在IndexedDB中等待。</p><p id="5ead" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在断开与互联网的连接，尝试发送消息。等一会儿，打开网络，嗖的一声，信息来了！</p><figure class="kn ko kp kq fd ii er es paragraph-image"><div class="er es le"><img src="../Images/134f633de931d6b5bf68dc3650602e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/0*L8LZ7SpW6Tb_mNrY.gif"/></div></figure><h1 id="f3d8" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">网络弹性消息</h1><p id="15da" class="pw-post-body-paragraph il im hh in b io ki iq ir is kj iu iv iw kk iy iz ja kl jc jd je km jg jh ji ha bi translated">使用服务工作者的后台同步API，我们现在有了网络弹性消息发送。用户不再需要打开一个网站来等待他们刚刚做的事情是否有效。我们越来越接近原生应用程序可以为用户提供的体验，就像我在开始时提到的内置短信应用程序。</p><p id="e930" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这只是一个初步的实现，完整的代码在GitHub 上。</p><p id="c20a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们还可以尝试在更多地方改善该应用程序的用户体验，例如:</p><ul class=""><li id="fe9a" class="lf lg hh in b io ip is it iw lh ja li je lj ji mm ll lm ln bi translated">改进用户界面以显示尚未发送的消息</li><li id="9fbc" class="lf lg hh in b io lo is lp iw lq ja lr je ls ji mm ll lm ln bi translated">包括超时或取消已发送消息的方法</li><li id="2485" class="lf lg hh in b io lo is lp iw lq ja lr je ls ji mm ll lm ln bi translated"><a class="ae jj" href="https://www.twilio.com/blog/2016/02/web-powered-sms-inbox-with-service-worker-push-notifications.html" rel="noopener ugc nofollow" target="_blank">推送通知</a>通知消息失败</li></ul><p id="98d3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">发送消息也不是后台同步的唯一用例。我可以看到这在以下方面很有用:</p><p id="ce4c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我希望你对后台同步API的潜力感到兴奋，让我知道你的想法或者你对它的用途有什么想法。你可以在这里的评论中找到我，也可以在Twitter上发邮件到philnash@twilio.com。</p></div><div class="ab cl mn mo go mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ha hb hc hd he"><p id="f34f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="mu">原载于2017年2月17日</em><a class="ae jj" href="https://www.twilio.com/blog/2017/02/send-messages-when-youre-back-online-with-service-workers-and-background-sync.html" rel="noopener ugc nofollow" target="_blank"><em class="mu">【www.twilio.com】</em></a><em class="mu">。</em></p></div></div>    
</body>
</html>