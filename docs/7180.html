<html>
<head>
<title>No Cause for Concern — RxJava and Retrofit Throwing a Tantrum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有理由担心——rx Java和翻新会发脾气</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/no-cause-for-concern-rxjava-and-retrofit-throwing-a-tantrum-96c9e4ba8a6c?source=collection_archive---------0-----------------------#2016-11-02">https://medium.com/square-corner-blog/no-cause-for-concern-rxjava-and-retrofit-throwing-a-tantrum-96c9e4ba8a6c?source=collection_archive---------0-----------------------#2016-11-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie"><p id="3df9" class="if ig hh bd ih ii ij ik il im in io dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae ip" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="7cda" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm io ha bi translated">上周，我们在JDK的<code class="du jn jo jp jq b">Throwable</code>类中发现了一个有趣的API设计问题，这个问题导致了RxJava中的bug和改型。这是一篇关于我们如何发现这些错误的文章。</p><h1 id="c3ac" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">装配跟踪</h1><p id="69ba" class="pw-post-body-paragraph iq ir hh is b it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm io ha bi translated">周一早上，<a class="ku kv ge" href="https://medium.com/u/85419ad6ecd1?source=post_page-----96c9e4ba8a6c--------------------------------" rel="noopener" target="_blank"> Nelson Osacky </a>打开一个pull请求，在Square Register Android的<strong class="is hi"> debug </strong>构建中启用RxJava <a class="ae ip" href="http://reactivex.io/RxJava/javadoc/rx/plugins/RxJavaHooks.html#enableAssemblyTracking()" rel="noopener ugc nofollow" target="_blank">汇编跟踪</a>。</p><blockquote class="ie"><p id="d65e" class="if ig hh bd ih ii kw kx ky kz la io dx translated">程序集跟踪通过报告失败的观察点是在哪里创建的，使得Rx调试更加容易。</p></blockquote><pre class="lb lc ld le lf lg jq lh li aw lj bi"><span id="a6a9" class="lk js hh jq b fi ll lm l ln lo">public class RegisterDevelopmentApp extends RegisterApp {<br/>  @Override public void onCreate() {<br/>    <strong class="jq hi">RxJavaHooks.enableAssemblyTracking();</strong><br/>    super.onCreate();<br/>  }<br/>}</span></pre><p id="6e22" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">根据<code class="du jn jo jp jq b">RxJavaHooks.enableAssemblyTracking()</code> Javadoc:</p><blockquote class="lu lv lw"><p id="8ef4" class="iq ir lx is b it lp iv iw ix lq iz ja ly lr jd je lz ls jh ji ma lt jl jm io ha bi translated">当源或操作符被实例化时，设置捕获当前stacktrace的钩子，将它保存在一个字段中以便调试，并改变传递的异常以保留此stacktrace。</p></blockquote><p id="e282" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">这里有一个例子(<a class="ae ip" href="https://mobile.twitter.com/dwursteisen/status/773842208164311040" rel="noopener ugc nofollow" target="_blank">感谢大卫</a>):</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="00b7" class="lk js hh jq b fi ll lm l ln lo">Observable.<em class="lx">just</em>(1, 2, 3)<br/>  .single()<br/>  .subscribe();</span></pre><p id="960f" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">该接收链出现故障:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="7e87" class="lk js hh jq b fi ll lm l ln lo">rx.exceptions.OnErrorNotImplementedException: Sequence contains too many elements<br/>  at ... lots of Rx internals<br/>  at rx.<strong class="jq hi">Observable.subscribe</strong>(Observable.java:9989)<br/>  at com.squareup.Example.test(Example.java:116)<br/>Caused by: java.lang.<strong class="jq hi">IllegalArgumentException: Sequence contains too many elements</strong><br/>  ... 38 more</span></pre><p id="fa35" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">当我们调用subscribe时会引发一个异常，所以stacktrace显示在subscribe时发生了错误<strong class="is hi">。我们试图理解错误消息，并弄清楚所有这些Rx内部类是关于什么的。</strong></p><p id="d0f0" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">让我们启用装配跟踪:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="f5ac" class="lk js hh jq b fi ll lm l ln lo">RxJavaHooks.<strong class="jq hi">enableAssemblyTracking()</strong>;<br/>Observable.just(1, 2, 3)<br/>  .single()<br/>  .subscribe();</span></pre><p id="4d30" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">最后我们得到了一个额外的原因:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="e9c5" class="lk js hh jq b fi ll lm l ln lo">rx.exceptions.OnErrorNotImplementedException: Sequence contains too many elements<br/>  at ... lots of Rx internals<br/>  at rx.Observable.subscribe(Observable.java:9989)<br/>  at com.squareup.Example.test(Example.java:116)<br/>  at ...<br/>Caused by: java.lang.IllegalArgumentException: Sequence contains too many elements<br/>  ... 38 more<br/>Caused by: rx.exceptions.AssemblyStackTraceException: <strong class="jq hi">Assembly trace</strong>:<br/>  at rx.Observable.create(Observable.java:98)<br/>  at rx.Observable.lift(Observable.java:251)<br/>  at rx.<strong class="jq hi">Observable.single</strong>(Observable.java:9337)<br/>  at com.squareup.Example.test(Example.java:115)</span></pre><p id="e880" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">现在很清楚，这一失败是由于创造了<code class="du jn jo jp jq b">single()</code>可观测性。<code class="du jn jo jp jq b">single()</code>期望源可观测物仅发射单一项目。</p><p id="07b1" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">让我们启用装配跟踪！</p><h1 id="5389" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">构建失败</h1><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="efa5" class="lk js hh jq b fi ll lm l ln lo">public class RegisterDevelopmentApp extends RegisterApp {<br/>  @Override public void onCreate() {<br/>    <strong class="jq hi">RxJavaHooks.enableAssemblyTracking();</strong><br/>    super.onCreate();<br/>  }<br/>}</span></pre><p id="2c52" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">啊哈，这个一行的拉请求破坏了我的团队写的一个UI测试。我看着失败的代码:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="ab7a" class="lk js hh jq b fi ll lm l ln lo">connectService.getClientSettings(clientId)<br/>  .subscribe(<br/>    (response) -&gt; { ... },<br/>    (throwable) -&gt; {<br/>      if (throwable instanceof RetrofitError) {<br/>        ...<br/>      } else {<br/>        <strong class="jq hi">Timber.d(throwable);</strong><br/>        <strong class="jq hi">throw new AssertionError("Should not happen", throwable);</strong><br/>      }<br/>    }<br/>  );</span></pre><p id="12fd" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">奇怪的是，一个翻新(1.x)调用应该只引发一个<code class="du jn jo jp jq b">RetrofitError</code>，而我们得到的是别的东西。以下是日志:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="e529" class="lk js hh jq b fi ll lm l ln lo">java.lang.IllegalStateException: Cause already initialized<br/>    at rx.internal.operators.OnSubscribeOnAssembly$OnAssemblySubscriber<br/>.onError(<strong class="jq hi">OnSubscribeOnAssembly.java:118</strong>)<br/>    at ...<br/>    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)<br/>Caused by: rx.exceptions.<strong class="jq hi">AssemblyStackTraceException</strong>: Assembly trace:<br/>    at ...<br/>    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)</span></pre><p id="e856" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated"><code class="du jn jo jp jq b">IllegalStateException</code>的实际堆栈跟踪丢失。</p><h1 id="5296" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">深入RxJava</h1><p id="5918" class="pw-post-body-paragraph iq ir hh is b it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm io ha bi translated">我看看<code class="du jn jo jp jq b">OnSubscribeOnAssembly.java</code> <a class="ae ip" href="https://github.com/ReactiveX/RxJava/blob/4ae4a40a2f493978851035e18a6159380f15573f/src/main/java/rx/internal/operators/OnSubscribeOnAssembly.java#L118" rel="noopener ugc nofollow" target="_blank">第118行</a>:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="849b" class="lk js hh jq b fi ll lm l ln lo">@Override public void onError(Throwable e) {<br/>  <strong class="jq hi">new AssemblyStackTraceException(</strong>stacktrace<strong class="jq hi">).attachTo(</strong>e<strong class="jq hi">);</strong><br/>  ...<br/>}</span></pre><p id="983b" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">呃。这个<code class="du jn jo jp jq b">AssemblyStackTraceException</code>是什么？</p><blockquote class="lu lv lw"><p id="8b0a" class="iq ir lx is b it lp iv iw ix lq iz ja ly lr jd je lz ls jh ji ma lt jl jm io ha bi translated">一个RuntimeException，它是无堆栈的，但通过跟踪操作符的程序集位置来保持文本堆栈跟踪。</p></blockquote><p id="3362" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">有意思。<code class="du jn jo jp jq b">AssemblyStackTraceException.attachTo()</code>是做什么的？</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="7f7c" class="lk js hh jq b fi ll lm l ln lo">public void attachTo(Throwable exception) {<br/>  for (;;) {<br/>    if (exception.getCause() == null) {<br/>      exception.initCause(this);<br/>      return;<br/>    }<br/>    exception = exception.getCause();<br/>  }<br/>}</span></pre><p id="eb42" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">每当一个<code class="du jn jo jp jq b">Observable</code>被创建时，<code class="du jn jo jp jq b">OnSubscribeOnAssembly</code>就会捕获一个堆栈跟踪并持有它。然后，当在相应的Rx链中抛出异常时，会在异常链的底部添加一个<code class="du jn jo jp jq b">AssemblyStackTraceException</code> <em class="lx"> </em>作为原因，并带有一个消息字符串，其中包含创建<code class="du jn jo jp jq b">Observable</code>的堆栈跟踪。整洁！</p><p id="3923" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">我们在最初的例子中看到了这样的结果:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="7a2a" class="lk js hh jq b fi ll lm l ln lo">rx.exceptions.OnErrorNotImplementedException: Sequence contains too many elements<br/>  at ... lots of Rx internals<br/>  at rx.Observable.subscribe(Observable.java:9989)<br/>  at com.squareup.Example.test(Example.java:116)<br/>  at ...<br/>Caused by: java.lang.IllegalArgumentException: Sequence contains too many elements<br/>  ... 38 more<br/>Caused by: rx.exceptions.AssemblyStackTraceException: <strong class="jq hi">Assembly trace</strong>:<br/>  at rx.Observable.create(Observable.java:98)<br/>  at rx.Observable.lift(Observable.java:251)<br/>  at rx.<strong class="jq hi">Observable.single</strong>(Observable.java:9337)<br/>  at com.squareup.Example.test(Example.java:115)</span></pre><h1 id="103b" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">原因已经初始化</h1><p id="5bb7" class="pw-post-body-paragraph iq ir hh is b it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm io ha bi translated">既然我已经理解了程序集跟踪是如何工作的，我再次查看日志:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="f956" class="lk js hh jq b fi ll lm l ln lo">java.lang.<strong class="jq hi">IllegalStateException: Cause already initialized</strong><br/>    at rx.internal.operators.OnSubscribeOnAssembly$OnAssemblySubscriber<br/>.onError(OnSubscribeOnAssembly.java:118)<br/>    at ...<br/>    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)<br/>Caused by: rx.exceptions.AssemblyStackTraceException: Assembly trace:<br/>    at ...<br/>    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)</span></pre><p id="ac4d" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">我仍然不知道这个<code class="du jn jo jp jq b">IllegalStateException</code>来自哪里，因为我没有它的堆栈。消息称<strong class="is hi">原因已经初始化</strong>，我们刚刚看到一段代码试图这样做:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="e2ab" class="lk js hh jq b fi ll lm l ln lo">public void attachTo(Throwable exception) {<br/>  for (;;) {<br/>    if (exception.getCause() == null) {<br/>      exception.<strong class="jq hi">initCause</strong>(this);<br/>      return;<br/>    }<br/>    exception = exception.getCause();<br/>  }<br/>}</span></pre><p id="2641" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">我打开<code class="du jn jo jp jq b">Throwable.initCause()</code>:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="0bb5" class="lk js hh jq b fi ll lm l ln lo">public void initCause(Throwable cause) {<br/> if (<strong class="jq hi">this.cause != this</strong>) {<br/>   throw new IllegalStateException("Cause already initialized");<br/> }<br/> this.cause = cause;<br/>}</span></pre><p id="42ef" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">Tada！我刚发现了我们的神秘例外。<code class="du jn jo jp jq b">cause</code>和<code class="du jn jo jp jq b">this</code>到底是怎么回事？让我们看看<code class="du jn jo jp jq b">Throwable</code>是如何构造的:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="3117" class="lk js hh jq b fi ll lm l ln lo">public class Throwable {<br/>  /**<br/>   * The throwable that caused this throwable to get thrown, or null<br/>   * if this throwable was not caused by another throwable, or if <br/>   * the causative throwable is unknown. <strong class="jq hi">If this field is equal to<br/>   * this throwable itself, it indicates that the cause of this<br/>   * throwable has not yet been initialized</strong>.<br/>   */<br/>  private Throwable <strong class="jq hi">cause = this</strong>;</span><span id="7f11" class="lk js hh jq b fi mf lm l ln lo">  public Throwable() {<br/>  }</span><span id="896c" class="lk js hh jq b fi mf lm l ln lo">  public Throwable(Throwable cause) {<br/>    this.cause = cause;<br/>  }<br/>}</span></pre><p id="fc8b" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">可以在没有原因的情况下构造一个<code class="du jn jo jp jq b">Throwable</code>，在这种情况下<code class="du jn jo jp jq b">cause</code>字段被设置为<code class="du jn jo jp jq b">this</code>以标记原因尚未初始化。然后，您可以稍后调用<code class="du jn jo jp jq b">initCause()</code>…但前提是原因尚未初始化。</p><blockquote class="ie"><p id="29c9" class="if ig hh bd ih ii kw kx ky kz la io dx translated">可抛出的原因只能设置一次。</p></blockquote><p id="9fd0" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm io ha bi translated">我们崩溃是因为我们在呼叫<code class="du jn jo jp jq b">initCause()</code>但是原因已经设定好了。让我们再看一下代码:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="196f" class="lk js hh jq b fi ll lm l ln lo">public void attachTo(Throwable exception) {<br/>  for (;;) {<br/>    if (<strong class="jq hi">exception.getCause() == null</strong>) {<br/>      exception.initCause(this);<br/>      return;<br/>    }<br/>    exception = exception.getCause();<br/>  }<br/>}</span></pre><p id="bffb" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">我们将沿着异常链往下走，直到找到一个有<code class="du jn jo jp jq b">null</code>原因的异常。然后我们在上面调用<code class="du jn jo jp jq b">initCause()</code>。<code class="du jn jo jp jq b">getCause()</code>什么时候返回null？</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="096c" class="lk js hh jq b fi ll lm l ln lo">public class Throwable {<br/>  /**<br/>   * Returns the cause of this throwable or <strong class="jq hi">null if the</strong><br/>   * <strong class="jq hi">cause is nonexistent or unknown</strong>.<br/>   */<br/>  public Throwable getCause() {<br/>    return (cause == this ? null : cause);<br/>  }<br/>}</span></pre><p id="c7ac" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">等一下。原因可能是不存在的<strong class="is hi">或</strong>也可能是未知的。那是两码事！</p><blockquote class="ie"><p id="0a48" class="if ig hh bd ih ii kw kx ky kz la io dx translated">当原因字段设置为自身时，原因不存在。当原因字段设置为空时，原因未知。</p></blockquote><p id="a2b0" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm io ha bi translated">就Java代码而言，区别如下:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="9a30" class="lk js hh jq b fi ll lm l ln lo">new Throwable(); // nonexistent cause (not initialized)<br/>Throwable cause = null;<br/>new Throwable(cause); // unknown cause (initialized to null)</span></pre><p id="2ce1" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">在这两种情况下，<code class="du jn jo jp jq b">getCause()</code>都返回<code class="du jn jo jp jq b">null</code>。但是，如果原因未知(初始化为<code class="du jn jo jp jq b">null</code>，那么<code class="du jn jo jp jq b">initCause()</code>会抛出一个<code class="du jn jo jp jq b">IllegalStateException</code>。</p><h1 id="835b" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">注定要失败的努力</h1><p id="438a" class="pw-post-body-paragraph iq ir hh is b it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm io ha bi translated">能否修复RxJava，使其在原因未知的情况下不调用<code class="du jn jo jp jq b">initCause()</code>？嗯，事实证明，这是没有办法检查的。</p><blockquote class="ie"><p id="7493" class="if ig hh bd ih ii kw kx ky kz la io dx translated">JDK没有提供API来确定可抛出的原因是不存在还是未知。</p></blockquote><p id="46fd" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm io ha bi translated">唯一的选择是尝试报告失败。我在RxJava中打开一个<a class="ae ip" href="https://github.com/ReactiveX/RxJava/pull/4740" rel="noopener ugc nofollow" target="_blank">拉请求</a>。</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="d6e4" class="lk js hh jq b fi ll lm l ln lo">public void attachTo(Throwable exception) {<br/>  for (;;) {<br/>    if (exception.getCause() == null) {<br/>      try {<br/>        exception.initCause(this);<br/>      } <strong class="jq hi">catch (IllegalStateException ignored)</strong> {<br/>        onError(new RuntimeException("Unknown cause", exception);<br/>      }<br/>      return;<br/>    }<br/>    exception = exception.getCause();<br/>  }<br/>}</span></pre><p id="7977" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">在阅读了Javadoc之后，我意识到<code class="du jn jo jp jq b">initCause()</code>的存在是为了向后兼容的问题，在这种情况下，遗留异常类缺少一个构造函数。</p><blockquote class="ie"><p id="0aad" class="if ig hh bd ih ii kw kx ky kz la io dx translated">initCause()应该只在构造一个异常后调用，它不是为向异常链添加元数据而设计的。</p></blockquote><p id="bf5a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm io ha bi translated">虽然汇编跟踪似乎是建立在一个黑客，好处显然超过了这种未知原因的边缘情况的缺点。</p><h1 id="f6b7" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">根本原因分析</h1><p id="52bd" class="pw-post-body-paragraph iq ir hh is b it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm io ha bi translated">既然RxJava在程序集跟踪失败时有了适当的错误报告，我就可以弄清楚触发这次调查的UI测试失败中发生了什么:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="7f22" class="lk js hh jq b fi ll lm l ln lo">connectService.getClientSettings(clientId)<br/>    .subscribe()</span></pre><p id="d0a7" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">我们正在测试一个HTTP错误场景，所以retrieval创建了一个带有<code class="du jn jo jp jq b">RetrofitError.httpError()</code>的异常:</p><pre class="mb mc md me fd lg jq lh li aw lj bi"><span id="78b3" class="lk js hh jq b fi ll lm l ln lo">public class RetrofitError extends RuntimeException {<br/>  public static RetrofitError httpError(Response response) {<br/>    return new RetrofitError(response, <strong class="jq hi">null</strong>);<br/>  }</span><span id="f5ae" class="lk js hh jq b fi mf lm l ln lo">  RetrofitError(Response response, Throwable exception) {<br/>    super(<strong class="jq hi">exception</strong>);<br/>    this.response = response;<br/>  }<br/>}</span></pre><p id="b287" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">答对了。<code class="du jn jo jp jq b">RetrofitError.httpError()</code> <em class="lx"> </em>创建一个原因未知的异常，这就是装配跟踪失败的原因。</p><p id="f0ba" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated"><code class="du jn jo jp jq b">RetrofitError</code>只存在于改型1.x中，所以我提交了一个<a class="ae ip" href="https://github.com/square/retrofit/pull/2057" rel="noopener ugc nofollow" target="_blank"> pull请求</a>在1.x分支上修复它。不会有新的公开发布，因为Retrofix 2.x现在已经出来两年了。</p><p id="1cb1" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">Square Register是我们最后一个没有迁移到改型2的应用程序。我们将很快完成迁移工作。与此同时，我们将使用一个改进1.x的内部版本。</p><h1 id="568c" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">收场白</h1><p id="3d93" class="pw-post-body-paragraph iq ir hh is b it kp iv iw ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm io ha bi translated">调查一次UI测试失败让我们踏上了一段有趣的旅程！今天，我们了解到:</p><ul class=""><li id="bdc3" class="mg mh hh is b it lp ix lq jb mi jf mj jj mk io ml mm mn mo bi translated">一个<code class="du jn jo jp jq b">Throwable</code>可以有一个不存在或未知的原因；那是两个不同的东西，没有API来判断哪个是哪个。</li><li id="b121" class="mg mh hh is b it mp ix mq jb mr jf ms jj mt io ml mm mn mo bi translated">程序集跟踪使Rx调试更容易，并以一种非预期的方式使用<code class="du jn jo jp jq b">Throwable</code> API将元数据附加到stracktrace。</li><li id="f939" class="mg mh hh is b it mp ix mq jb mr jf ms jj mt io ml mm mn mo bi translated">将<code class="du jn jo jp jq b">null</code>作为一个原因传递给<code class="du jn jo jp jq b">Throwable</code>构造函数看起来是无害的，但多年后会导致微妙的错误。</li></ul><p id="e34c" class="pw-post-body-paragraph iq ir hh is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm io ha bi translated">欢迎提供更多见解或提出问题！</p></div></div>    
</body>
</html>