<html>
<head>
<title>Remote and Programmatic Manipulation of Docker Containers from a Node application using Dockerode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dockerode从节点应用程序远程编程操作Docker容器</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/remote-and-programmatic-manipulation-of-docker-containers-from-a-node-application-using-dockerode-903228bdff06?source=collection_archive---------1-----------------------#2018-04-19">https://medium.com/oracledevs/remote-and-programmatic-manipulation-of-docker-containers-from-a-node-application-using-dockerode-903228bdff06?source=collection_archive---------1-----------------------#2018-04-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/cf637011b729f91f68c5b182a3dea2b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uup8bu3gf8jmYkbO."/></div></div></figure><p id="2a60" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在以前的文章中，我已经讨论过在智能测试策略中使用Docker容器，方法是创建一个包含应用程序基线和所需测试设置(例如测试数据)的容器映像。对于每个测试，不需要做复杂的设置动作和复杂的拆卸步骤，只需要在开始时旋转一个容器，然后在结束时扔掉它。</p><p id="3a97" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我已经展示了如何通过命令行实现这一点——但这当然不是一个可行的过程。在本文中，我将简要介绍容器的编程操作。通过从远程客户端提供对Docker守护程序API的访问(步骤1)和利用npm包Dockerode(步骤2 ),从一个简单的节点应用程序创建、启动和停止容器，以及构建、配置、检查、暂停容器和以其他方式进行操作变得非常简单。这为构建作业以编程方式运行测试开辟了道路，方法是启动容器，对该容器运行测试，并在测试后终止和移除该容器。协同工作的容器组合也可以轻松管理。</p><p id="4281" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我说过，这篇文章只是一个非常轻量级的介绍。</p><h1 id="3f14" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">向远程HTTP客户端公开Docker守护程序API</h1><p id="c65e" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">对我来说最长的一步是暴露Docker守护进程API。Docker的后续版本对此使用了不同的配置，显然不同的Linux发行版也有不同的方法。很高兴找到这篇文章:<a class="ae kq" href="https://www.ivankrizsan.se/2016/05/18/enabling-docker-remote-api-on-ubuntu-16-04" rel="noopener ugc nofollow" target="_blank">https://www . ivankrizsan . se/2016/05/18/enabling-docker-remote-api-on-Ubuntu-16-04</a>描述了作为Docker主机的Ubuntu 16.x如何启用对API的访问。</p><p id="9915" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编辑文件/lib/systemd/system/docker . service—将-H tcp://0.0.0.0:4243添加到描述如何启动Docker守护程序的条目中，以便让它在端口4243监听传入的请求(注意:也可以使用其他端口)。</p><p id="77ab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Reload (systemctl daemon-reload)应用更改后的文件配置</p><p id="cd9a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">重新启动docker服务:服务Docker重新启动</p><p id="d1eb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们在做生意。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/576619d32a89b65f623e4ca5d6c9948d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x5WLD3RyuQ-FlpvG."/></div></div></figure><p id="4160" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">简单检查一下端口4243上的HTTP请求是否确实被接收和处理了:在Docker主机上执行以下命令:</p><p id="48cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">curl<a class="ae kq" href="http://localhost:4243/version" rel="noopener ugc nofollow" target="_blank">http://localhost:4243/version</a></p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/96a080a77ca8bd5751b8e645f75c3623.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hyz0c3lUigc36tS9."/></div></div></figure><p id="a479" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一步是实际的远程访问。从一台可以成功ping通Docker主机的机器上运行的浏览器——在我的例子中，这是由vagger启动的虚拟机器VM，其IP地址为192.168.188.108，如Vagrantfile中所定义的那样——打开这个URL:<a class="ae kq" href="http://192.168.188.108:4243/version" rel="noopener ugc nofollow" target="_blank">http://192 . 168 . 188 . 108:4243/version</a>。结果应该与此类似:</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/3b5499d524a36a9788145d6613fb3308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nXQpmAB5inA6GrYG."/></div></div></figure><h1 id="1b27" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">和多克罗德一起去吧</h1><p id="4eae" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">开始使用npm软件包Dockerode与任何其他npm软件包没有什么不同。因此，创建一个可以在远程Docker主机中列出、启动、检查和停止容器的简单节点应用程序的步骤非常简单:</p><p id="1bc1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用npm init为新的节点应用程序创建框架</p><p id="d965" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用npm安装docker ode --保存</p><p id="b0db" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">检索Dockerode并在package.json中创建依赖项。</p><p id="6ff2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">创建文件index.js .定义Docker主机IP地址(在我的例子中是192.168.188.108)和Docker守护进程端口(在我的例子中是4243)并编写代码与Docker主机交互。这段代码将列出所有的容器。然后，它将检查、启动和停止一个特定的容器(标识符以db8开头)。这个容器恰好运行一个Oracle数据库——尽管这与本文无关。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2ade" class="la jo hh kw b fi lb lc l ld le">var Docker = require('dockerode'); <br/>var dockerHostIP = "192.168.188.108" <br/>var dockerHostPort = 4243 <br/>var docker = new Docker({ host: dockerHostIP, port: dockerHostPort }); <br/>docker.listContainers({ all: true }, function (err, containers) {<br/>  console.log('Total number of containers: ' + containers.length);<br/>  containers.forEach(function (container) { <br/>     console.log(`Container ${container.Names} - current status ${container.Status} - based on image ${container.Image}`) <br/>  }) <br/>}); <br/>async function startStop(containerId) { <br/>  var container = await docker.getContainer(containerId) <br/>  try { <br/>    var data = await container.inspect() <br/>    console.log("Inspected container " + JSON.stringify(data)) <br/>    var started = await container.start(); <br/>    console.log("Started "+started) <br/>    var stopped = await container.stop(); <br/>    console.log("Stopped "+stopped) <br/>  } catch (err) { console.log(err); <br/>    } <br/>} //startStop</span><span id="0113" class="la jo hh kw b fi lf lc l ld le">//invoke function <br/>startStop('db8')</span></pre><p id="29b1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Visual Studio代码中运行此函数的输出如下所示:</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/bba60e05eab44bf814cce4d560100f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SgZGhu-k5sYYeJ3k."/></div></div></figure><p id="e07f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">而且动作可以在Docker主机上这样追踪(证明是真的…)</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/f5e8e481e5b8d5be451ffa05d84d8235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9L9DAsKS2-gjnTv9."/></div></div></figure><h1 id="ff00" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">资源</h1><p id="b93b" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">Ivan Krizsan关于在Ubuntu 16.x上配置Docker守护进程的文章——我的生活更安全:<a class="ae kq" href="https://www.ivankrizsan.se/2016/05/18/enabling-docker-remote-api-on-ubuntu-16-04" rel="noopener ugc nofollow" target="_blank">https://www . ivankrizsan . se/2016/05/18/enabling-Docker-remote-API-on-Ubuntu-16-04</a></p><p id="9fae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Dockerode的GitHub Repo示例及更多:【https://github.com/apocas/dockerode T4】</p><p id="b619" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在DockerCon 2016上的演示给了我使用Dockerode的灵感:<a class="ae kq" href="https://www.youtube.com/watch?v=1lCiWaLHwxo" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=1lCiWaLHwxo</a></p><p id="2473" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于配置守护进程的Docker文档—<a class="ae kq" href="https://docs.docker.com/install/linux/linux-postinstall/#configure-where-the-docker-daemon-listens-for-connections" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/install/Linux/Linux-post install/# configure-where-the-docker-Daemon-listen-for-connections</a></p><p id="b6eb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae kq" href="https://technology.amis.nl/tag/api/" rel="noopener ugc nofollow" target="_blank"> api </a> <a class="ae kq" href="https://technology.amis.nl/tag/container/" rel="noopener ugc nofollow" target="_blank">容器</a> <a class="ae kq" href="https://technology.amis.nl/tag/daemon/" rel="noopener ugc nofollow" target="_blank">守护进程</a><a class="ae kq" href="https://technology.amis.nl/tag/docker/" rel="noopener ugc nofollow" target="_blank">docker</a><a class="ae kq" href="https://technology.amis.nl/tag/dockerode/" rel="noopener ugc nofollow" target="_blank">docker ode</a><a class="ae kq" href="https://technology.amis.nl/tag/http/" rel="noopener ugc nofollow" target="_blank">http</a><a class="ae kq" href="https://technology.amis.nl/tag/node/" rel="noopener ugc nofollow" target="_blank">节点</a> <a class="ae kq" href="https://technology.amis.nl/tag/programmatic/" rel="noopener ugc nofollow" target="_blank">程序化</a></p></div><div class="ab cl lg lh go li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ha hb hc hd he"><p id="fc46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ln">原载于2018年4月19日</em><a class="ae kq" href="https://technology.amis.nl/2018/04/19/remote-and-programmatic-manipulation-of-docker-containers-from-a-node-application-using-dockerode/" rel="noopener ugc nofollow" target="_blank"><em class="ln">technology . amis . nl</em></a><em class="ln">。</em></p></div></div>    
</body>
</html>