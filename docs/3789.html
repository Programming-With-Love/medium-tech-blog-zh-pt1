<html>
<head>
<title>Facade Design Pattern — Automation Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">外观设计模式——自动化测试</h1>
<blockquote>原文：<a href="https://medium.com/globant/facade-design-pattern-automation-testing-5a19e48883eb?source=collection_archive---------0-----------------------#2021-11-19">https://medium.com/globant/facade-design-pattern-automation-testing-5a19e48883eb?source=collection_archive---------0-----------------------#2021-11-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8e01fa2f7273d65b3ba05afc4fed0ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ybLoxAch2UZCegt4T1ciw.png"/></div></div></figure><h1 id="bb94" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">什么是设计模式:</h1><p id="6edf" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">设计模式是帮助我们将项目规划转化为高效结构的模块。对于任何自动化测试框架来说，实现正确的设计模式对于实现代码的可读性、可靠性和可维护性是非常重要的。</p><p id="a0a3" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi">设计模式的类型:</strong></p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/50176ecf64f034c2df762489d1faf79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6Im4a6Etb7vyZpBLDrGMQ.png"/></div></div></figure><p id="98b8" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在自动化测试中，常用的设计模式有<br/> 1)页面对象模型</p><p id="adef" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">2)工厂设计模式</p><p id="74d8" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">3)立面图案</p><p id="3961" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">4)单例模式</p><p id="04f9" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">5)流畅的页面对象模型</p><p id="2fcf" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi">在这篇博客中，我们将讨论Facade设计模式，它有助于轻松、可重用地实现复杂而冗长的用户操作。</strong></p><p id="1952" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi">什么是立面设计模式？</strong></p><p id="c9cb" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">立面模型属于结构设计模式。它建议使用简单的接口来实现复杂/冗长的代码。当在自动化中实现时，我们设计一个facade类，它使用一个页面对象模型来实现组合在不同页面上执行的动作的方法。</p><p id="3e92" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">再说说网购。作为一名客户，当我试图购买一件商品时，我需要浏览多个页面来输入送货地址、账单地址、付款信息、审核订单并最终下订单等。作为一名顾客，我唯一看到的是我的订单被保存了地址和支付信息，这对我来说是一个门面。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kv"><img src="../Images/08a3e6d6ceccf79c8d737ef7bfe77a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3QnQLe927wXoRb3388ROKA.png"/></div></div></figure><p id="7c73" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在自动化中，这种设计模式可以被看作是对页面对象模型的扩展，以创建不那么冗长、更简单和可读性更高的测试用例。</p><p id="9a17" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">我们可以通过下面的例子来理解这个设计。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kv"><img src="../Images/08a3e6d6ceccf79c8d737ef7bfe77a4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3QnQLe927wXoRb3388ROKA.png"/></div></div></figure><p id="db9a" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi">这里我们有:</strong></p><ol class=""><li id="007d" class="kw kx hh jp b jq kl ju km jy ky kc kz kg la kk lb lc ld le bi translated">测试应用程序中不同页面的页面对象。</li><li id="8874" class="kw kx hh jp b jq lf ju lg jy lh kc li kg lj kk lb lc ld le bi translated">一个facade类，它组合了前面提到的页面对象的动作。</li><li id="e6ba" class="kw kx hh jp b jq lf ju lg jy lh kc li kg lj kk lb lc ld le bi translated">测试类，它们将与facade交互，只是为了在UI上完成动作。</li></ol><p id="1e78" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi">我们为什么需要门面？</strong></p><p id="c132" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">不断增加的测试自动化覆盖率和复杂的测试应用程序通常会导致冗长且不可维护的自动化测试。</p><p id="4c5d" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">示例:假设许多测试用例需要在多个页面上执行一系列操作，以到达测试范围开始的特定页面。</p><p id="8570" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">为了理解这一点，让我们以一个在线购物体验为例，作为一个用户，我想验证我的订单历史并与之交互。</p><p id="fe8d" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi">不使用Facade模式实现:</strong></p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/1cfcde25297aef9231850b638b2bea90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yo2m48NMZ996WY17C8f7Aw.png"/></div></div></figure><p id="87b0" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">上面这段代码的缺点是:</p><ul class=""><li id="e16e" class="kw kx hh jp b jq kl ju km jy ky kc kz kg la kk ll lc ld le bi translated">测试变得太长</li><li id="dc44" class="kw kx hh jp b jq lf ju lg jy lh kc li kg lj kk ll lc ld le bi translated">如果在UI中引入了任何附加页面以到达最终页面，那么实现该流程的所有测试都需要更新。</li></ul><p id="fc98" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">例如，在上面的例子中，在点击订单历史链接之后，如果我们需要在导航到另一个页面之前执行一些操作(例如，选择下订单的时间范围),那么我们将不得不更新两个测试，这也增加了冗余代码行。</p><p id="1ba0" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi">使用Facade模式实现:</strong></p><p id="923b" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">我们可以通过在测试自动化框架中使用Facade模型来避免这种情况。作为一名QA工程师，我需要在我的facade类中适应这种变化，并且所有实现流程的测试都将有有效的变化。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lm"><img src="../Images/15228ab654b2e747c7c21f39537302df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tWa_vLSEXRGz-ahS_nI2UQ.png"/></div></div></figure><p id="4207" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi">立面设计模式的优势:</strong></p><ul class=""><li id="6944" class="kw kx hh jp b jq kl ju km jy ky kc kz kg la kk ll lc ld le bi translated">它提供了每个层次的用户操作所需的入口点。</li><li id="e454" class="kw kx hh jp b jq lf ju lg jy lh kc li kg lj kk ll lc ld le bi translated">当实现复杂的操作时，它增加了代码的可读性。</li><li id="9876" class="kw kx hh jp b jq lf ju lg jy lh kc li kg lj kk ll lc ld le bi translated">测试将会变得简单和简短，因为我们将facade类用于动作。</li><li id="0ac4" class="kw kx hh jp b jq lf ju lg jy lh kc li kg lj kk ll lc ld le bi translated">由于Facade是一个结构设计变更，它可以很容易地与任何现有的模式和/或方法集成，如TDD、BDD等。</li></ul><p id="5b00" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">为了理解这些优势，让我们考虑另一个网上购物体验的例子。作为最终用户，我想购买一件商品，并提供我对网站整体购物体验的反馈。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ln"><img src="../Images/9941d1a2d1dbf062dae12ddac916fd78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmFQB5WJdmnfjzRqqdwgYw.png"/></div></div></figure><p id="8826" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi">立面缺点:</strong></p><ul class=""><li id="cc71" class="kw kx hh jp b jq kl ju km jy ky kc kz kg la kk ll lc ld le bi translated">增加了一个额外的间接层，这可能会影响性能</li><li id="8336" class="kw kx hh jp b jq lf ju lg jy lh kc li kg lj kk ll lc ld le bi translated">如果对于任何系统改变，类的结构被改变，那么外观层也需要被更新。</li></ul><p id="8ab3" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi">总结:</strong></p><p id="ce6a" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">使用设计模式，增加代码的有效性和自动化。同时，它减少了复杂性和维护工作。在门面模式的情况下，工作量和效率可以直接与LOC矩阵相关联。</p><p id="43db" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">例如，对于订单历史场景:</p><p id="1d59" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">无正面的~ 17</p><p id="d9a8" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">与正面锁定~ 14</p><p id="3399" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">我们能够将LOC降低约17%,相应地，我们的维护工作量也会减少。</p><p id="3ebd" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在Facade模式的帮助下，我们可以将复杂的实现与多个动作结合起来，并提供一个易于访问的简单接口来实现相同的操作。</p></div></div>    
</body>
</html>