<html>
<head>
<title>Python loops comparison and performance testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python循环比较和性能测试</h1>
<blockquote>原文：<a href="https://medium.com/duomly-blockchain-online-courses/python-loops-comparison-and-performance-testing-9240e7589b82?source=collection_archive---------3-----------------------#2019-08-08">https://medium.com/duomly-blockchain-online-courses/python-loops-comparison-and-performance-testing-9240e7589b82?source=collection_archive---------3-----------------------#2019-08-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d0703d79a7ca1b8227d44f5069176d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pnX8aGFnLaCMCAp-5Gm6Mg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming courses online</a></figcaption></figure><p id="ba25" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文最初发表于:<a class="ae it" href="https://www.blog.duomly.com/loops-in-python-comparison-and-performance/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/loops-in-python-comparison-and-performance/</a></p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="b5b7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Python是当今最流行的编程语言之一。它是一种解释型的高级语言，语法优雅易读。然而，Python通常比Java、C#、尤其是C、C++或Fortran慢得多。有时，性能问题和瓶颈可能会严重影响应用程序的可用性。</p><p id="436f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">幸运的是，在大多数情况下，都有提高Python程序性能的解决方案。开发人员可以选择提高他们代码的速度。例如，一般的建议是使用优化的Python内置或第三方例程，通常用C或Cython编写。此外，使用局部变量比使用全局变量更快，所以在循环之前将全局变量复制到局部变量是一个好习惯。诸如此类。</p><p id="2ff0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，总是有可能用C、C++或Cython编写自己的Python函数，从应用程序调用它们并替换Python瓶颈例程。但这通常是一种极端的解决方案，实践中很少需要。</p><p id="1e7b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用Python循环时经常会出现性能问题，尤其是在大量迭代的情况下。有许多有用的技巧可以改进您的代码并使其运行得更快，但这超出了本文的范围。</p><p id="83f6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文比较了几种方法在对两个序列按元素求和时的性能:</p><ul class=""><li id="1771" class="jz ka hh iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated">使用while循环</li><li id="f391" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">使用for循环</li><li id="cc53" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">对列表理解使用for循环</li><li id="8fa7" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">使用第三方库编号</li></ul><p id="7704" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，性能并不是开发软件时唯一关心的问题。此外，根据Donald Knuth在《计算机编程艺术》中的观点，“过早优化是编程中所有罪恶(或者至少是大部分罪恶)的根源”。毕竟，正如蒂姆·彼得斯在《Python之禅》中所言，“可读性很重要”。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="accb" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">问题陈述</h1><p id="d327" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">我们将尝试对两个序列进行元素求和。换句话说，我们将获得两个相同大小的序列(列表或数组),并创建第三个序列，其中的元素是通过将输入中的相应元素相加而获得的。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="2d51" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">准备</h1><p id="29bf" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">我们将导入Python内置的包random，并生成一个包含100，000个伪随机数(从0到99，包括0和99)的列表r:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="6f90" class="lz ko hh lv b fi ma mb l mc md">import random<br/>r = [random.randrange(100) for _ in range(100_000)]</span></pre><p id="9986" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们还将使用第三方包numpy，所以让我们导入它:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="0b38" class="lz ko hh lv b fi ma mb l mc md">import numpy as np</span></pre><p id="d216" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们准备好出发了！</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="081c" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">简单循环</h1><p id="eeff" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">让我们首先看看一些简单的Python循环。</p><p id="7af9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">使用纯Python </strong></p><p id="cd61" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将从两个各有1000个元素的列表开始。整数变量n表示每个列表的长度。通过从r中随机选择n个元素来获得列表x和y:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="70c0" class="lz ko hh lv b fi ma mb l mc md">n = 1_000<br/>x, y = random.sample(r, n), random.sample(r, n)</span></pre><p id="5db0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们来看看得到一个有n个元素的新列表z需要多少时间，每个元素都是来自x和y的对应元素之和。</p><p id="3ab0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将首先测试while循环的性能:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="b21b" class="lz ko hh lv b fi ma mb l mc md">%%timeit<br/>i, z = 0, []<br/>while i &lt; n:<br/>    <!-- -->z.append(x[i] + y[i])<br/>    <!-- -->i += 1</span></pre><p id="ed58" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出是:</p><p id="9fd7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每圈160秒±1.44秒(平均标准偏差戴夫。7次运行，每次10000个循环)</p><p id="80d6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意，timeit的输出取决于许多因素，每次都可能不同。</p><p id="4006" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Python中的for循环更适合这种情况，即遍历集合、迭代器、生成器等等。让我们看看它是如何工作的:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="ad07" class="lz ko hh lv b fi ma mb l mc md">%%timeit<br/>z = []<br/>for i in range(n):<br/>    <!-- -->z.append(x[i] + y[i])</span></pre><p id="680e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出是:</p><p id="095b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">每圈122 s 188 ns(平均标准偏差。戴夫。7次运行，每次10000个循环)</strong></p><p id="849c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，与while相比，for循环更快，但也更优雅。</p><p id="9aeb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">列表理解非常类似于普通的for循环。它们适用于简单的案例(比如这个)。除了更紧凑之外，它们通常还会稍微快一些，因为减少了一些开销:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="bc6c" class="lz ko hh lv b fi ma mb l mc md">%%timeit<br/>z = [x[i] + y[i] for i in range(n)</span></pre><p id="2af4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出是:</p><p id="148c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">每圈87.2秒490纳秒(平均标准差。戴夫。7次运行，每次10000个循环)</strong></p><p id="2ed2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请记住，当你需要循环时，你不能在所有情况下都应用列表理解。一些更复杂的情况需要普通的for甚至while循环。</p><p id="efc2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">使用Python和NumPy </strong></p><p id="c692" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">numpy是一个第三方Python库，通常用于数值计算。特别适合操作数组。它提供了许多有用的例程来处理数组，但也允许编写紧凑而优雅的代码，而没有循环。</p><p id="e553" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">实际上，循环以及其他对性能至关重要的操作都是在底层的numpy中实现的。这使得numpy例程比纯Python代码快得多。另一个优势是numpy处理变量和类型的方式。</p><p id="212e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们首先使用Python整数x和y的列表来创建相应的64位整数的numpy数组:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="2f5a" class="lz ko hh lv b fi ma mb l mc md">x_, y_ = np.array(x, dtype=np.int64), np.array(y, dtype=np.int64)</span></pre><p id="97c1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">按元素对两个numpy数组x_和y_求和就像x_ + y_一样简单。但是让我们检查一下性能:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="23fd" class="lz ko hh lv b fi ma mb l mc md">%%timeit<br/>z = x_ + y_</span></pre><p id="32f6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出是:</p><p id="442a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">每循环1.03秒±5.09纳秒(平均标准偏差。戴夫。7次运行，每次1000000个循环)</strong></p><p id="2ae5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这几乎比我们使用列表理解时快了85倍。而且代码极其简单优雅。numpy数组是处理大型数组的更好选择。数据越大，性能优势通常越大。</p><p id="7cc9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">可能会更好。如果我们同意使用32位整数而不是64位整数，在某些情况下，我们可以节省内存和时间:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="dc7d" class="lz ko hh lv b fi ma mb l mc md">x_, y_ = np.array(x, dtype=np.int32), np.array(y, dtype=np.int32)</span></pre><p id="3de2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以像以前一样添加这两个数组:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="4bdf" class="lz ko hh lv b fi ma mb l mc md">%%timeit<br/>z = x_ + y_</span></pre><p id="16c0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出是:</p><p id="c930" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">每环路814纳秒±5.8纳秒(平均标准偏差戴夫。7次运行，每次1000000个循环)</strong></p><p id="9678" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当n较大，即10_000和100_000时获得的结果如下表所示。它们显示了相同的关系，在这种情况下，使用numpy时性能会有更大的提升。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="15d1" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">嵌套循环</h1><p id="f0d4" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">现在让我们比较一下嵌套的Python循环。</p><p id="3b7f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">使用纯Python </strong></p><p id="a448" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将再次使用两个名为x和y的列表。它们中的每一个将包含100个具有1.000个伪随机整数元素的内部列表。因此，x和y实际上将表示具有100行和1.000列的矩阵:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="6a59" class="lz ko hh lv b fi ma mb l mc md">m, n = 100, 1_000<br/>x = [random.sample(r, n) for _ in range(m)]<br/>y = [random.sample(r, n) for _ in range(m)]</span></pre><p id="6f1f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看使用两个嵌套的while循环添加它们的性能:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="dacf" class="lz ko hh lv b fi ma mb l mc md">%%timeit<br/>i, z = 0, []<br/>while i &lt; m:<br/>    <!-- -->j, z_ = 0, []<br/>    <!-- -->while j &lt; n:<br/>        <!-- -->z_.append(x[i][j] + y[i][j])<br/>        <!-- -->j += 1<br/>    <!-- -->z.append(z_)<br/>    <!-- -->i += 1</span></pre><p id="676c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出是:</p><p id="3573" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每圈19.7毫秒271秒(平均标准时间戴夫。7次运行，每次100个循环) <br/>同样，我们可以通过嵌套for循环获得一些性能提升:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="976d" class="lz ko hh lv b fi ma mb l mc md">%%timeit<br/>z = []<br/>for i in range(m):<br/>    <!-- -->z_ = []<br/>    <!-- -->for j in range(n):<br/>        <!-- --> z_.append(x[i][j] + y[i][j])<br/>    <!-- -->z.append(z_)</span></pre><p id="8559" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出是:</p><p id="ec62" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">每循环16.4毫秒303秒(平均标准时间戴夫。7次运行，每次100个循环)</strong> <br/>在某些情况下，嵌套的for循环可以与lists comprehensions一起使用，这带来了一个额外的好处:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="626a" class="lz ko hh lv b fi ma mb l mc md">%%timeit<br/>z = [[x[i][j] + y[i][j] for j in range(n)] for i in range(m)]</span></pre><p id="e13a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出是:</p><p id="67f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">每循环12.1毫秒99.4秒(平均标准时间戴夫。7次运行，每次100个循环)</strong></p><p id="25c4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以看到，在嵌套循环的情况下，列表理解比普通for循环更快，而for循环比while循环更快。</p><p id="be42" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，每个列表中有100.000 (100×1.000)个整数元素。这个例子比有100.000个元素和一个循环的例子稍慢。这是所有三种方法(列表理解、普通for和while循环)的结论。</p><p id="94db" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">使用Python和NumPy </strong></p><p id="b2f1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">numpy非常适合处理多维数组。让我们使用x和y来创建相应的64位整数numpy数组:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="80e5" class="lz ko hh lv b fi ma mb l mc md">x_, y_ = np.array(x, dtype=np.int64), np.array(y, dtype=np.int64)</span></pre><p id="fb7c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们来看看性能:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="eaad" class="lz ko hh lv b fi ma mb l mc md">%%timeit<br/>z = x_ + y_</span></pre><p id="af1e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出是:</p><p id="0e91" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">每循环69.9秒909纳秒(平均标准偏差戴夫。7次运行，每次循环10000次)</strong> <br/>这比列表理解快173倍。但如果我们使用32位整数，速度可能会更快:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="c884" class="lz ko hh lv b fi ma mb l mc md">x_, y_ = np.array(x, dtype=np.int32), np.array(y, dtype=np.int32)</span></pre><p id="c627" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">性能检查如前所述:</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="b490" class="lz ko hh lv b fi ma mb l mc md">%%timeit<br/>z = x_ + y_</span></pre><p id="cb70" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出是:</p><p id="fe6c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">每循环34.3秒44.6纳秒(平均标准偏差。戴夫。7次运行，每次10000个循环)</strong> <br/>比64位整数快两倍。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="f6c0" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结果摘要</h1><p id="b626" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">下表总结了获得的结果:</p><figure class="lq lr ls lt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es me"><img src="../Images/10c045c385346574c3d6be06d7f0b5b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUSll5xyyUsXRpFfuWnxsw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming online courses</a></figcaption></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><h1 id="dee4" class="kn ko hh bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="9ad9" class="pw-post-body-paragraph iu iv hh iw b ix ll iz ja jb lm jd je jf ln jh ji jj lo jl jm jn lp jp jq jr ha bi translated">本文比较了Python循环在元素级添加两个列表或数组时的性能。结果表明，列表理解比普通for循环快，而for循环又比while循环快。在这三种情况下，简单循环都比嵌套循环略快。</p><p id="f47d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">numpy提供的例程和操作符可以大大减少代码量，提高执行速度。这在处理一维或多维数组时特别有用。</p><p id="e186" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请记住，这里得到的结论或结果之间的关系并不是在所有情况下都适用、有效或有用的！它们是用于说明的。处理低效率的正确方法是发现瓶颈并执行自己的测试。</p><figure class="lq lr ls lt fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/dc19556cc6f07c2b5bf96731ca92ef6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*km4MpFktOL_hJnb-.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">Duomly — programming online courses</a></figcaption></figure><p id="1e7e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的阅读。</p><p id="b55f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文由我们的队友米尔科提供。</p></div></div>    
</body>
</html>