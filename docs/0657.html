<html>
<head>
<title>Seamless account transfers with Block Store</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Block Store实现无缝转账</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/seamless-account-transfers-with-block-store-987a38517311?source=collection_archive---------0-----------------------#2021-08-18">https://medium.com/androiddevelopers/seamless-account-transfers-with-block-store-987a38517311?source=collection_archive---------0-----------------------#2021-08-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/e6b3f9e01cb6a266c4862813ae902d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3SLdqieGhQVNmPOi_YfhFg.png"/></div></div></figure><div class=""/><p id="3719" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">新移动设备的魔力。打开脆盒，剥去塑料，露出完美的屏幕，设置设备，将以前的应用程序下载到新设备上。当用户试图使用他们的应用程序时，这种无缝体验就会中断，必须重新进行身份验证。试图记住帐户凭证和经历帐户恢复流程会引起很多摩擦。这种摩擦导致用户最终创建一个新帐户并放弃旧帐户，或者在某些情况下，摩擦如此之大，以至于他们完全放弃了应用程序。</p><p id="5631" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了解决这个问题，我们提出了块存储API，使用户在新设备上重新登录应用程序变得简单，就像在设置过程中从备份中恢复一样，这样他们就可以像离开时一样返回到他们的应用程序。请继续阅读，了解更多关于Block Store的信息及其优势，以及如何为用户提供神奇的体验！</p><h1 id="98ed" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是街区商店？</h1><p id="6a58" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">块存储API允许您的应用程序存储用户凭据，以后可以检索这些凭据以在新设备上重新验证用户。当用户使用一台设备启动另一台设备时，您的凭据数据会在设备之间传输。</p><h1 id="823b" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">块存储的工作原理:</h1><ol class=""><li id="63df" class="kq kr hs ir b is kl iw km ja ks je kt ji ku jm kv kw kx ky bi translated">当用户登录到您的应用程序时，或此后的任何时候，您可以保存您为该用户生成的验证令牌以阻止存储。</li><li id="6f28" class="kq kr hs ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">使用块存储保存令牌后，令牌将被加密并存储在本地设备上。</li><li id="10f4" class="kq kr hs ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">当用户使用设备到设备恢复流程设置新设备时，数据会转移到新设备。</li><li id="eb4a" class="kq kr hs ir b is kz iw la ja lb je lc ji ld jm kv kw kx ky bi translated">当用户在新设备上返回到您的应用时，如果他们在进行设备到设备恢复时提供了恢复其数据的同意，块存储将检索您的应用的令牌。</li></ol><h1 id="fdcb" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">为什么使用块存储？</h1><p id="386c" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">虽然此API可以选择使用，但在您的应用中实现它有一些优势:</p><ul class=""><li id="505c" class="kq kr hs ir b is it iw ix ja le je lf ji lg jm lh kw kx ky bi translated">如果用户不必担心记住他们的凭证，他们也会更愿意使用独特的、更难被网络钓鱼的密码。</li><li id="c6b4" class="kq kr hs ir b is kz iw la ja lb je lc ji ld jm lh kw kx ky bi translated">消除登录流程中的摩擦，这种摩擦最终会导致用户不再使用你的应用。</li><li id="acba" class="kq kr hs ir b is kz iw la ja lb je lc ji ld jm lh kw kx ky bi translated">集成很简单，并且不管您提供什么样的登录方法，它都能正常工作。</li><li id="d0ad" class="kq kr hs ir b is kz iw la ja lb je lc ji ld jm lh kw kx ky bi translated">谷歌验证用户的身份。</li></ul><h1 id="f9e6" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">如何在我的app中添加？</h1><p id="d4c7" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">当用户登录到您的应用程序时，您可以通过调用<code class="du li lj lk ll b">storeBytes()</code>来保存您为该用户生成的验证令牌以阻止存储。这将用户的凭据存储到源设备。现在，令牌被加密并存储在本地设备上。</p><figure class="lm ln lo lp fd hj"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="9dc6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当用户在新设备上执行设备到设备恢复流程时，块存储会检索您的令牌。由于用户已经同意在恢复流程中恢复您的应用程序数据，因此无需额外同意。当用户打开您的应用程序时，您可以通过调用<code class="du li lj lk ll b">retrieveBytes()</code>向Block Store请求您的令牌。这个检索到的令牌可用于保持用户在新设备上登录。如果调用应用程序没有令牌，它仍然会调用<code class="du li lj lk ll b">onSuccessListener()</code>，但结果是空字节。如果在同一个设备上调用<code class="du li lj lk ll b">storeBytes()</code>然后再调用<code class="du li lj lk ll b">retrieveBytes()</code>，<code class="du li lj lk ll b">retrieveBytes(</code>仍然会返回之前<code class="du li lj lk ll b">storeBytes()</code>设置的字节。</p><figure class="lm ln lo lp fd hj"><div class="bz dy l di"><div class="lq lr l"/></div></figure><h1 id="cc06" class="jn jo hs bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="81c1" class="pw-post-body-paragraph ip iq hs ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">这就是开始使用Block Store所需要知道的全部内容！要了解更多信息，请查看<a class="ae ls" href="https://developers.google.com/identity/blockstore/android" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="c9f0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编码快乐！</p></div></div>    
</body>
</html>