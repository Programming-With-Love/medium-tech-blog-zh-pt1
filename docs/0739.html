<html>
<head>
<title>Consuming flows safely in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Jetpack Compose中安全地使用流</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3?source=collection_archive---------0-----------------------#2022-08-10">https://medium.com/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3?source=collection_archive---------0-----------------------#2022-08-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/447b4899641c4875785dd75ef7e4aed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LL7FLWzjT4c6bQdGlvdz7w.png"/></div></div></figure><div class=""/><p id="59de" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以生命周期感知的方式收集流量是在Android上收集流量的<a class="ae jn" href="https://developer.android.com/topic/architecture/ui-layer#consume-ui-state" rel="noopener ugc nofollow" target="_blank">推荐方式</a>。如果您正在使用Jetpack Compose构建一个Android应用程序，使用<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code> API从您的UI中以生命周期感知的方式收集流。</p><p id="8e38" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>允许你的应用在不需要的时候保存应用资源，比如应用在后台的时候。让资源不必要地保持活动状态会影响用户的设备健康。这些资源可能包括firebase查询、位置或网络更新以及数据库连接。</p><p id="d2ba" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请继续阅读，了解更多关于这个API的信息，为什么您应该以生命周期感知的方式收集，以及它与<code class="du jo jp jq jr b">collectAsState</code> API的比较。</p><h1 id="fced" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">collectAsStateWithLifecycle</h1><p id="0805" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated"><code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>是一个可组合的函数，它从流中收集值，并以生命周期感知的方式将最新的值表示为组合<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/State" rel="noopener ugc nofollow" target="_blank">State</a></code>。每次出现新的流发射时，这个<code class="du jo jp jq jr b">State</code>对象的值都会更新。这会导致组合中每个<code class="du jo jp jq jr b">State.value</code>用法的重组。</p><p id="6e12" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">默认情况下，<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>使用<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#started" rel="noopener ugc nofollow" target="_blank">Lifecycle.State.STARTED</a></code>来开始和停止从流中收集值。当生命周期移入和移出目标状态时，会发生这种情况。您可以在<code class="du jo jp jq jr b">minActiveState</code>参数中配置生命周期状态。</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kv"><img src="../Images/1e18fe51793986537df9c6b3978be959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_X0J2wnopl_wNEU8"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx"><code class="du jo jp jq jr b"><em class="le">collectAsStateWithLifecycle</em></code><em class="le"> cancels the flow collection when the app is in the background by default</em></figcaption></figure><p id="6c57" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面的代码片段演示了如何使用<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>来收集StateFlow的<code class="du jo jp jq jr b">uiState</code>字段，该字段是可组合函数中的ViewModel所公开的:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><p id="8b6c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每次<code class="du jo jp jq jr b"><a class="ae jn" href="https://github.com/android/nowinandroid/blob/main/feature-author/src/main/java/com/google/samples/apps/nowinandroid/feature/author/AuthorViewModel.kt" rel="noopener ugc nofollow" target="_blank">AuthorViewModel</a></code>的<code class="du jo jp jq jr b">uiState</code>发出一个新的<code class="du jo jp jq jr b">AuthorScreenUiState</code>值，<code class="du jo jp jq jr b"><a class="ae jn" href="https://github.com/android/nowinandroid/blob/main/feature-author/src/main/java/com/google/samples/apps/nowinandroid/feature/author/AuthorScreen.kt" rel="noopener ugc nofollow" target="_blank">AuthorRoute</a></code>就会被重组。关于<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>的更多用法，请查看安卓应用中的<a class="ae jn" href="https://github.com/android/nowinandroid/search?q=collectAsStateWithLifecycle" rel="noopener ugc nofollow" target="_blank">，以及</a><a class="ae jn" href="https://github.com/android/nowinandroid/pull/166" rel="noopener ugc nofollow" target="_blank">其迁移PR </a>。</p><p id="3692" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要开始在您的项目中使用<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code> API，将<code class="du jo jp jq jr b">androidx.lifecycle.lifecycle-runtime-compose</code>工件添加到您的项目中。</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h1 id="7630" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在后台</h1><p id="4626" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">在引擎盖下， <code class="du jo jp jq jr b"><a class="ae jn" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-runtime-compose/src/main/java/androidx/lifecycle/compose/FlowExt.kt;l=168" rel="noopener ugc nofollow" target="_blank">collectAsStateWithLifecycle</a></code>的<a class="ae jn" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-runtime-compose/src/main/java/androidx/lifecycle/compose/FlowExt.kt;l=168" rel="noopener ugc nofollow" target="_blank">实现使用了<code class="du jo jp jq jr b"><a class="ae jn" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#(androidx.lifecycle.Lifecycle).repeatOnLifecycle(androidx.lifecycle.Lifecycle.State,kotlin.coroutines.SuspendFunction1)" rel="noopener ugc nofollow" target="_blank">repeatOnLifecycle</a></code> API，这是使用View系统在Android中收集流的推荐方式。</a></p><p id="858c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>避免您键入如下所示的样板代码，该代码也以生命周期感知的方式从可组合函数中收集流:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure><h1 id="7f9e" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">架构中的流集合</h1><p id="bb51" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">你的应用架构中的类型不应该知道其他类型的实现细节。UI不应该知道视图模型如何产生UI状态。<strong class="ir ht"/></p><p id="62e3" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">UI可以通过使用<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>收集UI状态来帮助释放资源。ViewModel可以通过以收集器感知的方式产生UI状态来实现同样的功能。如果没有收集器，比如当UI在屏幕上不可见时，停止来自数据层的上游流。在生成UI状态时，您可以使用<code class="du jo jp jq jr b"><a class="ae jn" href="https://github.com/android/nowinandroid/blob/main/feature-author/src/main/java/com/google/samples/apps/nowinandroid/feature/author/AuthorViewModel.kt#L104" rel="noopener ugc nofollow" target="_blank">.stateIn(WhileSubscribed)</a></code>流API来实现这一点。关于这方面的更多信息，请观看<a class="ae jn" href="https://youtu.be/fSB6_KE95bU?t=1009" rel="noopener ugc nofollow" target="_blank">科特林练习演讲</a>的这一部分。为了以这种方式测试ViewModel生成UI状态，请查看<a class="ae jn" href="https://developer.android.com/kotlin/flow/test#statein" rel="noopener ugc nofollow" target="_blank">测试指南</a>。</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kv"><img src="../Images/b36e56c63cfadb6606b36e50659cfb9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WoIKlW_GaW82KFeW"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx"><em class="le">In the UI layer, consume the UI state using collectAsStateWithLifecycle and produce it using .stateIn(WhileSubscribed) when the data layer exposes reactive streams. This enables the rest of the app to free up resources when not needed.</em></figcaption></figure><p id="6613" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">流的消费者和生产者不需要知道彼此是如何实现的。在一个拥有多种环境、变体、库和特性的大型应用程序中，找出实现细节是非常耗时的。更糟糕的是，维护依赖于实现细节的代码非常困难。</p><h1 id="2839" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">在后台保持资源活动</h1><p id="b585" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">Android应用可以在无数的Android设备上运行。不幸的是，不是所有的设备和用户都有无穷无尽的资源。应用程序通常在受限的环境中运行。当Android应用运行时，有一些重要因素会影响用户体验和设备系统健康:</p><ul class=""><li id="f1db" class="li lj hs ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated"><strong class="ir ht"> CPU使用率</strong>:CPU是所有设备组件中电池消耗最高的。电池寿命是用户长期关心的问题。如果被滥用，用户可能会卸载你的应用。</li><li id="0414" class="li lj hs ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir ht">数据使用</strong>:在不连接Wi-Fi的情况下，减少应用程序中的网络流量可以帮助用户节省资金。</li><li id="e8a3" class="li lj hs ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir ht">内存使用:</strong>一个应用程序如何使用内存会对设备的整体稳定性和性能产生非常大的影响。</li></ul><p id="ff3a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个想要尊重用户、设备系统健康或者<a class="ae jn" href="https://developer.android.com/docs/quality-guidelines/build-for-billions" rel="noopener ugc nofollow" target="_blank">为几十亿人打造</a>的Android开发者应该根据他们的目标市场、设备或国家优化这些不同的因素。根据设备类型和设备运行的Android版本，保留不需要的资源可能会产生负面影响。在UI层使用<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>可以让层次结构的其余部分释放资源。</p><h1 id="4052" class="js jt hs bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">集合状态比较</h1><p id="8d7a" class="pw-post-body-paragraph ip iq hs ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">开发者经常会问:如果<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>是从Android中的可组合函数收集流的最安全的方式，<em class="lh">为什么我们现在还需要</em> <code class="du jo jp jq jr b"><em class="lh">collectAsState</em></code> <em class="lh"> API？或者为什么不为</em> <code class="du jo jp jq jr b"><em class="lh">collectAsState</em></code> <em class="lh">添加生命周期感知功能，而不是创建一个新的API？</em></p><p id="fedc" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可组合函数的生命周期与运行Compose的平台无关。正如在<a class="ae jn" href="https://developer.android.com/jetpack/compose/lifecycle" rel="noopener ugc nofollow" target="_blank">可组合函数的生命周期页面</a>上所记录的，可组合函数的实例进入组合，重新组合0次或更多次，然后离开组合。</p><figure class="kw kx ky kz fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es lw"><img src="../Images/65e96183586e83b38cede75be86260e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MZkRry7NwG7hcyXM"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx"><em class="le">Lifecycle of an instance of a composable function in the Composition</em></figcaption></figure><p id="752c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">collectAsState</code> API遵循组合的生命周期。当可组合组件进入组合时，它开始收集流，当它离开组合时，它停止收集。<code class="du jo jp jq jr b">collectAsState</code>是一个平台无关的API，可以用来收集流量。</p><p id="bd46" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，当在Android应用程序中使用Compose时，Android生命周期在如何管理资源方面也起着关键作用。即使当Android应用程序在后台运行时，Compose停止重新合成，<code class="du jo jp jq jr b">collectAsState</code>也会保持收藏活动。这使得层次结构的其余部分无法释放资源。</p><p id="174f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du jo jp jq jr b">collectAsState</code>和<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>都有作曲的目的。后者在开发Android应用时，前者在为其他平台开发时。</p><p id="15df" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从<code class="du jo jp jq jr b">collectAsState</code>迁移到<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code>是显而易见的:</p><figure class="kw kx ky kz fd hj"><div class="bz dy l di"><div class="lf lg l"/></div></figure></div><div class="ab cl lx ly go lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ha hb hc hd he"><p id="69d9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以生命周期感知的方式收集流量是在Android上收集流量的推荐方式，以使您的应用程序的其他部分能够在需要时释放资源。</p><p id="7474" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您正在使用Jetpack Compose构建Android应用程序，请使用<code class="du jo jp jq jr b">collectAsStateWithLifecycle</code> composable函数来完成此操作。</p><p id="04b6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">附注:感谢何塞·阿尔塞雷卡、T21、马顿·布朗、阿莱杭德娜·斯塔马托和杰克·罗斯曼审阅本文。</p></div></div>    
</body>
</html>