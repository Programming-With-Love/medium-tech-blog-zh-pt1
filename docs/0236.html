<html>
<head>
<title>Draw What You See! … and clip the #e11 out of the rest.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">把你看到的画下来！…并将#e11从其余部分中剪下。</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/draw-what-you-see-and-clip-the-e11-out-of-the-rest-6df58c47873e?source=collection_archive---------5-----------------------#2016-01-12">https://medium.com/androiddevelopers/draw-what-you-see-and-clip-the-e11-out-of-the-rest-6df58c47873e?source=collection_archive---------5-----------------------#2016-01-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/a56aaac410329b38bae4d9b2961aa25e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9oB6s9vqxiHC8j1Bp-T4g.jpeg"/></div></div></figure><div class=""/><p id="e8f4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你的应用程序每在屏幕上画一个像素，都需要时间。每次你的应用程序绘制一个不透明的像素来替换已经绘制的东西，都是在浪费时间。在每次屏幕刷新时多次绘制一个像素被称为<em class="jn"> overdraw </em>，这是影响现代应用程序性能的常见问题。为了提高效率，每次你的应用程序刷新屏幕时，它应该努力把每个改变的像素只画一次。</p><p id="8757" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，一个应用程序可能会绘制一叠52张重叠的卡片，只有最后一张卡片完全可见。完全抽取下面的51张牌，并且部分覆盖，就是一个透支的例子。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div class="er es jo"><img src="../Images/e81be33833a5e92a39866e8ceb360bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*oFOYgK1_3ZBO2tISsCKulw.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Overdraw happens, if you fully draw overlapping cards.</figcaption></figure><p id="01a6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在过度绘制的应用程序中，最有可能出现的症状是渲染缓慢和动画断断续续。这是最常见的症状。因此，由于透支很常见，也很容易测试，我们建议你养成习惯，每次改变应用程序的视图时都检查一下。</p><h1 id="7332" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">测试透支。</h1><p id="4e53" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">您可以使用<a class="ae la" href="https://developer.android.com/tools/performance/debug-gpu-overdraw/index.html" rel="noopener ugc nofollow" target="_blank">调试GPU透支工具</a>在您的设备上使用颜色着色来可视化透支。</p><p id="896d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要在移动设备上打开调试GPU透支:</p><ol class=""><li id="2371" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated">打开<strong class="ir ht">设置。</strong></li><li id="4ec7" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">点击<strong class="ir ht">开发者选项</strong>。</li><li id="7bc5" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">在<em class="jn">硬件加速渲染</em>部分，选择<strong class="ir ht">调试GPU Overdraw </strong>。</li><li id="5107" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">在调试GPU透支弹出窗口中，选择<strong class="ir ht">显示透支区域</strong>。</li><li id="180e" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">观看您的设备变成彩虹般的颜色。这些颜色暗示了屏幕上每个像素的过度绘制量。本色没有透支。紫色透支一次。绿色透支两次。粉色透支三次。红色透支四次以上。</li></ol><figure class="jp jq jr js fd hj er es paragraph-image"><div class="er es lp"><img src="../Images/2413a9b6cc12aa6f5ad92bf61dfce05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*14OcmkRJEBFNtl7Szfu2FA.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">Left: Tint colors indicating overdraw. Center: Red warns of too much overdraw. Right: Blue and white indicate no or little overdraw.</figcaption></figure><h1 id="bf0e" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">遵守唯一的规则。</h1><blockquote class="lq"><p id="0782" class="lr ls hs bd lt lu lv lw lx ly lz jm dx translated">如果你的程序在任何时候画了用户看不到的东西，那就不要画。</p></blockquote><p id="557e" class="pw-post-body-paragraph ip iq hs ir b is ma iu iv iw mb iy iz ja mc jc jd je md jg jh ji me jk jl jm ha bi translated">特别是:</p><ul class=""><li id="3849" class="lb lc hs ir b is it iw ix ja ld je le ji lf jm mf lh li lj bi translated">消除不必要的背景。</li><li id="f650" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm mf lh li lj bi translated">大量剪辑，只重画屏幕上发生变化的区域。</li><li id="71ee" class="lb lc hs ir b is lk iw ll ja lm je ln ji lo jm mf lh li lj bi translated">简化和重新组织你的视图层次结构，首先最大限度地减少重叠。(这是一个很大的话题，所以会在下一篇文章中涉及。)</li></ul><h1 id="b179" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">消除不必要的背景。</h1><p id="3ffa" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">这个修复非常简单。在你的代码中搜索“android:background”，对于每个背景，确定它是否需要，是否在屏幕上可见。如果视图的背景被其他东西覆盖，例如一幅图像或孩子们的背景，从视图中删除<strong class="ir ht"> android:background </strong>代码行。</p><p id="02c6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">之前:</strong></p><pre class="jp jq jr js fd mg mh mi mj aw mk bi"><span id="7084" class="ml jy hs mh b fi mm mn l mo mp">&lt;ImageView<br/>    android:layout_width=”match_parent”<br/>    android:layout_height=”match_parent”<br/>    android:src=”@drawable/beach”<br/>    <strong class="mh ht">android:background=”@android:color/white” </strong>/&gt;</span></pre><p id="8f48" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">之后:</strong></p><pre class="jp jq jr js fd mg mh mi mj aw mk bi"><span id="6843" class="ml jy hs mh b fi mm mn l mo mp">&lt;ImageView<br/>    android:layout_width=”match_parent”<br/>    android:layout_height=”match_parent”<br/>    android:src=”@drawable/beach” /&gt;</span></pre><h1 id="58c7" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">大方夹。</h1><p id="4c16" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">对于标准视图，Android系统会尽可能减少overdraw，避免绘制完全隐藏的视图。例如，打开的导航抽屉下面的所有内容都不会被绘制。</p><h2 id="0e27" class="ml jy hs bd jz mq mr ms kd mt mu mv kh ja mw mx kl je my mz kp ji na nb kt nc bi translated">clipRect()</h2><p id="c72b" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">对于覆盖onDraw方法的复杂自定义视图，底层系统无法洞察如何绘制内容，这使得它很难知道应该避免什么。你可以通过使用<strong class="ir ht"> Canvas.clipRect API </strong>来帮助系统。这个函数允许你为一个视图定义一个矩形，并且只画矩形里面的东西。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div class="er es nd"><img src="../Images/93789f871c525e93c95406ebb1c69af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*Ta6cNlOzwlu8rgZlFL6GtA.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">When you clip, only the portion inside the clipping rectangle gets drawn.</figcaption></figure><p id="24c9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，对于那组堆叠的重叠卡片，您可以确定当前卡片的哪一部分是可见的，并相应地设置您的裁剪矩形。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div class="er es jo"><img src="../Images/acfd3597a6088a5a939f3203fa67a9a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*Ek_pY9dWvwfwzRVCN37Wmg.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx">When you apply clipping to a stack of cards, only the visible portions are drawn.</figcaption></figure><p id="f66e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">裁剪可以节省CPU和GPU的性能。</p><p id="3fd0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在CPU方面，一旦提交给<a class="ae la" href="http://developer.android.com/guide/topics/graphics/opengl.html" rel="noopener ugc nofollow" target="_blank"> OpenGLES </a>进行绘制，每个画布绘制命令都会有一点开销。任何完全位于指定裁剪矩形之外的绘制命令都不会提交给硬件，因此不会产生开销。(参见<a class="ae la" href="https://www.youtube.com/watch?v=WH9AFhgwmDw&amp;list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE&amp;index=53" rel="noopener ugc nofollow" target="_blank"> Android UI和GPU </a>或者等待下一篇文章来了解细节。),</p><p id="3600" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，仍然会绘制与裁剪矩形部分相交的任何内容，但在GPU端，clipRect将定义一个排除矩形，允许GPU在每像素级别上避免对任何被裁剪的内容进行着色。</p><figure class="jp jq jr js fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es ne"><img src="../Images/d9feadc50ff4cbfca0278dc72f49fa7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3YIyhJ6aFwcseTVNi42AxA.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx">Everything partially or fully inside the clipping rectangle is drawn.</figcaption></figure><h2 id="f1bf" class="ml jy hs bd jz mq mr ms kd mt mu mv kh ja mw mx kl je my mz kp ji na nb kt nc bi translated">快速拒绝()</h2><p id="f411" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">现在，即使您只在自定义视图的一角画了一个小圆，整个视图也会重建。不用重新计算和重绘整个屏幕，您可以计算改变区域的裁剪矩形，然后使用<strong class="ir ht"> quickReject() API </strong>在onDraw函数中测试裁剪矩形的交点。如果占用大量处理时间的视图的某个部分在裁剪矩形之外，quickReject可以提示您，以便您可以完全跳过该处理。</p><h2 id="5e7b" class="ml jy hs bd jz mq mr ms kd mt mu mv kh ja mw mx kl je my mz kp ji na nb kt nc bi translated">复杂剪裁</h2><p id="09f2" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">除了clipRect和quickReject之外，<a class="ae la" href="http://developer.android.com/reference/android/graphics/Canvas.html" rel="noopener ugc nofollow" target="_blank"> Canvas类</a>还提供了复杂剪辑的功能(clipPath、clipRegion或旋转时应用clipRect)。这种剪辑可能非常昂贵，而且没有抗锯齿功能。一般的建议是始终组成正确形状和大小的绘图元素，而不是剪裁，例如drawCircle或drawPath比带有drawColor的clipPath便宜得多。</p><h1 id="7a5e" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">当然啦！有取舍。</h1><p id="68c0" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">与消除背景不同，剪辑不是免费的，尤其是在较旧和较低端的设备上。所以，不需要的时候不要夹！然而，比大量裁剪好得多的是，只在必要时使用自定义视图，并安排用户界面和视图层次结构，以避免视图部分重叠。(我们将在下一期讨论这个问题。)</p><h1 id="75c6" class="jx jy hs bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">透支仍然重要。</h1><p id="a17c" class="pw-post-body-paragraph ip iq hs ir b is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji kz jk jl jm ha bi translated">像许多其他性能挑战一样，一点点，甚至很多的透支和额外重绘在你时髦的新手机上可能无关紧要。但世界上大多数人的设备功能都没那么强大。减少对它们的过度绘制可以节省大量资源，并大大减少绘制一帧所需的时间。</p><p id="cdfe" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">更一般地说，减少透支可能会对应用程序的性能产生重大影响，如果这是你的应用程序的最大性能问题，但如果你是在一个快速的设备上，它可能不会产生明显的影响。最后，如果你的应用程序有其他更大的性能问题，比如……这可能没有什么可衡量的影响，但这很说明问题。</p></div><div class="ab cl nf ng go nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ha hb hc hd he"><p id="4984" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了获得本节更有趣的版本，观看<a class="ae la" href="https://www.youtube.com/watch?v=T52v50r-JfE" rel="noopener ugc nofollow" target="_blank">理解透支</a>和<a class="ae la" href="https://www.youtube.com/watch?v=vkTn3Ule4Ps" rel="noopener ugc nofollow" target="_blank"> ClipRect和ClipReject </a>，它们是YouTube 上<a class="ae la" href="https://www.youtube.com/playlist?list=PLOU2XLYxmsIKEOXh5TwZEv89aofHzNCiu" rel="noopener ugc nofollow" target="_blank"> Android性能模式的一部分，在那里你也可以找到更多关于剪辑的内容。用</a><a class="ae la" href="https://io2015codelabs.appspot.com/codelabs/android-performance-debug-gpu-overdraw#1" rel="noopener ugc nofollow" target="_blank"> Debug GPU Overdraw Codelab </a>弄脏你的手。如果你想提前一步，可以查看Udacity 上的<a class="ae la" href="https://www.udacity.com/course/android-performance--ud825" rel="noopener ugc nofollow" target="_blank"> Android性能课程。但最重要的是，加入我们的</a><a class="ae la" href="https://plus.sandbox.google.com/communities/116342551728637785407" rel="noopener ugc nofollow" target="_blank"> Android Performance G+社区</a>，获得关于构建高性能Android应用的伟大技巧，你猜对了。</p></div></div>    
</body>
</html>