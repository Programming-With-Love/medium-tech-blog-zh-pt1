<html>
<head>
<title>Xamarin.Forms Shell : Navigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Xamarin。表单外壳:导航</h1>
<blockquote>原文：<a href="https://medium.com/globant/xamarin-forms-shell-navigation-d1179bfa2e4a?source=collection_archive---------0-----------------------#2021-12-14">https://medium.com/globant/xamarin-forms-shell-navigation-d1179bfa2e4a?source=collection_archive---------0-----------------------#2021-12-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e0fbfb6a2f26542b35d086823be2dccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NI8_A3SZ6bTI5WGU"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@rocinante_11?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mick Haupt</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f79a" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">简介</strong></h1><p id="d2dd" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">Xamarin。Form Shell旨在提高移动开发人员的工作效率，降低移动应用程序的复杂性。Shell为您的应用程序提供了一个容器。那个容器包括一个<code class="du kq kr ks kt b">MasterDetailPage</code>、一个<code class="du kq kr ks kt b">TabbedPage</code>和一个<code class="du kq kr ks kt b">NavigationPage</code>或者它们的组合。Shell还提供了搜索功能。它有基于URI的导航，使用路线导航到应用程序中的任何页面，而不必遵循导航层次结构。此外，它还提供了向后导航的能力，而不必访问导航堆栈上的所有页面。</p><p id="9af9" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">Xamarin的基本特征。表单外壳包括:</p><ul class=""><li id="87e8" class="kz la hh ju b jv ku jz kv kd lb kh lc kl ld kp le lf lg lh bi translated">描述应用程序视觉层次的单一位置。</li><li id="7dbc" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated">常见的导航用户体验。</li><li id="5e23" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated">基于URI的路由</li><li id="ac33" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated">集成的搜索处理程序</li><li id="f9e4" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated">应用渲染速度提高</li><li id="8766" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated">降低内存消耗</li></ul><p id="fdda" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">Xamarin。Forms Shell在iOS和Android上完全可用，但在通用Windows平台(UWP)上仅部分可用。壳牌目前正在UWP进行实验。</p><h1 id="dc8c" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">xa marin中的视觉层次。表单外壳应用程序</strong></h1><p id="6085" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">Xamarin的视觉层次结构。窗体外壳应用程序在扩展外壳类AppShell.xaml的类中描述。该类由三个主要的分层对象组成，它们是:</p><p id="c648" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><code class="du kq kr ks kt b"><strong class="ju hi">1. FlyoutItem</strong></code> <strong class="ju hi">或</strong> <code class="du kq kr ks kt b"><strong class="ju hi">TabBar</strong></code></p><ul class=""><li id="15b0" class="kz la hh ju b jv ku jz kv kd lb kh lc kl ld kp le lf lg lh bi translated">一个<code class="du kq kr ks kt b"><strong class="ju hi">FlyoutItem</strong></code>代表弹出菜单中的一个或多个项目，当应用程序的导航模式需要弹出菜单时应该使用。</li><li id="3bd1" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated">一个<code class="du kq kr ks kt b"><strong class="ju hi">TabBar</strong></code>代表底部标签栏，当应用程序的导航模式以底部标签开始并且不需要弹出时应该使用。</li></ul><p id="d2ea" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><code class="du kq kr ks kt b"><strong class="ju hi">2. Tab:</strong></code>代表分组内容，可通过底部标签导航。</p><ul class=""><li id="934c" class="kz la hh ju b jv ku jz kv kd lb kh lc kl ld kp le lf lg lh bi translated">每个<code class="du kq kr ks kt b"><strong class="ju hi">Tab</strong></code>对象都是<code class="du kq kr ks kt b">FlyoutItem</code>对象或<code class="du kq kr ks kt b">TabBar</code>对象的子对象。</li></ul><p id="98ed" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><code class="du kq kr ks kt b"><strong class="ju hi">3. ShellContent:</strong></code>表示每个页签的<code class="du kq kr ks kt b"><strong class="ju hi">ContentPage</strong></code>对象。</p><p id="64e3" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">这些对象用于组织应用程序视觉层次结构。本文提到的例子中使用了这些对象。</p><h1 id="c1ee" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">快速启动</strong></h1><p id="eb4f" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">Visual Studio为Shell提供了一个新的模板项目，但是您也可以快速地将Shell添加到任何应用程序中。</p><p id="4b08" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">要将Shell添加到任何应用程序中，您可以遵循以下步骤:</p><ol class=""><li id="a8fc" class="kz la hh ju b jv ku jz kv kd lb kh lc kl ld kp ln lf lg lh bi translated">向名为<code class="du kq kr ks kt b"><strong class="ju hi">AppShell.xaml</strong></code>的库项目添加一个新的XAML文件</li><li id="2528" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp ln lf lg lh bi translated">用<code class="du kq kr ks kt b"><strong class="ju hi">Shell</strong></code>类型而不是<code class="du kq kr ks kt b">ContentPage</code>来扩展类。文件背后的XAML和代码应该如下所示:</li></ol><p id="dcd8" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">AppShell.xaml</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="01ea" class="lw iv hh kt b fi lx ly l lz ma">&lt;Shell ae it" href="http://xamarin.com/schemas/2014/forms" rel="noopener ugc nofollow" target="_blank"&gt;http://xamarin.com/schemas/2014/forms"<br/>       xmlns:x="<a class="ae it" href="http://schemas.microsoft.com/winfx/2009/xaml" rel="noopener ugc nofollow" target="_blank">http://schemas.microsoft.com/winfx/2009/xaml</a>"<br/>       x:Class="MyApp.AppShell"&gt;</span><span id="5206" class="lw iv hh kt b fi mb ly l lz ma">&lt;/Shell&gt;</span></pre><p id="301f" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">AppShell.xaml.cs</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="91c0" class="lw iv hh kt b fi lx ly l lz ma">namespace MyApp<br/>{<br/>    public partial class AppShell : Shell<br/>    {<br/>        public AppShell()<br/>        {<br/>            InitializeComponent();<br/>        }<br/>    }<br/>}</span></pre><p id="30be" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">3.在App.xaml.cs文件中，将AppShell类对象设置为MainPage属性。App.xaml.cs类应该如下所示:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="368a" class="lw iv hh kt b fi lx ly l lz ma">namespace MyApp<br/>{<br/>    public partial class App : Application<br/>    {<br/>        public App()<br/>        {<br/>            InitializeComponent();<br/>            MainPage = new AppShell();<br/>        }<br/>        ...<br/>    }<br/>}</span></pre><p id="bf55" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">4.根据应用程序的导航要求，可以从<strong class="ju hi">弹出菜单或底部标签栏菜单中决定导航类型。</strong>以下是Xamarin中导航类型的详细信息。窗体外壳应用程序。</p><p id="4bde" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><strong class="ju hi">弹出菜单:</strong></p><p id="7072" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">弹出菜单也称为侧抽屉或汉堡菜单。弹出菜单由可选的标题、菜单项(可选)和弹出项组成。在弹出菜单中，侧面板是可折叠的，可以通过点击应用程序屏幕左上方的汉堡菜单图标(三条水平线图标)来打开。</p><p id="4f76" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">下面是Android和iOS上弹出菜单的截图:</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/2478c7478f74468efa901df4419accf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EG1V90RhWhlsLLinFrQStA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Flyout Menu</figcaption></figure><p id="09a6" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">上述弹出菜单的代码应该如下所示:</p><p id="a5a3" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><strong class="ju hi"> AppShell.xaml </strong></p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="9138" class="lw iv hh kt b fi lx ly l lz ma">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;<br/>&lt;Shell<br/>    ae it" href="http://xamarin.com/schemas/2014/forms" rel="noopener ugc nofollow" target="_blank"&gt;http://xamarin.com/schemas/2014/forms"<br/>    xmlns:x="<a class="ae it" href="http://schemas.microsoft.com/winfx/2009/xaml" rel="noopener ugc nofollow" target="_blank">http://schemas.microsoft.com/winfx/2009/xaml</a>"<br/>    xmlns:views="clr-namespace:Cars_XShell.Views"<br/>    xmlns:controls="clr-namespace:Cars_XShell.Controls"<br/>    x:Class="Cars_XShell.AppShell"&gt;<br/>   <br/>    &lt;Shell.FlyoutHeader&gt;<br/>        &lt;controls:FlyoutHeader/&gt;<br/>    &lt;/Shell.FlyoutHeader&gt;<br/><br/>    &lt;Shell.FlyoutFooter&gt;<br/>        &lt;controls:FlyoutFooter/&gt;<br/>    &lt;/Shell.FlyoutFooter&gt;<br/><br/>    &lt;FlyoutItem FlyoutDisplayOptions="AsMultipleItems"&gt;<br/>          &lt;Tab Title="Tata" Icon="icon_t.png"&gt;<br/>            &lt;ShellContent <br/>                Title="Tata Nexon" Icon="icon_t.png"<br/>                ContentTemplate="{DataTemplate views:TataNexon}"/&gt;<br/>            &lt;ShellContent <br/>                Title="Tata Harrier" Icon="icon_t.png"<br/>                ContentTemplate="{DataTemplate views:TataHarrier}"/&gt;<br/>        &lt;/Tab&gt;<br/>        &lt;ShellContent Title="Ford" Icon="icon_f.png"<br/>                      ContentTemplate="{DataTemplate views:Ford}"/&gt;<br/>        &lt;ShellContent Title="Kia" Icon="icon_k.png"<br/>                      ContentTemplate="{DataTemplate views:Kia}"/&gt;<br/>        &lt;ShellContent Title="Honda" Icon="icon_h.png"<br/>                      ContentTemplate="{DataTemplate views:Honda}"/&gt;<br/>    &lt;/FlyoutItem&gt;<br/>&lt;/Shell&gt;</span></pre><p id="501f" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><strong class="ju hi">标签栏:</strong></p><p id="6bd3" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">该导航菜单是传统的底部标签栏菜单，如下面的屏幕截图所示:</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/a53ca002ac164a263461bf61c2637db3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rTIA8gsIrYStBJzGrudJJg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Tabbed Menu</figcaption></figure><p id="cb18" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">标签栏上的每个标签都显示一个<code class="du kq kr ks kt b">ContentPage</code>。但是，如果底部选项卡包含多个页面，则页面可通过顶部选项卡栏导航。</p><p id="afce" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">上述选项卡式栏菜单的代码应该如下所示:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="d277" class="lw iv hh kt b fi lx ly l lz ma">&lt;Shell<br/>    ae it" href="http://xamarin.com/schemas/2014/forms" rel="noopener ugc nofollow" target="_blank"&gt;http://xamarin.com/schemas/2014/forms"<br/>    xmlns:x="<a class="ae it" href="http://schemas.microsoft.com/winfx/2009/xaml" rel="noopener ugc nofollow" target="_blank">http://schemas.microsoft.com/winfx/2009/xaml</a>"<br/>    xmlns:views="clr-namespace:Cars_XShell.Views"<br/>    xmlns:controls="clr-namespace:Cars_XShell.Controls"<br/>    x:Class="Cars_XShell.AppShell"&gt;<br/>   <br/>    &lt;Shell.FlyoutHeader&gt;<br/>        &lt;controls:FlyoutHeader/&gt;<br/>    &lt;/Shell.FlyoutHeader&gt;<br/><br/>    &lt;Shell.FlyoutFooter&gt;<br/>        &lt;controls:FlyoutFooter/&gt;<br/>    &lt;/Shell.FlyoutFooter&gt;<br/><br/>    &lt;TabBar FlyoutDisplayOptions="AsMultipleItems"&gt;<br/>        &lt;Tab Title="Tata" Icon="icon_t.png"&gt;<br/>            &lt;ShellContent <br/>                Title="Tata Nexon" Icon="icon_t.png"<br/>                ContentTemplate="{DataTemplate views:TataNexon}"/&gt;<br/>            &lt;ShellContent <br/>                Title="Tata Harrier" Icon="icon_t.png"<br/>                ContentTemplate="{DataTemplate views:TataHarrier}"/&gt;<br/>        &lt;/Tab&gt;<br/>        &lt;ShellContent Title="Ford" Icon="icon_f.png"<br/>                      ContentTemplate="{DataTemplate views:Ford}"/&gt;<br/>        &lt;ShellContent Title="Kia" Icon="icon_k.png"<br/>                      ContentTemplate="{DataTemplate views:Kia}"/&gt;<br/>        &lt;ShellContent Title="Honda" Icon="icon_h.png"<br/>                      ContentTemplate="{DataTemplate views:Honda}"/&gt;<br/>    &lt;/TabBar&gt;<br/>&lt;/Shell&gt;</span></pre><h1 id="0930" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">xa marin中的导航。表单外壳应用程序</strong></h1><p id="7db8" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">Xamarin。Forms Shell支持基于URI的导航。它使用路由导航到应用程序中的任何页面。它还提供向后导航到导航堆栈中任何页面的功能。</p><p id="5db7" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">下面是在<strong class="ju hi"> Shell </strong>类中定义的导航相关属性:</p><ul class=""><li id="f849" class="kz la hh ju b jv ku jz kv kd lb kh lc kl ld kp le lf lg lh bi translated"><code class="du kq kr ks kt b"><strong class="ju hi">BackButtonBehavior</strong></code>:定义后退按钮行为的附加属性。</li><li id="f328" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated"><code class="du kq kr ks kt b"><strong class="ju hi">CurrentItem</strong></code>:提供当前选择的项目。</li><li id="9726" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated"><code class="du kq kr ks kt b"><strong class="ju hi">CurrentPage</strong></code>:提供当前呈现的页面。</li><li id="bb6d" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated"><code class="du kq kr ks kt b"><strong class="ju hi">CurrentState</strong></code>:提供<code class="du kq kr ks kt b">Shell</code>的当前导航状态。</li><li id="7be2" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated"><code class="du kq kr ks kt b"><strong class="ju hi">Current</strong></code>:是<code class="du kq kr ks kt b">Application.Current.MainPage</code>的类型转换别名。</li></ul><p id="ef84" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><code class="du kq kr ks kt b"><strong class="ju hi">GoToAsync()</strong></code>方法用于在Xamarin Shell应用程序中执行导航。执行导航时会触发以下事件:</p><ol class=""><li id="eded" class="kz la hh ju b jv ku jz kv kd lb kh lc kl ld kp ln lf lg lh bi translated"><code class="du kq kr ks kt b">Navigating</code>当将要执行导航时触发事件</li><li id="6159" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp ln lf lg lh bi translated"><code class="du kq kr ks kt b">Navigated</code>导航完成时触发事件</li></ol><h1 id="1332" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">路线</strong></h1><p id="98ea" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">Xamarin。窗体外壳应用程序支持基于URI的导航。导航URI由以下三个部分组成:</p><ul class=""><li id="0a11" class="kz la hh ju b jv ku jz kv kd lb kh lc kl ld kp le lf lg lh bi translated">一个<em class="md"> route: </em>一个<strong class="ju hi"> Route </strong>属性用于定义作为外壳视觉层次结构的一部分存在的内容的路径。它用于为AppShell.xaml文件中定义的页面定义路径。</li><li id="289b" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated">一个<em class="md">页面:</em> <strong class="ju hi">页面</strong>不存在于shell可视化层次结构中(没有在AppShell.xaml文件中定义的页面)也可以被推送到导航堆栈上。这些路由可以在AppShell.xaml.cs文件中注册，然后用于导航到所需的注册页面。</li><li id="786b" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated">一个或多个<em class="md">查询参数:</em>查询参数是导航时可以传递给目的页面的参数。</li></ul><p id="ac56" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">当导航URI包括所有三个组件时，其结构应该如下所示:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="ff51" class="lw iv hh kt b fi lx ly l lz ma"><strong class="kt hi"><em class="md">//route/page?queryParameters</em></strong></span></pre><h1 id="4f68" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">登记路线</strong></h1><p id="ef8e" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">注册路由有两种方式:</p><ol class=""><li id="e532" class="kz la hh ju b jv ku jz kv kd lb kh lc kl ld kp ln lf lg lh bi translated">通过在AppSell.xaml文件中定义路线。在应用程序的可视层次结构中定义的页面也遵循这一点。</li><li id="91c7" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp ln lf lg lh bi translated">通过在AppShell.xaml.cs文件中显式注册路由。这种方法特别适用于没有在应用程序的可视层次结构中定义的页面。</li></ol><p id="44f9" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">路线可以定义在<code class="du kq kr ks kt b"><strong class="ju hi">FlyoutItem</strong></code><strong class="ju hi"/><code class="du kq kr ks kt b"><strong class="ju hi">TabBar</strong></code><strong class="ju hi"/><code class="du kq kr ks kt b"><strong class="ju hi">Tab</strong></code><strong class="ju hi"/>和<strong class="ju hi"> </strong> <code class="du kq kr ks kt b"><strong class="ju hi">ShellContent</strong></code>对象上，通过它们的<code class="du kq kr ks kt b">Route</code>属性。</p><p id="415b" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">下面是在AppShell.xaml文件中定义路由的示例:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="091f" class="lw iv hh kt b fi lx ly l lz ma">&lt;Shell ...&gt;<br/>    &lt;FlyoutItem ...<br/>                Route="cars"&gt;<br/>        &lt;Tab ...<br/>             Route="tata"&gt;<br/>            &lt;ShellContent ...<br/>                          Route="tataNexon" /&gt;<br/>            &lt;ShellContent ...<br/>                          Route="tataHarrier" /&gt;<br/>        &lt;/Tab&gt;<br/>        &lt;ShellContent ...<br/>                      Route="ford" /&gt;<br/>        &lt;ShellContent ...<br/>                      Route="kia" /&gt;  <br/>        &lt;ShellContent ...<br/>                      Route="honda" /&gt;<br/>    &lt;/FlyoutItem&gt;<br/>                <br/>    ...<br/>&lt;/Shell&gt;</span></pre><p id="5666" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">以上示例创建了以下路线层次结构:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="84a2" class="lw iv hh kt b fi lx ly l lz ma">cars<br/>  tata<br/>    tataNexon<br/>    tataHarrier<br/>  ford<br/>  kia<br/>  honda</span></pre><p id="0e64" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">例如，为了导航到<code class="du kq kr ks kt b">tataHarrier</code>路线的<code class="du kq kr ks kt b">ShellContent</code>对象，绝对路线URI是<code class="du kq kr ks kt b">//cars/tata/tataHarrier</code>。</p><p id="dc6d" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">类似地，为了导航到<code class="du kq kr ks kt b">ford</code>路线的<code class="du kq kr ks kt b">ShellContent</code>对象，绝对路线URI是<code class="du kq kr ks kt b">//ford</code>。</p><p id="58f2" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><strong class="ju hi">明确注册路由</strong></p><p id="a9f1" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在<code class="du kq kr ks kt b">Shell</code>子类构造函数中，或者在路由被调用之前运行的任何其他位置，额外的路由可以被显式地注册到任何没有在Shell可视化层次结构中表示的页面。</p><p id="4ac1" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">这是通过<code class="du kq kr ks kt b"><a class="ae it" href="https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.routing.registerroute" rel="noopener ugc nofollow" target="_blank">Routing.RegisterRoute</a>()</code>方法实现的:</p><p id="93dc" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">下面是注册未在外壳应用程序可视层次结构中定义的页面路由的示例:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="6203" class="lw iv hh kt b fi lx ly l lz ma">Routing.RegisterRoute(“cardetails”, typeof(CarDetailPage));</span></pre><p id="31ff" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">或者，如果需要，可以在不同的路由层次结构中注册页面:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="78f2" class="lw iv hh kt b fi lx ly l lz ma">Routing.RegisterRoute(“car/details”, typeof(CarDetailPage));</span></pre><h1 id="194b" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">执行导航</strong></h1><p id="7101" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">为了执行导航，在shell对象上调用<code class="du kq kr ks kt b"><strong class="ju hi">GoToAsync</strong></code>方法。为了调用GoToAsync方法进行导航，必须获得对Shell对象的引用。这个引用可以通过将<code class="du kq kr ks kt b"><strong class="ju hi">App.Current.MainPage</strong></code>属性赋给shell对象，或者通过<code class="du kq kr ks kt b"><strong class="ju hi">Shell.Current</strong></code>方法来获得。<code class="du kq kr ks kt b"><strong class="ju hi">GoToAsync</strong></code>方法返回一个<code class="du kq kr ks kt b"><strong class="ju hi">Task</strong></code>，它将在导航动画完成后立即完成。</p><p id="a6fc" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><strong class="ju hi">绝对路线</strong></p><p id="bb56" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">通过指定有效的绝对URI作为<code class="du kq kr ks kt b"><strong class="ju hi">GoToAsync</strong></code>方法的参数，可以进行导航:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="61fc" class="lw iv hh kt b fi lx ly l lz ma">await Shell.Current.GoToAsync(“//cars/ford”);</span></pre><p id="768d" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">上面的例子将导航到<code class="du kq kr ks kt b">ford</code>路线的页面，该路线在<code class="du kq kr ks kt b">ShellContent</code>对象中定义。该<code class="du kq kr ks kt b">ShellContent</code>对象是<code class="du kq kr ks kt b">FlyoutItem</code>对象的子对象，其路线为<code class="du kq kr ks kt b">cars</code>。</p><p id="197f" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">这表现在下面的代码片段中:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="0d41" class="lw iv hh kt b fi lx ly l lz ma">&lt;Shell ...&gt;<br/>    &lt;FlyoutItem ...<br/>                Route="cars"&gt;<br/>        <strong class="kt hi">&lt;ShellContent ...<br/>                      Route="ford" /&gt;</strong><br/>       ...</span><span id="6529" class="lw iv hh kt b fi mb ly l lz ma">    &lt;/FlyoutItem&gt;<br/>                <br/>    ...<br/>&lt;/Shell&gt;</span></pre><p id="b9d3" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><strong class="ju hi">相对路线</strong></p><p id="3358" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">也可以通过指定一个有效的相对URI作为<code class="du kq kr ks kt b"><a class="ae it" href="https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.shell.gotoasync" rel="noopener ugc nofollow" target="_blank">GoToAsync</a></code>方法的参数来进行导航。</p><p id="13c2" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">路由系统将尝试找到与URI匹配的页面，并相应地导航到该页面。如果应用程序中的所有路线都是唯一的，则只需将唯一的路线名称指定为相对URI，即可进行导航。</p><p id="3156" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">以下示例导航到<code class="du kq kr ks kt b"><strong class="ju hi">cardetails</strong></code>路线的页面:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="56b3" class="lw iv hh kt b fi lx ly l lz ma">await Shell.Current.GoToAsync(“cardetails”);</span></pre><p id="08f5" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在这个例子中，沿着层级向上搜索<code class="du kq kr ks kt b">cardetails</code>路线，直到找到匹配的页面。当找到页面时，它被推送到导航栈。</p><p id="8f02" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">支持几种路由格式:</p><ol class=""><li id="39f5" class="kz la hh ju b jv ku jz kv kd lb kh lc kl ld kp ln lf lg lh bi translated"><em class="md">路线- &gt; </em>路线层次将从当前位置向上搜索指定路线。匹配的页面将被推送到导航堆栈。</li><li id="8a88" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp ln lf lg lh bi translated">/ <em class="md">路线- &gt; </em>路线层次将从指定路线开始，从当前位置向下搜索。匹配的页面将被推送到导航堆栈。</li><li id="b227" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp ln lf lg lh bi translated">// <em class="md">路线- &gt; </em>将从当前位置向上搜索指定路线的路线层次。匹配的页面将替换导航堆栈。</li><li id="e79b" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp ln lf lg lh bi translated">/// <em class="md">路线- &gt; </em>将从当前位置向下搜索指定路线的路线层次。匹配的页面将替换导航堆栈。</li></ol><p id="484a" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><strong class="ju hi">向后导航</strong></p><ol class=""><li id="b4b5" class="kz la hh ju b jv ku jz kv kd lb kh lc kl ld kp ln lf lg lh bi translated">可以通过指定“..”来执行向后导航作为<code class="du kq kr ks kt b"><a class="ae it" href="https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.shell.gotoasync" rel="noopener ugc nofollow" target="_blank">GoToAsync</a></code>方法的参数:</li></ol><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="e4d2" class="lw iv hh kt b fi lx ly l lz ma">await Shell.Current.GoToAsync(“..”);</span></pre><p id="a20c" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">2.使用“..”向后导航也可以与路线结合使用:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="ebd4" class="lw iv hh kt b fi lx ly l lz ma">await Shell.Current.GoToAsync(“../route”);</span></pre><p id="e7e9" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在上面的例子中，执行向后导航，然后导航到指定的路线。</p><p id="e786" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">3.同样，也可以多次向后导航，然后导航到指定的路线:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="1f47" class="lw iv hh kt b fi lx ly l lz ma">await Shell.Current.GoToAsync(“../../route”);</span></pre><p id="0b3d" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在上面的例子中，向后导航执行两次，然后导航到指定的路线。</p><p id="2a35" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">4.此外，向后导航时，数据可以通过查询属性传递:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="75ed" class="lw iv hh kt b fi lx ly l lz ma">await Shell.Current.GoToAsync($"..?parameterToPassBack={parameterValueToPassBack}");</span></pre><p id="2b76" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在上面的示例中，执行向后导航，并将查询参数值传递给上一页的查询参数。</p><p id="cbe6" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><strong class="ju hi">将查询参数传递给导航URI </strong></p><p id="7347" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在Xamarin中执行导航时，数据可以在URI中作为查询参数传递。窗体外壳应用程序。</p><p id="1b06" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在导航URI中传递查询参数时，可以遵循以下URI格式:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="82bd" class="lw iv hh kt b fi lx ly l lz ma">route?nameofparameter={value of parameter}</span></pre><p id="81ad" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">要将多个查询参数传送至导航URI，请遵循以下格式:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="ec2e" class="lw iv hh kt b fi lx ly l lz ma">route?nameofparameter1={value of parameter1}&amp;nameofparameter2={value of parameter2}</span></pre><p id="27e4" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">例如，当用户选择<code class="du kq kr ks kt b">ElephantsPage</code>上的大象时，在示例应用程序中执行以下代码:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="7340" class="lw iv hh kt b fi lx ly l lz ma">async void OnCollectionViewSelectionChanged(object sender, SelectionChangedEventArgs e)<br/>{<br/>    string carName = (e.CurrentSelection.FirstOrDefault() as Car).CarName;<br/>    await Shell.Current.GoToAsync($"cardetails?name={carName}");<br/>}</span></pre><p id="4937" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><strong class="ju hi">如何接收页面中传递的参数？</strong></p><p id="a1a2" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">使用参数路由的页面，页面的类需要为每个查询参数用一个<code class="du kq kr ks kt b">QueryPropertyAttribute</code>修饰，并且为每个接收查询参数创建属性。</p><p id="7174" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">下面是<strong class="ju hi"> CarDetailPage </strong>的例子，其中页面上将要接收查询参数<strong class="ju hi"> Name </strong>:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="d6a5" class="lw iv hh kt b fi lx ly l lz ma">[QueryProperty(nameof(Name), "name")]<br/>public partial class CarDetailPage : ContentPage<br/>{<br/>    public string Name<br/>    {<br/>        set<br/>        {<br/>            // Custom logic<br/>        }<br/>    }<br/>    ...    <br/>}</span></pre><p id="09f6" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><strong class="ju hi">后退按钮定制:</strong></p><p id="490f" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在Xamarin。窗体外壳应用程序，后退按钮的外观和行为可以定制。</p><p id="721a" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">以下是可以自定义的属性，用于更新Xamarin Shell应用程序中后退按钮的外观和行为:</p><ul class=""><li id="7a22" class="kz la hh ju b jv ku jz kv kd lb kh lc kl ld kp le lf lg lh bi translated"><code class="du kq kr ks kt b">Command:</code>定义点击后退按钮时可以调用的命令。</li><li id="a466" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated"><code class="du kq kr ks kt b">CommandParameter:</code>定义了可以传递给命令的参数。</li><li id="a1cb" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated"><code class="du kq kr ks kt b">IconOverride:</code>定义后退按钮的图标。</li><li id="4a28" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated"><code class="du kq kr ks kt b">IsEnabled:</code>表示后退按钮是否启用。默认值为<code class="du kq kr ks kt b">true</code>。</li><li id="fc67" class="kz la hh ju b jv li jz lj kd lk kh ll kl lm kp le lf lg lh bi translated"><code class="du kq kr ks kt b">TextOverride:</code>定义用于后退按钮的文本。</li></ul><p id="f272" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">以下代码显示了重新定义后退按钮外观和行为的示例:</p><pre class="lo lp lq lr fd ls kt lt lu aw lv bi"><span id="1457" class="lw iv hh kt b fi lx ly l lz ma">&lt;ContentPage ...&gt;    <br/>    &lt;Shell.BackButtonBehavior&gt;<br/>        &lt;BackButtonBehavior Command="{Binding BackCommand}"<br/>                            IconOverride="back.png" /&gt;   <br/>    &lt;/Shell.BackButtonBehavior&gt;<br/>    ...<br/>&lt;/ContentPage&gt;</span></pre><p id="9a36" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><strong class="ju hi">总结</strong></p><p id="c8f8" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">Xamarin。Forms Shell将构建应用程序的一些复杂性抽象到一个直观的API中，使移动应用程序开发人员可以轻松管理导航，并将更多精力放在Xamarin应用程序的功能上。本文将带您了解如何从Xamarin开始。窗体外壳应用程序。它还让您了解Xamarin Shell的主要特性，以及如何在Xamarin中管理导航。窗体外壳应用程序。</p><p id="5027" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">示例源代码:<a class="ae it" href="https://github.com/ajpalan/Cars_XamarinShell" rel="noopener ugc nofollow" target="_blank">https://github.com/ajpalan/Cars_XamarinShell</a></p><p id="cb81" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">参考资料:</p><div class="me mf ez fb mg mh"><a href="https://docs.microsoft.com/en-us/xamarin/xamarin-forms/app-fundamentals/shell/navigation" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hi fi z dy mm ea eb mn ed ef hg bi translated">Xamarin。窗体外壳导航- Xamarin</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">下载示例Xamarin。Forms Shell包括一个基于URI的导航体验，使用路线导航到任何…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">docs.microsoft.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv in mh"/></div></div></a></div><div class="me mf ez fb mg mh"><a href="https://docs.microsoft.com/en-us/xamarin/xamarin-forms/app-fundamentals/shell/introduction" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hi fi z dy mm ea eb mn ed ef hg bi translated">Xamarin。表单外壳简介- Xamarin</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">下载示例Xamarin。Forms Shell通过提供……降低了移动应用程序开发的复杂性</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">docs.microsoft.com</p></div></div><div class="mq l"><div class="mw l ms mt mu mq mv in mh"/></div></div></a></div><div class="me mf ez fb mg mh"><a href="https://www.telerik.com/blogs/introduction-to-xamarin.forms-shell" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hi fi z dy mm ea eb mn ed ef hg bi translated">Xamarin简介。表单外壳</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">新的Xamarin。Forms Shell旨在提高移动开发人员的工作效率。应用程序内容组织和导航是…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">www.telerik.com</p></div></div><div class="mq l"><div class="mx l ms mt mu mq mv in mh"/></div></div></a></div><div class="me mf ez fb mg mh"><a href="https://www.knowledgehut.com/blog/software-testing/xamarin-forms-shell" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab dw"><div class="mj ab mk cl cj ml"><h2 class="bd hi fi z dy mm ea eb mn ed ef hg bi translated">Xamarin表单简介- Shell</h2><div class="mo l"><h3 class="bd b fi z dy mm ea eb mn ed ef dx translated">Xamarin Forms Shell通过提供以下基本功能降低了移动应用程序开发的复杂性…</h3></div><div class="mp l"><p class="bd b fp z dy mm ea eb mn ed ef dx translated">www.knowledgehut.com</p></div></div><div class="mq l"><div class="my l ms mt mu mq mv in mh"/></div></div></a></div></div></div>    
</body>
</html>