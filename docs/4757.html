<html>
<head>
<title>Do React Hooks Replace Redux?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React钩子会取代Redux吗？</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/do-react-hooks-replace-redux-210bab340672?source=collection_archive---------0-----------------------#2019-07-25">https://medium.com/javascript-scene/do-react-hooks-replace-redux-210bab340672?source=collection_archive---------0-----------------------#2019-07-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="4b16" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">TL；大卫:钩子很棒，但是不行。</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/830a23d13cf90c974aedfaf4128cd16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJ2obPBc-qMV1tU9wIEEvA.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Mandarin Duck — Malcolm Carlaw (CC-BY-2.0)</figcaption></figure><p id="9a0f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">自从引入React hooks API以来，出现了许多关于React hooks是否会取代Redux的问题。</p><p id="b37e" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在我看来，hooks和Redux之间几乎没有重叠。钩子没有给我们神奇的新状态能力。相反，它为我们已经可以用React做的事情增强了API。然而，hooks API使得原生的React state API变得更加可用，并且因为它比它所取代的<code class="du ki kj kk kl b">class</code>模型更容易，所以在适当的时候，我比以前使用<em class="km">更多地使用组件状态。</em></p><p id="0f4f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为了理解我的意思，我们首先需要更好地理解为什么我们会考虑Redux。</p><h2 id="ab39" class="kn ko hh bd kp kq kr ks kt ku kv kw kx jv ky kz la jz lb lc ld kd le lf lg lh bi translated">Redux是什么？</h2><p id="e842" class="pw-post-body-paragraph jm jn hh jo b jp li ii jr js lj il ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">Redux是一个可预测的状态管理库<em class="km">和架构</em>，很容易与React集成。</p><p id="0cda" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Redux的主要卖点是:</p><ul class=""><li id="b7fd" class="ln lo hh jo b jp jq js jt jv lp jz lq kd lr kh ls lt lu lv bi translated"><strong class="jo hi">确定性状态解析</strong>(结合纯组件时启用确定性视图渲染)。</li><li id="9cd1" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">事务性状态。</strong></li><li id="8a00" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">将状态管理</strong>与I/O和副作用隔离开来。</li><li id="b003" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">应用状态的单一真实来源</strong>。</li><li id="b8d4" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">不同组件之间轻松共享状态</strong> <em class="km">。</em></li><li id="54c5" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">交易遥测</strong>(自动记录动作对象)。</li><li id="344a" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">时间旅行调试。</strong></li></ul><p id="3904" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">换句话说，Redux给了你代码组织和调试的超能力。它使得构建更易维护的代码变得更容易，并且在出错时更容易找到根本原因。</p><h2 id="e1e2" class="kn ko hh bd kp kq kr ks kt ku kv kw kx jv ky kz la jz lb lc ld kd le lf lg lh bi translated">什么是React钩子？</h2><p id="99ec" class="pw-post-body-paragraph jm jn hh jo b jp li ii jr js lj il ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">React挂钩允许您使用状态和React生命周期特性，而无需使用<code class="du ki kj kk kl b">class</code>和React组件生命周期方法。它们是在React 16.8中引入的。</p><p id="5e7f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">React挂钩的主要卖点是:</p><ul class=""><li id="db28" class="ln lo hh jo b jp jq js jt jv lp jz lq kd lr kh ls lt lu lv bi translated"><strong class="jo hi">使用状态并挂钩到组件生命周期</strong>而不使用<code class="du ki kj kk kl b">class</code>。</li><li id="7bc8" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated">把相关的逻辑放在你的组件中的一个地方，而不是把它分割在不同的生命周期方法中。</li><li id="8a55" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">共享独立于组件实现的可重用行为</strong>(如<a class="ae mb" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具模式</a>)。</li></ul><p id="da94" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">请注意，这些奇妙的好处并没有真正与Redux的好处重叠。您可以并且应该使用React钩子来获得确定性状态更新，但是这一直是React的一个特性，Redux的确定性状态模型很好地插入了它。这就是React提供确定性视图渲染的方式，也是React的创建动机之一。</p><p id="f7a1" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">有了像<a class="ae mb" href="https://react-redux.js.org/next/api/hooks" rel="noopener ugc nofollow" target="_blank"> react-redux hooks API </a>和<a class="ae mb" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank"> React的useReducer hook </a>这样的工具，就没有必要二选一了。两者都用。混搭。</p><h2 id="3c63" class="kn ko hh bd kp kq kr ks kt ku kv kw kx jv ky kz la jz lb lc ld kd le lf lg lh bi translated">挂钩替代什么？</h2><p id="2ceb" class="pw-post-body-paragraph jm jn hh jo b jp li ii jr js lj il ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">自从hooks API推出以来，我已经停止使用:</p><ul class=""><li id="4345" class="ln lo hh jo b jp jq js jt jv lp jz lq kd lr kh ls lt lu lv bi translated"><code class="du ki kj kk kl b"><strong class="jo hi">class</strong></code> <strong class="jo hi">组件。</strong></li><li id="21d1" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi"/><a class="ae mb" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank"><strong class="jo hi">渲染道具</strong> </a> <strong class="jo hi">图案。</strong></li></ul><h2 id="a0f6" class="kn ko hh bd kp kq kr ks kt ku kv kw kx jv ky kz la jz lb lc ld kd le lf lg lh bi translated">挂钩不替代什么？</h2><p id="e934" class="pw-post-body-paragraph jm jn hh jo b jp li ii jr js lj il ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">我仍然经常使用:</p><ul class=""><li id="5746" class="ln lo hh jo b jp jq js jt jv lp jz lq kd lr kh ls lt lu lv bi translated"><strong class="jo hi">基于上面列出的所有原因，Redux </strong>。</li><li id="e55d" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">更高阶的组件</strong>组成我的所有或大部分应用程序视图共享的横切关注点，比如Redux提供者、公共布局提供者、配置提供者、认证/授权、i18n等等。</li><li id="9b34" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">容器和显示组件之间的分离</strong>为了更好的模块化、可测试性，以及效果和纯逻辑之间更容易的分离。</li></ul><h2 id="88f4" class="kn ko hh bd kp kq kr ks kt ku kv kw kx jv ky kz la jz lb lc ld kd le lf lg lh bi translated">何时使用钩子</h2><p id="6efc" class="pw-post-body-paragraph jm jn hh jo b jp li ii jr js lj il ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">你不需要总是为每个应用程序或每个组件使用Redux。如果你的应用程序由单一视图组成，不保存或加载状态，没有异步I/O，我想不出一个好的理由来增加Redux的复杂性。</p><p id="b9e9" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">同样，如果您的组件:</p><ul class=""><li id="52af" class="ln lo hh jo b jp jq js jt jv lp jz lq kd lr kh ls lt lu lv bi translated"><strong class="jo hi">不使用网络。</strong></li><li id="0aa4" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">不保存或加载状态。</strong></li><li id="e026" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">不与其他非子组件共享状态</strong>。</li><li id="eb2e" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">确实需要一些短暂的局部组件状态。</strong></li></ul><p id="ce92" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">对于React的内置组件状态模型，您可能有一个很好的用例。在这些情况下，React hooks将为您提供很好的服务。例如，下面的表单使用React中的本地组件状态<code class="du ki kj kk kl b">useState</code>钩子。</p><pre class="ix iy iz ja fd mc kl md me aw mf bi"><span id="8f65" class="kn ko hh kl b fi mg mh l mi mj">import React, { useState } from 'react';<br/>import t from 'prop-types';<br/>import TextField, { Input } from '<a class="ae mb" href="http://twitter.com/material/react-text-field" rel="noopener ugc nofollow" target="_blank">@material/react-text-field</a>';</span><span id="2cc6" class="kn ko hh kl b fi mk mh l mi mj">const noop = () =&gt; {};</span><span id="ddd5" class="kn ko hh kl b fi mk mh l mi mj">const Holder = ({<br/>  itemPrice = 175,<br/>  name = '',<br/>  email = '',<br/>  id = '',<br/>  removeHolder = noop,<br/>  showRemoveButton = false,<br/>}) =&gt; {<br/>  const [nameInput, setName] = useState(name);<br/>  const [emailInput, setEmail] = useState(email);</span><span id="65da" class="kn ko hh kl b fi mk mh l mi mj">const setter = set =&gt; e =&gt; {<br/>    const { target } = e;<br/>    const { value } = target;<br/>    set(value);<br/>  };</span><span id="1000" class="kn ko hh kl b fi mk mh l mi mj">return (<br/>    &lt;div className="row"&gt;<br/>      &lt;div className="holder"&gt;<br/>        &lt;div className="holder-name"&gt;<br/>          &lt;TextField label="Name"&gt;<br/>            &lt;Input value={nameInput} onChange={setter(setName)} required /&gt;<br/>          &lt;/TextField&gt;<br/>        &lt;/div&gt;<br/>        &lt;div className="holder-email"&gt;<br/>          &lt;TextField label="Email"&gt;<br/>            &lt;Input<br/>              value={emailInput}<br/>              onChange={setter(setEmail)}<br/>              type="email"<br/>              required<br/>            /&gt;<br/>          &lt;/TextField&gt;<br/>        &lt;/div&gt;<br/>        {showRemoveButton &amp;&amp; (<br/>          &lt;button<br/>            className="remove-holder"<br/>            aria-label="Remove membership"<br/>            onClick={e =&gt; {<br/>              e.preventDefault();<br/>              removeHolder(id);<br/>            }}<br/>          &gt;<br/>            &amp;times;<br/>          &lt;/button&gt;<br/>        )}<br/>      &lt;/div&gt;<br/>      &lt;div className="line-item-price"&gt;${itemPrice}&lt;/div&gt;<br/>      &lt;style jsx&gt;{cssHere}&lt;/style&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/>Holder.propTypes = {<br/>  name: t.string,<br/>  email: t.string,<br/>  itemPrice: t.number,<br/>  id: t.string,<br/>  removeHolder: t.func,<br/>  showRemoveButton: t.bool,<br/>};</span><span id="36e5" class="kn ko hh kl b fi mk mh l mi mj">export default Holder;</span></pre><p id="188d" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这段代码使用<code class="du ki kj kk kl b">useState</code>来跟踪姓名和电子邮件的短暂表单输入状态:</p><pre class="ix iy iz ja fd mc kl md me aw mf bi"><span id="1293" class="kn ko hh kl b fi mg mh l mi mj">const [nameInput, setName] = useState(name);<br/>const [emailInput, setEmail] = useState(email);</span></pre><p id="c630" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">你可能会注意到Redux的道具中也加入了一个<code class="du ki kj kk kl b">removeHolder</code>动作创建器。混搭就可以了。</p><p id="78a8" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">像这样使用本地组件状态总是很好的，但是在React hooks之前，我可能会想把它塞进Redux并从props中取出状态。</p><p id="8fd7" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">使用组件状态意味着使用一个<code class="du ki kj kk kl b">class</code>组件，用<code class="du ki kj kk kl b">class</code>实例属性语法(或者一个<code class="du ki kj kk kl b">constructor</code>函数)设置初始状态，等等——仅仅为了避免重复就增加了太多的复杂性。有一些即插即用的工具可以用Redux管理表单状态，这很有帮助，所以我不必担心短暂的表单状态会渗入到我的业务逻辑中。</p><p id="73d1" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因为我已经在所有重要的应用程序中使用Redux，所以选择很简单:Redux(几乎)所有的东西！</p><p id="114b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">现在选择仍然很简单:</p><blockquote class="ml"><p id="9a13" class="mm mn hh bd mo mp mq mr ms mt mu kh dx translated">组件状态为组件状态，Redux为应用程序状态。</p></blockquote><h2 id="1931" class="kn ko hh bd kp kq mv ks kt ku mw kw kx jv mx kz la jz my lc ld kd mz lf lg lh bi translated">何时使用Redux</h2><p id="dbff" class="pw-post-body-paragraph jm jn hh jo b jp li ii jr js lj il ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">另一个常见的问题是<em class="km">“应该把所有东西都放在Redux里吗？不这样不会破时间旅行调试吗？”</em></p><p id="a8b7" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">不，因为应用程序中有许多状态是<em class="km">短暂的</em>和<em class="km">太细粒度的</em>，无法为日志记录遥测或时间旅行调试之类的事情提供非常有用的信息。除非您正在构建一个实时协作编辑器，否则您可能不需要将每个用户按键或鼠标移动都置于Redux状态。当您向Redux state添加内容时，您添加了一个抽象层以及随之而来的复杂性。</p><p id="833d" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">换句话说，你应该可以随意使用Redux，但是当你这样做的时候，你应该有一个理由。</p><p id="0bd3" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果您的组件:</p><ul class=""><li id="e43f" class="ln lo hh jo b jp jq js jt jv lp jz lq kd lr kh ls lt lu lv bi translated"><strong class="jo hi">使用类似网络或设备API的I/O。</strong></li><li id="1113" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">保存或加载状态。</strong></li><li id="e8c3" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">与非子组件共享其状态。</strong></li><li id="dea5" class="ln lo hh jo b jp lw js lx jv ly jz lz kd ma kh ls lt lu lv bi translated"><strong class="jo hi">处理与应用程序其他部分共享的任何业务逻辑或数据处理。</strong></li></ul><p id="d09e" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这是另一个来自<a class="ae mb" href="https://tddday.com/" rel="noopener ugc nofollow" target="_blank">TDD day应用</a>的例子:</p><pre class="ix iy iz ja fd mc kl md me aw mf bi"><span id="5f2d" class="kn ko hh kl b fi mg mh l mi mj">import React from 'react';<br/>import { useDispatch, useSelector } from 'react-redux';<br/>import { compose } from 'ramda';</span><span id="efc3" class="kn ko hh kl b fi mk mh l mi mj">import page from '../../hocs/page.js';<br/>import Purchase from './purchase-component.js';<br/>import { addHolder, removeHolder, getHolders } from './purchase-reducer.js';</span><span id="9f67" class="kn ko hh kl b fi mk mh l mi mj">const PurchasePage = () =&gt; {<br/>  // You can use these instead of<br/>  // mapStateToProps and mapDispatchToProps<br/>  const dispatch = useDispatch();<br/>  const holders = useSelector(getHolders);</span><span id="0820" class="kn ko hh kl b fi mk mh l mi mj">const props = {<br/>    // Use function composition to compose action creators<br/>    // with dispatch. See <a class="ae mb" rel="noopener" href="/javascript-scene/composing-software-the-book-f31c77fc3ddc">"Composing Software"</a> for details.<br/>    addHolder: compose(<br/>      dispatch,<br/>      addHolder<br/>    ),<br/>    removeHolder: compose(<br/>      dispatch,<br/>      removeHolder<br/>    ),<br/>    holders,<br/>  };</span><span id="e1e3" class="kn ko hh kl b fi mk mh l mi mj">return &lt;Purchase {...props} /&gt;;<br/>};</span><span id="c314" class="kn ko hh kl b fi mk mh l mi mj">// `page` is a Higher Order Component composed of many<br/>// other higher order components using function composition.<br/>export default page(PurchasePage);</span></pre><p id="f0bf" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这个组件不处理任何DOM。它是一个容器组件，将DOM问题委托给一个导入的表示组件。它使用<a class="ae mb" href="https://react-redux.js.org/next/api/hooks" rel="noopener ugc nofollow" target="_blank"> React-Redux钩子API </a>连接到Redux。</p><p id="0375" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">它使用Redux是因为我们需要这个表单在UI的其他部分关心的数据，当我们完成购买流程时，我们需要将数据保存到数据库中。</p><p id="2f8d" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">它所关心的状态是在组件之间共享的，而不是局限于单个组件，它是持久的而不是短暂的，并且它可能跨越多个页面视图或会话。这些都是本地组件状态无法解决的问题，除非您在React API上构建自己的状态容器库——这比仅仅使用Redux要复杂得多。</p><p id="a971" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">未来，React的<a class="ae mb" href="https://reactjs.org/docs/react-api.html#suspense" rel="noopener ugc nofollow" target="_blank">悬念API </a>可能会帮助保存和加载状态。我们需要等到悬念API登陆，看看它是否能取代我在Redux中的保存/加载模式。Redux允许我们干净地将副作用与组件逻辑的其余部分分开，而不需要我们模仿I/O服务。(隔离效果是我更喜欢《T4》的原因。为了与这个用例竞争Redux，React的API需要提供效果隔离。</p><h2 id="388e" class="kn ko hh bd kp kq kr ks kt ku kv kw kx jv ky kz la jz lb lc ld kd le lf lg lh bi translated">Redux是建筑</h2><p id="56f8" class="pw-post-body-paragraph jm jn hh jo b jp li ii jr js lj il ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">Redux比状态管理库要多得多(通常也少得多)。它本质上也是<a class="ae mb" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> Flux架构</a>的一个子集，后者对于状态变化是如何发生的更加固执己见。我有另一篇博文，更深入地详述了Redux架构。</p><p id="bbc0" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">当我需要复杂的组件状态但不需要redux库时，我经常使用Redux风格的Redux。我还使用redux风格的动作(甚至Redux工具，如<a class="ae mb" href="https://github.com/ericelliott/autodux" rel="noopener ugc nofollow" target="_blank"> Autodux </a>和<a class="ae mb" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> redux-saga </a>)来调度节点应用程序中的动作，而无需导入Redux库。</p><p id="2357" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Redux一直比library更有架构和不强制的约定。事实上，Redux的基本实现可以在几十行代码中重现。</p><p id="4e5a" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你想开始在hooks API中使用更多的本地组件状态，而不是重复所有的事情，这是一个好消息。</p><p id="ee46" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">React提供了一个<code class="du ki kj kk kl b">useReducer</code>钩子，它将与Redux风格的减速器接口。这对于非平凡的状态逻辑、依赖状态等非常有用。如果您有一个用例，您认为您可以将短暂的状态包含到单个组件中，那么您可以使用Redux架构，但是使用<code class="du ki kj kk kl b">useReducer</code>钩子而不是Redux来管理状态。</p><p id="c0bd" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果您稍后需要保持或共享状态，那么您已经完成了90%。剩下的工作就是连接组件，并将缩减器添加到Redux存储中。</p><h2 id="e9af" class="kn ko hh bd kp kq kr ks kt ku kv kw kx jv ky kz la jz lb lc ld kd le lf lg lh bi translated">更多问答</h2><blockquote class="na nb nc"><p id="6633" class="jm jn km jo b jp jq ii jr js jt il ju nd jw jx jy ne ka kb kc nf ke kf kg kh ha bi translated">"如果所有东西都不在Redux中，决定论会被打破吗？"</p></blockquote><p id="ae2b" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">不。事实上，Redux也不强制执行决定论。惯例会。如果你希望你的Redux状态是确定的，<a class="ae mb" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976">使用纯函数</a>。如果你希望你的临时组件状态是确定的，使用纯函数。</p><blockquote class="na nb nc"><p id="9489" class="jm jn km jo b jp jq ii jr js jt il ju nd jw jx jy ne ka kb kc nf ke kf kg kh ha bi translated">"难道你不需要Redux作为真理的单一来源吗？"</p></blockquote><p id="5e67" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">真理的单一来源原则并没有说你需要你所有的状态都来自单一的来源。相反，它意味着对于每一个国家，应该有一个单一的真理来源。你可以有许多不同的状态，每一个都有自己唯一的真相来源。</p><p id="49c2" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这意味着你可以选择什么进入Redux，什么进入组件状态。您还可以从其他来源获取状态，比如当前位置的浏览器href。</p><p id="b12d" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">Redux是维护应用程序状态的单一真实来源的好方法，但是如果您的组件状态局限于单个组件，并且只在一个地方使用，根据定义，它已经有了该状态的单一真实来源:React组件状态。</p><p id="fdc0" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你把一些东西放入Redux状态，你应该总是从Redux状态读取它。对于Redux中所有状态，Redux应该是该状态的唯一真实来源。</p><p id="692f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果需要的话把所有东西都放在Redux里也没问题。对于需要频繁更新的状态，或者具有大量依赖状态的组件，可能会有性能影响。您不应该担心性能，除非它成为一个问题，但当您这样做时，尝试两种方法，看看它是否有影响。简档，并记住铁路性能模型。</p><blockquote class="na nb nc"><p id="4d2e" class="jm jn km jo b jp jq ii jr js jt il ju nd jw jx jy ne ka kb kc nf ke kf kg kh ha bi translated">"我应该使用react-redux connect，还是hooks API？"</p></blockquote><p id="c86f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">那得看情况。创建一个可重用的高阶组件，而hooks API针对与单个组件的集成进行了优化。是否需要将相同的商店道具连接到其他组件？跟<code class="du ki kj kk kl b">connect</code>走。否则，我更喜欢hooks API的读法。例如，假设您有一个为用户操作处理许可授权的组件:</p><pre class="ix iy iz ja fd mc kl md me aw mf bi"><span id="c8f6" class="kn ko hh kl b fi mg mh l mi mj">import { connect } from 'react-redux';<br/>import RequiresPermission from './requires-permission-component';<br/>import { userHasPermission } from '../../features/user-profile/user-profile-reducer';<br/>import curry from 'lodash/fp/curry';<br/><br/>const requiresPermission = curry(<br/>  (NotPermittedComponent, { permission }, PermittedComponent) =&gt; {<br/>    const mapStateToProps = state =&gt; ({<br/>      NotPermittedComponent,<br/>      PermittedComponent,<br/>      isPermitted: userHasPermission(state, permission),<br/>    });<br/><br/>    return connect(mapStateToProps)(RequiresPermission);<br/>  },<br/>);<br/><br/>export default requiresPermission;</span></pre><p id="c727" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">现在，如果您有一堆管理视图，它们都需要管理权限，那么您可以创建一个更高级的组件，将所有这些视图的权限要求与所有其他横切关注点结合起来:</p><pre class="ix iy iz ja fd mc kl md me aw mf bi"><span id="d4a0" class="kn ko hh kl b fi mg mh l mi mj">import NextError from 'next/error';<br/>import compose from 'lodash/fp/compose';<br/>import React from 'react';<br/>import requiresPermission from '../requires-permission';<br/>import withFeatures from '../with-features';<br/>import withAuth from '../with-auth';<br/>import withEnv from '../with-env';<br/>import withLoader from '../with-loader';<br/>import withLayout from '../with-layout';<br/><br/>export default compose(<br/>  withEnv,<br/>  withAuth,<br/>  withLoader,<br/>  withLayout(),<br/>  withFeatures,<br/>  requiresPermission(() =&gt; &lt;NextError statusCode={404} /&gt;, {<br/>    permission: 'admin',<br/>  }),<br/>);</span></pre><p id="c15e" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">要使用它:</p><pre class="ix iy iz ja fd mc kl md me aw mf bi"><span id="816b" class="kn ko hh kl b fi mg mh l mi mj">import compose from 'lodash/fp/compose';<br/>import adminPage from '../HOCs/admin-page';<br/>import AdminIndex from '../features/admin-index/admin-index-component.js';<br/><br/>export default adminPage(AdminIndex);</span></pre><p id="1414" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">高阶组件API对于这个用例来说很方便，它实际上比钩子API更简洁(它需要更少的代码)，但是为了阅读<code class="du ki kj kk kl b">connect</code> API，你必须记住它把<code class="du ki kj kk kl b">mapStateToProps</code>作为第一个参数，把<code class="du ki kj kk kl b">mapDispatchToProps</code>作为第二个参数，你应该知道它可以接受函数或对象文字，你应该知道这些行为的区别。你还需要记住，这是咖喱，但不是自动咖喱。</p><p id="f848" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">换句话说，我发现<code class="du ki kj kk kl b">connect</code> API用简洁的代码完成了这项工作，但它不是特别易读或符合人体工程学。如果我不需要为其他组件重用该连接，我更喜欢可读性更好的hooks API，尽管它涉及的输入稍微多一点。</p><blockquote class="na nb nc"><p id="38ac" class="jm jn km jo b jp jq ii jr js jt il ju nd jw jx jy ne ka kb kc nf ke kf kg kh ha bi translated">"如果单例是反模式，Redux是单例，那么Redux不是反模式吗？"</p></blockquote><p id="b945" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">不，单例是一种代码气味，它可能表明<em class="km">共享的可变状态，</em>才是真正的反模式。Redux通过封装(您不应该直接在reducers之外改变应用程序状态，相反，Redux处理状态更新)和消息传递(只有调度的动作对象可以触发状态更新)来防止共享的可变状态。</p><h2 id="e795" class="kn ko hh bd kp kq kr ks kt ku kv kw kx jv ky kz la jz lb lc ld kd le lf lg lh bi translated">后续步骤</h2><p id="42a9" class="pw-post-body-paragraph jm jn hh jo b jp li ii jr js lj il ju jv lk jx jy jz ll kb kc kd lm kf kg kh ha bi translated">在<a class="ae mb" href="https://ericelliottjs.com/" rel="noopener ugc nofollow" target="_blank">EricElliottJS.com</a>上了解更多关于React和Redux的信息。本文代码示例中使用的函数模式(如函数组合和部分应用程序)通过大量示例和视频演练进行了深入讨论。</p><p id="0194" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">学习<a class="ae mb" rel="noopener" href="/javascript-scene/unit-testing-react-components-aeda9a44aae2">如何单元测试React组件</a>，说到测试，学习<a class="ae mb" href="https://tddday.com/" rel="noopener ugc nofollow" target="_blank">TDDDay.com</a>上的测试驱动开发(TDD)。</p></div><div class="ab cl ng nh go ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ha hb hc hd he"><p id="1e4f" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hi"> <em class="km">埃里克·艾略特</em> </strong> <em class="km">是一位科技产品和平台顾问，《T5】 <a class="ae mb" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank"> <em class="km">【作曲软件】</em></a><em class="km"/><a class="ae mb" href="https://ericelliottjs.com" rel="noopener ugc nofollow" target="_blank"><em class="km">【EricElliottJS.com】</em></a><em class="km"/><a class="ae mb" href="https://devanywhere.io" rel="noopener ugc nofollow" target="_blank"><em class="km">devanywhere . io</em></a><em class="km">的联合创始人，以及dev团队导师。他曾为Adobe Systems、</em> <strong class="jo hi"> <em class="km">、Zumba Fitness、</em> </strong> <em class="km"> </em> <strong class="jo hi"> <em class="km">【华尔街日报、</em></strong><em class="km"/><strong class="jo hi"><em class="km">【ESPN、</em></strong><em class="km"/><strong class="jo hi"><em class="km">【BBC】</em></strong><em class="km">等顶级录音艺人和包括</em> <strong class="jo hi"> <em class="km"> Usher、【Metallica】</em></strong></em></p><p id="5a69" class="pw-post-body-paragraph jm jn hh jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">他和世界上最美丽的女人享受着与世隔绝的生活方式。</p></div></div>    
</body>
</html>