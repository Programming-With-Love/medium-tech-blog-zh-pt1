<html>
<head>
<title>Kotlin programmer dictionary: Function vs Method vs Procedure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林程序员词典:函数vs方法vs过程</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87?source=collection_archive---------1-----------------------#2017-10-26">https://blog.kotlin-academy.com/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87?source=collection_archive---------1-----------------------#2017-10-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="afe1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">函数</strong>和<strong class="jm io">方法</strong>是两个经常混淆的词。虽然每个<strong class="jm io">方法都是函数</strong>，<strong class="jm io">但并不是每个函数都是方法</strong>。还有一个词被错误地互换使用:一个<strong class="jm io">程序</strong>。让我们讨论一下所有这些术语之间的区别。</p><h1 id="58e6" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">函数与过程</h1><p id="0de6" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在旧的编程语言中，<strong class="jm io">函数</strong>和<strong class="jm io">过程</strong>之间的区别很重要。例如，在Pascal <strong class="jm io">中，函数</strong>和<strong class="jm io">过程</strong>是使用不同的关键字定义的。这两个概念之间的形式差异如下:</p><blockquote class="ll lm ln"><p id="1984" class="jk jl lo jm b jn jo jp jq jr js jt ju lp jw jx jy lq ka kb kc lr ke kf kg kh ig bi translated"><strong class="jm io">函数</strong>返回值，而<strong class="jm io">过程</strong>不返回值。</p></blockquote><p id="eb2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果它们如此相似，那么为什么它们会被区分开来呢？真正的原因是，函数式和过程式程序设计的良好实践声称，过程应该只用于调用一组操作，函数应该只用于计算返回值(它们应该没有副作用)。这种良好的设计实践被严重滥用。开发者使用过程来修改由参数(例如<code class="fe ls lt lu lv b">sort(list)</code>)和函数提供的对象，以调用一些操作并返回一些通知结果的数据(例如<code class="fe ls lt lu lv b">int success = saveData(data)</code>)。这样就消除了<strong class="jm io">功能</strong>和<strong class="jm io">程序</strong>之间的区别。</p><p id="c995" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还能定义一个<strong class="jm io">程序</strong>吗？我们可以用Java来实现，因为每个不指定return <a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e"> type </a>的方法都是一个过程:</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="c878" class="mf kj in lv b gy mg mh l mi mj">void<strong class="lv io"> </strong>printUser(User user) {<br/>    System.<em class="lo">out</em>.println(user);<br/>}</span></pre><p id="94bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在Kotlin中没有过程，因为每个函数至少返回<code class="fe ls lt lu lv b">Unit</code>对象。注意，<code class="fe ls lt lu lv b">printUser</code>过程的直接模拟是Kotlin中的一个函数，因为它返回<code class="fe ls lt lu lv b">Unit</code>:</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="d362" class="mf kj in lv b gy mg mh l mi mj">fun printUser(user: User) {<br/>    println(user)<br/>}</span><span id="2069" class="mf kj in lv b gy mk mh l mi mj">val result = printUser(user)<br/>print(result is Unit) // Prints: true</span></pre><p id="a671" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有些人称这种功能为“过程”,我认为这没有什么不对。但是你可以放心地忘记Kotlin中的这个词，你将正式正确。这很好，因为你使用的行业术语越少，普通观众就越容易理解。</p><figure class="lx ly lz ma gt mm gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/e701b1e13036bdb67e751f484065d9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*FmHpQYIdYtO9E0wo.png"/></div></figure><h1 id="d247" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">函数与方法</h1><p id="921e" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">另一个很大的困惑是<strong class="jm io">函数</strong>和<strong class="jm io">方法</strong>之间。区别如下:</p><blockquote class="ll lm ln"><p id="f922" class="jk jl lo jm b jn jo jp jq jr js jt ju lp jw jx jy lq ka kb kc lr ke kf kg kh ig bi translated"><strong class="jm io">方法</strong>是与<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">对象</a>关联的<strong class="jm io">函数</strong>。</p></blockquote><p id="b246" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">函数是一个更通用的术语，<strong class="jm io">所有的方法也是函数</strong>。那么什么是<strong class="jm io">方法</strong>？肯定所有成员函数和成员属性访问器都是<strong class="jm io">方法</strong>:</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="aed5" class="mf kj in lv b gy mg mh l mi mj">class A {<br/>   fun someMethod() {}<br/>}</span></pre><blockquote class="ll lm ln"><p id="32a5" class="jk jl lo jm b jn jo jp jq jr js jt ju lp jw jx jy lq ka kb kc lr ke kf kg kh ig bi translated">在OOP中，<a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类</a>拥有代表其数据和行为的<strong class="jm io">成员</strong>。Kotlin类的成员要么是方法，要么是属性。这就是为什么在类中定义的属性被称为<strong class="jm io">成员属性</strong>，而不是与任何类都没有关联的<strong class="jm io">顶级属性</strong>。</p></blockquote><p id="9ebb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Java静态方法呢？这是值得商榷的。一方面，Java术语通常将它们命名为<strong class="jm io">方法</strong>。另一方面，许多大学权威人士认为它们不是，因为它们与类相关，而不是与对象相关。肯定所有的顶级函数都是<strong class="jm io">而不是方法</strong>。</p><p id="74a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更有问题的是<em class="lo">伴随对象</em>和<em class="lo">对象声明</em>的函数。<em class="lo">伴随对象</em>函数通常被用作Java静态函数的类似物，它们不是方法:</p><pre class="lx ly lz ma gt mb lv mc md aw me bi"><span id="a11c" class="mf kj in lv b gy mg mh l mi mj">class MainActivity: Activity() {<br/>    <br/>    companion object {<br/>        fun start(context: Context) {<br/>            val intent = Intent(this, MainActivity::class.java)    <br/>            context.startActivity(intent)<br/>        }<br/>    }<br/>}</span></pre><p id="e70e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，<em class="lo">伴随对象</em>实际上是一个<em class="lo">对象声明</em>。<em class="lo">对象声明</em>实际上是单例模式的Kotlin实现，它的所有函数<strong class="jm io">都与这个单例对象实例</strong>相关联。因此它们是<strong class="jm io">方法</strong>。</p><p id="d8ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">扩展函数呢？成员扩展函数和所有成员函数一样，都是<strong class="jm io">方法</strong>。顶层扩展函数被编译成静态函数，receiver作为第一个<a class="ae lw" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">参数</a>放置。他们不是会员。另一方面，通常说它们与接收者类型相关联，基于这种推理，我们也可以称它们为方法。在C#命名法中，它们被称为<strong class="jm io">扩展方法</strong>，我认为在这里这样命名它们是完全合理的。</p><p id="ad24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，Kotlin使用的是<strong class="jm io">函数</strong>的快捷方式<code class="fe ls lt lu lv b">fun</code>关键字。这是绝对正确的，而函数是更一般的词，包括<strong class="jm io">方法</strong>，在Kotlin中没有<strong class="jm io">过程</strong>。智能:)</p><p id="00a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的措辞中，我们可能总是使用<strong class="jm io">函数</strong>，因为这是一个包含<strong class="jm io">方法</strong>的更通用的词。尽管在更合适的地方使用<strong class="jm io">方法</strong>术语是一个好的实践。原因就像当我们知道我们在谈论一只狗时，我们在说“狗”而不是“动物”一样。它提供了更多信息。通过使我们的演讲更具体，我们使它更容易理解。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="822d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我要感谢<a class="ae lw" href="https://twitter.com/intelliyole" rel="noopener ugc nofollow" target="_blank"> Dmitry Jemerov </a>的技术验证。</p><p id="2d9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章是Kotlin程序员词典的第二部分。要了解最新的新部件，只需关注此媒体或<a class="ae lw" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank">在Twitter上观察我</a>。如果你需要帮助，请记住<a class="ae lw" href="https://medium.com/@marcinmoskala/ive-just-opened-up-for-online-consultations-640349aaba55" rel="noopener">我愿意接受咨询</a>。</p><p id="43b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">喜欢的话记得鼓掌。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="lx ly lz ma gt mm gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi mw"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="8d02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是<a class="ae lw" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-2cb67fff1fe2" rel="noopener">科特林程序员词典</a>的其他出版部分:</p><ul class=""><li id="f8a1" class="mx my in jm b jn jo jr js jv mz jz na kd nb kh nc nd ne nf bi translated"><a class="ae lw" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">形参对实参，类型形参对类型实参</a></li><li id="1953" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0" rel="noopener">语句vs表达式</a></li><li id="e5ae" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">田地vs房产</a></li><li id="5ed1" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类对类型对对象</a></li><li id="4d02" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b">对象表达式vs对象声明</a></li><li id="4570" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-b085b1620890">接收器</a></li><li id="b9e1" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c">隐式接收者vs显式接收者</a></li><li id="c0c9" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277">分机接收机vs调度接收机</a></li><li id="9bf1" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-type-vs-receiver-object-575d2705ddd9">接收者类型与接收者对象</a></li><li id="db5f" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">函数类型vs函数文字vs Lambda表达式vs匿名函数</a></li><li id="b528" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-higher-order-function-9cadb07df94e">高阶函数</a></li><li id="d5eb" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-function-literal-with-receiver-vs-function-type-with-receiver-cc21dba0f4ff">带接收方的函数文字与带接收方的函数类型</a></li><li id="cc1e" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/kotlin-generics-variance-modifiers-36b82c7caa39">不变性vs协方差vs逆变</a></li><li id="6b0f" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-event-listener-vs-event-handler-305c667d0e3c">事件监听器vs事件处理器</a></li><li id="c50b" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated"><a class="ae lw" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-delegation-vs-composition-3025d9e8ae3d">代表团vs组成</a></li></ul><figure class="lx ly lz ma gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>