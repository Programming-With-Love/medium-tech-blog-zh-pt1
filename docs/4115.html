<html>
<head>
<title>On properly using volatile and synchronized</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正确使用易失性和同步</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/on-properly-using-volatile-and-synchronized-702fc05faac2?source=collection_archive---------1-----------------------#2016-12-07">https://medium.com/google-developer-experts/on-properly-using-volatile-and-synchronized-702fc05faac2?source=collection_archive---------1-----------------------#2016-12-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/3622908b4f0bb37a396678231f9b92df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*snN9RGvLtAQjl4r7KWMMgA.jpeg"/></div></div></figure><div class=""/><p id="354c" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在过去的几周里，我一直在写关于<a class="ae jn" rel="noopener" href="/google-developer-experts/diving-deeper-into-the-java-transient-modifier-3b16eff68f42#.tes59mm9a">瞬态</a>修饰语和Java中不同类型的<a class="ae jn" rel="noopener" href="/google-developer-experts/finally-understanding-how-references-work-in-android-and-java-26a0d9c92f83#.ixg2oyvhj">引用</a>。我想保留Java中未充分使用/误用的主题，并在本周为您带来<strong class="ir ht">易变性</strong>和<strong class="ir ht">同步</strong>修饰语。</p><p id="8727" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">多线程是一门需要多年才能掌握和正确理解的完整学科。我们将在本文中做一个简短的介绍。</p><p id="9728" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在计算中，可以从不同的线程同时访问一个资源。这可能会导致不一致和数据损坏。线程<em class="jo">线程</em>访问并修改资源。同时，线程<em class="jo"> ThreadB </em>开始访问相同的资源。数据可能已损坏，因为它正在被同时修改。让我们分析一个没有任何保护的例子:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="cccb" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您执行这个命令，结果是折衷的和不确定的。每次您都会得到不同的随机输出。这是因为每个线程在不同的时刻执行。</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="82b7" class="ka kb hs jw b fi kc kd l ke kf">Starting Thread 1 output:<br/>Starting Thread 2 output:<br/>Selected number is: 5<br/>Selected number is: 4<br/>Selected number is: 3<br/>Selected number is: 2<br/>Selected number is: 5<br/>Selected number is: 4<br/>Selected number is: 1<br/>Selected number is: 3<br/>Selected number is: 2<br/>Selected number is: 1<br/>Thread Thread 1 finishing.<br/>Thread Thread 2 finishing.</span></pre><p id="ecb0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">两个修饰符都处理多线程和保护代码段免受线程访问。我的直觉是<strong class="ir ht">同步</strong>比<strong class="ir ht">易变性</strong>被更广泛地使用和理解，所以我将在我的文章开始解释它是如何工作的。我们以后也需要它来理解与<strong class="ir ht">挥发性</strong>的区别。</p><h1 id="e8e5" class="kg kb hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">同步修改器</h1><p id="4dd5" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated"><strong class="ir ht">同步的</strong>修饰符可以应用于语句块或方法。<strong class="ir ht"> synchronized </strong>通过确保代码的关键部分不会被两个不同的线程同时执行来提供保护，确保数据的一致性。让我们应用前面示例中的修饰符<strong class="ir ht"> synchronized </strong>，看看它将如何受到保护:</p><figure class="jp jq jr js fd hj"><div class="bz dy l di"><div class="jt ju l"/></div></figure><p id="9af1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，在本例中，我们在运行函数<strong class="ir ht"> printCount() </strong>的部分添加了<strong class="ir ht"> synchronized </strong>。如果您现在执行此函数，结果将始终相同:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="e43d" class="ka kb hs jw b fi kc kd l ke kf">Starting Thread 1<br/>Starting Thread 2<br/>Selected number is: 5<br/>Selected number is: 4<br/>Selected number is: 3<br/>Selected number is: 2<br/>Selected number is: 1<br/>Thread Thread 1 finishing.<br/>Selected number is: 5<br/>Selected number is: 4<br/>Selected number is: 3<br/>Selected number is: 2<br/>Selected number is: 1<br/>Thread Thread 2 finishing.</span></pre><p id="3aca" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在<strong class="ir ht">同步</strong>已经解释过了，让我们来看看<strong class="ir ht">的易变性</strong>。</p><h1 id="f872" class="kg kb hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">挥发性改性剂</h1><p id="8453" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">我们之前提到过<strong class="ir ht">同步</strong>修改器可以应用于块和方法。它们之间的第一个区别是<strong class="ir ht">挥发性物质</strong>是一种可以应用于野外的改性剂。</p><p id="cece" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于Java内存和多线程如何工作的小说明。当我们在多线程环境中工作时，每个线程都在它们正在处理的变量的本地缓存中创建自己的副本。当这个值被更新时，更新首先发生在本地缓存副本中，而不是在真实变量中。因此，其他线程不知道其他线程正在改变的值。</p><p id="1c08" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里<strong class="ir ht">易变</strong>改变了范式。当一个变量被声明为<strong class="ir ht"> volatile </strong>时，它不会被存储在线程的本地缓存中。相反，每个线程将访问主内存中的变量，其他线程将能够访问更新后的值。为了正确理解，让我们比较一下所有的方法:</p><pre class="jp jq jr js fd jv jw jx jy aw jz bi"><span id="b501" class="ka kb hs jw b fi kc kd l ke kf">int firstVariable;<br/>int getFirstVariable() {return firstVariable;}<br/><br/>volatile int secondVariable;<br/>int getSecondVariable() {return secondVariable;}<br/><br/>int thirdVariable;<br/>synchronized int getThirdVariable() {return thirdVariable;}</span></pre><p id="e64d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一种方法不受保护。线程T1将访问该方法，创建自己的<em class="jo">第一变量</em>的本地副本并使用它。同时，T2和T3也可以访问<em class="jo">第一个变量</em>并修改其值。T1、T2和T3将具有它们自己的第一变量<em class="jo">的值</em>，这些值可能不相同，并且没有被复制到java的主存储器中，实际结果保存在主存储器中。</p><p id="4662" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jo">另一方面，getSecondVariable() </em>访问一个已经声明为<strong class="ir ht"> volatile </strong>的变量。这意味着，每个线程仍然能够访问该方法或块，因为它没有受到<strong class="ir ht"> synchronized </strong>的保护，但是它们都将从主存储器访问相同的变量，并且不会创建它们自己的本地副本。每个线程将访问相同的值。</p><p id="b3b6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从前面的例子中我们可以想象，getThirdVariable()一次只能被一个线程访问。这确保了变量在所有线程执行过程中保持同步。</p><h1 id="86f3" class="kg kb hs bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">易失性和同步的有用性</h1><p id="69b0" class="pw-post-body-paragraph ip iq hs ir b is ld iu iv iw le iy iz ja lf jc jd je lg jg jh ji lh jk jl jm ha bi translated">读完这篇短文后，你可能会想到一个问题。我理解理论上的含义，但实际上是什么呢？<strong class="ir ht">同步</strong>在这一点上可能更容易理解，但是什么时候应用<strong class="ir ht">易变</strong>修饰符是有用的呢？我喜欢展示一个例子来提供更好的理解。</p><p id="862e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">想到一个<em class="jo">日期</em>变量。<em class="jo">日期</em>变量总是需要相同，似乎它定期更新。每个访问被声明为<strong class="ir ht"> volatile </strong>的<em class="jo"> Date </em>变量的线程将总是显示相同的值。</p><p id="94a9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于线程安全有两个主要方面。一个是执行控制，一个是内存可见性。鉴于<strong class="ir ht"> volatile </strong>提供了内存可见性(所有线程将从主内存中访问相同的值),没有执行控制的保证，这种最新的只能通过<strong class="ir ht"> synchronized </strong>来实现。</p><p id="fc14" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同样，在Java中，对于一个<strong class="ir ht">可变</strong>变量(包括<em class="jo">长</em>和<em class="jo">双</em>变量)，所有的读写操作都是原子的。很多平台分两步执行<em class="jo"> long </em>和<em class="jo"> double </em>中的操作，一次写/读32个字节，允许两个线程看到两个不同的值。这可以通过使用<strong class="ir ht"> volatile </strong>来避免。</p><p id="4eb8" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">感谢<a class="ae jn" href="https://twitter.com/erikhellman" rel="noopener ugc nofollow" target="_blank"> Erik Hellman </a>对你的代码和文章的评论，你真棒。</p><p id="0fb1" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在我的<a class="ae jn" href="https://twitter.com/eenriquelopez" rel="noopener ugc nofollow" target="_blank"> Twitter账户</a>中写下我对软件工程和生活的想法。如果你喜欢这篇文章或者它确实帮助了你，请随意分享和/或留下评论。这是给业余作家加油的货币。</p></div></div>    
</body>
</html>