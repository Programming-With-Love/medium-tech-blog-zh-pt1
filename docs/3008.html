<html>
<head>
<title>100+ Java Interview Questions You Must Prepare In 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年你必须准备的100+ Java面试问题</h1>
<blockquote>原文：<a href="https://medium.com/edureka/java-interview-questions-1d59b9c53973?source=collection_archive---------0-----------------------#2019-06-07">https://medium.com/edureka/java-interview-questions-1d59b9c53973?source=collection_archive---------0-----------------------#2019-06-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d2be9cf4104b057145939d25a942d8d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fmxOItbUYq7McFd4oVe5jA.jpeg"/></div></div></figure><p id="81bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我将列出一些最重要的Java面试问题和答案，它们将使你在面试过程中脱颖而出。全世界大约有1000万开发人员使用Java为150亿台支持Java的设备开发应用程序。它还被用于创建将大数据等趋势技术应用到手机和DTH盒子等家用设备的应用程序。因此今天，Java到处都在使用！</p><p id="2e8d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们编制了一份Java面试问题列表，分为7个部分，即:</p><ol class=""><li id="857b" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">基本面试问题</li><li id="0b89" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">哎呀面试问题</li><li id="82b0" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">JDBC面试问题</li><li id="c426" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">春季面试问题</li><li id="43b2" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">冬眠面试问题</li><li id="96c7" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">JSP面试问题</li><li id="9a48" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">例外和线索面试问题</li></ol><p id="06f3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为一名Java专业人员，了解正确的流行词汇、学习正确的技术并为常见的Java面试问题准备正确的答案是至关重要的。这里有一个权威的Java面试问题列表，可以保证你轻松进入下一个阶段。</p><p id="1b8c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以让我们从第一组基本的Java面试问题开始。</p><h1 id="b924" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">基本Java面试问题</h1><h2 id="1670" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q1。解释JDK，JRE和JVM？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ln"><img src="../Images/fa1b0288303a5458bccd7b73037e9d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Y_zdn_jOp9Oa_F3VReCrg.png"/></div></div></figure><h2 id="9bed" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q2。解释Java中的公共静态void main(String args[])。</h2><p id="b788" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java中的main()是任何Java程序的入口点。它总是写成<strong class="ir hi">public static void main(String[]args)</strong>。</p><ul class=""><li id="29cd" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated"><strong class="ir hi"> public </strong> : Public是一个访问修饰符，用来指定谁可以访问这个方法。Public意味着任何类都可以访问该方法。</li><li id="94f8" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi"> static </strong>:它是java中的一个关键字，标识它是基于类的。main()在Java中是静态的，因此无需创建类的实例就可以访问它。如果main不是静态的，那么编译器将抛出一个错误，因为JVM在创建任何对象之前调用了<strong class="ir hi"> main </strong>()并且只有静态方法可以通过该类直接调用。</li><li id="46f3" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi"> void </strong>:是方法的返回类型。Void定义了不会返回任何值的方法。</li><li id="7fad" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi"> main </strong>:它是JVM搜索的方法的名称，作为一个只有特定签名的应用程序的起点。它是主要执行发生的方法。</li><li id="6dca" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi"> String args[] </strong>:传递给main方法的参数。</li></ul><h2 id="b485" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q3。为什么Java是平台无关的？</h2><p id="af85" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java被称为平台无关的，因为它的字节码可以在任何系统上运行，而与它的底层操作系统无关。</p><h2 id="5421" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q4。为什么Java不是100%面向对象？</h2><p id="3dda" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java不是100%面向对象的，因为它使用了八种原始数据类型，如Boolean、byte、char、int、float、double、long、short，它们都不是对象。</p><h2 id="432a" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q5。Java中的包装类是什么？</h2><p id="afa0" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">包装类将Java原语转换成引用类型(对象)。每种原始数据类型都有一个专用的类。这些被称为包装类，因为它们将原始数据类型“包装”到该类的对象中。参考下图，其中显示了不同的原始类型、包装类和构造函数参数。</p><h2 id="73a7" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q6。Java中的构造函数是什么？</h2><p id="4140" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在Java中，构造函数指的是用来初始化对象的代码块。它必须与类的名称相同。此外，它没有返回类型，并且在创建对象时自动调用。</p><p id="e4ab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有两种类型的构造函数:</p><ol class=""><li id="f75b" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi">默认构造函数:</strong>在Java中，默认构造函数不接受任何输入。换句话说，默认构造函数是无参数构造函数，如果用户没有定义其他构造函数，默认情况下会创建无参数构造函数。它的主要目的是用默认值初始化实例变量。此外，它主要用于对象创建。</li><li id="dfad" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">参数化构造函数:</strong>Java中的参数化构造函数，是能够用提供的值初始化实例变量的构造函数。换句话说，接受参数的构造函数叫做参数化构造函数。</li></ol><h2 id="13c9" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q7。什么是Java中的singleton类，怎样才能让一个类成为singleton？</h2><p id="b282" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Singleton类是这样一个类，在一个JVM中，在任何给定的时间只能创建一个实例。通过使类的构造函数私有，可以使类成为单例类。</p><h2 id="f802" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q8。Java中数组列表和vector有什么区别？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ly"><img src="../Images/8b9700b62ce7079d9063831b1de31ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_GoP2C_w8XiOWJK99ZnxQ.png"/></div></div></figure><h2 id="8cd1" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q9。Java中equals()和==有什么区别？</h2><p id="0c01" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Equals()方法在Java的Object类中定义，用于检查业务逻辑定义的两个对象是否相等。</p><p id="8fd1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">“==”或Java中的等式运算符是Java编程语言提供的一种二元运算符，用于比较原语和对象。<em class="lz">public boolean equals(Object o)</em>是Object类提供的方法。默认实现使用==运算符来比较两个对象。例如:方法可以像字符串类一样被覆盖。equals()方法用于比较两个对象的值。</p><h2 id="2fc8" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q10。Java中堆内存和栈内存有什么区别？</h2><p id="75af" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">堆内存和堆栈内存之间的主要区别是:</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/16ef2a49ffcdc837d9c8170a8ab917d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jQhoHWI8cJWPNbW3FxKopA.png"/></div></div></figure><h2 id="9a57" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q11。Java中的包是什么？列出包装的各种优点。</h2><p id="0875" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java中的包是捆绑在一起的相关类和接口的集合。通过使用包，开发人员可以轻松地模块化代码并优化其重用。此外，包中的代码可以被其他类导入并重用。下面我列出了它的一些优点:</p><ul class=""><li id="fdbd" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">包有助于避免名称冲突</li><li id="884e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">它们提供了对代码更容易的访问控制</li><li id="a8bd" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">包还可以包含隐藏类，这些隐藏类对外部类不可见，只在包内使用</li><li id="144a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">创建适当的层次结构，使相关类的定位更加容易</li></ul><h2 id="7fe1" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q12。Java中为什么不用指针？</h2><p id="1e0b" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java不使用指针，因为它们不安全，而且会增加程序的复杂性。因为Java以代码简单著称，所以添加指针的概念将是矛盾的。此外，由于JVM负责隐式内存分配，因此为了避免用户直接访问内存，Java中不鼓励使用指针。</p><h2 id="4cb2" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q13。Java中的JIT编译器是什么？</h2><p id="d9a9" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">JIT代表Java中的实时编译器。它是一个帮助将Java字节码转换成直接发送给处理器的指令的程序。默认情况下，JIT编译器在Java中是启用的，并且每当调用Java方法时都会被激活。然后，JIT编译器将被调用方法的字节码编译成本机代码，编译成“实时”执行。一旦方法被编译，JVM直接调用该方法的编译代码，而不是解释它。这就是为什么它经常负责Java应用程序在运行时的性能优化。</p><h2 id="6175" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q14。Java中的访问修饰符是什么？</h2><p id="456e" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在Java中，访问修饰符是特殊的关键字，用于限制一个类、构造函数、数据成员和另一个类中的方法的访问。Java支持四种类型的访问修饰符:</p><ol class=""><li id="7cd5" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><em class="lz">默认</em></li><li id="df44" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><em class="lz">私人</em></li><li id="0f39" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><em class="lz">被保护</em></li><li id="04ce" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><em class="lz">公开</em></li></ol><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/711353b7e86810a7adef4c87de137139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uCFbSk4an5lppSDXsyt7ig.png"/></div></div></figure><h2 id="a140" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q15。定义一个Java类。</h2><p id="9519" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java中的类是一个蓝图，包含了你所有的数据。一个类包含描述对象行为的字段(变量)和方法。让我们来看看类的语法。</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="9f76" class="kz kc hh mc b fi mg mh l mi mj">class Abc {<br/>member variables // class body<br/>methods  }</span></pre><h2 id="21ea" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q16。Java中的对象是什么，是如何创建的？</h2><p id="4534" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">对象是现实世界中具有状态和行为的实体。一个对象有三个特征:</p><ol class=""><li id="4372" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">状态</li><li id="3d80" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">行为</li><li id="070a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">身份</li></ol><p id="52d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用“new”关键字创建对象。例如:</p><p id="178a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">class name obj = new class name()；</p><h2 id="f610" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q17。什么是面向对象编程？</h2><p id="da0b" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">面向对象编程是一种编程模型或方法，其中程序是围绕对象而不是逻辑和功能来组织的。换句话说，OOP主要关注的是需要被操作的对象，而不是逻辑。这种方法对于大型复杂代码的程序来说是理想的，并且需要积极地更新或维护。</p><h2 id="c2fa" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q18。Java中OOPs的主要概念是什么？</h2><p id="967b" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">面向对象编程(OOPs)是一种编程风格，与以下概念相关联:</p><ol class=""><li id="571c" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi"> <em class="lz">继承:</em> </strong>继承是一个类获取另一个类的属性的过程。</li><li id="7035" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi"> <em class="lz">封装:</em></strong>Java中的封装是一种将数据和代码打包成一个单元的机制。</li><li id="c8a7" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi"> <em class="lz">抽象:</em> </strong> <em class="lz"> </em>抽象是对用户隐藏实现细节，只向用户提供功能的方法论。</li><li id="77bc" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi"> <em class="lz">多态性:</em> </strong> <em class="lz"> </em>多态性是变量、函数或对象采取多种形式的能力。</li></ol><h2 id="8d0c" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q19。局部变量和实例变量有什么区别？</h2><p id="994c" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在Java中，<strong class="ir hi">局部变量</strong>通常用在方法、构造函数或<strong class="ir hi">块</strong>中，并且只有局部范围。因此，该变量只能在块的范围内使用。拥有局部变量的最大好处是，类中的其他方法甚至不知道这个变量。</p><p id="7e69" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lz">例题</em> </strong></p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="47e9" class="kz kc hh mc b fi mg mh l mi mj">if(x &gt; 100)<br/>{<br/>String test = "Edureka";<br/>}</span></pre><p id="0483" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">而Java中的<strong class="ir hi">实例变量</strong>，是一个绑定到其对象本身的变量。这些变量在一个<strong class="ir hi">类</strong>中声明，但是在一个方法之外。该类的每个对象在使用变量时都会创建自己的副本。因此，对变量的任何更改都不会反映在该类的任何其他实例中，而只会绑定到该特定实例。</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="f21a" class="kz kc hh mc b fi mg mh l mi mj">class Test{<br/>public String EmpName;<br/>public int empAge;<br/>}</span></pre><h2 id="e165" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">问题20。区分Java中的构造函数和方法？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/51aeba83cbf7041452f3dcc040fd5283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xoaj5rgPjrqwyodHeIRhpQ.png"/></div></div></figure><h2 id="8ffc" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">问题21。Java中的final关键字是什么？</h2><p id="b6d2" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated"><strong class="ir hi"> final </strong>是Java中的一个特殊关键字，用作非访问修饰符。最终变量可用于不同的环境，例如:</p><ul class=""><li id="67bd" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated"><strong class="ir hi">最终变量</strong></li></ul><p id="d280" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当final关键字与变量一起使用时，其值一旦赋值就不能更改。如果最后一个变量没有赋值，那么只使用类构造函数就可以给它赋值。</p><ul class=""><li id="40a1" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated"><strong class="ir hi">最终方法</strong></li></ul><p id="4e5e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当一个方法被声明为final时，它不能被继承类覆盖。</p><ul class=""><li id="7b11" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated"><strong class="ir hi">期末班</strong></li></ul><p id="789f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当一个类在Java中被声明为final时，它不能被任何子类扩展，但是它可以扩展其他类。</p><h2 id="fbed" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">问题22。break和continue语句的区别是什么？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/50c1706701314ea89fd95362a2725027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GyXW3G6woPV5TOO-OV2hAA.png"/></div></div></figure><p id="3b9d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lz">例假断:</em> </strong></p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="6d60" class="kz kc hh mc b fi mg mh l mi mj">for (int i = 0; i &lt; 5; i++) <br/>{ <br/>if (i == 3) <br/>{ <br/>break; <br/>} <br/>System.out.println(i); <br/>}</span></pre><p id="15a9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lz">例子继续:</em> </strong></p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="d6f9" class="kz kc hh mc b fi mg mh l mi mj">for (int i = 0; i &lt; 5; i++) <br/>{ <br/>if (i == 2) <br/>{ <br/>continue; <br/>} <br/>System.out.println(i); <br/>}</span></pre><h2 id="90d9" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">问题23。什么是Java中的无限循环？举例说明。</h2><p id="ddbd" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">无限循环是Java中的一个指令序列，当没有遇到函数出口时，它会无休止地循环。这种类型的循环可能是编程错误的结果，也可能是基于应用程序行为的故意行为。一旦应用程序退出，无限循环将自动终止。</p><p id="dc2b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lz">例如:</em> </strong></p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="944b" class="kz kc hh mc b fi mg mh l mi mj">public class InfiniteForLoopDemo<br/>{<br/>public static void main(String[] arg) {<br/>for(;;)<br/>System.out.println("Welcome to Edureka!");<br/>// To terminate this program press ctrl + c in the console.<br/>}<br/>}</span></pre><h2 id="e693" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">问题24。Java中的this()和super()有什么区别？</h2><p id="78a3" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在Java中，super()和this()都是用于调用构造函数的特殊关键字。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/66278315d52089ece0ee6e4b27439592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tb-4TwmQoZ31UUw8A9Od3g.png"/></div></div></figure><h2 id="a874" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">问题25。什么是Java字符串池？</h2><p id="e498" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java字符串池指的是存储在堆内存中的字符串集合。在这种情况下，每当创建一个新对象时，String pool首先检查该对象是否已经存在于池中。如果存在，那么相同的引用被返回到变量，否则新的对象将在字符串池中被创建，并且相应的引用将被返回。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es ml"><img src="../Images/c99c04c108d5c062e66c243c01d7d920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*xXxEEAwOS7HT69IVBQbp3g.png"/></div></figure><h2 id="f150" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">问题26。区分Java中的静态和非静态方法。</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ly"><img src="../Images/d8e61bf8c5916727037371b5ef6e8fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6EXVMrJJo-N8WXguLQHGPQ.png"/></div></div></figure><h2 id="fca4" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q27。什么是Java中的构造函数链？</h2><p id="55ae" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在Java中，构造函数链接是从一个构造函数调用另一个关于当前对象的构造函数的过程。构造函数链接只有通过遗留才是可能的，在遗留中，子类构造函数负责首先调用超类的构造函数。构造函数链中可以有任意数量的类。构造函数链接可以通过两种方式实现:</p><ol class=""><li id="3fb0" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">在同一个类中使用this()</li><li id="02d7" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">使用super()从基类</li></ol><h2 id="5e47" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated"><strong class="ak"> Q28。字符串、字符串生成器和字符串缓冲区之间的区别。</strong></h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/12defc5ff958370505527cdb3835b497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIh_xtZOm90zzATfWJkfzw.png"/></div></div></figure><h2 id="32dc" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">问题29。Java中的类加载器是什么？</h2><p id="c6e6" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated"><strong class="ir hi"> Java类加载器</strong>是负责加载类文件的JVM (Java虚拟机)的子集。每当一个Java程序被执行时，它首先被类加载器加载。Java提供了三种内置的类装入器:</p><ol class=""><li id="2e31" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">引导类装入器</li><li id="4474" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">扩展类加载器</li><li id="e397" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">系统/应用程序类加载器</li></ol><h2 id="886e" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q30。为什么Java字符串本质上是不可变的？</h2><p id="9b47" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在Java中，字符串对象本质上是不可变的，这意味着一旦字符串对象被创建，它的状态就不能被修改。每当您试图更新该对象的值而不是更新该特定对象的值时，Java都会创建一个新的string对象。Java字符串对象是不可变的，因为字符串对象通常缓存在字符串池中。由于字符串通常在多个客户端之间共享，一个客户端的操作可能会影响其他客户端。它增强了应用程序的安全性、缓存、同步和性能。</p><h2 id="d37e" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q31。数组和数组列表有什么区别？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mm"><img src="../Images/f58c21bd206077185a0b8f7e0dfbc651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHJ-HWeHEigK8o2rZy1rcw.png"/></div></div></figure><h2 id="cc1c" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q32。Java中的地图是什么？</h2><p id="24bb" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在Java中，Map是Util包的一个接口，它将唯一的键映射到值。Map接口不是主集合接口的子集，因此它的行为与其他集合类型没有什么不同。以下是地图界面的一些特征:</p><ol class=""><li id="dc80" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">映射不包含重复的键。</li><li id="cfcf" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">每个键最多可以映射一个值。</li></ol><h2 id="5697" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q33。Java中的集合类是什么？列出它的方法和接口。</h2><p id="81fa" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在Java中，集合是一个框架，充当存储和操作一组对象的体系结构。使用收藏，您可以执行各种任务，如搜索、排序、插入、操作、删除等。Java集合框架包括以下内容:</p><ul class=""><li id="cca7" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">接口</li><li id="d0b9" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">班级</li><li id="40bc" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">方法</li></ul><p id="3bb0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下图显示了Java集合的完整层次结构。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mn"><img src="../Images/6acc2550ebbc12270535a2c890969ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_viHXY0P-XYXgd2Rr3KS8A.png"/></div></div></figure><h1 id="08ff" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">哎呀Java面试问题</h1><h2 id="a732" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q1。什么是多态性？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es mo"><img src="../Images/52c0f869154c3047f7d6402c3316a0ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*hOZK1dB8pBkqs2QQiqRd7A.png"/></div></figure><p id="b643" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">多态性简单描述为“一个接口，多个实现”。多态性是一种能够在不同的上下文中赋予事物不同的含义或用法的特性——特别是，允许一个实体(如变量、函数或对象)有不止一种形式。有两种类型的多态性:</p><ol class=""><li id="4d8c" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">编译时多态性</li><li id="1f6a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">运行时多态性</li></ol><p id="5046" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编译时多态性是方法重载，而运行时多态性是使用继承和接口完成的。</p><h2 id="9f04" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q2。什么是运行时多态或动态方法调度？</h2><p id="03e8" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在Java中，运行时多态或动态方法调度是一个在运行时而不是编译时解决对被覆盖方法的调用的过程。在这个过程中，通过超类的引用变量调用被覆盖的方法。让我们看看下面的例子来更好地理解它。</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="c7a3" class="kz kc hh mc b fi mg mh l mi mj">class Car {<br/>void run()<br/>{<br/>System.out.println(&amp;ldquo;car is running&amp;rdquo;); <br/>}<br/>}<br/>class Audi extends Car {<br/>void run()<br/>{<br/>System.out.prinltn(&amp;ldquo;Audi is running safely with 100km&amp;rdquo;);<br/>}<br/>public static void main(String args[])<br/>{<br/>Car b= new Audi();    //upcasting<br/>b.run();<br/>}<br/>}</span></pre><h2 id="4e6f" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q3。Java中的抽象是什么？</h2><p id="bdfb" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">抽象是指处理思想而不是事件的品质。它基本上处理的是隐藏细节，向用户展示本质的东西。因此，你可以说Java中的抽象是对用户隐藏实现细节，只向他们展示功能的过程。抽象可以通过两种方式实现:</p><ol class=""><li id="cf9c" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi">抽象类</strong>(可以实现0-100%的抽象)</li><li id="45f7" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">接口</strong>(可以实现100%的抽象)</li></ol><h2 id="9316" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q4。Java里的接口是什么意思？</h2><p id="365c" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java中的接口是一个类的蓝图，或者你可以说它是抽象方法和静态常量的集合。在接口中，每个方法都是公共的和抽象的，但是它不包含任何构造函数。因此，接口基本上是一组具有空体的相关方法。示例:</p><p id="9fae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><br/>公共接口动物{，公共虚空吃()；<br/>公共虚空睡眠()；<br/>public void run()；<br/> }</p><h2 id="5088" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q5。抽象类和接口有什么区别？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mp"><img src="../Images/4b20c216d93ef10c1ffb8fa529f64b96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XD4dUTenGwSLK8W_TvwcSw.png"/></div></div></figure><h2 id="a81b" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated"><strong class="ak"> Q6。Java中的继承是什么？</strong></h2><p id="8611" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java中的继承概念是一个类的属性可以被另一个类继承。它有助于重用代码和建立不同类之间的关系。继承在两种类型的类之间执行:</p><ol class=""><li id="7aca" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">父类(超类或基类)</li><li id="801f" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">子类(子类或派生类)</li></ol><p id="daf7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">继承属性的类称为子类，而属性被继承的类称为父类。</p><h2 id="b8f6" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q7。Java中有哪些不同类型的继承？</h2><p id="3234" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java支持四种类型的继承，它们是:</p><ol class=""><li id="fd20" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi">单一继承:</strong>在单一继承中，一个类继承另一个类的属性，即只有一个父类和一个子类。</li><li id="19db" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">多级继承:</strong>当一个类是从另一个类派生出来的，即一个类有不止一个父类，但在不同的级别，这种类型的继承称为多级继承。</li><li id="a4a9" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">层次继承:</strong>当一个类有不止一个子类(子类)，或者换句话说，不止一个子类有相同的父类，那么这种继承称为层次继承。</li><li id="218a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">混合遗传:</strong>混合遗传是两种<em class="lz">或两种以上</em>遗传的组合。</li></ol><h2 id="dcfb" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q8。什么是方法重载和方法重写？</h2><p id="a1cf" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated"><strong class="ir hi"> <em class="lz">方法重载:</em> </strong></p><ul class=""><li id="5116" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">在方法重载中，相同类的方法共享相同的名称，但是每个方法必须具有不同数量的参数或者具有不同类型和顺序的参数。</li><li id="5c0d" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">方法重载是对方法的行为进行更多的“添加”或“扩展”。</li><li id="cf53" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">它是一种编译时多态性。</li><li id="2b7c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">这些方法必须有不同的签名。</li><li id="7e46" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">它可能需要也可能不需要方法重载中的继承。</li></ul><p id="09ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看下面的例子来更好地理解它。</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="bc0c" class="kz kc hh mc b fi mg mh l mi mj">class Adder {<br/>Static int add(int a, int b)<br/>{<br/>return a+b;<br/>}<br/>Static double add( double a, double b)<br/>{<br/>return a+b;<br/>}<br/>public static void main(String args[])<br/>{<br/>System.out.println(Adder.add(11,11));<br/>System.out.println(Adder.add(12.3,12.6));<br/>}}</span></pre><p id="3311" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lz">方法覆盖:</em> </strong></p><ul class=""><li id="49ca" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">在方法覆盖中，子类拥有与超类相同的名称、相同数量和类型的参数以及相同的返回类型。</li><li id="1921" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">方法重写是为了“改变”方法的现有行为。</li><li id="6ef5" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">它是一个运行时多态。</li><li id="bd40" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">这些方法必须具有相同的签名。</li><li id="9b07" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">在方法重写中总是需要继承。</li></ul><p id="ae8b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看下面的例子来更好地理解它。</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="1225" class="kz kc hh mc b fi mg mh l mi mj">class Car {<br/>void run(){<br/>System.out.println(&amp;ldquo;car is running&amp;rdquo;); <br/>}<br/>Class Audi extends Car{<br/>void run()<br/>{<br/>System.out.prinltn(&amp;ldquo;Audi is running safely with 100km&amp;rdquo;);<br/>}<br/>public static void main( String args[])<br/>{<br/>Car b=new Audi();<br/>b.run();<br/>}<br/>}</span></pre><h2 id="793a" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q9。你能在Java中重写私有或静态方法吗？</h2><p id="98ff" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在Java中，不能重写私有或静态方法。如果你在子类中创建一个具有相同返回类型和相同方法参数的相似方法，那么它将隐藏超类方法；这就是所谓的方法隐藏。类似地，你不能覆盖子类中的私有方法，因为它在子类中是不可访问的。您可以做的是在子类中创建另一个同名的私有方法。让我们看看下面的例子来更好地理解它。</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="cdd9" class="kz kc hh mc b fi mg mh l mi mj">class Base {<br/>private static void display() {<br/>System.out.println("Static or class method from Base");<br/>}<br/>public void print() {<br/>System.out.println("Non-static or instance method from Base");<br/>}<br/>class Derived extends Base {<br/>private static void display() {<br/>System.out.println("Static or class method from Derived");<br/>}<br/>public void print() {<br/>System.out.println("Non-static or instance method from Derived");<br/>}<br/>public class test {<br/>public static void main(String args[])<br/>{<br/>Base obj= new Derived();<br/>obj1.display();<br/>obj1.print();<br/>}<br/>}</span></pre><h2 id="e0a4" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q10。什么是多重继承？Java支持吗？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es mq"><img src="../Images/31aaccc4def3b7128c5e071c70f02bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*4R0ihJH-NkPIAvmDA1vwOA.png"/></div></figure><p id="3810" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果一个子类继承了多个类的属性，则称为多重继承。Java不允许扩展多个类。</p><p id="a2ba" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">多重继承的问题是，如果多个父类有相同的方法名，那么在运行时编译器很难决定从子类中执行哪个方法。</p><p id="e83c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，Java不支持多重继承。该问题通常被称为<strong class="ir hi">钻石问题。</strong></p><h2 id="f750" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q11。Java中的封装是什么？</h2><p id="63c4" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">封装是一种将数据(变量)和代码(方法)作为一个单元绑定在一起的机制。在这里，数据对外界是隐藏的，只能通过当前的类方法来访问。这有助于保护数据免受任何不必要的修改。我们可以通过以下方式在Java中实现封装:</p><ul class=""><li id="e2a6" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">将类的变量声明为私有。</li><li id="0d12" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">提供公共的setter和getter方法来修改和查看变量的值。</li></ul><h2 id="b06c" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q12。什么是协会？</h2><p id="90fc" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">关联是一种关系，其中所有对象都有自己生命周期，且没有所有者。我们以老师和学生为例。多名学生可以与一名教师相关联，一名学生可以与多名教师相关联，但是对象之间没有所有权，两者都有自己的生命周期。这些关系可以是一对一、一对多、多对一和多对多。</p><h2 id="60e5" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q13。聚合是什么意思？</h2><p id="db0e" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">聚合是一种特殊形式关联，其中所有对象都有自己的生命周期，但存在所有权，子对象不能属于另一个父对象。我们举个部门和老师的例子。单个教师不能属于多个部门，但是如果我们删除了部门教师对象也不会破坏。</p><h2 id="e85e" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q14。Java中的composition是什么？</h2><p id="3a15" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">组合又是一种特殊形式的聚合，我们可以称之为“死亡”关系。这是一种强类型的聚集。子对象没有生命周期，如果父对象删除，所有子对象也将被删除。让我们再举一个房子和房间之间关系的例子。房子可以包含多个房间，没有独立生活的房间，任何房间都不能属于两个不同的房子，如果我们删除了房子房间就会自动删除。</p><h2 id="3775" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated"><strong class="ak"> Q15。什么是标记接口？</strong></h2><p id="f34d" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">标记接口可以定义为没有数据成员和成员函数的接口。简单来说，空接口称为标记接口。Java中标记接口最常见的例子是可串行化的、可克隆的等等。标记接口可以声明如下。</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="d5da" class="kz kc hh mc b fi mg mh l mi mj">public interface Serializable{ <br/>}</span></pre><h2 id="b481" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated"><strong class="ak"> Q16。Java中的对象克隆是什么？</strong></h2><p id="7089" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java中的对象克隆是创建对象的精确副本的过程。它基本上意味着创建与原始对象具有相似状态的对象的能力。为了实现这一点，Java提供了一种方法<strong class="ir hi"> clone() </strong>来利用这一功能。此方法创建当前对象的类的新实例，然后用相应字段的完全相同的内容初始化其所有字段。为了object clone()，必须实现标记接口<strong class="ir hi"> java.lang.Cloneable </strong>以避免任何运行时异常。您必须注意的一点是Object clone()是一个受保护的方法，因此您需要覆盖它。</p><h2 id="936d" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q17。Java中的复制构造函数是什么？</h2><p id="e17f" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">复制构造函数是一个成员函数，用于使用同一个类的另一个对象初始化一个对象。尽管在Java中不需要复制构造函数，因为所有的对象都是通过引用传递的。而且，Java甚至不支持自动传值。</p><h2 id="d0b0" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q18。什么是Java中的构造函数重载？</h2><p id="d08a" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在Java中，构造函数重载是一种向类中添加任意数量的构造函数的技术，每个构造函数都有不同的参数列表。编译器使用列表中参数的数量及其类型来区分重载的构造函数。</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="85d5" class="kz kc hh mc b fi mg mh l mi mj">class Demo<br/>{<br/>int i;<br/>public Demo(int a)<br/>{<br/>i=k;<br/>}<br/>public Demo(int a, int b)<br/>{<br/>&amp;hellip;<br/>}</span></pre><h1 id="0ddf" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Servlets面试问题</h1><h2 id="59e8" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q1。什么是servlet？</h2><ul class=""><li id="2c5b" class="jn jo hh ir b is ls iw lt ja mr je ms ji mt jm lx jt ju jv bi translated">Java Servlet是服务器端技术，通过提供对动态响应和数据持久性的支持来扩展web服务器的功能。</li><li id="3509" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">javax.servlet和javax.servlet.http包为编写我们自己的servlet提供了接口和类。</li><li id="dd36" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">所有Servlet都必须实现javax.servlet.Servlet接口，该接口定义了servlet生命周期方法。在实现通用服务时，我们可以扩展Java Servlet API提供的GenericServlet类。HttpServlet类提供了一些方法，如doGet()和doPost()，用于处理特定于HTTP的服务。</li><li id="b8ed" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">大多数时候，web应用程序是使用HTTP协议访问的，这就是为什么我们主要扩展HttpServlet类。下图显示了Servlet API层次结构。</li></ul><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es mu"><img src="../Images/0f153e5cd63747fa064468b3deaa2337.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*6OUzGhftu82nf2CaOVlfvA.png"/></div></figure><h2 id="6dcd" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q2。Get和Post方法有什么区别？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mp"><img src="../Images/60b4788103a361d5e6bdc4e4d2617e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JS_sKjs4JDRQerVAW0iLGg.png"/></div></div></figure><h2 id="22dd" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q3。什么是请求调度程序？</h2><p id="d3ad" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">RequestDispatcher接口用于将请求转发到另一个资源，该资源可以是HTML、JSP或同一应用程序中的另一个servlet。我们还可以使用它将另一个资源的内容包含到响应中。</p><p id="d333" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该接口中定义了两种方法:</p><p id="1a46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1.void forward()</p><p id="b844" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.void include()</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/79a283f9ddab421fbcbcbd78e9b62eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NeQ5MCs8m7KkhZdXN_Q8Q.png"/></div></div></figure><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/875c122449e95ba2f5897fe2148a0837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55xL9L1A_ZdISDdEPuFtNw.png"/></div></div></figure><h2 id="ee47" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q4。forward()方法和sendRedirect()方法有什么区别？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mp"><img src="../Images/029ae3b3001e928bc8a813e906b63c42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOapP3nKYvU648WAf8o28Q.png"/></div></div></figure><h2 id="d4b5" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q5。servlet的生命周期是什么？</h2><p id="6a10" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">servlet的生命周期有5个阶段:</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es mw"><img src="../Images/ad52efe6bd4a535bd0287e41e1421b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*BhozW03p94EAIkwkWjk5rw.png"/></div></figure><ol class=""><li id="6104" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">Servlet已加载</li><li id="cc94" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Servlet被实例化</li><li id="4fde" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Servlet已初始化</li><li id="5b86" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">服务请求</li><li id="54c2" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Servlet被破坏</li></ol><h2 id="1104" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q6。cookies在Servlets中是如何工作的？</h2><ul class=""><li id="df2d" class="jn jo hh ir b is ls iw lt ja mr je ms ji mt jm lx jt ju jv bi translated">Cookies是由服务器发送到客户端的文本数据，它保存在客户端的本地机器上。</li><li id="8b63" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">Servlet API通过实现可序列化和可克隆接口的javax.servlet.http.Cookie类提供Cookie支持。</li><li id="fa07" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">提供HttpServletRequest getcookies()方法是为了从请求中获取Cookie数组，因为没有必要向请求中添加Cookie，所以没有向请求中设置或添加Cookie的方法。</li><li id="182d" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">类似地，提供了http servlet response add Cookie(Cookie c)方法来在响应头中附加Cookie，没有用于Cookie的getter方法。</li></ul><h2 id="716f" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q7。ServletContext和ServletConfig有什么区别？</h2><p id="5021" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Servlets JSP中ServletContext和ServletConfig的区别如下表所示。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mp"><img src="../Images/078b534d614009f829c65110029e9a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YmXLtlFzXf1_sTsAWyFAXA.png"/></div></div></figure><h2 id="450b" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q8。servlets中有哪些不同的会话管理方法？</h2><p id="5eb2" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">会话是客户机和服务器之间的对话状态，它可以由客户机和服务器之间的多个请求和响应组成。由于HTTP和Web服务器都是无状态的，维护会话的唯一方法是在每个请求和响应中在服务器和客户机之间传递一些关于会话的唯一信息(会话id)。</p><p id="dfa1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">servlets中会话管理的一些常见方式有:</p><ol class=""><li id="d523" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">用户认证</li><li id="65db" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">HTML隐藏字段</li><li id="e6c8" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">饼干</li><li id="3d1b" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">URL重写</li><li id="cd3d" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">会话管理API</li></ol><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mx"><img src="../Images/5b9c8d2b6938f7f285396cc5c64ae1c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eYGBLOhsjZ5CP975zD4ZIA.png"/></div></div></figure><h1 id="945c" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">JDBC面试问题</h1><h2 id="aff5" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q1。什么是JDBC司机？</h2><p id="525f" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">JDBC驱动程序是使java应用程序能够与数据库交互的软件组件。有4种类型的JDBC驱动程序:</p><ol class=""><li id="0dc0" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">JDBC-ODBC桥驱动程序</li><li id="a54c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">原生API驱动程序(部分java驱动程序)</li><li id="1708" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">网络协议驱动(全java驱动)</li><li id="489c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">瘦驱动程序(全java驱动程序)</li></ol><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es mw"><img src="../Images/d3280e1d0badfea6c22d8c3036ffc271.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*fkxWgXCUGnP2uRdHwr8UAA.png"/></div></figure><h2 id="0e5f" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q2。用java连接数据库的步骤有哪些？</h2><ul class=""><li id="6711" class="jn jo hh ir b is ls iw lt ja mr je ms ji mt jm lx jt ju jv bi translated">注册驱动程序类</li><li id="e570" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">正在创建连接</li><li id="65cd" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">创建语句</li><li id="8f45" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">执行查询</li><li id="1590" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">关闭连接</li></ul><h2 id="e433" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q3。什么是JDBC API组件？</h2><p id="088c" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">java.sql包包含JDBC API的接口和类。</p><p id="ce19" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">接口:</strong></p><ul class=""><li id="bf3e" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">关系</li><li id="3222" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">声明</li><li id="c471" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">准备报表</li><li id="2d76" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">结果集</li><li id="92c1" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">结果集元数据</li><li id="407d" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">数据库元数据</li><li id="e1e1" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">可调用语句等。</li></ul><p id="629e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">班级:</strong></p><ul class=""><li id="8986" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">驾驶员管理器</li><li id="767e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">一滴</li><li id="fd3b" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">泥炭田</li><li id="8f44" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">类型</li><li id="ed13" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">SQLException等。</li></ul><h2 id="b779" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q4。JDBC驱动程序管理器类的作用是什么？</h2><p id="257b" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">驱动管理器<em class="lz">类</em>管理注册的驱动。它可以用来注册和注销驱动程序。它提供了返回连接实例的工厂方法。</p><h2 id="3607" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q5。什么是JDBC连接接口？</h2><p id="032c" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">连接接口维护与数据库的会话。它可用于事务管理。它提供了返回Statement、PreparedStatement、CallableStatement和DatabaseMetaData实例的工厂方法。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es my"><img src="../Images/aa15a8c98060934ae16de172ae6ad878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TziVjN_Kijf0kRzTBpHDPw.png"/></div></div></figure><h2 id="313c" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q6。JDBC结果集接口的目的是什么？</h2><p id="af51" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">ResultSet对象表示表中的一行。它可以用来改变光标指针并从数据库中获取信息。</p><h2 id="fd34" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q7。什么是JDBC结果集元数据接口？</h2><p id="c959" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">ResultSetMetaData接口返回表的信息，如总列数、列名、列类型等。</p><h2 id="16d4" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q8。什么是JDBC数据库元数据接口？</h2><p id="3a99" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">DatabaseMetaData接口返回数据库的信息，如用户名、驱动程序名、驱动程序版本、表数、视图数等。</p><h2 id="c7b4" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q9。你说的JDBC批量加工是什么意思？</h2><p id="7f3b" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">批处理帮助您将相关的SQL语句分组到一个批处理中并执行它们，而不是执行单个查询。通过在JDBC中使用批处理技术，您可以执行多个查询，从而提高性能。</p><h2 id="6027" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q10。execute，executeQuery，executeUpdate有什么区别？</h2><p id="ed35" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">语句<strong class="ir hi"> <em class="lz"> execute(字符串查询)</em> </strong>用于执行任何SQL查询，如果结果是结果集，如运行Select查询，则返回TRUE。当没有ResultSet对象(如运行插入或更新查询)时，输出为FALSE。我们可以使用<em class="lz"> getResultSet() </em>来获取结果集，并使用<em class="lz"> getUpdateCount() </em>方法来检索更新计数。</p><p id="f526" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">语句<strong class="ir hi"> <em class="lz"> executeQuery(字符串查询)</em> </strong>用于执行选择查询并返回结果集。即使没有与查询匹配的记录，返回的结果集也不会为null。当执行select查询时，我们应该使用executeQuery方法，这样如果有人试图执行insert/update语句，就会抛出java.sql.SQLException，并显示消息“executeQuery方法不能用于更新”。</p><p id="85f0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">语句<em class="lz"/><strong class="ir hi"><em class="lz">execute Update(字符串查询</em> </strong> <em class="lz"> ) </em>用于执行插入/更新/删除(DML)语句或不返回任何内容的DDL语句。输出是int，等于SQL数据操作语言(DML)语句的行数。对于DDL语句，输出为0。</p><p id="11bf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">只有在不确定语句类型时，才应该使用execute()方法，否则请使用executeQuery或executeUpdate方法。</p><h2 id="8c9b" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q11。你对JDBC的陈述有什么理解？</h2><p id="131d" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">JDBC语句基本上是用来向数据库发送SQL命令和从数据库检索数据的语句。像execute()、executeUpdate()、executeQuery等各种方法。由JDBC提供，用于与数据库交互。</p><p id="152b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">JDBC支持3种类型的语句:</p><ol class=""><li id="ed18" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi"> <em class="lz">语句:</em> </strong>用于对数据库的通用访问，在运行时执行静态SQL查询。</li><li id="1378" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi"><em class="lz">prepared statement:</em></strong>用于为执行中的查询提供输入参数。</li><li id="8da6" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi"><em class="lz">callable statement:</em></strong><em class="lz"/>用于访问数据库存储过程，帮助接受运行时参数。</li></ol><h1 id="51ae" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">春季面试问题</h1><h2 id="dc82" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q1。春天是什么？</h2><p id="4ae0" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Wikipedia将Spring框架定义为“Java平台的应用程序框架和控制容器反转”。该框架的核心特性可以被任何Java应用程序使用，但也有用于在Java EE平台上构建web应用程序的扩展。”Spring本质上是一个轻量级的集成框架，可用于用java开发企业应用程序。</p><h2 id="0d01" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q2。说出Spring框架的不同模块。</h2><p id="5381" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">一些重要的Spring框架模块是:</p><ul class=""><li id="9521" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated"><strong class="ir hi">Spring Context</strong><strong class="ir hi">-</strong>为依赖注入。</li><li id="8cd6" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi"> Spring AOP - </strong>面向方面编程。</li><li id="8e46" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi">弹簧刀</strong> <strong class="ir hi"> - </strong>使用刀模式进行数据库操作</li><li id="9669" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi">春天的JDBC - </strong>为JDBC和数据源提供支持。</li><li id="7826" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi"> Spring ORM - </strong>对Hibernate等ORM工具的支持</li><li id="2e02" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi"> Spring Web模块- </strong>用于创建Web应用程序。</li><li id="ad1e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi"> Spring MVC - </strong>模型-视图-控制器实现，用于创建web应用程序、web服务等。</li></ul><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mn"><img src="../Images/b789810f24055d18b2cbe53b883c551c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0IAipi7HH_cnfVMrcZ9Lew.png"/></div></div></figure><h2 id="47a2" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q3。列出基于注释的Spring配置中的一些重要注释。</h2><p id="88fb" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">重要的注释是:</p><ul class=""><li id="e311" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">@必填</li><li id="33fa" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">@自动连线</li><li id="9452" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">@限定符</li><li id="1fc7" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">@资源</li><li id="a560" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">@PostConstruct</li><li id="b049" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">@PreDestroy</li></ul><h2 id="fc8d" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q4。解释春豆，列出春豆的不同范围。</h2><p id="1f4b" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Beans是构成Spring应用程序主干的对象。它们由Spring IoC容器管理。换句话说，bean是由Spring IoC容器实例化、组装和管理的对象。</p><p id="e2bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Spring beans中定义了五个作用域。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mz"><img src="../Images/eb076d6d3c1fd42f86019e29bc314582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-liMgcvLHYhsDCGnnAbTQ.png"/></div></div></figure><ul class=""><li id="7320" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated"><strong class="ir hi"> Singleton </strong>:每个容器只创建一个bean实例。这是spring beans的默认范围。在使用这个范围时，确保spring bean没有共享的实例变量，否则可能会导致数据不一致的问题，因为它不是线程安全的。</li><li id="0a27" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi">原型</strong>:每次请求bean时都会创建一个新的实例。</li><li id="cbbe" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi"> Request </strong>:这与原型作用域相同，但是它意味着用于web应用程序。将为每个HTTP请求创建一个新的bean实例。</li><li id="adf5" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi">会话</strong>:容器将为每个HTTP会话创建一个新的bean。</li><li id="b8f9" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated"><strong class="ir hi">全局会话</strong>:这用于为Portlet应用程序创建全局会话beans。</li></ul><h2 id="01b4" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q5。解释DispatcherServlet和ContextLoaderListener的作用。</h2><p id="d202" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">DispatcherServlet 基本上是Spring MVC应用程序中的前端控制器，它加载spring bean配置文件并初始化所有已配置的bean。如果启用了注释，它还会扫描包来配置任何用@Component、@Controller、@Repository或@Service注释注释的bean。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/ece455877aab89b834ccde2f2b1dfff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vnbyaSmXL3kogg2MTqwcZA.png"/></div></div></figure><p id="62e5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> ContextLoaderListener，</strong>则是在Spring根中启动和关闭WebApplicationContext的监听器。它的一些重要功能包括将应用程序上下文的生命周期与ServletContext的生命周期联系起来，以及自动化应用程序上下文的创建。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es na"><img src="../Images/3736bf28db81a74c85e0d06397da1041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*giPszKjNclDgLRm5YJmREA.png"/></div></figure><h2 id="1e9a" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q6。构造函数注入和setter注入有什么区别？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mp"><img src="../Images/d20ba8135ad3c202b0e0b2d30e4feabd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zGPdfgyjV_uEPfdVd3R1QA.png"/></div></div></figure><h2 id="1041" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q7。什么是春季自动布线？什么是自动布线模式？</h2><p id="79c0" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">自动连接使程序员能够自动注入bean。我们不需要编写显式的注入逻辑。让我们看看使用依赖注入来注入bean的代码。</p><p id="421d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">自动布线模式如下所示:</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mp"><img src="../Images/fb7429597f4242020e4b4a6993c5eb0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VrOHKaETrLyllep8A2xcBA.png"/></div></div></figure><h2 id="911d" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q8。如何在Spring MVC框架中处理异常？</h2><p id="9484" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Spring MVC框架提供了以下方法来帮助我们实现健壮的异常处理。</p><p id="2a0c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">基于控制器:</strong></p><p id="fb05" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以在控制器类中定义异常处理方法。我们只需要用@ExceptionHandler注释来注释这些方法。</p><p id="d92b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">全局异常处理程序:</strong></p><p id="92c8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">异常处理是一个跨领域的问题，Spring提供了@ControllerAdvice注释，我们可以用它来定义我们的全局异常处理程序。</p><p id="c455" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> HandlerExceptionResolver实现:</strong></p><p id="4853" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于一般的异常，大多数时候我们提供静态页面。Spring框架提供了HandlerExceptionResolver接口，我们可以实现该接口来创建全局异常处理程序。这种定义全局异常处理程序的额外方法背后的原因是，spring framework还提供了默认的实现类，我们可以在spring bean配置文件中定义这些类，以获得Spring framework异常处理的好处。</p><h2 id="2584" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q9。你用过哪些重要的Spring注释？</h2><p id="c2e0" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">我在项目中使用的一些Spring注释是:</p><p id="99bc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">@控制器</strong> -用于Spring MVC项目中的控制器类。</p><p id="2de2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> @RequestMapping </strong> -用于在控制器处理程序方法中配置URI映射。这是一个非常重要的注释，因此您应该仔细阅读Spring MVC RequestMapping注释示例</p><p id="be98" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> @ResponseBody </strong> -用于发送对象作为响应，通常用于发送XML或JSON数据作为响应。</p><p id="43ac" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> @PathVariable </strong> -用于将动态值从URI映射到处理程序方法参数。</p><p id="8e2d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> @Autowired </strong> -用于spring beans中的自动连接依赖项。</p><p id="8108" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> @Qualifier </strong> -带有@Autowired注释，以避免出现多个bean类型实例时的混淆。</p><p id="0aed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> @Service </strong> -用于服务类。</p><p id="adee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> @Scope </strong> -用于配置春豆的范围。</p><p id="5964" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> @Configuration、@ComponentScan和@Bean </strong> -用于基于java的配置。</p><p id="144b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用于配置方面和建议的AspectJ注释，@Aspect，@Before，@After，@Around，@Pointcut等。</p><h2 id="6ad8" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q10。如何集成Spring和Hibernate框架？</h2><p id="d5d6" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">我们可以使用Spring ORM模块来集成Spring和Hibernate框架。如果您使用Hibernate 3+,其中SessionFactory提供当前会话，那么您应该避免使用HibernateTemplate或HibernateDaoSupport类，最好使用带有依赖注入的DAO模式进行集成。</p><p id="b8bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，Spring ORM支持使用Spring声明式事务管理，因此您应该利用这一点，而不是使用hibernate模板代码进行事务管理。</p><h2 id="6a68" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q11。说出Spring支持的事务管理类型。</h2><p id="41b3" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Spring支持两种类型的事务管理。它们是:</p><ol class=""><li id="4777" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi">程序化交易管理:</strong>在这种情况下，借助于编程来管理交易。它为您提供了极大的灵活性，但是很难维护。</li><li id="d243" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">声明式事务管理:</strong>在这里，事务管理与业务代码分离。只有注释或基于XML的配置用于管理事务。</li></ol><h1 id="412e" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">冬眠面试问题</h1><h2 id="1faa" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q1。什么是Hibernate框架？</h2><p id="34b8" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">对象关系映射或ORM是将应用程序域模型对象映射到关系数据库表的编程技术。Hibernate是基于Java的ORM工具，它提供了一个将应用程序域对象映射到关系数据库表的框架，反之亦然。</p><p id="179a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Hibernate提供了Java持久性API的参考实现，这使得它成为ORM工具的一个很好的选择，具有松耦合的优点。我们可以使用Hibernate持久性API进行CRUD操作。Hibernate框架通过使用JPA注释和基于XML的配置，提供了将普通的旧java对象映射到传统数据库表的选项。</p><p id="b6ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">类似地，hibernate配置也很灵活，既可以通过XML配置文件也可以通过编程来完成。</p><h2 id="d43f" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q2。使用Hibernate框架有什么重要的好处？</h2><p id="4b07" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">使用hibernate框架的一些重要好处是:</p><ol class=""><li id="30e3" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">Hibernate消除了JDBC附带的所有锅炉板代码，并负责管理资源，因此我们可以专注于业务逻辑。</li><li id="5551" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Hibernate框架提供了对XML和JPA注释的支持，这使得我们的代码实现是独立的。</li><li id="da81" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Hibernate提供了一种类似于SQL的强大的查询语言(HQL)。然而，HQL是完全面向对象的，理解继承、多态和关联等概念。</li><li id="0a02" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Hibernate是来自Red Hat社区的一个开源项目，在世界范围内广泛使用。这使它成为比其他软件更好的选择，因为学习曲线很小，而且有大量的在线文档，在论坛上很容易获得帮助。</li><li id="7c4c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Hibernate很容易与其他Java EE框架集成，它非常受欢迎，以至于Spring Framework为hibernate与Spring应用程序的集成提供了内置支持。</li><li id="d910" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Hibernate支持使用代理对象的惰性初始化，并且只在需要时才执行实际的数据库查询。</li><li id="d377" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">休眠缓存帮助我们获得更好的性能。</li><li id="152c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">对于数据库供应商特定特性，hibernate是合适的，因为我们还可以执行原生sql查询。</li></ol><p id="f6d8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总的来说，hibernate是目前市场上ORM工具的最佳选择，它包含了你在ORM工具中需要的所有特性。</p><h2 id="098e" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q3。解释Hibernate架构</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/de502aeb7e5572c86d6b4e89846994ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1o9EtU_cNf2s_Ks8ts4qA.png"/></div></div></figure><h2 id="1dfd" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q4。get和load方法有什么区别？</h2><p id="e9f9" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">get()和load()方法之间的区别如下所示。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nb"><img src="../Images/433ab4a42fe91335980b081ecf5f7486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*45W39SWGe32pTyGr0K1SSw.png"/></div></div></figure><h2 id="00da" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q5。Hibernate比JDBC有什么优势？</h2><p id="0544" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Hibernate框架相对于JDBC的一些重要优势是:</p><ol class=""><li id="4194" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">Hibernate删除了JDBC API附带的大量代码，代码看起来更干净，可读性更好。</li><li id="3527" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Hibernate支持继承、关联和集合。这些功能是JDBC API所不具备的。</li><li id="e7f0" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Hibernate隐式地提供了事务管理，事实上，大多数查询不能在事务之外执行。在JDBC API中，我们需要使用提交和回滚为事务管理编写代码。</li><li id="2279" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">JDBC API抛出的SQLException是检查过的异常，所以我们需要写很多try-catch块代码。大多数情况下，它在每个JDBC调用中都是冗余的，用于事务管理。Hibernate包装了JDBC异常并抛出JDBCException或HibernateException未检查异常，所以我们不需要写代码来处理它。Hibernate内置的事务管理消除了try-catch块的使用。</li><li id="9699" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Hibernate查询语言(HQL)更面向对象，更接近Java编程语言。对于JDBC，我们需要编写本地SQL查询。</li><li id="c993" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Hibernate支持缓存，这有利于提高性能，JDBC查询没有被缓存，因此性能较低。</li><li id="1e12" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Hibernate也提供了创建数据库表的选项，因为JDBC表必须存在于数据库中。</li><li id="ab30" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Hibernate配置帮助我们使用类似JDBC的连接以及连接池的JNDI数据源。这是企业应用程序中一个非常重要的特性，而在JDBC API中却完全没有。</li><li id="05d1" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Hibernate支持JPA注释，所以代码独立于实现，并且很容易用其他ORM工具替换。JDBC代码与应用程序紧密结合。</li></ol><h1 id="8e6e" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Java面试问题:JSP</h1><h2 id="b5a0" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q1。jsp的生命周期方法是什么？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nc"><img src="../Images/bf9be99eaf395a56bc7daa37ea24117b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HlENoHGhLKucjY5KrzyQSg.png"/></div></div></figure><h2 id="f8f4" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q2。JSP隐式对象有哪些？</h2><p id="840d" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">JSP默认提供9个隐式对象。它们如下:</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nd"><img src="../Images/206d480758f1ea17ea2a8a4cdffe80ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-AwWqPPWENckxJyKIfUH4w.png"/></div></div></figure><h2 id="0414" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q3。include指令和include动作有什么区别？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nd"><img src="../Images/80265060bdfc4f6ae71667e32879d90f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyEsNlh8TP0hJ5pLawQxuw.png"/></div></div></figure><h2 id="00cd" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q4。如何禁用浏览器后退按钮的缓存？</h2><p id="150e" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated"><strong class="ir hi">&lt;</strong>%<br/>response . set header(" Cache-Control "，" no-store ")；<br/> response.setHeader("Pragma "，" no-cache ")；<br/> response.setHeader ("Expires "，" 0 ")；//防止在代理服务器上缓存<br/> % <strong class="ir hi"> &gt; </strong></p><h2 id="799c" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q5。在JSTL有哪些不同的标签？</h2><p id="a234" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">有5种类型JSTL标签。</p><ol class=""><li id="1a82" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">核心标签</li><li id="f9d8" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">sql标记</li><li id="e030" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">xml标签</li><li id="4552" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">国际化标签</li><li id="c43c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">功能标签</li></ol><h2 id="c8c7" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q6。如何在JSP中禁用会话？</h2><p id="a051" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated"><strong class="ir hi">&lt;</strong>% @ page session = " false " %<strong class="ir hi">&gt;</strong></p><h2 id="e363" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q7。如何删除JSP中的Cookie？</h2><p id="3efb" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">以下代码解释了如何删除JSP中的Cookie:</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="0927" class="kz kc hh mc b fi mg mh l mi mj">Cookie mycook = new Cookie("name1","value1");<br/>response.addCookie(mycook1);<br/>Cookie killmycook = new Cookie("mycook1","value1"); <br/>killmycook . set MaxAge ( 0 );<br/>killmycook . set Path ("/");<br/>killmycook . addCookie ( killmycook 1 );</span></pre><h2 id="6993" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q8。解释jspDestroy()方法。</h2><p id="6950" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">每当jsp页面将要被销毁时，就会从<strong class="ir hi">javax . servlet . JSP . JSP page</strong>接口调用jspDestry()方法。Servlets destroy方法可以很容易地被覆盖来执行清理，比如在关闭数据库连接时。</p><h2 id="02f9" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q9。JSP怎么比Servlet技术好？</h2><p id="f045" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">JSP是服务器端的一种技术，可以简化内容生成。它们是以文档为中心的，而servlets是程序。Java服务器页面可以包含执行和实例化Java类的Java程序片段。但是，它们出现在HTML模板文件中。它为Web应用程序的开发提供了框架。</p><h1 id="d80d" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">Q10。为什么不应该在web.xml中配置JSP标准标签？</h1><p id="c92d" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">我们不需要在web.xml中配置JSP标准标记，因为当container加载web应用程序并找到TLD文件时，它会自动将它们配置为直接在应用程序JSP页面中使用。我们只需要使用taglib指令将它包含在JSP页面中。</p><h2 id="ee03" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q11。您将如何使用JSP EL来获取HTTP方法名？</h2><p id="7bc6" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">使用pageContext JSP EL隐式对象，您可以获得请求对象引用，并利用点运算符来检索JSP页面中的HTTP方法名。用于此目的的JSP EL代码将类似于${pageContext.request.method}。</p><h1 id="0345" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">异常和线程Java面试问题</h1><h2 id="2801" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q1。错误和异常的区别是什么？</h2><p id="fc20" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">错误是运行时出现的不可恢复的情况。例如内存不足错误。这些JVM错误不能在运行时修复。虽然可以在catch块中捕获错误，但是应用程序的执行将会停止并且不可恢复。</p><p id="c4bc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">而异常是由于错误输入或人为错误等而发生的情况。例如，如果指定的文件不存在，将抛出FileNotFoundException。或者，如果您尝试使用空引用，将会发生NullPointerException。在大多数情况下，有可能从异常中恢复(可能是通过给用户输入正确值的反馈等。</p><h2 id="aecd" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q2。如何处理Java异常？</h2><p id="8234" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java中有五个关键字用于处理异常:</p><ol class=""><li id="3302" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">尝试</li><li id="b3b3" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">捕捉</li><li id="5929" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">最后</li><li id="8538" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">扔</li><li id="8a78" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">投</li></ol><h2 id="ec17" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q3。检查异常和未检查异常有什么区别？</h2><p id="a16c" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated"><strong class="ir hi"> <em class="lz">检查出异常</em> </strong></p><ul class=""><li id="ac2f" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">除了RuntimeException和Error之外，扩展Throwable类的类被称为检查异常。</li><li id="888c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">被检查的异常在编译时被检查。</li><li id="74d9" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">示例:IOException、SQLException等。</li></ul><p id="412f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lz">未检查的异常</em> </strong></p><ul class=""><li id="7c5a" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">扩展RuntimeException的类被称为未检查的异常。</li><li id="c617" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">编译时不检查未检查的异常。</li><li id="e070" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">例如:ArithmeticException、NullPointerException等。</li></ul><h2 id="24ab" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q4。关键字final、final和finalize的目的是什么？</h2><p id="a321" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated"><strong class="ir hi"> <em class="lz">最终:</em> </strong></p><p id="e623" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Final用于对类、方法和变量应用限制。final类不能被继承，final方法不能被覆盖，final变量值不能被改变。让我们看看下面的例子来更好地理解它。</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="abe7" class="kz kc hh mc b fi mg mh l mi mj">class FinalVarExample {<br/>public static void main( String args[])<br/>{<br/>final int a=10;   // Final variable<br/>a=50;             //Error as value can't be changed<br/>}</span></pre><p id="3592" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lz">最后:</em> </strong></p><p id="2470" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Finally用于放置重要的代码，无论异常是否被处理，它都会被执行。让我们看看下面的例子来更好地理解它。</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="d638" class="kz kc hh mc b fi mg mh l mi mj">class FinallyExample {<br/>public static void main(String args[]){<br/>try {<br/>int x=100;<br/>}<br/>catch(Exception e) {<br/>System.out.println(e);<br/>}<br/>finally {<br/>System.out.println("finally block is executing");}<br/>}}<br/>}</span></pre><p id="d6c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="lz">敲定</em> </strong></p><p id="6229" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Finalize用于在对象被垃圾回收之前执行清理处理。让我们看看下面的例子来更好地理解它。</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="d0af" class="kz kc hh mc b fi mg mh l mi mj">class FinalizeExample {<br/>public void finalize() {<br/>System.out.println("Finalize is called");<br/>}<br/>public static void main(String args[])<br/>{<br/>FinalizeExample f1=new FinalizeExample();<br/>FinalizeExample f2=new FinalizeExample();<br/>f1= NULL;<br/>f2=NULL;<br/>System.gc();<br/>}<br/>}</span></pre><h2 id="5e35" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q5。throw和throws有什么区别？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ne"><img src="../Images/2d4b9a93e4a0d427d8d08605223f4734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJvOU6Cjk-wQBUaNM2gfgw.png"/></div></div></figure><h2 id="701c" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q6。java中的异常层次是什么？</h2><p id="e9a2" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">层次结构如下:</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es nf"><img src="../Images/1185529737ce4c22064c82c1b6ac6326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*AwHUsjKiwh5_HyBdwH1iLQ.png"/></div></figure><p id="87b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Throwable是所有异常类的父类。有两种类型的异常:已检查的异常和未检查的异常或运行时异常。两种类型的异常都扩展了异常类，而错误又进一步分为虚拟机错误和断言错误。</p><h2 id="63bd" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q7。如何创建自定义异常？</h2><p id="56f1" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">要创建自己的异常，请扩展异常类或它的任何子类。</p><ul class=""><li id="3e1b" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">类New1Exception扩展异常{ } //这将创建检查的异常</li><li id="0e90" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">NewException类扩展IOException { } //这将创建检查的异常</li><li id="041f" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">class NewException扩展了nullponterexception { }//这将创建未检查的异常</li></ul><h2 id="42e8" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q8。Java异常类的重要方法有哪些？</h2><p id="6078" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Exception及其所有子类不提供任何特定的方法，所有方法都在基类Throwable中定义。</p><ol class=""><li id="4957" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi"> String getMessage() </strong> —该方法返回Throwable的消息字符串，该消息可以在通过其构造函数创建异常时提供。</li><li id="0c18" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">String getlocalized message(</strong>)—提供此方法是为了让子类可以覆盖它，以便向调用程序提供特定于语言环境的消息。Throwable类实现这个方法只需使用getMessage()方法返回异常消息。</li><li id="0ce8" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">Synchronized Throwable get cause()</strong>—该方法返回异常或空id的原因，原因未知。</li><li id="fb61" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi"> String toString() </strong> —该方法以字符串格式返回Throwable的信息，返回的字符串包含Throwable类的名称和本地化的消息。</li><li id="f25f" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">void printStackTrace()</strong>—此方法将堆栈跟踪信息打印到标准错误流，此方法是重载的，我们可以将PrintStream或PrintWriter作为参数传递，以将堆栈跟踪信息写入文件或流。</li></ol><h2 id="07f3" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q9。进程和线程有什么区别？</h2><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ng"><img src="../Images/ee41c40377608f67b707d7a98a5626af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rZe_VcoVfM2FiyV3GGXBw.png"/></div></div></figure><h2 id="42f6" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q10。什么是finally块？有没有最后不执行的情况？</h2><p id="9162" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Finally块是一个总是执行一组语句的块。无论是否发生任何异常，它总是与try块相关联。<br/>是，如果程序通过调用System.exit()或导致致命错误(导致进程中止)而退出，finally将不会执行。</p><h2 id="25b5" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q11。什么是同步？</h2><p id="990b" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">同步指的是多线程。一个同步的代码块一次只能由一个线程执行。由于Java支持多线程的执行，两个或多个线程可以访问相同的字段或对象。同步是一个保持所有执行中的并发线程同步的过程。同步避免了由于共享内存视图不一致而导致的内存一致性错误。当一个方法被声明为synchronized时，线程持有该方法对象的监视器。如果另一个线程正在执行synchronized方法，该线程将被阻塞，直到该线程释放监视器。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nh"><img src="../Images/4328e6c79772d167fc5943b0f809f787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7w6QFWzcendYNA4ZRWRzsQ.png"/></div></div></figure><h2 id="0b31" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q12。可以在单个try块下写多个catch块吗？</h2><p id="29b0" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">是的，我们可以在单个try块下有多个catch块，但是方法应该从特定到一般。让我们通过一个编程示例来理解这一点。</p><pre class="lo lp lq lr fd mb mc md me aw mf bi"><span id="2634" class="kz kc hh mc b fi mg mh l mi mj">public class Example {<br/>public static void main(String args[]) {<br/>try {<br/>int a[]= new int[10];<br/>a[10]= 10/0;<br/>}<br/>catch(ArithmeticException e)<br/>{<br/>System.out.println("Arithmetic exception in first catch block");<br/>}<br/>catch(ArrayIndexOutOfBoundsException e)<br/>{<br/>System.out.println("Array index out of bounds in second catch block");<br/>}<br/>catch(Exception e)<br/>{<br/>System.out.println("Any exception in third catch block");<br/>}<br/>}</span></pre><h2 id="b11c" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q13。Java异常类的重要方法有哪些？</h2><p id="58c6" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">方法是在基类Throwable中定义的。下面是Java异常类的一些重要方法。</p><ol class=""><li id="78dc" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi"> String getMessage() </strong> —该方法返回关于异常的消息字符串。消息可以通过其构造函数提供。</li><li id="f5ff" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">public stack trace element[]getstack trace()—</strong>该方法返回一个数组，包含堆栈跟踪中的每个元素。索引0处的元素表示调用堆栈的顶部，而数组中的最后一个元素表示调用堆栈底部的方法。</li><li id="d7a2" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">Synchronized Throwable get cause()</strong>—该方法返回异常的原因或由Throwable对象表示的空id。</li><li id="571a" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi"> String toString() </strong> —该方法以字符串格式返回信息。返回的字符串包含可抛出类的名称和本地化消息。</li><li id="0e63" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi"> void printStackTrace() </strong> —此方法将堆栈跟踪信息打印到标准错误流中。</li></ol><h2 id="f4e6" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q14。Java中的OutOfMemoryError是什么？</h2><p id="9846" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">OutOfMemoryError是java.lang.Error的子类，通常在JVM内存不足时发生。</p><h2 id="dfe8" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q15。什么是线程？</h2><p id="d98a" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">线程是可由调度程序独立执行的最小程序指令。在Java中，所有的程序都至少有一个被称为主线程的线程。这个主线程是在程序开始执行时由JVM创建的。主线程用于调用程序的main()。</p><h2 id="9274" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q16。创建线程的两种方法是什么？</h2><p id="3b95" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">在Java中，可以通过以下两种方式创建线程:-</p><ul class=""><li id="5146" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">通过实现Runnable接口。</li><li id="4738" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">通过延长螺纹</li></ul><h2 id="8079" class="kz kc hh bd kd la lb lc kh ld le lf kl ja lg lh kp je li lj kt ji lk ll kx lm bi translated">Q17。Java中有哪些不同类型的垃圾收集器？</h2><p id="8efc" class="pw-post-body-paragraph ip iq hh ir b is ls iu iv iw lt iy iz ja lu jc jd je lv jg jh ji lw jk jl jm ha bi translated">Java中的垃圾收集一个帮助隐式内存管理的程序。因为在Java中，使用new关键字可以动态地创建对象，一旦创建了对象，就会消耗一些内存。一旦任务完成，并且不再有对对象的引用，Java使用垃圾收集销毁对象并释放它所占用的内存。Java提供了四种垃圾收集器:</p><ul class=""><li id="87de" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm lx jt ju jv bi translated">串行垃圾收集器</li><li id="90e9" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">并行垃圾收集器</li><li id="e153" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">CMS垃圾收集器</li><li id="dda7" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm lx jt ju jv bi translated">G1垃圾收集器</li></ul><p id="61a1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就把我们带到了Java面试问题博客的结尾。您在这个Java面试问题博客中学习的主题是招聘人员在Java专业人员中寻找的最受欢迎的技能。这些Java面试问题一定会帮助你在面试中胜出。祝你面试顺利！</p><p id="c2b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想查看更多关于人工智能、DevOps、道德黑客等市场最热门技术的文章，那么你可以参考<a class="ae ni" href="https://www.edureka.co/blog/?utm_source=medium&amp;utm_medium=content-link&amp;utm_campaign=java-interview-questions" rel="noopener ugc nofollow" target="_blank"> Edureka的官方网站。</a></p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释Java的各个方面。</p><blockquote class="nj nk nl"><p id="1138" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">1.<a class="ae ni" rel="noopener" href="/edureka/object-oriented-programming-b29cfd50eca0">面向对象编程</a></p><p id="98de" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">2.<a class="ae ni" rel="noopener" href="/edureka/inheritance-in-java-f638d3ed559e">Java中的继承</a></p><p id="e34c" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">3.<a class="ae ni" rel="noopener" href="/edureka/polymorphism-in-java-9559e3641b9b">Java中的多态性</a></p><p id="9f5c" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">4.<a class="ae ni" rel="noopener" href="/edureka/java-abstraction-d2d790c09037">Java中的抽象</a></p><p id="f258" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">5.<a class="ae ni" rel="noopener" href="/edureka/java-string-68e5d0ca331f"> Java字符串</a></p><p id="71f7" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">6.<a class="ae ni" rel="noopener" href="/edureka/java-array-tutorial-50299ef85e5"> Java数组</a></p><p id="cabb" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">7.<a class="ae ni" rel="noopener" href="/edureka/java-collections-6d50b013aef8"> Java集合</a></p><p id="340f" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">8.<a class="ae ni" rel="noopener" href="/edureka/java-thread-bfb08e4eb691"> Java线程</a></p><p id="1843" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">9.Java Servlets简介</p><p id="7e8f" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">10.<a class="ae ni" rel="noopener" href="/edureka/servlet-and-jsp-tutorial-ef2e2ab9ee2a"> Servlet和JSP教程</a></p><p id="521d" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">11.<a class="ae ni" rel="noopener" href="/edureka/java-exception-handling-7bd07435508c">Java中的异常处理</a></p><p id="6513" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">12.<a class="ae ni" rel="noopener" href="/edureka/advanced-java-tutorial-f6ebac5175ec">高级Java教程</a></p><p id="6660" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">13.<a class="ae ni" rel="noopener" href="/edureka/java-tutorial-bbdd28a2acd7"> Java教程</a></p><p id="9eea" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">14.<a class="ae ni" rel="noopener" href="/edureka/java-programs-1e3220df2e76"> Java程序</a></p><p id="0de8" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">15.<a class="ae ni" rel="noopener" href="/edureka/kotlin-vs-java-4f8653f38c04"> Kotlin vs Java </a></p><p id="73ef" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">16.<a class="ae ni" rel="noopener" href="/edureka/what-is-dependency-injection-5006b53af782">使用Spring Boot的依赖注入</a></p><p id="04cc" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">17.<a class="ae ni" rel="noopener" href="/edureka/comparable-in-java-e9cfa7be7ff7">堪比Java </a></p><p id="0f07" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">18.<a class="ae ni" rel="noopener" href="/edureka/java-frameworks-5d52f3211f39">十大Java框架</a></p><p id="7c21" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">19.<a class="ae ni" rel="noopener" href="/edureka/java-reflection-api-d38f3f5513fc"> Java反射API </a></p><p id="0359" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">20.<a class="ae ni" rel="noopener" href="/edureka/pattern-programs-in-java-f33186c711c8">Java中的30大模式</a></p><p id="1b5a" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">21.<a class="ae ni" rel="noopener" href="/edureka/java-cheat-sheet-3ad4d174012c">核心Java备忘单</a></p><p id="eac5" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">22.<a class="ae ni" rel="noopener" href="/edureka/socket-programming-in-java-f09b82facd0">Java中的套接字编程</a></p><p id="c576" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">23.<a class="ae ni" rel="noopener" href="/edureka/java-oop-cheat-sheet-9c6ebb5e1175"> Java OOP备忘单</a></p><p id="08c5" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">24.<a class="ae ni" rel="noopener" href="/edureka/annotations-in-java-9847d531d2bb">Java中的注释</a></p><p id="5eae" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">25.<a class="ae ni" rel="noopener" href="/edureka/library-management-system-project-in-java-b003acba7f17">Java中的图书管理系统项目</a></p><p id="ac14" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">26.<a class="ae ni" rel="noopener" href="/edureka/java-binary-tree-caede8dfada5">爪哇的树木</a></p><p id="41c1" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">27.<a class="ae ni" rel="noopener" href="/edureka/machine-learning-in-java-db872998f368">Java中的机器学习</a></p><p id="6762" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">28.<a class="ae ni" rel="noopener" href="/edureka/data-structures-algorithms-in-java-d27e915db1c5">Java中的顶级数据结构&amp;算法</a></p><p id="10e3" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">29.<a class="ae ni" rel="noopener" href="/edureka/java-developer-skills-83983e3d3b92"> Java开发者技能</a></p><p id="acd9" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">30.<a class="ae ni" rel="noopener" href="/edureka/servlet-interview-questions-266b8fbb4b2d">前55个Servlet面试问题</a></p><p id="965a" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">31.<a class="ae ni" rel="noopener" href="/edureka/java-exception-handling-7bd07435508c"> </a> <a class="ae ni" rel="noopener" href="/edureka/java-projects-db51097281e3">顶级Java项目</a></p><p id="3fd2" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">32.<a class="ae ni" rel="noopener" href="/edureka/java-string-cheat-sheet-9a91a6b46540"> Java字符串备忘单</a></p><p id="d7ba" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">33.<a class="ae ni" rel="noopener" href="/edureka/nested-classes-java-f1987805e7e3">Java中的嵌套类</a></p><p id="15e1" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">34.<a class="ae ni" rel="noopener" href="/edureka/java-collections-interview-questions-162c5d7ef078"> Java集合面试问答</a></p><p id="3e57" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">35.<a class="ae ni" rel="noopener" href="/edureka/deadlock-in-java-5d1e4f0338d5">Java中如何处理死锁？</a></p><p id="a282" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">36.<a class="ae ni" rel="noopener" href="/edureka/java-collections-interview-questions-6d20f552773e">你需要知道的50大Java集合面试问题</a></p><p id="07a7" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">37.<a class="ae ni" rel="noopener" href="/edureka/java-string-pool-5b5b3b327bdf">Java中的字符串池是什么概念？</a></p><p id="50d8" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">38.<a class="ae ni" rel="noopener" href="/edureka/difference-between-c-cpp-and-java-625c4e91fb95">C、C++和Java有什么区别？</a></p><p id="620e" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">39.<a class="ae ni" rel="noopener" href="/edureka/palindrome-in-java-5d116eb8755a">Java中的回文——如何检查一个数字或字符串？</a></p><p id="ae61" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">40.<a class="ae ni" rel="noopener" href="/edureka/mvc-interview-questions-cd568f6d7c2e">你需要知道的顶级MVC面试问答</a></p><p id="56ca" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">41.<a class="ae ni" rel="noopener" href="/edureka/applications-of-java-11e64f9588b0">Java编程语言十大应用</a></p><p id="c828" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">42.<a class="ae ni" rel="noopener" href="/edureka/deadlock-in-java-5d1e4f0338d5">Java中的死锁</a></p><p id="c6d7" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">43.<a class="ae ni" rel="noopener" href="/edureka/java-sqrt-method-59354a700571">Java中的平方和平方根</a></p><p id="0263" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">44.<a class="ae ni" rel="noopener" href="/edureka/type-casting-in-java-ac4cd7e0bbe1">Java中的类型转换</a></p><p id="b93e" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">45.<a class="ae ni" rel="noopener" href="/edureka/operators-in-java-fd05a7445c0a">Java中的运算符及其类型</a></p><p id="836c" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">46.<a class="ae ni" rel="noopener" href="/edureka/destructor-in-java-21cc46ed48fc">Java中的析构函数</a></p><p id="ce21" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">47.<a class="ae ni" rel="noopener" href="/edureka/binary-search-in-java-cf40e927a8d3">Java中的二分搜索法</a></p><p id="7708" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">48.<a class="ae ni" rel="noopener" href="/edureka/mvc-architecture-in-java-a85952ae2684">Java中的MVC架构</a></p><p id="fa9e" class="ip iq lz ir b is it iu iv iw ix iy iz nm jb jc jd nn jf jg jh no jj jk jl jm ha bi translated">49.<a class="ae ni" rel="noopener" href="/edureka/hibernate-interview-questions-78b45ec5cce8">冬眠面试问答</a></p></blockquote></div><div class="ab cl np nq go nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ha hb hc hd he"><p id="f4ba" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lz">原载于2019年6月7日</em><a class="ae ni" href="https://www.edureka.co/blog/interview-questions/java-interview-questions/" rel="noopener ugc nofollow" target="_blank"><em class="lz">www.edureka.co</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>