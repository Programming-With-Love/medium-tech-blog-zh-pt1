<html>
<head>
<title>React Native Plant App UI #4 : Illustration Slider and Animated Steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React原生植物应用程序UI #4:插图滑块和动画步骤</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/react-native-plant-app-ui-4-illustration-slider-and-animated-steps-649c4731807f?source=collection_archive---------0-----------------------#2019-11-12">https://medium.com/quick-code/react-native-plant-app-ui-4-illustration-slider-and-animated-steps-649c4731807f?source=collection_archive---------0-----------------------#2019-11-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1f37c407fde4b134966efd211fb33cf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l0YBzA4Nykc-7NVg.png"/></div></div></figure><p id="5af9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本教程是我们React原生植物应用教程系列的第四部分。在<a class="ae jn" href="https://kriss.io/react-native-plant-app-ui-3-implementing-welcome-screen/" rel="noopener ugc nofollow" target="_blank">的前一部分</a>中，我们成功地实现并截取了欢迎屏幕的一些UI部分。本教程是我们上一部分停止的同一教程的继续。因此，建议仔细阅读前一部分，以便对整个项目有所了解和认识。</p><p id="6b2c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您想从头开始学习，可以在下面找到本教程系列之前的所有部分:</p><ul class=""><li id="a750" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><a class="ae jn" href="https://kriss.io/react-native-plant-app-ui-1-getting-started/" rel="noopener ugc nofollow" target="_blank"> React原生植物App UI #1:入门</a></li><li id="c93f" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><a class="ae jn" href="https://kriss.io/react-native-plant-app-ui-2-implementing-custom-components/" rel="noopener ugc nofollow" target="_blank"> React本地工厂应用UI #2:实现定制组件</a></li><li id="303b" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><a class="ae jn" href="https://kriss.io/react-native-plant-app-ui-3-implementing-welcome-screen/" rel="noopener ugc nofollow" target="_blank">构建React原生植物应用UI #3:实现欢迎屏幕</a></li></ul><p id="ffc4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如前所述，撰写本系列教程的动机来自于<a class="ae jn" href="https://www.instamobile.io/" rel="noopener ugc nofollow" target="_blank"> React Native应用程序模板</a>，这些模板提供了各种用React Native编写的移动应用程序模板，并由通用特性和设计提供支持。这些应用程序模板允许我们实现自己的应用程序，甚至启动自己的创业公司。此外，第四部分也是Youtube视频教程中的编码实现和设计的延续，由<a class="ae jn" href="https://www.youtube.com/watch?v=gyiwFcrVRCM&amp;list=PLNRPou200YIeu4UllJkv8-Ca19Ld_eOay&amp;index=2" rel="noopener ugc nofollow" target="_blank"> React UI Kit </a>用于Plant应用程序。视频教程似乎非常彻底地交付了整体app的编码实现。但是，没有对编码和实现的口头指导。本教程系列是实现相同的编码风格和设计形式的文章。因此，学习者可以经历每一步，慢慢理解实现。</p><h2 id="66ab" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">概观</h2><p id="2b7c" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">在这个系列教程的第四部分中，我们将实现我们在上一部分教程中分离出来的UI部分。我们分离的UI部分是插图部分和步骤(分隔符点)部分。这个想法是从在欢迎屏幕上用水平图像滑块实现插图部分开始。然后，我们将添加分隔符点称为步骤部分下面的图像插图。然后，我们将根据插图图像的滑动为活动分隔符点设置动画。</p><p id="2bcb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么，让我们开始吧！！</p><h2 id="2f27" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">将图像作为道具导入</h2><p id="a5bb" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">这里，我们将为插图滑块部分导入图像。我们将使用<code class="du ld le lf lg b">defaultProps</code>模块导入插图作为道具。为此，我们需要使用以下代码片段中的代码:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="6dd6" class="kc kd hh lg b fi lp lq l lr ls">Welcome.defaultProps = {<br/>  illustrations: [<br/>    { id: 1, source: require('../assets/images/illustration_1.png') },<br/>    { id: 2, source: require('../assets/images/illustration_2.png') },<br/>    { id: 3, source: require('../assets/images/illustration_3.png') },<br/>  ],<br/>};</span></pre><p id="9e61" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，我们定义了一个名为<code class="du ld le lf lg b">illustrations</code>的数组，它保存图像为<code class="du ld le lf lg b">id</code>和<code class="du ld le lf lg b">source</code>的对象。现在，我们可以使用插图变量作为欢迎屏幕中的道具。</p><h2 id="dfb7" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">实施插图部分</h2><p id="aadd" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">现在，我们要以函数<code class="du ld le lf lg b">renderIllustrations()</code>的形式实现我们在之前教程中截取的插图部分。在这个插图部分，我们将把图像显示为一个水平滑块。为此，我们需要使用以下代码片段中的代码:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="2895" class="kc kd hh lg b fi lp lq l lr ls">state = {<br/>  }<br/><br/><br/>renderIllustrations(){<br/>    const { illustrations } = this.props;</span></pre><p id="a0df" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，我们已经初始化了<code class="du ld le lf lg b">state</code>变量。此外，我们已经从props中定义了<code class="du ld le lf lg b">illustrations</code>常量。现在，我们将插图部分中的图像显示为水平滑块。</p><h2 id="8997" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">使用<code class="du ld le lf lg b">FlatList</code>组件</h2><p id="e724" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">这里，我们将使用<code class="du ld le lf lg b">FlatList</code>组件来渲染图像。然后，我们将使用不同的道具配置来配置<code class="du ld le lf lg b">FlatList</code>，以便正确显示水平图像滑块。为此，我们需要在<code class="du ld le lf lg b">renderIllustrations()</code>函数中使用以下代码片段中的代码:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="ead9" class="kc kd hh lg b fi lp lq l lr ls">&lt;FlatList<br/>  horizontal<br/>  pagingEnabled<br/>  scrollEnabled<br/>  showsHorizontalScrollIndicator={false}<br/>  scrollEventThrottle={16}<br/>  snapToAlignment="center"<br/>  data={illustrations}<br/>  extraDate={this.state}<br/>  keyExtractor={(item, index) =&gt; `${item.id}`}<br/>  renderItem={({ item }) =&gt; (<br/>    &lt;Image<br/>      source={item.source}<br/>      resizeMode="contain"<br/>    /&gt;<br/>  )}<br/>/&gt;</span></pre><p id="6551" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，我们有一个<code class="du ld le lf lg b">FlatList</code>，它具有不同的螺旋桨配置，解释如下:</p><ul class=""><li id="fc83" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><code class="du ld le lf lg b">pagingEnabled</code>:当其值为true时，滚动时滚动视图停止在滚动视图大小的倍数上。默认值为false。</li><li id="1c50" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><code class="du ld le lf lg b">scrollEnabled</code>:当其值为false时，不能通过触摸交互滚动视图。默认值为true。</li><li id="2837" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><code class="du ld le lf lg b">showsHorizontalScrollIndicator</code>:当其值为false时，底部的水平滚动条不显示。</li><li id="d591" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><code class="du ld le lf lg b">scrollEventThrottle</code>:该属性用于控制滚动时触发滚动事件的频率(以毫秒为单位的时间间隔)。数字越小，跟踪滚动位置的代码越准确。</li><li id="3bb3" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><code class="du ld le lf lg b">snapToAlignment</code>:该属性将定义捕捉与滚动视图的关系。</li></ul><p id="264a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，我们还有<code class="du ld le lf lg b">keyExtractor</code>道具，用于惟一地标识列表中的每一项。然后，我们有了<code class="du ld le lf lg b">renderItem</code> prop，它使我们能够返回列表中每一项的模板。在这种情况下，它返回来源于<code class="du ld le lf lg b">illustrations</code>数组的<code class="du ld le lf lg b">Image</code>组件。</p><p id="7009" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，我们将在模拟器屏幕中获得以下结果:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es lt"><img src="../Images/5395be6fbcdeece2badb67f83418abb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*KuGhaNrhfyQMHY6G.gif"/></div></figure><p id="464f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们所看到的，我们得到了带有水平图像滑块的插图部分。但是，图像和滑动动作似乎并不吸引人。因此，我们将对我们的<code class="du ld le lf lg b">FlatList</code>和它的<code class="du ld le lf lg b">Image</code>组件使用一些样式属性。</p><h2 id="ba2d" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated"><strong class="ak">配置插图样式</strong></h2><p id="0507" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">这里，我们将为平面列表及其图像组件配置一些样式。为此，我们将使用react-native包中的<code class="du ld le lf lg b">Dimensions</code>组件。这个<code class="du ld le lf lg b">Dimensions</code>组件允许我们获得应用程序屏幕的完整高度和宽度，这样我们就可以使用这些尺寸变量来配置样式。为此，我们需要首先导入<code class="du ld le lf lg b">Dimensions</code>组件，如下面的代码片段所示:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="11ab" class="kc kd hh lg b fi lp lq l lr ls">import { StyleSheet, FlatList, Image, Dimensions } from 'react-native';</span></pre><p id="98cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们需要使用由<code class="du ld le lf lg b">Dimensions</code>组件提供的<code class="du ld le lf lg b">get()</code>函数，如下面的代码片段所示:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="315a" class="kc kd hh lg b fi lp lq l lr ls">const { width, height } = Dimensions.get('window');</span></pre><p id="69b9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们将使用这些<code class="du ld le lf lg b">width</code>和<code class="du ld le lf lg b">height</code>常量来设计<code class="du ld le lf lg b">renderIllustrations()</code>函数中的插图:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="5856" class="kc kd hh lg b fi lp lq l lr ls">&lt;FlatList<br/>   horizontal<br/>   pagingEnabled<br/>   scrollEnabled<br/>   showsHorizontalScrollIndicator={false}<br/>   scrollEventThrottle={16}<br/>   snapToAlignment="center"<br/>   data={illustrations}<br/>   extraDate={this.state}<br/>   keyExtractor={(item, index) =&gt; `${item.id}`}<br/>   renderItem={({ item }) =&gt; (<br/>     &lt;Image<br/>       source={item.source}<br/>       resizeMode="contain"<br/>       style={{ width, height: height / 2, overflow: 'visible' }}<br/>     /&gt;<br/>   )}<br/> /&gt;</span></pre><p id="2d80" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，我们将在模拟器屏幕中获得以下结果:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es lt"><img src="../Images/30bca464d3d1040bb56264dfaf2c2058.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*_8gSrgtg3pwHHPwX.gif"/></div></figure><p id="0f2b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们所看到的，我们现在已经有了插图部分和一个合适的图像滑块。而且，滑动动作看起来很流畅，很吸引人。</p><h2 id="9d33" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated">实施步骤部分</h2><p id="9149" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">在这一步中，我们将实现步骤部分，它将根据插图部分图像的数量包括分隔符点。因为有三个图像，所以将有三个定界符点。在上一篇教程中，我们已经将这一部分分割为<code class="du ld le lf lg b">renderSteps()</code>函数。现在，我们将向该函数添加分隔符点。为此，我们需要使用以下代码片段中的代码:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="76c5" class="kc kd hh lg b fi lp lq l lr ls">renderSteps(){<br/>   const { illustrations } = this.props<br/>   return(<br/>     &lt;Block row center middle style={styles.stepsContainer}&gt;<br/>       {illustrations.map((item, index) =&gt; {<br/>         return (<br/>           &lt;Block<br/>             animated<br/>             flex={false}<br/>             key={`step-${index}`}<br/>             color="gray"<br/>             style={[styles.steps]}<br/>           /&gt;<br/>         )<br/>       })}<br/>     &lt;/Block&gt;<br/>   )<br/> }</span></pre><p id="2908" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，在<code class="du ld le lf lg b">renderSteps()</code>函数中，我们从props中定义了<code class="du ld le lf lg b">illustrations</code>常量，就像在<code class="du ld le lf lg b">renderIllustration()</code>函数中一样。然后，我们返回了一个父组件为<code class="du ld le lf lg b">Block</code>的模板和一些样式道具。块模板包裹定界符点的模板。这里为了使定界符点的数量等于插图图像的数量，我们使用了插图数组中的<code class="du ld le lf lg b">map()</code>数组函数。<code class="du ld le lf lg b">map()</code>函数遍历插图数组中的每一项，并返回每一项的模板。在这种情况下，我们使用<code class="du ld le lf lg b">map()</code>功能只是为了使定界符点的数量等于插图图像的数量。然后，在map()函数内部，我们已经返回了带有道具和样式的<code class="du ld le lf lg b">Block</code>组件。</p><p id="24b4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面的代码片段提供了所需的样式:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="dac0" class="kc kd hh lg b fi lp lq l lr ls">const styles = StyleSheet.create({<br/>  stepsContainer: {<br/>    position: 'absolute',<br/>    bottom: theme.sizes.base * 3,<br/>    right: 0,<br/>    left: 0,<br/>  },<br/>  steps: {<br/>    width: 5,<br/>    height: 5,<br/>    borderRadius: 5,<br/>    marginHorizontal: 2.5,<br/>  },<br/>});</span></pre><p id="293d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，我们将在模拟器屏幕中获得以下结果:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lu"><img src="../Images/b5b356a516f84649e0ebf1a15cf05dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Auspf3nsfpya8EE6.png"/></div></div></figure><p id="a42a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们所看到的，我们在插图图像的底部有分隔符点。到目前为止，这些点将只是看起来毫无生气的风格。但是我们将在图像滑动的基础上，为这些点添加带有动画的活动样式。</p><h2 id="4f97" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated"><strong class="ak">添加活动风格动画</strong></h2><p id="b9d6" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">在这里，我们将添加动画到我们的步骤部分的分隔符点。为此，我们需要从react-native包中导入<code class="du ld le lf lg b">Animated</code>组件，如下面的代码片段所示:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="d729" class="kc kd hh lg b fi lp lq l lr ls">import { StyleSheet, FlatList, Image, Dimensions, Animated } from 'react-native';</span></pre><p id="0243" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们需要定义一个名为<code class="du ld le lf lg b">scrollX</code>的变量，它被初始化为<code class="du ld le lf lg b">Animated</code>值。这个变量将为水平动画存储我们的动画值。为此，我们需要使用以下代码片段中的代码:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="54e3" class="kc kd hh lg b fi lp lq l lr ls">export default class Welcome extends React.Component {<br/>  <br/>  scrollX = new Animated.Value(0);<br/><br/>  state = {<br/>  }<br/><br/>.......................</span></pre><p id="11e4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，<code class="du ld le lf lg b">Animated.Value</code>配置使我们能够绑定到样式属性或其他属性，也可以进行插值。</p><p id="dba6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们需要将这个<code class="du ld le lf lg b">scrollX</code>值配置到<code class="du ld le lf lg b">renderIllustrations()</code>函数的<code class="du ld le lf lg b">FlatList</code>组件的<code class="du ld le lf lg b">onScroll</code>事件中，如下面的代码片段所示:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="8e9d" class="kc kd hh lg b fi lp lq l lr ls">&lt;FlatList<br/>   horizontal<br/>   pagingEnabled<br/>   scrollEnabled<br/>   showsHorizontalScrollIndicator={false}<br/>   scrollEventThrottle={16}<br/>   snapToAlignment="center"<br/>   data={illustrations}<br/>   extraDate={this.state}<br/>   keyExtractor={(item, index) =&gt; `${item.id}`}<br/>   renderItem={({ item }) =&gt; (<br/>     &lt;Image<br/>       source={item.source}<br/>       resizeMode="contain"<br/>       style={{ width, height: height / 2, overflow: 'visible' }}<br/>     /&gt;<br/>   )}<br/>   onScroll={<br/>     Animated.event([{<br/>       nativeEvent: { contentOffset: { x: this.scrollX } }<br/>     }])<br/>   }<br/> /&gt;</span></pre><p id="c0e5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，我们使用了<code class="du ld le lf lg b">Animated</code>组件的<code class="du ld le lf lg b">event</code>函数，它将<code class="du ld le lf lg b">nativeEvent</code>作为一个参数。然后，我们根据<code class="du ld le lf lg b">nativeEvent</code>配置中的<code class="du ld le lf lg b">scrollX</code>变量定义了<code class="du ld le lf lg b">contentOffset</code>值。</p><h2 id="c5eb" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated"><strong class="ak">根据滑动图像在定界符点中配置动画</strong></h2><p id="199a" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">这里，我们将为定界符点添加动画，这将取决于<code class="du ld le lf lg b">renderIllustrations()</code>函数的<code class="du ld le lf lg b">FlatList</code>组件的<code class="du ld le lf lg b">onScroll</code>事件。为此，我们需要首先使用<code class="du ld le lf lg b">Animated</code>组件的<code class="du ld le lf lg b">divide</code>函数初始化步进位置。<code class="du ld le lf lg b">divide</code>函数创建一个新的<code class="du ld le lf lg b">Animated</code>值，该值由第一个动画值除以第二个动画值组成。下面的代码片段显示了它的用法:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="c1fe" class="kc kd hh lg b fi lp lq l lr ls">const stepPosition = Animated.divide(this.scrollX, width);</span></pre><p id="4522" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们将在<code class="du ld le lf lg b">renderSteps()</code>函数中进行一些配置，以便为定界符点添加动画属性。为此，我们需要在<code class="du ld le lf lg b">renderSteps()</code>函数中使用下面代码片段中的代码:</p><pre class="lh li lj lk fd ll lg lm ln aw lo bi"><span id="4509" class="kc kd hh lg b fi lp lq l lr ls">&lt;Block row center middle style={styles.stepsContainer}&gt;<br/>   {illustrations.map((item, index) =&gt; {<br/>     const opacity = stepPosition.interpolate({<br/>       inputRange: [index - 1, index, index + 1],<br/>       outputRange: [0.4, 1, 0.4],<br/>       extrapolate: 'clamp',<br/>     });<br/><br/>     return (<br/>       &lt;Block<br/>         animated<br/>         flex={false}<br/>         key={`step-${index}`}<br/>         color="gray"<br/>         style={[styles.steps, { opacity }]}<br/>       /&gt;<br/>     )<br/>   })}<br/> &lt;/Block&gt;</span></pre><p id="8e97" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，我们定义了一个名为<code class="du ld le lf lg b">opacity</code>的常量，它被初始化为<code class="du ld le lf lg b">stepPosition</code>常量<code class="du ld le lf lg b">initlized</code>到<code class="du ld le lf lg b">Animated.divide</code>的<code class="du ld le lf lg b">interpolate()</code>函数。<code class="du ld le lf lg b">interpolate()</code>函数以<code class="du ld le lf lg b">inputRange</code>、<code class="du ld le lf lg b">outputRange</code>和<code class="du ld le lf lg b">extrapolate</code>为参数值。<code class="du ld le lf lg b">interpolate()</code>功能允许输入范围映射到不同的输出范围。然后，我们将<code class="du ld le lf lg b">opacity</code>常量添加到<code class="du ld le lf lg b">Block</code>组件的样式属性中。</p><p id="de42" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，我们将在模拟器屏幕中获得以下结果:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es lt"><img src="../Images/7064d67e96ce87234f47b3d377443fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*4XccdTNfviW_EGq9.gif"/></div></figure><p id="4e93" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们所看到的，当滑动插图部分的图像时，我们在步骤部分的分隔符点中获得了活动样式动画。最重要的是，动画看起来非常流畅和吸引人。至此，我们已经结束了这部分的教程。</p><p id="2ce0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，我们在Plant应用程序UI的欢迎屏幕中成功实现了带有图像滑块的插图部分和带有动画分隔符点的步骤部分。</p><h2 id="4e58" class="kc kd hh bd ke kf kg kh ki kj kk kl km ja kn ko kp je kq kr ks ji kt ku kv kw bi translated"><strong class="ak">结论</strong></h2><p id="365f" class="pw-post-body-paragraph ip iq hh ir b is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji lb jk jl jm ha bi translated">本教程是React Native Plant App UI教程系列的第四部分。在这一部分中，我们从本系列教程的第三部分中停止的地方继续。在教程的这一部分，我们得到了如何使用<code class="du ld le lf lg b">FlatList</code>组件将图像滑块添加到插图部分的逐步指导。我们还学习了如何向步骤部分的分隔符点添加漂亮的活动样式动画。因此，我们根据插图部分中图像的滑动制作了测光点的活动动画。</p><p id="540b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本系列教程的下一部分中，我们将使用欢迎屏幕上的模态视图来实现服务条款部分。</p></div></div>    
</body>
</html>