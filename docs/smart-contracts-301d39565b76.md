# 什么是智能合约？—初学者指南

> 原文：<https://medium.com/edureka/smart-contracts-301d39565b76?source=collection_archive---------2----------------------->

![](img/f9b61d531f76fbec6bcaae72d8e4c4d5.png)

What are smart contracts — Edureka

*“智能合约”*的短语和概念是由 ***尼克·萨伯*** *提出的*，其愿景是将电子交易方法(如 POS(销售点)的功能扩展到数字领域。智能合约帮助你以透明、无冲突的方式交换财产、股份或任何有价值的东西，同时避免了中间人的服务。**

![](img/b488d7d1fb86129c2652d80a5c7f8763.png)

以下是我们将在这个智能合同博客中涉及的主题:

1.  什么是智能合约？
2.  Nick Szabo 的智能合同
3.  为什么我们需要智能合同？
4.  智能合同:根据用例的复杂性
5.  智能合同用例:医疗保健行业
6.  智能合同优势
7.  用于撰写智能合同的区块链平台
8.  编写和部署智能合同的工具
9.  编写以太坊的编程语言
10.  财产转让智能合同

# 什么是智能合约？

智能合约是一种自我操作的计算机程序，在满足特定条件时自动执行。

![](img/04112106a65abd2f7368ca2f4e3da1c7.png)

***智能合约=不可信合约***

有了智能合约，你可以在陌生人之间以无冲突透明的方式分享任何有价值的东西。

你也可以把智能合约想象成一个基于区块链的自动售货机。就像自动售货机被配置为接收美元来分发您选择的商品一样，智能合同使用*乙醚*作为燃料来根据预先配置的规则执行代码。

## Nick Szabo 的智能合同

![](img/9530c23af1f36c69eef50a44c5b17925.png)

在他的论文中，Szabo 建议执行一个合成资产的合同，比如衍生品和债券。“这些新证券是通过多种方式将证券(如债券)和衍生品(期权和期货)结合在一起形成的。由于对这些复杂的期限结构进行了计算机化分析，非常复杂的支付期限结构现在可以纳入标准化的合同，并以低交易成本进行交易，”他写道。

# 为什么我们需要智能合同？

我们可以通过在区块链上写一个合同来自动化许多解决方案，让事情变得简单高效。让我们比较和评估智能合同如何优于传统合同。

![](img/c92085b8eca5a61414c3bf7a6bc78f66.png)

# 智能合同:根据用例的复杂性

契约的复杂性取决于你想在区块链上编码的用例。下图将让您更清楚地了解智能合约的复杂性。

![](img/a399eb479f30a293ddc75911d83151eb.png)

有了情境化的智能合约，不仅公司将实现自动化，还可以形成一个去中心化的自治政府。

让我们借助用例来理解智能合同是如何工作的。

# 智能合同用例:医疗保健行业

**患者数据管理:**谈到患者数据管理，医疗保健行业有两个主要问题*:*

*   ***首先**，每位患者都是独一无二的，因此，为了适应治疗并提供个性化护理，访问完整的医疗记录至关重要*
*   ***其次**，在医疗界共享信息是一项重大挑战*

*现在，使用区块链上的智能合约功能可以解决上述问题。*

*![](img/fe07022ffaa12714dc88b33066fc25ad.png)*

# *智能合同优势*

*智能合约给你带来了以下好处:*

*![](img/7bfe2e7ec2680bfb909109a4ad7baca3.png)*

# *用于撰写智能合同的区块链平台*

*虽然 ***以太坊*** 是最受欢迎的合同写作平台，但它不是唯一的。以下是用于编写智能合同的一些其他平台:*

***比特币:**比特币在处理文档时使用功能有限的脚本。这些脚本是专门为处理比特币交易而设计的。*

***Hyperledger Fabric:** 在 Fabric 中，Chaincode 是部署在网络上的程序代码，在共识过程中，它由链验证器一起执行和验证。*

***NXT:** 这是一个公共的区块链平台，包含智能合约模板的有限选择。你必须使用给定的东西，你不能自己写代码。*

***侧链:**侧链增强了区块链性能和隐私保护。他们还增加了智能合同、安全句柄和真实世界的财产登记等功能。*

## *编写和部署智能合同的工具*

1.  ***Mist 浏览器** —是一款浏览和使用 dApps 的工具。它是一个独立的浏览器，可以用来浏览 dApps 并与之交互。*
2.  ***松露框架** —松露是以太坊流行的开发框架。它具有内置的智能契约编译、链接、部署和二进制管理。*
3.  ***元掩码** —元掩码是一座桥梁，让人们可以在今天的浏览器中访问未来的分布式网络。它允许用户在浏览器中运行以太坊 dApps，而无需运行完整的以太坊节点。*
4.  *Remix 是一个基于 web 浏览器的 IDE，允许用户编写 Solidity 智能合同，然后部署和运行智能合同。*

# *用于编写以太坊智能合约的编程语言*

*Solidity*&Serpent*是编写以太坊智能合约的两种主要语言。*

***可靠性:**它是一种面向契约的高级语言，语法类似于 JavaScript，设计目标是以太坊虚拟机(EVM)。*

***Serpent:** Serpent 是一种为编写以太坊契约而设计的高级语言。它与 Python 非常相似，但截至 2017 年 9 月，Solidity 是以太坊开发者的首选开发语言。*

*虽然 Solidity 是目前最流行的智能合同语言，但有一些即将出现的智能合同语言在未来会变得很重要。*

## ***即将出现的编程语言***

1.  ***Viper:** Viper 有一个类似 Python 的缩进模式。它关注安全性、语言和编译器的简单性。*
2.  ***Lisk:** Lisk 使用 javascript 作为智能契约语言，这使得开发者编写应用程序更加容易。*
3.  ***Chain:** Chain 以 Ruby、Java、NodeJS 等流行语言提供 SDK 的企业级区块链基础设施。*

*现在，由于 Solidity 是用于编写以太坊智能合约的最广泛使用的编程语言，所以让我带您看一个用 Solidity 编写的合约。*

# *财产转让智能合同*

## ***问题:***

*目前，我们使用中央权力机构来转移财产所有权。这不仅耗时，还会带来大量额外费用，并增加文档管理的负担。此外，由于系统是集中的，因此始终存在欺诈的可能性。*

*![](img/67a23152d1eee35c8224a6d6f83ab27d.png)*

## ***解决方案:***

*该计划旨在利用这项技术让所有各方——银行、经纪人、政府官员、买家和卖家——都能看到房地产交易的细节。*

*好吧，让我给你写一份聪明的合同:*

```
*pragma solidity ^0.4.11;

// We're making this use case for mimicking the real world property transfer
// Pre-requisite of this use case is that:
// A digital identity is in-place
// Govt agrees to put the land records on the public blockchain
// Each Development Authority (DA) becomes the defacto owner of the property that exist under their constituency/legislative body
// When all the above conditions are met, then DA(owner) can easily attach the respective property to their rightful owner after thorough verification.
// we shall be formulating the function around this set assumption.
// we're assuming that each DA shall deploy their own smart contract as per their rule and regulation. This whole smart contract is written by considering DA as the owner, who can allot property.
// A govt can become a layer on top of these DA. and the Govt can decide, which DA(address) becomes the owner of which contituency.
// We can extend this easily. But after going through this smart contract, you shall be able to figure out, how the things might work.
contract PropertyTransfer {

address public DA; // DA shall be the owner, we shall be initializing this variable's value by the address of the user who's going to deploy it. e.g. let's say DA itself.

     uint256 public totalNoOfProperty; // total no of properties under a DA at any point of time. they should increase as per the allotment to their respective owner after verification.
 // Below is the constructor whose code is run only when the contract is created. 
function PropertyTransfer() {
   DA = msg.sender; // setting the owner of the contract as DA.
}// modifier to check the tx is coming from the DA(owner) or not
modifier onlyOwner(){
   require(msg.sender == DA);
   _;}
// This structure is kept like this for storing a lot more information than just the name
struct Property{
   string name;  //keeping the map of the property against each address. we shall provide name to the property
   bool isSold;   // we're keeping the count as well for each address
} 
mapping(address => mapping(uint256=>Property)) public propertiesOwner; // we shall have the properties mapped against each address by its name and it's individual count.
mapping(address => uint256) individualCountOfPropertyPerOwner; // how many property does a particular person hold
event PropertyAlloted(address indexed _verifiedOwner, uint256 indexed _totalNoOfPropertyCurrently, string _nameOfProperty, string _msg);
event PropertyTransferred(address indexed _from, address indexed _to, string _propertyName, string _msg);
// this shall give us the exact property count which any address own at any point of time
function getPropertyCountOfAnyAddress(address _ownerAddress) constant returns (uint256){
   uint count=0;
for(uint i =0; i<individualCountOfPropertyPerOwner[_ownerAddress];i++){
   if(propertiesOwner[_ownerAddress][i].isSold != true)
   count++;
    }
   return count;
}
// this function shall be called by DA only after verification
function allotProperty(address _verifiedOwner, string _propertyName)
onlyOwner
{
   propertiesOwner[_verifiedOwner][individualCountOfPropertyPerOwner[_verifiedOwner]++].name = _propertyName;
   totalNoOfProperty++;
   PropertyAlloted(_verifiedOwner,individualCountOfPropertyPerOwner[_verifiedOwner], _propertyName, "property allotted successfully");
}
// check whether the owner have the said property or not. if yes, return the index
function isOwner(address _checkOwnerAddress, string _propertyName) constant returns (uint){
   uint i ;
   bool flag ;
for(i=0 ; i<individualCountOfPropertyPerOwner[_checkOwnerAddress]; i++){
if(propertiesOwner[_checkOwnerAddress][i].isSold == true){
   break;
}
flag = stringsEqual(propertiesOwner[_checkOwnerAddress][i].name,_propertyName);
if(flag == true){
   break;
   }
}
if(flag == true){
   return i;
}
else {
   return 999999999; // We're expecting that no individual shall be owning this much properties
}}
// functionality to check the equality of two strings in Solidity
function stringsEqual (string a1, string a2) constant returns (bool){
return sha3(a1) == sha3(a2)? true:false;
}
// transfer the property to the new owner
// todo : change from to msg.sender
function transferProperty (address _to, string _propertyName)
returns (bool , uint )
{
uint256 checkOwner = isOwner(msg.sender, _propertyName);
bool flag;

if(checkOwner != 999999999 && propertiesOwner[msg.sender][checkOwner].isSold == false){
     // step 1 . remove the property from the current owner and decrase the counter.
     // step 2 . assign the property to the new owner and increase the counter
   propertiesOwner[msg.sender][checkOwner].isSold = true;
   propertiesOwner[msg.sender][checkOwner].name = "Sold";// really nice finding. we can't put empty string
   propertiesOwner[_to][individualCountOfPropertyPerOwner[_to]++].name = _propertyName;
   flag = true;
   PropertyTransferred(msg.sender , _to, _propertyName, "Owner has been changed." );
}
else {
   flag = false;
   PropertyTransferred(msg.sender , _to, _propertyName, "Owner doesn't own the property." );}
return (flag, checkOwner);
}}*
```

*所以，你刚刚编写了一个在分散网络上转移财产的方法。多酷啊！！*

*你可以看到[智能合同]改变社会方方面面的潜力是巨大的。*

*至此，我结束了这篇*智能合同*博客。我希望你喜欢阅读这个博客，并发现它的信息量。如果你想查看更多关于人工智能、DevOps、道德黑客等市场最热门技术的文章，你可以参考 Edureka 的官方网站。*

*请留意本系列中的其他文章，它们将解释区块链的其他各个方面。*

> *1.[区块链教程](/edureka/blockchain-tutorial-d05f9c36b62b)*
> 
> *2.[以太坊教程](/edureka/ethereum-tutorial-with-smart-contracts-db7f80175646)*
> 
> *3.[以太坊专用网络](/edureka/ethereum-private-network-tutorial-22ef4119e4c3)*
> 
> *4.[坚固性教程](/edureka/solidity-tutorial-ca49906bdd47)*
> 
> *5.[松露以太坊教程](/edureka/developing-ethereum-dapps-with-truffle-7533289c8b2)*
> 
> *6.[最好的以太坊开发工具](/edureka/ethereum-development-tools-7175503a1ac7)*
> 
> *7.[超帐织物](/edureka/hyperledger-fabric-184667460-edc184667460)*
> 
> *8. [Hyperledge vs 以太坊](/edureka/hyperledger-vs-ethereum-bdc868e10817)*

**原载于 2018 年 4 月 3 日*[*【www.edureka.co*](https://www.edureka.co/blog/smart-contracts/)*。**