<html>
<head>
<title>3 Different Kinds of Prototypal Inheritance: ES6+ Edition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3种不同的原型继承:ES6+版本</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/3-different-kinds-of-prototypal-inheritance-es6-edition-32d777fa16c9?source=collection_archive---------0-----------------------#2016-05-30">https://medium.com/javascript-scene/3-different-kinds-of-prototypal-inheritance-es6-edition-32d777fa16c9?source=collection_archive---------0-----------------------#2016-05-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/396a11a11f4f32931f86c220e46c5275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zD09LrXaCbW1MIsq2hzVIg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Triplets — Phil Dolby (CC-BY-2.0)</figcaption></figure><p id="b3eb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">本文改编自【JavaScript应用程序编程”，针对ES6进行了扩展和更新。</p><p id="6d72" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为了声称精通JavaScript，理解JavaScript的本地继承能力是如何工作的很重要。这是JavaScript编写和学习中经常被忽视的领域，但是理解它可以极大地增强能力。</p><p id="23cb" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">JavaScript是有史以来最具表现力的编程语言之一。它最好的特性之一是无需类和类继承就能创建和继承对象<em class="js">。</em></p><p id="0a9a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">它的委托原型、运行时对象扩展和闭包的组合允许您在JavaScript中表达三种不同的原型，这提供了超越类继承的显著优势。</p><p id="8504" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">更多关于类继承的缺点，请看“经典继承过时了:如何在原型OO中思考”:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="jx jy l"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Recorded at the O’Reilly Fluent conference, 2013</figcaption></figure><h1 id="a561" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">委托/差异继承</h1><p id="530e" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">委托原型是作为另一个对象的基础的对象。当从委托原型继承时，新对象会获得对原型的引用。</p><p id="7272" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">当您尝试访问新对象的属性时，它会首先检查对象自己的属性。如果它没有在那里找到它，它检查<em class="js">`[[原型]]` </em>，等等，沿着<strong class="iv hi">原型链</strong>向上，直到它回到<em class="js"> `Object.prototype` </em>，它是大多数对象的根委托。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/b3ed72f61c9c2533043aa0278dc16868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wgVmoipm1IhKMDluvwuW4Q.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">The Prototype Chain</figcaption></figure><p id="b68d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">方法委托可以节省内存资源，因为所有实例只需要共享每个方法的一个副本。有几种方法可以在JavaScript中建立这种关系。您可能在ES6中看到的是这样的:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ld jy l"/></div></figure><p id="e223" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">由于与类继承相关的许多问题，以及扩展类的诱惑，我不推荐这种技术。我在这里提出它只是因为它可能是一个熟悉的参考点。</p><p id="3292" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您可能也熟悉ES5构造函数版本:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ld jy l"/></div></figure><p id="40f3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我更喜欢使用<em class="js"> `Object.create()`的<strong class="iv hi">工厂函数</strong>。</em>(在JavaScript中，<em class="js">任何函数</em>都可以创建新对象。当它不是构造函数时，它被称为<em class="js">工厂函数)</em>:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ld jy l"/></div></figure><p id="f469" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">通过使用<em class="js"> `Object.create(null)`将原型设置为<em class="js"> `null` </em>,可以避免属性委托。</em></p><p id="7800" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">委托的一个主要缺点是它不太适合存储状态。如果您试图将状态存储为对象或数组，则变更对象或数组的任何成员都会变更共享原型的每个实例的成员。为了保护实例安全，您需要为每个对象制作一份状态副本。</p><h1 id="f6ed" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">串联继承/克隆/混合</h1><p id="2f3d" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">串联继承是将属性从一个对象复制到另一个对象的过程，不保留两个对象之间的引用。它依赖于JavaScript的动态对象扩展特性。</p><p id="f267" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">克隆是存储对象默认状态的一个很好的方法:这个过程通常使用<em class="js"> `Object.assign()'来实现。</em>在ES6之前，从Lodash、下划线或jQuery中使用类似的<em class="js"> `.extend()` </em>方法是很常见的。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ld jy l"/></div></figure><p id="ebf7" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这种风格用于混音是很常见的。例如，您可以通过混合<em class="js"> `EventEmitter3` </em>原型将任何对象变成事件发射器:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ld jy l"/></div></figure><p id="eb0b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们可以用它来创建一个主干风格的事件发射模型:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ld jy l"/></div></figure><p id="072b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">串联继承非常强大，但是当您将它与闭包结合使用时，它会变得更好。</p><h1 id="d53f" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">功能继承</h1><p id="7c28" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">不要与函数式编程混淆。</p><p id="c20f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">由道格拉斯·克洛克福特在《JavaScript:精彩部分》中创造。函数继承利用工厂函数，然后使用串联继承添加新的属性。</p><p id="c7a3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为扩展现有对象而创建的函数通常被称为<em class="js">函数混合。使用函数进行扩展的主要优点是，它允许您使用函数闭包来封装私有数据。换句话说，你可以强制私有状态。</em></p><p id="4bb8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">将属性挂在公共属性上有点尴尬，因为用户可以在不调用正确方法的情况下设置或获取它们。我们真正想做的是在私有闭包<em class="js">中隐藏属性(参见:</em> <a class="ae jr" rel="noopener" href="/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36"> <em class="js">“什么是闭包？”</em> </a> <em class="js"> ) </em>。它看起来像这样:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ld jy l"/></div></figure><p id="bdd5" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">通过将<em class="js"> `attrs` </em>从公共属性移动到私有标识符，我们从公共API中移除了它的所有踪迹。现在使用它的唯一方法是通过<strong class="iv hi">特权方法</strong>。特权方法是在闭包的函数范围内定义的任何方法，这使它们能够访问私有数据。</p><p id="ce62" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">注意在上面的例子中，我们用<em class="js"> `mixinModel()` </em>包装了实际的函数mixin，<em class="js"> `rawMixin()` </em>。我们需要这样做的原因是因为我们需要在函数中设置<em class="js"> `this` </em>的值，这是我们用<em class="js"> `Function.prototype.call()`完成的。我们可以跳过包装器，让调用者来做这件事，但是那样会很讨厌。</em></p><h1 id="79a1" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">类继承上的合成</h1><blockquote class="le"><p id="d9b0" class="lf lg hh bd lh li lj lk ll lm ln jq dx translated">"优先选择对象组合而不是类继承。"~四人帮，“ <a class="ae jr" href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;dpID=51szD9HC9pL&amp;dpSrc=sims&amp;preST=_AC_UL160_SR127%2C160_&amp;refRID=1M5H8SBQF96ZHXYV1RQ2&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=530b7fcb4f0e734b7952559730673cae" rel="noopener ugc nofollow" target="_blank">设计模式:可复用面向对象软件的要素</a></p></blockquote><p id="7745" class="pw-post-body-paragraph it iu hh iv b iw lp iy iz ja lq jc jd je lr jg jh ji ls jk jl jm lt jo jp jq ha bi translated">类继承用限制性分类法创建了<strong class="iv hi"> is-a </strong>关系，所有这些最终对新用例来说都是错误的。但事实证明，我们通常为<strong class="iv hi"> has-a </strong>、<strong class="iv hi"> uses-a </strong>或<strong class="iv hi"> can-do </strong>关系使用继承。</p><p id="ec5a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">作曲更像是吉他效果器踏板。想要一个可以做延迟，微妙失真和机器人声音的东西？没问题！把它们都插上电源:</p><pre class="jt ju jv jw fd lu lv lw lx aw ly bi"><span id="9fc9" class="lz ka hh lv b fi ma mb l mc md">const effect = compose(delay, distortion, robovoice); // Rock on!</span></pre><blockquote class="le"><p id="0274" class="lf lg hh bd lh li me mf mg mh mi jq dx translated">什么时候需要使用类继承？对我来说，答案很简单:“永远不会。”</p></blockquote><h2 id="4408" class="lz ka hh bd kb mj mk ml kf mm mn mo kj je mp mq kn ji mr ms kr jm mt mu kv mv bi translated">成分是:</h2><ul class=""><li id="6527" class="mw mx hh iv b iw kx ja ky je my ji mz jm na jq nb nc nd ne bi translated"><strong class="iv hi">更简单</strong></li><li id="d2ac" class="mw mx hh iv b iw nf ja ng je nh ji ni jm nj jq nb nc nd ne bi translated"><strong class="iv hi">更富表现力</strong></li><li id="425a" class="mw mx hh iv b iw nf ja ng je nh ji ni jm nj jq nb nc nd ne bi translated"><strong class="iv hi">更加灵活</strong></li></ul><p id="c0ed" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">更多内容请参见“组合胜于继承”。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="nk jy l"/></div></figure><h1 id="95dc" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">“阶级”呢？</h1><p id="f7c5" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">如你所见，JavaScript提供了一个非常灵活的对象系统，不需要依赖<em class="js"> `class`。那么我们为什么要在第一个地方加上<em class="js"> `class` </em>？因为很多人都熟悉其他语言中的类范式，人们一直试图在JavaScript中模仿它。</em></p><blockquote class="le"><p id="45f7" class="lf lg hh bd lh li lj lk ll lm ln jq dx translated">JavaScript中的继承是如此简单，以至于让那些认为需要努力的人感到困惑。为了使它变得更难，我们加上了“阶级”。</p></blockquote><p id="5baf" class="pw-post-body-paragraph it iu hh iv b iw lp iy iz ja lq jc jd je lr jg jh ji ls jk jl jm lt jo jp jq ha bi translated">几个流行的库使用委托原型链在JavaScript中实现了伪类继承来模拟类继承。添加一个官方的<em class="js"> `class` </em>关键字提供了一种单一的规范方式来模拟JavaScript中的类继承——但是在我看来，<a class="ae jr" rel="noopener" href="/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3">你应该完全避免它</a>。在JavaScript中，组合比类继承更简单、更有表现力、更灵活。我想不出一个好的用例，其中<em class="js"> `class` </em>比本地原型更适合。</p><p id="449a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">几年来，我一直鼓励人们为类继承提出一个令人信服的用例，但我听到的不是好的用例，而是很多常见的误解。</p><h1 id="31eb" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="ecf0" class="pw-post-body-paragraph it iu hh iv b iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm lb jo jp jq ha bi translated">一旦你开始考虑使用原型的无类对象和继承，以及连接，你就会真正体会到JavaScript的对象系统是多么简单、强大和灵活。</p></div><div class="ab cl nl nm go nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ha hb hc hd he"><p id="dbad" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">想了解更多关于原型继承和对象组合的知识吗？</p><h1 id="294a" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated"><a class="ae jr" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank">跟随Eric Elliott学习JavaScript】</a></h1></div><div class="ab cl nl nm go nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ha hb hc hd he"><p id="4b12" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi"> <em class="js">埃里克艾略特</em> </strong> <em class="js">著有</em> <a class="ae jr" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="js">【编程JavaScript应用】</em> </a> <em class="js">(奥赖利)，以及</em> <a class="ae jr" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank"> <em class="js">【跟埃里克艾略特学JavaScript】</em></a><em class="js">。他曾为</em><strong class="iv hi"><em class="js">Adobe Systems</em></strong><em class="js"/><strong class="iv hi"><em class="js">Zumba Fitness</em></strong><em class="js"/><strong class="iv hi"><em class="js">【华尔街日报】</em></strong><em class="js"/><strong class="iv hi"><em class="js">BBC</em></strong><em class="js">等顶级录音师</em></p><p id="61a2" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>