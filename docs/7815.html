<html>
<head>
<title>Here’s What Makes Apache Flink scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这就是阿帕奇Flink的规模</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/what-makes-apache-flink-scale-317f642fe6d5?source=collection_archive---------1-----------------------#2019-10-02">https://medium.com/walmartglobaltech/what-makes-apache-flink-scale-317f642fe6d5?source=collection_archive---------1-----------------------#2019-10-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="7420" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">内存管理和网络流量控制一瞥</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/9c54dd5b039156a57962a8559b801829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wN5t9ILU0fpnhbMX2vtng.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Time-Lapse Photography of Blue Lights by <a class="ae jm" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="224b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Apache Flink是一个流行的实时数据处理框架。由于它以容错方式以极高的吞吐量进行低延迟处理，所以它越来越受欢迎。</p><p id="8c6b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在过去的三年里，我一直在生产中使用Apache Flink，每次它都能出色地完成任何工作负载。我运行过Flink作业，在不超过20个内核的情况下以超过1000万RPM的速度处理数据流。不仅仅是我。你可以看到所有其他公司的基准。</p><p id="b2a3" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">你可以在这里找到官方的基准。</p><div class="kj kk ez fb kl km"><a href="https://data-artisans.com/blog/curious-case-broken-benchmark-revisiting-apache-flink-vs-databricks-runtime" rel="noopener  ugc nofollow" target="_blank"><div class="kn ab dw"><div class="ko ab kp cl cj kq"><h2 class="bd hi fi z dy kr ea eb ks ed ef hg bi translated">打破基准的奇怪案例:重温Apache Flink与Databricks运行时-数据…</h2><div class="kt l"><h3 class="bd b fi z dy kr ea eb ks ed ef dx translated">阿尔约沙·克雷泰克和迈克尔·温特斯；在过去的几个月里，Databricks一直在推广Apache Spark与…</h3></div><div class="ku l"><p class="bd b fp z dy kr ea eb ks ed ef dx translated">data-artisans.com</p></div></div><div class="kv l"><div class="kw l kx ky kz kv la jg km"/></div></div></a></div><p id="83d2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">因此，我们自然会想到这样一个问题:Flink是如何有效地进行扩展的？<br/>这里有一些巧妙的技巧。</p><h1 id="79ec" class="lb lc hh bd ld le lf lg lh li lj lk ll in lm io ln iq lo ir lp it lq iu lr ls bi translated">减少垃圾收集</h1><p id="d7eb" class="pw-post-body-paragraph jn jo hh jp b jq lt ii js jt lu il jv jw lv jy jz ka lw kc kd ke lx kg kh ki ha bi translated">当您在Java中操作大量数据时，垃圾收集会很快成为瓶颈。完整的GC会使JVM停滞几秒钟，在某些情况下甚至几分钟。</p><p id="c84d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Flink通过管理内存本身来解决这个问题。Flink保留一部分堆内存(通常在70%左右)作为托管内存。托管内存由相同大小的内存段填充(默认为32KB)。这些内存段类似于<em class="ly"> java.nio.ByteBuffer </em>，只包含字节数组。</p><p id="01f1" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">每当一个操作者想要使用内存时，它就向内存管理器请求段，一旦完成，就将它们返回到内存池。由于这些内存段的寿命很长，可以持续重用，所以它们驻留在老一代堆中，不需要经历许多GC周期。</p><p id="01d3" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Flink还提供了将内存段放入堆外内存的功能，以提高网络和文件系统的I/O速度，尤其是对于有状态操作符。</p><p id="b1a7" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">托管内存的另一个优点是Flink可以将较大的段降级到磁盘，并在以后读回它们。这种溢出有助于防止内存不足错误。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lz"><img src="../Images/54e86943f264d24c93c84d93248e6a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9kLZafvpdQ_iqV2FW9oaA.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">A high-level overview of how Flink stores data serialized in memory segments (From <a class="ae jm" href="https://flink.apache.org/news/2015/05/11/Juggling-with-Bits-and-Bytes.html" rel="noopener ugc nofollow" target="_blank">Juggling with Bits and Bytes by Apache Flink</a>)</figcaption></figure><p id="8d17" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><strong class="jp hi">注意</strong>:在现代JVM (Java 8+)中，有了新的G1 GC，堆空间几乎和堆外一样有效。堆外空间可能有很大的安装和拆卸成本，但如果有更好的序列化，它比堆快。</p><h1 id="ceb7" class="lb lc hh bd ld le lf lg lh li lj lk ll in lm io ln iq lo ir lp it lq iu lr ls bi translated">最小化数据传输</h1><p id="762c" class="pw-post-body-paragraph jn jo hh jp b jq lt ii js jt lu il jv jw lv jy jz ka lw kc kd ke lx kg kh ki ha bi translated">在分布式数据处理系统中，映射或过滤任务可以在一个节点上运行，而在另一个节点上减少任务。这要求数据在网络上跨节点共享。</p><p id="5392" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在，假设您需要对一个数据流执行多个映射和过滤操作。没有必要在单独的任务上运行这些操作。这是因为除了前一个操作符之外，这些操作符都不需要任何其他操作符的输入。</p><p id="bd3e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Apache Flink执行前面提到的优化，其中几个映射和过滤器转换在一个槽中连续完成。这种链接最小化了插槽和多个JVM进程之间的数据共享。因此，作业具有较低的网络I/O、数据传输延迟以及对象之间的最小同步。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ma"><img src="../Images/733ee5b8632cd82c4a8e210294b44d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*3tN3FGq2DEydRENE_0zLpQ.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx">Operator chaining in a simple Flink job. The small rectangle inside the JVM represents each slot.</figcaption></figure><h1 id="90c5" class="lb lc hh bd ld le lf lg lh li lj lk ll in lm io ln iq lo ir lp it lq iu lr ls bi translated">挤压你的字节</h1><p id="7df3" class="pw-post-body-paragraph jn jo hh jp b jq lt ii js jt lu il jv jw lv jy jz ka lw kc kd ke lx kg kh ki ha bi translated">这样的Java对象相当重，例如，一个简单的整数对象占用24个字节来存储一个4字节的数据。为了避免存储如此沉重的对象，Flink实现了它的序列化算法，这种算法更加节省空间。</p><p id="479a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">但是，为什么不使用Kryo(目前在spark中使用)、Avro或协议缓冲区等其他序列化框架呢？</p><p id="5905" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">实现它的二进制表示允许Flink将相关的对象和相关的键、散列存储在一起。例如，字符串数组的索引键可以彼此相邻地存储。高速缓存在单个指令中提取一组连续的字节，并预取接下来的几个字节。缓存可以加快相邻存储的对象的访问速度。</p><p id="3d0e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">使用自定义二进制表示的另一个优点是可以直接对二进制数据进行操作，从而减少序列化/反序列化的开销。例如，Flink会立即对序列化对象进行比较。这提供了执行排序等操作的能力，甚至不需要反序列化数据。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mb"><img src="../Images/a1011e07f59e1353149f39ce7e58a066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cPjhpjp6LIDS8IA51fninQ.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Benchmark for different serialized formats in Flink (Taken from <a class="ae jm" href="https://flink.apache.org/news/2015/05/11/Juggling-with-Bits-and-Bytes.html" rel="noopener ugc nofollow" target="_blank">https://flink.apache.org/news/2015/05/11/Juggling-with-Bits-and-Bytes.html</a>)</figcaption></figure><h1 id="1cc8" class="lb lc hh bd ld le lf lg lh li lj lk ll in lm io ln iq lo ir lp it lq iu lr ls bi translated">避免阻止所有人</h1><p id="8a63" class="pw-post-body-paragraph jn jo hh jp b jq lt ii js jt lu il jv jw lv jy jz ka lw kc kd ke lx kg kh ki ha bi translated">在Flink 1.4之后，Flink改进了它的网络通信。这项新政策被称为基于信用的流量控制。</p><p id="57b1" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">每个任务管理器中运行多个插槽，每个插槽都可以运行一个子任务。然而，由于这个原因，多个任务管理器之间的网络连接需要被多路复用，即，连接需要处理来自所有子任务的数据。</p><p id="8e1d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">多路复用带来了一种折衷。每当接收子任务由于网络缓冲区已满而阻塞时，整个TCP连接都会受到反压力。这不是最佳的，因为可能有其他接收子任务具有空缓冲区，但是现在，由于反压力，它们不得不处于空闲状态。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mc"><img src="../Images/b0cbef17c74cd0020cef4e8c258a01bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPevKRdoVqKdbuIStO0TLA.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Normal Flow without credit announcements from <a class="ae jm" href="https://flink.apache.org/2019/06/05/flink-network-stack.html" rel="noopener ugc nofollow" target="_blank">A Deep-Dive into Flink’s Network Stack</a></figcaption></figure><p id="db27" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Flink通过引入信用公告解决了这个问题。接收者子任务向发送者子任务宣布他们还有多少缓冲区。当发送方意识到接收方没有剩余的缓冲区时，它就会停止向接收方发送数据。这有助于防止阻塞子任务的字节阻塞TCP通道。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es md"><img src="../Images/46422ba037b2a5974e2dbea510fb0a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bu8SNZVUO9PVA3Ubucmb4g.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Credit-based flow control from <a class="ae jm" href="https://flink.apache.org/2019/06/05/flink-network-stack.html" rel="noopener ugc nofollow" target="_blank">A Deep-Dive into Flink’s Network Stack</a></figcaption></figure><p id="5957" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">下面是一个更简单的表示法—</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es me"><img src="../Images/b27974958d30f002a5f7e6f13a35416d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aNugqfl778TJS57DncVogQ.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Without Credit-Based Flow</figcaption></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es me"><img src="../Images/cadcbbde64373ab981a3f2ea9738cb05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhGiQisr-t_mkTPUkTwxtg.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">With Credit-Based Flow</figcaption></figure><p id="5f01" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Apache Flink是当今最强大的实时数据处理系统。<br/>然而，与其他数据流系统相比，它仍然是新的，并且有某些缺点-</p><ol class=""><li id="11c5" class="mf mg hh jp b jq jr jt ju jw mh ka mi ke mj ki mk ml mm mn bi translated">无法在运行时扩展应用程序。</li><li id="d8ed" class="mf mg hh jp b jq mo jt mp jw mq ka mr ke ms ki mk ml mm mn bi translated">无法在运行时添加新的运算符。</li><li id="cbfb" class="mf mg hh jp b jq mo jt mp jw mq ka mr ke ms ki mk ml mm mn bi translated">Flink ML没有Spark MLLib成熟。</li></ol><p id="b294" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">要阅读更多关于这个话题的内容，你可以参考以下文章—</p><ul class=""><li id="6041" class="mf mg hh jp b jq jr jt ju jw mh ka mi ke mj ki mt ml mm mn bi translated"><a class="ae jm" href="https://flink.apache.org/news/2015/05/11/Juggling-with-Bits-and-Bytes.html" rel="noopener ugc nofollow" target="_blank">玩弄比特和字节</a></li><li id="ad04" class="mf mg hh jp b jq mo jt mp jw mq ka mr ke ms ki mt ml mm mn bi translated"><a class="ae jm" href="https://ci.apache.org/projects/flink/flink-docs-release-1.1/concepts/concepts.html#tasks--operator-chains" rel="noopener ugc nofollow" target="_blank">阿帕奇弗林克概念</a></li><li id="7996" class="mf mg hh jp b jq mo jt mp jw mq ka mr ke ms ki mt ml mm mn bi translated"><a class="ae jm" href="https://flink.apache.org/2019/06/05/flink-network-stack.html" rel="noopener ugc nofollow" target="_blank">深入了解Flink的网络堆栈</a></li><li id="53a6" class="mf mg hh jp b jq mo jt mp jw mq ka mr ke ms ki mt ml mm mn bi translated"><a class="ae jm" href="https://hackernoon.com/what-makes-apache-flink-the-best-choice-for-streaming-applications-fc377858a53" rel="noopener ugc nofollow" target="_blank">是什么让Apache Flink成为流媒体应用的最佳选择？</a></li></ul></div></div>    
</body>
</html>