<html>
<head>
<title>A Comprehensive Guide To Angular 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular 4综合指南</h1>
<blockquote>原文：<a href="https://medium.com/edureka/angular-tutorial-for-beginners-4738ce387b03?source=collection_archive---------0-----------------------#2017-05-30">https://medium.com/edureka/angular-tutorial-for-beginners-4738ce387b03?source=collection_archive---------0-----------------------#2017-05-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/a4210cea51b9a66797f34d5ecb0431ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*hlJ7jAMeHYgflPKIw2kRkA.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx">Angular Tutorial — Edureka</figcaption></figure><p id="e4ce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在阅读这篇有角度的教程文章之前，我想提醒您一点。你一定经历过许多反应灵敏、动态的网络和移动应用程序。它不会重新加载整个页面，而是只重新加载所需的部分。例如<em class="jn"> Gmail </em>，你可能已经注意到，当你点击一封电子邮件时，它只会在正文部分重新加载该邮件，而不会检索页面的其他部分，如侧边和导航栏。这类应用程序是SPA(单页应用程序),是使用Angular开发的。一些最受欢迎的例子是网飞，贝宝，自由职业者等。</p><p id="7f16" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本文中，我们将讨论Angular的演变，然后继续，我们将了解Angular的构建模块。我们将讨论Angular，而不是Angular 2或Angular 4，因为从Angular 2开始，Angular社区已经决定将Angular的任何版本都称为<strong class="ir hi"><em class="jn"/></strong>。在这篇有角度的教程文章中，我们将涵盖:</p><ul class=""><li id="7e66" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">角度的演变</li><li id="1553" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">AngularJS和Angular的区别</li><li id="39ce" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">角度特征</li><li id="fd36" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">棱角分明的建筑材料</li><li id="45b9" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">模块</li><li id="23ca" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">成分</li><li id="9d0a" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">模板</li><li id="f670" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">[计]元数据</li><li id="ed87" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">数据绑定</li><li id="d319" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">指令</li><li id="6551" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">服务</li><li id="c02c" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">依赖注入</li></ul><p id="76bf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们向前看，并试图了解角的演变。</p><h1 id="1a76" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">角度的演变</h1><p id="004a" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">Angular是一个基于JavaScript的开源框架，用于构建客户端web应用程序。所以，让我们先来了解一下Javascript。JavaScript运行在web的客户端，可用于设计或编程网页在事件发生时的行为。通常，JavaScript用于界面交互、幻灯片和其他交互组件。JavaScript发展很快，也已经用于服务器端编程(如Node.js)、游戏开发等。</p><p id="f029" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">JavaScript处理动态内容，这是web开发的一个重要方面。动态内容是指不断变化的内容，它适应特定的用户。例如，JavaScript可用于通过检查正在访问网站的设备来确定是否呈现网站的移动版本。</p><p id="fb4f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这鼓励了web开发人员开始创建他们自己的定制JavaScript库，以减少代码行的数量并轻松实现复杂的功能。jQuery 是一个快速、小巧、功能丰富的JavaScript库，它通过一个易于使用的API使HTML文档遍历和操作、事件处理、动画和Ajax变得更加简单。jQuery成为最受欢迎的一个，因为它易于使用并且非常强大。</p><p id="485f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于jQuery没有真正的结构，开发人员可以完全自由地构建他们认为合适的项目。然而，缺乏结构也意味着更容易陷入“意大利面条式代码”的陷阱，这可能会在没有明确设计方向或代码可维护性的大型项目中导致混乱。对于这些情况，像Angular这样的框架会有很大的帮助。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lf"><img src="../Images/c8e22fdc262504dd86a196006d6ca24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JegB0KrkM6SEzXmBYEhjpw.png"/></div></div></figure><p id="beb3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Angular是一个客户端JavaScript框架，专门用于帮助开发人员根据web开发的最佳实践构建SPAs(单页应用程序)。通过为构建spa提供结构化的环境，产生“意大利面条式代码”的风险大大降低了。所以，你一定想知道什么是SPA？</p><p id="9638" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">单页应用</em> </strong>(或<strong class="ir hi"> <em class="jn"> SPA </em> </strong>)是通过网络浏览器访问的应用，像其他网站一样，但提供更动态的交互，类似于本地移动和桌面应用。普通网站和SPA最显著的区别是减少了页面刷新次数。SPAs大量使用AJAX——这是一种与后端服务器通信的方式，无需刷新整个页面就可以将数据加载到我们的应用程序中。因此，呈现页面的过程大部分发生在客户端。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lo"><img src="../Images/c27a1b5f742cebc2488d95c3a67faa24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84RAqDkd9Ob2ptZUSUUXZQ.png"/></div></div></figure><p id="6628" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，如果你浏览Gmail，你会注意到当从收件箱打开邮件时，只会获取电子邮件并显示在电子邮件列表中。其余的组件，如侧边栏，导航栏等。不会重新加载。它只刷新所需部分的DOM(文档对象模型)。所以，这减少了网站的开销。</p><p id="9c8e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们知道了什么是Javascript &amp; JQuery，以及angular是如何出现的。在本文中，我们将浏览angular的特性，并理解如何使用Angular。</p><h1 id="7bad" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">角度教程</h1><p id="739f" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">Angular是一个基于打字稿的开源前端web应用程序平台，由Google的Angular团队和一个由个人和公司组成的社区领导。Angular是由构建AngularJS的同一个团队完全重写的。但是我告诉你，Angular和AngularJS是完全不同的。让我们理解角形和棱形的区别。</p><h1 id="efdf" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">有角的和有角的区别</h1><ul class=""><li id="d64d" class="jo jp hh ir b is la iw lb ja lp je lq ji lr jm jt ju jv jw bi translated">Angular应用程序的架构不同于AngularJS。Angular的主要构建块是模块、组件、模板、元数据、数据绑定、指令、服务和依赖注入。我们一会儿将会看到它。</li><li id="afcb" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">Angular完全改写了AngularJS。</li><li id="60ff" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">Angular没有“范围”或控制器的概念，相反，它使用组件的层次结构作为其主要的架构概念。</li><li id="7abd" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">Angular的表达式语法更简单，侧重于“[ ]”用于属性绑定，而“()”用于事件绑定</li><li id="6723" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><strong class="ir hi">移动开发</strong> —首先解决移动性能问题，桌面开发就会容易得多。因此，Angular首先处理移动开发。</li><li id="fa8e" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><strong class="ir hi">模块化</strong> —角度遵循模块化。相似的功能一起保存在相同的模块中。这给Angular一个更轻&amp;更快的内核。</li></ul><p id="e3d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Angular建议使用微软的TypeScript语言，它引入了以下特性:</p><ul class=""><li id="96e9" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">基于类的面向对象编程</li><li id="fafb" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">静态打字</li></ul><p id="e1f0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">TypeScript是ECMAScript 6 (ES6)的超集，并向后兼容ECMAScript 5。Angular还包括ES6的优势:</p><ul class=""><li id="c2f4" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">迭代器</li><li id="c0e7" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">For/Of循环</li><li id="e85f" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">反射</li><li id="f7d4" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">改进的依赖注入——绑定使得命名依赖成为可能</li><li id="8c1b" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">动力载荷</li><li id="d860" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">异步模板编译</li><li id="e1cd" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">更简单的路由</li><li id="e43a" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">用组件和指令替换控制器和$ scope组件是带有模板的指令</li><li id="21bb" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">使用RxJS支持反应式编程</li></ul><p id="4ce3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇Angular教程中，我们先来了解Angular的特性。</p><h1 id="623f" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">角度特征</h1><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lf"><img src="../Images/505d6aa11a033bb0434c1e142939d6ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8-7N5Nyg2FrlNUAhuhWYw.png"/></div></div></figure><h2 id="28e1" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated"><strong class="ak">十字平台</strong></h2><ul class=""><li id="98fb" class="jo jp hh ir b is la iw lb ja lp je lq ji lr jm jt ju jv jw bi translated"><strong class="ir hi">渐进式网络应用</strong></li></ul><p id="3ee0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它使用现代网络平台功能来提供类似应用程序的体验。它提供了高性能、离线和零步骤安装。因此，使用Angular非常简单。</p><ul class=""><li id="d800" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><strong class="ir hi">原生</strong></li></ul><p id="d53c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用Ionic Framework、NativeScript和React Native的策略构建原生移动应用。</p><ul class=""><li id="0fe1" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><strong class="ir hi">桌面</strong></li></ul><p id="84af" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用你为web plus学习的相同的角度方法，创建跨Mac、Windows和Linux的桌面安装应用程序。</p><h2 id="3da9" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated"><strong class="ak">速度和性能</strong></h2><ul class=""><li id="80ec" class="jo jp hh ir b is la iw lb ja lp je lq ji lr jm jt ju jv jw bi translated"><strong class="ir hi">代码生成</strong></li></ul><p id="b09c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Angular将您的模板转换成针对JavaScript虚拟机高度优化的代码，为您提供手写代码的所有优势和框架的生产力。</p><ul class=""><li id="cfb3" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><strong class="ir hi">通用</strong></li></ul><p id="bec7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以使用Angular的任何技术来为Node.js等应用程序提供服务。NET、PHP等服务器。</p><ul class=""><li id="799a" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><strong class="ir hi">代码拆分</strong></li></ul><p id="c459" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Angular应用程序通过新的组件路由器快速加载，该组件路由器提供自动代码分割，因此用户只需加载渲染他们请求的视图所需的代码。</p><h2 id="1b64" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated"><strong class="ak">生产力</strong></h2><ul class=""><li id="0f82" class="jo jp hh ir b is la iw lb ja lp je lq ji lr jm jt ju jv jw bi translated"><strong class="ir hi">模板</strong></li></ul><p id="38e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用简单而强大的模板语法快速创建UI视图。</p><ul class=""><li id="3365" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><strong class="ir hi">角度CLI </strong></li></ul><p id="842b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">命令行工具:您可以轻松快速地开始构建组件、添加组件、测试组件，然后使用Angular CLI立即部署它们。</p><ul class=""><li id="6aa2" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><strong class="ir hi"> IDEs </strong></li></ul><p id="2992" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在流行的编辑器和ide(如微软的VS Code)中获得智能代码完成、即时错误和其他反馈。</p><h2 id="7f6d" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated"><strong class="ak">完整的开发故事</strong></h2><ul class=""><li id="21d3" class="jo jp hh ir b is la iw lb ja lp je lq ji lr jm jt ju jv jw bi translated"><strong class="ir hi">测试</strong></li></ul><p id="89c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了Karma for unit tests，您可以在运行中识别您的错误，量角器使您的场景测试运行得更快、更稳定。</p><p id="289c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">继续我们角度教程最重要的部分，让我们讨论角度的构建模块。</p><h1 id="2594" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">棱角分明的建筑材料</h1><p id="f4d2" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">Angular的主要构件有:</p><ul class=""><li id="1b55" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">模块</li><li id="08ba" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">成分</li><li id="fde4" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">模板</li><li id="8dd2" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">[计]元数据</li><li id="8b3e" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">数据绑定</li><li id="1ba2" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">指令</li><li id="12bb" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">服务</li><li id="0db6" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">依赖注入</li></ul><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lo"><img src="../Images/c9efdae7a1f91c3f9a1253d13d28730b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htInuHjDtOhFcQwolB3JPw.png"/></div></div></figure><p id="62ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，在我们的Angular教程中，让我们详细地谈论一下它们中的每一个。我们先来了解一下，什么是模块？</p><h2 id="32d3" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated">模块</h2><p id="d9d6" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">Angular应用是模块化的，为了保持模块化，我们有<em class="jn">个Angular模块</em>或者你可以说<em class="jn">个NgModules </em>。每个Angular app包含至少一个Angular模块，即根模块。一般命名为<em class="jn"> AppModule </em>。根模块可以是小型应用程序中唯一的模块。而大多数应用程序都有多个模块。你可以说，模块是一个内聚的代码块，具有一组相关的功能，这些功能具有特定的应用领域或工作流。任何角度模块都是带有@NgModule decorator的类。</p><p id="0dc1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"><em class="jn">decorator</em></strong><em class="jn"/>是修改JavaScript类的函数。Decorators主要用于将元数据附加到类上，这样它就知道这些类的配置以及它们应该如何工作。<em class="jn"> NgModule </em>是一个decorator函数，它采用元数据对象，其属性描述模块。这些属性是:</p><ul class=""><li id="e438" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><strong class="ir hi"> <em class="jn">声明:</em> </strong>视图及其相关的类属于该模块。有三类Angular可以包含视图:组件、指令和管道。我们一会儿会谈到它们。</li><li id="4e81" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><strong class="ir hi"> <em class="jn">导出:</em> </strong>其他模块的组件应该可以访问的类。</li><li id="5056" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><strong class="ir hi"> <em class="jn">导入:</em> </strong>模块，该模块的组件需要该模块的类。</li><li id="2ee9" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><strong class="ir hi"> <em class="jn">提供者:</em> </strong>服务存在于一个模块中，将在其他模块或组件中使用。一旦服务被包含在提供者中，它在应用程序的所有部分都是可访问的</li><li id="9374" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><strong class="ir hi"><em class="jn">bootstrap:</em></strong><em class="jn">根组件</em>，它是应用程序的主视图。这个根模块只有这个属性，它指示要引导的组件。</li></ul><p id="a6f9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看根模块(即<strong class="ir hi"><em class="jn">src/app/app . module . ts</em></strong>)是什么样子的:</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="ef32" class="ls kd hh mh b fi ml mm l mn mo">import { NgModule } from '<a class="ae mp" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import { BrowserModule } from '<a class="ae mp" href="http://twitter.com/angular/platform-browser" rel="noopener ugc nofollow" target="_blank">@angular/platform-browser</a>';<br/> <br/><a class="ae mp" href="http://twitter.com/NgModule" rel="noopener ugc nofollow" target="_blank">@NgModule</a>({<br/>imports:[ BrowserModule ],<br/>providers: [ BookList ],<br/>declarations: [ AppComponent ],<br/>exports: [],<br/>bootstrap: [ AppComponent ]<br/>})<br/> <br/>export class AppModule { }</span></pre><p id="9fe6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个根模块通常不会<em class="jn">导出</em>它的类，因为根模块是一个导入其他模块&amp;组件来使用它们的模块。我们在一个<em class="jn"> main.ts </em>文件中引导<em class="jn"> AppModule </em>，在这里我们指定引导模块，并且在引导模块内部包含引导组件。</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="0933" class="ls kd hh mh b fi ml mm l mn mo">import { enableProdMode } from '<a class="ae mp" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import { platformBrowserDynamic } from '<a class="ae mp" href="http://twitter.com/angular/platform-browser-dynamic" rel="noopener ugc nofollow" target="_blank">@angular/platform-browser-dynamic</a>';<br/>import { AppModule } from './app/app.module';<br/>import { environment } from './environments/environment';<br/> <br/>if (environment.production) {<br/>enableProdMode();<br/>}<br/> <br/>platformBrowserDynamic().bootstrapModule(AppModule);</span></pre><h2 id="7eb3" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated">角度库</h2><p id="a884" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">Angular为我们提供了一组JavaScript模块(库模块),它们提供了各种功能。每个Angular库都有<em class="jn"> @angular </em>前缀，像<em class="jn"> @angular/core、@angular/compiler、@angular/compiler-cli、@angular/http、@angular/router </em>。您可以使用<strong class="ir hi"> npm </strong>包管理器安装它们，并使用JavaScript import语句导入它们的一部分。</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="f03b" class="ls kd hh mh b fi ml mm l mn mo">import { Component } from '@angular/core';</span></pre><p id="8ca0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的例子中，Angular的组件装饰器是从@angular/core库中导入的。</p><p id="5c2f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在继续学习Angular教程，让我们了解Angular的下一个重要组成部分，即组件。</p><h2 id="ae0a" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated">成分</h2><p id="25c2" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">一个<em class="jn">组件</em>控制屏幕上一个或多个被称为<em class="jn">视图</em>的部分。例如，如果您正在构建一个电影列表应用程序，您可以拥有像App组件(<em class="jn">引导组件)</em>、movie list组件、电影描述组件等组件。</p><p id="da11" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在组件内部，您定义了组件的应用程序逻辑，即它如何支持视图——在类内部。该类通过属性和方法的API与视图进行交互。</p><p id="0de2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个应用程序都有一个在主模块中引导的主组件，即AppComponent。</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="364d" class="ls kd hh mh b fi ml mm l mn mo">import { Component } from '<a class="ae mp" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/> <br/><a class="ae mp" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>selector:'app-root',<br/>templateUrl:'./app.component.html',<br/>styleUrls: ['./app.component.css']<br/>})<br/> <br/>export class AppComponent{<br/>title = 'app works!';<br/>}</span></pre><p id="559c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以，在看了自举组件之后。现在让我们来看看另一个组件，即电影组件，以便让您对该组件有更多的了解。</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="e3a8" class="ls kd hh mh b fi ml mm l mn mo">import { Component, OnInit } from '<a class="ae mp" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/> <br/><a class="ae mp" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>selector: 'app-movies',<br/>templateUrl: './movies.component.html',<br/>styleUrls: ['./movies.component.css']<br/>})<br/> <br/>export class MoviesComponent implements OnInit {<br/>  movies: any[];<br/>  ngOnInit() {<br/>    getMovies()({<br/>    this.movies = movies;<br/>    })<br/>  }<br/>}</span></pre><p id="f173" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里，首先，我们使用import关键字导入组件中所需的组件和依赖项。然后，我们使用@Component decorator附加组件的元数据。第一个属性是选择器，它针对关键字并转储所选标记中的数据。您可以使用两种方式附加视图:或者您可以附加模板属性并在此处指定模板，或者您可以使用templateUrl并提供包含模板的文件的路径。稍后我们将详细讨论模板。第三个属性是styleUrls，它给出了CSS样式表的路径。</p><p id="75c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后在元数据之后，我们指定驻留在类中的组件的逻辑。我们指定构造函数，并在其中指定变量和方法，这需要在创建类时进行初始化。然后我们还有<strong class="ir hi"> ngOnInit </strong>方法，当一个组件被实例化时调用它。</p><p id="07b9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">转到角度教程的下一个构建模块，即模板。</p><h2 id="1248" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated">模板</h2><p id="dc1b" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">您将组件的视图与其伙伴<strong class="ir hi">模板</strong>关联起来。模板只不过是HTML标签的一种形式，告诉Angular如何呈现组件。模板看起来像普通的HTML，除了一些不同之处。这是我们上面讨论的电影组件的模板:</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="f317" class="ls kd hh mh b fi ml mm l mn mo">&lt;app-navbar&gt;&lt;/app-navbar&gt;<br/> <br/> <br/>&lt;div class ="container"&gt;<br/>&lt;flash-messages&gt;&lt;/flash-messages&gt;<br/>&lt;router-outlet&gt;&lt;/router-outlet&gt;<br/>&lt;/div&gt;</span></pre><p id="70dc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里我们有像<app-navbar>这样的自定义标签。</app-navbar></p><h2 id="8eaf" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated">[计]元数据</h2><p id="1f57" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">元数据告诉Angular如何处理一个类。为了告诉Angular that MovieList组件是一个组件，<strong class="ir hi">元数据</strong>被附加到该类。在TypeScript中，通过使用一个<strong class="ir hi">装饰器</strong>来附加元数据。在下面的代码中，您可以看到附加到电影组件的元数据:</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="3d85" class="ls kd hh mh b fi ml mm l mn mo">import { Component, OnInit } from '<a class="ae mp" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/> <br/><a class="ae mp" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>selector: 'app-movies',<br/>templateUrl: './movies.component.html',<br/>styleUrls: ['./movies.component.css']<br/>})</span></pre><p id="9ef4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是@Component decorator，它将它下面的类标识为组件类。@Component decorator接受Angular创建和呈现组件及其视图所需的配置对象。</p><p id="d818" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">@Component decorator最重要的配置是:</p><ul class=""><li id="86b8" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><em class="jn">选择器</em>:选择器告诉Angular在找到&lt; app-movies &gt;标签<em class="jn">的地方创建并插入这个组件的一个实例。</em>例如，如果一个应用的HTML包含&lt;app-movies&gt;&lt;/app-movies&gt;，那么Angular会在这些标签之间插入一个MovieListComponent视图的实例。</li><li id="dfad" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><em class="jn"> templateUrl </em>:包含该组件的HTML模板的路径。</li><li id="16f7" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><em class="jn">提供者</em>:组件所需服务的<strong class="ir hi">依赖注入提供者</strong>的数组。这是告诉Angular组件的构造函数需要一个<em class="jn"> MovieService </em>来获取要显示的电影列表的一种方式。</li></ul><p id="c843" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">@Component中的元数据告诉Angular从哪里获取您为组件指定的主要构建块。<em class="jn">模板、元数据和组件共同描述了一个视图。架构的要点是你必须在你的代码中添加元数据，这样Angular就知道该做什么。</em></p><h2 id="56fd" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated">数据绑定</h2><p id="5d45" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">如果您没有使用框架，您必须将数据值推入HTML控件，并将用户响应转换为一些动作和值更新。编写这样的推/拉逻辑是乏味的、容易出错的，读起来是一场噩梦。角度支持<strong class="ir hi">数据绑定</strong>，一种将模板的各个部分与组件的各个部分协调起来的机制。你应该在模板HTML中添加绑定标记来告诉Angular如何连接两边。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es mq"><img src="../Images/775ebafeb9fbdd1b7258df5dfc48a49a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*w_xnPqM8182GjklB2pCTiA.png"/></div></figure><p id="3a30" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每种形式都有一个方向——到DOM，从DOM，或者两个方向都有。</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="8639" class="ls kd hh mh b fi ml mm l mn mo">&lt;li&gt; {{movie.name}}&lt;/li&gt;<br/> <br/> <br/>&lt;movie-detail [movie]="selectedMovie"&gt;&lt;/movie-detail&gt;<br/> <br/> <br/>&lt;li (click)="selectMovie(Movie)"&gt;&lt;/li&gt;</span></pre><ul class=""><li id="27e6" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">{{movie.name}} <em class="jn">插值</em>显示&lt; li &gt;元素内组件的name属性值。</li><li id="f3b5" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">[movie] <em class="jn">属性绑定</em>将selectedMovie的值从父MovieListComponent传递到子MovieDetailComponent的movie属性。</li><li id="499c" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">(click) <em class="jn">事件绑定</em>在用户点击电影名称时调用组件的selectMovie方法。</li></ul><p id="7145" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">双向数据绑定</strong>是一个重要的部分，因为它使用ngModel指令将属性和事件绑定结合在一个符号中。以下是MovieDetailComponent模板中的一个示例:</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="7a58" class="ls kd hh mh b fi ml mm l mn mo">&lt;input [(ngModel)]="movie.name"&gt;</span></pre><p id="0bc7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在双向绑定中，与属性绑定一样，数据属性值从组件流向输入框。用户的更改也会流回组件，将属性重置为最新值，就像事件绑定一样。Angular在每个JavaScript事件周期处理一次所有数据绑定，从应用程序组件树的根到所有子组件。</p><p id="261f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">数据绑定在模板及其组件之间的通信中起着重要的作用。数据绑定对于父组件和子组件之间的通信也很重要。</p><p id="22e4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本角度教程中，我们将进一步讨论下一个构建模块，即指令。</p><h2 id="4394" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated">指令</h2><p id="7d75" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated">角度模板是<em class="jn">动态</em>。当Angular呈现它们时，它根据directives给出的指令转换DOM。指令是带有@Directive decorator的类。一个组件是一个带有模板的<em class="jn">指令</em>；@Component decorator实际上是一个用面向模板的特性扩展的@Directive decorator。</p><p id="2181" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然<strong class="ir hi">一个组件在技术上是一个指令</strong>，但是组件对于angle应用来说是如此独特和重要，以至于这个架构概述将组件从指令中分离出来。</p><p id="4494" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">存在两种<em class="jn">其他</em>类指令:<strong class="ir hi"> <em class="jn">结构</em> </strong>和<strong class="ir hi"> <em class="jn">属性</em> </strong>指令。</p><p id="cbd2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">指令往往像属性一样出现在元素标记中，有时按名称出现，但更多情况下作为赋值或绑定的目标。</p><p id="a0f6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">结构化</strong>指令通过添加、删除和替换DOM中的元素来改变布局。</p><p id="b4fe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该示例模板使用了两个内置的结构指令:</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="9b70" class="ls kd hh mh b fi ml mm l mn mo">&lt;li *ngFor="let movie of movies"&gt;&lt;/li&gt; <br/>&lt;movie-detail *ngIf="selectedMovie"&gt;&lt;/movie-detail&gt;</span></pre><ul class=""><li id="d29b" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">*ngFor告诉Angular在电影中为每部电影检索一个<li/></li><li id="2282" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">*仅当选定的电影存在时，ngIf才包括MovieDetail组件。</li></ul><p id="3612" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">属性</strong>指令改变现有元素的外观或行为。在模板中，它们看起来像普通的HTML属性。ngModel指令实现双向数据绑定，是属性指令的一个示例。ngModel通过设置现有元素的display value属性并响应change事件来修改现有元素的行为。</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="766a" class="ls kd hh mh b fi ml mm l mn mo">&lt;input [(ngModel)]="movie.name"&gt;</span></pre><p id="c602" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Angular还有一些指令，它们或者改变布局结构(例如ngSwitch)，或者修改DOM元素和组件的某些方面(例如ngStyle和ngClass)。</p><p id="86fb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您也可以编写自己的指令，即<em class="jn">自定义指令</em>。</p><h2 id="41b5" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated">服务</h2><p id="bc52" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated"><em class="jn">服务</em>是一个宽泛的范畴，包含您的应用程序所需的任何价值、功能或特性。服务通常是一个定义明确的类。任何东西都可以是服务。例子包括:</p><ul class=""><li id="711c" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">日志服务</li><li id="babe" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">数据服务</li><li id="7434" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">消息总线</li><li id="a6c4" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">税收计算器</li><li id="abff" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">应用程序配置</li></ul><figure class="lg lh li lj fd ii er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lo"><img src="../Images/cab14b8381e5f02bdc1177cb66de655a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMkoFhyYC8Nj2OZo1jA_9A.png"/></div></div></figure><p id="9aae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Angular没有服务的定义。没有服务基类，也没有注册服务的地方。然而服务是任何角度应用的基础。组件是服务的消费者。</p><p id="e423" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里有一个服务类的例子，我们使用Google的Firebase作为数据库，并导入电影列表:</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="19a6" class="ls kd hh mh b fi ml mm l mn mo">import { Injectable } from '<a class="ae mp" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import { AngularFire, FirebaseListObservable, FirebaseObjectObservable } from 'angularfire2';<br/>import { Movie } from '../interfaces/movie'<br/> <br/><a class="ae mp" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank">@Injectable</a>()<br/> <br/>export class FirebaseService {<br/>movies: FirebaseListObservable&lt;any[]&gt;;<br/>movie: FirebaseObjectObservable&lt;any&gt;;<br/>titles: FirebaseListObservable&lt;any[]&gt;;<br/>term: string = 'Incep';<br/> <br/>constructor(privateaf: AngularFire) { }<br/> <br/>getMovies()<br/>{<br/>    this.movies = this.af.database.list('/movies') asFirebaseListObservable&lt;Movie[]&gt;;<br/>    returnthis.movies;<br/>}<br/> <br/>getMovieDetails(id)<br/>{<br/>    this.movie = this.af.database.object('/movies/'+id) asFirebaseObjectObservable&lt;Movie&gt;;<br/>    return this.movie;<br/>}<br/> <br/>searchMovies()<br/>{<br/>    this.movies = this.af.database.list('/movies',{<br/>    query: {<br/>        orderByChild:'title',<br/>        startAt:this.term,<br/>        endAt:this.term + "\uf8ff",<br/>        value:'once'<br/>}<br/>} ) as FirebaseListObservable&lt;Movie[]&gt;;<br/>return this.movies;<br/>}<br/>}</span></pre><p id="29a7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">服务无处不在。组件类不从服务器获取数据，不验证用户输入，也不直接记录到控制台。他们将此类任务委托给服务。</p><p id="f9ad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">组件的工作是实现用户体验，仅此而已。它在视图(由模板呈现)和应用程序逻辑之间起中介作用。一个好的组件提供了数据绑定的属性和方法。Angular确实帮助你<em class="jn">遵循</em>这些原则，通过<em class="jn">依赖注入</em>将你的应用程序逻辑分解到服务中，并使这些服务对组件可用。</p><p id="0c99" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以，现在让我们理解本文中的依赖注入。</p><h2 id="048f" class="ls kd hh bd ke lt lu lv ki lw lx ly km ja lz ma kq je mb mc ku ji md me ky mf bi translated">依赖注入</h2><p id="21ed" class="pw-post-body-paragraph ip iq hh ir b is la iu iv iw lb iy iz ja lc jc jd je ld jg jh ji le jk jl jm ha bi translated"><em class="jn">依赖注入</em>是一种为一个类的新实例提供它所需要的完全依赖的方法。大多数依赖项都是服务。Angular使用依赖注入为新组件提供它们需要的服务。Angular可以通过查看组件的构造函数参数的类型来判断组件需要哪些服务。</p><p id="8a08" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当Angular创建一个组件时，它首先向一个<strong class="ir hi">注入器</strong>请求组件所需的服务。</p><figure class="lg lh li lj fd ii er es paragraph-image"><div class="er es mq"><img src="../Images/f7ecd9547054c9b320fe005f29a9eeda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*thpk1Sw3ncQs6kdcquZ53g.png"/></div></figure><p id="b7d7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注入器维护一个它先前创建的服务实例的容器。如果所请求的服务实例不在容器中，那么在将服务返回给Angular之前，注入器会创建一个实例并将其添加到容器中。当所有请求的服务都被解析并返回后，Angular可以调用组件的构造函数，并将这些服务作为参数。这就是<em class="jn">依赖注入</em>。</p><p id="291a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下面的例子中，你可以看到，我们向注入器注册了Firebase服务的<strong class="ir hi">提供者</strong>。提供者是可以创建或返回服务的东西，通常是服务类本身。您可以在模块或组件中注册提供程序。</p><p id="4324" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一般来说，将提供者添加到根模块中，这样服务的同一个实例在任何地方都可用，如下面的代码所示。</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="8b3d" class="ls kd hh mh b fi ml mm l mn mo"><a class="ae mp" href="http://twitter.com/NgModule" rel="noopener ugc nofollow" target="_blank">@NgModule</a>({<br/>declarations: [<br/>AppComponent,<br/>HomeComponent,<br/>MoviesComponent,<br/>NavbarComponent,<br/>MovieDetailsComponent,<br/>AboutComponent,<br/>BoldTextDirective,<br/>MovieSearchComponent,<br/>],<br/> <br/>imports: [<br/>BrowserModule,<br/>FormsModule,<br/>HttpModule,<br/>RouterModule.forRoot(routes),<br/>AngularFireModule.initializeApp(firebaseConfig,firebaseAuthConfig),<br/>FlashMessagesModule<br/>],<br/> <br/>providers: [FirebaseService],<br/>bootstrap: [AppComponent]<br/>})<br/> <br/>export class AppModule { }</span></pre><p id="4547" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">或者，您可以在@Component decorator的providers属性中注册组件级别的服务:</p><pre class="lg lh li lj fd mg mh mi mj aw mk bi"><span id="8b6f" class="ls kd hh mh b fi ml mm l mn mo">import { Component } from '<a class="ae mp" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/>import { FirebaseService } from './services/firebase.service';<br/> <br/><a class="ae mp" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>selector:'app-root',<br/>templateUrl:'./app.component.html',<br/>styleUrls: ['./app.component.css'],<br/>providers: [FirebaseService]<br/>})<br/>export class AppComponent {<br/>title = 'app works!';<br/>}</span></pre><p id="3940" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在组件级别注册意味着您可以通过该组件的每个新实例获得一个新的服务实例。</p><p id="204e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总结依赖注入，你可以说:</p><ul class=""><li id="afaa" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">依赖注入被连接到Angular框架中，并在任何地方使用。</li><li id="5750" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><em class="jn">喷油器</em>是主要机构。</li><li id="69d5" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">注入器维护它创建的服务实例的<em class="jn">容器</em>。</li><li id="7ad1" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">注入器可以从<em class="jn">提供者</em>创建一个新的服务实例。</li><li id="9281" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><em class="jn">提供者</em>是创建服务的诀窍。</li><li id="edcf" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">向注射器注册<em class="jn">供应商</em>。</li></ul><p id="b06d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就把我们带到了“角度教程”文章的结尾。如果你想查看更多关于人工智能、Python、道德黑客等市场最热门技术的文章，那么你可以参考<a class="ae mp" href="https://www.edureka.co/blog/?utm_source=medium&amp;utm_medium=content-link&amp;utm_campaign=angular-tutorial" rel="noopener ugc nofollow" target="_blank"> Edureka的官方网站。</a></p><p id="27e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请留意本系列中的其他文章，它们将解释Web开发的各个方面。</p><blockquote class="mr ms mt"><p id="57e3" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">1.<a class="ae mp" rel="noopener" href="/edureka/reactjs-tutorial-aa087fd7fc90"> ReactJS教程</a></p><p id="93c3" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">2.<a class="ae mp" rel="noopener" href="/edureka/react-components-65dc1d753af5">反应成分</a></p><p id="44b2" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">3.<a class="ae mp" rel="noopener" href="/edureka/react-router-2aab4e781736"> React路由器v4教程</a></p><p id="e22a" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">4.<a class="ae mp" rel="noopener" href="/edureka/react-redux-tutorial-2b3d81cfd3f7"> React Redux教程</a></p><p id="8899" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">5.<a class="ae mp" rel="noopener" href="/edureka/angular-directive-tutorial-3b203de7948a">角度指令教程</a></p><p id="da12" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">6.<a class="ae mp" rel="noopener" href="/edureka/animating-angularjs-apps-with-nganimate-directive-510500755b76">使用ngAnimate指令制作AngularJS应用程序动画</a></p><p id="f188" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">7.<a class="ae mp" rel="noopener" href="/edureka/node-js-tutorial-800e03bc596b"> NodeJS教程</a></p><p id="550f" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">8.<a class="ae mp" rel="noopener" href="/edureka/php-tutorial-beginners-guide-to-php-f78a189de6f"> PHP教程</a></p><p id="a9e6" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">9.<a class="ae mp" rel="noopener" href="/edureka/jquery-tutorial-for-beginners-679021d74ab4"> JQuery教程</a></p><p id="a63a" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">10.<a class="ae mp" rel="noopener" href="/edureka/top-10-javascript-frameworks-3179f1b5bd41">十大JavaScript框架</a></p><p id="823e" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">11.<a class="ae mp" rel="noopener" href="/edureka/node-js-mysql-tutorial-cef7452f2762">使用Node.js和MySQL构建CRUD应用程序</a></p><p id="b4e1" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">12.<a class="ae mp" rel="noopener" href="/edureka/node-js-mongodb-tutorial-fa80b60fb20c">使用节点构建CRUD应用程序。JS和MongoDB </a></p><p id="39fb" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">13.<a class="ae mp" rel="noopener" href="/edureka/rest-api-with-node-js-b245e345f7a5">用Node.js构建REST API</a></p><p id="0306" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">14.<a class="ae mp" rel="noopener" href="/edureka/node-js-requests-6b94862307a2">提出Node.js请求的3种最佳方式</a></p><p id="10ff" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">15.<a class="ae mp" rel="noopener" href="/edureka/html-vs-html5-83302f95652e"> HTML vs HTML5 </a></p><p id="53f1" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">16.<a class="ae mp" rel="noopener" href="/edureka/what-is-rest-api-d26ea9000ee6">什么是REST API？</a></p><p id="7b35" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">17.<a class="ae mp" rel="noopener" href="/edureka/flutter-vs-react-native-58133fbf9f33">颤振vs反应原生</a></p><p id="ea4d" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">18.<a class="ae mp" rel="noopener" href="/edureka/node-js-docker-tutorial-72e7542d69d8">如何对Node.js App进行Dockerize？</a></p><p id="ea44" class="ip iq jn ir b is it iu iv iw ix iy iz mu jb jc jd mv jf jg jh mw jj jk jl jm ha bi translated">19.<a class="ae mp" rel="noopener" href="/edureka/javascript-calculator-47778c7596f3">如何构建一个JavaScript计算器？</a></p></blockquote></div><div class="ab cl mx my go mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ha hb hc hd he"><p id="1d6f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="jn">原载于2017年5月30日</em><a class="ae mp" href="https://www.edureka.co/blog/angular-tutorial/" rel="noopener ugc nofollow" target="_blank"><em class="jn">www.edureka.co</em></a><em class="jn">。</em></p></div></div>    
</body>
</html>