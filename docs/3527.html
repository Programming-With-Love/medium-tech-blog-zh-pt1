<html>
<head>
<title>Coroutine Is a New Thread</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">协程是一个新线程</h1>
<blockquote>原文：<a href="https://medium.com/globant/coroutine-is-a-new-thread-934d9956ce2e?source=collection_archive---------0-----------------------#2020-10-24">https://medium.com/globant/coroutine-is-a-new-thread-934d9956ce2e?source=collection_archive---------0-----------------------#2020-10-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="30dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将在这个故事中讲述协程的基础知识。</p><p id="b775" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们仔细看看它😎</p><h1 id="cdbf" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">什么是协程？</h1><p id="26bf" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">Kotlin引入了coroutine作为异步或非阻塞编程的推荐解决方案。</p><p id="7c58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">"<strong class="ig hi">协程是一个轻量级线程</strong>"</p><p id="de7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在不阻塞应用UI线程的情况下，可以平稳地将<strong class="ig hi">操作</strong>如向/从数据库写入/读取数据、从服务器&amp; <strong class="ig hi">获取数据、长时间运行的操作</strong>执行<strong class="ig hi"/><strong class="ig hi"/><strong class="ig hi">。</strong></p><p id="f028" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，协程是救世主。</p><p id="3718" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看同样的实际用途。</p><blockquote class="kf kg kh"><p id="dd79" class="ie if ki ig b ih ii ij ik il im in io kj iq ir is kk iu iv iw kl iy iz ja jb ha bi translated">Coroutine是在Kotlin中引入的，但它不是Kotlin标准库的一部分。它包含在库<strong class="ig hi"> kotlinx.coroutines </strong>中。</p></blockquote><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/e8fbbec4d4548d62d08363aedb77ed16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*40Z5w18uM14SxYK1A-n-yg.jpeg"/></div></div></figure><p id="aa4b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个由JetBrains开发的丰富的协程库。它包含许多高级协同程序使能的原语。</p><p id="3be6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了使用协程，请在您的项目build.gradle中添加依赖项</p><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="ky kz l"/></div><figcaption class="la lb et er es lc ld bd b be z dx">Add <strong class="ak">dependency</strong> to project <strong class="ak">build.gradle (app module)</strong></figcaption></figure><h1 id="1ed3" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">协同工作创造</strong></h1><p id="ffcc" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">协程作业是用下列协程生成器创建的。</p><ul class=""><li id="3112" class="le lf hh ig b ih ii il im ip lg it lh ix li jb lj lk ll lm bi translated">发动</li><li id="c359" class="le lf hh ig b ih ln il lo ip lp it lq ix lr jb lj lk ll lm bi translated">异步ˌ非同步(asynchronous)</li></ul><p id="54d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它是在某个协同作用域的上下文中创建的。在下面的例子中，我们使用GlobalScope上下文来创建协程。</p><h1 id="25ee" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">使用GlobalScope.launch</h1><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="ky kz l"/></div><figcaption class="la lb et er es lc ld bd b be z dx"><strong class="ak">Coroutine job</strong> created using <strong class="ak">launch</strong></figcaption></figure><h1 id="a07b" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">使用GlobalScope.async</h1><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="ky kz l"/></div><figcaption class="la lb et er es lc ld bd b be z dx"><strong class="ak">Coroutine job</strong> created using <strong class="ak">async</strong></figcaption></figure><p id="f06a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们已经使用launch和async协程生成器成功地创建了协程。</p><p id="9ba1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">默认情况下，协程被立即调度执行</strong>。可以通过参数指定其他选项，如开始、阻止等。</p><p id="e321" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">从概念上讲，异步就像启动</strong>。它启动一个独立的协程，这是一个轻量级线程，与所有其他协程并行工作。不同之处在于，launch返回一个作业，并且不携带任何结果值，而async返回一个Deferred——一个轻量级的非阻塞未来，表示以后提供结果的承诺。你可以用。await()来获得它的最终结果，但是deferred也是一项工作，所以如果需要的话可以取消它。</p><p id="089d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有一些作业的属性和方法可以用来控制作业。</p><h1 id="b3cc" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">作业属性</h1><ul class=""><li id="6ed4" class="le lf hh ig b ih ka il kb ip ls it lt ix lu jb lj lk ll lm bi translated">isActive :当该作业处于活动状态时返回true它已经开始，尚未完成，也未被取消。如果等待其子作业完成的作业未被取消或失败，则该作业仍被视为活动的。</li><li id="b362" class="le lf hh ig b ih ln il lo ip lp it lq ix lr jb lj lk ll lm bi translated"><strong class="ig hi"> isCancelled </strong>:如果该作业由于某种原因被取消，则返回true，无论是通过显式调用cancel，还是由于该作业失败或其子作业或父作业被取消。在一般情况下，这并不意味着作业已经完成，因为它可能仍在完成它正在做的任何事情，并等待其子作业完成。</li><li id="495f" class="le lf hh ig b ih ln il lo ip lp it lq ix lr jb lj lk ll lm bi translated"><strong class="ig hi"> isCompleted </strong>:当该作业因某种原因完成时，返回true。被取消或失败并已完成执行的作业也被视为已完成。只有在其所有子作业完成后，作业才变得完整。</li></ul><h1 id="143d" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">工作职能</h1><ul class=""><li id="7fb4" class="le lf hh ig b ih ka il kb ip ls it lt ix lu jb lj lk ll lm bi translated"><strong class="ig hi">取消</strong>:取消该作业，取消原因可选。原因可用于指定错误消息或提供有关取消原因的其他详细信息，以便进行调试。有关取消机制的完整说明，请参见作业文档。</li><li id="2717" class="le lf hh ig b ih ln il lo ip lp it lq ix lr jb lj lk ll lm bi translated"><strong class="ig hi"> invokeOnCompletion </strong>:注册该作业完成时同步调用一次的处理程序。当作业已经完成时，将立即调用处理程序，并显示作业的异常或取消原因或null。否则，该处理程序将在该作业完成时被调用一次。</li><li id="040c" class="le lf hh ig b ih ln il lo ip lp it lq ix lr jb lj lk ll lm bi translated"><strong class="ig hi"> join </strong>:挂起协程，直到这个任务完成。当作业由于任何原因完成，并且调用协程的作业仍处于活动状态时，该调用会正常恢复(无例外)。如果作业仍处于新状态，该函数也启动相应的协程。</li><li id="16cb" class="le lf hh ig b ih ln il lo ip lp it lq ix lr jb lj lk ll lm bi translated"><strong class="ig hi"> start </strong>:启动与该作业相关的协程(如果有)，如果它还没有启动的话。如果该调用实际上启动了协程，则结果为true如果它已经启动或完成，则结果为false。</li></ul><p id="da0f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们知道了如何创建协程并控制它。</p><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="lv kz l"/></div></figure><p id="46d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">借助协程，享受长时间运行操作的完美执行😎</p></div></div>    
</body>
</html>