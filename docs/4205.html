<html>
<head>
<title>Are Web Components a thing?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件是一个东西吗？</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/are-web-components-a-thing-5a116b1da7e4?source=collection_archive---------2-----------------------#2018-10-23">https://medium.com/google-developer-experts/are-web-components-a-thing-5a116b1da7e4?source=collection_archive---------2-----------------------#2018-10-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/33bea83d03351709e60074bf4a7c3d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VueUSoUr5GaI5L0m"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">“brown block lot” by <a class="ae hu" href="https://unsplash.com/@mangofantasy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tim Johnson</a> on <a class="ae hu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="85aa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在与不太喜欢Web组件的人交谈时，我发现他们觉得Web组件不会有任何发展。这可能是因为他们有一个巨大的炒作，因为，比方说，一年前，但没有在过去几个月。</p><p id="9d26" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于那些关注的人来说，最近出现了一个非常重要的消息。首先，微软宣布他们开始致力于自定义元素和影子DOM的实现。这是一件大事，因为从几周前开始，Edge团队就没有任何迹象了。<br/>Firefox中的支持终于在今天登陆了63版本！在我看来，未来看起来非常光明。</p><p id="418a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">尽管Web组件规范已经存在很多年了，但是似乎很多开发人员都没有掌握这个标准的基础。围绕这个规范有很多误解和神话。让我们试着澄清一些方面。</p><h1 id="3f9e" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">不能将对象作为属性传递(对还是错？)</h1><figure class="kq kr ks kt fd hj"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="ebbf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我看了这条推文后感到很困惑，因为我意识到即使是经验开发者也不明白自定义元素是如何工作的。我并不是说他们必须喜欢它们，但是你不能将一个对象作为属性传递，这完全是一个<strong class="iw hy">错误的</strong>陈述。那么，我如何将一个对象作为属性传递呢？简答:via <em class="kw">属性</em>！:)<br/>看看下面这张图，你会有更好的想法。</p><figure class="kq kr ks kt fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es kx"><img src="../Images/b3852330ce3a3e7bf368061fb8ef5138.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYVxzLdjkUpxK7XYY9yDjg.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Property values are managed with getters and setters</figcaption></figure><p id="54fe" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的例子中，我们定义了一个包含名为myObj的属性的自定义元素。要将对象传递给属性，首先需要选择元素</p><p id="b6d8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du ky kz la lb b">let el = document.querySelector('my-el')</code></p><p id="c9f5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后使用点符号赋值，在本例中是一个标准对象</p><p id="d7d2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du ky kz la lb b">el.myObj = {a: 'test'}</code></p><p id="3c99" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就是这样。</p><figure class="kq kr ks kt fd hj"><div class="bz dy l di"><div class="lc kv l"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">You can test it by yourself</figcaption></figure><h1 id="1db9" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">为什么人们仍然对此感到困惑？</h1><p id="56a7" class="pw-post-body-paragraph iu iv hx iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">问题是大多数开发人员谈论'<em class="kw">属性'</em>，而他们实际上指的是'<em class="kw">属性'。</em>这两者可以相互关联，例如，我可以将属性反射到属性，但这并不总是需要的。</p><p id="6637" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于属性，您只能传递字符串或将其用作布尔值。在后一种情况下，如果属性存在，则返回true，否则返回false。<br/>说清楚一点，在下面的例子中<strong class="iw hy"> att === true </strong>。</p><p id="f127" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du ky kz la lb b">&lt;my-component att="false"&gt;&lt;/my-component&gt;</code></p><p id="3553" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">是误导还是不符合人体工程学？你可以对此有自己的看法，但这就是HTML的工作方式。在我看来，这是<em class="kw">一贯</em>。</p><h1 id="bfbb" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">自定义元素的API不好吗？</h1><p id="fb6b" class="pw-post-body-paragraph iu iv hx iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">有些人抱怨自定义元素API的冗长，他们认为这是完全无用的，设计糟糕。<br/>此处赘言部分属实。以Codepen为例，假设您有十个属性，而不是一个。你最终会得到10个getter和10个setter，在大多数情况下，它们只是在属性名称上有所不同，但是它们为每个属性做了相同的事情。<br/>这个不方便肯定，另一方面我也不认为这代表API不好。<br/>这是一个低级API，直接使用它并不总是很方便，但是你可以在它的基础上构建。你不需要开发一个完整的框架或者库，你只需要写一些抽象就可以了。如果你不想自己做抽象，试试<a class="ae hu" href="https://github.com/WebReflection/hyperHTML-Element" rel="noopener ugc nofollow" target="_blank">超HTML元素</a>或<a class="ae hu" href="https://github.com/Polymer/lit-element" rel="noopener ugc nofollow" target="_blank"> lit元素</a>它们很棒！</p><p id="ddb2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">也就是说，如果你仍然将Web组件与React、Vue、Polymer或其他框架进行比较，你就没有抓住要点，说实话，这是不公平的。</p><h1 id="eed3" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Web组件可以在任何地方工作</h1><p id="c4b8" class="pw-post-body-paragraph iu iv hx iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">不幸的是，这种说法不太准确。这确实是Web组件的一大承诺，但是事情并不总是无缝地工作。<br/> 如果你想了解更多关于Web组件、库和框架之间的互操作性，我强烈建议你看看由<a class="li lj ge" href="https://medium.com/u/d712d6fb229b?source=post_page-----5a116b1da7e4--------------------------------" rel="noopener" target="_blank"> Rob Dodson </a>撰写的<a class="ae hu" href="https://custom-elements-everywhere.com/" rel="noopener ugc nofollow" target="_blank">Custom Element Everywhere</a>。你会发现它们在哪里工作，在哪里不工作，以及潜在的解决方法。</p><h1 id="0376" class="js jt hx bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">那么，Web组件是一个东西吗？</h1><p id="4724" class="pw-post-body-paragraph iu iv hx iw b ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn lh jp jq jr ha bi translated">在我看来，是的，绝对是。也许它们不适合你，但这并不意味着它们不好或没用。我认为这是开始使用自定义元素和阴影DOM的好时机。深入了解Web组件可能会有助于改变你的想法，以防你仍然对这个标准持怀疑态度。</p><p id="4fe4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你对这个话题感兴趣，并且想保持联系，<a class="ae hu" href="https://twitter.com/granze" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我。</a></p></div></div>    
</body>
</html>