<html>
<head>
<title>Making Android unidirectional data flow with Kotlin coroutines 🦄</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin协同程序制作Android单向数据流🦄</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/making-android-unidirectional-data-flow-with-kotlin-coroutines-d69966717b6e?source=collection_archive---------2-----------------------#2019-10-17">https://blog.kotlin-academy.com/making-android-unidirectional-data-flow-with-kotlin-coroutines-d69966717b6e?source=collection_archive---------2-----------------------#2019-10-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8534f79e8e90b19bcd964b949fc30013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ksJRrucXsh9xer-3Rg94Lw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo from <a class="ae jz" href="https://images.pexels.com/photos/1295138/pexels-photo-1295138.jpeg?cs=srgb&amp;dl=barrel-blue-daytime-1295138.jpg&amp;fm=jpg" rel="noopener ugc nofollow" target="_blank">Emiliano Arano</a></figcaption></figure><p id="51f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">几年前，我分享了一些关于依赖注入的想法。今天，我想分享一些关于围绕ViewModel构建开发的想法。我们如何将它设置为状态和事件？借助<a class="ae jz" href="https://github.com/Kotlin/kotlinx.coroutines" rel="noopener ugc nofollow" target="_blank">科特林协同程序</a>、<a class="ae jz" href="https://mockk.io" rel="noopener ugc nofollow" target="_blank">莫克</a>甚至<a class="ae jz" href="http://arrow-kt.io" rel="noopener ugc nofollow" target="_blank"> Arrow-kt.io </a>？</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="1202" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">TL；DR:所有这些都被打包成一个小库:<a class="ae jz" href="https://github.com/arnaudgiuliani/uniflow-kt" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> Uniflow🦄</strong>T11】</a></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="738c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2017年，谷歌发布了<a class="ae jz" href="https://developer.android.com/topic/libraries/architecture" rel="noopener ugc nofollow" target="_blank"> Android架构组件</a>，为开发者构建应用提供了真正的支持。自从第一次发布以来，我一直在为许多公司使用这些组件。自2018年以来，这也是为欧洲的几个会议举办<a class="ae jz" href="https://medium.com/@giuliani.arnaud/presentations-6b91f53899ac" rel="noopener">研讨会的好机会。</a></p><p id="04ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">众所周知的<a class="ae jz" href="https://medium.com/upday-devs/android-architecture-patterns-part-2-model-view-presenter-8a6faaae14a5?source=post_page-----e7eeee76b73b----------------------" rel="noopener"> MVP架构</a>在1-1契约中保存事物，通过契约链接视图及其控制器，而MVVM架构方法提供了一种观察控制器并以数据流形式获得结果的方式。但是在某个地方，我们正在失去视图和视图模型之间的一种“正式契约”。没有什么强迫你以这种或那种方式构造你的视图模型。我们只是在“更新”视图。</p><p id="8c63" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">早在2016年，这个话题就有了一些非常好的反馈。那两篇来自<a class="lf lg ep" href="https://medium.com/u/d5885adb1ddf?source=post_page-----d69966717b6e--------------------------------" rel="noopener" target="_blank">弗洛里纳·蒙特内斯库</a>和<a class="lf lg ep" href="https://medium.com/u/d866ff513d08?source=post_page-----d69966717b6e--------------------------------" rel="noopener" target="_blank">露西娅·帕约</a>的文章仍然是很好的参考:<a class="ae jz" href="https://medium.com/upday-devs/android-architecture-patterns-part-3-model-view-viewmodel-e7eeee76b73b" rel="noopener"> Android架构模式第三部分:模型-视图-视图模型</a> &amp; <a class="ae jz" href="https://upday.github.io/blog/mvvm_rx_common_mistakes/" rel="noopener ugc nofollow" target="_blank"> MVVM + RxJava:常见错误</a>。</p><p id="37d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">即使它用RxJava plumbery涵盖了“前Android架构组件”的风格，主要思想仍然是相同的:视图模型应该主要以状态的形式发布数据，而不是在不同的事件流中传播。为什么？我们需要确保随着时间的推移，我们的数据在视图中保持一致。</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lh"><img src="../Images/a45e377bf5ea527607bf32373fa72e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BsrHkrsKLGimMjRrmibi7g.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Several streams of data to define the view data?</figcaption></figure><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lh"><img src="../Images/992fbe082e890ded300c96cd284b73b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tfXMqOJuGNC4jGzZAn0Q8Q.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">One stream of data, to define the view state</figcaption></figure><p id="d5f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从这种方法中产生的可测试性真的很棒。因为您的视图模型一次只有一个状态，所以测试只是测试状态序列的问题！更重要的是，你现在可以重放任何状态，然后轻松模拟任何场景！</p><p id="f705" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">ViewModel处理视图的所有逻辑抽象。视图只是在这里绑定动作并呈现状态和事件。有没有让你想到别的事情？<a class="ae jz" href="https://flaviocopes.com/react-unidirectional-data-flow/" rel="noopener ugc nofollow" target="_blank">反应单向数据流</a>！</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/4a5d6136b4b6a28d68eea84469ba7dac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wWCvobLcMz_V7It2tQPGfg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Unidirectional data flow — <a class="ae jz" href="https://flaviocopes.com/react-unidirectional-data-flow/" rel="noopener ugc nofollow" target="_blank">https://flaviocopes.com/react-unidirectional-data-flow/</a></figcaption></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="efbb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还可以考虑另一个好主意:MVI。这是http://hannesdorfmann.com/android/mosby3-mvi-1的汉尼斯·多尔曼的优秀系列</p><p id="6838" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…但是对不起，我的课太多了😱😭！我希望我们可以用几行代码编写一些东西，并坚持使用我的ViewModel类。我们如何做到这一点？🤔</p><h1 id="66c4" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">视图模型、操作和状态🔄</h1><p id="810f" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">让我们用一些定义来形式化所有这些东西:</p><ul class=""><li id="6b0b" class="mq mr in kc b kd ke kh ki kl ms kp mt kt mu kx mv mw mx my bi translated"><strong class="kc io">状态</strong>定义了一组数据，将由视图模型一次性公开</li><li id="cd64" class="mq mr in kc b kd mz kh na kl nb kp nc kt nd kx mv mw mx my bi translated"><strong class="kc io">动作</strong>是ViewModel提供的一个功能，它允许您创建一个新的ViewModel状态</li><li id="d403" class="mq mr in kc b kd mz kh na kl nb kp nc kt nd kx mv mw mx my bi translated">ViewModel <strong class="kc io">公开动作</strong>，并且是唯一允许改变其状态的组件</li></ul><p id="9768" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">视图观察状态流</strong>(数据类，从<code class="fe ne nf ng nh b">UIState</code>继承的密封类)。</p><p id="4303" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那些潜在的<strong class="kc io">状态代表了视图将要使用的契约</strong>。ViewModel向视图公开操作，并以状态流的形式提供结果。</p><h1 id="ba69" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">让我们来看一个示例应用程序</h1><p id="c866" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">让我们来看一个用例(有些人从我的工作室中认出了下面的截图)。让我们关注最后一个屏幕:它<strong class="kc io">显示一天的天气</strong>。</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/60edb4a14f3ea819d2f7026e243b1898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tp6kWsknTNjmTU9JqGbwDA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Weather App — the Last screen is about to show weather for one day</figcaption></figure><p id="38b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们写下我们希望向视图公开的<strong class="kc io">状态</strong>(我们的契约):</p><ul class=""><li id="d589" class="mq mr in kc b kd ke kh ki kl ms kp mt kt mu kx mv mw mx my bi translated">初始状态(我们还没有任何数据)</li><li id="fa3f" class="mq mr in kc b kd mz kh na kl nb kp nc kt nd kx mv mw mx my bi translated">“天气”状态(针对我们的主要数据)</li><li id="61d3" class="mq mr in kc b kd mz kh na kl nb kp nc kt nd kx mv mw mx my bi translated">一个失败的国家，以防任何事情出错</li></ul><figure class="li lj lk ll gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="4b2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们创建一个扩展<code class="fe ne nf ng nh b">AndroidDataFlow</code>的类，并定义<code class="fe ne nf ng nh b">getWeatherOfTheDay</code>动作来推送一些状态:</p><figure class="li lj lk ll gt jo"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">DataFlow exposing getWeather action and setting initial state in init block</figcaption></figure><p id="dd84" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ne nf ng nh b">getWeatherOfTheDay</code>将检索给定日期的天气(字符串)，并将<code class="fe ne nf ng nh b">Weather</code>状态更新推送到视图。</p><p id="ce0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个状态都是不可变的Kotlin数据(数据类或对象)，只由ViewModel发出。</p><p id="fd11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">视图只调用ViewModel操作并绑定观察到的UI呈现结果。活动的功能<code class="fe ne nf ng nh b">onStates</code>允许观察进入的状态。这里我们是直接“手工”装订。</p><figure class="li lj lk ll gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3152" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，您可以使用<a class="ae jz" href="https://mockk.io/" rel="noopener ugc nofollow" target="_blank">mock</a>非常容易地测试您的流程:</p><figure class="li lj lk ll gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><blockquote class="nl nm nn"><p id="9459" class="ka kb no kc b kd ke kf kg kh ki kj kk np km kn ko nq kq kr ks nr ku kv kw kx ig bi translated">随着时间的推移，我们的系统拥有可预测的数据状态！即使您有几个并行触发的操作，我们也能确保一次只有一个状态。</p></blockquote><p id="900b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您的应用程序更容易调试:每个状态更新都由Uniflow跟踪。这种状态记录可以很容易地重定向到任何记录系统(Crashlytics…)。最后，很容易理解生产中发生了什么，并重放任何错误情况。</p><p id="015a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Uniflow允许我们为一个给定的状态设置一个守卫:它确保我们只有在一个给定的状态下才触发一个动作，然后我们有一个一致的状态流。</p><p id="012d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有时候，你不想只推送新的UI更新。在这种情况下，我们将使用<strong class="kc io">事件</strong>到<strong class="kc io">事件</strong>触发“副作用”。它们的用法与状态非常相似，<a class="ae jz" href="https://github.com/arnaudgiuliani/uniflow-kt/blob/master/Documentation.md#side-effects--events" rel="noopener ugc nofollow" target="_blank">查看文档</a>。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="0efe" class="ln lo in bd lp lq ns ls lt lu nt lw lx ly nu ma mb mc nv me mf mg nw mi mj mk bi translated">准备好Kotlin协程了吗👍</h1><p id="88eb" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">正如您可能已经看到的，我们<a class="ae jz" href="https://github.com/arnaudgiuliani/uniflow-kt/blob/master/Documentation.md#coroutines-the-easy-way" rel="noopener ugc nofollow" target="_blank">可以在任何动作代码块中直接编写Kotlin协程</a>。只需使用<code class="fe ne nf ng nh b">setState</code>或任何其他<a class="ae jz" href="https://github.com/arnaudgiuliani/uniflow-kt/blob/master/Documentation.md#actions-states--events-" rel="noopener ugc nofollow" target="_blank">动作生成器</a>，它将让你在IO Dispatcher上默认运行任何协程代码。</p><figure class="li lj lk ll gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="42d6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个动作函数只需要返回一个UIState对象，它会在主线程上用LiveData推送给你。</p><p id="74ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太好了！但是……任何使用过Kotlin协同程序的人都知道，您必须小心处理错误。为什么？因为协程依赖于异常，然后您必须使用旧的“try/catch”块来捕捉周围的任何问题。</p><p id="8bd7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Uniflow提供的一种方法是通过提供一个后备lambda函数为您创建这个“try/catch”块，让您在出错时处理您的操作。下面，<code class="fe ne nf ng nh b">setState</code>允许第二个lambda表达式捕捉任何错误:</p><figure class="li lj lk ll gt jo"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="6882" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">使用函数式编程✨实现更安全的流程</h1><p id="e940" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">您可以完美地编写命令式代码，并使用Uniflow提供的错误处理来编写您的操作。但是您可能需要更精确地控制代码流，而不需要在特定的块上使用try/catch。</p><p id="bf8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一种处理可能导致错误的表达式的方法(也称为“副作用”)，是用<a class="ae jz" href="https://arrow-kt.io/" rel="noopener ugc nofollow" target="_blank"> Arrow-kt.io </a>引入一些功能性的优点。我们在这里用<code class="fe ne nf ng nh b"><a class="ae jz" href="https://github.com/arnaudgiuliani/uniflow-kt/blob/master/Documentation.md#wrapping-unsafe-expression" rel="noopener ugc nofollow" target="_blank">safeCall</a></code> <a class="ae jz" href="https://github.com/arnaudgiuliani/uniflow-kt/blob/master/Documentation.md#wrapping-unsafe-expression" rel="noopener ugc nofollow" target="_blank">把一个有风险的表达式</a>用<code class="fe ne nf ng nh b"><a class="ae jz" href="https://arrow-kt.io/docs/arrow/core/try/" rel="noopener ugc nofollow" target="_blank">Try</a></code> <a class="ae jz" href="https://arrow-kt.io/docs/arrow/core/try/" rel="noopener ugc nofollow" target="_blank">类型</a>包装起来:</p><figure class="li lj lk ll gt jo"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Wrapping unsafe expression with Arrow</figcaption></figure><p id="0634" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从任何一个函数表达式中，您都可以用<code class="fe ne nf ng nh b">toState</code>轻松地呈现成功和失败状态:</p><figure class="li lj lk ll gt jo"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Rendering state, the FP way!</figcaption></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="924c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Uniflow将所有这些想法捆绑到一个小型Kotlin/Android库中。我每天和我的团队一起使用它。我们将在生产中使用它几个月。</p><p id="bad3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">检查<a class="ae jz" href="https://github.com/arnaudgiuliani/uniflow-kt" rel="noopener ugc nofollow" target="_blank">单流</a>🦄GitHub项目与Gradle一起安装。这只是添加到依赖项中的一行:</p><pre class="li lj lk ll gt nx nh ny nz aw oa bi"><span id="6683" class="ob lo in nh b gy oc od l oe of">// Jcenter()</span><span id="874a" class="ob lo in nh b gy og od l oe of">// Core<br/>implementation 'io.uniflow:uniflow-core:$version'<br/>testImplementation 'io.uniflow:uniflow-test:$version'<br/><br/>// Android<br/>implementation 'io.uniflow:uniflow-android:$version'<br/>testImplementation 'io.uniflow:uniflow-android-test:$version'<br/><br/>// AndroidX<br/>implementation 'io.uniflow:uniflow-androidx:$version'<br/>testImplementation 'io.uniflow:uniflow-androidx-test:$version'</span></pre><p id="0a12" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将发布一个更完整的应用程序示例来详细说明它。我们可以想象与Arrow-kt.io的更多集成，或者直接与未来的Android Compose组件集成。✨</p><p id="84a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望你会喜欢这些想法！🙂不要犹豫，给一些反馈👍🦄🎉</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="213a" class="ln lo in bd lp lq ns ls lt lu nt lw lx ly nu ma mb mc nv me mf mg nw mi mj mk bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="6781" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae jz" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae jz" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察推特</a>并在媒体上关注我们。</p><p id="d873" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你需要一个科特林工作室，看看我们如何能帮助你:<a class="ae jz" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi ni"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>