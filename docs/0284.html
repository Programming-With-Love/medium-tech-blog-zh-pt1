<html>
<head>
<title>Lifecycle Aware Data Loading with Architecture Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用架构组件加载生命周期感知数据</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/lifecycle-aware-data-loading-with-android-architecture-components-f95484159de4?source=collection_archive---------0-----------------------#2017-05-17">https://medium.com/androiddevelopers/lifecycle-aware-data-loading-with-android-architecture-components-f95484159de4?source=collection_archive---------0-----------------------#2017-05-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="fff9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我之前的博文<a class="ae jc" rel="noopener" href="/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832">中，我谈到了如何使用</a><a class="ae jc" href="https://developer.android.com/guide/components/loaders.html" rel="noopener ugc nofollow" target="_blank">加载器</a>以自动处理配置变更的方式加载数据。</p><p id="53f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随着<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/index.html" rel="noopener ugc nofollow" target="_blank">架构组件</a>的引入，有一个替代方案为这个用例提供了一个现代的、灵活的、可测试的解决方案。</p><h1 id="788a" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">关注点分离</h1><p id="ea9a" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">装载机的两大优势是:</p><ul class=""><li id="1f8e" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">它们封装了数据加载的过程</li><li id="0878" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">它们在配置更改后仍然存在，避免了不必要的重新加载数据</li></ul><p id="720a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于架构组件，这两个好处现在由两个独立的类来处理:</p><ul class=""><li id="9e6d" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated"><code class="du ku kv kw kx b"><a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/livedata.html" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>提供一个生命周期感知基类，用于封装装载数据</li><li id="115d" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><code class="du ku kv kw kx b"><a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" rel="noopener ugc nofollow" target="_blank">ViewModels</a></code>在配置变更时自动保留</li></ul><p id="b35a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种分离的一个显著优点是，您可以在多个<code class="du ku kv kw kx b">ViewModels</code>中重用同一个<code class="du ku kv kw kx b">LiveData</code>，通过一个<code class="du ku kv kw kx b"><a class="ae jc" href="https://developer.android.com/reference/android/arch/lifecycle/MediatorLiveData.html" rel="noopener ugc nofollow" target="_blank">MediatorLiveData</a></code>将多个<code class="du ku kv kw kx b">LiveData</code>源组合在一起，或者在一个<code class="du ku kv kw kx b">Service</code>中使用它们，避免试图将一个<code class="du ku kv kw kx b">Loader</code>合并到一个没有<code class="du ku kv kw kx b">LoaderManager</code>的场景中。</p><p id="14ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然<code class="du ku kv kw kx b">Loaders</code>支持用户界面和数据加载的分离(可测试应用的第一步！)，这个模型扩展了这个优势——您的<code class="du ku kv kw kx b">ViewModel</code>可以通过模拟您的数据源来完全测试，而<code class="du ku kv kw kx b">LiveData</code>可以在完全隔离的情况下测试。一个干净的、可测试的架构是<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/guide.html" rel="noopener ugc nofollow" target="_blank">应用架构指南</a>中的一大焦点。</p><h1 id="50e2" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">保持简单</h1><p id="4cd0" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">这在理论上听起来不错。一个说明性的例子<a class="ae jc" rel="noopener" href="/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#5aa5">重现我们的</a> <code class="du ku kv kw kx b"><a class="ae jc" rel="noopener" href="/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#5aa5">AsyncTaskLoader</a></code>可能有助于使想法更具体一点:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="3ce5" class="lg je hh kx b fi lh li l lj lk">public class JsonViewModel extends AndroidViewModel {<br/>  // You probably have something more complicated<br/>  // than just a String. Roll with me<br/>  private final MutableLiveData&lt;List&lt;String&gt;&gt; data =<br/>      new MutableLiveData&lt;List&lt;String&gt;&gt;();</span><span id="48ec" class="lg je hh kx b fi ll li l lj lk">  public JsonViewModel(Application application) {<br/>    super(application);<br/>    loadData();<br/>  }</span><span id="0eb2" class="lg je hh kx b fi ll li l lj lk">  public LiveData&lt;List&lt;String&gt;&gt; getData() {<br/>    return data;<br/>  }</span><span id="c084" class="lg je hh kx b fi ll li l lj lk">  private void loadData() {<br/>    new AsyncTask&lt;Void,Void,List&lt;String&gt;&gt;() {<br/>      @Override<br/>      protected List&lt;String&gt; doInBackground(Void... voids) {<br/>        File jsonFile = new File(getApplication().getFilesDir(),<br/>            "downloaded.json");<br/>        List&lt;String&gt; data = new ArrayList&lt;&gt;();<br/>        // Parse the JSON using the library of your choice<br/>        return data;<br/>      }</span><span id="230b" class="lg je hh kx b fi ll li l lj lk">      @Override<br/>      protected void onPostExecute(List&lt;String&gt; data) {<br/>        this.data.setValue(data);<br/>      }<br/>    }.execute();<br/>  }<br/>}</span></pre><p id="fb19" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">等等，一个<code class="du ku kv kw kx b">AsyncTask</code>？这怎么安全？这里有两个安全功能:</p><ol class=""><li id="1799" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb lm km kn ko bi translated"><code class="du ku kv kw kx b"><a class="ae jc" href="https://developer.android.com/reference/android/arch/lifecycle/AndroidViewModel.html" rel="noopener ugc nofollow" target="_blank">AndroidViewModel</a></code>(<code class="du ku kv kw kx b">ViewModel</code>的子类)只有一个对应用程序<code class="du ku kv kw kx b">Context</code>的引用，所以非常重要的是我们没有引用<code class="du ku kv kw kx b">Activity</code>的<code class="du ku kv kw kx b">Context</code>等等。这可能会出现泄漏——甚至有一个棉绒检查来避免这种问题。</li><li id="0030" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb lm km kn ko bi translated">只有当有东西在观察它的时候，才会给出结果</li></ol><p id="9ee0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是我们还没有完全抓住架构组件的本质:我们的<code class="du ku kv kw kx b">ViewModel</code>直接构建和管理我们的<code class="du ku kv kw kx b">LiveData</code>。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="f5d2" class="lg je hh kx b fi lh li l lj lk">public class JsonViewModel extends AndroidViewModel {<br/>  private final JsonLiveData data;</span><span id="d56e" class="lg je hh kx b fi ll li l lj lk">  public JsonViewModel(Application application) {<br/>    super(application);<br/>    data = new JsonLiveData(application);<br/>  }</span><span id="0025" class="lg je hh kx b fi ll li l lj lk">  public LiveData&lt;List&lt;String&gt;&gt; getData() {<br/>    return data;<br/>  }<br/>}</span><span id="656e" class="lg je hh kx b fi ll li l lj lk">public class JsonLiveData extends LiveData&lt;List&lt;String&gt;&gt; {<br/>  private final Context context;</span><span id="504c" class="lg je hh kx b fi ll li l lj lk">  public JsonLiveData(Context context) {<br/>    this.context = context;<br/>    loadData();<br/>  }</span><span id="a07d" class="lg je hh kx b fi ll li l lj lk">  private void loadData() {<br/>    new AsyncTask&lt;Void,Void,List&lt;String&gt;&gt;() {<br/>      @Override<br/>      protected List&lt;String&gt; doInBackground(Void… voids) {<br/>        File jsonFile = new File(getApplication().getFilesDir(),<br/>            "downloaded.json");<br/>        List&lt;String&gt; data = new ArrayList&lt;&gt;();<br/>        // Parse the JSON using the library of your choice<br/>        return data;<br/>      }</span><span id="4949" class="lg je hh kx b fi ll li l lj lk">      @Override<br/>      protected void onPostExecute(List&lt;String&gt; data) {<br/>        setValue(data);<br/>      }<br/>    }.execute();<br/>  }<br/>}</span></pre><p id="890f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，正如您所料，我们的<code class="du ku kv kw kx b">ViewModel</code>变得相当简单。我们的<code class="du ku kv kw kx b">LiveData</code>现在完全封装了加载过程，只加载一次数据。</p><h1 id="bdf4" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><code class="du ku kv kw kx b">LiveData</code>世界中的数据变化</h1><p id="803e" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">就像<a class="ae jc" rel="noopener" href="/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#1e8c">加载器如何对其他地方的变化做出反应一样</a>，这个相同的功能在使用<code class="du ku kv kw kx b">LiveData</code>时非常关键——顾名思义，数据是会变化的！当有一个观察者时，我们可以很容易地修改我们的类来继续加载数据:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="96dd" class="lg je hh kx b fi lh li l lj lk">public class JsonLiveData extends LiveData&lt;List&lt;String&gt;&gt; {<br/>  private final Context context;<br/>  private final FileObserver fileObserver;</span><span id="2abc" class="lg je hh kx b fi ll li l lj lk">public JsonLiveData(Context context) {<br/>    this.context = context;<br/>    String path = new File(context.getFilesDir(),<br/>        "downloaded.json").getPath();<br/>    fileObserver = new FileObserver(path) {<br/>      @Override<br/>      public void onEvent(int event, String path) {<br/>        // The file has changed, so let’s reload the data<br/>        loadData();<br/>      }<br/>    };<br/>    loadData();<br/>  }</span><span id="f04c" class="lg je hh kx b fi ll li l lj lk">  @Override<br/>  protected void onActive() {<br/>    fileObserver.startWatching();<br/>  }</span><span id="eebf" class="lg je hh kx b fi ll li l lj lk">  @Override<br/>  protected void onInactive() {<br/>    fileObserver.stopWatching();<br/>  }</span><span id="b64b" class="lg je hh kx b fi ll li l lj lk">  private void loadData() {<br/>    new AsyncTask&lt;Void,Void,List&lt;String&gt;&gt;() {<br/>      @Override<br/>      protected List&lt;String&gt; doInBackground(Void… voids) {<br/>        File jsonFile = new File(getApplication().getFilesDir(),<br/>            "downloaded.json");<br/>        List&lt;String&gt; data = new ArrayList&lt;&gt;();<br/>        // Parse the JSON using the library of your choice<br/>        return data;<br/>      }</span><span id="c178" class="lg je hh kx b fi ll li l lj lk">      @Override<br/>      protected void onPostExecute(List&lt;String&gt; data) {<br/>        setValue(data);<br/>      }<br/>    }.execute();<br/>  }<br/>}</span></pre><p id="6a1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">既然我们对监听变化感兴趣，我们可以利用LiveData的<code class="du ku kv kw kx b">onActive()</code>和<code class="du ku kv kw kx b">onInactive()</code>回调，只在我们的数据上有主动观察者时才进行监听——只要有人在观察，就可以保证他们得到最新的数据。</p><h1 id="d9b7" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">观察数据</h1><p id="ca68" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在<code class="du ku kv kw kx b">Loader</code>世界中，将数据放入用户界面需要用到一个<code class="du ku kv kw kx b">LoaderManager</code>，在正确的地方调用<code class="du ku kv kw kx b">initLoader()</code>，并构建一个<code class="du ku kv kw kx b">LoaderCallbacks</code>。在架构组件的世界里，事情要简单得多。</p><p id="61c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要做两件事:</p><ol class=""><li id="6d7a" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb lm km kn ko bi translated">获取对我们的视图模型的引用</li><li id="d622" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb lm km kn ko bi translated">开始观察我们的实时数据</li></ol><p id="49c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是解释起来几乎和代码本身一样长:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="e65b" class="lg je hh kx b fi lh li l lj lk">public class MyActivity extends AppCompatActivity {<br/>  public void onCreate(Bundle savedInstanceState) {<br/>    super.onCreate(savedInstanceState);<br/>    JsonViewModel model =<br/>        ViewModelProviders.of(this).get(JsonViewModel.class);<br/>    model.getData().observe(this, data -&gt; {<br/>      // update UI<br/>    });<br/>  }<br/>}</span></pre><p id="96b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你会注意到没有必要事后清理:<code class="du ku kv kw kx b">ViewModels</code>只在需要的时候自动存活，<code class="du ku kv kw kx b">LiveData</code>只在调用<code class="du ku kv kw kx b">Activity</code> / <code class="du ku kv kw kx b">Fragment</code> / <code class="du ku kv kw kx b"><a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/lifecycle.html#lco" rel="noopener ugc nofollow" target="_blank">LifecycleOwner</a></code>开始或恢复时自动传递数据给你。</p><h1 id="d13e" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">装载所有的东西</h1><p id="82b9" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">现在，如果你还在强烈反对<code class="du ku kv kw kx b">AsyncTask</code>的阵营中，我完全可以接受:<code class="du ku kv kw kx b">LiveData</code>比仅仅局限于那个构造要灵活得多。</p><p id="3f24" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/room.html" rel="noopener ugc nofollow" target="_blank"> Room </a>让您拥有<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/room.html#daos-query-observable" rel="noopener ugc nofollow" target="_blank">可观察查询</a>——返回<code class="du ku kv kw kx b">LiveData</code>的数据库查询，这样数据库更改就可以通过您的视图模型自动传播到您的UI。有点像没有接触光标或加载器的<code class="du ku kv kw kx b">CursorLoader</code>。</p><p id="238a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们也可以用一个<code class="du ku kv kw kx b">LiveData</code>类重写<code class="du ku kv kw kx b"><a class="ae jc" rel="noopener" href="/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#85b1">FusedLocationApi</a></code> <a class="ae jc" rel="noopener" href="/google-developers/making-loading-data-on-android-lifecycle-aware-897e12760832#85b1">示例</a>:</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="30e6" class="lg je hh kx b fi lh li l lj lk">public class LocationLiveData extends LiveData&lt;Location&gt; implements<br/>    GoogleApiClient.ConnectionCallbacks,<br/>    GoogleApiClient.OnConnectionFailedListener,<br/>    LocationListener {<br/>  private GoogleApiClient googleApiClient;</span><span id="94d5" class="lg je hh kx b fi ll li l lj lk">  public LocationLiveData(Context context) {<br/>    googleApiClient =<br/>      new GoogleApiClient.Builder(context, this, this)<br/>      .addApi(LocationServices.API)<br/>      .build();<br/>  }</span><span id="e3e0" class="lg je hh kx b fi ll li l lj lk">  @Override<br/>  protected void onActive() {<br/>    // Wait for the GoogleApiClient to be connected<br/>    googleApiClient.connect();<br/>  }</span><span id="e36b" class="lg je hh kx b fi ll li l lj lk">  @Override<br/>  protected void onInactive() {<br/>    if (googleApiClient.isConnected()) {<br/>      LocationServices.FusedLocationApi.removeLocationUpdates(<br/>          googleApiClient, this);<br/>    }<br/>    googleApiClient.disconnect();<br/>  }</span><span id="866a" class="lg je hh kx b fi ll li l lj lk">  @Override<br/>  public void onConnected(Bundle connectionHint) {<br/>    // Try to immediately find a location<br/>    Location lastLocation = LocationServices.FusedLocationApi<br/>        .getLastLocation(googleApiClient);<br/>    if (lastLocation != null) {<br/>      setValue(lastLocation);<br/>    }</span><span id="b72d" class="lg je hh kx b fi ll li l lj lk">    // Request updates if there’s someone observing<br/>    if (hasActiveObservers()) {<br/>      LocationServices.FusedLocationApi.requestLocationUpdates(<br/>          googleApiClient, new LocationRequest(), this);<br/>    }<br/>  }</span><span id="dfe0" class="lg je hh kx b fi ll li l lj lk">  @Override<br/>  public void onLocationChanged(Location location) {<br/>    // Deliver the location changes<br/>    setValue(location);<br/>  }</span><span id="5315" class="lg je hh kx b fi ll li l lj lk">  @Override<br/>  public void onConnectionSuspended(int cause) {<br/>    // Cry softly, hope it comes back on its own<br/>  }</span><span id="b73a" class="lg je hh kx b fi ll li l lj lk">  @Override<br/>  public void onConnectionFailed(<br/>      @NonNull ConnectionResult connectionResult) {<br/>    // Consider exposing this state as described here:<br/>    // <a class="ae jc" href="https://d.android.com/topic/libraries/architecture/guide.html#addendum" rel="noopener ugc nofollow" target="_blank">https://d.android.com/topic/libraries/architecture/guide.html#addendum</a><br/>  }<br/>}</span></pre><h1 id="1d8a" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">仅仅触及架构组件的表面</h1><p id="6a47" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">Android架构组件还有很多，所以一定要查看所有的文档。</p><p id="01e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我个人强烈建议通读整个<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/guide.html" rel="noopener ugc nofollow" target="_blank">应用架构指南</a>，让你了解所有这些组件如何组合在一起，为你的整个应用形成一个坚实的架构。</p></div></div>    
</body>
</html>