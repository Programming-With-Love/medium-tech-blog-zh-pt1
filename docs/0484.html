<html>
<head>
<title>Coroutines &amp; Patterns for work that shouldn’t be cancelled</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不应该取消的工作的协程和模式</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/coroutines-patterns-for-work-that-shouldnt-be-cancelled-e26c40f142ad?source=collection_archive---------0-----------------------#2020-04-07">https://medium.com/androiddevelopers/coroutines-patterns-for-work-that-shouldnt-be-cancelled-e26c40f142ad?source=collection_archive---------0-----------------------#2020-04-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/9a13884a9a3c8f2045ce9634ff87f130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VyZlS3tgNPLjB1ZU"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="7547" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">协同程序中的取消和异常(第四部分)</h2></div><p id="dbe2" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在<a class="ae hu" rel="noopener" href="/androiddevelopers/cancellation-in-coroutines-aa6b90163629">协程系列</a>的<em class="ki">取消和异常的第2部分中，我们学习了取消不再需要的工作的重要性。在Android上，你可以使用Jetpack提供的<code class="du kj kk kl km b">CoroutineScope</code>:<code class="du kj kk kl km b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#(androidx.lifecycle.ViewModel).viewModelScope:kotlinx.coroutines.CoroutineScope" rel="noopener ugc nofollow" target="_blank">viewModelScope</a></code>或<code class="du kj kk kl km b"><a class="ae hu" href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#lifecyclescope" rel="noopener ugc nofollow" target="_blank">lifecycleScope</a></code>，当它们的作用域完成时，也就是当<code class="du kj kk kl km b">Activity/Fragment/Lifecycle</code>完成时，取消任何正在运行的工作。如果你正在创造你自己的<code class="du kj kk kl km b">CoroutineScope</code>，确保你把它绑在一个<code class="du kj kk kl km b">Job</code>上，需要的时候叫取消。</em></p><p id="0c73" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是，有些情况下，即使用户离开了屏幕，您也希望操作能够完成。因此，您<em class="ki">不希望</em>工作被取消(例如，写入数据库或向您的服务器发出某个网络请求)。</p><p id="45a8" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">请继续阅读，寻找实现这一目标的模式！</p><h1 id="ea66" class="kn ko hx bd kp kq kr ks kt ku kv kw kx jd ky je kz jg la jh lb jj lc jk ld le bi translated">协同程序还是工作管理器？</h1><p id="8cad" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">只要您的应用程序进程还活着，协程就会一直运行。如果你需要运行比进程持续时间更长的操作(例如，发送日志到你的远程服务器)，在Android上使用<a class="ae hu" href="https://developer.android.com/topic/libraries/architecture/workmanager" rel="noopener ugc nofollow" target="_blank">工作管理器</a>。WorkManager是用于预期在未来某个时间点执行的关键操作的库。</p><p id="0ef6" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">对当前流程中有效的操作使用协程，如果用户终止应用程序，则可以取消这些操作(例如，发出您想要缓存的网络请求)。触发这些行动的模式是什么？</p><h1 id="d1c5" class="kn ko hx bd kp kq kr ks kt ku kv kw kx jd ky je kz jg la jh lb jj lc jk ld le bi translated">协程最佳实践</h1><p id="ad4a" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">因为这种模式建立在其他协程最佳实践的基础上；让我们回顾一下:</p><h2 id="9525" class="lk ko hx bd kp ll lm ln kt lo lp lq kx jv lr ls kz jz lt lu lb kd lv lw ld lx bi translated"><strong class="ak"> 1。将调度程序注入到类中</strong></h2><p id="faad" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">当创建新的协程或调用<code class="du kj kk kl km b">withContext</code>时，不要硬编码它们。</p><p id="9aa9" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">✅ <em class="ki">的好处</em>:易于测试，因为你可以很容易地更换它们进行单元测试和仪器测试。</p><h2 id="6b0f" class="lk ko hx bd kp ll lm ln kt lo lp lq kx jv lr ls kz jz lt lu lb kd lv lw ld lx bi translated"><strong class="ak"> 2。ViewModel/Presenter层应该创建协程</strong></h2><p id="2fbb" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">如果是只针对UI的操作，那么UI层可以做到。如果您认为这在您的项目中是不可能的，很可能您没有遵循最佳实践#1(即，测试不注入<code class="du kj kk kl km b">Dispatchers</code>的虚拟机更加困难；在这种情况下，公开挂起函数是可行的)。</p><p id="c88f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">✅ <em class="ki">好处</em>:ui层应该是哑的，不直接触发任何业务逻辑。相反，将这一职责委托给视图模型/演示者层。测试UI层需要在Android中进行测试，这需要一个仿真器来运行。</p><h2 id="608b" class="lk ko hx bd kp ll lm ln kt lo lp lq kx jv lr ls kz jz lt lu lb kd lv lw ld lx bi translated"><strong class="ak"> 3。ViewModel/Presenter层下面的层应该公开挂起函数和流</strong></h2><p id="8328" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">如果你需要创建协程，使用<code class="du kj kk kl km b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html" rel="noopener ugc nofollow" target="_blank">coroutineScope</a></code>或者<code class="du kj kk kl km b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html" rel="noopener ugc nofollow" target="_blank">supervisorScope</a></code>。如果您需要它们遵循不同的范围，这就是本文的内容！继续读！</p><p id="569b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">✅ <em class="ki">好处</em>:调用者(通常是ViewModel层)可以控制这些层中工作的执行和生命周期，在需要的时候可以取消。</p><h1 id="d425" class="kn ko hx bd kp kq kr ks kt ku kv kw kx jd ky je kz jg la jh lb jj lc jk ld le bi translated">协程中不应该取消的操作</h1><p id="95f7" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">假设我们的应用程序中有一个视图模型和一个存储库，逻辑如下:</p><pre class="ly lz ma mb fd mc km md me aw mf bi"><span id="8590" class="lk ko hx km b fi mg mh l mi mj">class MyViewModel(private val repo: Repository) : ViewModel() {<br/>  fun callRepo() {<br/>    viewModelScope.launch {<br/>      repo.doWork()<br/>    }<br/>  }<br/>}</span><span id="1831" class="lk ko hx km b fi mk mh l mi mj">class Repository(private val ioDispatcher: CoroutineDispatcher) {<br/>  suspend fun doWork() {<br/>    withContext(ioDispatcher) {<br/>      doSomeOtherWork()<br/><strong class="km hy">      veryImportantOperation() // This shouldn’t be cancelled</strong><br/>    }<br/>  }<br/>}</span></pre><p id="f93a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们不希望<code class="du kj kk kl km b">veryImportantOperation()</code>被<code class="du kj kk kl km b">viewModelScope</code>控制，因为它随时可能被取消。我们希望这次行动能持续到<code class="du kj kk kl km b">viewModelScope</code>。我们如何实现这一目标？</p><p id="810c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">为此，<strong class="jo hy">在应用程序类中创建您自己的作用域，并调用由它启动的协程中的那些操作</strong>。该范围应该被注入到需要它的类中。</p><p id="8728" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">与我们稍后将看到的其他解决方案(如<code class="du kj kk kl km b">GlobalScope</code>)相比，创建您自己的<code class="du kj kk kl km b">CoroutineScope</code>的好处是您可以根据自己的意愿进行配置。需要一个<code class="du kj kk kl km b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/" rel="noopener ugc nofollow" target="_blank">CoroutineExceptionHandler</a></code>吗？你有自己的线程池作为<code class="du kj kk kl km b">Dispatcher</code>使用吗？将所有常见配置放在它的<code class="du kj kk kl km b">CoroutineContext</code>中！</p><p id="15e7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">您可以将其命名为<code class="du kj kk kl km b">applicationScope</code>，并且它必须包含一个<code class="du kj kk kl km b">SupervisorJob()</code>，这样协同程序中的故障就不会在层次结构中传播(如系列文章的<a class="ae hu" rel="noopener" href="/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c">第3部分所示):</a></p><pre class="ly lz ma mb fd mc km md me aw mf bi"><span id="ebc6" class="lk ko hx km b fi mg mh l mi mj">class MyApplication : Application() {<br/>  // No need to cancel this scope as it'll be torn down with the process<br/><strong class="km hy">  val applicationScope = CoroutineScope(SupervisorJob() + otherConfig)<br/></strong>}</span></pre><p id="f077" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们不需要取消这个作用域，因为只要应用程序进程还活着，我们就希望它保持活动状态，所以我们不持有对<code class="du kj kk kl km b">SupervisorJob</code>的引用。我们可以使用这个作用域来运行需要比调用作用域更长生命周期的协程。</p><blockquote class="ml"><p id="0fd4" class="mm mn hx bd mo mp mq mr ms mt mu kh dx translated">对于不应该取消的操作，从应用程序协同作用域创建的协同程序中调用它们</p></blockquote><p id="7298" class="pw-post-body-paragraph jm jn hx jo b jp mv iy jr js mw jb ju jv mx jx jy jz my kb kc kd mz kf kg kh ha bi translated"><strong class="jo hy">每当您创建一个新的存储库实例时，传入我们在上面</strong>创建的applicationScope。对于测试，查看下面的<em class="ki">测试</em>部分。</p><h2 id="5da8" class="lk ko hx bd kp ll lm ln kt lo lp lq kx jv lr ls kz jz lt lu lb kd lv lw ld lx bi translated">使用哪个协程生成器？</h2><p id="c956" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">根据<code class="du kj kk kl km b">veryImportantOperation</code>的行为，您需要使用launch或async来启动一个新的协程:</p><ul class=""><li id="b6a6" class="na nb hx jo b jp jq js jt jv nc jz nd kd ne kh nf ng nh ni bi translated">如果它需要返回结果，使用<code class="du kj kk kl km b"><strong class="jo hy">async</strong></code>并调用<code class="du kj kk kl km b"><strong class="jo hy">await</strong></code>等待它完成。</li><li id="eedc" class="na nb hx jo b jp nj js nk jv nl jz nm kd nn kh nf ng nh ni bi translated">如果没有，使用<code class="du kj kk kl km b"><strong class="jo hy">launch</strong></code>并等待它以<code class="du kj kk kl km b"><strong class="jo hy">join</strong></code>结束。请注意，正如系列文章的<a class="ae hu" rel="noopener" href="/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c">第3部分所解释的，您必须在启动块内部手动处理异常。</a></li></ul><p id="c124" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这就是使用<code class="du kj kk kl km b">launch</code>触发协程的方式:</p><pre class="ly lz ma mb fd mc km md me aw mf bi"><span id="5008" class="lk ko hx km b fi mg mh l mi mj">class Repository(<br/>  private val externalScope: CoroutineScope,<br/>  private val ioDispatcher: CoroutineDispatcher<br/>) {<br/>  suspend fun doWork() {<br/>    withContext(ioDispatcher) {<br/>      doSomeOtherWork()<br/><strong class="km hy">      externalScope.launch {<br/></strong>        // if this can throw an exception, wrap inside try/catch<br/>        // or rely on a CoroutineExceptionHandler installed<br/>        // in the externalScope's CoroutineScope<br/>        veryImportantOperation()<br/><strong class="km hy">      }.join()<br/></strong>    }<br/>  }<br/>}</span></pre><p id="df81" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">或者使用<code class="du kj kk kl km b">async</code>:</p><pre class="ly lz ma mb fd mc km md me aw mf bi"><span id="6c25" class="lk ko hx km b fi mg mh l mi mj">class Repository(<br/>  private val externalScope: CoroutineScope,<br/>  private val ioDispatcher: CoroutineDispatcher<br/>) {<br/>  suspend fun doWork(): Any { // Use a specific type in Result<br/>    withContext(ioDispatcher) {<br/>      doSomeOtherWork()<br/><strong class="km hy">      return externalScope.async {</strong><br/>        // Exceptions are exposed when calling await, they will be<br/>        // propagated in the coroutine that called doWork. Watch<br/>        // out! They will be ignored if the calling context cancels.<br/>        veryImportantOperation()<br/><strong class="km hy">      }.await()</strong><br/>    }<br/>  }<br/>}</span></pre><p id="11aa" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在任何情况下，ViewModel代码都不会改变，如上所述，即使<code class="du kj kk kl km b">viewModelScope</code>被破坏，使用<code class="du kj kk kl km b">externalScope</code>的工作也会继续运行。此外，<code class="du kj kk kl km b">doWork()</code>不会返回，直到<code class="du kj kk kl km b">veryImportantOperation()</code>像任何其他暂停调用一样完成。</p><h2 id="d07f" class="lk ko hx bd kp ll lm ln kt lo lp lq kx jv lr ls kz jz lt lu lb kd lv lw ld lx bi translated">简单点的怎么样？</h2><p id="8bae" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">另一个可以服务于某些用例的模式(可能是任何人都会想到的第一个解决方案)是在<code class="du kj kk kl km b">externalScope</code>的上下文中使用<code class="du kj kk kl km b">withContext</code>包装<code class="du kj kk kl km b">veryImportantOperation</code>，如下所示:</p><pre class="ly lz ma mb fd mc km md me aw mf bi"><span id="ad40" class="lk ko hx km b fi mg mh l mi mj">class Repository(<br/>  private val externalScope: CoroutineScope,<br/>  private val ioDispatcher: CoroutineDispatcher<br/>) {<br/>  suspend fun doWork() {<br/>    withContext(ioDispatcher) {<br/>      doSomeOtherWork()<br/><strong class="km hy">      withContext(externalScope.coroutineContext)</strong> {<br/>        veryImportantOperation()<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="9aab" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是，这种方法有一些需要注意的地方:</p><ul class=""><li id="68a0" class="na nb hx jo b jp jq js jt jv nc jz nd kd ne kh nf ng nh ni bi translated">如果调用<code class="du kj kk kl km b">doWork</code>的协程在<code class="du kj kk kl km b">veryImportantOperation</code>正在执行时被取消，它将一直执行到下一个取消点，而不是在<code class="du kj kk kl km b">veryImportantOperation</code>执行完之后。</li><li id="9c40" class="na nb hx jo b jp nj js nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><code class="du kj kk kl km b">CoroutineExceptionHandler</code>在<code class="du kj kk kl km b">withContext</code>中使用上下文时，不会像你预期的那样工作，因为异常会被再次抛出。</li></ul><h1 id="54db" class="kn ko hx bd kp kq kr ks kt ku kv kw kx jd ky je kz jg la jh lb jj lc jk ld le bi translated">测试</h1><p id="a0b3" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">由于我们需要注射<code class="du kj kk kl km b">Dispatcher</code>和<code class="du kj kk kl km b">CoroutineScope</code>两种药物，在这些情况下你应该注射什么？</p><figure class="ly lz ma mb fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es no"><img src="../Images/2617518bbe189b105425b3e9c3e311d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28VspziXz1sCGIKQqKhZQw.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">What to inject in testing</figcaption></figure><p id="7f48" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">🔖<em class="ki">图例</em> : <code class="du kj kk kl km b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-dispatcher/index.html" rel="noopener ugc nofollow" target="_blank">TestCoroutineDispatcher</a></code>，<code class="du kj kk kl km b"><a class="ae hu" href="https://github.com/android/plaid/blob/master/test_shared/src/main/java/io/plaidapp/test/shared/MainCoroutineRule.kt" rel="noopener ugc nofollow" target="_blank">MainCoroutineRule</a></code>，<code class="du kj kk kl km b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/-test-coroutine-scope/" rel="noopener ugc nofollow" target="_blank">TestCoroutineScope</a></code>，<code class="du kj kk kl km b"><a class="ae hu" href="https://github.com/google/iosched/blob/adssched/mobile/src/androidTest/java/com/google/samples/apps/iosched/tests/di/TestCoroutinesModule.kt#L36" rel="noopener ugc nofollow" target="_blank">AsyncTask.THREAD_POOL_EXECUTOR.asCoroutineDispatcher()</a></code></p><h1 id="a9d1" class="kn ko hx bd kp kq kr ks kt ku kv kw kx jd ky je kz jg la jh lb jj lc jk ld le bi translated">可供选择的事物</h1><p id="0ef2" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">还有其他方法可以用协程实现这种行为。然而，这些解决方案不能系统地应用于所有用例。让我们看看一些替代方案，以及为什么/什么时候应该/不应该使用它们。</p><h2 id="1008" class="lk ko hx bd kp ll lm ln kt lo lp lq kx jv lr ls kz jz lt lu lb kd lv lw ld lx bi translated">❌全球镜</h2><p id="932e" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">有多种原因让你不应该使用<code class="du kj kk kl km b"><a class="ae hu" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/" rel="noopener ugc nofollow" target="_blank">GlobalScope</a></code>:</p><ul class=""><li id="ed57" class="na nb hx jo b jp jq js jt jv nc jz nd kd ne kh nf ng nh ni bi translated"><strong class="jo hy">提升硬编码值</strong>。如果你直接使用<code class="du kj kk kl km b">GlobalScope</code>，硬编码<code class="du kj kk kl km b">Dispatchers</code>可能会很有诱惑力。那是一种不好的做法！</li><li id="fe21" class="na nb hx jo b jp nj js nk jv nl jz nm kd nn kh nf ng nh ni bi translated">这使得测试变得非常困难。由于您的代码将在不受控制的范围内执行，您将无法管理由它启动的工作的执行。</li><li id="f861" class="na nb hx jo b jp nj js nk jv nl jz nm kd nn kh nf ng nh ni bi translated">你不能像我们对<code class="du kj kk kl km b">applicationScope</code>所做的那样，在作用域中为所有协程建立一个公共的协程上下文。相反，你必须向所有由<code class="du kj kk kl km b">GlobalScope</code>启动的协程传递一个公共的<code class="du kj kk kl km b">CoroutineContext</code>。</li></ul><p id="0852" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy">建议:不要直接用。</strong></p><h2 id="6614" class="lk ko hx bd kp ll lm ln kt lo lp lq kx jv lr ls kz jz lt lu lb kd lv lw ld lx bi translated">Android中的❌进程生命周期所有者范围</h2><p id="dae5" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">在安卓系统中，<code class="du kj kk kl km b">androidx.lifecycle:lifecycle-process</code>库中有一个<code class="du kj kk kl km b">applicationScope</code>，可以通过<code class="du kj kk kl km b">ProcessLifecycleOwner.get().lifecycleScope</code>访问。</p><p id="707f" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这种情况下，你应该注入一个<code class="du kj kk kl km b">LifecycleOwner</code>而不是我们之前做的<code class="du kj kk kl km b">CoroutineScope</code>。在生产中，你可以通过<code class="du kj kk kl km b">ProcessLifecycleOwner.get()</code>和单元测试，你可以使用<code class="du kj kk kl km b">LifecycleRegistry</code>创建一个假的<code class="du kj kk kl km b">LifecycleOwner</code>。</p><p id="3c1a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">注意，这个作用域的默认<code class="du kj kk kl km b">CoroutineContext</code>使用了<code class="du kj kk kl km b">Dispatchers.Main.immediate</code>，这对于后台工作来说可能并不理想。与<code class="du kj kk kl km b">GlobalScope</code>一样，您必须将一个公共的<code class="du kj kk kl km b">CoroutineContext</code>传递给所有由<code class="du kj kk kl km b">GlobalScope</code>启动的协程。</p><p id="1399" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">由于上述原因，这种替代方法比仅仅在<code class="du kj kk kl km b">Application</code>类中创建一个<code class="du kj kk kl km b">CoroutineScope</code>需要更多的工作。此外，我个人不喜欢在ViewModel/Presenter下面的层中包含与Android生命周期相关的类，因为这些层应该是平台不可知的。</p><p id="70c7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy">建议:不要直接用</strong>。</p><h2 id="23b4" class="lk ko hx bd kp ll lm ln kt lo lp lq kx jv lr ls kz jz lt lu lb kd lv lw ld lx bi translated">⚠️免责声明</h2><p id="8114" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">如果你的<code class="du kj kk kl km b">applicationScope</code>的<code class="du kj kk kl km b">CoroutineContext</code>与<code class="du kj kk kl km b">GlobalScope</code>或<code class="du kj kk kl km b">ProcessLifecycleOwner.get().lifecycleScope</code>的相匹配，你<em class="ki">可以直接将它们赋值如下:</em></p><pre class="ly lz ma mb fd mc km md me aw mf bi"><span id="130e" class="lk ko hx km b fi mg mh l mi mj">class MyApplication : Application() {<br/>  <strong class="km hy">val applicationScope = GlobalScope</strong><br/>}</span></pre><p id="69d8" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">您仍然可以获得上述所有的<em class="ki">好处</em>，并且如果将来需要，您可以很容易地更改它。</p><h2 id="aa9c" class="lk ko hx bd kp ll lm ln kt lo lp lq kx jv lr ls kz jz lt lu lb kd lv lw ld lx bi translated">❌ ✅使用不可取消</h2><p id="5691" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">如系列文章的<a class="ae hu" rel="noopener" href="/androiddevelopers/cancellation-in-coroutines-aa6b90163629">第2部分所示，您可以使用<code class="du kj kk kl km b">withContext(NonCancellable)</code>来调用被取消的协程中的挂起函数。我们建议用它来清理可以挂起的代码。但是，你不应该滥用它。</a></p><p id="5269" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这样做是非常危险的，因为您会失去对协程执行的控制。的确，它产生了更简洁、更易读的代码，但这在未来可能导致的问题是不可预测的。</p><p id="098a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">其用法示例:</p><pre class="ly lz ma mb fd mc km md me aw mf bi"><span id="efb9" class="lk ko hx km b fi mg mh l mi mj">class Repository(<br/>  private val ioDispatcher: CoroutineDispatcher<br/>) {<br/>  suspend fun doWork() {<br/>    withContext(ioDispatcher) {<br/>      doSomeOtherWork()<br/> <strong class="km hy">     withContext(NonCancellable)</strong> {<br/>        veryImportantOperation()<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="01a7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">虽然这很有诱惑力，但你可能并不总是知道<code class="du kj kk kl km b">veryImportantOperation()</code>背后是什么:也许是一个外部库，也许是一个接口背后的实现，……会发生什么问题？</p><ul class=""><li id="1d6d" class="na nb hx jo b jp jq js jt jv nc jz nd kd ne kh nf ng nh ni bi translated">你不能在测试中停止这些操作。</li><li id="737e" class="na nb hx jo b jp nj js nk jv nl jz nm kd nn kh nf ng nh ni bi translated">使用<code class="du kj kk kl km b">delay</code>的无限循环将无法取消。</li><li id="8473" class="na nb hx jo b jp nj js nk jv nl jz nm kd nn kh nf ng nh ni bi translated">在它内部收集一个<code class="du kj kk kl km b">Flow</code>使得流从外部不可取消。</li><li id="c533" class="na nb hx jo b jp nj js nk jv nl jz nm kd nn kh nf ng nh ni bi">…</li></ul><p id="6fbc" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这些问题会导致细微的、非常难以调试的错误。</p><p id="9cdf" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated"><strong class="jo hy">建议:仅将它用于挂起清理代码。</strong></p></div><div class="ab cl np nq go nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ha hb hc hd he"><p id="3576" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">每当您需要在当前作用域之外运行一些工作时，我们建议在您的<code class="du kj kk kl km b">Application</code>类中创建一个自定义作用域，并在其中运行协程。避免使用<code class="du kj kk kl km b">GlobalScope</code>、<code class="du kj kk kl km b">ProcessLifecycleOwner</code>示波器和<code class="du kj kk kl km b">NonCancellable</code>进行此类工作。</p></div></div>    
</body>
</html>