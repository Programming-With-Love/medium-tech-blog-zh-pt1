<html>
<head>
<title>Server Rendering, Code Splitting, and Lazy Loading with React Router v4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React路由器v4的服务器渲染、代码分割和延迟加载</h1>
<blockquote>原文：<a href="https://medium.com/airbnb-engineering/server-rendering-code-splitting-and-lazy-loading-with-react-router-v4-bfe596a6af70?source=collection_archive---------0-----------------------#2018-01-09">https://medium.com/airbnb-engineering/server-rendering-code-splitting-and-lazy-loading-with-react-router-v4-bfe596a6af70?source=collection_archive---------0-----------------------#2018-01-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie if ig"><p id="d5fb" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">"祝那些尝试服务器渲染、代码分割应用的人好运."<br/> — <a class="jg jh ge" href="https://medium.com/u/162352c45b6e?source=post_page-----bfe596a6af70--------------------------------" rel="noopener" target="_blank">瑞安·弗洛伦斯</a>，React路由器的联合创始人</p></blockquote><p id="26d9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">接受挑战。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jl"><img src="../Images/12d03057e4b690930cef280283ff59fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvhtTXNk3MobRZf9v01aqQ.jpeg"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx">Nicole, one of our hosts, taking some guests on a <a class="ae kb" href="https://www.airbnb.com/experiences/184926" rel="noopener ugc nofollow" target="_blank">sunrise walk and picnic above Edinburgh</a></figcaption></figure><h1 id="8772" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">Airbnb服务器渲染的一些背景</h1><p id="cd73" class="pw-post-body-paragraph ih ii hh ik b il la in io ip lb ir is ji lc iv iw jj ld iz ja jk le jd je jf ha bi translated">从历史上看，Airbnb一直是一款Rails应用。几年前，这种情况开始改变，我们开始将Rails简单地用作数据层，所有渲染逻辑开始以React的形式迁移到JavaScript中。为了维护服务器渲染，我们创建并开源了<a class="ae kb" href="https://github.com/airbnb/hypernova" rel="noopener ugc nofollow" target="_blank"> Hypernova </a>，一个JavaScript渲染服务。</p><p id="9bbb" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">更进一步，我们在React Router v3中引入了客户端路由和基于路由的代码分割，作为我们<a class="ae kb" rel="noopener" href="/airbnb-engineering/rearchitecting-airbnbs-frontend-5e213efc24d2">架构改造</a>的一部分。这是实现平滑页面转换和较小初始页面加载的原因。</p><h2 id="c8b1" class="lf kd hh bd ke lg lh li ki lj lk ll km ji lm ln kq jj lo lp ku jk lq lr ky ls bi translated">输入React路由器v4</h2><p id="6ca5" class="pw-post-body-paragraph ih ii hh ik b il la in io ip lb ir is ji lc iv iw jj ld iz ja jk le jd je jf ha bi translated">服务器渲染+代码拆分归结为一个需求。为了让它们一起工作，你需要在渲染之前匹配你当前的路线。</p><p id="bca0" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated"><em class="ij">(这篇文章的其余部分代码相当多，如果你还不熟悉RRv4，请花些时间阅读优秀的</em> <a class="ae kb" href="https://reacttraining.com/react-router/web/guides/philosophy" rel="noopener ugc nofollow" target="_blank"> <em class="ij"> React路由器文档</em> </a> <em class="ij">。另外，看看</em> <a class="ae kb" href="https://webpack.js.org/guides/code-splitting/" rel="noopener ugc nofollow" target="_blank"> <em class="ij"> webpack代码分解文档</em> </a> <em class="ij">也无妨。)</em></p><p id="9b2b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">那么问题是反应路由器v4从集中式路由配置(具有用于异步加载的<code class="du lt lu lv lw b">getComponent</code>功能)切换到分散式版本。路线现在被内联定义，如下所示:</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="cbac" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">以这种方式定义路由意味着在实际呈现之前，您不会知道需要哪些路由/组件来呈现您的页面。为了演示为什么这是一个问题，假设我们正在异步加载<code class="du lt lu lv lw b">About</code>组件。</p><p id="ab0b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">当我们进行服务器呈现时，我们希望呈现所有的内容，因此会生成用于<code class="du lt lu lv lw b">About</code>组件的html并插入到DOM树中。但是在客户端，我们不知道匹配<code class="du lt lu lv lw b">/about</code>路径，也不知道加载<code class="du lt lu lv lw b">About</code>组件，直到我们已经进入渲染周期。这将导致客户端/服务器不匹配错误，因为没有加载<code class="du lt lu lv lw b">About</code>组件，客户端不会创建与服务器相同的html。这也可能意味着内容的闪烁和渲染的浪费，意味着用户体验的恶化。</p><h1 id="19a5" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">重新集中路线</h1><p id="100f" class="pw-post-body-paragraph ih ii hh ik b il la in io ip lb ir is ji lc iv iw jj ld iz ja jk le jd je jf ha bi translated">为了解决内联路由的独特问题，他们创建了<code class="du lt lu lv lw b"><a class="ae kb" href="https://github.com/ReactTraining/react-router/tree/master/packages/react-router-config" rel="noopener ugc nofollow" target="_blank">react-router-config</a></code>。这让你可以继续在一个集中的位置定义你的路线，并在触发你的初始渲染之前匹配它们。使用该库，我们的路由定义可能如下所示:</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="lx ly l"/></div><figcaption class="jx jy et er es jz ka bd b be z dx">This is the basic route structure we’ll be using in the rest of the post.</figcaption></figure><h1 id="f94a" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">分散我们重新集中的路线</h1><p id="e04c" class="pw-post-body-paragraph ih ii hh ik b il la in io ip lb ir is ji lc iv iw jj ld iz ja jk le jd je jf ha bi translated">(我知道你在想什么……)</p><p id="a11d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">使用<code class="du lt lu lv lw b">react-router-config</code>很棒，但是还有一点工作要做。<code class="du lt lu lv lw b">react-router-config</code>似乎不支持异步加载组件，要求子路由过于明确。请注意，所有路径值都被定义为完整路径。</p><p id="92f8" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">这会变得有点笨拙，并且限制了重用。为了解决这个问题，我们实现了一个映射功能，允许组件定义子路由。</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="cebd" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">这样做在开发过程中给了我们更多的自由。孙管线不再需要知道其完整路径，并且可以在任何位置插入到中心配置中，以创建深度嵌套的管线。</p><p id="e7d2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">这是非常强大的，尤其是在大型代码库中。路由可以在多个位置重用，并且组件逻辑可以是路由不可知的，因此它们的可重用性也增加了。这使得我们目前向大型单页应用(SPA)的过渡成为可能，因为我们可以在不增加核心流程的情况下增加额外的路线。随着时间的推移，我们的SPA会包含更多的产品页面，因此我们可以放心，任何单个页面都只包含所需的内容。</p><h1 id="c4ea" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">定义异步路由</h1><p id="2451" class="pw-post-body-paragraph ih ii hh ik b il la in io ip lb ir is ji lc iv iw jj ld iz ja jk le jd je jf ha bi translated">我们需要确保所有的组件，无论用户点击哪个路径，在我们调用渲染之前都被加载。</p><p id="6082" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">首先，我们将创建一个异步组件定义，然后我们将更改我们的孙路由以使用新组件。<strong class="ik hi">注意静态加载函数</strong>，稍后将使用它来确保我们准备好渲染。</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="39b4" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">此外，让我们更新我们的孙子路线，以利用新的助手函数。</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="lx ly l"/></div></figure><h2 id="a714" class="lf kd hh bd ke lg lh li ki lj lk ll km ji lm ln kq jj lo lp ku jk lq lr ky ls bi translated">确保路线准备就绪</h2><p id="e5b9" class="pw-post-body-paragraph ih ii hh ik b il la in io ip lb ir is ji lc iv iw jj ld iz ja jk le jd je jf ha bi translated">现在我们导出一个路由配置，它包含一个定义静态<code class="du lt lu lv lw b">load</code>函数的路由组件。在渲染之前剩下要做的就是确保所有的东西都被加载了。</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="lx ly l"/></div></figure><h1 id="9553" class="kc kd hh bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">把所有的放在一起</h1><p id="99ac" class="pw-post-body-paragraph ih ii hh ik b il la in io ip lb ir is ji lc iv iw jj ld iz ja jk le jd je jf ha bi translated">现在一切就绪，我们终于准备好呈现我们的应用程序了。这是所有东西联系在一起时的样子(减去助手函数<code class="du lt lu lv lw b">ensureReady</code>、<code class="du lt lu lv lw b">generateAsyncComponent</code>和<code class="du lt lu lv lw b">convertCustomRouteConfig</code>的定义)</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="lx ly l"/></div></figure><h2 id="6afb" class="lf kd hh bd ke lg lh li ki lj lk ll km ji lm ln kq jj lo lp ku jk lq lr ky ls bi translated">演示！</h2><p id="58f7" class="pw-post-body-paragraph ih ii hh ik b il la in io ip lb ir is ji lc iv iw jj ld iz ja jk le jd je jf ha bi translated">这篇文章代码有点多，我想看到所有这些都在运行会有所帮助。查看<a class="ae kb" href="https://github.com/gdborton/rrv4-ssr-and-code-splitting" rel="noopener ugc nofollow" target="_blank">演示库</a>来查看所有的东西，并随意探索代码！</p><h2 id="fff1" class="lf kd hh bd ke lg lh li ki lj lk ll km ji lm ln kq jj lo lp ku jk lq lr ky ls bi translated"><em class="lz">下一步是什么</em></h2><p id="fa32" class="pw-post-body-paragraph ih ii hh ik b il la in io ip lb ir is ji lc iv iw jj ld iz ja jk le jd je jf ha bi translated">我们一直在寻找改进的方法，包括我们的核心产品和我们所依赖的开源库。</p><ul class=""><li id="f9b8" class="ma mb hh ik b il im ip iq ji mc jj md jk me jf mf mg mh mi bi translated">向<code class="du lt lu lv lw b">react-router-config</code>提出问题/请求，希望这一过程对其他人来说更加简单。</li><li id="1133" class="ma mb hh ik b il mj ip mk ji ml jj mm jk mn jf mf mg mh mi bi translated">随着越来越多的页面被拉进我们的<a class="ae kb" rel="noopener" href="/airbnb-engineering/rearchitecting-airbnbs-frontend-5e213efc24d2"> SPA </a>，研究如何最小化水合大小。</li></ul></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><p id="48a7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated"><em class="ij">我们一直在寻找有才华、有好奇心的人来</em> <a class="ae kb" href="https://www.airbnb.com/careers/departments/engineering" rel="noopener ugc nofollow" target="_blank"> <em class="ij">加入团队</em> </a> <em class="ij">。或者，如果你只是想谈谈工作，可以随时在twitter上联系我</em><a class="ae kb" href="https://twitter.com/garyborton" rel="noopener ugc nofollow" target="_blank"><em class="ij">@ Gary borton</em></a><em class="ij">。</em></p></div><div class="ab cl mo mp go mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ha hb hc hd he"><h2 id="f718" class="lf kd hh bd ke lg lh li ki lj lk ll km ji lm ln kq jj lo lp ku jk lq lr ky ls bi translated">* *关于导入的说明()</h2><p id="a96b" class="pw-post-body-paragraph ih ii hh ik b il la in io ip lb ir is ji lc iv iw jj ld iz ja jk le jd je jf ha bi translated">您在上面代码中看到的<code class="du lt lu lv lw b">import()</code>是相对较新的<a class="ae kb" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank">动态导入语法</a>(目前是阶段3)。这个新语法意味着支持ES模块的异步加载。我们正在利用它来替换我们源代码中的webpack的<code class="du lt lu lv lw b">require.ensure</code>调用。</p><p id="7cfc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">我们已经发布了一些特定于webpack的babel转换来帮助解决这个问题。<a class="ae kb" href="https://github.com/airbnb/babel-plugin-dynamic-import-webpack" rel="noopener ugc nofollow" target="_blank">动态导入webpack </a>和<a class="ae kb" href="https://github.com/airbnb/babel-plugin-dynamic-import-node" rel="noopener ugc nofollow" target="_blank">动态导入节点</a>。</p><p id="3580" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">他们可以将您的大额<code class="du lt lu lv lw b">require.ensure</code>电话转换成:</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="lx ly l"/></div></figure><p id="3b33" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is ji iu iv iw jj iy iz ja jk jc jd je jf ha bi translated">对此:</p><figure class="jm jn jo jp fd jq"><div class="bz dy l di"><div class="lx ly l"/></div></figure></div></div>    
</body>
</html>