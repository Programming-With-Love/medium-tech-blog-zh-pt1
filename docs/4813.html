<html>
<head>
<title>Mocking is not rocket science: Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嘲笑不是火箭科学:基础</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/mocking-is-not-rocket-science-basics-ae55d0aadf2b?source=collection_archive---------2-----------------------#2018-01-10">https://blog.kotlin-academy.com/mocking-is-not-rocket-science-basics-ae55d0aadf2b?source=collection_archive---------2-----------------------#2018-01-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8f15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">模仿是一种使测试代码可读和可维护的技术。在接下来的三篇文章中，我将展示<a class="ae ki" href="http://mockk.io" rel="noopener ugc nofollow" target="_blank">mock</a>库的基础、特性和古怪之处。这是一个新的开源库(<a class="ae ki" href="https://github.com/oleksiyp/mockk" rel="noopener ugc nofollow" target="_blank"> github repository </a>)，致力于让Kotlin中的嘲讽变得更好。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/f3fa450bb7a96613717b84208d415612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rpMZL8Xn7npEVfNCf2aHQw.jpeg"/></div></div></figure><blockquote class="kv kw kx"><p id="ed6c" class="jk jl ky jm b jn jo jp jq jr js jt ju kz jw jx jy la ka kb kc lb ke kf kg kh ig bi translated">本文使用的技巧是<strong class="jm io">戳</strong>，而不是<strong class="jm io">嘲讽</strong>。这是两个相似但经常混淆的术语。点击阅读更多相关信息<a class="ae ki" href="https://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="a270" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用stubs或mocks的主要目的是将测试一个组件(称为被测系统)与它们依赖的组件隔离开来。</p><blockquote class="lc"><p id="1c16" class="ld le in bd lf lg lh li lj lk ll kh dk translated">被测系统(SUT)是指被测试是否正常工作的系统。</p><p id="5340" class="ld le in bd lf lg lh li lj lk ll kh dk translated">依赖组件(DOC)，是合作者，是SUT履行其职责所需的组件</p></blockquote><p id="2280" class="pw-post-body-paragraph jk jl in jm b jn lm jp jq jr ln jt ju jv lo jx jy jz lp kb kc kd lq kf kg kh ig bi translated">基本思想是将SUT连接到模拟组件，而不是依赖组件。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/b67728c2c956d7963ce1d4d890a636b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*gPK6zTtnVNBmI1hee7ZSZQ.png"/></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk">Visualization of System Under Test with two mocked Depended On Component</figcaption></figure><p id="e1cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者在科特林:</p><pre class="kk kl km kn gt lw lx ly lz aw ma bi"><span id="f4e6" class="mb mc in lx b gy md me l mf mg"><strong class="lx io">class </strong>Dependency1(<strong class="lx io">val value1</strong>: Int)<br/><strong class="lx io">class </strong>Dependency2(<strong class="lx io">val value2</strong>: String)<br/><br/><strong class="lx io">class </strong>SystemUnderTest(<br/>        <strong class="lx io">val dependency1</strong>: Dependency1,<br/>        <strong class="lx io">val dependency2</strong>: Dependency2<br/>)</span></pre><p id="1ac9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，现在我们想给SUT增加以下功能:</p><pre class="kk kl km kn gt lw lx ly lz aw ma bi"><span id="aa81" class="mb mc in lx b gy md me l mf mg"><strong class="lx io">fun </strong>calculate() = <br/>        <strong class="lx io">dependency1</strong>.<strong class="lx io">value1 </strong>+ <strong class="lx io">dependency2</strong>.<strong class="lx io">value2</strong>.<em class="ky">toInt</em>()</span></pre><p id="7ec3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并测试它:</p><pre class="kk kl km kn gt lw lx ly lz aw ma bi"><span id="b0ea" class="mb mc in lx b gy md me l mf mg">@Test<br/><strong class="lx io">fun </strong>calculateAddsValues() {<br/>    <strong class="lx io">val </strong>doc1 = <em class="ky">mockk</em>&lt;Dependency1&gt;()<br/>    <strong class="lx io">val </strong>doc2<strong class="lx io"> </strong>= <em class="ky">mockk</em>&lt;Dependency2&gt;()<br/><br/>    <em class="ky">every </em><strong class="lx io">{ </strong>doc1.<strong class="lx io">value1 } </strong>returns 5<br/>    <em class="ky">every </em><strong class="lx io">{ </strong>doc2.<strong class="lx io">value2 } </strong>returns <strong class="lx io">"6"<br/><br/>    val </strong>sut = SystemUnderTest(doc1, doc2)<br/><br/>    <em class="ky">assertEquals</em>(11, sut.calculate())<br/>}</span></pre><p id="18bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我解释每一行。</p><pre class="kk kl km kn gt lw lx ly lz aw ma bi"><span id="1ba3" class="mb mc in lx b gy md me l mf mg"><strong class="lx io">val </strong>doc1 = <em class="ky">mockk</em>&lt;Dependency1&gt;()</span></pre><p id="7d79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建一个类型为<code class="fe mh mi mj lx b">Dependency1</code>的模拟对象。此对象是SUT的第一个依赖组件的替换。</p><pre class="kk kl km kn gt lw lx ly lz aw ma bi"><span id="b8de" class="mb mc in lx b gy md me l mf mg"><strong class="lx io">val </strong>doc2<strong class="lx io"> </strong>= <em class="ky">mockk</em>&lt;Dependency2&gt;()</span></pre><p id="7eb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本相同，只是针对<code class="fe mh mi mj lx b">Dependency2</code> DOC。</p><pre class="kk kl km kn gt lw lx ly lz aw ma bi"><span id="8a58" class="mb mc in lx b gy md me l mf mg"><em class="ky">every </em><strong class="lx io">{ </strong>doc1.<strong class="lx io">value1 } </strong>returns 5</span></pre><p id="b5e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为<code class="fe mh mi mj lx b">value1</code>属性的getter提供预期的行为。这意味着我们期望当getter被调用时，返回值是<code class="fe mh mi mj lx b">5</code>。</p><pre class="kk kl km kn gt lw lx ly lz aw ma bi"><span id="b8c4" class="mb mc in lx b gy md me l mf mg"><em class="ky">every </em><strong class="lx io">{ </strong>doc2.<strong class="lx io">value2 } </strong>returns <strong class="lx io">"6"</strong></span></pre><p id="6394" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样适用于<code class="fe mh mi mj lx b">doc2</code>属地。我们期望<code class="fe mh mi mj lx b">value2</code> <strong class="jm io"> </strong>返回字符串<code class="fe mh mi mj lx b">“6”</code>。</p><pre class="kk kl km kn gt lw lx ly lz aw ma bi"><span id="4480" class="mb mc in lx b gy md me l mf mg"><strong class="lx io">val </strong>sut = SystemUnderTest(doc1, doc2)</span></pre><p id="3e30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用我们的模拟文件初始化SUT。</p><pre class="kk kl km kn gt lw lx ly lz aw ma bi"><span id="fb47" class="mb mc in lx b gy md me l mf mg"><em class="ky">assertEquals</em>(11, sut.calculate())</span></pre><p id="70e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在执行<code class="fe mh mi mj lx b">calculate</code>功能时，被模拟的组件被调用，预期的行为被执行。之后，我们验证执行具有依赖关系的函数的结果是正确的。</p><p id="95ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上就是这样。我们用mock替换了依赖关系。</p><p id="8a98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这为什么有价值？在这个简化的例子中，这一点并不明显。毕竟，仅仅提供依赖组件也会考验我们的SUT:</p><pre class="kk kl km kn gt lw lx ly lz aw ma bi"><span id="115e" class="mb mc in lx b gy md me l mf mg">@Test<br/><strong class="lx io">fun </strong>calculateAddsValues() {<br/>    <strong class="lx io">val </strong>doc1 = Dependency1(5)<br/>    <strong class="lx io">val </strong>doc2 = Dependency2(<strong class="lx io">"6"</strong>)<br/><br/>    <strong class="lx io">val </strong>sut = SystemUnderTest(doc1, doc2)<br/><br/>    <em class="ky">assertEquals</em>(11, sut.calculate())<br/>}</span></pre><p id="7ca2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是真的。当依赖组件依赖于复杂配置和其他组件时，好处就会显现。通常情况下就是这样。一切都是有线的，需要其他依赖。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/14ea8d65a76110d4f040e88267196d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkKL7KJbqh4y7y4FIMeiRw.jpeg"/></div></div></figure><p id="1d90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是最基本的。下一篇文章将介绍如何设置依赖于组件的预期行为和行为验证。</p></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><p id="e20b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一篇文章:</p><div class="mr ms gp gr mt mu"><a rel="noopener  ugc nofollow" target="_blank" href="/mocking-is-not-rocket-science-expected-behavior-and-behavior-verification-3862dd0e0f03"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd io gy z fp mz fr fs na fu fw im bi translated">嘲讽不是火箭科学:预期行为和行为验证</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">在上一篇文章中，我描述了嘲讽的基础。现在让我来概述一下MockK的基本特性。</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">blog.kotlin-academy.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni kt mu"/></div></div></a></div></div><div class="ab cl mk ml hr mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ig ih ii ij ik"><p id="585d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">拍手</strong>说“谢谢”并帮助他人找到这篇文章。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="https://kt.academy/article"><div class="gh gi nj"><img src="../Images/7cc3e53c80b722128adb3c22f527646e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PRlebsP2nkBq-WA8pLJew.png"/></div></a></figure><p id="bec0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于用MockK进行单元测试的下一篇文章将在下周发表。不要错过它。订阅出版物和作者频道。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi nk"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure></div></div>    
</body>
</html>