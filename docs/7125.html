<html>
<head>
<title>Dude, Where’s My char[]?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哥们，我的char[]呢？</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/dude-wheres-my-char-f1eb223f8800?source=collection_archive---------1-----------------------#2015-07-20">https://medium.com/square-corner-blog/dude-wheres-my-char-f1eb223f8800?source=collection_archive---------1-----------------------#2015-07-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="bc9a" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">在Android M中查找String.value</h2></div><p id="f7cc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">作者写的</em><a class="ae jt" href="http://twitter.com/Piwai" rel="noopener ugc nofollow" target="_blank"><em class="js"/></a><em class="js">。</em></p><blockquote class="ju"><p id="4553" class="jv jw hh bd jx jy jz ka kb kc kd jr dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jt" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="3164" class="pw-post-body-paragraph iw ix hh iy b iz ke ii jb jc kf il je jf kg jh ji jj kh jl jm jn ki jp jq jr ha bi translated"><em class="js">这篇文章最初是内部邮件列表上的一个帖子，我认为Square之外的人也会感兴趣。</em></p><p id="5ded" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当Android M preview 2发布时，我开始收到解析堆转储时<a class="ae jt" href="http://squ.re/leakcanary" rel="noopener ugc nofollow" target="_blank"> LeakCanary </a>崩溃的报告。LeakCanary进入一个String对象的char数组来读取一个线程名，但是在Android M中这个char数组已经不存在了。</p><h1 id="f2ed" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">我们挖吧</h1><p id="026e" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">下面是Android M之前String.java的结构:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="29bf" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">public</strong> <strong class="ll hi">final</strong> <strong class="ll hi">class</strong> <strong class="ll hi">String</strong> <strong class="ll hi">{</strong><br/>  <strong class="ll hi">private</strong> <strong class="ll hi">final</strong> <strong class="ll hi">char</strong> value<strong class="ll hi">[];</strong><br/>  <strong class="ll hi">private</strong> <strong class="ll hi">final</strong> <strong class="ll hi">int</strong> offset<strong class="ll hi">;</strong><br/>  <strong class="ll hi">private</strong> <strong class="ll hi">final</strong> <strong class="ll hi">int</strong> count<strong class="ll hi">;</strong><br/>  <strong class="ll hi">private</strong> <strong class="ll hi">int</strong> hash<strong class="ll hi">;</strong><br/>  <em class="js">// ...</em><br/><strong class="ll hi">}</strong></span></pre><p id="a774" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是String.java在M:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="2817" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">public</strong> <strong class="ll hi">final</strong> <strong class="ll hi">class</strong> <strong class="ll hi">String</strong> <strong class="ll hi">{</strong><br/>  <strong class="ll hi">private</strong> <strong class="ll hi">final</strong> <strong class="ll hi">int</strong> count<strong class="ll hi">;</strong><br/>  <strong class="ll hi">private</strong> <strong class="ll hi">int</strong> hash<strong class="ll hi">;</strong><br/>  <em class="js">// ...</em><br/><strong class="ll hi">}</strong></span></pre><p id="323d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">char[]去哪了？为了了解更多，让我们看看当我们连接两个字符串时会发生什么:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="fd0a" class="lp kk hh ll b fi lq lr l ls lt">String baguette <strong class="ll hi">=</strong> flour <strong class="ll hi">+</strong> love<strong class="ll hi">;</strong></span></pre><p id="de20" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">换句话说:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="a500" class="lp kk hh ll b fi lq lr l ls lt">String baguette <strong class="ll hi">=</strong> flour<strong class="ll hi">.</strong>concat<strong class="ll hi">(</strong>love<strong class="ll hi">);</strong></span></pre><p id="3696" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">String.concat()现在是一个本机方法:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="eb53" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">public</strong> <strong class="ll hi">final</strong> <strong class="ll hi">class</strong> <strong class="ll hi">String</strong> <strong class="ll hi">{</strong><br/>  <strong class="ll hi">public</strong> <strong class="ll hi">native</strong> String <strong class="ll hi">concat(</strong>String string<strong class="ll hi">);</strong><br/>  <em class="js">// ...</em><br/><strong class="ll hi">}</strong></span></pre><h1 id="4123" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">走向本土化</h1><p id="84ae" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">concat()在<a class="ae jt" href="https://android.googlesource.com/platform/art/+/android-m-preview-1/runtime/native/java_lang_String.cc" rel="noopener ugc nofollow" target="_blank"> String.cc </a>中实现:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="4055" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">static</strong> jstring <strong class="ll hi">String_concat</strong>(JNIEnv<strong class="ll hi">*</strong> env, jobject java_this, jobject java_string_arg) {<br/>  ScopedFastNativeObjectAccess soa(env);<br/>  <strong class="ll hi">if</strong> (UNLIKELY(java_string_arg <strong class="ll hi">==</strong> <strong class="ll hi">nullptr</strong>)) {<br/>    ThrowNullPointerException("string arg == null");<br/>    <strong class="ll hi">return</strong> <strong class="ll hi">nullptr</strong>;<br/>  }<br/>  StackHandleScope<strong class="ll hi">&lt;</strong>2<strong class="ll hi">&gt;</strong> hs(soa.Self());<br/>  Handle<strong class="ll hi">&lt;</strong>mirror<strong class="ll hi">::</strong>String<strong class="ll hi">&gt;</strong> string_this(hs.NewHandle(soa.Decode<strong class="ll hi">&lt;</strong>mirror<strong class="ll hi">::</strong>String<strong class="ll hi">*&gt;</strong>(java_this)));<br/>  Handle<strong class="ll hi">&lt;</strong>mirror<strong class="ll hi">::</strong>String<strong class="ll hi">&gt;</strong> string_arg(hs.NewHandle(soa.Decode<strong class="ll hi">&lt;</strong>mirror<strong class="ll hi">::</strong>String<strong class="ll hi">*&gt;</strong>(java_string_arg)));<br/>  <strong class="ll hi">int32_t</strong> length_this <strong class="ll hi">=</strong> string_this<strong class="ll hi">-&gt;</strong>GetLength();<br/>  <strong class="ll hi">int32_t</strong> length_arg <strong class="ll hi">=</strong> string_arg<strong class="ll hi">-&gt;</strong>GetLength();<br/>  <strong class="ll hi">if</strong> (length_arg <strong class="ll hi">&gt;</strong> 0 <strong class="ll hi">&amp;&amp;</strong> length_this <strong class="ll hi">&gt;</strong> 0) {<br/>    mirror<strong class="ll hi">::</strong>String<strong class="ll hi">*</strong> result <strong class="ll hi">=</strong> mirror<strong class="ll hi">::</strong>String<strong class="ll hi">::</strong>AllocFromStrings(soa.Self(), string_this, string_arg);<br/>    <strong class="ll hi">return</strong> soa.AddLocalReference<strong class="ll hi">&lt;</strong>jstring<strong class="ll hi">&gt;</strong>(result);<br/>  }<br/>  jobject string_original <strong class="ll hi">=</strong> (length_this <strong class="ll hi">==</strong> 0) <strong class="ll hi">?</strong> java_string_arg : java_this;<br/>  <strong class="ll hi">return</strong> <strong class="ll hi">reinterpret_cast&lt;</strong>jstring<strong class="ll hi">&gt;</strong>(string_original);<br/>}</span></pre><p id="888d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">实际的串联是在<a class="ae jt" href="https://android.googlesource.com/platform/art/+/android-m-preview-1/runtime/mirror/string.cc" rel="noopener ugc nofollow" target="_blank"> mirror::String.cc </a>中的mirror::String::AllocFromStrings中完成的:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="bde7" class="lp kk hh ll b fi lq lr l ls lt">String<strong class="ll hi">*</strong> String<strong class="ll hi">::</strong>AllocFromStrings(Thread<strong class="ll hi">*</strong> self, Handle<strong class="ll hi">&lt;</strong>String<strong class="ll hi">&gt;</strong> string, Handle<strong class="ll hi">&lt;</strong>String<strong class="ll hi">&gt;</strong> string2) {<br/>  <strong class="ll hi">int32_t</strong> length <strong class="ll hi">=</strong> string<strong class="ll hi">-&gt;</strong>GetLength();<br/>  <strong class="ll hi">int32_t</strong> length2 <strong class="ll hi">=</strong> string2<strong class="ll hi">-&gt;</strong>GetLength();<br/>  gc<strong class="ll hi">::</strong>AllocatorType allocator_type <strong class="ll hi">=</strong> Runtime<strong class="ll hi">::</strong>Current()<strong class="ll hi">-&gt;</strong>GetHeap()<strong class="ll hi">-&gt;</strong>GetCurrentAllocator();<br/>  SetStringCountVisitor <strong class="ll hi">visitor</strong>(length <strong class="ll hi">+</strong> length2);<br/>  String<strong class="ll hi">*</strong> new_string <strong class="ll hi">=</strong> Alloc<strong class="ll hi">&lt;</strong>true<strong class="ll hi">&gt;</strong>(self, length <strong class="ll hi">+</strong> length2, allocator_type, visitor);<br/>  <strong class="ll hi">if</strong> (UNLIKELY(new_string <strong class="ll hi">==</strong> <strong class="ll hi">nullptr</strong>)) {<br/>    <strong class="ll hi">return</strong> <strong class="ll hi">nullptr</strong>;<br/>  }<br/>  <strong class="ll hi">uint16_t*</strong> new_value <strong class="ll hi">=</strong> new_string<strong class="ll hi">-&gt;</strong>GetValue();<br/>  memcpy(new_value, string<strong class="ll hi">-&gt;</strong>GetValue(), length <strong class="ll hi">*</strong> <strong class="ll hi">sizeof</strong>(<strong class="ll hi">uint16_t</strong>));<br/>  memcpy(new_value <strong class="ll hi">+</strong> length, string2<strong class="ll hi">-&gt;</strong>GetValue(), length2 <strong class="ll hi">*</strong> <strong class="ll hi">sizeof</strong>(<strong class="ll hi">uint16_t</strong>));<br/>  <strong class="ll hi">return</strong> new_string;<br/>}</span></pre><p id="3e1c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，它使用<a class="ae jt" href="https://android.googlesource.com/platform/art/+/android-m-preview-1/runtime/mirror/string-inl.h" rel="noopener ugc nofollow" target="_blank"> string-inl.h </a>中的Alloc分配一个大小合适的新字符串:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="bc2a" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">template</strong> <strong class="ll hi">&lt;bool</strong> kIsInstrumented, <strong class="ll hi">typename</strong> PreFenceVisitor<strong class="ll hi">&gt;</strong><br/><strong class="ll hi">inline</strong> String<strong class="ll hi">*</strong> String<strong class="ll hi">::</strong>Alloc(Thread<strong class="ll hi">*</strong> self, <strong class="ll hi">int32_t</strong> utf16_length, gc<strong class="ll hi">::</strong>AllocatorType allocator_type,<br/>                             <strong class="ll hi">const</strong> PreFenceVisitor<strong class="ll hi">&amp;</strong> pre_fence_visitor) {<br/>  <strong class="ll hi">size_t</strong> header_size <strong class="ll hi">=</strong> <strong class="ll hi">sizeof</strong>(String);<br/>  <strong class="ll hi">size_t</strong> data_size <strong class="ll hi">=</strong> <strong class="ll hi">sizeof</strong>(<strong class="ll hi">uint16_t</strong>) <strong class="ll hi">*</strong> utf16_length;<br/>  <strong class="ll hi">size_t</strong> size <strong class="ll hi">=</strong> header_size <strong class="ll hi">+</strong> data_size;<br/>  Class<strong class="ll hi">*</strong> string_class <strong class="ll hi">=</strong> GetJavaLangString();<br/>  <em class="js">// Check for overflow and throw OutOfMemoryError if this was an unreasonable request.</em><br/>  <strong class="ll hi">if</strong> (UNLIKELY(size <strong class="ll hi">&lt;</strong> data_size)) {<br/>    self<strong class="ll hi">-&gt;</strong>ThrowOutOfMemoryError(StringPrintf("%s of length %d would overflow",<br/>                                             PrettyDescriptor(string_class).c_str(),<br/>                                             utf16_length).c_str());<br/>    <strong class="ll hi">return</strong> <strong class="ll hi">nullptr</strong>;<br/>  }<br/>  gc<strong class="ll hi">::</strong>Heap<strong class="ll hi">*</strong> heap <strong class="ll hi">=</strong> Runtime<strong class="ll hi">::</strong>Current()<strong class="ll hi">-&gt;</strong>GetHeap();<br/>  <strong class="ll hi">return</strong> down_cast<strong class="ll hi">&lt;</strong>String<strong class="ll hi">*&gt;</strong>(<br/>      heap<strong class="ll hi">-&gt;</strong>AllocObjectWithAllocator<strong class="ll hi">&lt;</strong>kIsInstrumented, true<strong class="ll hi">&gt;</strong>(self, string_class, size,<br/>                                                            allocator_type, pre_fence_visitor));<br/>}</span></pre><ul class=""><li id="9cfa" class="lu lv hh iy b iz ja jc jd jf lw jj lx jn ly jr lz ma mb mc bi translated">这将分配一个大小为header_size + data_size的对象</li><li id="7b29" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">header_size是<a class="ae jt" href="https://android.googlesource.com/platform/art/+/android-m-preview-1/runtime/mirror/string.h" rel="noopener ugc nofollow" target="_blank"> mirror::String.h </a>中mirror::String的大小:</li><li id="2f59" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">int32_t计数_</li><li id="ffe5" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">uint32_t哈希代码_</li><li id="1837" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">uint16_t值_[0]</li><li id="dd58" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">data_size实际上是总字符数乘以一个字符的大小(uint16_t)。</li></ul><p id="cc08" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这意味着字符数组被内联在字符串对象中。</p><p id="b517" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">还要注意零长度数组:uint16_t value_[0]。</p><p id="332e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们继续读mirror::String::AllocFromStrings:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="f2b8" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">uint16_t*</strong> new_value <strong class="ll hi">=</strong> new_string<strong class="ll hi">-&gt;</strong>GetValue();<br/>  memcpy(new_value, string<strong class="ll hi">-&gt;</strong>GetValue(), length <strong class="ll hi">*</strong> <strong class="ll hi">sizeof</strong>(<strong class="ll hi">uint16_t</strong>));<br/>  memcpy(new_value <strong class="ll hi">+</strong> length, string2<strong class="ll hi">-&gt;</strong>GetValue(), length2 <strong class="ll hi">*</strong> <strong class="ll hi">sizeof</strong>(<strong class="ll hi">uint16_t</strong>));</span></pre><p id="a19f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">其中GetValue()在<a class="ae jt" href="https://android.googlesource.com/platform/art/+/android-m-preview-1/runtime/mirror/string.h" rel="noopener ugc nofollow" target="_blank"> mirror::String.h </a>中定义，并返回我们上面注意到的uint16_t value_[0]的地址:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="08ae" class="lp kk hh ll b fi lq lr l ls lt"><strong class="ll hi">uint16_t*</strong> <strong class="ll hi">GetValue</strong>() SHARED_LOCKS_REQUIRED(Locks<strong class="ll hi">::</strong>mutator_lock_) {<br/>  <strong class="ll hi">return</strong> <strong class="ll hi">&amp;</strong>value_[0];<br/>}</span></pre><p id="ee98" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是从一个数组的内存地址到另一个数组的非常简单的复制。</p><h1 id="8088" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">抵消</h1><p id="6204" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">您可能已经注意到，偏移场现在完全消失了。Java字符串是不可变的，所以早期版本的JDK允许子字符串共享其父字符串的char数组，但偏移量和计数不同。这意味着保留一个小的子字符串可以在内存中保留一个更大的字符串，并防止它被垃圾收集。</p><p id="b895" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">char数组现在内联在String对象中，所以子字符串不能共享它们的父char数组，这就是为什么不再需要offset了。</p><h1 id="a9d2" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">优势</h1><p id="3a08" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">让我们推测一下为什么这些变化很有趣:</p><ul class=""><li id="db80" class="lu lv hh iy b iz ja jc jd jf lw jj lx jn ly jr lz ma mb mc bi translated">空间<a class="ae jt" href="https://en.wikipedia.org/wiki/Locality_of_reference" rel="noopener ugc nofollow" target="_blank">引用位置</a>:char数组就在字符串数据的其余部分旁边，而不是必须遵循引用并冒着使CPU缓存无效的风险。</li><li id="24df" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">更小的内存占用:Java char数组包含一个头来存储它的类型和长度，这是多余的。</li><li id="36bb" class="lu lv hh iy b iz md jc me jf mf jj mg jn mh jr lz ma mb mc bi translated">两个对象都必须是4字节对齐的，现在只有一个对象需要填充。</li></ul><p id="ef53" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">String是VM中最常用的类型之一，所以这些微优化将会带来巨大的改进。</p><h1 id="aae0" class="kj kk hh bd kl km kn ko kp kq kr ks kt in ku io kv iq kw ir kx it ky iu kz la bi translated">结论:回到堆转储</h1><p id="94f1" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">因为char[] value字段已从String.java中删除，所以无法在堆转储中对其进行解析。然而在Android M Preview 2中，char缓冲区仍然在堆转储中序列化，在字符串地址之后16个字节(因为字符串结构不长于16个字节)。这意味着我们可以让LeakCanary再次与Android M一起工作:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ab36" class="lp kk hh ll b fi lq lr l ls lt">Object value <strong class="ll hi">=</strong> fieldValue<strong class="ll hi">(</strong>values<strong class="ll hi">,</strong> "value"<strong class="ll hi">);</strong><br/>ArrayInstance charArray<strong class="ll hi">;</strong><br/><strong class="ll hi">if</strong> <strong class="ll hi">(</strong>isCharArray<strong class="ll hi">(</strong>value<strong class="ll hi">))</strong> <strong class="ll hi">{</strong><br/>  charArray <strong class="ll hi">=</strong> <strong class="ll hi">(</strong>ArrayInstance<strong class="ll hi">)</strong> value<strong class="ll hi">;</strong><br/><strong class="ll hi">}</strong> <strong class="ll hi">else</strong> <strong class="ll hi">{</strong><br/>  charArray <strong class="ll hi">=</strong> <strong class="ll hi">(</strong>ArrayInstance<strong class="ll hi">)</strong> heap<strong class="ll hi">.</strong>getInstance<strong class="ll hi">(</strong>instance<strong class="ll hi">.</strong>getId<strong class="ll hi">()</strong> <strong class="ll hi">+</strong> 16<strong class="ll hi">);</strong><br/><strong class="ll hi">}</strong></span></pre><p id="1eb2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个漏洞最终会在Android M中通过在转储堆时在所有字符串对象中插入一个虚拟char[] valuefield来修复<a class="ae jt" href="https://code.google.com/p/android-developer-preview/issues/detail?id=2769" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="3d90" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">非常感谢<a class="ae jt" href="https://twitter.com/dunnodono" rel="noopener ugc nofollow" target="_blank">切斯特·谢</a>、<a class="ae jt" href="https://twitter.com/romainguy" rel="noopener ugc nofollow" target="_blank">罗曼·盖伊</a>、<a class="ae jt" href="https://twitter.com/jessewilson" rel="noopener ugc nofollow" target="_blank">杰西·威尔逊</a>和<a class="ae jt" href="https://twitter.com/jakewharton" rel="noopener ugc nofollow" target="_blank">杰克·沃顿</a>帮助解决这个问题。</p></div><div class="ab cl mi mj go mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ha hb hc hd he"><div class="lg lh li lj fd mp"><a href="http://twitter.com/Piwai" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hi fi z dy mu ea eb mv ed ef hg bi translated">皮埃尔-伊夫·里考(@皮瓦伊)|推特</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">Pierre-Yves Ricau (@Piwai)的最新推文。安卓贝克@广场。巴黎/旧金山</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">twitter.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ne mp"/></div></div></a></div></div></div>    
</body>
</html>