<html>
<head>
<title>Automating Instance Initialization with Terraform on Oracle Cloud Infrastructure: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Oracle云基础设施上使用Terraform自动化实例初始化:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/automating-instance-initialization-with-terraform-on-oracle-cloud-infrastructure-part-2-e1aa1a8710d?source=collection_archive---------0-----------------------#2017-11-23">https://medium.com/oracledevs/automating-instance-initialization-with-terraform-on-oracle-cloud-infrastructure-part-2-e1aa1a8710d?source=collection_archive---------0-----------------------#2017-11-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="914b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为上一篇关于在Oracle计算云上使用Terraform实现实例初始化自动化的文章<a class="ae jc" rel="noopener" href="/oracledevs/automating-oracle-compute-cloud-instance-initialization-with-terraform-6e66968fe30a">(该文章重点介绍了如何将<code class="du jd je jf jg b">opc</code> Terraform provider与Oracle云基础设施<strong class="ig hi">经典计算</strong>)的后续文章，在本文中，我们将探讨与用于<strong class="ig hi"> Oracle云基础设施</strong>服务的<code class="du jd je jf jg b">oci</code> Terraform provider相同的一些选项，以及在配置多个实例时一些更高级的初始化选项。</a></p><p id="d307" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">与之前类似，在初始化Oracle云基础架构实例时，有两个不同的配置选项可供选择:</p><ul class=""><li id="9574" class="jh ji hh ig b ih ii il im ip jj it jk ix jl jb jm jn jo jp bi translated">在实例启动期间传递<strong class="ig hi"> cloud-init </strong>用户数据进行初始化</li><li id="02c7" class="jh ji hh ig b ih jq il jr ip js it jt ix ju jb jm jn jo jp bi translated">使用<strong class="ig hi"> Terraform Provisioners </strong>在实例运行后执行配置任务。</li></ul><h1 id="f02e" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">使用cloud-init进行实例初始化</h1><p id="9613" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">在Oracle云基础设施环境中，提供的Linux操作系统映像(包括Oracle Linux)通过在Terraform <code class="du jd je jf jg b">oci_core_instance</code>资源定义的<code class="du jd je jf jg b">metadata</code>块中提供<code class="du jd je jf jg b">user_data</code>条目来支持<strong class="ig hi"> cloud-init </strong>初始化。</p><p id="6c98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jd je jf jg b">user_data</code>属性的内容必须是一个<strong class="ig hi"> base64 </strong> <strong class="ig hi">编码的</strong>脚本，采用正在启动的操作系统支持的任何cloud-init格式，包括:</p><ul class=""><li id="f483" class="jh ji hh ig b ih ii il im ip jj it jk ix jl jb jm jn jo jp bi translated"><code class="du jd je jf jg b">#cloud-config</code>云配置数据</li><li id="4f32" class="jh ji hh ig b ih jq il jr ip js it jt ix ju jb jm jn jo jp bi translated"><code class="du jd je jf jg b">#!</code>用户数据脚本(例如<code class="du jd je jf jg b">#!/bin/bash</code>)</li><li id="86d4" class="jh ji hh ig b ih jq il jr ip js it jt ix ju jb jm jn jo jp bi translated"><code class="du jd je jf jg b">#include</code>包含文件</li><li id="3dc7" class="jh ji hh ig b ih jq il jr ip js it jt ix ju jb jm jn jo jp bi translated"><code class="du jd je jf jg b">#cloud-boothook</code>云Boothook</li></ul><h2 id="82e4" class="ky jw hh bd jx kz la lb kb lc ld le kf ip lf lg kj it lh li kn ix lj lk kr ll bi translated">示例:带有cloud-init的Linux实例</h2><p id="a3b9" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">在本例中，使用<code class="du jd je jf jg b">template_file</code>数据源和heredoc符号在Terraform配置中定义了一个<code class="du jd je jf jg b">#cloud-config</code>初始化脚本，以声明脚本内容。</p><figure class="lm ln lo lp fd lq"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="3317" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用户数据脚本内容也可以直接从本地文件加载</p><pre class="lm ln lo lp fd lt jg lu lv aw lw bi"><span id="fe4e" class="ky jw hh jg b fi lx ly l lz ma">user_data = "${base64encode(file("./mybootscript.sh"))}"</span></pre><h1 id="77aa" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">使用Terraform供应器初始化实例</h1><p id="20b9" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">Terraform支持几个<a class="ae jc" href="https://www.terraform.io/docs/provisioners/index.html" rel="noopener ugc nofollow" target="_blank">供应器</a>，这些供应器能够在初始实例资源创建后协调其他供应步骤。对于下面的例子，我们将使用一个简单的<code class="du jd je jf jg b"><strong class="ig hi">remote-exec</strong></code> provisioner。使用Terraform <code class="du jd je jf jg b"><strong class="ig hi">chef</strong></code> provisioner的更完整示例可以在<a class="ae jc" href="https://github.com/oracle/terraform-provider-oci/tree/master/docs/solutions/chef" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="8a53" class="ky jw hh bd jx kz la lb kb lc ld le kf ip lf lg kj it lh li kn ix lj lk kr ll bi translated">示例:带有<code class="du jd je jf jg b">remote-exec</code>供应器的Linux实例</h2><figure class="lm ln lo lp fd lq"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="c699" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意在连接块中使用特殊的<code class="du jd je jf jg b">${self.<strong class="ig hi">public_ip</strong>}</code>引用从当前实例中获取公共IP地址属性。如果实例没有公共IP地址，而Terraform运行的环境可以直接(或VPN)访问私有网络，那么可以使用<code class="du jd je jf jg b">${self.<strong class="ig hi">private_ip</strong>}</code>作为替代。</p><p id="129b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果实例没有公共IP地址，并且Terraform没有到实例专用网络的直接连接，Terraform通过在连接块中添加堡垒主机细节来支持通过堡垒主机的<a class="ae jc" href="https://www.terraform.io/docs/provisioners/connection.html#connecting-through-a-bastion-host-with-ssh" rel="noopener ugc nofollow" target="_blank">连接。</a></p><pre class="lm ln lo lp fd lt jg lu lv aw lw bi"><span id="7fc5" class="ky jw hh jg b fi lx ly l lz ma">resource "oci_core_instance" "example" {<br/>  ...<br/>  connection {<br/>    type        = "ssh"<br/>    host        = "${self.<strong class="jg hi">private_ip</strong>}"<br/>    user        = "opc"<br/>    private_key = "${file(var.ssh_private_key_file)}"<br/>    <br/>    <strong class="jg hi">bastion_host        = "${oci_core_instance.bastion.public_ip}"<br/>    bastion_user        = "opc"<br/>    bastion_private_key = "${file(var.ssh_private_key_file)}"</strong><br/>  }<br/>  <strong class="jg hi">...</strong><br/>}</span></pre><h1 id="410e" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">使用带<code class="du jd je jf jg b">null_resource</code>的地形供应器</h1><p id="06b2" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">在某些情况下，将供应配置与实例资源定义分开是很有用的。Terraform <code class="du jd je jf jg b"><a class="ae jc" href="https://www.terraform.io/docs/provisioners/null_resource.html" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">null_resource</strong></a></code>特别允许配置与单个现有资源没有直接关联的置备程序。</p><p id="e5bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个很好的例子是，在资源之间存在供应时(而不是创建时)依赖性的情况下，<code class="du jd je jf jg b">null_resource</code>对于供应很有用。</p><p id="0f2e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们考虑一个带有数据库(DB)实例和中间件(MW)实例的配置示例。MW实例配置要求在配置文件中设置DB实例的IP地址值。</p><p id="8000" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们声明如下:</p><pre class="lm ln lo lp fd lt jg lu lv aw lw bi"><span id="5043" class="ky jw hh jg b fi lx ly l lz ma">resource "oci_core_instance" "<strong class="jg hi">DB</strong>" {<br/>  ...<br/>}</span><span id="51b1" class="ky jw hh jg b fi mb ly l lz ma">resource "oci_core_instance" "<strong class="jg hi">MW</strong>" {<br/>  ...<br/>  provisioner "remote-exec" {<br/>    inline = [<br/>      "echo ${<strong class="jg hi">oci_core_instance.DB.private_ip</strong>} &gt; /tmp/database.ip",<br/>    ]<br/>  }<br/>}</span></pre><p id="b0be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是通过在MW实例供应内容中包含对<code class="du jd je jf jg b">${oci_core_instance.DB.public_ip}</code>的引用，MW实例的创建现在依赖于DB实例，因此Terraform将不会开始创建MW资源，直到创建了DB实例之后。</p><p id="0e61" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过将该配置的供应分离到单独的<code class="du jd je jf jg b">null_resource</code>中，DB和MW资源的创建将并行开始，并且<code class="du jd je jf jg b">null_resource</code>供应程序将仅在两者都创建之后执行。</p><pre class="lm ln lo lp fd lt jg lu lv aw lw bi"><span id="dedb" class="ky jw hh jg b fi lx ly l lz ma"><strong class="jg hi">resource "null_resource" </strong>"config-MW" {<br/>  triggers {<br/>    db_private_ip = "${oci_core_instance.DB.private_ip}"<br/>    mw_instance_id = "${oci_core_instance.MW.id}"<br/>  }</span><span id="0851" class="ky jw hh jg b fi mb ly l lz ma">  connection {<br/>    host = "${<strong class="jg hi">oci_core_instance.MW.private_ip</strong>}"<br/>    ...<br/>  }</span><span id="0f38" class="ky jw hh jg b fi mb ly l lz ma">  provisioner "remote-exec" {<br/>    inline = [<br/>      "echo ${<strong class="jg hi">oci_core_instance.DB.private_ip</strong>} &gt; /tmp/database.ip",<br/>    ]<br/>  }<br/>}</span></pre><p id="cc0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jd je jf jg b">connection</code>区块和<code class="du jd je jf jg b">provisioner</code>声明与之前相同。<code class="du jd je jf jg b">triggers</code>部分定义了导致<code class="du jd je jf jg b">null_resource</code>被重新创建的条件(即供应器被重新执行)。在此示例中，如果DB <strong class="ig hi">私有IP </strong>地址发生变化，或者MW <strong class="ig hi">实例ID </strong>发生变化(即MW实例被重新创建)，则重新执行供应脚本</p><p id="410b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以在一个配置中定义多个<code class="du jd je jf jg b">null_resources</code>来处理更复杂的实例供应需求。</p><h2 id="e13f" class="ky jw hh bd jx kz la lb kb lc ld le kf ip lf lg kj it lh li kn ix lj lk kr ll bi translated">不要重复你自己</h2><p id="8b4a" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">最后一个例子展示了如何定义一个<code class="du jd je jf jg b">null_resource</code>来在多个实例上运行同一个provisioner，这有助于保持配置干燥</p><pre class="lm ln lo lp fd lt jg lu lv aw lw bi"><span id="f318" class="ky jw hh jg b fi lx ly l lz ma">resource "null_resource" "cluster" {<br/>  <strong class="jg hi">count = 2</strong></span><span id="bf11" class="ky jw hh jg b fi mb ly l lz ma">connection {<br/>    type        = "ssh"<br/>    host        = "${<strong class="jg hi">element(list(oci_core_instance.DB.public_ip, oci_core_instance.MW.public_ip), count.index)</strong>}"<br/>    user        = "opc"<br/>    private_key = "${file(var.ssh_private_key_file)}"<br/>  }</span><span id="218e" class="ky jw hh jg b fi mb ly l lz ma">  provisioner "remote-exec" {<br/>    inline = [<br/>      "echo 'This instance was provisioned by Terraform.' | sudo tee /etc/motd",<br/>    ]<br/>  }<br/>}</span></pre><p id="ef4b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是通过提供资源计数<strong class="ig hi">和基于计数索引从主机列表中选择要连接(和供应)的特定主机来实现的</strong></p></div></div>    
</body>
</html>