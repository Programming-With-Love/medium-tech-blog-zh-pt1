<html>
<head>
<title>Microservice Approach for Web Development — Micro Frontends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web开发的微服务方法——微前端</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/microservice-approach-for-web-development-micro-frontends-1cba93d85021?source=collection_archive---------2-----------------------#2018-05-17">https://medium.com/oracledevs/microservice-approach-for-web-development-micro-frontends-1cba93d85021?source=collection_archive---------2-----------------------#2018-05-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="36e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇文章基于我的甲骨文代码2018华沙会谈。查看幻灯片共享上的<a class="ae jc" href="https://www.slideshare.net/andrejusb/microservice-approach-for-web-development-with-micro-frontends" rel="noopener ugc nofollow" target="_blank">演示文稿</a>:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="2388" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">想知道微前端是什么意思吗？查看微前端描述<a class="ae jc" href="https://micro-frontends.org/" rel="noopener ugc nofollow" target="_blank">此处</a>。简单地说，微前端必须在隔离的环境中实现自顶向下的业务逻辑(数据库、中间件和UI)，它应该是可重用的，并可插入到主应用程序UI外壳中。微前端之间不能有共享变量。优势——分布式团队可以在独立的微前端上工作，这改进了大型和模块化系统的开发。还有运行时优势——如果一个前端停止工作，主应用程序应该继续工作。</p><p id="2fa1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我已经用Oracle JET实现了微前端架构。源代码可以在<a class="ae jc" href="https://github.com/abaranovskis-redsamurai/warsaw" rel="noopener ugc nofollow" target="_blank"> GitHub </a>库获得。有三个应用程序，两个具有微前端，一个是主UI shell。两个微前端都被实现为JET复合组件。首先是托管在WebLogic上，它在后端调用ADF BC REST服务。第二个托管在节点上。JS并返回静态数据。第一个微前端实现监听器，它允许处理来自外部的动作。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jk"><img src="../Images/efb7b004d98361269aa3d3bfaca1e944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQ_Bly877KqYNPkiptSNsA.png"/></div></div></figure><p id="8d03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当在浏览器中访问JET应用程序时，会从服务器下载大量的HTML、JS和CSS文件。微前端的核心思想——不是从与主应用程序相同的主机加载HTML、JS和CSS，而是从不同的主机加载。主应用程序中呈现的JET复合组件将从不同的主机下载。不仅仅是下载，所有后端调用也应该到那个主机，而不是主主机。JET复合组件集成到主应用程序架构中:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jr"><img src="../Images/c4042cd7126bd658b150e9667a3095ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rWjRJJtbyUOvfuL3-0SpcA.png"/></div></div></figure><p id="c948" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是它在实践中的工作方式。这些图表中的每一个都是单独的JET复合组件，作为微前端从不同的主机加载到主应用程序中。我们可以在网络监视器中看到这一点。两个微前端的Loader.js脚本从不同的主机下载:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es js"><img src="../Images/a2a4ae3fdb9da14c529b1f29588fafa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qg6oVgemuz-NCo-FHqtRIA.png"/></div></div></figure><p id="1303" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行时优势—如果一个或多个微前端关闭，应用程序将继续运行:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jt"><img src="../Images/66d3ebb2d1a51e782a777d6ab021f6fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8x9MC5DLtNnpggUZkKHiSQ.png"/></div></div></figure><p id="450c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">JET Composite组件运行在客户端，即使它托管在自己的微前端。这使得在主应用中订阅组件中发生的事件并将该事件路由到另一个微前端成为可能。在本例中，一旦在“职务图表-员工图表”(另一个微前端)中选择了项目，就会被过滤:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es ju"><img src="../Images/4ce7eb482d8b0ad0203aca05ce69d18d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0VRNbgt7HzMFA_RdOg-Ow.png"/></div></div></figure><p id="3aaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">技术实现</p><p id="c3af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">主应用程序必须配置为支持JET复合组件的远程模块加载。在Duncan Mills的博客文章— <a class="ae jc" href="https://blogs.oracle.com/groundside/jet-composite-components-xii-revisiting-the-loader-script" rel="noopener ugc nofollow" target="_blank"> JET Custom Components XII —重温加载程序脚本</a>中了解更多信息。简而言之，应该在JET应用程序main.js中添加Xhr config:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jv"><img src="../Images/4225c8d3e75552c10b76f90c8dfc96ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIz0Gt1il3iW6maTf8Kevg.png"/></div></div></figure><p id="a40d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">微前端所在的服务器必须设置Access-Control-Allow-Origin头。集成了两个微前端的主模块使用JET模块组件。主UI外壳中的每个微前端都被包装到JET模块中。这允许主应用程序运行，即使模块中的微前端停止:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jw"><img src="../Images/75b42bb91f69100f08ff31a4ef25a913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oEb9o95PxFs1W5sSVdjfEQ.png"/></div></div></figure><p id="7d40" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">JET模块从变量初始化，该变量返回模块名称:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jx"><img src="../Images/d610c38ed3e127435924ab04248269d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjuj0_MB2o12kEacR0yCSQ.png"/></div></div></figure><p id="2e91" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作业模块包含作业微前端— JET复合组件。它由WebLogic托管，并在后端调用ADF BC REST。组件分配有监听程序:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jy"><img src="../Images/a78f355485b5e7cef07a5deedc49ac2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHcbvnhAqKTynrmv5_3tPQ.png"/></div></div></figure><p id="0a26" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最重要的部分在JS脚本中。这里，我们从远程主机加载JET复合组件，而不是在本地引用它。这允许自行开发和托管微前端JET复合组件:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jz"><img src="../Images/c9a8ddf573de9199b6acdd0574f90de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bdCY431KJxOgKBtcoC5pdA.png"/></div></div></figure><p id="c25c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">监听器引用<em class="ka"> c2 </em>元素并调用方法。主app中的<em class="ka"> c2 </em>元素与第二微前端相关:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kb"><img src="../Images/9062e73c5b71181b7dad7936d95cdab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQ2RfqW6LA6dVvEoyCZkXA.png"/></div></div></figure><p id="0cdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此组件是从另一个主机的节点加载的。JS:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kc"><img src="../Images/9afa38f657544e2dcf22d4d5936bdea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wynZyQAmLgcALpfurkUwOQ.png"/></div></div></figure><p id="5008" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重要提示—对于要从远程主机加载的JET复合组件，请确保添加。突出显示的JET复合组件脚本的js(参考源代码):</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es kd"><img src="../Images/48ee34ab33e05e04f200c5af194010b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x0pm2om-SPb2du8aLLKUpQ.png"/></div></div></figure></div><div class="ab cl ke kf go kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="ha hb hc hd he"><p id="3e7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ka">原载于2018年5月17日</em><a class="ae jc" href="https://andrejusb.blogspot.lt/2018/05/microservice-approach-for-web.html" rel="noopener ugc nofollow" target="_blank"><em class="ka">andrejusb.blogspot.com</em></a><em class="ka">。</em></p></div></div>    
</body>
</html>