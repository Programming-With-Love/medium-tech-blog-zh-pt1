<html>
<head>
<title>Mounting a GCP bucket as NFS in kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在库伯内特斯装上一个GCP桶作为NFS</h1>
<blockquote>原文：<a href="https://medium.com/compendium/mounting-a-gcp-bucket-as-nfs-in-kubernetes-8f6d3faf4da3?source=collection_archive---------0-----------------------#2019-03-22">https://medium.com/compendium/mounting-a-gcp-bucket-as-nfs-in-kubernetes-8f6d3faf4da3?source=collection_archive---------0-----------------------#2019-03-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c4971ce7728091202cfc55b4e0327bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOMtZQ4cb_gxIZ1HkiKOfw.png"/></div></div></figure><p id="39b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">创建一个无限大小的文件共享，就像NFS安装在kubernetes集群中的一个桶上一样？不管这是不是一个好主意，这里有一个我们所面临的问题和我们如何解决它的小描述。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><h1 id="ec9b" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">背景</h1><p id="043c" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">为什么我首先想要这个作为NFS服务器？为什么不使用gcsfuse简单地将它安装在需要它的pod中呢？</p><p id="0a39" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于我当前的客户来说，Kubernetes集群是一个托管的airflow实例(cloud composer)，我已经设置了一个NFS服务器，它在这个集群中平稳运行(<a class="ae ky" href="https://estl.tech/multi-writer-file-storage-on-gke-6d044ec96a46" rel="noopener ugc nofollow" target="_blank">遵循这个伟大的指南</a>)。这个NFS共享由使用<a class="ae ky" href="https://airflow.apache.org/kubernetes.html" rel="noopener ugc nofollow" target="_blank"> kubernetes操作符</a>的进程使用，该操作符在composer集群中产生pod。</p><p id="5e3a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Kubernetes集群内部运行NFS服务器的缺点是“很难”在集群外部获得卷。对于开发人员和其他过程都是如此。</p><p id="058f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">开始出现的一个棘手问题是为开发人员列出一个文件这样简单的事情。人们不得不躲进一个豆荚里做一个ls。实际上，以桶的形式查看文件会非常方便。磁盘增长怎么办？</p><p id="d569" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我可以直接在吊舱中使用gcsfuse，对吗？</p><p id="bffc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不尽然——因为pod是使用Airflow Kubernetes操作符创建的，所以我对创建环境没有完全的控制权，并且我没有找到一种好的方法来针对不同的图像以通用的方式运行gcsfuse。除了添加它，还有一堆脚本到dockerfile文件中。但我的蜘蛛感觉一直告诉我，将来有人会忘记一些事情，这不会有好结果。我想要一些简单的东西，如卷和安装，可以应用于所有的工作，而不改变docker的形象。</p><p id="af57" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以安装一个铲斗吗？这当然很好。无限磁盘存储？易于在集群外用于各种作业？或者直接使用原生bucket API。</p><p id="d634" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">实际上没有文章描述如何做到这一点(也许是有充分的理由？—桶并不是真正的文件系统，不像我们习惯的那样有锁。此外，还有入口和出口..)</p><h1 id="136f" class="jv jw hh bd jx jy kz ka kb kc la ke kf kg lb ki kj kk lc km kn ko ld kq kr ks bi translated">解决办法</h1><p id="77cb" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">我最初的想法是修改NFS服务器，只使用gcsfuse来挂载一个桶，而不是获取一个卷声明。</p><h1 id="f7db" class="jv jw hh bd jx jy kz ka kb kc la ke kf kg lb ki kj kk lc km kn ko ld kq kr ks bi translated">创建一个密码来保存服务帐户</h1><p id="5484" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">首先，您显然要创建服务帐户并下载它，然后授予它所需的访问权限。例如，首先在本地测试服务帐户访问，并确保您可以在bucket上使用gsutil。</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="e72a" class="ln jw hh lj b fi lo lp l lq lr">kubectl create secret generic sa-THE-SERVICE-ACCOUNT --from-file=key.json=sa.json</span></pre><h1 id="a026" class="jv jw hh bd jx jy kz ka kb kc la ke kf kg lb ki kj kk lc km kn ko ld kq kr ks bi translated">创建复制控制器</h1><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="c1b5" class="ln jw hh lj b fi lo lp l lq lr"><em class="jn">yaml/nfs-bucket-server-rc.yaml</em></span><span id="a488" class="ln jw hh lj b fi ls lp l lq lr"><strong class="lj hi">apiVersion: </strong>v1<br/><strong class="lj hi">kind: </strong>ReplicationController<br/><strong class="lj hi">metadata:<br/>  name: </strong>nfs-bucket-server<br/><strong class="lj hi">spec:<br/>  replicas: </strong>1<br/>  <strong class="lj hi">selector:<br/>    role: </strong>nfs-bucket-server<br/>  <strong class="lj hi">template:<br/>    metadata:<br/>      labels:<br/>        role: </strong>nfs-bucket-server<br/>    <strong class="lj hi">spec:<br/>      volumes:<br/>        </strong>- <strong class="lj hi">name: </strong>sa-THE-SERVICE-ACCOUNT<br/>          <strong class="lj hi">secret:<br/>            secretName: </strong>sa-THE-SERVICE-ACCOUNT<br/>      <strong class="lj hi">containers:<br/>      </strong>- <strong class="lj hi">name: </strong>nfs-bucket-server<br/>        <strong class="lj hi">image: </strong>anderselton/nfs-bucket-server:latest<br/>        <strong class="lj hi">env:<br/>        </strong>- <strong class="lj hi">name: </strong>BUCKET<br/>          <strong class="lj hi">value: </strong>"CHANGE-ME"<br/>        <strong class="lj hi">ports:<br/>          </strong>- <strong class="lj hi">name: </strong>nfs<br/>            <strong class="lj hi">containerPort: </strong>2049<br/>          - <strong class="lj hi">name: </strong>mountd<br/>            <strong class="lj hi">containerPort: </strong>20048<br/>          - <strong class="lj hi">name: </strong>rpcbind<br/>            <strong class="lj hi">containerPort: </strong>111<br/>        <strong class="lj hi">volumeMounts:<br/>          </strong>- <strong class="lj hi">name: </strong>sa-THE-SERVICE-ACCOUNT<br/>            <strong class="lj hi">mountPath: </strong>"/accounts"<br/>            <strong class="lj hi">readOnly: </strong>true<br/>        <strong class="lj hi">securityContext:<br/>          privileged: </strong>true</span></pre><p id="c3d8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">奔跑</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="39f5" class="ln jw hh lj b fi lo lp l lq lr"><em class="jn">kubectl</em> apply -f yaml/nfs-bucket-server-rc.yaml</span></pre><h1 id="1bf5" class="jv jw hh bd jx jy kz ka kb kc la ke kf kg lb ki kj kk lc km kn ko ld kq kr ks bi translated">创建服务以向其他pod公开服务器</h1><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="ed16" class="ln jw hh lj b fi lo lp l lq lr"><em class="jn">yaml/nfs-bucket-server-service.yaml</em></span><span id="40f4" class="ln jw hh lj b fi ls lp l lq lr"><strong class="lj hi">kind: </strong>Service<br/><strong class="lj hi">apiVersion: </strong>v1<br/><strong class="lj hi">metadata:<br/>  name: </strong>nfs-bucket-server<br/><strong class="lj hi">spec:<br/>  ports:<br/>    </strong>- <strong class="lj hi">name: </strong>nfs<br/>      <strong class="lj hi">port: </strong>2049<br/>    - <strong class="lj hi">name: </strong>mountd<br/>      <strong class="lj hi">port: </strong>20048<br/>    - <strong class="lj hi">name: </strong>rpcbind<br/>      <strong class="lj hi">port: </strong>111<br/>  <strong class="lj hi">selector:<br/>    role: </strong>nfs-bucket-server</span></pre><p id="0d00" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">奔跑</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="8f94" class="ln jw hh lj b fi lo lp l lq lr"><em class="jn">kubectl</em> apply -f yaml/nfs-bucket-server-service.yaml</span></pre><h1 id="e8f1" class="jv jw hh bd jx jy kz ka kb kc la ke kf kg lb ki kj kk lc km kn ko ld kq kr ks bi translated">创建NFS卷并申请(供其他pod使用)</h1><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="c02e" class="ln jw hh lj b fi lo lp l lq lr"><em class="jn">yaml/nfs-bucket-pv.yaml</em></span><span id="50da" class="ln jw hh lj b fi ls lp l lq lr"><strong class="lj hi">apiVersion: </strong>v1<br/><strong class="lj hi">kind: </strong>PersistentVolume<br/><strong class="lj hi">metadata:<br/>  name: </strong>nfs-bucket<br/><strong class="lj hi">spec:<br/>  capacity:<br/>    storage: </strong>1Mi<br/>  <strong class="lj hi">accessModes:<br/>    </strong>- ReadWriteMany<br/>  <strong class="lj hi">nfs:<br/>    server: </strong>nfs-bucket-server.default.svc.cluster.local<br/>    <strong class="lj hi">path: </strong>"/"</span><span id="4ac3" class="ln jw hh lj b fi ls lp l lq lr"><em class="jn"><br/>yaml/nfs-bucket-pvc.yaml</em></span><span id="363f" class="ln jw hh lj b fi ls lp l lq lr"><strong class="lj hi">apiVersion: </strong>v1<br/><strong class="lj hi">kind: </strong>PersistentVolumeClaim<br/><strong class="lj hi">metadata:<br/>  name: </strong>nfs-bucket<br/><strong class="lj hi">spec:<br/>  accessModes:<br/>    </strong>- ReadWriteMany<br/>  <strong class="lj hi">storageClassName: </strong>""<br/>  <strong class="lj hi">resources:<br/>    requests:<br/>      storage: </strong>1Mi</span></pre><p id="d34b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">奔跑</p><pre class="le lf lg lh fd li lj lk ll aw lm bi"><span id="1b9a" class="ln jw hh lj b fi lo lp l lq lr"><em class="jn">kubectl</em> apply -f yaml/nfs-bucket-pv.yaml<br/><em class="jn">kubectl</em> apply -f yaml/nfs-bucket-pvc.yaml</span></pre><p id="170b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于不存在完成这一特定任务的映像，我不得不编写一个自定义的dockerfile 来包含NFS服务器、gcsfuse和一个启动脚本，以便将它们粘在一起。当然还有一堆yaml配置文件。</p><p id="3eff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">完整的GitHub repo，包含在您自己的集群中执行此操作所需的一切:</p><p id="fa59" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae ky" href="https://github.com/ael-computas/gcp-kubernetes-bucket-nfs-server" rel="noopener ugc nofollow" target="_blank">https://github . com/ael-computas/GCP-kubernetes-bucket-NFS-server</a></p><p id="ef36" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你可以(或许应该)做的是:</p><ul class=""><li id="853a" class="lt lu hh ir b is it iw ix ja lv je lw ji lx jm ly lz ma mb bi translated">只需使用bucket原生API</li><li id="bd74" class="lt lu hh ir b is mc iw md ja me je mf ji mg jm ly lz ma mb bi translated">如果你需要做本地开发，可能抽象在你这边，所以开发的时候从本地FS读取，云/生产的时候从bucket读取。</li></ul></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="5e88" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">事实可能证明这是一个非常糟糕的想法，我们应该使用原生API来代替，并进行我们需要的重写。</p></div></div>    
</body>
</html>