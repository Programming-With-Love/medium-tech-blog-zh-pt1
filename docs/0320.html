<html>
<head>
<title>The Android Lifecycle cheat sheet — part III : Fragments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android生命周期备忘单——第三部分:片段</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iii-fragments-afc87d4f37fd?source=collection_archive---------0-----------------------#2017-12-05">https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iii-fragments-afc87d4f37fd?source=collection_archive---------0-----------------------#2017-12-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="1427" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本系列中:<br/> * <a class="ae jc" rel="noopener" href="/@JoseAlcerreca/the-android-lifecycle-cheat-sheet-part-i-single-activities-e49fd3d202ab"> <strong class="ig hi">第一部分:活动</strong> —单个活动生命周期</a> <br/> * <a class="ae jc" rel="noopener" href="/@JoseAlcerreca/the-android-lifecycle-cheat-sheet-part-ii-multiple-activities-a411fd139f24"> <strong class="ig hi">第二部分:多个活动</strong> —导航和回栈</a> <br/> * <strong class="ig hi">第三部分:片段</strong> —活动和片段生命周期(本帖)<br/> * <a class="ae jc" rel="noopener" href="/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iv-49946659b094"> <strong class="ig hi">第四部分:视图模型、半透明活动和启动模式</strong> </a></p><p id="e8b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些图表还可以作为PDF格式的<a class="ae jc" href="https://github.com/JoseAlcerreca/android-lifecycles" rel="noopener ugc nofollow" target="_blank">备忘单</a>快速参考。</p></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><p id="1c3a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一节中，我们将介绍附加到活动的片段的行为。不要将这个场景与添加到后台堆栈的片段相混淆(有关片段事务和后台堆栈的更多信息，请参见<a class="ae jc" rel="noopener" href="/google-developers/tasks-and-the-back-stack-dbb7c3b0f6d4">任务和后台堆栈</a>)。</p><h1 id="4859" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">场景1:包含片段的活动开始和结束</strong></h1><figure class="kj kk kl km fd kn er es paragraph-image"><div class="er es ki"><img src="../Images/28eb03f082f71a99fe884b8d6e471ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*ALMDBkuAAZ28BJ2abmvniA.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx"><strong class="bd jm">Scenario 1: Activity with Fragment starts and finishes</strong></figcaption></figure><p id="3a0e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，保证活动的<code class="du ku kv kw kx b">onCreate</code>在片段的之前执行。然而，并排显示的回调——比如<code class="du ku kv kw kx b">onStart</code>和<code class="du ku kv kw kx b">onResume</code>——是并行执行的，因此可以按任意顺序调用。例如，系统可能在片段的<code class="du ku kv kw kx b">onStart</code>方法之前执行活动的<code class="du ku kv kw kx b">onStart </code>方法，但是在活动的<code class="du ku kv kw kx b">onResume</code>方法之前执行<em class="ky">片段的</em> <code class="du ku kv kw kx b">onResume</code>方法。</p><p id="32a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ky">小心管理各个执行序列的时间，以避免竞争情况。</em></p></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><h1 id="4e7a" class="jk jl hh bd jm jn kz jp jq jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh bi translated">场景2:具有片段的活动被旋转</h1><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/8d2b4b988c0376da3cb0b191e3c7404e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukapaC23cOJSPUeZ0bUdCA.png"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx"><strong class="bd jm">Scenario 2: Activity with Fragment is rotated</strong></figcaption></figure><h2 id="4a96" class="lj jl hh bd jm lk ll lm jq ln lo lp ju ip lq lr jy it ls lt kc ix lu lv kg lw bi translated">状态管理</h2><p id="ebef" class="pw-post-body-paragraph ie if hh ig b ih lx ij ik il ly in io ip lz ir is it ma iv iw ix mb iz ja jb ha bi translated">片段状态的保存和恢复方式与活动状态非常相似。不同的是片段中没有<code class="du ku kv kw kx b">onRestoreInstanceState</code>，但是在片段的<code class="du ku kv kw kx b">onCreate</code>、<code class="du ku kv kw kx b">onCreateView</code>和<code class="du ku kv kw kx b">onActivityCreated</code>中有Bundle。</p><p id="ca20" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以保留片段，这意味着在配置更改时使用相同的实例。如下一个场景所示，这稍微改变了图表。</p></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><h1 id="8eb8" class="jk jl hh bd jm jn kz jp jq jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh bi translated"><strong class="ak">片段—场景3:循环使用保留片段的活动</strong></h1><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/5bf0b30671f90e66e367b45dd8bc8897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hK_YRdty1GoafABfug-r4g.png"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx"><strong class="bd jm">Scenario 3: Activity with retained Fragment is rotated</strong></figcaption></figure><p id="8b23" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在循环之后，片段既不会被销毁，也不会被创建，因为在重新创建活动之后，会使用同一个片段实例。状态包在<code class="du ku kv kw kx b">onActivityCreated</code>中仍然可用。</p><p id="0869" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不建议使用保留的片段，除非它们用于存储配置更改中的数据(在非UI片段中)。这是架构组件库中的<a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" rel="noopener ugc nofollow" target="_blank">视图模型</a>类在内部使用的，但是使用了更简单的API。</p></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><p id="480a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ky">如果你发现错误或者你认为遗漏了什么重要的东西，请在评论中报告。此外，请让我们知道您希望我们写的其他场景。</em></p></div></div>    
</body>
</html>