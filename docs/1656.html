<html>
<head>
<title>Improve Java Code Coverage and Quality with Unit Tests and JaCoCo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用单元测试和JaCoCo提高Java代码覆盖率和质量</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/improve-java-code-with-unit-tests-and-jacoco-b342643736ed?source=collection_archive---------0-----------------------#2019-03-04">https://medium.com/capital-one-tech/improve-java-code-with-unit-tests-and-jacoco-b342643736ed?source=collection_archive---------0-----------------------#2019-03-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4fa321d6050c23cead1912647234323c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sHA3cws2yEyX8zSS"/></div></div></figure><p id="23f8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">作为一家技术公司，快速生产可靠的技术是其一部分。与此同时，我们不能牺牲代码质量来稍微提高交付速度。在保持快速发布进度的同时确保代码质量的主要工具之一是编写测试。像任何其他技能一样，测试写作必须通过实践和经验来发展。</p><p id="fd40" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这篇文章中，我们将使用一个示例程序来探索代码覆盖率和圈复杂度计算对于确保代码被正确测试是如何有用的。我们将学习如何使用JaCoCo获得关于代码覆盖范围的快速反馈。最后，我们还将看看代码覆盖率的限制，以及即使有100%的代码覆盖率，bug是如何逃脱的。</p><p id="47f1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从一个简单的应用程序开始，这是一个计算数学表达式的Spring Boot web应用程序。</p><p id="ba6a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">计算器的界面是:</p><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="b4b3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">业务逻辑是:</p><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="58b5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这段代码有一个简单的HTTP端点:</p><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="b661" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该应用程序是从Spring Boot的一个主界面启动的:</p><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="9610" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">应用程序的构建由一个简单的POM文件控制:</p><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="6b7d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们也有一个简单的单元测试文件，但是它不做任何事情:</p><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="aa33" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这段代码的问题是它没有有用的测试。我们如何解决这个问题？我们如何知道我们写的测试值得写呢？</p><p id="aa2a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">编写测试时需要考虑一些标准:</p><ul class=""><li id="5040" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated">我们希望确保最好测试的代码部分是最有可能包含bug的部分。</li><li id="08a8" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">我们希望将测试集中在应用程序的关键部分，这些部分的错误最有可能给我们的客户带来不好的结果。</li><li id="8346" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">我们不希望编写重复覆盖代码相同区域的测试，而忽略代码的其他部分。</li></ul><p id="fa71" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们从试图找出代码的哪些部分最有可能包含bug开始。如果我们必须对错误隐藏在代码中的位置做出一个一般性的假设，我们会查看最复杂的代码。但是我们如何找出哪个代码是最复杂的呢？</p><h1 id="4e6f" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">圈复杂度</h1><p id="09f8" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">一种常见的启发式算法叫做圈复杂度。它已经存在很久了；托马斯·麦凯布在1976年发明了它。算法的简单描述可以在<a class="ae lk" href="https://www.theserverside.com/feature/How-to-calculate-McCabe-cyclomatic-complexity-in-Java" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><ul class=""><li id="decf" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated">为该方法的开始指定一个点。</li><li id="d723" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">为每个条件结构增加一个点，比如一个<code class="du ll lm ln lo b">if</code>条件。</li><li id="0661" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">每个迭代结构加一分。</li><li id="4e86" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">在<code class="du ll lm ln lo b">switch</code>语句中，为每个case或缺省块添加一个点。</li><li id="3689" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">任何附加布尔条件加一分，如使用<code class="du ll lm ln lo b">&amp;&amp;</code>或<code class="du ll lm ln lo b">||</code>。</li></ul><p id="d13a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">分数越高，方法越复杂。麦凯布为国家标准和技术研究所撰写的一篇论文建议<a class="ae lk" href="http://www.mccabe.com/pdf/mccabe-nist235r.pdf%3E" rel="noopener ugc nofollow" target="_blank">你应该把分数保持在10分或更低</a>。当处理圈复杂度时，请记住，最终，一个人必须声明一段代码是否是关键的；任何算法计算出的数字都只是一个决策指南。</p><p id="c8bf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lp">注意——你要知道</em> <a class="ae lk" href="https://www.cqse.eu/en/blog/mccabe-cyclomatic-complexity/" rel="noopener ugc nofollow" target="_blank"> <em class="lp">有些人不喜欢用圈复杂度</em> </a> <em class="lp">。</em></p><p id="fe9f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">许多公司正在使用SonarQube为他们的软件提供代码质量度量。SonarQube提供的度量之一是圈复杂度。然而，在我看来，这一过程来得太晚了。SonarQube通常运行在已经推送到git的代码上。它可以监控一个特性分支，但是在这种情况下，您需要一个快速的反馈周期，一个不涉及推送git然后等待服务器处理您的分支的周期。这就是贾科科的用武之地。</p><h1 id="1a19" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">介绍JaCoCo</h1><p id="6690" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">JaCoCo 是一个开源的Java软件质量工具，用于测量代码覆盖率，向您展示您编写的单元测试已经测试了您代码中的哪些行。除了覆盖率，JaCoCo还报告了每个方法的复杂性，并告诉您一个方法中还有多少复杂性没有被测试。</p><p id="f352" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看如何将JaCoCo支持添加到我们的计算器服务中。我们需要做的就是在POM文件中添加几行。在<code class="du ll lm ln lo b">projects/build/plugins</code>下，添加以下XML:</p><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="0b3f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在<code class="du ll lm ln lo b">projects</code>下，添加这个XML:</p><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="529c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在你需要做的就是运行命令<code class="du ll lm ln lo b">mvn test jacoco:report</code>。这将运行项目中的所有单元测试，并创建代码覆盖率信息的HTML报告。您可以在项目的<code class="du ll lm ln lo b">target/site/jacoco</code>目录中找到这个报告。</p><p id="4ca3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们看一下报告，我们会发现我们遗漏了相当多的内容:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/be10922a6aa5aab5d52b0815406b5e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_w32pqG-KzpUj5wM"/></div></div></figure><p id="70b3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">红色太多了。在我们继续之前，让我们看一下表格中的列，以便了解我们在看什么以及我们需要改进什么。</p><p id="68dc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">元素列给出了当前应用程序中的包。您可以使用本专栏深入研究代码，以确切了解哪些内容被覆盖，哪些内容没有被覆盖。我们一会儿就会谈到这一点，但首先我们将看看其他列。</p><ul class=""><li id="2553" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated"><strong class="ir hi">遗漏指令和Cov。</strong> —这给出了测试中已经覆盖的Java字节码指令数量的图形和百分比度量。红色表示未覆盖，绿色表示覆盖。</li><li id="e92c" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><strong class="ir hi">缺枝漏盖。— </strong>这给出了测试中已经覆盖的_ branch _数量的图形和百分比度量。一个分支是你代码中的一个决策点，你需要为一个决策的每一种可能的方式提供一个测试，以获得完整的覆盖。</li><li id="d53d" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><strong class="ir hi"> Missed和Cxty </strong> —在这里我们可以找到源代码的圈复杂度分数。在包级别，这是包中所有类的所有方法的得分总和。在类级别，它是类中所有方法的分数总和，在方法级别，它是方法的分数。</li><li id="c70f" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><strong class="ir hi">遗漏和行数</strong> —这是代码行数和没有完全覆盖的行数。</li><li id="622c" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><strong class="ir hi">遗漏和方法</strong> —这是方法的数量和没有完全覆盖的方法的数量。</li><li id="337a" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><strong class="ir hi">遗漏类和类</strong> —这是类的数量，包括内部类，以及没有至少一些代码覆盖率的类的数量。</li></ul><p id="9118" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们回到元素列。如果您点击一个包名，您将会看到一个类似的屏幕，在Element列中有一个包中的类。如果你点击<code class="du ll lm ln lo b">com.example.demo</code>链接，看起来是这样的:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lq"><img src="../Images/b5f63a83e44b1da25bb709f42a6d3b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DtPTDY13Gernatew"/></div></div></figure><p id="f0de" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您单击一个类名，您将看到该类中的方法:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lr"><img src="../Images/56cb721a2ea0de84b883be6750f71eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XKuDnz94fyWmf1_t"/></div></div></figure><p id="024a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，如果你点击一个方法的名字，你会看到这个类的源代码，滚动到这个方法:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div class="er es ls"><img src="../Images/d36558536a394d0c06c125929ea6419e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/0*K_MdXCFPBO7Fxb3e"/></div></figure><p id="dbba" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">代码用红色、黄色或绿色来表示每一行代码是没有覆盖、部分覆盖还是完全覆盖。类名以绿色突出显示，表明默认构造函数已经被Spring应用程序上下文的空测试调用。还调用了<code class="du ll lm ln lo b">calculator</code>方法，因为它的<code class="du ll lm ln lo b">@Bean</code>注释也将<code class="du ll lm ln lo b">CalculatorImpl</code>的实例放入应用程序上下文中。</p><p id="a89c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们看到，在产品包级别，我们有:</p><ul class=""><li id="c0ac" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated"><code class="du ll lm ln lo b">com.example.demo.calculator</code>套餐的0%覆盖率</li><li id="f434" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><code class="du ll lm ln lo b">com.example.demo.controller</code>封装中37%的覆盖率，</li><li id="fdfc" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated"><code class="du ll lm ln lo b">com.example.demo</code>中58%的覆盖率</li></ul><p id="662b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们有任何覆盖的唯一原因是<code class="du ll lm ln lo b">DemoApplicationTests</code>中的<code class="du ll lm ln lo b">@SpringBootTest</code>注释启动了一个Spring应用程序上下文，它加载了用<code class="du ll lm ln lo b">@Bean</code>注释的构造函数和方法。这证明了一个重要的观点；你可以在没有任何测试的情况下触发代码覆盖，但是你不应该这么做。从测试中调用代码而不确认调用代码所导致的更改是无效的测试。您可以欺骗Sonar和JaCoCo，但是代码审查人员应该验证代码覆盖率反映了实际验证的值。</p><blockquote class="lt"><p id="9c3d" class="lu lv hh bd lw lx ly lz ma mb mc jm dx translated">这证明了一个重要的观点；您可以在没有任何测试的情况下触发代码覆盖率，但是您不应该这样做。从测试中调用代码而不确认调用代码所导致的更改是无效的测试。您可以欺骗Sonar和JaCoCo，但是代码审查人员应该验证代码覆盖率反映了实际验证的值。</p></blockquote><h1 id="1813" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks me ku kv kw mf ky kz la mg lc ld le bi translated">查看JaCoCo中的单元测试覆盖率</h1><p id="bd94" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">现在我们应该写一些测试。我们可以从已经有的测试<code class="du ll lm ln lo b">DemoApplicationTests</code>开始。这里没有太多要验证的，但是我们可以确保加载了我们业务逻辑的正确实现。在我们的小程序中，很清楚哪个实现被加载到应用程序上下文中，但是对于包含其他人编写的库的较大程序，您可能会意外地依赖于错误的接口实现。使用类路径扫描，您也可能会错过您认为正在加载的类或REST端点。</p><p id="5017" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里有一个测试来验证我们正在实例化正确的东西:</p><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="83c0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们用<code class="du ll lm ln lo b">mvn test jacoco:report</code>再次运行我们的测试覆盖，然后在<code class="du ll lm ln lo b">DemoApplication</code>上向下钻取到方法级别，我们现在看到:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/6f341d71c86f0c2159295b8a5d46a5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n6_6fA2JDOFfPno6"/></div></div></figure><p id="b268" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗯，报道里什么都没变。我们不打算为<code class="du ll lm ln lo b">main</code>添加测试，因为这会启动应用程序，我们不想在单元测试中这样做。但是现在我们实际上正在测试，以确保我们的应用程序加载了正确的类。记住，像圈复杂度和代码覆盖报告这样的东西是帮助人们理解测试和代码质量的工具。最后，一个人必须判断测试是否有效。</p><p id="f905" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们为REST端点添加一个测试。如果查看代码，您会注意到，虽然有Spring注释将其标记为REST端点，将方法映射到URI，并从请求中提取数据，但您不需要Spring或应用程序上下文来测试该类的业务逻辑。</p><p id="6685" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们在不使用Spring的情况下编写我们的单元测试:</p><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="5dc1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为这是一个单元测试，我们只测试类中的功能；类之外的一切都可以(也应该)用模拟实现来替换。我们有一个简单的<code class="du ll lm ln lo b">Calculator</code>实现，然后有两个测试，覆盖了通过控制器方法的两个可能路径(正常返回值和异常)。</p><p id="3234" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们现在查看我们的代码覆盖率，我们会得到:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/dcf625c21cc66884d94cb2c9c08f0109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IHZXdvk9lk5tUTz1"/></div></div></figure><p id="9228" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">进步！我们的控制器包现在有100%的代码覆盖率。</p><p id="7306" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们必须为业务逻辑编写测试。显然，这是应用程序中最复杂的代码。这个包的总复杂度为31，其中21个复杂度点来自一个方法，即<code class="du ll lm ln lo b">CalculatorImpl</code>中的<code class="du ll lm ln lo b">process</code>。这是我们应该集中努力的地方。</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mj"><img src="../Images/c4073ea51e018bcc4692844f681cb67f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rB2IKEsv6-jiOBAB"/></div></div></figure><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><h1 id="48e4" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">初始单元测试结果</h1><p id="79e2" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">在这些测试中有一些事情需要注意。首先，在这些测试中再次没有关于春天的内容。一般来说，您应该避免为您的测试加载Spring应用程序上下文，因为这会大大降低测试速度。</p><p id="cb4e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来是我们处理测试用例的方式。这个业务逻辑为不同的输入返回不同的输出。不要一遍又一遍地重复自己，使用数据驱动的测试来指定预期的输入和预期的输出。JUnit具有内置的参数化支持，易于使用，并为每个数据条目输出不同的测试结果。你可以在<a class="ae lk" href="https://github.com/junit-team/junit4/wiki/Parameterized-tests" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多。</p><p id="03ab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，还有对阴性病例的测试。我们希望确保我们测试的不仅仅是代码中的“黄金路径”。我们还需要了解是什么触发了异常，以及会触发什么异常。</p><p id="c6c6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在添加了这些测试并看到它们通过之后，让我们看看我们的代码覆盖率是什么样的。</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/22bd5b1f842ad2ac530ae902e2730136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aSAYf8WTfTDS9gPV"/></div></div></figure><p id="a9ce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">仅仅几个测试用例就覆盖了很多内容，但是让我们做得更好。让我们看看类级别，这样我们就可以看到方法级别的覆盖率是什么样的:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/f4a101ae114ee6cbaa26ea6594d42153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*94Jus6xiIXz-clez"/></div></div></figure><p id="c1c0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以深入代码，看看<code class="du ll lm ln lo b">process</code>中还有哪些部分没有测试:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div class="er es mm"><img src="../Images/e79adc824dcd6630b8296fb19223a758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*QzUgkzeKsZmvusTQ"/></div></figure><p id="027b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">而在<code class="du ll lm ln lo b">shouldEvaluate</code>:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div class="er es mn"><img src="../Images/15ea548f30d0aab89c1ff8895a6e8c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/0*KMj1t7h9v3WLz96H"/></div></figure><p id="cd93" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">尽管我们已经达到了相当好的测试覆盖率，但是代码中还有很多分支没有被测试。看起来我们需要在测试集中添加一些表达式来触发这些分支。</p><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="c424" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过这些新的测试，我们可以重新检查我们的代码覆盖率，并看到我们的改进:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7d448fbf173c628d6079ebb299d132aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0rCqMjnfREeW8VFt"/></div></div></figure><p id="752f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们再次深入代码，看看哪些部分在<code class="du ll lm ln lo b">process</code>中仍未测试:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div class="er es mo"><img src="../Images/e0f3843a23c2b9ba326c1d885dd657c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/0*71u3GpoHLneQTS7K"/></div></figure><p id="1a02" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">并且在<code class="du ll lm ln lo b">shouldEvaluate</code>中:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mp"><img src="../Images/a1730bbd5dba3bf728635e67cc43c0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GRpK9euZ4xLUVCqu"/></div></div></figure><p id="f2ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">看起来不错。在<code class="du ll lm ln lo b">process</code>中唯一没有测试的是两个引发异常的<code class="du ll lm ln lo b">default</code>开关条件。(该代码目前实际上是不可实现的，但是包含一个<code class="du ll lm ln lo b">default</code>条款是一个好的做法，以防将来的变化触发意外情况。)</p><h1 id="68f4" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">修复bug</h1><p id="ba8d" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">所以，我们结束了，对吗？事实上，我们不是。尽管已经通过了测试，并且拥有接近100%的代码覆盖率。这个程序有两个错误。你见过他们吗？花点时间试着找到它们。</p><p id="f1f5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里有几个暴露漏洞的测试案例:</p><pre class="jn jo jp jq fd mq lo mr ms aw mt bi"><span id="4270" class="mu ki hh lo b fi mv mw l mx my">{"6 / 3", 2, null},</span><span id="c3e3" class="mu ki hh lo b fi mz mw l mx my">{"1 – 1 * 2", -1, null}</span></pre><p id="799c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行这些测试会产生:</p><pre class="jn jo jp jq fd mq lo mr ms aw mt bi"><span id="efc8" class="mu ki hh lo b fi mv mw l mx my">[INFO] Running com.example.demo.calculator.CalculatorTest</span><span id="d0b2" class="mu ki hh lo b fi mz mw l mx my">[ERROR] Tests run: 16, Failures: 2, Errors: 0, Skipped: 0, Time elapsed: 0.169 s &lt;&lt;&lt; FAILURE! — in com.example.demo.calculator.CalculatorTest</span><span id="4f2f" class="mu ki hh lo b fi mz mw l mx my">[ERROR] testProcess[14: CalculatorTest(6 / 3)=2, throws null](com.example.demo.calculator.CalculatorTest) Time elapsed: 0.013 s &lt;&lt;&lt; FAILURE!</span><span id="e72b" class="mu ki hh lo b fi mz mw l mx my">java.lang.AssertionError: expected:&lt;2.0&gt; but was:&lt;18.0&gt;</span><span id="ddad" class="mu ki hh lo b fi mz mw l mx my">at com.example.demo.calculator.CalculatorTest.testProcess(CalculatorTest.java:60)</span><span id="05e1" class="mu ki hh lo b fi mz mw l mx my">[ERROR] testProcess[15: CalculatorTest(1–1 * 2)=-1, throws null](com.example.demo.calculator.CalculatorTest) Time elapsed: 0.001 s &lt;&lt;&lt; FAILURE!</span><span id="89bd" class="mu ki hh lo b fi mz mw l mx my">java.lang.AssertionError: expected:&lt;-1.0&gt; but was:&lt;0.0&gt;</span><span id="d9bd" class="mu ki hh lo b fi mz mw l mx my">at com.example.demo.calculator.CalculatorTest.testProcess(CalculatorTest.java:60)</span></pre><p id="4735" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你在<code class="du ll lm ln lo b">CalculatorImpl</code>的第137行查看，在函数<code class="du ll lm ln lo b">shouldEvaluate</code>中，在<code class="du ll lm ln lo b">if</code>语句的条件中有一个<code class="du ll lm ln lo b">=</code>而不是<code class="du ll lm ln lo b">-</code>。此外，在<code class="du ll lm ln lo b">CalculatorImpl</code>的第106行，在<code class="du ll lm ln lo b">process</code>函数中，当计算<code class="du ll lm ln lo b">/</code>时，代码乘而不是除。如果您能找到这些问题，那么修复它们是很容易的，但是为了找到它们，您需要提供真正代表代码的所有可能输入的数据。这就是为什么开发人员最好自己编写测试的原因之一；开发人员通常最清楚要传入哪种数据。代码覆盖率数字是不够的。</p><p id="8b47" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦我们修复了错误，我们重新运行我们的测试，它们通过了，我们的代码覆盖率实际上稍微好了一些。</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es na"><img src="../Images/eb8008bcbbc36bd1cf9818fd579a167d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ofo0j0wAGAEKVEBf"/></div></div></figure><h1 id="6493" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">重构</h1><p id="819a" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">我们可以在这里停下来，但是<code class="du ll lm ln lo b">process</code>方法确实应该被重构。它的复杂度分数21远远高于我们对单一方法的要求。一个简单的重构就是删除重复的代码。将运算符应用于数字的代码出现了三次。应该分解成自己的方法。既然我们已经有了代码覆盖率良好的单元测试，那么在做这些改变的时候就更容易有信心了。</p><p id="ca85" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的代码现在看起来像这样:</p><figure class="jn jo jp jq fd ii"><div class="bz dy l di"><div class="jr js l"/></div></figure><p id="7a27" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们用<code class="du ll lm ln lo b">mvn test jacoco:report</code>重新运行我们的测试和代码覆盖时，我们现在看到了这个:</p><figure class="jn jo jp jq fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nb"><img src="../Images/92e2165006fa68505677d3dfb5f40a8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9CeGYSRxA5DK_QG-"/></div></div></figure><h1 id="1f86" class="kh ki hh bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">绿色的</h1><p id="ad52" class="pw-post-body-paragraph ip iq hh ir b is lf iu iv iw lg iy iz ja lh jc jd je li jg jh ji lj jk jl jm ha bi translated">那好多了。我们已经降低了复杂性，增加了代码覆盖率，同时确保我们的程序仍然工作，即使在做出更改之后。既然我们已经验证了该功能可以在本地工作，我们就可以确信它已经为拉请求中的代码审查做好了准备。</p><p id="db38" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">测试是许多开发人员避免做的事情。但是通过一些简单的工具和对过程的一些理解，测试帮助你花更少的时间跟踪错误，花更多的时间解决有趣的问题。请记住这些提示:</p><ul class=""><li id="e368" class="jt ju hh ir b is it iw ix ja jv je jw ji jx jm jy jz ka kb bi translated">JaCoCo可以帮助您在本地获得代码覆盖度量。</li><li id="031e" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">一定要为代码库的复杂部分编写测试。</li><li id="96b5" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">代码覆盖率不是一切；100%覆盖率的代码中仍然可能存在bug。</li><li id="250f" class="jt ju hh ir b is kc iw kd ja ke je kf ji kg jm jy jz ka kb bi translated">重构代码的复杂部分，使它们不那么复杂。</li></ul></div><div class="ab cl nc nd go ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ha hb hc hd he"><p id="2381" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些是作者的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被其认可。使用或展示的所有商标和其他知识产权均为其各自所有者所有。本文为2019首都一。</p></div></div>    
</body>
</html>