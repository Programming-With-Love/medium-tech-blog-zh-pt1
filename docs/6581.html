<html>
<head>
<title>Empower Eclipse’s Extension-points with Guice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Guice增强Eclipse的扩展点</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/empower-eclipses-extension-points-with-guice-e75a7e4526bd?source=collection_archive---------3-----------------------#2019-02-20">https://medium.com/quick-code/empower-eclipses-extension-points-with-guice-e75a7e4526bd?source=collection_archive---------3-----------------------#2019-02-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="968e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Eclipse Equinox是OSGi核心规范的一个实现，它允许Eclipse应用程序动态地安装、激活、停用、更新和/或卸载扩展/增强应用程序功能的组件和服务(插件)。一个<em class="jc">插件</em>是一个模块化的、自包含的单元，它提供了一个可以在Eclipse应用程序中使用或者被其他插件使用的API。插件可以提供对Eclipse应用程序UI的增强(例如，附加的菜单、按钮、对话框等)，可以提供允许用户执行任务的Java类(例如，提交到VCS存储库、运行单元测试、将web应用程序部署到服务器等)。)或者两者都有。此外，插件可以提供扩展点，因此用户可以通过添加缺少的/附加的功能来扩展插件。例如，<a class="ae jd" href="https://www.eclipse.org/mylyn/" rel="noopener ugc nofollow" target="_blank"> Mylyn </a>插件定义了扩展点，允许用户连接到开箱即用的任务服务。</p><h1 id="e1cb" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">扩展点</h1><p id="3fdb" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">简单地说，扩展点定义了一个插件和其他希望扩展其功能的插件之间的契约。这通常包括一组必须配置的参数和/或实现特定接口(也支持类扩展)的类的限定名。扩展插件必须提供所有这些信息。在运行时，Equinox api可用于查找哪些插件扩展了特定的扩展点，检索参数值并实例化适当的类。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/d923376f3fd5e76cb000fc9f737f520e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g3D_fKOQukGxrtyyzTLhew.png"/></div></div></figure><p id="62b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上图展示了如何定义一个简单的扩展点。这个扩展点允许插件贡献它们自己的API实现，该API是在类org . eclipse . epsilon . imoduletracerepository中定义的。假设我们想提供一个可以处理文本文件的实现和另一个可以处理数据库的实现。为了访问它们中的每一个，需要一组不同的信息；例如，对于文件，路径/位置就足够了，对于数据库，我们可能需要url、登录凭证和目标数据库。因此，每个实现都需要一个单独的配置对话框来提供必要的信息。我们可以通过向我们的扩展点添加另一个属性来解决这个问题，通过它也提供了要使用的特定配置对话框，如下图所示。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kt"><img src="../Images/5270412936fa294efedce146b7e32eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otZGJ5B0wH2tg64yVN9S6w.png"/></div></div></figure><h1 id="181c" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">管理扩展点</h1><p id="5da0" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">扩展点信息存储在扩展点模式中(带有<em class="jc">的xml文件)。exsd </em>扩展名)，它们是从插件的<em class="jc"> plugin.xml </em>元数据文件中引用的。这意味着，尽管在创建扩展点时，内容辅助或类选择工具帮助我们挑选现有的类，<em class="jc">扩展/实现了</em>信息以纯文本形式存储。这样做的最大后果是扩展点方案中的信息与java代码脱节。因此，诸如更改类名或包之类的重构会破坏扩展点。然而，在扩展插件加载到Eclipse应用程序之前，这个错误不会出现。</p><p id="7cda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，扩展点有许多需要提供的文档。因为模式不是主要代码库的一部分，所以更容易让这些信息变得陈旧(或者根本不提供)。此外，添加/删除API变得非常耗时。创建新元素/属性，定义其属性，指向正确的类，添加描述，更新扩展点文档…此外，扩展点成为API的固有部分，在确定是否需要主要、次要或修补程序时，必须考虑对其进行任何更改。</p><h1 id="a63a" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">依赖注入拯救</h1><p id="c8b9" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">理想情况下，我们希望定义一次扩展点，并尽可能少地改变它们。这需要我们预见可能的扩展点，并为它们做好准备。实际上，直到添加了新的特性/功能，并且随着应用程序架构的改变，我们才能够确定需要什么扩展点。例如，在我们广泛介绍的插件中，我们可能会先发制人地防范其他类型的存储库……但是如果我们也想允许扩展插件来贡献工厂、任务管理器等，该怎么办呢？</p><p id="a920" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">一个利落的办法，IMHO，就是通过依赖注入来解决这个。</em>T9】</strong></p><p id="e61f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jd" href="https://github.com/google/guice" rel="noopener ugc nofollow" target="_blank"> Guice </a>是Google开发的依赖注入框架。</p><blockquote class="ku kv kw"><p id="32d3" class="ie if jc ig b ih ii ij ik il im in io kx iq ir is ky iu iv iw kz iy iz ja jb ha bi translated">…注入只是一种设计模式。核心原则是<em class="hh">将行为与依赖解析</em>分开。</p></blockquote><p id="8f6a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">也就是说，类不再负责查找它们执行所需的对象，这些应该在构造时提供。Guice框架处理“构造期间的供应”(也称为注入)，你需要做的就是<strong class="ig hi"> a) </strong>告诉Guice它负责注入什么依赖关系(通过注释)以及<strong class="ig hi"> b) </strong>在注入期间使用什么实现。后者是通过扩展<strong class="ig hi"> AbstractModule </strong>类来完成的。</p><p id="ee62" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们将所有依赖解析委托给Guice，这意味着我们可以极大地简化我们的扩展点。怎么会？在前面的例子中，我们可以改变我们的扩展点来接受扩展Guice的AbstractModule的类。也就是说，扩展插件提供了一个绑定所需实现的Guice模块。</p><h1 id="1927" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">把所有的放在一起</h1><p id="e203" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">我将假设我们修改了基本代码，现在IModuleTraceRepository和friends是通过注入提供的。然后，我们更改扩展点以接受AbstractModule:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es la"><img src="../Images/be64e33944dde813ee59953fd657ae3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOQoM_10M8jGnkYZWxKnIQ.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx">The TraceRepository implementation is replaced by a Guice module that can provide all bindings.</figcaption></figure><p id="acf0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，扩展插件可以提供自己的AbstractModule实现:</p><pre class="ki kj kk kl fd lf lg lh li aw lj bi"><span id="2b57" class="lk jf hh lg b fi ll lm l ln lo"><strong class="lg hi">public</strong> <strong class="lg hi">class</strong> MyTraceGuiceModule <strong class="lg hi">extends</strong> AbstractModule {</span><span id="28a7" class="lk jf hh lg b fi lp lm l ln lo">@Override<br/><strong class="lg hi">protected</strong> <strong class="lg hi">void</strong> configure() {<br/>    bind(IModuleTraceRepository.<strong class="lg hi">class</strong>).to(MyModuleTraceRepo.<strong class="lg hi">class</strong>);<br/>}</span></pre><p id="bd9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并在扩展配置中提供它。</p><p id="784c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，如果将来我们需要其他类型的存储库，可能是工厂或其他实现，我们不需要更改扩展点定义，扩展插件只需要添加更多绑定:</p><pre class="ki kj kk kl fd lf lg lh li aw lj bi"><span id="2071" class="lk jf hh lg b fi ll lm l ln lo"><strong class="lg hi">public</strong> <strong class="lg hi">class</strong> MyTraceGuiceModule <strong class="lg hi">extends</strong> AbstractModule {</span><span id="8f67" class="lk jf hh lg b fi lp lm l ln lo">@Override<br/><strong class="lg hi">protected</strong> <strong class="lg hi">void</strong> configure() {<br/>    bind(IModuleTraceRepository.<strong class="lg hi">class</strong>).to(MyModuleTraceRepo.<strong class="lg hi">class</strong>);<br/>    bind(IModelTraceRepository.<strong class="lg hi">class</strong>).to(MyModelTraceRepo.<strong class="lg hi">class</strong>);<br/>    bind(IElementFactory.<strong class="lg hi">class</strong>).to(MyElementFactory.<strong class="lg hi">class</strong>);<br/>    ...<br/>}</span></pre></div><div class="ab cl lq lr go ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ha hb hc hd he"><p id="28aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这仍然没有解决文档的问题。如果扩展点定义中列出了所需的绑定，那么这些信息可能会在一段时间后变得陈旧。解决这个问题的一个方法是为您自己的AbstractModule扩展提供列出所需绑定的Javadoc注释。此外，这个类可以有一个方法，该方法可以检查是否已经提供了所有需要的绑定，并发出警告/异常以通知开发人员。大致如下:</p><pre class="ki kj kk kl fd lf lg lh li aw lj bi"><span id="dccf" class="lk jf hh lg b fi ll lm l ln lo">class YourModule extends AbstractModule {</span><span id="1a23" class="lk jf hh lg b fi lp lm l ln lo">@Override protected void configure() { }<br/><br/>  void validateBindings(Injector injector) {<br/>    <!-- -->Set&lt;Class&lt;?&gt;&gt; reqInterfaces = <strong class="lg hi">new</strong> HashSet&lt;&gt;(<br/>      Arrays.<em class="jc">asList</em>(<br/>        IModuleTraceRepository.<strong class="lg hi">class,<br/>        </strong>IModelTraceRepository.<strong class="lg hi">class,<br/>        </strong>IElementFactory.<strong class="lg hi">class,<br/>        ...));</strong></span><span id="6eab" class="lk jf hh lg b fi lp lm l ln lo">    req<!-- -->.removeAll(injector.getAllBindings().keySet().stream()<br/>      .map(k -&gt; k.getTypeLiteral().getRawType())<br/>      .collect(Collectors.<em class="jc">toSet</em>()));<br/>    if (!req.isEmpty()) {<br/>      throw new IllegalStateException("Missing bindings: " + req);<br/>    }<br/>  }<br/>}</span></pre><h1 id="3dba" class="je jf hh bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">结局</h1><p id="0a07" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip ke ir is it kf iv iw ix kg iz ja jb ha bi translated">Guice注入可以简化您的扩展点管理。试试吧，让我在下面的评论中知道它的进展如何。</p><figure class="ki kj kk kl fd km er es paragraph-image"><a href="https://www.buymeacoffee.com/KinoriTech"><div class="er es lx"><img src="../Images/041a0c7464198414e6ce355f9235099e.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*SGCT6C60o4t58wRqeU2viQ.png"/></div></a></figure></div></div>    
</body>
</html>