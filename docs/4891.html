<html>
<head>
<title>Item 30: Consider factory functions instead of constructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第30条:考虑工厂函数而不是构造函数</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/item-30-consider-factory-functions-instead-of-constructors-e1c747fc475?source=collection_archive---------1-----------------------#2019-09-17">https://blog.kotlin-academy.com/item-30-consider-factory-functions-instead-of-constructors-e1c747fc475?source=collection_archive---------1-----------------------#2019-09-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/b84f5bfef04c53c790c24c717c1ae2a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TFRSFuSaayDUshnf.jpg"/></div></div></figure><div class=""/><p id="8da6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">更新:</strong> <a class="ae kt" href="https://kt.academy/article/ek-factory-functions" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz">这里的</strong> </a> <strong class="jx iz">是这篇文章的最新版本。</strong></p><blockquote class="ku kv kw"><p id="9909" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated">这是本书<a class="ae kt" href="https://leanpub.com/effectivekotlin/" rel="noopener ugc nofollow" target="_blank">有效科特林</a>的一部分。从概念上讲，这是同一作者对本文的扩展，基于Joshoua Bloch的《有效的Java》一书的第一条。</p></blockquote><p id="e696" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Kotlin中，类允许客户端获取实例的最常见方式是提供一个主构造函数:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ffd8" class="lk ll iy lg b gy lm ln l lo lp">class MyLinkedList&lt;T&gt;(val head: T, val tail: MyLinkedList&lt;T&gt;?)</span><span id="d53c" class="lk ll iy lg b gy lq ln l lo lp">val list = MyLinkedList(1, MyLinkedList(2, null))</span></pre><p id="9544" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然构造函数不是创建对象的唯一方法。对象实例化有许多创造性的设计模式。它们中的大多数都围绕着这样一个想法，即函数可以为我们创建对象，而不是直接创建对象。例如，下面的顶级函数创建了一个<code class="fe lr ls lt lg b">MyLinkedList</code>的实例:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="eeb2" class="lk ll iy lg b gy lm ln l lo lp">fun &lt;T&gt; myLinkedListOf(vararg elements: T): MyLinkedList&lt;T&gt;? {<br/>   if(elements.isEmpty()) return null<br/>   val head = elements.first()<br/>   val elementsTail = elements.copyOfRange(1, elements.size)<br/>   val tail = myLinkedListOf(*elementsTail)<br/>   return MyLinkedList(head, tail)<br/>}</span><span id="c49e" class="lk ll iy lg b gy lq ln l lo lp">val list = myLinkedListOf(1, 2)</span></pre><p id="d83b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为构造函数的替代函数被称为工厂函数，因为它们产生一个对象。使用工厂函数代替构造函数有很多优点，包括:</p><ul class=""><li id="ecf2" class="lu lv iy jx b jy jz kc kd kg lw kk lx ko ly ks lz ma mb mc bi translated"><strong class="jx iz">与构造函数不同，函数有名字。</strong>名字解释了一个对象是如何被创建的，参数是什么。比如说你看到下面这段代码:<code class="fe lr ls lt lg b">ArrayList(3)</code>。你能猜出这个论点是什么意思吗？它应该是新创建的列表中的第一个元素，还是列表的大小？肯定不是不言自明的。在这种情况下，一个像<code class="fe lr ls lt lg b">ArrayList.withSize(3)</code>这样的名字可以消除任何困惑。名称非常有用:它们解释了对象创建的参数或特有方式。命名的另一个原因是它解决了具有相同参数类型的构造函数之间的冲突。</li><li id="8dad" class="lu lv iy jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><strong class="jx iz">与构造函数不同，函数可以返回其返回类型的任何子类型的对象。</strong>这可以用来为不同的情况提供更好的对象。当我们想要将实际的对象实现隐藏在接口后面时，这一点尤其重要。想到stdlib(标准库)里的<code class="fe lr ls lt lg b">listOf</code>。它声明的返回类型是<code class="fe lr ls lt lg b">List</code>，这是一个接口。它真正的回报是什么？答案取决于我们使用的平台。对于Kotlin/JVM、Kotlin/JS和Kotlin/Native来说是不同的，因为它们各自使用不同的内置集合。这是Kotlin团队做出的重要优化。这也给了Kotlin创建者更多的自由，因为列表的实际类型可能会随着时间的推移而改变，只要新对象仍然实现接口<code class="fe lr ls lt lg b">List</code>并以同样的方式运行，一切都会好的。</li><li id="e289" class="lu lv iy jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated">与构造函数不同，函数不需要在每次被调用时都创建一个新对象。这很有帮助，因为当我们使用函数创建对象时，我们可以包含一个缓存机制来优化对象创建，或者在某些情况下确保对象重用(比如在Singleton模式中)。我们还可以定义一个静态工厂函数，如果不能创建对象，它将返回<code class="fe lr ls lt lg b">null</code>。比如<code class="fe lr ls lt lg b">Connections.createOrNull()</code>，当<code class="fe lr ls lt lg b">Connection</code>由于某种原因无法创建时，它返回<code class="fe lr ls lt lg b">null</code>。</li><li id="aa9d" class="lu lv iy jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><strong class="jx iz">工厂函数可以提供可能尚不存在的对象。</strong>这被基于注释处理的库的创建者大量使用。这样，程序员可以在不构建项目的情况下，通过代理对将要生成或使用的对象进行操作。</li><li id="f87e" class="lu lv iy jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><strong class="jx iz">当我们在对象外部定义工厂函数时，我们可以控制它的可见性。</strong>例如，我们可以使一个顶级工厂函数只能在同一个文件或同一个模块中访问。</li><li id="c8f5" class="lu lv iy jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><strong class="jx iz">工厂函数可以内联，因此它们的类型参数可以具体化。</strong></li><li id="9361" class="lu lv iy jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><strong class="jx iz">工厂函数可以构造原本可能很难构造的对象。</strong></li><li id="b1ad" class="lu lv iy jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated"><strong class="jx iz">构造函数需要立即调用超类的构造函数或者主构造函数。当我们使用工厂函数时，我们可以推迟构造函数的使用:</strong></li></ul><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2a54" class="lk ll iy lg b gy lm ln l lo lp">fun makeListView(config: Config) : ListView {<br/>   val items = … // Here we read items from config<br/>   return ListView(items) // We call actual constructor<br/>}</span></pre><p id="1926" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">工厂函数的使用有一个限制:它不能在子类构造中使用。这是因为在子类构造中，我们需要调用超类构造函数。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ee7f" class="lk ll iy lg b gy lm ln l lo lp">class IntLinkedList: MyLinkedList&lt;Int&gt;() {<br/>   // Supposing that MyLinkedList is open</span><span id="fd86" class="lk ll iy lg b gy lq ln l lo lp">   constructor(vararg ints: Int): myLinkedListOf(*ints) // Error<br/>}</span></pre><p id="9ad1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这通常不是问题，因为如果我们已经决定使用工厂函数创建超类，为什么我们要为它的子类使用构造函数呢？我们应该考虑为这样的类实现一个工厂函数。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a109" class="lk ll iy lg b gy lm ln l lo lp">class MyLinkedIntList(<br/>   head: Int, <br/>   tail: MyLinkedIntList?<br/>): MyLinkedList&lt;Int&gt;(head, tail)</span><span id="98c1" class="lk ll iy lg b gy lq ln l lo lp">fun myLinkedIntListOf(vararg elements: Int): MyLinkedIntList? {<br/>   if(elements.isEmpty()) return null<br/>   val head = elements.first()<br/>   val elementsTail = elements.copyOfRange(1, elements.size)<br/>   val tail = myLinkedIntListOf(*elementsTail)<br/>   return MyLinkedIntList(head, tail)<br/>}</span></pre><p id="f2e2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的函数比前一个构造函数长，但是它有更好的特性——灵活性、类的独立性和声明可空返回类型的能力。</p><p id="5a6b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">工厂函数背后有强大的理由，尽管需要理解的是<strong class="jx iz">它们不是主构造函数</strong>的竞争对手。工厂函数仍然需要在其主体中使用构造函数，因此构造函数必须存在。如果我们真的想使用工厂函数强制创建，它可以是私有的，但是我们很少这样做(<em class="kx"> Item 31:考虑带有命名可选参数</em>的主构造函数)。<strong class="jx iz">工厂函数主要是对二级构造函数的竞争</strong>，纵观Kotlin项目，它们通常以二级构造函数取胜，而很少使用。<strong class="jx iz">他们之间也存在竞争，因为有各种不同的工厂职能。</strong>让我们讨论不同的Kotlin工厂功能:</p><ol class=""><li id="d2bd" class="lu lv iy jx b jy jz kc kd kg lw kk lx ko ly ks mi ma mb mc bi translated">伴随对象工厂函数</li><li id="e19e" class="lu lv iy jx b jy md kc me kg mf kk mg ko mh ks mi ma mb mc bi translated">扩展工厂功能</li><li id="6f32" class="lu lv iy jx b jy md kc me kg mf kk mg ko mh ks mi ma mb mc bi translated">顶级工厂功能</li><li id="b7f9" class="lu lv iy jx b jy md kc me kg mf kk mg ko mh ks mi ma mb mc bi translated">假构造函数</li><li id="f10c" class="lu lv iy jx b jy md kc me kg mf kk mg ko mh ks mi ma mb mc bi translated">工厂类上的方法</li></ol><figure class="lb lc ld le gt ip gh gi paragraph-image"><a href="https://kt.academy/workshop/abTesting"><div class="gh gi mj"><img src="../Images/c92f7d012bc612fef84f3edd03fe40a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ri-r2vZr9ONwve4vWvT_gg.png"/></div></a></figure><h2 id="ce88" class="lk ll iy bd mk ml mm dn mn mo mp dp mq kg mr ms mt kk mu mv mw ko mx my mz na bi translated">伴随对象工厂函数</h2><p id="9788" class="pw-post-body-paragraph jv jw iy jx b jy nb ka kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">定义工厂函数最流行的方法是在一个伴随对象中定义它:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5f5e" class="lk ll iy lg b gy lm ln l lo lp">class MyLinkedList&lt;T&gt;(val head: T, val tail: MyLinkedList&lt;T&gt;?) {</span><span id="521c" class="lk ll iy lg b gy lq ln l lo lp">   companion object {<br/>      fun &lt;T&gt; of(vararg elements: T): MyLinkedList&lt;T&gt;? { /*...*/ }<br/>   }<br/>}</span><span id="3052" class="lk ll iy lg b gy lq ln l lo lp">// Usage<br/>val list = MyLinkedList.of(1, 2)</span></pre><p id="3e9d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Java开发人员应该非常熟悉这种方法，因为它直接等同于静态工厂方法。尽管其他语言的开发人员可能也很熟悉它。在一些语言中，如C++，它被称为<em class="kx">命名构造函数习语</em>，因为它的用法类似于构造函数，但有一个名称。</p><p id="1ab8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Kotlin中，这种方法也适用于接口:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9ed5" class="lk ll iy lg b gy lm ln l lo lp">class MyLinkedList&lt;T&gt;(<br/>   val head: T, <br/>   val tail: MyLinkedList&lt;T&gt;?<br/>): MyList&lt;T&gt; {<br/>   // ...<br/>}</span><span id="918c" class="lk ll iy lg b gy lq ln l lo lp">interface MyList&lt;T&gt; {<br/>// ...</span><span id="4d22" class="lk ll iy lg b gy lq ln l lo lp">   companion object {<br/>      fun &lt;T&gt; of(vararg elements: T): MyList&lt;T&gt;? {<br/>         // ...<br/>      }<br/>   }<br/>}</span><span id="ba36" class="lk ll iy lg b gy lq ln l lo lp">// Usage<br/>val list = MyList.of(1, 2)</span></pre><p id="efcd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，上述函数的名称并不是真正的描述性的，但是对于大多数开发人员来说应该是可以理解的。原因是有一些来自Java的约定，多亏了它们，一个简短的单词就足以理解参数的意思。以下是一些常见的名称及其描述:</p><ul class=""><li id="be57" class="lu lv iy jx b jy jz kc kd kg lw kk lx ko ly ks lz ma mb mc bi translated"><code class="fe lr ls lt lg b">from</code> —采用单个参数并返回相同类型的对应实例的类型转换函数，例如:</li></ul><p id="06ef" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lr ls lt lg b">val date: Date = Date.from(instant)</code></p><ul class=""><li id="5c77" class="lu lv iy jx b jy jz kc kd kg lw kk lx ko ly ks lz ma mb mc bi translated"><code class="fe lr ls lt lg b">of</code> —采用多个参数并返回包含这些参数的同一类型实例的聚合函数，例如:</li></ul><p id="9212" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lr ls lt lg b">val faceCards: Set&lt;Rank&gt; = EnumSet.of(JACK, QUEEN, KING)</code></p><ul class=""><li id="56a5" class="lu lv iy jx b jy jz kc kd kg lw kk lx ko ly ks lz ma mb mc bi translated"><code class="fe lr ls lt lg b">valueOf</code>——比<code class="fe lr ls lt lg b">from</code>和<code class="fe lr ls lt lg b">of</code>更详细的替代方案，例如:</li></ul><p id="5db9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lr ls lt lg b">val prime: BigInteger = BigInteger.valueOf(Integer.MAX_VALUE)</code></p><ul class=""><li id="ed4b" class="lu lv iy jx b jy jz kc kd kg lw kk lx ko ly ks lz ma mb mc bi translated"><code class="fe lr ls lt lg b">instance</code>或<code class="fe lr ls lt lg b">getInstance</code> —用在单例中以获得唯一的实例。参数化时，将返回由参数参数化的实例。通常，当参数相同时，我们可以预期返回的实例总是相同的，例如:</li></ul><p id="105b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lr ls lt lg b">val luke: StackWalker = StackWalker.getInstance(options)</code></p><ul class=""><li id="85b3" class="lu lv iy jx b jy jz kc kd kg lw kk lx ko ly ks lz ma mb mc bi translated"><code class="fe lr ls lt lg b">createInstance</code>或<code class="fe lr ls lt lg b">newInstance</code>——类似于<code class="fe lr ls lt lg b">getInstance</code>，但是这个函数保证每个调用返回一个新的实例，例如:</li></ul><p id="6a54" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lr ls lt lg b">val newArray = Array.newInstance(classObject, arrayLen)</code></p><ul class=""><li id="8b63" class="lu lv iy jx b jy jz kc kd kg lw kk lx ko ly ks lz ma mb mc bi translated"><code class="fe lr ls lt lg b">getType</code> —与<code class="fe lr ls lt lg b">getInstance</code>相似，但如果工厂功能在不同的类中使用。Type是工厂函数返回的对象的类型，例如:</li></ul><p id="1767" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lr ls lt lg b">val fs: FileStore = Files.getFileStore(path)</code></p><ul class=""><li id="3060" class="lu lv iy jx b jy jz kc kd kg lw kk lx ko ly ks lz ma mb mc bi translated"><code class="fe lr ls lt lg b">newType</code> —与<code class="fe lr ls lt lg b">newInstance</code>相似，但如果工厂功能在不同的类中使用。Type是工厂函数返回的对象的类型，例如:</li></ul><p id="57ce" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lr ls lt lg b">val br: BufferedReader = Files.newBufferedReader(path)</code></p><p id="48eb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">许多经验不足的Kotlin开发人员将伴随对象成员视为需要分组到单个块中的静态成员。然而，伴随对象实际上要强大得多:例如，伴随对象可以实现接口和扩展类。因此，我们可以实现如下所示的通用伴随对象工厂函数:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="598b" class="lk ll iy lg b gy lm ln l lo lp"><strong class="lg iz">abstract class </strong>ActivityFactory {<br/>   <strong class="lg iz">abstract fun </strong>getIntent(context: Context): Intent</span><span id="2451" class="lk ll iy lg b gy lq ln l lo lp"><strong class="lg iz">   fun </strong>start(context: Context) {<br/>      <strong class="lg iz">val </strong>intent = getIntent(context)<br/>      context.startActivity(intent)<br/>   }</span><span id="d5be" class="lk ll iy lg b gy lq ln l lo lp"><strong class="lg iz">   fun </strong>startForResult(activity: Activity, requestCode: Int) {<br/>      <strong class="lg iz">val </strong>intent = getIntent(activity)<br/>      activity.startActivityForResult(intent, requestCode)<br/>   }<br/>}</span><span id="ad00" class="lk ll iy lg b gy lq ln l lo lp"><strong class="lg iz">class </strong>MainActivity : AppCompatActivity() {<br/>   <em class="kx">//...</em></span><span id="54d7" class="lk ll iy lg b gy lq ln l lo lp"><strong class="lg iz">   companion object</strong>: ActivityFactory() {<br/>      <strong class="lg iz">override fun </strong>getIntent(context: Context): Intent =<br/>         Intent(context, MainActivity::<strong class="lg iz">class</strong>.<em class="kx">java</em>)<br/>   }<br/>}</span><span id="8114" class="lk ll iy lg b gy lq ln l lo lp">// Usage<br/><strong class="lg iz">val </strong>intent = MainActivity.getIntent(context)<br/>MainActivity.start(context)<br/>MainActivity.startForResult(activity, requestCode)</span></pre><p id="3369" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，这样的抽象伙伴对象工厂可以保存值，因此它们可以实现缓存或支持测试的伪创建。在Kotlin编程社区中，伴随对象的优势没有得到很好的利用。尽管如此，如果你看看Kotlin团队产品的实现，你会发现伴随对象被大量使用。例如，在Kotlin协同程序库中，几乎每一个协同程序上下文的伴随对象都实现了一个接口<code class="fe lr ls lt lg b">CoroutineContext.Key</code>，因为它们都是我们用来识别这个上下文的关键字。</p><h2 id="d86e" class="lk ll iy bd mk ml mm dn mn mo mp dp mq kg mr ms mt kk mu mv mw ko mx my mz na bi translated">扩展工厂功能</h2><p id="0d6a" class="pw-post-body-paragraph jv jw iy jx b jy nb ka kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">有时，我们希望创建一个工厂函数，其行为类似于一个现有的伴随对象函数，而我们要么不能修改这个伴随对象，要么只想在一个单独的文件中指定一个新函数。在这种情况下，我们可以利用伴随对象的另一个优势:我们可以为它们定义扩展函数。</p><p id="a505" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们不能改变<code class="fe lr ls lt lg b">Tool</code>接口:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6c6e" class="lk ll iy lg b gy lm ln l lo lp">interface Tool {<br/>   /*...*/</span><span id="bb4c" class="lk ll iy lg b gy lq ln l lo lp">   companion object { /*...*/ }<br/>}</span></pre><p id="f742" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管如此，我们可以在其伴随对象上定义一个扩展函数(当这个类或接口声明了任何伴随对象时，至少是一个空对象):</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e67a" class="lk ll iy lg b gy lm ln l lo lp">fun Tool.Companion.createBigTool( /*...*/ ) : BigTool { /*...*/ }</span></pre><p id="6ec3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在调用站点，我们可以写:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f545" class="lk ll iy lg b gy lm ln l lo lp">Tool.createBigTool()</span></pre><p id="cc42" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个强大的可能性，让我们用自己的工厂方法扩展外部库。一个问题是，要对伴随对象进行扩展，必须有一些(甚至是空的)伴随对象:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b67c" class="lk ll iy lg b gy lm ln l lo lp">interface Tool {<br/>   /*...*/</span><span id="1556" class="lk ll iy lg b gy lq ln l lo lp">   companion object {}<br/>}</span></pre><h2 id="724b" class="lk ll iy bd mk ml mm dn mn mo mp dp mq kg mr ms mt kk mu mv mw ko mx my mz na bi translated">顶级功能</h2><p id="efe7" class="pw-post-body-paragraph jv jw iy jx b jy nb ka kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">创建对象的一种流行方法是使用顶级工厂函数。一些常见的例子有<code class="fe lr ls lt lg b">listOf</code>、<code class="fe lr ls lt lg b">setOf</code>和<code class="fe lr ls lt lg b">mapOf</code>。类似地，库设计者指定用于创建对象的顶级函数。顶级工厂函数被广泛使用。比如在Android中，我们有定义一个函数来创建一个<code class="fe lr ls lt lg b">Intent</code>来开始一个活动的传统。在Kotlin中，<code class="fe lr ls lt lg b">getIntent()</code>可以写成一个伴随对象函数:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b679" class="lk ll iy lg b gy lm ln l lo lp">class MainActivity: Activity {</span><span id="2e54" class="lk ll iy lg b gy lq ln l lo lp">   companion object {<br/>      fun getIntent(context: Context) =<br/>         Intent(context, MainActivity::class.java)<br/>   }<br/>}</span></pre><p id="663d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Kotlin Anko库中，我们可以使用具体化类型的顶级函数<code class="fe lr ls lt lg b">intentFor</code>来代替:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ad23" class="lk ll iy lg b gy lm ln l lo lp">intentFor&lt;MainActivity&gt;()</span></pre><p id="c1c2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该函数也可用于传递参数:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6e5a" class="lk ll iy lg b gy lm ln l lo lp">intentFor&lt;MainActivity&gt;("page" to 2, "row" to 10)</span></pre><p id="94e4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用顶级函数创建对象对于像<code class="fe lr ls lt lg b">List</code>或<code class="fe lr ls lt lg b">Map</code>这样的小而常用的对象来说是一个完美的选择，因为<code class="fe lr ls lt lg b">listOf(1,2,3)</code>比<code class="fe lr ls lt lg b">List.of(1,2,3)</code>更简单，可读性更好。但是，公共顶级函数需要谨慎使用。公共顶级函数有一个缺点:它们随处可用。很容易混淆开发人员的IDE提示。当顶级函数像类方法一样命名并且与类方法混淆时，问题变得更加严重。这就是为什么顶级函数应该被明智地命名。</p><h2 id="0eee" class="lk ll iy bd mk ml mm dn mn mo mp dp mq kg mr ms mt kk mu mv mw ko mx my mz na bi translated">假构造函数</h2><p id="4bdc" class="pw-post-body-paragraph jv jw iy jx b jy nb ka kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">Kotlin中构造函数的用法与顶级函数相同:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="50bd" class="lk ll iy lg b gy lm ln l lo lp">class A</span><span id="b37c" class="lk ll iy lg b gy lq ln l lo lp">val a = A()</span></pre><p id="ecc5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它们的引用也与顶级函数相同(构造函数引用实现函数接口):</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="af0f" class="lk ll iy lg b gy lm ln l lo lp">val reference: ()-&gt;A = ::A</span></pre><p id="1aad" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从用法的角度来看，大写是构造函数和函数的唯一区别。按照惯例，类以大写字母开头；函数是小写字母。虽然技术上函数可以以大写字母开头。这个事实被用在不同的地方，例如，在Kotlin标准库的情况下。<code class="fe lr ls lt lg b">List</code>和<code class="fe lr ls lt lg b">MutableList</code>是接口。他们不能有构造函数，但是Kotlin开发者希望允许下面的<code class="fe lr ls lt lg b">List</code>构造:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="cf11" class="lk ll iy lg b gy lm ln l lo lp">List(4) { "User$it" } // [User0, User1, User2, User3]</span></pre><p id="e0ee" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是Collections.kt中包含以下函数(从Kotlin 1.1开始)的原因:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7307" class="lk ll iy lg b gy lm ln l lo lp">public inline fun &lt;T&gt; List(<br/>   size: Int,<br/>   init: (index: Int) -&gt; T<br/>): List&lt;T&gt; = MutableList(size, init)</span><span id="a62d" class="lk ll iy lg b gy lq ln l lo lp">public inline fun &lt;T&gt; MutableList(<br/>   size: Int,<br/>   init: (index: Int) -&gt; T<br/>): MutableList&lt;T&gt; {<br/>   val list = ArrayList&lt;T&gt;(size)<br/>   repeat(size) { index -&gt; list.add(init(index)) }<br/>   return list<br/>}</span></pre><p id="6345" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些顶级函数的外观和行为都像构造函数，但它们拥有工厂函数的所有优点。许多开发人员没有意识到他们是幕后的顶级功能。这就是为什么他们经常被称为<em class="kx">假施工人员</em>。</p><p id="7abd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发人员选择假构造函数而不是真构造函数的两个主要原因是:</p><ul class=""><li id="ede2" class="lu lv iy jx b jy jz kc kd kg lw kk lx ko ly ks lz ma mb mc bi translated">拥有接口的“构造函数”</li><li id="ef85" class="lu lv iy jx b jy md kc me kg mf kk mg ko mh ks lz ma mb mc bi translated">具有具体化的类型参数</li></ul><p id="eeb7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除此之外，伪构造函数的行为应该像普通构造函数一样。它们看起来像构造函数，它们应该这样表现。如果你想包含缓存，返回一个可空类型或者返回一个可以被创建的类的子类，考虑使用一个有名字的工厂函数，比如一个伴随对象工厂方法。</p><p id="15df" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有一种方法可以声明伪构造函数。使用带有<code class="fe lr ls lt lg b">invoke</code>操作符的伴随对象可以获得类似的结果。看一下下面的例子:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4b6f" class="lk ll iy lg b gy lm ln l lo lp">class Tree&lt;T&gt; {</span><span id="6f86" class="lk ll iy lg b gy lq ln l lo lp">   companion object {<br/>      operator fun &lt;T&gt; invoke(size: Int, generator: (Int)-&gt;T): Tree&lt;T&gt;{<br/>         //...<br/>      }<br/>   }<br/>}</span><span id="88e7" class="lk ll iy lg b gy lq ln l lo lp">// Usage<br/>Tree(10) { "$it" }</span></pre><p id="c1de" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，在一个伴随对象中实现<code class="fe lr ls lt lg b">invoke</code>来制造一个假的构造函数是很少使用的，我不推荐这样做。首先，因为它打破了<em class="kx">第12项:根据名字使用运算符方法</em>。调用伴随对象是什么意思？请记住，可以使用名称来代替运算符:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0031" class="lk ll iy lg b gy lm ln l lo lp">Tree.invoke(10) { "$it" }</span></pre><p id="2199" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">调用是与对象构造不同的操作。以这种方式使用运算符与其名称不一致。更重要的是，这种方法比一个顶级函数更复杂。看他们的倒影就能看出这种复杂性。比较一下当我们在一个伴随对象中引用一个构造函数、伪构造函数和<code class="fe lr ls lt lg b">invoke</code>函数时，反射是什么样子:</p><p id="d10e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">构造者:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="584e" class="lk ll iy lg b gy lm ln l lo lp">val f: ()-&gt;Tree = ::Tree</span></pre><p id="3bed" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假构造器:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="df0a" class="lk ll iy lg b gy lm ln l lo lp">val f: ()-&gt;Tree = ::Tree</span></pre><p id="a3dc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在伴随对象中调用:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="be05" class="lk ll iy lg b gy lm ln l lo lp">val f: ()-&gt;Tree = Tree.Companion::invoke</span></pre><p id="52f2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当你需要一个假的构造函数时，我推荐使用标准的顶级函数。当我们不能在类本身中定义构造函数时，或者当我们需要构造函数没有提供的功能时(比如具体化的类型参数)，应该谨慎地使用这些方法来建议典型的类似构造函数的用法。</p><h2 id="fa2b" class="lk ll iy bd mk ml mm dn mn mo mp dp mq kg mr ms mt kk mu mv mw ko mx my mz na bi translated">工厂类上的方法</h2><p id="557b" class="pw-post-body-paragraph jv jw iy jx b jy nb ka kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">有许多与工厂类相关的创造模式。例如，抽象工厂或原型。他们每个人都有一些优点。</p><p id="16ec" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将会看到，其中一些方法在科特林是不合理的。在下一个项目中，我们将看到伸缩构造器和构建器模式在Kotlin中很少有意义。</p><p id="017e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">工厂类比工厂函数更有优势，因为类可以有状态。例如，这个非常简单的工厂类生成具有下一个id号的学生:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="cf33" class="lk ll iy lg b gy lm ln l lo lp">data class Student(<br/>   val id: Int,<br/>   val name: String,<br/>   val surname: String<br/>)</span><span id="daa9" class="lk ll iy lg b gy lq ln l lo lp">class StudentsFactory {<br/>   var nextId = 0<br/>   <br/>   fun next(name: String, surname: String) =<br/>      Student(nextId++, name, surname)<br/>}</span><span id="1b74" class="lk ll iy lg b gy lq ln l lo lp">val factory = StudentsFactory()<br/>val s1 = factory.next("Marcin", "Moskala")<br/>println(s1) // Student(id=0, name=Marcin, Surname=Moskala)<br/>val s2 = factory.next("Maja", "Markiewicz")<br/>println(s2) // Student(id=1, name=Maja, Surname=Markiewicz)</span></pre><p id="2e87" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">工厂类可以有属性，这些属性可以用来优化对象创建。当我们可以保持一种状态时，我们可以引入不同种类的优化或功能。例如，我们可以使用缓存或通过复制以前创建的对象来加速对象的创建。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi mj"><img src="../Images/3860f92ecd05def9ec2568695cfc2895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVLi_vixkafibx_Rzo19dg.jpeg"/></div></a></figure><h2 id="da4a" class="lk ll iy bd mk ml mm dn mn mo mp dp mq kg mr ms mt kk mu mv mw ko mx my mz na bi translated">摘要</h2><p id="bafb" class="pw-post-body-paragraph jv jw iy jx b jy nb ka kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">如您所见，Kotlin提供了多种指定工厂函数的方法，它们都有各自的用途。当我们设计对象创建时，我们应该把它们记在心里。它们中的每一个对于不同的情况都是合理的。其中一些应该谨慎使用:伪构造函数、顶级工厂方法和扩展工厂函数。定义工厂函数最通用的方法是使用一个伴随对象。对于大多数开发人员来说，它是安全且非常直观的，因为它的用法与Java静态工厂方法非常相似，而且Kotlin主要继承了Java的风格和实践。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><p id="a281" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于审查这一项目，我想感谢艾伦凯恩，法比奥科里尼，杰夫·福尔克和约旦汉森。这是Marcin Moskał a的有效Kotlin的一部分:</p><div class="im in gp gr io nn"><a href="https://leanpub.com/effectivekotlin/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iz gy z fp ns fr fs nt fu fw ix bi translated">有效科特林</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">最佳实践有效的Kotlin总结了Kotlin社区的最佳实践和经验，以及一个…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">leanpub.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob iu nn"/></div></div></a></div></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><h1 id="d06c" class="oc ll iy bd mk od oe of mn og oh oi mq oj ok ol mt om on oo mw op oq or mz os bi translated">单击👏说“谢谢！”并帮助他人找到这篇文章。</h1><p id="fd76" class="pw-post-body-paragraph jv jw iy jx b jy nb ka kb kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae kt" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae kt" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察推特</a>并在媒体上关注我们。</p><p id="4c38" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你需要一个科特林工作室，看看我们如何能帮助你:<a class="ae kt" href="https://kt.academy/" rel="noopener ugc nofollow" target="_blank"> kt.academy </a>。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi mj"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure></div></div>    
</body>
</html>