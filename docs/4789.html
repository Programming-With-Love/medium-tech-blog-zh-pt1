<html>
<head>
<title>Kotlin programmer dictionary: Statement vs Expression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林程序员词典:语句vs表达式</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0?source=collection_archive---------0-----------------------#2017-10-19">https://blog.kotlin-academy.com/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0?source=collection_archive---------0-----------------------#2017-10-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/ad62fc54509dc4a78b40ce939b89adaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NIm-rSf0GH52vS3A."/></div></div></figure><div class=""/><p id="665f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">S <strong class="jx iz">语句</strong>和<strong class="jx iz">表达式</strong>是两个经常被误解的重要术语。让我们从<strong class="jx iz">表达式</strong>术语开始解释。</p><h1 id="19cf" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">表示</h1><p id="b375" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Kotlin社区中的<strong class="jx iz">表达式</strong>术语通常与Kotlin <em class="lw">单表达式</em> <a class="ae lx" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener"> <em class="lw">函数</em> </a>相关联:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="e2ae" class="mh ku iy md b gy mi mj l mk ml">fun bigger(a: Int, b: Int) = if(a &gt; b) a else b</span></pre><p id="0fdf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑到这一点，我们应该直观地知道什么是<strong class="jx iz">表情</strong>。问题是直觉可能会误导人。让我们从一个常见的定义开始:</p><blockquote class="mm mn mo"><p id="5003" class="jv jw lw jx b jy jz ka kb kc kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ks ig bi translated">编程语言中的<strong class="jx iz">表达式</strong>是一个或多个显式值、常数、变量、运算符和<a class="ae lx" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">函数</a>的组合，编程语言对其进行解释和计算以产生另一个值。</p></blockquote><p id="0b37" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此<code class="fe ms mt mu md b">1 + 1</code>是一个<strong class="jx iz">表达式</strong>。同<code class="fe ms mt mu md b">sumOf(1,2,3)</code>。注意，一个<strong class="jx iz">表达式</strong>可以包含另一个<strong class="jx iz">表达式</strong>。例如，表达式<code class="fe ms mt mu md b">sumOf(1, 2*3)</code>包含表达式<code class="fe ms mt mu md b">2*3</code>。一个<strong class="jx iz">表达式</strong>是返回值的代码的每一部分。注意，在Kotlin中，每个<a class="ae lx" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">函数</a>至少返回<code class="fe ms mt mu md b">Unit</code>，因此每个<a class="ae lx" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">函数</a>调用都是一个表达式。是不是说什么都是一个<strong class="jx iz">表达式</strong>？肯定不是！这里有几个例子:</p><ul class=""><li id="a46c" class="mv mw iy jx b jy jz kc kd kg mx kk my ko mz ks na nb nc nd bi translated">变量声明是<strong class="jx iz">不是表达式</strong> ( <code class="fe ms mt mu md b">val a = 10</code>)</li><li id="6736" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated">变量或属性赋值<strong class="jx iz">不是Kotlin ( <code class="fe ms mt mu md b">a = 10</code>)中的表达式</strong></li><li id="8af6" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated">局部<a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类</a>声明是<strong class="jx iz">而不是表达式</strong> ( <code class="fe ms mt mu md b">class A {}</code>)</li></ul><p id="64c6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不是<strong class="jx iz">表达式</strong>，但都是<strong class="jx iz">语句</strong>。</p><h1 id="2c84" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">声明</h1><p id="7b72" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">让我们从另一个常见的定义开始解释:</p><blockquote class="mm mn mo"><p id="83f3" class="jv jw lw jx b jy jz ka kb kc kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ks ig bi translated">在计算机编程中，<strong class="jx iz">语句</strong>是命令式编程语言中最小的独立元素，它表达了要执行的一些动作。</p></blockquote><p id="fd2f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想这是不清楚的，所以我将展示一个例子。让我们看看下面的代码:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f9df" class="mh ku iy md b gy mi mj l mk ml">val bestUser = users.filter { it.passing }<br/>      .maxBy { it.meanScore }<br/>println("${bestUser.name} ${bestUser.surname}")</span></pre><p id="9e97" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在这里看到很多<strong class="jx iz">表达式</strong>，但是只有两个<strong class="jx iz">语句</strong>。首先是处理<code class="fe ms mt mu md b">users</code>集合并将结果存储在<code class="fe ms mt mu md b">bestUser</code>变量中。第二个<strong class="jx iz">语句</strong>显示该用户的姓名。最简单的启发是，<strong class="jx iz">语句</strong>是代码的一部分，在Java中以分号结束。在Kotlin中，这通常是一行代码，但是我们也可以在一行中编写多个<strong class="jx iz">语句</strong>(如果我们使用分号的话)或者我们可以使用<strong class="jx iz">多行语句</strong>:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="10cd" class="mh ku iy md b gy mi mj l mk ml">val bestUsers = users.filter { it.passing }<br/>      .sortedBy { -it.meanScore }<br/>      .take(10)<br/>print("The best students are: "); println(bestUsers.joinToString());</span></pre><p id="36cf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是3个<strong class="jx iz">语句</strong>。第一步是处理<code class="fe ms mt mu md b">users</code>以获得最佳用户，第二步是打印“最佳学生是:”，第三步是打印连接到单个字符串的最佳用户。</p><p id="ad3c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，一个独立的<strong class="jx iz">表达式</strong>也是一个<strong class="jx iz">语句</strong>。如下图<code class="fe ms mt mu md b">updateUser</code>所示<a class="ae lx" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">功能</a>调用:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6a71" class="mh ku iy md b gy mi mj l mk ml">updateUser(user)</span></pre><p id="0bdd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种独立的表达式称为<em class="lw">表达式语句</em>。</p><p id="bcd3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有趣的观察是，在纯函数式编程中没有<strong class="jx iz">语句</strong>。只有<strong class="jx iz">表情</strong>。</p><h1 id="cd93" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">你为什么需要它？</h1><p id="d70a" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">现在当你理解了什么是一个<strong class="jx iz">语句</strong>和一个<strong class="jx iz">表达式</strong>时，你就应该明白当你在一本书或一篇文章中描述一些代码时，这些术语是多么有用。让我们看一个例子:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6d2c" class="mh ku iy md b gy mi mj l mk ml">fun showUsers(users: List&lt;User&gt;?) {<br/>    users ?: return<br/>    val adapters = users.map { UserAdapter(it, ::onUserClicked) }<br/>    list.adapter = UserListAdapter(adapters)<br/>}</span></pre><blockquote class="mm mn mo"><p id="6b1f" class="jv jw lw jx b jy jz ka kb kc kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ks ig bi translated">在上面的代码片段中，我们可以看到<code class="fe ms mt mu md b">showUsers</code>是如何定义的。在其主体的第一条<strong class="jx iz">语句</strong>中，检查<code class="fe ms mt mu md b">users</code> <a class="ae lx" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener"> <strong class="jx iz">参数</strong> </a>是否不是<code class="fe ms mt mu md b">null</code>。请注意，虽然Kotlin中的<a class="ae lx" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">函数</a> <a class="ae lx" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">参数</a>是<strong class="jx iz">只读的</strong>，但这样的断言对于<a class="ae lx" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">函数</a>的其余部分来说是智能地将<code class="fe ms mt mu md b">users</code>强制转换为不可空的。因此，在第二个<strong class="jx iz">语句</strong>中，我们可以直接使用它，无需任何拆包。注意，当我们在表达式<code class="fe ms mt mu md b">UserAdapter(it, ::onUserClicked)</code>上将用户映射到适配器时，我们还提供了引用<a class="ae lx" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">函数</a> <code class="fe ms mt mu md b">onUserClicked</code>的<a class="ae lx" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">参数</a>。在最后一个<strong class="jx iz">语句</strong>中，我们将<code class="fe ms mt mu md b">list</code>的适配器指定为新创建的<code class="fe ms mt mu md b">UserListAdapter</code>实例。它包括为所有用户创建的适配器。</p></blockquote><p id="ca51" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，<strong class="jx iz">语句</strong>和<strong class="jx iz">表达式</strong>这两个词帮助我们在描述代码时明确我们的意思。</p><h1 id="7df5" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Java vs in Kotlin中的表达式是什么？</h1><p id="00e3" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">注意，在Kotlin和Java中，什么是什么不是一个<strong class="jx iz">表达式</strong>之间有一些基本的区别。所有的Kotlin <a class="ae lx" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">函数</a>调用都是<strong class="jx iz">表达式</strong>，因为它们至少返回<code class="fe ms mt mu md b">Unit</code>。没有定义任何返回类型<a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">的Java </a><a class="ae lx" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">函数</a>的调用不是<strong class="jx iz">表达式</strong>。Kotlin值赋值(<code class="fe ms mt mu md b">a = 1</code>)在Kotlin中是<strong class="jx iz">而不是表达式</strong>，而在Java中是因为它返回赋值(在Java中你可以做<code class="fe ms mt mu md b">a = b = 2</code>或<code class="fe ms mt mu md b">a = 2 * (b = 3)</code>)。Java中控制结构(<code class="fe ms mt mu md b">if</code>、<code class="fe ms mt mu md b">switch</code>)的所有用法都是<strong class="jx iz">不是表达式</strong>，而Kotlin允许<code class="fe ms mt mu md b">if</code>、<code class="fe ms mt mu md b">when</code>、<code class="fe ms mt mu md b">try</code>返回值:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="ef5e" class="mh ku iy md b gy mi mj l mk ml">val bigger = if(a &gt; b) a else b</span><span id="85ad" class="mh ku iy md b gy nj mj l mk ml">val color = when {<br/>    relax -&gt; GREEN<br/>    studyTime -&gt; YELLOW<br/>    else -&gt; BLUE<br/>}</span><span id="e843" class="mh ku iy md b gy nj mj l mk ml">val object = try {<br/>    gson.fromJson(json)<br/>} catch (e: Throwable) {<br/>    null<br/>}</span></pre></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><p id="155e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我要感谢德米特里·杰梅罗夫的技术验证。这篇文章是科特林程序员词典的第二部分。要了解最新的新部件，只需关注这个媒体或在Twitter上观察我。如果你需要一些帮助，记得<a class="ae lx" href="https://medium.com/@marcinmoskala/ive-just-opened-up-for-online-consultations-640349aaba55" rel="noopener">我愿意接受咨询</a>。</p><p id="43b9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">喜欢的话记得鼓掌。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi nr"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="8d02" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是<a class="ae lx" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-2cb67fff1fe2" rel="noopener">科特林程序员词典</a>的其他出版部分:</p><ul class=""><li id="f8a1" class="mv mw iy jx b jy jz kc kd kg mx kk my ko mz ks na nb nc nd bi translated"><a class="ae lx" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">形参vs实参，类型形参vs类型实参</a></li><li id="b936" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">函数vs方法vs程序</a></li><li id="9971" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">字段对属性</a></li><li id="765d" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类vs类型vs对象</a></li><li id="4d02" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b">对象表达式vs对象声明</a></li><li id="d473" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-b085b1620890">接收器</a></li><li id="7374" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c">隐式接收者vs显式接收者</a></li><li id="e269" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277">分机接收机对调度接收机</a></li><li id="ba74" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-type-vs-receiver-object-575d2705ddd9">接收方类型与接收方对象</a></li><li id="66e3" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">函数类型vs函数文字vs Lambda表达式vs匿名函数</a></li><li id="031f" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-higher-order-function-9cadb07df94e">高阶函数</a></li><li id="0778" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-function-literal-with-receiver-vs-function-type-with-receiver-cc21dba0f4ff">带接收方的函数文字与带接收方的函数类型</a></li><li id="f612" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/kotlin-generics-variance-modifiers-36b82c7caa39">不变性vs协方差vs逆变</a></li><li id="8bed" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-event-listener-vs-event-handler-305c667d0e3c">事件监听器vs事件处理器</a></li><li id="d70d" class="mv mw iy jx b jy ne kc nf kg ng kk nh ko ni ks na nb nc nd bi translated"><a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-delegation-vs-composition-3025d9e8ae3d">代表团vs组成</a></li></ul><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ns"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>