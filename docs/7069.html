<html>
<head>
<title>Fact Check And Common Misconceptions Around Comparing SwiftUI &amp; Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于SwiftUI和Jetpack Compose比较的事实检查和常见误解</h1>
<blockquote>原文：<a href="https://medium.com/quick-code/fact-check-and-common-misconceptions-around-comparing-swiftui-jetpack-compose-9fa37a77130?source=collection_archive---------0-----------------------#2022-09-14">https://medium.com/quick-code/fact-check-and-common-misconceptions-around-comparing-swiftui-jetpack-compose-9fa37a77130?source=collection_archive---------0-----------------------#2022-09-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/0ef9d236d2cb22a8a0568d868606b2ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/0*I6IKAbk8CuQmrLZf"/></div></figure><p id="4a01" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用移动应用程序的开发人员有多个UI选项可供选择。使用声明式UI比命令式UI有明显的优势。</p><blockquote class="jj jk jl"><p id="2057" class="il im jm in b io ip iq ir is it iu iv jn ix iy iz jo jb jc jd jp jf jg jh ji ha bi translated">近年来，声明式UI越来越受欢迎，因为它们使开发人员能够用更少的代码更快地创建移动应用程序，在声明式UI中，您可以描述UI在给定状态下的外观，并且框架会根据需要对更改做出响应。</p></blockquote><p id="1b10" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这种UI框架的两个例子是<strong class="in hi"> SwiftUI </strong>和<strong class="in hi"> Jetpack Compose </strong>。</p><p id="fecc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jq" href="https://developer.apple.com/xcode/swiftui/" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>包括多个API和其他组件，用于跨iOS、macOS、tvOS和watchOS的可定制应用设计。这意味着，您现在只需学习一种语言和一个布局框架，就可以在任何地方部署您的代码。Jetpack Compose 旨在简化Android上的开发，随着应用程序状态的变化自动更新，并访问Android APIs。</p><p id="d4c8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这两个框架既有相似之处，也有不同之处。本文将对这两者进行比较，以便您可以确定哪一个更适合您的项目。</p><p id="96a7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">SwiftUI和Jetpack Compose之间的比较将集中在几个重要因素上，例如它们提供的平台支持、每个平台所需的学习曲线以及它们提供的功能。</p><h2 id="a4fd" class="jr js hh bd jt ju jv jw jx jy jz ka kb iw kc kd ke ja kf kg kh je ki kj kk kl bi translated"><strong class="ak"> Jetpack可组合功能</strong></h2><p id="b1dc" class="pw-post-body-paragraph il im hh in b io km iq ir is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji ha bi translated">可组合函数用于以编程方式定义应用程序的UI。这意味着应用程序的布局不需要使用XML文件。要创建一个可组合的函数，您只需要对函数名使用<strong class="in hi"> @Composable </strong>注释。</p><p id="0d24" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下面是一个可组合函数的基本语法的例子。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="1e09" class="jr js hh kw b fi la lb l lc ld">@Composable<br/>fun HelloWorld() {<br/>   Text("Hello, World!")<br/>}</span></pre><p id="1fd3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了使用这个可组合的函数，我们在这个方法中调用它，如下所示:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="d3b3" class="jr js hh kw b fi la lb l lc ld">setContent {<br/>  HelloWorld()<br/>}</span></pre><p id="f662" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">以前，它会显示在XML布局文件(main_layout.xml)中，如下所示:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="6a69" class="jr js hh kw b fi la lb l lc ld">&lt;LinearLayout <br/>android:layout_width="match_parent"<br/>android:layout_height="match_parent"<br/>android:orientation="vertical" &gt;<br/>    &lt;TextView android:id="@+id/text"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="Hello, World" /&gt;<br/>&lt;/LinearLayout&gt;</span></pre><p id="090a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">并且布局资源文件将以这种方式加载:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="a064" class="jr js hh kw b fi la lb l lc ld">fun onCreate(savedInstanceState: Bundle) {<br/>  super.onCreate(savedInstanceState)<br/>  setContentView(R.layout.main_layout)<br/>}</span></pre><h2 id="544f" class="jr js hh bd jt ju jv jw jx jy jz ka kb iw kc kd ke ja kf kg kh je ki kj kk kl bi translated">SwiftUI功能</h2><p id="bf00" class="pw-post-body-paragraph il im hh in b io km iq ir is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji ha bi translated">在Swift UI中，Xcode生成的代码示例如下所示:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f793" class="jr js hh kw b fi la lb l lc ld">struct ContentView : View {<br/>  var body : some View {<br/>    Text("Hello, world!")<br/>  }<br/>}</span></pre><p id="6df1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然而，以前使用UIKit时，在ViewController中会编写相同的语法，如下所示:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="59a2" class="jr js hh kw b fi la lb l lc ld">class ViewController: UIViewController {<br/>   @IBOutlet weak var myLabel: UILabel!<br/>   override func viewDidLoad() {<br/>     super.viewDidLoad()<br/>     myLabel.text = "Hello, World!"<br/>   }<br/>}</span></pre><h2 id="07a0" class="jr js hh bd jt ju jv jw jx jy jz ka kb iw kc kd ke ja kf kg kh je ki kj kk kl bi translated">类似</h2><p id="7c80" class="pw-post-body-paragraph il im hh in b io km iq ir is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji ha bi translated">除了它们的基本功能，SwiftUI和Jetpack Compose还提供了其他相似之处。</p><ul class=""><li id="c048" class="le lf hh in b io ip is it iw lg ja lh je li ji lj lk ll lm bi translated">它们都是<strong class="in hi">命令式/声明式的— </strong>然后您可以响应用户事件并手动更新数据。随着状态的变化，您决定UI应该如何变化。在iOS中，这意味着你不必像在UIKit、StoryBoard或Interface Builder中那样“连接事物”，而在Android中，你不需要从XML布局文件中加载内容。总的来说，您编写的代码要少得多。</li><li id="1361" class="le lf hh in b io ln is lo iw lp ja lq je lr ji lj lk ll lm bi translated">这两个框架还在源代码中提供了更好的可读性Jetpack Compose的内置组件(如文本和按钮)也是由可组合函数构建的，因此您可以更容易地检查源代码，以查看每个参数是如何列出的以及它们是如何工作的。SwiftUI中的内置视图以类似的方式呈现在原始视图中，尽管这种情况下的源代码可读性较差。</li></ul><h2 id="b442" class="jr js hh bd jt ju jv jw jx jy jz ka kb iw kc kd ke ja kf kg kh je ki kj kk kl bi translated">差异</h2><p id="b9ef" class="pw-post-body-paragraph il im hh in b io km iq ir is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji ha bi translated">SwiftUI和Jetpack Compose确实有显著的不同。</p><ul class=""><li id="e3ba" class="le lf hh in b io ip is it iw lg ja lh je li ji lj lk ll lm bi translated">例如，SwiftUI是与OS 一起打包的<strong class="in hi">，而Jetpack Compose是<strong class="in hi">一个库—</strong>swift ui的运行性能更好，因为它是在系统中预编译的，但如果你需要向框架中添加新功能，你需要等待你的项目配置适当的最低版本。在Android中，如果你想给Jetpack Compose增加一个功能，只需要升级你的库版本。</strong></li><li id="8ae4" class="le lf hh in b io ln is lo iw lp ja lq je lr ji lj lk ll lm bi translated">SwiftUI使用<strong class="in hi">协议实现</strong>，而Compose使用<strong class="in hi">编译器插件和组合——</strong>组合是一种将责任委托给另一个类的优雅方式，但对于SwiftUI方法来说不是必需的，在swift ui方法中，您添加一个等同于组件的“修饰符”。</li><li id="338c" class="le lf hh in b io ln is lo iw lp ja lq je lr ji lj lk ll lm bi translated">由于SwiftUI与系统的强耦合性，很难写出一个不尊重iOS设计的应用。使用Jetpack Compose，您可以轻松地创建符合材料规范的组件，但是您需要更多的代码来构建具有漂亮UI的应用程序。</li><li id="48b8" class="le lf hh in b io ln is lo iw lp ja lq je lr ji lj lk ll lm bi translated">SwiftUI <strong class="in hi">不是开源的</strong>，文档随着时间的推移在慢慢增长。Jetpack Compose <strong class="in hi">是开源的</strong>,公众很容易获得。你可以检查图书馆里建了什么来做同样的或相似的事情，或者寻找灵感。</li><li id="a9da" class="le lf hh in b io ln is lo iw lp ja lq je lr ji lj lk ll lm bi translated">尽管预览功能对两个框架都可用，SwiftUI在预览画布上即时显示您的更改，无需刷新。另一方面，Jetpack Compose要求您在做出更改后单击刷新按钮，以便您可以看到新更改的预览。</li></ul><h2 id="811f" class="jr js hh bd jt ju jv jw jx jy jz ka kb iw kc kd ke ja kf kg kh je ki kj kk kl bi translated">SwiftUI所需的学习曲线</h2><p id="14fa" class="pw-post-body-paragraph il im hh in b io km iq ir is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji ha bi translated">虽然您可能马上就开始使用SwiftUI，但为了避免有限的支持、有限的接受度和有限的API覆盖范围，您需要记住UIKit。</p><p id="0385" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，SwiftUI仅在iOS 13及更高版本的设备上可用，仅在<a class="ae jq" href="https://developer.apple.com/videos/wwdc2019/" rel="noopener ugc nofollow" target="_blank"> WWDC 2019 </a>上展示。这表明SwiftUI将无法支持要求兼容iOS 12或更早版本的应用。由于UIKit已经存在了十多年，您应该能够找到您可能遇到的几乎每个问题的答案，以及提供扩展和定制的多个库。</p><p id="507f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">不过，如果你目前使用UIKit，你可以为当前项目切换到SwiftUI。UIKit流程如下所示:</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es ls"><img src="../Images/dfba50c6841056288176cef90a8dc5cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/0*l-I0_PI-yqEV-IOW.png"/></div></figure><p id="bf10" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这里有一个使用相同流程的可点击按钮的示例代码。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3d21" class="jr js hh kw b fi la lb l lc ld">class ViewController: UIViewController {</span><span id="f0f7" class="jr js hh kw b fi lt lb l lc ld">  override func viewDidLoad() {</span><span id="ad96" class="jr js hh kw b fi lt lb l lc ld">class ViewController: UIViewController {<br/>  override func viewDidLoad() {<br/>   super.viewDidLoad()<br/>   let button = UIButton(type: UIButton.ButtonType.system) as<br/> UIButton<br/>    button.setTitle("Show data", for: UIControl.State.normal)<br/>    button.addTarget(self, action: #selector(self.buttonAction), for: .touchUpInside)<br/>    self.view.addSubview(button)<br/>   }<br/>   @objc func buttonAction(_ sender:UIButton!) {<br/>    print("Button pressed")<br/>   }<br/>   override func didReceiveMemoryWarning() {<br/>     super.didReceiveMemoryWarning()<br/>   }<br/>}</span></pre><p id="53a9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您将其转换为SwiftUI，流程将变为如下所示:</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es lu"><img src="../Images/243c3bcd6d85a57c0a58527c792c4e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/0*G54BPrKycTM8AEHU.png"/></div></figure><p id="44cd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">将自定义按钮的代码更改为如下所示:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="976f" class="jr js hh kw b fi la lb l lc ld">struct ContentView: View {<br/>  var body: some View {<br/>   VStack(alignment: .leading) {<br/>    Button {<br/>     print("Button pressed")<br/>    } label: { Text("Show data") }<br/>   }<br/>  }<br/>}</span></pre><h2 id="bfc3" class="jr js hh bd jt ju jv jw jx jy jz ka kb iw kc kd ke ja kf kg kh je ki kj kk kl bi translated">编写Jetpack所需的学习曲线</h2><p id="d83c" class="pw-post-body-paragraph il im hh in b io km iq ir is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji ha bi translated">至于Jetpack Compose，为现有项目重写整个UI是深入尝试的一种方式。当当前可用的可组合函数不完全支持您的一些遗留代码时，这可能会令人沮丧，但是对于初始设置，迁移整个屏幕以进行组合是一项任务。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8e21" class="jr js hh kw b fi la lb l lc ld">@Composable<br/>fun HelloWorld() {<br/>   Text("Hello, World!")<br/>}</span></pre><p id="ebf0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Compose还支持向现有的视图层次结构中添加可组合的组件。为此，只需向XML文件添加一个ComposeView，如下例所示:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e889" class="jr js hh kw b fi la lb l lc ld">&lt;LinearLayout<br/>android:layout_width="match_parent"<br/>android:layout_height="match_parent"<br/>android:orientation="vertical" &gt;<br/>    &lt;TextView android:id="@+id/text"<br/>      android:layout_width="wrap_content"<br/>      android:layout_height="wrap_content"<br/>      android:text="Hello, World" /&gt;<br/>   &lt;androidx.compose.ui.platform.ComposeView<br/>     android:id="@+id/compose"<br/>     android:layout_width="match_parent"<br/>     android:layout_height="match_parent" /&gt;<br/>&lt;/LinearLayout&gt;</span></pre><p id="cc64" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在活动中，调用此视图上的setContent方法，将您的可组合应用到UI的这一部分。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="7d8d" class="jr js hh kw b fi la lb l lc ld">findViewById&lt;ComposeView&gt;(R.id.compose).setContent {<br/>  MaterialTheme {<br/>    Text("Hello, World!")<br/>  }<br/>}</span></pre><p id="2422" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在可组合层次结构中使用视图是您可能需要考虑的另一件事。当您必须使用没有类似可组合视图的视图时，比如地图视图，这会很有帮助。当在可组合UI中提供这些遗留视图时，可以使用AndroidView可组合。</p><p id="6fcd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Android XML设置很可能永远不会完全消失，就像SwiftUI和UIKit一样。从旧标准到新标准的转换需要几年时间，类似于Java到Kotlin的转换，您可能仍然会偶尔与旧代码进行交互。</p><h2 id="7ed6" class="jr js hh bd jt ju jv jw jx jy jz ka kb iw kc kd ke ja kf kg kh je ki kj kk kl bi translated">包装它</h2><p id="e5de" class="pw-post-body-paragraph il im hh in b io km iq ir is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji ha bi translated">有人可能会说，在Android和iOS上同时使用Compose是个好主意，其他人会倾向于说尊重平台的UI/UX准则很重要，Compose不能像SwiftUI那样构建应用程序。在这种情况下，<em class="jm">没有一个控制另一个</em>。</p><p id="4ec6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">声明式用户界面承诺为移动开发者提供一个直观、低代码的应用解决方案。SwiftUI和Jetpack Compose都提供了很多功能。如果您正在使用iOS，并且需要系统中的即时功能，SwiftUI可能是正确的选择。如果你正在使用iOS或Android，并且你更喜欢具有更多可定制性的开源工具，那么你应该考虑Jetpack Compose。</p></div></div>    
</body>
</html>