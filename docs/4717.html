<html>
<head>
<title>Functional Mixins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">功能混合蛋白</h1>
<blockquote>原文：<a href="https://medium.com/javascript-scene/functional-mixins-composing-software-ffb66d5e731c?source=collection_archive---------0-----------------------#2017-06-08">https://medium.com/javascript-scene/functional-mixins-composing-software-ffb66d5e731c?source=collection_archive---------0-----------------------#2017-06-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="4eb8" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">编写软件</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/b5319c93f5a4237f1472d1686f5b1e6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVpU7iruzXafhU2VLeH4lw.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx">Smoke Art Cubes to Smoke — MattysFlicks — (CC BY 2.0)</figcaption></figure><blockquote class="jm jn jo"><p id="dd42" class="jp jq jr js b jt ju ii jv jw jx il jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><strong class="js hi">注:</strong>这是《作曲软件》系列的一部分<strong class="js hi">s</strong><a class="ae km" href="https://leanpub.com/composingsoftware" rel="noopener ugc nofollow" target="_blank">T5】(现在一本书！) </a>从基础开始学习JavaScript ES6+中的函数式编程和组合软件技术。敬请关注。还会有更多这样的事情发生！<br/> <a class="ae km" rel="noopener" href="/javascript-scene/functors-categories-61e031bac53f"> &lt;上一个</a> | <a class="ae km" rel="noopener" href="/javascript-scene/composing-software-an-introduction-27b72500d6ea"> &lt; &lt;从第1部分开始</a> | <a class="ae km" rel="noopener" href="/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1">下一个&gt; </a></p></blockquote><p id="c4bd" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated"><strong class="js hi">功能混合</strong>是在管道中连接在一起的可组合工厂功能；每个函数都像装配线上的工人一样添加一些属性或行为。函数式mixin不依赖或不需要基工厂或构造函数:只需将任意对象传入mixin，就会返回该对象的增强版本。</p><p id="ba00" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">功能性mixin特性:</p><ul class=""><li id="628c" class="kq kr hh js b jt ju jw jx kn ks ko kt kp ku kl kv kw kx ky bi translated">数据隐私/封装</li><li id="7f05" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">继承私有状态</li><li id="062c" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">从多个来源继承</li><li id="419f" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">没有菱形问题(属性冲突模糊)-最后一个获胜</li><li id="7ff2" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">没有基类要求</li></ul><h1 id="00b4" class="le lf hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">动机</h1><p id="c79f" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">所有现代软件开发实际上都是组合:我们将一个大的、复杂的问题分解成更小、更简单的问题，然后组合解决方案形成一个应用程序。</p><p id="acbd" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">组成的原子单位有两种:</p><ul class=""><li id="61f8" class="kq kr hh js b jt ju jw jx kn ks ko kt kp ku kl kv kw kx ky bi translated">功能</li><li id="9f7f" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">数据结构</li></ul><p id="a8c6" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">应用程序结构是由这些原子单元的组合定义的。通常，复合对象是使用类继承产生的，其中类从父类继承其大部分功能，并扩展或覆盖部分。这种方法的问题在于，它会导致<strong class="js hi"> is-a </strong>思维，例如，“管理员就是雇员”，导致许多设计问题:</p><ul class=""><li id="c55b" class="kq kr hh js b jt ju jw jx kn ks ko kt kp ku kl kv kw kx ky bi translated">紧密耦合问题:因为子类依赖于父类的实现，所以类继承是面向对象设计中最紧密的耦合。</li><li id="be64" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated"><strong class="js hi">脆弱的基类问题:</strong>由于紧密耦合，对基类的更改可能会破坏大量的子类——潜在地在由第三方管理的代码中。作者可以破解他们不知道的代码。</li><li id="c2e3" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated"><strong class="js hi">不灵活的层次问题:</strong>对于单祖先分类法，如果有足够的时间和进化，所有的类分类法对于新的用例来说最终都是错误的。</li><li id="4b08" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated"><strong class="js hi">必然的复制问题:</strong>由于不灵活的层次结构，新的用例经常通过复制而不是扩展来实现，导致类似的类出现意想不到的分歧。一旦复制开始，新类应该从哪个类继承，或者为什么继承就不明显了。</li><li id="a716" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated"><strong class="js hi">大猩猩/香蕉问题:</strong>“…面向对象语言的问题是它们拥有所有这些隐含的环境。你想要一个香蕉，但你得到的是一只大猩猩拿着香蕉和整个丛林。”~乔·阿姆斯特朗，<a class="ae km" href="http://www.amazon.com/gp/product/1430219483?ie=UTF8&amp;camp=213733&amp;creative=393185&amp;creativeASIN=1430219483&amp;linkCode=shr&amp;tag=eejs-20&amp;linkId=3MNWRRZU3C4Q4BDN" rel="noopener ugc nofollow" target="_blank">《工作中的编码员》</a></li></ul><p id="7aee" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">如果一名行政人员是雇员，你如何处理聘请外部顾问临时履行行政职责的情况？如果你预先知道每一个需求，也许类继承可以工作，但是我从来没有见过这种情况发生。如果使用足够多，随着新问题和更有效的流程的发现，应用程序和需求不可避免地会随着时间的推移而增长和发展。</p><p id="e4d4" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">Mixins提供了一种更加灵活的方法。</p><h1 id="8fe9" class="le lf hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">什么是混合蛋白？</h1><blockquote class="jm jn jo"><p id="204e" class="jp jq jr js b jt ju ii jv jw jx il jy jz ka kb kc kd ke kf kg kh ki kj kk kl ha bi translated"><em class="hh">“重对象组合轻类继承”四人帮，</em> <a class="ae km" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=as_li_ss_tl?ie=UTF8&amp;qid=1494993475&amp;sr=8-1&amp;keywords=design+patterns&amp;linkCode=ll1&amp;tag=eejs-20&amp;linkId=6c553f16325f3939e5abadd4ee04e8b4" rel="noopener ugc nofollow" target="_blank"> <em class="hh">“设计模式:可复用面向对象软件的要素”</em> </a></p></blockquote><p id="817f" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated"><strong class="js hi">混合</strong>是<em class="jr">对象组合的一种形式，</em>其中组件特性混合到一个复合对象中，因此每个混合的属性成为复合对象的属性。</p><p id="e448" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">OOP中的术语“mixins”来自mixin冰激凌店。你不用在不同的预混合桶里放一大堆冰淇淋口味，而是香草冰淇淋，以及一堆可以混合在一起为每位顾客创造定制口味的独立配料。</p><p id="b32f" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">对象混合是相似的:你从一个空的对象开始，混合一些特性来扩展它。因为JavaScript支持动态对象扩展和没有类的对象，所以在JavaScript中使用对象混合非常容易——以至于它是JavaScript中最常见的继承形式。让我们看一个例子:</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="ec1f" class="mg lf hh mc b fi mh mi l mj mk">const chocolate = {<br/>  hasChocolate: () =&gt; true<br/>};</span><span id="40d1" class="mg lf hh mc b fi ml mi l mj mk">const caramelSwirl = {<br/>  hasCaramelSwirl: () =&gt; true<br/>};</span><span id="fc2d" class="mg lf hh mc b fi ml mi l mj mk">const pecans = {<br/>  hasPecans: () =&gt; true<br/>};</span><span id="af60" class="mg lf hh mc b fi ml mi l mj mk">const iceCream = Object.assign({}, chocolate, caramelSwirl, pecans);</span><span id="41be" class="mg lf hh mc b fi ml mi l mj mk">/*<br/>// or, if your environment supports object spread...<br/>const iceCream = {...chocolate, ...caramelSwirl, ...pecans};<br/>*/</span><span id="927a" class="mg lf hh mc b fi ml mi l mj mk">console.log(`<br/>  hasChocolate: ${ iceCream.hasChocolate() }<br/>  hasCaramelSwirl: ${ iceCream.hasCaramelSwirl() }<br/>  hasPecans: ${ iceCream.hasPecans() }<br/>`);</span></pre><p id="3403" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">哪些日志:</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="0641" class="mg lf hh mc b fi mh mi l mj mk">  hasChocolate: true<br/>  hasCaramelSwirl: true<br/>  hasPecans: true</span></pre><h1 id="23ac" class="le lf hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">什么是函数继承？</h1><p id="3e9a" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">功能继承是通过对对象实例应用扩充功能来继承特性的过程。该函数提供了一个闭包作用域，您可以使用它来保持一些数据的私有性。扩充功能使用动态对象扩展来用新的属性和方法扩展对象实例。</p><p id="2240" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">让我们看一个道格拉斯·克洛克福特的例子，他创造了这个术语:</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="cf17" class="mg lf hh mc b fi mh mi l mj mk">// Base object factory<br/>function base(spec) {<br/>    var that = {}; // Create an empty object<br/>    that.name = spec.name; // Add it a "name" property<br/>    return that; // Return the object<br/>}</span><span id="f4ff" class="mg lf hh mc b fi ml mi l mj mk">// Construct a child object, inheriting from "base"<br/>function child(spec) {<br/>    // Create the object through the "base" constructor<br/>    var that = base(spec); <br/>    that.sayHello = function() { // Augment that object<br/>        return 'Hello, I\'m ' + that.name;<br/>    };<br/>    return that; // Return it<br/>}</span><span id="7bbf" class="mg lf hh mc b fi ml mi l mj mk">// Usage<br/>var result = child({ name: 'a functional object' });<br/>console.log(result.sayHello()); // "Hello, I'm a functional object"</span></pre><p id="cef5" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">因为<code class="du mm mn mo mc b">child()</code>和<code class="du mm mn mo mc b">base()</code>紧密耦合，当你加上<code class="du mm mn mo mc b">grandchild()</code>、<code class="du mm mn mo mc b">greatGrandchild()</code>等...，您将选择解决类继承的大多数常见问题。</p><h1 id="a7f1" class="le lf hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">什么是功能性混音？</h1><p id="caf1" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">函数混合是可组合的函数，它将新的属性或行为与给定对象的属性混合在一起。函数式mixin不依赖也不需要基工厂或构造函数:只需将任意对象传递给mixin，它就会被扩展。</p><p id="38c1" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">让我们看一个例子:</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="88c1" class="mg lf hh mc b fi mh mi l mj mk">const flying = o =&gt; {<br/>  let isFlying = false;</span><span id="5811" class="mg lf hh mc b fi ml mi l mj mk">  return Object.assign({}, o, {<br/>    fly () {<br/>      isFlying = true;<br/>      return this;<br/>    },</span><span id="f70f" class="mg lf hh mc b fi ml mi l mj mk">    isFlying: () =&gt; isFlying,</span><span id="cf88" class="mg lf hh mc b fi ml mi l mj mk">    land () {<br/>      isFlying = false;<br/>      return this;<br/>    }<br/>  });<br/>};</span><span id="d69b" class="mg lf hh mc b fi ml mi l mj mk">const bird = flying({});<br/>console.log( bird.isFlying() ); // false<br/>console.log( bird.fly().isFlying() ); // true</span></pre><p id="ad5d" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">注意，当我们调用<code class="du mm mn mo mc b">flying()</code>时，我们需要传入一个要扩展的对象。功能混合是为功能组合而设计的。让我们创造一些东西来作曲:</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="6e0c" class="mg lf hh mc b fi mh mi l mj mk">const quacking = quack =&gt; o =&gt; Object.assign({}, o, {<br/>  quack: () =&gt; quack<br/>});</span><span id="43a4" class="mg lf hh mc b fi ml mi l mj mk">const quacker = quacking('Quack!')({});<br/>console.log( quacker.quack() ); // 'Quack!'</span></pre><h1 id="4c3e" class="le lf hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">组成函数混合</h1><p id="5f8c" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">可以用简单的函数组合来组合函数混合:</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="a77a" class="mg lf hh mc b fi mh mi l mj mk">const createDuck = quack =&gt; quacking(quack)(flying({}));</span><span id="eae4" class="mg lf hh mc b fi ml mi l mj mk">const duck = createDuck('Quack!');</span><span id="e7f9" class="mg lf hh mc b fi ml mi l mj mk">console.log(duck.fly().quack());</span></pre><p id="7807" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">不过，读起来有点别扭。调试或重新安排合成顺序也可能有点棘手。</p><p id="ee03" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">当然，这是标准的函数组合，我们已经知道一些使用<code class="du mm mn mo mc b">compose()</code>或<code class="du mm mn mo mc b">pipe()</code>的更好的方法。如果我们使用<code class="du mm mn mo mc b">pipe()</code>来颠倒函数的顺序，那么组合将看起来像<code class="du mm mn mo mc b">Object.assign({}, ...)</code>或<code class="du mm mn mo mc b">{...object, ...spread}</code>——保持相同的优先顺序。在属性冲突的情况下，中的最后一个对象获胜。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="68e5" class="mg lf hh mc b fi mh mi l mj mk">const pipe = (...fns) =&gt; x =&gt; fns.reduce((y, f) =&gt; f(y), x);<br/>// OR...<br/>// import pipe from `lodash/fp/flow`;</span><span id="e6e6" class="mg lf hh mc b fi ml mi l mj mk">const createDuck = quack =&gt; pipe(<br/>  flying,<br/>  quacking(quack)<br/>)({});</span><span id="eb53" class="mg lf hh mc b fi ml mi l mj mk">const duck = createDuck('Quack!');</span><span id="80f5" class="mg lf hh mc b fi ml mi l mj mk">console.log(duck.fly().quack());</span></pre><h1 id="238b" class="le lf hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">何时使用功能混合</h1><p id="3833" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">你应该总是使用尽可能简单的抽象来解决你正在处理的问题。从一个纯函数开始。如果您需要具有持久状态的对象，请尝试使用工厂函数。如果您需要构建更复杂的对象，请尝试函数混合。</p><p id="992e" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">以下是一些很好的函数混合用例:</p><ul class=""><li id="6847" class="kq kr hh js b jt ju jw jx kn ks ko kt kp ku kl kv kw kx ky bi translated">应用程序状态管理，例如Redux存储。</li><li id="835d" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">某些跨领域的问题和服务，例如集中式记录器。</li><li id="3ab1" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">可组合的函数数据类型，例如JavaScript <code class="du mm mn mo mc b">Array</code>类型实现<code class="du mm mn mo mc b">Semigroup</code>、<code class="du mm mn mo mc b">Functor</code>、<code class="du mm mn mo mc b">Foldable</code>。一些代数结构可以根据其他代数结构派生，这意味着某些派生可以组成一个新的数据类型，而无需定制。</li></ul><p id="403c" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated"><strong class="js hi"> React users: </strong> <code class="du mm mn mo mc b">class</code>适合生命周期挂钩，因为调用者不需要使用<code class="du mm mn mo mc b">new</code>，并且记录的最佳实践是避免从React提供的基本组件之外的任何组件继承。</p><p id="6054" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">我使用并推荐带有功能组合的hoc(高阶组件)来组合UI组件。</p><h1 id="1a45" class="le lf hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">警告</h1><p id="490c" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">大多数问题都可以用纯函数很好地解决。功能混合就不一样了。像类继承一样，函数混合也有自己的问题。事实上，使用函数混合可以忠实地再现类继承的所有特性和问题。</p><p id="e5f1" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">不过，你可以通过以下建议来避免这种情况:</p><ul class=""><li id="b0b7" class="kq kr hh js b jt ju jw jx kn ks ko kt kp ku kl kv kw kx ky bi translated">使用最简单的实际实现。从左边开始，只在需要时移到右边:纯函数&gt;工厂&gt;函数混合&gt;类。</li><li id="0d69" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">避免在对象、混合或数据类型之间创建<strong class="js hi"> is-a </strong>关系。</li><li id="2812" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">避免mixin之间的隐式依赖——只要有可能，函数mixin应该是自包含的，并且不知道其他mixin。</li><li id="a953" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">“函数式混合”并不意味着“函数式编程”。</li><li id="6b10" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">当您使用<code class="du mm mn mo mc b">Object.assign()</code>或对象扩展语法(<code class="du mm mn mo mc b">{...}</code>)访问属性时，可能会有副作用。您还将跳过任何不可枚举的属性。ES2017增加了<code class="du mm mn mo mc b"><a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors" rel="noopener ugc nofollow" target="_blank">Object.getOwnPropertyDescriptors()</a></code>来解决这个问题。</li></ul><p id="ede5" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">我主要依靠功能组合来组合行为和应用程序结构，但也经常使用高阶组件(hoc)形式的功能混合(混合到组件属性中)和表达中间件(混合到请求和响应对象中)。</p><p id="9d17" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">我从不使用类继承，除非我直接从第三方基类继承，比如<code class="du mm mn mo mc b">React.Class</code>。我从不建立自己的继承层次结构。</p><h1 id="363c" class="le lf hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">班级</h1><p id="f7e2" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">在JavaScript中，类继承很少(也许<em class="jr">永远不会</em>)是最好的方法，但是这种选择有时是由你无法控制的库或框架做出的。在这种情况下，如果库:</p><ol class=""><li id="68a7" class="kq kr hh js b jt ju jw jx kn ks ko kt kp ku kl mp kw kx ky bi translated">不要求您扩展自己的类(即，不要求您构建多级类层次结构)，并且</li><li id="958d" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl mp kw kx ky bi translated">不需要您直接使用<code class="du mm mn mo mc b">new</code>关键字——换句话说，框架会为您处理实例化</li></ol><p id="e9e6" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">Angular 2+和React都满足这些要求，所以只要不扩展自己的类，就可以安全地使用它们的类。如果您愿意，React允许您避免使用类，但是您的组件可能无法利用React基类中内置的优化，并且您的组件看起来不像文档示例中的组件。在任何情况下，如果有意义的话，您应该总是更喜欢React组件的函数形式。</p><h2 id="ef99" class="mg lf hh bd lg mq mr ms lk mt mu mv lo kn mw mx lq ko my mz ls kp na nb lu nc bi translated">课堂表现</h2><p id="0454" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">在一些浏览器中，类可以提供JavaScript引擎优化，这在其他情况下是不可用的。几乎在所有情况下，这些优化都不会对应用程序的性能产生重大影响。事实上，可能很多年都不需要担心性能差异。无论如何构建对象，对象创建和属性访问总是非常快(每秒百万次操作)。</p><p id="d536" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">也就是说，类似RxJS、Lodash等通用实用程序库的作者应该研究使用<code class="du mm mn mo mc b">class</code>创建对象实例可能带来的性能优势。除非你已经测量出一个显著的瓶颈，你可以证明使用<code class="du mm mn mo mc b">class</code>可以大大减少这个瓶颈，否则你应该优化干净、灵活的代码，而不是担心性能。</p><h1 id="415f" class="le lf hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">隐式依赖</h1><p id="82cb" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">您可能会被诱惑去创建旨在一起工作的功能混合。假设您想为您的应用程序构建一个配置管理器，当您试图访问不存在的配置属性时，它会记录警告。</p><p id="1e75" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">有可能像这样建造它:</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="352a" class="mg lf hh mc b fi mh mi l mj mk">// in its own module...<br/>const withLogging = logger =&gt; o =&gt; Object.assign({}, o, {<br/>  log (text) {<br/>    logger(text)<br/>  }<br/>});<br/></span><span id="8d14" class="mg lf hh mc b fi ml mi l mj mk">// in a different module with no explicit mention of<br/>// withLogging -- we just assume it's there...<br/>const withConfig = config =&gt; (o = {<br/>  log: (text = '') =&gt; console.log(text)<br/>}) =&gt; Object.assign({}, o, {<br/>  get (key) {<br/>    return config[key] == undefined ?</span><span id="7b83" class="mg lf hh mc b fi ml mi l mj mk">      // vvv implicit dependency here... oops! vvv<br/>      this.log(`Missing config key: ${ key }`) :<br/>      // ^^^ implicit dependency here... oops! ^^^</span><span id="134b" class="mg lf hh mc b fi ml mi l mj mk">      config[key]<br/>    ;<br/>  }<br/>});</span><span id="6b4d" class="mg lf hh mc b fi ml mi l mj mk">// in yet another module that imports withLogging and<br/>// withConfig...<br/>const createConfig = ({ initialConfig, logger }) =&gt;<br/>  pipe(<br/>    withLogging(logger),<br/>    withConfig(initialConfig)<br/>  )({})<br/>;</span><span id="d73f" class="mg lf hh mc b fi ml mi l mj mk">// elsewhere...<br/>const initialConfig = {<br/>  host: 'localhost'<br/>};</span><span id="5cef" class="mg lf hh mc b fi ml mi l mj mk">const logger = console.log.bind(console);</span><span id="27f1" class="mg lf hh mc b fi ml mi l mj mk">const config = createConfig({initialConfig, logger});</span><span id="8547" class="mg lf hh mc b fi ml mi l mj mk">console.log(config.get('host')); // 'localhost'<br/>config.get('notThere'); // 'Missing config key: notThere'</span></pre><p id="4c5c" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">然而，也可以这样构建它:</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="5344" class="mg lf hh mc b fi mh mi l mj mk">// import withLogging() explicitly in withConfig module<br/>import withLogging from './with-logging';</span><span id="9f37" class="mg lf hh mc b fi ml mi l mj mk">const addConfig = config =&gt; o =&gt; Object.assign({}, o, {<br/>  get (key) {<br/>    return config[key] == undefined ? <br/>      this.log(`Missing config key: ${ key }`) :<br/>      config[key]<br/>    ;<br/>  }<br/>});</span><span id="a0be" class="mg lf hh mc b fi ml mi l mj mk">const withConfig = ({ initialConfig, logger }) =&gt; o =&gt;<br/>  pipe(</span><span id="3117" class="mg lf hh mc b fi ml mi l mj mk">    // vvv compose explicit dependency in here vvv<br/>    withLogging(logger),<br/>    // ^^^ compose explicit dependency in here ^^^</span><span id="9386" class="mg lf hh mc b fi ml mi l mj mk">    addConfig(initialConfig)<br/>  )(o)<br/>;</span><span id="e9b7" class="mg lf hh mc b fi ml mi l mj mk">// The factory only needs to know about withConfig now...<br/>const createConfig = ({ initialConfig, logger }) =&gt;<br/>  withConfig({ initialConfig, logger })({})<br/>;<br/></span><span id="e582" class="mg lf hh mc b fi ml mi l mj mk">// elsewhere, in a different module...<br/>const initialConfig = {<br/>  host: 'localhost'<br/>};</span><span id="65f3" class="mg lf hh mc b fi ml mi l mj mk">const logger = console.log.bind(console);</span><span id="cf6d" class="mg lf hh mc b fi ml mi l mj mk">const config = createConfig({initialConfig, logger});</span><span id="279c" class="mg lf hh mc b fi ml mi l mj mk">console.log(config.get('host')); // 'localhost'<br/>config.get('notThere'); // 'Missing config key: notThere'</span></pre><p id="0932" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">正确的选择取决于很多因素。要求函数mixin使用提升的数据类型是有效的，但是如果是这样的话，应该在函数签名和API文档中明确API契约。</p><p id="aabf" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">这就是隐式版本在签名中有一个默认值<code class="du mm mn mo mc b">o</code>的原因。由于JavaScript缺乏类型注释功能，我们可以通过提供默认值来伪装它:</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="72d5" class="mg lf hh mc b fi mh mi l mj mk">const withConfig = config =&gt; (o = {<br/>  log: (text = '') =&gt; console.log(text)<br/>}) =&gt; Object.assign({}, o, {<br/>  // ...</span></pre><p id="8f7a" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">如果您使用的是TypeScript或Flow，那么最好为您的对象需求声明一个显式接口。</p><h1 id="9dfa" class="le lf hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">函数混合和函数编程</h1><p id="790c" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">在函数混合的上下文中,“函数式”并不总是具有与“函数式编程”相同的纯粹含义。函数混合通常在OOP风格中使用，带有副作用。许多函数混合会改变你传递给它们的对象参数。顾客小心上当。</p><p id="f76c" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">出于同样的原因，一些开发人员更喜欢函数式编程风格，不会维护对传入对象的标识引用。你应该对你的mixins和使用它们的代码进行编码，假设它们是两种风格的随机混合。</p><p id="7c64" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">这意味着如果你需要返回对象实例，总是返回<code class="du mm mn mo mc b">this</code>而不是闭包函数代码中对实例对象的引用，很可能它们不是对相同对象的引用。此外，总是假设对象实例将通过使用<code class="du mm mn mo mc b">Object.assign()</code>或<code class="du mm mn mo mc b">{...object, ...spread}</code>语法的赋值来复制。这意味着，如果您设置了不可枚举的属性，它们可能不会对最终对象起作用:</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="8156" class="mg lf hh mc b fi mh mi l mj mk">const a = Object.defineProperty({}, 'a', {<br/>  enumerable: false,<br/>  value: 'a'<br/>});</span><span id="afd8" class="mg lf hh mc b fi ml mi l mj mk">const b = {<br/>  b: 'b'<br/>};</span><span id="c8c8" class="mg lf hh mc b fi ml mi l mj mk">console.log({...a, ...b}); // { b: 'b' }</span></pre><p id="c7bb" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">同样，如果您使用的函数混合不是在函数代码中创建的，就不要假设代码是纯的。假设基对象可能会发生变异，并假设可能会有副作用&amp;没有引用透明性保证，也就是说，记忆由函数混合组成的工厂通常是不安全的。</p><h1 id="ff4a" class="le lf hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">结论</h1><p id="6de5" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">Functional mixins是可组合的工厂函数，它向对象添加属性和行为，比如装配线上的工作站。它们是从多个源特性(<strong class="js hi"> has-a，uses-a，can-do </strong>)组合行为的好方法，而不是继承给定类的所有特性(<strong class="js hi"> is-a </strong>)。</p><p id="f350" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">请注意，“函数式混合”并不意味着“函数式编程”——它仅仅意味着“使用函数的混合”。可以使用函数式编程风格编写函数式混合，避免副作用并保持引用透明性，但这并不能保证。第三方混音可能会有副作用和不确定性。</p><ul class=""><li id="16cb" class="kq kr hh js b jt ju jw jx kn ks ko kt kp ku kl kv kw kx ky bi translated">与简单的对象混合不同，函数混合支持真正的数据隐私(封装)，包括继承私有数据的能力。</li><li id="6e84" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">与单祖先类继承不同，函数混合也支持从许多祖先继承的能力，类似于类装饰符、特征或多重继承。</li><li id="198e" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">与C++中的多重继承不同，菱形问题在JavaScript中很少出现问题，因为当冲突出现时有一个简单的规则:最后添加的mixin获胜。</li><li id="a456" class="kq kr hh js b jt kz jw la kn lb ko lc kp ld kl kv kw kx ky bi translated">与类装饰、特征或多重继承不同，不需要基类。</li></ul><p id="a350" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">从最简单的实施开始，仅在需要时转向更复杂的实施:</p><p id="c00d" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">函数&gt;对象&gt;工厂函数&gt;函数混合&gt;类</p><p id="d7d5" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated"><a class="ae km" rel="noopener" href="/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1"> <strong class="js hi">接下来:JavaScript工厂函数与ES6+ &gt; </strong> </a></p><h1 id="3994" class="le lf hh bd lg lh li lj lk ll lm ln lo in lp io lq iq lr ir ls it lt iu lu lv bi translated">后续步骤</h1><p id="e44a" class="pw-post-body-paragraph jp jq hh js b jt lw ii jv jw lx il jy kn ly kb kc ko lz kf kg kp ma kj kk kl ha bi translated">想了解更多关于用JavaScript编写软件的知识吗？</p><p id="6a7e" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated"><a class="ae km" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank">跟Eric Elliott学JavaScript】。如果你不是会员，你就错过了！</a></p><figure class="ix iy iz ja fd jb er es paragraph-image"><a href="https://ericelliottjs.com/product/lifetime-access-pass/"><div class="er es nd"><img src="../Images/ebd7dfc9ae8d8938e30bdbdbe428fd4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3njisYUeHOdyLCGZ8czt_w.jpeg"/></div></a></figure></div><div class="ab cl ne nf go ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ha hb hc hd he"><p id="5e7e" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated"><strong class="js hi"> <em class="jr">埃里克·艾略特</em> </strong> <em class="jr">著有</em> <a class="ae km" href="http://pjabook.com" rel="noopener ugc nofollow" target="_blank"> <em class="jr">【编程JavaScript应用】</em> </a> <em class="jr">(奥赖利)，以及</em> <a class="ae km" href="http://ericelliottjs.com/product/lifetime-access-pass/" rel="noopener ugc nofollow" target="_blank"> <em class="jr">【跟埃里克·艾略特学JavaScript】</em></a><em class="jr">。他为Adobe Systems</em><strong class="js hi"><em class="jr"/></strong><em class="jr"/><strong class="js hi"><em class="jr">尊巴健身</em></strong><em class="jr"/><strong class="js hi"><em class="jr">华尔街日报</em></strong><em class="jr"/><strong class="js hi"><em class="jr">【ESPN</em></strong><em class="jr"/><strong class="js hi"><em class="jr">BBC</em></strong><em class="jr">等顶级录音师贡献了软件经验</em></p><p id="98ef" class="pw-post-body-paragraph jp jq hh js b jt ju ii jv jw jx il jy kn ka kb kc ko ke kf kg kp ki kj kk kl ha bi translated">他大部分时间都在旧金山湾区和世界上最美丽的女人在一起。</p></div></div>    
</body>
</html>