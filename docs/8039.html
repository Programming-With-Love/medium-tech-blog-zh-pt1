<html>
<head>
<title>Apache Spark ! What Next ? ( Is it GPU..)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇火花！接下来呢？(是GPU吗..)</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/apache-spark-what-next-is-it-gpu-33ce4a3851c1?source=collection_archive---------2-----------------------#2021-07-30">https://medium.com/walmartglobaltech/apache-spark-what-next-is-it-gpu-33ce4a3851c1?source=collection_archive---------2-----------------------#2021-07-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7bbeb4ea2d1e35ef345b92690bbc3060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UKpQk-VVf35E_Tad.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://miro.medium.com/max/2000/1*lVKnWhRIkmbqq1WE13ml2Q.png" rel="noopener">source</a></figcaption></figure><p id="672a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">决策是任何企业的关键。在当今高度数字化的世界中，获取丰富的信息有助于更好地做出这些关键决策。要释放如此丰富的信息，关键是要有一个集成的平台，它有助于为预测、物流和库存优化以及场景规划提供极具价值的商业智能，从而提高高质量决策的速度。</p><p id="2609" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在广阔的数字化世界中构建精确的优化解决方案是一个迭代过程，以发现适合决策的结果。这通常是死记硬背和“循环中最快的胜利”游戏，因为你迭代得越快，就越容易探索最佳解决方案并获得好的答案。</p><p id="6144" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在数字化世界中搅动如此巨大的数据海洋需要强大的计算工具。随着时间的推移，工具变得越来越快，但由于电子在物质中运动的物理限制，速度是有限的。这就是像由GPU(图形处理单元)驱动的RAPIDS这样的技术正在突破这一速度障碍的地方。</p><p id="76ec" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Rapids是几个开源项目的保护伞。RAPIDS大大提高了每一步迭代的速度，并提供了一种通用的信息格式，从而减少了不同系统之间交换数据的负担。</p><p id="97f7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在用户方面，RAPIDS复制了Python、cuDF API来简化基于Rapids的平台的过渡。它支持接口，如炽燃SQL，急流火花等。用于数据处理。这里我们要讨论的是基于GPU的RAPIDS-Spark大数据处理。</p><h1 id="7581" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">这就是我们兴奋的地方</h1><ol class=""><li id="c198" class="kq kr hh iw b ix ks jb kt jf ku jj kv jn kw jr kx ky kz la bi translated">带火花的急流的出现</li><li id="a348" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">你为什么需要火花急流？</li><li id="baa9" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">用GPU加速火花</li><li id="a326" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">架构是否有助于SPARK RAPIDS比SPARK-CPU表现更好？</li><li id="91bf" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">火花急流的关键进展</li><li id="bbd2" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">基于用例以及限制的调优</li></ol><h1 id="bdf8" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">火花与急流一起出现</h1><p id="6074" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">RAPIDS Accelerator for Apache Spark通过RAPID库利用GPU来加速处理。</p><p id="04ed" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">RAPIDS Accelerator for Apache Spark结合了RAPIDS cuDF库的强大功能和Spark分布式计算框架的规模。RAPIDS Accelerator库还内置了一个基于UCX (Unified Communication X)的加速洗牌，可以对其进行配置以利用GPU到GPU的通信和RDMA(远程直接内存访问)<strong class="iw hi"> </strong>功能。</p><h1 id="cd8d" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">为什么我们需要火花滩？</h1><p id="1ba3" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">人工智能在分析领域的日益普及产生了对新框架的需求，以利用GPU快速、经济高效地处理数据，RAPIDS通过更快的迭代和更频繁的部署来提高模型准确性，从而帮助ETL(提取、转换和加载)流程实现这一目标。此外，以下属性有助于为ETL管道选择RAPIDS spark。</p><ol class=""><li id="9227" class="kq kr hh iw b ix iy jb jc jf lj jj lk jn ll jr kx ky kz la bi translated">GPU加速的数据处理</li><li id="b4c7" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">易于与现有Spark-CPU流水线集成。从Spark-CPU到SPARK-RAPIDS的代码迁移成本几乎为零。</li><li id="209d" class="kq kr hh iw b ix lb jb lc jf ld jj le jn lf jr kx ky kz la bi translated">使用Spark-Rapids全面降低查询处理成本</li></ol><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lm"><img src="../Images/e4f9240a9332dab5baca38ecdae3aca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*auIN7S5zDiZ7QXcyxyFBsg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx">Tested Spark-Rapids performance (using nvidia-tesla-v100 GPU type) in one of the use case and found 66% performance improvement for ETL processing which deals with almost 67 billion records residing on cloud Platform.</figcaption></figure><h1 id="bffa" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">用GPU加速火花</h1><p id="7bd0" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">Rapids是一套使用GPU来加速数据处理的软件库。对于快速GPU优化算法，它使用低级CUDA代码，同时仍然拥有简单易用的SPARK-SQL和数据帧API。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lr"><img src="../Images/7cf406909bde46a090d2ed86e86415d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*rE_sGKih2EiP3Oli5gLA5w.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://www.nvidia.com/content/dam/en-zz/Solutions/deep-learning/deep-learning-solutions/data-science/apache-spark-3/apache-spark-accelerated-data-science-pipeline-1cC-L@2x-f.png" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="ad7b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Rapids的独特之处在于，它完全集成了Spark-sql API，这些API可以快速通过GPU加速到Rapids。SQL插件试图产生与Apache Spark完全相同的结果。在一些情况下，特定的函数会有一些差异，但大多数情况下都会获得预期的结果。</p><h1 id="6f76" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">架构是否有助于SPARK RAPIDS比SPARK-CPU表现更好？</h1><p id="bf79" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">RAPIDS由GPU机器驱动，而Spark2.0基于CPU工作。GPU具有高度并行的结构，这使得它在用于可以并行分区和处理的数据时比CPU更有效。更具体地说，GPU经过高度优化，可以执行浮点运算、矩阵运算等高级计算。</p><p id="0005" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">CPU和GPU之间计算能力的差异背后的原因是GPU专门用于计算密集型和高度并行的计算，这正是你在大数据上执行单个指令所需要的。GPU的设计更多的是数据处理，而不是数据缓存和流量控制。如果一个问题可以并行处理，通常意味着两件事:第一，对每个元素执行相同的问题，这需要不太复杂的流程控制；第二，数据集是海量的，问题具有高运算强度，这降低了对低延迟存储器的需求。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es ls"><img src="../Images/07899efb83e46ffedc35d66d85f5c8b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*Ye_hyp_HD8dcl4C7k7L1xA.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://assets-global.website-files.com/5debb9b4f88fbc3f702d579e/5e08f35d7436081481e15d61_e7b08ad97410491586d63028740b90c1.png" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="8c34" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上图展示了CPU和GPU在结构上的区别。缓存是为数据缓存而设计的；控件是为流量控制而设计的；ALU(算术逻辑单元)是为数据处理而设计的。</p><h1 id="495e" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">SPARK RAPIDS的特性有助于提高性能</h1><p id="8a3a" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">Apache Spark 3.0中的一些关键改进有助于实现透明的GPU加速:</p><p id="83f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">Apache Spark 3.0的RAPIDS加速器:</em></p><p id="5340" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Apache Spark的RAPIDS加速器建立在NVIDIA CUDA和UCX之上，通过Spark SQL和DataFrame APIs以及Spark shuffle实现，应用程序可以利用GPU并行性和高带宽内存速度，而无需更改代码</p><p id="4f4b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">急流加速火花数据帧&amp;火花SQL: </em></p><p id="310f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">RAPIDS通过Spark SQL和DataFrames提供GPU加速的内存高效的列数据处理和查询计划。当Spark查询执行时，它会经历以下步骤。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lu"><img src="../Images/58d7dbf3c2fcb4a6e763d8723a0726c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*1pWPW49CISd8Jvod3q0vHQ.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://developer-blogs.nvidia.com/wp-content/uploads/2020/06/accelerated-spark-sql-query-execution-plan-1.png" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="4aeb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过使用<em class="lt">spark . rapids . sql . enabled = TRUE，</em>启用GPU功能，对于具有聚合函数和比较运算符的不同查询，SQL性能有所提高。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lv"><img src="../Images/9a78f8313b794a4d38cdf0ec6c934728.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*GIPjEC_xbFnh5ho2Pf8YOg.png"/></div></figure><p id="5940" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">*如上图所示，当查询处理大约3000多万条记录时，性能提高了80%。160 GB。</em></p><p id="3bc5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt"> **在第一个sql中，一些操作不是100%兼容。这些不兼容性中有许多是大多数查询不会遇到的情况，或者不会对结果输出产生任何有意义的差异，但是操作落在CPU上，这在这种情况下会降低性能。通过单独启用这些操作，或者使用名为</em><strong class="iw hi"><em class="lt">spark . rapids . SQL . incompatible leops . enabled、</em> </strong> <em class="lt">的参数来启用这些操作，可以极大地提高查询的性能，但结果会因用例而异。随着时间的推移，RAPIDS-SPARK希望不兼容运营商的数量会减少。更多信息可在</em> <a class="ae it" href="https://nvidia.github.io/spark-rapids/docs/configs.html" rel="noopener ugc nofollow" target="_blank"> <em class="lt">网址</em> </a> <em class="lt">中找到。</em></p><p id="052b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">急流加速火花洗牌:</em></p><p id="507d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">加速spark shuffle实施基于GPU加速的统一通信X (UCX)库，可显著优化spark进程之间的数据传输。UCX公开了一组抽象的通信原语，它们充分利用了可用的硬件资源和负载，包括RDMA、TCP(传输控制协议)、GPU、共享内存和网络原子操作</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lw"><img src="../Images/07aba00f175783efaf102d80509bcf9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*4Bo8yk0JWuMFC-I8VAlDJw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><a class="ae it" href="https://developer-blogs.nvidia.com/wp-content/uploads/2020/06/spark-shuffle-diagram-1-1024x564.png" rel="noopener ugc nofollow" target="_blank">source</a></figcaption></figure><p id="5c16" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了加速洗牌操作，可以使用以下参数:</p><p id="481e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">spark . rapids . SQL . shuffle . spill threads，</em></p><p id="0913" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">spark . rapids . shuffle . transport . maxreceiveinflightbytes，</em></p><p id="bb49" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">spark . rapids . shuffle . ucx . use wake up</em></p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lx"><img src="../Images/1a44161f99bed02c0dca8c1c5d6d1db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*-O6CymQc3hw9GnWXZsVXew.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx"><em class="ly">Using above parameters, in recent research done by us, we found extra 23–29 % performance improvement with accelerated shuffle operation in RAPIDS spark, for this use-case input record count was more than 35 million and size of data was 167 GB</em></figcaption></figure><p id="842f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">Spark中的GPU感知调度:</em></p><p id="02d1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Apache Spark 3.0中，GPU现在是一种可调度的资源。这允许Spark为执行器调度指定数量的GPU，您可以指定每个任务需要多少GPU。Spark将这些资源请求传递给底层集群管理器、Kubernetes、YARN或standalone。您还可以配置一个发现脚本来检测集群管理器分配了哪些GPU。</p><h1 id="7941" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">基于用例以及限制的调优</h1><p id="e61e" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">除了上述特性之外，在调优过程中还有一些要点需要考虑。</p><p id="095d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">遗嘱执行人人数:</em></p><p id="84af" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">RAPIDS加速器插件只支持GPU和执行器之间的一对一映射。</p><p id="36f7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">每个执行者的任务数量:</em></p><p id="b80a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果每个集群节点都有24个CPU核心和4个GPU，那么设置spark.executor.cores=6将运行每个执行器，每个执行器有6个核心和6个并发任务，假设每个任务有一个核心的默认设置，即:spark . task . CPU = 1。</p><p id="d674" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">每个GPU的并发任务数:</em></p><p id="925b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当任务共享GPU时，每个执行器的并发任务数量可以进一步限制。这有助于避免GPU内存不足错误，同时仍允许作业中未在GPU上执行的部分完全并发。另一方面，将此值设置为高可能会导致GPU内存不足错误或运行时性能不佳。</p><p id="b23f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">配置键:<em class="lt">spark . rapids . SQL . concurrentgputasks</em></p><p id="f696" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">共享内存:</em></p><p id="7a3e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在GPU上分配内存可能是一项开销很大的操作。RAPIDS使用一个名为RMM (RAPIDS内存管理)的池分配器来减少这种开销。如果池耗尽，将会分配更多内存并添加到池中。大多数时候这是一个巨大的胜利，但是如果你需要与其他不知道RMM的库共享GPU，这可能会导致内存问题。</p><p id="1c0e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">configuration key:<em class="lt">spark . rapids . memory . GPU . pooling . enabled</em></p><p id="67da" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">位置等待:</em></p><p id="d0b0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它控制Spark应该等待多长时间以获得更好的任务局部性。当任务完成得比这个设置更快时，Spark调度程序可能会在一个阶段中不利用集群中的所有执行器，如果将这个设置为0，查询将会获得显著的性能提升。</p><p id="c790" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">配置键:<em class="lt"> spark.locality.wait </em></p><p id="c763" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lt">柱状批量大小:</em></p><p id="6da9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它控制GPU处理期间多个批次的拼接过程的上限。将该值设置得太低会导致大量的GPU处理开销和任务执行速度变慢。将该值设置得太高会导致GPU内存不足错误。如果在读取查询输入分区后，任务由于GPU内存不足错误而失败，请尝试将其设置为较低的值。</p><p id="c2d5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">配置密钥:spark . rapids . SQL . reader . batchsizerows</p><h1 id="33c8" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="2bf7" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated">如果有人想在GPU上移动他们的计算密集型数据管道，那么SPARK-RAPIDS可能是一个很好的选择，正如我们在本文中强调的那样。用户必须确保当前ETL管道中使用的函数/操作与SPARK-RAPIDS兼容，如果函数/操作不兼容，那么执行将退回到CPU，整体性能可能会下降一点，我们可能不会获得预期的节省。我们将在下一篇文章中展示SPARK RAPIDS GPU执行的一部分何时以及如何落在CPU上，以及当前有哪些选项来处理这些问题。SPARK RAPIDs发展迅速，因此今天不兼容的功能/操作可能明天就会兼容。</p><h1 id="7ee5" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">参考文献:</strong></h1><p id="668a" class="pw-post-body-paragraph iu iv hh iw b ix ks iz ja jb kt jd je jf lg jh ji jj lh jl jm jn li jp jq jr ha bi translated"><a class="ae it" href="https://rapids.ai/" rel="noopener ugc nofollow" target="_blank">https://rapids.ai/</a></p><p id="6f7e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae it" href="https://nvidia.github.io/spark-rapids/" rel="noopener ugc nofollow" target="_blank">https://nvidia.github.io/spark-rapids/</a></p></div></div>    
</body>
</html>