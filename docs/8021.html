<html>
<head>
<title>Solr Anti-patterns — Part1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solr反模式—第1部分</h1>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/anti-patterns-in-solr-9361a9ae04e7?source=collection_archive---------1-----------------------#2021-06-08">https://medium.com/walmartglobaltech/anti-patterns-in-solr-9361a9ae04e7?source=collection_archive---------1-----------------------#2021-06-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7208" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个<a class="ae jc" href="https://en.wikipedia.org/wiki/Anti-pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">反模式</strong> </a>是对一个重复出现的问题的常见回应，这种回应通常是无效的，并且有可能产生非常不利的后果。</p><p id="510d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是描述solr反模式的系列文章中的第一篇，为了提高Solr集群的性能和稳定性，应该避免使用这些反模式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/5b68ed678a3488b8e497efd5a9ce8f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIky-UG55AsZklqmkIeKGg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx">Image by <a class="ae jc" href="https://pixabay.com/users/davidzydd-985081/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2502391" rel="noopener ugc nofollow" target="_blank">David Zydd</a> from <a class="ae jc" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2502391" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="789c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最常见的反模式是:</p><h2 id="298f" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">1.深度分页</h2><p id="810c" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">在Solr中，使用<code class="du kt ku kv kw b">start</code>和<code class="du kt ku kv kw b">rows</code>参数支持<a class="ae jc" href="https://solr.apache.org/guide/8_8/pagination-of-results.html#basic-pagination" rel="noopener ugc nofollow" target="_blank">基本分页搜索</a>，但是在Solr中使用<a class="ae jc" href="https://solr.apache.org/guide/8_8/pagination-of-results.html#performance-problems-with-deep-paging" rel="noopener ugc nofollow" target="_blank">深度分页</a>会出现性能问题。</p><p id="b61e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用非常大的<code class="du kt ku kv kw b">start</code>或<code class="du kt ku kv kw b">rows</code>参数值可能会适得其反<strong class="ig hi"> </strong>。深度分页不仅需要Solr在内存中计算(和排序)应该为当前页面获取的所有匹配文档，还需要计算可能出现在以前页面上的所有文档。</p><p id="02cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:使用<a class="ae jc" href="https://lucene.apache.org/solr/guide/8_1/pagination-of-results.html#fetching-a-large-number-of-sorted-results-cursors" rel="noopener ugc nofollow" target="_blank">游标查询</a>来避免高起点和行参数的限制。游标查询是为深度分页而设计的，并推荐用于深度分页。使用游标查询时，需要注意的<a class="ae jc" href="https://solr.apache.org/guide/8_1/pagination-of-results.html#constraints-when-using-cursors" rel="noopener ugc nofollow" target="_blank">约束</a>很少。</p><h2 id="379e" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">2.显式提交和优化</h2><p id="5ddf" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">应该避免从客户端应用程序发送显式提交请求，因为这会严重影响集群的性能。</p><p id="de25" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行优化将从索引中删除所有已删除的文档，并将创建一个单独的段。此操作将创建比未来合并所考虑的最大值大得多的段，您必须定期执行此操作。这是一个非常繁重的操作，在执行期间索引大小加倍，并且基本上再次重建索引。</p><p id="f63f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:Solr提供了<a class="ae jc" href="https://solr.apache.org/guide/8_8/shards-and-indexing-data-in-solrcloud.html#ignoring-commits-from-client-applications-in-solrcloud" rel="noopener ugc nofollow" target="_blank">ignorecommoptimizeupdateprocessorfactory</a>，将忽略所有显式提交/优化。这种改变可以在solrconfig.xml中完成。</p><h2 id="af59" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">3.没有<a class="ae jc" href="https://solr.apache.org/guide/8_8/docvalues.html#docvalues" rel="noopener ugc nofollow" target="_blank">文档值</a>的字段或大型结果集上的SFPSGH</h2><p id="0393" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">SFPSGH -&gt;排序/方面/透视/统计/分组/突出显示</p><p id="6fd5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果在没有docValues的字段上运行SFPSGH查询，那么Solr就不能使用OS缓存，而必须将该字段的整个索引加载到JVM (Java虚拟机)中。如果那个字段的索引大于分配给Solr的JVM堆，这将导致Solr节点用完内存。</p><p id="530f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">即使Solr没有退出内存，<em class="kx"> FieldCache </em>也不会被推出Solr JVM，而是永远留在那里，直到Solr节点重新启动或者您重新加载集合。</p><p id="4e16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:为字段启用docValues (docValue=true ),并缩小必须执行SFPSGH操作的查询结果集。</p><p id="4d56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:不要为所有字段启用文档值。DocValues在写入端有一个性能损失，如果您在许多字段上启用了它，将会导致您的接收速度变慢。此外，更改docValue需要重新索引文档。</p><h2 id="dc89" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">4.无限制刻面</h2><p id="8610" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">您需要小心地为查询设置适当的facet.limit参数。如果在具有许多唯一值的字段上设置facet.limit=-1，情况尤其如此。</p><p id="47e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:尽量限制facet的结果集的数量，在启用了docValue的字段上使用facet，并使用<a class="ae jc" href="https://solr.apache.org/guide/8_8/json-facet-api.html" rel="noopener ugc nofollow" target="_blank"> json facet API </a>代替旧式的facet。</p><h2 id="e8f5" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">5.将所有字段存储在Solr中</h2><p id="545d" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">搜索索引是RAM受限的，因为它们必须将大部分索引保存在内存中。因此，不必要的字段存储会导致性能问题或增加硬件成本。</p><p id="e510" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有时，有些字段不会被搜索，但需要显示在搜索结果中。您可以通过将字段属性设置为stored=true和indexed=false来实现。存储字段会增加索引的大小，索引越大，搜索越慢。</p><p id="5c60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:根据业务需求存储和索引字段。</p><h2 id="233d" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">6.捕捉所有字段</h2><p id="1eff" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">托管模式中带有类似于<copyfield source="”*”" dest="”_text_”/">的条目的_text_ field被称为catch-all字段。</copyfield></p><p id="0773" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在某些情况下，如果客户端不知道可以搜索哪些字段，则可以启用此功能，但是在为“无所不包”字段的字段类型设计管道时要非常小心。如果您有同义词扩展或图形过滤器工厂，那么解析的查询可能会爆炸，并可能导致内存不足的问题，特别是如果您使用solr 7.x，请参见以下错误报告片段:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ky"><img src="../Images/b31cacffe921c5dcef494545c4a8452f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJhh9jpiBDvKD5InBhU07g.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx"><a class="ae jc" href="https://issues.apache.org/jira/browse/SOLR-13336" rel="noopener ugc nofollow" target="_blank">https://issues.apache.org/jira/browse/SOLR-13336</a></figcaption></figure><p id="9e28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">欲了解更多详情，请阅读此处的<a class="ae jc" href="https://dineshkumarnaik.medium.com/maxbooleanclauses-behavior-in-solr-7-x-vs-8-x-a02f9ec0f5af" rel="noopener"/>。</p><p id="cb31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:无所不包的字段会显著增加索引的大小。如果不需要，可以考虑删除该字段和相应的copyField指令。</p><h2 id="a6ea" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">7.堆大小:太大或太小</h2><p id="10c3" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">您需要理解，当涉及到Solr中的堆使用时，一种大小并不适合所有情况。您需要一个足够大的堆，这样您就不会有OOM异常和持续垃圾收集的问题，但也要足够小，这样您就不会浪费内存或遇到大量垃圾收集暂停。</p><p id="c71f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:确定正确大小的最佳方法是分析位于日志目录中的垃圾收集(GC)日志。有各种各样的工具，如<a class="ae jc" href="http://www.tagtraum.com/gcviewer.html" rel="noopener ugc nofollow" target="_blank"> GCViewer </a>和<a class="ae jc" href="https://gceasy.io/" rel="noopener ugc nofollow" target="_blank"> GCEasy </a>可以帮助分析这些日志，特别是显示GC完成后使用的内存量。</p><h2 id="ff81" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">8.大型事务日志(TLOGs)</h2><p id="f879" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">只有当<em class="kx">你</em>告诉Solr进行硬提交(或者自动提交发生，在solrconfig.xml中配置)时，TLOGs才会翻转。</p><p id="55ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，在批量加载的情况下，比如说每秒加载1，000个文档，并且一个小时内没有执行硬提交，那么您的单个tlog将包含3，600，000个文档。并且不正常的关闭可能导致在Solr节点开始营业之前完全重放它。这可能需要<em class="kx">个小时。</em></p><p id="33ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:如果您有非常大的tlogs，这是一件坏事，您应该更改您的硬提交设置。</p><h2 id="ae6d" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">9.在一个碎片中存储数十亿份文档</h2><p id="b7f1" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">请记住，Lucene/Solr对每个lucene-index有大约21.4亿个文档的限制，但是在Solr中，即使删除的文档也算作常规文档，并且更新的结果不是1个文档→而是1个删除的文档和1个新文档。</p><p id="6a74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，被删除的文档也计入21.4亿个文档的限制中。由于删除的文档很难估计，建议将常规文档的数量限制在10亿。这为删除的文档提供了空间，也为扩展提供了一些缓冲。</p><p id="56e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:考虑到未来6个月到一年的数据增长，规划您的分片策略。您可以从1.5或2的索引/Ram比率开始，假设您有1亿个大小为1 KB的文档，这意味着总大小为100 GB。</p><p id="1777" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在每个具有25gb Ram的节点/计算中，索引/Ram比率为1.5或2，您可以将索引大小保持在(35到40)或50 GB(如果最少的方面/透视查询的查询率较低)。<br/>您至少需要2或3个碎片来容纳100 GB。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kz"><img src="../Images/4b00d891bd277e80b8161b49e313ad98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jaCuSLb6eUKzXR9yAdFXAA.png"/></div></div></figure><p id="2304" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:这只是一个开始的例子，您必须进行适当的性能测试，以获得满足您的读写吞吐量的实际数字。</p><h2 id="00c5" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated"><strong class="ak"> 10。唯一键上的分组/分面</strong></h2><p id="408e" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">对唯一键进行分组或分面不是有效的用例，因为唯一键字段的计数将始终为1。但是有时用户会在不知不觉中犯这样的错误，这会导致集群中断。</p><p id="149f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设jobId被定义为托管模式中的唯一键，那么运行下面的查询会导致OOM，因为如果字段的基数(字段中唯一值的数量)很大(对于唯一键字段，基数最高)，分组和分面是繁重的操作。</p><pre class="je jf jg jh fd la kw lb lc aw ld bi"><span id="d306" class="jt ju hh kw b fi le lf l lg lh">q=*:*&amp;group.ngroups=true&amp;rows=0&amp;group.field=jobId&amp;group=true<br/> <br/>q=*:*&amp;facet.limit=-1&amp;facet.field=jobId&amp;rows=0&amp;facet=true</span></pre><p id="f1f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:如果您想按唯一键排序，请确保您不是在排序数百万条记录，在运行SFPSGH之类的复杂操作之前，尝试缩小搜索结果的范围。</p><p id="a0dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解决方案:避免在唯一键上运行分面/分组。</p><h1 id="3862" class="li ju hh bd jv lj lk ll jz lm ln lo kd lp lq lr kg ls lt lu kj lv lw lx km ly bi translated">结论</h1><p id="5a7f" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">这篇文章是我们列出10个最常见的solr反模式及其替代解决方案的第一部分。在<a class="ae jc" rel="noopener" href="/walmartglobaltech/solr-anti-patterns-part2-ad6b15a6e991">第2部分</a>中，我们介绍了更多的反模式和解决方案，以帮助您提高集群的稳定性和性能。敬请期待！</p></div></div>    
</body>
</html>