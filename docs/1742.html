<html>
<head>
<title>Using Kotlin’s Delegation to Add Superpowers to a Data Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin的委托为数据类添加超级能力</h1>
<blockquote>原文：<a href="https://medium.com/capital-one-tech/using-kotlins-delegation-to-add-superpowers-to-a-data-class-5060a93c0943?source=collection_archive---------2-----------------------#2020-05-27">https://medium.com/capital-one-tech/using-kotlins-delegation-to-add-superpowers-to-a-data-class-5060a93c0943?source=collection_archive---------2-----------------------#2020-05-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/1bf542653e91a6e3fd4676fd26ec59f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HGx7cYWCeSTryDev"/></div></div></figure><p id="ddd8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你已经用Kotlin写了一段时间的代码，你几乎肯定会遇到<a class="ae jn" href="https://kotlinlang.org/docs/reference/delegation.html" rel="noopener ugc nofollow" target="_blank">委托</a>。委托模式最常见的用法之一是lazy 的<a class="ae jn" href="https://kotlinlang.org/docs/reference/delegated-properties.html#lazy" rel="noopener ugc nofollow" target="_blank">，它强制一个值直到被请求时才被计算，并且这个值在后续请求时不会被重新计算。</a></p><p id="e430" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">委托模式的另一个常见用法是当它被用来实现一个<code class="du jo jp jq jr b">interface</code> <code class="du jo jp jq jr b">by</code>一些注入的参数，比如<code class="du jo jp jq jr b">CoroutineScope by injectedScope</code>。这允许我们在注入的参数上调用公共成员，而不必持续地直接引用它，类似于我们使用<code class="du jo jp jq jr b">with(something)</code>时的情况。</p><h1 id="fdb3" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">增强固定大小的状态容器</h1><p id="7e3e" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">直到最近，我在授权方面的经验仅限于上面的两个例子。然而，后来我遇到了一种优雅的方式，通过使用委托来赋予固定大小的数据容器<code class="du jo jp jq jr b">Collection</code>的权力。</p><p id="3c56" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我的职业生涯中，固定大小的数据容器是我经常遇到的一个需求。通常，这些是在编译时已知的一组或一列实体，但是需要通过API响应或其他运行时输入来处理或实现各种字段。这种容器的一个例子是用户有资格使用的一套特征。潜在的功能在编译时是已知的，但用户是否有资格使用该功能以及每个功能的所有特征直到应用程序运行时才知道。</p><p id="58d5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Kotlin中，我们通常使用以下两种方式之一来表示这种类型的数据:数据类或<code class="du jo jp jq jr b">Set&lt;T&gt;</code>。</p><h1 id="21dd" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">数据类</h1><p id="31fd" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">在设计这样的容器时，数据类是一个很好的起点。</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="84e7" class="ld jt hh jr b fi le lf l lg lh">data class FeatureSuite(<br/>  val featureOne: Feature.TypeA.FeatureOne,<br/>  val featureTwo: Feature.TypeA.FeatureTwo,<br/>  val featureThree: Feature.TypeB.FeatureThree,<br/>  ...<br/>)</span></pre><p id="9eb9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">拥有这些特性的<code class="du jo jp jq jr b">data class</code>表示的一个主要好处是，我们可以保证在构建套件时考虑到每个特性。这是因为每个特性都是我们类的构造函数的必需参数。此外，作为套件的公共属性，我们对每个特性都有不可空的访问权，所以如果我们需要检查给定的特性是否被启用，我们必须做的就是<code class="du jo jp jq jr b">suite.featureOne.isEnabled()</code>。顺便说一下，在普通的<code class="du jo jp jq jr b">class</code>上使用<code class="du jo jp jq jr b">data class</code>确保了每个参数都必须是<code class="du jo jp jq jr b">val</code>或<code class="du jo jp jq jr b">var</code>，这有助于加强该域实体的容器特征。</p><p id="3d58" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，<code class="du jo jp jq jr b">data class</code>也有不好的一面。如果我们想获得类型为<code class="du jo jp jq jr b">TypeA</code>的特性列表，除了创建并返回所有已知<code class="du jo jp jq jr b">TypeA</code>特性列表的“硬编码”公共方法之外，我们别无选择。如果我们要向套件中添加一个新的<code class="du jo jp jq jr b">TypeA</code>特性，我们很可能会忘记将其添加到列表中，这也意味着我们要在两个不同的地方跟踪相同的数据，这增加了复杂性。捕捉这一点的单元测试将是脆弱的和尽力而为的，这不是我们在写测试时所渴望的。</p><h1 id="9b0b" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">设定<feature/></h1><p id="b3b2" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们可以采取的第二种方法是使用一个<code class="du jo jp jq jr b">Set&lt;Feature&gt;</code>作为我们特性的容器。这可能类似于:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="1f65" class="ld jt hh jr b fi le lf l lg lh">typealias FeatureSuite = Set&lt;Feature&gt;</span></pre><p id="d2b9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我们可以通过执行以下操作来创建一个<code class="du jo jp jq jr b">FeatureSuite</code>:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="b20e" class="ld jt hh jr b fi le lf l lg lh">val featureSuite = setOf(<br/>  Feature.TypeA.FeatureOne(...),<br/>  Feature.TypeA.FeatureTwo(...),<br/>  Feature.TypeB.FeatureThree(...),<br/>  ...<br/>)</span></pre><p id="aa46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过使用一个<code class="du jo jp jq jr b">Set</code>，我们现在能够像<code class="du jo jp jq jr b">filterIsInstance</code>一样获得类型<code class="du jo jp jq jr b">TypeA</code>的所有特性，而不必担心如果我们添加一个新特性会丢失一个。</p><p id="7e1b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然而，我们已经失去了<code class="du jo jp jq jr b">data class</code>的好处！我们不再能保证在创建套件时每个特性都被传入，并且我们不能对每个特性进行空安全访问，因为不能保证特性存在于<code class="du jo jp jq jr b">Set</code>中！这种零安全性的缺乏将会传播到套件的所有使用中，如果请求了一个没有添加到套件中的特性，可能会导致<code class="du jo jp jq jr b">RuntimeException</code>。</p><p id="7897" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">那么，我们如何获得<code class="du jo jp jq jr b">data class</code> <strong class="ir hi">和</strong><code class="du jo jp jq jr b">Set</code>的好处，都在一个实体中呢？你猜对了，代表团！</p><h1 id="9492" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">代表团，你的新超级大国！</h1><p id="7f63" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们应该将<code class="du jo jp jq jr b">FeatureSuite</code>定义如下:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="5a50" class="ld jt hh jr b fi le lf l lg lh">data class FeatureSuite(<br/>  val featureOne: Feature.TypeA.FeatureOne,<br/>  val featureTwo: Feature.TypeA.FeatureTwo,<br/>  val featureThree: Feature.TypeB.FeatureThree,<br/>  ...<br/>) : Set&lt;Feature&gt; by setOf(<br/>  featureOne,<br/>  featureTwo,<br/>  featureThree,<br/>  ...<br/>)</span></pre><p id="b094" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，我们现在通过使用由所有特性参数组成的<code class="du jo jp jq jr b">Set</code>的委托，同时拥有了<code class="du jo jp jq jr b">data class</code>和<code class="du jo jp jq jr b">Set</code>的优点。</p><ul class=""><li id="8953" class="li lj hh ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated">确保所有特性都通过构造函数传递到套件中</li><li id="a751" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">通过<code class="du jo jp jq jr b">featureSuite.someFeature</code>对功能进行零安全访问</li><li id="198e" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">能够<code class="du jo jp jq jr b">filterIsInstance</code>并接收给定类型的所有特性，而不用担心会丢失一个</li></ul><p id="4cd4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们也可以开始添加额外的功能来使呼叫站点更加整洁:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="b9b1" class="ld jt hh jr b fi le lf l lg lh">val typeAFeatures: List&lt;Feature.TypeA&gt; by lazy {<br/>  filterIsInsance(Feature.TypeA::class.java)<br/>}</span><span id="fc81" class="ld jt hh jr b fi lw lf l lg lh">val enabledFeatures: List&lt;Feature&gt; by lazy {<br/>  filter { it.isEnabled() }<br/>}</span></pre><h1 id="1bdc" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">测试</h1><p id="c8fc" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">我们应该通过单元测试来执行一些事情，以减少任何未来开发人员错误的风险:</p><ul class=""><li id="8b5e" class="li lj hh ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated">所有的特性都应该映射到底层的<code class="du jo jp jq jr b">Set</code>(需要确保我们没有遗漏任何一个！).这是最重要的测试。</li><li id="ca9f" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated">传递给套件的特性实际上与底层<code class="du jo jp jq jr b">Set</code>中的特性完全相同(对象相等)</li></ul><p id="458e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第一个测试很简单。因为<code class="du jo jp jq jr b">Set</code>本质上不允许重复，我们只需要确保创建的<code class="du jo jp jq jr b">Set</code>的大小与套件本身的参数数量相同。</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="a079" class="ld jt hh jr b fi le lf l lg lh">// Notes: `primaryConstructor` is made available through `kotlin-reflect` and `FakeFeatureSuite` is just a convenience method to create a (real) test object that can be re-used in other tests.</span><span id="371c" class="ld jt hh jr b fi lw lf l lg lh">@Test<br/>fun `All features mapped to Set`() {</span><span id="504d" class="ld jt hh jr b fi lw lf l lg lh">  val featuresRequiredInConstructor =<br/>    FeatureSuite::class.primaryConstructor!!.parameters.size</span><span id="41ff" class="ld jt hh jr b fi lw lf l lg lh">  val featuresAddedToSet = FakeFeatureSuite().size </span><span id="e568" class="ld jt hh jr b fi lw lf l lg lh">  assertThat(featuresAddedToSet)<br/>    .isEqualTo(featuresRequiredInConstructor)</span><span id="1231" class="ld jt hh jr b fi lw lf l lg lh">}</span></pre><p id="bb76" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">第二个测试不那么可靠，但仍然值得一试:</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="4027" class="ld jt hh jr b fi le lf l lg lh">@Test<br/>fun `Object equality of features`() {</span><span id="f45c" class="ld jt hh jr b fi lw lf l lg lh">  val featureSuite = FakeFeatureSuite()</span><span id="36f9" class="ld jt hh jr b fi lw lf l lg lh">  val featureOneFromSet = featureSuite.single {<br/>    it is Feature.TypeA.FeatureOne<br/>  }</span><span id="2c9b" class="ld jt hh jr b fi lw lf l lg lh">  assertThat(featureSuite.featureOne)<br/>    .isSameAs(featureOneFromSet)</span><span id="57a6" class="ld jt hh jr b fi lw lf l lg lh">}</span></pre><p id="55f5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个测试的风险是一个新的特性会被添加到套件中，但是不会被添加到这个测试中。我们可以尝试防止这种情况的一种方法是检查断言的数量是否总是等于套件中特性的数量。</p><pre class="kv kw kx ky fd kz jr la lb aw lc bi"><span id="828c" class="ld jt hh jr b fi le lf l lg lh">val assertions = listOf&lt;AbstractAssert&lt;*,*&gt;&gt;(<br/>  // Wrap our assertions in a List</span><span id="ce8f" class="ld jt hh jr b fi lw lf l lg lh">  assertThat(featureSuite.featureOne)<br/>    .isSameAs(featureOneFromSet)<br/>)</span><span id="355d" class="ld jt hh jr b fi lw lf l lg lh">val expectedAssertionCount =<br/>  FeatureSuite::class.primaryConstructor!!.parameters.size</span><span id="fff3" class="ld jt hh jr b fi lw lf l lg lh">assertThat(assertions.size)<br/>  .`as`( "Ensure all constructor params checked for object equality").isEqualTo(expectedAssertionCount)</span></pre><p id="97ec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，如果添加了一个新特性，但是没有添加到我们的断言中，这个测试将会失败。我们现在唯一能弄乱它的方法是偶然地复制列表中的断言，而不是为一个新特性添加一个唯一的断言。</p><h1 id="37d7" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="21e3" class="pw-post-body-paragraph ip iq hh ir b is kq iu iv iw kr iy iz ja ks jc jd je kt jg jh ji ku jk jl jm ha bi translated">通过结合普通<code class="du jo jp jq jr b">data class</code>和<code class="du jo jp jq jr b">Set</code>的优点，我们能够以一种避免<code class="du jo jp jq jr b">RuntimeException</code> s的安全方式为我们的功能套件提供所有需要的功能。一如既往，如果您对我如何改进这一实现有任何建议，请按我的方式提出！</p></div><div class="ab cl lx ly go lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ha hb hc hd he"><p id="6ea5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="me">披露声明:2020资本一。观点是作者个人的观点。除非本帖中另有说明，否则Capital One不隶属于所提及的任何公司，也不被这些公司认可。使用或展示的所有商标和其他知识产权是其各自所有者的财产。</em></p><p id="800a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="me">原载于2020年5月27日https://brandontrautmann.com</em><a class="ae jn" href="https://brandontrautmann.com/using-delegation-to-add-superpowers-to-a-data-class/" rel="noopener ugc nofollow" target="_blank"><em class="me"/></a><em class="me">。</em></p></div></div>    
</body>
</html>