<html>
<head>
<title>First Impressions of Android’s new ConstraintLayout</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android新ConstraintLayout的第一印象</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/first-impressions-of-androids-new-constraintlayout-c6d081b2bc2a?source=collection_archive---------0-----------------------#2016-05-31">https://medium.com/google-developer-experts/first-impressions-of-androids-new-constraintlayout-c6d081b2bc2a?source=collection_archive---------0-----------------------#2016-05-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="692d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在谷歌IO之后， <a class="ae jd" href="https://developers.google.com/experts/" rel="noopener ugc nofollow" target="_blank"> <em class="jc">安卓GDE </em> </a> <em class="jc">团队聚在一起，收集我们对大会最重要公告的想法。这是我们对新约束布局的想法总结。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/bea32ea882601bbaa5ee75b11e951ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXzQznd_I5VRYekamyQJ_w.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">High-level Constraint Layout basic concepts</figcaption></figure><p id="b8db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在IO 2016上，更令人兴奋的<a class="ae jd" href="http://android-developers.blogspot.com/2016/05/android-studio-22-preview-new-ui.html" rel="noopener ugc nofollow" target="_blank">公告</a>(特别是对专注于UI的开发人员而言)之一是一个名为<em class="jc"> ConstraintLayout </em> (CL)的新布局容器和工具。</p><p id="5cdf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个工具还处于早期阶段。目前只能从Android Studio 的<a class="ae jd" href="http://tools.android.com/download/studio/canary/latest" rel="noopener ugc nofollow" target="_blank">金丝雀频道获得。我们预计它会很快成熟(他们已经在发布的第一周内推出了他们的第一个更新)。我们希望这种布局类型最终会成为所有顶级界面的默认布局。</a></p><h2 id="65af" class="ju jv hh bd jw jx jy jz ka kb kc kd ke ip kf kg kh it ki kj kk ix kl km kn ko bi translated">ConstraintLayout视图类型</h2><p id="0e96" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">基本上，新的CL只是另一个简单的XML布局类型。这与你可能已经在使用的其他布局没有太大区别(比如<em class="jc"> RelativeLayout </em>或<em class="jc"> LinearLayout </em>)。事实上，CL可以像任何其他布局一样使用——它可以嵌套到其他布局中，甚至可以用于API 9。查看和编辑XML是可能的，但是当我们问谷歌员工这个问题时，他们都回答说:“T20你可以，但是你为什么要用？”。这主要是作为一个面向视觉的工具来设计的。</p><p id="8a5f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">新布局基于<em class="jc">约束。这些描述了您的视图(或屏幕)之间的关系，具有响应的性质。这些属性与<em class="jc"> RelativeLayout </em>使用的属性非常相似(如:<em class="jc">Android:layout _ alignParentBottom = " true "</em>)。</em></p><p id="8912" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果CL仅仅是另一个布局容器，就没有什么好兴奋的了。但是，CL不仅仅是另一种布局类型<em class="jc">。这是一个全新的布局容器，旨在帮助开发人员创建复杂的布局，优化快速渲染。这是因为它会生成平面视图层次结构(请阅读这篇<a class="ae jd" href="http://blog.venmo.com/hf2t3h4x98p5e13z82pl8j66ngcmry/performance-tuning-on-android" rel="noopener ugc nofollow" target="_blank">文章</a>以了解为什么这很重要)。这将真正帮助开发人员创建具有复杂界面的应用程序，快速显示，没有视觉抖动或暂停，消耗最少的内存资源。# perfmatters-)</em></p><blockquote class="ku kv kw"><p id="520e" class="ie if jc ig b ih ii ij ik il im in io kx iq ir is ky iu iv iw kz iy iz ja jb ha bi translated">这应该摆脱了“这里应该用什么布局”这种答案来源于经验(和失败)的新手问题。现在有了一个顶级容器，它被设计成每个人都应该经常使用的主要容器</p></blockquote><h2 id="d526" class="ju jv hh bd jw jx jy jz ka kb kc kd ke ip kf kg kh it ki kj kk ix kl km kn ko bi translated">约束布局编辑器</h2><p id="ad71" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">除了新的布局类型之外，还有一个全新的可视化编辑器来简化这些新布局的创建。可视化编辑器旨在成为开发人员与其布局交互的主要方式。我们不打算详细介绍这个工具的用法，因为<a class="ae jd" href="https://developers.google.com/experts/people/rebecca-franks" rel="noopener ugc nofollow" target="_blank">丽贝卡</a>已经在<a class="ae jd" href="http://riggaroo.co.za/constraintlayout-101-new-layout-builder-android-studio/" rel="noopener ugc nofollow" target="_blank">这篇文章中做得很好了，</a>还有<a class="ae jd" href="http://tools.android.com/tech-docs/layout-editor" rel="noopener ugc nofollow" target="_blank">的文档</a>。</p><blockquote class="ku kv kw"><p id="0109" class="ie if jc ig b ih ii ij ik il im in io kx iq ir is ky iu iv iw kz iy iz ja jb ha bi translated">这主要是作为一个可视化工具而设计的，从头开始重新编写，并不是现有可视化编辑器的发展</p></blockquote><p id="322c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">新的可视化编辑器使用起来很有趣。它由3个主要工具组成:</p><ul class=""><li id="2cd4" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated">可视化编辑器—显示您的用户界面在特定屏幕上的外观以及应用的特定主题</li><li id="4d39" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">蓝图编辑器——这是人们花费大部分时间的地方，也是开发人员定义他们的视图之间的关系的地方</li><li id="4721" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">属性编辑器—将特定属性应用于选定的视图。</li></ul><p id="0ccc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大多数开发人员的交互将使用蓝图视图来完成。如果您启用了“自动连接”按钮并将一个视图(如<em class="jc">按钮</em>或<em class="jc">文本视图</em>)拖动到屏幕上，编辑器将自动创建<em class="jc">约束</em>(连接到其他对象或屏幕边缘)。创建约束时，会显示一个很好的动画。</p><p id="f8f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">删除和重新创建约束很容易，甚至还有一个<em class="jc">“推断约束”</em>按钮，它会猜测整个布局的约束。当我们尝试这样做时，它的效果和预期的一样好。我们认为开发人员将利用这一点开始，然后调整约束来微调细节。</p><p id="c1b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总的来说，所有的编辑器都非常简单易用。如果你习惯于用<em class="jc"> RelativeLayouts </em>构建ui，这看起来会很熟悉。然而，如果你已经嵌套了大量的LinearLayouts来构建复杂的布局，那么，为你感到羞耻，这将是学习如何以正确的方式构建响应性布局的好时机。</p><h2 id="c582" class="ju jv hh bd jw jx jy jz ka kb kc kd ke ip kf kg kh it ki kj kk ix kl km kn ko bi translated">这一切将走向何方？</h2><p id="c1c7" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">对于这个工具来说，现在还为时尚早。对于谷歌的所有事情，我们都抱着谨慎乐观的态度。</p><p id="290c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们欢迎有一天设计师能够理解Android视图布局的基本概念，甚至使用工具。从原型工具(如Sketch或Adobe Illustrator)导出布局的可能性很可能会出现(直接来自Google或社区)。</p><p id="bcbe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">目前可以将现有布局直接导入工具。在某些时候，这可能是值得做的事情，因为这应该会提高每个应用程序的整体性能。此时，我们认为在生产中广泛使用它之前让它成熟一点是明智的。</p><p id="e91b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们担心向面向视觉的开发的转变会如何影响开发工作流。例如，如何为代码评审跟踪布局的变化？</p><p id="91cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当创建<em class="jc">约束时，<em class="jc">蓝图</em>编辑器显示动画。</em>它们很慢，你必须在动画结束前停止约束生成。看起来这将是乏味的(希望有一个关闭动画的选项)。</p><h2 id="6e0b" class="ju jv hh bd jw jx jy jz ka kb kc kd ke ip kf kg kh it ki kj kk ix kl km kn ko bi translated">结论</h2><p id="6a5b" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">我们对这个新的UI概念感到兴奋，并且认为使用<em class="jc"> ConstraintLayout </em>在不久的将来会非常有用。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lo"><img src="../Images/c84016ebb365492f03a591c4c7d69007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9J415Zf7dYwz0lcV5VJHg.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx">Some of the Andoid GDEs at post-IO gathering</figcaption></figure></div></div>    
</body>
</html>