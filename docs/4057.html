<html>
<head>
<title>Event-driven programming for Android (part I)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android的事件驱动编程(上)</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/event-driven-programming-for-android-part-i-f5ea4a3c4eab?source=collection_archive---------0-----------------------#2015-01-25">https://medium.com/google-developer-experts/event-driven-programming-for-android-part-i-f5ea4a3c4eab?source=collection_archive---------0-----------------------#2015-01-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="dfbc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(这是由三部分组成的系列文章的第一部分)</p><p id="432d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然Android在其开发中包含了一些事件驱动的特性，但它远远不是一个纯事件驱动的架构。这是好事还是坏事？正如在软件开发的每一个问题中一样，答案并不容易:视情况而定。</p><p id="dab1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，让我们为事件驱动开发建立一个定义。这是一个编程范例，其中执行流由动作触发的事件决定(如用户交互、来自其他线程的消息等)。从这个意义上说，Android是部分事件驱动的:我们都可以想到onClick监听器或活动生命周期，它们是能够在应用程序中触发动作的事件。为什么我说它不是一个纯事件驱动的系统？默认情况下，每个事件都绑定到一个特定的控制器，除此之外很难操作(例如，onClick事件是为一个视图定义的，具有有限的范围)。</p><p id="06cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">等等，你说的是一种新的编程模式。采用框架或方法总是有成本的，这会带来优势吗？我说是的，为了证明这一点，我想提出一些传统Android开发的局限性。</p><p id="1ce6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在许多情况下，很容易得到如下图所示的结构:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/4bf64b415e9f7e7fc8c55d6af4ce9a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*E8LdhGivILj-DZntgtctrg.png"/></div></figure><p id="96c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jk">活动</em>可以与<em class="jk">片段</em>通信，<em class="jk">片段</em>可以向另一个<em class="jk">片段</em>和<em class="jk">服务发送消息。</em>组件之间存在紧密耦合，应用更改可能会非常昂贵(*)。这经常导致样板代码，实现需要回调和通过不同层传播的功能的接口…你可能知道我想去哪里。随着代码量的增加，可维护性和良好的软件工程实践正在减少。</p><p id="e12d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">事件驱动编程在这里如何应用？让我们代表另一个系统提案:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jl"><img src="../Images/cb017a1e2579f55940e5e60a2ed75802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WqRoVCAdoc8c5Tfu5myWQ.png"/></div></div></figure><p id="e788" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从概念上讲，所表示的系统有一个事件总线。有不同的实体订阅事件总线，发布事件或监听事件——分别是生产者或消费者。任何订户都可以在不知道逻辑的情况下执行操作。想想吧。考虑一下特殊的可能性:一个片段可以再次呈现并更新它的屏幕，而不需要知道任何操作背后的逻辑，只需要知道发生了一个事件。考虑代码解耦和拥有一个干净的、划分好的架构的可能性。</p><p id="39de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Android支持这种范式吗？嗯，部分是。如前所述，SDK本身提供了一套精简的事件处理技术，但我们希望更进一步。这里我想提几个名字:</p><ul class=""><li id="a5f5" class="jq jr hh ig b ih ii il im ip js it jt ix ju jb jv jw jx jy bi translated"><a class="ae jz" href="https://github.com/greenrobot/EventBus/" rel="noopener ugc nofollow" target="_blank"> EventBus </a>，来自<a class="ae jz" href="http://greenrobot.de/" rel="noopener ugc nofollow" target="_blank">绿色机器人</a>。这个库已经针对Android进行了优化，并具有一些高级功能，如交付线程和订阅者优先级。</li><li id="2c59" class="jq jr hh ig b ih ka il kb ip kc it kd ix ke jb jv jw jx jy bi translated"><a class="ae jz" href="http://square.github.io/otto/" rel="noopener ugc nofollow" target="_blank">奥托</a>，来自<a class="ae jz" href="https://squareup.com/global/en/register" rel="noopener ugc nofollow" target="_blank">方</a>。最初是来自<a class="ae jz" href="https://code.google.com/p/guava-libraries/" rel="noopener ugc nofollow" target="_blank">番石榴</a>的一个分支，它已经进化并完善到Android平台。</li></ul><p id="639e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尝试过两者之后，我更喜欢EventBus而不是Otto。Greenrobot <a class="ae jz" href="https://github.com/greenrobot/EventBus/blob/master/COMPARISON.md" rel="noopener ugc nofollow" target="_blank">声称</a>EventBus在性能上明显优于其配对产品，并提供了额外的功能。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kf"><img src="../Images/c2e3f54f29f816b93201a4d67a957dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*uw1QaSKhDc_J_zDTMH24ow.png"/></div></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es kg"><img src="../Images/6b0b531dceaaeaeb8876ad5a6f6a01a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4FFuBtsHh1OFtm-lts4OSA.png"/></div></div></figure><p id="1da6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一篇文章将探讨如何在EventBus中实现基本功能</p><p id="5ca2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(*)提到“很多时间”，我故意喜欢用“贵”这个词。从经济角度思考通常更有效。</p></div></div>    
</body>
</html>