<html>
<head>
<title>Kotlin Programmer Dictionary: Object expression vs Object declaration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林程序员词典:对象表达式与对象声明</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b?source=collection_archive---------4-----------------------#2017-11-16">https://blog.kotlin-academy.com/kotlin-programmer-dictionary-object-expression-vs-object-declaration-791b183ad16b?source=collection_archive---------4-----------------------#2017-11-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/cdd2bb58e698a2a615b88a681c24c179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*rTTsERCDnruDeuuE.jpg"/></div></figure><p id="95a3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在<a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">的前一部分</a>中，我们已经描述了什么是<a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">对象</a>。问题是Kotlin引入了一个<code class="fe kq kr ks kt b">object</code>作为关键字。这在编程社区中引起了一些混乱。因此，我经常听到程序员错误地使用<strong class="jt io">对象</strong>术语来描述另外两种结构:</p><ul class=""><li id="a540" class="ku kv in jt b ju jv jy jz kc kw kg kx kk ky ko kz la lb lc bi translated"><strong class="jt io">对象声明</strong></li><li id="0a94" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><strong class="jt io">对象表达式</strong></li></ul><p id="7223" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们分别描述一下。</p><h1 id="b46b" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">对象声明</h1><p id="ede2" class="pw-post-body-paragraph jr js in jt b ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ig bi translated">下面是一个<strong class="jt io">对象声明</strong>的例子:</p><pre class="ml mm mn mo gt mp kt mq mr aw ms bi"><span id="3e7d" class="mt lj in kt b gy mu mv l mw mx">object HttpService {<br/>    val api = retrofit.create(Api::class.java)</span><span id="21d5" class="mt lj in kt b gy my mv l mw mx">    fun post(url: String) = api.post(url)<br/>}</span></pre><p id="61f7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">对象声明</strong>是<a class="ae kp" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">单例模式</a>的实现。在关键字<code class="fe kq kr ks kt b">object</code>之后，我们实际上定义了类的成员。这个类只能有一个实例，这就是为什么我们使用这个<strong class="jt io">对象声明</strong>的名称来引用它:</p><pre class="ml mm mn mo gt mp kt mq mr aw ms bi"><span id="9369" class="mt lj in kt b gy mu mv l mw mx">HttpService.post("wwww.myurl.com/event")</span><span id="8d8d" class="mt lj in kt b gy my mv l mw mx">val service: HttpService = HttpService<br/>service.post("wwww.myurl.com/event")</span></pre><p id="682d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">尽管名称相同，<strong class="jt io">对象声明</strong>和由该对象声明创建的对象并不是一回事。他们不应该混淆。关于<strong class="jt io">对象声明</strong>的更多信息可以在<a class="ae kp" href="https://kotlinlang.org/docs/reference/object-declarations.html#object-declarations" rel="noopener ugc nofollow" target="_blank"> Kotlin参考</a>中找到。</p><h2 id="c5b0" class="mt lj in bd lk mz na dn lo nb nc dp ls kc nd ne lw kg nf ng ma kk nh ni me nj bi translated"><strong class="ak">伴侣对象</strong></h2><p id="b936" class="pw-post-body-paragraph jr js in jt b ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ig bi translated">同伴对象是<strong class="jt io">对象声明</strong>的兄弟。它的工作原理是一样的，但是它从类中取名字:</p><pre class="ml mm mn mo gt mp kt mq mr aw ms bi"><span id="5250" class="mt lj in kt b gy mu mv l mw mx">class Connection {<br/>    private constructor() {}<br/> <br/>    companion object {<br/>        fun create() = Connection()<br/>    }<br/>}</span><span id="1458" class="mt lj in kt b gy my mv l mw mx">val connection = Connection.create()</span></pre><p id="b7ce" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">它的使用方式通常与Java中静态字段和属性的使用方式相同，但是尽管它是类的一个实例，但它提供了更多的可能性。我希望在另一篇文章中描述它们。</p><h2 id="3538" class="mt lj in bd lk mz na dn lo nb nc dp ls kc nd ne lw kg nf ng ma kk nh ni me nj bi translated">对象表达式</h2><p id="78d4" class="pw-post-body-paragraph jr js in jt b ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ig bi translated"><strong class="jt io">对象表达式</strong>是创建<strong class="jt io">对象</strong>的单个实例的结构:</p><pre class="ml mm mn mo gt mp kt mq mr aw ms bi"><span id="f81e" class="mt lj in kt b gy mu mv l mw mx">val coords = object {<br/>    var x = 10<br/>    var y = 10<br/>}</span></pre><p id="aa59" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">注意，它也生成类型，而我们可以使用这个<strong class="jt io">对象表达式</strong>中定义的成员:</p><pre class="ml mm mn mo gt mp kt mq mr aw ms bi"><span id="6b69" class="mt lj in kt b gy mu mv l mw mx">println(coords.x) // Prints: 10</span></pre><p id="c036" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">它通常被用作Java匿名类的替代品:</p><pre class="ml mm mn mo gt mp kt mq mr aw ms bi"><span id="85e3" class="mt lj in kt b gy mu mv l mw mx">window.addMouseListener(object : MouseAdapter() {<br/>    override fun mouseClicked(e: MouseEvent) {<br/>        // ...<br/>    }<br/><br/>    override fun mouseEntered(e: MouseEvent) {<br/>        // ...<br/>    }<br/>})</span></pre><p id="3f67" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">关于对象表达式的更多信息可以在<a class="ae kp" href="https://kotlinlang.org/docs/reference/object-declarations.html#object-expressions" rel="noopener ugc nofollow" target="_blank"> Kotlin参考文献</a>中找到。</p><h2 id="5d95" class="mt lj in bd lk mz na dn lo nb nc dp ls kc nd ne lw kg nf ng ma kk nh ni me nj bi translated">结论</h2><p id="7b90" class="pw-post-body-paragraph jr js in jt b ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ig bi translated"><strong class="jt io">对象声明</strong>和<strong class="jt io">对象表达式</strong>都创建了一个单独的对象(虽然<strong class="jt io">对象声明</strong>创建<strong class="jt io"> </strong>它很懒散)，但它们不仅仅是对象。它们还指定对象实现并生成类型。这就是为什么它们不应该仅仅作为一个对象被提及。</p><p id="a45a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">下面是一些我们如何在句子中使用这些术语的例子:</p><ul class=""><li id="e933" class="ku kv in jt b ju jv jy jz kc kw kg kx kk ky ko kz la lb lc bi translated">我看到您在<code class="fe kq kr ks kt b">HttpProvider</code>对象声明中有一个对象</li><li id="a8d6" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated">您可以使用由对象表达式创建的对象来…</li></ul></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><p id="8eec" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这个帖子是<a class="ae kp" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-2cb67fff1fe2" rel="noopener">科特林程序员词典</a>的第六部分。要了解最新的新部件，只需关注此媒体或<a class="ae kp" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank">在Twitter上观察我</a>。如果你需要帮助，记得<a class="ae kp" href="https://medium.com/@marcinmoskala/ive-just-opened-up-for-online-consultations-640349aaba55" rel="noopener">我愿意接受咨询</a>。</p><p id="43b9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">喜欢的话记得<strong class="jt io">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><a href="http://eepurl.com/diMmGv"><div class="gh gi nr"><img src="../Images/5ce68714efe3efc036e06786166954ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDqv_d5NZnPUJA0FeZqhqQ.png"/></div></a></figure><p id="8d02" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">以下是《科特林程序员词典》的其他部分:</p><ul class=""><li id="f8a1" class="ku kv in jt b ju jv jy jz kc kw kg kx kk ky ko kz la lb lc bi translated"><a class="ae kp" href="https://medium.com/kotlin-academy/programmer-dictionary-parameter-vs-argument-type-parameter-vs-type-argument-b965d2cc6929" rel="noopener">形参对实参，类型形参对类型实参</a></li><li id="1953" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0" rel="noopener">语句vs表情</a></li><li id="2a4f" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" href="https://medium.com/kotlin-academy/kotlin-programmer-dictionary-function-vs-method-vs-procedure-c0216642ee87" rel="noopener">功能vs方法vs程序</a></li><li id="d41a" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-field-vs-property-30ab7ef70531">属性对字段</a></li><li id="84df" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-class-vs-type-vs-object-e6d1f74d1e2e">类vs类型vs对象</a></li><li id="4a41" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-b085b1620890">接收器</a></li><li id="9f08" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-implicit-receiver-vs-explicit-receiver-da638de31f3c">隐式接收者vs显式接收者</a></li><li id="17ba" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-extension-receiver-vs-dispatch-receiver-cd154e57e277">分机接收机vs调度接收机</a></li><li id="a7ee" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-receiver-type-vs-receiver-object-575d2705ddd9">接收器类型对比接收器对象</a></li><li id="05b0" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/kotlin-programmer-dictionary-function-type-vs-function-literal-vs-lambda-expression-vs-anonymous-edc97e8873e">函数类型对比函数文字对比λ表达式对比匿名函数</a></li><li id="0bec" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-higher-order-function-9cadb07df94e">高阶函数</a></li><li id="9335" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-function-literal-with-receiver-vs-function-type-with-receiver-cc21dba0f4ff">带接收器的功能文字与带接收器的功能类型</a></li><li id="bfcb" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/kotlin-generics-variance-modifiers-36b82c7caa39">不变性对协方差对对比方差</a></li><li id="3d5c" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-event-listener-vs-event-handler-305c667d0e3c">事件侦听器与事件处理程序</a></li><li id="6c5e" class="ku kv in jt b ju ld jy le kc lf kg lg kk lh ko kz la lb lc bi translated"><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/programmer-dictionary-delegation-vs-composition-3025d9e8ae3d">授权vs .组成</a></li></ul><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ns"><img src="../Images/f36a792ac0eb95fc577e6f4125dba956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zo_H5DsF3fI8ucapgZHWWw.gif"/></div></div></figure></div></div>    
</body>
</html>