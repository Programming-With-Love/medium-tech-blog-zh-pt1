<html>
<head>
<title>Exploring Android P: Priority Buckets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Android P:优先级桶</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/exploring-android-p-priority-buckets-d34d12059d36?source=collection_archive---------2-----------------------#2018-06-18">https://medium.com/google-developer-experts/exploring-android-p-priority-buckets-d34d12059d36?source=collection_archive---------2-----------------------#2018-06-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/df8d7e3b070a4b91ccd93d14aa71e9b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZgLsJkQVSlO5tHWUnV7KQ.png"/></div></div></figure><p id="4648" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Google I/O上，围绕最新版本的Android p发布了许多新公告。其中一个公告是优先级桶，这是Android的一个电池管理更新，系统将根据有问题的应用程序最近的使用频率和使用频率来区分资源的优先级。在本文中，我们将快速探究这些桶是什么，以及它们将如何在这些情况下影响我们的应用程序的行为。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="e309" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些新的优先级桶旨在允许系统更智能地在应用程序之间分配资源——如果有一个你很少使用的应用程序试图在你使用你经常使用的密集型应用程序的过程中做一些后台工作，为什么你会希望后台服务能够启动并对你当前正在做的事情造成干扰？另一方面，如果能够屏蔽来自一个你很少使用也没有真正关心的应用程序的所谓高优先级消息，同时仍然能够接收你经常使用的应用程序的消息，那就太好了。出于这些目的以及更多目的，我们现在有了优先级存储桶的概念，它将我们的应用程序分组到五个不同的存储桶中的一个，每个存储桶都有系统强加的不同操作规则。应用程序将属于以下五个类别之一:</p><ul class=""><li id="714c" class="ju jv hh ir b is it iw ix ja jw je jx ji jy jm jz ka kb kc bi translated"><strong class="ir hi">活动</strong> —用户当前正在使用的应用程序。这将是在前台的东西，有一些系统级的进程运行或以某种方式进行交互。<strong class="ir hi">注意:</strong>如果一个应用没有启动器活动，那么它可能永远不会被放入这个桶中。</li><li id="5600" class="ju jv hh ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir hi">工作集</strong> —一个当前没有使用但经常运行的应用程序，可能大多数时间都在运行。例如，即使时间很短，你也可能一天打开几次Twitter应用。</li><li id="5fc5" class="ju jv hh ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir hi">频繁</strong> —当前不使用但有时一周都打开的应用程序。例如，如果你一周跑步3次，那么你用来追踪跑步的应用程序就属于这种情况。</li><li id="36ec" class="ju jv hh ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir hi">稀有</strong> —设备上很少使用的应用。比如你可能只有去度假的时候才会用到的搭车共享app。</li><li id="dae3" class="ju jv hh ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir hi">从不</strong> —已经安装但从未启动的应用。</li></ul><figure class="kj kk kl km fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ki"><img src="../Images/149c797f259efc92c07d1d0bb033efc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_0wU_Y49wfVkDeJCQvYE5Q.png"/></div></div></figure><p id="2f1b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，一旦一个应用程序被分配到一个存储桶，并不意味着它将永远呆在那里。这些存储桶是动态的，这意味着系统将根据最近的行为重新分配应用存储桶。例如，如果你的用户从来不经常使用你的应用程序，然后发现一些有价值的东西逐渐增加了他们的使用，那么你的应用程序就会向上移动。如果在设备上可用，那么系统将使用机器学习来确定应用的频率，然后根据这些预测将这些应用放入桶中。否则，应用程序将根据最近的使用情况被分类到桶中。通过<strong class="ir hi">用法</strong>有几样东西可以算作这个，比如:</p><ul class=""><li id="021a" class="ju jv hh ir b is it iw ix ja jw je jx ji jy jm jz ka kb kc bi translated">打开应用程序的用户</li><li id="4001" class="ju jv hh ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated">与通知操作交互的用户。显示随后被取消的通知对应用程序存储桶状态没有任何影响。</li></ul><p id="eb2c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，我们现在知道我们的应用程序将落入这些桶中的一个——但是这对我们到底意味着什么呢？这些桶中的每一个都有它自己的由系统强制执行的单独行为。</p><figure class="kj kk kl km fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kn"><img src="../Images/38979be210c3f3b5748a5cf8100e6e58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yTwFX1jBCS39zwtpv39UyQ.png"/></div></div></figure><p id="a3f9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然这些限制仅在设备使用电池供电时适用，但重要的是要了解这些限制，并优化您的应用，使其仍能在这些情况下正常工作。首先，如果您的应用程序属于<strong class="ir hi">活动</strong>阶段，那么就没有任何限制，所以您不需要担心在这些情况下应用程序的行为会发生变化。</p><p id="58fb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一方面，当您的应用程序进入<strong class="ir hi">工作集</strong>桶时，就会有一些轻微的限制。在这种情况下，任何正在运行的作业最多可延迟2小时，任何正在触发的警报最多可延迟6分钟。接下来，当我们的应用程序移动到<strong class="ir hi">频繁</strong>桶中时，注册的作业可能会延迟8小时，警报可能会延迟30分钟——这与之前的桶相比有了很大的提升。此时，对于高优先级FCM消息也有限制，因为频繁的应用程序一天只能接收10条这样的消息。最后，当我们的应用程序落入<strong class="ir hi">罕见的</strong>桶中时，作业最多可以延迟24小时，警报最多可以延迟2小时。高优先级通知也下降到每天5个的限制，并且现在引入了网络限制，这意味着网络操作最多可以推迟24小时。</p><p id="325a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>重要的是要知道，如果一个应用程序被分割成不同的包，那么这些包可能都属于不同的优先级。不要依赖于包之间会出现相同的行为，因为这是不可能的。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="3041" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您希望检查您的应用程序对于一个用户来说处于哪个桶中，那么您可以使用<a class="ae ko" href="https://developer.android.com/reference/android/app/usage/UsageStatsManager#getAppStandbyBucket()" rel="noopener ugc nofollow" target="_blank">getappstandbybutket()</a>函数来完成。虽然您的应用程序应该以一种在所有情况下都是最佳的方式构建，但是这个函数在时间很重要的情况下会很方便。例如，在某个时间段内，发布到API的某个东西可能是至关重要的——如果某个应用程序在<strong class="ir hi">稀有</strong>桶中，那么为此安排一个作业可能没有意义，因为它可能会被推迟24小时。</p><p id="fc76" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">记住这一点，重要的是不要试图改变应用程序的行为来在包之间移动应用程序。首先，不同的设备制造商可能会改变优先级存储桶的工作方式，因此您永远无法依赖应用程序放置位置的决定因素。其次，您不应该仅仅为了通过优先级桶向上移动而强制提示用户重新获得交互性，例如，试图通过高优先级通知重新获得交互以试图恢复桶状态将是一种糟糕的做法。如果你的通知提供了价值，那很好——但是不要滥用系统来提升级别。此外，您可能会达到您的高优先级配额，并且在当天的剩余时间内无法显示任何进一步的通知。</p></div><div class="ab cl jn jo go jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ha hb hc hd he"><p id="45dd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望这能让你对新的优先级桶以及它们如何操作有所了解。如果你对这个话题有任何问题或意见，请联系我们🙂</p><div class="kp kq ez fb kr ks"><a href="https://twitter.com/hitherejoe" rel="noopener  ugc nofollow" target="_blank"><div class="kt ab dw"><div class="ku ab kv cl cj kw"><h2 class="bd hi fi z dy kx ea eb ky ed ef hg bi translated">乔·伯奇(@hitherejoe) |推特</h2><div class="kz l"><h3 class="bd b fi z dy kx ea eb ky ed ef dx translated">乔伯奇的最新推文(@hitherejoe)。Android Lead &amp;高级工程师@Buffer。谷歌开发专家…</h3></div><div class="la l"><p class="bd b fp z dy kx ea eb ky ed ef dx translated">twitter.com</p></div></div><div class="lb l"><div class="lc l ld le lf lb lg in ks"/></div></div></a></div></div></div>    
</body>
</html>