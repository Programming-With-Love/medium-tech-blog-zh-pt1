<html>
<head>
<title>Advanced FP for the Enterprise Bee: State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向企业Bee的高级FP:状态</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-state-4f8fd2d8098b?source=collection_archive---------1-----------------------#2021-02-19">https://medium.com/google-developer-experts/advanced-fp-for-the-enterprise-bee-state-4f8fd2d8098b?source=collection_archive---------1-----------------------#2021-02-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/0e61264a5b8e3e3507810f3c0387948f.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/0*rMk9skNj5L-1E6cs"/></div><figcaption class="il im et er es in io bd b be z dx">Bees Collaborating to Build Honeycomb</figcaption></figure><h1 id="7d06" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="3d63" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">欢迎阅读我们的八部分系列的倒数第二篇文章，为有实践意识的企业开发人员研究高级函数式编程。本文将对上一篇文章中的用例<a class="ae kl" rel="noopener" href="/google-developer-experts/advanced-fp-for-the-enterprise-bee-optics-2ccc444d409b">进行扩展，在上一篇文章中，我们开发了一组不可变类型来配置</a><a class="ae kl" href="https://www.jetbrains.com/space/" rel="noopener ugc nofollow" target="_blank"> JetBrains空间</a>的一个实例。这一次，我们正在探索单子的世界，特别是<em class="km">态</em>类型。一如既往，样本代码在本报告中可用<a class="ae kl" href="https://bitbucket.org/instilco/advanced-fp-gde/src/master/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="db4a" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">“M”的房子</h1><p id="73d9" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">就像漫画里的<a class="ae kl" href="https://en.wikipedia.org/wiki/House_of_M" rel="noopener ugc nofollow" target="_blank">一样，M的房子是软件工程里一个吓人的地方。这是一个令人不安的交替现实——有着奇怪名字和神秘能力的外星人似乎已经控制了局面。幸运的是，现实要平庸得多。</a></p><p id="7597" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">为了编写软件，我们需要用代码来表示事物。客户、订单、交付、汽车、牲畜等等。但是，因为编程是一个复杂的职业，我们不能总是直接使用这些类型。相反，我们需要根据预期的复杂情况，将它们包装在各种容器中。</p><p id="67e2" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">这些容器中的一些符合单子的条件。最简单的是<em class="km"> Identity </em>(或<em class="km"> Id </em>)类型，它包装一个值而不添加任何功能。例如，这是格罗古的<a class="ae kl" href="https://en.wikipedia.org/wiki/Monad_(functional_programming)#Identity_monad" rel="noopener ugc nofollow" target="_blank">身份单子</a>:</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es ks"><img src="../Images/6855fa141b2df1eac2ce8808ab869aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*paxt8j1HNottdzxE"/></div></div></figure><p id="b471" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">我们可以用一些真实世界的例子来使单子的概念更加具体。假设我们有一个客户ID，需要从数据库中获取匹配的订单:</p><ul class=""><li id="53ca" class="lb lc hh jp b jq kn ju ko jy ld kc le kg lf kk lg lh li lj bi translated">如果客户可能没有订单，我们使用<em class="km">选项&lt;订单&gt; </em></li><li id="276d" class="lb lc hh jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">如果可能有很多订单我们使用一个集合，比如<em class="km">列表&lt;订单&gt;列表</em></li><li id="ca40" class="lb lc hh jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">为了管理错误，我们可以使用<em class="km">尝试&lt;命令&gt;命令</em>或<em class="km">命令&lt;错误，命令&gt;命令</em></li><li id="2ea9" class="lb lc hh jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">对于某些订单，如果只有总值可用，我们可以使用<em class="km">Double&lt;，Order &gt; </em></li><li id="e0bb" class="lb lc hh jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">如果订单经过一系列检查，其中任何一项都可能失败，我们可以使用一个经过<em class="km">验证的&lt;列表&lt;字符串&gt;，订单&gt; </em></li><li id="5faa" class="lb lc hh jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">为了推迟查询数据库，我们可以将查询代码包装在一个<em class="km"> Eval </em>或<em class="km"> IO中。</em>我们这样做可能是为了批量查询性能。</li></ul><p id="4114" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">这些容器单体的特点是它们是通用的，可以根据一组规则进行组合，并实现某些功能(如<em class="km"> flatMap </em>)。最有用的是，对于工作的开发人员来说，返回单子的函数可以通过统一的过程方便地组合起来。</p><p id="933e" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">为了更好地理解这是如何工作的，我们将把<em class="km">状态单子</em>应用到我们现有的代码库中，以配置JetBrains空间的实例。状态是更抽象和深奥的单子之一，所以如果我们能理解它，那么剩下的应该不会有什么困难。</p><h1 id="c73c" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍状态单子</h1><p id="b65a" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated"><em class="km">状态</em>类型用于以下功能:</p><ul class=""><li id="567c" class="lb lc hh jp b jq kn ju ko jy ld kc le kg lf kk lg lh li lj bi translated">需要一些信息(状态)。</li><li id="6ab9" class="lb lc hh jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">返回状态的修改版本和结果。</li></ul><p id="3568" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">如果S表示状态的类型，R表示结果，那么函数的签名是<em class="km"> S = &gt; (S，R)。通常我们想要组合多个函数，其中每个调用都需要前一个调用返回的状态。</em></p><p id="79c0" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">在上一篇文章的案例研究中，我们使用一些粗略且现成的<code class="du lp lq lr ls b">toString</code>方法生成了输出。让我们用使用<em class="km">状态</em>类型的代码来替换它。我们的函数使用的状态将是一个<code class="du lp lq lr ls b">Instance</code>对象，它在JetBrains空间的一个实例中对项目、配置文件、存储库和博客进行建模。返回值将是一个<code class="du lp lq lr ls b">List&lt;String&gt;</code>，它保存我们想要打印的文本行。</p><p id="1f77" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">下面的代码显示了一个使用<em class="km">状态</em>类型的<code class="du lp lq lr ls b">displayInstance</code>方法。我们正在组合对<code class="du lp lq lr ls b">displayTitle</code>、<code class="du lp lq lr ls b">displayProfiles</code>、<code class="du lp lq lr ls b">displayProjects</code>和<code class="du lp lq lr ls b">displayBlogs</code>的调用。每个人负责处理一个<code class="du lp lq lr ls b">Instance</code>的一个部分。如前所述，它们接受一个<code class="du lp lq lr ls b">Instance</code>并返回一个字符串列表:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="7f14" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated"><code class="du lp lq lr ls b">fx</code>块中的函数组合负责将状态传递给每个函数。所以我们需要做的就是将结果捕捉到局部变量中。在块的末尾，我们将所有的返回值合并并平铺到一个列表中。然后通过<code class="du lp lq lr ls b">foreach</code>和<code class="du lp lq lr ls b">println</code>输出。</p><p id="6c3a" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">注意，我们需要调用<code class="du lp lq lr ls b">runA</code>来触发该块，并将初始状态作为参数传递。此时，我们需要将结果封装在一个<code class="du lp lq lr ls b">Id</code>单子中，并调用<code class="du lp lq lr ls b">fix</code>来执行向下转换。当<em class="km">状态</em>类型成为Arrow的正式部分时，这两者都不需要。</p><p id="8c4f" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">我们可以以通常的方式调用<code class="du lp lq lr ls b">displayInstance</code>，输出是我们空间配置的完整描述:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="lt lu l"/></div></figure><pre class="kt ku kv kw fd lv ls lw lx aw ly bi"><span id="6732" class="lz iq hh ls b fi ma mb l mc md">Kotlin Programming for MegaCorp<br/> Profiles are:<br/>  Pete Smith at <a class="ae kl" href="mailto:Pete.Smith@megacorp.com" rel="noopener ugc nofollow" target="_blank">Pete.Smith@megacorp.com</a><br/>  Jane Jones at <a class="ae kl" href="mailto:Jane.Jones@megacorp.com" rel="noopener ugc nofollow" target="_blank">Jane.Jones@megacorp.com</a><br/> Projects are:<br/>  Project 'Course Exercises' (PROJ202) with repos:<br/>    <a class="ae kl" href="http://elsewhere.com" rel="noopener ugc nofollow" target="_blank">http://elsewhere.com</a><br/>  Project 'Course Examples' (PROJ101) with repos:<br/>    <a class="ae kl" href="http://somewhere.com" rel="noopener ugc nofollow" target="_blank">http://somewhere.com</a><br/> Blogs are:<br/>  Setting Up<br/>   setup.md<br/>   More client-specific content<br/>  Welcome to the Course<br/>   welcome.md<br/>   Some additional client-specific content</span></pre><h1 id="81f8" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">检查显示功能</h1><p id="236e" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">下面是最简单的显示功能:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="22ad" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">正如你所看到的，我们使用了“函数作为值”的风格，其中一个不可变的变量指的是一个Lambda。我们使用<code class="du lp lq lr ls b">State</code>类型来指定输入和输出。这里的输入是<code class="du lp lq lr ls b">Instance</code>，而输出是一个单项列表，通过<code class="du lp lq lr ls b">toT</code>与<code class="du lp lq lr ls b">Instance</code>结合。</p><p id="a80b" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated"><code class="du lp lq lr ls b">displayProfiles</code>功能稍微复杂一些。对于实例中的每个配置文件，我们需要生成一个包含用户名和电子邮件的字符串。这可以通过调用<code class="du lp lq lr ls b">map</code>来实现。我们使用<code class="du lp lq lr ls b">cons</code>光学元件预先计划一个标题字符串，然后通过<code class="du lp lq lr ls b">toT</code>将其与<code class="du lp lq lr ls b">Instance</code>组合。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="17b1" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">最后两个函数具有相同的结构，但是我们需要处理嵌套的内容。在<code class="du lp lq lr ls b">displayProjects</code>的例子中，它是存储库。在<code class="du lp lq lr ls b">displayBlogs</code>的情况下，它是附加内容:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h1 id="a2de" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">使用状态构建实例</h1><p id="2bc8" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">前面的例子展示了使用<em class="km">状态</em>类型，加上一元合成，来输出我们的<code class="du lp lq lr ls b">Instance</code>的描述。然而，我们在任何时候都没有修改状态。</p><p id="125f" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">为了说明这一点，让我们重写我们的<code class="du lp lq lr ls b">createInstance</code>方法来使用state类型:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="1eef" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">状态将再次成为一个<code class="du lp lq lr ls b">Instance</code>对象。但是随着函数调用的进行，我们会逐渐增加它。请记住，这种类型是不可变的，所以每次变异都会返回一个新的实例。</p><p id="e072" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">对于我们的结果类型，我们将使用一个简单的字符串，它描述了已经实现的内容。一旦所有的方法都被调用，我们在调用<code class="du lp lq lr ls b">displayInstance</code>之前组合结果并打印出来:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="lt lu l"/></div></figure><pre class="kt ku kv kw fd lv ls lw lx aw ly bi"><span id="626c" class="lz iq hh ls b fi ma mb l mc md"><strong class="ls hi">Created Projects Created Profiles Created Blogs</strong><br/>Kotlin Programming for MegaCorp<br/> Profiles are:<br/>  Pete Smith at <a class="ae kl" href="mailto:Pete.Smith@megacorp.com" rel="noopener ugc nofollow" target="_blank">Pete.Smith@megacorp.com</a><br/>  Jane Jones at <a class="ae kl" href="mailto:Jane.Jones@megacorp.com" rel="noopener ugc nofollow" target="_blank">Jane.Jones@megacorp.com</a><br/> Projects are:<br/>  Project 'Course Exercises' (PROJ202) with repos:<br/>    <a class="ae kl" href="http://elsewhere.com" rel="noopener ugc nofollow" target="_blank">http://elsewhere.com</a><br/>  Project 'Course Examples' (PROJ101) with repos:<br/>    <a class="ae kl" href="http://somewhere.com" rel="noopener ugc nofollow" target="_blank">http://somewhere.com</a><br/> Blogs are:<br/>  Setting Up<br/>   setup.md<br/>   More client-specific content<br/>  Welcome to the Course<br/>   welcome.md<br/>   Some additional client-specific content</span></pre><p id="1717" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">下面是<code class="du lp lq lr ls b">copyProfiles</code>的声明。请注意，这是一个高阶函数。我们传入<code class="du lp lq lr ls b">DslInstance</code>并返回一个生成的函数，该函数接受一个<code class="du lp lq lr ls b">Instance</code>并返回一个<code class="du lp lq lr ls b">State&lt;Instance, String&gt;</code>。使用<code class="du lp lq lr ls b">toT</code>助手方法来组合修改后的<code class="du lp lq lr ls b">Instance</code>和<code class="du lp lq lr ls b">String</code>报告。新的<code class="du lp lq lr ls b">Instance</code>将被传递给下一个函数，而结果存储在<code class="du lp lq lr ls b">log1</code>局部变量中。</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="lt lu l"/></div></figure><p id="c03b" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated"><code class="du lp lq lr ls b">copyProjects</code>和<code class="du lp lq lr ls b">copyBlogs</code>方法类似，但更复杂，因为它们需要创建嵌套内容:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="lt lu l"/></div></figure><h1 id="1d8d" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论</h1><p id="863a" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在这一系列文章中，我们一直在使用单子，但没有特别提到它。Monad是包装一个或多个值以提供额外功能的容器。像<code class="du lp lq lr ls b">Either</code>、<code class="du lp lq lr ls b">Validated</code>和<code class="du lp lq lr ls b">State</code>这样的一元类型是由Arrow (Kotlin)和Cats (Scala)这样的函数库提供的。虽然每个单子都是容器，但不是每个容器都是单子。例如，未来不是一元的，因为它是不确定的。</p><p id="da02" class="pw-post-body-paragraph jn jo hh jp b jq kn js jt ju ko jw jx jy kp ka kb kc kq ke kf kg kr ki kj kk ha bi translated">单子最巧妙的一点是能够链接函数调用，并为您处理组合的机制。在<code class="du lp lq lr ls b">State</code>类型的情况下，每个调用返回一对结果和状态的新版本。我们希望将状态传递给下一个调用，并存储结果以备后用。在链的末端，我们可以传递结果和/或最终状态。</p><h1 id="7ad2" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">谢谢</h1><p id="defb" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">继续感谢<a class="ae kl" href="https://twitter.com/rickityg" rel="noopener ugc nofollow" target="_blank"> Richard Gibson </a>和<a class="ae kl" href="https://instil.co/training/team/" rel="noopener ugc nofollow" target="_blank"> Instil培训团队</a>对这一系列文章的评论、评论和鼓励。</p></div></div>    
</body>
</html>