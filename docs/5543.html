<html>
<head>
<title>Dockerized app with Java module system, Helidon, and Alpine based JDK 12 EA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Java模块系统、Helidon和Alpine的JDK 12 EA的Dockerized应用程序</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/dockerized-app-with-java-module-system-helidon-and-alpine-based-jdk-12-ea-53d9f240f58a?source=collection_archive---------0-----------------------#2018-12-26">https://medium.com/oracledevs/dockerized-app-with-java-module-system-helidon-and-alpine-based-jdk-12-ea-53d9f240f58a?source=collection_archive---------0-----------------------#2018-12-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7b7df9720a96e84a2b5904b3a96779cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*odsso3Aef7yXgBEt"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/@frankiefoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">frank mckenna</a> on <a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a2ff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如你所知，JDK 9引入了一个<em class="js">原生</em>模块系统来设计和构建应用程序，这些应用程序由一系列独立的模块组成，这些模块通过定义良好的公共接口相互通信。使用Java模块系统的一些优点是:</p><ul class=""><li id="082c" class="jt ju hh iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">由于实现细节是隐藏的，因此增强了可维护性</li><li id="dd62" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">可靠的配置，允许模块声明它们的依赖关系，并解决传统类路径机制的一些问题</li><li id="b6c0" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">能够构建特定于应用的定制运行时<a class="ae it" href="https://docs.oracle.com/en/java/javase/11/tools/jlink.html" rel="noopener ugc nofollow" target="_blank">映像</a></li><li id="5201" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">通过更快的启动时间和更少的内存占用，提高了平台的完整性和性能</li><li id="d718" class="jt ju hh iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">由于强大的封装和减少平台和应用程序攻击面的潜力，间接提高了安全性</li></ul><p id="830b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在容器集成和支持方面，JDK版本10和11对JVM进行了改进，以确保JVM遵守容器上设置的内存和CPU限制。不仅如此，JDK 12早期版本<a class="ae it" href="https://jdk.java.net/12/" rel="noopener ugc nofollow" target="_blank">现在包括了一个基于Alpine Linux的二进制文件，它使用了</a><a class="ae it" href="http://www.musl-libc.org/" rel="noopener ugc nofollow" target="_blank"> musl </a> C库。使用基于Alpine Linux的二进制文件的最大优点是，现在可以构建更小的docker映像来运行Java应用程序。更小的图像大小反过来意味着我们可以获得更快的下载、更快的启动和减少安全漏洞的攻击面等好处。</p><p id="f335" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们构建一个示例应用程序来看看JDK提供的这些强大功能。该应用程序是一个简单的静态图像服务器，使用<a class="ae it" href="https://helidon.io" rel="noopener ugc nofollow" target="_blank"> Helidon </a>构建，并作为docker容器部署。我们将使用<a class="ae it" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>作为构建工具。</p><p id="75f9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们首先定义一个gradle构建脚本来设置Java模块系统和我们的应用程序的依赖项:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="aa74" class="kq kr hh km b fi ks kt l ku kv">plugins {<br/>    id "java-library"<br/>    id "com.zyxist.chainsaw" version "0.3.1"<br/>}</span><span id="ef8e" class="kq kr hh km b fi kw kt l ku kv">repositories {<br/>    mavenCentral()<br/>}</span><span id="cd49" class="kq kr hh km b fi kw kt l ku kv">sourceCompatibility = "11"</span><span id="a4a1" class="kq kr hh km b fi kw kt l ku kv">dependencies {<br/>    compile "io.helidon.webserver:helidon-webserver:0.10.5"<br/>    compile "io.helidon.webserver:helidon-webserver-netty:0.10.5"<br/>}</span></pre><p id="bb52" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于我们使用本地Java模块系统，我们将创建一个“module-info”类来定义我们的模块:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f2d8" class="kq kr hh km b fi ks kt l ku kv">module example.imageserver {<br/>    exports example.imageserver;<br/><br/>    requires java.logging;<br/>    requires io.helidon.webserver;<br/>}</span></pre><p id="b75e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们使用Helidon的内置静态内容处理程序创建一个静态图像服务器:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="e27d" class="kq kr hh km b fi ks kt l ku kv">var contentSupport = StaticContentSupport<br/>        .<em class="js">create</em>(Paths.<em class="js">get</em>("/app/images"));<br/><br/>var routing = Routing.<em class="js">builder</em>()<br/>        .register("/images", contentSupport)<br/>        .build();<br/><br/>var config = ServerConfiguration.<em class="js">builder</em>()<br/>        .port(8080)<br/>        .build();<br/><br/>WebServer.<em class="js">create</em>(config, routing).start();</span></pre><p id="6895" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">没错，就是用Java写的代码:-)。这就是创建一个静态web服务器的全部工作。现在让我们把注意力转向建立码头工人形象。我们将利用palantir gradle <a class="ae it" href="https://github.com/palantir/gradle-docker" rel="noopener ugc nofollow" target="_blank">插件</a>并配置它来构建我们的docker映像。以下是相关的gradle构建文件片段:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="b3c8" class="kq kr hh km b fi ks kt l ku kv">plugins {<br/>    ...<br/>    id 'com.palantir.docker' version "0.20.1"<br/>}</span><span id="a70f" class="kq kr hh km b fi kw kt l ku kv">...</span><span id="0e99" class="kq kr hh km b fi kw kt l ku kv">docker {<br/>    name "image-server:${version}"<br/>    files configurations.compileClasspath, "${jar.archivePath}"<br/>    copySpec.into("app")<br/>}</span></pre><p id="10cb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们定义“Dockerfile ”,它使用多阶段构建过程为我们的应用程序创建docker映像:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="adbc" class="kq kr hh km b fi ks kt l ku kv"><strong class="km hi">FROM </strong>alpine:latest as <em class="js">build<br/><br/></em># Check the JDK 12 EA downloads link to get the latest version<br/><strong class="km hi">RUN </strong>mkdir <strong class="km hi">-</strong>p <strong class="km hi">/</strong>opt<strong class="km hi">/</strong>jdk \<br/>    <strong class="km hi">&amp;&amp; </strong>wget <strong class="km hi">-</strong>q "https://download.java.net/java/early_access/alpine/20/binaries/openjdk-12-ea+20_linux-x64-musl_bin.tar.gz" \<br/>    <strong class="km hi">&amp;&amp; </strong>tar <strong class="km hi">-</strong>xzf "openjdk-12-ea+20_linux-x64-musl_bin.tar.gz" <strong class="km hi">-</strong>C <strong class="km hi">/</strong>opt<strong class="km hi">/</strong>jdk<br/><br/><strong class="km hi">RUN </strong>["/opt/jdk/jdk-12/bin/jlink", \<br/>     "--compress=2", \<br/>     "--strip-debug", \<br/>     "--no-header-files", \<br/>     "--no-man-pages", \<br/>     "--module-path", "/opt/jdk/jdk-12/jmods", \<br/>     "--add-modules", "java.base,java.logging,jdk.unsupported", \<br/>     "--output", "/custom-jre"]<br/><br/><strong class="km hi">FROM </strong>alpine:latest<br/><strong class="km hi">COPY --</strong>from=<em class="js">build </em><strong class="km hi">/</strong>custom-jre <strong class="km hi">/</strong>opt<strong class="km hi">/</strong>jdk<strong class="km hi">/<br/>ADD </strong>app <strong class="km hi">/</strong>app<br/><br/><strong class="km hi">CMD </strong>["/opt/jdk/bin/java", \<br/>     "--upgrade-module-path", "/app", \<br/>     "-m", "examples.imageserver/examples.imageserver.Server"]</span></pre><p id="2ea1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意我们如何使用docker构建过程的第一阶段来下载基于Alpine Linux的JDK，并使用jlink创建一个定制的JRE。对于自定义JRE，除了添加“java.base”模块和“java.logging”模块，我们还添加了“jdk.unsupported”模块，以允许netty(支持Helidon)访问内部jdk类。</p><p id="69fc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">docker构建的第二阶段将以Alpine Linux作为基础映像开始(大约4.5 MB)。然后，我们添加在第一阶段构建的定制JRE以及我们的应用程序模块。最后一步是添加运行应用程序的命令。有了这些文件和配置，是时候构建我们的应用程序并将其打包为docker映像了。让我们请格雷尔为我们做这件事:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="1c8b" class="kq kr hh km b fi ks kt l ku kv">gradlew clean build docker</span></pre><p id="cb69" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上面的命令将构建一个docker映像，它只包含我们的定制JRE以及应用程序jar。如果你现在运行“docker images ”,你会发现我们的docker images只有58.6 MB大小。这不是很好吗？我们现在可以将应用程序作为docker容器运行:</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4c55" class="kq kr hh km b fi ks kt l ku kv">docker run -d -p 8080:8080 imageserver</span></pre><p id="a338" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用浏览器，导航到<a class="ae it" href="http://localhost:8080/images/container-3.jpg" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/images</a>，查看我们的dockerized应用程序的运行情况。</p><p id="0c1d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以前往<a class="ae it" href="https://github.com/udaychandra/image-server" rel="noopener ugc nofollow" target="_blank"> Github </a>来克隆和使用示例项目。</p></div></div>    
</body>
</html>