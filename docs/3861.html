<html>
<head>
<title>Property Wrappers in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的属性包装器</h1>
<blockquote>原文：<a href="https://medium.com/globant/property-wrappers-in-swift-85d2b2cc8b2?source=collection_archive---------0-----------------------#2022-04-15">https://medium.com/globant/property-wrappers-in-swift-85d2b2cc8b2?source=collection_archive---------0-----------------------#2022-04-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="f300" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Swift 5.1 中引入了属性包装器，以消除样板代码，促进代码重用，并支持更具表现力的API。</p><h2 id="89d5" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">为什么我们需要属性包装器？</h2><p id="f36c" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">属性包装在管理属性存储方式的代码和定义属性的代码之间添加了一层隔离。</p><p id="2ea8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，如果您有提供线程安全检查的属性，或者将它们的底层数据存储在数据库中，那么您必须在每个属性上编写代码。</p><p id="7f7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用属性包装时，只需在定义包装时编写一次管理代码，然后通过将该管理代码应用于多个属性来重用它。</p><p id="a798" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用属性包装器是一种选择。但是一旦你意识到属性包装器及其好处，你就会理解它对Swift语言的补充。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/f70433b2d8afa5877f87d83749032057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bLgILueYgCi70_Xmx4EgA.jpeg"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx">PC: @<a class="ae jc" href="https://unsplash.com/photos/qAriosuB-lY" rel="noopener ugc nofollow" target="_blank">zlucerophoto</a></figcaption></figure><blockquote class="kt"><p id="eba9" class="ku kv hh bd kw kx ky kz la lb lc jb dx translated">这是对Swift库的一个很好的补充，它允许删除许多样板代码，这些代码我们可能都在项目中写过。</p></blockquote><h2 id="3344" class="jd je hh bd jf jg ld ji jj jk le jm jn ip lf jp jq it lg js jt ix lh jv jw jx bi translated">什么是属性包装？</h2><p id="7923" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">若要定义属性包装，请创建一个定义wrappedValue属性的结构、枚举或类。</p><p id="8693" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Swift中的属性包装器允许您在不同的包装器对象中提取公共逻辑。</p><p id="1081" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以将属性包装器视为一个额外的层，它定义了如何在读取时存储或计算属性。</p><p id="26d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">受<strong class="ig hi">科特林的委托属性</strong>的启发，属性包装器最初被命名为<strong class="ig hi">属性委托</strong>。</p><h2 id="0c9a" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">剖析属性包装器</h2><p id="b6ae" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">要定义属性包装器，可以使用注释<strong class="ig hi"> @propertyWrapper </strong></p><p id="d7bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">属性包装器就像Swift中的任何其他结构一样，用名为<strong class="ig hi"> wrappedValue </strong>的<strong class="ig hi"> @propertyWrapper </strong>属性&amp;进行注释。</p><p id="2eaf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> wrappedValue </strong>获取和设置块是您可以截取和执行所需操作的地方。</p><p id="1bf1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了使用属性包装器，我们将为变量加上前缀<strong class="ig hi"> @ &lt;属性包装器名称&gt; </strong></p><h2 id="4824" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">属性包装器内部是如何工作的？</h2><p id="e9ab" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">每次编译器遇到属性包装时，它都会生成代码，为属性包装提供存储并通过属性包装访问属性。</p><p id="e035" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结构、枚举或类定义属性，但为属性提供存储的是属性包装。顾名思义，属性由属性包装器包装。</p><h2 id="9fd3" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">访问包装的值</h2><p id="918b" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">让我们看看一些代码👀</p><p id="2fb0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将实现一个Base64Encoding属性包装器，它将接受一个作为字符串的正常值，当我们读取该值时，它将总是返回一个Base64编码的字符串。</p><p id="3640" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们了解一下<em class="li"> </em> <code class="du lj lk ll lm b">Base64Encoding</code>属性包装器的实现。我们有一个String类型的私有变量属性&amp;和一个getter &amp; setter的<em class="li">包装值</em>。</p><p id="2885" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">getter通过将值编码为base64EncodingString()来返回存储在<code class="du lj lk ll lm b">value</code>属性中的值。setter将新值赋给<code class="du lj lk ll lm b">value</code>属性。<code class="du lj lk ll lm b">wrappedValue</code>计算属性充当私有<code class="du lj lk ll lm b">value</code>属性的代理。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="0d5d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要使用Base64Encoding属性包装器，我们只需要用<code class="du lj lk ll lm b">@Base64Encoding</code>属性注释文本属性。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="0d60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">瞧啊。完成了。💃🏻</p><p id="cb00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，每当我们从有效负载中访问文本时，它总是会返回一个base64编码的字符串。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ln lo l"/></div></figure><h2 id="a35e" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">从属性包装中投影值</h2><p id="18b0" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">属性包装可以通过定义投影值来公开附加功能。</p><p id="ae7d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">预计值的名称与包装值相同，只是它以美元符号($)开头。</p><p id="8a5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们用一个例子来形象地说明这一点:</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="c545" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的OddOrEven示例中，代码将一个<em class="li"> projectedValue </em>属性添加到<em class="li"> OddOrEven </em>结构中，以跟踪数字是偶数还是奇数。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="7bc8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="li">数字结构。$someNumber </em>访问包装器的预计值。</p><p id="fd6f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="li"> numberStruct的值。$someNumber </em>为真，因为存储的数字是6，它是偶数&amp;，打印的消息是“<em class="li">数字是偶数</em>”。但是，由于存储的数字是<em class="li"> 7 </em>，即<em class="li">奇数</em> &amp;，打印的信息是“<em class="li">数字是奇数</em>”。</p><p id="4d3e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">属性包装器可以返回任何类型的值作为它的投影值。这里，projectedValue是Bool数据类型。</p><h2 id="979a" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">对属性包装本身的访问</h2><p id="944e" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">要访问属性包装器类型本身，您需要向属性添加一个<em class="li">下划线</em> ( _)。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="1b12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，我们添加了额外的功能来检查小于10的数字。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="24fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，_someNumber提供了对OddOrEven包装器的访问，因此我们可以调用checkLessThanTen()方法。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="e5c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，从外部调用包装器会产生编译错误。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="ae19" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，使用projectedValue可以公开<em class="li"> checkLessThanTen </em>方法。<br/>通过向属性添加语法糖美元符号($)，可以公开包装器的实例。</p><p id="0761" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">包装器可以返回<em class="li"> self </em>来公开包装器的实例作为其投影值。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="4ded" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">OddOrEven类型的projectedValue正在返回self以公开<em class="li"> OddOrEven </em>包装器的实例。</p><figure class="ke kf kg kh fd ki"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="b4b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，可以从外部调用包装器&amp; checkLessThanTen方法调用成功。</p><h2 id="ab52" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">结论</h2><p id="86a9" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">简单地说，当我们需要约束属性值以应用某些逻辑或功能时，我们可以使用属性包装器。<br/>属性包装器可以应用于局部存储变量，但不能应用于全局变量或计算变量。</p><p id="f584" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">属性包装器对于减少代码重复、提高可读性以及创建便于代码重用的表达性API非常有用。</p><h2 id="9ae2" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">参考资料:</h2><p id="d308" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated"><a class="ae jc" href="https://docs.swift.org/swift-book/LanguageGuide/Properties.html" rel="noopener ugc nofollow" target="_blank">https://docs . swift . org/swift-book/language guide/properties . html</a></p></div></div>    
</body>
</html>