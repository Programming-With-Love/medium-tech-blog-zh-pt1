<html>
<head>
<title>How we switched our template rendering engine to React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何切换我们的模板渲染引擎作出反应</h1>
<blockquote>原文：<a href="https://medium.com/pinterest-engineering/how-we-switched-our-template-rendering-engine-to-react-a799a3d540b0?source=collection_archive---------0-----------------------#2016-11-18">https://medium.com/pinterest-engineering/how-we-switched-our-template-rendering-engine-to-react-a799a3d540b0?source=collection_archive---------0-----------------------#2016-11-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="401e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Jessica Chan | Pinterest工程师，核心体验</p><p id="4575" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2015年，我们决定迁移我们的传统web体验，以跟上我们的快速增长，并随着开发人员速度的提高而表现得更好。最终，我们发现React比我们以前的模板引擎渲染得更快，在迭代特性方面障碍更少，并且拥有一个大型开发人员社区。在前一篇文章的基础上，我们将更深入地迁移web基础设施来服务React页面，这需要在不破坏网站的情况下移动大量的代码。</p><h2 id="f302" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">做出反应的路线图</h2><p id="09f8" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">当我们开始这个项目时，Pinterest.com已经在现有的架构上忙碌了一段时间。在服务器上，<a class="ae jc" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>，一个Python web应用框架，服务于我们的web请求，<a class="ae jc" href="http://jinja.pocoo.org/" rel="noopener ugc nofollow" target="_blank"> Jinja </a>正在渲染我们的模板。服务器对浏览器的响应包括浏览器获取JavaScript、图像和CSS以及初始化客户端应用程序所需的所有标记、资产和数据。Nunjucks ，一个JavaScript模板渲染引擎，使用与Jinja相同的模板语法，在客户端完成所有后续的模板渲染。</p><p id="14fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">模板语法和堆栈如下所示:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kd"><img src="../Images/9ada3394d0ae0e34e7056b004c69c58c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xlZDAN6zVmnZm7Px.png"/></div></div></figure><p id="b59e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种架构是可行的，因为Jinja和Nunjucks之间的模板语法(几乎)是相同的。然而，必须复制模板渲染工具和库，如上所示，这意味着对于我们需要添加的每个Jinja Python工具，我们必须为Nunjucks编写JavaScript版本。这很麻烦，导致了很多错误，也是另一个让我们转向使用相同的语言和引擎在客户端和服务器端进行模板渲染的原因。</p><p id="4c98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下图显示了我们在React中整合模板渲染的最终目标:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kp"><img src="../Images/820d03e2e3ef9b13abce61e4dcfc2495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tymT9xoP1l8QVxHn.png"/></div></div></figure><p id="1794" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">看起来很不错:我们可以在客户机和服务器之间共享实用程序和库，并且我们有一个引擎React，在两者上呈现模板。但是我们如何到达那里呢？如果我们将客户端渲染引擎从Nunjucks切换到React，我们还必须切换服务器端渲染，这样它们就可以共享相同的模板语法。停止开发以便我们可以切换我们所有的模板来反应不是一个选项。</p><p id="c8b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要一个解决方案，允许我们迭代转换数百个Pinterest组件，而不中断产品团队的工作或Pinners的体验。该解决方案如下所示:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kq"><img src="../Images/b916c0d2736b05ad4e8bfd4763733d88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PbqT8SsWIosb2WIH.png"/></div></div></figure><p id="6a1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一步是在客户端和服务器之间整合到一个单一的模板渲染引擎，然后我们可以用其他东西来替换这个引擎。如果服务器可以解释JavaScript，使用Nunjucks来呈现模板并共享我们的客户端代码，我们就可以通过迭代迁移来做出反应。</p><h2 id="55cc" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">服务器端Nunjucks架构</h2><p id="c2d9" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">当我们第一次考虑如何在服务器端解释JavaScript时，有两个主要选择:<a class="ae jc" href="https://code.google.com/archive/p/pyv8/" rel="noopener ugc nofollow" target="_blank"> PyV8 </a>和<a class="ae jc" href="https://nodejs.org" rel="noopener ugc nofollow" target="_blank">节点</a>。PyV8的优势是给了我们一个快速原型化的方法，不用太担心建立一个独立的服务，但是它没有得到很好的维护，并且这个包的内存占用很大。</p><p id="26d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Node是一个更自然的选择，尽管建立一个新服务会有开销，而且我们会通过一个网络接口与这个服务进行通信，这个网络接口有它自己的复杂性(在下一节中有更多的描述)。有一个大型社区支持和使用Node，我们可以更好地控制服务的调整和优化。</p><p id="f66a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们继续在Nginx代理层后面建立节点流程，并以这样一种方式设计接口，使得每个网络请求都是无状态呈现。这允许我们将请求外包给流程组，并根据需要扩展流程的数量。</p><p id="2ea9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还重构了我们的客户端渲染JavaScript，以便它可以被客户端和服务器端使用。这导致了一个带有API的同步呈现模块，该模块接受与环境无关的请求，并使用Nunjucks返回最终标记。节点和浏览器都调用这个模块来获取HTML。</p><p id="8669" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在web服务器上，我们缩短了模板渲染的时间，因此它没有调用Jinja，而是发出网络请求，将模板渲染外包给我们的节点工作器。</p><h2 id="83f4" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">之前:Jinja一次渲染整个模块树</h2><p id="8fd2" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">Pinterest模板的结构是树。根模块调用子模块，子模块也有子模块，等等。，渲染过程遍历这些模块以生成最终的HTML，该HTML构成了最终的结果。</p><p id="5c89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个模块可以根据从其父模块接收的数据进行渲染，也可以请求进行网络调用以获取更多数据，从而继续渲染。这些数据请求必然是阻塞的，因为我们在到达节点之前不知道呈现路径。这意味着模块树呈现被下游数据请求阻塞，这些请求可以在任何时候发起。</p><p id="606f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为Python在单个线程上进行所有渲染，所以渲染会阻塞线程，本质上是串行的。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kr"><img src="../Images/5f47634a36c1c72dfceb9710dde0fbe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_rSGkNltzYv4Ypju.gif"/></div></div></figure><p id="5f49" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用户代理发出请求时出现的紫色圆圈表示没有数据的模块呈现请求。调用API来获取数据，填充圆圈并为渲染过程做好准备。渲染具体化子对象，并在到达需要数据的子对象时停止。对API的后续调用满足这些数据请求，呈现继续进行。</p><h2 id="25dc" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">之后:努恩朱克斯在网上请求</h2><p id="86bf" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">和以前一样，用户代理发出一个请求，这个请求导致一个需要数据的潜在模块呈现请求。通过调用API再次获得数据，但是另一个网络调用是对一个位于同一位置的节点进程进行的，以便尽可能地使用它所拥有的数据来呈现模板。</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ks"><img src="../Images/6c4a0639bd76fb99c4ead3fccdaaf2b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OppRJv4UTm2w8iKp.gif"/></div></div></figure><p id="4e5b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，Node发送回一个响应，其中包含已呈现的模板，以及一个“holes”数组，指示工人无法呈现的模块，因为它们仍然需要数据。然后我们的Python webapp通过调用API提供他们需要的数据，每个模块作为完全独立的模块请求<em class="kt">并行</em>发送回Node。重复这一过程，直到整个树被渲染，并且所有请求都无漏洞地返回。</p><h2 id="525c" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">首次展示</h2><p id="a116" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">对新系统的信心是推出该系统的关键。开发人员仍在用Jinja构建，并创建和修改新的Python实用程序，我们必须确保新系统不会给Pinners的页面加载带来延迟。我们还必须构建错误处理、服务监控、警报和操作手册，以扩展新节点流程的维护和故障排除。</p><p id="521d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">确保平稳过渡有许多依赖因素，两个工具对项目的成功至关重要。</p><p id="1c59" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">棉绒和测试。</strong> Jinja和Nunjucks的语法接近相同，但不完全相同。每个模板引擎支持的内容的差异以及Python和Nunjucks中的语言差异迫使我们对工程师可以使用模板做什么保持严格的限制。最终，我们需要确保在服务器上渲染的模板在客户端上的渲染是相同的，并且由Jinja渲染的模板在由Nunjucks渲染时也是相同的。</p><p id="9ad5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Pinterest，我们非常依赖构建时linters，它可以防止开发人员在开发时做一些会破坏网站的事情，这有助于确保所有正在开发的模板只使用Jinja和Nunjucks都支持的功能子集。我们甚至编写了一个特殊的可扩展的Nunjucks扩展，它采用我们编写的自定义规则，以一种<a class="ae jc" href="http://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>风格的方式编写，并在每次构建期间将它们应用于所有的Nunjucks模板。我们还实现了一个名为“render all tests”的特殊的无所不包的单元测试套件，该套件从字面上呈现每一个模板，并确保它们在Jinja和Nunjucks之间以及客户端和节点之间呈现相同。这有助于保护我们的发布免受难以追踪的疯狂错误的影响。</p><p id="cd52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Pinterest实验框架。</strong>我们最初只向员工推出了新架构，然后向很小一部分Pinners推出。我们通过我们的<a class="ae jc" href="https://engineering.pinterest.com/blog/monitoring-ab-experiments-real-time" rel="noopener ugc nofollow" target="_blank">实验仪表板</a>关注跟踪用户活动和表现的指标。在大多数Pinners接触到新系统之前，逐步推出使我们能够跟踪棘手的渲染错误、Python/JavaScript差异和性能问题。</p><p id="cfd3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实验仪表板捕捉到的一个错误示例是一个细微的客户端渲染错误，它只影响特定浏览器上执行特定操作的一小部分用户。跟踪此操作使我们能够缩小bug的范围，并验证它何时得到修复:</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div class="er es ku"><img src="../Images/74dc45e394dad682747dae44a2545b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*xVJCPKci_sSbnDfK.png"/></div></figure><h2 id="a6c5" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">表演</h2><p id="a932" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">服务器端渲染在向Pinners提供Pinterest上的丰富内容方面发挥着重要作用。我们依靠高性能的服务器响应时间来提供更快的体验和保持良好的SEO地位。</p><p id="8d5d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在早期的迭代中，Nunjucks架构在服务器端比我们现有的Jinja设置要慢。进行多个网络调用引入了额外的开销(准备请求、序列化和反序列化数据)，往返过程给我们的呈现时间增加了不小的毫秒数。</p><p id="5a82" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们做了两件事，有助于降落三角洲，并允许我们发射。</p><p id="96c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">并行化。有了Jinja，我们不需要通过网络协议调用sidecar进程来呈现模板。然而，由于模板渲染受CPU限制的特性，这也意味着Jinja模板渲染无法进行有意义的并行化。我们的Nunjucks render调用不是这样的。通过使用gevent并行调用，我们能够同时启动到代理nginx层的网络连接，从而非常高效地将请求分配给可用的工作人员。</strong></p><p id="5f67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">避免不必要的数据序列化。</strong>在我们的模板渲染中有几个热点，我们只是在标记中嵌入大量数据，以便发送到浏览器。这些主要位于静态头部和body end标签周围，对于每个web请求都是一致的。对于我们的员工来说，一个很大的问题是这些巨大的JSON blobs数据的序列化和反序列化。避免这种情况有助于我们获得另一个性能优势，最终实现对等。</p><p id="0b4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是结果的图表(红色的是Nunjucks，绿色的是Jinja):</p><figure class="ke kf kg kh fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kv"><img src="../Images/4ffb24e37dc95a9bc7e4ed9d5c2ed145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kXyHfdOrJxxzZngN.png"/></div></div></figure><h2 id="afa2" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">反应正在发生</h2><p id="c486" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">一旦Nunjucks引擎就位并为Pinterest.com的100%模板提供服务，开发者就可以开始将他们的模块转换为React组件了。今天，随着Nunjucks代码在整个代码库中迅速被React转换所取代，我们放弃了我们的旧框架，并愉快地解决了构建完整React应用程序的挑战，同时看到了迁移带来的许多性能和开发人员生产率的提高。</p></div></div>    
</body>
</html>