<html>
<head>
<title>Effective Kotlin: Consider inline modifier for higher-order functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有效的Kotlin:考虑高阶函数的内联修饰符</h1>
<blockquote>原文：<a href="https://blog.kotlin-academy.com/effective-kotlin-consider-inline-modifier-for-higher-order-functions-758afcaffc11?source=collection_archive---------0-----------------------#2018-04-16">https://blog.kotlin-academy.com/effective-kotlin-consider-inline-modifier-for-higher-order-functions-758afcaffc11?source=collection_archive---------0-----------------------#2018-04-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/f705296419846bda189c8e149b1bdcb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPfNZWXgaOI1xy6VetEG_Q.jpeg"/></div></div></figure><div class=""/><p id="a602" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能已经注意到，所有的集合处理函数都是内联的。你有没有问过自己，为什么他们是这样定义的？例如，下面是Kotlin stdlib中的一个简化的<code class="fe kt ku kv kw b">filter</code>函数:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="0e31" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">inline fun </strong>&lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T)-&gt;Boolean): List&lt;T&gt;{<br/>    <strong class="kw iz">val </strong>destination = ArrayList&lt;T&gt;()<br/>    <strong class="kw iz">for </strong>(element <strong class="kw iz">in this</strong>) <br/>        <strong class="kw iz">if </strong>(predicate(element))<br/>            destination.add(element)<br/>    <strong class="kw iz">return </strong>destination<br/>}</span></pre><p id="3ea1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个<code class="fe kt ku kv kw b">inline</code>修改器有多重要？假设我们有5 000件产品，我们需要合计购买的价格。我们可以简单地通过以下方式实现:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="0e59" class="lf lg iy kw b gy lh li l lj lk">users.<em class="ll">filter </em><strong class="kw iz">{ it</strong>.<strong class="kw iz">bought }</strong>.<em class="ll">sumByDouble </em><strong class="kw iz">{ it</strong>.<strong class="kw iz">price }</strong></span></pre><p id="9d20" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的机器中，平均计算需要38毫秒。如果这个功能不是<code class="fe kt ku kv kw b">inline</code>会是多少钱？在我的机器上平均42毫秒。<a class="ae lm" href="https://github.com/MarcinMoskala/effective-kotlin-tests/blob/master/src/main/kotlin/org/kotlinacademy/InlineFilterBenchmark.kt" rel="noopener ugc nofollow" target="_blank">自己去查</a>。这看起来不是很多，但是当您每次使用方法进行集合处理时，您可以注意到这大约10%的差异。</p><p id="941a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们修改lambda表达式中的局部变量时，可以观察到更大的差异。比较以下功能:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="f557" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">inline fun </strong>repeat(times: Int, action: (Int) -&gt; Unit) {<br/>    <strong class="kw iz">for </strong>(index <strong class="kw iz">in </strong>0 <em class="ll">until </em>times) {<br/>        action(index)<br/>    }<br/>}<br/><br/><strong class="kw iz">fun </strong>noinlineRepeat(times: Int, action: (Int) -&gt; Unit) {<br/>    <strong class="kw iz">for </strong>(index <strong class="kw iz">in </strong>0 <em class="ll">until </em>times) {<br/>        action(index)<br/>    }<br/>}</span></pre><p id="76f5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能已经注意到，除了name，唯一的区别是first有<code class="fe kt ku kv kw b">inline</code>修饰符，而second没有。用法也是一样的:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="f8f4" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">var </strong>a = 0<br/>repeat(100_000_000) <strong class="kw iz">{<br/>    </strong>a += 1<br/><strong class="kw iz">}</strong></span><span id="5b38" class="lf lg iy kw b gy ln li l lj lk"><strong class="kw iz">var </strong>b = 0<br/><em class="ll">noinlineRepeat</em>(100_000_000) <strong class="kw iz">{<br/>    </strong>b += 1<br/><strong class="kw iz">}</strong></span></pre><p id="5539" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们在执行时间上有很大的不同。<code class="fe kt ku kv kw b">inlineRepeat</code>平均用时0.335 ns，而<code class="fe kt ku kv kw b">noinlineRepeat</code>平均用时153 980 484.884 ns。是46.6万倍以上！<a class="ae lm" href="https://github.com/MarcinMoskala/effective-kotlin-tests/blob/master/src/main/kotlin/org/kotlinacademy/InlineRepeatBenchmark.kt" rel="noopener ugc nofollow" target="_blank">自己去查</a>。</p><p id="c568" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么这如此重要？这种性能改进有什么代价吗？我们什么时候应该使用行内修饰符？这些都是非常重要的问题，我们会努力回答。尽管一切都需要从更基本的问题开始:行内修饰符是做什么的？</p><figure class="kx ky kz la gt ip gh gi paragraph-image"><a href="https://leanpub.com/effectivekotlin/c/3YYtCtqCC6a4"><div class="gh gi lo"><img src="../Images/0742a8ad0cfd3851db2d28061bf6f214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbef0K0JtDZ6F2vBVUDZsg.jpeg"/></div></a></figure><h1 id="99df" class="lp lg iy bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">行内修饰符是做什么的？</h1><p id="b161" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">我们知道函数通常是如何被调用的。执行跳转到函数体，调用所有语句，然后跳转回调用函数的地方。</p><p id="dee9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管当一个函数用<code class="fe kt ku kv kw b">inline</code>修饰符标记时，编译器会对它进行不同的处理。在代码编译期间，它用自己的主体替换这样的函数调用。<code class="fe kt ku kv kw b">print</code>是<code class="fe kt ku kv kw b">inline</code>的功能:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="6ca2" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">public inline fun </strong>print(message: Int) {<br/>    System.out.print(message)<br/>}</span></pre><p id="2a28" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们定义以下<code class="fe kt ku kv kw b">main</code>时:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="311d" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">fun </strong>main(args: Array&lt;String&gt;) {<br/>    <em class="ll">print</em>(2)<br/>    <em class="ll">print</em>(2)<br/>}</span></pre><p id="8650" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编译后，它将如下所示:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="1220" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">fun </strong>main(args: Array&lt;String&gt;) {<br/>    System.<em class="ll">out</em>.print(2)<br/>    System.<em class="ll">out</em>.print(2)<br/>}</span></pre><p id="442c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一点小小的不同，那就是我们不需要跳转到另一个函数然后返回。虽然这种影响可以忽略不计。这就是为什么当您自己定义这种内联函数时，IDEA IntelliJ中会出现以下警告:</p><figure class="kx ky kz la gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mr"><img src="../Images/bc891ebeefee78caa639ea9d32c34b06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZBktqv-Utek7YVKNQMxrUg.png"/></div></div></figure><p id="23ce" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们有lambda参数时，IntelliJ为什么建议使用inline？因为当我们内联函数体时，我们不需要从参数中创建lambdas，相反，我们可以将它们内联到调用中。对上述<code class="fe kt ku kv kw b">repeat</code>函数的调用:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="da0f" class="lf lg iy kw b gy lh li l lj lk">repeat(100) { println(<strong class="kw iz">"A"</strong>) }</span></pre><p id="dcc4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">会这样处理编译:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="bb3e" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">for </strong>(index <strong class="kw iz">in </strong>0 <em class="ll">until </em>1000) {<br/>    println(<strong class="kw iz">"A"</strong>)<br/>}</span></pre><p id="5915" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你所看到的，lambda表达式的主体替换了内联函数中的调用。让我们看另一个例子。此<code class="fe kt ku kv kw b">filter</code>功能用途:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="c0e0" class="lf lg iy kw b gy lh li l lj lk">val users2 = users.<em class="ll">filter </em><strong class="kw iz">{ it</strong>.<strong class="kw iz">bought }</strong></span></pre><p id="01a0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将替换为:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="b1bf" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">val </strong>destination = ArrayList&lt;T&gt;()<br/><strong class="kw iz">for </strong>(element <strong class="kw iz">in this</strong>) <br/>    <strong class="kw iz">if </strong>(predicate(element))<br/>        destination.add(element)<br/>val users2 = destination</span></pre><p id="d86d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个重要的改进。是因为JVM没有天真的支持lambda表达式。解释lambda表达式是如何编译的相当复杂，但一般来说，有两种选择:</p><ul class=""><li id="1573" class="ms mt iy jx b jy jz kc kd kg mu kk mv ko mw ks mx my mz na bi translated">匿名类</li><li id="34ef" class="ms mt iy jx b jy nb kc nc kg nd kk ne ko nf ks mx my mz na bi translated">单独的类</li></ul><p id="fa8b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看例子。我们有下面的λ表达式:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="619a" class="lf lg iy kw b gy lh li l lj lk">val lambda: ()-&gt;Unit = {<br/>    // body<br/>}</span></pre><p id="0401" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它可能是JVM anonymus类:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="130b" class="lf lg iy kw b gy lh li l lj lk">// Java<br/>Function0 lambda = <strong class="kw iz">new </strong>Function0() {<em class="ll"><br/>   </em><strong class="kw iz">public </strong>Object invoke() {<br/>      // code<br/>   }<br/>};</span></pre><p id="a272" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者它可能是在一个单独文件中定义的普通类:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="df65" class="lf lg iy kw b gy lh li l lj lk">// Java<br/>// Additional class in separate file<br/>public class TestInlineKt$lambda implements Function0 {<br/><em class="ll">   </em><strong class="kw iz">public </strong>Object invoke() {<br/>      // code<br/>   }<br/>}</span><span id="ceb3" class="lf lg iy kw b gy ln li l lj lk">// Usage<br/>Function0 lambda = <strong class="kw iz">new</strong> TestInlineKt$lambda()</span></pre><p id="8e9c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二种选择更快，只要有可能就使用。当我们需要使用局部变量时，第一个选项(匿名类)是必要的。</p><p id="9abe" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是为什么我们在修改局部变量时，<code class="fe kt ku kv kw b">repeat</code>和<code class="fe kt ku kv kw b">noinlineRepeat</code>会有如此大的差异。非内联函数中的Lambda需要编译成匿名类。这是一笔巨大的成本，因为它们的创建和使用都比较慢。当我们使用内联函数时，我们根本不需要创建任何额外的类。你自己检查一下。将这段代码编译和反编译成Java:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="8027" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">fun </strong>main(args: Array&lt;String&gt;) {<br/>    <strong class="kw iz">var </strong>a = 0<br/>    <em class="ll">repeat</em>(100_000_000) <strong class="kw iz">{<br/>        </strong>a += 1<br/>    <strong class="kw iz">}<br/>    var </strong>b = 0<br/>    <em class="ll">noinlineRepeat</em>(100_000_000) <strong class="kw iz">{<br/>        </strong>b += 1<br/>    <strong class="kw iz">}<br/></strong>}</span></pre><p id="c974" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您会发现与此类似的内容:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="eecd" class="lf lg iy kw b gy lh li l lj lk">// Java<br/><strong class="kw iz">public static final void </strong>main(@NotNull String[] args) {<br/>   <strong class="kw iz">int </strong>a = 0;<br/>   <strong class="kw iz">int </strong>times$iv = 100000000;<br/>   <strong class="kw iz">int </strong>var3 = 0;<br/><br/>   <strong class="kw iz">for</strong>(<strong class="kw iz">int </strong>var4 = times$iv; var3 &lt; var4; ++var3) {<br/>      ++a;<br/>   }<br/><br/>   <strong class="kw iz">final </strong>IntRef b = <strong class="kw iz">new </strong>IntRef();<br/>   b.element = 0;<br/>   noinlineRepeat(100000000, (Function1)(<strong class="kw iz">new </strong>Function1() {<em class="ll"><br/>      </em><strong class="kw iz">public </strong>Object invoke(Object var1) {<br/>         ++b.element;<br/>         <strong class="kw iz">return </strong>Unit.INSTANCE;<br/>      }<br/>   }));<br/>}</span></pre><p id="ff83" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe kt ku kv kw b">filter</code>的例子中，改进不是很明显，因为非内联版本的lambda表达式被编译成普通类。它的创建和使用很快，但仍然有成本，所以我们有大约10%的差异。</p><figure class="kx ky kz la gt ip gh gi paragraph-image"><a href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a"><div class="gh gi lo"><img src="../Images/3146970f03e44cb07afe660b0d43e045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54OqlYA4etu7wfpmMP5TKQ.png"/></div></a></figure><h1 id="cf8a" class="lp lg iy bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">收集流处理与传统方式</h1><p id="3e7e" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">内联修饰符是一个关键元素，它使得流方式的集合处理与基于循环的经典处理一样有效。它经过了一次又一次的测试，传统的处理在代码可读性方面的代价是巨大的，而在性能方面的改进很小或者没有。例如，下面的代码:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="b7f8" class="lf lg iy kw b gy lh li l lj lk">return data.filter { filterLoad(it) }.map { mapLoad(it) }</span></pre><p id="4dd2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">工作原理和执行时间与此相同:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="2e68" class="lf lg iy kw b gy lh li l lj lk">val list = ArrayList&lt;String&gt;()<br/>for (it in data) {<br/>    if (filterLoad(it)) {<br/>        val value = mapLoad(it)<br/>        list.add(value)<br/>    }<br/>}<br/>return list</span></pre><p id="51e4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基准测试的具体结果(此处代码为<a class="ae lm" href="https://github.com/JetBrains/kotlin-benchmarks/blob/master/src/main/kotlin/org/jetbrains/ClassListBenchmark.kt" rel="noopener ugc nofollow" target="_blank"/>):</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="e6b6" class="lf lg iy kw b gy lh li l lj lk">Benchmark           (size) Mode  Cnt        Score    Error  Units<br/>filterAndMap           10  avgt  200      561.249 ±      1  ns/op<br/>filterAndMap         1000  avgt  200    29803.183 ±    127  ns/op<br/>filterAndMap       100000  avgt  200  3859008.234 ±  50022  ns/op<br/><br/>filterAndMapManual     10  avgt  200      526.825 ±      1  ns/op<br/>filterAndMapManual   1000  avgt  200    28420.161 ±     94  ns/op<br/>filterAndMapManual 100000  avgt  200  3831213.798 ±  34858  ns/op</span></pre><p id="02e5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从程序的角度来看，这两个功能几乎相等。虽然从可读性的角度来看，第一个选项要好得多。这就是为什么我们总是倾向于使用智能集合处理功能，而不是自己实现整个处理。此外，如果我们需要其他不是stdlib的集合处理函数，请毫不犹豫地编写自己的函数。例如，这是我在上一个项目中添加的函数，当时我需要转置列表列表:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="2472" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">fun </strong>&lt;E&gt; List&lt;List&lt;E&gt;&gt;.transpose(): List&lt;List&lt;E&gt;&gt; {<br/>    <strong class="kw iz">if </strong>(isEmpty()) <strong class="kw iz">return this<br/><br/>    val </strong>width = <em class="ll">first</em>().<strong class="kw iz">size<br/>    if </strong>(<em class="ll">any </em><strong class="kw iz">{ it</strong>.<strong class="kw iz">size </strong>!= width <strong class="kw iz">}</strong>) {<br/>        <strong class="kw iz">throw </strong>IllegalArgumentException(<strong class="kw iz">"All nested lists must have the same size, but sizes were ${</strong><em class="ll">map </em><strong class="kw iz">{ it</strong>.<strong class="kw iz">size }}"</strong>)<br/>    }<br/><br/>    <strong class="kw iz">return </strong>(0 <em class="ll">until </em>width).<em class="ll">map </em><strong class="kw iz">{ </strong>col <strong class="kw iz">-&gt;<br/>        </strong>(0 <em class="ll">until </em><strong class="kw iz">size</strong>).<em class="ll">map </em><strong class="kw iz">{ </strong>row <strong class="kw iz">-&gt; this</strong>[row][col] <strong class="kw iz">}<br/>    }<br/></strong>}</span></pre><p id="6ff2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">只要记得写一些单元测试:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="a97f" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">class </strong>TransposeTest {<br/><br/>    <strong class="kw iz">private val list </strong>= <em class="ll">listOf</em>(<em class="ll">listOf</em>(1, 2, 3), <em class="ll">listOf</em>(4, 5, 6))<br/><br/>    @Test<br/>    <strong class="kw iz">fun </strong>`Transposition of transposition is identity`() {<br/>        Assert.assertEquals(<strong class="kw iz">list</strong>, <strong class="kw iz">list</strong>.<em class="ll">transpose</em>().<em class="ll">transpose</em>())<br/>    }<br/><br/>    @Test<br/>    <strong class="kw iz">fun </strong>`Simple transposition test`() {<br/>        <strong class="kw iz">val </strong>transposed = <em class="ll">listOf</em>(<em class="ll">listOf</em>(1, 4), <em class="ll">listOf</em>(2, 5), <em class="ll">listOf</em>(3, 6))<br/>        assertEquals(transposed, <strong class="kw iz">list</strong>.<em class="ll">transpose</em>())<br/>    }<br/>}</span></pre><h1 id="54b2" class="lp lg iy bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">内嵌修改量的成本</h1><p id="c2d5" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">内联不应该使用得太频繁，因为它也有成本。假设我真的很喜欢打印2。我首先定义了以下函数:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="6b49" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">inline fun </strong>twoPrintTwo() {<br/>    <em class="ll">print</em>(2)<br/>    <em class="ll">print</em>(2)<br/>}</span></pre><p id="b08f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对我来说还不够，所以我增加了这个功能:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="72ce" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">inline fun </strong>twoTwoPrintTwo() {<br/>    <em class="ll">twoPrintTwo</em>()<br/>    <em class="ll">twoPrintTwo</em>()<br/>}</span></pre><p id="2655" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还是不满意。我定义了以下函数:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="8fac" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">inline fun </strong>twoTwoTwoPrintTwo() {<br/>    <em class="ll">twoTwoPrintTwo</em>()<br/>    <em class="ll">twoTwoPrintTwo</em>()<br/>}<br/><br/><strong class="kw iz">fun </strong>twoTwoTwoTwoPrintTwo() {<br/>    <em class="ll">twoTwoTwoPrintTwo</em>()<br/>    <em class="ll">twoTwoTwoPrintTwo</em>()<br/>}</span></pre><p id="e986" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我决定检查一下我在编译的代码中有什么，所以我把它编译成JVM字节码，再反编译成Java。<code class="fe kt ku kv kw b">twoTwoPrintTwo</code>已经相当大了:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="879e" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">public static final void </strong>twoTwoPrintTwo() {<br/>   <strong class="kw iz">byte </strong>var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>}</span></pre><p id="f40e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是<code class="fe kt ku kv kw b">twoTwoTwoTwoPrintTwo</code>真的很吓人:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="9468" class="lf lg iy kw b gy lh li l lj lk"><strong class="kw iz">public static final void </strong>twoTwoTwoTwoPrintTwo() {<br/>   <strong class="kw iz">byte </strong>var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print(var1);<br/>   var1 = 2;<br/>   System.<strong class="kw iz"><em class="ll">out</em></strong>.print();<br/>}</span></pre><p id="4e26" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这显示了内联函数的主要问题:当我们过度使用它们时，代码增长非常快。这实际上是为什么IntelliJ在我们使用它们时会给出警告并且不太可能改进的一个原因。</p><figure class="kx ky kz la gt ip gh gi paragraph-image"><a href="https://www.kt.academy/"><div class="gh gi lo"><img src="../Images/018370a2476e1ce49e6d3299428b4f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K-f1laplrjQQAMlYKfLgHw.png"/></div></a></figure><h1 id="3d58" class="lp lg iy bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">内嵌修饰符使用的不同方面</h1><p id="0aa4" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">内联修饰符，由于它的特性，比我们在本文中看到的变化要大得多。它允许非局部返回和具体化的泛型类型。它也有一些局限性。虽然这与有效的Kotlin系列无关，并且这是一篇单独文章的材料。如果你想让我写，就在推特上或者评论里表达出来。</p><h1 id="cf14" class="lp lg iy bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">一般来说，我们什么时候应该使用行内修饰符？</h1><p id="1525" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">我们使用<code class="fe kt ku kv kw b">inline</code>修饰符最重要的情况是当我们用参数函数定义类似util的函数时。集合或字符串处理(如<code class="fe kt ku kv kw b">filter</code>、<code class="fe kt ku kv kw b">map</code>或<code class="fe kt ku kv kw b">joinToString</code>)或只是独立的函数(如<code class="fe kt ku kv kw b">repeat</code>)就是很好的例子。</p><p id="d74b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是为什么<code class="fe kt ku kv kw b">inline</code>修饰符对于库开发者来说是一个重要的优化。他们应该知道它是如何工作的，它的改进和成本是什么。当我们用函数类型参数定义自己的util函数时，我们将在项目中使用<code class="fe kt ku kv kw b">inline</code>修饰符。</p><p id="5547" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们没有函数类型参数、具体化类型参数，并且不需要非局部返回时，那么我们很可能不应该使用<code class="fe kt ku kv kw b">inline</code>修饰符。这就是为什么我们会在Android Studio或IDEA IntelliJ上有一个警告。</p><p id="aa73" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其他情况更复杂，我们需要基于直觉。在本系列的后面，我们将看到，有时并不清楚哪种优化更好。在这种情况下，我们需要基于测量或某人的专业知识。</p><h1 id="0909" class="lp lg iy bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">有效科特林</h1><p id="2643" class="pw-post-body-paragraph jv jw iy jx b jy mm ka kb kc mn ke kf kg mo ki kj kk mp km kn ko mq kq kr ks ig bi translated">这是第一篇关于有效科特林的文章。当我们看到兴趣，我们将出版下一部分。在Kot。学院我们也在研究关于这个主题的书:</p><div class="im in gp gr io ng"><a href="https://leanpub.com/effectivekotlin" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iz gy z fp nl fr fs nm fu fw ix bi translated">有效科特林</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">这本书对官方的(Kotlin和Google对Kotlin的最佳实践)和…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">leanpub.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu iu ng"/></div></div></a></div><p id="c48d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将涵盖更广泛的主题，并深入其中的每一个问题。它还将包括Kotlin和Google团队发布的最佳实践、与我们合作的Kotlin团队成员的经验，以及“Kotlin中的有效Java”系列中涉及的主题。为了支持它并使我们更快地发布它，<a class="ae lm" href="https://leanpub.com/effectivekotlin" rel="noopener ugc nofollow" target="_blank">使用此链接并订阅</a>。</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="ccff" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你需要Kotlin工作室吗？访问<a class="ae lm" href="https://www.kt.academy/" rel="noopener ugc nofollow" target="_blank">我们的网站</a>，看看我们能为您做些什么。</p><p id="555a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">了解卡帕头最新的重大新闻。学院，<a class="ae lm" href="https://kotlin-academy.us17.list-manage.com/subscribe?u=5d3a48e1893758cb5be5c2919&amp;id=d2ba84960a" rel="noopener ugc nofollow" target="_blank">订阅时事通讯</a>，<a class="ae lm" href="https://twitter.com/ktdotacademy" rel="noopener ugc nofollow" target="_blank">观察Twitter </a>并在medium上关注我们。</p><p id="f0bc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Twitter上引用我，用<a class="ae lm" href="https://twitter.com/marcinmoskala" rel="noopener ugc nofollow" target="_blank"> @MarcinMoskala </a>。</p><p id="4cad" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">喜欢的话记得<strong class="jx iz">拍</strong>。请注意，如果您按住鼓掌按钮，您可以留下更多的掌声。</p><p id="e61b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢<a class="ae lm" href="https://twitter.com/orangy" rel="noopener ugc nofollow" target="_blank"> Ilya Ryzhenkov </a>的指正和重要建议。</p></div></div>    
</body>
</html>