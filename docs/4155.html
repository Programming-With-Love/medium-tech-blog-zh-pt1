<html>
<head>
<title>ViewModels under the hood..</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引擎盖下的视图模型..</h1>
<blockquote>原文：<a href="https://medium.com/google-developer-experts/viewmodels-under-the-hood-f8e286c4cc72?source=collection_archive---------1-----------------------#2018-02-12">https://medium.com/google-developer-experts/viewmodels-under-the-hood-f8e286c4cc72?source=collection_archive---------1-----------------------#2018-02-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="facc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">去年在Google I/O上，Google宣布了一组名为Android Architecture Components的库。</p><p id="e41e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Android架构组件是基于以下原因创建的。(这是我对他们的看法，并不反映谷歌或其工程师的实际意见):</p><p id="2552" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1 .给一个关于如何设计android应用的观点。有许多不同的方法来设计一个android应用程序，其中许多在文档中没有提到。这让许多试图只使用文档来学习的新Android开发者感到困惑。</p><p id="e022" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2 .提供工具来帮助解决android开发人员发现的常见问题。(生命周期管理、数据持久性、分页)</p><p id="c256" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Android架构组件是库的组合:Room、ViewModel、LiveData、生命周期感知组件和分页库。</p><p id="9f8f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">去年，我做了两次关于这些组件的演讲。这些都集中在视图模型和生命周期感知组件上(<a class="ae jc" href="https://www.youtube.com/watch?v=uMohC2p8itg&amp;t=804s" rel="noopener ugc nofollow" target="_blank">链接到其中一个记录</a></p><p id="df4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">演示结束后，观众通常会有两种感受。为找到解决视图模型问题的解决方案而兴奋，以及想了解它们如何工作的好奇心。</p><p id="c920" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了回答这个好奇和其他常见的问题，例如:<br/>-为什么我们不应该在视图模型中存储太多的数据？<br/> -为什么我们不能使用视图模型在活动之间进行交流？</p><p id="4283" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我决定写这篇文章，解释在使用视图模型时会发生什么。</p><p id="c622" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇文章不会讨论这个库中的其他组件。有这么多可用的资源，其中一些链接将发布在这篇文章的底部。</p><h1 id="73b8" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">视图模型</h1><blockquote class="kb kc kd"><p id="12f9" class="ie if ke ig b ih ii ij ik il im in io kf iq ir is kg iu iv iw kh iy iz ja jb ha bi translated">ViewModel类旨在存储和管理与UI相关的数据，以便这些数据在屏幕旋转等配置更改后仍然存在。—developer.android.com</p></blockquote><p id="ea17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设您有一个应用程序，它有一个显示电影细节的屏幕。<br/>打开时，该屏幕将显示从源(网络/数据库)加载的信息。如果用户决定旋转设备，将从源重新加载信息。</p><p id="6530" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是因为Android系统将在轮换配置更改时重新创建活动。<br/>如果源是远程服务器，这种小行为重复多次会浪费用户的数据。这是一个非常小的问题，但在更复杂的情况下，会造成更大的损害。<br/>为了解决这个小问题，让我们的应用成为用户设备上的好公民，我们可以尝试以下方法:</p><p id="4d17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.使类<code class="du ki kj kk kl b">Movie</code>成为一个<code class="du ki kj kk kl b">Parcelable</code>对象，并将其保存在实例状态<code class="du ki kj kk kl b">Bundle</code>中。</p><p id="7e0d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.我们自己改变过程配置。</p><p id="0a86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.创建一个<code class="du ki kj kk kl b">ViewModel</code>，将<code class="du ki kj kk kl b">Movie</code>对象保留在<code class="du ki kj kk kl b">ViewModel</code>中，让它完成剩下的工作。</p><p id="1f74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一种解决方案更容易实现，并且最常用于像我们的例子这样的简单情况。然而，如果对象变得太复杂，就很容易达到<code class="du ki kj kk kl b">Parcelable</code>的极限大小。</p><p id="1719" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个解决方案将阻止<code class="du ki kj kk kl b">Activity</code>号重启。这将解决我们的问题，但是我们在这个过程中失去了其他可以从<code class="du ki kj kk kl b">Activity</code>重启中获益的特性(为新配置重新加载适当的资源)。</p><p id="be12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用<code class="du ki kj kk kl b">ViewModels</code>的第三种解决方案是最可靠的，即使在最复杂的情况下也更容易实现。要实施此解决方案，我们需要完成以下步骤:</p><p id="fa01" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.创建一个将<code class="du ki kj kk kl b">Movie</code>作为变量的<code class="du ki kj kk kl b">ViewModel</code>类的子类。</p><p id="d5ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.在<code class="du ki kj kk kl b">ViewModel</code>上公开一个方法，该方法获取它应该加载的电影细节的Id。</p><p id="d79c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.暴露一个<code class="du ki kj kk kl b">LiveData</code>，它发出一个加载到<code class="du ki kj kk kl b">ViewModel</code>中的<code class="du ki kj kk kl b">Movie</code>对象。</p><p id="f878" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.在<code class="du ki kj kk kl b">Activity</code> / <code class="du ki kj kk kl b">Fragment</code>中获取<code class="du ki kj kk kl b">ViewModel</code>的一个实例。</p><p id="234b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">5.观察<code class="du ki kj kk kl b">Activity</code> / <code class="du ki kj kk kl b">Fragment</code>内外露的<code class="du ki kj kk kl b">LiveData</code>有无变化。</p><p id="ab1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">6.从源获取<code class="du ki kj kk kl b">Movie</code>并等待<code class="du ki kj kk kl b">LiveData</code>发布。</p><p id="eb8d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">7.最后，当<code class="du ki kj kk kl b">Movie</code>对象被发送到我们正在观察的<code class="du ki kj kk kl b">Activity</code> / <code class="du ki kj kk kl b">Fragment</code>时，显示电影细节。</p><p id="ff4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，如果旋转设备，<code class="du ki kj kk kl b">ViewModel</code>将在配置更改后继续存在，并且只要与它关联的范围仍然存在，它就会存在。如下图所示，ViewModel将保持活动状态，直到它的作用域(活动或片段)被破坏。</p><figure class="kn ko kp kq fd kr er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es km"><img src="../Images/1564b613f7c223769e76ff391ecfa0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSMJf03rllUciUgF_1M_uA.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">ViewModel Scope</figcaption></figure><p id="ec25" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着我们将获得相同的<code class="du ki kj kk kl b">ViewModel</code>实例。我们将开始观察这个实例<code class="du ki kj kk kl b">LiveData</code>和旋转发射前最新发射的数据。</p><p id="631b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这七个步骤相对容易做到。但是它们没有回答我前面提到的问题。要做到这一点，让我们详细看看这个过程是如何发生的。</p><h2 id="8ca8" class="lc je hh bd jf ld le lf jj lg lh li jn ip lj lk jr it ll lm jv ix ln lo jz lp bi translated">创建/获取视图模型实例的过程</h2><p id="9976" class="pw-post-body-paragraph ie if hh ig b ih lq ij ik il lr in io ip ls ir is it lt iv iw ix lu iz ja jb ha bi translated">假设我们有一个<code class="du ki kj kk kl b">MovieDetailsViewModel</code>类。我们可以通过从片段/活动中执行以下语句来获得它的实例:</p><p id="8d6e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk kl b">ViewModelProviders.of(this).get(MyViewModel.class);</code></p><p id="acde" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面语句中的链接调用可以分为两个独立的部分:</p><p id="42bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1st —调用在<code class="du ki kj kk kl b">ViewModelProviders</code>类中使用静态方法<code class="du ki kj kk kl b">of</code>获得一个<code class="du ki kj kk kl b">ViewModelProvider</code>。</p><p id="4ce5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2nd —从第一次调用中检索的ViewModelProvider获取<code class="du ki kj kk kl b">ViewModel</code>的调用。</p><h1 id="fe1e" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">视图模型提供者</h1><p id="d7d7" class="pw-post-body-paragraph ie if hh ig b ih lq ij ik il lr in io ip ls ir is it lt iv iw ix lu iz ja jb ha bi translated"><code class="du ki kj kk kl b">ViewModelProviders</code>是一个带有助手方法的类，用来获取<code class="du ki kj kk kl b">ViewModelProvider</code>。这个类有<code class="du ki kj kk kl b">DefaultFactory</code>作为它唯一的私有变量。<code class="du ki kj kk kl b">DefaultFactory</code>类用于创建一个<code class="du ki kj kk kl b">ViewModelProvider</code>的新实例。<br/> <code class="du ki kj kk kl b">ViewModelProviders</code>有一个名为<code class="du ki kj kk kl b">of</code>的静态方法的重载。其中一个方法将一个<code class="du ki kj kk kl b">Activity</code>和另一个<code class="du ki kj kk kl b">Fragment</code>作为参数，如以下签名所示:</p><p id="32b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk kl b">public static ViewModelProvider of(@NonNull FragmentActivity activity)</code> <br/> <code class="du ki kj kk kl b"> public static ViewModelProvider of(@NonNull Fragment fragment)</code></p><p id="a019" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当调用<code class="du ki kj kk kl b">of</code>的方法来获取<code class="du ki kj kk kl b">ViewModelProvider</code>时，会发生以下情况:</p><ol class=""><li id="3d2d" class="lv lw hh ig b ih ii il im ip lx it ly ix lz jb ma mb mc md bi translated"><strong class="ig hi">检查并获取片段/活动</strong> <code class="du ki kj kk kl b"><strong class="ig hi">Application</strong></code>。<br/>对于一个<code class="du ki kj kk kl b">Activity</code>，这个检查和检索是通过调用<code class="du ki kj kk kl b">checkApplication(Activity)</code>方法来完成的。<br/>该方法调用<code class="du ki kj kk kl b">Activity</code> <code class="du ki kj kk kl b">getApplication()</code>，如果为空，将返回应用程序或抛出异常。<br/>通过<code class="du ki kj kk kl b">Fragment</code>调用<code class="du ki kj kk kl b">of</code>方法时，使用类似的过程。在这种情况下，getApplication参数是对<code class="du ki kj kk kl b">checkActivity(Fragment)</code>的包装调用。checkActivity方法将为<code class="du ki kj kk kl b">Fragment</code>获取<code class="du ki kj kk kl b">Activity</code>。这将确保<code class="du ki kj kk kl b">Fragment</code>首先连接到<code class="du ki kj kk kl b">Activity</code>上。</li><li id="be40" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated"><strong class="ig hi">初始化</strong> <code class="du ki kj kk kl b"><strong class="ig hi">ViewModelProvider</strong></code> <strong class="ig hi">工厂。</strong> <br/>为此，将调用<code class="du ki kj kk kl b">initializeFactoryIfNeeded(Application)</code>方法。该方法将上一步中检索到的<code class="du ki kj kk kl b">Application</code>实例作为参数。<br/> 3。<strong class="ig hi">返回</strong> <code class="du ki kj kk kl b"><strong class="ig hi">ViewModelProvider</strong></code> <strong class="ig hi">。</strong><br/><code class="du ki kj kk kl b">of</code>方法将创建并返回ViewModelProvider的一个新实例。</li></ol><p id="6914" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一步完成实现得到一个<code class="du ki kj kk kl b">Activity</code>的<code class="du ki kj kk kl b">ViewModelProvider</code>看起来像这样:</p><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="ky kz et er es la lb bd b be z dx">Snippets from take from <a class="ae jc" href="https://github.com/aosp-mirror/platform_frameworks_support/blob/313c2be47202f789353ba6e96ae7e1c69b53a3a5/lifecycle/extensions/src/main/java/android/arch/lifecycle/ViewModelProviders.java" rel="noopener ugc nofollow" target="_blank">ViewModelProviders</a> implementation.</figcaption></figure></div><div class="ab cl ml mm go mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ha hb hc hd he"><h1 id="f1ef" class="jd je hh bd jf jg ms ji jj jk mt jm jn jo mu jq jr js mv ju jv jw mw jy jz ka bi translated">视图模型提供者</h1><p id="144c" class="pw-post-body-paragraph ie if hh ig b ih lq ij ik il lr in io ip ls ir is it lt iv iw ix lu iz ja jb ha bi translated">顾名思义，<code class="du ki kj kk kl b"><a class="ae jc" href="https://github.com/aosp-mirror/platform_frameworks_support/blob/313c2be47202f789353ba6e96ae7e1c69b53a3a5/lifecycle/extensions/src/main/java/android/arch/lifecycle/ViewModelProvider.java" rel="noopener ugc nofollow" target="_blank">ViewModelProvider</a></code>是实际提供<code class="du ki kj kk kl b"><a class="ae jc" href="https://github.com/aosp-mirror/platform_frameworks_support/blob/313c2be47202f789353ba6e96ae7e1c69b53a3a5/lifecycle/extensions/src/main/java/android/arch/lifecycle/ViewModel.java" rel="noopener ugc nofollow" target="_blank">ViewModel</a></code>的类。</p><p id="9ad5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个类包含了静态方法<code class="du ki kj kk kl b">get(Class&lt;T&gt; modelClass)</code>。这是在语句的第二部分调用的方法，以获得前面提到的<code class="du ki kj kk kl b">ViewModel</code>。</p><p id="5100" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从公开的API来看，一切都很简单。但是在我们得到一个<code class="du ki kj kk kl b">ViewModel</code>的实例之前，还有更多的事情发生，我们接下来会看到。</p><p id="1b5d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk kl b">ViewModelProvider</code>有两个构造函数:<br/> 1。<code class="du ki kj kk kl b">ViewModelProvider(ViewModelStore store, Factory factory)</code> <br/> 2。<code class="du ki kj kk kl b">ViewModelProvider(ViewModelStoreOwner storeOwner, Factory factory)</code></p><p id="676e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">两个构造函数都将<code class="du ki kj kk kl b">Factory</code>作为第二个参数来创建一个<code class="du ki kj kk kl b">ViewModel</code>类，但是它们的第一个参数不同。</p><p id="77d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个构造函数取一个<code class="du ki kj kk kl b">ViewModelStore</code>。A <code class="du ki kj kk kl b">ViewModelStore</code>是存储<code class="du ki kj kk kl b">ViewModels</code>的类。</p><p id="5ebb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了保存<code class="du ki kj kk kl b">ViewModels</code>，<code class="du ki kj kk kl b">ViewModelStore</code>将它们存储在一个<code class="du ki kj kk kl b">HashMap</code>中。每个<code class="du ki kj kk kl b">ViewModel</code>都用一个<code class="du ki kj kk kl b">String</code>作为关键字保存在地图中。<br/>关键是<code class="du ki kj kk kl b">DefaultName</code>变量和<code class="du ki kj kk kl b">ViewModel</code>类规范名称的连接。(<code class="du ki kj kk kl b">DefaultName</code>是<code class="du ki kj kk kl b">ViewModelProvider</code>类中的一个简单的最终字符串)<br/>用<code class="du ki kj kk kl b">ViewModelStore</code>创建的<code class="du ki kj kk kl b">ViewModelProvider</code>将通过执行以下操作返回<code class="du ki kj kk kl b">ViewModel</code>:</p><p id="115e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.将使用<code class="du ki kj kk kl b">DefaultName</code>和作为<code class="du ki kj kk kl b">get</code>方法的参数传递的类的规范名称创建一个键。</p><p id="3353" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.使用键从<code class="du ki kj kk kl b">HashMap</code>中检索<code class="du ki kj kk kl b">ViewModel</code>实例。</p><p id="0b3b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.如果找到，执行检查并确保返回正确的<code class="du ki kj kk kl b">ViewModel</code>实例。否则，将创建一个新实例，保存在<code class="du ki kj kk kl b">ViewModelStore</code>中并返回。</p><figure class="kn ko kp kq fd kr"><div class="bz dy l di"><div class="mj mk l"/></div><figcaption class="ky kz et er es la lb bd b be z dx">Snippet from <a class="ae jc" href="https://github.com/aosp-mirror/platform_frameworks_support/blob/313c2be47202f789353ba6e96ae7e1c69b53a3a5/lifecycle/extensions/src/main/java/android/arch/lifecycle/ViewModelProvider.java" rel="noopener ugc nofollow" target="_blank">ViewModelProvider.java</a> implementation</figcaption></figure><p id="2326" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">到目前为止，我们知道了<code class="du ki kj kk kl b">ViewModels</code>是如何被创建和存储的，但是<br/>这还不能解释它们如何在配置改变后存活的问题。这是因为<code class="du ki kj kk kl b">ViewModelProviders</code>的第一个构造函数采用了一个<code class="du ki kj kk kl b">ViewModelStore</code>，并且这个存储本身不属于任何范围。</p><p id="3681" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在解决我们开始的问题的实现中，<code class="du ki kj kk kl b">ViewModelProvider</code>将使用第二个构造函数创建。将a <code class="du ki kj kk kl b">ViewModelStoreOwner</code>作为第一个参数的构造函数</p><h1 id="e8f4" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">视图模型存储所有者</h1><p id="343b" class="pw-post-body-paragraph ie if hh ig b ih lq ij ik il lr in io ip ls ir is it lt iv iw ix lu iz ja jb ha bi translated"><code class="du ki kj kk kl b">ViewModelStoreOwner</code>是一个接口，顾名思义，它是<code class="du ki kj kk kl b">ViewModelStore</code>的所有者。这可以是实现该接口定义的<code class="du ki kj kk kl b">getViewModelStore()</code>的任何类。在库中，<code class="du ki kj kk kl b">ViewModelStoreOwner</code>就是<code class="du ki kj kk kl b">HolderFragment</code>类。这个类有一个可以通过<code class="du ki kj kk kl b">getViewModelStore()</code>方法访问的<code class="du ki kj kk kl b">ViewModelStore</code>变量。<br/> <code class="du ki kj kk kl b">HolderFragment</code>是正规的安卓<code class="du ki kj kk kl b">Fragment</code>。这个<code class="du ki kj kk kl b">Fragment</code>使用<code class="du ki kj kk kl b">setRetainInstanceState(boolean)</code>方法为true，以便保留实例状态。正如您所猜测的，state拥有包含所有<code class="du ki kj kk kl b">ViewModels</code>的<code class="du ki kj kk kl b">ViewModelStore</code>。</p><p id="d4c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Android架构组件出现之前，这种技术已经被多次用于相同的目的。</p><p id="016c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk kl b">HolderFragment</code>是<code class="du ki kj kk kl b">ViewModelStore</code>内所有视图模型将居住的范围。根据帖子前面显示的带有<code class="du ki kj kk kl b">ViewModel</code>范围的图像，如果范围(<code class="du ki kj kk kl b">HolderFragment</code>)被破坏，所有视图模型将被清除。</p><p id="f3a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们知道了<code class="du ki kj kk kl b">ViewModels</code>是如何经受住配置变化的。然而，这并没有解释我们如何用ViewModels在片段之间进行交流，以及为什么我们不能用两个活动做同样的事情。</p><h1 id="38cb" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">谁拥有HolderFragment？</h1><h2 id="98c0" class="lc je hh bd jf ld le lf jj lg lh li jn ip lj lk jr it ll lm jv ix ln lo jz lp bi translated">HolderFragmentManager</h2><p id="7621" class="pw-post-body-paragraph ie if hh ig b ih lq ij ik il lr in io ip ls ir is it lt iv iw ix lu iz ja jb ha bi translated"><code class="du ki kj kk kl b">HolderFragment</code>有一个名为<code class="du ki kj kk kl b">HolderFragmentManager</code>的内部静态类。<code class="du ki kj kk kl b">HolderFragmentManager</code>创建并管理<code class="du ki kj kk kl b">HolderFragment</code>实例。<br/>创建实例后，它将它们与一个<code class="du ki kj kk kl b">Activity</code>或<code class="du ki kj kk kl b">Fragment</code>相关联。<br/>使用<code class="du ki kj kk kl b">holderFragmentFor(Activity)</code>和<code class="du ki kj kk kl b"> holderFragmentFor(Fragment)</code>方法完成整个过程。<br/>如果有或没有<code class="du ki kj kk kl b">HolderFragment</code>的实例，这些方法将以两种不同的方式运行。<br/>对于没有<code class="du ki kj kk kl b">HolderFragment</code>实例的情况，这些方法将:<br/> 1。创建一个<code class="du ki kj kk kl b">HolderFragment</code>的实例。</p><p id="2751" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.将新实例添加到父实例(<code class="du ki kj kk kl b">Activity</code> / <code class="du ki kj kk kl b">Fragment</code> ) <code class="du ki kj kk kl b">FragmentManager</code>。这将导致<code class="du ki kj kk kl b">HolderFragment</code>内视图模型范围的扩大。因此，只要<code class="du ki kj kk kl b">Activity</code> / <code class="du ki kj kk kl b">Fragment</code>将视图模型存储在它的<code class="du ki kj kk kl b">FragmentManager</code>中，视图模型就会一直存在</p><p id="52aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.向<code class="du ki kj kk kl b">Activity</code> / <code class="du ki kj kk kl b">Fragment</code>生命周期<code class="du ki kj kk kl b">onDestroy() </code>回调方法注册一个回调。因为<code class="du ki kj kk kl b">HolderFragment</code>在一个<code class="du ki kj kk kl b">Activity</code>/<code class="du ki kj kk kl b">Fragment</code>/<code class="du ki kj kk kl b">FragmentManager</code>中，当<code class="du ki kj kk kl b">Activity</code> / <code class="du ki kj kk kl b">Fragment</code>被销毁时，它的<code class="du ki kj kk kl b">onDestroy()</code>方法将被调用，而<code class="du ki kj kk kl b">ViewModelStore </code>将被清除。最后，当注册的回调被调用时，<code class="du ki kj kk kl b">HolderFragment</code>实例将从与<code class="du ki kj kk kl b">Activity</code> / <code class="du ki kj kk kl b">Fragment </code>关联的<code class="du ki kj kk kl b">HolderFragmentManager</code> <code class="du ki kj kk kl b">HashMap</code>中删除。</p><p id="65c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.将支架<code class="du ki kj kk kl b">Fragment</code>添加到<code class="du ki kj kk kl b">HashMap</code>中，其键为<code class="du ki kj kk kl b">Activity</code> / <code class="du ki kj kk kl b">Fragment</code>。这就是为什么我们不能使用相同的<code class="du ki kj kk kl b">ViewModel</code>在两个活动或片段之间进行通信。</p><p id="c29b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于片段来说，只有当它们可以有相同的父对象时，通信才是可能的。这意味着我们可以通过请求父<code class="du ki kj kk kl b">Activity</code>而不是<code class="du ki kj kk kl b">Fragment</code>本身来欺骗并获得一个<code class="du ki kj kk kl b">ViewModel</code>的相同实例。</p><p id="4659" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">5.返回HolderFragment实例。</p><p id="2000" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当已经有一个<code class="du ki kj kk kl b">HolderFragment</code>的实例时，这些方法将查找并返回已经在<code class="du ki kj kk kl b">HashMap</code>中的实例。</p><p id="a83f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">知道了<code class="du ki kj kk kl b">ViewModelStoreOwner</code>下面的细节，我们可以回到<code class="du ki kj kk kl b">ViewModelsProviders</code>来看看我们如何创建创建<code class="du ki kj kk kl b">ViewModelProvider</code>实例所需的<code class="du ki kj kk kl b">ViewModelStoreOnwer</code>。<br/><code class="du ki kj kk kl b">ViewModelProviders</code>类通过从<code class="du ki kj kk kl b">ViewModelStores</code>类调用静态方法<code class="du ki kj kk kl b">of</code>来获得<code class="du ki kj kk kl b">ViewModelStoreOwner</code>的一个实例。</p><p id="1bf0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ki kj kk kl b">ViewModelStores</code>类的工作是抽象出对<code class="du ki kj kk kl b">HolderFragmentManager</code>内部的<code class="du ki kj kk kl b">holderFragmentOf(Activity/Fragment)</code>静态方法的调用。如前所述，这个方法将负责返回一个<code class="du ki kj kk kl b">ViewModelStoreOwner</code>。<br/> <br/>我希望你能愉快地阅读这篇长文，并且现在你对视图模型是如何创建和工作的有了更多的了解。</p><p id="5c96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望你能利用这个解释的细节，永远记住:<br/>——在创建<code class="du ki kj kk kl b">Activity</code>之前，你不应该试图获取<code class="du ki kj kk kl b">ViewModel</code>的实例。如果是为了一个<code class="du ki kj kk kl b">Fragment</code>而得到它，你不应该试图在一个没有连接到<code class="du ki kj kk kl b">Activity</code>的<code class="du ki kj kk kl b">Fragment</code>上得到它。你不应该在你的<code class="du ki kj kk kl b">ViewModel</code>上放太多东西。正如你所看到的，它们只是一个常规的<code class="du ki kj kk kl b">Fragment</code>，如果系统因为使用太多资源而决定终止，那么它的父模型和你所有的视图模型也会消失。为了避免这类问题，我建议您在使用savedInstance状态解决方案的同时使用<code class="du ki kj kk kl b">ViewModel</code>。</p><p id="5ff5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的示例中，在实例状态中存储电影id将确保即使ViewModel被终止，我们仍然能够获得正确的电影Id，并传递它来为适当的电影重新加载数据。</p><p id="6b06" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">—您只能使用视图模型在共享同一父对象的片段之间进行通信。</p><p id="d93c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你觉得有什么不清楚的地方，有什么建议或者要补充的，请在下面留下你的评论，让我们开始对话。</p><p id="f2c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感谢您的时间，并随时与您认为会喜欢阅读这篇文章的开发人员分享。</p><p id="0ad8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下次见！</p><p id="7261" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有用的链接:</p><p id="e60e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://developer.android.com/topic/libraries/architecture/index.html" rel="noopener ugc nofollow" target="_blank">架构组件官方指南</a></p><p id="14c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://www.youtube.com/watch?v=FrteWKKVyzI&amp;t=1662s" rel="noopener ugc nofollow" target="_blank">架构组件介绍—谷歌IO 17 </a></p><p id="c34b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://www.youtube.com/watch?v=Ts-uxYiBEQ8&amp;t=4s" rel="noopener ugc nofollow" target="_blank">建筑构件——GDD欧洲2017 </a> ( <a class="mx my ge" href="https://medium.com/u/d5885adb1ddf?source=post_page-----f8e286c4cc72--------------------------------" rel="noopener" target="_blank">弗洛里纳·蒙特内斯库</a>)</p><p id="8a63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://riggaroo.co.za/android-architecture-components-looking-viewmodels-part-2/" rel="noopener ugc nofollow" target="_blank"> Android架构组件—查看视图模型—第2部分</a> ( <a class="mx my ge" href="https://medium.com/u/3f9b9c30bec7?source=post_page-----f8e286c4cc72--------------------------------" rel="noopener" target="_blank">丽贝卡·弗兰克斯</a>)</p><p id="30ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://www.youtube.com/watch?v=9QrFMsihBAo&amp;t=848s" rel="noopener ugc nofollow" target="_blank">Android架构组件介绍</a> — SSA空中专家第六集</p><p id="c80e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感谢<a class="mx my ge" href="https://medium.com/u/d5885adb1ddf?source=post_page-----f8e286c4cc72--------------------------------" rel="noopener" target="_blank">弗洛里纳·蒙特内斯库</a>、<a class="mx my ge" href="https://medium.com/u/60764aad5eb3?source=post_page-----f8e286c4cc72--------------------------------" rel="noopener" target="_blank">罗萨里奥·佩雷拉·费尔南德斯</a>和<a class="mx my ge" href="https://medium.com/u/95b3bd440473?source=post_page-----f8e286c4cc72--------------------------------" rel="noopener" target="_blank">穆斯塔法·阿里</a>审阅了帖子的第一版。</p></div></div>    
</body>
</html>