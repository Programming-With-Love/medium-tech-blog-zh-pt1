<html>
<head>
<title>Are Flutter State widgets an illusion?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter State widgets是错觉吗？</h1>
<blockquote>原文：<a href="https://medium.com/globant/are-flutter-state-widgets-an-illusion-1c3b715620b7?source=collection_archive---------0-----------------------#2021-02-13">https://medium.com/globant/are-flutter-state-widgets-an-illusion-1c3b715620b7?source=collection_archive---------0-----------------------#2021-02-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="85ce" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated"><strong class="ak"> <em class="jc">如果我说Flutter中只有一种widget类型呢？即不是无状态和StatefulWidget而是只有StatefulWidget？</em>T3】</strong></h1><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ji jj l"/></div></figure><p id="2423" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">继续挖掘StatelessWidget和StatefulWidget是如何工作的。让我们检查StatefulWidget代码:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ki"><img src="../Images/4c28da19789b5cbab380d89bbea8b4ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4cvE2vvA1WUTT0IjnnhVw.png"/></div></div></figure><p id="6e1c" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">没看到任何特别的东西！！！！奇怪。因此，当我们查看在线课程和其他资料时，他们总是给我们两种小部件类型:有状态和无状态，创建状态并调用setState()来更新有状态小部件的屏幕，而您不能更新无状态小部件。</p><p id="b694" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">让我们检查setState的代码。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kp"><img src="../Images/c1f0faf6ba7d2bcb7c1a6b5902b77d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2K0v565_IFjIPaXvhUg85A.png"/></div></div></figure><p id="c629" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因此它转到element并调用来自Element类的markNeedsBuild。这表明小部件已经变脏，需要重新构建。</p><h1 id="f89a" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">什么是元素？</h1><p id="0b56" class="pw-post-body-paragraph jk jl hh jm b jn kq jp jq jr kr jt ju jv ks jx jy jz kt kb kc kd ku kf kg kh ha bi translated">元素表示使用小部件来配置树中的特定位置。如果父小部件为这个位置重新构建并创建一个新的小部件，元素可能会改变。元素(可变属性)通过<a class="ae kv" href="https://api.flutter.dev/flutter/widgets/Element-class.html" rel="noopener ugc nofollow" target="_blank"> createElement() </a>方法创建。框架调用<a class="ae kv" href="https://api.flutter.dev/flutter/widgets/Element/mount.html" rel="noopener ugc nofollow" target="_blank"> mount </a>方法将新创建的元素添加到树中给定父节点的给定位置。</p><p id="06ce" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">有关更多信息，请参见本<a class="ae kv" href="https://api.flutter.dev/flutter/widgets/Element-class.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><p id="56d6" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">好的，那为什么我说只有一个小部件呢？等一下什么让我们检查无状态小部件代码</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kw"><img src="../Images/10738967d7023487d80478702112a16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZpMezk5Fa1DRxNwdKqtng.png"/></div></div></figure><p id="7899" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们经常在StatelessWidget中编写build方法，因为它是抽象的，但是什么是StatelessElement呢？</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kx"><img src="../Images/0183ef9bd25f1acf6eb95c7a0a7fc382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ySaWgNLEgapqUf-go-OkFQ.png"/></div></div></figure><p id="5db4" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">并且这个ComponentElement扩展到Element。所以一切都是相关的。</p><p id="368a" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">既然我们在同一个页面上，有状态和无状态小部件使用元素基于脏状态进行呈现和更新。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ky"><img src="../Images/ae8a19b388e7cce599d146da83065727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Px52to3Db2bwrIeYwSeVHw.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx">Stateless Widget can update by calling markNeedsBuild from Element</figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ld"><img src="../Images/ab242737127e5a13e6ab4b21cfef4cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZgkfT3kB9b8fsCH_-cXA4w.png"/></div></div></figure><p id="ae28" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">总而言之，如果我们比较有状态类和无状态类，它们看起来是一样的，那么为什么会有两个不同的东西呢？从我的角度来看，它可以减少开发人员在每次小部件需要数据时创建元素的问题，并对开发人员隐藏markNeedsBuild的真正逻辑。</p><p id="804c" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是！但是！等等，为什么知道这个很好？我们不是开源贡献者，但如果我们理解事情如何工作的本质，我们就可以。这个概念被用在dart Provider包中，我们几乎都用它来进行状态管理。</p><p id="2e5d" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这里我们有ChangeNotifierProvider，它在数据改变时通知重建子部件。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es le"><img src="../Images/307058653c754c29f87196c13fdfd85f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqd9oXF5cWk1folTnRe3qw.png"/></div></div></figure><p id="d294" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">对于ChangeNotifierProvider，它扩展了ListenableProvider类</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lf"><img src="../Images/7f314ed369af72cac9c9833f59ed569d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BuqWIb5-6S9RdcFEvEBr6Q.png"/></div></div></figure><p id="8fa0" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">检查它发送的构造函数start listening inherited Provider，它是提供程序包类。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kw"><img src="../Images/5d185db07cd1f684567af9c72d0e60dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4V57S_JcEUmhYQBkxciMA.png"/></div></div></figure><p id="4e9a" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在_startLitening方法中，我们有<strong class="jm hi">值？。add listener(e . markneedsnotify dependents)；</strong> value是一个LinkedList，存储监听ChangeNotifier变化的监听器。在那个<strong class="jm hi">mark needs notify dependencies</strong>方法中，我们有一个markNeedsBuild，它将被我们传递的子节点调用。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es lg"><img src="../Images/ad750b040f2100d63527f70055ec2d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4OuSlm5QoAfl5s1RVKnvg.png"/></div></div></figure><p id="5c8e" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">现在我们知道了这一点…</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="lh jj l"/></div></figure><p id="18d4" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">有两种不同的小部件类型可以降低复杂性。演示代码链接<a class="ae kv" href="https://emojipedia.org/emoji/%F0%9F%91%87/" rel="noopener ugc nofollow" target="_blank">👇</a></p><div class="li lj ez fb lk ll"><a href="https://github.com/parthdave93/FlutterWidgetMythDemo" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab dw"><div class="ln ab lo cl cj lp"><h2 class="bd hi fi z dy lq ea eb lr ed ef hg bi translated">part hdave 93/FlutterWidgetMythDemo</h2><div class="ls l"><h3 class="bd b fi z dy lq ea eb lr ed ef dx translated">新的颤振应用。这个项目是颤振应用的起点。一些资源让你…</h3></div><div class="lt l"><p class="bd b fp z dy lq ea eb lr ed ef dx translated">github.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz kn ll"/></div></div></a></div><p id="31f8" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">希望你喜欢。</p><p id="f3ef" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">你知道你可以按拍手吗👏按钮50次？你走得越高，就越能激励我写更多的东西！</p><p id="b640" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">你好，我是帕斯·戴夫。noob开发者和noob摄影师。你可以在<a class="ae kv" href="https://in.linkedin.com/in/parth-dave-907b8177" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上找到我，或者在<a class="ae kv" href="https://github.com/parthdave93" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上跟踪我，或者在<a class="ae kv" href="https://twitter.com/the_parth_dave" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我？</p><p id="c55a" class="pw-post-body-paragraph jk jl hh jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">祝你有一个愉快的飞行日！</p></div></div>    
</body>
</html>