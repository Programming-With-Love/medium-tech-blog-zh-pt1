<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://medium.com/walmartglobaltech/openssl-server-reverse-shell-from-windows-client-aee2dbfa0926?source=collection_archive---------4-----------------------#2019-02-22">https://medium.com/walmartglobaltech/openssl-server-reverse-shell-from-windows-client-aee2dbfa0926?source=collection_archive---------4-----------------------#2019-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><p id="1e60" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">OpenSSL服务器从Windows客户端反向外壳</p><p id="21a5" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">凯莉·罗伯茨(<a class="ae ie" href="https://twitter.com/OrOneEqualsOne" rel="noopener ugc nofollow" target="_blank"> @OrOneEqualsOne </a>)</p><p id="2227" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">我喜欢通过<a class="ae ie" href="https://twitter.com/int0x33" rel="noopener ugc nofollow" target="_blank"> @int0x33 </a>学习<a class="ae ie" rel="noopener" href="/@int0x33/day-43-reverse-shell-with-openssl-1ee2574aa998">这个只使用OpenSSL的简单shell </a>。OpenSSL默认安装在大多数Linux和OS X操作系统上，使得这个命令和控制(C2)选项对于这些目标是可行的。但是让我们来看看如何建立从Windows客户端到OpenSSL服务器的C2会话。</p><p id="ed48" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">将此处<a class="ae ie" href="https://stackoverflow.com/questions/19252963/powershell-ssl-socket-client" rel="noopener ugc nofollow" target="_blank">的</a>和此处<a class="ae ie" href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology and Resources/Reverse Shell Cheatsheet.md" rel="noopener ugc nofollow" target="_blank">的</a>的解决方案片段结合起来，我们得到了这个漂亮的解决方案。</p><figure class="if ig ih ii fd ij"><div class="bz dy l di"><div class="ik il l"/></div></figure><p id="19b2" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">请注意，<code class="du im in io ip b">AuthenticateAsClient</code>调用中指定的域将出现在TLS协商的SNI字段中，因此您可能希望将其从<code class="du im in io ip b">fake.domain</code>更改为更可信的名称。在服务器上，按照<a class="ae ie" href="https://twitter.com/int0x33" rel="noopener ugc nofollow" target="_blank"> @int0x33 </a>所述，生成您的证书并启动监听器。</p><figure class="if ig ih ii fd ij"><div class="bz dy l di"><div class="ik il l"/></div></figure><p id="0ac7" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">在受害系统上，打开PowerShell提示符并粘贴上面的代码，将第一行中的IP地址替换为您的服务器的IP地址。</p><figure class="if ig ih ii fd ij er es paragraph-image"><div class="er es iq"><img src="../Images/bdd78d9a26954ee97bd0b531cd0ed6f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*MsEQUM0AFi2DICOmfk7mRg.png"/></div></figure><p id="f53e" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">确保在最后一行代码后按回车键。(您可能必须按一次Enter键才能到达最后一行代码，然后再按一次)</p><p id="168c" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">现在，我们已经建立了一个到运行openssl的服务器的C2会话，带有s_server选项。下图显示了以红色输入的命令及其绿色响应。</p><figure class="if ig ih ii fd ij er es paragraph-image"><div class="er es it"><img src="../Images/90f005e8e3171be108d97095433b9ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*w9UXCJKzbqveF2yE1pSCfA.png"/></div></figure><p id="a5d1" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">这是Wireshark中网络流量的样子。</p><figure class="if ig ih ii fd ij er es paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="er es iu"><img src="../Images/e24988b8cf802dcb947bc8bbb747e783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEbXX0oGe1dJIHi0UvNMeg.png"/></div></div></figure><p id="a2d7" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">要增加绕过基于主机和网络的检测的可能性，请使用以下建议。</p><p id="74c7" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">1)使用端口443(而不是本例中给出的端口9876)。您必须在服务器和客户端上都进行更改。</p><p id="7832" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">2)在您的服务器上使用可信证书，例如由<a class="ae ie" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank"> Let's Encrypt </a>生成的cert.pem和privkey.pem文件，这些文件通常位于/etc/letsencrypt/live/ &lt;您的域&gt; /中。然后用您的域名替换PowerShell脚本中的IP地址。</p><p id="41de" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">3)使用<a class="ae ie" href="https://www.blackhillsinfosec.com/getting-powershell-empire-past-windows-defender/" rel="noopener ugc nofollow" target="_blank">该技术</a>生成一个可执行文件，该文件将使用。Net而不是PowerShell，并且具有内置的脚本块日志记录和AMSI旁路。您只需要通过用分号分隔语句，将PowerShell脚本变成一行。</p><p id="08c0" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">注意:openssl侦听器只能处理一个客户端(运行所有PowerShell的Windows机器)。如果您想第二次连接客户机，您必须重新启动监听器。</p><p id="fc16" class="pw-post-body-paragraph hf hg hh hi b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx hy hz ia ib ic id ha bi translated">有趣的东西。如果你是一个pentest，并正在寻找一个快速的C2连接，这可能会为你做。</p></div></div>    
</body>
</html>