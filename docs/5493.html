<html>
<head>
<title>Finder bot with GraalVM and TensorFlow.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有GraalVM和TensorFlow.js的Finder bot</h1>
<blockquote>原文：<a href="https://medium.com/oracledevs/finder-bot-with-graalvm-and-tensorflow-js-29710c0d21e3?source=collection_archive---------0-----------------------#2018-08-22">https://medium.com/oracledevs/finder-bot-with-graalvm-and-tensorflow-js-29710c0d21e3?source=collection_archive---------0-----------------------#2018-08-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a19e9ff92416a8da6a7edded3ff2fbb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqx2WN3eo0ktnd2m1M3StQ.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx">Photo by <a class="ae it" href="https://unsplash.com/photos/C8VWyZhcIIU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Joseph Chan</a> on <a class="ae it" href="https://unsplash.com/search/photos/bot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c75a" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="96c7" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">在处理文本搜索和文本处理任务时，grep、awk和sed等实用程序是非常强大的命令行工具。话虽如此，我很少使用它们，因为大多数时候我最喜欢的IDE已经为我完成了工作。有时，我会在google上搜索grep、awk和sed命令或它们各自的手册页，以获得正确的命令和选项。我一直在想，我们是否可以利用在<a class="ae it" href="https://en.wikipedia.org/wiki/Natural_language_processing" rel="noopener ugc nofollow" target="_blank"> NLP </a>和<a class="ae it" href="https://en.wikipedia.org/wiki/Natural_language_understanding" rel="noopener ugc nofollow" target="_blank"> NLU </a>中取得的惊人进步，并添加一些机器学习，将这些命令隐藏在命令行机器人(CLB)后面，并通过自然文本处理常见用例。</p><p id="1e3a" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">比如说“给我找出buildpal/ui下所有包含‘Mady’这个词的JavaScript文件”就不错了。这相当于执行以下命令:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="3aac" class="le iv hh la b fi lf lg l lh li">grep --include=\*.js -rnwl buildpal/ui -e "Mady"</span></pre><p id="3571" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">当然，使用工具是个人选择的问题。上面的命令非常简洁，一旦所有选项都正确，它就能很好地完成工作。</p><p id="ff08" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">让我们来谈谈构建finder命令行bot的一些高级方面。CLB应该采用简单的英语表达，如“在foo/bar下查找包含‘world’的文件”，将其转换为命令，执行并返回结果。我们将看看GraalVM和Tensorflow.js如何潜在地用于这个实验。</p><h1 id="d1f0" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">意图分类和实体提取</h1><p id="df68" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">与三年前相比，ML和NLU的当前状态使得意图分类和实体提取变得相对容易。简单来说，意图是用户试图完成的事情，或者是用户查询或陈述背后的意图。在我们的finder CLB领域中，一个意图是“查找”或“搜索”文件。我们训练好的模型的工作是将给定的话语分类成这些特定意图中的一个。</p><p id="b330" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">实体提取是识别携带与意图相关的附加信息的关键字的过程。例如，在话语“在buildpal/ui下为我查找包含‘Mady’的所有JavaScript文件”中，实体可以是文件夹路径“buildpal/ui”、文件类型“JavaScript”和搜索词“Mady”。可以使用正则表达式或通过更复杂的技术(如词性标注或命名实体识别)来提取实体。在开始之前，我们需要对意图进行分类，并训练我们的模型。在后续的文章中，我将介绍模型的设置、训练和验证。同时，请参考这篇伟大的<a class="ae it" rel="noopener" href="/oracledevs/text-classification-with-deep-neural-network-in-tensorflow-simple-explanation-be07c6cbe867">文章</a>。</p><h1 id="5c58" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">GraalVM</h1><p id="b4c4" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">甲骨文最近发布了一款多语言虚拟机<a class="ae it" href="https://www.graalvm.org/" rel="noopener ugc nofollow" target="_blank"> GraalVM </a>，它可以执行用Java、C、Scala、JavaScript和Python等语言编写的程序。我们将看到如何利用它来建立发现者CLB。第一步是安装GraalVM并设置相关的环境变量。已安装的bin目录包含JavaScript和Node.js的附加启动器。如果您已经像我一样安装了Node.js，您可以使用别名指向Graal的版本。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="8c06" class="le iv hh la b fi lf lg l lh li">alias gnode='/path/to/graal/bin/node'<br/>alias gnpm='/path/to/graal/bin/npm'</span></pre><h1 id="4602" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">TensorFlow.js</h1><p id="1b3f" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">如您所知，TensorFlow框架有多种风格。虽然我们可以使用TensorFlow for Java API，但是让我们修补一下JavaScript <a class="ae it" href="https://js.tensorflow.org/" rel="noopener ugc nofollow" target="_blank">版本</a>，看看它如何作为节点包与GraalVM一起工作。</p><p id="9eae" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">首先，用“gnpm init”初始化您的项目。接下来，使用以下命令安装所需的TensorFlow包:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="d48a" class="le iv hh la b fi lf lg l lh li">gnpm install @tensorflow/tfjs<br/>npm install @tensorflow/tfjs-node</span></pre><p id="247a" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">请注意，我无法使用Graal的npm安装本机TensorFlow包。“libtensorflow.so”有问题。因此，作为一种变通方法，我使用了我的系统上可用的常规npm。</p><h1 id="1f4a" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">发现者机器人</h1><p id="dfd6" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">从更高的层面来看，让我们看看如何将不同的部分整合在一起。我们使用TensorFlow对象加载训练好的模型:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="c440" class="le iv hh la b fi lf lg l lh li">const tf = require('<a class="ae it" href="http://twitter.com/tensorflow/tfjs" rel="noopener ugc nofollow" target="_blank">@tensorflow/tfjs</a>');<br/>require('<a class="ae it" href="http://twitter.com/tensorflow/tfjs-node" rel="noopener ugc nofollow" target="_blank">@tensorflow/tfjs-node</a>');</span><span id="8426" class="le iv hh la b fi lj lg l lh li">tf.loadModel('file://clb/model.json').then(model =&gt; {...});</span></pre><p id="e3ea" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">该模型将用于识别用户的意图。</p><p id="7972" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">Java或Node.js都可以用来实现功能的其余部分——从命令行读取用户的句子，使用NIO查找文件，或者如果grep可用，使用process builder执行grep命令。为了混合Java和JavaScript，我们必须向Graal传递额外的标志:</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="196e" class="le iv hh la b fi lf lg l lh li">gnode --polyglot --jvm index.js</span></pre><p id="808e" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">当模型以合理的置信度识别出“查找”意图时(我们可以配置错误阈值)，我们可以继续提取实体。带有正则表达式的简单模式匹配对我们的用例来说很好。完成后，我们继续构建和执行grep命令并读取其输出。如果grep不可用，我们可以选择使用Java或Node.js实现查找功能。</p><h1 id="7715" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结论</h1><p id="2df3" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">这是我们短暂而有趣的实验。我们讨论了构建具有有限NLU功能的命令行机器人的一些方面，该机器人可以将常规的英语句子转换成可执行的命令。</p><p id="f3ef" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">我将以最后一句话结束。对于NLU和服务模型，无论是本地还是远程，肯定有其他成熟的方法——使用您选择的框架和/或通过像<a class="ae it" href="https://oracle.github.io/graphpipe" rel="noopener ugc nofollow" target="_blank"> GraphPipe </a>这样的服务器协议。</p><p id="f316" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">在本文的第2部分，我们将深入探讨意图分类模型。</p></div></div>    
</body>
</html>