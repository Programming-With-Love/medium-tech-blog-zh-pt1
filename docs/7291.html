<html>
<head>
<title>Uncovering Inconsistent Keychain Behavior While Fixing a Valet iOS Bug</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修复代客iOS错误时发现不一致的钥匙串行为</h1>
<blockquote>原文：<a href="https://medium.com/square-corner-blog/uncovering-inconsistent-keychain-behavior-while-fixing-a-valet-ios-bug-7c9beece0aa1?source=collection_archive---------4-----------------------#2018-02-22">https://medium.com/square-corner-blog/uncovering-inconsistent-keychain-behavior-while-fixing-a-valet-ios-bug-7c9beece0aa1?source=collection_archive---------4-----------------------#2018-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="f57a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">几个月前，一名开发人员从他们的iOS应用程序向Square发送了以下错误堆栈跟踪:</p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="jh ji l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Valet error stack trace</figcaption></figure><blockquote class="jn"><p id="c258" class="jo jp hh bd jq jr js jt ju jv jw jb dx translated">注意，我们已经行动了！如果您想继续了解Square的最新技术内容，请访问我们的新家<a class="ae jx" href="https://developer.squareup.com/blog" rel="noopener ugc nofollow" target="_blank">https://developer.squareup.com/blog</a></p></blockquote><p id="4039" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">这导致了一个<a class="ae jx" href="https://github.com/square/Valet" rel="noopener ugc nofollow" target="_blank">代客</a>的补丁，这是Square广受欢迎的开源库，用于管理iOS和macOS的钥匙链。在这个过程中，我们还发现了iOS和macOS上钥匙链行为的微妙但有趣的不一致性。</p><p id="f0f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本帖将涵盖以下内容:</p><ul class=""><li id="c16e" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated">错误的详细情况；</li><li id="7fff" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">iOS钥匙串和代客服务概述；</li><li id="3d7c" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">代客调试和打补丁；和</li><li id="6685" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">我们如何偶然发现iOS和macOS中不同的钥匙串行为，以及造成这种行为的因素。</li></ul><h1 id="f32f" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">错误详细信息</h1><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="9082" class="lu ks hh lq b fi lv lw l lx ly">NSInvalidArgumentException’, reason: ‘-[__NSCFData isEqualToString:]: unrecognized selector sent to instance 0x6080000b97b0</span></pre><p id="2944" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的错误消息表明，<strong class="ig hi"> isEqualToString </strong>(一个<strong class="ig hi"> NSString </strong>方法)正在一个__ <strong class="ig hi"> NSCFData </strong>实例(一个<strong class="ig hi"> NSData </strong>的私有子类，它没有实现<strong class="ig hi"> isEqualToString </strong>)上被调用。</p><p id="67e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">进一步查看堆栈跟踪，不属于苹果<a class="ae jx" href="https://developer.apple.com/documentation/corefoundation" rel="noopener ugc nofollow" target="_blank"> CoreFoundation </a>框架的第一个调用是:</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="a18a" class="lu ks hh lq b fi lv lw l lx ly">-[VALValet migrateObjectsMatchingQuery:removeOnCompletion:]</span></pre><p id="847b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">VALValet是Valet中的一个类，<strong class="ig hi">migrateObjectsMatchingQuery</strong>方法在这里调用<strong class="ig hi"> isEqualToString </strong>一次<a class="ae jx" href="https://github.com/square/Valet/blob/2.2.3/Valet/VALValet.m#L426" rel="noopener ugc nofollow" target="_blank">:</a></p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="jh ji l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Error location in [VALValet migrateObjectsMatchingQuery:removeOnCompletion:]</figcaption></figure><p id="4b1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就在代码调用<strong class="ig hi"> isEqualToString </strong>和崩溃发生之前，从keychain条目中检索的<strong class="ig hi"> kSecAttrAccount </strong>值被存储为<strong class="ig hi"> NSString </strong>:</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="e6d4" class="lu ks hh lq b fi lv lw l lx ly">NSString *const key = keychainEntry[(__bridge id)kSecAttrAccount];</span></pre><p id="18bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，这个异常表明<strong class="ig hi">键</strong>实际上是一个<strong class="ig hi"> NSData </strong>对象。</p><p id="be29" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为什么Valet会假设<strong class="ig hi"> kSecAttrAccount </strong>值是一个字符串？</p><p id="39cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在回答这个问题之前，先回答以下先决问题会有所帮助:</p><ul class=""><li id="9622" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated">iOS钥匙扣是什么？</li><li id="66d0" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">什么是贴身男仆？</li><li id="9d6c" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">Valet的<strong class="ig hi">migrateObjectsMatchingQuery</strong>方法是做什么的？</li></ul><h1 id="ecae" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">iOS钥匙扣是什么？</h1><p id="c8d7" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">如果您已经熟悉iOS钥匙串，请随意跳过这一部分。</p><p id="6cae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在应用程序启动之间保存数据的一种方式是通过<a class="ae jx" href="https://developer.apple.com/documentation/foundation/userdefaults" rel="noopener ugc nofollow" target="_blank"> UserDefaults </a>，这是一个带有简单API的键值存储:</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="ecb8" class="lu ks hh lq b fi lv lw l lx ly">let myUsername = "foo"</span><span id="d8fb" class="lu ks hh lq b fi me lw l lx ly"><strong class="lq hi">// Store value in UserDefaults<br/></strong>UserDefaults.standard.set("bar", forKey: myKey)</span><span id="5c13" class="lu ks hh lq b fi me lw l lx ly"><strong class="lq hi">// Retrieve data<br/></strong>UserDefaults.standard.string(forKey: myKey)</span></pre><p id="7d63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">iOS <a class="ae jx" href="https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/iPhoneTasks/iPhoneTasks.html#//apple_ref/doc/uid/TP30000897-CH208-SW1" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">钥匙链</strong> </a>是另一个持久选项，允许应用程序在设备上的加密SQLite数据库文件中存储敏感数据，如密码。可以通过使用预定义的属性字段(例如，<strong class="ig hi"> kSecAttrAccount </strong>、<strong class="ig hi"> kSecClass </strong>、<strong class="ig hi"> kSecAttrService </strong>)来检索和存储钥匙串条目。</p><h2 id="c39a" class="lu ks hh bd kt mf mg mh kx mi mj mk lb ip ml mm lf it mn mo lj ix mp mq ln mr bi translated">iOS钥匙串和用户默认设置有什么区别？</h2><p id="99be" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">iOS钥匙串是安全的存储(并且有一个难以使用的API)，而UserDefaults则完全不安全(但是有一个易于使用的API)。</p><p id="9806" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">UserDefaults将数据存储在应用程序沙箱内的. plist(属性列表)文件的纯文本中。像<a class="ae jx" href="https://www.ibrowseapp.com/" rel="noopener ugc nofollow" target="_blank"> iBrowse </a>和<a class="ae jx" href="https://macroplant.com/iexplorer" rel="noopener ugc nofollow" target="_blank"> iExplorer </a>这样的实用程序可以很容易地检查设备上的文件，使得UserDefaults只适合存储用户偏好和设置等非敏感数据。</p><p id="6693" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下说明了在iOS钥匙串中创建和获取用户名/密码条目所需的最少代码量:</p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="jh ji l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Storing and fetching iOS keychain entries</figcaption></figure><p id="d522" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不仅钥匙串的使用冗长，而且每个与钥匙串交互的函数(例如，<strong class="ig hi"> SecItem* </strong>)都会返回一组需要检查和处理的错误代码(参见<a class="ae jx" href="https://opensource.apple.com/source/Security/Security-57740.60.18/base/SecBase.h" rel="noopener ugc nofollow" target="_blank"> SecBase.h </a>中的<strong class="ig hi"> OSStatus </strong>)。</p><h1 id="80a0" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">什么是贴身男仆？</h1><p id="3f55" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">处理keychain很复杂，容易出错，并且通常包含大量样板代码。不幸的是，对于任何需要存储帐户信息或敏感数据的应用程序来说，这也是不可避免的。</p><p id="094f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了使钥匙串管理更容易，Square开发了Valet作为iOS和macOS的开源库，将钥匙串的复杂性隐藏在简单的键-值接口下。</p><p id="b9c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过代客在钥匙串中存储和检索用户名/密码类似于用户默认设置:</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="ecb0" class="lu ks hh lq b fi lv lw l lx ly">let myUsername = "my-username"; let myPassword = "my-password"</span><span id="5677" class="lu ks hh lq b fi me lw l lx ly">let valet = VALValet(<br/>    identifier: Bundle.main.bundleIdentifier!, <br/>    accessibility: .whenUnlocked<br/>)</span><span id="4f6a" class="lu ks hh lq b fi me lw l lx ly"><strong class="lq hi">// Store username/password<br/></strong>valet?.setString(myPassword, forKey: myUsername)</span><span id="59c0" class="lu ks hh lq b fi me lw l lx ly"><strong class="lq hi">// Retrieve password by username<br/></strong>valet?.string(forKey: myUsername)</span></pre><p id="86cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们有了更多的上下文，让我们回到我们对开发人员收到的错误的调查。</p><h1 id="afab" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">Valet的migrateObjectsMatchingQuery方法是做什么的？</h1><p id="0f1e" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">如前所述，异常:</p><blockquote class="ms mt mu"><p id="1faa" class="ie if mv ig b ih ii ij ik il im in io mw iq ir is mx iu iv iw my iy iz ja jb ha bi translated">NSInvalidArgumentException[_ _ NSCFData is equaltostring:]:无法识别的选择器</p></blockquote><p id="f88b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">发生在VALValet的<strong class="ig hi">migrateObjectsMatchingQuery</strong>方法中。这个方法是做什么的？</p><p id="f999" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">migrateObjectsMatchingQuery</strong>方法的典型用法如下:</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="6399" class="lu ks hh lq b fi lv lw l lx ly">let valet = VALValet(<br/>    identifier: Bundle.main.bundleIdentifier!, <br/>    accessibility: .whenUnlocked<br/>)</span><span id="2388" class="lu ks hh lq b fi me lw l lx ly">let query: [String: Any] = [<br/>    kSecAttrService as String: Bundle.main.bundleIdentifier as Any,<br/>    kSecClass as String: kSecClassGenericPassword as Any<br/>]</span><span id="2d12" class="lu ks hh lq b fi me lw l lx ly"><strong class="lq hi">valet?.migrateObjects(<br/>    matchingQuery: query, <br/>    removeOnCompletion: true<br/>)</strong></span></pre><p id="42e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">migrateObjectsMatchingQuery:removeOnCompletion:</strong>允许应用程序将现有钥匙串条目的管理转移到代客。如果应用程序在使用Valet之前使用钥匙串来保存数据，此方法会将现有钥匙串条目重新构造为一种格式，允许通过Valet的simpler API更新或获取这些条目。</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="836e" class="lu ks hh lq b fi lv lw l lx ly">let query: [String: Any] = [<br/>    <strong class="lq hi">kSecAttrService</strong> as String: Bundle.main.bundleIdentifier as Any,<br/>    <strong class="lq hi">kSecClass</strong> as String: kSecClassGenericPassword as Any<br/>]</span></pre><p id="e07e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">查询</strong>参数用于选择要迁移到代客的钥匙串条目，并使用标准钥匙串属性字段名称作为过滤标准。</p><p id="b24f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">迁移允许应用程序过渡到代客，而无需强制用户重新输入帐户密码或储存在钥匙串中的其他信息。</p><h1 id="6d7b" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">仔细查看错误发生的位置</h1><p id="2ab3" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">重新访问<strong class="ig hi">migrateObjectsMatchingQuery</strong>中抛出异常的代码块:</p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="jh ji l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">migrateObjectsMatchingQuery: sanity checking Keychain Entries</figcaption></figure><p id="2bbc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在迁移之前，这部分代码负责对作为迁移候选对象的现有钥匙串条目进行完整性检查。例如，要符合条件，现有条目必须具有<strong class="ig hi"> kSecAttrAccount </strong>和<strong class="ig hi"> kSecValueData </strong>值。</p><p id="6f8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">逐行解释:</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="fd4d" class="lu ks hh lq b fi lv lw l lx ly">for (NSDictionary *const keychainEntry in <strong class="lq hi">queryResultWithData</strong>)</span></pre><p id="9d21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> queryResultWithData </strong>是一个数组，包含使用提供给<strong class="ig hi">migrateObjectsMatchingQuery</strong>方法的<strong class="ig hi">查询</strong>搜索钥匙串后返回的条目的数据。</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="2d2e" class="lu ks hh lq b fi lv lw l lx ly"><strong class="lq hi">NSString</strong> *const <strong class="lq hi">key</strong> = keychainEntry[(__bridge id)kSecAttrAccount];</span></pre><p id="f338" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个条目的<strong class="ig hi"> kSecAttrAccount </strong>值存储在<strong class="ig hi"> key </strong>变量中。<strong class="ig hi">注意这里假设值是一个字符串。</strong>编译器允许这样做，因为<strong class="ig hi"> NSDictionary </strong>值是<strong class="ig hi"> id </strong>指针，这允许隐式转换。</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="a227" class="lu ks hh lq b fi lv lw l lx ly">if ([<strong class="lq hi">key isEqualToString:VALCanAccessKeychainCanaryKey]</strong>) { <br/>    // We don't care about this key. Move along.<br/>    continue;<br/>}</span></pre><p id="7d29" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在对每个条目进行完整性检查之前，将<strong class="ig hi">键</strong>与<strong class="ig hi">valcanaccesskeychainkanarykey</strong>进行比较，如果发现匹配，则跳过所有检查。</p><p id="c388" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">valcanaccesskeychainkanarykey</strong>是一个字符串常量，在执行探索性(金丝雀)钥匙串条目插入时，由代客存储在条目的<strong class="ig hi"> kSecAttrAccount </strong>字段中。这些插入验证了在初始化代客实例时指定了正确的钥匙串可访问性。</p><p id="48c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果查询结果包含金丝雀条目，我们希望跳过对该条目的任何健全性检查。金丝雀条目是一种特殊情况，不会导致任何迁移健全性检查失败。</p><p id="4ce6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当<strong class="ig hi">键</strong>(条目的<strong class="ig hi"> kSecAttrAccount </strong>字段中的值)为<strong class="ig hi"> NSString </strong>时，一切正常。然而，这个异常证明了<strong class="ig hi">键</strong>可能是一个<strong class="ig hi"> NSData </strong>对象。</p><p id="34ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">问题是Valet假设一个条目的<strong class="ig hi"> kSecAttrAccount </strong>值将是一个<strong class="ig hi"> NSString </strong>对象:</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="21c4" class="lu ks hh lq b fi lv lw l lx ly"><strong class="lq hi">NSString</strong> *const <strong class="lq hi">key</strong> = keychainEntry[(__bridge id)kSecAttrAccount];</span></pre><h1 id="b174" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">为什么Valet假设kSecAttrAccount值是NSString？</h1><p id="bd9b" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">与SecAttrAccount属性相关联的<a class="ae jx" href="https://developer.apple.com/documentation/security/ksecattraccount" rel="noopener ugc nofollow" target="_blank">钥匙串值的Apple文档提供了以下描述:</a></p><blockquote class="ms mt mu"><p id="c0a6" class="ie if mv ig b ih ii ij ik il im in io mw iq ir is mx iu iv iw my iy iz ja jb ha bi translated">一个键，其值是一个<strong class="ig hi">字符串</strong>，表示该项目的【钥匙串条目的】帐户名。</p></blockquote><p id="380f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由此看来，假设<strong class="ig hi"> kSecAttrAccount </strong>值总是字符串似乎是合理的。</p><p id="bf33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，从这个代客使用的例子:</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="6e35" class="lu ks hh lq b fi lv lw l lx ly">let myUsername = "my-username"; let myPassword = "my-password"</span><span id="1504" class="lu ks hh lq b fi me lw l lx ly">let valet = VALValet(<br/>    identifier: Bundle.main.bundleIdentifier!, <br/>    accessibility: .whenUnlocked<br/>)</span><span id="402d" class="lu ks hh lq b fi me lw l lx ly"><strong class="lq hi">// Store username/password<br/></strong>valet?.setString(myPassword, forKey: myUsername)</span><span id="ad09" class="lu ks hh lq b fi me lw l lx ly"><strong class="lq hi">// Retrieve password by username<br/></strong>valet?.string(forKey: myUsername)</span></pre><p id="3cbf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Valet只接受密钥的字符串参数(在上面的示例中为<strong class="ig hi"> myUsername </strong>)，然后这些参数作为<strong class="ig hi"> kSecAttrAccount </strong>值存储在钥匙串中。</p><p id="8f78" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由Valet创建的任何条目都遵守Apple对<strong class="ig hi"> kSecAttrAccount </strong>值的类型限制。然而，对于现有的钥匙串条目，代客作出有缺陷的假设:</p><ul class=""><li id="43e1" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated">所有开发人员都遵守这些钥匙串类型限制；或者</li><li id="a925" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">框架或操作系统对钥匙串数据实施类型限制。</li></ul><h1 id="03ee" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">重现错误</h1><p id="5d2c" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">然而，开发人员收到的异常表明，有可能将NSData对象存储在钥匙串条目的<strong class="ig hi"> kSecAttrAccount </strong>字段中，这与Apple的文档相矛盾。</p><p id="4c11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的代码片段证明了这一点，并且在尝试迁移keychain条目时抛出了相同的异常。</p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="jh ji l"/></div><figcaption class="jj jk et er es jl jm bd b be z dx">Reproducing the “unrecognized selector” exception</figcaption></figure><h1 id="2f97" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">修复:添加类型检查</h1><p id="7b9b" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">由于不能再假设<strong class="ig hi"> kSecAttrAccount </strong>总是一个字符串，我们需要在字符串比较之前添加一个类型检查，以避免将<strong class="ig hi"> isEqualToString </strong>消息发送给非<strong class="ig hi"> NSString </strong>对象。</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="7728" class="lu ks hh lq b fi lv lw l lx ly">if (<strong class="lq hi">[key isKindOfClass:[NSString class]] &amp;&amp; <br/>    </strong>[key isEqualToString:VALCanAccessKeychainCanaryKey]) {</span><span id="1aba" class="lu ks hh lq b fi me lw l lx ly">    // We don’t care about this key. Move along.<br/>    continue;<br/><strong class="lq hi">}</strong></span></pre><p id="9b28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为代客总是使用<strong class="ig hi"> kSecAttrAccount </strong>字段中的<strong class="ig hi"> NSString </strong>值来创建条目，所以代客金丝雀条目的键将总是一个<strong class="ig hi"> NSString </strong>。因此，添加这种类型检查是一个有效的需求。</p><h1 id="10a2" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">一个无意的发现:macOS和iOS钥匙链的不一致行为</h1><p id="f79e" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">接下来，我们添加了下面的测试来验证我们的更改(代客是在Objective C中编写的):</p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="jh ji l"/></div></figure><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="659b" class="lu ks hh lq b fi lv lw l lx ly">NSString *identifier = @"my_identifier";<br/>NSData *<strong class="lq hi">dataBlob</strong> = [@"foo" dataUsingEncoding:NSUTF8StringEncoding];<br/><br/>NSDictionary *<strong class="lq hi">keychainData</strong> = @{ <br/>    (__bridge id)kSecAttrService : identifier, <br/>    (__bridge id)kSecClass : (__bridge id)kSecClassGenericPassword, <br/><strong class="lq hi">    (__bridge id)kSecAttrAccount : dataBlob,<br/></strong>    (__bridge id)kSecValueData : dataBlob<br/>};</span></pre><p id="9bfa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">测试故意存储<strong class="ig hi">数据块</strong>，它是<strong class="ig hi"> keychainData </strong>的<strong class="ig hi"> kSecAttrAccount </strong>字段中的<strong class="ig hi"> NSData </strong>对象，它被插入到钥匙链中。正如所料，该修复防止了异常被抛出。</p><p id="f20b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有趣的是，最后一个断言通过了iOS目标，但是<strong class="ig hi">在macOS </strong> <strong class="ig hi">环境</strong>中失败(代客可以管理iOS和macOS钥匙链):</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="75ef" class="lu ks hh lq b fi lv lw l lx ly">NSError *error = <br/>    [self.valet migrateObjectsMatchingQuery:query removeOnCompletion:NO];<br/>    <br/><strong class="lq hi">XCTAssertNil(error); // Passes for iOS, fails for macOS</strong></span></pre><p id="7190" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在macOS目标上运行测试导致了一个<strong class="ig hi">VALMigrationErrorKeyInQueryResultInvalid</strong>错误，表明钥匙串条目的<strong class="ig hi"> kSecAttrAccount </strong>值为<strong class="ig hi"> nil </strong>。回想一下，任何作为迁移候选的键都必须在<strong class="ig hi"> kSecAttrAccount </strong>字段中有一个值。</p><p id="85b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果类型不正确，在macOS上插入包含<strong class="ig hi"> kSecAttrAccount </strong>数据对象的条目会导致<strong class="ig hi"> kSecAttrAccount </strong>值无法持久化。另一方面，无论类型是否正确，iOS都会持久保存<strong class="ig hi"> kSecAttrAccount </strong>值。</p><p id="9ddd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在两个操作系统中插入<strong class="ig hi"> keychainData </strong>后检查钥匙串条目，确认<strong class="ig hi"> kSecAttrAccount </strong>数据值成功存储在iOS上，但未存储在macOS上:</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="38cf" class="lu ks hh lq b fi lv lw l lx ly"><strong class="lq hi">macOS:</strong></span><span id="29ec" class="lu ks hh lq b fi me lw l lx ly">(lldb) po keychainEntry<br/>{</span><span id="1f9a" class="lu ks hh lq b fi me lw l lx ly"><strong class="lq hi">    /** MISSING ACCT VALUE !!! **/<br/></strong>    cdat = "2017-08-12 11:37:39 +0000";<br/>    class = genp; // kSecClass<br/>    labl = "Keychain_With_Account_Name_As_NSData";<br/>    mdat = "2017-08-12 11:37:39 +0000";<br/>    svce = "my_identifier"; // kSecAttrService<br/>    "v_Data" = &lt;666f6f&gt;; // kSecValueData<br/>    "v_PersistentRef" = &lt;...&gt;;<br/>}</span><span id="0d1c" class="lu ks hh lq b fi me lw l lx ly"><strong class="lq hi">iOS:<br/><br/></strong>(lldb) po keychainEntry<br/>{<br/>    <strong class="lq hi">/** PERSISTED kSecAttrAccount VALUE !!! **/<br/></strong>    <strong class="lq hi">acct = &lt;666f6f&gt;;</strong><br/>    agrp = "&lt;*&gt;.com.squareup.Valet-iOS-Test-Host-App";<br/>    cdat = "2017-08-12 11:35:45 +0000";<br/>    mdat = "2017-08-12 11:35:45 +0000";<br/>    musr = &lt;&gt;;<br/>    pdmn = ak;<br/>    svce = "my_identifier"; // kSecAttrService<br/>    sync = 0;<br/>    tomb = 0;<br/>    "v_Data" = &lt;666f6f&gt;; // kSecValueData<br/>    "v_PersistentRef" = &lt;67656e70 00000000 00000325&gt;;<br/>}</span></pre><h1 id="a438" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">为什么iOS会持久化kSecAttrAccount值，而macOS不会？</h1><p id="eaf1" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">苹果公司的一名开发人员在一个询问这个问题的帖子上发布了<a class="ae jx" href="https://forums.developer.apple.com/thread/46429" rel="noopener ugc nofollow" target="_blank">这个回复</a>:</p><blockquote class="ms mt mu"><p id="2337" class="ie if mv ig b ih ii ij ik il im in io mw iq ir is mx iu iv iw my iy iz ja jb ha bi translated"><strong class="ig hi">sec item API有两个实现:</strong></p><p id="7aa6" class="ie if mv ig b ih ii ij ik il im in io mw iq ir is mx iu iv iw my iy iz ja jb ha bi translated"><strong class="ig hi"> iOS实现</strong>，也用于OS X上的iCloud钥匙串</p><p id="90a8" class="ie if mv ig b ih ii ij ik il im in io mw iq ir is mx iu iv iw my iy iz ja jb ha bi translated"><strong class="ig hi"> OS X实现</strong>，这是一个兼容垫片，可以过渡到传统的钥匙链</p><p id="7b2f" class="ie if mv ig b ih ii ij ik il im in io mw iq ir is mx iu iv iw my iy iz ja jb ha bi translated">注意两者在达尔文都有。在安全项目中搜索<strong class="ig hi"> SecItemUpdate_ios </strong>和<strong class="ig hi"> SecItemUpdate_osx </strong>，看看这在幕后是如何工作的。</p><p id="9805" class="ie if mv ig b ih ii ij ik il im in io mw iq ir is mx iu iv iw my iy iz ja jb ha bi translated"><strong class="ig hi">iOS实现基于SQLite。如果你熟悉SQLite，你会知道它的核心是无类型的，因此iOS实现必须进行自己的类型转换。这就是为什么该实现在类型方面有些宽容。然而……</strong></p><p id="b0af" class="ie if mv ig b ih ii ij ik il im in io mw iq ir is mx iu iv iw my iy iz ja jb ha bi translated">重要说明:我强烈建议您使用头文件中指定的类型。其他类型也能工作，但那是实现的意外，而不是设计的特性。此外，由于有两个实现，这些事故并不总是排成一行。</p><p id="5d89" class="ie if mv ig b ih ii ij ik il im in io mw iq ir is mx iu iv iw my iy iz ja jb ha bi translated">我意识到这条规则被苹果样本代码的不同部分打破了。</p></blockquote><p id="cb5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简而言之，这两个因素导致了这种行为差异:</p><ul class=""><li id="539e" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated">iOS和macOS的钥匙链不使用相同的数据存储。</li><li id="ee7c" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">两种操作系统的钥匙串实现是不同的。</li></ul><h2 id="cc33" class="lu ks hh bd kt mf mg mh kx mi mj mk lb ip ml mm lf it mn mo lj ix mp mq ln mr bi translated">iOS和macOS使用不同的钥匙串数据存储</h2><p id="bfd5" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">SQLite是支持iOS keychain的数据存储，它使用<strong class="ig hi">类型关联</strong>而不是严格的类型，这意味着SQLite中的列数据类型更多的是一种建议，而不是一种要求。</p><p id="f44c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">来自<a class="ae jx" href="http://sqlite.org/datatype3.html" rel="noopener ugc nofollow" target="_blank"> SQLite文档</a>:</p><blockquote class="ms mt mu"><p id="c8a7" class="ie if mv ig b ih ii ij ik il im in io mw iq ir is mx iu iv iw my iy iz ja jb ha bi translated">任何列仍然可以存储任何类型的数据。只是有些列，如果可以选择的话，会更喜欢使用一个存储类而不是另一个……<strong class="ig hi">具有文本相似性的列使用存储类NULL、TEXT或BLOB </strong>来存储所有数据。</p></blockquote><p id="f8f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这解释了在iOS中观察到的行为，它允许将一个<strong class="ig hi"> NSData </strong>对象存储在<strong class="ig hi"> kSecAttrAccount </strong>列中，即使推荐的数据类型是字符串。</p><h2 id="82e4" class="lu ks hh bd kt mf mg mh kx mi mj mk lb ip ml mm lf it mn mo lj ix mp mq ln mr bi translated">iOS和macOS上不同的钥匙串实现</h2><p id="d70e" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">iOS和macOS都使用<strong class="ig hi"> SecItemUpdate </strong>函数来更新钥匙串条目。它的实现可以在<a class="ae jx" href="https://opensource.apple.com/source/Security/Security-57740.60.18/OSX/libsecurity_keychain/lib/SecItem.cpp.auto.html" rel="noopener ugc nofollow" target="_blank"> SecItem.cpp </a>中找到，它是开源的，是苹果安全框架的一部分:</p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="jh ji l"/></div></figure><p id="12f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从<strong class="ig hi"> can_target_(ios|osx) </strong>布尔值和<strong class="ig hi">secitem update _(IOs | OS x)</strong>函数可以明显看出，每个操作系统的代码路径都是不同的。</p><p id="51da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于感兴趣的读者，<strong class="ig hi"> SecItemUpdate_ios </strong>通过一个预处理宏别名到<a class="ae jx" href="https://opensource.apple.com/source/Security/Security-57740.60.18/OSX/sec/Security/SecItem.c" rel="noopener ugc nofollow" target="_blank"> SecItem.c </a>中的<strong class="ig hi"> SecItemUpdate </strong>函数。<strong class="ig hi"> SecItemUpdate_osx </strong>在<a class="ae jx" href="https://opensource.apple.com/source/Security/Security-57740.60.18/OSX/libsecurity_keychain/lib/SecItem.cpp.auto.html" rel="noopener ugc nofollow" target="_blank"> SecItem.cpp </a>中定义。整个安全框架可以在这里<a class="ae jx" href="https://opensource.apple.com/tarballs/Security/" rel="noopener ugc nofollow" target="_blank">下载。</a></p><h2 id="6432" class="lu ks hh bd kt mf mg mh kx mi mj mk lb ip ml mm lf it mn mo lj ix mp mq ln mr bi translated">钥匙串发现摘要</h2><p id="bb80" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">总结本次调查中我们对钥匙链的了解:</p><ul class=""><li id="1b5e" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated">如果<strong class="ig hi">数据</strong>对象存储在钥匙串条目的<strong class="ig hi"> kSecAttrAccount </strong>字段中，iOS和macOS都不会返回错误。</li><li id="c0bf" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">iOS持久保存<strong class="ig hi"> kSecAttrAccount </strong>值，而不考虑类型，而macOS不这样做。</li><li id="9c6a" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">很明显，macOS keychains保存在类型安全数据库中，或者在macOS codepath中添加了iOS上不存在的类型检查。</li></ul><h1 id="f24a" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">修复测试</h1><p id="6f31" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">回到失败的代客测试，为了说明不同平台之间不同的钥匙串行为，以下:</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="f449" class="lu ks hh lq b fi lv lw l lx ly"><strong class="lq hi">XCTAssertNil(error); // Passes for iOS, fails for macOS</strong></span></pre><p id="2e6d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">需要替换为:</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="7788" class="lu ks hh lq b fi lv lw l lx ly"># if <strong class="lq hi">TARGET_OS_IPHONE</strong><br/>    XCTAssertNil(error);</span><span id="b311" class="lu ks hh lq b fi me lw l lx ly"># elif <strong class="lq hi">TARGET_OS_MAC</strong></span><span id="f2e8" class="lu ks hh lq b fi me lw l lx ly">/**<br/>  iOS allows kSecAttrAccount NSData entries, <br/>  while OSX sets the value to nil for any non-string entry.<br/>  */</span><span id="9b5d" class="lu ks hh lq b fi me lw l lx ly"><strong class="lq hi">    XCTAssertEqual(<br/>        error.code, <br/>        VALMigrationErrorKeyInQueryResultInvalid<br/>    );</strong></span><span id="c8ae" class="lu ks hh lq b fi me lw l lx ly"># else<br/>    [NSException raise:@"UnsupportedOperatingSystem" format:@"Only OSX and iOS are supported"];</span><span id="719d" class="lu ks hh lq b fi me lw l lx ly"># endif</span></pre><p id="82f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了这个改变，测试现在通过了，可以在Github的<a class="ae jx" href="https://github.com/square/Valet/pull/114" rel="noopener ugc nofollow" target="_blank">这里</a>找到最终修复的链接。</p><h1 id="d77d" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">向开发人员传达调查结果</h1><p id="f8d0" class="pw-post-body-paragraph ie if hh ig b ih lz ij ik il ma in io ip mb ir is it mc iv iw ix md iz ja jb ha bi translated">在完成我们的调查后，我们告诉开发人员，崩溃是由于一个<strong class="ig hi"> NSData </strong>对象存储在一个钥匙串条目的<strong class="ig hi"> kSecAttrAccount </strong>属性中。</p><p id="c3fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">他们回应说，他们的应用程序一直存储着<strong class="ig hi"> kSecAttrAccount </strong>字符串值，但使用的是第三方库，该库也存储着包含钥匙链中<strong class="ig hi"> kSecAttrAccount </strong>值的凭证。极有可能此资料库正在插入有问题的钥匙串条目。然而，该库对应用程序的功能至关重要，不能被删除。</p><p id="6d98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通常使用应用程序的主包标识符作为<strong class="ig hi"> kSecAttrService </strong>属性值，它充当钥匙串中的名称空间。开发人员的代码和库很可能在同一个名称空间下存储条目。</p><p id="80c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">开发人员应用程序中用于将钥匙串条目迁移到代客的代码:</p><pre class="jc jd je jf fd lp lq lr ls aw lt bi"><span id="73e9" class="lu ks hh lq b fi lv lw l lx ly">let valet = VALValet(<br/>    identifier: Bundle.main.bundleIdentifier!, <br/>    accessibility: .whenUnlocked<br/>)</span><span id="59d4" class="lu ks hh lq b fi me lw l lx ly"><strong class="lq hi">let query: [String: Any] = [<br/>    kSecAttrService as String!: Bundle.main.bundleIdentifier as Any,   <br/>    kSecClass as String!: kSecClassGenericPassword as Any<br/>]</strong></span><span id="124f" class="lu ks hh lq b fi me lw l lx ly">valet?.migrateObjects(<br/>    matchingQuery: query, <br/>    removeOnCompletion: true<br/>)</span></pre><p id="b02a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的查询返回应用程序捆绑包标识符下存储的所有通用密码，在本例中，它包括一个由第三方库存储的带有<strong class="ig hi"> kSecAttrService </strong>数据对象的条目。</p><p id="b613" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将开发人员的应用程序更新到包含修复程序的Valet版本为他们解决了问题。</p><p id="a297" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我要感谢代客的创造者<strong class="ig hi">埃里克·穆勒</strong>和<strong class="ig hi">丹·费德曼</strong>，他们帮助调试和修复了这个问题。</p></div></div>    
</body>
</html>