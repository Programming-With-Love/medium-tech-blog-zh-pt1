<html>
<head>
<title>App Startup, Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用程序启动，第1部分</h1>
<blockquote>原文：<a href="https://medium.com/androiddevelopers/app-startup-part-1-34f57b65cacd?source=collection_archive---------0-----------------------#2020-12-08">https://medium.com/androiddevelopers/app-startup-part-1-34f57b65cacd?source=collection_archive---------0-----------------------#2020-12-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/b77bb84454c59eca56ab0ea8a8b28bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YfPMlXN1XQk27xuE"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">Illustration by <a class="ae hu" href="https://twitter.com/VPoltrack" rel="noopener ugc nofollow" target="_blank">Virginia Poltrack</a></figcaption></figure><div class=""/><div class=""><h2 id="b1ec" class="pw-subtitle-paragraph iu hw hx bd b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl dx translated">内容提供商和自动初始化</h2></div><p id="ed31" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">最近开始玩<a class="ae hu" href="https://developer.android.com/topic/libraries/app-startup" rel="noopener ugc nofollow" target="_blank"> AndroidX App创业</a>库。几周前，它<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/startup#1.0.0" rel="noopener ugc nofollow" target="_blank">达到了1.0 </a>，所以我认为是时候弄清楚为什么、何时以及如何使用它了。</p><p id="147e" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我意识到的第一件事是，它的名字<em class="ki"> App Startup </em>，可能意味着比它实际拥有的更广泛的功能。该库并不关注一般的创业问题(至少目前是这样)；它特别针对最小化由于内容提供者而自动发生的初始化的影响。</p><p id="297a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">现在也许你和我一样，从来没有想过库是如何初始化的。也许这是因为很多事情都是在幕后发生的。具体来说，您在您的<code class="du kj kk kl km b">build.gradle</code>文件中添加一行，将一个库作为依赖项包含进来，这样就完成了(除了调用该库中的APIs否则您为什么要添加它呢？).</p><p id="070d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">但是许多库不仅仅是等待被调用的方法包；它们通常需要首先进行初始化，这可能需要很长时间。更糟糕的是，特别是在隐藏陷阱方面，这些库通常在启动时加载和初始化，因为它们使用了<a class="ae hu" href="https://developer.android.com/guide/topics/providers/content-providers" rel="noopener ugc nofollow" target="_blank">内容提供者</a>。</p><h1 id="7b1e" class="kn ko hx bd kp kq kr ks kt ku kv kw kx jd ky je kz jg la jh lb jj lc jk ld le bi translated">尽情分享[提供商]</h1><p id="559f" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">内容提供商是Android在应用程序之间共享应用程序数据<em class="ki">的方式。例如，手机上的联系人通过内容提供商共享，允许其他应用程序访问用户的联系人(当然，假设用户授予他们权限)。同样，您可以让其他应用程序访问您的应用程序创建的数据。也许你的应用程序管理着一个甜甜圈评级数据库，这似乎是非常重要的信息，其他应用程序可能需要，呃，经常使用。</em></p><blockquote class="lk"><p id="dca2" class="ll lm hx bd ln lo lp lq lr ls lt kh dx translated">每当使用任何声明内容提供者的应用程序启动时，内容提供者被自动创建和运行</p></blockquote><p id="1ab9" class="pw-post-body-paragraph jm jn hx jo b jp lu iy jr js lv jb ju jv lw jx jy jz lx kb kc kd ly kf kg kh ha bi translated">内容提供者的一个重要的，也许是不明显的问题是，每当使用任何声明内容提供者的应用程序启动时，它们就会自动创建和运行。请注意，不仅用户可以启动应用程序，访问应用程序中服务的系统也可以启动应用程序，或者当作业调度程序启动代表应用程序运行的重复作业时，等等。所有这些都引发了内容提供商的开销和他们产生的工作。当有人请求访问该提供者时，系统需要该功能，因此它在启动时自动运行内容提供者。</p><p id="2f9a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">这个细节对于使用这些库的开发人员来说并不明显，因为它是如何发生的细节隐藏在自动生成的代码中。特别是，您必须查看<a class="ae hu" href="https://developer.android.com/studio/build/manifest-merge" rel="noopener ugc nofollow" target="_blank">合并清单</a>文件，看看这是如何发生的。</p><h1 id="d069" class="kn ko hx bd kp kq kr ks kt ku kv kw kx jd ky je kz jg la jh lb jj lc jk ld le bi translated">明显性</h1><p id="b864" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">我与Android应用程序清单的大部分交互都是单独与为我创建的<code class="du kj kk kl km b">Manifest.xml</code>文件进行的，我编辑该文件以添加附加活动、服务和权限等内容。但是这个清单文件不是给系统的最终文件；它只是提供特定于应用程序的信息作为实际“合并”清单的输入。合并的文件是从您的<code class="du kj kk kl km b">Manifest.xml</code>文件创建的，还有工具获取的其他信息，包括您的应用程序使用的库中的清单。正是在这个最终的合并清单中，我们看到了库内容提供商正在发生什么。</p><p id="0b4d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">我们来看一个具体的例子。并不是所有的库都有内容提供者(尽管这很常见)，所以我们来看一个有内容提供者的库:<a class="ae hu" href="https://developer.android.com/jetpack/androidx/releases/work" rel="noopener ugc nofollow" target="_blank"> WorkManager </a>。为了在我的项目中使用<code class="du kj kk kl km b">WorkManager</code>，我将这个依赖项添加到我的应用程序的<code class="du kj kk kl km b">build.gradle</code>文件中:</p><pre class="lz ma mb mc fd md km me mf aw mg bi"><span id="bd59" class="mh ko hx km b fi mi mj l mk ml">implementation "androidx.work:work-runtime-ktx:2.4.0"</span></pre><p id="949c" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在我同步并构建了应用程序之后，我运行了一些启动计时(稍后会详细介绍)，来比较我在这个变化前后的启动持续时间。我注意到我的应用程序比以前多花了70毫秒的时间来启动……而且这还没有调用<code class="du kj kk kl km b">WorkManager</code>中的任何功能。我所做的只是添加了上面的依赖关系。</p><p id="a3dd" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">额外启动延迟的原因在合并的清单文件中找到，我可以在查看<code class="du kj kk kl km b">Manifest.xml</code>时通过点击Android Studio编辑器窗口左下角的合并清单选项卡来查看:</p><figure class="lz ma mb mc fd hj er es paragraph-image"><div class="er es mm"><img src="../Images/24df942eb2cc009a893753f9a2f5dfc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/0*_gAU32roHMwOUNKF"/></div><figcaption class="hq hr et er es hs ht bd b be z dx">The tabs at the bottom of the editor window for Manifest.xml control whether you are seeing your application manifest file or the final merged manifest</figcaption></figure><p id="134a" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">在这个合并版本的清单中，我看到including <code class="du kj kk kl km b">WorkManager</code>在清单中放入了更多的信息，包括这个提供者块:</p><figure class="lz ma mb mc fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mn"><img src="../Images/c3bec6812fa637992970c5ec30ad748a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KBAWVsGAi5cyv826"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx">This provider was in the merged manifest file after adding WorkManager as a dependency</figcaption></figure><p id="4298" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">出于对这个提供者的好奇，我点击了它的第一行，这方便地将我带到了<code class="du kj kk kl km b">WorkManager</code>的清单文件，其中包含以下内容:</p><pre class="lz ma mb mc fd md km me mf aw mg bi"><span id="89b6" class="mh ko hx km b fi mi mj l mk ml">&lt;application&gt;<br/>    &lt;provider<br/>        android:name="androidx.work.impl.WorkManagerInitializer"<br/>        android:authorities="${applicationId}.workmanager-init"<br/>        android:directBootAware="false"<br/>        android:exported="false"<br/>        android:multiprocess="true"<br/>        tools:targetApi="n" /&gt;<br/>    &lt;!-- ... and a bunch of other stuff ... --&gt;<br/>&lt;/application&gt;</span></pre><p id="0f44" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">所发生的是，合并的清单文件合并了组成应用程序的所有部分的清单文件，包括现在我作为依赖项添加的,<code class="du kj kk kl km b">WorkManager</code>库的清单文件。由于合并后的清单中现在有了一个内容提供者，所以当我的应用程序启动时，系统会自动创建并运行它。</p><p id="139b" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">好了，现在我知道我是如何让库加载并运行内容提供者的了。但是这有什么影响呢？</p><h1 id="46e8" class="kn ko hx bd kp kq kr ks kt ku kv kw kx jd ky je kz jg la jh lb jj lc jk ld le bi translated">测量启动</h1><p id="e4dc" class="pw-post-body-paragraph jm jn hx jo b jp lf iy jr js lg jb ju jv lh jx jy jz li kb kc kd lj kf kg kh ha bi translated">我最近给<a class="ae hu" rel="noopener" href="/androiddevelopers/testing-app-startup-performance-36169c27ee55">发了一篇文章</a>，<a class="ae hu" rel="noopener" href="/androiddevelopers/testing-app-startup-performance-36169c27ee55">测试应用启动性能</a>，详细介绍了如何测量一个应用的启动时间。我用这种方法测量了添加<code class="du kj kk kl km b">WorkManager</code>依赖项前后我的应用程序的启动时间，发现<code class="du kj kk kl km b">WorkManager</code>平均给我的应用程序增加了67毫秒的启动时间。</p><p id="9b9d" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">请注意，正如在<a class="ae hu" rel="noopener" href="/androiddevelopers/testing-app-startup-performance-36169c27ee55">启动测试文章</a>中所述，我锁定了我的Pixel 2时钟，因此这可能比真实用户在该设备上看到的持续时间更长……但可能没有低端设备上的用户体验的时间长。还要注意(正如那篇文章中所描述的)，我可能不需要锁定时钟，因为系统通常在应用程序启动时以最大频率运行时钟。但是为了获得一致的结果，锁定时钟通常是性能测试中的一个好习惯。此外，锁定时钟往往会产生更长的持续时间(从较慢的频率)，这有助于在短时间内减少数据中的噪声。</p><p id="01f9" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">还要注意，这个持续时间不仅仅是由于内容提供商本身。内容提供商创建内容可能需要相当长的时间，但比我看到的67毫秒更接近1-2毫秒。相反，除了创建和运行内容提供者来执行实际初始化库的工作之外，这是库花费在<em class="ki">加载</em>和<em class="ki">初始化</em>的总时间。</p><p id="6393" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">因此，简单地将这个库添加到我的项目中似乎导致了将近70毫秒的启动时间。在一个真正的应用程序中，我可能会使用多个库，许多库在启动时都有自己的内容提供者，这会导致启动时更多的延迟，因为所有的东西都被初始化了。</p><p id="cbe7" class="pw-post-body-paragraph jm jn hx jo b jp jq iy jr js jt jb ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">当然，问题是我是否能做些什么来减轻这种打击。而答案当然是…回来看<a class="ae hu" rel="noopener" href="/androiddevelopers/app-startup-part-2-c431e80d0df">第二部</a>！<em class="ki">(剧透:在</em> <a class="ae hu" rel="noopener" href="/androiddevelopers/app-startup-part-2-c431e80d0df"> <em class="ki"> Part 2 </em> </a> <em class="ki">中，我会讨论如何使用AndroidX App启动库来懒洋洋地加载库)</em>。</p><h1 id="5fa6" class="kn ko hx bd kp kq kr ks kt ku kv kw kx jd ky je kz jg la jh lb jj lc jk ld le bi translated">续接<a class="ae hu" rel="noopener" href="/androiddevelopers/app-startup-part-2-c431e80d0df">第二部分</a></h1></div></div>    
</body>
</html>